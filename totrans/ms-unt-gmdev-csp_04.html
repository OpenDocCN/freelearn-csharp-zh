<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"/>2</h1>
<h1 id="_idParaDest-28" class="calibre5"><a id="_idTextAnchor029" class="calibre6 pcalibre1 pcalibre"/>Writing Clean and Modular C# Code for Unity Game Development</h1>
<p class="calibre3">Welcome to <a href="B22017_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 2</em></a>, where we focus on the importance of clean and modular C# code for Unity game development. In the next pages, you’ll learn practical skills to write clear and efficient code. We’ll cover clean code principles, stress the significance of readability, and introduce industry best practices. You’ll also explore conventions and code structuring for smoother collaboration. Additionally, we’ll delve into refactoring and optimization techniques to enhance your C# code’s performance and scalability. By the end of this chapter, you’ll have the expertise to write, document, refactor, and optimize C# code effectively, laying a solid foundation for successful Unity game development.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre10">
<li class="calibre11">Introduction to writing clean code</li>
<li class="calibre11">C# code conventions and readability</li>
<li class="calibre11">C# code refactoring and optimization techniques</li>
</ul>
<h1 id="_idParaDest-29" class="calibre5"><a id="_idTextAnchor030" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You will need the following to follow along with me in this chapter:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Unity version 2022.3.13</strong>: Download and install Unity version 2022.3.13 or any other version. It is recommended to install the 2022 version.</li>
<li class="calibre11"><strong class="bold">Primary IDE – Visual Studio 2022</strong>: Ensure Visual Studio 2022 is installed for optimal learning.</li>
<li class="calibre11"><strong class="bold">GitHub repository for code samples</strong>: Access the code samples and project files of this chapter from our GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002</a>. Clone or download the repository to have easy access to the code demonstrated in this chapter.</li>
</ul>
<h1 id="_idParaDest-30" class="calibre5"><a id="_idTextAnchor031" class="calibre6 pcalibre1 pcalibre"/>Introduction to writing clean code</h1>
<p class="calibre3">Clean code <a id="_idIndexMarker048" class="calibre6 pcalibre1 pcalibre"/>refers to well-organized, readable, and easy-to-understand code. It’s like writing a clear story that anyone can follow without getting lost in confusing jargon or messy paragraphs.</p>
<p class="calibre3">In software<a id="_idIndexMarker049" class="calibre6 pcalibre1 pcalibre"/> development, clean code matters a lot. First, it makes the code easier for everyone in the team to grasp, helping them work together smoothly. Second, it saves time because clean code is simpler to fix when something goes wrong. Lastly, it’s like having a clean room – it just feels better and is easier to manage in the long run. In this list, we highlight the significance of employing clean code<a id="_idTextAnchor032" class="calibre6 pcalibre1 pcalibre"/>:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Building AAA games</strong>: Have you come across “the power of clean code” on your coding journey? Well, it’s like the secret sauce for cooking up high-quality code, especially when you’re aiming to create top-notch AAA games. Clean code is the key ingredient for building games that stand out in the industry.</li>
<li class="calibre11"><strong class="bold">Working with others</strong>: In the world of coding, we’re never alone. Whether you’re part of a company with high standards or collaborating on a project, the clean code mentality is your silent companion. You might not realize you’re using it, but with a bit of knowledge, you can rock the industry by making your code clear and understandable for everyone on the team.</li>
<li class="calibre11"><strong class="bold">Flexibility in applying clean code</strong>: The goal of this chapter isn’t to force you to use all these clean code principles every single time. Sometimes you need to dive into coding first and then tidy up later. These aren’t strict rules; they’re more like tools you can pull out when needed. If a feature is familiar, and you know how to implement it with principles such as SOLID, go for it. But if you’re unsure, start with the basics and refine your code so you gain a clearer picture of what’s needed.</li>
<li class="calibre11"><strong class="bold">Every coder’s struggle</strong>: Picture this: you’re tired of the endless coding and updates, facing issues as you go. Changing a feature becomes a headache, especially when the code turns into a messy puzzle. Dealing with testers feels like a never-ending loop of modifications. If this sounds familiar, you’re not alone. This chapter is your guide to overcoming the struggles of code maintenance and updates.</li>
<li class="calibre11"><strong class="bold">Code that tells a story</strong>: Ever written a piece of code and then completely forgotten what it was for? It happens to the best of us. This chapter is here to teach you how to write code that tells a story – a story that’s clear and easy to follow and won’t leave you scratching your head later.</li>
<li class="calibre11"><strong class="bold">Modularity and efficiency tips</strong>: Get ready for some tips and tricks on how to make your <a id="_idIndexMarker050" class="calibre6 pcalibre1 pcalibre"/>code modular and efficient. I’ll walk you through general principles and show you how to apply them in real-world scenarios. Plus, we’ll dive into examples – messy code versus clean code – for each clean code principle, giving you a practical understanding of how to implement these ideas in your own projects.</li>
</ul>
<p class="calibre3">Clean code is essential for building better software. By understanding its importance, you’ll be better equipped to write code that’s clear, understandable, and effective. In the next section, we will understand the principles of writing clean code.</p>
<h1 id="_idParaDest-31" class="calibre5"><a id="_idTextAnchor033" class="calibre6 pcalibre1 pcalibre"/>Principles of writing clean code</h1>
<p class="calibre3">In the <a id="_idIndexMarker051" class="calibre6 pcalibre1 pcalibre"/>world of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>), clean<a id="_idIndexMarker052" class="calibre6 pcalibre1 pcalibre"/> code thrives on a foundation of five key principles <a id="_idIndexMarker053" class="calibre6 pcalibre1 pcalibre"/>known as <strong class="bold">SOLID</strong>. These principles act as guiding lights, helping us write code that’s not just functional but also the following:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Easy to read and understand</strong>: Anyone who picks up your code should be able to grasp its purpose and logic without too much effort</li>
<li class="calibre11"><strong class="bold">Maintainable</strong>: Modifications and updates should be a breeze, even for someone unfamiliar with the code’s history</li>
<li class="calibre11"><strong class="bold">Extendable and reusable</strong>: Building on existing code should be straightforward, promoting code reuse and reducing redundancy</li>
</ul>
<p class="calibre3">Let me tell you a story. Before<a id="_idIndexMarker054" class="calibre6 pcalibre1 pcalibre"/> I discovered SOLID principles, I often found myself struggling to figure out how to build features. Reaching the finish line felt like a messy, chaotic journey. Then, SOLID came along and changed everything. It was like a map, helping me organize my thoughts and code into a clear, structured path.</p>
<p class="calibre3">But SOLID wasn’t just a clean code tool; it empowered me to become a better problem solver. It shifted my mindset from a “try hard” approach to a “create solutions” approach. I went from someone who wrestled with code to someone who crafted elegant solutions.</p>
<p class="calibre3">As software developers, our job is to solve problems. SOLID becomes your secret weapon in this battle. It provides the framework to tackle most challenges you’ll encounter.</p>
<p class="calibre3">However, simply reading about SOLID isn’t enough. True learning comes from applying it yourself. Grab your existing code and dive in! Experiment with incorporating SOLID principles and see how they transform your work. Trust me, the hands-on experience will solidify your understanding and unlock a whole new level of development mastery.</p>
<h2 id="_idParaDest-32" class="calibre7"><a id="_idTextAnchor034" class="calibre6 pcalibre1 pcalibre"/>Single Responsibility Principle (SRP)</h2>
<p class="calibre3">Let’s <a id="_idIndexMarker055" class="calibre6 pcalibre1 pcalibre"/>discuss the <strong class="bold">Single Responsibility Principle</strong> (<strong class="bold">SRP</strong>) in the context of game development. The <a id="_idIndexMarker056" class="calibre6 pcalibre1 pcalibre"/>SRP suggests that a class should have only one reason to change, meaning it should only have one responsibility. In the gaming world, this translates to ensuring that each component or class is responsible for a single aspect of the game, making the code base more modular and maintainable.</p>
<p class="calibre3">When we begin coding, it’s common to stuff all the logic into one massive class that takes on many jobs. It gets tricky trying to fix one issue without messing up other things in that class or introducing new logic that ends up making other sections act strangely.</p>
<p class="calibre3">Let’s start with an example of a player controller script that combines various responsibilities and then refactor it to adhere to the SRP.</p>
<p class="calibre3">In the following code block, we can see the old <code>PlayerController</code> class, which has many responsibilities:</p>
<pre class="source-code">
public class PlayerController : MonoBehaviour
{
    private Animator playerAnimator;
    private RigidBody rigidBody;
    private void Start()
    {
        playerAnimator = GetComponent&lt;Animator&gt;();
        rigidBody = GetComponent&lt;RigidBody&gt;();
    }
    private void Update()
    {
        // Logic for handling animations
        playerAnimator.SetBool("IsRunning",playerInput.IsRunning());
        // Logic for handling player input
        if (Input.GetKeyDown(KeyCode.Space))
        {
            rigidBody.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
        }
        // Logic for handling player movement
    }
}</pre> <p class="calibre3">Let’s <a id="_idIndexMarker057" class="calibre6 pcalibre1 pcalibre"/>break down the big class into smaller classes, each with its own set of actions.</p>
<p class="calibre3">In the following<a id="_idIndexMarker058" class="calibre6 pcalibre1 pcalibre"/> code block, we can see the <code>PlayerAnimation</code> class, which is responsible for handling player animations:</p>
<pre class="source-code">
public class PlayerAnimation : MonoBehaviour
{
    private Animator animator;
    private void Start()
    {
        animator = GetComponent&lt;Animator&gt;();
    }
    public void UpdateAnimation(bool isRunning)
    {
        animator.SetBool("IsRunning", isRunning);
    }
}</pre> <p class="calibre3">In the following code block, we can see the <code>PlayerMovement</code> class, which is responsible for handling player movement, and the <code>PlayerInput</code> class, which is responsible for handling player input:</p>
<pre class="source-code">
public class PlayerMovement : MonoBehaviour
{
    public void Move(float horizontalInput)
    {
        // Logic for moving the player based on input
    }
     public void Jump()
    {
        // Logic for jumping the player based on input
    }
}
public class PlayerInput : MonoBehaviour
{
    public float HorizontalInput()
    {
        return Input.GetAxisRaw("Horizontal");
    }
    public bool IsJumping()
    {
        // Logic for determining if the player is jumping
        return Input.GetKeyDown(KeyCode.Space);
    }
    public bool IsRunning()
    {
        // Logic for determining if the player is running
        return Input.GetKey(KeyCode.LeftShift);
    }
}</pre> <p class="calibre3">In the following<a id="_idIndexMarker059" class="calibre6 pcalibre1 pcalibre"/> code block, we can see<a id="_idIndexMarker060" class="calibre6 pcalibre1 pcalibre"/> the <code>PlayerController</code> class acting as the orchestrator, delegating responsibilities:</p>
<pre class="source-code">
public class PlayerController : MonoBehaviour
{
    private PlayerAnimation playerAnimation;
    private PlayerInput playerInput;
    private PlayerMovement playerMovement;
    private void Start()
    {
        playerAnimation = GetComponent&lt;PlayerAnimation&gt;();
        playerInput = GetComponent&lt;PlayerInput&gt;();
        playerMovement = GetComponent&lt;PlayerMovement&gt;();
    }
    private void Update()
    {
        playerMovement.Move(playerInput.HorizontalInput());
        if (playerAnimation != null)
        {
            playerAnimation.UpdateAnimation(playerInput.IsRunning());
        }
        if (playerInput.IsJumping())
        {
            playerMovement.Jump();
        }
    }
}</pre> <p class="calibre3">In this <a id="_idIndexMarker061" class="calibre6 pcalibre1 pcalibre"/>simplified version of the <code>PlayerController</code> class, we have separate classes for movement, input handling, and <a id="_idIndexMarker062" class="calibre6 pcalibre1 pcalibre"/>animations, making <code>PlayerController</code> more focused and adhering to the SRP. Each class handles its specific responsibility, enhancing code organization and clarity.</p>
<h2 id="_idParaDest-33" class="calibre7"><a id="_idTextAnchor035" class="calibre6 pcalibre1 pcalibre"/>Open-Closed Principle (OCP)</h2>
<p class="calibre3">Let’s <a id="_idIndexMarker063" class="calibre6 pcalibre1 pcalibre"/>explore the <strong class="bold">Open-Closed Principle</strong> (<strong class="bold">OCP</strong>) in the context of game development. The OCP promotes the idea that a class should be <a id="_idIndexMarker064" class="calibre6 pcalibre1 pcalibre"/>open for extension while remaining closed for modification. In the context of game development, this implies the ability to introduce new features or functionalities without making changes to the existing code. This principle plays a crucial role in enhancing code flexibility and maintainability, allowing for the seamless addition of new elements to the game without disrupting the established framework.</p>
<p class="calibre3">An example of the <em class="italic">power-up dilemma</em> is as follows.</p>
<p class="calibre3">Imagine you have a basic power-up system in your game that grants bonus points. Using the OCP, you can create a base <code>PowerUp</code> class with common functionalities such as activation and duration. Then, you can create subclasses for different specific power-ups, such as double jump or temporary invincibility.</p>
<p class="calibre3">This way, adding a new power-up involves creating a new subclass without modifying the existing code. You’re not stuck with a rigid system – the possibilities are endless!</p>
<p class="calibre3">OCP allows you to <a id="_idIndexMarker065" class="calibre6 pcalibre1 pcalibre"/>build games that are flexible, adaptable, and maintainable. It’s like having a well-designed construction set, letting you create and expand your game world without limits.</p>
<p class="calibre3">In the following <a id="_idIndexMarker066" class="calibre6 pcalibre1 pcalibre"/>code block, we can see the base <code>PowerUp</code> class with common functionalities:</p>
<pre class="source-code">
public abstract class PowerUp
{
    public abstract void Activate(); // Common activation logic
    public abstract void Deactivate(); // Common deactivation logic
}</pre> <p class="calibre3">In the following code block, we can see the subclass for <code>DoubleJumpPowerUp</code>:</p>
<pre class="source-code">
public class DoubleJumpPowerUp : PowerUp
{
    public override void Activate()
    {
        // Specific activation logic for double jump
    }
    public override void Deactivate()
    {
        // Specific deactivation logic for double jump
    }
}</pre> <p class="calibre3">In the following code block, we can see the subclass for <code>TemporaryInvincibilityPowerUp</code>:</p>
<pre class="source-code">
public class TemporaryInvincibilityPowerUp : PowerUp
{
    public override void Activate()
    {
        // Specific activation logic for temporary invincibility
    }
    public override void Deactivate()
    {
        // Specific deactivation logic for temporary invincibility
    }
}</pre> <p class="calibre3">In <a id="_idIndexMarker067" class="calibre6 pcalibre1 pcalibre"/>the <a id="_idIndexMarker068" class="calibre6 pcalibre1 pcalibre"/>following code block, we can see the <code>PowerUpManager</code> class utilizing the power-ups:</p>
<pre class="source-code">
public class PowerUpManager : MonoBehaviour
{
    private void Start()
    {
        // Example of using the power-up system
        PowerUp doubleJump = new DoubleJumpPowerUp();
        AddPowerUp(doubleJump);
        PowerUp invincibility = new TemporaryInvincibilityPowerUp();
        AddPowerUp(invincibility);
    }
    private void AddPowerUp(PowerUp powerUp)
    {
        powerUp.Activate();
        // Logic for adding power-up to the game
    }
    private void RemovePowerUp(PowerUp powerUp)
    {
        powerUp.Deactivate();
        // Logic for removing power-up from the game
    }
}</pre> <p class="calibre3">In this <a id="_idIndexMarker069" class="calibre6 pcalibre1 pcalibre"/>Unity example, the <code>PowerUp</code> class is extended with specific power-ups, such as <code>DoubleJumpPowerUp</code> and <code>TemporaryInvincibilityPowerUp</code>. The <code>PowerUp</code><strong class="source-inline">
Manager</strong> class demonstrates how to add and remove power-ups, and each power-up logs a message upon activation and deactivation. This structure allows for the addition of new power-ups without modifying the existing code, following the OCP.</p>
<p class="calibre3">Now, the<a id="_idIndexMarker070" class="calibre6 pcalibre1 pcalibre"/> fun part begins! We can use this system to connect each power-up subclass to its own prefab. When the player grabs a power-up, only the specific power-up associated with that prefab activates. This means adding new power-ups is a breeze – just create a new subclass and its prefab and voilà! You’ve expanded your game’s possibilities without touching the core logic. This principle isn’t just for power-ups, though. You can use it for enemies, items, abilities – the sky’s the limit! So, go forth and build your awesome game with the power of the OCP!</p>
<h2 id="_idParaDest-34" class="calibre7"><a id="_idTextAnchor036" class="calibre6 pcalibre1 pcalibre"/>Liskov Substitution Principle (LSP)</h2>
<p class="calibre3">Let’s <a id="_idIndexMarker071" class="calibre6 pcalibre1 pcalibre"/>explore the <strong class="bold">Liskov Substitution Principle</strong> (<strong class="bold">LSP</strong>) within the realm of game development. The LSP<a id="_idIndexMarker072" class="calibre6 pcalibre1 pcalibre"/> maintains that substituting objects of a superclass with objects of a subclass should not disrupt the program’s correctness. In the context of game development, this implies that using derived classes (subclasses) should seamlessly integrate without compromising the expected functionality of the base class. This principle ensures the smooth interchangeability of classes, allowing for flexibility and ease of use in game development scenarios.</p>
<p class="calibre3"> An example of the <em class="italic">sneaky enemy dilemma</em> is as follows.</p>
<p class="calibre3">Imagine you have a base class called <code>Enemy</code> with basic movement and attack behaviors. You then create two subclasses: <code>GroundEnemy</code> and <code>FlyingEnemy</code>. The LSP ensures that both subclasses behave as expected enemies, moving and attacking in ways that comply with the <code>Enemy</code> base class’s definition. This means that any code designed to work with enemies, such as collision detection or damage calculation, will work seamlessly with both <code>GroundEnemy</code> and <code>FlyingEnemy</code> instances. This consistency simplifies development and allows you to focus on creating unique behaviors for each subclass without worrying about breaking core functionalities.</p>
<p class="calibre3">In the following code block, we can see the base class for <code>Enemy</code>:</p>
<pre class="source-code">
public class Enemy : MonoBehaviour
{
    public virtual void Move()
    {// Basic movement logic for all enemies
    }
    public virtual void Attack()
    {// Basic attack logic for all enemies
    }
}</pre> <p class="calibre3">In the following code block, we can see the subclass for <code>GroundEnemy</code>:</p>
<pre class="source-code">
public class GroundEnemy : Enemy
{
    public override void Move()
    {// Specific movement logic for ground enemies
    }
    public override void Attack()
    {// Specific attack logic for ground enemies
    }
}</pre> <p class="calibre3">In the <a id="_idIndexMarker073" class="calibre6 pcalibre1 pcalibre"/>following code block, we can see the <a id="_idIndexMarker074" class="calibre6 pcalibre1 pcalibre"/>subclass for <code>FlyingEnemy</code>:</p>
<pre class="source-code">
public class FlyingEnemy : Enemy
{
    public override void Move()
    {// Specific movement logic for flying enemies
    }
    public override void Attack()
    {// Specific attack logic for flying enemies
    }
}</pre> <p class="calibre3">In the following code block, we can see the <code>EnemyManager</code> class demonstrating the LSP:</p>
<pre class="source-code">
public class EnemyManager : MonoBehaviour
{
    void Start()
    {
        // Creating instances of GroundEnemy and FlyingEnemy
        Enemy groundEnemy = new GroundEnemy();
        Enemy flyingEnemy = new FlyingEnemy();
        // Using LSP, treating both enemies as base class
        groundEnemy.Move();
        groundEnemy.Attack();
        flyingEnemy.Move();
        flyingEnemy.Attack();
    }
}</pre> <p class="calibre3">In this <a id="_idIndexMarker075" class="calibre6 pcalibre1 pcalibre"/>Unity example, the <code>Enemy</code> class <a id="_idIndexMarker076" class="calibre6 pcalibre1 pcalibre"/>acts as the base class with basic movement and attack methods. The <code>GroundEnemy</code> and <code>FlyingEnemy</code> subclasses extend the base class and provide specific implementations for movement and attack. The <code>EnemyManager</code> class demonstrates the LSP by treating instances of both subclasses as instances of the base class, ensuring that code written to work with enemies functions seamlessly with both <code>GroundEnemy</code> and <code>FlyingEnemy</code> instances.</p>
<h2 id="_idParaDest-35" class="calibre7"><a id="_idTextAnchor037" class="calibre6 pcalibre1 pcalibre"/>What is the difference between the LSP and OCP?</h2>
<p class="calibre3">In game <a id="_idIndexMarker077" class="calibre6 pcalibre1 pcalibre"/>development, the key difference between the LSP and OCP lies in their focus and application.</p>
<p class="calibre3">The LSP <a id="_idIndexMarker078" class="calibre6 pcalibre1 pcalibre"/>ensures that derived classes can be seamlessly substituted for their base class without affecting program behavior. In a game, this means different types of enemies (e.g., ground and flying enemies) should be interchangeable without breaking the expected functionality.</p>
<p class="calibre3">The OCP encourages designing classes that are open for extension but closed for modification. In game development, this allows adding new features (e.g., new types of weapons) without altering existing code, promoting flexibility and maintainability.</p>
<p class="calibre3">To better illustrate their difference, here’s an example. In a game system, consider a base class for weapons. Adhering to the LSP allows substituting specific weapon types without disrupting expected behaviors, while following the OCP enables extending the system to add new weapons without modifying existing code.</p>
<h2 id="_idParaDest-36" class="calibre7"><a id="_idTextAnchor038" class="calibre6 pcalibre1 pcalibre"/>Interface Segregation Principle (ISP)</h2>
<p class="calibre3">Now, let’s talk about <a id="_idIndexMarker079" class="calibre6 pcalibre1 pcalibre"/>the <strong class="bold">Interface Segregation Principle</strong> (<strong class="bold">ISP</strong>) in the gaming world. The ISP suggests that a class shouldn’t be required to do things it doesn’t need to. Simply put, it encourages creating <a id="_idIndexMarker080" class="calibre6 pcalibre1 pcalibre"/>small, task-specific interfaces instead of big, general ones. In the context of game development, this means designing interfaces that suit each class’s specific needs. This helps keep things clear, makes the code more focused, and allows for easier upkeep and changes in game development.</p>
<p class="calibre3">Let’s see an example of the NPC interfaces dilemma.</p>
<p class="calibre3">Imagine you have NPCs in your game, each with various functionalities, such as wandering, talking, and trading. Applying the ISP ensures that each NPC only needs to implement interfaces relevant to its specific behaviors, avoiding unnecessary methods.</p>
<p class="calibre3"><em class="italic">Without the ISP</em>, in the following code block, we can see the <code>INPC</code> interface, which has general methods for all NPCs, with the <code>FriendlyNPC</code> and <code>AggressiveNPC</code> classes, which implement <code>INPC</code>:</p>
<pre class="source-code">
public interface INPC
{
    void Wander();
    void Talk();
    void Trade();
}
public class FriendlyNPC : INPC
{
    public void Wander() { /* Implementation */ }
    public void Talk() { /* Implementation */ }
    public void Trade() { /* Implementation */ }
}
public class AggressiveNPC : INPC
{
    // Unnecessary implementations for Wander and Trade
    public void Wander() { /* Unnecessary Implementation */ }
    public void Talk() { /* Implementation */ }
    public void Trade() { /* Unnecessary Implementation */ }
}</pre> <p class="calibre3"><em class="italic">With the ISP</em>, in the<a id="_idIndexMarker081" class="calibre6 pcalibre1 pcalibre"/> following code block, we will separate interfaces based on functionality, with the <code>FriendlyNPC</code> and <code>AggressiveNPC</code> classes, which implement <a id="_idIndexMarker082" class="calibre6 pcalibre1 pcalibre"/>relevant interfaces:</p>
<pre class="source-code">
public interface IWanderable
{
    void Wander();
}
public interface ITalkable
{
    void Talk();
}
public interface ITradable
{
    void Trade();
}
public class FriendlyNPC : IWanderable, ITalkable, ITradable
{
    public void Wander() { /* Implementation */ }
    public void Talk() { /* Implementation */ }
    public void Trade() { /* Implementation */ }
}
public class AggressiveNPC : ITalkable
{
    public void Talk() { /* Implementation */ }
}</pre> <p class="calibre3">In this <a id="_idIndexMarker083" class="calibre6 pcalibre1 pcalibre"/>adapted example, applying the ISP leads to separate interfaces for distinct NPC functionalities. Each NPC type (friendly or aggressive) can<a id="_idIndexMarker084" class="calibre6 pcalibre1 pcalibre"/> now implement only the interfaces relevant to its behavior, avoiding the implementation of unnecessary methods. This makes the system more modular and adaptable as different NPC types can adhere to their specific interfaces without being burdened by irrelevant methods.</p>
<h2 id="_idParaDest-37" class="calibre7"><a id="_idTextAnchor039" class="calibre6 pcalibre1 pcalibre"/>Dependency Inversion Principle (DIP)</h2>
<p class="calibre3">Let’s <a id="_idIndexMarker085" class="calibre6 pcalibre1 pcalibre"/>discuss the <strong class="bold">Dependency Inversion Principle</strong> (<strong class="bold">DIP</strong>) in the context of game development. The DIP suggests<a id="_idIndexMarker086" class="calibre6 pcalibre1 pcalibre"/> that high-level modules (e.g., game logic) should not depend on low-level modules (e.g., specific implementations), but both should depend on abstractions (e.g., interfaces or abstract classes). Additionally, it promotes that details should depend on abstractions, not the other way around.</p>
<p class="calibre3">Let us see an example of the weapon manager dilemma.</p>
<p class="calibre3">Consider a game where the <code>WeaponManager</code> is responsible for handling different types of weapons wielded by the player. Without adhering to the DIP, the <code>WeaponManager</code> might directly instantiate and manage specific weapon classes, such as pistols and rifles. However, applying the DIP transforms the scenario. Now, the <code>WeaponManager</code> relies on an abstraction, say <code>IWeapon</code>, representing the common functionalities of all weapons.</p>
<p class="calibre3">In the following code block, we can see the high-level module and also the low-level modules <em class="italic">without </em><em class="italic">the DIP</em>:</p>
<pre class="source-code">
public class WeaponManager
{
    private Pistol pistol;
    private Rifle rifle;
    public WeaponManager()
    {
        pistol = new Pistol();
        rifle = new Rifle();
    }
    public void UseWeapons()
    {
        pistol.Fire();
        rifle.Fire();
    }
}
public class Pistol
{
    public void Fire() { /* Implementation */ }
}
public class Rifle
{
    public void Fire() { /* Implementation */ }
}</pre> <p class="calibre3"><em class="italic">With the DIP</em>, in the <a id="_idIndexMarker087" class="calibre6 pcalibre1 pcalibre"/>following code block, we can see the high-level module and low-level modules<a id="_idIndexMarker088" class="calibre6 pcalibre1 pcalibre"/> implementing the abstraction:</p>
<pre class="source-code">
public interface IWeapon
{
    void Fire();
}
public class WeaponManager
{
    private readonly List&lt;IWeapon&gt; weapons;
    public WeaponManager(List&lt;IWeapon&gt; weapons)
    {
        this.weapons = weapons;
    }
    public void UseWeapons()
    {
        foreach (var weapon in weapons)
        {
            weapon.Fire();
        }
    }
}
public class Pistol : IWeapon
{
    public void Fire() { /* Implementation */ }
}
public class Rifle : IWeapon
{
    public void Fire() { /* Implementation */ }
}</pre> <p class="calibre3">In this <a id="_idIndexMarker089" class="calibre6 pcalibre1 pcalibre"/>example, applying the DIP allows <code>WeaponManager</code> to depend on the abstraction (<code>IWeapon</code>), enabling easy extension with new weapon types without modifying the high-level module. This flexibility is crucial in game development, where new features and components may be added over time without disrupting existing code.</p>
<p class="calibre3">Implementing <a id="_idIndexMarker090" class="calibre6 pcalibre1 pcalibre"/>the SOLID principles in Unity is instrumental in achieving modular C# code, a crucial aspect of effective software design. Modularity, which involves breaking down a system into self-contained components, is facilitated by the SOLID principles, making the code not only easy to understand, maintain, and test but also adherent to the LSP.</p>
<p class="calibre3">Modularity’s significance lies in its ability to enhance code organization. Applying the SRP ensures that each module has a single responsibility, fostering a focused and modular code base. The OCP supports extending code without changing existing modules, allowing the seamless addition of new features. The LSP ensures that derived classes can substitute their base classes without affecting program behavior, promoting consistency and predictability in Unity code.</p>
<p class="calibre3">In Unity development, effective code organization involves using namespaces and classes thoughtfully. The ISP tailors interfaces to specific functionalities, promoting a concise and modular design. <strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>), advocated by the DIP, creates loosely <a id="_idIndexMarker091" class="calibre6 pcalibre1 pcalibre"/>coupled modules, enhancing adaptability. In summary, the SOLID principles, including the LSP, guide the creation of modular and flexible C# code in Unity, ensuring a robust, maintainable, and consistent code base. In the following section, we’ll explore design patterns in game development and learn how to implement them effectively in our code base.</p>
<h1 id="_idParaDest-38" class="calibre5"><a id="_idTextAnchor040" class="calibre6 pcalibre1 pcalibre"/>Understanding design patterns in game development</h1>
<p class="calibre3">Design patterns are <a id="_idIndexMarker092" class="calibre6 pcalibre1 pcalibre"/>proven solutions to common problems encountered in software development. In game development, they provide valuable tools for building robust, maintainable, and efficient games. The following section has an overview of design patterns and their types.</p>
<p class="calibre3">There are many design patterns, each applicable to specific situations. Here are some common types encountered in game development.</p>
<h2 id="_idParaDest-39" class="calibre7"><a id="_idTextAnchor041" class="calibre6 pcalibre1 pcalibre"/>Creational patterns</h2>
<p class="calibre3">Creational patterns<a id="_idIndexMarker093" class="calibre6 pcalibre1 pcalibre"/> are design patterns that provide <a id="_idIndexMarker094" class="calibre6 pcalibre1 pcalibre"/>structured approaches to object creation, ensuring flexibility and reusability while maintaining a clear separation between object creation and usage code. Here are some of these patterns:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Singleton</strong>: Ensures<a id="_idIndexMarker095" class="calibre6 pcalibre1 pcalibre"/> only one instance of a class exists throughout the game. Useful for global objects such as game managers or audio players.</li>
<li class="calibre11"><strong class="bold">Factory Method</strong>: Creates <a id="_idIndexMarker096" class="calibre6 pcalibre1 pcalibre"/>objects without specifying the exact class, promoting flexibility and code reuse.</li>
<li class="calibre11"><strong class="bold">Object Pool</strong>: Pre-allocates <a id="_idIndexMarker097" class="calibre6 pcalibre1 pcalibre"/>and reuses objects to improve performance, especially for frequently created objects such as projectiles or enemies.</li>
</ul>
<h2 id="_idParaDest-40" class="calibre7"><a id="_idTextAnchor042" class="calibre6 pcalibre1 pcalibre"/>Structural patterns</h2>
<p class="calibre3">Structural patterns <a id="_idIndexMarker098" class="calibre6 pcalibre1 pcalibre"/>focus on organizing classes and <a id="_idIndexMarker099" class="calibre6 pcalibre1 pcalibre"/>objects to form larger structures, enabling better composition and flexibility in managing complex relationships between entities within a system. Here are some of these patterns:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Flyweight</strong>: Makes <a id="_idIndexMarker100" class="calibre6 pcalibre1 pcalibre"/>incompatible interfaces work together by translating calls between them. Useful for integrating external libraries or custom code.</li>
<li class="calibre11"><strong class="bold">Decorator</strong>: Adds <a id="_idIndexMarker101" class="calibre6 pcalibre1 pcalibre"/>functionality to an object dynamically without subclassing it, promoting flexible object behavior.</li>
</ul>
<h2 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor043" class="calibre6 pcalibre1 pcalibre"/>Behavioral patterns</h2>
<p class="calibre3">Behavioral patterns <a id="_idIndexMarker102" class="calibre6 pcalibre1 pcalibre"/>address communication and interaction<a id="_idIndexMarker103" class="calibre6 pcalibre1 pcalibre"/> between objects in a system, focusing on how objects collaborate and distribute responsibilities to achieve desired behaviors and functionalities. These patterns help manage algorithms, relationships, and responsibilities among objects to promote flexibility and extensibility in software design. Here are some of these patterns:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Observer</strong>: Allows <a id="_idIndexMarker104" class="calibre6 pcalibre1 pcalibre"/>objects to subscribe to and be notified about changes in other objects, facilitating communication and event handling.</li>
<li class="calibre11"><strong class="bold">Strategy</strong>: Defines<a id="_idIndexMarker105" class="calibre6 pcalibre1 pcalibre"/> a family of algorithms and encapsulates them to allow switching between them at runtime. Useful for handling different player actions or enemy behaviors.</li>
<li class="calibre11"><strong class="bold">State</strong>: Encapsulates <a id="_idIndexMarker106" class="calibre6 pcalibre1 pcalibre"/>the behavior of an object based on its internal state, allowing for state-dependent behavior changes. Useful for handling character states such as walking, jumping, or attacking.</li>
</ul>
<p class="calibre3">In the next few sections, we are going to talk about one design pattern from each type.</p>
<h3 class="calibre9">Singleton design pattern</h3>
<p class="calibre3">The<a id="_idIndexMarker107" class="calibre6 pcalibre1 pcalibre"/> Singleton pattern ensures that a class <a id="_idIndexMarker108" class="calibre6 pcalibre1 pcalibre"/>has only one instance and provides a global point of access to that instance throughout the application. <em class="italic">Figure 2</em><em class="italic">.1</em> illustrates the Singleton structure:</p>
<div><div><img alt="Figure 2.1 – Singleton design pattern structure" src="img/B22017_02_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Singleton design pattern structure</p>
<p class="calibre3">In the <a id="_idIndexMarker109" class="calibre6 pcalibre1 pcalibre"/>following code block, you can see an<a id="_idIndexMarker110" class="calibre6 pcalibre1 pcalibre"/> implementation example of Singleton in Unity:</p>
<pre class="source-code">
public class GameManager : MonoBehaviour
{
    // Static reference to the instance
    private static GameManager _instance;
    // Public property to access the instance
    public static GameManager Instance
    {
        get
        {
            if (_instance == null)
            {
                // If the instance is null, create a new instance
                _instance = new GameObject("GameManager").AddComponent&lt;GameManager&gt;();
            }
            return _instance;
        }
    }
    // Other GameManager properties and methods
    public void StartGame()
    {
        Debug.Log("Game Started!");
    }
}</pre> <p class="calibre3">In the<a id="_idIndexMarker111" class="calibre6 pcalibre1 pcalibre"/> following<a id="_idIndexMarker112" class="calibre6 pcalibre1 pcalibre"/> code block, we can see a usage example for the Singleton pattern:</p>
<pre class="source-code">
public class PlayerController : MonoBehaviour
{
    private void Start()
    {
        // Accessing the GameManager instance
        GameManager.Instance.StartGame();
    }
}</pre> <p class="calibre3">In this example, <code>GameManager</code> is a Singleton responsible for managing the game state. The <code>PlayerController</code> class accesses the single instance to start the game. While Singletons<a id="_idIndexMarker113" class="calibre6 pcalibre1 pcalibre"/> offers global access and lazy initialization benefits, developers should carefully consider the potential drawbacks, especially in larger projects.</p>
<p class="calibre3">The following are some<a id="_idIndexMarker114" class="calibre6 pcalibre1 pcalibre"/> of the pros of using the Singleton pattern:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Global access</strong>: Provides a single, globally accessible point to manage and control a specific aspect of the game, such as game state or settings</li>
<li class="calibre11"><strong class="bold">Lazy initialization</strong>: The instance is created only when it is first needed, saving resources until it’s required</li>
<li class="calibre11"><strong class="bold">Easy to implement</strong>: The Singleton pattern is straightforward to implement and widely recognized, making it easy for developers to understand and use</li>
</ul>
<p class="calibre3">The following<a id="_idIndexMarker115" class="calibre6 pcalibre1 pcalibre"/> are some of the cons of using the Singleton pattern:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Global state</strong>: Singletons introduce a global state, and excessive use can lead to tight coupling and a global state that is challenging to manage</li>
<li class="calibre11"><strong class="bold">Potential for misuse</strong>: Developers might overuse Singletons, leading to a proliferation of global instances, diminishing the benefits of encapsulation</li>
<li class="calibre11"><strong class="bold">Difficult to test</strong>: Testing code that depends on Singletons can be challenging, as the global state may impact the results of unit tests</li>
</ul>
<p class="calibre3">There is a principle, though, that exists to solve the singleton problem, and it’s called dependency injection.</p>
<p class="calibre3">DI is a design pattern that addresses the concerns associated with tight coupling and global state by <a id="_idIndexMarker116" class="calibre6 pcalibre1 pcalibre"/>providing objects with their dependencies rather than letting them create those dependencies. In Unity, this is often achieved through constructor injection or property injection.</p>
<p class="calibre3">The <a id="_idIndexMarker117" class="calibre6 pcalibre1 pcalibre"/>following are the benefits of DI:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Reduced coupling</strong>: By injecting dependencies, classes become less dependent on specific implementations, reducing tight coupling</li>
<li class="calibre11"><strong class="bold">Testability</strong>: Classes with injected dependencies are often easier to test because you can provide mock or test implementations for those dependencies</li>
<li class="calibre11"><strong class="bold">Flexibility</strong>: Different implementations of a dependency can be injected, enabling easy swapping of components without modifying existing code</li>
</ul>
<p class="calibre3">DI can help mitigate some of the issues associated with the Singleton pattern in the following ways:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Reduced global state</strong>: By injecting dependencies, you can avoid creating global singletons, reducing the overall global state in your application</li>
<li class="calibre11"><strong class="bold">Easier testing</strong>: Code relying on injected dependencies is generally easier to test because you can replace real implementations with mock objects or test-specific instances</li>
<li class="calibre11"><strong class="bold">Improved modularity</strong>: DI encourages a modular design where components are loosely coupled, making it easier to understand and maintain the code base</li>
</ul>
<p class="calibre3">The Singleton design pattern<a id="_idIndexMarker118" class="calibre6 pcalibre1 pcalibre"/> provides a single, globally accessible instance of a class, offering convenience but potentially leading to issues such as tight coupling and difficulty in testing. DI addresses these concerns by allowing objects to be provided with their dependencies externally, reducing reliance on a global state. This promotes loose coupling, enhances testability, and improves code maintainability by decoupling components and facilitating the easier management of object life cycles.</p>
<h3 class="calibre9">Flyweight design pattern</h3>
<p class="calibre3">The <a id="_idIndexMarker119" class="calibre6 pcalibre1 pcalibre"/>Flyweight pattern in Unity offers a <a id="_idIndexMarker120" class="calibre6 pcalibre1 pcalibre"/>solution for optimizing memory usage by sharing common data across multiple objects. It allows you to efficiently manage resources by storing shared data externally and referencing it when needed. <em class="italic">Figure 2</em><em class="italic">.2</em> illustrates Flyweight’s structure:</p>
<div><div><img alt="Figure 2.2 – Flyweight design pattern structure" src="img/B22017_02_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Flyweight design pattern structure</p>
<p class="calibre3">In the following code blocks, you’ll see an example scenario where the Flyweight pattern can be applied.</p>
<p class="calibre3">The <code>IWeapon</code> interface represents the shared properties and behaviors of weapons:</p>
<pre class="source-code">
 // Flyweight interface for weapons
public interface IWeapon
{
    void Fire();
}</pre> <p class="calibre3">The <code>Weapon</code> class implements the <code>IWeapon</code> interface and acts as a concrete Flyweight class representing individual weapons:</p>
<pre class="source-code">
// Concrete flyweight class for shared weapon properties
public class Weapon : IWeapon
{
     private string name;
     private int damage;
     private string sound;
     public Weapon(string name, int damage, string sound)
     {
         this.name = name;
         this.damage = damage;
         this.sound = sound;
     }
     public void Fire()
     {
          Debug.Log($"{name} fired - Damage: {damage} - Sound: {sound}");
     }
}</pre> <p class="calibre3">The <code>WeaponFactory</code> class <a id="_idIndexMarker121" class="calibre6 pcalibre1 pcalibre"/>acts as a Flyweight factory, managing<a id="_idIndexMarker122" class="calibre6 pcalibre1 pcalibre"/> and reusing flyweight objects based on specific keys (e.g., weapon types):</p>
<pre class="source-code">
// Flyweight factory class to manage and reuse flyweight objects
public class WeaponFactory
{
    private Dictionary&lt;string, IWeapon&gt; weapons;
    public WeaponFactory()
    {
        weapons = new Dictionary&lt;string, IWeapon&gt;();
    }
    public IWeapon GetWeapon(string key)
    {
        if (!weapons.ContainsKey(key))
        {
            switch (key)
            {
                case "pistol":
                    weapons[key] = new Weapon("Pistol", 30, "Bang!");
                    break;
                case "shotgun":
                    weapons[key] = new Weapon("Shotgun", 50, "Boom!");
                    break;
                case "rifle":
                    weapons[key] = new Weapon("Rifle", 40, "Pew Pew!");
                    break;
                default:
                    throw new ArgumentException("Invalid weapon key");
            }
        }
        return weapons[key];
    }
}</pre> <p class="calibre3">The <code>GameClient</code> class <a id="_idIndexMarker123" class="calibre6 pcalibre1 pcalibre"/>demonstrates <a id="_idIndexMarker124" class="calibre6 pcalibre1 pcalibre"/>how to use the flyweight objects retrieved from the factory, showcasing the reusability and memory efficiency of the Flyweight pattern:</p>
<pre class="source-code">
public class GameClient : MonoBehaviour
{
    void Start()
    {
        WeaponFactory weaponFactory = new WeaponFactory();
        // Using flyweight objects
        IWeapon pistol = weaponFactory.GetWeapon("pistol");
        pistol.Fire();
        IWeapon shotgun = weaponFactory.GetWeapon("shotgun");
        shotgun.Fire();
        IWeapon rifle = weaponFactory.GetWeapon("rifle");
        rifle.Fire();
        // Reusing flyweight objects
        IWeapon anotherPistol = weaponFactory.GetWeapon("pistol");
        anotherPistol.Fire();
    }
}</pre> <p class="calibre3">This <a id="_idIndexMarker125" class="calibre6 pcalibre1 pcalibre"/>example simulates a game scenario where different types of weapons are represented as flyweight objects, and the factory efficiently manages these shared objects to optimize memory usage and improve performance.</p>
<p class="calibre3">The following are <a id="_idIndexMarker126" class="calibre6 pcalibre1 pcalibre"/>the pros of using the Flyweight pattern:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Memory optimization</strong>: By sharing common data, the pattern reduces memory consumption, especially for large numbers of similar objects</li>
<li class="calibre11"><strong class="bold">Improved performance</strong>: Sharing reduces the overhead of creating and managing redundant data, leading to better performance</li>
<li class="calibre11"><strong class="bold">Simplified code</strong>: Separating shared and unique data promotes cleaner and more maintainable code</li>
</ul>
<p class="calibre3">The following are the<a id="_idIndexMarker127" class="calibre6 pcalibre1 pcalibre"/> cons of using the Flyweight pattern:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Complexity</strong>: Implementing the Flyweight pattern introduces additional complexity, especially when managing shared and unique states</li>
<li class="calibre11"><strong class="bold">Potential overhead</strong>: While the pattern improves memory and performance, it may introduce overhead due to managing shared resources</li>
</ul>
<p class="calibre3">Despite these considerations, the Flyweight pattern remains a valuable tool for efficient resource management in Unity projects, particularly in scenarios with many similar objects requiring memory optimization.</p>
<h3 class="calibre9">Observer design pattern</h3>
<p class="calibre3">The <a id="_idIndexMarker128" class="calibre6 pcalibre1 pcalibre"/>Observer pattern<a id="_idIndexMarker129" class="calibre6 pcalibre1 pcalibre"/> in Unity promotes loose coupling between objects by allowing them to subscribe to events and receive notifications when those events occur. This way, objects can react to changes without needing to know the specific details of the object raising the event.</p>
<p class="calibre3"><em class="italic">Figure 2</em><em class="italic">.3</em> illustrates Observer’s structure.</p>
<div><div><img alt="Figure 2.3 – Observer design pattern structure" src="img/B22017_02_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Observer design pattern structure</p>
<p class="calibre3">Let’s create a simple example in Unity to demonstrate the implementation of a health system using the Observer pattern.</p>
<p class="calibre3">In the following code block, we can see the <code>IHealthObserver</code> Observer interface and the <code>IHealthSubject</code> subject interface:</p>
<pre class="source-code">
// Observer interface
public interface IHealthObserver
{
    void OnHealthChanged(int health);
}
// Subject interface
public interface IHealthSubject
{
    event Action&lt;int&gt; OnHealthChanged;
}</pre> <p class="calibre3">In the <a id="_idIndexMarker130" class="calibre6 pcalibre1 pcalibre"/>following code block, we can see <a id="_idIndexMarker131" class="calibre6 pcalibre1 pcalibre"/>the <code>HealthManager</code> class implementing <code>IHealthSubject</code>:</p>
<pre class="source-code">
public class HealthManager : MonoBehaviour, IHealthSubject
{
    private int currentHealth;
    public int MaxHealth { get; private set; } = 100;
    // Event to notify observers when health changes
    public event Action&lt;int&gt; OnHealthChanged;
    private void Start()
    {
        currentHealth = MaxHealth;
    }
    // Method to damage the character
    public void TakeDamage(int damage)
    {
        currentHealth -= damage;
        currentHealth = Mathf.Clamp(currentHealth, 0, MaxHealth);
        // Notify observers about the health change
        OnHealthChanged?.Invoke(currentHealth);
        // Check for death condition
        if (currentHealth == 0)
        {
            Debug.Log("Character has died!");
            // Additional logic for character death...
        }
    }
}</pre> <p class="calibre3">In <a id="_idIndexMarker132" class="calibre6 pcalibre1 pcalibre"/>the <a id="_idIndexMarker133" class="calibre6 pcalibre1 pcalibre"/>following code block, we can see the <code>UIObserver</code> class implementing <code>IHealthObserver</code>:</p>
<pre class="source-code">
public class UIObserver : MonoBehaviour, IHealthObserver
{
    public void OnHealthChanged(int health)
    {
        // Update UI elements based on the received health value
        Debug.Log($"Health UI Updated: {health}");
        // Additional UI update logic...
    }
}</pre> <p class="calibre3">In the following code block, we can see the <code>GameplayObserver</code> class implementing <code>IHealthObserver</code>:</p>
<pre class="source-code">
public class GameplayObserver : MonoBehaviour, IHealthObserver
{
    public void OnHealthChanged(int health)
    {
        // Update gameplay mechanics based on the received health value
        Debug.Log($"Gameplay Updated: {health}");
        // Additional gameplay update logic...
    }
}</pre> <p class="calibre3">In the<a id="_idIndexMarker134" class="calibre6 pcalibre1 pcalibre"/> following code block, we can see a usage <a id="_idIndexMarker135" class="calibre6 pcalibre1 pcalibre"/>example for the Observer pattern in Unity:</p>
<pre class="source-code">
public class GameExample : MonoBehaviour
{
    private void Start()
    {
        HealthManager healthManager = new HealthManager();
        UIObserver uiObserver = new UIObserver();
        GameplayObserver gameplayObserver = new GameplayObserver();
        // Register observers with the HealthManager
        healthManager.OnHealthChanged += uiObserver.OnHealthChanged;
        healthManager.OnHealthChanged += gameplayObserver.OnHealthChanged;
        // Simulate damage to the character
        healthManager.TakeDamage(20);
    }
}</pre> <p class="calibre3">In this <a id="_idIndexMarker136" class="calibre6 pcalibre1 pcalibre"/>example, the <code>HealthManager</code> class <a id="_idIndexMarker137" class="calibre6 pcalibre1 pcalibre"/>represents the subject, and the <code>UIObserver</code> and <code>GameplayObserver</code> classes represent observers. When the character takes damage, <code>HealthManager</code> triggers the <code>OnHealthChanged</code> event, notifying all registered observers. Each observer then updates its state based on the received health value, demonstrating the Observer pattern in action.</p>
<p class="calibre3">The following <a id="_idIndexMarker138" class="calibre6 pcalibre1 pcalibre"/>are the pros of using the Observer pattern:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Improved decoupling</strong>: Objects are not dependent on each other’s implementation details, promoting loose coupling and modularity</li>
<li class="calibre11"><strong class="bold">Enhanced maintainability</strong>: Code becomes easier to understand and modify because event handling is centralized and observers are decoupled</li>
<li class="calibre11"><strong class="bold">Increased flexibility</strong>: Allows for the dynamic addition and removal of observers, making the system more adaptable to changing requirements</li>
</ul>
<p class="calibre3">The following are<a id="_idIndexMarker139" class="calibre6 pcalibre1 pcalibre"/> the cons of using the Observer pattern:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Increased complexity</strong>: Introduces additional abstraction layers compared to direct communication, which can slightly increase code complexity</li>
<li class="calibre11"><strong class="bold">Performance overhead</strong>: Event handling involves method calls and potentially data transfer, which can lead to some performance overhead</li>
</ul>
<p class="calibre3">Overall, the Observer pattern is a powerful tool for facilitating communication between objects and managing dynamic changes in Unity. The benefits of loose coupling and flexibility outweigh the drawbacks in most situations involving event-driven behavior.</p>
<p class="calibre3">Additionally, here are some other applications of the Observer pattern in Unity:</p>
<ul class="calibre10">
<li class="calibre11">Implementing state machines for characters and enemies</li>
<li class="calibre11">Updating UI elements based on changes in game state (e.g., score, level, and inventory)</li>
<li class="calibre11">Triggering animations or sound effects based on specific events in the game</li>
</ul>
<p class="calibre3">Remember, you can find all the examples on GitHub for reference.</p>
<p class="calibre3">It’s not mandatory <a id="_idIndexMarker140" class="calibre6 pcalibre1 pcalibre"/>to use these patterns in all your code. They serve as solutions to common problems, but sometimes, implementing patterns might complicate things unnecessarily. The key is to focus on solving the problem at hand first and then look for the best solution. In the following section, we will delve into coding conventions and explore best practices for writing clear code.</p>
<h1 id="_idParaDest-42" class="calibre5"><a id="_idTextAnchor044" class="calibre6 pcalibre1 pcalibre"/>Coding conventions and best practices</h1>
<p class="calibre3">Maintaining consistent and clear code is essential for effective development and collaboration. Adhering to recognized conventions and best practices enhances code clarity, maintainability, and readability. Here’s a breakdown of key aspects of C# coding:</p>
<p class="calibre3"><strong class="bold">C# naming conventions</strong>: Understanding <a id="_idIndexMarker141" class="calibre6 pcalibre1 pcalibre"/>and implementing C# naming conventions is pivotal for maintaining code consistency and clarity. Let’s delve into <a id="_idIndexMarker142" class="calibre6 pcalibre1 pcalibre"/>best practices for naming variables, methods, classes, and namespaces to ensure our code is both readable and expressive:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Variables</strong>: Adopt <strong class="bold">camelCase</strong> (e.g., <strong class="source-inline1">playerScore</strong>, <strong class="source-inline1">enemyHealth</strong>) and opt for <a id="_idIndexMarker143" class="calibre6 pcalibre1 pcalibre"/>descriptive<a id="_idIndexMarker144" class="calibre6 pcalibre1 pcalibre"/> names conveying the variable’s purpose (e.g., <strong class="source-inline1">currentLevel</strong>, <strong class="source-inline1">isGameOver</strong>). Avoid abbreviations unless widely understood (e.g., fps for frames per second).</li>
<li class="calibre11"><strong class="bold">Methods</strong>: Utilize <strong class="bold">PascalCase</strong> (e.g., <strong class="source-inline1">StartGame</strong>, <strong class="source-inline1">MovePlayer</strong>) and ensure the <a id="_idIndexMarker145" class="calibre6 pcalibre1 pcalibre"/>method<a id="_idIndexMarker146" class="calibre6 pcalibre1 pcalibre"/> name precisely reflects its functionality. Use verbs for action-oriented methods (e.g., <strong class="source-inline1">CalculateDamage</strong>, <strong class="source-inline1">LoadLevel</strong>).</li>
<li class="calibre11"><strong class="bold">Classes</strong>: Employ<a id="_idIndexMarker147" class="calibre6 pcalibre1 pcalibre"/> PascalCase for class names (e.g., <strong class="source-inline1">Player</strong>, <strong class="source-inline1">EnemyController</strong>) and avoid generic names such as <strong class="source-inline1">MyClass</strong> or <strong class="source-inline1">NewClass</strong>. Choose descriptive names representing the class’s purpose.</li>
<li class="calibre11"><strong class="bold">Namespaces</strong>: Apply <a id="_idIndexMarker148" class="calibre6 pcalibre1 pcalibre"/>PascalCase for namespaces (e.g., <strong class="source-inline1">MyGame.Characters</strong>, <strong class="source-inline1">Utility.Math</strong>) and organize code into meaningful hierarchical namespaces.</li>
<li class="calibre11"><strong class="bold">Meaningful and descriptive names</strong>: Crafting meaningful and descriptive names <a id="_idIndexMarker149" class="calibre6 pcalibre1 pcalibre"/>is fundamental to writing clear and understandable code. Let’s explore guidelines for selecting names that accurately convey the purpose and type of variables, avoiding ambiguity and enhancing code readability:<ul class="calibre16"><li class="calibre11">Choose names that accurately reflect the represented entity.</li><li class="calibre11">Avoid ambiguous names such as <strong class="source-inline1">temp</strong> or <strong class="source-inline1">data</strong>.</li><li class="calibre11">Use prefixes and suffixes to clarify variable types (e.g., <strong class="source-inline1">isJumping</strong>, <strong class="source-inline1">playerPosition</strong>).</li></ul></li>
<li class="calibre11"><strong class="bold">Code formatting</strong>: Mastering<a id="_idIndexMarker150" class="calibre6 pcalibre1 pcalibre"/> code formatting is a <a id="_idIndexMarker151" class="calibre6 pcalibre1 pcalibre"/>fundamental aspect of writing clean and organized code. Let’s explore key elements such as indentation, spacing, and comments to enhance readability and structure in your programming endeavors:<ul class="calibre16"><li class="calibre11"><strong class="bold">Indentation</strong>: Employ <a id="_idIndexMarker152" class="calibre6 pcalibre1 pcalibre"/>consistent indentation for enhanced readability and structure</li><li class="calibre11"><strong class="bold">Spacing</strong>: Introduce<a id="_idIndexMarker153" class="calibre6 pcalibre1 pcalibre"/> appropriate spacing around operators, keywords, and parentheses</li><li class="calibre11"><strong class="bold">Comments</strong>: Include<a id="_idIndexMarker154" class="calibre6 pcalibre1 pcalibre"/> comments to elucidate complex logic, clarify algorithms, and document code functionality</li></ul></li>
<li class="calibre11"><strong class="bold">Error handling and exception management</strong>: Error handling and exception management <a id="_idIndexMarker155" class="calibre6 pcalibre1 pcalibre"/>are critical aspects of software development, ensuring robustness and reliability in handling unexpected scenarios. Let’s delve into effective strategies, such as using <strong class="source-inline1">try-catch</strong> blocks and providing meaningful feedback, to manage errors gracefully and enhance user experience:<ul class="calibre16"><li class="calibre11">Implement robust error handling for graceful management of unexpected situations</li><li class="calibre11">Use <strong class="source-inline1">try-catch</strong> blocks to capture exceptions and provide meaningful user feedback</li><li class="calibre11">Avoid ignoring errors to prevent unpredictable behavior</li></ul></li>
<li class="calibre11"><strong class="bold">Method and class length</strong>: When it comes to method and class length, maintaining a <a id="_idIndexMarker156" class="calibre6 pcalibre1 pcalibre"/>balance between conciseness and clarity is paramount to fostering maintainable code bases. Let’s explore strategies for keeping methods and classes concise while ensuring they remain focused and easy to understand, promoting code readability and maintainability:<ul class="calibre16"><li class="calibre11">Strive for concise and focused methods and classes</li><li class="calibre11">Steer clear of “monolithic classes” handling everything, making them challenging to understand and maintain</li><li class="calibre11">Extract complex functionality into separate methods for clarity and reusability</li></ul></li>
<li class="calibre11"><strong class="bold">Additional best practices</strong>: In pursuit of robust and maintainable code, embracing <a id="_idIndexMarker157" class="calibre6 pcalibre1 pcalibre"/>additional best practices beyond the fundamentals is essential. Let’s delve into strategies:<ul class="calibre16"><li class="calibre11">Employ meaningful constants instead of magic numbers</li><li class="calibre11">Minimize the use of global variables</li><li class="calibre11">Avoid deeply nested code and excessive indentation</li></ul></li>
</ul>
<p class="calibre3">Embarking on a journey through essential coding conventions and best practices, we explored fundamental aspects such as C# naming conventions, where clarity and consistency reign supreme. We discussed the nuances of meaningful and descriptive names, mastering the art of code formatting, navigating error handling and exception management, and optimizing method and class length, as well as discovered additional best practices to refine your code base for robustness and clarity.</p>
<p class="calibre3">Let’s explore some refactoring techniques with examples.</p>
<h2 id="_idParaDest-43" class="calibre7"><a id="_idTextAnchor045" class="calibre6 pcalibre1 pcalibre"/>Refactoring techniques</h2>
<p class="calibre3">Refactoring techniques<a id="_idIndexMarker158" class="calibre6 pcalibre1 pcalibre"/> involve breaking down long and complex methods into smaller, focused functions and eliminating duplicated code to adhere to principles such as <strong class="bold">Don’t Repeat Yourself</strong> (<strong class="bold">DRY</strong>) and <strong class="bold">Keep It Simple, Stupid</strong> (<strong class="bold">KISS</strong>), ultimately resulting in cleaner and more maintainable Unity projects.</p>
<p class="calibre3">Let’s look at a couple of examples of code smells in Unity projects that may indicate a need for refactoring.</p>
<h3 class="calibre9">Example 1: Long and complex method</h3>
<p class="calibre3">In the<a id="_idIndexMarker159" class="calibre6 pcalibre1 pcalibre"/> following code block, we can see that the <code>PlayerController</code> class has a long method:</p>
<pre class="source-code">
public class PlayerController : MonoBehaviour
{
    public void HandlePlayerInput()
    {
        // ... (code for handling input)
        if (isMoving)
        {
            // ... (code for player movement)
        }
        if (isShooting)
        {
            // ... (code for shooting logic)
        }
        // ... (more complex logic)
        if (isJumping)
        {
            // ... (code for jumping)
        }
        // ... (more code)
        if (isDucking)
        {
            // ... (code for ducking)
        }
        // ... (more code)
        if (isInteracting)
        {
            // ... (code for interacting with objects)
        }
        // ... (even more code)
    }
}</pre> <p class="calibre3">The <a id="_idIndexMarker160" class="calibre6 pcalibre1 pcalibre"/>code smell here is the <code>HandlePlayerInput</code> method is lengthy and handles multiple tasks, making it hard to maintain. Refactor it into smaller, dedicated functions for specific player actions, such as movement, shooting, and jumping.</p>
<p class="calibre3"><em class="italic">After refactoring</em>, in the following code block, we can see the <code>PlayerController</code> class has methods for each piece of logic instead of a large method:</p>
<pre class="source-code">
public class PlayerController : MonoBehaviour
{
    public void HandlePlayerInput()
    {
        HandleMovement();
        HandleShooting();
        HandleJumping();
        HandleDucking();
        HandleInteracting();
    }
    private void HandleMovement()
    {
        // ... (code for player movement)
    }
    private void HandleShooting()
    {
        // ... (code for shooting logic)
    }
    private void HandleJumping()
    {
        // ... (code for jumping)
    }
    private void HandleDucking()
    {
        // ... (code for ducking)
    }
    private void HandleInteracting()
    {
        // ... (code for interacting with objects)
    }
}</pre> <h3 class="calibre9">Example 2: Duplicated code</h3>
<p class="calibre3">In the <a id="_idIndexMarker161" class="calibre6 pcalibre1 pcalibre"/>following code block, we can see the <code>EnemyAI</code> class has duplicated logic:</p>
<pre class="source-code">
public class EnemyAI : MonoBehaviour
{
    public void AttackPlayer()
    {
        // ... (code for attacking player)
    }
    public void AttackAlly()
    {
        // ... (same code for attacking ally)
    }
    public void AttackBoss()
    {
        // ... (same code for attacking boss)
    }
}</pre> <p class="calibre3">The code smell here is that duplicated code for attacking the player, ally, and boss poses maintenance hurdles. Refactor by crafting a single method for attacking and invoking it with distinct parameters to eliminate redundancy.</p>
<p class="calibre3"><em class="italic">After refactoring</em>, in the following code block, we can see <code>EnemyAI</code> has common code for attacking:</p>
<pre class="source-code">
public class EnemyAI : MonoBehaviour
{
    public void Attack(Entity target)
    {
        // ... (common code for attacking)
    }
    // Usage examples:
    // enemyAI.Attack(player);
    // enemyAI.Attack(ally);
    // enemyAI.Attack(boss);
}</pre> <p class="calibre3">These refactoring<a id="_idIndexMarker162" class="calibre6 pcalibre1 pcalibre"/> examples adhere to the DRY and KISS principles, resulting in cleaner and more maintainable Unity code. In the next couple of bullet points, we will take a look at the definitions of DRY and KISS:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">DRY principle</strong>: The<a id="_idIndexMarker163" class="calibre6 pcalibre1 pcalibre"/> DRY principle is a software development concept advocating for the avoidance of code duplication. It emphasizes that each piece of knowledge or logic within a system should have a single, unambiguous representation to reduce redundancy. By following DRY, developers aim to enhance maintainability, reduce the chance of errors, and improve code readability.</li>
<li class="calibre11"><strong class="bold">KISS principle</strong>: The <a id="_idIndexMarker164" class="calibre6 pcalibre1 pcalibre"/>KISS principle suggests that simplicity should be a key goal in design and decision-making. It encourages developers to favor straightforward, uncomplicated solutions over complex ones. KISS asserts that simplicity often leads to better understandability, maintainability, and reduced chances of errors. The principle is a reminder to avoid unnecessary complexity when solving problems.</li>
</ul>
<p class="calibre3">By identifying and <a id="_idIndexMarker165" class="calibre6 pcalibre1 pcalibre"/>addressing code smells in Unity projects, we ensure cleaner, more maintainable code. Through examples such as breaking down long methods and eliminating duplicated code, we adhere to principles such as DRY and KISS, resulting in improved code quality and readability.</p>
<p class="calibre3">Time to demonstrate your knowledge! Give these questions and challenges a try.</p>
<h1 id="_idParaDest-44" class="calibre5"><a id="_idTextAnchor046" class="calibre6 pcalibre1 pcalibre"/>Questions</h1>
<ul class="calibre10">
<li class="calibre11">What is the primary goal of writing clean code?</li>
<li class="calibre11">Implement a singleton pattern for managing game settings such as sound volume, music volume, and screen resolution. Ensure that there is only one instance of the settings manager throughout the game.</li>
<li class="calibre11">Create a singleton score manager that tracks the player’s score across multiple game levels or scenes. Ensure that the score manager instance persists between scene changes.</li>
<li class="calibre11">Implement a flyweight pattern using object pooling for bullets in a shooting game. The flyweight should efficiently manage the creation and reuse of bullet objects to minimize memory overhead during gameplay.</li>
<li class="calibre11">Design a flyweight pattern for rendering a tile-based map in a 2D game. Optimize the rendering process by reusing flyweight tile objects for similar tile types, such as grass, water, and rocks.</li>
<li class="calibre11">Develop an observer pattern-based event system for handling in-game events such as player deaths, power-up pickups, and level completions. Implement observers for different event types and ensure efficient event broadcasting.</li>
<li class="calibre11">Create an observer pattern implementation to update UI elements dynamically based on game events. For example, update health bars, score displays, and inventory icons using observers for player health changes, score increments, and item pickups.</li>
<li class="calibre11">Combine singleton, flyweight, and observer patterns to design a player character system. Use the singleton pattern for player input handling, flyweight for managing player animations efficiently, and observers for handling player state changes (e.g., health, inventory).</li>
<li class="calibre11">Design a game system (e.g., inventory management, quest tracking) and choose the most suitable design patterns (singleton, flyweight, observer, etc.) to implement various aspects of the system. Justify your design decisions based on SOLID principles and scalability.</li>
</ul>
<h1 id="_idParaDest-45" class="calibre5"><a id="_idTextAnchor047" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">To wrap up this chapter, remember that writing neat and well-organized C# code is key for successful Unity game development. The skills you’ve gained, such as naming things sensibly and arranging code logically, will make your game creation journey smoother. Keeping things simple and avoiding repeated code make your work easier to grasp and maintain. Applying these ideas will lead to games with code that just makes sense, making you a more efficient and effective game developer. It’s important to note that the journey toward clean code and best practices is ongoing. You don’t have to apply all the principles in every project, but consistently incorporating them into your coding mindset will enhance your skills over time.</p>
<p class="calibre3">Now, gear up for the next chapter, where you’ll explore Unity plugins. You will discover how to identify and evaluate various types of plugins, seamlessly integrating them into your projects. This knowledge will empower you to enhance game features, save development time, and implement new mechanics using C#. So, get ready for <a href="B22017_03.xhtml#_idTextAnchor049" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 3</em></a>, where you’ll broaden your Unity toolkit and elevate your game development skills.</p>
</div>
</body></html>