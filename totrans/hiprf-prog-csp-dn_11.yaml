- en: '*Chapter 9*: Enhancing the Performance of Networked Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：提高网络应用程序的性能'
- en: You will be very hard pressed when you turn your computer on to not have a single
    application using some kind of network application. Your operating system connects
    to a network to download and install Windows updates. Installed applications will
    poll (check at regular intervals) application servers over the internet to see
    if there are newer versions available for download.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开电脑时，很难找到一个不使用某种网络应用程序的应用程序。你的操作系统连接到网络以下载和安装Windows更新。已安装的应用程序将通过互联网定期轮询（检查）应用服务器，以查看是否有可下载的新版本。
- en: Browsers download audio and visual data over the internet, and websites allow
    you to upload and download files. Business applications communicate with database
    servers. Communication applications send large volumes of textual, audio, and
    visual data over networks – often with multiple people from various parts of the
    world involved in online video meetings and training sessions. Your fintech applications
    communicate with your financial providers over the internet. This is only just
    scratching the surface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器通过互联网下载音频和视觉数据，网站允许你上传和下载文件。商业应用程序与数据库服务器进行通信。通信应用程序通过网络发送大量的文本、音频和视觉数据——通常涉及来自世界各地多个地区的人们参与在线视频会议和培训课程。你的金融科技应用程序通过互联网与你的金融提供商进行通信。这只是冰山一角。
- en: Our world is very interconnected via technology, and it is networks that make
    all this possible. I am sure that you have felt some frustration as a user of
    a website or application when it experiences a slowdown, an application hang,
    or the application temporarily freezes while some other tasks block the UI until
    they have been completed, preventing you from doing any work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的世界通过技术紧密相连，是网络使得所有这一切成为可能。我相信，作为网站或应用程序的用户，当它出现减速、应用程序挂起或应用程序在完成某些其他任务之前暂时冻结，阻止你进行任何工作，你一定感受到了一些挫败感。
- en: Due to this, having applications that are highly performant over a network is
    crucial in today’s fast-paced world. And that is why Microsoft is busy working
    to always improve the efficiency and speed of their software. One such piece of
    software that is relatively new on the scene is **Google Remote Procedural Calls**
    (**gRPCs**). A software framework for making **Remote Procedural Calls** (**RPCs**),
    gRPC/gRPC-Web has received a performance boost.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，在当今快节奏的世界中，拥有在网络中表现优异的应用程序至关重要。这就是为什么微软正忙于不断提高他们软件的效率和速度。在舞台上相对较新的一个软件是**Google远程过程调用**（**gRPCs**）。这是一个用于进行**远程过程调用**（**RPCs**）的软件框架，gRPC/gRPC-Web获得了性能提升。
- en: In this chapter, you will learn how to speed up the performance of network applications.
    You will also learn how to communicate over a network using the `System.IO.Pipelines`
    to provide performant streaming capabilities.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何提高网络应用程序的性能。你还将学习如何使用`System.IO.Pipelines`在网络中进行通信，以提供高性能的流式传输能力。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: '**Understanding the network layers and protocols**: To produce working network
    software, you don’t necessarily need to know anything about networks and how they
    work – that is, unless you are writing low-level software to improve the network
    performance of networked applications. In this section, we will start looking
    at improving the network performance of software by looking at the different layers
    of a network and the protocols that live in those layers.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解网络层和协议**：为了编写可工作的网络软件，你不必了解任何关于网络及其工作原理的知识——除非你正在编写用于提高网络应用程序性能的低级软件。在本节中，我们将从查看网络的各个层以及存在于这些层中的协议开始，来探讨如何提高软件的网络性能。'
- en: '**Improving web-based network traffic**: Many of us use the internet daily
    during our work, family, education, and leisure time. The internet works over
    a web-based network that covers the globe. This network is made up of very slow
    copper wire networks to ultra-fast fiber-optic networks, and many computers with
    varying degrees of processing power. In this section, we will learn how to improve
    traffic over the internet to improve internet resource transfer. You will also
    learn how to monitor web application performance using Microsoft Edge.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化基于Web的网络流量**：我们中的许多人每天都在工作、家庭、教育和休闲时间使用互联网。互联网通过覆盖全球的基于Web的网络运行。这个网络由非常慢的铜线网络到超快的光纤网络组成，以及具有不同处理能力的许多计算机。在本节中，我们将学习如何改善互联网上的流量，以提高互联网资源传输。你还将学习如何使用Microsoft
    Edge监控Web应用程序的性能。'
- en: '**High-performance communication using gRPC**: In this section, we will learn
    how to perform high-speed network inter-process communication using gRPC and gRPC-Web.
    When it comes to gRPC-Web, we will be using Blazor Server for the server-side
    code and Blazor WebAssembly for the client-side code.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用gRPC进行高性能通信**：在本节中，我们将学习如何使用gRPC和gRPC-Web进行高速网络进程间通信。当涉及到gRPC-Web时，我们将使用Blazor
    Server进行服务器端代码，使用Blazor WebAssembly进行客户端代码。'
- en: '**Optimizing internet resources**: To improve resource upload and download
    times, it pays for you to spend time performing the right kinds of resource optimization.
    In this section, we will learn how to optimize images, text characters, and data
    transmission.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化互联网资源**：为了提高资源上传和下载时间，花时间进行正确的资源优化是值得的。在本节中，我们将学习如何优化图像、文本字符和数据传输。'
- en: '**Using pipelines for content streaming**: In this section, you will learn
    how to break down the data processing, data transmission, and data reception phases
    into several atomic tasks that work together using pipelines.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用管道进行内容流传输**：在本节中，你将学习如何将数据处理、数据传输和数据接收阶段分解为几个原子任务，这些任务通过管道协同工作。'
- en: '**Caching resources in memory**: In this section, you will learn how to cache
    resources in memory to reduce page transfer and display times. This can help reduce
    network load for other users and prevent bottlenecks and throttling.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在内存中缓存资源**：在本节中，你将学习如何将资源缓存到内存中，以减少页面传输和显示时间。这可以帮助减少其他用户的网络负载，并防止瓶颈和限制。'
- en: 'Upon completing this chapter, you will be able to do the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够做到以下事项：
- en: Understand and apply UDP-based and TCP-based network protocols
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并应用基于UDP和基于TCP的网络协议
- en: Monitor and identify problems with network traffic
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和识别网络流量问题
- en: Improve the network retrieval performance of resources using caching
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存提高资源网络检索性能
- en: Issue web requests and process responses securely
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全地发出网络请求并处理响应
- en: Efficiently stream content over a network such as the internet using pipelines
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道在网络上高效地传输内容，例如互联网
- en: Note
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: As with all performance-sensitive work, all the techniques and examples in this
    chapter, as well as throughout this book, should be measured in the context of
    your application. The overhead of certain techniques mentioned may not be necessary,
    depending on the scale your networking applications need to handle.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与所有性能敏感型工作一样，本章以及整本书中提到的所有技术和示例，都应在你的应用程序上下文中进行衡量。某些技术可能带来的开销可能不是必要的，这取决于你的网络应用程序需要处理的规模。
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the contents of this chapter, you will need the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的内容，你需要以下条件：
- en: Visual Studio 2022 or later
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022或更高版本
- en: Microsoft Edge
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Edge
- en: 'This book’s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH09](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH09)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH09](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH09)
- en: Understanding the network layers and protocols
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解网络层和协议
- en: When writing applications that interact with networks, it is very useful to
    know what **network protocols** are used. A network protocol is a defined set
    of rules that defines how data is formatted, transmitted, and received between
    different devices and applications over a network. Different network protocols
    are used for different tasks. Some protocols are secure by nature, while some
    protocols are insecure by nature. The **OSI network layer reference model** is
    a good place to start in understanding the layers of a device’s networking capabilities
    and the associated protocols for those layers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写与网络交互的应用程序时，了解所使用的**网络协议**非常有用。网络协议是一组定义了如何在网络上的不同设备和应用程序之间格式化、传输和接收数据的规则。不同的网络协议用于不同的任务。一些协议本质上是安全的，而另一些协议本质上是不可靠的。**OSI网络层参考模型**是了解设备网络能力和相关协议的好起点。
- en: '**OSI** stands for **Open Standards Institute**. The OSI network layer reference
    model is a conceptual model that defines and standardizes the communication between
    computers and telecommunication devices. It is independent of the technology that
    underpins such communication, so it is a technology-agnostic representation of
    the layers and protocols of a device’s network layers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**OSI**代表**开放标准研究所**。OSI网络层参考模型是一个概念模型，它定义和标准化了计算机和电信设备之间的通信。它独立于支撑这种通信的技术，因此它是对设备网络层和协议的技术无关表示：'
- en: '![Table 9.1 – The OSI network layer reference model'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 9.1 – The OSI network layer reference model'
- en: '](img/B16617_Table_9.1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Table_9.1.jpg](img/B16617_Table_9.1.jpg)'
- en: Table 9.1 – The OSI network layer reference model
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 – OSI网络层参考模型
- en: 'As you can see, a network has seven layers of operation. These layers are as
    follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，网络有七个操作层。这些层如下：
- en: '**Application layer**: The application layer provides a user interface that
    allows users to send and receive data over a network. This layer contains all
    the applications you use and that operate behind the scenes to interact with the
    presentation level. For example, your internet browser employs the HTTP, HTTPS,
    and FTP protocols for transmitting and receiving files over the internet, while
    email clients use POP3, SMTP, and IMAP for sending and receiving email data.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：应用层提供了一个用户界面，允许用户通过网络发送和接收数据。该层包含所有您使用的应用程序，以及那些在幕后操作以与表示层交互的应用程序。例如，您的互联网浏览器使用HTTP、HTTPS和FTP协议在互联网上传输和接收文件，而电子邮件客户端使用POP3、SMTP和IMAP发送和接收电子邮件数据。'
- en: '**Presentation layer**: The presentation layer encrypts, formats, and compresses
    the data ready for network transmission. The protocols that are employed in this
    layer include POP/SMTP, Usenet, HTTP, FTP, Telnet, DNS, SNMP, and NFS.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：表示层加密、格式化和压缩准备用于网络传输的数据。在此层使用的协议包括POP/SMTP、Usenet、HTTP、FTP、Telnet、DNS、SNMP和NFS。'
- en: '**Session layer**: The session layer initiates and terminates sessions with
    remote systems. This is the layer where ports are assigned for network communication.
    Examples include port 25 for POP/SMTP, port 532 for Usenet, port 80 for HTTP,
    port 443 for HTTPS, ports 20 and 21 for FTP, port 23 for Telnet, port 53 for DNS,
    ports 161 and 162 for SNMP, and the use of an RPC Portmapper for NFS.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话层**：会话层启动和终止与远程系统的会话。这是分配网络通信端口的层级。例如，端口25用于POP/SMTP，端口532用于Usenet，端口80用于HTTP，端口443用于HTTPS，端口20和21用于FTP，端口23用于Telnet，端口53用于DNS，端口161和162用于SNMP，以及使用RPC端口映射器来支持NFS。'
- en: '**Transport layer**: The transport layer breaks down data streams into smaller
    data delivery segments using either TCP or UDP.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层**：传输层使用TCP或UDP将数据流分解成较小的数据交付段。'
- en: '**Network layer**: The network layer provides logical addressing using either
    the original IPv4 or the newer IPv6.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络层**：网络层使用原始的IPv4或更新的IPv6提供逻辑寻址。'
- en: '**Data Link layer**: The data link layer prepares the data for transmission.
    This layer translates information from the network layer into a format that can
    be easily transmitted over the required network type using the SLIP, PPP, 802.2
    SNAP, and Ethernet II protocols.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据链路层**：数据链路层为传输准备数据。该层将网络层的信息转换为可以使用SLIP、PPP、802.2 SNAP和以太网II协议轻松在所需网络类型上传输的格式。'
- en: '**Physical layer**: The physical layer is responsible for moving data between
    device locations. The types of physical network connections that this layer can
    make available include RS-X, CAT1 to CAT8, ISDN, ADSL, ATM, FDDI, and Coaxial
    Cable.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理层**：物理层负责在设备位置之间移动数据。该层可以提供的物理网络连接类型包括 RS-X、CAT1 到 CAT8、ISDN、ADSL、ATM、FDDI
    和同轴电缆。'
- en: 'The following protocols are used in these various levels:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下协议在这些不同级别中使用：
- en: '**Domain Name Service** (**DNS**): The purpose of the DNS protocol is to translate
    host names into IP addresses and vice versa using what is known as domain name
    resolution. Port 53 is the default port for DNS.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域名系统** (**DNS**)：DNS 协议的目的是通过域名解析将主机名转换为 IP 地址，反之亦然。DNS 的默认端口是 53。'
- en: '**Dynamic Host Configuration Protocol** (**DHCP**): The purpose of DHCP is
    to assign IP address-related information dynamically to networked devices. Ports
    67 and 68 are the default ports for DHCP.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态主机配置协议** (**DHCP**)：DHCP 的目的是动态地将 IP 地址相关信息分配给网络设备。DHCP 的默认端口是 67 和 68。'
- en: '**Hypertext Transfer Protocol** (**HTTP**): The purpose of HTTP is to enable
    the transfer of web pages and supporting material over the internet. Port 80 is
    the default port for the HTTP protocol.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超文本传输协议** (**HTTP**)：HTTP 的目的是使网页及其支持材料能够在互联网上传输。HTTP 协议的默认端口是 80。'
- en: '**Hypertext Transfer Protocol Secure** (**HTTPS**): The purpose of HTTPS is
    to enable the safe transfer of web pages and their supporting material securely
    over the internet. Port 443 is the default port for HTTPS.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超文本传输协议安全** (**HTTPS**)：HTTPS 的目的是在互联网上安全地传输网页及其支持材料。HTTPS 的默认端口是 443。'
- en: '**Secure Shell** (**SSH**): The purpose of the SSH protocol is to securely
    connect to a remote computer and move files around and execute various commands.
    The default port for SSH is port 22.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全外壳** (**SSH**)：SSH 协议的目的是安全地连接到远程计算机，移动文件并执行各种命令。SSH 的默认端口是 22。'
- en: '**Secure Socket Layer** (**SSL**): The purpose of the SSL protocol is to secure
    the data that is transferred between a server and a web browser. Port 443 is the
    default port for SSL.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全套接字层** (**SSL**)：SSL 协议的目的是确保服务器和网页浏览器之间传输的数据安全。SSL 的默认端口是 443。'
- en: '**File Transfer Protocol** (**FTP**): The purpose of FTP is to transfer files
    over the internet. Ports 20 and 21 are the default ports for FTP.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件传输协议** (**FTP**)：FTP 的目的是在互联网上传输文件。FTP 的默认端口是 20 和 21。'
- en: '**Telnet**: Telnet provides insecure two-way interactive text-based communication
    between two computers using virtual terminal connections. Port 23 is the default
    port for Telnet.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Telnet**：Telnet 通过虚拟终端连接提供两个计算机之间不安全的双向交互式文本通信。Telnet 的默认端口是 23。'
- en: '**Trivial File Transfer Protocol** (**TFTP**): The default port for TFTP is
    port 69\.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '** trivial 文件传输协议** (**TFTP**)：TFTP 的默认端口是 69。'
- en: '**Simple Mail Transfer Protocol** (**SMTP**): The purpose of SMTP is to ensure
    the safe transmission of emails over the network. Port 25 is the default for the
    SMTP protocol.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单邮件传输协议** (**SMTP**)：SMTP 的目的是确保电子邮件在网络上的安全传输。SMTP 协议的默认端口是 25。'
- en: '**Post Office Protocol version 3** (**POP3**): The purpose of POP3 is to download
    and read emails from email servers. Port 110 is the default port for POP3.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邮局协议版本 3** (**POP3**)：POP3 的目的是从电子邮件服务器下载和阅读电子邮件。POP3 的默认端口是 110。'
- en: '**Internet Message Access Protocol 4** (**IMAP4**): The purpose of IMAP is
    to access emails on a remote email server without the need to download them. Port
    143 is the default port for IMAP.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网消息访问协议 4** (**IMAP4**)：IMAP 的目的是在不下载的情况下访问远程电子邮件服务器上的电子邮件。IMAP 的默认端口是
    143。'
- en: '**Remote Desktop Protocol** (**RDP**): The purpose of RDP is to establish a
    remote connection to a computer and take control of it. Port 3389 is the default
    for RDP.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程桌面协议** (**RDP**)：RDP 的目的是建立到计算机的远程连接并控制它。RDP 的默认端口是 3389。'
- en: '**Transmission Control Protocol** (**TCP**): The purpose of TCP is to provide
    trustworthy assurance that transmitted data will be received. TCP enables data
    sending and receiving. Different protocols come under the banner of TCP and each
    TCP protocol has a default port number.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输控制协议** (**TCP**)：TCP 的目的是提供可靠的保证，确保传输的数据将被接收。TCP 允许数据发送和接收。不同的协议属于 TCP
    的范畴，每个 TCP 协议都有一个默认端口号。'
- en: '**User Datagram Protocol** (**UDP**): The purpose of UDP is to provide untrusted
    data transmission without the assurance that the data will be received. UDP only
    allows data to be transmitted. Different protocols come under the banner of UDP
    and each UDP protocol has a default port number.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户数据报协议** (**UDP**): UDP的目的在于提供不受信任的数据传输，而不保证数据会被接收。UDP只允许数据传输。不同的协议属于UDP的范畴，每个UDP协议都有一个默认端口号。'
- en: '**Internet Protocol** (**IP**): The purpose of the IP is to address how data
    packets are routed between host computers on a TCP/IP network.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网协议** (**IP**): IP的目的是在TCP/IP网络上指定如何在主机计算机之间路由数据包。'
- en: '**Ethernet**: The purpose of the Ethernet protocol is to provide control over
    how data is transmitted over a LAN per the IEEE 802.3 protocol.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以太网**：以太网协议的目的是根据IEEE 802.3协议，控制数据如何在局域网中传输。'
- en: '**Point-to-Point** (**PPP**): The purpose of the PPP protocol is to establish
    a data link connection between two routers using authentication, transmission
    encryption, and data compression.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点对点** (**PPP**): PPP协议的目的是通过身份验证、传输加密和数据压缩，在两个路由器之间建立数据链路连接。'
- en: '**Network Time Protocol** (**NTP**): The purpose of NTP is to provide clock
    synchronization between computer systems over packet-switched data networks with
    variable latency.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络时间协议** (**NTP**): NTP的目的是在具有可变延迟的分组交换数据网络上，在计算机系统之间提供时钟同步。'
- en: '**Network News Transport Protocol** (**NNTP**): The purpose of NNTP is to transport
    Usenet articles (*netnews*) between news servers. It is also used by end user
    client applications to read and post articles.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络新闻传输协议** (**NNTP**): NNTP的目的是在新闻服务器之间传输Usenet文章（*netnews*）。它也被终端用户客户端应用程序用于阅读和发布文章。'
- en: These are only a small subset of the various network protocols that are used
    in today’s world. You are encouraged to further research the various protocols
    in use if you do a lot of programming that requires network access. You can find
    some useful articles to assist your advancement in the *Further reading* section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是当今世界使用的各种网络协议中的一小部分。如果您进行大量需要网络访问的编程，鼓励您进一步研究各种协议。您可以在“进一步阅读”部分找到一些有用的文章来帮助您进步。
- en: Once you understand what network protocols are used for, you can select the
    protocol that best suits your need. This helps reduce overhead. For example, if
    you only want to transmit data and do not wish to receive it or care whether it
    is received or not, then you would use the UDP network protocol. However, if you
    must guarantee that data is sent and received, then you must use TCP instead.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了网络协议的用途，您就可以选择最适合您需求的协议。这有助于减少开销。例如，如果您只想传输数据，而不希望接收它或关心它是否被接收，那么您将使用UDP网络协议。然而，如果您必须保证数据被发送和接收，那么您必须使用TCP。
- en: '**The Internet Engineering Task Force** (**IETF**) has defined two **Request
    For Comments** (**RFCs**) network transport protocols that have become internet
    standards. RFC 768 (UDP) defines UDP, whereas RFC 793 (TCP) defines TCP. Here
    are the official links for these RFCs for you to look at:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网工程任务组** (**IETF**) 定义了两个成为互联网标准的网络传输协议的**请求评论** (**RFCs**)。RFC 768 (UDP)
    定义了UDP，而RFC 793 (TCP) 定义了TCP。以下是这些RFC的官方链接，供您查阅：'
- en: 'RFC 768 (UDP): [https://tools.ietf.org/html/rfc768](https://tools.ietf.org/html/rfc768.)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 768 (UDP): [https://tools.ietf.org/html/rfc768](https://tools.ietf.org/html/rfc768.)'
- en: 'RFC 793 (TCP): [https://tools.ietf.org/html/rfc793](https://tools.ietf.org/html/rfc793)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 793 (TCP): [https://tools.ietf.org/html/rfc793](https://tools.ietf.org/html/rfc793)'
- en: TCP is a connection-oriented protocol responsible for ensuring that data is
    transferred reliably across networks via sessions. The sender and receiver agree
    on what data will be transferred. Packet error checking is performed on the received
    data. If there are errors, then a request is submitted to re-transmit the packet
    that failed. TCP is often used with **IP**. Packets are made aware of where to
    go and how to get there by IP. The combination of the TCP and IP protocols, when
    they work together, is defined as TCP/IP.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是一种面向连接的协议，负责确保通过会话在网络中可靠地传输数据。发送方和接收方就将要传输的数据达成一致。对接收到的数据进行数据包错误检查。如果有错误，则提交重传失败数据包的请求。TCP通常与**IP**一起使用。IP使数据包知道它们要去哪里以及如何到达。当TCP和IP协议协同工作时，这种组合被定义为TCP/IP。
- en: UDP differs from TCP as it is connectionless. UDP receivers listen for UDP packets
    with sessions being established. No error checking is performed with UDP. Therefore,
    packets may be lost with the receiver being unaware of the loss of those packets.
    UDP does not acknowledge the sender when data is received or when packets are
    lost.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: UDP与TCP不同，因为它是无连接的。UDP接收器监听UDP数据包，会话无需建立。UDP不执行错误检查。因此，数据包可能会丢失，接收器可能没有意识到这些数据包的丢失。UDP在接收到数据或数据包丢失时不会向发送方确认。
- en: With TCP establishing connections for communication sessions and performing
    error checking and resubmitting lost or corrupted packets, it is generally considered
    slower than UDP. UPD is faster than TCP because it does not establish connections
    for sessions or perform error checking. Therefore, TCP is the best option when
    data must be received without errors, such as with financial transactions. However,
    UDP is the best option when it comes to streaming live images, such as when you
    are watching a movie. That’s why movies can sometimes appear a bit grainy at times.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: TCP通过建立通信会话、执行错误检查和重新提交丢失或损坏的数据包，通常被认为比UDP慢。UDP比TCP快，因为它不建立会话连接或执行错误检查。因此，当数据必须无错误接收时，例如在金融交易中，TCP是最佳选择。然而，当涉及到流式传输实时图像，例如观看电影时，UDP是最佳选择。这就是为什么电影有时会显得有点颗粒感。
- en: In the real world, the OSI model does not exist in all practicality. Instead,
    the universally accepted network model that is tangible in a practical way is
    the TCP/IP model.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，OSI模型并非在所有实际情况下都存在。相反，普遍接受的、在实用层面上有形的网络模型是TCP/IP模型。
- en: The TCP/IP model
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP/IP模型
- en: 'The TCP/IP model differs from the OSI model in that there are only four layers
    that make up the TCP/IP model. These layers are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP模型与OSI模型的不同之处在于，TCP/IP模型只由四个层组成。这些层如下：
- en: Application layer
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层
- en: Transport layer
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层
- en: Internet layer
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网层
- en: Network interface layer
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络接口层
- en: 'So, how do the layers of the TCP/IP model map to the OSI model? The following
    table presents both models and their layers side by side for comparison:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，TCP/IP模型的层是如何映射到OSI模型的？以下表格展示了这两个模型及其层并列比较：
- en: '![Table 9.2 – Comparison between the TCP/IP model and the OSI model'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![表9.2 – TCP/IP模型与OSI模型的比较'
- en: '](img/B16617_Table_9.2.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Table_9.2.jpg)'
- en: Table 9.2 – Comparison between the TCP/IP model and the OSI model
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.2 – TCP/IP模型与OSI模型的比较
- en: 'Let’s describe each layer in the TCP/IP model:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述TCP/IP模型中的每一层：
- en: The **Application layer** enables users to initiate communication between applications
    and systems over a network. This can be sending an email, opening a web page,
    running an application over a network, accessing application information from
    a database, and performing file transfers over a network.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**使用户能够在网络上启动应用程序和系统之间的通信。这可以是发送电子邮件、打开网页、通过网络运行应用程序、从数据库访问应用程序信息以及通过网络执行文件传输。'
- en: The **Transport layer** resolves host-to-host communication.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层**解决主机间的通信。'
- en: The **Internet layer** connects different networks.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网层**连接不同的网络。'
- en: The **Network Interface layer** is the physical hardware that enables network
    communication between a server and its hosts.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络接口层**是物理硬件，它使服务器与其主机之间能够进行网络通信。'
- en: Now that we have learned about the TCP/IP model, in the next section, we will
    write a simple email application and discuss how it relates to the TCP/IP model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了TCP/IP模型，在下一节中，我们将编写一个简单的电子邮件应用程序，并讨论它与TCP/IP模型的关系。
- en: Writing an example email application with the TCP/IP model
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TCP/IP模型编写一个示例电子邮件应用程序
- en: 'In this section, we are going to write a simple console application that sends
    an email using SMTP. Then, we will discuss how this email is sent through the
    TCP/IP model. To write a simple console application, follow these steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个简单的控制台应用程序，使用SMTP发送电子邮件。然后，我们将讨论这封电子邮件是如何通过TCP/IP模型发送的。要编写一个简单的控制台应用程序，请按照以下步骤操作：
- en: Start a new .NET 6.0 Console Application and call it `CH09_OsiReferenceModel`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的.NET 6.0控制台应用程序，并将其命名为`CH09_OsiReferenceModel`。
- en: 'Add a new class called `EmailServer` with the following `using` statements:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`EmailServer`的新类，并包含以下`using`语句：
- en: '[PRE0]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need these two namespaces for handling exceptions and sending emails.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这两个命名空间来处理异常和发送电子邮件。
- en: 'Add the following method:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE1]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code takes the necessary parameters for sending our email programmatically.
    A `MailMessage` is built up from those parameters. Then, we initialize and configure
    a `SmtpClient` to connect to a networked-host email server that sends our email.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为发送电子邮件提供了必要的参数。从这些参数中构建了一个`MailMessage`。然后，我们初始化并配置一个`SmtpClient`来连接到网络化主机电子邮件服务器，发送我们的电子邮件。
- en: 'Update the `Program` class, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Program`类，如下所示：
- en: '[PRE2]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are writing a greeting to the console window. Then, we are calling
    `SendMail()` to send our email, and then finishing with a message.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在向控制台窗口写入问候语。然后，我们调用`SendMail()`来发送我们的电子邮件，并以一条消息结束。
- en: 'Now, add the `SendMail()` method:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`SendMail()`方法：
- en: '[PRE3]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Replace the email addresses with valid ones. This method calls the `SendMail`
    method in the `EmailServer` class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将电子邮件地址替换为有效的地址。此方法调用`EmailServer`类中的`SendMail`方法。
- en: Run the program; you should have an email in your email account.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序；你应该在你的电子邮件账户中收到一封电子邮件。
- en: 'With your project working, it is time to discuss how your project links in
    with the TCP/IP network model. Let’s start by looking at the following diagram:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的项目运行正常时，是时候讨论你的项目如何与TCP/IP网络模型相连接了。让我们先看看以下图表：
- en: '![Figure 9.1 – Sending and receiving an email over a network via SMTP using
    the TCP/IP protocol'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 通过TCP/IP协议使用SMTP在网络中发送和接收电子邮件'
- en: '](img/B16617_Figure_9.1.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_9.1.jpg)'
- en: Figure 9.1 – Sending and receiving an email over a network via SMTP using the
    TCP/IP protocol
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 通过TCP/IP协议使用SMTP在网络中发送和接收电子邮件
- en: First, start with your email client putting together an email, and the user
    clicking **Send**. When the data hits the Application layer, this is where the
    SMTP protocol comes into play. In this layer, the recipient is contacted, and
    the data is formatted and prefixed with an SMTP header.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用电子邮件客户端组合一封电子邮件，并让用户点击**发送**。当数据到达应用层时，SMTP协议开始发挥作用。在这一层，联系收件人，并对数据进行格式化，并加上SMTP头部。
- en: The email is then passed to the Transport layer. TCP is employed in this layer
    and is used to break down messages into smaller packets prefixed with a TCP header.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，电子邮件被传递到传输层。在这一层使用TCP，用于将消息分解成带有TCP头部的小数据包。
- en: From the transport layer, the email is passed to the Internet layer. IP formats
    the email packets so that they’re ready to be transmitted over the internet and
    prefixes them with an IP header. These formatted TCP/IP packets are then passed
    to the Network interface layer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从传输层开始，电子邮件被传递到互联网层。IP对电子邮件数据包进行格式化，以便它们可以传输到互联网，并在其前面加上IP头部。这些格式化的TCP/IP数据包随后被传递到网络接口层。
- en: At the network interface layer, the sender and receiver IP addresses are added
    to the header that is prefixed to the email. The email is then sent to the receiver.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络接口层，发送者和接收者的IP地址被添加到电子邮件前面加上头的头部中。然后，电子邮件被发送到接收者。
- en: When the email packet reaches the receiver, it first hits the network layer.
    The header for the network layer is removed, and the email packet is passed to
    the Internet layer. The IP header is removed, and the email packet is passed to
    the transport layer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当电子邮件数据包到达接收者时，它首先到达网络层。网络层的头部被移除，电子邮件数据包被传递到互联网层。IP头部被移除，电子邮件数据包被传递到传输层。
- en: At the transport layer, the email packets are then reassembled. Once all the
    packets have been assembled with the TCP headers removed, they are passed to the
    application layer, where the SMTP protocol removes the SMTP header, passes the
    pure email data to the client, and closes the session.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输层，电子邮件数据包被重新组装。一旦所有数据包都组装完成，并移除了TCP头部，它们被传递到应用层，在那里SMTP协议移除SMTP头部，将纯电子邮件数据传递给客户端，并关闭会话。
- en: With that, we have covered the conceptual OSI model and the practical four-layer
    TCP/IP model. Sending an email was the example we used to discuss the journey
    from the sender to the receiver over the four-layer TCP/IP layer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经涵盖了概念性的OSI模型和实用的四层TCP/IP模型。发送电子邮件是我们用来讨论从发送者到接收者在四层TCP/IP层中旅程的例子。
- en: Now that you understand the different layers that make up a network and some
    of the different network protocols and their uses, let’s look at network tracing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了构成网络的不同层以及一些不同的网络协议及其用途，让我们来看看网络跟踪。
- en: Improving web-based network traffic
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高基于Web的网络流量
- en: It is a good idea to keep an eye on the performance of your web applications.
    This helps you see how well your application transmits and receives information
    from the network we all know as the internet or, as it is increasingly being referred
    to, the cloud. You can even track down those calls that are taking a long time
    to complete, enabling you to improve the responsive performance of your application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关注您的 Web 应用程序的性能是一个好主意。这有助于您了解您的应用程序如何从我们所熟知的互联网或日益被称作云的网络中传输和接收信息。您甚至可以追踪那些耗时较长的调用，从而提高您应用程序的响应性能。
- en: There are various ways that you can accomplish this task. But we will only focus
    on one way, and that way is to record your application’s performance in the web
    browser using the in-built development tools performance analyzer. Specifically,
    we will be looking at using Microsoft Edge’s **development tools**. This will
    be the topic of the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此任务有多种方法。但我们将只关注一种方法，那就是使用内置的开发工具性能分析器在 Web 浏览器中记录您应用程序的性能。具体来说，我们将探讨使用 Microsoft
    Edge 的**开发工具**。这将是下一节的主题。
- en: Recording your web-applications performance using Microsoft Edge
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Microsoft Edge 记录您的 Web 应用程序性能
- en: In this section, you will be using the Microsoft Edge web browser to analyze
    the performance of your web applications. Internet is the name given to the **Wide
    Area Network** (**WAN**) that we use every day to browse the web. Sometimes, web
    applications can be slow, and they are often much slower than their desktop counterparts.
    That is where the developer tools provided by various browsers come in.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用 Microsoft Edge 浏览器来分析您的 Web 应用程序性能。互联网是我们每天用来浏览网页的**广域网**（WAN）的名称。有时，Web
    应用程序可能会很慢，而且它们通常比它们的桌面版本慢得多。这就是各种浏览器提供的开发者工具发挥作用的地方。
- en: 'With the browser developer tools, you have some powerful capabilities for seeing
    what your application is doing behind the scenes. The main features that are provided
    by various browsers are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器开发者工具，您有一些强大的功能来查看您的应用程序在幕后做了什么。各种浏览器提供的主要功能如下：
- en: The ability to navigate the elements of the currently loaded website to view
    the HTML structure, styles employed, computed styles, layout, event listeners,
    DOM breakpoints, properties, and accessibility.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够导航当前加载的网站元素以查看 HTML 结构、使用的样式、计算样式、布局、事件监听器、DOM 断点、属性和可访问性。
- en: You can view console messages, including any error messages raised.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以查看控制台消息，包括任何抛出的错误消息。
- en: You can view all the resources that make up a page with sources, synchronize
    changes with the local filesystem, override page assets with files from a local
    folder, view content scripts served by extensions, and create and save code snippets
    for later reuse.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用资源查看构成页面的所有内容，与本地文件系统同步更改，使用来自本地文件夹的文件覆盖页面资源，查看由扩展提供的内联脚本，以及创建和保存代码片段以供以后重用。
- en: You can record and view the network traffic generated by a page, including information
    such as name, status, type, initiator, size, time, and waterfall with the **Network**
    tab.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用**网络**选项卡记录和查看页面生成的网络流量，包括名称、状态、类型、发起者、大小、时间和瀑布图等信息。
- en: You can record a process. This information can be extremely detailed and you
    can save screenshots, record memory usage, and view the web vitals for the page
    with the **Performance** tab.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以记录一个过程。这些信息可以非常详细，您可以保存屏幕截图，记录内存使用情况，并通过**性能**选项卡查看页面的网络核心指标。
- en: You can profile memory usage and have the option to record a heap snapshot,
    allocate instrumentation on time, and allocate a sample.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以分析内存使用情况，并可以选择记录堆快照，按时间分配仪表，以及分配样本。
- en: You can see and debug the background services for your applications on the **Application**
    tab, including their storage and caches.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在**应用程序**选项卡上查看和调试您应用程序的后台服务，包括它们的存储和缓存。
- en: Security, which enables you to view the main origin and secure origins of your
    application, along with its security information, such as whether it has a valid
    **SSL certificate**.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性，这使您能够查看您应用程序的主要来源和受保护来源，以及其安全信息，例如它是否有有效的**SSL证书**。
- en: 'Each browser from various vendors works in subtly different ways. Developers
    each have their preferences as to which browser and set of developer tools they
    like to use. In this section, we will be using the **Microsoft Edge Network**
    and **Performance** tabs to analyze the performance of a web page. To do so, follow
    these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 来自不同厂商的每个浏览器都以微妙不同的方式工作。开发者们各自有他们偏好的浏览器和开发者工具集。在本节中，我们将使用**Microsoft Edge网络**和**性能**标签页来分析网页的性能。要这样做，请按照以下步骤操作：
- en: 'Open **Microsoft Edge** and press *F12* to open the developer tools. The following
    screen should appear:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Microsoft Edge**并按*F12*键打开开发者工具。应该会出现以下屏幕：
- en: '![Figure 9.2 – Microsoft Edge developer tools displaying the default tab'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – Microsoft Edge开发者工具显示默认标签页'
- en: '](img/B16617_Figure_9.2.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_9.2.jpg)'
- en: Figure 9.2 – Microsoft Edge developer tools displaying the default tab
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – Microsoft Edge开发者工具显示默认标签页
- en: Click on the **Network** tab.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**网络**标签页。
- en: In the address box, type `docs.microsoft.com`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地址框中，输入`docs.microsoft.com`。
- en: 'The website will now load. As it does, you will see the network traffic being
    generated and logged. The following screenshot shows a portion of the data that’s
    been ordered by the resources that took the longest time to process:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 网站现在将开始加载。在加载过程中，您将看到生成的网络流量被记录下来。以下截图显示了按处理时间最长的资源排序的数据的一部分：
- en: '![Figure 9.3 – The Microsoft Edge developer tools'' Network tab displaying
    network traffic data'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – Microsoft Edge开发者工具的“网络”标签页显示网络流量数据'
- en: '](img/B16617_Figure_9.3.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_9.3.jpg)'
- en: Figure 9.3 – The Microsoft Edge developer tools' Network tab displaying network
    traffic data
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – Microsoft Edge开发者工具的“网络”标签页显示网络流量数据
- en: As you can see, the **Network** tab is useful for seeing what resource has been
    requested (**name**), the **status** and **type** values of the request, what
    initiated the request (**initiator**), the request **size** and **time** to process,
    and its visual representation on the **Waterfall** chart. This information can
    be applied to your pages and their resources to reduce the overall size of a complete
    request and reduce the time it takes to complete the request.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**网络**标签页有助于查看已请求的资源（**名称**）、请求的**状态**和**类型**值、发起请求的**发起者**、请求的**大小**和**处理时间**，以及其在**瀑布图**上的视觉表示。这些信息可以应用于您的页面及其资源，以减少完整请求的整体大小并缩短完成请求所需的时间。
- en: 'Now that we’ve seen the **Network** tab in action, let’s look at the **Performance**
    tab in action. To do so, follow these steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了**网络**标签页的实际应用，让我们看看**性能**标签页的实际应用。要这样做，请按照以下步骤操作：
- en: Click on the **Performance** tab, and then click on the **record** button.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**性能**标签页，然后点击**记录**按钮。
- en: Type `docs.microsoft.com` into the address bar and press *Enter*.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地址栏中输入`docs.microsoft.com`并按*Enter*键。
- en: Once the page has fully loaded, stop the recording by clicking on the popup
    dialog’s **Stop** button.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面完全加载后，通过点击弹出对话框的**停止**按钮来停止记录。
- en: The profile that has just been captured will now be loaded and presented to
    you. How long this process will take varies based on how long you were recording
    and how much traffic was generated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚捕获的配置文件现在将加载并展示给您。这个过程需要多长时间取决于您记录了多长时间以及产生了多少流量。
- en: 'Once the profile has finished loading, you should be presented with the following
    screen:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置文件加载完成，您应该会看到以下屏幕：
- en: '![Figure 9.4 – The Microsoft Edge performance profile for docs.microsoft.com'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – docs.microsoft.com的Microsoft Edge性能配置文件'
- en: '](img/Figure_9.4.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4.jpg)'
- en: Figure 9.4 – The Microsoft Edge performance profile for docs.microsoft.com
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – docs.microsoft.com的Microsoft Edge性能配置文件
- en: You may be unable to read the contents of the preceding screenshot. That’s okay
    – this screenshot just represents the amount of data that you can glean using
    the performance profiler. You have screenshots, a Waterfall chart, a breakdown
    of all the methods and properties that were utilized to load the URL, and a summary
    of the types of traffic by time, such as loading time, scripting time, rendering
    time, painting time, system time, and idle time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能无法阅读前一个截图的内容。没关系 – 这个截图只是表示您可以使用性能分析器获取的数据量。您有截图、瀑布图、加载URL所使用的所有方法和属性的分解，以及按时间汇总的流量类型，如加载时间、脚本时间、渲染时间、绘制时间、系统时间和空闲时间。
- en: You can use this information to find where most of the time is being taken up
    for a request and identify the method where the time is being consumed. This will
    help you identify the areas of your web projects that may be candidates for performance
    improvement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些信息来找出请求中大部分时间被占用的地方，并识别消耗时间的方法。这将帮助你确定你的Web项目中可能需要性能改进的区域。
- en: There is a wealth of information that can be gathered regarding the performance
    of your application using browser tools. And not all that information has been
    covered here. For instance, we have not even touched on the memory profiling tab
    in Microsoft Edge Developer Tools due to this chapter’s page length restrictions.
    However, you are actively encouraged to try out all the different features available
    in the web browser’s development tools for yourself to help you profile and improve
    the performance of your web applications and their network utilization.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器工具可以收集有关应用程序性能的大量信息。这里并没有涵盖所有这些信息。例如，由于本章的页面长度限制，我们甚至没有触及Microsoft Edge开发者工具中的内存分析选项卡。然而，你被积极鼓励亲自尝试网络浏览器开发工具中所有不同的功能，以帮助你分析和改进Web应用程序及其网络利用率。
- en: Now that we have learned how to use browser development tools to profile the
    internet traffic that’s produced by our application requests and responses, let’s
    look at the performance-enhanced **gRPC Remote Procedural Call** (**gRPC**) framework
    for high-speed network data transfer and communication.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何使用浏览器开发工具来分析由我们的应用程序请求和响应产生的互联网流量，让我们来看看性能增强的**gRPC远程过程调用**（**gRPC**）框架，用于高速网络数据传输和通信。
- en: High-performance communication using gRPC
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gRPC进行高性能通信
- en: What is gRPC? It is an open source **RPC** framework. Applications use RPC to
    talk to each other. gRPC is built upon the modern technologies of HTTP/2 for the
    **transport protocol layer** and **protocol buffers** (**Protobuf**) for serializing
    technology for messages. Protobuf also provides a language-neutral contract language.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是gRPC？它是一个开源的**RPC**框架。应用程序使用RPC进行相互通信。gRPC基于HTTP/2的现代技术构建，用于**传输协议层**，以及**协议缓冲区**（**Protobuf**）用于消息的序列化技术。Protobuf还提供了一种语言中立的合同语言。
- en: gRPC has been designed with modern high-performance and cross-platform applications
    in mind. There are implementations for all manner of programming languages. This
    enables applications developed on different operating systems and in different
    programming languages to talk to each other.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC的设计考虑了现代高性能和跨平台应用程序。有各种编程语言的实现。这使得在操作系统和不同编程语言上开发的应用程序能够相互通信。
- en: gRPC is in an opinionated contract-first framework with the contract being defined
    in a **proto file**. This proto file contains your API definitions and the messages
    they will send and receive. Code generation is then used to generate strongly
    typed clients and messages for your language and platforms, which in our case
    will be C# and .NET. The language of gRPC is binary and designed for computers.
    This makes gRPC perform better than text-based HTTP APIs. The complexity of remoting
    is hidden from the programmer in the gRPC framework. Much of the work you would
    normally have to do by hand as a programmer is done for you by code generation
    tools. And so, all you must do is call methods on your clients and await the results.
    For increased developer productivity and application performance, you are better
    off using gRPC over HTTP APIs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是一个有观点的合同优先框架，合同在**proto文件**中定义。这个proto文件包含了你的API定义以及它们将发送和接收的消息。然后使用代码生成来为你的语言和平台生成强类型客户端和消息，在我们的案例中将是C#和.NET。gRPC的语言是二进制的，专为计算机设计。这使得gRPC比基于文本的HTTP
    API表现更好。在gRPC框架中，远程的复杂性被隐藏起来，程序员不需要手动完成的大部分工作都由代码生成工具完成。因此，你所需要做的就是调用客户端上的方法并等待结果。为了提高开发者的生产力和应用程序的性能，你最好使用gRPC而不是HTTP
    API。
- en: HTTP APIs are content-first and consider the shape of URLs, HTTP methods, JSON
    and XML, and more. REST APIs are code-first. Normally, you would write your code
    and then generate Swagger or RAML contracts afterward. REST APIs are human-readable
    as they are text-based. This makes them easy to debug with the right tools, but
    these APIs perform slower than gRPC. REST APIs deal with low-level HTTP, so you
    have more to think about in terms of HTTP requests, responses, and routing. This
    is more complicated than using gRPC, but you do end up with a high degree of control.
    So, even though HTTP APIs are not big on performance, they will appeal to the
    widest developer audience. They can be easier to get started with. However, they
    can become incredibly complex and deep-routed when you’re working on complicated
    enterprise software.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP API是内容优先，考虑URL的形状、HTTP方法、JSON和XML等。REST API是代码优先。通常，您会先编写代码，然后生成Swagger或RAML合约。REST
    API基于文本，因此可读性强。这使得它们在适当的工具的帮助下易于调试，但与gRPC相比，这些API的性能较慢。REST API处理低级HTTP，因此在HTTP请求、响应和路由方面需要考虑更多。这比使用gRPC更复杂，但最终您将获得高度的控制。因此，尽管HTTP
    API在性能上不是特别突出，但它们将吸引最广泛的开发者群体。它们可能更容易上手。然而，当您在开发复杂的企业软件时，它们可能会变得极其复杂和深层路由。
- en: Now that you know about gRPC and HTTP, you will appreciate that the fastest
    network and inter-application communication will be carried out by gRPC and not
    HTTP. And since this book is about performance, we will now demonstrate gRPC at
    work with a simple demonstration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了gRPC和HTTP，您会欣赏到最快的网络和应用程序间通信将由gRPC而不是HTTP来完成。鉴于这本书是关于性能的，我们将现在通过一个简单的演示来展示gRPC的工作原理。
- en: Programming a simple gRPC client/server application
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程简单的gRPC客户端/服务器应用程序
- en: In this section, we will be building a gRPC service that returns a single message.
    Then, we will write a client to call the gRPC service and update our client and
    server so that we can stream messages. Let’s begin by writing our gRPC service.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个返回单个消息的gRPC服务。然后，我们将编写一个客户端来调用gRPC服务，并更新我们的客户端和服务器，以便我们可以流式传输消息。让我们先编写我们的gRPC服务。
- en: Building a gRPC service
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建gRPC服务
- en: 'In this section, we are going to build a gRPC service in **Visual Studio**.
    Later in this chapter, we will consume this service. To build a gRPC service in
    Visual Studio, follow these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用**Visual Studio**构建一个gRPC服务。在本章的后面部分，我们将使用这个服务。要在Visual Studio中构建gRPC服务，请按照以下步骤操作：
- en: Open Visual Studio and select **Start a new project**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并选择**创建新项目**。
- en: Search for and select the ASP.NET Core **gRPC Service** template and click **Next**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并选择ASP.NET Core **gRPC服务**模板，然后点击**下一步**。
- en: On the `CH09_GrpcService`, and click **Create**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CH09_GrpcService`上点击**创建**。
- en: You will then be presented with the **Additional information** page. Ensure
    the latest version of .NET Framework is selected from the drop-down; this should
    be .NET 6.0.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来将显示**附加信息**页面。请确保从下拉菜单中选择最新的.NET Framework版本；这应该是.NET 6.0。
- en: Click on the `appsettings.json` file.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`appsettings.json`文件。
- en: Make sure the project is set as the startup project, and then run it. You should
    be presented with a **Trust ASP.NET Core SSL Certificate** dialog. Click on **Yes**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保项目设置为启动项目，然后运行它。您应该会看到一个**信任ASP.NET Core SSL证书**对话框。点击**是**。
- en: You will now be presented with a security dialog, informing you that you are
    about to install a security certificate. Click **Yes** to install it. Once the
    certificate has been installed, your service should [be running. The gRPC](http://localhost:5000)
    service URLs are [http://localhost:5000](http://localhost:5000) and [https://localhost:5001](https://localhost:5001).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将弹出一个安全对话框，告知您即将安装安全证书。点击**是**以安装它。一旦证书安装完成，您的服务应该[正在运行。gRPC](http://localhost:5000)服务的URL是[http://localhost:5000](http://localhost:5000)和[https://localhost:5001](https://localhost:5001)。
- en: Note
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Ports 5000 and 5001 may be different on your system if they are already in use.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果5000和5001端口已被占用，您的系统上的端口可能不同。
- en: 'Enter https://localhost:5001 in a browser; you should get the following message:
    **Communication with gRPC endpoints must be made through a gRPC client.** To learn
    how to create a client, visit [https://go.microsoft.com/fwlink/?linkid=2086909](https://go.microsoft.com/fwlink/?linkid=2086909).
    This message informs us that the next step is for us to write a client that will
    be able to communicate with the service.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中输入https://localhost:5001；您应该会收到以下消息：**与gRPC端点的通信必须通过gRPC客户端进行。**要了解如何创建客户端，请访问[https://go.microsoft.com/fwlink/?linkid=2086909](https://go.microsoft.com/fwlink/?linkid=2086909)。此消息通知我们下一步是为我们编写一个能够与该服务通信的客户端。
- en: 'And that is how easy it is to get started with a gRPC service. Open the `greet.proto`
    file in the `Proto` folder and enter the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单，就可以开始使用gRPC服务了。在`Proto`文件夹中打开`greet.proto`文件，并输入以下代码：
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the proto language is straightforward. In this file, we stated
    the language’s syntax, assembly namespace, and the name of the package. We then
    provided a service definition, which defines the RPC request and response, followed
    by the request and response messages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，proto语言很简单。在这个文件中，我们声明了语言的语法、程序集命名空间和包名。然后，我们提供了一个服务定义，它定义了RPC请求和响应，随后是请求和响应消息。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is a lot of code generation that goes on under the hood. So, in case you
    are wondering where certain files are located, you will find them hiding away
    in your `Obj\Debug\net6.0\Protos` folder.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层进行了大量的代码生成。因此，如果您想知道某些文件的位置，您将在您的`Obj\Debug\net6.0\Protos`文件夹中找到它们隐藏起来。
- en: Since we are using gRPC for our service, we need a client. So, in the next section,
    we will build our client.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用gRPC为我们提供服务，我们需要一个客户端。因此，在下一节中，我们将构建我们的客户端。
- en: Building a gRPC client
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建gRPC客户端
- en: 'In this section, we are going to add a gRPC client project that will consume
    our gRPC service. Also, for our client project, we will write a simple console
    application. To add a client project, follow these steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个gRPC客户端项目，该项目将消费我们的gRPC服务。此外，对于我们的客户端项目，我们将编写一个简单的控制台应用程序。要添加客户端项目，请按照以下步骤操作：
- en: Start a new .NET 6.0 Console Application project named `CH09_GrpcServiceClient`
    and change the target framework to `.NET 6.0`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的名为`CH09_GrpcServiceClient`的.NET 6.0控制台应用程序项目，并将目标框架更改为`.NET 6.0`。
- en: Right-click on the project’s **Service dependences** node in the Solution Explorer
    and select the **Add Connected Service** menu option. This will present you with
    the following tab:![Figure 9.5 – The Connected Services tab in Visual Studio
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，右键单击项目的**服务依赖项**节点，并选择**添加连接服务**菜单选项。这将向您展示以下选项卡：![图9.5 – Visual
    Studio中的连接服务选项卡
- en: '](img/B16617_Figure_9.5.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_9.5.jpg)'
- en: Figure 9.5 – The Connected Services tab in Visual Studio
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – Visual Studio中的连接服务选项卡
- en: 'Click on the **Add** button under the **Service References (OpenAPI, gRPC)**
    section. This will bring up the **Add service reference** dialog, as shown in
    the following screenshot:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**服务引用（OpenAPI，gRPC）**部分下点击**添加**按钮。这将弹出**添加服务引用**对话框，如图所示：
- en: '![Figure 9.6 – The Add service reference dialog in Visual Studio'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – Visual Studio中的添加服务引用对话框'
- en: '](img/B16617_Figure_9.6.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_9.6.jpg)'
- en: Figure 9.6 – The Add service reference dialog in Visual Studio
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – Visual Studio中的添加服务引用对话框
- en: 'Click on the **gRPC** option and then click on the **Next** button. The wizard
    dialog presented in the preceding screenshot will move to the **Add a new gRPC
    service reference** page, as shown here:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**gRPC**选项，然后点击**下一步**按钮。前面截图中的向导对话框将移动到**添加新gRPC服务引用**页面，如图所示：
- en: '![Figure 9.7 – The Add a new gRPC service reference page of the Add service
    reference dialog'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 添加服务引用对话框中的添加新gRPC服务引用页面'
- en: '](img/B16617_Figure_9.7.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_9.7.jpg)'
- en: Figure 9.7 – The Add a new gRPC service reference page of the Add service reference
    dialog
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 添加服务引用对话框中的添加新gRPC服务引用页面
- en: Click on the `greet.proto` file in your gRPC service project, and select it.
    Ensure the **client** option is selected from the dropdown list. Then, click **Finish**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的gRPC服务项目中点击`greet.proto`文件，并选择它。确保从下拉列表中选择**客户端**选项。然后，点击**完成**。
- en: 'The dialog will change to **Service reference configuration progress**. When
    you get a message stating **Successfully added service reference(s)**, click the
    **Close** button. Your gRPC connected service will now appear in the **Service
    References** section of the **Connected Services** tab, as shown here:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话框将变为 **服务引用配置进度**。当你收到显示 **成功添加服务引用** 的消息时，点击 **关闭** 按钮。你的 gRPC 连接服务现在将出现在
    **连接服务** 选项卡的 **服务引用** 部分中，如图所示：
- en: '![Figure 9.8 – The Connected Services tab displaying our connected gRPC service'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8 – 显示我们连接的 gRPC 服务的“连接服务”选项卡]'
- en: '](img/B16617_Figure_9.8.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Figure_9.8.jpg](img/B16617_Figure_9.8.jpg)'
- en: Figure 9.8 – The Connected Services tab displaying our connected gRPC service
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 显示我们连接的 gRPC 服务的“连接服务”选项卡
- en: 'With that, you have added a client project to your gRPC service. With the client
    projected added, we can now write the console applications. Follow these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就已经将一个客户端项目添加到了你的 gRPC 服务中。客户端项目添加后，我们现在可以编写控制台应用程序。按照以下步骤操作：
- en: 'Open the `CH09_GrpcServiceClient.csproj` file by selecting it in the Solution
    Explorer. You should see the following XML:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在解决方案资源管理器中选择它来打开 `CH09_GrpcServiceClient.csproj` 文件。你应该会看到以下 XML：
- en: '[PRE5]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding XML code, you can see the references to Google’s `Protobuf`
    library and the `gRPC` libraries. You will also see a Protobuf link to your proto
    file in the gRPC service, which indicates that your project is taking on the role
    of the client.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 XML 代码中，你可以看到对 Google 的 `Protobuf` 库和 `gRPC` 库的引用。你还会看到一个指向 gRPC 服务中你的
    proto 文件的 Protobuf 链接，这表明你的项目正在承担客户端的角色。
- en: Open the `Program` class in your client project.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的客户端项目中打开 `Program` 类。
- en: 'Update the `Main(string[] args)` method, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Main(string[] args)` 方法，如下所示：
- en: '[PRE6]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our entry point method, we call the asynchronous `ExecuteGrpClient()` method.
    However, because we cannot mark our main method as async, we have to call `Wait()`
    on the `ExecuteGrpcClient()` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的入口点方法中，我们调用异步的 `ExecuteGrpClient()` 方法。然而，因为我们不能将我们的主方法标记为异步，所以我们不得不在 `ExecuteGrpcClient()`
    方法上调用 `Wait()`：
- en: '[PRE7]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because we will be awaiting an asynchronous call, we must make the `ExecuteGrpcClient()`
    method asynchronous with the async modifier. This method does not return anything.
    However, it cannot be declared void, so we must provide `Task` as the return type.
    Then, we must declare our gRPC channel by pointing it to our gRPC HTTPS address.
    Then, we must declare our client by passing in the gRPC channel we have just declared
    and initialized. Next, we must obtain a reply by awaiting our asynchronous call
    to our server method and passing in a message request where we set the properties
    as necessary. Finally, we must print the response from the server to the console
    window.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将等待异步调用，所以我们必须使用异步修饰符将 `ExecuteGrpcClient()` 方法声明为异步。此方法不返回任何内容。然而，它不能声明为
    void，因此我们必须提供 `Task` 作为返回类型。然后，我们必须通过指向我们的 gRPC HTTPS 地址来声明我们的 gRPC 通道。然后，我们必须通过传递我们刚刚声明和初始化的
    gRPC 通道来声明我们的客户端。接下来，我们必须通过等待对服务器方法的异步调用并传递一个消息请求（我们根据需要设置属性）来获取一个回复。最后，我们必须将服务器的响应打印到控制台窗口。
- en: Open the server project in the terminal and type `dotnet run`. The server will
    be running locally on port 5001.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中打开服务器项目，并输入 `dotnet run`。服务器将本地运行在端口 5001 上。
- en: 'Then, open the client project in the terminal window and type `dotnet run`.
    It will print the following message in the console window:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在终端窗口中打开客户端项目，并输入 `dotnet run`。它将在控制台窗口中打印以下消息：
- en: '[PRE8]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With that, you have successfully written a gRPC server and consumed its message
    by writing and running a gRPC client. So what? What does this mean for you? It
    means that you now have a cross-platform way of communication between different
    applications using a common protocol. And what is the big deal in this regard?
    Well, say that you have several legacy applications written in various languages
    and you want to migrate them all to a common platform and programming language
    such as .NET or C# – you now have a straightforward way to accomplish this.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经成功编写了一个 gRPC 服务器，并通过编写和运行 gRPC 客户端来消费其消息。那么这又意味着什么呢？这对你意味着你现在有了在不同应用程序之间使用通用协议进行通信的跨平台方式。在这方面有什么大不了的？嗯，假设你有一些用各种语言编写的遗留应用程序，并且你想要将它们全部迁移到一个通用的平台和编程语言，比如
    .NET 或 C# – 你现在有了一种直接完成此任务的方法。
- en: By using gRPC, you can provide a phased migration from legacy platforms to the
    .NET 5 and higher platforms and C# 9 and higher programming language. You would
    accomplish this by writing gRPC clients for your .NET clients and legacy clients.
    This would enable you to start using .NET and C# as you incrementally replace
    older systems. Then, gradually, as the older systems are replaced by one modern
    system, you can fully utilize .NET and C# and benefit from all the performance
    improvements the Microsoft teams have made to the language and framework. Plus,
    you can leverage all the business and performance benefits of using the Microsoft
    ecosystem, which includes the Microsoft Azure Cloud services that have been built
    with security, scalability, and performance in mind.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用gRPC，你可以提供从遗留平台到.NET 5及以上平台和C# 9及以上编程语言的逐步迁移。你会通过为你的.NET客户端和遗留客户端编写gRPC客户端来实现这一点。这将使你能够在逐步替换旧系统的同时开始使用.NET和C#。然后，随着旧系统被一个现代系统逐步取代，你可以充分利用.NET和C#，并从微软团队对语言和框架所做的所有性能改进中受益。此外，你可以利用使用微软生态系统的所有业务和性能优势，这包括以安全性、可扩展性和性能为设计目标的微软Azure云服务。
- en: 'At this point, it is worth noting the various languages that are officially
    supported by gRPC. The officially supported languages, operating systems, compilers,
    and SDKs are shown in the following table:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得注意gRPC官方支持的各种语言。官方支持的语言、操作系统、编译器和SDK如下表所示：
- en: '![Table 9.3 – Officially supported languages by gRPC'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![表9.3 – gRPC官方支持的语言'
- en: '](img/B16617_Table_9.3.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Table_9.3.jpg)'
- en: Table 9.3 – Officially supported languages by gRPC
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.3 – gRPC官方支持的语言
- en: As we can see, gRPC is well supported across languages, operating systems, SDKs,
    and compilers. So, gRPC is the perfect networking technology to bring disparate
    systems together using one harmonious messaging framework.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，gRPC在多种语言、操作系统、SDK和编译器方面都得到了良好的支持。因此，gRPC是使用一个和谐的消息框架将不同的系统结合起来的完美网络技术。
- en: So far, you have consumed a unary request and know that gRPC can be used with
    various operating systems and programming languages. But what if you need to handle
    a whole batch of gRPC requests? How do we do that? Good question. We’ll learn
    how to do this in the next section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经消费了一个单一请求，并且知道gRPC可以与各种操作系统和编程语言一起使用。但是，如果你需要处理一整批gRPC请求呢？我们该如何做？这是一个好问题。我们将在下一节中学习如何做到这一点。
- en: Streaming multiple gRPC requests
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流式传输多个gRPC请求
- en: 'In this section, we will be modifying our client and server gRPC projects to
    send and process message streams. By the end of this project, you will be sending
    10 messages from the server to the client. On the client, you will process each
    message as it comes in and write it to the console window. To do so, follow these
    steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将修改我们的客户端和服务器gRPC项目以发送和处理消息流。到项目结束时，你将从服务器发送10条消息到客户端。在客户端，你将处理每个到达的消息并将其写入控制台窗口。为此，请按照以下步骤操作：
- en: 'Update the `greet.proto` file in the `CH09_GrpcService` project, as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`CH09_GrpcService`项目的`greet.proto`文件，如下所示：
- en: '[PRE9]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will see that you have added a new message stream to our service definition.
    Instead of returning a single `HelloReply` message, the message stream returns
    a stream of messages of the `HelloReply` type.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到你已经为我们服务的定义添加了一个新的消息流。而不是返回一个单一的`HelloReply`消息，消息流返回一个`HelloReply`类型的消息流。
- en: 'In the `GreeterService` class of the `CH09_GrpcServer` project, add the following
    method:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CH09_GrpcServer`项目的`GreeterService`类中，添加以下方法：
- en: '[PRE10]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this method, you are iterating 10 times. For each iteration, you await the
    `responseStream.WriteAsync(HelloReply)` method. In this asynchronous call, you
    set the message on the `HelloReply` object. With each iteration taking only milliseconds,
    you will purposefully slow down the processing of the task for human eyes to see
    each method being written one after the other. This delay slows down your task
    by 10 seconds – a second for each iteration. In a normal application, you would
    normally not have such a delay in place.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，你将迭代10次。对于每次迭代，你等待`responseStream.WriteAsync(HelloReply)`方法。在这个异步调用中，你将消息设置在`HelloReply`对象上。由于每次迭代只需毫秒级，你将故意减慢任务的处理速度，以便人类眼睛可以看到一个方法接一个方法地写入。这种延迟将你的任务减慢了10秒——每次迭代一秒。在正常的应用程序中，你通常不会设置这样的延迟。
- en: Now that you have updated your server project, rebuild both projects to see
    the changes and move to your `CH09_GrpcServiceClient` project.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经更新了你的服务器项目，请重新构建两个项目以查看更改，并移动到你的 `CH09_GrpcServiceClient` 项目。
- en: 'In the `Program` class, move the code inside the `ExecuteGrpcClient()` method
    into its own method called `SingleGrpcMessageClient()`. Then, add the following
    two lines of code to the `ExecuteGrpcClient()` method:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类中，将 `ExecuteGrpcClient()` 方法内的代码移动到其自己的方法 `SingleGrpcMessageClient()`
    中。然后，将以下两行代码添加到 `ExecuteGrpcClient()` 方法中：
- en: '[PRE11]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code contains two asynchronous calls: one for a single message,
    and one for streaming multiple messages.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含两个异步调用：一个用于单个消息，另一个用于流式传输多个消息。
- en: 'Add the `GrpcMessageResponseStream()` method:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GrpcMessageResponseStream()` 方法：
- en: '[PRE12]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`GrpcMessageResponseStream()` creates a `GrpcChannel` and assigns it to a new
    client. A call is then made to a gRPC stream. This iterates through all the items
    in the stream that have been sent back to the client from the server, and then
    prints the message for each item to the console window.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`GrpcMessageResponseStream()` 创建一个 `GrpcChannel` 并将其分配给一个新的客户端。然后调用一个 gRPC
    流。这会遍历从服务器发送回客户端的所有流项目，并将每个项目的消息打印到控制台窗口。'
- en: 'Open each of the projects in their own terminals and type the `dotnet run`
    command. This will start the server and run the client. You should see the following
    console window output:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在各自的终端中打开每个项目，并输入 `dotnet run` 命令。这将启动服务器并运行客户端。你应该看到以下控制台窗口输出：
- en: '[PRE13]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You now know how to use gRPC with desktop applications. In the next section,
    you will learn how to use gRPC with Blazor.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何将 gRPC 用于桌面应用程序。在下一节中，你将学习如何将 gRPC 用于 Blazor。
- en: Programming a simple gRPC Blazor application
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个简单的 gRPC Blazor 应用程序
- en: '**Blazor** is a web programming model. With Blazor, you can have server-side
    Blazor projects that you would write when you have sensitive information that
    you need to keep secret. You can have client-side Blazor projects when application
    performance is of the utmost importance. As part of an organization’s enterprise
    application, you have many different Blazor server-side and client-side applications
    working together as one.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blazor** 是一种网络编程模型。使用 Blazor，你可以拥有服务器端 Blazor 项目，这些项目是你需要编写以保护敏感信息不被泄露时使用的。当应用程序性能至关重要时，你可以拥有客户端
    Blazor 项目。作为组织的企业应用程序的一部分，你会有许多不同的 Blazor 服务器端和客户端应用程序协同工作。'
- en: For gRPC to work with web projects, a wrapper called gRPC-Web has been developed.
    This enables you to have both gRPC-Web services and gRPC-Web clients. With gRPC-Web,
    it is possible to build end-to-end pipelines that are compatible with the HTTP/1.1
    and HTTP/2 protocols. This provides a competitive edge over browser APIs that
    are unable to call gRPC HTTP/2, especially when you consider that not all .NET
    platforms have support for HTTP/2 via the `HttpClient` class. Another benefit
    of gRPC-Web is that you don’t have to use just TCP for **Inter-Process Communication**
    (**IPC**). For IPC, you can also use named pipes (UDP) and **Unix domain sockets**
    (**UDS**).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 gRPC 能够与网络项目一起工作，已经开发了一个名为 gRPC-Web 的包装器。这使得你可以拥有 gRPC-Web 服务和 gRPC-Web
    客户端。使用 gRPC-Web，可以构建与 HTTP/1.1 和 HTTP/2 协议兼容的端到端管道。这为无法调用 gRPC HTTP/2 的浏览器 API
    提供了竞争优势，特别是当你考虑到并非所有 .NET 平台都通过 `HttpClient` 类支持 HTTP/2 时。gRPC-Web 的另一个好处是，你不必仅使用
    TCP 进行**进程间通信**（**IPC**）。对于 IPC，你也可以使用命名管道（UDP）和**Unix 域套接字**（**UDS**）。
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The default template app for Blazor has a fetch data page that uses JSON for
    its data backend. The data size for this JSON file is 627 bytes. But when JSON
    is replaced with gRPC, the size of the data is reduced to 309 bytes. This example
    shows that data transfer is quicker using gRPC-Web than it is using JSON, as there
    is not so much data to transmit and receive over the network. The reduced size
    of the data transmission using gRPC-Web means that more requests can be made over
    the network before the requests need to be throttled.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 的默认模板应用程序有一个使用 JSON 作为其数据后端的数据获取页面。该 JSON 文件的数据大小为 627 字节。但是当 JSON 被替换为
    gRPC 时，数据大小减少到 309 字节。这个例子表明，使用 gRPC-Web 进行数据传输比使用 JSON 快，因为网络传输和接收的数据量较少。使用 gRPC-Web
    传输数据大小的减少意味着在请求需要被节流之前，可以在网络上发送更多的请求。
- en: In .NET 6.0, applications are made smaller via aggressive trimming. You can
    aggressively trim gRPC-based applications to reduce their size and increase their
    performance, especially when it comes to sending data over networks. This is because
    of the in-built code generation that is part of gRPC.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 6.0 中，应用程序通过积极的剪枝来减小体积。您可以积极剪枝基于 gRPC 的应用程序以减小其体积并提高其性能，尤其是在发送网络数据时。这是因为
    gRPC 内置的代码生成功能。
- en: In web projects, gRPC cannot be directly accessed. Therefore, a proxy project
    known as gRPC-Web was introduced to enable the use of gRPC with web projects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 项目中，无法直接访问 gRPC。因此，引入了一个名为 gRPC-Web 的代理项目，以使 Web 项目能够使用 gRPC。
- en: In the following sections, we will be writing a Blazor client and Server gRPC
    application consisting of a Blazor Server Application and a Blazor WebAssembly
    Application. Let’s begin.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将编写一个 Blazor 客户端和服务器 gRPC 应用程序，该应用程序由一个 Blazor 服务器应用程序和一个 Blazor WebAssembly
    应用程序组成。让我们开始。
- en: The blank solution
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是我们的空白解决方案
- en: 'We need to start with a blank solution:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从一个空白解决方案开始：
- en: Open Visual Studio and search for `Blank Solution`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并搜索 `Blank Solution`。
- en: Create the blank solution and name it `CH09_BlazorGrpc`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空白解决方案并将其命名为 `CH09_BlazorGrpc`。
- en: This will provide a blank solution to which we can add our client and server
    Blazor applications. Next, we will work on our client project.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供一个空白解决方案，我们可以向其中添加我们的客户端和服务器 Blazor 应用程序。接下来，我们将处理我们的客户端项目。
- en: The Blazor client project
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor 客户端项目
- en: 'In this section, we will build our Blazor client gRPC application. Follow these
    steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建我们的 Blazor 客户端 gRPC 应用程序。按照以下步骤操作：
- en: Add a new `CH09_BlazorGrpc.Client`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 `CH09_BlazorGrpc.Client`。
- en: 'Add the following NuGet packages:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 NuGet 包：
- en: '`Google.Protobuf`'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Google.Protobuf`'
- en: '`Grpc.Net.Client`'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Grpc.Net.Client`'
- en: '`Grpc.Net.Client.Web`'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Grpc.Net.Client.Web`'
- en: '`Grpc.Tools`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Grpc.Tools`'
- en: Add a folder called `Protos` and a file to that folder called `person.proto`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Protos` 的文件夹，并在该文件夹中添加一个名为 `person.proto` 的文件。
- en: 'Open the `person.proto` file and add the following code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `person.proto` 文件并添加以下代码：
- en: '[PRE14]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our proto file defines the proto definition version as proto3\. So, the `proto3`
    syntax will be used. The namespace for our service definition is `CH09_BlazorGrpc.Client`.
    The name that’s been given to our package is `grpcpeople`. There are three messages
    called `PeopleRequest`, `PeopleResponse`, and `PersonResponse`. Finally, we define
    our service as `Person` with an RPC called `GetPeople` that takes a `PeopleRequest`
    and returns a `PeopleResponse`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 proto 文件定义了 proto 定义版本为 proto3。因此，将使用 `proto3` 语法。我们的服务定义的命名空间是 `CH09_BlazorGrpc.Client`。我们给我们的包取的名字是
    `grpcpeople`。有三个消息名为 `PeopleRequest`、`PeopleResponse` 和 `PersonResponse`。最后，我们定义我们的服务为
    `Person`，并有一个名为 `GetPeople` 的 RPC，它接受一个 `PeopleRequest` 并返回一个 `PeopleResponse`。
- en: 'Add the following imports to the `_Imports.razor` file:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入添加到 `_Imports.razor` 文件中：
- en: '[PRE15]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These imports will be available to all our files.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些导入将适用于所有我们的文件。
- en: 'Locate the `Pages`/`Index.razor` page and replace its contents with the following
    code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到 `Pages`/`Index.razor` 页面，并用以下代码替换其内容：
- en: '[PRE16]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code will call the gRPC service that has been located by the service
    app and list the people that have been returned.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将调用由服务应用程序定位的 gRPC 服务，并列出返回的人员。
- en: That’s our client application completed. Now, let’s write our server application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们的客户端应用程序完成了。现在，让我们编写我们的服务器应用程序。
- en: The Blazor server project
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor 服务器项目
- en: 'In this section, we will write our server application, which will contain our
    service responsible for returning the requested data to the client. Let’s begin:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写我们的服务器应用程序，它将包含负责向客户端返回请求数据的服务的应用程序。让我们开始：
- en: Add a new Blazor Server app called `CH09_BlazorGrpc.Server`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 Blazor 服务器应用程序，名为 `CH09_BlazorGrpc.Server`。
- en: Add the `Grpc.AspNetCore` and `Grpc.AspNetCore.Web` NuGet packages.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Grpc.AspNetCore` 和 `Grpc.AspNetCore.Web` NuGet 包。
- en: Copy the `Protos` folder and its contents from the client project and paste
    it into the server project.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从客户端项目复制 `Protos` 文件夹及其内容，并将其粘贴到服务器项目中。
- en: Add the `PeopleService` class to the root of the server project.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PeopleService` 类添加到服务器项目的根目录。
- en: 'Replace the contents of the `PeopleService` class with the following code:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PeopleService` 类的内容替换为以下代码：
- en: '[PRE17]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This service has a single method that returns a list of people.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务有一个返回人员列表的单个方法。
- en: 'Replace the code in the `Program.cs` file with the following:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program.cs` 文件中的代码替换为以下内容：
- en: '[PRE18]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code configures our Blazor application to use gRPC and sets up
    our `PeopleService` class so that our client application can use it. We also configured
    `Cors` so that our gRPC requests and responses don’t get blocked.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码配置了我们的Blazor应用程序以使用gRPC，并设置了我们的`PeopleService`类，以便我们的客户端应用程序可以使用它。我们还配置了`Cors`，以便我们的gRPC请求和响应不会被阻止。
- en: Right-click on the solution and select **Properties**.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击解决方案并选择**属性**。
- en: Under **Startup Project**, select **Multiple startup projects** and change **Action**
    to **Start** for both the client and the server projects.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**启动项目**下，选择**多个启动项目**，并将客户端和服务器项目的**操作**都更改为**启动**。
- en: Click on **OK** to close the property dialog.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭属性对话框。
- en: 'Run the project. Two browser and two console windows should open. If all goes
    well, then you should see the following browser window:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。应该打开两个浏览器窗口和两个控制台窗口。如果一切顺利，您应该看到以下浏览器窗口：
- en: '![Figure 9.9 – The client Blazor application showing the response from the
    gRPC service in the server app'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 – 客户端Blazor应用程序显示服务器应用程序中gRPC服务的响应'
- en: '](img/B16617_Figure_9.9.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_9.9.jpg)'
- en: Figure 9.9 – The client Blazor application showing the response from the gRPC
    service in the server app
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 客户端Blazor应用程序显示服务器应用程序中gRPC服务的响应
- en: Note
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The port numbers depend on the ports that are available on a system. So, alternative
    ports will be used if ports 5000 and 5001 are already in use. This has happened
    here, in which port 7272 is being used for the server app and port 7108 is being
    used for the client app.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号取决于系统上可用的端口号。因此，如果端口5000和5001已被占用，将使用备用端口。这里就是这样，服务器应用程序正在使用端口7272，客户端应用程序正在使用端口7108。
- en: With that, you have learned about desktop and web-based network data transmission
    and communication using gRPC and gRPC-Web, both of which have received several
    performance enhancements along with C# and .NET Framework. You have also used
    the Blazor server and Blazor WebAssembly to perform web data transmissions and
    receive data.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，您已经了解了使用gRPC和gRPC-Web在桌面和基于Web的网络数据传输和通信，这些都与C#和.NET Framework一起获得了多项性能提升。您还使用了Blazor服务器和Blazor
    WebAssembly来执行Web数据传输并接收数据。
- en: You can use this information to replace your code that uses the JSON data format
    with the binary format of gRPC. This should cut down the size of your data transmissions
    and reduce the time it takes for the data to be transmitted and received, thus
    improving the performance of your networked applications – especially those applications
    that deal with huge volumes of data.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此信息将使用JSON数据格式的代码替换为gRPC的二进制格式。这应该会减少您的数据传输大小，并减少数据传输和接收所需的时间，从而提高您网络应用程序的性能——尤其是处理大量数据的应用程序。
- en: Optimizing internet resources
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化互联网资源
- en: The best web page is a web page that does the minimum it needs to present the
    necessary data that you want your users to view. Noisy web pages take longer to
    load and can be a source of irritation to your end users.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳网页是完成所需的最小工作来展示您希望用户查看的必要数据的网页。嘈杂的网页加载时间更长，可能会成为您最终用户的烦恼来源。
- en: When you use advert services and analytical and health monitoring services,
    these can produce unnecessary network traffic and an increase in page load time.
    So, you need to be concise in what data you gather regarding the page that is
    loading. You also need to reduce the number of resources that your page is downloading.
    Some of these resources will be explained here.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用广告服务、分析和健康监控服务时，这些服务可能会产生不必要的网络流量并增加页面加载时间。因此，您需要简洁地收集有关正在加载的页面的数据。您还需要减少页面下载的资源数量。其中一些资源将在下面进行解释。
- en: Images
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图片
- en: '**Images** are one of the resources that can significantly increase the time
    it takes to load a page. Therefore, it is important to use the right image format
    and compression for your images. It is often necessary to reduce the file size
    of images. Images usually come in three file formats: **JPEG/JPG**, **PNG**, and
    **GIF/animated GIF**. When it comes to image optimization, you are best off experimenting
    based on your website requirements. This is because you will need to factor in
    the tradeoff between image quality and image size, depending on your specific
    requirements.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**图片**是能够显著增加页面加载时间的资源之一。因此，使用正确的图片格式和压缩对图片进行优化非常重要。通常需要减小图片的文件大小。图片通常有三种文件格式：**JPEG/JPG**、**PNG**和**GIF/动画GIF**。在图像优化方面，最好根据您网站的需求进行实验。这是因为您需要根据具体需求权衡图像质量和图像大小之间的折衷。'
- en: 'An example of a tool that you can use for PNG optimization is PNGGauntlet by
    Ben Hollis: [https://pnggauntlet.com/](https://pnggauntlet.com/). This tool creates
    small PBGs by combining PNGOUT, OptiPNG, and DeflOpt with no loss of image quality.
    It can also convert the JPG, GIF, TIFF, and BMP file formats into PNG. You can
    configure the tool to your liking.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Ben Hollis的PNGGauntlet工具进行PNG优化：[https://pnggauntlet.com/](https://pnggauntlet.com/)。该工具通过结合PNGOUT、OptiPNG和DeflOpt，在不损失图像质量的情况下创建小的PBGs。它还可以将JPG、GIF、TIFF和BMP文件格式转换为PNG。您可以根据自己的喜好配置该工具。
- en: Text characters
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本字符
- en: When transmitting text over the internet, the more characters you have, the
    larger the file you will have. As a page grows, the time to load that page increases.
    You can reduce the size of each request and response by enabling deflate or `gzip`
    compression. Most, if not all, web servers provide web compression. You will have
    to look at how to enable web compression in the web server that you are using.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上传输文本时，字符越多，文件就越大。随着页面的增长，加载该页面的时间也会增加。您可以通过启用deflate或`gzip`压缩来减小每个请求和响应的大小。大多数，如果不是所有，Web服务器都提供Web压缩。您需要查看如何启用您所使用的Web服务器中的Web压缩。
- en: You can also reduce the size of your HTML, CSS, and JavaScript files in production
    by using minification. During development, when you have reached the stage where
    you are ready to deploy your application, you can employ tools such as webpack
    that will condense your files by removing unnecessary whitespace, comments, and
    unused code. Tools such as webpack can drastically reduce the size of your files.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用压缩来减小生产中HTML、CSS和JavaScript文件的大小。在开发过程中，当您达到准备部署应用程序的阶段时，您可以采用webpack等工具，通过删除不必要的空白、注释和未使用的代码来压缩您的文件。像webpack这样的工具可以显著减小文件的大小。
- en: This size reduction results in less data being transmitted over a network, meaning
    that the files a user has requested get downloaded on their device much faster.
    The quicker that requested files are downloaded to a user’s device, the quicker
    the requested page will be rendered for them to view.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这种尺寸减小导致通过网络传输的数据量减少，这意味着用户请求的文件将更快地下载到他们的设备上。请求的文件下载到用户设备越快，请求的页面渲染给用户查看的速度就越快。
- en: Data transmission
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据传输
- en: Transmitting data over a network takes time. That time can vary based on several
    different factors, such as the amount of network traffic and the route taken.
    Not all networks use fiber optic, and there are still locations over the internet
    that are still on slow copper wire connections.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上传输数据需要时间。这个时间可以根据多个不同的因素而变化，例如网络流量和所选择的路径。并非所有网络都使用光纤，互联网上仍然有一些位置仍然使用慢速铜线连接。
- en: One way to reduce network traffic and load time for networked resources is to
    **cache** them on the user’s computer that requested the resource. When a network
    resource is requested, the application will check if it exists in the cache. If
    it does, then the item will be retrieved from the cache on the user’s computer.
    But if the item is not in the cache, it will be downloaded over the network and
    stored in the user’s cache. When an item is being retrieved from the cache, the
    expiration date and time will be checked for the resource. If the expiry date
    and time have been reached, then the resource will be downloaded from over the
    network.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 减少网络流量和网络资源加载时间的一种方法是在请求资源的用户计算机上对其进行**缓存**。当请求网络资源时，应用程序将检查它是否存在于缓存中。如果存在，则将从用户计算机上的缓存中检索该项。但如果项不在缓存中，它将通过网络下载并存储在用户的缓存中。当从缓存中检索项时，将检查资源的过期日期和时间。如果过期日期和时间已到达，则资源将从网络上下载。
- en: Also, when working with large volumes of data, it is best to filter the data
    on the server and only return the subset of the data that you require. If the
    amount of data that you require is quite large, then employ data paging, whereby
    the data is divided into pages. Then, you only need to download a page as it is
    requested. This reduces the time it takes to receive the data once the request
    has been made.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当处理大量数据时，最好在服务器上过滤数据，并且只返回所需的数据子集。如果您需要的数据量相当大，则应使用数据分页，即将数据分成页。然后，您只需在请求时下载一页。这减少了在请求后接收数据所需的时间。
- en: Using pipelines for content streaming
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道进行内容流式传输
- en: '`System.IO.Pipelines` is a high-performance I/O .NET library that was first
    shipped with .NET Core 2.1 and was born from performance work carried out by the
    Kestrel team. The purpose behind pipelines is to reduce the complexity of correctly
    parsing stream and socket data.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.IO.Pipelines` 是一个高性能的 I/O .NET 库，它首次随 .NET Core 2.1 一起发布，并起源于 Kestrel
    团队进行性能工作时的成果。管道背后的目的是减少正确解析流和套接字数据的复杂性。'
- en: In this section, we will learn how to use pipelines with sockets. We will write
    to small console applications. The first console application will listen for incoming
    requests on port `7000` and output the contents to the console window. The second
    console application will listen for the newline key. When it is detected, it will
    send the contents of the command line to the server on port `7000`. By completing
    this project, you will see how easy it is to write a network communication application
    with a minimal number of lines of code using pipes and sockets.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用管道与套接字。我们将编写小型控制台应用程序。第一个控制台应用程序将监听端口 `7000` 上的传入请求并将内容输出到控制台窗口。第二个控制台应用程序将监听换行键。当检测到该键时，它将命令行内容发送到端口
    `7000` 上的服务器。通过完成此项目，您将看到使用管道和套接字编写网络通信应用程序是多么简单，只需极少的代码行。
- en: Let’s start by writing our server console app.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写我们的服务器控制台应用程序开始。
- en: Writing and running a TCP server console application
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写和运行 TCP 服务器控制台应用程序
- en: 'In this section, we will use sockets and pipelines to write a console application
    that listens for incoming data on port `7000`. When data is received, it is processed
    and output to the console window. To write a TCP server console application, follow
    these steps:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用套接字和管道编写一个控制台应用程序，该程序监听端口 `7000` 上的传入数据。当接收到数据时，它将被处理并输出到控制台窗口。要编写
    TCP 服务器控制台应用程序，请按照以下步骤操作：
- en: Start a new .NET 6.0 Console Application called `CH09_TcpServer`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的 .NET 6.0 控制台应用程序，名为 `CH09_TcpServer`。
- en: Add the `System.IO.Pipelines` NuGet package.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `System.IO.Pipelines` NuGet 包。
- en: 'Add a new class called `SocketExtensions`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `SocketExtensions` 的新类：
- en: '[PRE19]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is our `SocketExtensions` class, which we will build up with extension
    methods to simplify our socket code.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `SocketExtensions` 类，我们将通过扩展方法构建它以简化我们的套接字代码。
- en: 'Add the `ReceiveAsync` extension method:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReceiveAsync` 扩展方法：
- en: '[PRE20]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method extends a socket to delimit a section of a one-dimensional array.
    It receives data from a connected socket and returns a `Task` that represents
    the asynchronous receive operation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法扩展套接字以界定一维数组的一部分。它从连接的套接字接收数据并返回一个 `Task`，该 `Task` 表示异步接收操作。
- en: 'Add the `GetString` extension method:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GetString` 扩展方法：
- en: '[PRE21]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method extends a socket to delimit a section of a one-dimensional array.
    Then, it decodes a sequence of bytes into a string and returns the decoded string.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法扩展套接字以界定一维数组的一部分。然后，它将一系列字节解码成字符串并返回解码后的字符串。
- en: 'Add the `GetArray` method:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GetArray` 方法：
- en: '[PRE22]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method gets contiguous memory and returns a delimited section of a one-dimensional
    array.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法获取连续的内存并返回一维数组的一个分隔部分。
- en: 'Add the final extension method – that is, `GetArray`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加最终的扩展方法 – 即 `GetArray`：
- en: '[PRE23]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method tries to get a segment from the underlying memory buffer. The return
    value indicates the success of the operation. A delimited segment of a one-dimensional
    array is returned.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法尝试从底层内存缓冲区获取一个段。返回值表示操作的成功。返回一个一维数组的分隔段。
- en: Switch to the `Program` class.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Program` 类。
- en: 'Replace the `Program.cs` file’s source code with the following code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program.cs` 文件的源代码替换为以下代码：
- en: '[PRE24]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our top-level code creates a socket on port `7000`. Then, it listens for incoming
    data on port `7000` and processes the data.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最顶层代码在端口 `7000` 上创建一个套接字。然后，它监听端口 `7000` 上的传入数据并处理数据。
- en: 'Add the `ProcessLinesAsync` method:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ProcessLinesAsync` 方法：
- en: '[PRE25]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this method, we pass in a socket. The socket is assigned to a new `NetworkStream`
    object. Then, the new `NetworkStream` object is passed into a new `PipeReader`
    object. While there is data to be read, we read and process each line in the stream
    in turn. Once the stream has been completely read from start to finish, we mark
    the reader as complete so that no more data will be read from it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，我们传递一个套接字。套接字被分配给一个新的 `NetworkStream` 对象。然后，新的 `NetworkStream` 对象被传递给一个新的
    `PipeReader` 对象。当有数据要读取时，我们依次读取并处理流中的每一行。一旦从开始到结束完全读取了流，我们将读取器标记为完成，这样就不会再从它那里读取更多数据。
- en: 'Now, add the `TryReadLine` method:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `TryReadLine` 方法：
- en: '[PRE26]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method attempts to read a line of a `ReadOnlySequence` of bytes. If is
    unable to, it will return false. But if it can, it will set the line it can read
    as a `ReadOnlySequence` of bytes and return true.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法尝试读取一个 `ReadOnlySequence` 字节的行。如果不能，它将返回 false。但如果可以，它将设置的行作为 `ReadOnlySequence`
    字节返回并返回 true。
- en: 'Add our final method for our TCP Server called `ProcessLine`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们 TCP 服务器最后的 `ProcessLine` 方法：
- en: '[PRE27]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All we are doing here is printing the contents of the stream to the console
    window line by line.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是逐行将流的内容打印到控制台窗口。
- en: 'Run the program. You should see something similar to the following:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。你应该看到以下类似的内容：
- en: '![Figure 9.10 – The TCP Server in a running state ready to receive connections
    on port 7000'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – 运行状态下的 TCP 服务器，准备在端口 7000 上接收连接'
- en: '](img/B16617_Figure_9.12.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_9.12.jpg)'
- en: Figure 9.10 – The TCP Server in a running state ready to receive connections
    on port 7000
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – 运行状态下的 TCP 服务器，准备在端口 7000 上接收连接'
- en: You now have your TCP Server project up and running. The next step in developing
    your understanding of pipelines is to write our TCP Client project. We will do
    this in the next section.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的 TCP 服务器项目已经启动并运行。在了解管道的下一步，我们需要编写我们的 TCP 客户端项目。我们将在下一节中这样做。
- en: Writing and running a TCP client console application
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写和运行 TCP 客户端控制台应用程序
- en: 'In this section, we will continue looking at pipelines by writing the TCP client
    console application that will be sending console input to the TCP Server. The
    data received by the TCP Server from our TCP client will be displayed in the TCP
    Server’s window:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续通过编写将控制台输入发送到 TCP 服务器的 TCP 客户端控制台应用程序来查看管道。TCP 服务器从我们的 TCP 客户端接收到的数据将在
    TCP 服务器的窗口中显示：
- en: Start a new .NET 6.0 Console Application called `CH09_TcpClient`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 .NET 6.0 控制台应用程序，名为 `CH09_TcpClient`。
- en: 'In the `Program.cs` file, you will need to include the following namespaces:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，你需要包含以下命名空间：
- en: '[PRE28]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will need these namespaces for our TCP Client to read the console input and
    send it to the TCP Server for processing.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些命名空间来让我们的 TCP 客户端读取控制台输入并将其发送到 TCP 服务器进行处理。
- en: 'Add the following top-level statements:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下顶级语句：
- en: '[PRE29]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For our TCP Client, we simply open a new TCP socket on port `7000` and connect
    using the `IPAddress.Loopback` address. Then, we pass the socket into a new `NetworkStream`.
    Finally, we listen for input from the console window’s standard input and copy
    that input to the network stream that transmits the data to our TCP Server for
    processing.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 TCP 客户端，我们只需在端口 `7000` 上打开一个新的 TCP 套接字，并使用 `IPAddress.Loopback` 地址进行连接。然后，我们将套接字传递给一个新的
    `NetworkStream`。最后，我们监听来自控制台窗口标准输入的输入，并将该输入复制到发送数据到我们的 TCP 服务器进行处理的网络流中。
- en: 'Run the program. You should see the following:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。你应该看到以下内容：
- en: '![Figure 9.11 – The TCP Client listening on port 7000'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – TCP 客户端在端口 7000 上监听'
- en: '](img/Image87742.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Image87742.jpg)'
- en: Figure 9.11 – The TCP Client listening on port 7000
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – TCP客户端监听7000端口
- en: 'Type `Hello, World!` and press *Enter*. Your TCP Client console application
    should look as follows:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Hello, World!`并按*Enter*。你的TCP客户端控制台应用程序应该看起来如下：
- en: '![Figure 9.12 – The TCP Client console window displaying user input'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12 – 显示用户输入的TCP客户端控制台窗口'
- en: '](img/Image87751.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 显示TCP客户端响应的TCP服务器控制台窗口'
- en: Figure 9.12 – The TCP Client console window displaying user input
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 显示用户输入的TCP客户端控制台窗口
- en: 'Observe the TCP Server console window. You will see that the message **Hello,
    World!** has appeared since you typed the same message in the TCP Client window
    and pressed *Enter*, as shown here:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察TCP服务器控制台窗口。你会看到自你在TCP客户端窗口中输入相同的信息并按*Enter*以来，消息**Hello, World!**已经出现，如下所示：
- en: '![Figure 9.13 – The TCP Server console window displaying the response from
    the TCP Client'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 显示TCP客户端响应的TCP服务器控制台窗口'
- en: '](img/Image87759.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 显示TCP客户端响应的TCP服务器控制台窗口'
- en: Figure 9.13 – The TCP Server console window displaying the response from the
    TCP Client
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 显示TCP客户端响应的TCP服务器控制台窗口
- en: With that, you have finished writing and running the TCP client and server console
    applications, and you have seen just how simple it is to write a console application
    with sockets and pipelines. The code is very minimal and you can chain multiple
    pipelines together. For example, on the client end, a chained pipeline could be
    the serialization of an object followed by its encryption. Then, at the server
    end, the data could be decrypted and deserialized, and the resulting object could
    then be passed to LINQ, which would save the data contained in the object to a
    database. We can use sockets and pipelines with most C# project types, and you
    are encouraged to experiment with your own little projects to further your knowledge.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经完成了TCP客户端和服务器控制台应用程序的编写和运行，你也看到了使用套接字和管道编写控制台应用程序是多么简单。代码非常简洁，你可以将多个管道链接在一起。例如，在客户端，一个链式管道可以是对象的序列化，然后是加密。然后，在服务器端，数据可以被解密和反序列化，然后生成的对象可以传递给LINQ，这将保存对象中包含的数据到数据库。我们可以使用套接字和管道与大多数C#项目类型一起使用，并鼓励你通过自己的小项目进行实验，以进一步扩展你的知识。
- en: Caching resources in memory
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在内存中缓存资源
- en: '**Caching** items in memory requires RAM to be allocated so that they can be
    stored and retrieved efficiently. Storing frequently accessed resources in memory
    greatly improves the performance of applications.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**内存中的项目需要分配RAM，以便它们可以高效地存储和检索。将频繁访问的资源存储在内存中可以显著提高应用程序的性能。'
- en: A typical application that benefits from caching is a website. A traditional
    website will consist of HTML pages that define the structure of the visual web
    page that’s displayed to end users, CSS, which styles the page and makes it look
    nice, and JavaScript, which makes websites dynamic and interactive.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 从缓存中受益的典型应用程序是网站。一个传统的网站将包括HTML页面，它定义了显示给最终用户的视觉网页的结构，CSS，它为页面添加样式并使其看起来很漂亮，以及JavaScript，它使网站变得动态和交互式。
- en: Many pages of a website can use the same resources, such as data, images, sounds,
    files, and objects. Caching – temporarily storing some item so that it can be
    retrieved efficiently – can be done with a database, filesystem, or memory.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的许多页面可以使用相同的资源，例如数据、图像、声音、文件和对象。缓存（暂时存储某些项目以便可以高效检索）可以使用数据库、文件系统或内存来完成。
- en: In this section, we will learn how to store items in memory. Microsoft recommends
    the use of their `Microsoft.Extensions.Caching.Memory` NuGet package for caching
    items in memory. Therefore, we will follow their guidance and use this library
    in our example project.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在内存中存储项目。Microsoft建议使用他们的`Microsoft.Extensions.Caching.Memory` NuGet包来在内存中缓存项目。因此，我们将遵循他们的指导，并在我们的示例项目中使用这个库。
- en: We will be creating a very simple ASP.NET Core website that displays the current
    time and the cached time. When the cached time has expired, we will reset the
    cache. Each time the home view is called, we will output some text to the immediate
    window that displays the current time, the cached time, and the time difference
    in seconds.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常简单的ASP.NET Core网站，该网站显示当前时间和缓存时间。当缓存时间已过期时，我们将重置缓存。每次调用主页视图时，我们将在显示当前时间、缓存时间和秒数差异的即时窗口中输出一些文本。
- en: 'After each specified period has elapsed, you will see that the cache is reset,
    along with the time that’s output to the screen after the page refresh. To write
    our ASP.NET Core MVC web application, follow these steps:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个指定的时间周期结束后，你会看到缓存被重置，以及页面刷新后屏幕上输出的时间。要编写我们的 ASP.NET Core MVC 网络应用程序，请按照以下步骤操作：
- en: Start a new empty ASP.NET Core MVC Web Application, ensuring that your target
    framework is `net6.0` and called `CH09_AspNetCoreCaching`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的空 ASP.NET Core MVC 网络应用程序，确保你的目标框架是 `net6.0`，并命名为 `CH09_AspNetCoreCaching`。
- en: Add the `Microsoft.Extensions.Caching.Memory` NuGet package, and then add the
    `using` statement for this package to the `HomeController` class.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Microsoft.Extensions.Caching.Memory` NuGet 包，并将此包的 `using` 语句添加到 `HomeController`
    类中。
- en: 'Add an `IMemoryCache` member variable and update the `HomeController` constructor,
    as follows:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `IMemoryCache` 成员变量，并按如下方式更新 `HomeController` 构造函数：
- en: '[PRE30]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our `_memoryCache` variable will hold our cache in memory. The object that’s
    being used as our memory cache is injected into the `HomeController` constructor
    as a parameter and assigned to our variable.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `_memoryCache` 变量将持有我们的内存缓存。用作我们内存缓存的对象被注入到 `HomeController` 构造函数中作为参数，并分配给我们的变量。
- en: 'Next, add the `SetCache` method:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `SetCache` 方法：
- en: '[PRE31]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method accepts a key and a value. We set our `MemoryCacheEntryOptions`
    with a sliding expiration of 20 seconds and then set the cached entry’s value,
    which will expire in 20 seconds.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个键和一个值。我们使用滑动过期时间为20秒的 `MemoryCacheEntryOptions`，然后设置缓存条目的值，该值将在20秒后过期。
- en: 'The next thing we need to do is update the `HomeController` constructor’s `Index`
    method, as shown here:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步需要做的是更新 `HomeController` 构造函数的 `Index` 方法，如下所示：
- en: '[PRE32]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code declares a `DateTime` variable called `whenCached`. It checks
    if the value exists. If it does, its value will be set to the time when the variable
    was cached. If the variable does not exist, then it will be added to the cache.
    If it does exist, then the difference in time between now and when the variable
    was cached is calculated, and the results will be output to the debug window if
    the cache has not expired. If the cache has expired, then the cached variable
    will be updated with the current time.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码声明了一个名为 `whenCached` 的 `DateTime` 变量。它检查该值是否存在。如果存在，其值将被设置为变量被缓存时的时间。如果变量不存在，则将其添加到缓存中。如果它确实存在，那么将计算现在和变量被缓存时的时间差，如果缓存未过期，则结果将输出到调试窗口。如果缓存已过期，则缓存变量将使用当前时间进行更新。
- en: 'Now, we need to update our Home view’s HTML code, as follows:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新我们的主页的 HTML 代码，如下所示：
- en: '[PRE33]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code defines our model for the Razor page. The title of our page
    is set to `Index`. Our main page title is `Index`. Finally, we have a row that
    defines when the variable was cached and the current time.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了我们的 Razor 页面的模型。我们的页面标题被设置为 `Index`。我们的主页标题是 `Index`。最后，我们有一行定义了变量被缓存的时间和当前时间。
- en: 'Now, we need to update our `Program.cs file` to inform our website to use memory
    caching:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新我们的 `Program.cs` 文件，以通知我们的网站使用内存缓存：
- en: '[PRE34]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With that, our services have been configured to use the memory cache.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的服务已经配置为使用内存缓存。
- en: 'With that, we have configured our MVC application to use memory caching with
    sliding expiration. This means that we are now ready to run our project. Run the
    project and refresh a few times within 20 seconds, and then watch what happens.
    You will see that the cached and current times start the same. Then, when you
    refresh the page, you will see that the cached time remains the same, but the
    current time is ahead of the cached time. Then, when 20 seconds is over, the cached
    time will be updated in sync with the current time, as shown here:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经配置了我们的 MVC 应用程序以使用具有滑动过期的内存缓存。这意味着我们现在可以运行我们的项目。运行项目，在20秒内刷新几次，然后观察发生了什么。你会看到缓存的和当前的时间开始相同。然后，当你刷新页面时，你会看到缓存的时间保持不变，但当前时间领先于缓存时间。然后，当20秒过后，缓存时间将与当前时间同步更新，如下所示：
- en: '![Figure 9.14 – ASP.NET Core MVC memory caching example in action'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – ASP.NET Core MVC内存缓存示例在实际中的应用'
- en: '](img/B16617_Figure_9.14.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_9.14.jpg)'
- en: Figure 9.14 – ASP.NET Core MVC memory caching example in action
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – ASP.NET Core MVC内存缓存示例在实际中的应用
- en: As you can see from the preceding screenshot and by running the code, we now
    have a way of storing items in a computer’s memory cache, and we can determine
    when its cache value expires and has to be updated. This is a really simple way
    to improve a networked application’s network performance. It also reduces the
    amount of data that is transmitted over a network. This, in turn, helps reduce
    bandwidth problems and reduces transaction and network traffic costs for cloud-hosted
    operations.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图和运行代码所示，我们现在有了一种在计算机内存缓存中存储项目的方法，并且可以确定其缓存值何时过期并需要更新。这是一种真正简单的方法来提高网络应用程序的网络性能。它还减少了通过网络传输的数据量。这反过来有助于减少带宽问题，并降低云托管操作的事务和网络流量成本。
- en: That concludes this chapter. Now, let’s summarize what we have learned from
    working through this chapter.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章的内容。现在，让我们总结一下通过本章的学习我们所获得的知识。
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you studied the OSI reference model to understand the different
    layers of a network and the various protocols available for each layer. You also
    learned that the various protocols can be grouped into two main groups: TCP and
    UDP.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了OSI参考模型，以了解网络的不同层次以及每个层次可用的各种协议。你还了解到，各种协议可以分为两大类：TCP和UDP。
- en: Then, you learned about web browser development tools, which allow you to monitor
    your website’s activities, such as memory usage and network traffic. You also
    saw the errors it raises via the console window. This can help identify problems
    and resolve them.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了关于网页浏览器开发工具的内容，这些工具允许你监控你网站的各项活动，例如内存使用和网络流量。你还可以通过控制台窗口看到它抛出的错误。这有助于识别问题并解决它们。
- en: From there, you learned how to add gRPC for desktop clients and servers, and
    gRPC-Web for web-based clients and servers. You learned that gRPC helps reduce
    the size of data compared to the JSON data format, thus reducing page load time.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，你学习了如何为桌面客户端和服务器添加gRPC，以及为基于Web的客户端和服务器添加gRPC-Web。你了解到，与JSON数据格式相比，gRPC有助于减少数据大小，从而减少页面加载时间。
- en: After that, you learned how to optimize internet resources. This includes using
    the correct file format and reducing the size of images, caching items to reduce
    network traffic and load times, reducing the number of background services that
    are running, and limiting the number of resources that your page loads. You also
    considered filtering data on the server and dividing it into pages that are returned
    as requested.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你学习了如何优化互联网资源。这包括使用正确的文件格式，减少图像大小，缓存项目以减少网络流量和加载时间，减少正在运行的背景服务数量，以及限制页面加载的资源数量。你还考虑了在服务器上过滤数据并将其分成请求返回的页面。
- en: Finally, you learned how to write and run TCP client and server console applications
    before looking at memory caching, in which you can use ASP.NET Core MVC as your
    host project.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在学习内存缓存之前，你学习了如何编写和运行TCP客户端和服务器控制台应用程序，其中你可以使用ASP.NET Core MVC作为你的宿主项目。
- en: In the next chapter, we will be working with data by benchmarking different
    methods for inserting, updating, and deleting data efficiently. This will help
    us choose the best method for data operations based on our benchmark results.
    But before we do that, take some time to go through the *Further reading* section
    to further your knowledge on improving network performance. Also, try your hand
    at the questions to see how much knowledge you have retained.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过基准测试不同的数据插入、更新和删除方法来处理数据。这将帮助我们根据基准测试结果选择最佳的数据操作方法。但在我们这样做之前，花些时间浏览*进一步阅读*部分，以进一步了解提高网络性能的知识。同时，尝试回答问题以了解你保留了多少知识。
- en: Questions
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: Name the seven layers of the OSI reference model.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列出OSI参考模型的七个层次。
- en: Name some network protocols.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举一些网络协议。
- en: What is the difference between TCP/IP and UDP?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP/IP和UDP之间有什么区别？
- en: How can you see what errors are produced by your web page, what network traffic
    it produces, and how much memory it uses?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何查看你的网页产生的错误，它产生的网络流量以及它使用的内存量？
- en: What are gRPC and gRPC-Web?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: gRPC和gRPC-Web是什么？
- en: How you can optimize internet resources?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何优化互联网资源？
- en: Further reading
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及主题的信息，请查看以下资源：
- en: 'OSI seven layers model explained with examples: [https://www.computernetworkingnotes.com/ccna-study-guide/osi-seven-layers-model-explained-with-examples.html#:~:text=The%20OSI%20(Open%20System%20Interconnection)%20Reference%20Model%20is,and%20software%20applications%20which%20work%20in%20dissimilar%20environments](https://www.computernetworkingnotes.com/ccna-study-guide/osi-seven-layers-model-explained-with-examples.html#:~:text=The%20OSI%20(Open%20System%20Interconnection)%20Reference%20Model%20is,and%20software%20applications%20which%20work%20in%20dissimilar%20en)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带示例解释 OSI 七层模型：[https://www.computernetworkingnotes.com/ccna-study-guide/osi-seven-layers-model-explained-with-examples.html#:~:text=The%20OSI%20(Open%20System%20Interconnection)%20Reference%20Model%20is%2C,and%20software%20applications%20which%20work%20in%20dissimilar%20environments](https://www.computernetworkingnotes.com/ccna-study-guide/osi-seven-layers-model-explained-with-examples.html#:~:text=The%20OSI%20(Open%20System%20Interconnection)%20Reference%20Model%20is%2C,and%20software%20applications%20which%20work%20in%20dissimilar%20en)
- en: 'TCP/IP model: [https://ipcisco.com/lesson/tcp-ip-model/](https://ipcisco.com/lesson/tcp-ip-model/)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/IP 模型：[https://ipcisco.com/lesson/tcp-ip-model/](https://ipcisco.com/lesson/tcp-ip-model/)
- en: 'Overview of common TCP and UDP default ports: [https://www.examcollection.com/certification-training/network-plus-overview-of-common-tcp-and-udp-default-ports.html#:~:text=%20Overview%20of%20common%20TCP%20and%20UDP%20default,FTP%20is%20to%20transfer%20files%20over...%20More](https://www.examcollection.com/certification-training/network-plus-overview-of-common-tcp-and-udp-default-ports.html#:~:text=%20Overview%20of%20common%20TCP%20and%20UDP%20default,FTP%20is%20to%20transfer%20files%20over...%20More)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见 TCP 和 UDP 默认端口的概述：[https://www.examcollection.com/certification-training/network-plus-overview-of-common-tcp-and-udp-default-ports.html#:~:text=%20Overview%20of%20common%20TCP%20and%20UDP%20default%2CFTP%20is%20to%20transfer%20files%20over...%20More](https://www.examcollection.com/certification-training/network-plus-overview-of-common-tcp-and-udp-default-ports.html#:~:text=%20Overview%20of%20common%20TCP%20and%20UDP%20default%2CFTP%20is%20to%20transfer%20files%20over...%20More)
- en: 'List of TCP and UDP port numbers: [https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 和 UDP 端口号列表：[https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)
- en: 'Internet protocol suite: [https://en.wikipedia.org/wiki/Internet_protocol_suite](https://en.wikipedia.org/wiki/Internet_protocol_suite)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网协议套件：[https://en.wikipedia.org/wiki/Internet_protocol_suite](https://en.wikipedia.org/wiki/Internet_protocol_suite)
- en: '.NET network tracing: [https://www.shanebart.com/dotnet-network-tracing/](https://www.shanebart.com/dotnet-network-tracing/)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 网络跟踪：[https://www.shanebart.com/dotnet-network-tracing/](https://www.shanebart.com/dotnet-network-tracing/)
- en: 'dotnet-trace instructions: [https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md](https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dotnet-trace 指令：[https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md](https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md)
- en: 'How to view and kill processes using the Terminal in Mac OS X: [https://www.chriswrites.com/how-to-view-and-kill-processes-using-the-terminal-in-mac-os-x/](https://www.chriswrites.com/how-to-view-and-kill-processes-using-the-terminal-in-mac-os-x/)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Mac OS X 的终端中查看和终止进程：[https://www.chriswrites.com/how-to-view-and-kill-processes-using-the-terminal-in-mac-os-x/](https://www.chriswrites.com/how-to-view-and-kill-processes-using-the-terminal-in-mac-os-x/)
- en: 'How to find a process name using a PID number in Linux: [https://www.tecmint.com/find-process-name-pid-number-linux/](https://www.tecmint.com/find-process-name-pid-number-linux/)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 中使用 PID 号查找进程名称：[https://www.tecmint.com/find-process-name-pid-number-linux/](https://www.tecmint.com/find-process-name-pid-number-linux/)
- en: 'High-performance services with gRPC – what’s new in .NET 5: [https://www.youtube.com/watch?v=EJ8M2Em5Zzc](https://www.youtube.com/watch?v=EJ8M2Em5Zzc)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 gRPC 的高性能服务 – .NET 5 中的新功能：[https://www.youtube.com/watch?v=EJ8M2Em5Zzc](https://www.youtube.com/watch?v=EJ8M2Em5Zzc)
- en: 'gRPC-Web with .NET: [https://www.youtube.com/watch?v=UV-VnlcpDhU](https://www.youtube.com/watch?v=UV-VnlcpDhU)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC-Web 与 .NET：[https://www.youtube.com/watch?v=UV-VnlcpDhU](https://www.youtube.com/watch?v=UV-VnlcpDhU)
- en: '.NET Conf 2021 new Blazor WebAssembly capabilities in .NET 6: https://www.youtube.com/watch?v=kesUNeBZ1Os&list=PLdo4fOcmZ0oVFtp9MDEBNb
    A2sSqYvXSXO&index=20'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Conf 2021 .NET 6 中新的 Blazor WebAssembly 功能：[https://www.youtube.com/watch?v=kesUNeBZ1Os&list=PLdo4fOcmZ0oVFtp9MDEBNb
    A2sSqYvXSXO&index=20](https://www.youtube.com/watch?v=kesUNeBZ1Os&list=PLdo4fOcmZ0oVFtp9MDEBNb
    A2sSqYvXSXO&index=20)
- en: '.NET Conf 2021 high-performance services with gRPC – what’s new in .NET 6:
    [https://www.youtube.com/watch?v=CXH_jEa8dUw&list=PLdo4fOcmZ0oVFtp9MDEBNbA2sSqYvXSXO&index=31](https://www.youtube.com/watch?v=CXH_jEa8dUw&list=PLdo4fOcmZ0oVFtp9MDEBNbA2sSqYvXSXO&index=31)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Conf 2021 使用 gRPC 的高性能服务 – .NET 6 中的新功能：[https://www.youtube.com/watch?v=CXH_jEa8dUw&list=PLdo4fOcmZ0oVFtp9MDEBNbA2sSqYvXSXO&index=31](https://www.youtube.com/watch?v=CXH_jEa8dUw&list=PLdo4fOcmZ0oVFtp9MDEBNbA2sSqYvXSXO&index=31)
- en: 'Everything about Blazor: [https://codewithmukesh.com/blog/category/dotnet/blazor/](https://codewithmukesh.com/blog/category/dotnet/blazor/)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Blazor的一切：[https://codewithmukesh.com/blog/category/dotnet/blazor/](https://codewithmukesh.com/blog/category/dotnet/blazor/)
