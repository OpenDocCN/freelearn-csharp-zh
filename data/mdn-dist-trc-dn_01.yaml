- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Observability Needs of Modern Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代应用程序的可观察性需求
- en: With the increasing complexity of distributed systems, we need better tools
    to build and operate our applications. **Distributed tracing** is one such technique
    that allows you to collect structured and correlated telemetry with minimum effort
    and enables observability vendors to build powerful analytics and automation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分布式系统复杂性的增加，我们需要更好的工具来构建和运行我们的应用程序。**分布式跟踪**就是这样一种技术，它允许您以最小的努力收集结构化和关联的遥测数据，并使可观察性供应商能够构建强大的分析和自动化工具。
- en: In this chapter, we’ll explore common observability challenges and see how distributed
    tracing brings observability to our systems where logs and counters can’t. We’ll
    see how correlation and causation along with structured and consistent telemetry
    help answer arbitrary questions about the system and mitigate issues faster.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨常见的可观察性挑战，并了解分布式跟踪如何将可观察性带到我们的系统中，而日志和计数器无法做到这一点。我们将看到关联和因果关系，以及结构化和一致的遥测数据如何帮助回答关于系统的任意问题，并更快地缓解问题。
- en: 'Here’s what you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将学到的内容：
- en: An overview of monitoring techniques using counters, logs, and events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计数器、日志和事件概述监控技术
- en: Core concepts of distributed tracing – the span and its structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪的核心概念——跨度及其结构
- en: Context propagation standards
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文传播标准
- en: How to generate meaningful and consistent telemetry
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何生成有意义且一致的遥测数据
- en: How to use distributed tracing along with metrics and logs for performance analysis
    and debugging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用分布式跟踪、指标和日志进行性能分析和调试
- en: By the end of this chapter, you will become familiar with the core concepts
    and building blocks of distributed tracing, which you will be able to use along
    with other telemetry signals to debug functional issues and investigate performance
    issues in distributed applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉分布式跟踪的核心概念和构建块，你将能够将其与其他遥测信号一起使用，以调试功能问题和调查分布式应用程序中的性能问题。
- en: Understanding why logs and counters are not enough
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解为什么日志和计数器不足以满足需求
- en: 'Monitoring and observability cultures vary across the industry; some teams
    use ad hoc debugging with `printf` while others employ sophisticated observability
    solutions and automation. Still, almost every system uses a combination of common
    telemetry signals: logs, events, metrics or counters, and profiles. Telemetry
    collection alone is not enough. A system is **observable** if we can detect and
    investigate issues, and to achieve this, we need tools to store, index, visualize,
    and query the telemetry, navigate across different signals, and automate repetitive
    analysis.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和可观察性文化在行业中各不相同；一些团队使用`printf`进行临时调试，而其他团队则采用复杂的可观察性解决方案和自动化。然而，几乎每个系统都使用常见的遥测信号组合：日志、事件、指标或计数器，以及配置文件。仅遥测收集是不够的。如果我们能够检测和调查问题，则系统是**可观察的**，为了实现这一点，我们需要工具来存储、索引、可视化和查询遥测数据，跨不同信号导航，并自动化重复分析。
- en: Before we begin exploring tracing and discovering how it helps, let’s talk about
    other telemetry signals and their limitations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索跟踪并了解它如何帮助之前，让我们谈谈其他遥测信号及其局限性。
- en: Logs
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志
- en: A **log** is a record of some event. Logs typically have a timestamp, level,
    class name, and formatted message, and may also have a property bag with additional
    context.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志**是某些事件的记录。日志通常包含时间戳、级别、类名和格式化消息，并且可能还包含带有额外上下文的属性包。'
- en: Logs are a low-ceremony tool, with plenty of logging libraries and tools for
    any ecosystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是一种低仪式的工具，任何生态系统都有大量的日志库和工具。
- en: 'Common problems with logging include the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 日志中常见的问题包括以下内容：
- en: '**Verbosity**: Initially, we won’t have enough logs, but eventually, as we
    fill gaps, we will have too many. They become hard to read and expensive to store.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余**: 初始阶段，我们不会有足够的日志，但最终，随着我们填补空白，我们将拥有过多的日志。它们变得难以阅读且存储成本高昂。'
- en: '**Performance**: Logging is a common performance issue even when used wisely.
    It’s also very common to serialize objects or allocate strings for logging even
    when the logging level is disabled.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**: 即使使用得当，日志记录也是一个常见性能问题。在日志级别被禁用时，序列化对象或为日志分配字符串也是非常常见的。'
- en: '*One new log statement can take your production down; I did it once. The log
    I added was written every millisecond. Multiplied by a number of service instances,
    it created an I/O bottleneck big enough to significantly increase latency and
    the error rate for users*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*一条新的日志语句可能会让你的生产环境崩溃；我有过一次这样的经历。我添加的日志每毫秒都会写一次。乘以服务实例的数量，它创建了一个足够大的I/O瓶颈，足以显著增加延迟和用户的错误率*。'
- en: '**Not queryable**: Logs coming from applications are intended for humans. We
    can add context and unify the format within our application and still only be
    able to filter logs by context properties. Logs change with every refactoring,
    disappear, or become out of date. New people joining a team need to learn logging
    semantics specific to a system, and the learning curve can be steep.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可查询**：来自应用程序的日志是供人类使用的。我们可以在应用程序内部添加上下文并统一格式，但仍只能通过上下文属性来过滤日志。日志会随着每次重构而改变，消失或过时。新加入团队的人需要学习特定于系统的日志语义，学习曲线可能很陡峭。'
- en: '**No correlation**: Logs for different operations are interleaved. The process
    of finding logs describing certain operations is called correlation. In general,
    log correlation, especially across services, must be implemented manually (spoiler:
    not in ASP.NET Core).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无关联**：不同操作的日志是交织在一起的。寻找描述某些操作的日志的过程称为关联。一般来说，日志关联，尤其是在服务之间，必须手动实现（剧透：不是在ASP.NET
    Core中）。'
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Logs are easy to produce but are verbose, and then can significantly impact
    performance. They are also difficult to filter, query, or visualize.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 日志易于生成，但很冗长，可能会显著影响性能。它们也难以过滤、查询或可视化。
- en: To be accessible and useful, logs are sent to some central place, a **log management
    system**, which stores, parses, and indexes them so they can be queried. This
    implies that your logs need to have at least some structure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于访问和有用，日志被发送到某个中心位置，即**日志管理系统**，它存储、解析和索引它们，以便可以查询。这意味着你的日志至少需要有一些结构。
- en: '`ILogger` in .NET supports structured logging, as we’ll see in [*Chapter 8*](B19423_08.xhtml#_idTextAnchor131),
    *Writing Structured and Correlated Logs*, so you get the human-readable message,
    along with the context. Structured logging, combined with structured storage and
    indexing, converts your logs into rich events that you can use for almost anything.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`.NET中的`ILogger`支持结构化日志记录，正如我们将在[*第8章*](B19423_08.xhtml#_idTextAnchor131)，“编写结构化和关联日志”中看到的，因此你得到的是可读性强的消息，以及上下文。结构化日志记录，结合结构化存储和索引，将你的日志转换为丰富的事件，你可以用于几乎任何事情。'
- en: Events
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: An **event** is a structured record of something. It has a timestamp and a property
    bag. It may have a name, or that could just be one of the properties.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**是某事的记录。它有一个时间戳和属性包。它可能有一个名称，或者这可能是属性之一。'
- en: The difference between logs and events is semantical – an event is structured
    and usually follows a specific schema.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 日志和事件之间的区别是语义上的——事件是有结构的，通常遵循特定的模式。
- en: For example, an event that describes adding an item to a shopping bag should
    have a well-known name, such as `shopping_bag_add_item` with `user-id` and `item-id`
    properties. Then, you can query them by name, item, and user. For example, you
    can find the top 10 popular items across all users.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，描述向购物袋添加商品的日志应该有一个众所周知的名字，例如`shopping_bag_add_item`，并具有`user-id`和`item-id`属性。然后，你可以通过名称、项目和用户来查询它们。例如，你可以找到所有用户中最受欢迎的前10个商品。
- en: 'If you write it as a log message, you’d probably write something like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其作为日志消息编写，你可能会写一些像这样的事情：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If your logging provider captures individual properties, you would get the same
    context as with events. So, now we can find every log for this user and item,
    which probably includes other logs not related to adding an item.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的日志提供程序捕获单个属性，你将获得与事件相同的环境。因此，现在我们可以找到关于这个用户和商品的每一条日志，这很可能包括与添加商品无关的其他日志。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Events with consistent schema can be queried efficiently but have the same verbosity
    and performance problems as logs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一致模式的日志可以有效地查询，但与日志一样存在冗长和性能问题。
- en: Metrics and counters
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标和计数器
- en: Logs and events share the same problem – verbosity and performance overhead.
    One way to solve them is aggregation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 日志和事件存在相同的问题——冗长和性能开销。解决这些问题的方法之一是聚合。
- en: A **metric** is a value of something aggregated by dimensions and over a period
    of time. For example, a request latency metric can have an HTTP route, status
    code, method, service name, and instance dimensions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**指标**是某物通过维度和时间聚合的值。例如，请求延迟指标可以包含HTTP路由、状态码、方法、服务名称和实例维度。'
- en: 'Common problems with metrics include the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 指标常见的难题包括以下：
- en: '**Cardinality**: Each combination of dimensions is a time series, and aggregation
    happens within one time series. Adding a new dimension causes a combinatorial
    explosion, so metrics must have low cardinality – that is, they cannot have too
    many dimensions, and each one must have a small number of distinct values. As
    a result, you can’t measure granular things such as per-user experience with metrics.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基数**：每个维度的组合都是一个时间序列，聚合发生在单个时间序列内。添加一个新维度会导致组合爆炸，因此指标必须具有低基数——也就是说，它们不能有太多的维度，并且每个维度必须具有少量不同的值。因此，你不能使用指标来衡量像每个用户的体验这样的细粒度事物。'
- en: '**No causation**: Metrics only show correlation and no cause and effect, so
    they are not a great tool to investigate issues.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无因果关系**：指标仅显示相关性，没有因果关系，因此它们不是调查问题的优秀工具。'
- en: As an expert on your system, you might use your intuition to come up with possible
    reasons for certain types of behavior and then use metrics to confirm your hypothesis.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你系统的专家，你可能使用你的直觉来找出某些类型行为可能的原因，然后使用指标来证实你的假设。
- en: '`queue_is_full` or `queue_is_empty`. Something such as `queue_utilization`
    would be more generic. Over time, the number of metrics grows along with the number
    of alerts, dashboards, and team processes relying on them.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue_is_full` 或 `queue_is_empty`。像 `queue_utilization` 这样的东西会更通用。随着时间的推移，指标的数量会随着警报、仪表板和依赖它们的团队流程数量的增加而增长。'
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Metrics have low impact on performance, low volume that doesn’t grow much with
    scale, low storage costs, and low query time. They are great for dashboards and
    alerts but not for issue investigation or granular analytics.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 指标对性能的影响很小，体积不大，不会随着规模的增长而大幅增长，存储成本低，查询时间短。它们非常适合仪表板和警报，但不适合问题调查或细粒度分析。
- en: A **counter** is a single time series – it’s a metric without dimensions, typically
    used to collect resource utilization such as CPU load or memory usage. Counters
    don’t work well for application performance or usage, as you need a dedicated
    counter per each combination of attributes, such as HTTP route, status code, and
    method. It is difficult to collect and even harder to use. Luckily, .NET supports
    metrics with dimensions, and we will discuss them in [*Chapter 7*](B19423_07.xhtml#_idTextAnchor115),
    *Adding* *Custom Metrics*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**计数器**是一个单一的时间序列——它是一个没有维度的指标，通常用于收集资源利用率，如CPU负载或内存使用。计数器不适合应用程序性能或使用，因为你需要为每个属性组合（如HTTP路由、状态码和方法）设置一个专门的计数器。收集它们很困难，使用起来更难。幸运的是，.NET支持具有维度的指标，我们将在[*第7章*](B19423_07.xhtml#_idTextAnchor115)，“添加自定义指标”中讨论它们。'
- en: What’s missing?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺少什么？
- en: Now you know all you need to monitor a monolith or small distributed system
    – use metrics for system health analysis and alerts, events for usage, and logs
    for debugging. This approach has taken the tech industry far, and there is nothing
    essentially wrong with it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道你需要监控单体或小型分布式系统所需的一切——使用指标进行系统健康分析和警报，事件用于使用情况，日志用于调试。这种方法已经将科技行业推进很远，而且其中并没有本质上的错误。
- en: With up-to-date documentation, a few key performance and usage metrics, concise,
    structured, correlated, and consistent events, common conventions, and tools across
    all services, anyone operating your system can do performance analysis and debug
    issues.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最新的文档、几个关键的性能和用量指标、简洁、结构化、相关和一致的事件、跨所有服务的通用约定和工具，任何操作你的系统的人都可以进行性能分析和调试问题。
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*So, the ultimate goal is to efficiently operate a system, and the problem
    is not a specific telemetry signal or its limitations but a lack of standard solutions
    and practices, correlation, and structure for* *existing signals.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*因此，最终目标是高效地运营系统，问题不在于特定的遥测信号或其局限性，而在于缺乏标准解决方案、实践、相关性以及现有信号的结构。*'
- en: Before we jump into distributed tracing and see how its ecosystem addresses
    these gaps, let’s summarize the new requirements we have for the perfect observability
    solution we intend to solve with tracing and the new capabilities it brings. Also,
    we should keep in mind the old capabilities – low-performance overhead and manageable
    costs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入分布式跟踪并了解其生态系统如何解决这些差距之前，让我们总结一下我们对于完美可观察性解决方案的新要求，我们打算通过跟踪来解决这些问题，以及它带来的新功能。同时，我们也应该记住旧的功能——低性能开销和可管理的成本。
- en: Systematic debugging
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统性调试
- en: We need to be able to investigate issues in a generic way. From an error report
    to an alert on a metric, we should be able to drill down into the issue, follow
    specific requests end to end, or bubble up from an error deep in the stack to
    understand its effect on users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够以通用方式调查问题。从错误报告到指标上的警报，我们应该能够深入问题，从头到尾跟踪特定的请求，或者从堆栈深处的错误向上冒泡，以了解其对用户的影响。
- en: All this should be reasonably easy to do when you’re on call and paged at 2AM
    to resolve an incident in production.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都应该在你被叫醒并在凌晨2点被叫去解决生产中的事件时相对容易完成。
- en: Answering ad hoc questions
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回答即兴问题
- en: I might want to understand whether users from Redmond, WA, who purchased a product
    from my website are experiencing longer delivery times than usual and why – because
    of the shipment company, rain, cloud provider issues in this region, or anything
    else.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能想知道来自华盛顿州雷德蒙德的用户是否在购买我的网站上的产品时经历了比平时更长的配送时间，以及原因——是因为运输公司、雨水、该地区的云服务提供商问题，或其他任何原因。
- en: It should not be required to add more telemetry to answer most of the usage
    or performance questions. Occasionally, you’d need to add a new context property
    or an event, but it should be rare on a stable code path.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要添加更多遥测来回答大多数使用或性能问题。偶尔，你可能需要添加一个新的上下文属性或事件，但在稳定的代码路径上这应该是罕见的。
- en: Self-documenting systems
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自文档化系统
- en: Modern systems are dynamic – with continuous deployments, feature flag changes
    in runtime, and dozens of external dependencies with their own instabilities,
    nobody can know everything.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统是动态的——随着持续部署、运行时功能标志的变化以及数十个具有自己不稳定性的外部依赖项，没有人能知道一切。
- en: Telemetry becomes your single source of truth. Assuming it has enough context
    and common semantics, an observability vendor should be able to visualize it reasonably
    well.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 遥测成为你唯一的真相来源。假设它有足够的上下文和通用语义，一个可观测性供应商应该能够合理地可视化它。
- en: Auto-instrumentation
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动仪器化
- en: It’s difficult to instrument everything in your system – it’s repetitive, error-prone,
    and hard to keep up to date, test, and enforce common schema and semantics. We
    need shared instrumentations for common libraries, while we would only add application-specific
    telemetry and context.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的系统中为所有事物进行仪器化是困难的——它是重复的、易出错的，并且难以保持最新、测试和强制执行通用的模式和语义。我们需要为常见的库共享仪器化，而我们会仅添加特定于应用程序的遥测和上下文。
- en: With an understanding of these requirements, we will move on to distributed
    tracing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了这些要求后，我们将继续讨论分布式跟踪。
- en: Introducing distributed tracing
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍分布式跟踪
- en: '**Distributed tracing** is a technique that brings structure, correlation and
    causation to collected telemetry. It defines a special event called *span* and
    specifies causal relationships between spans. Spans follow common conventions
    that are used to visualize and analyze traces.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式跟踪**是一种将结构、关联和因果关系引入收集遥测的技术。它定义了一个特殊的事件称为*跨度*，并指定了跨度之间的因果关系。跨度遵循用于可视化和分析跟踪的通用约定。'
- en: Span
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨度
- en: 'A **span** describes an operation such as an incoming or outgoing HTTP request,
    a database call, an expensive I/O call, or any other interesting call. It has
    just enough structure to represent anything and still be useful. Here are the
    most important span properties:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨度**描述了一个操作，如入站或出站HTTP请求、数据库调用、昂贵的I/O调用或任何其他有趣的调用。它具有足够的结构来表示任何事物，同时仍然有用。以下是跨度最重要的属性：'
- en: The span’s name should describe the operation type in human-readable format,
    have low cardinality, and be human-readable.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨度的名称应以人类可读的格式描述操作类型，具有低基数，并且易于人类阅读。
- en: The span’s start time and duration.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨度的开始时间和持续时间。
- en: The status indicates success, failure, or no status.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态表示成功、失败或无状态。
- en: The span kind distinguishes the client, server, and internal calls, or the producer
    and consumer for async scenarios.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨度类型区分客户端、服务器和内部调用，或在异步场景中的生产者和消费者。
- en: Attributes (also known as tags or annotations) describe specific operations.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性（也称为标签或注释）描述特定的操作。
- en: Span context identifies spans and is propagated everywhere, enabling correlation.
    A parent span identifier is also included on child spans for causation.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨度上下文标识跨度并在各处传播，以实现关联。父跨度标识符也包含在子跨度中，以表示因果关系。
- en: Events provide additional information about operations within a span.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件提供了关于跨度内操作的其他信息。
- en: Links connect traces and spans when parent-child relationships don’t work –
    for example, for batching scenarios.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当父子关系不起作用时，链接将连接跟踪和跨度——例如，在批处理场景中。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In .NET, the tracing span is represented by `System.Diagnostics.Activity`. The
    `System.Span` class is not related to distributed tracing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，追踪跨度由 `System.Diagnostics.Activity` 表示。`System.Span` 类与分布式追踪无关。
- en: Relationships between spans
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨度之间的关系
- en: A span is a unit of tracing, and to trace more complex operations, we need multiple
    spans.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度是一个追踪的单位，为了追踪更复杂的操作，我们需要多个跨度。
- en: 'For example, a user may attempt to get an image and send a request to the service.
    The image is not cached, and the service requests it from the cold storage (as
    shown in *Figure 1**.1*):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户可能尝试获取一个图像并向服务发送请求。图像未缓存，服务从冷存储中请求它（如图 *图 1*.1 所示）：
- en: '![Figure 1.1 – A GET image request flow](img/B19423_01_01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – GET 图像请求流程](img/B19423_01_01.jpg)'
- en: Figure 1.1 – A GET image request flow
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – GET 图像请求流程
- en: 'To make this operation debuggable, we should report multiple spans:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此操作可调试，我们应该报告多个跨度：
- en: The incoming request
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传入的请求
- en: The attempt to get the image from the cache
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从缓存中获取图像的尝试
- en: Image retrieval from the cold storage
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从冷存储中检索图像
- en: Caching the image
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存图像
- en: These spans form a `trace-id`. Within the trace, each span is identified by
    `span-id`. Spans include a pointer to a parent span – it’s just their parent’s
    `span-id`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些跨度形成一个 `trace-id`。在追踪中，每个跨度由 `span-id` 标识。跨度包括指向父级跨度的指针——它只是父级的 `span-id`。
- en: '`trace-id`, `span-id`, and `parent-span-id` allow us to not only correlate
    spans but also record relationships between them. For example, in *Figure 1**.2*,
    we can see that Redis `GET`, `SETEX`, and `HTTP GET` spans are siblings and the
    incoming request is their parent:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace-id`、`span-id` 和 `parent-span-id` 允许我们不仅关联跨度，而且记录它们之间的关系。例如，在 *图 1*.2
    中，我们可以看到 Redis `GET`、`SETEX` 和 `HTTP GET` 跨度是兄弟，而传入的请求是它们的父级：'
- en: '![Figure 1.2 – Trace visualization showing relationships between spans](img/B19423_01_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 展示跨度之间关系的追踪可视化](img/B19423_01_02.jpg)'
- en: Figure 1.2 – Trace visualization showing relationships between spans
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 展示跨度之间关系的追踪可视化
- en: Spans can have more complicated relationships, which we’ll talk about later
    in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098), *Tracing* *Your Code*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度可以具有更复杂的关系，我们将在后面的 [*第 6 章*](B19423_06.xhtml#_idTextAnchor098) *追踪您的代码* 中讨论。
- en: '`trace-id` and `span-id`) enables even more interesting cross-signal scenarios.
    For example, you can stamp parent span context on logs (spoiler: just configure
    `ILogger` to do it) and you can correlate logs to traces. For example, if you
    use `ConsoleProvider`, you will see something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace-id` 和 `span-id`) 使得跨信号场景更加有趣。例如，您可以在日志上标记父级跨度上下文（剧透：只需配置 `ILogger` 即可）并将日志与追踪相关联。例如，如果您使用
    `ConsoleProvider`，您将看到如下内容：'
- en: '![Figure 1.3 – Logs include span context and can be correlated to other signals](img/B19423_01_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 日志包括跨度上下文，可以与其他信号相关联](img/B19423_01_03.jpg)'
- en: Figure 1.3 – Logs include span context and can be correlated to other signals
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 日志包括跨度上下文，可以与其他信号相关联
- en: You could also link metrics to traces using exemplars – metric metadata containing
    the trace context of operations that contributed to a recorded measurement. For
    instance, you can check examples of spans that correspond to the long tail of
    your latency distribution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用示例将度量与追踪相关联——包含对记录测量有贡献的操作的追踪上下文的度量元数据。例如，您可以检查与您延迟分布长尾对应的跨度示例。
- en: Attributes
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: '**Span attributes** are a property bag that contains details about the operation.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨度属性**是一个包含关于操作详细信息的属性包。'
- en: Span attributes should describe this specific operation well enough to understand
    what happened. OpenTelemetry semantic conventions specify attributes for popular
    technologies to help with this, which we’ll talk about in the *Ensuring consistency
    and structure* section later in this chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度属性应该足够详细地描述这个特定的操作，以便理解发生了什么。OpenTelemetry 语义约定指定了用于帮助此目的的属性，我们将在本章后面的 *确保一致性和结构*
    部分讨论。
- en: 'For example, an incoming HTTP request is identified with at least the following
    attributes: the HTTP method, path, query, API route, and status code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个传入的 HTTP 请求至少由以下属性标识：HTTP 方法、路径、查询、API 路由和状态码：
- en: '![Figure 1.4 – The HTTP server span attributes](img/B19423_01_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – HTTP 服务器跨度属性](img/B19423_01_04.jpg)'
- en: Figure 1.4 – The HTTP server span attributes
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – HTTP 服务器跨度属性
- en: Instrumentation points
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪器化点
- en: 'So, we have defined a span and its properties, but when should we create spans?
    Which attributes should we put on them? While there is no strict standard to follow,
    here’s the rule of thumb:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经定义了跨度及其属性，但我们应该在何时创建跨度？我们应该在它们上放置哪些属性？虽然没有严格的遵循标准，但以下是一些经验法则：
- en: '*Create a new span for every incoming and outgoing network call and use standard
    attributes for the protocol or technology* *whenever available.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*为每个传入和传出的网络调用创建一个新的跨度，并在可用时使用协议或技术的标准属性。*'
- en: 'This is what we’ve done previously with the memes example, and it allows us
    to see what happened on the service boundaries and detect common problems: dependency
    issues, status, latency, and errors on each service. This also allows us to correlate
    logs, events, and anything else we collect. Plus, observability backends are aware
    of HTTP semantics and will know how to interpret and visualize your spans.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们之前在 memes 示例中做过的事情，它使我们能够看到在服务边界上发生了什么，并检测到常见问题：依赖性问题、状态、延迟以及每个服务的错误。这也使我们能够关联日志、事件以及我们收集的任何其他内容。此外，可观察性后端了解
    HTTP 语义，并将知道如何解释和可视化您的跨度。
- en: There are exceptions to this rule, such as socket calls, where requests could
    be too small to be instrumented. In other cases, you might still be rightfully
    concerned with verbosity and the volume of generated data – we’ll see how to control
    it with sampling in [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083), *Configuration
    and* *Control Plane*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则有一些例外，例如套接字调用，其中请求可能太小而无法进行仪器化。在其他情况下，您可能仍然会合理地关注冗长性和生成数据的量——我们将在 [*第 5
    章*](B19423_05.xhtml#_idTextAnchor083) *配置和控制平面* 中看到如何通过采样来控制它。
- en: Tracing – building blocks
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪 - 构建块
- en: Now that you are familiar with the core concepts of tracing and its methodology,
    let’s talk about implementation. We need a set of convenient APIs to create and
    enrich spans and pass context around. Historically, every **Application Performance
    Monitoring** (**APM**) tool had its own SDKs to collect telemetry with their own
    APIs. Changing the APM vendor meant rewriting all your instrumentation code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了跟踪的核心概念及其方法论，让我们来谈谈实现。我们需要一组方便的 API 来创建和丰富跨度，并在周围传递上下文。历史上，每个 **应用性能监控**（**APM**）工具都有自己的
    SDK，用于使用它们自己的 API 收集遥测数据。更换 APM 供应商意味着重写所有的仪器代码。
- en: OpenTelemetry solves this problem – it’s a cross-language telemetry platform
    for tracing, metrics, events, and logs that unifies telemetry collection. Most
    of the APM tools, log management, and observability backends support OpenTelemetry,
    so you can change vendors without rewriting any instrumentation code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 解决了这个问题——它是一个跨语言的遥测平台，用于跟踪、指标、事件和日志，统一了遥测收集。大多数 APM 工具、日志管理和可观察性后端都支持
    OpenTelemetry，因此您可以在不重写任何仪器代码的情况下更换供应商。
- en: .NET tracing implementation conforms to the OpenTelemetry API specification,
    and in this book, .NET tracing APIs and OpenTelemetry APIs are used interchangeably.
    We’ll talk about the difference between them in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098),
    *Tracing* *Your Code*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 跟踪实现符合 OpenTelemetry API 规范，在这本书中，.NET 跟踪 API 和 OpenTelemetry API 是可以互换使用的。我们将在
    [*第 6 章*](B19423_06.xhtml#_idTextAnchor098) *跟踪您的代码* 中讨论它们之间的区别。
- en: Even though OpenTelemetry primitives are baked into .NET and the instrumentation
    code does not depend on them, to collect telemetry from the application, we still
    need to add the **OpenTelemetry SDK**, which has everything we need to configure
    a collection and an exporter. You might as well write your own solution compatible
    with .NET tracing APIs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 OpenTelemetry 基本原语已嵌入 .NET 中，且仪器代码不依赖于它们，但为了从应用程序中收集遥测数据，我们仍然需要添加 **OpenTelemetry
    SDK**，它包含我们配置收集和导出器所需的一切。您也可以编写自己的与 .NET 跟踪 API 兼容的解决方案。
- en: OpenTelemetry became an industry standard for tracing and beyond; it’s available
    in multiple languages, and in addition to a unified collection of APIs it provides
    configurable SDKs and a standard wire format for the telemetry – **OpenTelemetry
    protocol** (**OTLP**). You can send telemetry to any compatible vendor, either
    by adding a specific exporter or, if the backend supports OTLP, by configuring
    the vendor’s endpoint.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 成为了跟踪及其他领域的行业标准；它支持多种语言，除了提供统一的 API 集合外，它还提供了可配置的 SDK 和遥测的标准线格式——**OpenTelemetry
    协议**（**OTLP**）。您可以通过添加特定的导出器或将后端配置为支持 OTLP，将遥测数据发送到任何兼容的供应商。
- en: As shown in *Figure 1**.5*, the application configures the OpenTelemetry SDK
    to export telemetry to the observability backend. Application code, .NET libraries,
    and various instrumentations use .NET tracing APIs to create spans, which the
    OpenTelemetry SDK listens to, processes, and forwards to an exporter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 1**.5* 所示，应用程序配置 OpenTelemetry SDK 以将遥测数据导出到可观察性后端。应用程序代码、.NET 库和各种仪器化使用
    .NET 跟踪 API 创建跨度，OpenTelemetry SDK 会监听、处理并将它们转发到导出器。
- en: '![Figure 1.5 – Tracing building blocks](img/B19423_01_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 跟踪构建块](img/B19423_01_05.jpg)'
- en: Figure 1.5 – Tracing building blocks
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 跟踪构建块
- en: So, OpenTelemetry decouples instrumentation code from the observability vendor,
    but it does much more than that. Now, different applications can share instrumentation
    libraries and observability vendors have unified and structured telemetry on top
    of which they can build rich experiences.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，OpenTelemetry 将仪器化代码与可观察性供应商解耦，但它做的远不止这些。现在，不同的应用程序可以共享仪器化库，可观察性供应商可以在其之上构建丰富的体验。
- en: Instrumentation
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪器化
- en: 'Historically, all APM vendors had to instrument popular libraries: HTTP clients,
    web frameworks, Entity Framework, SQL clients, Redis client libraries, RabbitMQ,
    cloud providers’ SDKs, and so on. That did not scale well. But with .NET tracing
    APIs and OpenTelemetry semantics, instrumentation became common for all vendors.
    You can find a growing list of shared community instrumentations in the OpenTelemetry
    Contrib repo: [https://github.com/open-telemetry/opentelemetry-dotnet-contrib](https://github.com/open-telemetry/opentelemetry-dotnet-contrib).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，所有 APM 供应商都必须对流行的库进行仪器化：HTTP 客户端、Web 框架、Entity Framework、SQL 客户端、Redis
    客户端库、RabbitMQ、云提供商的 SDK 等。这并不容易扩展。但有了 .NET 跟踪 API 和 OpenTelemetry 语义，仪器化对所有供应商都变得普遍。你可以在
    OpenTelemetry Contrib 仓库中找到一个不断增长的共享社区仪器化列表：[https://github.com/open-telemetry/opentelemetry-dotnet-contrib](https://github.com/open-telemetry/opentelemetry-dotnet-contrib)。
- en: Moreover, since OpenTelemetry is a vendor-neutral standard and baked into .NET,
    it’s now possible for libraries to implement native instrumentation – HTTP and
    gRPC clients, ASP.NET Core, and several other libraries support it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 OpenTelemetry 是一个供应商中立的标准化方案，并且已经集成到 .NET 中，现在库可以实现原生仪器化——HTTP 和 gRPC
    客户端、ASP.NET Core 以及其他几个库都支持它。
- en: Even with native tracing support, it’s off by default – you need to install
    and register specific instrumentation (which we’ll cover in [*Chapter 2*](B19423_02.xhtml#_idTextAnchor038),
    *Native Monitoring in .NET*). Otherwise, tracing code does nothing and, thus,
    does not add any performance overhead.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有原生跟踪支持，默认情况下也是关闭的——你需要安装和注册特定的仪器（我们将在 [*第 2 章*](B19423_02.xhtml#_idTextAnchor038)
    中介绍，*Native Monitoring in .NET*）。否则，跟踪代码将不起作用，因此不会增加任何性能开销。
- en: Backends
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: The **observability backend** (aka monitoring, APM tool, and log management
    system) is a set of tools responsible for ingestion, storage, indexing, visualization,
    querying, and probably other things that help you monitor your system, investigate
    issues, and analyze performance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察性后端**（也称为监控、APM 工具和日志管理系统）是一组负责摄取、存储、索引、可视化、查询以及可能帮助您监控系统、调查问题和分析性能的其他工具。'
- en: '**Observability vendors** build these tools and provide rich user experiences
    to help you use traces along with other signals.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察性供应商**构建这些工具，并提供丰富的用户体验，帮助你使用跟踪以及其他信号。'
- en: Collecting traces for common libraries became easy with the OpenTelemetry ecosystem.
    As you’ll see in [*Chapter 2*](B19423_02.xhtml#_idTextAnchor038), *Native Monitoring
    in .NET*, most of it can be done automatically with just a few lines of code at
    startup. But how do we use them?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry 生态系统收集常见库的跟踪变得容易。正如你在 [*第 2 章*](B19423_02.xhtml#_idTextAnchor038)
    中将看到的，*Native Monitoring in .NET*，大部分工作都可以在启动时通过几行代码自动完成。但我们是怎样使用它们的呢？
- en: While you can send spans to `stdout` and store them on the filesystem, this
    would not leverage all tracing benefits. Traces can be huge, but even when they
    are small, grepping them is not convenient.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可以将跨度发送到 `stdout` 并将它们存储在文件系统中时，这并不会充分利用所有跟踪的优势。跟踪数据可能非常大，即使它们很小，使用 `grep`
    来搜索它们也不方便。
- en: 'Tracing visualizations (such as a Gantt chart, trace viewer, or trace timeline)
    is one of the common features tracing providers have. *Figure 1**.6* shows a trace
    timeline in Jaeger – an open source distributed tracing platform:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪可视化（如甘特图、跟踪查看器或跟踪时间线）是跟踪提供者常见的功能之一。*图 1**.6* 展示了 Jaeger 中的跟踪时间线——一个开源的分布式跟踪平台：
- en: "![Figure 1.6 – Trace visualization in Jaeger\uFEFF with errors marked with\
    \ exclamation point](img/B19423_01_06.jpg)"
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 在Jaeger中标记感叹号显示错误的跟踪可视化](img/B19423_01_06.jpg)'
- en: Figure 1.6 – Trace visualization in Jaeger with errors marked with exclamation
    point
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 在Jaeger中标记感叹号显示错误的跟踪可视化
- en: While it may take a while to find an error log, the visualization shows what’s
    important – where failures are, latency, and a sequence of steps. As we can see
    in *Figure 1**.6*, the frontend call failed because of failure on the storage
    side, which we can further drill into.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然找到错误日志可能需要一段时间，但可视化显示了重要的信息——失败的位置、延迟和步骤序列。正如我们在*图1.6*中可以看到的那样，前端调用失败是因为存储端的问题，我们可以进一步深入调查。
- en: However, we can also see that the frontend made four consecutive calls into
    storage, which potentially could be done in parallel to speed things up.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以看到前端对存储进行了四次连续调用，这可能会并行执行以加快速度。
- en: 'Another common feature is filtering or querying by any of the span properties
    such as name, `trace-id`, `span-id`, `parent-id`, name, attribute name, status,
    timestamp, duration, or anything else. An example of such a query is shown in
    *Figure 1**.7*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见功能是通过span的任何属性进行过滤或查询，例如名称、`trace-id`、`span-id`、`parent-id`、名称、属性名称、状态、时间戳、持续时间或任何其他内容。*图1.7*中显示了此类查询的一个示例：
- en: '![Figure 1.7 – A custom Azure Monitor query that calculates the Redis hit rate](img/B19423_01_07.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 计算Redis命中率的自定义Azure Monitor查询](img/B19423_01_07.jpg)'
- en: Figure 1.7 – A custom Azure Monitor query that calculates the Redis hit rate
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 计算Redis命中率的自定义Azure Monitor查询
- en: For example, we don’t report a metric for the cache hit rate, but we can estimate
    it from traces. While they’re not precise because of sampling and might be more
    expensive to query than metrics, we can still do it ad hoc, especially when we
    investigate specific failures.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们不报告缓存命中率的指标，但我们可以从跟踪中估计它。虽然由于采样它们可能不够精确，并且可能比指标查询更昂贵，但我们仍然可以临时这样做，尤其是在我们调查特定故障时。
- en: Since traces, metrics, and logs are correlated, you will fully leverage observability
    capabilities if your vendor supports multiple signals or integrates well with
    other tools.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跟踪、指标和日志是相关的，如果你的供应商支持多个信号或与其他工具良好集成，你将充分利用可观察性功能。
- en: Reviewing context propagation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查上下文传播
- en: Correlation and causation are the foundation of distributed tracing. We’ve just
    covered how related spans share the same `trace-id` and have a pointer to the
    parent recorded in `parent-span-id`, forming a casual chain of operations. Now,
    let’s explore how it works in practice.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性和因果关系是分布式跟踪的基础。我们刚刚介绍了相关span如何共享相同的`trace-id`，并在`parent-span-id`中记录指向父span的指针，形成一个操作因果链。现在，让我们探索它在实际中的工作方式。
- en: In-process propagation
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程内传播
- en: Even within a single service, we usually have nested spans. For example, if
    we trace a request to a REST service that just reads an item from a database,
    we’d want to see at least two spans – one for an incoming HTTP request and another
    for a database query. To correlate them properly, we need to pass span context
    from ASP.NET Core to the database driver.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在单个服务中，我们通常也有嵌套的span。例如，如果我们跟踪一个请求到只从数据库读取项目的REST服务，我们至少想要看到两个span——一个用于传入的HTTP请求，另一个用于数据库查询。为了正确关联它们，我们需要从ASP.NET
    Core传递span上下文到数据库驱动程序。
- en: One option is to pass context explicitly as a function argument. It’s a viable
    solution in Go, where explicit context propagation is a standard, but in .NET,
    it would make onboarding onto distributed tracing difficult and would ruin the
    auto-instrumentation magic.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是显式地将上下文作为函数参数传递。在Go中，这是一个可行的解决方案，因为显式上下文传播是一个标准，但在.NET中，它会使分布式跟踪的入门变得困难，并破坏自动化的魔法。
- en: .NET Activity (aka the span) is propagated implicitly. Current activity can
    always be accessed via the `Activity.Current` property, backed up by `System.Threading.AsyncLocal<T>`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Activity（也称为span）是隐式传播的。当前活动可以通过`Activity.Current`属性访问，该属性由`System.Threading.AsyncLocal<T>`支持。
- en: Using our previous example of a service reading from the database, ASP.NET Core
    creates an Activity for the incoming request, and it becomes current for anything
    that happens within the scope of this request. Instrumentation for the database
    driver creates another one that uses `Activity.Current` as its parent, without
    knowing anything about ASP.NET Core and without the user application passing the
    Activity around. The logging framework would stamp `trace-id` and `span-id` from
    `Activity.Current`, if configured to do so.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前的例子，一个从数据库读取的服务，ASP.NET Core 为入站请求创建一个 Activity，并且它成为此请求范围内发生的任何事情的当前
    Activity。数据库驱动程序的仪器创建另一个使用 `Activity.Current` 作为其父级的 Activity，而不了解 ASP.NET Core，并且用户应用程序没有传递
    Activity。如果配置为这样做，日志框架会在 `Activity.Current` 上盖章 `trace-id` 和 `span-id`。
- en: It works for sync or async code, but if you process items in the background
    using in-memory queues or manipulate with threads explicitly, you would have to
    help runtime and propagate activities explicitly. We’ll talk more about it in
    [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098), *Tracing* *Your Code*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它适用于同步或异步代码，但如果你在后台使用内存队列处理项目或显式地使用线程进行操作，你将不得不帮助运行时并显式传播活动。我们将在 [*第 6 章*](B19423_06.xhtml#_idTextAnchor098)，*跟踪你的代码*
    中更多地讨论这个问题。
- en: Out-of-process propagation
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程外传播
- en: In-process correlation is awesome, and for monolith applications, it would be
    almost sufficient. But in the microservice world, we need to trace requests end
    to end and, therefore, propagate context over the wire, and here’s where standards
    come into play.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 进程内关联很棒，对于单体应用程序来说，几乎足够。但在微服务世界中，我们需要端到端跟踪请求，因此需要在网络上传播上下文，这就是标准发挥作用的地方。
- en: You can find multiple practices in this space – every complex system used to
    support something custom, such as `x-correlation-id` or `x-request-id`. You can
    find `x-cloud-trace-context` or `grpc-trace-bin` in old Google systems, `X-Amzn-Trace-Id`
    on AWS, and `Request-Id` variations and `ms-cv` in the Microsoft ecosystem. Assuming
    your system is heterogeneous and uses a variety of cloud providers and tracing
    tools, correlation is difficult.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域你可以找到多种实践——每个用于支持自定义内容的复杂系统，例如 `x-correlation-id` 或 `x-request-id`。在旧版
    Google 系统中可以找到 `x-cloud-trace-context` 或 `grpc-trace-bin`，在 AWS 上可以找到 `X-Amzn-Trace-Id`，在
    Microsoft 生态系统中可以找到 `Request-Id` 变体和 `ms-cv`。假设你的系统是异构的，并使用各种云提供商和跟踪工具，关联变得困难。
- en: Trace context (which you can explore in more detail at [https://www.w3.org/TR/trace-context](https://www.w3.org/TR/trace-context))
    is a relatively new standard, converting context propagation over HTTP, but it’s
    widely adopted and used by default in OpenTelemetry and .NET.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪上下文（你可以在 [https://www.w3.org/TR/trace-context](https://www.w3.org/TR/trace-context)
    上更详细地了解）是一个相对较新的标准，它将 HTTP 上的上下文传播转换为标准，但它被广泛采用，并在 OpenTelemetry 和 .NET 中默认使用。
- en: W3C Trace Context
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: W3C 跟踪上下文
- en: The trace context standard defines `traceparent` and `tracestate` HTTP headers
    and the format to populate context on them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪上下文标准定义了 `traceparent` 和 `tracestate` HTTP 头以及填充它们的格式。
- en: The traceparent header
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跟踪上下文头
- en: 'The `traceparent` is an HTTP request header that carries the protocol version,
    `trace-id`, `parent-id`, and `trace-flags` in the following format:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceparent` 是一个 HTTP 请求头，它以以下格式携带协议版本、`trace-id`、`parent-id` 和 `trace-flags`：'
- en: '[PRE1]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`version`: The protocol version – only `00` is defined at the moment.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：协议版本——目前只定义了 `00`。'
- en: '`trace-id`: The logical end-to-end operation ID.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace-id`：逻辑端到端操作 ID。'
- en: '`parent-id`: Identifies the client span and serves as a parent for the corresponding
    server span.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent-id`：标识客户端 span 并作为相应服务器 span 的父级。'
- en: '`trace-flags`: Represents the sampling decision (which we’ll talk about in
    [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083), *Configuration and Control Plane*).
    For now, we can determine that `00` indicates that the parent span was sampled
    out and `01` means it was sampled in.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace-flags`：表示采样决策（我们将在 [*第 5 章*](B19423_05.xhtml#_idTextAnchor083)，*配置和控制平面*
    中讨论）。现在我们可以确定 `00` 表示父 span 被采样出来，而 `01` 表示它被采样进来。'
- en: 'All identifiers must be present – that is, `traceparent` has a fixed length
    and is easy to parse. *Figure 1**.8* shows an example of context propagation with
    the `traceparent` header:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标识符都必须存在——也就是说，`traceparent` 有一个固定的长度，易于解析。*图 1**.8* 展示了使用 `traceparent` 头的上下文传播示例：
- en: '![Figure 1.8 – traceparent is populated from the outgoing span context and
    becomes a parent for the incoming span](img/B19423_01_08.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – traceparent 从出站 span 上下文中填充并成为入站 span 的父级](img/B19423_01_08.jpg)'
- en: Figure 1.8 – traceparent is populated from the outgoing span context and becomes
    a parent for the incoming span
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – `traceparent` 从出站跨度上下文中填充并成为入站跨度的父级
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The protocol does not require creating spans and does not specify instrumentation
    points. Common practice is to create spans per outgoing and incoming requests,
    and put client span context into request headers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议不要求创建跨度，也不指定仪器点。常见的做法是针对每个出站和入站请求创建跨度，并将客户端跨度上下文放入请求头部。
- en: The tracestate header
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跟踪状态头部
- en: The `tracestate` is another request header, which carries additional context
    for the tracing tool to use. It’s *designed for OpenTelemetry or an APM tool to
    carry additional control information and not for application-specific context*
    (covered in detail later in the *Baggage* section).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracestate` 是另一个请求头，它为跟踪工具提供了额外的上下文。它是**为 OpenTelemetry 或 APM 工具携带额外的控制信息而设计的，而不是为特定应用程序的上下文**（在后面的
    *Baggage* 部分中详细说明）。'
- en: 'The `tracestate` consists of a list of key-value pairs, serialized to a string
    with the following format: `"vendor1=value1,vendor2=value2"`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracestate` 由一系列键值对组成，序列化为以下格式的字符串：`"vendor1=value1,vendor2=value2"`。'
- en: The `tracestate` can be used to propagate incompatible legacy correlation IDs,
    or some additional identifiers vendor needs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracestate` 可以用来传播不兼容的旧版关联 ID，或者供应商需要的某些附加标识符。'
- en: 'OpenTelemetry, for example, uses it to carry a sampling probability and score.
    For example, `tracestate: "ot=r:3;p:2"` represents a key-value pair, where the
    key is `ot` (OpenTelemetry tag) and the value is `r:3;p:2`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，OpenTelemetry 使用它来携带采样概率和分数。例如，`tracestate: "ot=r:3;p:2"` 表示一个键值对，其中键是 `ot`（OpenTelemetry
    标签），值是 `r:3;p:2`。'
- en: The `tracestate` header has a soft limitation on size (512 characters) and can
    be truncated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracestate` 头部有一个软限制在大小（512 个字符）上，并且可以被截断。'
- en: The traceresponse (draft) header
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: traceresponse（草案）头部
- en: Unlike `traceparent` and `tracestate`, **traceresponse** is a response header.
    At the time of writing, it’s defined in W3C Trace-Context Level 2 ([https://www.w3.org/TR/trace-context-2/](https://www.w3.org/TR/trace-context-2/))
    and has reached W3C Editor’s Draft status. There is no support for it in .NET
    or OpenTelemetry.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `traceparent` 和 `tracestate` 不同，**traceresponse** 是一个响应头。在撰写本文时，它由 W3C Trace-Context
    Level 2 定义（[https://www.w3.org/TR/trace-context-2/](https://www.w3.org/TR/trace-context-2/）），并达到了
    W3C 编辑草案状态。在 .NET 或 OpenTelemetry 中没有对其的支持。
- en: '`traceresponse` is very similar to `traceparent`. It has the same format, but
    instead of client-side identifiers, it returns the `trace-id` and `span-id` values
    of the server span:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceresponse` 非常类似于 `traceparent`。它具有相同的格式，但不是客户端标识符，而是返回服务器跨度的 `trace-id`
    和 `span-id` 值：'
- en: '[PRE2]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`traceresponse` is optional in the sense that the server does not need to return
    it, even if it supports W3C Trace-Context Level 2\. It’s useful to return `traceresponse`
    when the client did not pass a valid `traceparent`, but can log `traceresponse`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceresponse` 是可选的，从某种意义上说，服务器不需要返回它，即使它支持 W3C Trace-Context Level 2。当客户端没有传递有效的
    `traceparent` 时，返回 `traceresponse` 是有用的，但可以记录 `traceresponse`。'
- en: External-facing services may decide to start a new trace, because they don’t
    trust the caller’s `trace-id` generation algorithm. Uniform random distribution
    is one concern; another reason could be a special `trace-id` format. If the service
    restarts a trace, it’s a good idea to return the `traceresponse` header to caller.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 面向外部服务的可能决定开始一个新的跟踪，因为他们不相信调用者的 `trace-id` 生成算法。均匀随机分布是一个担忧；另一个原因可能是特殊的 `trace-id`
    格式。如果服务重新启动跟踪，返回 `traceresponse` 头部给调用者是一个好主意。
- en: B3
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B3
- en: The B3 specification ([https://github.com/openzipkin/b3-propagation](https://github.com/openzipkin/b3-propagation))
    was adopted by Zipkin – one of the first distributed tracing systems.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: B3 规范（[https://github.com/openzipkin/b3-propagation](https://github.com/openzipkin/b3-propagation)）被
    Zipkin – 分布式跟踪系统之一所采用。
- en: 'B3 identifiers can be propagated as a single `b3` header in the following format:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: B3 标识符可以以以下格式的单个 `b3` 头部进行传播：
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another way is to pass individual components, using `X-B3-TraceId`, `X-B3-SpanId`,
    `X-B3-ParentSpanId`, and `X-B3-Sampled`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `X-B3-TraceId`、`X-B3-SpanId`、`X-B3-ParentSpanId` 和 `X-B3-Sampled` 传递单个组件。
- en: The sampling state suggests whether a service should trace the corresponding
    request. In addition to `0` (don’t record) and `1` (do record), it allows us to
    force tracing with a flag set to `d`. It’s usually done for debugging purposes.
    The sampling state can be passed without other identifiers to specify the desired
    sampling decision to the service.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 样本状态表示服务是否应该跟踪相应的请求。除了 `0`（不记录）和 `1`（记录）之外，它还允许我们通过将标志设置为 `d` 来强制跟踪。这通常用于调试目的。样本状态可以在没有其他标识符的情况下传递，以指定服务所需的采样决策。
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The key difference with W3C Trace-Context, beyond header names, is the presence
    of both `span-id` and `parent-span-id`. B3 systems can use the same `span-id`
    on the client and server sides, creating a single span for both.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与 W3C Trace-Context 的关键区别，除了头部名称之外，还在于同时存在 `span-id` 和 `parent-span-id`。B3 系统可以在客户端和服务器端使用相同的
    `span-id`，为两者创建单个跨度。
- en: 'Zipkin reuses `span-id` from the incoming request, also specifying `parent-span-id`
    on it. The Zipkin span represents the client and server at the same time, as shown
    in *Figure 1**.9*, recording different durations and statuses for them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin 重用来自传入请求的 `span-id`，并在其上指定 `parent-span-id`。Zipkin 的跨度同时表示客户端和服务器，如图
    *图 1**.9* 所示，记录它们的不同持续时间和状态：
- en: '![Figure 1.9 – Zipkin creates one span to represent the client and server](img/B19423_01_09.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – Zipkin 创建一个跨度来表示客户端和服务器](img/B19423_01_09.jpg)'
- en: Figure 1.9 – Zipkin creates one span to represent the client and server
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – Zipkin 创建一个跨度来表示客户端和服务器
- en: OpenTelemetry and .NET support `b3` headers but ignore `parent-span-id` – they
    generate a new `span-id` for every span, as it’s not possible to reuse `span-id`
    (see *Figure 1**.10*).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 和 .NET 支持 `b3` 头部，但忽略 `parent-span-id` – 它为每个跨度生成一个新的 `span-id`，因为不可能重用
    `span-id`（见 *图 1**.10*）。
- en: '![Figure 1.10 – OpenTelemetry does not use parent-span-id from B3 headers and
    creates different spans for the client and server](img/B19423_01_10.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – OpenTelemetry 不使用 B3 头部中的父跨度 ID，并为客户端和服务器创建不同的跨度](img/B19423_01_10.jpg)'
- en: Figure 1.10 – OpenTelemetry does not use parent-span-id from B3 headers and
    creates different spans for the client and server
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – OpenTelemetry 不使用 B3 头部中的父跨度 ID，并为客户端和服务器创建不同的跨度
- en: Baggage
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行李
- en: So far, we have talked about span context and correlation. But in many cases,
    distributed systems have application-specific context. For example, you authorize
    users on your frontend service, and after that, `user-id` is not needed for application
    logic, but you still want to add it as an attribute on spans from all services
    to query and aggregate it on a per-user basis.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了跨度上下文和关联。但在许多情况下，分布式系统具有特定于应用程序的上下文。例如，你在前端服务上授权用户，之后，`user-id` 对于应用程序逻辑不再需要，但你仍然希望将其作为属性添加到所有服务的跨度中，以便按用户查询和汇总。
- en: You can stamp `user-id` once on the frontend. Then, spans recorded on the backend
    will not have `user-id`, but they will share the same `trace-id` as the frontend.
    So, with some joins in your queries, you can still do per-user analysis. It works
    to some extent but may be expensive or slow, so you might decide to propagate
    `user-id` and stamp it on the backend spans too.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前端一次性标记 `user-id`。然后，后端记录的跨度将不会有 `user-id`，但它们将与前端共享相同的 `trace-id`。因此，通过在查询中进行一些连接，你仍然可以进行按用户分析。这在某种程度上是可行的，但可能成本高昂或速度较慢，因此你可能决定传播
    `user-id` 并将其标记在后台跨度上。
- en: The **baggage** ([https://www.w3.org/TR/baggage/](https://www.w3.org/TR/baggage/))
    defines a generic propagation format for distributed context, and you can use
    it for business logic or anything else by adding, reading, removing, and modifying
    baggage members. For example, you can route requests to the test environment and
    pass feature flags or extra telemetry context.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**行李** ([https://www.w3.org/TR/baggage/](https://www.w3.org/TR/baggage/)) 定义了分布式上下文的通用传播格式，你可以通过添加、读取、删除和修改行李成员来使用它进行业务逻辑或其他任何事情。例如，你可以将请求路由到测试环境，并传递功能标志或额外的遥测上下文。'
- en: Baggage consists of a list of semicolon-separated members. Each member has a
    key, value, and optional properties in the following formats – `key=value;property1;key2=property2`
    or `key=value;property1;key2=property2,anotherKey=anotherValue`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 行李由一系列分号分隔的成员组成。每个成员都有一个键、值以及以下格式的可选属性 – `key=value;property1;key2=property2`
    或 `key=value;property1;key2=property2,anotherKey=anotherValue`。
- en: OpenTelemetry and .NET only propagate baggage, but don’t stamp it on any telemetry.
    You can configure `ILogger` to stamp baggage and need to enrich traces explicitly.
    We’ll see how it works in [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083), *Configuration
    and* *Control Plane*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry和.NET只传播行李，但不会在遥测上盖章。您可以将`ILogger`配置为盖章行李，并需要显式丰富跟踪。我们将在[*第5章*](B19423_05.xhtml#_idTextAnchor083)“配置和控制平面”中看到它是如何工作的。
- en: Tip
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should not put any sensitive information in baggage, as it’s almost impossible
    to guarantee where it would flow – your application or sidecar infrastructure
    can forward it to your cloud provider or anywhere else.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应在行李中放置任何敏感信息，因为它几乎不可能保证它会流向何处——您的应用程序或边车基础设施可以将其转发到您的云提供商或任何其他地方。
- en: Maintain a list of well-known baggage keys across your system and only use known
    ones, as you might receive baggage from another system otherwise.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统中维护一个已知的行李键列表，并且只使用已知的键，否则您可能会收到来自另一个系统的行李。
- en: Baggage specification has a *working draft* status and may still change.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 行李规范处于*工作草案*状态，可能还会发生变化。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: While the W3C Trace Context standard is HTTP-specific and B3 applies to any
    RPC calls, they are commonly used for any context propagation needs – for example,
    they are passed as the event payload in messaging scenarios. This may change once
    protocol-specific standards are introduced.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然W3C跟踪上下文标准是针对HTTP的，而B3适用于任何RPC调用，但它们通常用于任何上下文传播需求——例如，在消息场景中，它们作为事件有效负载传递。一旦引入了特定协议的标准，这可能会改变。
- en: Ensuring consistency and structure
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保一致性和结构
- en: As we already defined, spans are structured events describing interesting operations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经定义的，跨度是描述有趣操作的有序事件。
- en: A span’s start time, duration, status, kind, and context are strongly typed
    – they enable correlation and causation, allowing us to visualize traces and detect
    failures or latency issues.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度的开始时间、持续时间、状态、类型和上下文是强类型的——它们使关联和因果关系成为可能，使我们能够可视化跟踪并检测失败或延迟问题。
- en: The span’s name and attributes describe an operation but are not strongly typed
    or strictly defined. If we don’t populate them in a meaningful way, we can detect
    an issue but have no knowledge of what actually happened.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度的名称和属性描述了一个操作，但不是强类型或严格定义的。如果我们不以有意义的方式填充它们，我们可以检测到问题，但无法了解实际发生了什么。
- en: 'For example, for client HTTP calls, beyond generic properties, we want to capture
    at least the URL, method, and response code (or exception) – if we don’t know
    any of these, we’re blind. Once we populate them, we can start doing some powerful
    analysis with queries over such spans to answer the following common questions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于客户端HTTP调用，除了通用属性之外，我们还想捕获至少URL、方法和响应代码（或异常）——如果我们不知道这些中的任何一项，我们就处于盲目的状态。一旦我们填充了它们，我们就可以开始使用查询此类跨度进行一些强大的分析，以回答以下常见问题：
- en: Which dependency calls were made in the scope of this request? Which of them
    failed? What was the latency of each of them?
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个请求的作用域内，哪些依赖项被调用？哪些失败了？它们的延迟是多少？
- en: Does my application make independent dependency calls in parallel or sequentially?
    Does it make any unnecessary requests when they can be done lazily?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的应用程序是并行还是顺序地独立调用依赖项？当可以延迟执行时，它是否发出任何不必要的请求？
- en: Are dependency endpoints configured correctly?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项端点是否配置正确？
- en: What are the success or error rates and latency per dependency API?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个依赖项API的成功或错误率和延迟是多少？
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: This analysis relies on an application using the same attributes for all HTTP
    dependencies. Otherwise, the operator that performs the queries will have a hard
    time writing and maintaining them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析依赖于一个应用程序使用相同的属性来处理所有HTTP依赖项。否则，执行查询的操作员将很难编写和维护它们。
- en: With unified and community-driven telemetry collection taken off the observability
    vendor’s plate, they can now fully focus on (semi-)automating analysis and giving
    us powerful performance and fault analysis tools.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将统一和社区驱动的遥测收集从可观察性供应商的盘子上拿掉后，他们现在可以完全专注于（半）自动化分析和提供强大的性能和故障分析工具。
- en: OpenTelemetry defines a set of semantic conventions for spans, traces, and resources,
    which we’ll talk more about in [*Chapter 9*](B19423_09.xhtml#_idTextAnchor148),
    *Best Practices*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry定义了一套关于跨度、跟踪和资源的语义约定，我们将在[*第9章*](B19423_09.xhtml#_idTextAnchor148)“最佳实践”中详细讨论。
- en: Building application topology
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序拓扑
- en: Distributed tracing, combined with semantic conventions, allows us to build
    visualizations such as an application map (aka service map), as shown in *Figure
    1**.11* – you could see your whole system along with key health metrics. It’s
    an entry point to any investigation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪，结合语义约定，使我们能够构建如图*图1.11*所示的应用程序图（也称为服务图），你可以看到整个系统以及关键的健康指标。它是任何调查的入口点。
- en: "![Figure 1.11 – An Azure Monitor \uFEFFapplication map for a meme service is\
    \ an up-to-date system diagram with all the basic health metrics](img/B19423_01_11.jpg)"
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11 – Azure Monitor为meme服务创建的应用程序图是一个包含所有基本健康指标的最新系统图](img/B19423_01_11.jpg)'
- en: Figure 1.11 – An Azure Monitor application map for a meme service is an up-to-date
    system diagram with all the basic health metrics
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – Azure Monitor为meme服务创建的应用程序图是一个包含所有基本健康指标的最新系统图
- en: Observability vendors depend on trace and metrics semantics to build service
    maps. For example, the presence of HTTP attributes on the client span represents
    an outgoing HTTP call, and we need to show the outgoing arrow to a new dependency
    node. We should name this node based on the span’s host attribute.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测性供应商依赖于跟踪和指标语义来构建服务图。例如，客户端跨度上存在HTTP属性表示一个出站的HTTP调用，我们需要显示指向新依赖节点的出站箭头。我们应该根据跨度的主机属性来命名此节点。
- en: If we see the corresponding server span, we can now merge the server node with
    the dependency node, based on span context and causation. There are other visualizations
    or automation tools that you might find useful – for example, critical path analysis,
    or finding common attributes that correspond to higher latency or error rates.
    Each of these relies on span properties and attributes following common semantics
    or at least being consistent across services.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看到相应的服务器跨度，我们现在可以根据跨度上下文和因果关系将服务器节点与依赖节点合并。还有其他可视化或自动化工具你可能觉得有用——例如，关键路径分析，或找到与更高延迟或错误率相对应的常见属性。这些每一个都依赖于跨度属性和遵循常见语义或至少在服务之间保持一致。
- en: Resource attributes
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源属性
- en: '**Resource attributes** describe the process, host, service, and environment,
    and are the same for all spans reported by the service instance – for example,
    the service name, version, unique service instance ID, cloud provider account
    ID, region, availability zone, and K8s metadata.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源属性**描述了进程、主机、服务和环境，并且对于服务实例报告的所有跨度都是相同的——例如，服务名称、版本、唯一服务实例ID、云提供商账户ID、区域、可用区以及K8s元数据。'
- en: These attributes allow us to detect anomalies specific to certain environments
    or instances – for example, an error rate increase only on instances that have
    a new version of code, an instance that goes into a restart loop, or a cloud service
    in a region and availability zone that experiences issues.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性使我们能够检测特定环境或实例的特定异常——例如，只有具有新版本代码的实例的错误率增加，进入重启循环的实例，或在区域和可用区遇到问题的云服务。
- en: Based on standard attributes, observability vendors can write generic queries
    to perform this analysis or build common dashboards. It also enables the community
    to create vendor-agnostic tools and solutions for popular technologies.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 基于标准属性，可观测性供应商可以编写通用查询来执行此分析或构建通用仪表板。它还使社区能够为流行技术创建供应商无关的工具和解决方案。
- en: Such attributes describe a service instance and don’t have to appear on every
    span – OTLP, for example, passes resource attributes once per batch of spans.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性描述了一个服务实例，并不需要在每个跨度上出现——例如，OTLP在每次跨度批次中只传递一次资源属性。
- en: Performance analysis overview
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析概述
- en: Now that you know the core concepts around distributed tracing, let’s see how
    we can use the observability stack to investigate common distributed system problems.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了分布式跟踪的核心概念，让我们看看我们如何使用可观测性堆栈来调查常见的分布式系统问题。
- en: The baseline
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基线
- en: 'Before we talk about problems, let’s establish a baseline representing the
    behavior of a healthy system. We also need it to make data-driven decisions to
    help with common design and development tasks such as the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论问题之前，让我们建立一个代表健康系统行为的基线。我们还需要它来做出数据驱动的决策，以帮助以下常见设计和开发任务，例如：
- en: '**Risk estimation**: Any feature work on the hot path is a good candidate for
    additional performance testing prior to release and guarding new code with feature
    flags.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险估计**：任何对热点路径上的功能工作都是发布前进行额外性能测试的良好候选者，并且使用功能标志保护新代码。'
- en: '**Capacity planning**: Knowing the current load is necessary to understand
    whether a system can handle planned growth and new features.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容量规划**：了解当前负载对于理解系统是否可以处理计划的增长和新功能是必要的。'
- en: '**Understand improvement potential**: It makes more sense to optimize frequently
    executed code, as even small optimizations bring significant performance gains
    or cost reductions. Similarly, improving reliability brings the most benefits
    for components that have a higher error rate and that are used by other services.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解改进潜力**：优化经常执行的代码更有意义，因为即使是小的优化也能带来显著的性能提升或成本降低。同样，提高可靠性为错误率较高且被其他服务使用的组件带来最大的好处。'
- en: '**Learning usage patterns**: Depending on how users interact with your system,
    you might change your scaling or caching strategy, extract specific functionality
    to a new service, or merge services.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习使用模式**：根据用户如何与您的系统交互，您可能需要更改您的扩展或缓存策略，将特定功能提取到新的服务中，或者合并服务。'
- en: 'Generic indicators that describe the performance of each service include the
    following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 描述每个服务性能的通用指标包括以下内容：
- en: '**Latency**: How fast a service responds'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：服务响应的速度'
- en: '**Throughput**: How many requests, events, or bytes the service is handling
    per second'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：每秒服务处理多少请求、事件或字节数'
- en: '**Error rate**: How many errors a service returns'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误率**：服务返回的错误数量'
- en: Your system might need other indicators to measure durability or data correctness.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您的系统可能需要其他指标来衡量持久性或数据正确性。
- en: Each of these signals is useful when it includes an API route, a status code,
    and other context properties. For example, the error rate could be low overall
    but high for specific users or API routes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些信号包括 API 路由、状态码和其他上下文属性时，每个信号都很有用。例如，错误率可能总体上很低，但对于特定用户或 API 路由却很高。
- en: Measuring signals on the server and client sides, whenever possible, gives you
    a better picture. For example, you can detect network failures and avoid “*it
    works on my machine*” situations when clients see issues and servers don’t.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，在服务器和客户端上测量信号，可以给您一个更清晰的画面。例如，您可以检测网络故障并避免“*在我的机器上它工作正常*”的情况，当客户端看到问题时，服务器却没有。
- en: Investigating performance issues
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查性能问题
- en: 'Let’s divide performance issues into two overlapping categories:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将性能问题分为两个重叠的类别：
- en: Widespread issues that affect a whole instance, server, or even the system,
    and move the distribution median.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响整个实例、服务器甚至整个系统，并移动分布中位数的广泛问题。
- en: An individual request or job that takes too much time to complete. If we visualize
    the latency distribution, as shown in *Figure 1**.12*, we’ll see such issues in
    the long tail of distribution – they are rare, but part of normal behavior.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成时间过长的单个请求或作业。如果我们可视化延迟分布，如图 *图 1**.12* 所示，我们将在分布的长尾中看到这些问题——它们很少见，但属于正常行为。
- en: '![Figure 1.12 – Azure Monitor latency distribution visualization, with a median
    request (the 50th percentile) taking around 80 ms and the 95th percentile around
    250 ms](img/B19423_01_12.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – Azure Monitor 延迟分布可视化，中位数请求（第 50 个百分位数）大约为 80 毫秒，第 95 个百分位数大约为 250
    毫秒](img/B19423_01_12.jpg)'
- en: Figure 1.12 – Azure Monitor latency distribution visualization, with a median
    request (the 50th percentile) taking around 80 ms and the 95th percentile around
    250 ms
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – Azure Monitor 延迟分布可视化，中位数请求（第 50 个百分位数）大约为 80 毫秒，第 95 个百分位数大约为 250
    毫秒
- en: Long tails
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长尾
- en: Individual issues can be caused by an unfortunate chain of events – transient
    network issues, high contention in optimistic concurrency algorithms, hardware
    failures, and so on.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 单个问题可能是由一系列不幸的事件引起的——瞬态网络问题、乐观并发算法中的高竞争、硬件故障等。
- en: Distributed tracing is an excellent tool to investigate such issues. If you
    have a bug report, you might have a trace context for a problematic operation.
    To achieve it, make sure you show the `traceparent` value on the web page and
    return `traceresponse` or a document that users need to record, or log `traceresponse`
    when sending requests to your service.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪是调查此类问题的优秀工具。如果您有错误报告，您可能有一个有问题的操作的跟踪上下文。为了实现这一点，请确保您在网页上显示 `traceparent`
    值，并返回用户需要记录的 `traceresponse` 或文档，或者当向您的服务发送请求时记录 `traceresponse`。
- en: So, if you know the trace context, you can start by checking the trace view.
    For example, in *Figure 1**.13*, you can see an example of a long request caused
    by transient network issues.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您知道跟踪上下文，您可以从检查跟踪视图开始。例如，在 *图 1**.13* 中，您可以看到由瞬态网络问题引起的长时间请求的示例。
- en: '![Figure 1.13 – A request with high latency caused by transient network issues
    and retries](img/B19423_01_13.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13 – 由短暂网络问题和重试引起的高延迟请求](img/B19423_01_13.jpg)'
- en: Figure 1.13 – A request with high latency caused by transient network issues
    and retries
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – 由短暂网络问题和重试引起的高延迟请求
- en: The frontend request took about 2.6 seconds and the time was spent on the storage
    service downloading meme content. We see three tries of `Azure.Core.Http.Request`,
    each of which was fast, and the time between them corresponds to the back-off
    interval. The last try was successful.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前端请求大约花费了 2.6 秒，时间花在存储服务下载表情包内容上。我们看到 `Azure.Core.Http.Request` 的三次尝试，每次都很快，它们之间的时间对应于退避间隔。最后一次尝试是成功的。
- en: If you don’t have `trace-id`, or perhaps if the trace was sampled out, you might
    be able to filter similar operations based on the context and high latency.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 `trace-id`，或者可能是跟踪被采样，你可能可以根据上下文和高延迟过滤类似操作。
- en: For example, in Jaeger, you can filter spans based on the service, span name,
    attributes, and duration, which helps you to find a needle in a haystack.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Jaeger 中，你可以根据服务、跨度名称、属性和持续时间来过滤跨度，这有助于你在“大海捞针”中找到所需信息。
- en: 'In some cases, you will end up with mysterious gaps – the service was up and
    running but spent significant time doing nothing, as shown in *Figure 1**.14*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能会遇到神秘的间隙——服务运行正常，但花费了大量时间什么也没做，如图 *图 1.14* 所示：
- en: '![Figure 1.14 – A request with high latency and gaps in spans](img/B19423_01_14.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14 – 带有高延迟和跨度间隙的请求](img/B19423_01_14.jpg)'
- en: Figure 1.14 – A request with high latency and gaps in spans
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – 带有高延迟和跨度间隙的请求
- en: If you don’t get enough data from traces, check whether there are any logs available
    in the scope of this span.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从跟踪中获取不到足够的数据，请检查此跨度范围内是否有任何日志可用。
- en: You might also check resource utilization metrics – was there a CPU spike, or
    maybe a garbage collection pause at this moment? You might find some correlation
    using timestamps and context, but it’s impossible to tell whether this was a root
    cause or a coincidence.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查资源利用率指标——此时是否有 CPU 峰值，或者可能发生了垃圾回收暂停？你可能会通过时间戳和上下文找到一些相关性，但无法判断这是根本原因还是巧合。
- en: If you have a continuous profiler that correlates profiles to traces (yes, they
    can do it with `Activity.Current`), you can check whether there are profiles available
    for this or similar operations.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个将配置文件与跟踪关联的持续分析器（是的，它们可以使用 `Activity.Current` 来做到这一点），你可以检查是否有此或类似操作的配置文件可用。
- en: We’ll see how to investigate this further with .NET diagnostics tools in [*Chapter
    4*](B19423_04.xhtml#_idTextAnchor068), *Low-Level Performance Analysis with Diagnostic
    Tools*, but if you’re curious about what happened in *Figure 1**.14*, the service
    read a network stream that was not instrumented.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 4 章*](B19423_04.xhtml#_idTextAnchor068) “使用诊断工具进行低级性能分析”中看到如何使用 .NET
    诊断工具进一步调查，但如果你对 *图 1.14* 中发生的事情感到好奇，服务读取了一个未进行度量的网络流。
- en: Even though we talk about individual performance issues, in many cases we don’t
    know how widespread they are, especially when we’re at the beginning of an incident.
    Metrics and rich queries across traces can be used to find out how common a problem
    is. If you’re on call, checking whether an issue is widespread or becoming more
    frequent is usually more urgent than finding the root cause.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们谈论的是个别性能问题，但在许多情况下，我们不知道这些问题有多普遍，尤其是在事件开始时。跨跟踪的指标和丰富查询可以用来找出问题有多普遍。如果你在值班，检查问题是否普遍或变得更加频繁通常比找到根本原因更紧急。
- en: Note
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Long-tail latency requests are inevitable in distributed systems, but there
    are always opportunities for optimization, with caching, collocation, adjusting
    timeouts and the retry policy, and so on. Monitoring P95 latency and analyzing
    traces for long-tail issues helps you find such areas for improvement.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，长尾延迟请求是不可避免的，但总有优化机会，例如缓存、协同定位、调整超时和重试策略等。监控 P95 延迟和分析跟踪以解决长尾问题有助于你找到这些改进区域。
- en: Performance issues
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能问题
- en: Performance problems manifest as latency or throughput degradation beyond usual
    variations. Assuming you fail fast or rate-limit incoming calls, you might also
    see an increase in the error rate for `408`, `429`, or `503` HTTP status codes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题表现为延迟或吞吐量下降，超出正常变化范围。假设你快速失败或限制传入调用，你也可能会看到 `408`、`429` 或 `503` HTTP 状态码的错误率增加。
- en: Such issues can start as a slight decrease in dependency availability, causing
    a service to retry. With outgoing requests taking more resources than usual, other
    operations slow down, and the time to process client requests grows, along with
    number of active requests and connections.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题可能始于依赖项可用性的轻微下降，导致服务重试。由于出站请求比平时消耗更多资源，其他操作会变慢，处理客户端请求的时间会增长，同时活跃请求和连接的数量也会增加。
- en: It could be challenging to understand what happened first; you might see high
    CPU usage and a relatively high GC rate – all symptoms you would usually see on
    an overloaded system, but nothing that stands out. Assuming you measure the dependency
    throughput and error rate, you could see the anomaly there, but it might be difficult
    to tell whether it’s a cause or effect.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 理解发生了什么可能具有挑战性；您可能会看到高CPU使用率和相对较高的GC率——这些都是您通常在过载系统上看到的症状，但没有突出显示的。假设您测量了依赖项吞吐量和错误率，您可能会在那里看到异常，但可能很难判断它是原因还是结果。
- en: Individual distributed traces are rarely useful in such cases – each operation
    takes longer, and there are more transient errors, but traces may look normal
    otherwise.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，单个分布式跟踪很少有用——每个操作都会花费更长的时间，并且会有更多的短暂错误，但跟踪可能看起来正常。
- en: 'Here’s a list of trivial things to check first, and they serve as a foundation
    for more advanced analysis:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份首先需要检查的简单事项列表，它们是更高级分析的基础：
- en: Is there an active deployment or a recent feature rollout? You can find out
    whether a problem is specific to instances running a new version of code using
    a `service.version` resource attribute. If you include feature flags on your traces
    or events, you can query them to check whether degradation is limited to (or started
    from) the requests with a new feature enabled.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有正在进行的部署或最近的功能发布？您可以使用`service.version`资源属性来找出问题是否仅限于运行新版本代码的实例。如果您在跟踪或事件中包含功能标志，您可以查询它们以检查降级是否仅限于（或始于）启用新功能的请求。
- en: Are issues specific to a certain API, code path, or combination of attributes?
    Some backends, such as Honeycomb, automate this analysis, finding attributes corresponding
    to a higher latency or error rate.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题是否特定于某个API、代码路径或属性组合？一些后端，如Honeycomb，会自动化这种分析，找到对应于更高延迟或错误率的属性。
- en: Are all instances affected? How many instances are alive? Attribute-based analysis
    is helpful here too.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否所有实例都受到影响？有多少实例处于活动状态？基于属性的分析在这里也很有帮助。
- en: Are your dependencies healthy? If you can, check their server-side telemetry
    and see whether they experience problems with other services, not just yours.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的依赖项是否健康？如果可以，检查它们的服务器端遥测数据，看看它们是否与其他服务（而不仅仅是您的服务）存在问题。
- en: Attribute analysis can help here as well – assuming just one of your cloud storage
    accounts or database partitions is misbehaving, you will see it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 属性分析在这里同样有帮助——假设您的云存储账户或数据库分区中只有一个表现异常，您会看到这一点。
- en: Did the load increase sharply prior to the incident? Or, if your service is
    auto-scaled, is the auto-scaler functioning properly, and are you able to catch
    up with the load?
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件发生前负载是否急剧增加？或者，如果您的服务是自动扩展的，自动扩展器是否正常工作，您是否能够跟上负载？
- en: There are more questions to ask about infrastructure, the cloud provider, and
    other aspects. The point of this exercise is to narrow down and understand the
    problem as much as possible. If the problem is not in your code, investigation
    helps to find a better way to handle problems like these in the future and gives
    you an opportunity to fill the gaps in your telemetry, so next time something
    similar happens, you can identify it faster.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基础设施、云提供商和其他方面还有更多问题要问。这个练习的目的是尽可能缩小问题范围并理解问题。如果问题不在您的代码中，调查有助于找到更好的方法来处理这类问题，并给您一个机会填补您遥测中的空白，这样下次类似的事情发生时，您可以更快地识别它。
- en: If you suspect a problem in your code, .NET provides a set of signals and tools
    to help investigate high CPU, memory leaks, deadlocks, thread pool starvation,
    and profile code, as we’ll see in [*Chapter 4*](B19423_04.xhtml#_idTextAnchor068),
    *Low-Level Performance Analysis with* *Diagnostic Tools*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您怀疑代码中存在问题，.NET提供了一套信号和工具来帮助调查高CPU、内存泄漏、死锁、线程池饥饿和代码分析，正如我们将在[*第4章*](B19423_04.xhtml#_idTextAnchor068)中看到的，*使用诊断工具进行低级性能分析*。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Distributed systems need a new approach to observability that simplifies investigating
    incidents and minimizes the time to resolve issues. This approach should focus
    on human experience such as data visualization, the correlation across telemetry
    signals, and analysis automation. It requires structured, correlated telemetry
    signals that work together and new tools that leverage them to build a rich experience.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统需要一种新的可观察性方法，该方法简化了事故的调查并最小化了解决问题的时间。这种方法应专注于人类体验，如数据可视化、遥测信号的关联以及分析自动化。它需要结构化、关联的遥测信号，以及利用它们构建丰富体验的新工具。
- en: Distributed tracing is one such signal – it follows requests through any system
    and describes service operations with spans, the events representing operations
    in the system. .NET supports distributed tracing and integrates natively with
    OpenTelemetry, which is a cross-language platform to collect, process, and export
    traces, metrics, and logs in a vendor-agnostic way. Most modern vendors are compatible
    with OpenTelemetry and leverage distributed tracing capabilities. The OpenTelemetry
    ecosystem includes a diverse set of shared instrumentation libraries that automate
    common telemetry collection needs.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪就是这样一种信号——它跟随请求穿过任何系统，并使用跨度描述服务操作，跨度代表系统中的操作事件。.NET支持分布式跟踪，并原生集成与OpenTelemetry，这是一个跨语言平台，以供应商无关的方式收集、处理和导出跟踪、指标和日志。大多数现代供应商都与OpenTelemetry兼容，并利用分布式跟踪功能。OpenTelemetry生态系统包括一系列共享的仪器库，这些库自动化了常见的遥测收集需求。
- en: Distributed tracing enables correlation and causation by propagating context
    within the process and between services. OpenTelemetry defines standard semantics
    for common technologies so that vendors can build trace visualizations, application
    maps, shared dashboards, alerts, or queries that rely on consistent and standard
    attributes. Trace context and consistent attributes enable correlation between
    spans, logs, metrics, and any other signals coming from your system.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪通过在进程内和进程间传播上下文来实现关联和因果关系。OpenTelemetry为常见技术定义了标准语义，以便供应商可以构建依赖于一致和标准属性的跟踪可视化、应用程序映射、共享仪表板、警报或查询。跟踪上下文和一致属性使跨度、日志、指标以及来自你系统的任何其他信号之间的关联成为可能。
- en: Individual issues can be efficiently analyzed with distributed tracing and investigations
    into widespread performance issues rely on attributes and timestamp correlation
    on metrics and across traces. Observability vendors may automate this analysis.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用分布式跟踪有效地分析个别问题，对广泛性能问题的调查则依赖于指标和跟踪上的属性以及时间戳关联。可观察性供应商可能会自动化这种分析。
- en: A combination of metrics, traces, and events gives the right number of details.
    Metrics allow us to receive unbiased data in a cost-effective way. By querying
    traces and events over high-cardinality attributes, we can answer ad hoc questions
    about the system.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 指标、跟踪和事件的组合提供了正确数量的细节。指标使我们能够以成本效益的方式接收无偏见的数据。通过查询具有高基数属性的跟踪和事件，我们可以回答关于系统的即兴问题。
- en: In the next chapter, we’ll get hands-on experience with distributed tracing.
    We’ll build a demo application and explore native tracing capabilities in .NET.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将亲身体验分布式跟踪。我们将构建一个演示应用程序并探索.NET中的原生跟踪功能。
- en: Questions
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would you define spans and traces? What information does a span contain?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何定义跨度（span）和跟踪（trace）？跨度包含哪些信息？
- en: How does span correlation work?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跨度关联是如何工作的？
- en: Assuming you are on call and receive a report from a user about slow response
    time from your service, how would you approach the investigation?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你正在值班并收到用户关于你的服务响应时间慢的报告，你会如何处理调查？
- en: Further reading
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Cloud-Native Observability with OpenTelemetry* by Alex Boten'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用OpenTelemetry的云原生可观察性》* by Alex Boten'
