- en: Responding to User Events for Interactive UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI Buttons to move between scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating button properties on mouse-over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing image panels and changing panel depths via buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the value of an interactive UI Slider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a countdown timer graphically with a UI Slider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting custom mouse cursors for 2D and 3D GameObjects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting custom mouse cursors for UI controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive text entry with an Input Field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toggles and radio buttons via Toggle Groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating text and image icon UI Dropdown menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a radar to indicate the relative locations of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost all the recipes in this chapter involve different interactive UI controls.
    Although there are different kinds of interactive UI controls, the basic way to
    work with them, and have scripted actions respond to user actions, is all based
    on the same idea: events triggering the execution of object method functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, for fun, and an example of a very different kind of UI, the final recipe
    demonstrates how to add to your game a sophisticated real-time communication of
    the relative positions of objects in the scene (that is, a radar!).
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UI can be used for three main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To display **static (unchanging) values**, such as the name or logo image of
    the game, or word labels such as Level and Score, that tell us what the numbers
    next to them indicate (recipes for these can be found in the [Chapter 1](920700d7-96cd-4015-b17c-ee2451bc648e.xhtml), *Displaying
    Data with Core UI Elements*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display **values that change due to our scripts**, such as timers, scores,
    or the distance from our Player character to some other object (an example of
    this is the radar recipe at the end of this chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Interactive** UI controls, whose purpose is to allow the Player to communicate
    with the game scripts via their mouse or touchscreen. These are the ones we''ll
    look at in detail in this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The core concept for working with Unity Interactive UI controls is the *registration
    of an object''s public method to be informed when a particular event occurs*.
    For example, we can add a UI Dropdown to a scene named DropDown 1, and then write
    a `MyScript` script class containing a `NewValueAction()` public method to do
    some action. But nothing will happen until we do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to add an *instance of the script class as a component* on a GameObject
    in the scene (which we'll name `go1` for our example – although we can also add
    the script instance to the UI GameObject itself if we choose to).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the UI Dropdown''s properties, we need to *register the GameObject''s public
    method* of its script component to respond to the `On Value Changed` event messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e7f83bb-dd87-4eca-bb4a-f20e054e3632.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `NewValueAction()` public method of the `MyScript` script will typically
    retrieve the value selected by the user in the Dropdown and do something with
    it – for example, confirm it to the user, change the music volume, or change the
    game difficulty. The `NewValueAction()` method will be invoked (executed) each
    time GameObject go1 receives the `NewValueAction()` message. In the DropDown 1''s
    properties, we need to register GameObject go1''s scripted component MyScript''s
    `NewValueAction()` public method as an event listener for On Value Changed events.
    We need to do all this at **Design-Time** (that is, in the Unity editor before
    running the scene):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e2ebc59-b702-4b80-aec7-143f8f20b371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At **runtime** (when the scene in the built application is running), if the
    user changes the value in the drop-down menu of UI Dropdown GameObject DropDown
    1 (step 1 in the diagram), this will generate an On Value Changed event. DropDown
    1 will update its display on screen, to show the user the newly-selected value
    (step 2a). It will also send messages to all the GameObject components registered
    as listeners to **On Value Changed** events (step 2b). In our example, this will
    lead to the `NewValueAction()` method in GameObject go1's scripted component being
    executed (step 3).
  prefs: []
  type: TYPE_NORMAL
- en: Registering public object methods is a very common way to handle events such
    as user interaction or web communications, which may occur in different orders,
    may never occur, or may happen several times in a short period. Several software
    Design Patterns describe ways to work with these event setups, such as the *Observer
    Pattern* and the *Publisher-Subscriber* pattern (we'll learn more about this pattern
    in [Chapter 16](04f5a183-ae0b-4d73-8e78-c90fd75c9a64.xhtml), *Design Patter**ns*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Core GameObjects, components, and concepts relating to interactive Unity UI
    development include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual UI controls**: The visible UI controls themselves include Button,
    Image, Text, and Toggle. These are the UI controls the user sees on the screen,
    and uses their mouse/touchscreen to interact with. These are the GameObjects that
    maintain a list of object-methods that have subscribed to user-interaction events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction UI controls**: These are non-visible components that are added
    to GameObjects; examples include Input Field and Toggle Group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Panel**: UI objects can be grouped together (logically and physically) with
    UI Panels. Panels can play several roles, including providing a GameObject parent
    in the Hierarchy for a related group of controls. They can provide a visual background
    image to graphically relate controls on the screen, and they can also have scripted
    resize and drag interactions added, if desired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sibling Depth**: The bottom-to-top display order (what appears on the top
    of what) for a UI element is determined initially by their sequence in the Hierarchy.
    At **Design-Time**, this can be manually set by dragging GameObjects into the
    desired sequence in the Hierarchy. At **Run-Time**, we can send messages to the
    Rect Transforms of GameObjects to dynamically change their Hierarchy position
    (and therefore, the display order), as the game or user interaction demands. This
    is illustrated in the *Organizing images inside panels and changing panel depths
    via buttons* recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, a UI element exists with most of the components that you may need for
    something in your game, but you may need to adapt it somehow. An example of this
    can be seen in the recipe that makes a UI Slider non-interactive, instead using
    it to display a red-green progress bar for the status of a countdown timer. See
    this in the *Displaying a countdown timer graphically with a UI Slider* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI Buttons to move between scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as scenes where the player plays the game, most games will have menu
    screens, which display to the user messages about instructions, high scores, the
    level they have reached so far, and so on. Unity provides UI Buttons to offer
    users a simple way to indicate their choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create a very simple game consisting of two screens,
    each with a button to load the other one, as illustrated in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/873bd5cc-73d8-4132-94e1-db89a8f3c865.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a button-navigable multi-scene game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the current (empty) scene, in a new folder, `_Scenes`, naming the scene
    page1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **UI Text** object positioned at the top center of the scene, containing
    large white text that says Main Menu (page 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **UI Button** to the scene positioned in the middle-center of the screen.
    In the **Hierarchy**, click on the show children triangle to display the **Text**
    child of this GameObject button. Select the **Text** GameObject, and in the **Inspector** for
    the Text property of the Text (Script) component, enter the text goto page 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1c2d5b99-fa37-4e6a-935d-bfe90904ea40.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a second scene, named page2, with UI Text = Instructions (page 2), and
    a **UI Button** with the goto page 1 text. You can either repeat the preceding
    steps, or you can duplicate the page1 scene file, naming the duplicate page2,
    and edit the UI Text and UI Button Text appropriately
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add both scenes to the Build, which is the set of scenes that will end up in
    the actual application built by Unity. To add the scene1 to the Build, open scene
    page1, then choose menu: File | Build Settings... then click on the Add Current
    button so that the page1 scene becomes the first scene on the list of Scenes in
    the Build. Now open scene page2 and repeat the process, so both scenes have been
    added to the Build.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We cannot tell Unity to load a scene that has not been added to the list of
    scenes in the build. This makes sense since when an application is built we should
    never try to open a scene that isn't included as part of that application.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you have scene page1 open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, `SceneLoader`, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Select the Button in the Hierarchy and click on the plus sign (+) button at
    the bottom of the **Button (Script)** component, in the **Inspector** view, to
    create a new `OnClick` event handler for this button (that is, an action to perform
    when the button is clicked).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Main Camera from the Hierarchy over the Object slot immediately below
    the menu saying Runtime Only. This means that when the Button receives an `OnClick`
    event, we can call a public method from a scripted object inside the Main Camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `LoadOnClick` method from the SceneLoader drop-down list (initially
    showing No Function). Type 1 (the index of the scene we want to be loaded when
    this button is clicked) in the text box, below the method''s drop-down menu. This
    integer, 1, will be passed to the method when the button receives an `OnClick`
    event message, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/77109497-bde4-46a5-bcc2-d7ca372aa435.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the current scene (page1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open page2 and follow the same steps to make the page2 button load page1\. That
    is, add an instance of the  `SceneLoader` script class to the main camera, then
    add an `OnClick` event action to the button, which calls `LoadOnClick`, and passes
    the integer 0, so scene page1 is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save scene page2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the page1 scene, you will be presented with your Main Menu text
    and a button, which when clicked, makes the game load the page2 scene. On scene
    page2, you'll have a button to take you back to page1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have created two scenes, and added both of these scenes to the game's build.
    You added a UI Button, and some UI Text to each scene.
  prefs: []
  type: TYPE_NORMAL
- en: Note, the Build sequence of scenes is actually a scripted array, which count
    from 0, then 1, and so on, so page1 has index 0, and page2 has index 1.
  prefs: []
  type: TYPE_NORMAL
- en: When a UI Button is added to the Hierarchy panel, a child UI Text object is
    also automatically created, and the content of the Text property of this UI Text
    child is the text that the user sees on the button.
  prefs: []
  type: TYPE_NORMAL
- en: You created a script class, and added an instance as a component to the Main
    Camera. In fact, it didn't really matter where this script instance was added,
    as long as it was in one of the GameObjects of the scene. This is necessary since
    the `OnClick` event action of a button can only execute a method (function) of
    a component in a GameObject in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: For the button of each scene, you then added a new `OnClick` event action, which
    invokes (executes) the `LoadOnClick` method of the SceneLoader scripted component
    in the Main Camera. This method inputs the integer index of the scene in the project's
    Build settings, so that the button on the page1 scene gives integer 1 as the scene
    to be loaded, and the button for page2 gives integer 0.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Color tint when mouse pointer is over the button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways in which we can visually inform the user that the button
    is interactive when they move their mouse cursor over it. The simplest is to add
    a Color Tint that will appear when the mouse is over the button – this is the
    default **Transition**. With the Button selected in the Hierarchy, choose a tint
    color (for example, red), for the Highlighted Color property of the Button (Script)
    component, in the Inspector tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d23e51c5-6e25-4999-91db-d9d8079f5233.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another form of visual Transition to inform the user of an active button is
    Sprite Swap. In this case, properties for different images for Targeted/Highlighted/Pressed/Disabled
    are available in the **Inspector** panel. The default Targeted Graphic is the
    built-in Unity **Button (Image)** – this is the grey rounded rectangle default
    when GameObject buttons are created. Dragging in a very different-looking image
    for the **Highlighted** Sprite is an effective alternative to set a Color Tint.
    We have provided a `rainbow.png` image with the project for this recipe that can
    be used for the Button mouse over Highlighted Sprite. The screenshot shows the
    button with this rainbow background image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b4ac2db-ba46-4d00-ab55-88fc75d4f8e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Animating button properties on mouse-over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the previous recipe, we illustrated two ways to visually communicate
    buttons to users. The Animation of button properties can be a highly effective,
    and visually interesting, way to reinforce to the user that the item their mouse
    is currently over is a clickable, active button. One common animation effect is
    for a button to get larger when the mouse is over it, and then it shrinks back
    to its original size when the mouse pointer is moved away. Animation effects are
    achieved by choosing the Animation option for the Transition property of a `Button`
    GameObject, and by creating an animation controller with triggers for the Normal,
    Highlighted, Pressed, and Disabled states.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To animate a button for enlargement when the mouse is over it (the Highlighted
    state), do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI Button**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector Button (Script)** component, set the **Transition** property
    to **Animation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Auto Generate Animation** button (just below the **Disabled Trigger**
    property) for the **Button (Script)** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84439d36-92e0-45ef-82a8-734c5ee91987.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the new controller (in new folder `Animations`), naming it **button-animation-controller**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the **Button** GameObject is selected in the Hierarchy. In the
    Animation panel, select the **Highlighted** clip from the drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fde4a896-a33a-4d1e-a0f2-29e964ec9a34.png)'
  prefs: []
  type: TYPE_IMG
- en: In the **Animation** panel, click on the red record circle button, and then
    click on the **Add Property** button, choosing to record changes to the Rect Transform
    | Scale property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Two keyframes will have been created. Delete the second one at `1:00` (since
    we don''t want a "bouncing" button):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd86535c-4ace-447d-9d88-835b54167f09.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the frame at `1:00` by clicking one of the diamonds (both turn blue when
    selected), then press the *Backspace/Delete* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the first keyframe at `0:00` (the only one now!). In the Inspector, set the
    X and Y scale properties of the **Rect Transform** component to (`1.2, 1.2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the red record circle button for the second time to end the recording
    of the animation changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run your scene, and you will see that the button smoothly animates
    to get larger when the mouse is over it, and then smoothly returns to its original
    size when the mouse has moved away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have created a button, and set its Transition mode to Animation. This makes
    Unity require an Animation Controller with four states: Normal, Highlighted, Pressed,
    and Disabled. You then made Unity automatically create an Animation Controller
    with these four states.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you edited the Animation for the Highlighted (mouse-over) state, deleting
    the second keyframe, and making the only keyframe a version of the Button made
    larger to a scale of 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: When the mouse is not over the Button, it's unchanged and Normal state settings
    are used. When the mouse moves over the Button, the Animation Controller smoothly
    in-betweens the settings of the Button to become those of its Highlighted state
    (that is, bigger). When the mouse is moved away from the Button, the Animation
    Controller smoothly in-betweens the settings of the Button to become those of
    its Normal state (that is, its original size).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following web pages offer video and web-based tutorials on UI animations:'
  prefs: []
  type: TYPE_NORMAL
- en: The Unity button transitions tutorial is available at[http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions.](http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions)
    Ray Wenderlich's great tutorial (part 2), including the button animations, is
    available at[ http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2](http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2).
  prefs: []
  type: TYPE_NORMAL
- en: Organizing image panels and changing panel depths via buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI Panels are provided by Unity to allow UI controls to be grouped and moved
    together, and also to visually group elements with an Image background (if desired).
    The sibling depth is what determines which UI elements will appear above or below
    others. We can see the sibling depth explicitly in the Hierarchy, since the top-to-bottom
    sequence of UI GameObjects in the Hierarchy sets the sibling depth. So, the first
    item has a depth of 1, the second has a depth of 2, and so on. The UI GameObjects
    with larger sibling depths (further down the Hierarchy and so drawn later) appear
    above the UI GameObjects with lower sibling depths.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create three UI Panels, each showing a different playing
    card image. We''ll also add four triangle arrangement buttons to change the display
    order (move to bottom, move to top, move up one, and move down one):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c677aba-f531-433a-9d1b-6b0df593bc21.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the images that you need in a folder named
    `Images` in the `02_03` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the UI Panels whose layering can be changed by clicking buttons,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new **UI Panel** GameObject named **Panel-jack-diamonds**. Do the
    following to this Panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Image (Script)** component, drag the `**jack_of_diamonds**` playing
    card image asset file from the **Project** panel into the **Source Image** property.
    Select the **Color** property and increase the **Alpha** value to `255` (so this
    background image of the panel is no longer partly transparent).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the **Rect Transform** property, position it in the middle-center part of
    the screen, and size it with **Width** = `200` and **Height** = `300`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a **UI Button** named **Button-move-to-front**. In the **Hierarchy**,
    child this button to **Panel-jack-diamonds**. Delete the **Text** child GameObject
    of this button (since we'll use an icon to indicate what this button does).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the **Button-move-to-front** GameObject selected in the **Hierarchy**,
    do the following in the Inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Rect Transform**, position the button top-center of the player card
    image so that it can be seen at the top of the playing card. Size the image to
    **Width** = `16` and **Height** = `16`. Move the icon image down slightly, by
    setting **Pos Y** = `-5` (to ensure we can see the horizontal bar above the triangle).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the **Source Image** property of the **Image (Script)** component, select
    the arrangement triangle icon image: `icon_move_to_front`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an **OnClick** event handler by clicking on the plus sign (**+**) at the
    bottom of the **Button (Script)** component.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag **Panel-jack-diamonds** from the **Hierarchy** over to the **Object** slot
    (immediately below the menu saying **Runtime Only**).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select the `RectTransform.SetAsLastSibling` method from the drop-down function
    list (initially showing **No Function**):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4254ab98-f133-4652-b80e-46b7decce6cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat step 2; create a second Panel named **Panel-2-diamonds** with its own
    **move-to-front** button, and **Source Image** of `2_of_diamonds`. Move and position
    this new panel slightly to the right of **Panel-jack-diamonds**, allowing both
    the **move-to-front** buttons to be seen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your **Scene** and run the game. You will be able to click the **move-to-front**
    button on either of the cards to move that card's panel to the front. If you run
    the game with the Game panel not maximized, you'll actually see the panels changing
    order in the list of the children of the **Canvas** in the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have created two **UI Panels**, each panel contains a background **Image**
    of a playing card and a **UI** **Button** whose action will make its parent panel
    move to the front. You set the **Alpha** (transparency) setting of the background
    image's **Color** to `255` (no transparency).
  prefs: []
  type: TYPE_NORMAL
- en: You added an `OnClick` event action to the button of each **UI** **Panel**.
    The action sends a `SetAsLastSibling` message to the **Button's** **Panel** parent.
    When the **OnClick** message is received, the clicked **Panel** is moved to the
    bottom (end) of the sequence of GameObjects in the **Canvas**, and therefore this
    **Panel** is drawn last of the **Canvas** objects, and so appears visually in
    front of all other GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: The button's action illustrates how the **OnClick** function does not have to
    be the calling of a public method of a scripted component of an object, but it
    can be sending a message to one of the non-scripted components of the targeted
    GameObject. In this recipe, we send the `**SetAsLastSibling**` message to the
    **Rect Transform** of the Panel where the Button is located.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Moving up or down by just one position, using scripted methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the **Rect Transform** offers a useful `SetAsLastSibling` (move to front)
    and `SetAsFirstSibling` (move to back), and even `SetSiblingIndex` (if we knew
    exactly what position in the sequence to type in), there isn''t a built-in way
    to make an element move up or down just one position in the sequence of GameObjects
    in the **Hierarchy**. However, we can write two straightforward methods in C#
    to do this, and we can add buttons to call these methods, providing full control
    of the top-to-bottom arrangement of the UI controls on the screen. To implement
    four buttons (move-to-front/move-to-back/up one/down one), do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a C# script class called `ArrangeActions`, containing the following
    code, and add an instance as a scripted component to each of your **Panels**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Add a second **UI Button** to each card panel, this time using the arrangement
    triangle icon image called `icon_move_to_front`, and set the **OnClick** event
    function for these buttons to `SetAsFirstSibling`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two further **UI Buttons** to each card panel with the up and down triangle
    icon images: `icon_down_one` and `icon_up_one`. Set the **OnClick** event-handler
    function for the down-one buttons to call the `MoveDownOne()` method, and set
    the functions for the up-one buttons to call the `MoveUpOne()` method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy one of the **UI Panels** to create a third card (this time showing the
    Ace of diamonds). Arrange the three cards so that you can see all four buttons
    for at least two of the cards, even when those cards are at the bottom (see the
    screenshot at the beginning of this recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the **Scene** and run your game. You will now have full control over the
    layering of the three card panels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note, we should avoid *negative* sibling depths, so we should probably test
    for the currentSiblingIndex value before subtracting 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if(currentSiblingIndex > 0)` `      panelRectTransform.SetSiblingIndex( currentSiblingIndex
    - 1 );`'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the value of an interactive UI Slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe illustrates how to create an interactive **UI Slider**, and execute
    a C# method each time the user changes the **UI Slider** value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05acc1b3-9377-40c3-a4a7-ba89420cb03a.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a **UI Slider** and display its value on the screen, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **UI Text** GameObject to the scene with a **Font** size of `30` and placeholder
    text, such as slider value here (this text will be replaced with the slider value
    when the scene starts). Set **Horizontal-** and **Vertical- Overflow** to **Overflow**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** add a **UI Slider **GameObject to the scene – choose menu:
    GameObject | UI | Slider.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, modify the settings for the position of the **UI Slider**
    GameObject's **Rect Transform** to the top-middle part of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, modify settings for **Position** of the **UI Text's Rect
    Transform** to just below the slider (top, middle, then **Pos Y** = `-30`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector**, set the **UI Slider''s Min Value** to `0`, the **Max
    Value** to `20`, and check the **Whole Numbers** checkbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c24362c0-a292-4e65-8b9c-952697a07e82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a C# script class called `SliderValueToText`, containing the following
    code, and add an instance as a scripted component to the **Text** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the **Text** GameObject is selected in the **Hierarchy**. Then,
    in the **Inspector**, drag the **Slider** GameObject into the public **Slider
    UI** variable slot for the **Slider Value To Text (Script)** scripted component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e06acc58-c7da-40a5-aea4-42725c00ddfe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Ensure that the **Slider** GameObject is selected in the **Hierarchy**. Then,
    in the **Inspector**, drag the **Text** GameObject into the public **None (Object)**
    slot for the **Slider (Script)** scripted component, in the section for **On Value
    Changed (Single)** - as shown in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/52ff1c10-af95-4396-94aa-eef952d24413.png)**Registering an object to
    receive UI event messages**'
  prefs: []
  type: TYPE_NORMAL
- en: You have now told Unity to which object a message should be sent each time the
    slider is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the drop-down menu, select **SliderValueToText** and the `ShowSliderValue()`
    method, as shown in the following screenshot. This means that each time the slider
    is updated, the `ShowSliderValue()` method, in the scripted object, in the **Text** GameObject
    will be executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b3df604-b62e-435b-b6a2-9b10347a1f6c.png)'
  prefs: []
  type: TYPE_IMG
- en: When you run the **Scene**, you will now see a **UI Slider**. Below it, you
    will see a text message in the form `Slider value = <n>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each time the **UI Slider** is moved, the text value shown will be (almost)
    instantly updated. The values should range from `0` (the leftmost of the slider)
    to `20` (the rightmost of the slider).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a **UI Slider** GameObject, and set it to be whole numbers in the
    range of `0` ... `20`.
  prefs: []
  type: TYPE_NORMAL
- en: You have added an instance of the `SliderValueToText` C# script class to the **UI
    Text **GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: The `Awake()` method caches references to the Text component in the textSliderValue
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method invokes the `ShowSliderValue()` method, so that the display
    is correct when the scene begins (that is, the initial slider value is displayed).
  prefs: []
  type: TYPE_NORMAL
- en: The `ShowSliderValue()` method gets the value of the slider and then updates
    the text displayed to be a message in the form of `Slider value = <n>`.
  prefs: []
  type: TYPE_NORMAL
- en: You added the `ShowSliderValue()` method of the **SliderValueToText** scripted
    component to the **Slider** GameObject's list of **On Value Changed **event listeners.
    So, each time the slider value changes, it sends a message to call the `ShowSliderValue()`
    method, and so the new value is updated on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a countdown timer graphically with a UI Slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many cases where we wish to inform the player of the proportion of
    time remaining, or at the completion of some value at a point in time, for example,
    a loading progress bar, the time or health remaining compared to the starting
    maximum, or how much the player has filled up their water bottle from the fountain
    of youth. In this recipe, we''ll illustrate how to remove the interactive "handle"
    of a **UI Slider**, and change the size and color of its components to provide
    us with an easy-to-use, general purpose progress/proportion bar. In this recipe,
    we''ll use our modified **UI Slider** to graphically present to the user how much
    time remains for a countdown timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17ced000-edba-4800-9630-5d537802d356.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the script and images that you need in the
    folders named `_Scripts` and Images in the `02_05` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a digital countdown timer with a graphical display, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `**CountdownTimer**` script and the `red_square` and `green_square`
    images to this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **UI Text** GameObject to the scene with a **Font** size of `30` and placeholder
    text such as **UI S****lider** value here (this text will be replaced with the
    slider value when the scene starts). Set **Horizontal-** and **Vertical- Overflow**
    to **Overflow**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy**, add a** Slider** GameObject to the scene – choose menu:
    `GameObject | UI | Slider`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, modify the settings for the **Position** of the** Slider**
    GameObject's **Rect Transform** to the top-middle part of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Slider** GameObject is selected in the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deactivate the **Handle Slide Area** child GameObject (by unchecking it)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll see the "drag circle" disappear in the **Game** panel (the user will
    not be dragging the slider, since we want this slider to be display-only):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd18eb19-ba49-4761-bc8b-2059bbd0e4f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the **Background** child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `red_square` image into the **Source Image** property of the **Image
    (Script)** component in the **Inspector**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select the Fill child of the Fill Area child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `green_square` image into the **Source Image** property of the **Image
    (Script)** component in the **Inspector**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select the **Fill Area** child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Rect Transform** component, use the **Anchors** preset position of
    left-middle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set **Width** to `155` and **Height** to `12`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8666f436-e0d5-4ef4-84c5-61d9b833df10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a C# script class called `SliderTimerDisplay` that contains the following
    code, and add an instance as a scripted component to the **Slider** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Run your game and you will see the slider move with each second, revealing more
    and more of the red background to indicate the time remaining.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You hid the **Handle Slide Area** child so that the **UI Slider** is for display
    only, and cannot be interacted with by the user. The **Background** color of the
    **UI Slider** was set to red, so that, as the counter goes down, more and more
    red is revealed – warning the user that the time is running out.
  prefs: []
  type: TYPE_NORMAL
- en: The **Fill** of the **UI Slider** was set to green, so that the proportion remaining
    is displayed in green – the more green displayed, the greater the value of the
    slider/timer.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the provided **CountdownTimer** script class was automatically
    added as a component to the Slider via `[RequireComponent(...)]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Awake()` method caches references to the **CountdownTimer** and **Slider**
    components in the `countdownTimer` and `sliderUI` variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method calls the `SetupSlider()` method and then resets the countdown
    timer to start counting down from 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetupSlider()` method sets up this slider for float (decimal) values between
    `0.0` and `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: In each frame, the `Update()` method sets the slider value to the float returned
    by calling the `GetProportionRemaining()` method from the running timer. At runtime,
    Unity adjusts the proportion of red/green displayed in the Slider to match the
    slider's value.
  prefs: []
  type: TYPE_NORMAL
- en: Setting custom mouse cursors for 2D and 3D GameObjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cursor icons are often used to indicate the nature of the interaction that
    can be done with the mouse. Zooming, for instance, might be illustrated by a magnifying
    glass; shooting, on the other hand, is usually represented by a stylized target.
    In this recipe, we will learn how to implement custom mouse cursor icons to better
    illustrate your gameplay – or just to escape the Windows, macOS, and Linux default
    UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01301f05-5a91-4ed1-bbc6-28b3a4922d95.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the folders that you'll need in the `02_06`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make a custom cursor appear when the mouse is over a GameObject, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided folder, called `Images`. Select the `unity_logo` image in
    the **Project** panel, and in the **Inspector** change the **Texture T**ype to
    **Sprite (2D and UI)**. This is because we'll use this image for a **2D Sprite**
    GameObject, and it requires this **Texture Type** (it won't work with the **Default**
    type).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **2D Object | Sprite** GameObject to the scene. Name this **New Sprite**,
    if this wasn't the default name when created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, set the **Sprite** property of the **Sprite Renderer**
    component to the `unity_logo` image. In the GameObjects **Transform** component,
    set the scaling to `(3,3,3)`, and if necessary, reposition the **Sprite** to be
    centered in the **Game** panel when the **Scene** runs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add to the **Sprite** GameObject a `Physics 2D | Box Collider`. This is needed
    for this GameObject to receive `OnMouseEnter` and `OnMouseExit` event messages.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the provided folder called `IconsCursors`. Select all three images in
    the **Project** panel, and in the **Inspector**, change the **Texture Type** to
    **Cursor**. This will allow us to use these images as mouse cursors without any
    errors occurring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class called `CustomCursorPointer`, containing the following
    code, and add an instance as a scripted component to the **New Sprite** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Event methods `OnMouseEnter()` and `OnMouseExit()` have been deliberately declared
    as public. This will allow these methods to also be called from UI GameObjects
    when they receive the `OnPointerEnterExit` events.
  prefs: []
  type: TYPE_NORMAL
- en: With the **New Sprite** item selected in the **Hierarchy**, drag the `CursorTarget`
    image into the public **Cursor Texture 2D** variable slot in the **Inspector** for
    the **Customer Cursor Pointer (Script)** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the current **Scene**. When the mouse pointer moves over the Unity
    logo sprite, it will change to the custom **CursorTarget** image that you chose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a **Sprite** GameObject and assigned it the Unity logo image. You
    imported some cursor images, and set their **Texture** **Type** to **Cursor**,
    so they could be used to change the image for the user's mouse pointer. You added
    a **Box Collider** to the sprite GameObject so that it would receive `OnMouseEnter`
    and `OnMouseExit` event messages.
  prefs: []
  type: TYPE_NORMAL
- en: You created the `**CustomCursorPointer**` script class, and added an instance-object
    of this class to the sprite GameObject – this script tells Unity to change the
    mouse pointer when an `OnMouseEnter` message is received, that is, when the user's
    mouse pointer moves over the part of the screen where the Unity logo sprite image
    is being rendered. When an `OnMouseExit` event is received (the users mouse pointer
    is no longer over the cube part of the screen), the system is told to go back
    to the operating system's default cursor. This event should be received within
    a few milliseconds of the user's mouse exiting from the collider.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you selected the image `CursorTarget` to be the custom mouse-pointer
    cursor image the user sees when the mouse is over the Unity logo image.
  prefs: []
  type: TYPE_NORMAL
- en: Setting custom mouse cursors for UI controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous recipe demonstrated how to change the mouse pointer for 2D and
    3D GameObjects receiving `OnMouseEnter` and `OnMouseExit` events. Unity UI controls
    do not receive `OnMouseEnter` and `OnMouseExit` events. Instead, UI controls can
    be made to respond to `PointerEnter` and `PointerExit` events if we add a special
    **Event Trigger** component to the UI GameObject. In this recipe, we''ll change
    the mouse pointer to a custom magnifying glass cursor when it moves over a **UI
    Button** GameObject:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21b28fb7-a234-420a-a718-912a3c5f0b93.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll use the same asset files as for the previous recipe,
    and its `CustomCursorPointer` C# script class, all of which can be found in the
    `02_07` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set a custom mouse pointer when the mouse moves over a UI control GameObject,
  prefs: []
  type: TYPE_NORMAL
- en: 'do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided `IconsCursors` folder. Select all three images in the **Project**
    panel, and in the **Inspector** change the **Texture Type** to **Cursor**. This
    will allow us to use these images as mouse cursors without any errors occurring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided `_Scripts` folder, containing the `CustomCursorPointer` C# script
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **UI Button** GameObject to the scene, leaving this named as **Button**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance of the `CustomCursorPointer` C# script class to the **Button**
    GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **Button** GameObject selected in the **Hierarchy**, drag the `CursorZoom`
    image into the public **Cursor Texture 2D** variable slot in the **Inspector** for
    the **Customer Cursor Pointer (Script)** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector**, add an **Event Triggers** component to GameObject **Button**.
    Choose menu: Add Component | Event | Event Trigger.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **PointerEnter** event to your **Event Trigger** component, click on the
    plus (**+**) button to add an event handler slot, and drag GameObject **Button**
    into the **Object** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Function** drop-down menu, choose **CustomCursorPointer** and then
    choose the `OnMouseEnter` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ca3871d1-3bfa-4acf-9a95-b3b2be861d1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Add a **Pointer Exit** event to your **Event Trigger** component, and make it
    call the `OnMouseExit()` method from **CustomCursorPointer** when this event is
    received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the current **Scene**. When the mouse pointer moves over the **UI ****Button**,
    it will change to the custom `**CursorZoom**` image that you chose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have imported some cursor images, and set their **Texture Type** to **Cursor**,
    so they could be used to change the image for the user's mouse pointer. You also
    created a **UI Button** GameObject and added to it an **Event Triggers** component.
  prefs: []
  type: TYPE_NORMAL
- en: You added an instance of the `CustomCursorPointer` C# script class to the **Button**
    GameObject, and selected the magnifying-glass-style `CursorZoom` image.
  prefs: []
  type: TYPE_NORMAL
- en: You created a **PointerEnter** event, and linked it to invoke the `OnMouseEnter`
    method of the instance of the `CustomCursorPointer` script in the **Button** GameObject (which
    changes the mouse pointer image to the custom mouse cursor).
  prefs: []
  type: TYPE_NORMAL
- en: You created a **PointerExit** event, and linked it to invoke the `OnMouseExit`
    method of the instance of the `CustomCursorPointer` C# script class to the **Button**
    GameObject (which resets the mouse cursor back to the system default).
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, you have redirected **PointerEnter/Exit** events to invoke the
    **OnMouseEnter/Exit** methods of the `CustomCursorPointer` C# script class so
    we can manage custom cursors for 2D, 3D, and UI GameObjects with the same scripting
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive text entry with an Input Field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While often we just wish to display non-interactive text messages to the user,
    there are times (such as name entry for high scores) where we want the user to
    be able to enter text or numbers into our game. Unity provides the UI Input Field
    component for this purpose. In this recipe, we''ll create an Input Field that
    prompts the user to enter their name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3f06f63-a811-466f-8a4c-e418768a5568.png)'
  prefs: []
  type: TYPE_IMG
- en: Having interactive text on the screen isn't of much use unless we can *retrieve*
    the text entered to use in our game logic, and we may need to know each time the
    user changes the text content and act accordingly. This recipe adds an event-handler
    C# script that detects each time the user has completed editing the text, and
    updates an extra message on screen confirming the newly-entered content.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an interactive text input box to the user, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, change the background of the **Main Camera** to solid
    white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **UI Input Field** to the **Scene**. Position this to the top-center of
    the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **UI Text** GameObject to the scene, naming it **Text-prompt**. Position
    this to the left of **Input Field**. Change the **Text** property of this GameObject
    to Name:.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **UI Text** GameObject named **Text-display**. Position this to
    the right of the **Input Text** control, and color its text red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all of the content of the **Text** property of this new GameObject (so
    initially the user won't see any text on screen for this GameObject).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the `DisplayChangedTextContent` C# script class to the **Text-display**
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With **Text-display** selected in the **Hierarchy**, from the **Project** panel
    drag the **Input Field** GameObject into the public **Input Field **variable of
    the **Display Changed Content (Script)** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/68735db8-5fcd-4255-a441-65c6354d8caf.png)'
  prefs: []
  type: TYPE_IMG
- en: With **Input Field** selected in the **Hierarchy**, add an **End Edit (String)**
    event to the list of event handlers for the **Input Field (Script)** component.
    Click on the plus (**+**) button to add an event-handler slot, and drag the **Text-display**
    GameObject into the **Object** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Function** drop-down menu, choose **DisplayChangedTextContent** and
    then choose the `DisplayNewValue` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the **Scene**. Each time the user types in new text and then presses
    Tab or Enter, the End Edit event will fire, and you'll see a new content text
    message displayed in red on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of interactive text input in Unity is the responsibility of the **Input
    Field** component. This needs a reference to a **UI Text** GameObject. To make
    it easier to see where the text can be typed, **Text Input** (as do Buttons) include
    a default rounded rectangle image, with a white background.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are usually three **Text** GameObjects involved with the user text input:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The static prompt text, in our recipe, displaying to the user the text Name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The faint placeholder text, reminding users where and what they should type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The editable text object (with the font and color settings) that is actually
    displayed to the user, showing the characters as they type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You created an **Input Field** GameObject, which automatically provides two
    child **Text** GameObjects, named **Placeholder** and **Text**. These represent
    the faint placeholder text, and the editable text, which you renamed **Text-input**.
    You then added a third **Text** GameObject, **Text-prompt**, containing text Name:.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in scripting that is part of **Input Field** components does lots
    of work for us. At runtime, a **Text****-Input** Input Caret GameObject is created –
    displaying the blinking vertical line to inform the user where their next letter
    will be typed. When there is no text content, the faint placeholder text will
    be displayed. As soon as any characters have been typed, the placeholder will
    be hidden and the characters typed will appear in black text. Then, if all the
    characters are deleted, the placeholder will appear again.
  prefs: []
  type: TYPE_NORMAL
- en: You then added a red fourth **Text** GameObject **Text-display**, to confirm
    to the user what they last entered in the **Input Field**. You created the `DisplayChangedTextContent` C#
    script class, and added an instance as a component of the **Text-display** GameObject.
    You linked the **Input** **Field** GameObject to the **Input Field** public variable of
    the scripted component (so the script can access the text content entered by the
    user).
  prefs: []
  type: TYPE_NORMAL
- en: You registered an **End Edit** event handler of the **Input Field**, so that
    each time the user finished editing text (by pressing *Enter*), the `DisplayNewValue()`
    method of your `DisplayChangedTextContent` scripted object is invoked (executed),
    and the red text content of **Text-display** updated to tell the user what the
    newly edited text contained.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the type of content that can be typed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Content Type** of the **Input Field (Script)**, can be set (restricted)
    to several specific types of text input, including email addresses, integer or
    decimal numbers only, or the password text (where an asterisk is displayed for
    each entered character). Learn more about Input Fields on the Unity Manual page:
    [https://docs.unity3d.com/Manual/script-InputField.html](https://docs.unity3d.com/Manual/script-InputField.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Toggles and radio buttons via Toggle Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users make choices, and often, these choices have *one of two* options (for
    example, sound on or off), or sometimes *one of several* possibilities (for example,
    difficulty level as easy/medium/hard). Unity **UI Toggles** allows users to turn
    options on and off; and when combined with **Toggle Groups**, they restrict choices
    to one of the group of items. In this recipe, we'll first explore the basic Toggle,
    and a script to respond to a change in values. Then, we'll extend the example
    to illustrate **Toggle Groups**, and styling these with round images to make them
    look more like traditional radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot shows how the button''s status changes are logged in the **Console**
    panel when the scene is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bacaea1e-3e22-4edc-9941-a46ce48400a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the images that you'll need in a folder named
    `UI Demo Textures` in the `02_09` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To display an on/off UI Toggle to the user, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, change the Background color of the **Main Camera** to
    white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **UI Toggle** to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Label** child of the **Toggle** GameObject, set the **Text** property
    to First Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the C# script class called `ToggleChangeManager` to the **Toggle**
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the **Toggle** GameObject selected, add an **On Value Changed** event to
    the list of event handlers for the **Toggle (Script)** component, click on the
    plus (**+**) button to add an event-handler slot, and drag **Toggle** into the
    **Object** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Function** drop-down menu, choose **ToggleChangeManager** and then
    choose the `PrintNewToggleValue` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the **Scene**. Each time you check or uncheck the **Toggle** GameObject,
    the **On Value Changed** event will fire, and you'll see a new text message printed
    into the **Console** window by our script, stating the new Boolean true/false
    value of the **Toggle**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a Unity **UI Toggle** GameObject, it comes with several child
    GameObjects automatically – **Background**, **Checkmark**, and the text **Label**.
    Unless we need to style the look of a **Toggle** in a special way, all that is
    needed is simply to edit the text **Label** so that the user knows what option
    or feature this **Toggle** is going to turn on/off.
  prefs: []
  type: TYPE_NORMAL
- en: The `Awake()` method of the `ToggleChangeManager` C# class caches a reference
    to the **Toggle** component in the GameObject where the script instance is located.
    When the game is running, each time the user clicks on the **Toggle** to change
    its value, an **On Value Changed** event is fired. We then register the `PrintNewToggleValue()` method,
    which is to be executed when such an event occurs. This method retrieves, and
    then prints out to the **Console** panel, the new Boolean true/false value of
    the **Toggle**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more Toggles and a Toggle Group to implement mutually-exclusive radio
    buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity **UI Toggles** are also the base components if we wish to implement a
    group of mutually-exclusive options in the style of *radio buttons*. We need to
    group related radio button **UI Toggles** together, so when one turns on, all
    the others in the group turn off.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to change the visual look if we want to adhere to the usual style
    of radio buttons as circles, rather than the square **UI Toggle** default images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38859625-98f2-41a4-8890-2feb6140fa9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a group of related toggles in the visual style of radio buttons,
    do the following to the project you just created:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `UI Demo Textures` folder into the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the C# script class `ToggleChangeManager` component from the **Toggle**
    GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the **Toggle** GameObject as **Toggle-easy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Canvas** GameObject, and in the **Inspector** add a **UI | Toggle
    Group** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **Toggle-easy** GameObject selected, in the **Inspector** drag the
    **Canvas** GameObject into the **Toggle Group** property of the **Toggle (Script)**
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Label** text to **Easy**, and tag this GameObject with a new tag
    called `Easy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Background** child GameObject of **Toggle-easy**, and in the `Image
    (Script)` component, drag the `UIToggleBG` image into the **Source Image** property
    (a circle outline).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Is On** property of the **Toggle (Script)** component is checked,
    and then select the **Checkmark** child GameObject of **Toggle-easy.** In the
    **Image (Script)** component, drag the `UIToggleButton` image into the **Source
    Image** property (a filled circle).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of the three choices (easy, medium, and hard) that we'll offer to the user,
    we'll set the easy option to be the one that is supposed to be initially selected.
    Therefore, we need its Is On property to be checked, which will lead to its checkmark
    image being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: To make these Toggles look more like radio buttons, the background of each is
    set to the circle outline image of `UIToggleBG`, and the checkmark (which displays
    the Toggles that are on) is filled with the circle image called `UIToggleButton`.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the **Toggle-easy** GameObject, naming the copy **Toggle-medium**.
    Set its **Rect Transform** property **Pos Y** to `-25` (so, this copy is positioned
    below the easy option), and uncheck the **Is On** property of the **Toggle (Script)**
    component. Tag this copy with a new tag called `Medium`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **Toggle-medium** GameObject, naming the copy **Toggle-hard**.
    Set its **Rect Transform** property **Pos Y** to `-50` (so this copy is positioned
    below the medium option). Tag this copy with a new tag called `Hard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the `RadioButtonManager` C# script class to the **Canvas**
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the **Toggle-easy** GameObject in the **Project** panel. Now do the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we based this on the **First Class** toggle, there is already an **On
    Value Changed** event to the list of event handlers for the **Toggle (Script)**
    component. Drag the **Canvas** GameObject in the target object slot (under the
    drop-down showing **Runtime Only**).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From the **Function** drop-down menu, choose **RadioButtonManager**, and then
    choose the `PrintNewGroupValue` method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the **Toggle** parameter slot, which is initially **None (Toggle)**, drag
    the **Toggle-easy** GameObject. Your **On Value** **Changed** settings in the
    Inspector should look as shown in the following screenshot:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/65dd1ee8-292b-4ff6-b111-c2de1efdb65e.png)'
  prefs: []
  type: TYPE_IMG
- en: Do the same for the **Toggle-medium** and **Toggle-hard** GameObjects – so each
    Toggle object calls the `PrintNewGroupValue(...)` method of a C# scripted component
    called `RadioButtonManager` in the **Canvas** GameObject, passing itself as a
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the **Scene**. Each time you check one of the three radio buttons,
    the **On Value Changed** event will fire, and you'll see a new text message printed
    into the **Console** window by our script, stating the tag of whichever **Toggle**
    (radio button) was just set to true (**Is On**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By adding a **Toggle Group** component to the **Canvas**, and having each **Toggle**
    GameObject link to it, the three radio buttons can tell the **Toggle Group** when
    they have been selected, and the other member of the group are then deselected.
    If you had several groups of radio buttons in the same scene, one strategy is
    to add the **Toggle Group** component to one of the **Toggles**, and have all
    the others link to that one.
  prefs: []
  type: TYPE_NORMAL
- en: We store the current radio button value (the last one switched On) in the currentDifficulty
    class property. Since variables declared outside a method are remembered, we could,
    for example, add a public method, such as `GetCurrentDifficulty()`, which could
    tell other scripted objects the current value, regardless of how long it's been
    since the user last changed their option.
  prefs: []
  type: TYPE_NORMAL
- en: Creating text and image icon UI Dropdown menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we created radio-style buttons with a **Toggle Group**,
    to present the user with a choice of one of many options. Another way to offer
    a range of choices is with a drop-down menu. Unity provides the **UI Dropdown**
    control for such menus. In this recipe, we'll offer the user a drop-down choice
    for the suit of a deck of cards (hearts, clubs, diamonds, or spades).
  prefs: []
  type: TYPE_NORMAL
- en: Note, the **UI Dropdown** created by default includes a scrollable area, in
    case there isn't space for all the options. We'll learn how to remove the GameObjects
    and components, to reduce complexity when such a feature is not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we''ll learn how to add icon images with each menu option, as shown in
    the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b3d3774-ac65-4916-a0af-a9eceab985e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the image that you need in a folder named
    Images in the `02_10` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a **UI Dropdown** control GameObject, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **UI Dropdown** to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, for the **Dropdown (Script)** component, change the list
    of **Options** from Option A, Option B, and Option C to Hearts, Clubs, Diamonds,
    and Spades. You'll need to click the plus (**+**) button to add space for the
    fourth option of **Spades**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the C# script class called `DropdownManager` to the **Dropdown**
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With the **Dropdown** GameObject selected, add an **On Value Changed** event
    to the list of event handlers for the **Dropdown** **(Script)** component, click
    on the plus (**+**) button to add an event-handler slot, and drag **Dropdown**
    into the **Object** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Function** drop-down menu, choose **DropdownManager** and then choose
    the `PrintNewValue` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the **Scene**. Each time you change the **Dropdown**, the **On
    Value Changed** event will fire, and you''ll see a new text message printed into
    the **Console** window by our script, stating the **Integer** index of the chosen
    **Dropdown** value (`0` for the first item, `1` for the second item and so on):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/85e24ad8-f22a-49c2-9711-d97c913cfc3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the **Template** child GameObject of the **Dropdown** in the **Project**
    panel, and in its **Rect Transform** reduce its height to `50`. When you run the
    **Scene**, you should see a scrollable area, since not all options fit within
    the **Template''s** height:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ba11998-516a-47aa-ac44-bf08d8837fa5.png)'
  prefs: []
  type: TYPE_IMG
- en: Delete the **Scrollbar** child of the **Template** GameObject, and remove the
    **Scroll Rect (Script)** component of the **Template** GameObject. When you run
    the **Scene** now, you'll only see the first two options (**Hearts** and **Clubs**),
    with no way to access the other two options. When you are sure your **Template's**
    height is sufficient for all its options, you can safely remove these scrollable
    options to simplify the GameObjects in your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a Unity **UI DropDown** GameObject, it comes with several components
    and child GameObjects automatically – **Label**, **Arrow**, and **Template** (and
    **ViewPort** and **Scrollbar**, and so on). **Dropdowns** work by duplicating
    the **Template** GameObject for each of the **Options** listed in the **Dropdown
    (Script)** component. Both **Text** and **Sprite** image values can be given for
    each option. The properties of the **Template** GameObject are used to control
    the visual style and behavior of the **Dropdown's** thousands of possible settings.
  prefs: []
  type: TYPE_NORMAL
- en: You first replaced the default options (Option A, Option B, and so on) in the
    **Dropdown (Script)** component. You then created a C# script class, `DropdownManager`,
    that when attached to your **Dropdown**, and having its `PrintNewValue` method
    registered for **On Value Changed** events, means that we can see the **Integer**
    index of the option each time the user changes their choice. Item index values
    start counting at zero (as with many computing items), so `0` for the first item,
    `1` for the second item, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Since the default **Dropdown** GameObject created includes a **Scroll Rect (Script)**
    component and a **Scrollbar** child GameObject, when you reduced the height of
    the **Template**, you could still scroll through the options. You then removed
    these items so that your **Dropdown** had no scrolling feature anymore.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adding images to a Dropdown control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two pairs of items Unity uses to manage how **Text** and **Images**
    are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Caption Text** and **Image** GameObjects are used to control how the currently-selected
    item for the **Dropdown** is displayed – the part of the **Dropdown** we always
    see, whether the **Dropdown** is being interacted with or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Item Text** and **Image** GameObjects are part of the **Template** GameObject,
    and they define how each option is displayed as a row when the **Dropdown** menu
    items are being displayed – the rows displayed when the user is actively working
    with the **Dropdown** GameObject.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So we have to add an **Image** in two places (**Caption** and **Template** Item),
    in order to get a **Dropdown** working fully with image icons for each option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a **Sprite** image with each **Text** item in the **Dropdown**, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the provided `Images` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, for the **Dropdown (Script)** component, for each item
    in the list of **Options** **Hearts**, **Clubs**, **Diamonds**, and **Spades**,
    drag the associated **Sprite** image from the `card_suits` folder in the **Project** panel (`hearts.png`
    for **Hearts**, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **UI Image** in the **Project** panel, and child this **Image** to the
    **Dropdown** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `hearts.png` Image from the **Project** panel into the **Source Image**
    property of the **Image (Script)** for the **Image** GameObject. Size this Image
    to `25` x `25` in the **Rect Transform**, and drag it over the letter "**H**"
    in "**Hearts**" in the **Label** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the **Label** GameObject to the right of the hearts image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Dropdown** Selected in the **Project** panel, drag the **Image** GameObject
    into the **Caption Image** property of the **Dropdown (Script)** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the **Template** GameObject (usually it is disabled).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **Image** GameObject child of **Dropdown**, and name the copy
    **Item Image**. Child this **Image** in between the **Item** **Background** and
    **Item Checkmark** GameObjects that are in **Dropdown-Template-Content-Item**
    (the **Item Image** needs to appear below the white **Item Background Image**,
    otherwise it will be covered by the background and not be visible).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since items in the **Dropdown** are slightly smaller, resize Item Image to be
    `20` x `20` in its **Rect Transform**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position **Item Image** over the "**O**" of "**Option A**" of **Item Text**,
    and then move **Item Text** to the right so that the icon and text are not on
    top of each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With **Dropdown** Selected in the **Project** panel, drag the **Item Image**
    GameObject into the **Item Image** property of the D**ropdown (Script)** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7688bad7-9deb-4c0b-a0b7-3ad351c1acaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Disable the **Template** GameObject, then run the scene to see your **Dropdown**
    with icon images for each menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity UI Dropdowns are powerful interface components – learn more about these
    controls from the Unity Manual at [https://docs.unity3d.com/Manual/script-Dropdown.html.](https://docs.unity3d.com/Manual/script-Dropdown.html)
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a radar to indicate the relative locations of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A radar displays the locations of other objects relative to the player, usually
    based on a circular display, where the center represents the player, and each
    graphical blip indicates how far away and what relative direction objects are
    to the player. Sophisticated radar displays will display different categories
    of objects with different colored or shaped blip icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the screenshot, we can see two red square blips, indicating the relative
    position of the two red cube GameObjects tagged Cube near the player, and a yellow
    circle blip indicating the relative position of the yellow sphere GameObject tagged
    Sphere. The green circle radar background image gives the impression of an aircraft
    control tower radar or something similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0653d19-56ae-44d5-87ab-51d345421ca2.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the images that you need in a folder named
    Images in `02_11`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a radar to show the relative positions of the objects, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new 3D project, with a textured **Terrain**. Import the **Environment**
    standard asset package contents, by choosing menu: Assets | Import Package | Environment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a terrain by navigating to the Create | 3D Object | Terrain menu.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Size the **Terrain** 20 x 20, positioned at `(-10, 0, -10)` - so that its center
    is at `(0, 0, 0)`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/53fd93f2-6896-4a29-8a4c-b4ff879ed5a9.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Texture paint your **T****errain** with the **SandA****lbedo** option, as shown
    in the screenshot. You need to select the **Paintbrush** tool in the **Terrain**
    component, then click the **Edit Textures** button, and select the **SandAlbedo**
    texture from the imported **Environme****nt** assets:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d917b712-db0a-4e2e-a6ae-ef16ce9b5d2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Import the provided folder `Images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 3D Cube GameObject at **Position** `(2, 0.5, 2)`. Create a Tag `Cube`
    and tag this GameObject with this new tag. Texture this GameObject with the red
    image called `icon32_square_yellow`, by dragging image `icon32_square_yellow`
    from the **Project** panel over this GameObject in the **Hierarchy** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **cube** GameObject, and move this new cube to **Position** `(6,
    0.5, 2)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 3D Sphere GameObject at Position `(0, 0.5, 4)`. Create a Tag with the
    name `Sphere` and tag this GameObject with this new tag. Texture this GameObject
    with the red image called `icon32_square_yellow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the **Characters** standard asset package into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Standard Assets` folder in the **Project** panel, drag the prefab
    `ThirdPersonController` into the **Scene** and position it at `(0, 1, 0)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tag this **ThirdPersonController** GameObject as `Player` (selecting this built-in
    tag means that the camera we'll add will automatically track this player object,
    without us having to manually set the target for the camera).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the **Main Camera** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the **Cameras** standard asset package into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Standard Assets` folder in the **Project** panel, drag the prefab
    `Multi-PurposeCameraRig` into the **Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, add a UI | RawImage GameObject to the scene named
    **RawImage-radar**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **RawImage-radar** GameObject is selected in the **Hierarchy**
    panel. From the `Images` folder in the **Project** panel, drag the `radarBackground`
    image into the **Raw Image (Script)** public property **Texture**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Rect Transform**, position **RawImage-radar** at the top-left using the
    **Anchor Presets** item. Then set both width and height to `200` pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **UI RawImage** named **RawImage-blip**. Assign it the `yellowCircleBlackBorder` Texture
    image file from the **Project** panel. In the **Project** panel, create a new
    empty prefab asset file named `blip-sphere`, and drag the **RawImage-blip** GameObject
    into this prefab to store all its properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the texture of GameObject **RawImage-blip** to `redSquareBlackBorder` from
    the **Project** panel. In the **Project** panel, create a new empty prefab asset
    file named `blip-cube`, and drag the **RawImage-blip** GameObject into this prefab
    to store all its properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the **RawImage-blip** GameObject from the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class called `Radar`, containing the following code, and
    add an instance as a scripted component to the **RawImage-radar** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run your game. You will see two red squares and one yellow circle on the radar,
    showing the relative positions of the red cubes and yellow sphere. If you move
    too far away, the blips will disappear.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A radar background is displayed on the screen. The center of this circular image
    represents the position of the player's character. You have created two prefabs;
    one for red square images to represent each red cube found within the radar distance,
    and one for yellow circles to represent yellow sphere GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Radar` C# script class has been added to the radar **UI Image** GameObject.
    This class defines four public variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**insideRadarDistance**: This value defines the maximum distance in the scene
    that an object may be from the player to still be included on the radar (objects
    further than this distance will not be displayed on the radar).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**blipSizePercentage**: This public variable allows the developer to decide
    how large each blip will be, as a proportion of the radar''s image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rawImageBlipCube** and **rawImageBlipSphere**: These are references to the
    prefab UI RawImages that are to be used to visually indicate the relative distance
    and position of cubes and spheres on the radar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there is a lot happening in the code for this recipe, each method will
    be described in its own section.
  prefs: []
  type: TYPE_NORMAL
- en: The Start() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Start()` method first caches a reference to the **Raw Image** of the radar
    background image. Then it caches a reference to the **Transform** component of
    the player's character (tagged as `Player`). This allows the scripted object to
    know about the position of the Player's character in each frame. Next, the width
    and height of the radar image are cached – so, the relative positions for blips
    can be calculated, based on the size of this background radar image. Finally,
    the size of each blip (`blipWidth` and `blipHeight`) is calculated, using the
    `blipSizePercentage` public variable.
  prefs: []
  type: TYPE_NORMAL
- en: The Update() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Update()` method calls the `RemoveAllBlips()` method, which removes any
    old **RawImage** UI GameObjects of cubes and spheres that might currently be displayed.
    If we didn't remove old blips before creating the new ones, then you'd see "tails"
    behind each blip as new ones are created in different positions – which could
    actually be an interesting effect.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `FindAndDisplayBlipsForTag(...)` method is called twice. First, for
    the objects tagged `Cube`, to be represented on the radar with the `rawImageBlipCube`
    prefab and then again for objects tagged `Sphere`, to be represented on the radar
    with the `rawImageBlipSphere` prefab. As you might expect, most of the hard work
    for the radar is to be performed by the `FindAndDisplayBlipsForTag(...)` method.
  prefs: []
  type: TYPE_NORMAL
- en: This code is a simple approach to creating a radar. It is very inefficient to
    make repeated calls to `FindGameObjectWithTag("Blip")` for every frame from the
    `Update()` method. In a real game, it would be much better to cache all created
    blips in something such as a `List` or `ArrayList`, and then simply loop through
    that list each time.
  prefs: []
  type: TYPE_NORMAL
- en: The FindAndDisplayBlipsForTag(...) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method inputs two parameters: the string tag for the objects to be searched
    for, and a reference to the `RawImage` prefab to be displayed on the radar for
    any such tagged objects within the range.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the current position of the player''s character is retrieved from the
    cached player **Transform** variable. Next, an array is constructed, referring
    to all GameObjects in the scene that have the provided tag. This array of GameObjects
    is looped through, and for each GameObject, the following actions are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: The position of the target GameObject is retrieved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance from this target position to the player's position is calculated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this distance is within the range (less than or equal to `insideRadarDistance`),
    then the `CalculateBlipPositionAndDrawBlip(...)` method is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CalculateBlipPositionAndDrawBlip (...) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method inputs three parameters: the position of the player, the position
    of the target, and a reference to the prefab of the blip to be drawn.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three steps are now required to get the blip for this object to appear on the
    radar:'
  prefs: []
  type: TYPE_NORMAL
- en: The normalized position of the target is calculated by calling `NormalizedPosition(...)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The position of the blip on the radar is calculated from this normalized position
    by calling `CalculateBlipPosition(...)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `RawImage` blip is displayed by calling `DrawBlip(...)` and passing the
    blip position and the reference to the RawImage prefab that is to be created there
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The NormalisedPosition(...) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NormalizedPosition(...)` method inputs the player's character position
    and the target GameObject position. It has the goal of outputting the relative
    position of the target to the player, returning a **Vector3** object with a triplet
    of X, Y, and Z values. Note that since the radar is only 2D, we ignore the Y-value
    of target GameObjects. So, the Y-value of the **Vector3** object returned by this
    method will always be `0`. So, for example, if a target was at exactly the same
    location as the player, the returned X, Y, Z **Vector3** object would be `(0,
    0, 0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that the target GameObject is no further from the player's character
    than `insideRadarDistance`, we can calculate a value in the `-1 ... 0 ... +1`
    range for the X and Z axis by finding the distance on each axis from the target
    to the player, and then dividing it by `insideRadarDistance`. An X-value of `-1`
    means that the target is fully to the left of the player (at a distance that is
    equal to insideRadarDistance), and +1 means it is fully to the right. A value
    of 0 means that the target has the same X position as the player's character.
    Likewise, for `-1 ... 0 ... +1` values in the Z-axis (this axis represents how
    far, in front or behind us an object, is located, which will be mapped to the
    vertical axis in our radar).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this method constructs and returns a new **Vector3** object, with the
    calculated X and Z normalized values, and a Y-value of zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**The normalized position**'
  prefs: []
  type: TYPE_NORMAL
- en: A normalized value is one that has been simplified in some way, so the context
    has been abstracted away. In this recipe, what we are interested in is where an
    object is relative to the player. So, our normal form is to get a value of the
    X and Z position of a target in the `-1` to `+1` range for each axis. Since we
    are only considering GameObject within our `insideRadarDistance` value, we can
    map these normalized target positions directly onto the location of the radar
    image in our UI.
  prefs: []
  type: TYPE_NORMAL
- en: The CalculateBlipPosition(...) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we calculate `angleToTarget`: the angle from `(0, 0, 0)` to our normalized
    target position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we calculate `anglePlayer`: the angle the player''s character is facing.
    This recipe makes use of the yaw angle of the rotation, which is the rotation
    about the Y-axis, that is, the direction that a character controller is facing.
    This can be found in the Y component of a GameObject''s `eulerAngles` component
    of its transform. You can imagine looking from above and down at the character
    controller, and see what direction they are facing – this is what we are trying
    to display graphically with the radar.'
  prefs: []
  type: TYPE_NORMAL
- en: Our desired radar angle (the `angleRadarDegrees` variable) is calculated by
    subtracting the player's direction angle from the angle between the target and
    player, since a radar displays the relative angle from the direction that the
    player is facing, to the target object. In mathematics, an angle of zero indicates
    an east direction. To correct this, we need to also subtract `90` degrees from
    the angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The angle is then converted into radians, since this is required for the Unity
    trigonometry methods. We then multiply the `Sin()` and `Cos()` results by our
    normalized distances to calculate the X and Y values, respectively (see the following
    diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a325868-bf9e-4c56-8f79-8b4bd53b460d.png)'
  prefs: []
  type: TYPE_IMG
- en: In this figure, alpha is the angle between player and target object, "a" is
    the adjacent side, "h" is the hypotenuse, and "o" is the side opposite the angle.
  prefs: []
  type: TYPE_NORMAL
- en: Our final position values need to be expressed as pixel lengths, relative to
    the center of the radar. So, we multiply our `blipX` and `blipY` values by half
    the width and the height of the radar; note that we multiply only with half the
    width, since these values are relative to the center of the radar. We then add
    half the width and height of the radar image to the blipX/Y values. So, these
    values are now positioned relative to the center.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a new **Vector2** object is created and returned, passing back these
    final calculated X and Y pixel values for the position of our blip icon.
  prefs: []
  type: TYPE_NORMAL
- en: The DrawBlip() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DrawBlip()` method takes the input parameters of the position of the blip
    (as a **Vector2** X, Y pair), and the reference to the **RawImage** prefab to
    be created at that location on the radar.
  prefs: []
  type: TYPE_NORMAL
- en: A new GameObject is created (Instantiated) from the prefab, and is parented
    to the **radar** GameObject (of which the scripted object is also a component).
    A reference is retrieved from the **Rect Transform** of the new **RawImage** GameObject
    that has been created for the blip. Calls to the Unity **RectTransform** method
  prefs: []
  type: TYPE_NORMAL
- en: '`SetInsetAndSizeFromParentEdge(...)`  result in the blip GameObject being positioned
    at the provided horizontal and vertical locations over the radar image, regardless
    of where in the Game panel the background radar image has been located.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adapt for object heights and opaque obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This radar script scans 360 degrees all around the player, and only considers
    straight line distances in the X-Z plane. So, the distances in this radar are
    not affected by any height difference between the player and target GameObjects.
    The script can be adapted to ignore targets whose height is more than some threshold
    different to the player's height.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as presented, this recipe radar sees through *everything*, even if there
    are obstacles between the player and the target. The recipe can be extended to
    not show obscured targets through the use of the Ray Casting techniques. See the
    Unity scripting reference for more details about ray-casting: [http://docs.unity3d.com/ScriptReference/Physics.Raycast.html](http://docs.unity3d.com/ScriptReference/Physics.Raycast.html).
  prefs: []
  type: TYPE_NORMAL
