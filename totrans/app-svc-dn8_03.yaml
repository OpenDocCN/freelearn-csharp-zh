- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building Entity Models for SQL Server Using EF Core
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EF Core 为 SQL Server 构建实体模型
- en: This chapter is about managing relational data stored in SQL Server, Azure SQL
    Database, or Azure SQL Edge by using the higher-level object-to-data store mapping
    technology named **Entity Framework Core** (**EF Core**). Then, you will learn
    how to store entity models that use inheritance hierarchies using three different
    mapping strategies. Finally, you will build class libraries for a SQL Server database
    that will be used in code examples throughout the rest of this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何使用名为**Entity Framework Core**（**EF Core**）的高级对象到数据存储映射技术来管理存储在 SQL Server、Azure
    SQL Database 或 Azure SQL Edge 中的关系型数据。然后，你将学习如何使用三种不同的映射策略存储使用继承层次结构的实体模型。最后，你将构建用于本书其余部分代码示例的
    SQL Server 数据库的类库。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Managing SQL Server data with EF Core
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EF Core 管理SQL Server数据
- en: Mapping inheritance hierarchies with EF Core
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EF Core 映射继承层次结构
- en: Building a reusable entity data model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可重用的实体数据模型
- en: Managing data with EF Core
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EF Core 管理数据
- en: EF Core is an **object-relational mapper** (**ORM**) that uses ADO.NET underneath
    when working with SQL Server. Because it is a higher-level technology, it is not
    as efficient as using ADO.NET directly, but it can be easier for developers to
    work with because they can treat the data as objects instead of rows in multiple
    tables. This should feel more natural for an object-oriented developer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 是一个**对象关系映射器**（**ORM**），当与 SQL Server 一起工作时，它使用 ADO.NET。因为它是一个高级技术，所以它不如直接使用
    ADO.NET 效率高，但它可以使开发人员更容易工作，因为他们可以将数据视为对象而不是多个表中的行。这对于面向对象的开发者来说应该感觉更自然。
- en: 'EF Core 8 only targets .NET 8\. EF Core 7 targeted .NET 6, so it could be used
    with both the **Long Term Support** (**LTS**) release of .NET 6 and the **Standard
    Term Support** (**STS**) release of.NET 7, as shown in *Figure 3.1*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 8 仅针对 .NET 8。EF Core 7 针对的是 .NET 6，因此它可以与 .NET 6 的**长期支持**（**LTS**）版本和
    .NET 7 的**标准支持**（**STS**）版本一起使用，如图3.1所示：
- en: '![](img/B19587_03_01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_03_01.png)'
- en: 'Figure 3.1: EF Core 7 targeted .NET 6 or later'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：EF Core 7 针对.NET 6或更高版本
- en: When EF Core 9 is released in November 2024, we can expect it to target .NET
    8 or later, so you can upgrade EF Core while still getting long-term support for
    the .NET 8 platform. The EF Core team is responsible for making sure that you
    will be able to swap 8 for 9 in the version number of their packages and your
    code should still work. They are usually very good at that, and they will document
    any needed changes to your code in the official release notes for EF Core 9.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当 EF Core 9 在2024年11月发布时，我们可以期待它将针对 .NET 8 或更高版本，因此你可以在仍然获得 .NET 8 平台长期支持的同时升级
    EF Core。EF Core 团队负责确保你将能够在他们的包版本号中将8替换为9，并且你的代码仍然可以工作。他们通常在这方面做得很好，并且会在 EF Core
    9 的官方发布说明中记录任何必要的代码更改。
- en: Understanding Entity Framework Core
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Entity Framework Core
- en: As well as traditional RDBMSs like SQL Server, EF Core supports modern cloud-based,
    nonrelational, schema-less data stores, such as Azure Cosmos DB and MongoDB, sometimes
    with third-party providers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统的 RDBMS，如 SQL Server 之外，EF Core 还支持现代基于云的、非关系型、无模式的数据库存储，如 Azure Cosmos
    DB 和 MongoDB，有时需要第三方提供程序。
- en: 'There are two approaches to working with EF Core:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与 EF Core 一起工作的有两种方法：
- en: '**Database First**: A database already exists, so you build a model that matches
    its structure and features.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库优先**：已存在数据库，因此你构建一个与其结构和功能相匹配的模型。'
- en: '**Code First**: No database exists, so you build a model and then use EF Core
    to create a database that matches its structure and features.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码优先**：不存在数据库，因此你构建一个模型，然后使用 EF Core 创建一个与其结构和功能相匹配的数据库。'
- en: We will use EF Core with an existing database because that is the most common
    scenario. You will also see an example of Code First later in this chapter that
    will create its database at runtime.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用 EF Core 与现有数据库一起使用，因为这是最常见的场景。你将在本章后面看到代码优先的示例，该示例将在运行时创建其数据库。 '
- en: Scaffolding models using an existing database
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现有数据库生成模型框架
- en: Scaffolding is the process of using a tool to create classes that represent
    the model of an existing database using reverse engineering. A good scaffolding
    tool allows you to extend the automatically generated classes and then regenerate
    those classes without losing your extended classes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 框架生成是通过使用工具创建代表现有数据库模型的类的过程，该过程使用逆向工程。一个好的框架生成工具允许你扩展自动生成的类，然后在不丢失扩展类的情况下重新生成这些类。
- en: If you know that you will never regenerate the classes using the tool, then
    feel free to change the code for the automatically generated classes as much as
    you want. The code generated by the tool is just the best approximation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道您永远不会使用此工具重新生成类，那么您可以随意更改自动生成的类的代码。工具生成的代码只是最佳近似。
- en: '**Good Practice**: Do not be afraid to overrule a tool when you know better.
    For example, when using SQLite for the Northwind database, date/time columns are
    mapped to `string` properties, and `money` columns are mapped to `double` properties.
    In the Northwind database, these would be better mapped to `DateTime` and `decimal`
    respectively, but in another database, they might need more flexibility. As another
    example, in the Northwind database, a `CustomerId` should always be five uppercase
    alphabetic characters. The tool cannot infer this automatically, so you could
    add a regular expression to validate it. Keep in mind that tool behavior is one
    of the more volatile components of .NET, so these examples may not be valid by
    the time you read this book.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您知道更好的方法，不要害怕推翻工具。例如，当使用 SQLite 为 Northwind 数据库时，日期/时间列映射到 `string`
    属性，而 `money` 列映射到 `double` 属性。在 Northwind 数据库中，这些列最好分别映射到 `DateTime` 和 `decimal`，但在另一个数据库中，可能需要更多的灵活性。另一个例子是在
    Northwind 数据库中，`CustomerId` 应始终是五个大写字母。工具无法自动推断这一点，因此您可以添加正则表达式来验证它。请记住，工具行为是
    .NET 中更易变的部分之一，因此这些示例在您阅读此书时可能不再有效。'
- en: Setting up the dotnet-ef tool
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 dotnet-ef 工具
- en: .NET has a command-line tool named `dotnet`. It can be extended with capabilities
    useful for working with EF Core. It can perform design-time tasks like creating
    and applying migrations from an older model to a newer model and generating code
    for a model from an existing database.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 有一个名为 `dotnet` 的命令行工具。它可以扩展用于与 EF Core 一起使用的功能。它可以执行设计时任务，例如从旧模型创建并应用迁移到新模型，以及从现有数据库生成模型的代码。
- en: The `dotnet` `ef` command-line tool is not automatically installed. You must
    install this package as either a **global** or **local tool**. If you have already
    installed an older version of the tool, then you should uninstall any existing
    version.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet` `ef` 命令行工具不是自动安装的。您必须将此包安装为 **全局** 或 **本地** 工具。如果您已经安装了此工具的旧版本，那么您应该卸载任何现有版本。'
- en: 'Let’s make sure you have the latest version of the tool installed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保您已安装了工具的最新版本：
- en: 'At a command prompt or terminal, check if you have already installed `dotnet-ef`
    as a global tool, as shown in the following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，检查您是否已将 `dotnet-ef` 作为全局工具安装，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Check in the list if an older version of the tool has been installed, like
    the one for .NET 7, as shown in the following output:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中检查是否已安装工具的旧版本，如 .NET 7 的版本，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If an older version is already installed, then uninstall the tool, as shown
    in the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已经安装了旧版本，那么请按照以下命令卸载工具：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Install the latest version, as shown in the following command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下命令安装最新版本：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If necessary, follow any OS-specific instructions to add the `dotnet tools`
    directory to your `PATH` environment variable, as described in the output of installing
    the `dotnet-ef` tool.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，按照任何特定于操作系统的说明将 `dotnet tools` 目录添加到您的 `PATH` 环境变量中，如安装 `dotnet-ef` 工具的输出中所述。
- en: 'If you want to install a preview version, you can specify a version wildcard,
    for example, for EF Core 9 previews, as shown in the following command:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想安装预览版本，您可以指定版本通配符，例如，对于 EF Core 9 预览版，如下所示：
- en: '`dotnet tool install --global dotnet-ef --version 9-*`'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`dotnet tool install --global dotnet-ef --version 9-*`'
- en: 'Instead of uninstalling and then installing, you can update using the following
    command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令进行更新，而不是卸载然后安装：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Defining EF Core models
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 EF Core 模型
- en: EF Core uses a combination of **conventions**, **annotation attributes**, and
    **Fluent API** statements to build an **entity model** at runtime so that any
    actions performed on the classes can later be automatically translated into actions
    performed on the actual database. An **entity class** represents the structure
    of a table, and an instance of the class represents a row in that table.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 使用 **约定**、**注解属性** 和 **Fluent API** 语句的组合在运行时构建 **实体模型**，以便对类执行的任何操作都可以稍后自动转换为对实际数据库执行的操作。**实体类**代表表的结构，类的实例代表该表中的一行。
- en: First, we will review the three ways to define a model, with code examples,
    and then we will create some classes that implement those techniques.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将回顾定义模型的三种方法，并附带代码示例，然后我们将创建一些实现这些技术的类。
- en: Using EF Core conventions to define the model
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 EF Core 约定来定义模型
- en: 'The code we will write will use the following conventions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的代码将使用以下约定：
- en: The name of a table is assumed to match the name of a `DbSet<T>` property in
    the `DbContext` class, for example, `Products`.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设表的名称与 `DbContext` 类中 `DbSet<T>` 属性的名称相匹配，例如 `Products`。
- en: The names of the columns are assumed to match the names of properties in the
    entity model class, for example, `ProductId`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设列的名称与实体模型类中的属性名称相匹配，例如 `ProductId`。
- en: The `string` .NET type is assumed to be an `nvarchar` type in the database.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库中 `string` 类型被假定为 `nvarchar` 类型。
- en: The `int` .NET type is assumed to be an `int` type in the database.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.NET` 类型 `int` 被假定为数据库中的 `int` 类型。'
- en: The primary key is assumed to be a property that is named `Id` or `ID`. Or,
    when the entity model class is named `Product`, then the property can be named
    `ProductId` or `ProductID`. If this property is of an integer type or the `Guid`
    type, then it is also assumed to be an `IDENTITY` column (a column type that automatically
    assigns a value when inserting).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设主键是一个名为 `Id` 或 `ID` 的属性。或者，当实体模型类名为 `Product` 时，属性可以命名为 `ProductId` 或 `ProductID`。如果此属性是整数类型或
    `Guid` 类型，则它也被假定为 `IDENTITY` 列（一种在插入时自动分配值的列类型）。
- en: '**Good Practice**: There are many other conventions that you should know, and
    you can even define your own, but that is beyond the scope of this book. You can
    read about them at the following link: [https://learn.microsoft.com/en-us/ef/core/modeling/](https://learn.microsoft.com/en-us/ef/core/modeling/).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：还有许多其他约定你应该了解，你甚至可以定义自己的约定，但这超出了本书的范围。你可以在以下链接中了解它们：[https://learn.microsoft.com/en-us/ef/core/modeling/](https://learn.microsoft.com/en-us/ef/core/modeling/)。'
- en: Using EF Core annotation attributes to define the model
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 EF Core 注解属性来定义模型
- en: Conventions often aren’t enough to completely map the classes to the database
    objects. For example, some databases like SQLite use dynamic column types so the
    tool has to guess about what property types its columns should map to, based on
    the current data values in that column.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 约定通常不足以完全将类映射到数据库对象。例如，一些数据库如 SQLite 使用动态列类型，因此工具必须根据该列当前的数据值来猜测其列应映射到的属性类型。
- en: 'A simple way of adding more smarts to your model is to apply annotation attributes,
    as shown in *Table 3.1*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的模型添加更多智能的一种简单方法是通过应用注解属性，如下表 3.1 所示：
- en: '| **Attribute** | **Description** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `[Required]` | Ensures the value is not null. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `[Required]` | 确保值不为空。|'
- en: '| `[StringLength(50)]` | Ensures the value is up to 50 characters in length.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `[StringLength(50)]` | 确保值的长度不超过 50 个字符。|'
- en: '| `[RegularExpression(expression)]` | Ensures the value matches the specified
    regular expression. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `[RegularExpression(expression)]` | 确保值匹配指定的正则表达式。|'
- en: '| `[Column(TypeName = "money", Name = "UnitPrice")]` | Specifies the column
    type and column name used in the table. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `[Column(TypeName = "money", Name = "UnitPrice")]` | 指定在表中使用的列类型和列名。|'
- en: 'Table 3.1: Common EF Core annotation attributes'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：常见的 EF Core 注解属性
- en: 'For example, in the database, the maximum length of a product name is 40, and
    the value cannot be null, as shown highlighted in the following partial DDL code,
    which defines how to create a table named `Products`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在数据库中，产品名称的最大长度为 40，且值不能为空，如下面部分 DDL 代码所示，该代码定义了如何创建名为 `Products` 的表，其中高亮显示的部分如下：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In a `Product` class, we could apply attributes to specify this, as shown in
    the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Product` 类中，我们可以应用属性来指定这一点，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Good Practice**: If you have nullability checks enabled, then you do not
    need to decorate a non-nullable reference type with the `[Required]` attribute
    as shown above. This is because the C# nullability will flow to the EF Core model.
    A `string` property will be required; a `string?` property will be optional, in
    other words, nullable. You can read more about this at the following link: [https://learn.microsoft.com/en-us/ef/core/modeling/entity-properties?tabs=data-annotations%2Cwith-nrt#required-and-optional-properties](https://learn.microsoft.com/en-us/ef/core/modeling/entity-properties?tabs=data-annotations%2Cwith-nrt#required-and-optional-properties).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您启用了可空性检查，那么您不需要像上面那样用 `[Required]` 属性装饰非可空引用类型。这是因为 C# 的可空性会传播到
    EF Core 模型。一个 `string` 属性将是必需的；一个 `string?` 属性将是可选的，换句话说，是可空的。您可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/ef/core/modeling/entity-properties?tabs=data-annotations%2Cwith-nrt#required-and-optional-properties](https://learn.microsoft.com/en-us/ef/core/modeling/entity-properties?tabs=data-annotations%2Cwith-nrt#required-and-optional-properties)。'
- en: When there isn’t an obvious map between .NET types and database types, an attribute
    can be used.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当 .NET 类型与数据库类型之间没有明显的映射时，可以使用属性。
- en: 'For example, in the database, the column type of `UnitPrice` for the `Products`
    table is `money`. .NET does not have a `money` type, so it should use `decimal`
    instead, as shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在数据库中，`Products` 表的 `UnitPrice` 列的数据类型是 `money`。.NET 没有名为 `money` 的数据类型，因此应该使用
    `decimal` 代替，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another example is for the `Categories` table, as shown highlighted in the
    following DDL code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是针对 `Categories` 表，如下面的 DDL 代码所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Description` column can be longer than the maximum 8,000 characters that
    can be stored in an `nvarchar` variable, so it needs to map to `ntext` instead,
    as shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Description` 列的长度可以超过可以存储在 `nvarchar` 变量中的最大 8,000 个字符，因此它需要映射到 `ntext`，如下面的代码所示：'
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the EF Core Fluent API to define the model
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 EF Core Fluent API 定义模型
- en: The last way that the model can be defined is by using the Fluent API. This
    API can be used instead of attributes, as well as being used in addition to them.
    One reason you might need to do this is if the entity models need to be defined
    in a .NET Standard 2.0 class library so they can be used on legacy platforms.
    In this case, the class library should not include references to data annotation
    libraries. Another reason is that your team might have a policy to separate raw
    data models from validation rules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 模型定义的最后一種方式是使用 Fluent API。此 API 可以替代属性，也可以与它们一起使用。您可能需要这样做的一个原因是在 .NET Standard
    2.0 类库中定义实体模型，以便它们可以在旧平台上使用。在这种情况下，类库不应包含对数据注释库的引用。另一个原因是，您的团队可能有政策将原始数据模型与验证规则分开。
- en: 'For example, to define the `ProductName` property, instead of decorating the
    property with two attributes, an equivalent Fluent API statement could be written
    in the `OnModelCreating` method of the database context class, as shown in the
    following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要定义 `ProductName` 属性，而不是用两个属性装饰该属性，可以在数据库上下文类的 `OnModelCreating` 方法中编写一个等效的
    Fluent API 语句，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This keeps the entity model class simpler. You will see an example of this in
    the coding task below.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得实体模型类更加简单。您将在下面的编码任务中看到一个例子。
- en: Understanding data seeding with the Fluent API
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Fluent API 的数据初始化
- en: Another benefit of the Fluent API is to provide initial data to populate a database.
    EF Core automatically works out what insert, update, or delete operations must
    be executed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Fluent API 的另一个好处是提供初始数据以填充数据库。EF Core 会自动计算出需要执行哪些插入、更新或删除操作。
- en: 'For example, if we wanted to make sure that a new database has at least one
    row in the `Product` table, then we would call the `HasData` method, as shown
    in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想确保新数据库中至少有一行在 `Product` 表中，那么我们会调用 `HasData` 方法，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Calls to `HasData` take effect either during a data migration executed by the
    `dotnet ef database update` command or when you call the `Database.EnsureCreated`
    method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `HasData` 的调用在执行 `dotnet ef database update` 命令的数据迁移期间生效，或者当您调用 `Database.EnsureCreated`
    方法时。
- en: Our model will map to an existing database that is already populated with data,
    so we will not need to use this technique in our code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型将映射到一个已经填充了数据的现有数据库，因此我们不需要在我们的代码中使用这种技术。
- en: Defining the Northwind database model
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Northwind 数据库模型
- en: A `Northwind` class will be used to represent the database. To use EF Core,
    the class must inherit from `DbContext`. This class understands how to communicate
    with databases and dynamically generate SQL statements to query and manipulate
    data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用 `Northwind` 类来表示数据库。为了使用 EF Core，该类必须从 `DbContext` 继承。这个类了解如何与数据库通信并动态生成
    SQL 语句来查询和操作数据。
- en: Your `DbContext`-derived class should have an overridden method named `OnConfiguring`,
    which will set the database connection string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `DbContext` 派生类应该有一个名为 `OnConfiguring` 的重写方法，它将设置数据库连接字符串。
- en: Inside your `DbContext`-derived class, you must define at least one property
    of the `DbSet<T>` type. These properties represent the tables. To tell EF Core
    what columns each table has, the `DbSet<T>` properties use generics to specify
    a class that represents a row in the table. That entity model class has properties
    that represent its columns.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的由 `DbContext` 派生的类中，你必须定义至少一个 `DbSet<T>` 类型的属性。这些属性代表表。为了告诉 EF Core 每个表有哪些列，`DbSet<T>`
    属性使用泛型来指定一个代表表中行的类。这个实体模型类具有代表其列的属性。
- en: The `DbContext`-derived class can optionally have an overridden method named
    `OnModelCreating`. This is where you can write Fluent API statements as an alternative
    to decorating your entity classes with attributes. This can enhance the clarity
    and maintainability of the model configuration because all of it could be in one
    place instead of scattered throughout your code base. You can also mix and match
    both techniques, but then you’d lose this primary benefit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbContext` 派生的类可以可选地有一个名为 `OnModelCreating` 的重写方法。这是你可以编写 Fluent API 语句的地方，作为用属性装饰你的实体类的替代方案。这可以增强模型配置的清晰性和可维护性，因为所有这些都可以在一个地方而不是散布在你的代码库中。你还可以混合使用这两种技术，但那样就会失去这个主要好处。'
- en: If you did not create the Northwind database, or if you deleted it, then you
    will need to create it now. Instructions are in *Chapter 2, Managing Relational
    Data Using SQL Server*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有创建 Northwind 数据库，或者如果你已经删除了它，那么你现在需要创建它。具体说明在 *第 2 章，使用 SQL Server 管理关系数据*。
- en: 'Let’s build the model for the Northwind database in a console app:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制台应用程序中为 Northwind 数据库构建模型：
- en: 'Use your preferred code editor to create a console app project, as defined
    in the following list:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器创建一个控制台应用程序项目，如下列定义：
- en: 'Project template: **Console App** / `console`.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`。
- en: 'Solution file and folder: `Chapter03`.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter03`。
- en: 'Project file and folder: `Northwind.Console.EFCore`.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.Console.EFCore`。
- en: '**Do not use top-level statements**: Cleared.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**：已清除。'
- en: '**Enable native AOT publish**: Cleared.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用原生 AOT 发布**：已清除。'
- en: 'In the `Northwind.Console.EFCore` project, add package references to the EF
    Core data provider for SQL Server, and globally and statically import the `System.Console`
    class, as shown highlighted in the following markup:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Console.EFCore` 项目中，添加对 SQL Server 的 EF Core 数据提供程序的包引用，并全局和静态导入
    `System.Console` 类，如下所示的高亮标记：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Build the project to restore packages.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包。
- en: The next step assumes a database connection string for a local SQL Server authenticated
    with Windows integrated security. Modify it for Azure SQL Database or Azure SQL
    Edge with a user ID and password if necessary.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步假设有一个用于本地 SQL Server 的数据库连接字符串，该 SQL Server 使用 Windows 集成安全性进行身份验证。如果需要，修改它以用于
    Azure SQL 数据库或 Azure SQL Edge，并使用用户 ID 和密码。
- en: 'At a command prompt or terminal in the `Northwind.Console.EFCore` folder, generate
    a model for all the tables in a new folder named `Models`, as shown in the following
    command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Console.EFCore` 文件夹中的命令提示符或终端，在名为 `Models` 的新文件夹中为所有表生成一个模型，如下所示命令：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Command-line tools need to have their commands entered all in one line. The
    `dotnet-ef` tool often needs long commands to be entered. I recommend that you
    type from the print book or copy and paste long commands like this from the eBook
    into a plain text editor like Notepad. Then make sure that the whole command is
    properly formatted as a single line with correct spacing before you then copy
    and paste it to the command line. Copying and pasting directly from the eBook
    is likely to include newline characters, missing spaces, and so on that break
    the command. All command lines that must be entered from this book are available
    to copy from as a single line at the following link: [https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md).'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令行工具需要将命令全部输入一行中。`dotnet-ef`工具经常需要输入较长的命令。我建议您从打印书籍中输入或从电子书复制并粘贴此类长命令到纯文本编辑器（如记事本）中。然后确保在复制并粘贴到命令行之前，整个命令格式正确，且间距正确。直接从电子书复制粘贴可能会包含换行符、缺失空格等问题，从而破坏命令。本书中必须输入的所有命令行都可以在以下链接处复制为单行：[https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md)。
- en: 'Note the following:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下：
- en: 'The command action: `dbcontext scaffold`.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令操作：`dbcontext scaffold`。
- en: 'The connection string: This will be different depending on whether you are
    connecting to a local SQL Server (with or without an instance name) or Azure SQL
    Database.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接字符串：这取决于您是连接到本地SQL Server（带或不带实例名称）还是Azure SQL数据库。
- en: 'The database provider: `Microsoft.EntityFrameworkCore.SqlServer`.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库提供程序：`Microsoft.EntityFrameworkCore.SqlServer`。
- en: 'The output folder: `--output-dir Models`.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出文件夹：`--output-dir Models`。
- en: 'The namespace: `--namespace Northwind.Models`.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间：`--namespace Northwind.Models`。
- en: 'The use of data annotations as well as the Fluent API: `--data-annotations`.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据注解以及流畅式API：`--data-annotations`。
- en: 'Renaming the context from `[database_name]Context`: `--context NorthwindDb`.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将上下文从 `[database_name]Context` 重命名：`--context NorthwindDb`。
- en: 'Note the build messages and warnings, as shown in the following output:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意以下输出中的构建消息和警告：
- en: '[PRE14]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Good Practice**: Do not commit your project to Git until you have fixed this
    warning. If you used a username and password to connect to your SQL Server database,
    then that information is now in your source code! We will fix this by replacing
    the fixed connection string with a dynamically generated one that reads the sensitive
    values from environment variables.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：在修复此警告之前，不要将项目提交到Git。如果您使用用户名和密码连接到SQL Server数据库，那么这些信息现在已包含在您的源代码中！我们将通过用动态生成的连接字符串替换固定的连接字符串，并从环境变量中读取敏感值来解决这个问题。'
- en: Open the `Models` folder and note the 28 class files that were automatically
    generated.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Models` 文件夹，并注意自动生成的28个类文件。
- en: 'Open `Category.cs` and note that it represents a row in the `Categories` table,
    as shown in the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Category.cs` 并注意它代表 `Categories` 表中的一行，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note the following:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下：
- en: It decorates the entity class with the `[Index]` attribute that was introduced
    in EF Core 5\. This indicates properties that should have an index for its column
    in the table. In earlier versions, only the Fluent API was supported for defining
    indexes. Since we are working with an existing database, this attribute is not
    needed. But if we want to recreate a new empty Northwind database from our code,
    then this information will be used to create indexes in the `Categories` table.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用EF Core 5中引入的 `[Index]` 属性装饰实体类。这表示应在表中为该列创建索引的属性。在早期版本中，仅支持使用流畅式API定义索引。由于我们正在处理现有数据库，此属性不是必需的。但如果我们想从我们的代码中重新创建一个新的空Northwind数据库，那么这些信息将用于在
    `Categories` 表中创建索引。
- en: The table name in the database is `Categories` but the `dotnet-ef` tool used
    the **Humanizer** third-party library to automatically singularize the class name
    to `Category`, which is a more natural name when creating a single entity.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库中的表名为 `Categories`，但 `dotnet-ef` 工具使用了 **Humanizer** 第三方库自动将类名单数化到 `Category`，这在创建单个实体时是一个更自然的名称。
- en: The entity class is declared using the `partial` keyword so that you can create
    a matching `partial` class for adding additional code. This allows you to rerun
    the tool and regenerate the entity class without losing that extra code you wrote
    in your `partial` class.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体类使用 `partial` 关键字声明，这样您就可以创建一个匹配的 `partial` 类来添加额外的代码。这允许您重新运行工具并重新生成实体类，而不会丢失在您的
    `partial` 类中编写的额外代码。
- en: The `CategoryId` property is decorated with the `[Key]` attribute to explicitly
    indicate that it is the primary key for this entity although its name follows
    the primary key convention too.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryId` 属性被装饰了 `[Key]` 属性，以明确表示它是该实体的主键，尽管其名称也遵循主键约定。'
- en: The `Products` property uses the `[InverseProperty]` attribute to define the
    foreign key relationship to the `Category` property on the `Product` entity class.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Products` 属性使用 `[InverseProperty]` 属性来定义与 `Product` 实体类上的 `Category` 属性的外键关系。'
- en: Open `ProductsAboveAveragePrice.cs` and note that it represents a row returned
    by a database view rather than a table, so it is decorated with the `[Keyless]`
    attribute.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ProductsAboveAveragePrice.cs` 并注意它代表的是数据库视图返回的行，而不是表，因此它被装饰了 `[Keyless]`
    属性。
- en: 'Open `NorthwindDb.cs` and review the class, as shown in the following edited-for-space
    code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `NorthwindDb.cs` 并查看该类，如下面的编辑过的代码所示：
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note the following:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The `NorthwindDb` data context class is `partial` to allow you to extend it
    and regenerate it in the future. We used the name `NorthwindDb` because `Northwind`
    is used for a namespace.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NorthwindDb` 数据上下文类是 `partial` 的，以便您可以扩展它并在将来重新生成它。我们使用 `NorthwindDb` 这个名字是因为
    `Northwind` 被用于一个命名空间。'
- en: '`NorthwindDb` has two constructors: a default parameter-less one and one that
    allows options to be passed in. This is useful in apps where you want to specify
    the connection string at runtime.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NorthwindDb` 有两个构造函数：一个默认的无参数构造函数和一个允许传递选项的构造函数。这在需要运行时指定连接字符串的应用程序中很有用。'
- en: The `DbSet<T>` properties that represent tables like `Categories`.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表如 `Categories` 这样的表的 `DbSet<T>` 属性。
- en: In the `OnConfiguring` method, if options have not been specified in the constructor,
    then it defaults to using the connection string used during scaffolding. It has
    a compiler warning to remind you that you should not hardcode security information
    in this connection string.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `OnConfiguring` 方法中，如果构造函数中没有指定选项，则默认使用在生成框架时使用的连接字符串。它有一个编译器警告来提醒您不要在这个连接字符串中硬编码安全信息。
- en: In the `OnModelCreating` method, the Fluent API is used to configure the entity
    classes, and then a partial method named `OnModelCreatingPartial` is invoked.
    This allows you to implement that partial method in your own partial `Northwind`
    class to add your own Fluent API configuration, which will not be lost if you
    regenerate the model classes.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `OnModelCreating` 方法中，使用 Fluent API 来配置实体类，然后调用一个名为 `OnModelCreatingPartial`
    的部分方法。这允许您在自己的部分 `Northwind` 类中实现该部分方法，添加您自己的 Fluent API 配置，这样在重新生成模型类时也不会丢失。
- en: 'At the top of the `NorthwindDb.cs` file, import the namespace for working with
    ADO.NET types, as shown in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NorthwindDb.cs` 文件顶部，导入用于处理 ADO.NET 类型的命名空间，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Modify the `OnConfiguring` method to dynamically set the connection string
    and set any sensitive parameters using environment variables, as shown in the
    following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `OnConfiguring` 方法以动态设置连接字符串，并使用环境变量设置任何敏感参数，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Close the automatically generated class files.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭自动生成的类文件。
- en: '**More Information**: If you have not worked with environment variables before,
    then you can learn about them from an online section available at the following
    link: [https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch09-environment-variables.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch09-environment-variables.md).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：如果您之前没有使用过环境变量，那么您可以从以下链接提供的在线部分了解它们：[https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch09-environment-variables.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch09-environment-variables.md)。'
- en: Querying the Northwind model
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询 Northwind 模型
- en: 'Now we can query the model:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查询模型：
- en: 'In `Program.cs`, delete the existing statements. Add statements to create an
    instance of the `NorthwindDb` data context class and use it to query the products
    table for those that cost more than a given price, as shown in the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句。添加语句以创建 `NorthwindDb` 数据上下文类的实例，并使用它来查询产品表，以获取那些价格高于给定价格的产品，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the console app and note the results, as shown in the following partial
    output:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并注意结果，如下面的部分输出所示：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output of your connection string will be different.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你的连接字符串的输出将不同。
- en: Controlling the tracking of entities
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制实体的跟踪
- en: We need to start with the definition of entity **identity resolution**. EF Core
    resolves each entity instance by reading its unique primary key value. This ensures
    no ambiguities about the identities of entities or relationships between them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从实体**身份解析**的定义开始。EF Core通过读取其唯一的键值来解析每个实体实例。这确保了关于实体身份或它们之间关系的任何歧义都不会存在。
- en: EF Core can only track entities with keys because it uses a key to uniquely
    identify the entity in the database. Keyless entities, like those returned by
    views, are never tracked.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core只能跟踪具有键的实体，因为它使用键在数据库中唯一标识实体。无键实体，如视图返回的实体，永远不会被跟踪。
- en: By default, EF Core assumes that you want to track entities in local memory
    so that if you make changes, like adding a new entity, modifying an existing entity,
    or removing an existing entity, then you can call `SaveChanges` and all those
    changes will be made in the underlying data store.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，EF Core假设你想要在本地内存中跟踪实体，以便如果你进行更改，例如添加新实体、修改现有实体或删除现有实体，那么你可以调用`SaveChanges`，所有这些更改都将应用于底层数据存储。
- en: If you execute a query within a data context, like getting all customers in
    Germany, and then execute another query within the same data context, like getting
    all customers whose name starts with A, if one of those customer entities already
    exists in the context, it will be identified and not replaced or loaded twice.
    However, if the telephone number of that customer is updated in the database between
    the executions of the two queries, then the entity being tracked in the data context
    is not refreshed with the new telephone number.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个数据上下文中执行查询，比如获取德国的所有客户，然后在该数据上下文中执行另一个查询，比如获取所有名字以A开头的客户，如果其中一个客户实体已经存在于上下文中，它将被识别而不会被替换或加载两次。然而，如果在两次查询执行之间该客户的电话号码在数据库中被更新，那么在数据上下文中被跟踪的实体不会用新的电话号码刷新。
- en: If you do not need to track these changes, or you want to load new instances
    of an entity for every query execution with the latest data values, even if the
    entity is already loaded, then you can disable tracking.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要跟踪这些更改，或者你希望在每次查询执行时加载实体的最新数据值的新实例，即使实体已经加载，那么你可以禁用跟踪。
- en: 'To disable tracking for an individual query, call the `AsNoTracking` method
    as part of the query, as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用单个查询的跟踪，在查询中调用`AsNoTracking`方法，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To disable tracking by default for the data context, set the change tracker’s
    query tracking behavior to `NoTracking`, as shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要默认禁用数据上下文的跟踪，将更改跟踪器的查询跟踪行为设置为`NoTracking`，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To disable tracking for an individual query, but retain identity resolution,
    call the `AsNoTrackingWithIdentityResolution` method as part of the query, as
    shown in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用单个查询的跟踪但保留身份解析，在查询中调用`AsNoTrackingWithIdentityResolution`方法，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To disable tracking but perform identity resolution by default for the data
    context, set the change tracker’s query-tracking behavior to `NoTrackingWithIdentityResolution`,
    as shown in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用跟踪但默认执行身份解析的数据上下文，将更改跟踪器的查询跟踪行为设置为`NoTrackingWithIdentityResolution`，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To set defaults for all new instances of a data context, in the `OnConfiguring`
    method, call the `UseQueryTrackingBehavior` method, as shown in the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要为数据上下文的所有新实例设置默认值，在`OnConfiguring`方法中调用`UseQueryTrackingBehavior`方法，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A scenario using default tracking
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用默认跟踪的场景
- en: 'The default is **change tracking** with identity resolution. Once an entity
    is loaded into the data context, underlying changes are not reflected and only
    one copy exists. Entities have local changes tracked and a call to `SaveChanges`
    updates the database, as shown in *Table 3.2*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认是**更改跟踪**与身份解析。一旦实体被加载到数据上下文中，底层更改不会反映出来，并且只有一个副本存在。实体具有本地更改跟踪，并且调用`SaveChanges`会更新数据库，如*表3.2*所示：
- en: '| **Action** | **Entity in data context** | **Row in database** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **数据上下文中的实体** | **数据库中的行** |'
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-4567 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 德国客户的查询 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-4567
    |'
- en: '| Change telephone in database | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 更改数据库中的电话 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-9876
    |'
- en: '| Query for customers starting with A | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 查询以A开头的客户 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-9876
    |'
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 查询德国的客户 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-9876
    |'
- en: '| Change telephone in entity | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste,
    123-9876 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 更改实体中的电话 | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876
    |'
- en: '| Save changes | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-1928
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 保存更改 | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-1928 |'
- en: 'Table 3.2: Default tracking scenario'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2：默认跟踪场景
- en: The same scenario using no tracking
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用无跟踪的相同场景
- en: '**No tracking** and no identity resolution. Every query loads another instance
    of a database row into the data context, including underlying changes, allowing
    duplicates and mixed out-of-date and updated data. No local entity changes are
    tracked, so `SaveChanges` does nothing, as shown in *Table 3.3*:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**无跟踪**和**无身份解析**。每个查询都会将数据库行的一个新实例加载到数据上下文中，包括底层更改，允许重复和混合过时和更新的数据。没有跟踪本地实体更改，因此`SaveChanges`不起作用，如*表3.3*所示：'
- en: '| **Action** | **Entities in data context** | **Row in database** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **数据上下文中的实体** | **数据库中的行** |'
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-4567 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 查询德国的客户 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-4567
    |'
- en: '| Change telephone in database | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 更改数据库中的电话 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-9876
    |'
- en: '| Query for customers starting with A | Alfred’s Futterkiste, 123-4567Alfred’s
    Futterkiste, 123-9876 | Alfred’s Futterkiste, 123-9876 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 查询以A开头的客户 | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste, 123-9876
    | Alfred’s Futterkiste, 123-9876 |'
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste,
    123-9876Alfred’s Futterkiste, 123-9876 | Alfred’s Futterkiste, 123-9876 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 查询德国的客户 | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste, 123-9876Alfred’s
    Futterkiste, 123-9876 | Alfred’s Futterkiste, 123-9876 |'
- en: '| Change telephone in entity | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste,
    123-9876Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 更改实体中的电话 | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste, 123-9876Alfred’s
    Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876 |'
- en: '| Save changes | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste, 123-9876Alfred’s
    Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 保存更改 | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste, 123-9876Alfred’s
    Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876 |'
- en: 'Table 3.3: No tracking scenario'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.3：无跟踪场景
- en: The same scenario using no tracking with identity resolution
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用无跟踪和身份解析的相同场景
- en: 'No tracking with identity resolution. Once an entity is loaded into the data
    context, underlying changes are not reflected and only one copy exists. No local
    entity changes are tracked, so `SaveChanges` does nothing, as shown in *Table
    3.4*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 无跟踪且具有身份解析。一旦实体被加载到数据上下文中，底层更改不会反映出来，并且只有一个副本存在。没有跟踪本地实体更改，因此`SaveChanges`不起作用，如*表3.4*所示：
- en: '| **Action** | **Entities in data context** | **Row in database** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **数据上下文中的实体** | **数据库中的行** |'
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-4567 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 查询德国的客户 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-4567
    |'
- en: '| Change telephone in database | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 更改数据库中的电话 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-9876
    |'
- en: '| Query for customers starting with A | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 查询以A开头的客户 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-9876
    |'
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 查询德国的客户 | Alfred’s Futterkiste, 123-4567 | Alfred’s Futterkiste, 123-9876
    |'
- en: '| Change telephone in entity | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste,
    123-9876 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 更改实体中的电话 | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876
    |'
- en: '| Save changes | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 保存更改 | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876 |'
- en: 'Table 3.4: Identity resolution scenario'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.4：身份解析场景
- en: Summary of tracking
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪总结
- en: Which should you choose? Of course, it depends on your specific scenario.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 应该选择哪一个？当然，这取决于您的具体场景。
- en: You will sometimes read blogs that excitedly tell you that you can dramatically
    improve your EF Core queries by calling `AsNoTracking`. But if you run a query
    that returns thousands of entities and then run the same query again within the
    same data context, you now have thousands of duplicates! This wastes memory and
    impacts performance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会读到一些博客，兴奋地告诉你，通过调用`AsNoTracking`可以显著提高你的EF Core查询。但如果运行一个返回数千个实体的查询，然后在同一数据上下文中再次运行相同的查询，你现在就有数千个重复项！这浪费了内存并影响了性能。
- en: Understand how the three tracking choices work and select the best for your
    data context or individual queries. In the next topic, you will learn how to map
    inheritance hierarchies.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 理解三种跟踪选择的工作方式，并选择最适合你的数据上下文或单个查询的最佳选择。在下一个主题中，你将学习如何映射继承层次结构。
- en: Mapping inheritance hierarchies with EF Core
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EF Core映射继承层次结构
- en: 'Imagine that you have an inheritance hierarchy for some C# classes to store
    information about students and employees, both of which are types of people. All
    people have a name and an ID to uniquely identify them, students have a subject
    they are studying, and employees have a hire date, as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些C#类，用于存储有关学生和员工的信息，这些类都是人的类型。所有的人都有一个名字和一个ID来唯一标识他们，学生有一个他们正在学习的科目，员工有一个雇佣日期，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By default, EF Core will map these to a single table using the **table-per-hierarchy**
    (**TPH**) mapping strategy. EF Core 5 introduced support for the **table-per-type**
    (**TPT**) mapping strategy. EF Core 7 introduced support for the **table-per-concrete-type**
    (**TPC**) mapping strategy. Let’s explore the differences between these mapping
    strategies.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，EF Core将使用**表-每层次结构**（**TPH**）映射策略将这些映射到单个表中。EF Core 5引入了对**表-每类型**（**TPT**）映射策略的支持。EF
    Core 7引入了对**表-每具体类型**（**TPC**）映射策略的支持。让我们来探讨这些映射策略之间的区别。
- en: Table-per-hierarchy (TPH) mapping strategy
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表-每层次结构（TPH）映射策略
- en: 'For the `Person`-`Student`-`Employee` hierarchy, TPH will use a single table
    structure with a discriminator column to indicate which type of person, a student
    or employee, the row is, with nullable columns for extra values that only apply
    to some of the types, as shown highlighted in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Person`-`Student`-`Employee`层次结构，TPH将使用一个带有区分列的单表结构，该列用于指示行是哪种类型的人，学生还是员工，以及一些可空列用于存储仅适用于某些类型的额外值，如下面的代码所示，高亮显示的部分：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Some data in the table might look like *Table 3.5*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的某些数据可能看起来如下所示：
- en: '| **Id** | **Name** | **Discriminator** | **Subject** | **HireDate** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **Name** | **Discriminator** | **Subject** | **HireDate** |'
- en: '| 1 | Roman Roy | Student | History | NULL |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Roman Roy | Student | History | NULL |'
- en: '| 2 | Kendall Roy | Employee | NULL | 02/04/2014 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Kendall Roy | Employee | NULL | 02/04/2014 |'
- en: '| 3 | Siobhan Roy | Employee | NULL | 12/09/2020 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Siobhan Roy | Employee | NULL | 12/09/2020 |'
- en: 'Table 3.5: Sample data in the People table'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.5：People表中的示例数据
- en: TPH requires the `Discriminator` column to store the class name of the type
    for each row. TPH requires the columns for properties of derived types to be nullable,
    like `Subject` and `HireDate`. This will cause an issue if those properties are
    required (non-null) at the class level. EF Core does not handle this by default.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: TPH需要`Discriminator`列存储每行的类型类名。TPH需要派生类型属性的列是可空的，如`Subject`和`HireDate`。如果这些属性在类级别上是必需的（非空），这将导致问题。EF
    Core默认不处理这种情况。
- en: The main benefits of the TPH mapping strategy are simplicity and performance,
    which is why it is used by default.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: TPH映射策略的主要优点是简单性和性能，这就是为什么它被默认使用的原因。
- en: '**Good Practice**: If the discriminator column has many different values, then
    you can improve performance even more by defining an index on the discriminator.
    But if there are only a few different values, an index may make overall performance
    worse because it affects updating time. In this case, there are only two potential
    values, `Student` and `Employee`, so in a table with 100,000 rows, an index would
    make little difference.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果区分列有许多不同的值，那么通过在区分列上定义索引，你可以进一步提高性能。但如果只有少数不同的值，索引可能会使整体性能更差，因为它会影响更新时间。在这种情况下，只有两个潜在值，`Student`和`Employee`，所以在有100,000行记录的表中，索引几乎不会产生影响。'
- en: Table-per-type (TPT) mapping strategy
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表-每类型（TPT）映射策略
- en: 'For the `Person`-`Student`-`Employee` hierarchy, TPT will use a table for every
    type, as shown in the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Person`-`Student`-`Employee`层次结构，TPT将为每种类型使用一个表，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Some data in the tables might look like the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的某些数据可能看起来如下所示：
- en: '| **Id** | **Name** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **Name** |'
- en: '| 1 | Roman Roy |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Roman Roy |'
- en: '| 2 | Kendall Roy |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Kendall Roy |'
- en: '| 3 | Siobhan Roy |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Siobhan Roy |'
- en: 'Table 3.6: People table'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.6：人员表
- en: '| **Id** | **Subject** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **Subject** |'
- en: '| 1 | History |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 历史 |'
- en: 'Table 3.7: Students table'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.7：学生表
- en: '| **Id** | **HireDate** |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **HireDate** |'
- en: '| 2 | 02/04/2014 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 02/04/2014 |'
- en: '| 3 | 12/09/2020 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 12/09/2020 |'
- en: 'Table 3.8: Employees table'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.8：员工表
- en: The main benefit of the TPT mapping strategy is reduced storage due to the full
    normalization of the data. The main disadvantage is that a single entity is spread
    over multiple tables and reconstructing it takes more effort and therefore reduces
    overall performance. TPT is usually a poor choice, so only use it if the table
    structure is already normalized and cannot be restructured.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: TPT 映射策略的主要优点是由于数据的完全规范化而减少的存储空间。主要缺点是单个实体分散在多个表中，重建它需要更多的努力，因此降低了整体性能。TPT 通常不是一个好的选择，所以只有在表结构已经规范化且无法重新结构化时才使用它。
- en: Table-per-concrete-type (TPC) mapping strategy
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表按具体类型映射（TPC）策略
- en: 'For the `Person`-`Student`-`Employee` hierarchy, TPC will use a table for each
    non-abstract type, as shown in the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Person`-`Student`-`Employee` 层次，TPC 将为每个非抽象类型使用一个表，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since there is not a single table with an `IDENTITY` column to assign `Id` values,
    we can use the `(NEXT VALUE FOR [PersonIds])` command to define a sequence shared
    between the two tables so they do not assign the same `Id` values.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有单个带有 `IDENTITY` 列的表来分配 `Id` 值，我们可以使用 `(NEXT VALUE FOR [PersonIds])` 命令定义两个表之间共享的序列，这样它们就不会分配相同的
    `Id` 值。
- en: 'Some data in the tables might look like the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的某些数据可能如下所示：
- en: '| **Id** | **Name** | **Subject** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **Name** | **Subject** |'
- en: '| 1 | Roman Roy | History |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Roman Roy | 历史 |'
- en: 'Table 3.9: Students table'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.9：学生表
- en: '| **Id** | **Name** | **HireDate** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **Name** | **HireDate** |'
- en: '| 2 | Kendall Roy | 02/04/2014 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Kendall Roy | 02/04/2014 |'
- en: '| 3 | Siobhan Roy | 12/09/2020 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Siobhan Roy | 12/09/2020 |'
- en: 'Table 3.10: Employees table'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.10：员工表
- en: The main benefit of the TPC mapping strategy is performance because when querying
    a single concrete type, only one table is needed so we avoid expensive joins.
    It works best for large inheritance hierarchies of many concrete types, each with
    many type-specific properties.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: TPC 映射策略的主要优点是性能，因为当查询单个具体类型时，只需要一个表，因此我们避免了昂贵的连接。它最适合具有许多具体类型的大继承层次结构，每个类型都有许多特定类型的属性。
- en: Configuring inheritance hierarchy mapping strategies
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置继承层次映射策略
- en: 'First, all types must be included in the model, as shown in the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有类型都必须包含在模型中，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For TPH, you are now finished, because it is the default! If you want to make
    this explicit, then in the data context class `OnModelCreating` method, call the
    appropriate “use mapping strategy” method on the base class of the hierarchy.
    `Person` is the base class, so you would call `UseTphMappingStrategy` on that
    entity type, as shown in the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 TPH，你现在已经完成了，因为它是默认的！如果您想使其明确，那么在数据上下文类的 `OnModelCreating` 方法中，在层次结构的基类上调用适当的“使用映射策略”方法。`Person`
    是基类，所以您会在该实体类型上调用 `UseTphMappingStrategy`，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To use either of the other two mapping strategies, call the appropriate method,
    as shown in the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用其他两种映射策略之一，请调用适当的方法，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, you can optionally specify the table name to use for each entity class,
    as shown in the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以选择性地指定每个实体类要使用的表名，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The TPC strategy should have a shared sequence, so we should configure that
    too, as shown in the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: TPC 策略应该有一个共享的序列，因此我们也应该配置它，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Example of hierarchy mapping strategies
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：层次映射策略
- en: 'Now let’s see this in action using a new database and project named `HierarchyMapping`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用一个名为 `HierarchyMapping` 的新数据库和项目来实际看看这个操作：
- en: 'Use your preferred code editor to add a console app project, as defined in
    the following list:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器添加一个控制台应用程序项目，如下面的列表所示：
- en: 'Project template: **Console App** / `console`.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`。
- en: 'Solution file and folder: `Chapter03`.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter03`。
- en: 'Project file and folder: `Northwind.Console.HierarchyMapping`.'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.Console.HierarchyMapping`。
- en: '**Do not use top-level statements**: Cleared.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**：已清除。'
- en: '**Enable native AOT publish**: Cleared.'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用原生 AOT 发布**：已清除。'
- en: Configure the startup project to run `Northwind.Console.HierarchyMapping`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置启动项目以运行 `Northwind.Console.HierarchyMapping`。
- en: 'In the `Northwind.Console.HierarchyMapping` project, add package references
    to the EF Core data provider for SQL Server, and globally and statically import
    the `System.Console` class, as shown in the following markup:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Console.HierarchyMapping` 项目中，添加对 SQL Server EF Core 数据提供程序的包引用，并全局和静态导入
    `System.Console` 类，如下所示：
- en: '[PRE35]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Build the project to restore packages.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包。
- en: In the `Northwind.Console.HierarchyMapping` project, add a new folder named
    `Models`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Console.HierarchyMapping` 项目中，添加一个名为 `Models` 的新文件夹。
- en: 'In `Models`, add a new class file named `Person.cs`, and modify its contents,
    as shown in the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 目录下，添加一个名为 `Person.cs` 的新类文件，并修改其内容，如下所示：
- en: '[PRE36]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In `Models`, add a new class file named `Student.cs`, and modify its contents,
    as shown in the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 目录下，添加一个名为 `Student.cs` 的新类文件，并修改其内容，如下所示：
- en: '[PRE37]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `Models`, add a new class file named `Employee.cs`, and modify its contents,
    as shown in the following code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 目录下，添加一个名为 `Employee.cs` 的新类文件，并修改其内容，如下所示：
- en: '[PRE38]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `Models`, add a new class file named `HierarchyDb.cs`, and modify its contents,
    as shown in the following code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 目录下，添加一个名为 `HierarchyDb.cs` 的新类文件，并修改其内容，如下所示：
- en: '[PRE39]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In `Program.cs`, delete the existing statements. Add statements to configure
    the connection string for the `HierarchyDb` data context and then use it to delete
    and then create a database named `HierarchyMapping` (not `Northwind`!), show the
    automatically generated SQL script, and then output the students, employees, and
    people, as shown in the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句。添加语句以配置 `HierarchyDb` 数据上下文的连接字符串，然后使用它来删除并创建一个名为 `HierarchyMapping`（不是
    `Northwind`！）的数据库，显示自动生成的 SQL 脚本，然后输出学生、员工和人员，如下所示：
- en: '[PRE40]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Start the console app, and note the results including the single table named
    `People` that is created, as shown in the following output:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动控制台应用程序，并注意结果，包括创建的单个名为 `People` 的表，如下所示：
- en: '[PRE41]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In your preferred database tool, view the contents of the `People` table, as
    shown in *Figure 3.2*:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的数据库工具中查看 `People` 表的内容，如图 3.2 所示：
- en: '![](img/B19587_03_02.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_03_02.png)'
- en: 'Figure 3.2: The People table when using the TPH mapping strategy'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：使用 TPH 映射策略时的人员表
- en: Close the connection to the `HierarchyMapping` database.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭对 `HierarchyMapping` 数据库的连接。
- en: 'In `HierarchyDb.cs`, comment out the method call that configures TPH and add
    a call to the method that configures TPT, as shown highlighted in the following
    code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HierarchyDb.cs` 中，注释掉配置 TPH 的方法调用，并添加一个调用配置 TPT 的方法的调用，如下所示的高亮代码：
- en: '[PRE42]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Start the console app, and note the results including the three tables named
    `People`, `Students`, and `Employees` that are created, as shown in the following
    partial output:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动控制台应用程序，并注意结果，包括创建的三个名为 `People`、`Students` 和 `Employees` 的表，如下所示的部分输出：
- en: '[PRE43]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In your preferred database tool, view the contents of the tables, as shown
    in *Figure 3.3*:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的数据库工具中查看表的内容，如图 3.3 所示：
- en: '![](img/B19587_03_03.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_03_03.png)'
- en: 'Figure 3.3: The tables when using the TPT mapping strategy'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：使用 TPT 映射策略时的表
- en: Close the connection to the `HierarchyMapping` database.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭对 `HierarchyMapping` 数据库的连接。
- en: 'In `HierarchyDb.cs`, comment out the method call that configures TPT. Add a
    call to the method that configures TPC and configure a sequence to track assigned
    ID values starting at four because we always add three sample rows, as shown highlighted
    in the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HierarchyDb.cs` 中，注释掉配置 TPT 的方法调用，并添加一个调用配置 TPC 的方法的调用，因为我们需要始终添加三个示例行，如下所示的高亮代码：
- en: '[PRE44]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Start the console app, and note the results including the two tables named
    `Students` and `Employees` that are created as well as the shared sequence that
    starts at 4, as shown in the following partial output:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动控制台应用程序，并注意结果，包括创建的两个名为 `Students` 和 `Employees` 的表以及从 4 开始的共享序列，如下所示的部分输出：
- en: '[PRE45]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In your preferred database tool, view the contents of the tables, as shown
    in *Figure 3.4*:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的数据库工具中查看表的内容，如图 3.4 所示：
- en: '![](img/B19587_03_04.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_03_04.png)'
- en: 'Figure 3.4: The tables when using the TPC mapping strategy'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：使用 TPC 映射策略时的表
- en: Close the connection to the `HierarchyMapping` database.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭对 `HierarchyMapping` 数据库的连接。
- en: 'In `Program.cs`, after the statement to write the `database create` script
    to the console, add some statements to add two new people using the current database
    context, as shown highlighted in the following code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在将`database create`脚本写入控制台后的语句之后，添加一些语句来使用当前数据库上下文添加两个新的人，如下所示的高亮代码：
- en: '[PRE46]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Start the console app, and note the results, including the two new people added
    using the database context with IDs that start at 4, as shown in the following
    partial output:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动控制台应用程序，并注意结果，包括使用数据库上下文添加的两个新的人，其ID从4开始，如下面的部分输出所示：
- en: '[PRE47]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You’ve now seen how an object-relational mapper like EF Core can define an object
    inheritance hierarchy and map it in three different ways to an underlying database
    structure with one or more related tables. You’ve also seen how Code First works
    especially well with this since it is so easy to delete and recreate the database
    each time the project starts.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了对象关系映射器如EF Core如何定义一个对象继承层次结构，并以三种不同的方式将其映射到基础数据库结构中的一个或多个相关表中。你还看到了Code
    First如何与这很好地工作，因为每次项目启动时都很容易删除和重新创建数据库。
- en: Building a reusable entity data model
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建可重用的实体数据模型
- en: Practical applications usually need to work with data in a relational database
    or another data store. Earlier in this chapter, we defined EF Core models in the
    same console app project that we used them in.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用通常需要与关系型数据库或其他数据存储中的数据进行交互。在本章早期，我们定义了EF Core模型，这些模型在同一个控制台应用程序项目中使用。
- en: Now, we will define an entity data model for the Northwind database as a pair
    of reusable class libraries. One part of the pair will define the entities, like
    `Product` and `Customer`. The second part of the pair will define the tables in
    the database and the default configuration for how to connect to the database,
    and use the Fluent API to configure additional options for the model. This pair
    of class libraries will be used in many of the apps and services that you create
    in subsequent chapters.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为Northwind数据库定义一个实体数据模型，作为一对可重用的类库。这对中的一部分将定义实体，如`Product`和`Customer`。这对的另一部分将定义数据库中的表以及如何连接到数据库的默认配置，并使用Fluent
    API来配置模型的附加选项。这对类库将在后续章节中创建的许多应用程序和服务中使用。
- en: '**Good Practice**: You should create a separate class library project for your
    entity data models. This allows easier sharing between backend web servers and
    frontend desktop, mobile, and Blazor clients.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：你应该为你的实体数据模型创建一个单独的类库项目。这允许后端Web服务器和前端桌面、移动和Blazor客户端之间更容易共享。'
- en: Creating a class library for entity models using SQL Server
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQL Server创建实体模型类库
- en: 'You will now create the entity models using the `dotnet-ef` tool:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将使用`dotnet-ef`工具创建实体模型：
- en: 'Add a new project, as defined in the following list:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新项目，如下列所示：
- en: 'Project template: **Class Library** / `classlib`.'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`。
- en: 'Project file and folder: `Northwind.Common.EntityModels.SqlServer`.'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.Common.EntityModels.SqlServer`。
- en: 'Solution file and folder: `Chapter03`.'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter03`。
- en: 'In the `Northwind.Common.EntityModels.SqlServer` project, treat warnings as
    errors, and add package references for the SQL Server database provider and EF
    Core design-time support, as shown highlighted in the following markup:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.Common.EntityModels.SqlServer`项目中，将警告视为错误，并为SQL Server数据库提供者和EF
    Core设计时支持添加包引用，如下所示的高亮标记：
- en: '[PRE48]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**More Information**: If you are unfamiliar with how packages like `Microsoft.EntityFrameworkCore.Design`
    can manage their assets, then you can learn more at the following link: [https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets).'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**更多信息**：如果你不熟悉如何像`Microsoft.EntityFrameworkCore.Design`这样的包管理它们的资产，你可以在以下链接了解更多信息：[https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)。'
- en: Delete the `Class1.cs` file.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`Class1.cs`文件。
- en: Build the `Northwind.Common.EntityModels.SqlServer` project.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目`Northwind.Common.EntityModels.SqlServer`。
- en: Open a command prompt or terminal for the `Northwind.Common.EntityModels.SqlServer`
    folder.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Northwind.Common.EntityModels.SqlServer`文件夹的命令提示符或终端。
- en: The next step assumes a database connection string for a local SQL Server authenticated
    with Windows integrated security. Modify it for Azure SQL Database or Azure SQL
    Edge with a user ID and password if necessary.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个步骤假设有一个用于本地SQL Server的Windows集成安全认证的数据库连接字符串。如果需要，请将其修改为Azure SQL数据库或Azure
    SQL Edge，使用用户ID和密码。
- en: 'At the command line, generate entity class models for all tables, as shown
    in the following commands:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，为所有表生成实体类模型，如下面的命令所示：
- en: '[PRE49]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note the following:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: 'The command to perform: `dbcontext scaffold`.'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的命令：`dbcontext scaffold`。
- en: 'The connection string: `"``Data Source=.;Initial Catalog=Northwind;Integrated
    Security=true;TrustServerCertificate=True;"` .'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接字符串：`"``Data Source=.;Initial Catalog=Northwind;Integrated Security=true;TrustServerCertificate=True;"`。
- en: 'The database provider: `Microsoft.EntityFrameworkCore.SqlServer`.'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库提供程序：`Microsoft.EntityFrameworkCore.SqlServer`。
- en: 'The namespace for the generated classes: `--namespace Northwind.EntityModels`.'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成类的命名空间：`--namespace Northwind.EntityModels`。
- en: 'To use data annotations as well as the Fluent API: `--data-annotations`.'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用数据注释以及Fluent API：`--data-annotations`。
- en: Note that 28 classes were generated, from `AlphabeticalListOfProduct.cs` to
    `Territory.cs`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，生成了28个类，从`AlphabeticalListOfProduct.cs`到`Territory.cs`。
- en: In `NorthwindContext.cs`, delete the `OnConfiguring` method including the warning
    and connection string.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NorthwindContext.cs`中，删除包括警告和连接字符串的`OnConfiguring`方法。
- en: 'In `Customer.cs`, the `dotnet-ef` tool correctly identified that the `CustomerId`
    column is the primary key and it is limited to a maximum of five characters, but
    we also want the values to always be uppercase. So, add a regular expression to
    validate its primary key value to only allow uppercase Western characters, as
    shown highlighted in the following code:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Customer.cs`中，`dotnet-ef`工具正确识别出`CustomerId`列是主键，并且其长度限制为最多五个字符，但我们还希望这些值始终为大写。因此，添加一个正则表达式来验证其主键值，只允许大写西文字符，如下面的代码所示（高亮显示）：
- en: '[PRE50]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Creating a class library for the data context using SQL Server
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQL Server创建数据上下文类库
- en: 'Next, you will move the context model that represents the database to a separate
    class library:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将数据库表示的上下文模型移动到单独的类库中：
- en: 'Add a new project, as defined in the following list:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新项目，如下面的列表所示：
- en: 'Project template: **Class Library** / `classlib`.'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`。
- en: 'Project file and folder: `Northwind.Common.DataContext.SqlServer`.'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.Common.DataContext.SqlServer`。
- en: 'Solution file and folder: `Chapter03`.'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter03`。
- en: 'In the `DataContext` project, add a project reference to the `EntityModels`
    project, and add a package reference to the EF Core data provider for SQL Server,
    as shown in the following markup:'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`DataContext`项目中，将`EntityModels`项目添加为项目引用，并将EF Core数据提供程序添加为SQL Server的包引用，如下面的标记所示：
- en: '[PRE51]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Warning!** The path to the project reference should not have a line break
    in your project file.'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**警告**！项目引用的路径在项目文件中不应有换行符。'
- en: In the `Northwind.Common.DataContext.SqlServer` project, delete the `Class1.cs`
    file.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.Common.DataContext.SqlServer`项目中，删除`Class1.cs`文件。
- en: Build the `Northwind.Common.DataContext.SqlServer` project.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`Northwind.Common.DataContext.SqlServer`项目。
- en: Move the `NorthwindContext.cs` file from the `Northwind.Common.EntityModels.SqlServer`
    project/folder to the `Northwind.Common.DataContext.SqlServer` project/folder.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NorthwindContext.cs`文件从`Northwind.Common.EntityModels.SqlServer`项目/文件夹移动到`Northwind.Common.DataContext.SqlServer`项目/文件夹。
- en: 'In the `Northwind.Common.DataContext.SqlServer` project, add a class named
    `NorthwindContextExtensions.cs`, and modify its contents to define an extension
    method that adds the Northwind database context to a collection of dependency
    services, as shown in the following code:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.Common.DataContext.SqlServer`项目中，添加一个名为`NorthwindContextExtensions.cs`的类，并修改其内容以定义一个扩展方法，该方法将Northwind数据库上下文添加到依赖服务集合中，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Build the two class libraries and fix any compiler errors.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建两个类库，并修复任何编译器错误。
- en: '**Good Practice**: We have provided an optional argument for the `AddNorthwindContext`
    method so that we can override the SQL Server database connection string. This
    will allow us more flexibility, for example, to load these values from a configuration
    file.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：我们为`AddNorthwindContext`方法提供了一个可选参数，以便我们可以覆盖SQL Server数据库连接字符串。这将使我们更加灵活，例如，可以从配置文件中加载这些值。'
- en: Calculated properties on entity creation
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体创建时的计算属性
- en: EF Core 7 added an `IMaterializationInterceptor` interface that allows interception
    before and after an entity is created, and when properties are initialized. This
    is useful for calculated values.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 7 添加了一个 `IMaterializationInterceptor` 接口，允许在创建实体之前和之后以及属性初始化时进行拦截。这对于计算值很有用。
- en: For example, when a service or client app requests entities to show to the user,
    it might want to cache a copy of the entity for a period of time. To do this,
    it needs to know when the entity was last refreshed. It would be useful if this
    information was automatically generated and stored with each entity at the time
    of loading.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当服务或客户端应用程序请求向用户显示的实体时，它可能想要缓存一段时间内的实体副本。为此，它需要知道实体上次刷新的时间。如果在加载实体时自动生成并存储此信息，将非常有用。
- en: 'To achieve this goal, we must complete four steps:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个目标，我们必须完成四个步骤：
- en: First, define an interface with the extra property.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义一个具有额外属性的接口。
- en: Next, at least one entity model class must implement the interface.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，至少必须有一个实体模型类实现该接口。
- en: Then, define a class that implements the interceptor interface with a method
    named `InitializedInstance` that will execute on any entity, and if that entity
    implements the custom interface with the extra property, then it will set its
    value.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个实现拦截器接口的类，该接口有一个名为 `InitializedInstance` 的方法，它将在任何实体上执行，如果该实体实现了具有额外属性的定制接口，则将设置其值。
- en: Finally, we must create an instance of the interceptor and register it in the
    data context class.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须创建拦截器的实例并将其注册到数据上下文类中。
- en: 'Now let’s implement this for Northwind `Employee` entities:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为 Northwind `Employee` 实体实现这个功能：
- en: 'In the `Northwind.Common.EntityModels.SqlServer` project, add a new file named
    `IHasLastRefreshed.cs`, and modify its contents to define the interface, as shown
    in the following code:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Common.EntityModels.SqlServer` 项目中，添加一个名为 `IHasLastRefreshed.cs`
    的新文件，并修改其内容以定义接口，如下所示：
- en: '[PRE53]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `Northwind.Common.EntityModels.SqlServer` project, add a new file named
    `EmployeePartial.cs`, and modify its contents to implement the interface, as shown
    highlighted in the following code:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Common.EntityModels.SqlServer` 项目中，添加一个名为 `EmployeePartial.cs`
    的新文件，并修改其内容以实现接口，如下所示（高亮部分）：
- en: '[PRE54]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Good Practice**: Add extension code like this to a separate partial entity
    class file so that you can later regenerate the `Employee.cs` file using the `dotnet-ef`
    tool without overwriting your additional code.'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：将此类扩展代码添加到单独的部分实体类文件中，这样您就可以稍后使用 `dotnet-ef` 工具重新生成 `Employee.cs`
    文件，而不会覆盖您的附加代码。'
- en: 'In the `Northwind.Common.DataContext.SqlServer` project, add a new file named
    `SetLastRefreshedInterceptor.cs`, and modify its contents to define the interceptor,
    as shown in the following code:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Common.DataContext.SqlServer` 项目中，添加一个名为 `SetLastRefreshedInterceptor.cs`
    的新文件，并修改其内容以定义拦截器，如下所示：
- en: '[PRE55]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the `Northwind.Common.DataContext.SqlServer` project, in `NorthwindContext.cs`,
    delete the existing `OnConfiguring` method.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Common.DataContext.SqlServer` 项目中，在 `NorthwindContext.cs` 中删除现有的
    `OnConfiguring` 方法。
- en: 'In the `Northwind.Common.DataContext.SqlServer` project, add a new file named
    `NorthwindContextPartial.cs`, then declare and register the interceptor in the
    `OnConfiguring` method, as shown in the following code:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Common.DataContext.SqlServer` 项目中，添加一个名为 `NorthwindContextPartial.cs`
    的新文件，然后在 `OnConfiguring` 方法中声明和注册拦截器，如下所示：
- en: '[PRE56]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Save the changes.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改。
- en: Creating a test project to check the integration of the class libraries
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试项目以检查类库的集成
- en: 'Since we will not be creating a client project in this chapter that uses the
    EF Core model, we should create a test project to make sure the database context
    and entity models integrate correctly:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在本章中不创建使用 EF Core 模型的客户端项目，因此我们应该创建一个测试项目以确保数据库上下文和实体模型正确集成：
- en: Use your preferred coding tool to add a new **xUnit Test Project [C#]** / `xunit`
    project named `Northwind.Common.EntityModels.Tests` to the `Chapter03` solution.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的编码工具向 `Chapter03` 解决方案添加一个名为 `Northwind.Common.EntityModels.Tests` 的新
    **xUnit 测试项目 [C#]** / `xunit` 项目。
- en: 'In `Northwind.Common.EntityModels.Tests.csproj`, modify the configuration to
    treat warnings as errors and to add an item group with a project reference to
    the `Northwind.Common.DataContext.SqlServer` project, as shown in the following
    markup:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Common.EntityModels.Tests.csproj` 中，修改配置以将警告视为错误，并添加一个包含对 `Northwind.Common.DataContext.SqlServer`
    项目的项目引用的项组，如下所示：
- en: '[PRE57]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Warning!** The path to the project reference should not have a line break
    in your project file.'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**警告！** 在你的项目文件中，项目参考路径不应该包含换行符。'
- en: Build the `Northwind.Common.EntityModels.Tests` project to build and restore
    project dependencies.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并还原 `Northwind.Common.EntityModels.Tests` 项目的依赖项。
- en: Writing unit tests for entity models
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为实体模型编写单元测试
- en: 'A well-written unit test will have three parts:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 一个编写良好的单元测试将包含三个部分：
- en: '**Arrange**: This part will declare and instantiate variables for input and
    output.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排**：这部分将声明和实例化输入和输出的变量。'
- en: '**Act**: This part will execute the unit that you are testing. In our case,
    that means calling the method that we want to test.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行动**：这部分将执行你正在测试的单元。在我们的例子中，这意味着调用我们想要测试的方法。'
- en: '**Assert**: This part will make one or more assertions about the output. An
    assertion is a belief that, if not true, indicates a failed test. For example,
    when adding 2 and 2, we would expect the result to be 4.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：这部分将对输出进行一个或多个断言。断言是一种信念，如果它不成立，则表明测试失败。例如，当添加 2 和 2 时，我们期望结果是 4。'
- en: 'Now, we will write some unit tests for the `NorthwindContext` and entity model
    classes:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为 `NorthwindContext` 和实体模型类编写一些单元测试：
- en: Rename the file `UnitTest1.cs` to `NorthwindEntityModelsTests.cs` and then open
    it.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件 `UnitTest1.cs` 重命名为 `NorthwindEntityModelsTests.cs`，然后打开它。
- en: In Visual Studio Code, rename the class to `NorthwindEntityModelsTests`. (Visual
    Studio prompts you to rename the class when you rename the file.)
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，将类重命名为 `NorthwindEntityModelsTests`。（当你重命名文件时，Visual
    Studio 会提示你重命名类。）
- en: 'Modify the `NorthwindEntityModelsTests` class to import the `Northwind.EntityModels`
    namespace and have some test methods for ensuring the context class can connect,
    ensuring the provider is SQL Server, and ensuring the first product is named `Chai`,
    as shown in the following code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `NorthwindEntityModelsTests` 类以导入 `Northwind.EntityModels` 命名空间，并添加一些测试方法以确保上下文类可以连接，确保提供者是
    SQL Server，并确保第一个产品命名为 `Chai`，如下代码所示：
- en: '[PRE58]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Running unit tests using Visual Studio 2022
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2022 运行单元测试
- en: 'Now we are ready to run the unit tests and see the results:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备运行单元测试并查看结果：
- en: In Visual Studio 2022, navigate to **Test** | **Run All Tests**.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2022 中，导航到 **测试** | **运行所有测试**。
- en: 'In **Test Explorer**, note that the results indicate that four tests ran, and
    all passed, as shown in *Figure 3.5*:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **测试资源管理器** 中，注意结果表明运行了四个测试，并且全部通过，如 *图 3.5* 所示：
- en: '![](img/B19587_03_05.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_03_05.png)'
- en: 'Figure 3.5: All unit tests passed'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：所有单元测试通过
- en: Running unit tests using Visual Studio Code
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 运行单元测试
- en: 'Now we are ready to run the unit tests and see the results:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备运行单元测试并查看结果：
- en: 'In Visual Studio Code, in the `Northwind.Common.EntityModels.Tests` project’s
    **TERMINAL** window, run the tests, as shown in the following command:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，在 `Northwind.Common.EntityModels.Tests` 项目的 **终端** 窗口中运行测试，如下命令所示：
- en: '[PRE59]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If you are using **C# Dev Kit**, then you can also build the test project and
    then run the tests from the **Testing** section in the **Primary Side Bar**.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用 **C# 开发工具包**，那么你也可以从 **主侧栏** 的 **测试** 部分构建测试项目并运行测试。
- en: In the output, note that the results indicate that four tests ran, and all passed.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出中，注意结果表明运行了四个测试，并且全部通过。
- en: As an optional task, can you think of other tests you could write to make sure
    the database context and entity models are correct?
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为一项可选任务，你能想到其他可以编写的测试来确保数据库上下文和实体模型是正确的吗？
- en: Practicing and exploring
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些动手实践，以及通过深入研究本章主题来测试你的知识和理解。
- en: Exercise 3.1 – Test your knowledge
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What can the `dotnet-ef` tool be used for?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dotnet-ef` 工具可以用作什么？'
- en: What type would you use for the property that represents a table, for example,
    the `Products` property of a data context?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于表示表的属性的类型是什么，例如数据上下文的 `Products` 属性？
- en: What type would you use for the property that represents a one-to-many relationship,
    for example, the `Products` property of a `Category` entity?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于表示一对一关系的属性的类型是什么，例如 `Category` 实体的 `Products` 属性？
- en: What is the EF Core convention for primary keys?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EF Core 的主键约定是什么？
- en: Why might you choose the Fluent API in preference to annotation attributes?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你可能会选择 Fluent API 而不是属性注解？
- en: Why might you implement the `IMaterializationInterceptor` interface in an entity
    type?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你可能会在实体类型中实现 `IMaterializationInterceptor` 接口？
- en: Exercise 3.2 – Practice benchmarking ADO.NET against EF Core
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.2 – 练习将 ADO.NET 与 EF Core 进行基准测试
- en: In the `Chapter03` solution, create a console app named `Ch03Ex02_ADONETvsEFCore`
    that uses Benchmark.NET to compare retrieving all the products from the Northwind
    database using ADO.NET (`SqlClient`) and using EF Core.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Chapter03` 解决方案中，创建一个名为 `Ch03Ex02_ADONETvsEFCore` 的控制台应用程序，使用 Benchmark.NET
    比较使用 ADO.NET (`SqlClient`) 和使用 EF Core 从 Northwind 数据库检索所有产品。
- en: 'You can learn how to use Benchmark.NET by reading the online-only section *Benchmarking
    Performance and Testing* at the following link: [https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md).'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过阅读以下链接中的在线部分 *Benchmarking Performance and Testing* 来了解如何使用 Benchmark.NET：[https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md).
- en: Exercise 3.3 – Review performance choices
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.3 – 审查性能选择
- en: The data tier can have an outsized influence on the overall performance of an
    app or service.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层可以对应用程序或服务的整体性能产生不成比例的影响。
- en: 'Docs: [https://learn.microsoft.com/en-us/ef/core/performance/](https://learn.microsoft.com/en-us/ef/core/performance/)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 文档：[https://learn.microsoft.com/en-us/ef/core/performance/](https://learn.microsoft.com/en-us/ef/core/performance/)
- en: Exercise 3.4 – Explore topics
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.4 – 探索主题
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解本章涵盖主题的更多详细信息：
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-3---building-entity-models-for-sql-server-using-ef-core](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-3---building-entity-models-for-sql-server-using-ef-core)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-3---building-entity-models-for-sql-server-using-ef-core](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-3---building-entity-models-for-sql-server-using-ef-core)'
- en: Summary
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了：
- en: How to execute a simple query and process the results using the slower but more
    object-oriented EF Core.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用较慢但更面向对象的 EF Core 执行简单查询并处理结果。
- en: How to configure and decide between three mapping strategies for type hierarchies.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置和决定在类型层次结构中使用三种映射策略。
- en: How to implement calculated properties on entity creation.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在实体创建时实现计算属性。
- en: In the next chapter, you will learn how to use cloud-native data storage with
    Azure Cosmos DB.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用 Azure Cosmos DB 进行云原生数据存储。
- en: Learn more on Discord
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描以下二维码：
- en: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
- en: '![](img/QR_Code3048220001028652625.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code3048220001028652625.png)'
