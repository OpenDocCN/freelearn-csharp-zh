["```cs\nusing System.Collections;\nArrayList arrayList = new() { 5 };\narrayList.Add(6);\narrayList.AddRange(new int[] { -7, 8 });\narrayList.AddRange(new object[] { \"Marcin\", \"Kate\" });\narrayList.ArrayList class is created and 5 is added as the first element. This can be simplified, as shown here:\n\n```", "```cs\nobject first = arrayList[0]!;\nint third = (int)arrayListint in the second line. Such casting is necessary because the array list stores object values. As in the case of arrays, the zero-based indices are used while accessing particular elements within the collection. When you run the preceding lines of code, first will be equal to 5, while third will be equal to -7.\nOf course, you can use a `foreach` loop to iterate through all items, as follows:\n\n```", "```cs\n\n That’s not all – the `ArrayList` class has a set of properties and methods that you can use while developing applications utilizing the aforementioned data structure. To start with, let’s take a look at the `Count` and `Capacity` properties:\n\n```", "```cs\nbool containsMarcin = arrayList.true is returned. Otherwise, false is returned. But how can you find an index of this element? To do so, you can use the IndexOf or LastIndexOf method, as shown in the following line of code:\n\n```", "```cs\nbool containsAnn = arrayList.Remove, RemoveAt, RemoveRange, and Clear methods, as shown here:\n\n```", "```cs\n\n The difference between the mentioned methods is as follows:\n\n*   `Remove` removes the first occurrence of a given value\n*   `RemoveAt` removes an item with a provided index\n*   `RemoveRange` removes a given number of elements starting from some index\n*   `Clear` removes all elements\n\nAmong other methods, it is worth mentioning `Reverse`, which reverses the order of the elements within the array list, as well as `ToArray`, which returns an array with all items stored in the `ArrayList` instance.\nWhere can you find more information?\nYou can find content regarding an array list at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist](https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist). \nGeneric lists\nAs you can see, the `ArrayList` class contains a broad range of features, but it has a significant drawback – that is, it is not a strongly typed list. If you want to benefit from a strongly typed list, you can use the generic `List` class, which represents the collection whose size can be increased and decreased as necessary. This class is available in the `System.Collections.Generic` namespace.\nThe generic `List` class contains many properties and methods that are useful while developing applications that store data. Many members are named the same as in the `ArrayList` class. An example is the following two properties:\n\n*   `Count`, which returns the current number of elements in the list\n*   `Capacity`, which indicates how many elements can be currently stored in the list\n\nThere are also many similar methods, including the following ones:\n\n*   `Add` adds an item at the end of the list\n*   `AddRange` adds a collection of elements at the end of the list\n*   `Insert` places an element in a specified location within the list\n*   `InsertRange` places a collection of items in a specified location in the list\n*   `Contains` checks whether the list contains a given element\n*   `IndexOf` returns an index of the first occurrence of a given item\n*   `LastIndexOf` returns an index of the last occurrence of a given item\n*   `Remove` removes the first occurrence of a given value\n*   `RemoveAt` removes an item with a provided index\n*   `RemoveRange` removes a given number of elements starting from some index\n*   `Clear` removes all elements from the list\n*   `Reverse` reverses the order of items within the list\n*   `ToArray` returns an array with all items stored in the list\n\nYou can get a particular element from the list using the `[]` operator with an index.\nApart from the already-described features, you can use a comprehensive set of extension methods from the `System.Linq` namespace. Some of them are as follows:\n\n*   `Min` finds the minimum value in the list\n*   `Max` finds the maximum value in the list\n*   `Sum` returns a sum of all elements in the list\n*   `Average` calculates the average value of elements in the list\n*   `All` checks whether all elements in the list satisfy a condition\n*   `Any` verifies whether at least one element in the list satisfies a condition\n*   `ElementAtOrDefault` returns an element at a given index in the collection or a default value if the index is out of bounds\n*   `Distinct` returns a collection with only unique elements, namely without duplicates\n*   `OrderBy` and `OrderByDescending` order all elements in the list in ascending or descending order, as well as return the ordered collection\n*   `Skip` returns a collection bypassing a given number of elements in the list\n*   `Take` returns a given number of elements from the list\n\nAfter this theoretical introduction, let’s see such methods in action! First, let’s get the minimum, maximum, sum, and average values from the list, as shown here:\n\n```", "```cs\nbool allPositive = list.All(x => x > 0);\nbool anyZero = list.allPositive is equal to false, while anyZero to true.\nThe next part of the code is shown in the following block:\n\n```", "```cs\nList<int> unique = list.IEnumerable<int> type, which you can convert into List<int> by calling the ToList extension method. The resulting list contains 6, 90, -20, 0, 4, 1, 8, and 41.\nLet’s order the list using the `OrderBy` extension method, as follows:\n\n```", "```cs\nList<int> skipped = list.Skip(4).ToList();\nList<int> taken = list.Skip method skips 4 elements and returns the collection with the remaining elements, namely 4, 1, 8, -20, and 41.\nThe `Take` method simply takes `3` first elements – that is, `6`, `90`, and `-20`.\nDo you have any idea how to combine `Skip` with `Take` in some real-world examples? If not, just think about the **pagination** mechanism, which you can find on many websites. It allows you to navigate between pages of data, where each page contains a specified number of elements. How you can get such items for a given page? The answer is as follows:\n\n```", "```cs\n\n Of course, these are not the only features available for developers while creating applications using generic lists in the C# language. I strongly encourage you to discover more possibilities on your own. Next, we’ll look at two examples that show how to use a generic list in practice.\nWhere can you find more information?\nYou can find content regarding a generic list at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1).\nExample – average value\nThe first example utilizes the generic `List` class to store floating-point values (of the `double` type) entered by the user. After typing a number, the average value is calculated and presented in the console. The program stops the operation when an incorrect value is entered. The code is as follows:\n\n```", "```cs\n\n First, an instance of the `List` class is created. Then, within the infinite loop (`do-while`), the program waits until the user enters a number. If it is correct, the entered value is added to the list (by calling `Add`), and an average value from elements in the list is calculated (by calling `Average`). The result is shown in the console:\n\n```", "```cs\n\n In this section, you saw how to use a list that stores `double` values. However, can it also store instances of user-defined classes or records? Of course! You will see how to achieve this goal in the next example.\nExample – list of people\nThis second example shows you how to use a list to create a very simple database of people. For each, a name, an age, and a country are stored. When the program is launched, some data of people are added to the list. Then, such data is sorted and presented in the console.\nLet’s start with the declaration of the `Person` record:\n\n```", "```cs\nList<Person> people =\n[\n    new(\"Marcin\", 35, \"PL\"),\n    new(\"Sabine\", 25, \"DE\"),\n    new(\"Mark\", 31, \"PL\")\n];\n```", "```cs\nList<Person> r = people.OrderBy(p => p.Name).ToList();\n```", "```cs\nList<Person> r = foreach loop:\n\n```", "```cs\n\n After running the program, the following results will be presented:\n\n```", "```cs\n\n That’s all! Now, let’s talk a bit more about the LINQ expressions, which can be used not only to order elements but also to filter items based on the provided criteria, and even more.\nAs an example, let’s take a look at the following query, which is using the **method syntax**:\n\n```", "```cs\nList<string> names = (from p in people\n                      where p.Age <= 30\n                      orderby p.Name\n                      ArrayList class and the generic List class to store data in collections, the size of which could be dynamically adjusted. However, this is not the end of list-related topics within this chapter. Are you ready to get to know another data structure that maintains the elements in the sorted order? If so, let’s proceed to the next section, which focuses on sorted lists.\nSorted lists\nSo far, you’ve learned how to store data using simple lists. However, do you know that you can even use a data structure that ensures that the elements are sorted all the time? If not, let’s get to know the `SortedList` generic class (from the `System.Collections.Generic` namespace), `null`.\nImagine a sorted list\nIf you want to imagine a sorted list, think about a business holder in which you put business cards that you have received from other people. Since you like order and want to always be able to quickly find a business card for a specific person, you make sure that they are all arranged in alphabetical order, by last name. What a terrible waste of time, especially if you have dozens of business cards and suddenly you have to put in a card for Mrs. Ana Ave. Oh, no... almost all the business cards have to be moved. What can help you at this point is a sorted list! On its basis, your magic business card holder works, which automatically inserts a new business card into the appropriate place in the business card holder. Thanks to this, you always have order and you do not have to waste time constantly taking out and inserting business cards. Congratulations!\nYou can easily add an element to a sorted list using the `Add` method, as well as remove a specified item using the `Remove` method. Among other methods, it is worth noting `ContainsKey` and `ContainsValue` for checking whether the collection contains an item with a given key or value, as well as `IndexOfKey` and `IndexOfValue` for returning an index of an element by its key or value.\nAs a sorted list stores key-value pairs, you have also access to the `Keys` and `Values` properties. Particular keys and values can be easily obtained using the `[]` operator together with an index. As you can see, this data structure is quite similar to the ones that have already been presented. However, it has some significant differences. So, let’s take a look at an example that will show you how to use this data structure. You will also see differences in code compared with the previously described `List` class.\nWhere can you find more information?\nYou can find content regarding a sorted list at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2).\nExample – address book\nThis example uses the `SortedList` class to create a very simple address book, which is sorted by names of people. For each person, the following data is stored: `Name`, `Street`, `PostalCode`, `City`, and `Country`. The declaration of the `Person` record is shown in the following code:\n\n```", "```cs\n\n In the main part of the code, you create a new instance of `SortedList`. You need to specify types for keys and values, namely `string` and `Person`. Within the following part of the code, you also initialize the sorted list with data for `Marcin` and `Martyna`:\n\n```", "```cs\n\n Then, you can easily add data to the sorted list by calling the `Add` method, passing two parameters, namely a key (that is, a name), and a value (that is, an instance of the `Person` record), as shown in the following code snippet regarding `Mark`:\n\n```", "```cs\n\n When all the data is stored within the collection, you can easily iterate through its elements (namely through key-value pairs) using a `foreach` loop. It is worth mentioning that a type of the variable that’s used in the loop is `KeyValuePair<string, Person>`. However, you can use a value tuple to get access to a key (`k`) and a value (`p`):\n\n```", "```cs\n\n When the program is launched, you receive the following result in the console:\n\n```", "```cs\n\n As you can see, the collection is automatically sorted by names, which are used as keys for the sorted list. However, you need to remember that keys must be unique, so you cannot add more than one person with the same full name in this example.\nLinked lists\nWhile using the `List` generic class, you can easily get access to particular elements of the collection using indices. However, when you get a single element, how can you move to the next element of the collection? Is it possible? To do so, you may consider the `IndexOf` method to get an index of the element. Unfortunately, it returns an index of the first occurrence of a given value in the collection, so it will not always work as expected in this scenario. Fortunately, **linked lists** exist and can help you with this problem! In this section, you will learn about a few variants.\nSingly linked lists\nA **singly linked list** is a data structure in which **each list element contains a** **pointer to the next element**. Thus, you can easily **move from any element to the next one, but you cannot go back**. Of course, the last element in the list has an empty pointer to the next element because there is nothing more located in the list.\nImagine a singly linked list\nIf you want to better visualize a singly linked list, think about how to represent the phases of human development. Life after birth consists of the neonatal period, infancy, post-infanthood, preschool, school, adolescence, adulthood, and old age. From each phase, you can only go to the next one and you can never go back, even if you try very, very hard. It’s similar to a linked list, where you can easily move from a given item to the next item, but you don’t have any data to return to the item that brought you here. But it would be nice to be able to go back a dozen or so years and repeat some phase of development, right? Unfortunately, there is no “back” button here. :-)\nHere’s an example of a singly linked list:\n![Figure 4.2 – Illustration of a singly linked list](img/B18069_04_2.jpg)\n\nFigure 4.2 – Illustration of a singly linked list\nIs it possible to further expand this data structure so that you can both go forward and backward from a given list element? Of course! Let’s take a look.\nDoubly linked lists\nA **doubly linked list** is another data structure that **allows you to navigate both forward and backward from each list item**. It can be created based on the singly linked list by adding a second pointer, namely to the previous element.\nImagine a doubly linked list\nIf you want to better imagine a doubly linked list, open a text editor and start describing your day in it. Whenever you make a mistake, you press the “undo” button and you see the earlier version. You can also press “redo” and suddenly, you see what was in the document just before you undone the changes. Of course, you can perform such an operation many times, and the system remembers many previous and next operations. This is how you can think of a doubly linked list. In each element of the list, you can easily go to both the next element (equivalent to a “redo” operation) and the previous element (equivalent to a “back” operation). Just look how easy it is to find applications for various data structures in everyday life!\nThe following figure illustrates a doubly linked list:\n![Figure 4.3 – Illustration of a doubly linked list](img/B18069_04_3.jpg)\n\nFigure 4.3 – Illustration of a doubly linked list\nAs you can see, the `FIRST` box indicates the first element in the list. Each item has two properties that point to the previous and next element (`PREV` and `NEXT`, respectively). If there is no previous element, the `PREV` property is equal to `null`. Similarly, when there is no next element, the `NEXT` property is set to `null`. Moreover, the doubly linked list contains the `LAST` box that indicates the last element. \nDo you need to implement such a data structure on your own if you want to use it in your C#-based applications? Fortunately, no! It is already available as the `LinkedList` generic class in the `System.Collections.Generic` namespace. While creating an instance of this class, you need to specify the type parameter that indicates a type of a value stored in each element in the list, such as `int` or `string`.  Each element (also referred to as a *node*) is represented by an instance of the `LinkedListNode` generic class, such as `LinkedListNode<int>` or `LinkedListNode<string>`.\nSome additional explanation is necessary for the methods of adding new nodes to the doubly linked list. For this purpose, you can use a set of methods:\n\n*   `AddFirst` adds an element at the beginning of the list\n*   `AddLast` adds an element at the end of the list\n*   `AddBefore` adds an element before the specified node in the list\n*   `AddAfter` adds an element after the specified node in the list\n\nAll these methods return an instance of the `LinkedListNode` class. Moreover, there are some other methods:\n\n*   `Contains` checks whether the specified value exists in the list\n*   `Remove` removes a node from the list\n*   `Clear` removes all elements from the list\n\nAfter this short introduction, let’s take a look at an example that shows how to apply the doubly linked list, implemented as the `LinkedList` class, in practice.\nWhere can you find more information?\nYou can find content regarding a linked list at [https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1).\nExample – book reader\nAs an example, you will prepare a simple application that allows a user to read a book by changing pages. The user should be able to move to the next page (if it exists) after pressing the *N* key, and go back to the previous page (if it exists) after pressing the *P* key. The content of the current page, together with the page number, should be shown in the console, as presented in the screenshot:\n![Figure 4.4 – Screenshot of the book reader example](img/B18069_04_4.jpg)\n\nFigure 4.4 – Screenshot of the book reader example\nLet’s start with a declaration of the `Page` record, as shown in the following code:\n\n```", "```cs\nPage p1 = new(\"Welcome to (...)\");\nPage p2 = new(\"While reading (...)\");\nPage p3 = new(\"As a developer (...)\");\nPage p4 = new(\"In the previous (...)\");\nPage p5 = new(\"So far, you (...)\");\nPage p6 = new(\"The current (...)\");\n```", "```cs\nLinkedList<Page> pages = new();\npages.AddLast(p2);\nLinkedListNode<Page> n4 = pages.AddLast(p4);\npages.AddLast(p6);\npages.AddFirst(p1);\npages.AddBefore(n4, p3);\npages.AddAfter(n4, p5);\n```", "```cs\nLinkedListNode<Page> c = pages.First!;\nint number = 1;\nwhile (c != null)\n{\n    Console.Clear();\n    string page = $\"- {number} -\";\n    int spaces = (90 - page.Length) / 2;\n    Console.WriteLine(page.PadLeft(spaces + page.Length));\n    Console.WriteLine();\n    string content = c.Value.Content;\n    for (int i = 0; i < content.Length; i += 90)\n    {\n        string line = content[i..];\n        line = line.Length > 90 ? line[..90] : line;\n        Console.WriteLine(line.Trim());\n    }\n    Console.WriteLine($\"\\nQuote from (...)\");\n    Console.Write(c.Previous != null\n        ? \"< PREV [P]\" : GetSpaces(14));\n    Console.Write(c.Next != null\n        ? \"[N] NEXT >\".PadLeft(76) : string.Empty);\n    Console.WriteLine();\n    ConsoleKey key = Console.ReadKey(true).Key;\n    if (key == ConsoleKey.N && c.Next != null)\n    {\n        c = c.Next;\n        number++;\n    }\n    else if (key == ConsoleKey.P && c.Previous != null)\n    {\n        c = c.Previous;\n        number--;\n    }\n}\n```", "```cs\nstring GetSpaces(int number) => string.Join(\n    null, Enumerable.Range(0, number).Select(n => \" \"));\n```", "```cs\nusing System.Collections;\npublic class CircularLinkedList<T>\n    : LinkedList<T>\n{\n    public new IEnumerator GetEnumerator() =>\n        new CircularEnumerator<T>(this);\n}\n```", "```cs\npublic class CircularEnumerator<T>(LinkedList<T> list)\n    : IEnumerator<T>\n{\n    private LinkedListNode<T>? _current = null;\n    public T Current => _current != null\n        ? _current.Value\n        : default!;\n    object IEnumerator.Current => Current!;\n    public bool MoveNext()\n    {\n        if (_current == null)\n        {\n            _current = list?.First;\n            return _current != null;\n        }\n        else\n        {\n            _current = _current.Next\n                ?? _current!.List?.First;\n            return true;\n        }\n    }\n    public void Reset()\n    {\n        _current = null;\n    }\n    public void Dispose() { }\n}\n```", "```cs\npublic static class CircularLinkedListExtensions\n{\n    public static LinkedListNode<T>? Next<T>(\n        this LinkedListNode<T> n)\n    {\n        return n != null && n.List != null\n            ? n.Next ?? n.List.First\n            : null;\n    }\n}\n```", "```cs\nCircularLinkedList<string> categories = new();\ncategories.AddLast(\"Sport\");\ncategories.AddLast(\"Culture\");\ncategories.AddLast(\"History\");\ncategories.AddLast(\"Geography\");\ncategories.AddLast(\"People\");\ncategories.AddLast(\"Technology\");\ncategories.AddLast(\"Nature\");\ncategories.CircularLinkedList class is created, which represents a circular singly linked list with string elements. Then, eight values are added, namely Sport, Culture, History, Geography, People, Technology, Nature, and Science.\nThe following part of the code performs the most important operations:\n\n```", "```cs\n\n First, a few variables are declared:\n\n*   `isStopped`, which indicates whether the wheel is currently stopped\n*   `random`, for drawing random values of wheel spin in milliseconds\n*   `targetTime`, which is the target time when the wheel should stop\n*   `ms`, which is the last drawn number of milliseconds for wheel-spinning\n\nThen, the `foreach` loop is used to iterate through all the elements within a circular singly linked list. If there are no `break` or `return` instructions within such a loop, it will execute indefinitely due to the nature of a circular linked list. If the last item is reached, the first element in the list is taken automatically in the next iteration.\nIn this loop, you check whether the wheel is currently stopped or has not been started yet. If so, the message is presented to the user and the program waits until the *Enter* key is pressed. In such a situation, the new spinning operation is configured by drawing the total time of spinning, setting the expected stop time, indicating that the wheel is not stopped, as well as writing the current category. When the user presses any other key, the program stops its execution.\nIf the wheel is currently not stopped, you calculate the remaining number of milliseconds and the waiting time. This formula makes it possible to provide smaller times at the beginning (the wheel spins faster) and bigger times at the end (the wheel spins slower). Then, the program waits for the specified number of milliseconds.\nAt the end, you check whether the target time is reached. If so, the foreground color is changed to red and you indicate that the wheel is stopped. Then, the currently chosen category on the spinning wheel is presented in the console.\nWhen you run the application, you will get the result similar to the following one:\n![Figure 4.7 – Screenshot of the spin the wheel example](img/B18069_04_7.jpg)\n\nFigure 4.7 – Screenshot of the spin the wheel example\nWith that, we’ve looked at an example that uses a circular singly linked list. Are you curious whether you can expand it further to create a circular doubly linked list?\nCircular doubly linked lists\nThe last data structure we’ll cover in this chapter is named the **circular doubly linked list**. It is similar to the circular singly linked list but **allows you not only to iterate indefinitely in the forward direction but also in the backward direction**. You can achieve this by adding pointers to previous elements for each item in the list. Of course, you also need to point to the last element in the list as the previous element of the first one in the list.\nImagine a circular doubly linked list\nIf you want to better visualize a circular doubly linked list, grab your camera and start browsing the gallery of photos you’ve taken. Here, you can easily go from the first photo to the last one by clicking “back.” You can also go from the last photo to the first one by clicking “next.” Of course, you can also switch between subsequent photos in the photo gallery by clicking “back” and “next.” There is no issue with you taking another photo, at which point it will be added to the collection of photos you’ve already taken. Take a look for yourself! This is how a circular doubly linked list works. Snap, photo taken, and... let’s move on!\nA circular doubly linked list is presented in the following diagram:\n![Figure 4.8 – Illustration of a circular doubly linked list](img/B18069_04_8.jpg)\n\nFigure 4.8 – Illustration of a circular doubly linked list\nHere, the `PREV` property of the first node navigates to the last one, while the `NEXT` property of the last node navigates to the first. This data structure can be useful in some specific cases, as you will see while developing a real-world example.\nAfter this short introduction to the topic of circular doubly linked lists, it is time to take a look at the implementation code. If you use the code that’s already been prepared for the circular singly linked list, you only need to add one extension method, as shown here:\n\n```", "```cs\n\n The `Prev` method checks whether the node exists and whether the list is available. In such a case, it returns a value of the `Previous` property of the node (if such a value is not equal to `null`) or returns a reference to the last element in the list using the `Last` property. That’s all! Let’s take a look at the example.\nExample – art gallery\nThis example is a viewer of drawings presented in the console. Does this sound strange? It could be, but let’s try to create some console-based art!\nReal art in the console exists!\nThe topic of creating console-based graphics is quite popular and some amazing art has already been created by various authors! If you are curious about this topic, just search for *ASCII arts* in your web browser. Will you join this community with your drawings? If so, please share them with me as well!\nWhen a user presses *the right* or *left arrow*, the drawing is changed to the next or the previous one, respectively. As a result, the following art can be viewed in the console:\n![Figure 4.9 – ﻿Screenshots of the art gallery example](img/B18069_04_9.jpg)\n\nFigure 4.9 – Screenshots of the art gallery example\nThe code uses the `CircularLinkedList` class, as shown here:\n\n```", "```cs\n\n You create a circular doubly linked list consisting of a few elements. Each stores an array of strings. Such an array represents a particular image, namely the following rows forming the art. When you populate the list with data of all images, you store a reference to the first image as `node`. Then, you use a `do-while` loop that is executed until the *Escape* button is pressed. If the user presses the right arrow, you update the `node` variable using the `Next` method. If the left arrow is pressed, the `Prev` method is used instead. In each iteration, you clear the console and print the art so that you can receive a simple animation of a dancing figure.\nIf you are curious how such images are defined, take a look at the following code:\n\n```", "```cs\n\n With that, you’ve learned how to use a circular doubly linked list. In the final section of this chapter, we’ll learn about three list-related interfaces.\nList-related interfaces\nWhile developing applications in C#, you frequently use various collections, including lists. For this reason, it is worth mentioning three common interfaces:\n\n*   `IEnumerable`\n*   `ICollection`\n*   `IList`\n\nThe order of them is important because `IEnumerable` is the base interface for `ICollection` and `IList`, while `ICollection` is the base interface for `IList`. However, what is inside such interfaces? Let’s take a look!\n`IEnumerable` only provides you with a `GetEnumerator` method.\nThe `ICollection` interface adds the following methods for **manipulating** **the collection**:\n\n*   `Add` adds a given item to the collection\n*   `Clear` removes all the items from the collection\n*   `Contains` checks whether a given item exists in the collection\n*   `Remove` removes the first occurrence of a given item from the collection\n\nIt also exposes the `Count` and `IsReadOnly` properties, as well as the `CopyTo` method for copying the collection to an array.\nThe last interface I’ll mention here is `IList`. It allows you to **access items within the collection by an index**. Thus, the interface contains the indexer for getting or setting an item at a specified index in the collection, as well as methods:\n\n*   `IndexOf` returns an index of a given item in the collection\n*   `Insert` inserts a given item at a specified index in the collection\n*   `RemoveAt` removes an item at a specified index in the collection\n\nAs an example, do you know that the `LinkedList` generic class implements both generic and non-generic variants of the `ICollection` and `IE``numerable` interfaces? I strongly encourage you to take a look at other collections to see what interfaces are implemented by them. You can see this by clicking on the collection name in your code (such as `List` or `ArrayList`) and choosing the **Go To Definition** option from the context menu or simply by pressing *F12*.\nWhere can you find more information?\nYou can find content regarding the mentioned interfaces at: [https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable](https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable), [https://learn.microsoft.com/en-us/dotnet/api/system.collections.icollection](https://learn.microsoft.com/en-us/dotnet/api/system.collections.icollection), and [https://learn.microsoft.com/en-us/dotnet/api/system.collections.ilist](https://learn.microsoft.com/en-us/dotnet/api/system.collections.ilist).\nNext, I’ll summarize this chapter.\nSummary\nThis chapter was dedicated to **lists**, which are among the most common data structures that are used while developing various kinds of applications. However, this topic is not very easy because there are various variants of lists, including simple, sorted, and linked ones. Even this structure can be further divided as you saw while reading this chapter.\nFirst, you learned about **simple lists**, which can be implemented as an **array list** or as a **generic list**. One of the most important differences between them is that the array list is not strongly typed, while the generic list is. You learned about various properties and methods available for these data structures, together with extension methods. Such information was supported by code snippets.\nNext, you learned about **sorted lists**, which ensures a proper order of elements available in the collection. It is a bit of a different data structure but can be useful in various development scenarios. You learned how to use it while creating an address book, which is always sorted by names.\nFinally, you took a closer look at linked lists, starting with **singly linked lists** and **doubly linked lists**. They allow you to navigate between elements, either in only one direction or in both directions. Such a data structure can be easily extended to a **circular linked list**, either in singly or doubly linked variants. Therefore, you can benefit from the features of suitable structures without the significant development effort.\nThe available types of data structures can sound quite complicated. However, in this chapter, you saw detailed descriptions of particular data structures, together with illustrations and C#-based implementations. These should have helped simplify things for you and can be used as a basis for your future projects.\nAre you ready to learn other data structures? If so, proceed to the next chapter and read about **stacks** and **queues**!\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```"]