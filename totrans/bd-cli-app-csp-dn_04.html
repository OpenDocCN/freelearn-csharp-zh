<html><head></head><body>
		<div id="_idContainer065">
			<h1 id="_idParaDest-47" class="chapter-number"><a id="_idTextAnchor048"/>4</h1>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor049"/>Command-Line Parsing</h1>
			<p>In the previous chapter, we created a console application and learned how to pass parameters to it, converting these parameters to their expected data type when needed (remember that parameters passed to a console application are of the <span class="No-Break"><strong class="source-inline">String</strong></span><span class="No-Break"> type).</span></p>
			<p>However, even though a console application is at the heart of a CLI application, a CLI application is more than just a console application. A CLI application contains named parameters, switches, and subcommands to achieve the <span class="No-Break">intended goal.</span></p>
			<p>Armed with our knowledge of creating console applications, weâ€™ll build on top of that to learn how to create a <span class="No-Break">CLI application.</span></p>
			<p>To do so, in this chapter, weâ€™ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Creating the <span class="No-Break">console application</span></li>
				<li>Parsing the arguments of a <span class="No-Break">console application</span></li>
				<li>From console to CLI: parsing the arguments using an <span class="No-Break">existing library</span></li>
			</ul>
			<p>By the end of the chapter, you will learn how to start with a simple console application and convert it to a powerful CLI application that handles commands, subcommands, <span class="No-Break">and options.</span></p>
			<p class="callout-heading">Introducing Bookmarkr</p>
			<p class="callout"><strong class="bold">Bookmarkr</strong> is the<a id="_idIndexMarker097"/> name of the CLI application we will be building throughout <span class="No-Break">this book.</span></p>
			<p class="callout">It is a command-line application for <span class="No-Break">managing bookmarks.</span></p>
			<p class="callout">Throughout the pages of this book, we will bring <em class="italic">Bookmarkr</em> to life and add more and more features <span class="No-Break">to it.</span></p>
			<p class="callout"><em class="italic">Why a </em><span class="No-Break"><em class="italic">bookmark manager?</em></span></p>
			<p class="callout">Because everyone has used<a id="_idIndexMarker098"/> one, so they are familiar with how such a tool works and what functionalities <span class="No-Break">it provides.</span></p>
			<p class="callout">By removing the burden of understanding the business context of <em class="italic">what</em> we are building, we can then focus all of our attention on <em class="italic">how</em> we are building it. And that is precisely why I chose this application. Plus, it could still be super <span class="No-Break">useful </span><span class="No-Break">ğŸ˜‰</span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this <span class="No-Break">book, </span><a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor051"/>Creating the console application</h1>
			<p>Letâ€™s<a id="_idIndexMarker099"/> start by creating the console application. For this, in Visual Studio Code, display the <strong class="bold">Terminal</strong> window by going <span class="No-Break">to </span><span class="No-Break"><strong class="bold">View</strong></span><span class="No-Break">|</span><span class="No-Break"><strong class="bold">Terminal</strong></span><span class="No-Break">.</span></p>
			<p>Then, position yourself where you want the code folder to be created (I mentioned in the previous chapter that I always create a <strong class="source-inline">C:\Code</strong> folder that will contain all of my <span class="No-Break">code projects).</span></p>
			<p>From there, type the following command to create the <span class="No-Break">console application<a id="_idTextAnchor052"/>:</span></p>
			<pre class="console">
$ dotnet new console -n bookmarkr -o bookmarkr --use-program-main</pre>			<p>The .NET project currently looks like this when loaded in Visual <span class="No-Break">Studio Code:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B22400_04_01.jpg" alt="Figure 4.1 â€“ The bookmarkr project opened in Visual Studio Code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 â€“ The bookmarkr project opened in Visual Studio Code</p>
			<p>Letâ€™s add<a id="_idIndexMarker100"/> some code to the <span class="No-Break"><strong class="source-inline">Program.cs</strong></span><span class="No-Break"> file.</span></p>
			<p>The first feature we will implement is the ability to add a new bookmark to the list <span class="No-Break">of bookmarks.</span></p>
			<p>To do so, we need to create a <strong class="source-inline">BookmarkService</strong> class that will contain all the logic for the bookmarking operations. By following the best practices of development, we will create that class in its own code file, <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">BookmarkService.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
namespace bookmarkr;
public class BookmarkService
{
}</pre>			<p>Next, we will need to add a list of <strong class="source-inline">Bookmark</strong> objects to that <span class="No-Break"><strong class="source-inline">BookmarkService</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
namespace bookmarkr;
public class BookmarkService
{
Â Â Â Â private readonly List&lt;Bookmark&gt; _bookmarks = new();
}</pre>			<p>We <a id="_idIndexMarker101"/>will also need to define the <strong class="source-inline">Bookmark</strong> class. Here, again, we will follow the best practices of development, and we will create that class in its own code file, smartly named <strong class="source-inline">Bookmark.cs</strong> ğŸ˜Š. This class looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
namespace bookmarkr;
public class Bookmark
{
Â Â Â Â public required string Name { get; set; }
Â Â Â Â public required string Url { get; set; }
}</pre>			<p>Since the two properties of the <strong class="source-inline">Bookmark</strong> object cannot be <strong class="source-inline">null</strong>, we declare them with the <span class="No-Break"><strong class="source-inline">required</strong></span><span class="No-Break"> modifier.</span></p>
			<p>The updated .NET project now looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B22400_04_02.jpg" alt="Figure 4.2 â€“ The updated bookmarkr project opened in Visual Studio Code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 â€“ The updated bookmarkr project opened in Visual Studio Code</p>
			<p>Now that we have all the pieces in place, letâ€™s see how we can process <span class="No-Break">user requests.</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor053"/>Parsing the arguments of a console application</h1>
			<p>A <a id="_idIndexMarker102"/>request to a CLI application usually contains the name of the command (and an optional subcommand) along with arguments that provide values to the parameters needed by <span class="No-Break">the command.</span></p>
			<p>The first command we will be adding is the ability to add a new bookmark to the list <span class="No-Break">of bookmarks.</span></p>
			<p>The syntax of the expected command is <span class="No-Break">the following:</span></p>
			<pre class="console">
$ bookmarkr link add &lt;name&gt; &lt;url&gt;</pre>			<p>So, letâ€™s modify the code to handle such <span class="No-Break">a command!</span></p>
			<p>We will start with the <strong class="source-inline">Main</strong> method of the <strong class="source-inline">Program</strong> class (located in the <strong class="source-inline">Program.cs</strong> file). Why? Because this is the method that receives the input parameters from <span class="No-Break">the user.</span></p>
			<p>Since we may have multiple commands in the future, we will add a <strong class="source-inline">switch</strong> statement to handle each one of these. Hence, the code will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
namespace bookmarkr;
class Program
{
Â Â Â Â static void Main(string[] args)
Â Â Â Â {
Â Â Â Â Â Â Â Â if(args == null || args.Length == 0)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage(["You haven't passed any argument. 
Â Â Â Â Â Â Â Â Â Â Â Â The expected syntax is:", "bookmarkr &lt;command-name&gt; 
Â Â Â Â Â Â Â Â Â Â Â Â &lt;parameters&gt;"]);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â var service = new BookmarkService();
Â Â Â Â Â Â Â Â switch(args[0].ToLower())
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â case "link":
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ManageLinks(args, service);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â Â Â Â Â // we may add more commands here...
Â Â Â Â Â Â Â Â Â Â Â Â default:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage(["Unknown Command"]);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â static void ManageLinks(string[] args, BookmarkService svc)
Â Â Â Â {
Â Â Â Â Â Â Â Â if(args.Length &lt; 2)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage(["Unsufficient numberÂ Â of 
Â Â Â Â Â Â Â Â Â Â Â Â parameters. The expected syntax is:", "bookmarkr link 
Â Â Â Â Â Â Â Â Â Â Â Â &lt;subcommand&gt; &lt;parameters&gt;"]);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â switch(args[1].ToLower())
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â case "add":
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â svc.AddLink(args[2], args[3]);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â Â Â Â Â // we may add more subcommands here...
Â Â Â Â Â Â Â Â Â Â Â Â default:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage(["Unsufficient number of 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â parameters. The expected syntax is:", "bookmarkr link 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;subcommand&gt; &lt;parameters&gt;"]);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</pre>			<p>Letâ€™s<a id="_idIndexMarker103"/> explain <span class="No-Break">this code:</span></p>
			<ul>
				<li>The <strong class="source-inline">Main</strong> method<a id="_idIndexMarker104"/> dispatches the processing of each command to a specific method within the <strong class="source-inline">Program</strong> class. Since, for now, we only have one command (<strong class="source-inline">link</strong>), we have only one processing <span class="No-Break">method (</span><span class="No-Break"><strong class="source-inline">ManageLinks</strong></span><span class="No-Break">).</span></li>
				<li>The <strong class="source-inline">ManageLinks</strong> method handles the subcommands related to links. For now, we only have one subcommand (<strong class="source-inline">add</strong>) but we can easily imagine having more subcommands, such as <strong class="source-inline">update</strong> (to update the URL of an existing link), <strong class="source-inline">remove</strong> (to remove an existing link), and <strong class="source-inline">list</strong> (to list all <span class="No-Break">existing links).</span></li>
				<li>Finally, the <strong class="source-inline">ShowErrorMessage</strong> method is a utility method used to display error messages in red-colored text. Its code can be found in the <strong class="source-inline">Helper</strong> class and is omitted here because it does not provide value to the topic we <span class="No-Break">are discussing.</span></li>
			</ul>
			<p>If you write (or copy) this code, youâ€™ll notice that it does not compile. This is due to the <strong class="source-inline">AddLink</strong> method not yet being available in the <strong class="source-inline">BookmarkService</strong> class. Letâ€™s <span class="No-Break">add it!</span></p>
			<p>The code of the <strong class="source-inline">AddLink</strong> method is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public void AddLink(string name, string url)
{
Â Â Â Â Â Â Â Â if(string.IsNullOrWhiteSpace(name))
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage(["the 'name' for the link is 
Â Â Â Â Â Â Â Â Â Â Â Â not provided. The expected syntax is:", "bookmarkr link 
Â Â Â Â Â Â Â Â Â Â Â Â add &lt;name&gt; &lt;url&gt;"]);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if(string.IsNullOrWhiteSpace(url))
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage(["the 'url' for the link is 
Â Â Â Â Â Â Â Â Â Â Â Â not provided. The expected syntax is:", "bookmarkr link 
Â Â Â Â Â Â Â Â Â Â Â Â add &lt;name&gt; &lt;url&gt;"]);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if(_bookmarks.Any(b =&gt; b.Name.Equals(name, StringComparison.
Â Â Â Â Â Â Â Â OrdinalIgnoreCase)))
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Helper.ShowWarningMessage([$"A link with the name '{name}' 
Â Â Â Â Â Â Â Â Â Â Â Â already exists. It will thus not be added",
Â Â Â Â Â Â Â Â Â Â Â Â $"To update the existing link, use the command: bookmarkr 
Â Â Â Â Â Â Â Â Â Â Â Â link update '{name}' '{url}'"]);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â _bookmarks.Add(new Bookmark { Name = name, Url = url});
Â Â Â Â Â Â Â Â Helper.ShowSuccessMessage(["Bookmark successfully added!"]);
}</pre>			<p>This code is pretty <a id="_idIndexMarker105"/>simple and straightforward, but letâ€™s explain <span class="No-Break">it briefly:</span></p>
			<ul>
				<li>We first ensure that both the <strong class="source-inline">name</strong> and <strong class="source-inline">url</strong> parameters are provided. If not, we return an error message to the user with the expected syntax for <span class="No-Break">the command.</span></li>
				<li>We ensure that the link to be added is not already present in the list of bookmarks. If it is present, we inform the user with a warning message and invite them to use the <strong class="source-inline">update</strong> subcommand if they intend to update an <span class="No-Break">existing link.</span></li>
				<li>If the link does not already exist, we add it to the list of bookmarks and inform the user with a <span class="No-Break">success message.</span></li>
			</ul>
			<p>Pretty easy, isnâ€™t <span class="No-Break">it? </span><span class="No-Break">ğŸ˜Š</span></p>
			<p>However, there is a problem with this approach to building CLI applications. Can you guess what <span class="No-Break">it is?</span></p>
			<p>It is based on positional parameters. In other words, we expect the first parameter to be the name of the command, the second parameter to be the name of the subcommand, the third parameter to be the value of the <strong class="source-inline">name</strong> parameter, and the fourth parameter to be the value of the <span class="No-Break"><strong class="source-inline">url</strong></span><span class="No-Break"> parameter.</span></p>
			<p>But there are a couple <span class="No-Break">of issues:</span></p>
			<ul>
				<li>How could the user be aware of <span class="No-Break">that order?</span></li>
				<li>What if the user provided the <strong class="source-inline">url</strong> value as the third parameter and the <strong class="source-inline">name</strong> value as the <span class="No-Break">fourth parameter?</span></li>
			</ul>
			<p>If youâ€™re familiar with using CLI applications, you will know that the usual syntax for a CLI command looks <span class="No-Break">like this:</span></p>
			<pre class="console">
$ bookmarkr link add --name &lt;name&gt; --url &lt;url&gt;</pre>			<p>It can also look <span class="No-Break">like this:</span></p>
			<pre class="console">
$ bookmarkr link add -n &lt;name&gt; -u &lt;url&gt;</pre>			<p>This helps the <a id="_idIndexMarker106"/>user to know what is expected as parameters and to provide the parameters in the <span class="No-Break">appropriate manner.</span></p>
			<p>We can, of course, rely on the <strong class="source-inline">args</strong> list of parameters and compare each one to what is expected (for example, checking whether the third parameterâ€™s value is <strong class="source-inline">--name</strong> or <strong class="source-inline">-n</strong> so we know that the fourth parameter represents the value of the name of the link, and so on), but this will complexify our code <span class="No-Break">too much.</span></p>
			<p>I know what youâ€™re thinking. Youâ€™re smart and youâ€™ve already figured out that the best approach to solve this problem is to develop a library to parse these parameters and figure out what <span class="No-Break">they represent.</span></p>
			<p>But, because I know youâ€™re smart, I know that youâ€™ve already searched for an existing library that does just that. After all, you do not want to reinvent the wheel, <span class="No-Break">do you?</span></p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor054"/>From console to CLI â€“ parsing the arguments using an existing library</h1>
			<p>Although many libraries exist for the different programming languages, including .NET, we will focus on <strong class="source-inline">System.CommandLine</strong> throughout<a id="_idIndexMarker107"/> <span class="No-Break">this book.</span></p>
			<p>You may be wondering why we chose this library, especially if you are familiar with (or have heard about) <strong class="source-inline">CommandLineParser</strong>, which<a id="_idIndexMarker108"/> is another common library for <span class="No-Break">that matter.</span></p>
			<p>There are multiple reasons for that. In essence, <strong class="source-inline">System.CommandLine</strong> is a more modern, feature-rich, and performant library, whereas <strong class="source-inline">CommandLineParser</strong> is a simpler and more <span class="No-Break">lightweight alternative.</span></p>
			<p>Additionally, there are a few other reasons why I <span class="No-Break">prefer </span><span class="No-Break"><strong class="source-inline">System.CommandLine</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">System.CommandLine</strong> is a .NET Foundation project developed by Microsoft and the community, while <strong class="source-inline">CommandLineParser</strong> is a <span class="No-Break">third-party library</span></li>
				<li><strong class="source-inline">System.CommandLine</strong> uses a builder pattern and a more declarative approach to define commands and options, while <strong class="source-inline">CommandLineParser</strong> uses attributes and a more <span class="No-Break">imperative approach</span></li>
				<li><strong class="source-inline">System.CommandLine</strong> provides more advanced features out of the box, such as command hierarchies, response files, auto-completion, and parsing directives, whereas <strong class="source-inline">CommandLineParser</strong> is more lightweight and focused on basic <span class="No-Break">command-line parsing</span></li>
				<li><strong class="source-inline">System.CommandLine</strong> is known to be faster and more efficient, especially for large <span class="No-Break">command-line structures</span></li>
				<li>Even though both libraries are cross-platform, <strong class="source-inline">System.CommandLine</strong> has better support for platform-specific conventions, such as case-insensitivity <span class="No-Break">on Windows</span></li>
			</ul>
			<p>Now, letâ€™s rewrite our application to benefit from <a id="_idIndexMarker109"/>the <span class="No-Break"><strong class="source-inline">System.CommandLine</strong></span><span class="No-Break"> library!</span></p>
			<p class="callout-heading">Important note #1</p>
			<p class="callout">The previous code of the <strong class="source-inline">Program.cs</strong> file has been moved into a <strong class="source-inline">Program.Console.txt</strong> file for <span class="No-Break">further reference.</span></p>
			<p class="callout-heading">Important note #2</p>
			<p class="callout">While you can execute the application by its executable name (located in <strong class="source-inline">bin\Debug\net8.0\bookmarkr.exe</strong>), itâ€™s more convenient, during the development phase, to use the <strong class="source-inline">dotnet </strong><span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command.</span></p>
			<p class="callout">I prefer to rely on the executable name because it matches how we will use the application in production. If you prefer to use the <strong class="source-inline">dotnet run</strong> command, simply replace <strong class="source-inline">bookmarkr</strong> with <strong class="source-inline">dotnet run</strong> in the following <span class="No-Break">execution syntaxes.</span></p>
			<p>The first thing we need to do is to add the <strong class="source-inline">System.CommandLine</strong> NuGet package library to our project. To do this, open the Visual Studio Code terminal and type the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ dotnet add package System.CommandLine --prerelease</pre>			<p>At the time of the writing of this chapter, this library is still in Beta. When it makes it to <strong class="bold">general availability</strong> (<strong class="bold">GA</strong>), you will<a id="_idIndexMarker110"/> not need the <strong class="source-inline">--prerelease</strong> <span class="No-Break">switch anymore.</span></p>
			<p>The way <strong class="source-inline">System.CommandLine</strong> works is to have a <strong class="source-inline">RootCommand</strong> object that will act as the root command for all other commands of the CLI application. This means that every command in the application has, as a parent, either the <strong class="source-inline">root</strong> command or another command whose parent is ultimately the <span class="No-Break">root command.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor055"/>Adding the root command</h2>
			<p>The root command is the one that <a id="_idIndexMarker111"/>gets called when the user invokes the CLI application with <span class="No-Break">no parameters.</span></p>
			<p>The root command is an instance of the <span class="No-Break"><strong class="source-inline">RootCommand</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
var rootCommand = new RootCommand("Bookmarkr is a bookmark manager provided as a CLI application.")
{
};</pre>			<p>A command has a handler, which is a method that is called as the result of the user invoking <span class="No-Break">that command:</span></p>
			<pre class="source-code">
rootCommand.SetHandler(OnHandleRootCommand);</pre>			<p>The <strong class="source-inline">SetHandler</strong> method takes a delegate to the actual method that does <span class="No-Break">the job:</span></p>
			<pre class="source-code">
static void OnHandleRootCommand()
{
Â Â Â Â Console.WriteLine("Hello from the root command!");
}</pre>			<p>Finally, and since the <strong class="source-inline">System.CommandLine</strong> library follows the <strong class="source-inline">Builder</strong> pattern, we need to build and invoke a parser to kick <span class="No-Break">things in:</span></p>
			<pre class="source-code">
var parser = new CommandLineBuilder(rootCommand)
Â Â Â Â .UseDefaults()
Â Â Â Â .Build();
return await parser.InvokeAsync(args);</pre>			<p>Last but not least, letâ€™s add the required <strong class="source-inline">using</strong> statements at the top of <span class="No-Break">the file:</span></p>
			<pre class="source-code">
using System.CommandLine;
using System.CommandLine.Builder;
using System.CommandLine.Parsing;</pre>			<p>We are now ready to execute our application! Type <span class="No-Break">the following:</span></p>
			<pre class="console">
$ bookmarkr</pre>			<p>When executed, the<a id="_idIndexMarker112"/> application will invoke the appropriate command (here, the root command since no argument was passed to the executing application), which, in turn, will invoke its handler method (<strong class="source-inline">OnHandleRootCommand</strong>), and the result of its execution will be returned to the user. In this example, the command will display the message <strong class="source-inline">"Hello from the </strong><span class="No-Break"><strong class="source-inline">root command!"</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B22400_04_03.jpg" alt="Figure 4.3 â€“ Invoking the root command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 â€“ Invoking the root command</p>
			<p>Isnâ€™t that exciting? No? Youâ€™re rightâ€¦ This is not (yet) looking like a CLI application. Letâ€™s add <span class="No-Break">another command!</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor056"/>Adding the link command</h2>
			<p>The syntax for adding bookmarks<a id="_idIndexMarker113"/> using our CLI application is supposed to be <span class="No-Break">like this:</span></p>
			<pre class="console">
$ bookmarkr link add &lt;name&gt; &lt;url&gt;</pre>			<p>So, we need to create a <strong class="source-inline">link</strong> command. This command will have the root command as <span class="No-Break">a parent:</span></p>
			<pre class="source-code">
var linkCommand = new Command("link", "Manage bookmarks links")
{
};
rootCommand.AddCommand(linkCommand);</pre>			<p>Next, we need an <strong class="source-inline">add</strong> command, whose parent will be the <span class="No-Break"><strong class="source-inline">link</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
var addLinkCommand = new Command("add", "Add a new bookmark link")
{
};
linkCommand.AddCommand(addLinkCommand);
addLinkCommand.SetHandler(OnHandleAddLinkCommand);</pre>			<p>Now, letâ€™s execute <span class="No-Break">this application:</span></p>
			<pre class="console">
$ bookmarkr link add</pre>			<p>Pretty <span class="No-Break">close, huh?</span></p>
			<p>The only elements that are missing are the <strong class="source-inline">&lt;name&gt;</strong> and <strong class="source-inline">&lt;url&gt;</strong> parts. These are called <strong class="bold">options</strong>, and we will look into them in a moment. But first, letâ€™s focus <span class="No-Break">on commands.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor057"/>About commands</h2>
			<p>Commands are like a tree <a id="_idIndexMarker114"/>where the root command isâ€¦ well, the root of <span class="No-Break">that tree.</span></p>
			<p>Each command has a parent, which is either another command (for example, <strong class="source-inline">add</strong> has <strong class="source-inline">link</strong> as a parent), or the root command itself (as for the <span class="No-Break"><strong class="source-inline">link</strong></span><span class="No-Break"> command).</span></p>
			<p>The command tree dictates the syntax of the CLI application. For example, we cannot perform the <span class="No-Break">following call:</span></p>
			<pre class="console">
$ bookmarkr add</pre>			<p>This is because no <strong class="source-inline">add</strong> command has the root command as <span class="No-Break">a parent.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor058"/>Do all commands need to have a handler method?</h2>
			<p>The answer is, no, they donâ€™t. Only commands that actually do some processing need to have a handler method. In our case, neither the root command nor the <strong class="source-inline">link</strong> command require <span class="No-Break">a handler.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor059"/>Adding options to the link command</h2>
			<p>Since the <strong class="source-inline">add</strong> command<a id="_idIndexMarker115"/> requires two parameters (<strong class="source-inline">name</strong> and <strong class="source-inline">url</strong>), we will add two options <span class="No-Break">to it:</span></p>
			<pre class="source-code">
var nameOption = new Option&lt;string&gt;(
Â Â Â Â ["--name", "-n"],
Â Â Â Â "The name of the bookmark"
);
var urlOption = new Option&lt;string&gt;(
Â Â Â Â ["--url", "-u"],
Â Â Â Â "The URL of the bookmark"
);</pre>			<p>As you can see, an <strong class="source-inline">Option</strong> is defined by <span class="No-Break">the following:</span></p>
			<ul>
				<li>The data type of its value (here, <span class="No-Break">a string)</span></li>
				<li>Its aliases (for <strong class="source-inline">urlOption</strong>, these are <strong class="source-inline">--url</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">-u</strong></span><span class="No-Break">)</span></li>
				<li>Its description, which will be useful when requesting the help menu for that command (for <strong class="source-inline">urlOption</strong>, it is <strong class="source-inline">"The URL of </strong><span class="No-Break"><strong class="source-inline">the bookmark"</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Next, we need to<a id="_idIndexMarker116"/> assign these options to the command, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var addLinkCommand = new Command("add", "Add a new bookmark link")
{
Â Â Â Â nameOption,
Â Â Â Â urlOption
};</pre>			<p>We then need to pass these options to the <span class="No-Break"><strong class="source-inline">Handler </strong></span><span class="No-Break">method:</span></p>
			<pre class="source-code">
addLinkCommand.SetHandler(OnHandleAddLinkCommand, nameOption, urlOption);</pre>			<p>And, finally, we use the values of these options in the <span class="No-Break"><strong class="source-inline">Handler</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
static void OnHandleAddLinkCommand(string name, string url)
{
Â Â Â Â // 'service' is an instance of 'BookmarkService'.
Â Â Â Â service.AddLink(name, url);
}</pre>			<p>Now, if we execute the application, we get the expected result. This time, we saved about half of the code by not having to parse the arguments of the console application and delegating this to the <span class="No-Break"><strong class="source-inline">System.CommandLine</strong></span><span class="No-Break"> library:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B22400_04_04.jpg" alt="Figure 4.4 â€“ We successfully added a bookmark"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 â€“ We successfully added a bookmark</p>
			<p>Note that, using<a id="_idIndexMarker117"/> the aliases, we can execute the CLI application using <span class="No-Break">this syntax:</span></p>
			<pre class="console">
$ bookmarkr --name 'Packt Publishing' --url 'https://www.packtpub.com'</pre>			<p> We can also use <span class="No-Break">this syntax:</span></p>
			<pre class="console">
$ bookmarkr -n 'Packt Publishing' -u 'https://www.packtpub.com'</pre>			<p>The result will be the same as the one shown in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor060"/>What other types of options can we use?</h2>
			<p><strong class="source-inline">System.CommandLine</strong> doesnâ€™t only support <strong class="source-inline">string</strong> options. <strong class="source-inline">Option&lt;T&gt;</strong> is a generic type, so you can create an <strong class="source-inline">Option&lt;T&gt;</strong> for any data type. This, for example, could be <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">int</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">double</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">bool</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">DateTime</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Uri</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">TimeSpan</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Regex</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Enum</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">IPAddress</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">FileInfo</strong></span></li>
			</ul>
			<p>It could even be your own custom class if <span class="No-Break">you prefer.</span></p>
			<p>Depending on the data type we use, the provided value for the option will be parsed into that data type. If parsing fails, an exception will be raised, and an error message will be displayed to <span class="No-Break">the console.</span></p>
			<p>Here is an illustrative example. The root command has been updated to accept an integer option. When the program is executed and a value that cannot be parsed into an integer is provided for that option, we get the following <span class="No-Break">error message:</span></p>
			<pre class="console">
$ bookmarkr --number toto
Cannot parse argument 'toto' for option '--number' as expected type 'System.Int32'.</pre>			<p>Hmmâ€¦ Although the name of the option indicates that it is expecting a number, it is not clear what that number is all about. What is its purpose? Is there a range of valid values for that number? A little help would beâ€¦ well, helpful <span class="No-Break">here </span><span class="No-Break">ğŸ˜Š</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor061"/>Getting help</h2>
			<p>The good news is that when <a id="_idIndexMarker118"/>using <strong class="source-inline">System.CommandLine</strong>, we get the help menu automatically built for us. All we need to do is to provide meaningful names and descriptions to our commands and options and the library will do <span class="No-Break">the rest.</span></p>
			<p>We can get help by using either one of <span class="No-Break">these options:</span></p>
			<ul>
				<li><strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">help</strong></span></li>
				<li><strong class="source-inline">-h</strong></li>
				<li><strong class="source-inline">-?</strong></li>
			</ul>
			<p>The result will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B22400_04_05.jpg" alt="Figure 4.5 â€“ Help!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 â€“ Help!</p>
			<p>This also works for<a id="_idIndexMarker119"/> subcommands. For example, if we want to get help regarding the <strong class="source-inline">link</strong> command, we can type <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B22400_04_06.jpg" alt="Figure 4.6 â€“ Getting help for the link command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 â€“ Getting help for the link command</p>
			<p>We can do this<a id="_idIndexMarker120"/> for one subcommand at a time, such as the <strong class="source-inline">link add</strong> command, <span class="No-Break">for example:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B22400_04_07.jpg" alt="Figure 4.7 â€“ Getting help for the link add command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 â€“ Getting help for the link add command</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You have probably noticed <a id="_idIndexMarker121"/>that the <strong class="source-inline">dotnet run</strong> syntax for getting help requires an extra <strong class="source-inline">--</strong>. This is not a typo. It is required because, otherwise, the .NET CLI tool will <em class="italic">think</em> that you are requesting help with the <span class="No-Break"><strong class="source-inline">dotnet</strong></span><span class="No-Break"> tool.</span></p>
			<p class="callout">The extra <strong class="source-inline">--</strong> is used to separate the arguments that are passed to <strong class="source-inline">dotnet run</strong> from the arguments that are passed to the application being run. Everything after <strong class="source-inline">--</strong> is considered an argument to the application, not to <span class="No-Break"><strong class="source-inline">dotnet run</strong></span><span class="No-Break">.</span></p>
			<p>However, one thing we should keep in mind is that the usage of a CLI application (and hence, its help) depends on the current version of the application. But how do we get <span class="No-Break">that information?</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Getting the applicationâ€™s version number</h2>
			<p>There is a built-in<a id="_idIndexMarker122"/> option (<strong class="source-inline">--version</strong>) that displays the version number of the <span class="No-Break">CLI application.</span></p>
			<p>To display it, execute the command <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ bookmarkr --version</pre>			<p>But where does this value <span class="No-Break">come from?</span></p>
			<p>Well, it can be found in the <strong class="source-inline">.csproj</strong> file, within the <strong class="source-inline">&lt;PropertyGroup&gt;</strong> element at the beginning of <span class="No-Break">the file:</span></p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
Â Â Â Â &lt;OutputType&gt;Exe&lt;/OutputType&gt;
Â Â Â Â &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
Â Â Â Â &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
Â Â Â Â &lt;Nullable&gt;enable&lt;/Nullable&gt;
Â Â Â Â &lt;Version&gt;2.0.0&lt;/Version&gt;
&lt;/PropertyGroup&gt;</pre>			<p>Note that if no <strong class="source-inline">&lt;version&gt;</strong> element is provided, the default value to be returned will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">1.0.0</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Here, too, if you want to use the <strong class="source-inline">dotnet run</strong> syntax to query the version number of the application, youâ€™ll need to use the extra <strong class="source-inline">--</strong>, as follows: <strong class="source-inline">dotnet run -- --</strong><span class="No-Break"><strong class="source-inline">version</strong></span><span class="No-Break">.</span></p>
			<p>And thatâ€™s it! Youâ€™re now all set and ready to create your first <span class="No-Break">CLI application!</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor063"/>Summary</h1>
			<p>In this chapter, we started to build our very own CLI application, <em class="italic">Bookmarkr</em>, which is a bookmark manager provided as a CLI application, so it can be used within a <span class="No-Break">Terminal window.</span></p>
			<p>We started with a console application (because remember, â€œAt the core of every CLI application is a console applicationâ€), and then we introduced a library for parsing its command-line arguments including commands, subcommands, and options so we donâ€™t need to reinvent <span class="No-Break">the wheel.</span></p>
			<p>In the upcoming chapter, we will see how to control inputs and outputs and how to read data from and write data to a file so we can perform backup and restore operations for our bookmarks. This will prove especially useful to import and export bookmarks into and out of our bookmark <span class="No-Break">manager application</span></p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn <span class="No-Break">through practice.</span></p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the <em class="italic">Bookmarkr</em> application by adding the <span class="No-Break">following features.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/>Task #1 â€“ Delete an existing bookmark</h2>
			<p>The syntax is <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ bookmarkr link remove --name &lt;name&gt;</pre>			<p>It can also be <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ bookmarkr link remove -n &lt;name&gt;</pre>			<p>If the requested link name does not exist, the application should display a warning message to the user. Otherwise, the application should delete that bookmark and display a success message to <span class="No-Break">the user.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/>Task #2 â€“ Update an existing bookmark</h2>
			<p>The syntax is <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ bookmarkr link update --name &lt;name&gt; --url &lt;url&gt;</pre>			<p>It can also be <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ bookmarkr link update -n &lt;name&gt; -u &lt;url&gt;</pre>			<p>If the requested link name does not exist, the application should display an error message to the user and invite them to use the <strong class="source-inline">add</strong> command to add a new bookmark. Otherwise, the application should update the existing bookmark with the newly provided URL and display a success message to <span class="No-Break">the user.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor067"/>Task #3 â€“ List all existing bookmarks</h2>
			<p>The syntax is <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ bookmarkr link --list</pre>			<p>It can also be <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ bookmarkr link -l</pre>			<p>If the list of bookmarks contains no items, the application should display a warning message saying that the list of bookmarks is empty and, therefore, there is nothing to display. Otherwise, the application should present the list of bookmarks <span class="No-Break">as follows:</span></p>
			<pre class="console">
# &lt;name 1&gt;
&lt;url 1&gt;
# &lt;name 2&gt;
&lt;url 2&gt;
...</pre>		</div>
	</body></html>