- en: Using the Right Controls for the Job
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合适的控件完成任务
- en: In this chapter, we'll first consider the existing controls that **Windows Presentation
    Foundation** (**WPF**) offers us and look at how we can use them to create the
    layouts that we require. We'll investigate the many ways that we can modify these
    controls to avoid the need to create new controls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先考虑Windows Presentation Foundation（**WPF**）为我们提供的现有控件，并查看我们如何使用它们来创建所需布局。我们将调查我们可以修改这些控件的各种方式，以避免创建新控件的需求。
- en: We'll examine the various levels of functionality that are built into the existing
    controls and then discover how to best declare our own controls when required.
    We'll take an in-depth look at the various options that we have and determine
    when it's best to use each one. Let's jump straight in and take a look at the
    various layout controls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查现有控件中内置的各种功能级别，然后发现当需要时如何最好地声明我们自己的控件。我们将深入探讨我们拥有的各种选项，并确定何时使用每个选项最为合适。让我们直接跳入并查看各种布局控件。
- en: Investigating the built-in controls
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查内置控件
- en: There is a wide range of controls included in .NET Framework. They cover most
    common scenarios and it is rare that we will need to create our own controls in
    a typical form-based application. All of the UI controls tend to have their functionality
    built up from a large number of common base classes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework中包含了许多控件。它们涵盖了大多数常见场景，在典型的基于表单的应用程序中，我们很少需要创建自己的控件。所有的UI控件通常都是从大量常见的基类构建其功能。
- en: All controls will share the same core-level base classes that provide the core-level
    functionalities and then a number of derived framework-level classes that provide
    the functionality that is associated with the WPF Framework, such as data binding,
    styling, and templating. Let's take a look at an example.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有控件都将共享相同的核心级基类，这些基类提供核心级功能，然后是一系列派生框架级类，这些类提供与WPF框架关联的功能，例如数据绑定、样式化和模板化。让我们来看一个例子。
- en: Inheriting framework abilities
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承框架能力
- en: 'As with the base classes in our application framework, the built-in WPF controls
    also have an inheritance hierarchy, with each successive base class offering some
    additional functionality. Let''s look at the `Button` class as an example. Here
    is the inheritance hierarchy of the `Button` control:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们应用程序框架中的基类一样，内置的WPF控件也有一个继承层次结构，每个后续的基类都提供一些额外的功能。让我们以`Button`类为例。以下是`Button`控件的继承层次结构：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As with every object in .NET Framework, we start with the `Object` class, which
    provides low-level services to all classes. These include object comparison, finalization,
    and the ability to output a customizable `string` representation of each object.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像.NET Framework中的每个对象一样，我们首先从`Object`类开始，它为所有类提供低级服务。这些包括对象比较、终结和输出每个对象的可自定义`string`表示形式的能力。
- en: Next is the `DispatcherObject` class, which provides each object with thread
    affinity and associates them with a `Dispatcher` object. The `Dispatcher` class
    manages a prioritized queue of work items for individual threads. Only the thread
    that the associated `Dispatcher` object was created on can access each `DispatcherObject`
    directly and this enables derived classes to enforce thread safety.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`DispatcherObject`类，它为每个对象提供线程亲和性并将它们与一个`Dispatcher`对象关联起来。`Dispatcher`类管理为单个线程的工作项的优先级队列。只有创建相关`Dispatcher`对象的线程可以直接访问每个`DispatcherObject`，这使派生类能够强制执行线程安全。
- en: After the `DispatcherObject` class, we have the `DependencyObject` class, which
    enables all derived classes to use the WPF property system and declare Dependency
    Properties. The `GetValue` and `SetValue` methods that we call to access and set
    their values are also provided by the `DependencyObject` class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DispatcherObject`类之后，我们有`DependencyObject`类，它使所有派生类都能够使用WPF属性系统并声明依赖属性。我们用来访问和设置它们值的`GetValue`和`SetValue`方法也是由`DependencyObject`类提供的。
- en: Next up is the `Visual` class, which has the primary role of providing rendering
    support. All elements that are displayed in the UI will extend the `Visual` class.
    In addition to rendering each object, it also calculates their bounding box and
    provides support for hit testing, clipping, and transformations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Visual`类，它的主要作用是提供渲染支持。在UI中显示的所有元素都将扩展`Visual`类。除了渲染每个对象外，它还计算它们的边界框并提供对击中测试、裁剪和转换的支持。
- en: Extending the `Visual` class is the `UIElement` class, which provides a number
    of core services to all of its derived classes. These include the event and user
    input systems and the ability to determine the element's layout appearance and
    rendering behavior.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`Visual`类的是`UIElement`类，它为所有派生类提供了一系列核心服务。这些服务包括事件和用户输入系统，以及确定元素布局外观和渲染行为的能力。
- en: Following on from that is the `FrameworkElement` class, which provides the first
    framework-level members, building upon the foundation of the core-level classes
    that it extends. It is the `FrameworkElement` class that enables data binding
    through the `DataContext` property and styling through the `Style` property.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`FrameworkElement`类，它提供了第一级框架成员，建立在它所扩展的核心级别类的基础之上。是`FrameworkElement`类通过`DataContext`属性实现了数据绑定，通过`Style`属性实现了样式化。
- en: It also provides events that relate to an object's lifetime, an upgrade of the
    core-level layout system to a full layout system and improved support for animations,
    among other things. This is typically the lowest-level class that we might want
    to extend if we were creating our own basic elements, as it enables derived classes
    to partake in the majority of the WPF UI capabilities.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了与对象生命周期相关的事件，将核心级别的布局系统升级为完整的布局系统，并改进了对动画的支持，以及其他功能。这通常是如果我们创建自己的基本元素时可能想要扩展的最低级别类，因为它使派生类能够参与WPF
    UI的大部分功能。
- en: The `Control` class extends the `FrameworkElement` class and is the base class
    for most of the WPF UI elements. It provides appearance templating through the
    use of its `ControlTemplate` functionality and a host of appearance-related properties.
    These include coloring properties, such as `Background`, `Foreground`, and `BorderBrush`,
    along with alignment and typeface properties.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Control`类扩展了`FrameworkElement`类，并且是大多数WPF UI元素的基类。它通过使用其`ControlTemplate`功能提供外观模板化，以及一系列与外观相关的属性。这些属性包括颜色属性，如`Background`、`Foreground`和`BorderBrush`，以及对齐和字体属性。'
- en: Extending the `Control` class is the `ContentControl` class, which enables controls
    to have one object of any CLR type as its content. This means that we can either
    set data objects or UI elements as the content, although we may need to provide
    a `DataTemplate` for the data objects if they are of a custom type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`Control`类的是`ContentControl`类，它使得控件能够拥有任何CLR类型的单个对象作为其内容。这意味着我们可以将数据对象或UI元素设置为内容，尽管如果数据对象是自定义类型，我们可能需要提供一个`DataTemplate`。
- en: The final class in the long line of parent classes that the `Button` class extends
    is the `ButtonBase` class. In fact, this is the base class for all buttons in
    WPF and it adds useful functionality for buttons. This includes automatically
    converting certain keyboard events to mouse events, so that users can interact
    with the buttons without using a mouse.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`类所扩展的父类长串中的最后一类是`ButtonBase`类。实际上，这是WPF中所有按钮的基类，并为按钮添加了有用的功能。这包括自动将某些键盘事件转换为鼠标事件，使用户能够在不使用鼠标的情况下与按钮交互。'
- en: The `Button` class itself adds little to its inherited members with only three
    related `bool` properties; two that specify whether a button is the default button
    and one that specifies whether the button is a cancel button. We'll see an example
    of this shortly. It has an additional two protected overridden methods that get
    called when the button is clicked or when an automation peer is created for it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`类本身对其继承成员的添加很少，只有三个相关的`bool`属性；两个指定按钮是否是默认按钮，一个指定按钮是否是取消按钮。我们很快就会看到这个例子。它还有两个受保护的覆盖方法，当按钮被点击或为其创建自动化代理时会被调用。'
- en: While WPF enables us to modify existing controls to such a degree that we rarely
    need to create our own, it is important to be aware of this inheritance hierarchy
    so that we can extend the appropriate and most lightweight base class that fulfills
    our requirements when we need to.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WPF使我们能够修改现有的控件到这种程度，以至于我们很少需要创建自己的控件，但了解这种继承层次结构非常重要，这样我们才能在我们需要时扩展满足我们要求的适当且最轻量级的基类。
- en: For example, if we wanted to create our own custom button, it would typically
    make more sense to extend the `ButtonBase` class, rather than the `Button` class,
    and if we wanted to create a totally unique control, we could extend the `FrameworkElement`
    class. Now that we have a good understanding of the make-up of the available controls,
    let's see how they are displayed by the WPF layout system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建自己的自定义按钮，通常更合理的是扩展`ButtonBase`类，而不是`Button`类；如果我们想创建一个完全独特的控件，我们可以扩展`FrameworkElement`类。现在我们已经很好地理解了可用控件的结构，让我们看看WPF布局系统是如何显示它们的。
- en: Laying it on the line
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按行排列
- en: In WPF, the layout system is responsible for attaining the sizes of each element
    to be displayed, positioning them on screen, and then drawing them. As controls
    can be contained within other controls, the layout system works recursively, with
    each child control's overall position being determined by the position of its
    parent panel control.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，布局系统负责确定每个要显示的元素的大小，将它们定位在屏幕上，然后绘制它们。由于控件可以包含在其他控件中，布局系统以递归方式工作，每个子控件的总体位置由其父面板控件的位置决定。
- en: The layout system first measures each child in each panel in what is known as
    a measure pass. During this pass, each panel calls the `Measure` method of each
    child element and they specify how much space they would ideally like to have;
    this determines the `UIElement.DesiredSize` property value. Note that this is
    not necessarily how much space they will be given.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 布局系统首先在所谓的测量过程中测量每个面板中的每个子元素。在这个过程中，每个面板调用每个子元素的`Measure`方法，并指定它们理想上希望拥有的空间量；这确定了`UIElement.DesiredSize`属性值。请注意，这并不一定是它们将被分配的空间量。
- en: After the measure pass comes the arrange pass, when each panel calls the `Arrange`
    method of each child element. During this pass, the panels generate the bounding
    boxes of each of their child elements, dependent upon their `DesiredSize` values.
    The layout system will adjust these sizes to add any required margins or additional
    adjustments that may be needed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在测量过程之后是排列过程，此时每个面板调用每个子元素的`Arrange`方法。在这个过程中，面板根据它们的`DesiredSize`值生成每个子元素的边界框。布局系统将调整这些大小以添加所需的边距或可能需要的任何其他调整。
- en: It returns a value to the input parameter of the panels' `ArrangeOverride` method
    and each panel performs its own specific layout behavior before returning the
    possibly adjusted value. The layout system performs any remaining required adjustments
    before returning execution to the panel and completing the layout process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个值到面板的`ArrangeOverride`方法的输入参数，每个面板在返回可能调整后的值之前执行其特定的布局行为。布局系统在将执行权返回给面板并完成布局过程之前执行任何剩余的必要调整。
- en: We need to be careful when developing our applications to ensure that we do
    not unnecessarily trigger additional passes of the layout system, as this can
    lead to poor performance. This can occur when adding or removing items in a collection,
    applying transforms on the elements, or by calling the `UIElement.UpdateLayout`
    method, which forces a new layout pass.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发我们的应用程序时，我们需要小心，以确保我们不会不必要地触发布局系统的额外遍历，因为这可能导致性能下降。这可能在向集合中添加或删除项目、对元素应用转换或调用`UIElement.UpdateLayout`方法时发生，后者强制进行新的布局遍历。
- en: Containing controls
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含控件
- en: 'The existing controls can mostly be split into two main categories: those that
    provide layout support for other controls and those that make up the visible UI,
    and are arranged in it by the first category of controls. The first category of
    controls are of course panels and they provide a variety of ways to arrange their
    child controls in the UI.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的控件大多可以分为两大类：一类为其他控件提供布局支持，另一类则构成可见的UI，并通过第一类控件进行排列。第一类控件当然是面板，它们提供了多种方式来在UI中排列其子控件。
- en: Some provide resizing capabilities, while others don't, and some are more efficient
    than others, so it's important to use the right panel for the job at hand. Additionally,
    different panels offer different layout behaviors, so it is good to know what
    the available panels are and what they each offer us in terms of layout.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些提供了调整大小功能，而另一些则没有，一些比其他更高效，因此使用正确的面板来完成工作非常重要。此外，不同的面板提供不同的布局行为，因此了解可用的面板以及它们在布局方面为我们提供什么是有益的。
- en: All panels extend the abstract `Panel` class, and that extends the `FrameworkElement`
    class so it has all of the members and functionality of that class. However, it
    doesn't extend the `Control` class and so it cannot inherit its properties. It
    therefore adds its own `Background` property to enable users to color the gaps
    between the panel's various items.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有面板都扩展了抽象的 `Panel` 类，该类扩展了 `FrameworkElement` 类，因此它具有该类的所有成员和功能。然而，它没有扩展 `Control`
    类，因此它不能继承其属性。因此，它添加了自己的 `Background` 属性，使用户能够为面板的各种项目之间的间隙着色。
- en: The `Panel` class also provides a `Children` property that represents the items
    in each panel, although we do not typically interact with this property unless
    creating a custom panel. Instead, we can populate this collection by simply declaring
    our child elements directly within the panel element in XAML.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Panel` 类还提供了一个 `Children` 属性，它表示每个面板中的项目，尽管我们通常不会与这个属性交互，除非创建一个自定义面板。相反，我们可以在
    XAML 中直接在面板元素内声明我们的子元素来填充这个集合。'
- en: We are able to do this because the `Panel` class specifies the `Children` property
    in a `ContentPropertyAttribute` attribute in its class definition. While the `Content`
    property of a `ContentControl` normally enables us to add a single item of content,
    we are able to add multiple items into panels because their `Children` property,
    which is set as the content, is a collection.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够这样做是因为 `Panel` 类在其类定义中通过 `ContentPropertyAttribute` 属性指定了 `Children` 属性。虽然
    `ContentControl` 的 `Content` 属性通常使我们能够添加单个内容项，但我们能够向面板中添加多个项，因为它们的 `Children`
    属性，即设置的内容，是一个集合。
- en: Another `Panel` class property that we might need to use is the `IsItemsHost`
    property, which specifies whether a panel is to be used as a container for the
    items of an `ItemsControl` element, or not. The default value is `false`, so it
    makes no sense to explicitly set this property to `false`. In fact, it is only
    ever required in a very particular situation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可能需要使用的 `Panel` 类属性是 `IsItemsHost` 属性，它指定一个面板是否用作 `ItemsControl` 元素或其派生类（如
    `ListBox`）的项目的容器。默认值是 `false`，因此显式将此属性设置为 `false` 没有意义。实际上，它只在非常特定的情况下才需要。
- en: 'That situation is when we are replacing the default panel of an `ItemsControl`,
    or one of its derived classes, such as a `ListBox`, in a `ControlTemplate`. By
    setting this property to `true` on a panel element in a `ControlTemplate`, we
    are telling WPF to place the generated collection elements in the panel. Let''s
    see a quick example of this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那种情况是我们正在替换 `ItemsControl` 的默认面板或其派生类（如 `ListBox`）的 `ControlTemplate`。通过在 `ControlTemplate`
    中的面板元素上设置此属性为 `true`，我们告诉 WPF 将生成的集合元素放置在面板中。让我们看看一个快速示例：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this simple example, we are replacing the default internal items panel of
    the `ItemsControl` element with a horizontal `StackPanel`. Note that this is a
    permanent replacement and no one can make further changes to this without providing
    a new `ControlTemplate`. There is however a far easier way to achieve the same
    result and we saw an example of this in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们正在用水平 `StackPanel` 替换 `ItemsControl` 元素的默认内部项目面板。请注意，这是一个永久性的替换，没有提供新的
    `ControlTemplate`，没有人可以进一步修改它。然而，有一种远更简单的方法可以达到相同的结果，我们已经在 [第 4 章](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml)，*精通数据绑定*
    中看到了这个例子：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this alternative example, we simply provide a new `ItemsPanelTemplate` for
    the `ItemsControl` through its `ItemsPanel` property. Using this code, the internal
    panel can still be easily changed without the need to provide a new `ControlTemplate`
    and so when we don't want other users to be able to swap out the inner panel,
    we use the first method, otherwise, we use this method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个替代示例中，我们只是通过 `ItemsPanel` 属性为 `ItemsControl` 提供一个新的 `ItemsPanelTemplate`。使用这段代码，内部面板仍然可以很容易地更改，而无需提供新的
    `ControlTemplate`，因此当我们不希望其他用户能够替换内部面板时，我们使用第一种方法，否则我们使用这种方法。
- en: The `Panel` class also declares a `ZIndex` Attached Property, which can be used
    by child elements to specify a layered order within the panel. Child elements
    with higher values will appear above, or in front of, elements with lower values,
    although this property is ignored in panels that do not overlap their children.
    We'll see an example of this in the next section, so let's now focus on the panels
    that derive from the `Panel` class and what they offer us.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Panel`类还声明了一个`ZIndex`附加属性，子元素可以使用它来指定面板内的分层顺序。具有较高值的子元素将出现在具有较低值的元素之上或前面，尽管在未重叠其子元素的面板中，此属性将被忽略。我们将在下一节中看到这个例子，所以现在让我们专注于从`Panel`类派生的面板以及它们为我们提供了什么。'
- en: Canvas
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布
- en: The `Canvas` class enables us to explicitly position child elements using combinations
    of the `Canvas.Top`, `Canvas.Left`, `Canvas.Bottom`, and `Canvas.Right` Attached
    Properties. This is vaguely similar to the old Windows Forms system of control
    placement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`类使我们能够使用`Canvas.Top`、`Canvas.Left`、`Canvas.Bottom`和`Canvas.Right`附加属性的组合来显式定位子元素。这与旧Windows
    Forms系统中控件放置的系统有些类似。'
- en: 'However, when using WPF, we don''t typically layout UI controls in a `Canvas`.
    Instead, we tend to use them more for displaying shapes, constructing graphs,
    showing animations, or drawing applications. Take the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用WPF时，我们通常不会在`Canvas`中布局UI控件。相反，我们更倾向于使用它们来显示形状、构建图表、显示动画或绘制应用程序。以下是一个例子：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This example demonstrates a number of important points, so let''s first see
    the visual output of this code before discussing it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了几个重要的点，所以在我们讨论它之前，让我们先看看这段代码的视觉输出：
- en: '![](img/148bd854-f1c2-43ad-b3e0-a4f4a759ddcc.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/148bd854-f1c2-43ad-b3e0-a4f4a759ddcc.png)'
- en: The top-left rectangle is the output from one canvas, and the top-right and
    bottom ones are from two other canvas instances. They are all contained within
    a parent canvas element with a black background. The three inner canvases are
    spaced to give the effect that they each have a border. They have been declared
    in the order of top-left, top-right, bottom, and the last element to be declared
    is, the middle circle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 左上角的矩形是一个画布的输出，右上角和下方的矩形来自另外两个画布实例。它们都包含在一个具有黑色背景的父画布元素中。三个内部画布被间隔开来，以产生每个画布都有边框的效果。它们按照从左上角、右上角、底部，到最后一个要声明的中间圆圈的顺序声明。
- en: The left circle is being drawn in the top-left canvas and we can see where it
    is overlapping the canvas' apparent bottom border, which shows that it is not
    being clipped by its parent canvas. However, it is being clipped by the lower
    canvas element and this demonstrates that UI elements that are declared later
    will be displayed over the top of earlier declared elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的圆正在左上角的画布中绘制，我们可以看到它与画布的明显底部边界的重叠部分，这表明它没有被其父画布裁剪。然而，它被下方的画布元素裁剪，这证明了后来声明的UI元素将显示在较早声明的元素之上。
- en: Nevertheless, the second canvas to be declared is clipping the middle circle,
    which was the last declared element. This demonstrates that setting the `Panel.ZIndex`
    property on an element to any positive number will position that element above
    all others that have not explicitly set this property. The default value for this
    property is zero, so an element that has this property set to `1` will be rendered
    on top of all elements that have not explicitly set a value for it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，第二个声明的画布正在裁剪最后一个声明的元素，即中间的圆圈。这证明了将元素的`Panel.ZIndex`属性设置为任何正数将使该元素位于所有未明确设置此属性的其他元素之上。此属性的默认值为零，因此将此属性设置为`1`的元素将渲染在所有未明确为其设置值的元素之上。
- en: The next element to be declared is the bottom rectangle and the right circle
    is declared within it. Now, as this element is declared after the top canvases,
    you might expect that the right circle would overlap the upper-right canvas. While
    this would normally be the case, this won't happen with our example for two reasons.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要声明的元素是底部的矩形，右边的圆被声明在其中。现在，由于这个元素是在顶部画布之后声明的，你可能预计右边的圆会与右上角的画布重叠。虽然这通常是情况，但我们的例子中不会发生这种情况，原因有两个。
- en: The first, as we've just found out, is because the upper-right panel has a higher
    `ZIndex` property value than the lower panel and the second reason is because
    we have set the `UIElement.ClipToBounds` property to `true`, which is used by
    the `Canvas` panel to determine whether it should clip the visual content of any
    children that may lie outside the bounds of the panel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因，正如我们刚刚发现的，是因为右上角面板的 `ZIndex` 属性值高于下面板，第二个原因是我们将 `UIElement.ClipToBounds`
    属性设置为 `true`，这是 `Canvas` 面板用来确定是否应该裁剪可能位于面板边界之外的任何子元素的视觉内容。
- en: This is commonly used with animations, to enable a visual to be hidden out of
    the panel bounds and then slid into view in reaction to some event. We can tell
    that the right circle has been clipped by its parent panel because we can see
    its apparent top border, which is outside its bounds.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常与动画一起使用，以便在某个事件发生时将视觉元素隐藏在面板边界之外，然后将其滑动到视图中。我们可以通过看到其明显的顶部边框，该边框在其边界之外，来判断右侧的圆圈已被其父面板裁剪。
- en: The last element to be declared is the middle circle and we can see that, apart
    from the overlapping canvas element with the higher `ZIndex` property value, it
    overlaps all of the other elements. Note that the `Canvas` panel does not perform
    any kind of resizing on its children, so it is not typically used for generating
    form type UI.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后声明的元素是中间的圆圈，我们可以看到，除了与具有更高 `ZIndex` 属性值的重叠画布元素外，它还与其他所有元素重叠。请注意，`Canvas` 面板不会对其子元素执行任何类型的调整大小操作，因此它通常不用于生成表单类型的
    UI。
- en: DockPanel
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DockPanel
- en: 'The `DockPanel` class is primarily used in the top levels of the control hierarchy
    to lay out the top-level controls. It provides us with the ability to dock controls
    to various parts of the screen, for example, a menu docked at the top, a context
    menu on the left, a status bar at the bottom and our main View content control
    in the remainder of the screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`DockPanel` 类主要用于控制层次结构的顶层，用于布局顶层控件。它为我们提供了将控件停靠到屏幕各个部分的能力，例如，停靠在顶部的菜单、左侧的上下文菜单、底部的状态栏以及屏幕剩余部分的主
    View 内容控件：'
- en: '![](img/fbf9e32a-b2b5-436c-b14b-db966f715504.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbf9e32a-b2b5-436c-b14b-db966f715504.png)'
- en: 'This layout shown in the preceding diagram can be easily achieved with just
    the following XAML:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个图中展示的布局可以通过以下 XAML 轻松实现：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We specify where we want each element within the panel to be docked using the
    `DockPanel.Dock` Attached Property. We can specify the left, right, top, and bottom
    of the panel. The remaining space is normally filled by the last child that does
    not explicitly set one of the `Dock` property. However, if that is not the behavior
    that we want, then we can set the `LastChildFill` property to `false`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `DockPanel.Dock` 附加属性指定面板内每个元素想要停靠的位置。我们可以指定面板的左、右、上和下边。剩余的空间通常由未显式设置 `Dock`
    属性的最后一个子元素填充。然而，如果我们不希望这种行为，则可以将 `LastChildFill` 属性设置为 `false`。
- en: The `DockPanel` will automatically resize itself to fit its content unless its
    dimensions are specified, either explicitly using the `Width` and `Height` properties,
    or implicitly by a parent panel. If it and its children both have dimensions specified
    for them, there is a chance that certain children will not be provided with enough
    space and not be displayed correctly, as the last child is the only child that
    can be resized by the `DockPanel`. It should also be noted that this panel does
    not overlap its child elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`DockPanel` 将会自动调整自身大小以适应其内容，除非其尺寸被指定，无论是通过显式使用 `Width` 和 `Height` 属性，还是通过父面板的隐式指定。如果它及其子元素都指定了尺寸，那么有可能某些子元素将不会获得足够的空间，并且无法正确显示，因为最后一个子元素是唯一可以被
    `DockPanel` 调整大小的。还应注意的是，此面板不会与其子元素重叠。'
- en: 'Also note that the order that the children are declared in will affect the
    space and position that they are each provided with. For example, if we wanted
    the menu bar to fill the top of the screen, the context menu to take the remaining
    left side, and the View and the status bar to take the remaining space, we could
    just declare the context menu before the status bar:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，子元素的声明顺序将影响它们各自获得的空间和位置。例如，如果我们想让菜单栏填充屏幕顶部，上下文菜单占据剩余的左侧，而 View 和状态栏占据剩余的空间，我们只需在状态栏之前声明上下文菜单：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This slight change would result in the following layout:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种轻微的改变将导致以下布局：
- en: '![](img/65d77aca-c368-4445-b302-cf68b18f9422.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65d77aca-c368-4445-b302-cf68b18f9422.png)'
- en: Grid
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grid
- en: The `Grid` panel is by far the most commonly used when it comes to laying out
    typical UI controls. It is the most versatile and enables us to perform a number
    of tricks to end up with the layout that we require. It offers a flexible row-
    and column-based layout system that we can use to build UIs with a fluid layout.
    Fluid layouts are able to react and change size when users resize their application
    windows.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到布局典型的UI控件时，`网格`面板是最常用的。它是功能最全面的，使我们能够执行一些技巧，以获得所需的布局。它提供了一个灵活的基于行和列的布局系统，我们可以用它来构建具有流动布局的UI。流动布局能够响应用户调整应用程序窗口大小并改变大小。
- en: The `Grid` is one of the few panels that can resize all of its child elements
    depending on the space available, which makes it one of the most performance-intensive
    panels. Therefore, if we don't need the functionality that it provides, we should
    use a more performant panel, such as a `Canvas` or `StackPanel`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`网格`是少数几个可以根据可用空间调整所有子元素大小的面板之一，这使得它成为性能最密集的面板之一。因此，如果我们不需要它提供的功能，我们应该使用性能更好的面板，例如`画布`或`堆叠面板`。'
- en: The children of a `Grid` panel can each set their `Margin` property to be laid
    out using absolute coordinates, in a similar fashion to the `Canvas` panel. However,
    this should be avoided wherever possible, because that will break the fluidity
    of our UI. Instead, we typically define our desired layout using the grid's `RowDefinitions`
    and `ColumnDefinitions` collections and the `Grid.Row` and `Grid.Column` Attached
    Properties.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`网格`面板的子元素可以分别设置它们的`边距`属性，使用绝对坐标进行布局，这与`画布`面板类似。然而，应尽可能避免这样做，因为这会破坏我们UI的流畅性。相反，我们通常使用网格的`行定义`和`列定义`集合以及`Grid.Row`和`Grid.Column`附加属性来定义我们想要的布局。'
- en: While we can again hard code exact widths and heights for our rows and columns,
    we usually try to avoid doing so for the same reason. Instead, we generally take
    advantage of the grid's sizing behavior and declare our rows and columns, predominantly
    using one of two values.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以再次为我们的行和列硬编码确切的宽度和高度，但我们通常尽量避免这样做，原因相同。相反，我们通常利用网格的尺寸行为，并声明我们的行和列，主要使用两个值之一。
- en: The first is the `Auto` value, which takes its size from its content and the
    second is the default `*` star-sized value, which takes all of the remaining space.
    Typically, we set all columns or rows to `Auto` except the one(s) that contain(s)
    the most important data, which is/are set to `*`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`自动`值，它从其内容获取大小；第二个是默认的`*`星号大小值，它获取所有剩余的空间。通常，我们将所有列或行设置为`自动`，除了包含最重要数据的列或行，这些列或行被设置为`*`。
- en: 'Note that if we have more than one star-sized column, then the space is normally
    divided equally between them. However, if we need unequal divisions of the remaining
    space, then we can specify a multiplier number with the asterisk, which will multiply
    the proportion of space that that row or column will be provided with. Let''s
    see an example to help to clarify this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们有多个星号大小的列，那么空间通常在它们之间平均分配。然而，如果我们需要剩余空间的非均等分配，我们可以使用星号指定一个乘数数字，这将乘以该行或列将获得的空间比例。让我们通过一个例子来澄清这一点：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example demonstrates a number of points, so let''s see the rendered output
    before continuing:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了几个要点，所以在我们继续之前，让我们看看渲染的输出：
- en: '![](img/f16dcf8f-ac1f-47ae-bcf6-3995e5ee2e35.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f16dcf8f-ac1f-47ae-bcf6-3995e5ee2e35.png)'
- en: Here, we have a very basic confirmation dialog control. It is formed with a
    `Grid` panel with three columns and two rows. Note that a single star-sizing is
    used as the default width and height values for the `ColumnDefinition` and `RowDefinition`
    elements respectively; we do not need to explicitly set them and can simply declare
    empty elements. Also note that star-sizing will only work when the `Grid` panel
    has some size set on it, as we have done here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个非常基本的确认对话框控件。它由一个有三个列和两个行的`网格`面板组成。请注意，单个星号大小被用作`列定义`和`行定义`元素的默认宽度和高度值；我们不需要明确设置它们，只需声明空元素即可。同时请注意，星号大小仅在`网格`面板设置了某些大小的情况下才会工作，就像我们在这里所做的那样。
- en: Therefore, in our example, the second and third columns and the first row will
    use star-sizing and take all of the remaining space. The first column also uses
    star-sizing, however, it specifies a multiplier value of `2.5`. As such, it will
    be provided with two and a half times the amount of space that the other two columns
    will each have.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的例子中，第二列和第三列以及第一行将使用星号大小调整，并占用所有剩余的空间。第一列也使用星号大小调整，但是它指定了一个乘数值为`2.5`。因此，它将获得其他两列各自空间的两倍半。
- en: Note that this first column is only used to push the buttons in the other two
    columns to the correct position. While the `TextBlock` element is declared in
    the first column, it does not only reside in that column, because it has also
    specified the `Grid.ColumnSpan` Attached Property, which allows it to spread out
    across multiple columns. The `Grid.RowSpan` Attached Property does the same for
    rows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个第一列仅用于将其他两列中的按钮推到正确的位置。虽然`TextBlock`元素在第一列中声明，但它不仅位于该列，因为它还指定了`Grid.ColumnSpan`附加属性，这允许它扩展到多个列。`Grid.RowSpan`附加属性对行做同样的处理。
- en: The `Grid.Row` and `Grid.Column` Attached Properties are used by each element
    to specify which cell they should be rendered in. However, the default value for
    these properties is zero and so, when we want to declare an element within the
    first column or row of the panel, we can omit the setting of these properties,
    as has been done for the `TextBlock` in our example.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid.Row`和`Grid.Column`附加属性由每个元素用来指定它们应该渲染在哪个单元格中。然而，这些属性的默认值是零，所以当我们想在面板的第一列或第一行中声明一个元素时，我们可以省略这些属性的设置，就像我们例子中的`TextBlock`所做的那样。'
- en: The OK button has been declared in the second row and column and sets the `IsDefault` key
    to `true`, which enables users to invoke it by pressing the *Enter* key on their
    keyboards. It is also responsible for the blue border on the button and we can
    use this property to style the default button differently in our own templates. The Cancel button
    sits next to it in the third column and sets the `IsCancel` property to `true`,
    which enables the users to select it by pressing the *Esc* key on their keyboards.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “确定”按钮被声明在第二行和第二列，并将`IsDefault`键设置为`true`，这使用户可以通过按键盘上的*Enter*键来调用它。它还负责按钮上的蓝色边框，我们可以使用这个属性在我们自己的模板中为默认按钮设置不同的样式。“取消”按钮位于其旁边，在第三列，并将`IsCancel`属性设置为`true`，这使用户可以通过按键盘上的*Esc*键来选择它。
- en: Note that we could have set the lower `RowDefinition.Height` property to `26`
    instead of setting that on each button explicitly and the end result would have
    been the same, as the `Auto` value would be calculated from their height anyway.
    Also, note that the `Margin` property has been set on a few elements here for
    spacing purposes only, rather than for absolute positioning purposes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们本可以将`RowDefinition.Height`的较低属性设置为`26`，而不是在每个按钮上显式设置，最终结果将是相同的，因为`Auto`值无论如何都会从它们的高度计算得出。另外，请注意，这里的`Margin`属性已经设置在一些元素上，仅用于间距目的，而不是用于绝对定位目的。
- en: 'There are two other useful properties declared by the `Grid` class. The first
    is the `ShowGridLines` property, which as you can imagine, shows the borders of
    the rows and columns in the panel when set to `true`. While not really required
    for simple layouts as in the previous example, this can be useful while developing
    more complicated layouts. However, due to its poor performance, this feature should
    never be utilized in production XAML:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`类还声明了两个其他有用的属性。第一个是`ShowGridLines`属性，正如你可以想象的那样，当设置为`true`时，它会在面板中显示行和列的边框。虽然对于像上一个例子中的简单布局来说这不是必需的，但在开发更复杂的布局时这可能很有用。然而，由于其性能较差，这个功能永远不应该在生产XAML中使用：'
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s see what this looks like with visible grid lines now:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看有了可见的网格线后是什么样子：
- en: '![](img/d94f6a2d-482e-4cbe-94c1-4fc62ba50a95.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d94f6a2d-482e-4cbe-94c1-4fc62ba50a95.png)'
- en: The other useful property is the `IsSharedSizeScope` Attached Property, which
    enables us to share sizing information between two or more `Grid` panels. We can
    achieve this by setting this property to `true` on a parent panel and then specifying
    the `SharedSizeGroup` property on the relevant `ColumnDefinition` and/or `RowDefinition`
    elements of the inner `Grid` panels.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的属性是`IsSharedSizeScope`附加属性，它使我们能够在两个或多个`Grid`面板之间共享大小信息。我们可以通过在父面板上设置此属性为`true`，然后在内部`Grid`面板的相关`ColumnDefinition`和/或`RowDefinition`元素上指定`SharedSizeGroup`属性来实现这一点。
- en: There are a few conditions that we need to adhere to in order to get this to
    work and the first relates to scope. The `IsSharedSizeScope` property needs to
    be set on a parent element, but if that parent element is within a resource template
    and the definition elements that specify the `SharedSizeGroup` property are outside
    that template then it will not work. It will, however, work in the opposite direction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个功能正常工作，我们需要遵守几个条件，第一个与作用域相关。`IsSharedSizeScope`属性需要在父元素上设置，但如果该父元素在资源模板内，而指定`SharedSizeGroup`属性的元素定义在模板外，则它将不起作用。然而，在相反方向上它是有效的。
- en: 'The other point to be aware of is that star-sizing is not respected when sharing
    sizing information. In these cases, the star values of any definition elements
    will be read as `Auto`, so we do not typically set the `SharedSizeGroup` property
    on our star-sized column. However, if we set it on the other columns, then we
    will be left with our desired layout. Let''s see an example of this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意是，在共享大小信息时，星号大小不被尊重。在这些情况下，任何定义元素的星号值将被读取为`Auto`，所以我们通常不会在我们的星号大小列上设置`SharedSizeGroup`属性。然而，如果我们将其设置在其他列上，那么我们将得到我们想要的布局。让我们看看这个例子：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we have an `ItemsControl` that is data bound to a slightly
    edited version of our `Users` collection from our earlier examples. Previously,
    all of the user names were of a similar length, so one has been edited to demonstrate
    this point more clearly. The `ShowGridLines` property has also been set to `true`
    on the inner panels for the same reason.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个`ItemsControl`，它绑定到我们之前例子中`Users`集合的一个稍微编辑过的版本。之前，所有用户名长度相似，所以其中一个已经被编辑，以更清楚地说明这一点。出于同样的原因，`ShowGridLines`属性也已在内部面板上设置为`true`。
- en: 'In the example, we first set the `IsSharedSizeScope` Attached Property to `true`
    on the parent `Grid` panel and then apply the `SharedSizeGroup` property to the
    definitions of the inner `Grid` controls, which are declared inside the outer
    panel and within the `DataTemplate` element. Let''s see the rendered output of
    this code before continuing:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先在父`Grid`面板上设置`IsSharedSizeScope`附加属性为`true`，然后应用内部`Grid`控件的定义的`SharedSizeGroup`属性，这些控件在外部面板内声明，并在`DataTemplate`元素内。在继续之前，让我们看看这段代码的渲染输出：
- en: '![](img/677c3f7e-4a2b-4ee1-9b0b-3552f222bb37.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/677c3f7e-4a2b-4ee1-9b0b-3552f222bb37.png)'
- en: Note that we have provided the same number of columns and group names for the
    columns inside and outside of the `DataTemplate` element, which is essential for
    this functionality to work. Also note that we have not set the `SharedSizeGroup`
    property on the middle column, which is star-sized.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`DataTemplate`元素内部和外部都提供了相同数量的列和组名，这对于此功能正常工作至关重要。另外，请注意，我们没有在中间列上设置`SharedSizeGroup`属性，该属性是星号大小的。
- en: 'Grouping just the other two columns will have the same visual effect as grouping
    all three, but without losing the star-sizing on the middle column. However, let''s
    see what would happen if we also set the `SharedSizeGroup` property on the middle
    column definitions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 仅对其他两个列进行分组将产生与对三个列进行分组相同的视觉效果，但不会失去中间列的星号大小。然而，让我们看看如果我们也在中间列的定义上设置`SharedSizeGroup`属性会发生什么：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As expected, we have lost the star-sizing on our middle column and the remaining
    space has now been applied to the last column:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们的中间列已经失去了星号大小，现在剩余的空间已经应用到最后一列：
- en: '![](img/298fd5a8-a489-4fbd-b0bb-0d200dc2a841.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/298fd5a8-a489-4fbd-b0bb-0d200dc2a841.png)'
- en: The `Grid` panel within the template will be rendered for each item in the collection
    and so this will actually result in several panels, each with the same group names
    and therefore, also column spacing. It is important that we set the `IsSharedSizeScope`
    property to `true` on the `Grid` panel that is the common parent to all of the
    inner panels that we wish to share sizing information between.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模板内的`Grid`面板将为集合中的每个项目进行渲染，因此这实际上将导致几个面板，每个面板都有相同的组名，因此也有相同的列间距。我们非常重要的一点是，我们需要在所有内部面板的共同父元素`Grid`面板上设置`IsSharedSizeScope`属性为`true`，这些内部面板之间需要共享大小信息。
- en: StackPanel
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StackPanel
- en: 'The `StackPanel` is one of the WPF panels that only provides limited resizing
    abilities to its child items. It will automatically set the `HorizontalAlignment`
    and `VerticalAlignment` properties of each of its children to `Stretch`, as long
    as they don''t have explicit sizes specified. In these cases alone, the child
    elements will be stretched to fit the size of the containing panel. This can be
    easily demonstrated as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackPanel` 是 WPF 控件中仅对其子项提供有限调整大小能力的面板之一。只要它们没有指定明确的大小，它将自动将每个子项的 `HorizontalAlignment`
    和 `VerticalAlignment` 属性设置为 `Stretch`。在这种情况下，子元素将被拉伸以适应包含面板的大小。这可以通过以下方式轻松演示：'
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This panel literally lays each child element out one after the other, vertically
    by default, or horizontally when its `Orientation` property is set to `Horizontal`.
    Our example uses both orientations, so let''s take a quick look at its output
    before continuing:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板实际上将每个子元素依次排列，默认为垂直，当其 `Orientation` 属性设置为 `Horizontal` 时则为水平。我们的示例使用了这两种方向，因此在我们继续之前，让我们快速看一下其输出：
- en: '![](img/512a4b8a-dba9-4cd1-8768-ffd0c4515acd.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/512a4b8a-dba9-4cd1-8768-ffd0c4515acd.png)'
- en: Our whole example is wrapped in a `Border` element with a black background.
    In its `Resources` section, we declared a few style properties for the `TextBlock`
    elements in our example. Inside the border, we declare our first `StackPanel`
    control, with its default vertical orientation. In this first panel, we have three
    `TextBlock` elements and another `StackPanel` wrapped in a border.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整个示例被一个具有黑色背景的 `Border` 元素包裹。在其 `Resources` 部分中，我们为示例中的 `TextBlock` 元素声明了一些样式属性。在边框内部，我们声明了我们的第一个
    `StackPanel` 控件，其默认垂直方向。在这个第一个面板中，我们有三个 `TextBlock` 元素和另一个包裹在边框中的 `StackPanel`。
- en: The first `TextBlock` element is automatically stretched to fit the width of
    the panel. The second adds a margin, but would otherwise also be stretched across
    the width of the panel. The third, however, has its `HorizontalAlignment` property
    explicitly set to `Center` and so it is not stretched to fit by the panel.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `TextBlock` 元素会自动拉伸以适应面板的宽度。第二个添加了边距，但否则也会拉伸以适应面板的宽度。然而，第三个的 `HorizontalAlignment`
    属性被显式设置为 `Center`，因此它不会被面板拉伸以适应。
- en: The inner panel has three `TextBlock` elements declared inside it and has its
    `Orientation` property set to `Horizontal`. Its children are therefore laid out
    horizontally. Its border is colored, so that it is easier to see its bounds. Note
    the use of the `SnapsToDevicePixels` property set on it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 内部面板在其内部声明了三个 `TextBlock` 元素，并将其 `Orientation` 属性设置为 `Horizontal`。因此，其子项是水平排列的。它的边框被着色，这样更容易看到其边界。注意它上面设置的
    `SnapsToDevicePixels` 属性。
- en: As WPF uses device-independent pixel settings, thin straight lines can sometimes
    lie across individual pixel boundaries and appear anti-aliased. Setting this property
    to `true` will force the element to be rendered exactly in line with the physical
    pixels, using device-specific pixel settings and forming a clearer, sharper line.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WPF 使用设备无关的像素设置，细直线有时会跨越单个像素边界并呈现抗锯齿效果。将此属性设置为 `true` 将强制元素使用设备特定的像素设置精确渲染，从而形成更清晰、更锐利的线条。
- en: The first `TextBlock` element in the lower panel is automatically stretched
    to fit the height of the panel. As with the elements in the upper panel, the second
    adds a margin, but would otherwise also be stretched across the height of the
    panel. The third, however, has its `VerticalAlignment` property explicitly set
    to `Center` and so it is not stretched vertically to fit by the panel.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面板中的第一个 `TextBlock` 元素会自动拉伸以适应面板的高度。与上面板中的元素一样，第二个添加了边距，但否则也会拉伸以适应面板的高度。然而，第三个的
    `VerticalAlignment` 属性被显式设置为 `Center`，因此它不会被面板垂直拉伸以适应。
- en: As a side note, we have used the hexadecimal entity to add a new line in some
    of our text strings. This could also have been achieved using the `TextBlock.TextWrapping`
    property and hard coding a `Width` for each element, but this way is obviously
    far simpler.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们在一些文本字符串中使用了十六进制实体来添加换行。这也可以通过使用 `TextBlock.TextWrapping` 属性并为每个元素硬编码一个
    `Width` 来实现，但显然这种方法更简单。
- en: UniformGrid
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UniformGrid
- en: The `UniformGrid` panel is a lightweight panel that provides a simple way to
    create a grid of items, where each item is of the same size. We can set its `Row`
    and `Column` properties to specify how many rows and columns we want our grid
    to have. If we do not set one or both of these properties, the panel will implicitly
    set them for us, depending upon the available space it has and the size of its
    children.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`UniformGrid` 面板是一个轻量级面板，提供了一种简单的方式来创建一个项目网格，其中每个项目的大小相同。我们可以设置其 `Row` 和 `Column`
    属性来指定我们想要网格有多少行和列。如果我们没有设置一个或两个这些属性，面板将隐式地为我们设置它们，这取决于它拥有的可用空间及其子项的大小。'
- en: 'It also provides us with a `FirstColumn` property that will affect the column
    that the first child item will be rendered in. For example, if we set this property
    to `2` then the first child will be rendered in the third column. This is perfect
    for a calendar control, so let''s take a look at how we might create the following
    output using the `UniformGrid`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了一个 `FirstColumn` 属性，这将影响第一个子项将被渲染的列。例如，如果我们设置此属性为 `2`，则第一个子项将在第三列中渲染。这对于日历控件来说非常完美，所以让我们看看我们如何使用
    `UniformGrid` 创建以下输出：
- en: '![](img/b28f00fa-c5ca-42b4-8dce-38c6edd9f46c.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b28f00fa-c5ca-42b4-8dce-38c6edd9f46c.png)'
- en: 'As you can see, a calendar control often needs to have blank spaces in the
    first few columns and so the `FirstColumn` property achieves this requirement
    simply. Let''s see the XAML that defines this calendar example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，日历控件通常需要在前面几列留出空白空间，因此 `FirstColumn` 属性简单地实现了这一需求。让我们看看定义此日历示例的 XAML：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We start with a `StackPanel` that is used to stack one `UniformGrid` panel directly
    above an `ItemsControl` that uses another one as its `ItemsPanel` and specifies
    a font size to use within the control. The top `UniformGrid` panel declares a
    single row of seven columns and some basic `TextBlock` styles. It has seven child
    `TextBlock` items that output the names of the days in a week.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个 `StackPanel` 开始，它用于将一个 `UniformGrid` 面板直接堆叠在一个使用另一个 `UniformGrid` 作为其
    `ItemsPanel` 的 `ItemsControl` 之上，并指定在控件内使用的字体大小。顶部的 `UniformGrid` 面板声明了一个包含七个列的单行，以及一些基本的
    `TextBlock` 样式。它有七个子 `TextBlock` 项目，输出一周中每一天的名称。
- en: 'The `ItemsControl` element has its `Background` property set to `Black` to
    black out days not in the current month, and its `Padding` set to make the background
    appear like a border to the right and bottom of the calendar. The top and left
    borders come from the individual cells in the `UniformGrid` panel. The `ItemsControl.ItemsSource` property
    is data bound to a `Days` property in our View Model, so let''s take a look at
    that now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsControl` 元素的 `Background` 属性被设置为 `Black` 以遮蔽当前月份之外的天，并且 `Padding` 被设置为使背景看起来像日历的右下角边框。顶部和左边的边框来自
    `UniformGrid` 面板中的单个单元格。`ItemsControl.ItemsSource` 属性绑定到我们的视图模型中的 `Days` 属性，所以现在让我们看看它：'
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the use of the `Enumerable.Range` method to populate the collection. It
    provides a simple way to generate a contiguous sequence of integers from the supplied
    start and length input parameters. As a LINQ method, it is implemented using deferred
    execution and the actual values are not generated until actually accessed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `Enumerable.Range` 方法来填充集合。它提供了一个简单的方法来生成从提供的起始和长度输入参数开始的连续整数序列。作为一个 LINQ
    方法，它是通过延迟执行实现的，实际值只有在实际访问时才会生成。
- en: The second `UniformGrid` panel, which is set as the `ItemsControl.ItemsPanel`,
    only specifies that it should have seven columns, but leaves the number of rows
    to be calculated from the number of data bound items. Note also that we have hard
    coded a value of `2` to the `FirstColumn` property, although in a proper control,
    we would typically data bind the value for the relevant month to it instead.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `UniformGrid` 面板被设置为 `ItemsControl.ItemsPanel`，它只指定应该有七列，但将行数留待从数据绑定的项目数量计算得出。注意，我们已将
    `FirstColumn` 属性的值硬编码为 `2`，虽然在合适的控件中，我们通常会将其相关月份的值数据绑定到它。
- en: Finally, we use a `DataTemplate` to define what each day on the calendar should
    look like. Note that we do not need to specify a value for its `DataType` property
    in this example, because we are data binding to the whole data source object,
    which in this case is just an integer. Let's now move on to investigate the `WrapPanel`
    panel.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `DataTemplate` 来定义日历上每一天的外观。请注意，在这个例子中，我们不需要为其 `DataType` 属性指定值，因为我们正在将整个数据源对象进行数据绑定，在这个例子中它只是一个整数。现在让我们继续研究
    `WrapPanel` 面板。
- en: WrapPanel
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WrapPanel
- en: The `WrapPanel` panel is similar to `StackPanel`, except that it will stack
    its children in both directions by default. It starts by laying out the child
    items horizontally and when it runs out of space on the first row, it automatically
    wraps the next item onto a new row and continues to lay out the remaining controls.
    It repeats this process using as many rows as are required, until all of the items
    are rendered.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`WrapPanel`面板类似于`StackPanel`，但默认情况下它会在两个方向上堆叠其子项。它首先水平排列子项，当第一行空间不足时，它会自动将下一个项目换行到新行，并继续排列剩余控件。它使用所需行数重复此过程，直到所有项目都被渲染。'
- en: However, it also provides an `Orientation` property like `StackPanel`, and this
    will affect its layout behavior. If the `Orientation` property is changed from
    the default value of `Horizontal` to `Vertical`, then the panel's child items
    will be laid out vertically, from top to bottom until there is no more room in
    the first column. The items will then wrap to the next column and will continue
    in this way until all of the items have been rendered.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也提供了一个类似于`StackPanel`的`Orientation`属性，这将影响其布局行为。如果将`Orientation`属性从默认值`Horizontal`更改为`Vertical`，则面板的子项将垂直排列，从上到下直到第一列没有更多空间。项目将换行到下一列，并继续这种方式，直到所有项目都被渲染。
- en: 'This panel also declares `ItemHeight` and `ItemWidth` properties that enable
    it to restrict items'' dimensions and to produce a layout behavior similar to
    the `UniformGrid` panel. Note that the values will not actually resize each child
    item, but merely restrict the available space that they are provided with in the
    panel. Let''s see an example of this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板还声明了`ItemHeight`和`ItemWidth`属性，使其能够限制项目的尺寸并产生类似于`UniformGrid`面板的布局行为。请注意，这些值实际上不会调整每个子项的大小，而只是限制它们在面板中提供的可用空间。让我们看看这个示例：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that while similar to the output of a `UniformGrid` panel, the output
    of this example could not actually be achieved with that panel, because one of
    the child items is a different size to the others. Let''s see the visual output
    of this example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然与`UniformGrid`面板的输出类似，但这个示例实际上不能使用该面板实现，因为其中一个子项的大小与其他不同。让我们看看这个示例的视觉输出：
- en: '![](img/06ed28c9-6ec6-4af6-bf07-b1c918a2d724.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![示例图片](img/06ed28c9-6ec6-4af6-bf07-b1c918a2d724.png)'
- en: We first declare the `WrapPanel` and specify that each child should only be
    provided with a height of `50` pixels, while the panel itself should be `150`
    pixels wide. In the `Resources` section, we set the width of each button to be
    `50` pixels wide, therefore enabling three buttons to sit next to each other on
    each row, before wrapping items to the next row.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明了`WrapPanel`并指定每个子项应仅提供`50`像素的高度，而面板本身应宽`150`像素。在`Resources`部分，我们设置每个按钮的宽度为`50`像素，因此使得每个行上的三个按钮可以并排放置，在项目换行到下一行之前。
- en: Next, we simply define the eleven buttons that make up the panel's children,
    specifying that the zero button should be twice as wide as the others. Note that
    this would not have worked if we had set the `ItemWidth` property to `50` pixels,
    along with the `ItemHeight` property. In that case, we would have seen half of
    the zero button, with the other half covered by the period button and a blank
    space where the period button currently is.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简单地定义了组成面板子项的十一个按钮，指定零按钮的宽度是其他按钮的两倍。请注意，如果我们设置了`ItemWidth`属性为`50`像素，以及`ItemHeight`属性，这将不会起作用。在这种情况下，我们会看到零按钮的一半，另一半被点号按钮覆盖，并且点号按钮当前所在的位置是一个空白空间。
- en: Providing custom layout behavior
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供自定义布局行为
- en: When the layout behavior of the built-in panels do not meet our requirements,
    we can easily define a new panel with custom layout behavior. All we need to do
    is to declare a class that extends the `Panel` class and to override its `MeasureOverride`
    and `ArrangeOverride` methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当内置面板的布局行为不符合我们的要求时，我们可以轻松地定义一个新的具有自定义布局行为的面板。我们只需要声明一个扩展`Panel`类的类，并重写其`MeasureOverride`和`ArrangeOverride`方法。
- en: In the `MeasureOverride` method, we simply call the `Measure` method on each
    child item from the `Children` collection, passing in a `Size` element set to
    `double.PositiveInfinity`. This is equivalent to saying "set your `DesriredSize`
    property as if you had all of the space that you could possibly need" to each
    child item.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MeasureOverride`方法中，我们简单地调用`Children`集合中每个子项的`Measure`方法，传递一个设置为`double.PositiveInfinity`的`Size`元素。这相当于对每个子项说“将你的`DesriredSize`属性设置为如果你有所有可能需要的空间”。
- en: 'In the `ArrangeOverride` method, we use the newly determined `DesriredSize`
    property value of each child item to calculate its required position and call
    its `Arrange` method to render it in that position. Let''s look at an example
    of a custom panel that positions its items equally around the circumference of
    a circle:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ArrangeOverride`方法中，我们使用每个子项新确定的`DesiredSize`属性值来计算其所需的位置，并调用其`Arrange`方法在该位置渲染它。让我们看看一个自定义面板的例子，该面板将其项均匀地放置在圆的周长上：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In our `CircumferencePanel` class, we first declare our own `Padding` property
    of type `Thickness`, which will be used to enable the users of the panel to lengthen
    or shorten the radius of the circle and therefore, adjust the position of the
    rendered items within the panel. The `MeasureOverride` method is a simple affair,
    as previously explained.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`CircumferencePanel`类中，我们首先声明我们自己的`Padding`属性，其类型为`Thickness`，这将用于使用户能够延长或缩短圆的半径，从而调整面板内渲染项的位置。`MeasureOverride`方法如前所述很简单。
- en: In the `ArrangeOverride` method, we calculate the relevant angles to position
    the child items with, depending upon how many of them there are. We take the value
    of our `Padding` property into consideration when calculating the *X* and *Y*
    radiuses, so that users of our custom panel will be better able to control the
    position of the rendered items.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ArrangeOverride`方法中，我们根据子项的数量计算定位子项的相关角度。在计算*X*和*Y*半径时，我们考虑了我们的`Padding`属性值，这样我们的自定义面板的用户将能够更好地控制渲染项的位置。
- en: For each child item in the panel's `Children` collection, we first calculate
    the point on the circle where it should be displayed. We then offset that value
    using the value of the element's `DesiredSize` property, so that the bounding
    box of each item is centered on that point.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面板的`Children`集合中的每个子项，我们首先计算它应该显示在圆上的点。然后，我们使用元素的`DesiredSize`属性值偏移该值，这样每个项的边界框就位于该点上。
- en: 'We then create the element''s bounding box using a `Rect` element, with the
    offset point and the element''s `DesiredSize` property, and pass that to its `Arrange`
    method to render it. After each element is rendered, the current angle is changed
    for the next item. Remember that we can utilize this panel by adding a XAML namespace
    for the `Panels` CLR namespace and setting the `ItemsPanel` property of an `ItemsControl`
    or one of its derived classes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个`Rect`元素创建元素的边界框，包含偏移点和元素的`DesiredSize`属性，并将其传递给其`Arrange`方法以渲染它。每个元素渲染后，当前角度会改变以定位下一个项。记住，我们可以通过为`Panels`
    CLR命名空间添加一个XAML命名空间并设置`ItemsControl`或其派生类的`ItemsPanel`属性来利用这个面板：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Given some suitable data, we could use this panel to display the numbers on
    a clock control, for example. Let''s see the `Hours` property that the `ItemsSource`
    property of our example `ItemsControl` is data bound to:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一些合适的数据，我们可以使用这个面板在时钟控件上显示数字，例如。让我们看看我们的示例`ItemsControl`的`ItemsSource`属性绑定到的`Hours`属性：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As the hour numerals must start with 12 and then go back to 1, we declare the
    collection with the 12 element initially. At some later stage, possibly during
    construction, we then add the remaining numbers to the collection and this is
    what it looks like when using our new panel:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于小时数字必须从12开始然后回到1，我们最初声明包含12个元素的集合。在某个后续阶段，可能在构造期间，我们然后向集合中添加剩余的数字，这就是使用我们新面板时的样子：
- en: '![](img/a2731651-1436-4647-b644-24033721c070.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2731651-1436-4647-b644-24033721c070.png)'
- en: This concludes our coverage of the main panels that are available in WPF. While
    we don't have the space to have an in-depth look at every other WPF control, we'll
    find tips and tricks for a number of them throughout this book. Instead, let's
    now focus on a few essential controls and what they can do for us.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对WPF中可用的主要面板的介绍。虽然我们没有足够的空间深入探讨每个其他WPF控件，但在这本书中，我们将找到许多控件的小技巧和技巧。相反，现在让我们集中精力在几个基本控件上，以及它们能为我们做什么。
- en: Content controls
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容控件
- en: While this control is not often used directly, one use for it is to render a
    single data item according to a particular template. In fact, we often use a `ContentControl`
    to display our View Models and use a `DataTemplate` object that renders the associated
    View. Alternatively, we might use some form of `ItemsControl` to display a group
    of items and a `ContentControl` to display the selected item.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个控件不常直接使用，但其一个用途是根据特定模板渲染单个数据项。实际上，我们经常使用`ContentControl`来显示我们的视图模型，并使用一个渲染相关视图的`DataTemplate`对象。或者，我们可能使用某种形式的`ItemsControl`来显示一组项目，并使用`ContentControl`来显示所选项目。
- en: 'As we found out earlier, when looking at the inheritance hierarchy of the `Button`
    control, the `ContentControl` class extends the `Control` class and adds the ability
    for derived classes to contain any single CLR object. Note that if we need to
    specify more than a single object of content, we can use a single panel object
    that contains further objects:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在查看`Button`控件继承层次结构时发现的，`ContentControl`类扩展了`Control`类，并增加了派生类包含任何单个CLR对象的能力。请注意，如果我们需要指定多个内容对象，我们可以使用包含更多对象的单个面板对象：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/238a62c4-8115-4466-b502-e4d5c6066fb6.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/238a62c4-8115-4466-b502-e4d5c6066fb6.png)'
- en: We can specify this content through the use of the `Content` property. However,
    the `ContentControl` class specifies the `Content` property in a `ContentPropertyAttribute`
    attribute in its class definition and this enables us to set the content by simply
    declaring the child element directly within the control in the XAML. This attribute
    is used by the XAML processor when it processes XAML child elements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Content`属性来指定此内容。然而，`ContentControl`类在其类定义中通过`ContentPropertyAttribute`属性指定了`Content`属性，这使得我们能够通过在XAML中直接声明控件内的子元素来设置内容。此属性由XAML处理器在处理XAML子元素时使用。
- en: If the content is of type `string`, then we can use the `ContentStringFormat`
    property to specify a particular format for it. Otherwise, we can use the `ContentTemplate`
    property to specify a `DataTemplate` to use while rendering the content. Alternatively,
    the `ContentTemplateSelector` property is of type `DataTemplateSelector` and also
    enables us to select a `DataTemplate`, but based upon some custom condition that
    we may have. All derived classes have access to these properties in order to shape
    the output of their content.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内容是`string`类型，则我们可以使用`ContentStringFormat`属性来指定其特定格式。否则，我们可以使用`ContentTemplate`属性来指定在渲染内容时使用的`DataTemplate`。或者，`ContentTemplateSelector`属性是`DataTemplateSelector`类型，也使我们能够根据某些自定义条件选择`DataTemplate`。所有派生类都可以访问这些属性以塑造其内容的输出。
- en: However, this control is also able to display many primitive types without us
    having to specify a custom template. Let's move on to the next section now, where
    we'll find out exactly how it manages to accomplish this.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个控件也能够显示许多原始类型，而无需我们指定自定义模板。现在让我们继续到下一节，我们将了解它如何实现这一点。
- en: Presenting content
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示内容
- en: In WPF, there is a special element that is essential but often little understood.
    The `ContentPresenter` class basically presents content, as its name suggests.
    It is actually used internally within `ContentControl` objects to present their
    content.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，有一个特殊元素是基本但往往理解不深的。`ContentPresenter`类基本上展示内容，正如其名称所暗示的。它实际上在`ContentControl`对象内部使用来展示其内容。
- en: That is its sole job and it should not be used for other purposes. The only
    time that we should declare these elements is within a `ControlTemplate` of a
    `ContentControl` element or one of its many derived classes. In these cases, we
    declare them where we want the actual content to appear.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的唯一任务，它不应该用于其他目的。我们唯一应该声明这些元素的时间是在`ContentControl`元素或其许多派生类的`ControlTemplate`中。在这些情况下，我们在实际内容出现的位置声明它们。
- en: 'Note that specifying the `TargetType` property on a `ControlTemplate` when
    using a `ContentPresenter` will result in its `Content` property being implicitly
    data bound to the `Content` property of the relevant `ContentControl` element.
    We are however free to data bind it explicitly to whatever we like:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用`ContentPresenter`时，在`ControlTemplate`上指定`TargetType`属性将导致其`Content`属性隐式地数据绑定到相关`ContentControl`元素的`Content`属性。然而，我们可以自由地将其显式地数据绑定到我们想要的任何内容：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ContentTemplate` and `ContentTemplateSelector` properties both mirror those
    of the `ContentControl` class and also enable us to select a `DataTemplate` based
    upon a custom condition. Like the `Content` property, both of these properties
    will also be implicitly data bound to the properties of the same names in the
    templated parent if the `TargetType` property of the `ControlTemplate` has been
    set.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentTemplate`和`ContentTemplateSelector`属性都与`ContentControl`类相同，并且也允许我们根据自定义条件选择`DataTemplate`。像`Content`属性一样，如果`ControlTemplate`的`TargetType`属性已设置，这两个属性也将隐式地绑定到模板父级中同名属性。'
- en: This usually saves us from having to explicitly data bind these properties,
    although there are a few controls where the names of the relevant properties do
    not match up. In these cases, we can use the `ContentSource` property as a shortcut
    to data bind the `Content`, `ContentTemplate`, and `ContentTemplateSelector` properties.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常可以让我们避免显式地将这些属性数据绑定，尽管有一些控件的相关属性名称并不匹配。在这些情况下，我们可以使用`ContentSource`属性作为快捷方式来数据绑定`Content`、`ContentTemplate`和`ContentTemplateSelector`属性。
- en: If we set this property to `Header`, for example, the Framework will look for
    a property named `Header` on the `ContentControl` object to implicitly data bind
    to the `Content` property of the presenter. Likewise, it will look for properties
    named `HeaderTemplate` and `HeaderTemplateSelector` to implicitly data bind to
    the `ContentTemplate` and `ContentTemplateSelector` properties.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此属性设置为`Header`，例如，框架将在`ContentControl`对象上查找名为`Header`的属性，以隐式地将它绑定到表示器的`Content`属性。同样，它将查找名为`HeaderTemplate`和`HeaderTemplateSelector`的属性，以隐式地将它们绑定到`ContentTemplate`和`ContentTemplateSelector`属性。
- en: 'This is primarily used in a `ControlTemplate` for a `HeaderedContentControl`
    element or one of its derived classes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要用于`HeaderedContentControl`元素或其派生类的`ControlTemplate`：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are specific rules that determine what the `ContentPresenter` will display.
    If the `ContentTemplate` or `ContentTemplateSelector` property is set, then the
    data object specified by the `Content` property will have the resulting data template
    applied to it. Likewise, if a data template of the relevant type is found within
    the scope of the `ContentPresenter` element, it will be applied.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特定的规则决定了`ContentPresenter`将显示什么。如果设置了`ContentTemplate`或`ContentTemplateSelector`属性，那么由`Content`属性指定的数据对象将应用结果数据模板。同样，如果在`ContentPresenter`元素的范围内找到了相关类型的数据模板，它将被应用。
- en: If the content object is a UI element, or one is returned from a type converter,
    then the element is displayed directly. If the object is a `string`, or a `string`
    is returned from a type converter, then it will be set as the `Text` property
    of a `TextBlock` control and that will be displayed. Likewise, all other objects
    simply have the `ToString` method called on them and then this output is rendered
    in a standard `TextBlock` at runtime.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内容对象是一个UI元素，或者从类型转换器返回了一个，那么该元素将直接显示。如果对象是一个`string`，或者从类型转换器返回了一个`string`，那么它将被设置为`TextBlock`控件的`Text`属性，并显示出来。同样，所有其他对象都将调用其`ToString`方法，然后在运行时以标准`TextBlock`渲染此输出。
- en: Items controls
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目控制
- en: We've already seen a fair number of examples of the `ItemsControl` class, but
    we'll now take a closer look at this control. In the simplest terms, an `ItemsControl` class
    contains a variable number of `ContentPresenter` elements and enables us to display
    a collection of items. It is the base class for most common collection controls,
    such as the `ListBox`, `ComboBox`, and `TreeView` controls.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多`ItemsControl`类的示例，但现在我们将更仔细地研究这个控件。简单来说，`ItemsControl`类包含可变数量的`ContentPresenter`元素，并使我们能够显示一系列项目。它是大多数常见集合控件（如`ListBox`、`ComboBox`和`TreeView`控件）的基类。
- en: Each of these derived classes adds a specific look and set of capabilities,
    such as a border and the notion of a selected item. If we do not require these
    additional features and simply want to display a number of items, then we should
    just use the `ItemsControl`, because it is more efficient than its derived classes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个派生类都添加了特定的外观和功能集，例如边框和选中项的概念。如果我们不需要这些额外功能，只想显示多个项目，那么我们应该只使用`ItemsControl`，因为它比其派生类更高效。
- en: When using the **Model-View-ViewModel** (**MVVM**) pattern, we typically data
    bind a collection that implements the `IEnumerable` interface from our View Model
    to the `ItemsControl.ItemsSource` property. However, there is also an `Items`
    property that will reflect the items in the data bound collection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**模型-视图-视图模型**（**MVVM**）模式时，我们通常将实现`IEnumerable`接口的集合从我们的视图模型数据绑定到`ItemsControl.ItemsSource`属性。然而，还有一个`Items`属性将反映数据绑定集合中的项目。
- en: To clarify this further, either property can be used to populate the collection
    of items to display. However, only one can be used at a time, so if you have data
    bound a collection to the `ItemsSource` property, then you cannot add items using
    the `Items` property. In this case, the `Items` collection will become read-only.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阐明这一点，可以使用任一属性来填充要显示的项目集合。但是，一次只能使用一个，所以如果你已经将集合绑定到`ItemsSource`属性，那么你不能使用`Items`属性添加项目。在这种情况下，`Items`集合将变为只读。
- en: If we need to display a collection of items that don't implement the `IEnumerable`
    interface, then we will need to add them using the `Items` property. Note that
    the `Items` property is implicitly used when items are declared as the content
    of an `ItemsControl` element in XAML. However, when using MVVM, we generally use
    the `ItemsSource` property.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要显示一个不实现`IEnumerable`接口的项目集合，那么我们需要使用`Items`属性添加它们。请注意，当在XAML中将项目声明为`ItemsControl`元素的内容时，会隐式使用`Items`属性。然而，当使用MVVM时，我们通常使用`ItemsSource`属性。
- en: When displaying items in an `ItemsControl`, each item in the collection will
    implicitly be wrapped in a `ContentPresenter` container element. The type of container
    element will depend upon the type of collection control used. For example, a `ComboBox`
    would wrap its items in `ComboBoxItem` elements.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示`ItemsControl`中的项目时，集合中的每个项目都将隐式地被包裹在一个`ContentPresenter`容器元素中。容器元素的类型将取决于所使用的集合控件类型。例如，`ComboBox`会将其项目包裹在`ComboBoxItem`元素中。
- en: The `ItemContainerStyle` and `ItemContainerStyleSelector` properties enable
    us to provide a style for these container items. We must ensure that the styles
    that we provide are targeted to the correct type of container control. For example,
    if we were using a `ListBox`, then we would need to provide a style targeting
    the `ListBoxItem` type, as in the following example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemContainerStyle`和`ItemContainerStyleSelector`属性使我们能够为这些容器项目提供样式。我们必须确保我们提供的样式针对正确的容器控件类型。例如，如果我们使用`ListBox`，那么我们需要提供一个针对`ListBoxItem`类型的样式，如下面的示例所示。'
- en: Note that we can explicitly declare these container items, although there is
    little point in doing so, as it will otherwise be done for us. Furthermore, when
    using MVVM, we do not typically work with UI elements, preferring to work with
    data objects in the View Models and data bind to the `ItemsSource` property instead.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以显式声明这些容器项目，尽管这样做几乎没有意义，因为否则它们会被自动完成。此外，当使用MVVM时，我们通常不与UI元素一起工作，而是更喜欢在视图模型中处理数据对象并将数据绑定到`ItemsSource`属性。
- en: 'As we have already seen, the `ItemsControl` class has an `ItemsPanel` property
    of type `ItemsPanelTemplate` that enables us to change the type of panel that
    the collection control uses to layout its items. When we want to customize the
    template of an `ItemsControl`, we have two choices regarding how we render the
    control''s child items:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，`ItemsControl`类有一个`ItemsPanel`属性，其类型为`ItemsPanelTemplate`，这使我们能够更改集合控件用于布局其项目的面板类型。当我们想要自定义`ItemsControl`的模板时，我们有两个选择来渲染控件子项的方式：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We already saw an example of the preceding method in the previous section.
    In this way, we specify the actual items panel itself and set the `IsItemsHost`
    property to `true` on it to indicate that it is indeed to be used as the control''s
    items panel. Using the alternative method, we need to declare an `ItemsPresenter`
    element, which specifies where the actual items panel will be rendered. Note that
    this element will be replaced by the actual items panel being used at runtime:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中已经看到了前面方法的示例。这样，我们指定实际的项面板本身，并将`IsItemsHost`属性设置为`true`以指示它确实是要用作控件的项目面板。使用替代方法，我们需要声明一个`ItemsPresenter`元素，该元素指定实际项面板将被渲染的位置。请注意，此元素将在运行时被实际使用的项面板替换：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As with the `ContentControl` class, the `ItemsControl` class also provides properties
    that enable us to shape its data items. The `ItemTemplate` and `ItemTemplateSelector`
    properties let us apply a data template for each item. However, if we just need
    a simple textual output, there are alternative methods where we can avoid the
    need to define a data template at all.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ContentControl`类一样，`ItemsControl`类也提供了使我们能够塑造其数据项的属性。`ItemTemplate`和`ItemTemplateSelector`属性使我们能够为每个项目应用数据模板。然而，如果我们只需要简单的文本输出，还有其他方法可以避免完全定义数据模板的需求。
- en: We can use the `DisplayMemberPath` property to specify the name of the property
    from the object to display the value. Alternatively, we can set the `ItemStringFormat`
    property to format the output as a `string`, or as we saw earlier, just provide
    some meaningful output from the class' `ToString` method of the data object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`DisplayMemberPath`属性来指定从对象中显示的属性名称。或者，我们可以设置`ItemStringFormat`属性以将输出格式化为`string`，或者如我们之前所见，只需从数据对象的类的`ToString`方法提供一些有意义的输出。
- en: 'Another interesting property is the `AlternationCount` property, which enables
    us to style alternating containers differently. We can set it to any number and
    the alternating sequence will repeat after that many items have been rendered.
    As a simple example, let''s use a `ListBox` because the `ListBoxItem` controls
    that will be wrapped around our items have appearance properties that we can alternate:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的属性是`AlternationCount`属性，它使我们能够以不同的方式样式化交替的容器。我们可以将其设置为任何数字，并且在渲染了这么多项目之后，交替序列将重复。作为一个简单的例子，让我们使用`ListBox`，因为将围绕我们的项目包装的`ListBoxItem`控件具有我们可以交替的外观属性：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we set the `AlternationCount` property to `3`, so we can have three different
    styles for our items and this pattern will be repeated for all three further items.
    We make a style for the item containers using the `ItemContainerStyle` property.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`AlternationCount`属性设置为`3`，因此我们可以为我们的项目提供三种不同的样式，并且这种模式将重复应用于所有三个后续项目。我们使用`ItemContainerStyle`属性为项目容器创建一个样式。
- en: In this style, we use some simple triggers to change the color of the container
    background, depending on the value of the `AlternationIndex` property. Notice
    that the `AlternationCount` property starts at `0`, so the first item will have
    a red background, the second will have green, the third will have blue, then the
    pattern will repeat and the fourth will have red, and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种风格中，我们使用一些简单的触发器来根据`AlternationIndex`属性的值改变容器背景的颜色。请注意，`AlternationCount`属性从`0`开始，因此第一个项目将具有红色背景，第二个将具有绿色，第三个将具有蓝色，然后模式将重复，第四个将再次是红色，以此类推。
- en: 'Alternatively, we could have declared an `AlternationConverter` instance for
    each property that we wanted to alter and data bind them to the `AlternationIndex`
    property and the converter. We could create the same visual output using this
    XAML instead:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以为每个想要更改的属性声明一个`AlternationConverter`实例，并将它们绑定到`AlternationIndex`属性和转换器。我们可以使用以下XAML创建相同的视觉输出：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `AlternationConverter` class works by simply returning the item from its
    collection that relates to the specified `AlternationIndex` value, where the first
    item is returned for index zero. Note that we need to include the parenthesis
    around the data bound class and property name because it is an Attached Property
    and we need to use a `RelativeSource.Self` binding because the property is set
    on the item container object itself. Let''s see the output of these two code examples:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlternationConverter`类通过简单地返回与其指定的`AlternationIndex`值相关的集合中的项目来工作，其中索引为零时返回第一个项目。请注意，我们需要在数据绑定的类和属性名称周围包含括号，因为它是一个附加属性，并且我们需要使用`RelativeSource.Self`绑定，因为该属性是在项目容器对象本身上设置的。让我们看看这两个代码示例的输出：'
- en: '![](img/fe7b34ae-96eb-4c4e-8cbc-9934751acd07.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe7b34ae-96eb-4c4e-8cbc-9934751acd07.png)'
- en: 'There is one more useful property that the `ItemsControl` class provides and
    that is the `GroupStyle` property, which is used to display the child items in
    groups. To group items in the UI, we need to accomplish a few simple tasks. We
    first need to define XAML namespaces for our  `Converters` project and the `ComponentModel`
    CLR namespace:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsControl`类还提供了一个有用的属性，即`GroupStyle`属性，它用于在组中显示子项。要在UI中分组项目，我们需要完成几个简单的任务。首先，我们需要为我们的`Converters`项目和`ComponentModel`
    CLR命名空间定义XAML命名空间：'
- en: 'Next, we need to data bind a `CollectionViewSource` instance with one or more
    `PropertyGroupDescription` elements to our `Users` collection from the previous
    example. We then need to set that as the `ItemsSource` value for the `ItemsControl`
    and then set up its `GroupStyle`. Let''s see the `StringToFirstLetterConverter` converter
    and `CollectionViewSource` object that we need to declare in the local `Resources`
    section:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将一个 `CollectionViewSource` 实例与一个或多个 `PropertyGroupDescription` 元素数据绑定到之前示例中的
    `Users` 集合。然后，我们需要将其设置为 `ItemsControl` 的 `ItemsSource` 值，并设置其 `GroupStyle`。让我们看看在本地
    `Resources` 部分需要声明的 `StringToFirstLetterConverter` 转换器和 `CollectionViewSource`
    对象：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We specify the property that we want to use to group items by using the `PropertyName`
    property of the `PropertyGroupDescription` element. Note that in our case, we
    only have a few `User` objects, and so there would be no groups if we simply grouped
    by name. Therefore, we added a converter to return the first letter from each
    name to group on and specified it using the `Converter` property.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `PropertyGroupDescription` 元素的 `PropertyName` 属性指定我们想要用来按项目分组的属性。注意，在我们的情况下，我们只有几个
    `User` 对象，如果我们仅仅按名称分组，将不会有任何组。因此，我们添加了一个转换器，从每个名称中返回第一个字母以进行分组，并使用 `Converter`
    属性指定它。
- en: 'We then added a basic `SortDescription` element to the `CollectionViewSource.SortDescriptions`
    collection in order to sort the `User` objects. We specified the `Name` property
    in the `PropertyName` property of the `SortDescription` element so that the `User`
    objects will be sorted by name. Let’s see the `StringToFirstLetterConverter` class
    now:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `CollectionViewSource.SortDescriptions` 集合中添加了一个基本的 `SortDescription`
    元素，以便对 `User` 对象进行排序。我们在 `SortDescription` 元素的 `PropertyName` 属性中指定了 `Name` 属性，这样
    `User` 对象就会按名称排序。现在让我们看看 `StringToFirstLetterConverter` 类：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this converter, we specify the data types that are involved in the implementation
    of the converter in the `ValueConversion` attribute, even though they are the
    same type. In the `Convert` method, we check the validity of our `value` input
    parameter and return the `DependencyProperty.UnsetValue` value if it is `null`.
    We then call the `ToString` method on it and if it is an empty string, we return
    the `DependencyProperty.UnsetValue` value. For all valid `string` values, we simply
    return the first letter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个转换器中，我们在 `ValueConversion` 属性中指定了涉及转换器实现的数据类型，即使它们是相同类型。在 `Convert` 方法中，我们检查
    `value` 输入参数的有效性，如果它是 `null`，则返回 `DependencyProperty.UnsetValue` 值。然后我们调用它的 `ToString`
    方法，如果它是一个空字符串，我们返回 `DependencyProperty.UnsetValue` 值。对于所有有效的 `string` 值，我们简单地返回第一个字母。
- en: 'As we do not need (or would not be able) to convert anything back using this
    converter, the `ConvertBack` method simply returns the `DependencyProperty.UnsetValue`
    value. By attaching this converter to the `PropertyGroupDescription` element,
    we are now able to group by the first letter of each name. Let''s now see how
    we can declare the `GroupStyle` object:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要（或无法）使用此转换器转换任何内容，`ConvertBack` 方法简单地返回 `DependencyProperty.UnsetValue`
    值。通过将此转换器附加到 `PropertyGroupDescription` 元素，我们现在能够按每个名称的第一个字母进行分组。现在让我们看看如何声明 `GroupStyle`
    对象：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that we need to use the `Binding.Source` property to access the `CollectionViewSource`
    object named `GroupedUsers` from the local `Resources` section. We then declare
    the data template that defines what each group header will look like in the `HeaderTemplate`
    property. Here we make use of the `StringToFirstLetterConverter` instance that
    has also been declared in a suitable resource collection and set a few basic style
    properties.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要使用 `Binding.Source` 属性来访问本地 `Resources` 部分中名为 `GroupedUsers` 的 `CollectionViewSource`
    对象。然后，我们在 `HeaderTemplate` 属性中声明数据模板，定义每个组标题的外观。在这里，我们使用了也在合适的资源集合中声明的 `StringToFirstLetterConverter`
    实例，并设置了一些基本样式属性。
- en: 'Next, we specify a second data template, but one that defines what the items
    in each group should look like. We provide a very simple template that merely
    spaces the elements slightly and sets a few style properties. Let''s see the output
    of this example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定第二个数据模板，但这个模板定义了每个组中的项目应该是什么样子。我们提供了一个非常简单的模板，仅稍微间隔元素并设置了一些样式属性。让我们看看这个示例的输出：
- en: '![](img/d325ddef-c598-4132-af32-3c1955bb1387.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d325ddef-c598-4132-af32-3c1955bb1387.png)'
- en: Adorners
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰符
- en: An adorner is a special kind of class that is rendered above all UI controls,
    in what is known as an adorner layer. Adorner elements in this layer will always
    be rendered on top of the normal WPF controls, regardless of their `Panel.ZIndex`
    property setting. Each adorner is bound to an element of type `UIElement` and
    independently rendered in a position that is relative to the adorned element.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种特殊的类，它在所有UI控件之上渲染，被称为装饰器层。在这个层中的装饰器元素将始终渲染在正常WPF控件之上，无论它们的`Panel.ZIndex`属性设置如何。每个装饰器都绑定到类型为`UIElement`的元素，并独立地在相对于被装饰元素的位置进行渲染。
- en: The purpose of the adorner is to provide certain visual cues to the application
    user. For example, we could use an adorner to display a visual representation
    of UI elements that are being dragged in a drag and drop operation. Alternatively,
    we could use an adorner to add handles to a UI control to enable users to resize
    the element.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的目的是向应用程序用户提供某些视觉提示。例如，我们可以使用装饰器来显示正在拖放操作中拖动的UI元素的视觉表示。或者，我们可以使用装饰器向UI控件添加把手，使用户能够调整元素的大小。
- en: As the adorner is added to the adorner layer, it is the adorner layer that is
    the parent of the adorner, rather than the adorned element. In order to create
    a custom adorner, we need to declare a class that extends the `Adorner` class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当装饰器被添加到装饰器层时，装饰器层是装饰器的父级，而不是被装饰的元素。为了创建自定义装饰器，我们需要声明一个扩展`Adorner`类的类。
- en: When creating a custom adorner, we need to be aware that we are responsible
    for writing the code to render its visuals. However, there are a few different
    ways to construct our adorner graphics; we can use the `OnRender` or `OnRenderSizeChanged`
    methods and a drawing context to draw basic lines and shapes, or we can use the
    `ArrangeOverride` method to arrange .NET controls.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建自定义装饰器时，我们需要意识到我们负责编写代码以渲染其视觉元素。然而，构建我们的装饰器图形有几种不同的方法；我们可以使用`OnRender`或`OnRenderSizeChanged`方法以及绘图上下文来绘制基本的线条和形状，或者我们可以使用`ArrangeOverride`方法来排列.NET控件。
- en: Adorners receive events like other .NET controls, although if we don't need
    to handle them, we can arrange for them to be passed straight through to the adorned
    element. In these cases, we can set the `IsHitTestVisible` property to `false`
    and this will enable pass-through hit-testing of the adorned element. Let's look
    at an example of a resizing adorner that lets us resize shapes on a canvas.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器像其他.NET控件一样接收事件，尽管如果我们不需要处理它们，我们可以安排它们直接传递到被装饰的元素。在这些情况下，我们可以将`IsHitTestVisible`属性设置为`false`，这将启用被装饰元素的穿透式命中测试。让我们看看一个调整大小装饰器的例子，它允许我们在画布上调整形状的大小。
- en: 'Before we investigate the adorner class, let''s first see how we can use it.
    Adorners need to be initialized in code, and so a good place to do this is in
    the `UserControl.Loaded` method, when we can be certain that the canvas and its
    items will have been initialized. Note that as adorners are purely UI related,
    initializing them in the control''s code behind does not present any conflict
    when using MVVM:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究装饰器类之前，让我们首先看看我们如何使用它。装饰器需要在代码中进行初始化，因此一个好的地方是在`UserControl.Loaded`方法中这样做，当我们可以确定画布及其项目已经初始化时。请注意，由于装饰器纯粹与UI相关，在控制器的代码后部初始化它们在使用MVVM时不会产生任何冲突：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We access the adorner layer for the canvas that we will add the adorners to
    using the `AdornerLayer.GetAdornerLayer` method, passing in the canvas as the
    `Visual` input parameter. In this example, we attach an instance of our `ResizeAdorner`
    to each element in the canvas' `Children` collection and then add it to the adorner
    layer.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AdornerLayer.GetAdornerLayer`方法访问将要添加装饰器的画布的装饰器层，将画布作为`Visual`输入参数传递。在这个例子中，我们将我们的`ResizeAdorner`实例附加到画布`Children`集合中的每个元素上，然后将其添加到装饰器层。
- en: 'Now, we just need a `Canvas` panel named `Canvas` and some shapes to resize:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要一个名为`Canvas`的`Canvas`面板和一些需要调整大小的形状：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s now see the code in our `ResizeAdorner` class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的`ResizeAdorner`类中的代码：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we have declared the `Adorners` namespace within the `Views` project,
    as this is the only place that it will be used. Inside the class, we declare the
    `VisualCollection` object that will contain the visuals that we want to render
    and then the visuals themselves, in the shape of `Thumb` controls.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`Views`项目中声明了`Adorners`命名空间，因为这是它唯一会被使用的地方。在类内部，我们声明了将包含我们想要渲染的视觉的`VisualCollection`对象，然后是形状本身，即`Thumb`控件。
- en: We've chosen `Thumb` elements because they have built-in functionality that
    we want to take advantage of. They provide a `DragDelta` event that we will use
    to register the users' mouse movements when they drag each `Thumb`. These controls
    are normally used internally in the `Slider` and `ScrollBar` controls to enable
    users to alter values, so they're perfect for our purposes here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择`Thumb`元素，因为它们具有我们想要利用的内置功能。它们提供了一个`DragDelta`事件，我们将用它来记录用户在拖动每个`Thumb`时的鼠标移动。这些控件通常在`Slider`和`ScrollBar`控件内部使用，以使用户能够更改值，因此它们非常适合我们的目的。
- en: We initialize these objects in the constructor, specifying a custom cursor and
    a different `DragDelta` event handler for each `Thumb` control. In these separate
    event handlers, we use the `HorizontalChange` or `VerticalChange` properties of
    the `DragDeltaEventArgs` object to specify the distance and direction of the mouse
    movement that triggered the event.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中初始化这些对象，为每个`Thumb`控件指定一个自定义的光标和不同的`DragDelta`事件处理器。在这些独立的事件处理器中，我们使用`DragDeltaEventArgs`对象的`HorizontalChange`或`VerticalChange`属性来指定触发事件的鼠标移动的距离和方向。
- en: We use these values to move and/or resize the adorned element by the appropriate
    amount and direction. Note that we use the `Math.Max` method and the value `6`
    in our example to ensure that the adorned element cannot be resized smaller than
    the size of each `Thumb` element and the `Stroke` size of each adorned element.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些值来移动和/或按适当的数量和方向调整装饰元素的大小。请注意，我们使用`Math.Max`方法和示例中的值`6`来确保装饰元素不能小于每个`Thumb`元素的大小和每个装饰元素的`Stroke`大小。
- en: After the four `DragDelta` event handlers, we find two different ways to render
    our adorner visuals. In the first method, we use the `DrawingContext` object that
    is passed into the `OnRender` method by the base class to manually draw shapes.
    This is somewhat similar to the way that we used to draw in the `Control.Paint`
    event handler methods when using `Windows.Forms`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在四个`DragDelta`事件处理器之后，我们发现有两种不同的方式来渲染我们的装饰器视觉元素。在第一种方法中，我们使用基类通过`OnRender`方法传入的`DrawingContext`对象来手动绘制形状。这有点类似于我们过去在`Windows.Forms`中使用`Control.Paint`事件处理器方法绘制的方式。
- en: In this overridden method, we draw a rectangle that surrounds our element and
    is four pixels bigger than it in both dimensions. Note that we define a transparent
    background for the drawing brush, as we only want to see the rectangle border.
    Remember that adorner graphics are rendered on top of the adorned element, but
    we do not want to cover it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个覆盖的方法中，我们绘制一个矩形，它包围我们的元素，并且在两个维度上比它大四像素。请注意，我们为绘图刷定义了一个透明的背景，因为我们只想看到矩形边框。记住，装饰器图形是在装饰元素之上渲染的，但我们不希望覆盖它。
- en: In the `ArrangeOverride` method, we use .NET Framework to render our `Visual`
    elements using their `Arrange` methods, as we would in a custom panel. Note that
    we could just as easily render our rectangle border in this method using a `Rectangle`
    element; the `OnRender` method was used in this example merely as a demonstration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ArrangeOverride`方法中，我们使用.NET Framework通过它们的`Arrange`方法来渲染我们的`Visual`元素，就像在自定义面板中一样。请注意，我们同样可以在这种方法中使用`Rectangle`元素来渲染我们的矩形边框；在这个例子中，`OnRender`方法仅用作演示。
- en: In this method, we simply arrange each `Visual` element at the relevant position
    and size in turn. Calculating the appropriate positions can be achieved simply
    by dividing the width or height of each adorned element in half and subtracting
    half of the width or height of each thumb element.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们依次排列每个`Visual`元素在相关的位置和大小。通过将每个装饰元素的宽度和高度各自除以二并减去每个拇指元素的宽度和高度的一半，可以简单地计算出适当的位置。
- en: Finally, we get to the protected overridden `VisualChildrenCount` property and
    `GetVisualChild` method. The `Adorner` class extends the `FrameworkElement` class
    and that will normally return either zero or one from the `VisualChildrenCount`
    property, as each instance is normally represented by either no visual, or a single
    rendered visual.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了受保护的覆盖`VisualChildrenCount`属性和`GetVisualChild`方法。`Adorner`类扩展了`FrameworkElement`类，并且通常从`VisualChildrenCount`属性返回零或一，因为每个实例通常由没有视觉元素或单个渲染视觉元素表示。
- en: In our case and other situations when a derived class has multiple visuals to
    render, it is a requirement of the layout system that the correct number of visuals
    is specified. For example, if we always returned the value `2` from this property,
    then only two of our thumbs would be rendered on screen.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况和其他情况下，当派生类有多个视觉元素需要渲染时，布局系统要求指定正确的视觉元素数量。例如，如果我们总是从这个属性返回值 `2`，那么只有两个我们的缩略图会在屏幕上渲染。
- en: 'Likewise, we also need to return the correct item from our visual collection
    when requested to from the `GetVisualChild` method. If, for example, we always
    returned the first visual from our collection, then only that visual would be
    rendered, as the same visual cannot be rendered more than once. Let''s see what
    our adorners look like when rendered above each of our shapes:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们被要求从 `GetVisualChild` 方法返回正确的项目时，我们也需要从我们的视觉集合中返回正确的项目。例如，如果我们总是从我们的集合中返回第一个视觉元素，那么只有那个视觉元素会被渲染，因为相同的视觉元素不能被渲染多次。让我们看看我们的装饰器在渲染到我们每个形状上方时的样子：
- en: '![](img/5ace8f73-a97b-45e1-bd69-aa16115d2aec.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ace8f73-a97b-45e1-bd69-aa16115d2aec.png)'
- en: Modifying existing controls
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改现有控件
- en: When we find that the wide range of existing controls doesn't quite meet our
    needs, we might think that we need to create some new ones, as we would with other
    technologies. When using other UI languages, this might be the case, but with
    WPF, this is not necessarily true, as it provides a number of ways to modify the
    existing controls to suit our requirements.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发现现有的广泛控件并不完全满足我们的需求时，我们可能会认为我们需要创建一些新的控件，就像使用其他技术一样。当使用其他 UI 语言时，这可能是情况，但使用
    WPF 时，这并不一定正确，因为它提供了多种修改现有控件以适应我们需求的方法。
- en: As we found out earlier, all classes that extend the `FrameworkElement` class
    have access to the framework's styling capabilities and those that extend the
    `Control` class can have their appearance totally changed through their `ControlTemplate`
    property. All of the existing WPF controls extend these base cases, and so possess
    these abilities.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所发现，所有扩展 `FrameworkElement` 类的类都可以访问框架的样式化能力，而扩展 `Control` 类的类可以通过它们的 `ControlTemplate`
    属性完全改变外观。所有现有的 WPF 控件都扩展了这些基本案例，因此具有这些能力。
- en: In addition to these capabilities that enable us to change the look of the pre-existing
    WPF controls, we are also able to leverage the power of Attached Properties to
    add additional functionality to them too. In this section, we will investigate
    these different ways of modifying the existing controls.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些使我们能够改变现有 WPF 控件外观的能力之外，我们还能够利用附加属性的力量为它们添加额外的功能。在本节中，我们将探讨修改现有控件的不同方法。
- en: Styling
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化
- en: 'Setting the various properties of a control is the simplest way to alter its
    look and enables us to make either minor or more dramatic changes to it. As most
    UI elements extend the `Control` class, they mostly share the same properties
    that affect their appearance and alignment. When defining styles for controls,
    we should specify their type in the `TargetType` property, as this helps the compiler
    to verify that the properties that we are setting actually exist in the class:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 设置控件的各个属性是改变其外观的最简单方法，使我们能够对其进行细微或更显著的变化。由于大多数 UI 元素扩展了 `Control` 类，它们大多数共享相同的属性，这些属性影响它们的外观和对齐。当为控件定义样式时，我们应该在
    `TargetType` 属性中指定它们的类型，因为这有助于编译器验证我们设置的属性实际上存在于类中：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Failing to do so will result in the compiler stating that the member is not
    recognized or is not accessible. In these cases, we will need to specify the class
    type as well, in the format `ClassName.PropertyName`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，编译器会指出成员不被识别或不可访问。在这些情况下，我们需要指定类类型，格式为 `ClassName.PropertyName`：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'One really useful property that the `Style` class declares is the `BasedOn`
    property. Using this property, we can base our styles on other styles and this
    enables us to create a number of incrementally different versions. Let''s highlight
    this with an example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Style` 类声明的一个非常有用的属性是 `BasedOn` 属性。使用这个属性，我们可以基于其他样式创建样式，这使我们能够创建多个逐步不同的版本。让我们用一个例子来强调这一点：'
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we define a simple style for the textboxes in our application. We name
    it `TextBoxStyle` and then reference it in the `BasedOn` property of the second
    style. This means that all of the property setters and triggers declared in the
    first style will also apply to the bottom style. In the second style, we add a
    few further setters to make the applied textbox read-only.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为我们的应用程序中的文本框定义了一个简单的样式。我们将其命名为 `TextBoxStyle`，然后在第二个样式的 `BasedOn` 属性中引用它。这意味着第一个样式中声明的所有属性设置器和触发器也将应用于底部样式。在第二个样式中，我们添加了一些进一步的设置器，使应用的文本框变为只读。
- en: 'One last point to note is that if we wanted to base a style on the default
    style of a control, we can use the value that we normally enter into the `TargetType`
    property as the key to identify the style that we want to base the new style on:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要注意的是，如果我们想基于控件的默认样式创建一个样式，我们可以使用通常输入到 `TargetType` 属性中的值作为键来识别我们想要基于其创建新样式的样式：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's now move on to take a deeper look into resources.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在深入探讨资源。
- en: Being resourceful
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 充分利用资源
- en: Styles are most often declared in the various `Resources` dictionaries of the
    application, along with various templates, application colors, and brushes. The
    `Resources` property is of type `ResourceDictionary` and declared in the `FrameworkElement`
    class and so virtually all UI elements inherit it and can therefore host our styles
    and other resources.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 样式通常在应用程序的各种 `Resources` 字典中声明，包括各种模板、应用程序颜色和画笔。资源属性是 `ResourceDictionary` 类型，并在
    `FrameworkElement` 类中声明，因此几乎所有 UI 元素都继承它，因此可以托管我们的样式和其他资源。
- en: 'Although the `Resources` property is of type `ResourceDictionary`, we do not
    need to explicitly declare this element:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然资源属性是 `ResourceDictionary` 类型，但我们不需要显式声明此元素：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'While there are some occasions when we do need to explicitly declare the `ResourceDictionary`,
    it will be implicitly declared for us if we do not:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些情况下我们需要显式声明 `ResourceDictionary`，但如果我们不声明，它将隐式声明：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Every resource in each collection must have a key that uniquely identifies
    them. We use the `x:Key` directive to explicitly set this key, however, it can
    also be set implicitly as well. When we declare styles in any `Resources` section,
    we can specify the `TargetType` value alone, without setting the `x:Key` directive,
    in which case the style will be implicitly applied to all elements of the correct
    type that are in the scope of the style:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合中的每个资源都必须有一个唯一标识它们的键。我们使用 `x:Key` 指令显式设置此键，然而，它也可以隐式设置。当我们声明任何 `Resources`
    部分中的样式时，我们可以仅指定 `TargetType` 值，而不设置 `x:Key` 指令，在这种情况下，样式将隐式应用于所有正确类型的元素，这些元素在样式的范围内：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, the value for the `x:Key` directive is implicitly set to `{x:Type
    Button}`. Alternatively, we can set the `x:Key` directive explicitly, so that
    the style must also be applied explicitly:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`x:Key` 指令的值隐式设置为 `{x:Type Button}`。或者，我们可以显式设置 `x:Key` 指令，这样样式也必须显式应用：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Styles can have both values set as well, as shown in the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 样式也可以同时设置两个值，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But a compilation error will be thrown if neither value is set:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个值都没有设置，将会抛出编译错误：
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding XAML would result in the following compilation error:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 XAML 会导致以下编译错误：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When a `StaticResource` with a specific key is requested, the lookup process
    first looks in the local control; if it has a style and that style has a resource
    dictionary, it checks that first; if there is no item with a matching key, it
    next looks in the resource collection of the control itself.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求具有特定键的 `StaticResource` 时，查找过程首先在本地控件中查找；如果它有一个样式并且该样式有一个资源字典，它首先检查该样式；如果没有找到匹配的项，它接下来会在控件本身的资源集合中查找。
- en: If there is still no match, the lookup process checks the resource dictionaries
    of each successive parent control until it reaches the `MainWindow.xaml` file.
    If it still does not find a match, then it will look in the application `Resources`
    section in the `App.xaml` file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仍然没有匹配项，查找过程会检查每个后续父控件的资源字典，直到它达到 `MainWindow.xaml` 文件。如果它仍然找不到匹配项，那么它将在 `App.xaml`
    文件中的应用程序 `Resources` 部分中查找。
- en: '`StaticResource` lookups occur once upon initialization and will suit our requirements
    for most of the time. When using a `StaticResource` to reference one resource
    that is to be used within another resource, the resource being used must be declared
    beforehand. That is to say that a `StaticResource` lookup from one resource cannot
    reference another resource that is declared after it in the resource dictionary:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticResource` 查找在初始化时发生一次，并且对于大多数时间都符合我们的需求。当使用 `StaticResource` 来引用另一个资源中要使用的资源时，所使用的资源必须事先声明。也就是说，一个资源中的
    `StaticResource` 查找不能引用在资源字典中之后声明的另一个资源：'
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding XAML would result in the following error:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 XAML 代码会导致以下错误：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Simply moving the declaration of the brush before the style would clear this
    error and get the application running again. However, there are certain situations
    when using a `StaticResource` to reference a resource isn't suitable. For example,
    we might need our styles to update during runtime in response to some programmatic
    or user interaction, such as a changing of the computer theme.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将画笔声明的位置移动到样式的声明之前，可以清除此错误并使应用程序重新运行。然而，在某些情况下，使用 `StaticResource` 来引用资源并不合适。例如，我们可能需要在程序或用户交互（如更改计算机主题）响应时更新我们的样式。
- en: 'In these cases, we can use a `DynamicResource` to reference our resources and
    can rest assured that our styles will update when the relevant resources are changed.
    Note that the resource value is not looked up until it is actually requested,
    so this is perfect for resources that will not be ready until after the application
    starts. Note the following altered example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们可以使用 `DynamicResource` 来引用我们的资源，并且可以确信当相关资源更改时，我们的样式将更新。请注意，资源值只有在实际请求时才会查找，因此这对于在应用程序启动后才准备好的资源来说非常完美。注意以下修改后的示例：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, there will be no compilation error, as the `DynamicResource` will
    retrieve the value whenever it is set. While it's great to have this ability,
    it's important not to abuse it, as using the `DynamicResource` will negatively
    affect performance. This is because they repeatedly lookup the value each time
    it is requested, whether the values have changed or not. For this reason, we should
    only ever use a `DynamicResource` if we really need to.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将不会有编译错误，因为 `DynamicResource` 将在设置值时检索该值。虽然这种能力很棒，但重要的是不要滥用它，因为使用 `DynamicResource`
    会负面影响性能。这是因为它们每次请求值时都会重复查找，无论值是否已更改。因此，我们只有在真正需要时才应使用 `DynamicResource`。
- en: One final point about resource styles to mention here relates to scope. While
    this topic has been mentioned elsewhere in this book, it is outlined again here
    as it is essential to understand the resource lookup procedure. Application resources
    that are declared in the `App.xaml` file are available application-wide, so this
    is a great place to declare our common styles.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点关于资源样式的讨论与范围有关。虽然这个主题在本书的其他地方已经提到，但在这里再次概述，因为它对于理解资源查找过程至关重要。在 `App.xaml`
    文件中声明的应用程序资源是全局可用的，因此这是一个声明我们常用样式的绝佳位置。
- en: However, this is one of the furthest removed places that we can declare our
    styles, ignoring external resource dictionaries and theme styles. In general,
    the rule is that given a resource identifier conflict, the most local resources
    override those that are declared further away. Therefore, we can define our default
    styles in the application resources but retain the ability to override them locally.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是我们声明样式的最远离处，忽略外部资源字典和主题样式。一般来说，规则是，在资源标识符冲突的情况下，最本地资源覆盖那些声明得更远的资源。因此，我们可以在应用程序资源中定义我们的默认样式，同时保留在本地覆盖它们的能力。
- en: Conversely, locally declared styles without an `x:Key` directive will be implicitly
    applied locally, but will not be applied to elements of the relevant type that
    are declared externally. We can, therefore, declare implicit styles in the `Resources`
    section of a panel for example and they will only be applied to elements of the
    relative type within the panel.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，没有 `x:Key` 指令的本地声明样式将隐式应用于本地，但不会应用于外部声明的相关类型的元素。因此，我们可以在面板的 `Resources` 部分声明隐式样式，并且它们只会应用于面板内相对类型的元素。
- en: Merging resources
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源合并
- en: If we have a large application and our application resources are becoming overcrowded,
    we have the option of splitting our default colors, brushes, styles, templates,
    and other resources into different files. In addition to organizational and maintenance
    benefits, this also enables our main resource files to be shared amongst our other
    applications, and so this promotes reusability too.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序很大，并且应用程序资源变得过于拥挤，我们可以选择将默认的颜色、画笔、样式、模板和其他资源拆分到不同的文件中。除了组织和管理的好处外，这还使得我们的主要资源文件可以在我们的其他应用程序之间共享，从而也促进了可重用性。
- en: 'In order to do this, we first need one or more additional resource files. We
    can add an additional resource file using Visual Studio, by right-clicking on
    the relevant project and selecting the Add option and then the Resource Dictionary...
    option. Upon executing this command, we will be provided with a file like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们首先需要添加一个或多个额外的资源文件。我们可以通过在 Visual Studio 中右键单击相关项目并选择“添加”选项，然后选择“资源字典...”选项来添加一个额外的资源文件。执行此命令后，我们将得到一个类似这样的文件：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is one of the occasions when we do need to explicitly declare the `ResourceDictionary`
    element. Once we have transferred our styles or other resources to this file,
    we can merge it into our main application resources file like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要明确声明 `ResourceDictionary` 元素的情况之一。一旦我们将样式或其他资源转移到这个文件中，我们就可以像这样将其合并到我们的主要应用程序资源文件中：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that we do not specify the `x:Key` directive for this resource dictionary.
    In fact, if we did specify this value on the dictionary, we would receive a compilation
    error:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为这个资源字典指定 `x:Key` 指令。实际上，如果我们指定了这个值在字典上，我们会收到一个编译错误：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note also that we can set the `ResourceDictionary.MergedDictionaries` value
    either above or below our locally declared resources, but not anywhere in the
    middle of them. Within this property, we can declare another `ResourceDictionary`
    element for each external resource file that we want to merge and specify its
    location using a **Uniform Resource Identifier** (**URI**) in the `Source` property.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们可以将 `ResourceDictionary.MergedDictionaries` 的值设置在我们的本地声明的资源之上或之下，但不能在它们中间的任何位置。在这个属性中，我们可以为每个我们想要合并的外部资源文件声明另一个
    `ResourceDictionary` 元素，并使用 `Source` 属性中的 **统一资源标识符**（**URI**）指定其位置。
- en: 'If our external resource files reside in our startup project with our `App.xaml`
    file, we can reference them with relative paths, as shown in the preceding example.
    Otherwise, we will need to use the Pack URI notation. To reference a resource
    file from a referenced assembly, we would need to use the following format:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的外部资源文件位于包含我们的 `App.xaml` 文件的启动项目中，我们可以使用相对路径引用它们，如前例所示。否则，我们需要使用 Pack URI
    表示法。要从引用的程序集引用资源文件，我们需要使用以下格式：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In our case, assuming that we had some resource files in a folder named `Styles`
    in a separate project, or other referenced assembly, we would merge the file using
    the following path:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，假设我们有一些资源文件位于一个名为 `Styles` 的文件夹中，该文件夹位于一个单独的项目中，或者在其他引用的程序集中，我们会使用以下路径合并该文件：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When merging resource files, it is important to understand how naming conflicts
    will be resolved. Although the `x:Key` directives that we set on our resources
    must each be unique within their declared resource dictionary, it is perfectly
    legal to have duplicated key values within separate resource files. As such, there
    is an order of priority that will be followed in these cases. Let's see an example.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并资源文件时，了解命名冲突将如何解决是很重要的。尽管我们为资源设置的 `x:Key` 指令必须在它们声明的资源字典中是唯一的，但在不同的资源文件中拥有重复的关键值是完全合法的。因此，在这些情况下将遵循一个优先级顺序。让我们看看一个例子。
- en: 'Imagine that we have the aforementioned referenced resource file in a separate
    project and in that file, we have this resource:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个单独的项目中提到的资源文件，在该文件中，我们有以下资源：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that we would need to add a reference to the `System.Xaml` assembly in
    that project in order to avoid errors. Now imagine that we also have the locally
    declared `Default Styles.xaml` resource file that was referenced in the previous
    example and in that file, we have this resource:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要在该项目中添加对 `System.Xaml` 程序集的引用，以避免错误。现在假设我们还有一个在先前的例子中引用的本地声明的 `Default
    Styles.xaml` 资源文件，在该文件中，我们有以下资源：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s add a `Default Styles 2.xaml` resource file with this resource in it:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个包含此资源的 `Default Styles 2.xaml` 资源文件：
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s say that we merge all of these resource files and add this additional
    resource in our application resource file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们将所有这些资源文件合并，并在我们的应用程序资源文件中添加以下附加资源：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, let''s imagine that we have this in the XAML of one of our Views:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们假设我们在某个视图的XAML中有以下内容：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Also, let''s assume that we have this in the local resources of that file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在该文件的本地资源中有以下内容：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When running the application, our button text will be cyan, because the main
    rule of resource scope is that the highest priority resource that will be used
    will always be the most locally declared resource. If we removed or commented
    out the local brush declaration, the button text would then become purple when
    the application was next run.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行应用程序时，我们的按钮文本将是青色，因为资源作用域的主要规则是，将使用的最高优先级资源将是声明得最本地化的资源。如果我们移除或注释掉本地画笔声明，那么在应用程序下次运行时，按钮文本将变为紫色。
- en: If we removed the local purple brush resource from the control's `Resources`
    section, the application resources would be searched next in an attempt to resolve
    the `Brush` resource key. The next general rule is that the latest declared resource
    will be resolved. In this way, the button text would then become green, because
    of the locally declared resource in the `App.xaml` file, which would override
    the values from the merged dictionaries.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从控件的控制`Resources`部分移除本地紫色画笔资源，应用程序资源将随后在尝试解决`Brush`资源键时被搜索。下一个一般规则是最晚声明的资源将被解决。这样，按钮文本将变为绿色，因为`App.xaml`文件中声明的本地资源将覆盖合并字典中的值。
- en: However, if this green brush resource was removed, an interesting thing would
    happen. Given the recently stated rules, we might expect that the button text
    would then be set to red by the `Control Styles.xaml` resource file from the referenced
    assembly. Instead, it will be set to orange by the resource in the `Default Styles
    2.xaml` file.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果移除这个绿色画笔资源，会发生有趣的事情。根据最近宣布的规则，我们可能会预期按钮文本将由引用程序集的`Control Styles.xaml`资源文件设置为红色。相反，它将由`Default
    Styles 2.xaml`文件中的资源设置为橙色。
- en: This is the result of a combination of the two rules together. The two locally
    declared resource files have a higher priority than the resource file from the
    referenced assembly because they have been declared more locally than it. The
    second of the two locally declared resource files takes precedence over the first
    because it was declared after the first.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个规则结合的结果。两个本地声明的资源文件比引用程序集的资源文件具有更高的优先级，因为它们比它声明得更本地化。第二个本地声明的资源文件比第一个具有优先级，因为它是在第一个之后声明的。
- en: If we removed the reference to the second of the locally declared resource files,
    the text would then be set to blue by the resource in the `Default Styles.xaml`
    file. If we then removed the reference to this file, we would finally see the
    red button text that would be set by the `Control Styles.xaml` file from the referenced
    assembly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除对第二个本地声明的资源文件的引用，文本将由`Default Styles.xaml`文件中的资源设置为蓝色。如果我们然后移除对该文件的引用，我们最终会看到由引用程序集的`Control
    Styles.xaml`文件设置的红色按钮文本。
- en: Triggering changes
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发更改
- en: In WPF, we have a number of `Trigger` classes that enable us to modify controls,
    albeit most commonly, just temporarily. All of them extend the `TriggerBase` base
    class and therefore inherit its `EnterActions` and `ExitActions` properties. These
    two properties enable us to specify one or more `TriggerAction` objects to apply
    when the trigger becomes active and/or inactive respectively.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，我们有多个`Trigger`类，使我们能够修改控件，尽管最常见的是临时修改。所有这些类都扩展了`TriggerBase`基类，因此继承其`EnterActions`和`ExitActions`属性。这两个属性使我们能够指定一个或多个在触发器变为活动状态和/或非活动状态时应用的`TriggerAction`对象。
- en: While most trigger types also contain a `Setters` property that we can use to
    define one or more property setters that should occur when a certain condition
    is met, the `EventTrigger` class does not. Instead, it provides an `Actions` property
    that enables us to set one or more `TriggerAction` objects to be applied when
    the trigger becomes active.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数触发类型也包含一个`Setters`属性，我们可以用它来定义当满足某个条件时应发生的属性设置器，但`EventTrigger`类没有。相反，它提供了一个`Actions`属性，使我们能够设置一个或多个在触发器变为活动状态时应用的`TriggerAction`对象。
- en: 'Furthermore, unlike the other triggers, the `EventTrigger` class has no concept
    of state termination. This means that the action applied by the `EventTrigger`
    will not be undone when the triggering condition is no longer true. If you hadn''t
    already guessed this, the conditions that trigger the `EventTrigger` instances
    are events, or `RoutedEvent` objects more specifically. Let''s investigate this
    type of trigger first with a simple example that we saw in the [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与其他触发器不同，`EventTrigger`类没有状态终止的概念。这意味着当触发条件不再为真时，`EventTrigger`应用的动作不会被撤销。如果你还没有猜到这一点，触发`EventTrigger`实例的条件是事件，或者更具体地说，是`RoutedEvent`对象。让我们首先通过一个简单的例子来研究这种类型的触发器，这个例子我们在[第4章](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml)中看到过，*精通数据绑定*：
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In this example, the trigger condition is met when the `FrameworkElement.Loaded`
    event is raised. The action that is applied is the start of the declared animation.
    Note that the `BeginStoryboard` class actually extends the `TriggerAction` class
    and this explains how we are able to declare it within the trigger. This action
    will be implicitly added into the `TriggerActionCollection` of the `EventTrigger`
    object, although we could have explicitly set it as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，当`FrameworkElement.Loaded`事件被触发时，触发条件得到满足。应用的动作是声明动画的开始。请注意，`BeginStoryboard`类实际上扩展了`TriggerAction`类，这解释了为什么我们能够在触发器中声明它。此动作将被隐式添加到`EventTrigger`对象的`TriggerActionCollection`中，尽管我们也可以显式设置如下：
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In addition to the `EventTrigger` class, there are also `Trigger`, `DataTrigger`,
    `MultiTrigger` and `MultiDataTrigger` classes that enable us to set properties
    or control animations when a certain condition, or multiple conditions in the
    case of the multi triggers, are met. Each has its own merits, but apart from the
    `EventTrigger` class, which can be used in any trigger collection, there are some
    restrictions on where we can use them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`EventTrigger`类之外，还有`Trigger`、`DataTrigger`、`MultiTrigger`和`MultiDataTrigger`类，使我们能够在满足特定条件或多个条件（在多触发器的情况下）时设置属性或控制动画。每个都有其优点，但除了可以在任何触发器集合中使用的`EventTrigger`类之外，还有一些限制我们可以在哪里使用它们。
- en: Each control that extends the `FrameworkElement` class has a `Triggers` property
    of type `TriggerCollection`, that enable us to specify our triggers. However,
    if you've ever tried to declare a trigger there, then you're probably aware that
    we are only allowed to define triggers of type `EventTrigger` there.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 每个扩展`FrameworkElement`类的控件都有一个`Triggers`属性，其类型为`TriggerCollection`，使我们能够指定我们的触发器。然而，如果你曾经尝试在那里声明触发器，那么你可能已经意识到我们只能在那里定义`EventTrigger`类型的触发器。
- en: However, there are further trigger collections that we can use to declare our
    other types of triggers. When defining a `ControlTemplate`, we have access to
    the `ControlTemplate.Triggers` collection. For all other requirements, we can
    declare our other triggers in the `Style.Triggers` collection. Remember that triggers
    defined in styles have a higher priority than those declared in templates.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还可以使用其他触发器集合来声明我们的其他类型触发器。当定义`ControlTemplate`时，我们可以访问`ControlTemplate.Triggers`集合。对于所有其他需求，我们可以在`Style.Triggers`集合中声明我们的其他触发器。记住，在样式中定义的触发器优先级高于在模板中声明的触发器。
- en: Let's now take a look at the remaining types of triggers and what they can do
    for us. We start with the most simple, the `Trigger` class. Note that anything
    that the property trigger can do, the `DataTrigger` class can also do. However,
    the property trigger syntax is simpler and does not involve data binding and so
    it is more efficient.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看剩余的触发器类型以及它们能为我们做什么。我们从最简单的`Trigger`类开始。请注意，属性触发器能做的任何事情，`DataTrigger`类也能做。然而，属性触发器的语法更简单，不涉及数据绑定，因此更高效。
- en: There are, however, a few requirements to using a property trigger and they
    are as follows. The relevant property must be a Dependency Property. Unlike the
    `EventTrigger` class, the other triggers do not specify actions to be applied
    when the trigger condition is met, but property setters instead.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用属性触发器有一些要求，如下所示。相关的属性必须是依赖属性。与`EventTrigger`类不同，其他触发器不指定在触发条件满足时应用的动作，而是属性设置器。
- en: 'We are able to specify one or more `Setter` objects within each `Trigger` object
    and they will also be implicitly added to the trigger''s `Setters` property collection
    if we do not explicitly specify it. Note that also unlike the `EventTrigger` class,
    all other triggers will return the original property value when the trigger condition
    is no longer satisfied. Let''s look at a simple example:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在每个`Trigger`对象中指定一个或多个`Setter`对象，如果未明确指定，它们也将隐式添加到触发器的`Setters`属性集合中。请注意，与`EventTrigger`类不同，所有其他触发器在触发条件不再满足时都将返回原始属性值。让我们看一个简单的例子：
- en: '[PRE57]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here we have a button that will change the color of its text when the user mouse
    s over it. Unlike the `EventTrigger` however, its text color will return to its
    previously set color when the mouse is no longer over the button. Note also that
    property triggers use the properties of the controls that they are declared in
    for their conditions, as they have no way of specifying any other target.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个按钮，当用户鼠标悬停在其上时，其文本颜色会改变。然而，与`EventTrigger`不同，当鼠标不再悬停在按钮上时，其文本颜色将返回到之前设置的颜色。请注意，属性触发器使用它们声明的控件的属性作为它们的条件，因为它们没有其他目标可以指定。
- en: 'As previously mentioned, the `DataTrigger` class can also perform this same
    binding. Let''s see what that might look like:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`DataTrigger`类也可以执行相同的绑定。让我们看看它可能的样子：
- en: '[PRE58]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, when using a `DataTrigger`, instead of setting the `Property`
    property of the `Trigger` class, we need to set the `Binding` property instead.
    In order to achieve the same functionality as the property trigger, we also need
    to specify the `RelativeSource.Self` enumeration member to set the binding source
    to the control that is declaring the trigger.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当使用`DataTrigger`时，我们不需要设置`Trigger`类的`Property`属性，而是需要设置`Binding`属性。为了实现与属性触发器相同的功能，我们还需要指定`RelativeSource.Self`枚举成员，以将绑定源设置为声明触发器的控件。
- en: 'The general rule of thumb is that when we are able to use a simple property
    trigger that uses a property of the host control in its condition, we should use
    the `Trigger` class. When we need to use a property of another control, or a data
    object in our trigger condition, we should use a `DataTrigger`. Let''s look at
    an interesting practical example now:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的规则是，当我们能够使用一个简单的属性触发器，该触发器使用宿主控件的属性在其条件中时，我们应该使用`Trigger`类。当我们需要使用另一个控件的属性或触发条件中的数据对象时，我们应该使用`DataTrigger`。现在让我们来看一个有趣的实际例子：
- en: '[PRE59]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this style, we added a `DataTrigger` element that data binds to an `IsEditable`
    property that we could declare in a View Model class, that would determine whether
    the users could edit the data in the controls on screen or not. This would assume
    that an instance of the View Model was correctly set as the `UserControl.DataContext`
    property.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种风格中，我们添加了一个`DataTrigger`元素，该元素数据绑定到一个在视图模型类中声明的`IsEditable`属性，这将确定用户是否可以编辑屏幕上的控件中的数据。这假设视图模型实例已正确设置为`UserControl.DataContext`属性。
- en: If the value of the `IsEditable` property was `false`, then the `TextBox.IsReadOnly`
    property would be set to `true` and the control would become un-editable. Using
    this technique, we could make all of the controls in a form editable or un-editable
    by setting this property from the View Model.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`IsEditable`属性的值为`false`，则`TextBox.IsReadOnly`属性将被设置为`true`，控件将变为不可编辑。使用这种技术，我们可以通过从视图模型设置此属性来使表单中的所有控件可编辑或不可编辑。
- en: 'The triggers that we have looked at so far have all used a single condition
    to trigger their actions or property changes. However, there are occasionally
    situations when we might need more than a single condition to trigger our property
    changes. For example, in one situation, we might want one particular style, and
    in another situation, we might want a different look. Let''s see an example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前查看的触发器都使用了单个条件来触发它们的操作或属性更改。然而，偶尔我们可能需要多个条件来触发我们的属性更改。例如，在一种情况下，我们可能想要一种特定的样式，而在另一种情况下，我们可能想要不同的外观。让我们看一个例子：
- en: '[PRE60]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, we have two triggers. The first will change the button text
    to red when the mouse is over it. The second will change the button text to green
    if the mouse is over it *and* the button is focused.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个触发器。第一个会在鼠标悬停在按钮上时将其文本颜色变为红色。第二个如果鼠标悬停在按钮上并且按钮被聚焦时，会将按钮文本颜色变为绿色。
- en: Note that we had to declare the two triggers in this order, as triggers are
    applied from top to bottom. Had we swapped their order, then the text would never
    change to green because the single trigger would always override the value set
    by the first one.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须按照这个顺序声明这两个触发器，因为触发器是从上到下应用的。如果我们交换它们的顺序，那么文本永远不会变成绿色，因为单个触发器总是会覆盖第一个触发器设置的值。
- en: We can specify as many `Condition` elements as we need within the `Conditions`
    collection and as many setters as we need within the `MultiTrigger` element itself.
    However, every condition must return true in order for the setters or other trigger
    actions to be applied.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Conditions`集合中指定所需数量的`Condition`元素，并在`MultiTrigger`元素本身中指定所需数量的设置器。然而，每个条件都必须返回true，才能应用设置器或其他触发器操作。
- en: 'The same can be said for the last trigger type to be introduced here, the `MultiDataTrigger`.
    The difference between this trigger and the previous one is the same as that between
    the property trigger and the data trigger. That is, the data and multi-data triggers
    have a much wider range of target sources, while triggers and multi triggers only
    work with properties of the local control:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这里将要介绍的最后一个触发器类型，即`MultiDataTrigger`，也可以说同样的话。这个触发器与上一个触发器之间的区别与属性触发器和数据触发器之间的区别相同。也就是说，数据和多数据触发器具有更广泛的目标源范围，而触发器和多触发器仅与本地控件的属性一起工作：
- en: '[PRE61]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This example demonstrates the wider reach of the `MultiDataTrigger` class, due
    to its access to the wide range of binding sources. We have a `Show Errors` checkbox,
    a `No Errors` textblock, and let's say, some other form fields that are not displayed
    here. One of the conditions of this trigger uses the `ElementName` property to
    set the binding source to the checkbox and requires it to be checked.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了`MultiDataTrigger`类的更广泛的应用范围，这是由于其可以访问广泛的绑定源。我们有一个`显示错误`的复选框，一个`无错误`的文本块，以及一些其他表单字段，这里没有显示。这个触发器的其中一个条件使用`ElementName`属性将绑定源设置为复选框，并要求它被勾选。
- en: The other condition binds to an `IsValid` property from our View Model that
    would be set to `true` if there were no validation errors. The idea is that when
    the checkbox is checked and there are validation errors, the `Text` property of
    the `TextBlock` element will be data bound to another View Model property named
    `ErrorList`, which could output a description of the validation errors.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个条件绑定到我们的视图模型中的`IsValid`属性，如果没有验证错误，则该属性会被设置为`true`。其思路是，当复选框被勾选且存在验证错误时，`TextBlock`元素的`Text`属性将数据绑定到另一个名为`ErrorList`的视图模型属性，该属性可以输出验证错误的描述。
- en: Also note that in this example, we explicitly declared the `Setters` collection
    property and defined our setter within it. However, that is optional and we could
    have implicitly added the setter to the same collection without declaring the
    collection, as shown in the previous `MultiTrigger` example.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在这个例子中，我们明确声明了`Setters`集合属性并在其中定义了我们的设置器。然而，这是可选的，我们可以在不声明集合的情况下隐式地将设置器添加到同一个集合中，就像之前的`MultiTrigger`例子所示。
- en: Before moving onto the next topic, let's take a moment to investigate the `EnterActions`
    and `ExitActions` properties of the `TriggerBase` class that enable us to specify
    one or more `TriggerAction` objects to apply when the trigger becomes active and/or
    inactive respectively.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一个主题之前，让我们花点时间研究一下`TriggerBase`类的`EnterActions`和`ExitActions`属性，这些属性使我们能够指定一个或多个`TriggerAction`对象，在触发器变为活动状态和/或非活动状态时应用。
- en: 'Note that we cannot specify style setters in these collections, as they are
    not `TriggerAction` objects; setters can be added to the `Setters` collection.
    Instead, we use these properties to start animations when the trigger becomes
    active and/or inactive. To do that, we need to add a `BeginStoryboard` element,
    which extends the `TriggerAction` class. Let''s see an example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法在这些集合中指定样式设置器，因为它们不是`TriggerAction`对象；设置器可以添加到`Setters`集合中。相反，我们使用这些属性在触发器变为活动状态和/或非活动状态时启动动画。为此，我们需要添加一个`BeginStoryboard`元素，它扩展了`TriggerAction`类。让我们看一个例子：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this example, the `Trigger` condition relates to the `IsMouseOver` property
    of the `TextBox` control. Note that declaring our animations in the `EnterActions`
    and `ExitActions` properties when using the `IsMouseOver` property is effectively
    the same as having two `EventTrigger` elements, one for the `MouseEnter` event
    and one for `MouseLeave` event.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Trigger`条件与`TextBox`控件的`IsMouseOver`属性相关。请注意，当使用`IsMouseOver`属性时，在`EnterActions`和`ExitActions`属性中声明我们的动画实际上等同于有两个`EventTrigger`元素，一个用于`MouseEnter`事件，另一个用于`MouseLeave`事件。
- en: In this example, the animation in the `EnterActions` collection will start as
    the user's mouse cursor enters the control and the animation in the `ExitActions`
    collection will start as the user's mouse cursor leaves the control.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`EnterActions`集合中的动画将在用户的鼠标光标进入控件时开始，而`ExitActions`集合中的动画将在用户的鼠标光标离开控件时开始。
- en: We'll thoroughly cover animations later, in [Chapter 7](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml),
    *Mastering Practical Animations*, but in short, the animation that starts as the
    user's mouse cursor enters the control will fade in the control from being almost
    transparent to being opaque.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第7章[掌握实用动画](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml)中详细讲解动画，但简而言之，当用户的鼠标光标进入控件时开始的动画，将使控件从几乎透明渐变到不透明。
- en: The other animation will return the `TextBox` control to an almost transparent
    state when the user's mouse cursor leaves the control. This creates a nice effect
    when a mouse is dragged over a number of controls with this style. Now that we
    have a good understanding of triggers, let's move on to find other ways of customizing
    the standard .NET controls.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个动画将在用户鼠标光标离开控件时将`TextBox`控件恢复到几乎透明状态。当鼠标拖动到具有这种样式的多个控件上时，这会产生一个很好的效果。现在我们已经很好地理解了触发器，让我们继续寻找其他自定义标准.NET控件的方法。
- en: Templating controls
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控件模板化
- en: While we can greatly vary the look of each control using styles alone, there
    are occasionally situations when we need to alter their template to achieve our
    goal. For example, there is no direct way to change the background color of a
    button through styles alone. In these situations, we need to alter the control's
    default template.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过样式极大地改变每个控件的外观，但有时我们需要改变它们的模板以达到我们的目标。例如，没有直接的方法仅通过样式来改变按钮的背景颜色。在这些情况下，我们需要更改控件的默认模板。
- en: 'All UI elements that extend the `Control` class provide access to its `Template`
    property. This property is of type `ControlTemplate` and enables us to completely
    replace the originally declared template that defines the normal look of the control.
    We saw a simple example in the [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml), *Becoming
    Proficient with Data Binding*, but let''s now have a look at another example:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 所有扩展`Control`类的UI元素都提供了对其`Template`属性的访问。这个属性是`ControlTemplate`类型，使我们能够完全替换原来声明的模板，该模板定义了控件的正常外观。我们在[第4章](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml)中看到了一个简单的例子，即**精通数据绑定**，但现在让我们看看另一个例子：
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we have a button that we have altered to look like a circle. It is very
    basic, as we have not bothered to define any mouseover or click effects, but it
    shows that there is nothing scary about overriding the default template of a control
    and that it is simple to achieve:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个我们改变成圆形样式的按钮。它非常基础，因为我们没有费心定义任何鼠标悬停或点击效果，但它表明覆盖控件的默认模板并没有什么可怕之处，而且实现起来很简单：
- en: '![](img/7b728e6a-0fac-480f-9952-0addb06bb33a.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b728e6a-0fac-480f-9952-0addb06bb33a.png)'
- en: Note that the `ContentPresenter` element is declared after the `Ellipse` element
    because the ellipse is not a content control and cannot have another element set
    as its content. This results in the content being drawn on top of the ellipse.
    A side effect of this is that we therefore need to add a panel inside the template,
    to enable us to provide more than a single piece of content.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ContentPresenter`元素是在`Ellipse`元素之后声明的，因为椭圆不是一个内容控件，不能将另一个元素设置为它的内容。这导致内容被绘制在椭圆的上方。这个副作用是我们因此需要在模板内部添加一个面板，以便我们能够提供不止一个内容片段。
- en: Also note that as with styles, we need to specify the `TargetType` property
    of the template. To clarify this a little, we need to specify it if we want to
    data bind to any properties of the control, or if the template contains a `ContentPresenter`
    element. Omitting this declaration will not raise a compilation error in the latter
    case, but the content will simply not appear in our templated control. It is therefore
    good practice to always set this property to the appropriate type.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，与样式一样，我们需要指定模板的`TargetType`属性。为了澄清这一点，如果我们想要数据绑定到控件的任何属性，或者如果模板包含一个`ContentPresenter`元素，我们需要指定它。在后者的情况下，省略此声明不会引发编译错误，但内容将不会出现在我们的模板控件中。因此，始终将此属性设置为适当的类型是一个好习惯。
- en: 'However, unlike styles, if we declared a `ControlTemplate` and set its `TargetType`
    property in a `Resources` collection without specifying the `x:Key` directive,
    it would not be implicitly applied to all buttons in the application. In this
    case, we would receive a compilation error:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与样式不同，如果我们声明了一个`ControlTemplate`并在`Resources`集合中设置了其`TargetType`属性，但没有指定`x:Key`指令，则它不会隐式应用于应用程序中的所有按钮。在这种情况下，我们会收到一个编译错误：
- en: '[PRE64]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Instead, we need to set the `x:Key` directive and explicitly apply the template
    to the `Template` property of the control. If we want our template to be applied
    to every control of that type then we need to set it in the default style for
    that type. In this case, we need to *not* set the `x:Key` directive of the style,
    so that it will be implicitly applied:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要设置`x:Key`指令并显式地将模板应用于控件的`Template`属性。如果我们希望我们的模板应用于该类型的每个控件，那么我们需要将其设置在该类型的默认样式上。在这种情况下，我们需要*不*设置样式的`x:Key`指令，这样它就会隐式应用：
- en: '[PRE65]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Note that we would not typically hard code property values as we did in this
    template example, unless we did not want the users of our framework to be able
    to set their own colors on our templated controls. More often than not, we would
    make proper use of the `TemplateBinding` class to apply the values set from outside
    the control to the inner controls defined within our template:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通常不会像在这个模板示例中那样硬编码属性值，除非我们不希望我们的框架用户能够设置我们模板控件的自己的颜色。更常见的是，我们会正确使用`TemplateBinding`类来应用从控件外部设置的值到我们模板内定义的内部控件：
- en: '[PRE66]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: While this example is now far more verbose, it is also more practical and would
    enable users to set their own button properties. Setting this template in a default
    style would make the templated control far more reusable. Note that now, the hard
    coded values are made on the button control itself, with the exception of the
    `StrokeThickness` property.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子现在更加冗长，但它也更加实用，并使用户能够设置自己的按钮属性。在默认样式中设置此模板会使模板控件更加可重用。请注意，现在，硬编码的值是在按钮控件本身上进行的，除了`StrokeThickness`属性之外。
- en: 'There is no suitable property on the `Button` class that we could use to expose
    this inner control property. If this was a problem for us, we could expose the
    value of that property in a custom Attached Property and data bind to it on the
    button as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Button`类上没有合适的属性，我们可以用它来公开这个内部控件属性。如果这对我们来说是个问题，我们可以在自定义附加属性中公开该属性的值，并在按钮上绑定到它，如下所示：
- en: '[PRE67]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And we could do the following inside the control template:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在控件模板内部执行以下操作：
- en: '[PRE68]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: However, even though we have improved our template, there are certain elements
    defined in the default templates that affect the way their containing controls
    look or work. If we remove these elements, as we have done in the preceding example,
    we will break that default functionality. For example, our example button no longer
    has focusing or interaction effects.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我们已经改进了我们的模板，但默认模板中定义的一些元素会影响其包含控件的看起来或工作方式。如果我们移除了这些元素，就像我们在前面的示例中所做的那样，我们将破坏默认功能。例如，我们的示例按钮不再具有聚焦或交互效果。
- en: Sometimes, we may only need to slightly adjust the original template, in which
    case, we would typically start with the default `ControlTemplate` and then make
    our slight adjustment to it. If we had done this with our button example and simply
    replaced the visual aspects, then we could have retained the original interactivity
    with it.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能只需要稍微调整原始模板，在这种情况下，我们通常会从默认的`ControlTemplate`开始，然后对其进行轻微调整。如果我们对我们的按钮示例做了这样的处理，仅仅替换了视觉方面，那么我们就可以保留其原始的交互性。
- en: In days gone by, it could be quite difficult to find the default control templates
    for the various controls. We would previously need to try and track them down
    on the [docs.microsoft.com](http://docs.microsoft.com) website, or use Blend;
    now, however, we can use Visual Studio to provide it for us.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的日子里，找到各种控件默认的控制模板可能相当困难。我们之前需要尝试在 [docs.microsoft.com](http://docs.microsoft.com)
    网站上追踪它们，或者使用 Blend；然而，现在我们可以使用 Visual Studio 来为我们提供它。
- en: In the WPF designer, select the relevant control, or click on it with the mouse
    in a XAML file. With the relevant control selected or focused, press the *F4*
    key on your keyboard to open the Properties window. Next, open the Miscellaneous
    category to find the Template property, or type `Template` in the search field
    at the top of the Properties window.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 设计器中，选择相关的控件，或者在 XAML 文件中用鼠标点击它。在选择了相关控件或聚焦后，按键盘上的 *F4* 键以打开属性窗口。接下来，打开“杂项”类别以找到模板属性，或者在属性窗口顶部的搜索字段中输入“模板”。
- en: 'Click on the little square to the right of the Template value field and select
    the Convert to New Resource... item in the template options tooltip. In the popup
    dialog window that appears, name the new `ControlTemplate` to be added and decide
    where you want it to be defined:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 点击模板值字段右侧的小方块，并在模板选项工具提示中选择“转换为新资源...”项。在出现的弹出对话框窗口中，为新添加的 `ControlTemplate`
    命名，并决定你希望它在何处定义：
- en: '![](img/ba4093df-71fa-4c6f-a565-632761fa496b.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba4093df-71fa-4c6f-a565-632761fa496b.png)'
- en: 'Once you have entered the required details, click the OK button to create a
    copy of the default template of your selected control in your desired location.
    As an example, let''s take a look at the default control template of the `TextBox`
    control:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入了所需的详细信息，点击“确定”按钮以在所需位置创建所选控件默认模板的副本。例如，让我们看看 `TextBox` 控件的默认控件模板：
- en: '[PRE69]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As we can see, most of the properties set on the inner controls have been exposed
    to the `TextBox` control through the use of the `TemplateBinding` class. At the
    end of the template are the triggers that react to various states, such as focus,
    mouseover, and enabled states.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，大多数设置在内部控件上的属性都通过使用 `TemplateBinding` 类暴露给了 `TextBox` 控件。在模板的末尾是响应各种状态（如焦点、鼠标悬停和启用状态）的触发器。
- en: However, inside the `Border` element, we see a `ScrollViewer` named `PART_ContentHost`.
    The fact that this is named with the `PART_` prefix specifies that this control
    is required within this template. All named parts of each UI element will be listed
    on the *[ControlType] Styles and Templates* pages on [docs.microsoft.com](http://www.docs.microsoft.com).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 `Border` 元素内部，我们看到一个名为 `PART_ContentHost` 的 `ScrollViewer`。这个以 `PART_`
    前缀命名的现实表明这个控件必须在这个模板中使用。每个 UI 元素的每个命名部分都将列在 [docs.microsoft.com](http://www.docs.microsoft.com)
    的 *[ControlType] 样式和模板* 页面上。
- en: This named part control is required in the textbox because when the textbox
    is initialized, it programmatically adds the `TextBoxView` and `CaretElement`
    objects into the `ScrollViewer` object and these are the predominant elements
    that make up the textbox's functionality.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命名的部分控件在文本框中是必需的，因为当文本框初始化时，它会将 `TextBoxView` 和 `CaretElement` 对象程序化地添加到 `ScrollViewer`
    对象中，这些是构成文本框功能的主要元素。
- en: These specially named elements also need to be registered within the declaring
    class and we'll find out more about that later in the chapter as well. It is therefore
    important that we include these named controls in our custom templates if we want
    to keep the existing functionality.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特别命名的元素也需要在声明类中进行注册，我们将在本章后面了解更多关于这一点。因此，如果我们想保持现有功能，我们很重要地将这些命名控件包含在我们的自定义模板中。
- en: 'Note that we will not receive any compilation errors or even trace warnings
    if we do not include these named controls, and we are free to leave them out if
    we do not require their relevant functionality. This following example, while
    hardly functional, it still perfectly valid:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们不包括这些命名的控件，我们将不会收到任何编译错误，甚至不会有跟踪警告，并且如果我们不需要它们的相关功能，我们可以自由地省略它们。以下示例虽然几乎不起作用，但仍然完全有效：
- en: '[PRE70]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Although this `TextBox` control will indeed display the specified text value,
    it will have no containing box like a normal `TextBox` element would. What will
    happen when this template is rendered is that the `ContentPresenter` element will
    see a `string` and default to displaying it in a `TextBlock` element.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个`TextBox`控件确实会显示指定的文本值，但它将没有像正常`TextBox`元素那样的容器。当这个模板被渲染时，`ContentPresenter`元素将看到一个`string`并默认在`TextBlock`元素中显示它。
- en: Its `Text` property will still be data bound to the `Text` property of our `TextBox` control
    and so, when focused, it will still behave like a normal `TextBox` element and
    enable us to enter text. Of course, we won't see when it's focused because we
    didn't add any triggers to make that happen, and there won't be a caret as the
    `CaretElement` object will no longer be added.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 它的`Text`属性仍然绑定到我们的`TextBox`控件的`Text`属性，因此当它获得焦点时，它仍然会像正常的`TextBox`元素一样表现，并允许我们输入文本。当然，我们不会看到它获得焦点，因为我们没有添加任何触发器来实现这一点，并且不会出现光标，因为`CaretElement`对象将不再被添加。
- en: 'Instead, if we simply supply the required named control, even without anything
    else, we''ll still regain most of the original functionality:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们仅仅提供所需的命名控件，即使没有任何其他内容，我们仍然可以恢复大部分原始功能：
- en: '[PRE71]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now, when we run our application, we have the caret and text cursor when the
    mouse is over the `TextBox` control, and so we have regained more of the functionality,
    but not the look. However usually, the best option is to keep as much of the original
    template as we can and only change the parts that we really need to.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行我们的应用程序时，当鼠标悬停在`TextBox`控件上时，我们将有光标和文本光标，因此我们恢复了更多的功能，但不是外观。然而，通常最好的选择是尽可能保留原始模板，只更改我们真正需要更改的部分。
- en: Attaching properties
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加属性
- en: When using WPF, we have one further tool at our disposal to enable us to manipulate
    the built-in controls and avoid the need to create new ones. We are, of course,
    discussing Attached Properties, so let's extend an example that we started looking
    at in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml), *Becoming Proficient
    with Data Binding*.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用WPF时，我们还有一个额外的工具可以用来操作内置控件并避免创建新的控件。我们当然是在讨论附加属性，所以让我们扩展一个我们在[第4章](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml)，“精通数据绑定”中开始探讨的例子。
- en: 'In order to create a button that will enable us to set a second tooltip message
    to display when the control is disabled, we''ll need to declare two Attached Properties.
    One will hold the disabled tooltip message and the other will be the previously
    mentioned read-only property that temporarily holds onto the original tooltip
    value. Let''s look at our full `ButtonProperties` class now:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个按钮，使我们能够设置当控件禁用时显示的第二个提示信息，我们需要声明两个附加属性。一个将保存禁用时的提示信息，另一个将是之前提到的只读属性，它暂时保存原始提示值。现在让我们看看完整的`ButtonProperties`类：
- en: '[PRE72]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As with all Attached Properties, we start with a class that extends the `DependencyObject`
    class. In this class, we first declare the read-only `originalToolTipPropertyKey`
    field using the `RegisterAttachedReadOnly` method and the `OriginalToolTipProperty`
    property and its associated CLR getter.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有附加属性一样，我们从一个扩展了`DependencyObject`类的类开始。在这个类中，我们首先使用`RegisterAttachedReadOnly`方法和`OriginalToolTipProperty`属性及其关联的CLR获取器声明只读的`originalToolTipPropertyKey`字段。
- en: Next, we use the `RegisterAttached` method to register the `DisabledToolTip`
    property that will hold the value of the tooltip to be displayed when the control
    is disabled. We then see its CLR getter and setter methods and its all-important
    `PropertyChangedCallback` handling method.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`RegisterAttached`方法注册`DisabledToolTip`属性，该属性将保存当控件禁用时显示的提示信息。然后我们看到它的CLR获取器和设置方法以及至关重要的`PropertyChangedCallback`处理方法。
- en: In the `OnDisabledToolTipChanged` method, we first cast the `dependencyObject`
    input parameter to its actual type of `Button`. We then use it to set the `ToolTipService.SetShowOnDisabled`
    Attached Property to `true`, which is required because we want the button's tooltip
    to be displayed when the button is disabled. The default value is `false`, so
    our Attached Property would not work without this step.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnDisabledToolTipChanged`方法中，我们首先将`dependencyObject`输入参数转换为其实际类型`Button`。然后我们使用它来设置`ToolTipService.SetShowOnDisabled`附加属性为`true`，这是必需的，因为我们希望按钮的提示信息在按钮禁用时显示。默认值是`false`，所以没有这一步我们的附加属性将不会工作。
- en: Next, we determine whether we need to attach or detach the `Button_IsEnabledChanged`
    event-handling method depending on the `NewValue` and `OldValue` property values
    of the `DependencyPropertyChangedEventArgs` object. If the old value is `null`,
    then the property has not been set before and we need to attach the handler; if
    the new value is `null`, then we need to detach the handler.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据 `DependencyPropertyChangedEventArgs` 对象的 `NewValue` 和 `OldValue` 属性值确定是否需要附加或分离
    `Button_IsEnabledChanged` 事件处理方法。如果旧值是 `null`，则属性之前尚未设置，我们需要附加处理程序；如果新值是 `null`，则我们需要分离处理程序。
- en: In the `Button_IsEnabledChanged` event-handling method, we first cast the `sender`
    input parameter to the `Button` type. We then use it to access the `OriginalToolTip`
    property and if it is `null`, we set it with the current value from the control's
    normal `ToolTip` property. Note that we need to pass the `originalToolTipPropertyKey`
    field into the `SetValue` method, as it is a read-only property.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Button_IsEnabledChanged` 事件处理方法中，我们首先将 `sender` 输入参数转换为 `Button` 类型。然后我们使用它来访问
    `OriginalToolTip` 属性，如果它是 `null`，我们就使用控制器的正常 `ToolTip` 属性的当前值来设置它。请注意，我们需要将 `originalToolTipPropertyKey`
    字段传递给 `SetValue` 方法，因为它是一个只读属性。
- en: 'Finally, we utilize the `e.NewValue` property value to determine whether to
    set the original tooltip or the disabled tooltip into the control''s normal `ToolTip`
    property. Therefore, if the control is enabled, the `e.NewValue` property value
    will be `true` and the original tooltip will be returned; if the button is disabled,
    the disabled tooltip will be displayed. We could use this Attached Property as
    follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们利用 `e.NewValue` 属性值来确定是否将原始提示或禁用提示设置为控制器的正常 `ToolTip` 属性。因此，如果控制器处于启用状态，`e.NewValue`
    属性值将是 `true`，并返回原始提示；如果按钮被禁用，则显示禁用提示。我们可以如下使用这个附加属性：
- en: '[PRE73]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As can be seen from this simple example, Attached Properties enable us to easily
    add new functionality to the existing suite of UI controls. This again highlights
    how versatile WPF is and demonstrates that we often have no need to create completely
    new controls.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单的示例所示，附加属性使我们能够轻松地向现有的 UI 控件系列添加新功能。这再次突出了 WPF 的多功能性，并证明了我们通常没有必要创建全新的控件。
- en: Combining controls
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合控制
- en: When we need to arrange a number of existing controls in a particular way, we
    typically use a `UserControl` object. This is why we normally use this type of
    control to build our Views. However, when we need to build a reusable control,
    such as an address control, we tend to separate these from our Views, by declaring
    them in a `Controls` folder and namespace within our Views project.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要以特定方式排列多个现有控件时，我们通常使用 `UserControl` 对象。这就是为什么我们通常使用这种类型的控件来构建我们的视图。然而，当我们需要构建一个可重用控件，例如地址控件时，我们倾向于将它们与我们的视图分开，通过在视图项目中
    `Controls` 文件夹和命名空间内声明它们来实现。
- en: 'When declaring these reusable controls, it is customary to define Dependency
    Properties in the code behind and as long as there is no business-related functionality
    in the control, it is also OK to use the code behind to handle events. If the
    control is business-related, then we can use a View Model as we do with normal
    Views. Let''s take a look at an example of an address control:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明这些可重用控件时，通常在代码后定义依赖属性，只要控件中没有业务相关的功能，也可以使用代码后处理事件。如果控件与业务相关，则可以使用与正常视图相同的视图模型。让我们看看地址控件的一个示例：
- en: '[PRE74]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this example, we declare this class within the `Controls` namespace and set
    up a XAML namespace prefix for it. We then see the `Grid` panel that is used to
    layout the address controls and notice that the `SharedSizeGroup` property is
    set on the `ColumnDefinition` element that defines the label column. This will
    enable the column sizes within this control to be shared with externally declared
    controls.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在 `Controls` 命名空间内声明这个类，并为它设置一个 XAML 命名空间前缀。然后我们看到用于布局地址控件的 `Grid`
    面板，并注意到 `SharedSizeGroup` 属性被设置在定义标签列的 `ColumnDefinition` 元素上。这将使此控件内的列大小可以与外部声明的控件共享。
- en: We then see all of the `TextBlock` and `TextBox` controls that are data bound
    to the control's address fields. There's not much to note here except that the
    data bound properties are all accessed through a `RelativeSource` binding to an
    `Address` Dependency Property that is declared in the code behind file of the
    `AddressControl`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来看到所有绑定到控制器地址字段的数据绑定 `TextBlock` 和 `TextBox` 控件。这里没有太多需要注意的，除了数据绑定属性都是通过一个
    `RelativeSource` 绑定到一个在 `AddressControl` 代码后文件中声明的 `Address` 依赖属性来访问的。
- en: 'Remember that it''s fine to do this when using MVVM as long as we are not encapsulating
    any business rules here. Our control merely enables the users to input or add
    address information, which will be used by various Views and View Models. Let''s
    see this property now:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在使用 MVVM 模式时，只要我们不在这里封装任何业务规则，这样做是可以的。我们的控件仅仅允许用户输入或添加地址信息，这些信息将被各种视图和视图模型使用。现在让我们看看这个属性：
- en: '[PRE75]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is a very simple control with just one Dependency Property. We can see
    that the `Address` property is of type `Address`, so let''s have a quick look
    at that class next:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的控件，只有一个依赖属性。我们可以看到 `Address` 属性是 `Address` 类型，所以让我们快速看一下这个类：
- en: '[PRE76]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Again, we have a very simple class that is primarily made up from the address
    related properties. Note the use of the String Interpolation in the overridden
    `ToString` method to output a useful display of the class contents. Now we''ve
    seen the control, let''s take a look at how we can use it in our application.
    We can edit a View that we saw earlier, so let''s see the updated `UserView` XAML
    now:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是一个主要由地址相关属性组成的非常简单的类。注意在重写的 `ToString` 方法中使用字符串插值来输出有用的类内容。现在我们已经看到了控件，让我们看看我们如何在应用程序中使用它。我们可以编辑我们之前看到的视图，所以现在让我们看看更新的
    `UserView` XAML：
- en: '[PRE77]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this example, we can see the use of the `Grid.IsSharedSizeScope` property
    on the outermost `Grid` panel. Remember that the `SharedSizeGroup` property was
    set in the `AddressControl` XAML, although without this setting on the outer `Grid`,
    it does nothing by itself.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到在最外层的 `Grid` 面板上使用 `Grid.IsSharedSizeScope` 属性。记住，在 `AddressControl`
    XAML 中设置了 `SharedSizeGroup` 属性，尽管在没有在外部的 `Grid` 上设置此设置的情况下，它本身不会做任何事情。
- en: Looking at the outer panel's column definitions, we can see that we have also
    set the `SharedSizeGroup` property to the same value of `Label` on the left column
    so that the two panels' columns will be aligned.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下外部面板的列定义，我们可以看到我们还设置了 `SharedSizeGroup` 属性，使其与左侧列上的 `Label` 的相同值，以便两个面板的列对齐。
- en: We can skip over the two styles that are declared in the panel's `Resources`
    section as in a proper application, these would most likely reside in the application
    resources file. In the remainder of the View, we simply have a couple of rows
    of user properties and then `AddressControl`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以跳过在面板的 `Resources` 部分声明的两个样式，因为在正确应用中，这些样式很可能位于应用程序资源文件中。在视图的其余部分，我们只有几行用户属性，然后是
    `AddressControl`。
- en: This code assumes that we have declared an `Address` property of type `Address`
    in our `User` class and populated it with suitable values in the `UserViewModel`
    class. Note how we data bind the `Address` property of the `User` class to the
    `Address` property of the control, rather than setting the `DataContext` property.
    As the control's internal controls are data bound using `RelativeSource` bindings,
    which specify their own binding source, they do not require any `DataContext`
    to be set. In fact, doing so in this example would stop it from working.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码假设我们在 `User` 类中声明了一个类型为 `Address` 的 `Address` 属性，并在 `UserViewModel` 类中用合适的值填充了它。注意我们如何将
    `User` 类的 `Address` 属性数据绑定到控件的 `Address` 属性，而不是设置 `DataContext` 属性。由于控件的内部控件使用
    `RelativeSource` 绑定进行数据绑定，这些绑定指定了它们自己的绑定源，因此它们不需要设置任何 `DataContext`。实际上，在这个例子中这样做会阻止它工作。
- en: Creating custom controls
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义控件
- en: When using WPF, we can generally create the UI that we want using the many techniques
    already discussed in this book. However, in the cases where we require a totally
    unique control with both a custom drawn appearance and custom functionality, then
    we may need to declare a custom control.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 WPF 时，我们可以使用本书中已经讨论过的许多技术来创建我们想要的 UI。然而，在需要具有自定义绘制外观和自定义功能的独特控件的情况下，我们可能需要声明一个自定义控件。
- en: Developing custom controls is very different than creating `UserControl` elements
    and it can take some time to master this. To start with, we will need to add a
    new project of type WPF Custom Control Library to declare them in. Also, instead
    of having a XAML page and a code behind file, we only have the code file. At this
    point, you may be wondering where we define what our control should look like.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 开发自定义控件与创建 `UserControl` 元素非常不同，掌握这一技能可能需要一些时间。首先，我们需要添加一个新的项目，类型为 WPF 自定义控件库，以便在其中声明它们。此外，我们只有代码文件，而没有
    XAML 页面和代码后文件。在这个阶段，你可能想知道我们将在哪里定义我们的控件的外观。
- en: In fact, when defining a custom control, we declare our XAML in a separate file
    named `Generic.xaml`, which is added by Visual Studio when we add our controls
    project. To clarify, the XAML for all of the custom controls that we declare in
    this project will go into this file. This does not relate to controls that extend
    the `UserControl` class and we should not declare those in this project.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在定义自定义控件时，我们在一个名为`Generic.xaml`的单独文件中声明我们的XAML，这是Visual Studio在我们添加控件项目时添加的。为了澄清，我们在这个项目中声明的所有自定义控件的XAML都将放入这个文件中。这并不涉及扩展`UserControl`类的控件，我们不应该在这个项目中声明这些控件。
- en: This `Generic.xaml` file gets added into a folder named `Themes` in the root
    directory of our WPF Custom Control Library project, as this is where the Framework
    will look for the default styles of our custom controls. As such, we must declare
    the UI design of our control in a `ControlTemplate` and set it to the `Template`
    property in a style that targets the type of our control in this file.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Generic.xaml`文件被添加到我们的WPF自定义控件库项目的根目录下的`Themes`文件夹中，因为框架将在这里查找我们自定义控件的默认样式。因此，我们必须在这个文件中声明控件的UI设计，并将其设置为针对该文件中我们控件类型的样式的`Template`属性。
- en: The style must be applied to all instances of our control and so the style is
    defined with the `TargetType` set, but without the `x:Key` directive. If you remember,
    this will ensure that it is implicitly applied to all instances of our control
    that don't have an alternative template explicitly applied.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 样式必须应用于我们控件的每个实例，因此样式定义时将`TargetType`设置，但不设置`x:Key`指令。如果你还记得，这将确保它隐式应用于所有没有显式应用替代模板的我们控件的实例。
- en: A further difference is that we cannot directly reference any of the controls
    that are defined within the style in the `Generic.xaml` file. If you recall, when
    we provided a new template for the built-in controls, we were under no obligation
    to provide the same controls that were originally used. Therefore, if we tried
    to access a control from our original template that had been replaced, it would
    cause an error.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不同之处在于，我们无法直接在`Generic.xaml`文件中引用在样式内定义的任何控件。如果你还记得，当我们为内置控件提供新模板时，我们没有义务提供最初使用的相同控件。因此，如果我们尝试访问已被替换的原模板中的控件，将会引发错误。
- en: Instead, we generally need to access them by overriding the `FrameworkElement.OnApplyTemplate`
    method, which is raised once a template has been applied to an instance of our
    control. In this method, we should expect that our required control(s) will be
    missing and ensure that no errors occur if that is the case.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们通常需要通过重写`FrameworkElement.OnApplyTemplate`方法来访问它们，该方法在我们控件的实例应用模板后会被触发。在这个方法中，我们应该预期所需的控件（们）可能缺失，并确保在这种情况下不会发生错误。
- en: Let's look at a simple example of a custom control that creates a meter that
    can be used to monitor CPU activity, RAM usage, audio loudness, or any other regularly
    changing value. We'll first need to create a new project of type WPF Custom Control
    Library and rename the `CustomControl1.cs` class that Visual Studio adds for us
    to `Meter.cs`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的自定义控件示例，该控件可以创建一个仪表，用于监控CPU活动、RAM使用、音频音量或任何其他定期变化的值。我们首先需要创建一个新的WPF自定义控件库类型项目，并将Visual
    Studio为我们添加的`CustomControl1.cs`类重命名为`Meter.cs`。
- en: 'Note that we can only add a custom control to a project of this type and that
    when the project is added, Visual Studio will also add our `Themes` folder and
    `Generic.xaml` file, with a style for our control already declared inside it.
    Let''s see the code in the `Meter.cs` file:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只能将自定义控件添加到这种类型的项目中，并且当项目被添加时，Visual Studio也会添加我们的`Themes`文件夹和`Generic.xaml`文件，其中已经声明了我们的控件样式。让我们看看`Meter.cs`文件中的代码：
- en: '[PRE78]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is a relatively small class, with only two Dependency Properties and their
    associated CLR property wrappers and callback handlers. Of particular note is
    the class's static constructor and the use of the `DefaultStyleKeyProperty.OverrideMetadata`
    method.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较小的类，只有两个依赖属性及其关联的CLR属性包装器和回调处理程序。特别值得注意的是类的静态构造函数和`DefaultStyleKeyProperty.OverrideMetadata`方法的用法。
- en: This is also added by Visual Studio when adding the class and is required to
    override the type-specific metadata of the `DefaultStyleKey` Dependency Property
    when we derive a custom class from the `FrameworkElement` class.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是Visual Studio在添加类时添加的，当从`FrameworkElement`类派生自定义类时，需要重写`DefaultStyleKey`依赖属性的特定类型元数据。
- en: Specifically, this key is used by the Framework to find the default theme style
    for our control and so, by passing the type of our class into the `OverrideMetadata`
    method, we are telling the Framework to look for a default style for this type
    in our `Themes` folder.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这个键被框架用来找到我们控件的默认主题样式，因此，通过将我们类的类型传递给`OverrideMetadata`方法，我们告诉框架在我们的`Themes`文件夹中查找此类型的默认样式。
- en: If you remember, the theme styles are the last place that the Framework will
    look for the style of a specific type and declaring styles just about anywhere
    else in the application will override the default styles defined here.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，主题样式是框架最后会查找特定类型样式的位置，而在应用程序的其他任何地方声明样式都将覆盖这里定义的默认样式。
- en: The first Dependency Property is the main `Value` property of the control and
    this is used to determine the size of the visible meter bar. This property defines
    a default value of `0.0` and attaches the `CoerceValue` and `OnValueChanged` callback
    handlers.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个依赖属性是控件的主要`Value`属性，它用于确定可见仪表条的大小。此属性定义了一个默认值`0.0`，并附加了`CoerceValue`和`OnValueChanged`回调处理程序。
- en: In the `CoerceValue` handling method, we ensure that the output value always
    remains between `0.0` and `1.0`, as that is the scale that we will be using. In
    the `OnValueChanged` handler, we update the value of the other Dependency Property,
    `ClipRect`, dependent upon the input value.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CoerceValue`处理方法中，我们确保输出值始终保持在`0.0`和`1.0`之间，因为这是我们将会使用的刻度。在`OnValueChanged`处理程序中，我们根据输入值更新其他依赖属性`ClipRect`的值。
- en: To do this, we first cast the `dependencyObject` input parameter to our `Meter`
    type and then pass that instance to the `SetClipRect` method. In this method,
    we calculate the relative size of the meter bar and define the `Rect` element
    for the `ClipRect` Dependency Property accordingly.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先将`dependencyObject`输入参数转换为我们的`Meter`类型，然后将该实例传递给`SetClipRect`方法。在这个方法中，我们计算仪表条的相对大小，并根据此定义`ClipRect`依赖属性的`Rect`元素。
- en: Next, we see the CLR property wrapper for the `Value` Dependency Property and
    then the declaration of the `ClipRect` Dependency Property. Note that we declare
    it using a `DependencyPropertyKey` element, thus making it a read-only property,
    because it is only for internal use and has no value in being exposed publicly.
    The actual `ClipRect` Dependency Property comes from this key element.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到`Value`依赖属性的CLR属性包装器，然后是`ClipRect`依赖属性的声明。注意，我们使用`DependencyPropertyKey`元素来声明它，因此使其成为一个只读属性，因为它仅用于内部使用，公开它没有价值。实际的`ClipRect`依赖属性来自这个键元素。
- en: After this, we see the CLR property wrapper for the `ClipRect` Dependency Property
    and then we come to the aforementioned `OnApplyTemplate` method. In our case,
    the purpose of overriding this method is because often, data bound values will
    be set before the control's template has been applied and so we would not be able
    to correctly set the size of the meter bar from those values.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看到`ClipRect`依赖属性的CLR属性包装器，然后我们来到上述的`OnApplyTemplate`方法。在我们的情况下，重写此方法的目的通常是因为数据绑定值将在控件模板应用之前被设置，因此我们无法从这些值中正确设置仪表条的大小。
- en: Therefore, when the template has been applied and the control has been arranged
    and sized, we call the `SetClipRect` method in order to set the `Rect` element
    for the `ClipRect` Dependency Property to the appropriate value. Before this point
    in time, the `Height` and `Weight` properties of the `meter` instance will be
    `double.NaN` (where *NaN* is short for *Not a Number*) and cannot be used to size
    the `Rect` element correctly.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当模板已经应用，控件已经排列和调整大小时，我们调用`SetClipRect`方法来设置`ClipRect`依赖属性的`Rect`元素为适当的值。在此时间点之前，`meter`实例的`Height`和`Weight`属性将是`double.NaN`（其中*NaN*代表*Not
    a Number*），无法正确调整`Rect`元素的大小。
- en: When this method is called, we can rest assured that the `Height` and `Weight`
    properties of the `meter` instance will have valid values. Note that had we needed
    to access any elements from our template, we could have called the `FrameworkTemplate.FindName`
    method from this method, on the `ControlTemplate` object that is specified by
    our control's `Template` property.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个方法被调用时，我们可以确信`meter`实例的`Height`和`Weight`属性将具有有效的值。注意，如果我们需要从我们的模板中访问任何元素，我们可以在指定由我们的控件的`Template`属性指定的`ControlTemplate`对象上从这个方法调用`FrameworkTemplate.FindName`方法。
- en: 'If we had named a `Rectangle` element in our XAML `PART_Rectangle`, we could
    access it from the `OnApplyTemplate` method like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在XAML中将`Rectangle`元素命名为`PART_Rectangle`，我们就可以像这样从`OnApplyTemplate`方法中访问它：
- en: '[PRE79]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note that we always need to check for `null`, because the applied template
    may be a custom template that does not contain the `Rectangle` element at all.
    Note also that when we require the existence of a particular element in the template,
    we can decorate our custom control class declaration with a `TemplatePartAttribute`,
    that specifies the details of the required control:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们始终需要检查`null`，因为应用的模板可能是一个不包含`Rectangle`元素的定制模板。同时注意，当我们需要模板中存在特定元素时，我们可以用`TemplatePartAttribute`装饰我们的定制控件类声明，以指定所需控件的详细信息：
- en: '[PRE80]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This will not enforce anything and will not raise any compilation errors if
    the named part is not included in a custom template, but it will be used in documentation
    and by various XAML tools. It helps users of our custom controls to find out which
    elements are required when they provide custom templates.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不会强制执行任何操作，也不会因为命名部分未包含在定制模板中而引发任何编译错误，但它将在文档和各种XAML工具中使用。它帮助我们的定制控件用户在提供定制模板时了解需要哪些元素。
- en: 'Now that we''ve seen the inner workings of this control, let''s take a look
    at the XAML of the default style of our control in the `Generic.xaml` file to
    see how the `ClipRect` property is used:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了这个控件的内幕工作原理，让我们看看`Generic.xaml`文件中我们控件的默认样式的XAML，以了解`ClipRect`属性是如何使用的：
- en: '[PRE81]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: When each custom control class is created in a WPF Custom Control Library project,
    Visual Studio adds an almost empty default style that sets a basic `ControlTemplate`
    and targets the type of the class into the `Generic.xaml` file. We just need to
    define our custom XAML within this template.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当在WPF Custom Control Library项目中创建每个定制控件类时，Visual Studio会在`Generic.xaml`文件中添加一个几乎为空的默认样式，该样式设置了一个基本的`ControlTemplate`并将目标类型设置为类的类型。我们只需在这个模板中定义我们的定制XAML。
- en: We start by declaring the `ScaleColors` gradient brush resource within the template.
    Note that the default value for the `Offset` property of a `GradientStop` element
    is `0` and so we can omit the setting of this property if that is the value that
    we want it set to. Therefore, when we see a declared `GradientStop`, like the
    one with the `Color` property set to `LightGreen`, we know its `Offset` property
    is set to `0`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在模板内声明`ScaleColors`渐变画笔资源。注意，`GradientStop`元素的`Offset`属性的默认值是`0`，因此如果我们想将其设置为这个值，我们可以省略设置这个属性。因此，当我们看到一个声明了`GradientStop`，比如设置了`Color`属性为`LightGreen`的`GradientStop`时，我们知道它的`Offset`属性被设置为`0`。
- en: Our meter control is basically made up of a `Border` element that surrounds
    a `Rectangle` element. We use `TemplateBinding` elements to data bind the `Background`,
    `BorderBrush`, and `BorderThickness` properties of the `Border` element and set
    its `SnapsToDevicePixels` property to `True` to avoid aliasing.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器主要由一个包围着`Rectangle`元素的`Border`元素组成。我们使用`TemplateBinding`元素来将`Background`、`BorderBrush`和`BorderThickness`属性数据绑定到`Border`元素，并将其`SnapsToDevicePixels`属性设置为`True`以避免混叠。
- en: This enables users of the control to specify the border and background colors
    of the internal `Border` element of the meter control from outside the control.
    We could just as easily have exposed an additional brush property to replace the
    `ScaleColors` resource and enable users to define their own meter scale brush.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得控件的用户能够从控件外部指定仪表控制内部`Border`元素的边框和背景颜色。我们同样可以公开一个额外的画笔属性来替换`ScaleColors`资源，并允许用户定义他们自己的仪表刻度画笔。
- en: Note that we couldn't use a `TemplateBinding` to data bind the `Value` property
    in the `ToolTip` element. This is not because we don't have access to it through
    the template, but because we need to use the `Binding.StringFormat` property and
    the `P` format specifier to transform our `double` property value to a percentage
    value.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法使用`TemplateBinding`来将`ToolTip`元素中的`Value`属性数据绑定。这并不是因为我们无法通过模板访问它，而是因为我们需要使用`Binding.StringFormat`属性和`P`格式说明符将我们的`double`属性值转换为百分比值。
- en: If you remember, a `TemplateBinding` is a lightweight binding and does not offer
    this functionality. While it is beneficial to use it when we can, this example
    highlights the fact that we cannot use it in every circumstance.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，`TemplateBinding`是一种轻量级绑定，它不提供这种功能。虽然当我们能够使用它时，这样做是有益的，但这个例子突出了这样一个事实：我们并不能在所有情况下都使用它。
- en: Finally, we come to the all-important `Rectangle` element that is responsible
    for displaying the actual meter bar of our control. The `ScaleColors` brush resource
    is used here to paint the background of the rectangle. We set the `SnapsToDevicePixels`
    property to `true` on this element to ensure that the level that it displays is
    accurate and well-defined.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了至关重要的`Rectangle`元素，它负责显示我们控件的实际仪表条。在这里使用`ScaleColors`笔刷资源来绘制矩形的背景。我们将此元素的`SnapsToDevicePixels`属性设置为`true`，以确保显示的级别准确且定义良好。
- en: The magic in this control is formed by the use of the `UIElement.Clip` property.
    Essentially, this enables us to provide any type of `Geometry` element to alter
    the shape and size of the visible portion of a UI element. The geometry shape
    that we assign here will specify the visible portion of the control.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控件中的魔法是通过使用`UIElement.Clip`属性形成的。本质上，这使我们能够提供任何类型的`Geometry`元素来改变UI元素可见部分的形状和大小。我们在这里分配的几何形状将指定控制的可见部分。
- en: In our case, we declare a `RectangleGeometry` class, whose size and location
    are specified by its `Rect` property. We therefore data bind our `ClipRect` Dependency
    Property to this `Rect` property, so that the sizes calculated from the incoming
    data values are represented by this `RectangleGeometry` instance, and therefore
    the visible part of the `Rectangle` element.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们声明了一个`RectangleGeometry`类，其大小和位置由其`Rect`属性指定。因此，我们将`ClipRect`依赖属性数据绑定到这个`Rect`属性上，这样从传入的数据值计算出的尺寸就由这个`RectangleGeometry`实例表示，因此是`Rectangle`元素的可见部分。
- en: Note that we do this so that the gradient that is painted on the meter bar remains
    constant and does not change with the height of the bar as its value changes.
    If we had simply painted the background of the rectangle with the brush resource
    and adjusted its height, the background gradient would move with the size of the
    meter bar and spoil the effect.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们这样做是为了确保绘制在仪表条上的渐变保持不变，并且不会随着条的高度变化而改变。如果我们只是用笔刷资源绘制矩形的背景并调整其高度，背景渐变会随着仪表条的大小移动，从而破坏效果。
- en: 'Therefore, the whole rectangle is always painted with the gradient brush and
    we simply use its `Clip` property to just display the appropriate part of it.
    In order to use it in one of our Views, we''d first need to specify the `CustomControls`
    XAML namespace prefix:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整个矩形总是用渐变笔刷来填充，我们只需使用它的`Clip`属性来显示其适当的部分。为了在我们的视图中使用它，我们首先需要指定`CustomControls`
    XAML命名空间前缀：
- en: '[PRE82]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We could then declare a number of them, data bind some appropriate properties
    to their `Value` property, and set styles for them, just like any other control:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明多个这样的控件，将适当的属性数据绑定到它们的`Value`属性上，并为它们设置样式，就像任何其他控件一样：
- en: '[PRE83]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Given some valid properties to data bind to, the preceding example would produce
    an output similar to the following:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一些有效的属性进行数据绑定，前面的示例将生成类似于以下内容的输出：
- en: '![](img/67f18285-8cda-41db-a3a0-14d808ed645f.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67f18285-8cda-41db-a3a0-14d808ed645f.jpg)'
- en: Summary
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we've investigated the rich inheritance hierarchy of the built-in
    WPF controls, determining which abilities come from which base classes, and have
    seen how each control is laid out by their containing panels. We've examined the
    differences between the different panels and understand that some work better
    in certain conditions than others.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了内置WPF控件丰富的继承层次结构，确定了哪些能力来自哪些基类，并看到了每个控件是如何由其包含的面板布局的。我们检查了不同面板之间的差异，并理解在某些条件下，某些面板比其他面板工作得更好。
- en: We've also uncovered the mysteries of the `ContentControl` and `ItemsControl`
    elements and now have a good understanding of `ContentPresenter` and `ItemsPresenter`
    objects. We moved on to discover a wide variety of ways for us to customize the
    built-in controls. Finally, we considered how best to make our own controls.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还揭开了`ContentControl`和`ItemsControl`元素的秘密，现在对`ContentPresenter`和`ItemsPresenter`对象有了很好的理解。我们继续探索了多种自定义内置控件的方法。最后，我们考虑了如何最好地创建我们自己的控件。
- en: In the next chapter, we will further investigate the built-in controls, paying
    particular attention to the polymorphic ability of derived classes to override
    base class methods. We will introduce a number of examples that each highlight
    certain problems, and demonstrate how to overcome them each in turn by extending
    the built-in controls and overriding particular base class methods.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步研究内置控制，特别关注派生类覆盖基类方法的多态能力。我们将介绍一些示例，每个示例都突出某些问题，并展示如何通过扩展内置控制和覆盖特定的基类方法逐一克服这些问题。
