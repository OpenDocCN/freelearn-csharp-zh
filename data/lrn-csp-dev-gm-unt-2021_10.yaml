- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Revisiting Types, Methods, and Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾类型、方法和类
- en: Now that you've programmed the game's mechanics and interactions with Unity's
    built-in classes, it's time to expand our core C# knowledge and focus on the intermediate
    applications of the foundation we've laid. We'll revisit old friends—variables,
    types, methods, and classes—but we'll target their deeper applications and relevant
    use cases. Many of the topics we'll be covering don't apply to *Hero Born* in
    its current state, so some examples will be standalone rather than being applied
    directly to the game prototype.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经用Unity内置类编程了游戏机制和交互，是时候扩展我们的核心C#知识，并专注于我们已奠定基础的中级应用。我们将回顾老朋友——变量、类型、方法和类，但我们将针对它们的深入应用和相关用例。我们将讨论的许多主题在当前状态下的*英雄降世*中不适用，因此一些示例将是独立的，而不是直接应用于游戏原型。
- en: 'I''ll be throwing a lot of new information your way, so if you feel overwhelmed
    at any point, don''t hesitate to revisit the first few chapters to solidify those
    building blocks. We''ll also be using this chapter to break away from gameplay
    mechanics and features specific to Unity by focusing on the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您提供大量新信息，所以如果您在任何时候感到不知所措，请不要犹豫，回到前几章以巩固这些基础。我们还将利用本章摆脱游戏机制和Unity特有的功能，专注于以下主题：
- en: Intermediate modifiers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中级修饰符
- en: Method overloading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重载
- en: Using the `out` and `ref` parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`out`和`ref`参数
- en: Working with interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与接口一起工作
- en: Abstract classes and overriding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类和重写
- en: Extending class functionality
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展类功能
- en: Namespace conflicts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间冲突
- en: Type aliasing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Access modifiers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: While we've gotten into the habit of pairing the public and private access modifiers
    with our variable declarations, like we did with player health and items collected,
    there remains a laundry list of modifier keywords that we haven't seen. We can't
    go into detail about every one of them in this chapter, but the five that we'll
    focus on will further your understanding of the C# language and give your programming
    skills a boost.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经习惯了将公共和私有访问修饰符与我们的变量声明配对，就像我们在玩家健康和收集到的物品上所做的那样，但仍然有一长串的修饰符关键字我们没有见过。我们无法在本章中详细介绍每一个，但我们将关注的五个将有助于您进一步理解C#语言，并提升您的编程技能。
- en: 'This section will cover the first three modifiers in the following list, while
    the remaining two will be discussed later on in the *Intermediate OOP* section:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍以下列表中的前三个修饰符，而剩下的两个将在*中级OOP*部分稍后讨论：
- en: '`const`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`'
- en: '`readonly`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly`'
- en: '`static`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`'
- en: '`abstract`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract`'
- en: '`override`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override`'
- en: You can find a full list of available modifiers at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers)找到可用的修饰符完整列表。
- en: Let's start with the first three access modifiers provided in the preceding
    list.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从前面列表中提供的第一个三个访问修饰符开始。
- en: Constant and read-only properties
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量和只读属性
- en: 'There will be times when you need to create variables that store constant,
    unchanging values. Adding the `const` keyword after a variable''s access modifier
    will do just that, but only for built-in C# types. For example, you couldn''t
    mark an instance of our `Character` class as a constant. A good candidate for
    a constant value is `MaxItems` in the `GameBehavior` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您需要创建存储常量、不变值的变量。在变量的访问修饰符后添加`const`关键字就可以做到这一点，但仅限于内置的C#类型。例如，您不能将我们的`Character`类的实例标记为常量。`GameBehavior`类中的`MaxItems`是一个很好的常量值候选：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The above code would essentially lock the value of `MaxItems` at `4`, making
    it unchangeable. The problem you''ll run into with constant variables is that
    they can only be assigned a value in their declaration, meaning we can''t leave
    `MaxItems` without an initial value. As an alternative, we can use `readonly`,
    which won''t let you write to the variable, meaning it can''t be changed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将基本上锁定`MaxItems`的值为`4`，使其不可更改。您在使用常量变量时可能会遇到的问题是，它们只能在声明时赋值，这意味着我们不能不指定初始值就留下`MaxItems`。作为替代方案，我们可以使用`readonly`，这意味着您不能写入变量，因此它不能被更改：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the `readonly` keyword to declare a variable will give us the same unmodifiable
    value as a constant, while still letting us assign its initial value at any time.
    A good place for this would be the `Start()` or `Awake()` methods in one of our
    scripts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readonly`关键字声明一个变量将给我们一个与常量相同的不可修改的值，同时仍然允许我们在任何时间分配其初始值。一个好的地方是在我们脚本中的`Start()`或`Awake()`方法中。
- en: Using the static keyword
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态关键字
- en: We've already gone over how objects, or instances, are created from a class
    blueprint, and that all properties and methods belong to that particular instance,
    like we had with our very first `Character` class instance. While this is great
    for object-oriented functionality, not all classes need to be instantiated, and
    not all properties need to belong to a specific instance. However, static classes
    are sealed, meaning they cannot be used in class inheritance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过如何从类蓝图创建对象或实例，以及所有属性和方法都属于特定的实例，就像我们在第一个`Character`类实例中所做的那样。虽然这对于面向对象的功能来说很棒，但并非所有类都需要实例化，并非所有属性都需要属于特定的实例。然而，静态类是密封的，这意味着它们不能用于类继承。
- en: Utility methods are a good case for this situation, where we don't necessarily
    care about instantiating a particular `Utility` class instance since all its methods
    wouldn't be dependent on a particular object. Your task is to create just such
    a utility method in a new script.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 工具方法正是这种情况的一个好例子，在这种情况下，我们不一定关心实例化特定的`Utility`类实例，因为它的所有方法都不会依赖于特定的对象。你的任务是创建这样一个工具方法在一个新的脚本中。
- en: 'Let''s create a new class to hold some of our future methods that deal with
    raw computations or repeated logic that doesn''t depend on the gameplay:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的类来保存我们未来的一些方法，这些方法涉及原始计算或与游戏玩法无关的重复逻辑：
- en: Create a new C# script in the `Scripts` folder and name it `Utilities`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，并将其命名为`Utilities`。
- en: 'Open it up and add the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它并添加以下代码：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Delete the code inside `RestartLevel()` from `GameBehavior` and instead call
    the new `utility` method with the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GameBehavior`中的`RestartLevel()`删除代码，而是用以下代码调用新的`utility`方法：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break down the code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it adds the `using SceneManagement` directive so that we can access the
    `LoadScene()` method.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它添加了`using SceneManagement`指令，以便我们可以访问`LoadScene()`方法。
- en: Then, it declares `Utilities` as a public `static` class that does not inherit
    from `MonoBehavior` because we won't need it to be in the game scene.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将`Utilities`声明为一个公共的`static`类，它不继承自`MonoBehavior`，因为我们不需要它在游戏场景中。
- en: Next, it creates a public `static` variable to hold the number of times our
    player has died and restarted the game.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它创建了一个公共的`static`变量来保存玩家死亡并重新开始游戏的次数。
- en: After, it declares a public `static` method to hold our level restart logic,
    which is currently hardcoded in `GameBehavior`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它声明了一个公共的`static`方法来保存我们的关卡重启逻辑，这个逻辑目前硬编码在`GameBehavior`中。
- en: Finally, our update to `GameBehavior` calls `RestartLevel()` from the static
    `Utilities` class when the win or the lose button is pressed. Notice that we didn't
    need an instance of the `Utilities` class to call the method because it's static—it's
    just dot notation.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的`GameBehavior`更新在按下胜利或失败按钮时从静态的`Utilities`类调用`RestartLevel()`。注意，我们不需要`Utilities`类的实例来调用该方法，因为它本身就是静态的——它只是点符号。
- en: We've now extracted the restart logic from `GameBehavior` and put it into its
    static class, which makes it easier to reuse across our codebase. Marking it as
    `static` will also ensure that we never have to create or manage instances of
    the `Utilities` class before we use its class members.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将重启逻辑从`GameBehavior`中提取出来，并将其放入其静态类中，这使得它在代码库中更容易重用。将其标记为`static`也将确保我们在使用其类成员之前永远不需要创建或管理`Utilities`类的实例。
- en: Non-static classes can have properties and methods that are static and non-static.
    However, if an entire class is marked as static, all properties and methods must
    follow suit.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态类可以拥有静态和非静态的属性和方法。然而，如果一个类被标记为静态，那么所有的属性和方法都必须遵循同样的规则。
- en: That wraps up our second visit of variables and types, which will enable you
    to build out your own set of utilities and tools when managing larger and more
    complex projects down the road. Now it's time to move on to methods and their
    intermediate capabilities, which includes method overloading and `ref` and `out`
    parameters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对变量和类型的第二次访问，这将使你能够在管理更大、更复杂的项目时构建自己的工具集。现在，是时候继续到方法和它们的中间能力了，这包括方法重载和`ref`和`out`参数。
- en: Revisiting methods
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾方法
- en: 'Methods have been a big part of our code since we learned how to use them in
    *Chapter 3*, *Diving into Variables, Types, and Methods*, but there are two intermediate
    use cases we haven''t covered yet: method overloading and using the `ref` and
    `out` parameter keywords.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在*第3章*，*深入变量、类型和方法*中学习了如何使用方法以来，方法一直是我们的代码的重要组成部分，但我们还没有涵盖两个中间使用案例：方法重载和使用`ref`和`out`参数关键字。
- en: Overloading methods
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: 'The term **method overloading** refers to creating multiple methods with the
    same name but with different signatures. A method''s signature is made up of its
    name and parameters, which is how the C# compiler recognizes it. Take the following
    method as an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法重载**这个术语指的是创建多个具有相同名称但具有不同签名的函数。方法的签名由其名称和参数组成，这是C#编译器识别它的方式。以下是一个方法的例子：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method signature of `AttackEnemy()` is written as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttackEnemy()`方法的签名如下所示：'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we know the signature of `AttackEnemy()`, it can be overloaded by changing
    the number of parameters or the parameter types themselves, while still keeping
    its name. This provides added flexibility when you need more than one option for
    a given operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`AttackEnemy()`函数的签名，可以通过改变参数数量或参数类型本身来对其进行重载，同时保持其名称不变。这在你需要为特定操作提供多个选项时提供了额外的灵活性。
- en: The `RestartLevel()` method in `Utilities` is a great example of a situation
    where method overloading comes in handy. Right now, `RestartLevel()` only restarts
    the current level, but what happens if we expand the game so that it includes
    multiple scenes? We could refactor `RestartLevel()` to accept parameters, but
    that often leads to bloated and confusing code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Utilities`中的`RestartLevel()`方法是一个很好的例子，说明了方法重载如何派上用场。目前，`RestartLevel()`只重新启动当前关卡，但如果我们扩展游戏使其包含多个场景会发生什么？我们可以重构`RestartLevel()`以接受参数，但这通常会导致代码膨胀且难以理解。'
- en: The `RestartLevel()` method is, once again, a good candidate for testing out
    our new knowledge. Your task is to overload it to take in different parameters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestartLevel()`方法再次是一个测试我们新知识的良好候选者。你的任务是重载它以接受不同的参数。'
- en: 'Let''s add an overloaded version of `RestartLevel()`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`RestartLevel()`的重载版本：
- en: 'Open up `Utilities` and add the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Utilities`并添加以下代码：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open `GameBehavior` and update the call to the `Utilities.RestartLevel()` method
    to the following:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameBehavior`并更新对`Utilities.RestartLevel()`方法的调用，如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s break down the code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下代码：
- en: First, it declares an overloaded version of the `RestartLevel()` method that
    takes in an `int` parameter and returns a `bool`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个重载版本的`RestartLevel()`方法，该方法接受一个`int`类型的参数并返回一个`bool`类型的值。
- en: Then, it calls `LoadScene()` and passes in the `sceneIndex` parameter instead
    of manually hardcoding that value.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它调用`LoadScene()`并传入`sceneIndex`参数，而不是手动硬编码该值。
- en: Next, it returns `true` after the new scene is loaded and the `timeScale` property
    has been reset.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在新场景加载并重置`timeScale`属性后，它返回`true`。
- en: Finally, our update to `GameBehavior` calls the overloaded `RestartLevel()`
    method and passes in `0` as the `sceneIndex`. Overloaded methods are automatically
    detected by Visual Studio and are displayed by number, as shown here:![](img/B17573_10_01.png)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的`GameBehavior`更新调用重载的`RestartLevel()`方法，并将`0`作为`sceneIndex`传入。重载方法会被Visual
    Studio自动检测并以数字形式显示，如下所示：![](img/B17573_10_01.png)
- en: 'Figure 10.1: Multiple method overloads in Visual Studio'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.1：Visual Studio中的多个方法重载
- en: The functionality in the `RestartLevel()` method is now much more customizable
    and can account for additional situations you may need later. In this case, it
    is restarting the game from any scene we choose.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestartLevel()`方法的功能现在可以更加定制化，并可以应对你可能以后需要的额外情况。在这种情况下，它是从我们选择的任何场景重新启动游戏。'
- en: Method overloading is not limited to static methods—this was just in line with
    the previous example. Any method can be overloaded as long as its signature differs
    from the original.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载不仅限于静态方法——这只是为了与前面的例子保持一致。任何方法都可以重载，只要其签名与原始签名不同。
- en: Next up, we're going to cover two additional topics that can take your method
    game to a whole new level—`ref` and `out` parameters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍两个可以让你将方法游戏提升到全新水平的话题——`ref`和`out`参数。
- en: ref parameters
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ref`参数'
- en: 'When we talked about classes and structs back in *Chapter 5*, *Working with
    Classes, Structs*, *and OOP*, we discovered that not all objects are passed the
    same way: value types are passed by copy, while reference types are passed by
    reference. However, we didn''t go over how objects, or values, are used when they''re
    passed into methods as parameter arguments.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*第5章*中讨论类和结构体时，*使用类、结构体和面向对象编程*，我们发现并不是所有对象都是通过相同的方式传递的：值类型是通过复制传递的，而引用类型是通过引用传递的。然而，我们没有讨论当对象或值作为参数传递给方法时是如何使用的。
- en: By default, all arguments are passed by value, meaning that a variable passed
    into a method will not be affected by any changes that are made to its value inside
    the method body. This protects us from making unwanted changes to existing variables
    when we use them as method parameters. While this works for most cases, there
    are situations where you'll want to pass in a method argument by reference so
    that it can be updated and have that change reflected in the original variable.
    Prefixing a parameter declaration with either the `ref` or `out` keyword will
    mark the argument as a reference.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有参数都是通过值传递的，这意味着传递给方法的变量将不会受到方法体内对其值所做的任何更改的影响。这保护我们在使用它们作为方法参数时不会对现有变量做出不希望的改变。虽然这适用于大多数情况，但也有一些情况下，你希望通过引用传递方法参数，以便它可以被更新，并且这些更改会在原始变量中得到反映。在参数声明前加上`ref`或`out`关键字将标记该参数为引用。
- en: 'Here are a few key points to keep in mind about using the `ref` keyword:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ref`关键字时，以下是一些需要记住的关键点：
- en: Arguments have to be initialized before being passed into a method.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数在传递给方法之前必须进行初始化。
- en: You don't need to initialize or assign the reference parameter value before
    ending the method.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要在方法结束时初始化或分配引用参数的值。
- en: Properties with get or set accessors can't be used as `ref` or `out` arguments.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有获取或设置访问器的属性不能用作`ref`或`out`参数。
- en: Let's try this out by adding some logic to keep track of how many times a player
    has restarted the game.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一些逻辑来跟踪玩家重启游戏次数来尝试一下。
- en: Let's create a method to update `PlayerDeaths` to see the method arguments that
    are being passed by reference in action.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个方法来更新`PlayerDeaths`，以查看正在传递的引用参数的实际方法参数。
- en: 'Open up `Utilities` and add the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Utilities`并添加以下代码：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s break down the code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares a new `static` method that returns a `string` and takes in
    an `int` passed by reference.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个新的`static`方法，该方法返回一个`string`并接受一个通过引用传递的`int`。
- en: Then, it updates the reference parameter directly, incrementing its value by
    `1` and returning a string that contains the new value.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它直接更新引用参数，将其值增加`1`，并返回一个包含新值的字符串。
- en: Finally, it debugs the `PlayerDeaths` variable in `RestartLevel(int sceneIndex)`
    before and after it is passed by reference to `UpdateDeathCount()`. We also store
    a reference to the returned string value from `UpdateDeathCount()` in the `message`
    variable and print it out.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它在将`PlayerDeaths`变量传递给`UpdateDeathCount()`之前和之后，在`RestartLevel(int sceneIndex)`中对其进行调试。我们还把从`UpdateDeathCount()`返回的字符串值存储在`message`变量中，并将其打印出来。
- en: 'If you play the game and lose, the debug log will show that `PlayerDeaths`
    has increased by 1 inside `UpdateDeathCount()` because it was passed by reference
    and not by value:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩游戏并输了，调试日志将显示在`UpdateDeathCount()`函数中`PlayerDeaths`增加了1，因为它是通过引用传递而不是通过值传递：
- en: '![](img/B17573_10_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_10_02.png)'
- en: 'Figure 10.2: Example output from ref parameters'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：引用参数的示例输出
- en: For clarity, we could have updated the player death count without a `ref` parameter
    because `UpdateDeathCount()` and `PlayerDeaths` are in the same script. However,
    if this wasn't the case and you wanted the same functionality, `ref` parameters
    are super useful.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们可以在没有`ref`参数的情况下更新玩家死亡计数，因为`UpdateDeathCount()`和`PlayerDeaths`在同一个脚本中。然而，如果不是这种情况，并且你想要相同的功能，`ref`参数非常有用。
- en: We're using the `ref` keyword in this situation for the sake of our example,
    but we could have also updated `PlayerDeaths` directly inside `UpdateDeathCount()`
    or added logic inside `RestartLevel()` to only fire `UpdateDeathCount()` when
    the restart was due to a loss.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中使用`ref`关键字是为了说明，但我们也可以在`UpdateDeathCount()`内部直接更新`PlayerDeaths`，或者添加逻辑到`RestartLevel()`中，以便仅在重启是由于失败时才触发`UpdateDeathCount()`。
- en: Now that we know how to use a `ref` parameter in our project, let's take a look
    at the `out` parameter and how it serves a slightly different purpose.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在项目中使用`ref`参数，让我们来看看`out`参数以及它如何服务于稍微不同的目的。
- en: out parameters
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出参数
- en: 'The `out` keyword does the same job as `ref` but with different rules, which
    means they''re similar tools but they''re not interchangeable—each has its own
    use cases:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`关键字与`ref`关键字执行相同的工作，但有不同的规则，这意味着它们是类似工具，但它们不是可互换的——每个都有自己的用例：'
- en: Arguments do not need to be initialized before being passed into a method.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数在传递到方法之前不需要初始化。
- en: The referenced parameter value does need to be initialized or assigned in the
    calling method before it's returned.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在返回之前，引用参数值需要在调用方法中初始化或分配。
- en: 'For instance, we could have replaced `ref` with `out` in `UpdateDeathCount()`
    as long as we initialized or assigned the `countReference` parameter before returning
    from the method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在`UpdateDeathCount()`中将`ref`替换为`out`，只要我们在从方法返回之前初始化或分配了`countReference`参数：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Methods that use the `out` keyword are better suited to situations where you
    need to return multiple values from a single function, while the `ref` keyword
    works best when a reference value only needs to be modified. It's also more flexible
    than the `ref` keyword because the initial parameter values don't need to be set
    before they're used in the method. The `out` keyword is especially useful if you
    need to initialize the parameter value before you change it. Even though these
    keywords are a little more esoteric, it's important to have them in your C# toolkit
    for special use cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`out`关键字的函数更适合需要从单个函数返回多个值的情况，而`ref`关键字在只需要修改引用值时效果最佳。它也比`ref`关键字更灵活，因为初始参数值在使用方法之前不需要设置。如果需要在更改之前初始化参数值，`out`关键字特别有用。尽管这些关键字有点晦涩，但它们对于C#工具箱中的特殊用例来说非常重要。
- en: 'With these new method features under our belts, it''s time to revisit the big
    one: **object-oriented programming** (**OOP**). There''s so much to this topic
    that it''s impossible to cover everything in a chapter or two, but there are a
    few key tools that will come in handy early on in your development career. OOP
    is one of those topics that you''re encouraged to follow up on after finishing
    this book.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这些新的方法特性之后，是时候回顾一下最重要的一个：**面向对象编程（OOP**）。这个话题内容丰富，不可能在一章或两章中涵盖所有内容，但有一些关键工具将在你的开发生涯早期派上用场。OOP是那些你完成这本书后鼓励继续跟进的话题之一。
- en: Intermediate OOP
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中级面向对象编程（OOP）
- en: 'An object-oriented mindset is crucial to creating meaningful applications and
    understanding how the C# language works behind the scenes. The tricky part is
    that classes and structs by themselves aren''t the end of the line when it comes
    to OOP and designing your objects. They''ll always be the building blocks of your
    code, but classes are limited to single inheritance, meaning they can only ever
    have one parent or superclass, and structs can''t inherit at all. So, the question
    you should be asking yourself right about now is simple: *"How can I create objects
    from the same blueprint and have them perform different actions based on a specific
    scenario?"*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的心态对于创建有意义的应用程序和理解C#语言背后的工作原理至关重要。棘手的部分在于，就OOP和设计你的对象而言，类和结构体本身并不是终点。它们始终是代码的构建块，但类限于单继承，这意味着它们只能有一个父类或超类，而结构体则不能继承。所以，你现在应该问自己的问题是简单的：*"我如何从相同的蓝图创建对象，并根据特定场景让它们执行不同的操作？"*
- en: To answer this question, we'll be learning about interfaces, abstract classes,
    and class extensions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们将学习接口、抽象类和类扩展。
- en: Interfaces
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'One of the ways to gather groups of functionality together is through interfaces.
    Like classes, interfaces are blueprints for data and behaviors, but with one important
    difference: they can''t have any actual implementation logic or stored values.
    Instead, they contain the implementation blueprint, and it''s up to the adopting
    class or struct to fill in the values and methods outlined in the interface. You
    can use interfaces with both classes and structs, and there''s no upper limit
    to how many interfaces a single class or struct can adopt.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能组合在一起的一种方法是通过接口。像类一样，接口是数据和行为的蓝图，但有一个重要的区别：它们不能有任何实际的实现逻辑或存储值。相反，它们包含实现蓝图，而填充接口中概述的值和方法的责任则由采用类或结构体承担。你可以使用接口与类和结构体一起使用，并且单个类或结构体可以采用的接口数量没有上限。
- en: Remember, a single class can only have one parent class, and structs can't subclass
    at all. Breaking out functionality into interfaces lets you build up classes like
    building blocks, picking and choosing how you want them to behave like food from
    a menu. This would be a huge efficiency boost to your code base, breaking away
    from long, messy subclassing hierarchies.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个类只能有一个父类，结构体根本不能进行子类化。将功能分解到接口中让你可以像积木一样构建类，选择你希望它们如何表现，就像从菜单中选择食物一样。这将大大提高你的代码库的效率，摆脱长而混乱的子类化层次结构。
- en: For example, what if we wanted our enemies to be able to shoot back at our player
    when they're in close range? We could create a parent class that both the player
    and enemy could derive from, which would base them both on the same blueprint.
    The problem with that approach, however, is that enemies and players won't necessarily
    share the same behaviors and data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想让我们的敌人在我们玩家近距离时能够射击回来怎么办？我们可以创建一个父类，玩家和敌人都可以从中派生出来，这样它们就会基于相同的蓝图。然而，这种方法的问题在于，敌人和玩家不一定会有相同的行为和数据。
- en: The more efficient way to handle this would be to define an interface with a
    blueprint for what shootable objects need to do, and then have both the enemy
    and player adopt it. That way, they have the freedom to be separate and exhibit
    different behaviors while still sharing common functionality.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的更有效的方法是定义一个接口，其中包含可射击对象需要执行的操作的蓝图，然后让敌人和玩家都采用它。这样，它们就有自由独立并表现出不同的行为，同时仍然共享共同的功能。
- en: Refactoring the shooting mechanic into an interface is a challenge I'll leave
    to you, but we still need to know how to create and adopt interfaces in code.
    For this example, we'll create an interface that all manager scripts might need
    to implement for sharing a common structure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将射击机制重构为接口是一个挑战，我将留给你们去完成，但我们仍然需要知道如何在代码中创建和采用接口。对于这个例子，我们将创建一个接口，所有管理脚本可能都需要实现以共享一个共同的结构。
- en: 'Create a new C# script in the `Scripts` folder, name it `IManager`, and update
    its code as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`IManager`，并按照以下方式更新其代码：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares a public interface called `IManager` using the `interface`
    keyword.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它使用`interface`关键字声明了一个名为`IManager`的公共接口。
- en: Then, it adds a `string` variable to `IManager` named `State` with `get` and
    `set` accessors to hold the current state of the adopting class.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它向`IManager`添加了一个名为`State`的`string`变量，并提供了`get`和`set`访问器来保存采用类的当前状态。
- en: All interface properties need at least a get accessor to compile but can have
    both get and set accessors if necessary.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有接口属性至少需要一个get访问器才能编译，但如果需要，也可以同时有get和set访问器。
- en: Finally, it defines a method named `Initialize()` with no return type for the
    adopting class to implement. However, you could absolutely have a return type
    for a method inside an interface; there's no rule against it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它定义了一个名为`Initialize()`的方法，没有返回类型，供采用类实现。然而，你完全可以为接口内的方法指定返回类型；没有这样的规则。
- en: You've now created a blueprint for all manager scripts, meaning that each manager
    script adopting this interface needs to have a state property and an initialize
    method. Your next task is to use the `IManager` interface, which means it needs
    to be adopted by another class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经为所有管理脚本创建了一个蓝图，这意味着采用这个界面的每个管理脚本都需要有一个状态属性和一个初始化方法。你的下一个任务是使用`IManager`接口，这意味着它需要被另一个类采用。
- en: To keep things simple, let's have the game manager adopt our new interface and
    implement its blueprint.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，让我们让游戏管理器采用我们新的接口并实现其蓝图。
- en: 'Update `GameBehavior` with the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`GameBehavior`：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s break down the code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares that `GameBehavior` adopts the `IManager` interface using
    a comma and its name, just like with subclassing.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明`GameBehavior`采用`IManager`接口，使用逗号和其名称，就像在子类化中一样。
- en: Then, it adds a private variable that we'll use to back the public `State` value
    we have to implement from `IManager`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它添加了一个私有变量，我们将使用它来支持从`IManager`中实现的公共`State`值。
- en: Next, it adds the public `State` variable declared in `IManager` and uses `_state`
    as its private backing variable.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它添加了在`IManager`中声明的公共`State`变量，并使用`_state`作为其私有后置变量。
- en: After that, it declares the `Start()` method and calls the `Initialize()` method.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，它声明了`Start()`方法并调用了`Initialize()`方法。
- en: Finally, it declares the `Initialize()` method declared in `IManager` with an
    implementation that sets and prints out the public `State` variable.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它声明了`IManager`中声明的`Initialize()`方法，其实现将设置并打印出公共`State`变量。
- en: 'With this, we specified that `GameBehavior` adopts the `IManager` interface
    and implemented its `State` and `Initialize()` members, as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们指定了`GameBehavior`采用`IManager`接口并实现了其`State`和`Initialize()`成员，如下所示：
- en: '![](img/B17573_10_03.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_10_03.png)'
- en: 'Figure 10.3: Example output from an interface'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：接口的示例输出
- en: 'The great part of this is that the implementation is specific to `GameBehavior`;
    if we had another manager class, we could do the same thing but with different
    logic. Just for fun, let''s set up a new manager script to test this out:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是，实现是针对`GameBehavior`特定的；如果我们有另一个管理器类，我们可以做同样的事情，但使用不同的逻辑。为了好玩，让我们设置一个新的管理器脚本来测试这一点：
- en: In the **Project**, right-click inside the **Scripts** folder and choose **Create**
    | **C# Script**, then name it `DataManager`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**中，在**脚本**文件夹内右键单击，然后选择**创建** | **C# 脚本**，然后将其命名为`DataManager`。
- en: 'Update the new script with the following code and adopt the `IManager` interface:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新新脚本并采用`IManager`接口：
- en: '[PRE12]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Drag and drop the new script onto the **Game_Manager** object in the **Hierarchy**
    panel:![](img/B17573_10_04.png)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新脚本拖放到**层次**面板中的**Game_Manager**对象上！[](img/B17573_10_04.png)
- en: 'Figure 10.4: Data manager script attached to a GameObject'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.4：附加到GameObject的数据管理器脚本
- en: Then click play:![](img/B17573_10_05.png)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击播放：![](img/B17573_10_05.png)
- en: 'Figure 10.5: Output from data manager initialization'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.5：数据管理器初始化的输出
- en: While we could have done all of this with subclassing, we'd be limited to one
    parent class for all our managers. Instead, we have the option of adding new interfaces
    if we choose. We'll revisit this new manager script in *Chapter 12*, *Saving,
    Loading, and Serializing Data*. This opens up a whole world of possibilities for
    building classes, one of which is a new OOP concept called abstract classes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以通过子类化来完成所有这些，但我们会被限制在所有管理器的一个父类上。相反，如果我们选择，我们可以添加新的接口。我们将在*第12章*，*保存、加载和序列化数据*中重新访问这个新的管理器脚本。这为构建类打开了一个全新的世界，其中之一是一个新的面向对象概念，称为抽象类。
- en: Abstract classes
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: Another approach to separating common blueprints and sharing them between objects
    is the abstract class. Like interfaces, abstract classes cannot include any implementation
    logic for their methods; they can, however, store variable values. This is one
    of the key differences from interfaces—in situations where you might need to set
    initial values, an abstract class would be the way to go.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将常见蓝图分离并在对象之间共享的方法是抽象类。与接口一样，抽象类不能为其方法包含任何实现逻辑；然而，它们可以存储变量值。这是与接口的一个关键区别——在可能需要设置初始值的情况下，抽象类将是最佳选择。
- en: Any class that subclasses from an abstract class must fully implement all variables
    and methods marked with the `abstract` keyword. They can be particularly useful
    in situations where you want to use class inheritance without having to write
    out a base class's default implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象类派生的任何类都必须完全实现所有标记有`abstract`关键字的变量和方法。它们在您想要使用类继承而不必编写基类的默认实现的情况下特别有用。
- en: 'For example, let''s take the `IManager` interface functionality we just wrote
    and see what it would look like as an abstract base class. *Don''t change any
    of the actual code in our project*, as we still want to keep things working as
    they are:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们拿我们刚刚编写的`IManager`接口功能来看看它作为一个抽象基类会是什么样子。*不要更改我们项目中任何实际的代码*，因为我们仍然希望保持事物按原样工作：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s break down the code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares a new class named `BaseManager` using the `abstract` keyword.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它使用`abstract`关键字声明了一个名为`BaseManager`的新类。
- en: 'Then, it creates two variables: A `protected string` named `_state` that can
    only be accessed by classes that inherit from `BaseManager`. We''ve also set an
    initial value for `_state`, something we couldn''t do in our interface.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它创建了两个变量：一个名为`_state`的受保护字符串，只能由继承自`BaseManager`的类访问。我们还为`_state`设置了一个初始值，这是我们在接口中无法做到的。
- en: We also have an abstract string named `State` with `get` and `set` accessors
    to be implemented by the subclass.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一个名为`State`的抽象字符串，它具有`get`和`set`访问器，由子类实现。
- en: Finally, it adds `Initialize()` as an `abstract` method, also to be implemented
    in the subclass.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它添加了一个`abstract`方法`Initialize()`，也需要在子类中实现。
- en: 'In doing so, we have created an abstract class that does the same thing as
    an interface. In this setup, `BaseManager` has the same blueprint as `IManager`,
    allowing any subclasses to define their implementations of `state` and `Initialize()`
    using the `override` keyword:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们创建了一个与接口做同样事情的抽象类。在这个设置中，`BaseManager`与`IManager`有相同的蓝图，允许任何子类使用`override`关键字定义它们对`state`和`Initialize()`的实现：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we break down the preceding code, we can see the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分解前面的代码，我们可以看到以下内容：
- en: First, it declares a new class called `CombatManager` that inherits from the
    `BaseManager` abstract class.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个名为`CombatManager`的新类，该类继承自`BaseManager`抽象类。
- en: Then, it adds the `State` variable implementation from `BaseManager` using the
    `override` keyword.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它使用`override`关键字添加了`State`变量实现。
- en: Finally, it adds the `Initialize()` method implementation from `BaseManager`
    using the `override` keyword again and sets the protected `_state` variable.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它再次使用`override`关键字添加了`Initialize()`方法实现，并设置了受保护的`_state`变量。
- en: Even though this is only the tip of the iceberg of interfaces and abstract classes,
    their possibilities should be jumping around in your programming brain. Interfaces
    will allow you to spread and share pieces of functionality between unrelated objects,
    leading to a building block-like assembly when it comes to your code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这只是接口和抽象类的一小部分，它们的可能性也应该在你的编程大脑中跳跃。接口将允许你在无关对象之间传播和共享功能片段，当涉及到你的代码时，就像积木一样进行组装。
- en: Abstract classes, on the other hand, will let you keep the single-inheritance
    structure of OOP while separating a class's implementation from its blueprint.
    These approaches can even be mixed and matched, as abstract classes can adopt
    interfaces just like non-abstract ones.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，抽象类将允许你保持面向对象编程的单继承结构，同时将类的实现与其蓝图分离。这些方法甚至可以混合使用，因为抽象类可以像非抽象类一样采用接口。
- en: As always with complicated topics, your first stop should be the documentation.
    Check it out at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract)
    and [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理复杂主题时一样，你的第一步应该是查看文档。请查看[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract)和[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface)。
- en: You won't always need to build a new class from scratch. Sometimes, it's enough
    to add the feature or logic you want to an existing class, which is called a class
    extension.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是需要从头开始构建一个新类。有时，只需将你想要的功能或逻辑添加到现有类中就足够了，这被称为类扩展。
- en: Class extensions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类扩展
- en: 'Let''s step away from custom objects and talk about how we can extend existing
    classes so that they fit our own needs. The idea behind class extensions is simple:
    take an existing built-in C# class and add on any functionality that you need
    it to have. Since we don''t have access to the underlying code that C# is built
    on, this is the only way to get custom behavior out of objects the language already
    has.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时离开自定义对象，谈谈我们如何扩展现有类，以便它们符合我们的需求。类扩展背后的想法很简单：取一个现有的内置C#类，并添加任何你需要的功能。由于我们没有访问C#构建在之上的底层代码，这是从语言已有的对象中获得自定义行为的唯一方法。
- en: 'Classes can only be modified with methods—no variables or other entities are
    allowed. However limiting this might be, it makes the syntax consistent:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类只能通过方法进行修改——不允许变量或其他实体。尽管这种限制可能很严格，但它使语法保持一致：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Extension methods are declared using the same syntax as normal methods, but
    with a few caveats:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法使用与普通方法相同的语法声明，但有一些注意事项：
- en: All extension methods need to be marked as `static`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有扩展方法都需要标记为 `static`。
- en: 'The first parameter needs to be the `this` keyword, followed by the name of
    the class we want to extend and a local variable name:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数需要是 `this` 关键字，后跟我们要扩展的类的名称和局部变量名：
- en: This special parameter lets the compiler identify the method as an extension,
    and gives us a local reference for the existing class.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个特殊参数让编译器能够识别方法为扩展方法，并为我们提供了对现有类的局部引用。
- en: Any class methods and properties can then be accessed through the local variable.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类方法和属性都可以通过局部变量访问。
- en: It's common to store extension methods inside a static class, which, in turn,
    is stored inside its namespace. This allows you to control what other scripts
    have access to your custom functionality.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将扩展方法存储在静态类中是很常见的，该静态类又存储在其命名空间中。这允许您控制其他脚本对您的自定义功能的访问权限。
- en: Your next task is to put class extensions into practice by adding a new method
    to the built-in C# `String` class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您接下来的任务是通过对内置的 C# `String` 类添加一个新方法来将类扩展应用到实践中。
- en: 'Let''s take a look at extensions in practice by adding a custom method to the
    `String` class. Create a new C# script in the `Scripts` folder, name it `CustomExtensions`,
    and add the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向 `String` 类添加一个自定义方法来实际查看扩展方法。在 `Scripts` 文件夹中创建一个新的 C# 脚本，命名为 `CustomExtensions`，并添加以下代码：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s break down the code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares a namespace named `CustomExtensions` to hold all the extension
    classes and methods.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个名为 `CustomExtensions` 的命名空间来存放所有的扩展类和方法。
- en: Then, it declares a `static` class named `StringExtensions` for organizational
    purposes; each group of class extensions should follow this setup.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它为了组织目的声明了一个名为 `StringExtensions` 的 `static` 类；每个类扩展组都应该遵循这种设置。
- en: 'Next, it adds a `static` method named `FancyDebug` to the `StringExtensions`
    class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它在 `StringExtensions` 类中添加了一个名为 `FancyDebug` 的 `static` 方法：
- en: The first parameter, `this string str`, marks the method as an extension.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数，`this string str`，将方法标记为扩展方法。
- en: The `str` parameter will hold a reference to the actual text value that `FancyDebug()`
    is called from; we can operate on `str` inside the method body as a stand-in for
    all string literals.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str` 参数将保留对 `FancyDebug()` 被调用时的实际文本值的引用；我们可以在方法体内部操作 `str` 作为所有字符串字面量的替身。'
- en: Finally, it prints out a debug message whenever `FancyDebug` is executed, using
    `str.Length` to reference the string variable that the method is called on.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，每当执行 `FancyDebug` 时，它都会打印出一个调试消息，使用 `str.Length` 来引用被方法调用的字符串变量。
- en: In practice, this will let you add any of your own custom functionality to existing
    C# classes or even your own custom ones. Now that the extension is part of the
    `String` class, let's test it out. To use our new custom string method, we'll
    need to include it in whatever class we want to have access to it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这将允许您向现有的 C# 类或您自己的自定义类添加任何自定义功能。现在，扩展方法已成为 `String` 类的一部分，让我们来测试一下。要使用我们新的自定义字符串方法，我们需要将其包含在我们想要访问它的任何类中。
- en: 'Open up `GameBehavior` and update the class with the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `GameBehavior` 并使用以下代码更新类：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s break down the code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it adds the `CustomExtensions` namespace with a `using` directive at
    the top of the file.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它在文件顶部添加了 `CustomExtensions` 命名空间和一个 `using` 指令。
- en: Then, it calls `FancyDebug` on the `_state` string variable with dot notation
    inside `Initialize()` to print out the number of individual characters its value
    has.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它在 `Initialize()` 方法中使用点符号在 `_state` 字符串变量上调用 `FancyDebug`，以打印出其值中单个字符的数量。
- en: 'Extending the entire `string` class with `FancyDebug()` means that any string
    variable has access to it. Since the first extension method parameter has a reference
    to whatever `string` value that `FancyDebug()` is called on, its length will be
    printed out properly, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FancyDebug()` 扩展整个 `string` 类意味着任何字符串变量都可以访问它。由于第一个扩展方法参数有一个对 `FancyDebug()`
    被调用时的 `string` 值的引用，其长度将正确打印出来，如下所示：
- en: '![](img/B17573_10_06.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_10_06.png)'
- en: 'Figure 10.6: Example output from custom extension'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：自定义扩展的示例输出
- en: A custom class can also be extended using the same syntax, but it's more common
    to just add extra functionality directly into the class if it's one you control.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的语法，自定义类也可以被扩展，但如果您控制该类，通常更常见的是直接在类中添加额外的功能。
- en: The last topic we'll explore in this chapter is namespaces, which we briefly
    learned about earlier in the book. In the next section, you'll learn about the
    larger role that namespaces play in C# and how to create your type alias.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨最后一个主题，即命名空间，我们之前在书中简要介绍过。在下一节中，你将了解命名空间在C#中扮演的更大角色以及如何创建你的类型别名。
- en: Namespace conflicts and type aliasing
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间冲突和类型别名
- en: As your applications get more complicated, you'll start to section off your
    code into namespaces, ensuring that you have control over where and when it's
    accessed. You'll also use third-party software tools and plugins to save on time
    implementing a feature from the ground up that someone else has already made available.
    Both of these scenarios show that you're progressing with your programming knowledge,
    but they can also cause namespace conflicts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序变得更加复杂，你将开始将代码分成命名空间，确保你能够控制其访问的位置和时间。你还将使用第三方软件工具和插件来节省时间，实现别人已经提供的功能。这两种情况都表明你在编程知识方面正在进步，但它们也可能导致命名空间冲突。
- en: '**Namespace conflicts** happen when there are two or more classes or types
    with the same name, which happens more than you''d think.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间冲突**发生在有两个或更多具有相同名称的类或类型时，这种情况比你想的要多。'
- en: 'Good naming habits tend to produce similar results, and before you know it,
    you''re dealing with multiple classes named `Error` or `Extension`, and Visual
    Studio is throwing out errors. Luckily, C# has a simple solution to these situations:
    **type aliasing**.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的命名习惯往往会产生相似的结果，在你意识到之前，你可能会处理多个名为`Error`或`Extension`的类，而Visual Studio会抛出错误。幸运的是，C#对这些情况有一个简单的解决方案：**类型别名**。
- en: 'Defining a type alias lets you explicitly choose which conflicting type you
    want to use in a given class, or create a more user-friendly name for a long-winded
    existing one. Type aliases are added at the top of the class file with a `using`
    directive, followed by the alias name and the assigned type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型别名让你可以明确选择在给定类中要使用哪个冲突的类型，或者为冗长的现有类型创建一个更用户友好的名称。类型别名通过在类文件顶部添加一个`using`指令，然后是别名名称和分配的类型来添加：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For instance, if we wanted to create a type alias to refer to the existing
    `Int64` type, we could say the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个类型别名来引用现有的`Int64`类型，我们可以这样写：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that `CustomInt` is a type alias for the `System.Int64` type, the compiler
    will treat it as an `Int64`, letting us use it like any other type:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`CustomInt`是`System.Int64`类型的类型别名，编译器会将其视为`Int64`，让我们可以像使用任何其他类型一样使用它：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can use type aliasing with your custom types, or existing ones with the
    same syntax, as long as they're declared at the top of script files with the other
    `using` directives.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类型别名与你的自定义类型一起使用，或者使用具有相同语法的现有类型，只要它们在脚本文件顶部与`using`指令一起声明。
- en: For more information on the `using` keyword and type aliasing, check out the
    C# documentation at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`using`关键字和类型别名的更多信息，请查看C#文档中的[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive)。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With new modifiers, method overloading, class extensions, and object-oriented
    skills under our belts, we are only one step away from the end of our C# journey.
    Remember, these intermediate topics are intended to get you thinking about more
    complex applications of the knowledge you've been gathering throughout this book;
    don't think that what you've learned in this chapter is all that there is to know
    on these concepts. Take it as a starting point and continue from there.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了新的修饰符、方法重载、类扩展和面向对象技能之后，我们离C#之旅的终点只有一步之遥。记住，这些中级主题旨在让你思考你在本书中收集到的知识的更复杂应用；不要认为你在这章中学到的就是这些概念的全部。把它当作一个起点，并从这里继续前进。
- en: In the next chapter, we'll discuss the basics of generic programming, get a
    little hands-on experience with delegates and events, and wrap up with an overview
    of exception handling.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论泛型编程的基础，获得一些关于委托和事件的实践经验，并以异常处理的概述结束。
- en: Pop quiz – leveling up
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突击测验 – 提升等级
- en: Which keyword would mark a variable as unmodifiable but requires an initial
    value?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字会将变量标记为不可修改但需要初始值？
- en: How would you create an overloaded version of a base method?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何创建一个重载的基类方法？
- en: What is the main difference between classes and interfaces?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类和接口之间主要的区别是什么？
- en: How would you solve a namespace conflict in one of your classes?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何解决你其中一个类中的命名空间冲突？
- en: JOIN us on Discord!
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社群！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C# 专家以及哈里森·费罗内一起阅读这本书。提问，为其他读者提供解决方案，通过 *问我任何问题* 会话与作者聊天，以及更多。
- en: Join Now!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code_9781801813945.png)'
