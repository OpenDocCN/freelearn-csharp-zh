- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays and Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, you have certainly stored various collections within your applications,
    such as data of users, books, and logs. One of the natural ways of storing such
    data is by using arrays. However, have you ever thought about their variants?
    For example, have you heard about jagged arrays? In this chapter, you will see
    arrays in action, together with examples and detailed descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: You can use an array to `int`, `string`, as well as a user-defined class or
    record. Just keep in mind that **the number of elements in an array cannot be
    changed after initialization**. For this reason, you will not be able to easily
    add a new item at the end of the array or insert an element in a given position
    within the array while moving the remaining items one position further. If you
    need such features, you can use another data structure, namely a list and its
    variants, which will be described in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: While developing applications in the C# language, you can benefit from a few
    variants of arrays, namely **single-dimensional arrays**, **multi-dimensional
    arrays**, and **jagged arrays**. In this chapter, you will also get to know seven
    **sorting algorithms**, namely **selection sort**, **insertion sort**, **bubble
    sort**, **merge sort**, **Shell sort**, **quicksort**, and **heap sort**. For
    each, you will see an illustration-based example, the implementation code, and
    a step-by-step explanation. You will also see their performance analysis, presented
    with charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Single-dimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-dimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jagged arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-dimensional arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with the simplest variant of arrays, namely single-dimensional ones.
    `0`, while the last one has an index equal to the length of the array minus one.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a single-dimensional array
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better imagine a single-dimensional array, take your eyes off
    this book for a moment and look at the chest of drawers or wardrobe in your room.
    A standard chest of drawers consists of several drawers and a single-dimensional
    array looks similar. It also has several elements (as drawers), which are accessible
    via the index. You cannot change the size of the array in the same way as you
    cannot change the number of drawers since the furniture is prepared. An array
    has one significant advantage over a chest of drawers, namely all its “drawers”
    are always working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a single-dimensional array is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Example of a single-dimensional array](img/B18069_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Example of a single-dimensional array
  prefs: []
  type: TYPE_NORMAL
- en: 'It contains five elements with the following values: `9`, `-11`, `6`, `-12`,
    and `1`. The first element has an index equal to `0`, while the last one has an
    index equal to `4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a single-dimensional array, you need to declare and initialize it. The
    declaration is very simple because you just need to specify a type of element
    and a name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of an array with integer values is shown in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: numbers = new int[5];
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: int[] numbers = new int[5];
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: numbers[0] = 9;
  prefs: []
  type: TYPE_NORMAL
- en: numbers[1] = -11;
  prefs: []
  type: TYPE_NORMAL
- en: numbers[2] = 6;
  prefs: []
  type: TYPE_NORMAL
- en: numbers[3] = -12;
  prefs: []
  type: TYPE_NORMAL
- en: numbers[4] = 1;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: int[] numbers = new int[] { 9, -11, 6, -12, 1 };
  prefs: []
  type: TYPE_NORMAL
- en: int[] numbers = { 9, -11, 6, -12, 1 };
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'int[] numbers = [] operator and by specifying the index, as shown in the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: int last = numbers[numbers.Length - 1];
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: int last = numbers[^2], the third by [^3], and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other property is named `Rank` and returns the number of dimensions of
    the array. Usage of this property is shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'bool anyPositive = Array.TrueForAll to check whether all elements meet the
    provided predicate, such as to ensure that there are no zeros in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'int firstNegative = Array.FindAll method. The following code shows how to get
    all negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'int index = Array.ForEach. It allows you to perform some operations for all
    the elements in the array. As an example, you can use it to write the absolute
    value of each array element in the console, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, even for as simple a data structure as a single-dimensional
    array, you have a lot of useful built-in features. Let’s continue learning them
    and take a look at the two next methods, namely `Reverse` and `Sort`. According
    to their names, the first allows you to reverse the order of the elements, either
    for the whole array or only within some range. This is presented in the following
    line of code, which reverses the first three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Array.for loop and simply iterate through suitable indices and assign a given
    value. However, you can use the Fill method instead. The following line places
    3 as a value of all elements in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Array.Copy, which copies a range of elements from the source array to the destination
    array. You can use one out of a few variants, such as to specify indices from
    both arrays. As an example, let’s copy 3 elements (specified as length) from the
    numbers array (as the source array), starting from the first element (source index
    set to 0), and place them in the subarray array, starting from the first element
    (destination index set to 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'bool contains = numbers.Contains method is not the only available extension
    method. Among others, you can find All and Any. The first (All) checks whether
    all of the elements match the given predicate, while the other (Any) verifies
    whether at least one element meets the condition. You can use them to ensure that
    there are no zeros in the array and check whether there is at least one positive
    element, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: int min = numbers.Min();
  prefs: []
  type: TYPE_NORMAL
- en: 'int max = numbers.Average and Sum methods, which easily calculate the average
    value of all of the elements, as well as their sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After this short introduction to single-dimensional arrays, it’s high time to
    take a look at an example of how to apply such arrays in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can find a lot of interesting information about arrays and their various
    variants in the context of the C# language at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/).
  prefs: []
  type: TYPE_NORMAL
- en: Example – month names
  prefs: []
  type: TYPE_NORMAL
- en: To summarize what you’ve learned about single-dimensional arrays, let’s use
    an array to store names of months, written in English. Such names should be obtained
    automatically, not by hardcoding them in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, you create a new instance of the `CultureInfo` class (from the `System.Globalization`
    namespace), passing `en` as a parameter, to later get the names of months in English.
    Then, you declare a new single-dimensional array and initialize it with default
    values. It contains `12` elements to store the names of all the months in a year.
    Then, the `for` loop is used to iterate through the numbers of all months – that
    is, from `1` to `12`. For each of them, a `DateTime` instance representing the
    first day in a particular month from the current year is created.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the month is obtained by calling the `ToString` method on the `DateTime`
    instance, passing the proper format of the date (`MMMM`), as well as specifying
    the culture. Then, the name is stored in the array using the `[]` operator and
    an index of the element. It is worth noting that the index is equal to the current
    value of the `month` variable minus one. Such subtraction is necessary because
    the first element in the array has an index equal to zero, instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next interesting part of the code is the `foreach` loop, which iterates
    through all elements of the array. For each of them, the name of the month is
    shown in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, single-dimensional arrays are not the only available variant.
    You will learn more about multi-dimensional arrays in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-dimensional arrays
  prefs: []
  type: TYPE_NORMAL
- en: The arrays in the C# language do not need to have only one dimension. It is
    possible to create two-dimensional arrays as well. As you will see, multi-dimensional
    arrays are very useful and are frequently used while developing various applications.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a two-dimensional array
  prefs: []
  type: TYPE_NORMAL
- en: If you want to imagine a two-dimensional array, take a break, close your eyes,
    and play Sudoku. If you don’t know what this is, Sudoku is a popular game that
    requires you to fill empty cells of a 9x9 board with numbers from 1 to 9\. However,
    each row, each column, and each 3x3 box can only contain unique numbers. Surprise
    – this board forms a two-dimensional array! You can point to any place on the
    board by specifying its *row* and *column*, the same as in the case of a two-dimensional
    array. And if you are a bit tired of solving such puzzles with a pencil and a
    piece of paper, take a look at [*Chapter 9*](B18069_09.xhtml#_idTextAnchor367),
    *See in Action*, where you will learn how to create an algorithm for solving a
    Sudoku puzzle!
  prefs: []
  type: TYPE_NORMAL
- en: 'An example two-dimensional array that stores integer values is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Example of a two-dimensional array](img/B18069_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Example of a two-dimensional array
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to declare and initialize a two-dimensional array with `5`
    rows and `3` columns, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine a declaration with an initialization in a bit different way
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A small explanation is necessary for the way you access particular elements
    from a two-dimensional array. Let’s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: int[,,] numbers = new int[3, 2, 3];
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: int[,,,] numbers = new int[5, 4, 3, 2];
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 1   2   3   4   5   6   7   8   9  10
  prefs: []
  type: TYPE_NORMAL
- en: 2   4   6   8  10  12  14  16  18  20
  prefs: []
  type: TYPE_NORMAL
- en: 3   6   9  12  15  18  21  24  27  30
  prefs: []
  type: TYPE_NORMAL
- en: 4   8  12  16  20  24  28  32  36  40
  prefs: []
  type: TYPE_NORMAL
- en: 5  10  15  20  25  30  35  40  45  50
  prefs: []
  type: TYPE_NORMAL
- en: 6  12  18  24  30  36  42  48  54  60
  prefs: []
  type: TYPE_NORMAL
- en: 7  14  21  28  35  42  49  56  63  70
  prefs: []
  type: TYPE_NORMAL
- en: 8  16  24  32  40  48  56  64  72  80
  prefs: []
  type: TYPE_NORMAL
- en: 9  18  27  36  45  54  63  72  81  90
  prefs: []
  type: TYPE_NORMAL
- en: 10  20  30  40  50  60  70  80  90 100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: int[,] results = new int[10, 10];
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: for (int i = 0; i < results.GetLength(0); i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int j = 0; j < results.GetLength(1); j++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: results[i, j] = (i + 1) * (j + 1);
  prefs: []
  type: TYPE_NORMAL
- en: Console.Write($"{results[i, j],4}");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ConsoleColor GetColor(char terrain)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return terrain switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '''g'' => ConsoleColor.Green,'
  prefs: []
  type: TYPE_NORMAL
- en: '''s'' => ConsoleColor.Yellow,'
  prefs: []
  type: TYPE_NORMAL
- en: '''w'' => ConsoleColor.Blue,'
  prefs: []
  type: TYPE_NORMAL
- en: _ => ConsoleColor.DarkGray
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: char GetChar(char terrain)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return terrain switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '''g'' => ''\u201c'','
  prefs: []
  type: TYPE_NORMAL
- en: '''s'' => ''\u25cb'','
  prefs: []
  type: TYPE_NORMAL
- en: '''w'' => ''\u2248'','
  prefs: []
  type: TYPE_NORMAL
- en: _ => '\u25cf'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: using System.Text;
  prefs: []
  type: TYPE_NORMAL
- en: char[,] map =
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '{ ''s'', ''s'', ''s'', ''g'', ''g'', ''g'', ''g'', ''g'' },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ ''s'', ''s'', ''s'', ''g'', ''g'', ''g'', ''g'', ''g'' },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ ''s'', ''s'', ''s'', ''s'', ''s'', ''b'', ''b'', ''b'' },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ ''s'', ''s'', ''s'', ''s'', ''s'', ''b'', ''s'', ''s'' },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ ''w'', ''w'', ''w'', ''w'', ''w'', ''b'', ''w'', ''w'' },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ ''w'', ''w'', ''w'', ''w'', ''w'', ''b'', ''w'', ''w'' }'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: Console.OutputEncoding = Encoding.UTF8;
  prefs: []
  type: TYPE_NORMAL
- en: for (int r = 0; r < map.GetLength(0); r++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int c = 0; c < map.GetLength(1); c++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.ForegroundColor = GetColor(map[r, c]);
  prefs: []
  type: TYPE_NORMAL
- en: Console.Write(GetChar(map[r, c]) + " ");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Console.ResetColor();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: int[][] numbers = new int[4][];
  prefs: []
  type: TYPE_NORMAL
- en: numbers[0] = new int[] { 9, 5 };
  prefs: []
  type: TYPE_NORMAL
- en: numbers[1] = new int[] { 0, -3, 12 };
  prefs: []
  type: TYPE_NORMAL
- en: numbers[3] = new int[] { 54 };
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: int[][] numbers = new int[4][];
  prefs: []
  type: TYPE_NORMAL
- en: numbers[0] = [9, 5];
  prefs: []
  type: TYPE_NORMAL
- en: numbers[1] = [0, -3, 12];
  prefs: []
  type: TYPE_NORMAL
- en: numbers[3] = numbers array is initialized with default values, namely null.
    For this reason, we need to manually initialize particular elements, as shown
    in the following three lines of code. It is worth noting that the third element
    is not initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also write the preceding code in a different way, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s not all – an even shorter variant is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'How can you access a particular element from a jagged array? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: public enum MeanEnum { Car, Bus, Subway, Bike, Walk }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Random random = new();
  prefs: []
  type: TYPE_NORMAL
- en: int meansCount = Enum.GetNames<MeanEnum>().Length;
  prefs: []
  type: TYPE_NORMAL
- en: int year = DateTime.Now.Year;
  prefs: []
  type: TYPE_NORMAL
- en: MeanEnum[][] means = new MeanEnum[12][];
  prefs: []
  type: TYPE_NORMAL
- en: for (int m = 1; m <= 12; m++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int daysCount = DateTime.DaysInMonth(year, m);
  prefs: []
  type: TYPE_NORMAL
- en: means[m - 1] = new MeanEnum[daysCount];
  prefs: []
  type: TYPE_NORMAL
- en: for (int d = 1; d <= daysCount; d++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int mean = random.Next(meansCount);
  prefs: []
  type: TYPE_NORMAL
- en: means[m - 1][d - 1] = (MeanEnum)mean;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: string[] months = GetMonthNames();
  prefs: []
  type: TYPE_NORMAL
- en: int nameLength = months.Max(n => n.Length) + 2;
  prefs: []
  type: TYPE_NORMAL
- en: for (int m = 1; m <= 12; m++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string month = months[m - 1];
  prefs: []
  type: TYPE_NORMAL
- en: Console.Write($"{month}:".PadRight(nameLength));
  prefs: []
  type: TYPE_NORMAL
- en: for (int d = 1; d <= means[m - 1].Length; d++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: MeanEnum mean = means[m - 1][d - 1];
  prefs: []
  type: TYPE_NORMAL
- en: (char character, ConsoleColor color) = Get(mean);
  prefs: []
  type: TYPE_NORMAL
- en: Console.ForegroundColor = ConsoleColor.White;
  prefs: []
  type: TYPE_NORMAL
- en: Console.BackgroundColor = color;
  prefs: []
  type: TYPE_NORMAL
- en: Console.Write(character);
  prefs: []
  type: TYPE_NORMAL
- en: Console.ResetColor();
  prefs: []
  type: TYPE_NORMAL
- en: Console.Write(" ");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: string[] GetMonthNames()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: CultureInfo culture = new("en");
  prefs: []
  type: TYPE_NORMAL
- en: string[] names = new string[12];
  prefs: []
  type: TYPE_NORMAL
- en: foreach (int m in Enumerable.Range(1, 12))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: DateTime firstDay = new(DateTime.Now.Year, m, 1);
  prefs: []
  type: TYPE_NORMAL
- en: string name = firstDay.ToString("MMMM", culture);
  prefs: []
  type: TYPE_NORMAL
- en: names[m - 1] = name;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return names;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: (char Char, ConsoleColor Color) Get(MeanEnum mean)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return mean switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: MeanEnum.Bike => ('B', ConsoleColor.Blue),
  prefs: []
  type: TYPE_NORMAL
- en: MeanEnum.Bus => ('U', ConsoleColor.DarkGreen),
  prefs: []
  type: TYPE_NORMAL
- en: MeanEnum.Car => ('C', ConsoleColor.Red),
  prefs: []
  type: TYPE_NORMAL
- en: MeanEnum.Subway => ('S', ConsoleColor.Magenta),
  prefs: []
  type: TYPE_NORMAL
- en: MeanEnum.Walk => ('W', ConsoleColor.DarkYellow),
  prefs: []
  type: TYPE_NORMAL
- en: _ => throw new Exception("Unknown type")
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: void Sort(int[] a)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < a.Length - 1; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int minIndex = i;
  prefs: []
  type: TYPE_NORMAL
- en: int minValue = a[i];
  prefs: []
  type: TYPE_NORMAL
- en: for (int j = i + 1; j < a.Length; j++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (a[j] < minValue)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: minIndex = j;
  prefs: []
  type: TYPE_NORMAL
- en: minValue = a[j];
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: (a[i], a[minIndex]) = (a[minIndex], a[i]);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: int[] array = [-11, 12, -42, 0, 1, 90, 68, 6, -9];
  prefs: []
  type: TYPE_NORMAL
- en: Sort(array);
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(string.Join(" | ", array));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: -42 | -11 | -9 | 0 | 1 | 6 | 12 | 68 | 90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: void Sort(int[] a)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 1; i < a.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int j = i;
  prefs: []
  type: TYPE_NORMAL
- en: while (j > 0 && a[j] < a[j - 1])
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: (a[j], a[j - 1]) = (a[j - 1], a[j]);
  prefs: []
  type: TYPE_NORMAL
- en: j--;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: void Sort(int[] a)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < a.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int j = 0; j < a.Length - 1; j++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (a[j] > a[j + 1])
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: (a[j], a[j + 1]) = (a[j + 1], a[j]);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: void Sort(int[] a)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < a.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: bool isAnyChange = false;
  prefs: []
  type: TYPE_NORMAL
- en: for (int j = 0; j < a.Length - 1; j++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (a[j] > a[j + 1])
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: isAnyChange = true;
  prefs: []
  type: TYPE_NORMAL
- en: (a[j], a[j + 1]) = (a[j + 1], a[j]);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (!isAnyChange) { break; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: void Sort(int[] a)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (a.Length <= 1) { return; }
  prefs: []
  type: TYPE_NORMAL
- en: int m = a.Length / 2;
  prefs: []
  type: TYPE_NORMAL
- en: int[] left = GetSubarray(a, 0, m - 1);
  prefs: []
  type: TYPE_NORMAL
- en: int[] right = GetSubarray(a, m, a.Length - 1);
  prefs: []
  type: TYPE_NORMAL
- en: Sort(left);
  prefs: []
  type: TYPE_NORMAL
- en: Sort(right);
  prefs: []
  type: TYPE_NORMAL
- en: int i = 0, j = 0, k = 0;
  prefs: []
  type: TYPE_NORMAL
- en: while (i < left.Length && j < right.Length)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (left[i] <= right[j]) { a[k] = left[i++]; }
  prefs: []
  type: TYPE_NORMAL
- en: else { a[k] = right[j++]; }
  prefs: []
  type: TYPE_NORMAL
- en: k++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: while (i < left.Length) { a[k++] = left[i++]; }
  prefs: []
  type: TYPE_NORMAL
- en: while (j < right.Length) { a[k++] = right[j++]; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: int[] GetSubarray(int[] a, int si, int ei)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int[] result = new int[ei - si + 1];
  prefs: []
  type: TYPE_NORMAL
- en: Array.Copy(a, si, result, 0, ei - si + 1);
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: void Sort(int[] a)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int h = a.Length / 2; h > 0; h /= 2)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = h; i < a.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int j = i;
  prefs: []
  type: TYPE_NORMAL
- en: int ai = a[i];
  prefs: []
  type: TYPE_NORMAL
- en: while (j >= h && a[j - h] > ai)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: a[j] = a[j - h];
  prefs: []
  type: TYPE_NORMAL
- en: j -= h;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: a[j] = ai;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: for loop is used to calculate proper values of h, starting with the array (a)
    length divided by 2. It is further divided by 2 after each iteration and the last
    acceptable value is 1.
  prefs: []
  type: TYPE_NORMAL
- en: The next `for` loop calculates the `i` index, starting with `h`, and increases
    it until the end of the array is reached. This part is used to perform the insertion
    sort on virtual subarrays.
  prefs: []
  type: TYPE_NORMAL
- en: Within the loop, you can use the `ai` variable to store the current value of
    the element with the `i` index, so you can replace it later with another value.
    Then, a `while` loop is used to shift elements in the virtual subarray to find
    the correct location for `ai`. Finally, you store the `ai` variable in the location
    indicated by the `j` variable.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the implementation is very short and quite simple. What’s more,
    this algorithm is efficient and can be used for sorting large collections of data,
    as you will see later in this chapter. But what about the time complexity? **In
    the worst case, it is** **O(n**2**)**. However, its **average time complexity
    is about** **O(n log(n))**.
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort
  prefs: []
  type: TYPE_NORMAL
- en: The sixth sorting algorithm described in this book is **quicksort**. It is one
    of the popular algorithms from the divide and conquer group and divides a problem
    into a set of smaller ones. How does it work?
  prefs: []
  type: TYPE_NORMAL
- en: '**The algorithm picks some value (for example, from the last element of the
    array) as a pivot. Then, it reorders the array in such a way that values lower
    than the pivot are placed before it (forming the lower subarray), while values
    greater than or equal to the pivot are placed** **after it (the higher subarray).
    Such a process is called** **partitioning****. Next, the algorithm recursively
    sorts each of the aforementioned subarrays. Each subarray is further divided into
    the next two subarrays, and so on. The recursive calls stop when there are one
    or zero elements in a subarray because in such a case, there is nothing** **to
    sort**.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding description may sound a bit complicated. However, the following
    figure and the algorithm’s implementation should remove any doubts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the quicksort algorithm sorts a single-dimensional
    array with nine elements (`-11`, `12`, `-42`, `0`, `1`, `90`, `68`, `6`, and `-9`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Illustration of the quicksort algorithm](img/B18069_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Illustration of the quicksort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: In our case, it is assumed that the pivot is chosen as a value of the last element
    of the subarray that is currently being sorted. In *Step 1*, `-9` is chosen as
    the pivot. Then, it is necessary to swap `12` with `-42` (*Step 1*), as well as
    `12` with `-9` (*Step 2*), to ensure that only values lower than the pivot (`-11`,
    `-42`) are in the lower subarray and only values greater than or equal to the
    pivot (`0`, `1`, `90`, `68`, `6`, `12`) are placed in the higher subarray (*Step
    3*). Then, the algorithm is called recursively for both aforementioned subarrays,
    namely (`-11`, `-42`, from *Step 4*) and (`0`, `1`, `90`, `68`, `6`, `12`, from
    *Step 7*), so that they are processed in the same way as the input array.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, *Step 7* shows that `12` is chosen as the pivot. After partitioning,
    the subarray is divided into two other subarrays, namely (`0`, `1`, `6`) and (`90`,
    `68`). For both, other pivot elements are chosen, namely `6` and `68`. After performing
    such operations for all the remaining parts of the array, you receive the result
    shown in *Step 16*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that the pivot can be selected variously in other implementations
    of this algorithm. Now that you understand how the algorithm works, let’s proceed
    to its implementation. It’s no more complicated than the examples shown earlier,
    and it uses **recursion** to call the sorting method for subarrays. The main code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Sort` method takes only one parameter, namely the array that should be
    sorted. It just calls the `SortPart` method, which makes it possible to `SortPart`
    method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, the method checks whether the array (or subarray) has at least two elements
    by comparing the values of the `l` (*lower index*) and `u` (*upper index*) variables.
    If not, you return from this method. Otherwise, you perform the partitioning phase.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the pivot is chosen as a value of the last element in the array (or subarray)
    and stored as a value of the `pivot` variable. Then, a `for` loop is used to rearrange
    the array using comparisons and swapping elements. You need to perform this stage
    to ensure that values lower than the pivot are placed before it, while values
    greater than or equal to the pivot are placed after it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you store a new index of the pivot value as `p` and perform swapping
    to place it there. The `p` variable is also used to calculate lower and upper
    bounds for subarrays, namely as (`l`, `p-1`) and (`p+1`, `u`). Such ranges are
    then used while calling the `SortPart` method recursively for the lower and upper
    parts. That’s all!
  prefs: []
  type: TYPE_NORMAL
- en: What about the time complexity? It has **O(n log(n)) average time complexity,
    despite having O(n**2**) worst time complexity**. Does this look similar to Shell
    sort to you? If so, you are right! You are coming closer and closer to the end
    of this chapter, where you will see results from conducting performance tests
    on various sorting algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Heap sort
  prefs: []
  type: TYPE_NORMAL
- en: The last approach we’ll cover is based on an interesting data structure known
    as a **binary heap**. To give you a brief introduction, **it is a tree-based structure
    where each node contains either zero, one, or two child nodes**. You’ll learn
    more about trees and their variants later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: It won’t come as a surprise to you that the sorting solution is named **heap
    sort**. **First, the algorithm** **builds a** **max-heap** **from the array (the**
    **heapify** **operation). Then, it repeats a** **few steps until there is only
    one element in** **the heap:**
  prefs: []
  type: TYPE_NORMAL
- en: '**Swap the first element (root with the maximum value) with the** **last element.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Remove the last element (which is currently the maximum value) from** **the
    heap.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build the** **max-heap again.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By performing these operations, you efficiently receive the sorted array.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a new data structure must be introduced here, let’s look at what the binary
    heap looks like and how the algorithm operates to sort the example array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Illustration of the heap sort algorithm](img/B18069_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Illustration of the heap sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'The input array consists of six elements, namely `-11`, `12`, `-42`, `0`, `90`,
    and `-9`. You form a binary heap from it by placing the first element as a *root*
    and then by adding two of its child nodes: `12` and `-42`. You do not have more
    space at this level of the heap, so let’s add the following two elements from
    the array (`0` and `90`) as child nodes to the node with `12`. The last element
    from the array is left. You must place it as a child node of the node with `-42`.
    As you can see, you can easily map an array to a binary heap data structure and
    use an array as a data structure to store the data of a binary heap.'
  prefs: []
  type: TYPE_NORMAL
- en: Interesting properties of a binary heap
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a root node in a binary heap, represented by an array, is available
    at `array[0]`. If you need to access the data of a parent node of the *i*-th element,
    you can get it from `array[(i-1)/2]`. The left and right child nodes of the *i*-th
    element are available in `array[(2*i)+1]` and `array[(2*i)+2]`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The next operation, which takes an important role in the heap sort algorithm,
    is named `90` is located as the *root*. It contains `12` and `-9` as nodes. The
    node with `12` contains child nodes with smaller values, namely `0` and `-11`.
    The node with `-9` contains only one element, which is also smaller than it, namely
    `-42`.
  prefs: []
  type: TYPE_NORMAL
- en: Max-heap is not the only option
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the *heapify* operation to form the **min-heap**. It is similar
    to the max-heap, but each node needs to meet the condition that the values of
    its child nodes are greater than or equal to the parent node’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed to the second row of the preceding figure. Here, the last element
    of the array (`90`) is already sorted. This is the result of swapping the root
    (previously, `90`) with the last element in the array (previously, `-42`). Then,
    you must perform another *heapify* operation and receive the max-heap with `12`
    as the *root*. The aforementioned actions are repeated until the heap contains
    only one element. In the end, you receive the sorted array, as shown in the bottom-right
    corner of the preceding figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should be ready to analyze the implementation code in the
    C# language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `Sort` method contains two `for` loops. The first performs the initial *heapify*
    operation to prepare the *max-heap*. You can do so by calling the `Heapify` multiple
    times, namely in reverse order and on each node that is not a leaf. Then, you
    have the array with data forming the *max-heap*.
  prefs: []
  type: TYPE_NORMAL
- en: The second `for` loop is performed until there is at least one element in the
    heap. In each iteration, it swaps the *root* element (with an index equal to `0`)
    with the last element, which has an index equal to `i`. Then, you need to restore
    the *max-heap* property, which you do by calling the `Heapify` method, regarding
    the affected part of the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the code of the `Heapify` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It takes three parameters, namely an array (`a`), the number of elements in
    a heap (`n`), as well as an index of an element (`i`), which is a root of a subtree
    that should be *heapified*. First, you get an index of the maximum element (*root*,
    as `max`), as well as its left and right children (`l` and `r`, respectively).
    You can calculate indices according to the formulas presented earlier, namely
    `2*i+1` and `2*i+2`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following two lines, you check whether the left child index (`l`) is
    still within the heap (`l<n`) and whether the element with this index (`a[l]`)
    is greater than the current root value (`a[max]`). If so, you update the root
    index (`max`). In the same way, you check the right child and adjust the `max`
    variable, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, you check whether the *root* index changed during the mentioned
    operations. If so, this means that the current *root* is not the biggest value
    and you need to swap two elements in the array, namely representing the *root*
    (the `i` index) and the biggest value (the `max` index). Next, you recursively
    perform the *heapify* operation for the affected subtree, namely a tree with a
    new root value.
  prefs: []
  type: TYPE_NORMAL
- en: After this detailed explanation, it is worth mentioning the time complexity.
    It is very important in this case because the method is efficient and can be used
    successfully while sorting large data collections. **The time complexity is**
    **O(n log(n))**.
  prefs: []
  type: TYPE_NORMAL
- en: Despite learning about seven different sorting algorithms, please keep in mind
    that there are many more such algorithms available, including **block sort**,
    **tree sort**, **cube sort**, **strand sort**, and **cycle sort**. If you are
    interested in this topic, I strongly encourage you to take a look at them on your
    own. In the meantime, let’s compare the algorithms we’ve covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Performance analysis
  prefs: []
  type: TYPE_NORMAL
- en: To perform some tests, you need to configure your environment. So, let’s start
    by preparing the code for running various sorting algorithms using the same input
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember that each implementation presented in this chapter involves
    the `Sort` method, taking only one parameter (namely the `a` array)? Now, you
    can benefit from this assumption and create the `AbstractSort` abstract class,
    which requires you to implement this method while deriving from this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the abstract class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to prepare a separate class for each sorting algorithm (such
    as `SelectionSort` or `HeapSort`) according to the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Since all the classes representing sorting algorithms derive from the base
    abstract class (`AbstractSort`)you can easily create a list containing their instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting part of the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, you use a `for` loop to choose suitable values of `n`, which is the length
    of the input array used for sorting. You start with an array with zero elements
    (`n` = `0`) and end with hundreds of thousands of elements (`n` = `100000`), increasing
    the size by `10000` in each iteration. The values of `n` will be `0`, `10000`,
    `20000`, and `30000`, up to `100000`.
  prefs: []
  type: TYPE_NORMAL
- en: In each iteration, you create a new instance of the list (`milliseconds`) .
    Each its element stores a tuple consisting of two elements, namely a type of the
    sorting algorithm class (`Type`) and elapsed milliseconds of execution (`Ms`).
    Then, you use another `for` loop to perform such tests `5` times. In each of them,
    you get a random array (`array`) with a given size by calling `GetRandomArray`,
    which will be used as a template for each test. Next, you declare and initialize
    the input array (`input`).
  prefs: []
  type: TYPE_NORMAL
- en: The next part involves a `foreach` loop and iterates through all instances of
    classes deriving from `AbstractSort`. For each of them, you create an input array
    by copying elements from `array` to `input`. Then, you start the stopwatch and
    call the `Sort` method. As soon as it has finished running, you stop the stopwatch
    and add results to the `milliseconds` list.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the code is related to calculating the average result for each
    sorting algorithm and its presentation in the console. To do so, you use a few
    extension methods, such as `GroupBy`, `Select`, and `Average`, as well as a `foreach`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GetRandomArray` method was mentioned earlier, so let’s take a look at
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It uses the `Random` class to get a random integer value in the range of `<-100,000,
    100,000)`. The whole array is filled with such random values.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your environment is ready and you can perform tests! So, let’s
    run the code and see the results. I received the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.14 – Results of analyzing the performance of \uFEFFthe sorting algorithms](img/B18069_03_14.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Results of analyzing the performance of the sorting algorithms
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the table and its data, let’s take a look at the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Comparison of the sorting algorithms’ performance results](img/B18069_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Comparison of the sorting algorithms’ performance results
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the worst results are received for bubble sort, then the insertion
    sort and selection sort algorithms. For an array with 100,000 elements, they need
    almost 33 seconds (bubble sort), almost 14 seconds (insertion sort), and more
    than 5 seconds (selection sort). Such values look extremely high compared to the
    results of merge sort, Shell sort, quicksort, and heap sort. These algorithms
    needed between 12 and 28 milliseconds! Does this seem surprising? It shouldn’t
    if you recall time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s remember the average time complexity for the mentioned algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '*O(n*2*)*: Selection sort, insertion sort, and bubble sort'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*O(n log(n))*: Merge sort, Shell sort, quicksort, and heap sort'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oh, so it seems that such time complexities really have an importance! ;-) If
    you earlier had any doubts, it’s the high time to take attention to the algorithms
    you use in your applications. You should choose them carefully and optimize the
    solution to handle various amounts of data that need to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget about performance
  prefs: []
  type: TYPE_NORMAL
- en: Taking care of performance is important not only for sorting but for all operations
    that you perform in your mobile applications, web applications, APIs, and long-running
    background services. Let’s try to write efficient code and test it not only by
    meeting the functional requirements but also by taking care of non-functional
    ones, such as those related to performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chart, you almost cannot see any data regarding the algorithms
    with *O(n log(n))* time complexity, so let’s prepare another set of tests. Now,
    you can choose only these algorithms and increase the maximum number of *n* to
    one million! You can see my results in the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Comparison of the sorting algorithms’ performance results](img/B18069_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Comparison of the sorting algorithms’ performance results
  prefs: []
  type: TYPE_NORMAL
- en: There are some differences here, especially between quicksort and the remaining
    ones, namely Shell sort, merge sort, and heap sort. However, such changes are
    only visible with quite a huge input size and can be caused by the implementation
    details. All of the sorting algorithms with *O(n log(n))* time complexity are
    good solutions for sorting and can handle various amounts of data. It is also
    worth noting that these results were received on my device, so you may get different
    results. However, the relationship between the received number of elapsed milliseconds
    should be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are among the most common data structures that are used while developing
    various kinds of applications, such as mobile, web, or distributed ones. However,
    this topic is not as easy as it seems to be because even arrays can be divided
    into a few variants, namely **single-dimensional** and **multi-dimensional**,
    such as two-dimensional and three-dimensional, as well as **jagged arrays**, also
    referred to as arrays of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: While talking about arrays, don’t forget about **sorting algorithms**, which
    are one of the most popular algorithms used with this data structure. There are
    plenty of sorting algorithms that differ by their concept, application, implementation
    details, and performance results. In this chapter, you learned about seven different
    sorting algorithms, namely **selection sort**, **insertion sort**, **bubble sort**,
    **merge sort**, **Shell sort**, **quicksort**, and **heap sort**. Each of them
    was described, visualized in figures, and written in C# code.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you saw how important time complexity is and how
    big an impact it can have on **performance results** while you’re using algorithms
    with different computational complexity, such as *O(n*2*)* and *O(n log(n))*.
    You learned how to prepare a simple environment for the performance tests and
    run them to get the results. They were later shown in a table, as well as in charts,
    together with an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to learn other data structures? If so, proceed to the next chapter,
    where you’ll learn about various **variants of lists**, namely simple, generic,
    sorted, as well as singly, doubly, and circular linked. You will see their implementation
    and a few examples of how you can use them in real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
