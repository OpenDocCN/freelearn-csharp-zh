- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Better Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web APIs are the essence of the internet. They give developers the openness
    of the web and the ability to access any data on the internet. However, there
    are some best practices specific to APIs. The ability to select the right HTTP
    verb, how to document APIs, and testing APIs are just some of the topics we’ll
    cover.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, the techniques covered in this chapter are vast and dense. We’ll
    try to pack as much information as possible to help build quality APIs. We’ll
    also provide relevant links for further research.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating APIs quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardized Web API techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn how to design, create, test, and document APIs
    and how to perform full end-to-end tests of our APIs through a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll finish this chapter by reviewing some of the more common techniques for
    writing APIs, such as using the correct HTTP verbs and status codes, how to avoid
    large dependent resources, how to implement pagination into APIs, versioning an
    API, using DTOs instead of entities, and the best way to call other APIs from
    .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET 8, Web APIs take a front seat. Visual Studio has added new features
    to make Web APIs easier to build and test. For this chapter, we recommend using
    Visual Studio 2022, but the only requirement to view the GitHub repository is
    a simple text editor.
  prefs: []
  type: TYPE_NORMAL
- en: The code for *Chapter 09* is located in Packt Publishing’s GitHub repository,
    found at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  prefs: []
  type: TYPE_NORMAL
- en: Creating APIs quickly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With .NET 8, APIs are integrated into the framework, making it easier to create,
    test, and document. In this section, we’ll learn a quick and easy way to create
    a minimal API using Visual Studio 2022 and walk through the code it generates.
    We’ll also learn why minimal APIs are the best approach to building REST-based
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the features of .NET 8 is the ability to create minimal REST APIs extremely
    fast. One way is to use the dotnet command-line tool and the other way is to use
    Visual Studio. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio 2022 and create an **ASP.NET Core Web** **API** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the directory for the project, click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the project options, make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **Use Controllers** option to use minimal APIs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check **Enable OpenAPI support** to include support for API documentation using
    Swagger:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Options for a web minimal API project](img/B19493_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Options for a web minimal API project
  prefs: []
  type: TYPE_NORMAL
- en: Click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it – we have a simple API! It may not be much of one, but it’s still
    a complete API with Swagger documentation. Swagger is a tool for creating documentation
    for APIs and implementing the OpenAPI specification, whereas Swashbuckle is a
    NuGet package that uses Swagger for implementing Microsoft APIs. If we look at
    the project, there’s a single file called `Program.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening `Program.cs` will show the entire application. This is one of the strong
    points of .NET – the ability to create a scaffolded REST API relatively quickly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we created our “application” through the `.CreateBuilder()`
    method. We also added the `EndpointsAPIExplorer` and `SwaggerGen` services. `EndpointsAPIExplorer`
    enables the developer to view all endpoints in Visual Studio, which we’ll cover
    later. The `SwaggerGen` service, on the other hand, creates the documentation
    for the API when accessed through the browser. The next line creates our application
    instance using the `.``Build()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our app instance and we are in development mode, we can add Swagger
    and the Swagger UI. `.UseHttpsRedirection()` is meant to redirect to HTTPS when
    the protocol of a web page is HTTP to make the API secure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next line creates our GET `weatherforecast` route using `.MapGet()`. We
    added the `.WithName()` and `.WithOpenApi()` methods to identify the primary method
    to call and let .NET know it uses the OpenAPI standard, respectively. Finally,
    we called `app.Run()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we run the application, we will see the documented API on how to use our
    API and what’s available. Running the application produces the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Screenshot of our documented Web API](img/B19493_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Screenshot of our documented Web API
  prefs: []
  type: TYPE_NORMAL
- en: If we call the `/weatherforecast` API, we see that we receive JSON back with
    a 200 HTTP status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Results of our /weatherforecast API](img/B19493_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Results of our /weatherforecast API
  prefs: []
  type: TYPE_NORMAL
- en: Think of this small API as middleware with API controllers combined into one
    compact file (`Program.cs`).
  prefs: []
  type: TYPE_NORMAL
- en: Why minimal APIs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I consider minimal APIs to be a feature in .NET 8, even though it’s a language
    concept. If the application is extremely large, adding minimal APIs should be
    an appealing feature in four ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-contained**: Simple API functionality inside one file is easy to follow
    for other developers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Since we aren’t using controllers, the MVC overhead isn’t
    necessary when using these APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform**: With .NET, APIs can now be deployed on any platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-documenting**: While we can add Swashbuckle to other APIs, it also builds
    the documentation for minimal APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving forward, we’ll take these minimal APIs and start looking at Visual Studio’s
    testing capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created and reviewed a minimal API project in Visual Studio
    and why minimal APIs are important to our projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at designing APIs to help eliminate long resource
    (URL) names and standardized API naming.
  prefs: []
  type: TYPE_NORMAL
- en: Designing APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll cover the best approach for delivering intuitive and
    clear APIs to our users. The design of an API should be well thought-out and make
    sense when a user wishes to make a request.
  prefs: []
  type: TYPE_NORMAL
- en: To create a truly REST-based API, we must use a different mindset. We have to
    think of ourselves as a user and not a developer. When writing APIs, the users
    of the API *are* fellow developers.
  prefs: []
  type: TYPE_NORMAL
- en: Disconnecting from existing schemas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing APIs, we need a user’s perspective as opposed to basing an API
    on a class hierarchy or database schema. While developers may consider creating
    an API based on a class hierarchy or database schema as a shortcut, it could create
    more complexity as to which resource to use when retrieving data. One example
    is using an Order resource to find a contact. While an Order entity in Entity
    Framework Core could contain a `Company` property and we need the contact of the
    company, we wouldn’t write `https://www.myfakesite.com/Order/15/Company/Contact`.
    Basing a URL structure on an existing hierarchy or schema should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: It’s crucial to disregard existing schemas when designing a sensible API. Look
    at the API with new eyes to get the best design. The most popular APIs are the
    cleanest and most intuitive as they use the `collection/item/collection` syntax.
    A good example of this would be `/orders/15/companys`.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a system, look at how the user interacts with the website and extract the
    nouns from specific scenarios. These will become the resources for the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a user can perform the following actions in a shopping cart system:'
  prefs: []
  type: TYPE_NORMAL
- en: View a list of products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View a product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a product to the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a product from the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From these scenarios, we can extract the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re starting to identify and logically partition our APIs based on resources
    used throughout the system.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we can apply an HTTP verb to each resource based on each scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Relating HTTP verbs to resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have the primary resources, we can apply an HTTP verb to each resource
    based on the specific scenario we defined in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: When creating an API, it may be tempting to use the noun/verb syntax – for example,
    [https://www.myurl.com/products/get](https://www.myurl.com/products/get) or [https://www.myurl.com/getproducts](https://www.myurl.com/getproducts).
    This approach is counterproductive since web standards already exist for this
    exact purpose.
  prefs: []
  type: TYPE_NORMAL
- en: While this does work, it violates some of the REST principles (which we’ll get
    into when we looked at standardized web API techniques in the following sections).
    For now, let’s take it step by step and create a simple shopping cart API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each HTTP verb has a default operation based on its context:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Returns a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Creates a new resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Replaces an entire resource based on an identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: Updates specific items in a resource based on an identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Deletes a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, our scenarios in the previous section can begin to take shape
    based on the resources and their verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /api/products`: View a list of products'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/product/{id}`: View a product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/cart/{cartId}`: Add a product to the cart with `POST` data (that
    is, `new { ProductId = {productId}, Qty =` `1 }`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /api/cart/{cartId}`: Remove a product from the cart with `POST` data
    (that is, `new { ProductId = {``productId} }`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/cart/{cartId}`: Retrieve a cart with all the products in the cart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/cart/{cartId}/checkout`: Check out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have matched the resources to the scenarios that have been defined,
    we can move forward with returning status codes to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Returning HTTP status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the resources defined, we need to know whether the request was successful
    or not. This is where we return HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These status codes are broken into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1xx**: Information codes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2xx**: Success codes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3xx**: Redirection codes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4xx**: Client-side codes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5xx**: Server errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to unit tests, we look at a “happy” path and a broken path. But with
    APIs, we need to add an unrecoverable path in case an unrecoverable error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at two of the URLs and what status codes they should return.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /api/products` will return the following status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200 Success**: Products were successfully returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**500 Internal Server Error**: Optional if something caused a problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the API was successful, it will return a list of the products with a 200
    status code. If there are issues, it will return a 500 status code. The API could
    also return additional status codes. For example, if an API call is made for specific
    users, the API could return a 401, which is an Unauthorized status code.
  prefs: []
  type: TYPE_NORMAL
- en: '`POST /api/cart/{cartId}` with a post body of (`new { ProductId = {productId},
    Qty = 1 }`) will return the following status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**201 Created**: The item was created and added to the cart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**202 Accepted**: The item was added to the cart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404 Not Found**: The cart or product wasn’t found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**500 Internal Server Error**: An unrecoverable error occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this API, we can return either a 201 Created or a 202 Accepted status code.
    If we couldn’t find the cart or product to add to the cart, return a 404 status
    code. Otherwise, return a 500 status code.
  prefs: []
  type: TYPE_NORMAL
- en: While these two examples are not set in stone, they should provide a template
    for the team to discuss what business rules dictate the status codes that are
    returned to the user. Whatever status codes are returned, they should provide
    enough context as to the request made through the API.
  prefs: []
  type: TYPE_NORMAL
- en: Some APIs seen in the wild use an all-or-nothing approach; they either return
    a 200 or a 500\. It depends on how much information we want to send back to the
    client. These types of APIs feel like they’re missing more functionality, such
    as Unauthorized (401) or Not Found (404) status codes. It’s a best practice to
    include as much information as we can to the caller of the API.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes are standard in web development and are presented through
    the RFC `HttpStatusCodeEnum` class with every status code at [https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode](https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode),
    along with `IActionResults` such as `Ok(object)`. Specific status codes can be
    found at [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to design APIs and broke down each step – that
    is, disconnecting from the technology, identifying the resources, knowing the
    right verbs to apply to resources, and providing the correct response codes to
    our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will look at two ways to test our APIs: one in Visual
    Studio with the new Endpoints Explorer and the other by creating a complete integration
    test.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have our APIs designed and created, we need a way to test them in our
    IDE and our integration tests. Luckily, Visual Studio has added the new Endpoints
    Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn two ways to test our APIs. One way is through our
    development environment using Visual Studio. The second way we’ll test our API
    is through integration tests. If we have a CI/CD pipeline (which we should from
    [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031)), these will automatically run
    to confirm our APIs work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Endpoints Explorer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Historically, developers using Visual Studio had to run a separate tool to
    test their APIs, but with the latest version of .NET 8, the Visual Studio team
    added a new panel called **Endpoints Explorer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Endpoints Explorer](img/B19493_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Endpoints Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a collection of APIs defined in the `Program.cs` file, our collection
    will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Collection of APIs in Endpoints Explorer](img/B19493_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Collection of APIs in Endpoints Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-clicking on an API will generate a request in a new HTTP Editor. The
    HTTP Editor allows custom-defined variables for the APIs listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Sample API collection in the HTTP Editor](img/B19493_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Sample API collection in the HTTP Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9**.6*, the HTTP Editor uses the following commands to issue HTTP
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@`: Creates a variable for the file (for example, `@variable` = `value`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`//`: This specifies comments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`###`: This specifies the end of an HTTP request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<HTTP Verb>`: Creates a REST-based request, including `DELETE`, `GET`, `HEAD`,
    `OPTIONS`, `PATCH`, `POST`, `PUT`, and `TRACE` requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Headers>`: Adds headers directly after defining the URL so that they’re included
    in the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have defined the APIs, there are green arrows in the left gutter. Run
    the application to test the API locally. Pressing the arrow in the far left gutter
    *while the API is running* will produce results in the right-hand pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Results of the /attractions request](img/B19493_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Results of the /attractions request
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we tested the `/attractions` request, received the data, and
    displayed it on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this important?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By using this new Visual Studio feature, we gain the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized APIs**: We have a catalog of all of our APIs in one place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.http` file, execute sample requests, and understand what each API does in
    the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IDE-integrated**: Additional tools aren’t necessary for testing our APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This new feature is extremely helpful to developers looking to test existing
    APIs locally and also complements new minimal APIs introduced into the system.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Endpoints Explorer material
  prefs: []
  type: TYPE_NORMAL
- en: For additional material on Endpoints Explorer, Sayed Ibrahim Hashimi has provided
    a great write-up about everything it can do at [https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer](https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about Endpoints Explorer, how we can use it to help
    test APIs locally, and why it’s important. In the next section, we’ll take our
    APIs and learn how to use integration tests to produce quick results.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned about how to use Endpoints Explorer to test
    our APIs. However, we shouldn’t have to install Visual Studio on a server to test
    our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at applying an integration server for our APIs
    to achieve a complete end-to-end test.
  prefs: []
  type: TYPE_NORMAL
- en: When we created unit tests back in [*Chapter 8*](B19493_08.xhtml#_idTextAnchor189),
    we created an in-memory representation of a database. We can create a similar
    environment where we can spin up and tear down the entire environment for API
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: In our CI/CD pipelines, we can build a disposable server for our integration
    tests to provide a full end-to-end test with APIs and services and a disposable
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Building the integration server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since .NET provides us with a simple `Program.cs` file for our applications,
    we can wrap the entire application and replace the services we want to mimic with
    a web and database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set up the environment using the `WebApplicationFactory` class. We include
    the minimal API project as a dependency in our `Api.Tests` project. Once we have
    our dependency in the program, we can create our `WebApplicationFactory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we inherited from `WebApplicationFactory<Program>`.
    The generic `<Program>` comes from the included dependency we referenced. Then,
    we created a root for our in-memory database and proceeded to configure our services
    by removing all instances of `DbContextOptionsBuilder<ThemeParkDbContext>`. Once
    we’ve removed these, we can create a new scoped reference to the same type with
    our updated settings for the database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we added our new `ThemeParkDbContext` with our updated connection using
    a SQLite database. Remember, Entity Framework Core will automatically create the
    structure of our entire database with the `.EnsureCreated()` method. Finally,
    we added a dependency injection registration for `IThemeParkDbContext` for the
    services in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it for our integration server. Now, we can use `TestThemeParkApiApplication`
    in our integration test. For example, if we want to create a test for our `/attractions`
    API, our integration test will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we initialized `TestThemeParkApiApplication`
    on setup so that every instance is new through the `.EnsureCreated()` method.
    `_app.CreateClient` gives us `HttpClient` to make a call to a URL. We make a call
    to our `/attractions` API and compare it with a resource string we created instead
    of cluttering our test methods with large JSON strings. Finally, our test compares
    the JSON results with what’s returned from an API.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to create entire front-to-back integration tests proving the APIs,
    Entity Framework queries, and database code work as expected while running through
    a CI/CD pipeline with successful tests should instill confidence about the code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to take APIs and test them in Visual Studio’s
    Endpoints Explorer. We also learned how to take those APIs and make them testable
    in a CI/CD pipeline by wrapping our API project using `WebApplicationFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some of the common practices used in the industry
    when building APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Standardized Web API techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to use HTTP verbs and status codes properly,
    how to avoid large dependent resources, how to create paginations for APIs, how
    to version an API, using DTOs instead of entities, and the best way to make API
    calls from .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Using the right HTTP verbs and status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve looked at how to use HTTP verbs and how to return status codes.
    While this may seem like a trivial thing, some systems ignore these standards
    and use POSTs all the time, regardless of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger provides a great template for documenting APIs and with Visual Studio’s
    new Endpoints Explorer, Visual Studio brings this fundamental documentation down
    to the developer’s IDE, making the API easier to read and implement in other projects,
    showing developers what verbs to use and what status codes are expected.
  prefs: []
  type: TYPE_NORMAL
- en: In our example of a shopping cart API earlier in this chapter, users were going
    to add products to a cart and proceed to check out. They were going to use a cart
    to begin this process. The function of checking out led us to use the cart API
    with a method of checkout (`/cart/checkout`), which makes perfect sense. We should
    take the user’s actions and match them to actions in the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Beware dependent resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But how far do I take my API based on resources? What if one resource belongs
    to another resource and that’s dependent on another resource, and so on?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example: `/users/{userId}/projects/{projectId}/tasks`.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to get a user’s tasks for a project, but this URL seems a bit long,
    doesn’t it? How do we break this down into something a bit more manageable? Anything
    more than three levels deep is simply asking for trouble.
  prefs: []
  type: TYPE_NORMAL
- en: This URL requires a more granular approach – that is, breaking out each resource.
    Instead of the preceding URL, a better approach would be to use `/users/{userId}/projects`
    to retrieve a list of projects a user is working on at a time. The next URL would
    provide the tasks based on the selected project and look like `/projects/{projectId}/tasks`.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we all know everything is a compromise. In this case, we are
    providing a simpler API but requiring two calls instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: These are discussions to be had with team members, but essentially, the smaller
    the URL, the easier it is to implement. The longer the URL, the more resource
    lookups are necessary to fulfill the request.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination in API results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most API calls, results are returned in a raw, **JavaScript Object Notation**
    (**JSON**) format, usually as a collection or a single item. What if the client
    side needs paginated results and they only want one page of data for now?
  prefs: []
  type: TYPE_NORMAL
- en: 'To assist client-side developers, a JSON result could contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While returning results as a collection is usually required, some fields to
    return in the header are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Total`: Total number of records'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PageSize`: How many records are returned in this response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotalPages`: Specifies the total number of pages based on `PageSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CurrentPage`: Specifies what page we are currently on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Next` and `Previous`: Are there enough records to move back and forward?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sort`: Specifies how the results are sorted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Filter`: Specifies what filter was applied to the results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header is meant to help our fellow client-side developer make the most of
    the response. While this isn’t a comprehensive list of fields to include, it should
    be implemented with consistency across every single response when displaying a
    subset of records on the client.
  prefs: []
  type: TYPE_NORMAL
- en: A “status code” field or “success” field in the header should be avoided since
    HTTP status codes are considered the expected response.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating APIs, by default, they’ll more than likely be in a raw state
    with no versioning in place. There are four types of versioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No versioning**: When we create our first API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v1/users`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/users/?version=1`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`custom-header` to place the version into the header:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The most common versioning technique that’s used is URI versioning. While everyone’s
    mileage may vary, this technique is appealing because it’s immediately obvious
    which version we’re using.
  prefs: []
  type: TYPE_NORMAL
- en: Use DTOs, not entities!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While testing our API, we weren’t returning entities (`Attraction` or `Location`).
    Instead, we were returning **data transfer objects** (**DTOs**), which are a subset
    of properties.
  prefs: []
  type: TYPE_NORMAL
- en: Our security chapter ([*Chapter 4*](B19493_04.xhtml#_idTextAnchor086)) mentioned
    not to expose too much when it comes to primary keys or sensitive information.
    DTOs give the developer a chance to pick and choose which properties should be
    exposed to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our `Attraction` DTO is meant to provide a minimal amount of information;
    we’ll discuss this after we look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a simplified `AttractionDto` class containing simple properties.
    We also have a `LocationName` property based on our dependent `Location` class.
  prefs: []
  type: TYPE_NORMAL
- en: While we have this as a `.ToDto()` method, we could create other DTO extension
    methods to return different data in a `.ToDifferentDto()` method or whatever we
    want to call it.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to use DTOs instead of Entity Framework entities is the potentially
    recursive nature of navigational properties. When an entity is returned from an
    API, it’s turned into a JSON object. If we have a nested entity, it’ll follow
    it down the chain. It’s better to isolate and distill an entity’s properties down
    to their native types for basic consumption on the client side when they’re returned
    from the API.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid new instances of HttpClient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the majority of this chapter discussed creating and testing APIs, I feel
    we need to mention how to consume them in a .NET application as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to consume a web API, such as using `WebRequest` or `WebClient`,
    but for most purposes, the use of the `HttpClient` class is recommended because
    of its flexibility and modernization. The `WebRequest` and `WebClient` classes
    were included for the transition of legacy applications. With that said, it’s
    easy to create a new instance of `HttpClient`, but it’s not the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft states that `HttpClient` should only be used once per the lifetime
    of an application. If we create instances of `HttpClient` in multiple locations
    in our application, we are hindering the performance and scalability opportunities.
    It causes an issue called TCP port exhaustion if the rate of requests is too high,
    so it’s best to avoid code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Some developers may take this a step further and decide the following code
    snippet is better by wrapping a `using` statement to dispose of an `HttpClient`
    class properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this code is that we’re still creating another instance of
    `HttpClient`, still causing port exhaustion, and still disposing of it when we’ll
    more than likely need it later.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET Core 2.1, Microsoft created an `IHttpClientFactory` class to deliver
    a single instance of `HttpClient`. We can simply ask it for an `HttpClient` instance
    and we’ll receive one. The best news is it can be dependency injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code becomes easier to work with once we’ve injected the class through
    constructors, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we ask `HttpClientFactory` for a client using `.CreateClient()`, it won’t
    create a new instance of `HttpClient` unless it has to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of the `.CreateClient()` method as using a singleton design pattern behind
    the scenes, similar to the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, the preceding code is *not* thread-safe; it has been provided
    to show the concept of a singleton design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We always get an instance of `HttpClient`, which is a better way to make server-side
    API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about several techniques, such as how to design
    an API by disconnecting from technology by becoming a user of the application,
    identifying the resources, and using the right HTTP verbs and correct status codes.
    We also learned how to create, test, and document APIs, along with why minimal
    APIs are important. After, we learned how to use the new Endpoints Explorer in
    Visual Studio 2022, as well as how to build an automated end-to-end test of our
    APIs in a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Once we understood the process of writing APIs, we examined what standards were
    used in the industry to create common and useful APIs, such as using the correct
    HTTP verbs and status codes, avoiding large URLs, how to use pagination with APIs,
    versioning our API, using DTOs instead of entities, and the optimal way to use
    `HttpClient` when making API calls from .NET.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at how to improve performance across various
    topics we’ve covered in this book, and we’ll also provide some new performance
    tips.
  prefs: []
  type: TYPE_NORMAL
