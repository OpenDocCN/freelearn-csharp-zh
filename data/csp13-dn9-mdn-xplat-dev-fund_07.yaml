- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Packaging and Distributing .NET Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和分发.NET类型
- en: This chapter is about how C# keywords are related to .NET types and the relationship
    between namespaces and assemblies. You’ll become familiar with how to package
    and publish your .NET apps and libraries for cross-platform use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了C#关键字与.NET类型之间的关系以及命名空间和程序集之间的关系。你将熟悉如何打包和发布你的.NET应用程序和库以实现跨平台使用。
- en: There are several online sections for this chapter, and you will find links
    to them all at the end of the chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有几个在线部分，你将在章节末尾找到所有链接。
- en: In an online-only section, *Decompiling .NET assemblies*, we cover how to decompile
    .NET assemblies for learning purposes and why you cannot prevent others from decompiling
    your code. In another online-only section, *Porting from .NET Framework to modern
    .NET*, you can learn how to use legacy .NET Framework libraries in .NET libraries
    and how it is possible to port legacy .NET Framework code bases to modern .NET.
    Finally, in a third online-only section, *Creating source generators*, you will
    learn how to create source generators that can dynamically add source code to
    your projects—a very powerful feature.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅在线的部分，*反编译.NET程序集*，我们介绍了如何为了学习目的反编译.NET程序集，以及为什么你无法阻止他人反编译你的代码。在另一个仅在线的部分，*从.NET
    Framework迁移到现代.NET*，你可以学习如何在.NET库中使用遗留的.NET Framework库，以及如何将遗留的.NET Framework代码库迁移到现代.NET。最后，在第三个仅在线的部分，*创建源生成器*，你将学习如何创建可以动态向你的项目添加源代码的源生成器——这是一个非常强大的功能。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: The road to .NET 9
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 9之路
- en: Understanding .NET components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解.NET组件
- en: Publishing your applications for deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布你的应用程序以进行部署
- en: Native ahead-of-time compilation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生提前编译
- en: Packaging your libraries for NuGet distribution
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包你的库以进行NuGet分发
- en: Working with preview features
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预览功能
- en: The road to .NET 9
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 9之路
- en: This part of the book is about the functionality in the **Base Class Library**
    (**BCL**) APIs provided by .NET and how to reuse functionality across all the
    different .NET platforms, using .NET Standard.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的这一部分介绍了.NET提供的**基类库**（**BCL**）API中的功能，以及如何使用.NET Standard跨所有不同的.NET平台重用功能。
- en: .NET Standard-compatible frameworks
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Standard兼容的框架
- en: From .NET Core 2.0 onward, the support for a minimum of .NET Standard 2.0 is
    important because it provides many of the APIs that were missing from the first
    version of .NET Core. The 15 years’ worth of libraries and applications that .NET
    Framework developers had available to them that are relevant for modern development
    have now been migrated to .NET, and they can run cross-platform on macOS and Linux
    variants, as well as on Windows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET Core 2.0开始，对至少.NET Standard 2.0的支持很重要，因为它提供了许多在.NET Core的第一个版本中缺失的API。对于现代开发相关的15年积累的库和应用程序，.NET
    Framework开发者现在可以迁移到.NET，并且它们可以在macOS和Linux变体以及Windows上跨平台运行。
- en: '.NET Standard 2.1 added about 3,000 new APIs. Some of those APIs need runtime
    changes that would break backward compatibility. To summarize:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard 2.1添加了大约3,000个新API。其中一些API需要运行时更改，这可能会破坏向后兼容性。总结如下：
- en: .NET Framework 4.8 only implements .NET Standard 2.0.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework 4.8仅实现了.NET Standard 2.0。
- en: .NET Core 3.0, Xamarin, Mono, and Unity implement .NET Standard 2.1.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 3.0、Xamarin、Mono和Unity实现了.NET Standard 2.1。
- en: .NET 5 removed the need for .NET Standard because all project types can now
    target a single version of .NET. The same applies to .NET 6 and later. Each version
    from .NET 5 onward is backward compatible with previous versions. This means a
    class library that targets .NET 5 can be used by any .NET 5 or later projects
    of any type. Now that .NET versions have been released with full support for mobile
    and desktop apps built using .NET MAUI, the need for .NET Standard has been further
    reduced.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5移除了.NET Standard的需求，因为所有项目类型现在都可以针对.NET的单个版本。同样的情况也适用于.NET 6及以后的版本。从.NET
    5开始的每个版本都与之前的版本向后兼容。这意味着一个针对.NET 5的类库可以被任何类型的.NET 5或更高版本的任何项目使用。现在，随着.NET版本发布了对使用.NET
    MAUI构建的移动和桌面应用程序的全面支持，对.NET Standard的需求进一步减少。
- en: Since you might still need to create class libraries for legacy .NET Framework
    projects or legacy Xamarin mobile apps, there is still a need to create .NET Standard
    2.0 class libraries.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可能仍然需要为遗留的.NET Framework项目或遗留的Xamarin移动应用程序创建类库，因此仍然需要创建.NET Standard 2.0类库。
- en: Officially, you must also use a .NET Standard 2.0 class library to create a
    source generator even though it’s a rather modern feature of .NET.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，即使它是一个相对较新的功能，您也必须使用 .NET Standard 2.0 类库来创建源生成器。
- en: 'To summarize the progress that .NET has made since the first version of .NET
    Core in 2016, I have compared the major .NET Core and modern .NET versions with
    the equivalent .NET Framework versions in the following list:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结自 2016 年 .NET Core 首个版本以来 .NET 所取得的进展，我已将主要的 .NET Core 和现代 .NET 版本与以下列表中的等效
    .NET Framework 版本进行了比较：
- en: '**.NET Core 1.x**: Much smaller API compared to .NET Framework 4.6.1, which
    was the current version in March 2016.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Core 1.x**：与 .NET Framework 4.6.1 相比，API 小得多，这是 2016 年 3 月的当前版本。'
- en: '**.NET Core 2.x**: Reached API parity with .NET Framework 4.7.1 for modern
    APIs because they both implement .NET Standard 2.0.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Core 2.x**：由于它们都实现了 .NET Standard 2.0，因此与现代 API 相比，API 与 .NET Framework
    4.7.1 相等。'
- en: '**.NET Core 3.x**: Larger API compared to .NET Framework for modern APIs because
    .NET Framework 4.8 does not implement .NET Standard 2.1.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Core 3.x**：与 .NET Framework 相比，API 更大，因为 .NET Framework 4.8 没有实现 .NET
    Standard 2.1。'
- en: '**.NET 5**: Even larger API compared to .NET Framework 4.8 for modern APIs,
    with much-improved performance.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 5**：与 .NET Framework 4.8 相比，API 更大，特别是对于现代 API，性能有了显著提升。'
- en: '**.NET 6**: Continued improvements to performance and expanded APIs, with optional
    support for mobile apps in .NET MAUI, which was added in May 2022.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 6**：继续改进性能和扩展 API，并在 2022 年 5 月添加了对 .NET MAUI 的可选支持。'
- en: '**.NET 7**: Final unification with support for mobile apps, with .NET MAUI
    available as an optional workload. This book does not cover .NET MAUI development.
    Packt has multiple books that specialize in .NET MAUI, and you can find them by
    searching their website.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 7**：与支持移动应用的支持最终统一，.NET MAUI 作为可选工作负载可用。本书不涵盖 .NET MAUI 开发。Packt 有多本专注于
    .NET MAUI 的书籍，您可以通过搜索他们的网站找到它们。'
- en: '**.NET 8**: Continued to improve the platform and should be used for all new
    development if you need long-term support.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 8**：继续改进平台，如果您需要长期支持，则应用于所有新的开发。'
- en: '**.NET 9**: Continues to improve the platform, especially with performance,
    and should be used if you are comfortable with standard-term support. You can
    see the .NET 9 release notes for each preview at the following link: [https://github.com/dotnet/core/discussions/9234](https://github.com/dotnet/core/discussions/9234).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 9**：继续改进平台，特别是在性能方面，如果您对标准期限支持感到舒适，则应使用它。您可以在以下链接中查看每个预览版本的 .NET 9 发布说明：[https://github.com/dotnet/core/discussions/9234](https://github.com/dotnet/core/discussions/9234)。'
- en: 'You can read more details in the GitHub repository at the following link: [https://github.com/markjprice/cs13net9/blob/main/docs/ch07-features.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-features.md).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接的 GitHub 仓库中阅读更多详细信息：[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-features.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-features.md)。
- en: '**More Information**: A useful way to compare two versions of .NET is the APIs
    of the .NET website. For example, you can compare what’s new in .NET 9 compared
    to .NET 8 at the following link: [https://apisof.net/catalog?diff=net8.0-vs-net9.0](https://apisof.net/catalog?diff=net8.0-vs-net9.0).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：比较两个 .NET 版本的一个有用方法是 .NET 网站的 API。例如，您可以在以下链接中比较 .NET 9 与 .NET 8 的新功能：[https://apisof.net/catalog?diff=net8.0-vs-net9.0](https://apisof.net/catalog?diff=net8.0-vs-net9.0)。'
- en: Checking your .NET SDKs for updates
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查您的 .NET SDKs 是否有更新
- en: 'Microsoft introduced a command with .NET 6 to check the versions of .NET SDKs
    and runtimes that you have installed, and it warns you if any need updating. For
    example, enter the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在 .NET 6 中引入了一个命令来检查您已安装的 .NET SDKs 和运行时的版本，如果任何需要更新，它会向您发出警告。例如，输入以下命令：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will see results, including the status of available updates, as shown in
    the following partial output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到结果，包括可用更新的状态，如下所示的部分输出：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Good Practice**: To maintain support from Microsoft, you must keep your .NET
    SDKs and .NET runtimes up to date with the latest patches.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：为了保持微软的支持，您必须确保您的 .NET SDKs 和 .NET 运行时始终更新到最新的补丁。'
- en: 'A related third-party tool is `dotnet-outdated`, which allows you to quickly
    report on any outdated NuGet packages in your .NET projects. You can learn more
    about it at the following link: [https://github.com/dotnet-outdated/dotnet-outdated](https://github.com/dotnet-outdated/dotnet-outdated).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的第三方工具是 `dotnet-outdated`，它允许您快速报告 .NET 项目中任何过时的 NuGet 包。您可以在以下链接中了解更多信息：[https://github.com/dotnet-outdated/dotnet-outdated](https://github.com/dotnet-outdated/dotnet-outdated)。
- en: Understanding .NET components
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 .NET 组件
- en: '.NET is made up of several pieces, which are shown in the following list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 由几个部分组成，以下列表显示了这些部分：
- en: '**Language compilers**: These turn your source code, written with languages
    such as C#, F#, and Visual Basic, into **intermediate language** (**IL**) code
    stored in assemblies. With C# 6 and later, Microsoft switched to an open-source
    rewritten compiler known as **Roslyn**, which is also used by Visual Basic.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言编译器**：这些将您使用 C#、F# 和 Visual Basic 等语言编写的源代码转换为存储在组件中的**中间语言**（**IL**）代码。从
    C# 6 及以后版本开始，微软切换到了一个开源重写的编译器，称为 **Roslyn**，它也被 Visual Basic 使用。'
- en: '**Common Language Runtime** (**CLR**): This runtime loads assemblies, compiles
    the IL code stored in them into native code instructions for your computer’s CPU,
    and executes the code within an environment that manages resources, such as threads
    and memory.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共语言运行时**（**CLR**）：此运行时加载组件，将存储在其中的 IL 代码编译成计算机 CPU 的本地代码指令，并在管理资源（如线程和内存）的环境中执行代码。'
- en: '**Base Class Libraries** (**BCL**): These are prebuilt assemblies of types
    packaged and distributed using NuGet to perform common tasks when building applications.
    You can use them to quickly build anything you want, rather like combining LEGO™
    pieces.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基类库**（**BCL**）：这些是使用 NuGet 打包和分发的预构建组件集合，用于在构建应用程序时执行常见任务。您可以使用它们快速构建任何您想要的东西，就像组合乐高™
    瓦片一样。'
- en: Assemblies, NuGet packages, and namespaces
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件、NuGet 包和命名空间
- en: An **assembly** is where a type is stored in the filesystem. Assemblies are
    a mechanism for deploying code. For example, the `System.Data.dll` assembly contains
    types to manage data. To use types in other assemblies, they must be referenced.
    Assemblies can be static (pre-created) or dynamic (generated at runtime). Dynamic
    assemblies are an advanced feature that we will not cover in this book. Assemblies
    can be compiled into a single file as a DLL (class library) or an EXE (console
    app).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是类型在文件系统中存储的地方。组件是部署代码的机制。例如，`System.Data.dll` 组件包含用于管理数据的类型。要使用其他组件中的类型，它们必须被引用。组件可以是静态的（预先创建）或动态的（在运行时生成）。动态组件是本书不会涉及的高级功能。组件可以编译为单个文件，作为
    DLL（类库）或 EXE（控制台应用程序）。'
- en: Assemblies are distributed as **NuGet packages**, which are files that are downloadable
    from public online feeds and can contain multiple assemblies and other resources.
    You will also hear about **project SDKs**, **workloads**, and **platforms**, which
    are combinations of NuGet packages.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 组件以 **NuGet 包**的形式分发，这些是从公共在线源中可下载的文件，可以包含多个组件和其他资源。您还会听到关于 **项目 SDK**、**工作负载**和**平台**的内容，这些都是
    NuGet 包的组合。
- en: 'Microsoft’s NuGet feed is found here: [https://www.nuget.org/](https://www.nuget.org/).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的 NuGet 源位于此处：[https://www.nuget.org/](https://www.nuget.org/)。
- en: What is a namespace?
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间是什么？
- en: A namespace is the address of a type. Namespaces are a mechanism to uniquely
    identify a type by requiring a full address, rather than just a short name. In
    the real world, *Bob of 34 Sycamore Street* is different from *Bob of 12 Willow
    Drive*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是类型的地址。命名空间是一种机制，通过要求完整的地址来唯一标识一个类型，而不是仅仅一个短名称。在现实世界中，*34 桉树街的鲍勃*与*12 橡树巷的鲍勃*是不同的。
- en: In .NET, the `IActionFilter` interface of the `System.Web.Mvc` namespace is
    different from the `IActionFilter` interface of the `System.Web.Http.Filters`
    namespace.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，`System.Web.Mvc` 命名空间中的 `IActionFilter` 接口与 `System.Web.Http.Filters`
    命名空间中的 `IActionFilter` 接口不同。
- en: Dependent assemblies
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖组件
- en: If an assembly is compiled as a class library and provides types for other assemblies
    to use, then it has the file extension `.dll` (**dynamic link library**), and
    it cannot be executed standalone.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件被编译为类库并提供其他组件使用的类型，那么它具有文件扩展名 `.dll`（**动态链接库**），并且不能独立执行。
- en: Likewise, if an assembly is compiled as an application, then it has the file
    extension `.exe` (**executable**) and can be executed standalone. Before .NET
    Core 3, console apps were compiled to `.dll` files and had to be executed by the
    `dotnet run` command or a host executable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果一个组件被编译为应用程序，那么它具有文件扩展名 `.exe`（**可执行文件**）并且可以独立执行。在 .NET Core 3 之前，控制台应用程序被编译为
    `.dll` 文件，并且必须通过 `dotnet run` 命令或宿主可执行文件来执行。
- en: Any assembly can reference one or more class library assemblies as dependencies,
    but you cannot have circular references. So assembly *B* cannot reference assembly
    *A* if assembly *A* already references assembly *B*. The compiler will warn you
    if you attempt to add a dependency reference that would cause a circular reference.
    Circular references are often a warning sign of poor code design. If you are sure
    that you need a circular reference, then use an interface to solve it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序集都可以将一个或多个类库程序集作为依赖项引用，但不能有循环引用。因此，如果程序集 *A* 已经引用了程序集 *B*，则程序集 *B* 不能引用程序集
    *A*。如果尝试添加会导致循环引用的依赖项引用，编译器将发出警告。循环引用通常是代码设计不佳的警告信号。如果你确定你需要循环引用，那么请使用接口来解决这个问题。
- en: Microsoft .NET project SDKs
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Microsoft .NET 项目 SDK
- en: By default, console applications have a dependency reference on the Microsoft
    .NET project SDK. This platform contains thousands of types in NuGet packages
    that almost all applications would need, such as the `System.Int32` and `System.String`
    types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，控制台应用程序依赖于 Microsoft .NET 项目 SDK。此平台包含成千上万的类型，这些类型几乎所有应用程序都需要，例如 `System.Int32`
    和 `System.String` 类型。
- en: When using .NET, you reference the dependency assemblies, NuGet packages, and
    platforms that your application needs in a project file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 .NET 时，你需要在项目文件中引用应用程序需要的依赖程序集、NuGet 包和平台。
- en: 'Let’s explore the relationship between assemblies and namespaces:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索程序集和命名空间之间的关系：
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的代码编辑器创建一个新项目，如下列表所示：
- en: 'Project template: **Console App** / `console`'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Project file and folder: `AssembliesAndNamespaces`'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`AssembliesAndNamespaces`
- en: 'Solution file and folder: `Chapter07`'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter07`
- en: 'Open `AssembliesAndNamespaces.csproj`, and note that it is a typical project
    file for a .NET application, as shown in the following markup:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `AssembliesAndNamespaces.csproj`，注意它是一个典型的 .NET 应用程序项目文件，如下所示：
- en: '[PRE2]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the `<PropertyGroup>` section, add a new `<ItemGroup>` section to statically
    import `System.Console` for all C# files, using the implicit usings .NET SDK feature,
    as shown in the following markup:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<PropertyGroup>` 部分之后，添加一个新的 `<ItemGroup>` 部分以静态导入所有 C# 文件中的 `System.Console`，使用
    .NET SDK 的隐式使用功能，如下所示：
- en: '[PRE3]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: PropertyGroup element
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PropertyGroup` 元素'
- en: 'The `PropertyGroup` element is used to define configuration properties that
    control the build process. These properties can include anything, from the output
    path of the compiled binaries to versioning information. Each property within
    a `PropertyGroup` is defined as a simple name-value pair, as shown in the following
    markup:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyGroup` 元素用于定义控制构建过程的配置属性。这些属性可以是任何东西，从编译二进制的输出路径到版本信息。`PropertyGroup`
    中的每个属性都定义为简单的名称-值对，如下所示：'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中：
- en: '`OutputType` specifies the type of output, such as an executable (`Exe`) or
    a library (`Library`).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OutputType` 指定输出类型，例如可执行文件 (`Exe`) 或库 (`Library`)。'
- en: '`TargetFramework` specifies the target framework for the project, for example,
    `net9.0`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TargetFramework` 指定项目的目标框架，例如 `net9.0`。'
- en: '`RootNamespace` sets the default namespace for the project.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RootNamespace` 设置项目的默认命名空间。'
- en: ItemGroup element
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ItemGroup` 元素'
- en: The `ItemGroup` element is used to define collections of items that are included
    in the build process. Items can be source files, references to other assemblies,
    package references, and other resources.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemGroup` 元素用于定义包含在构建过程中的项目集合。项目可以是源文件、对其他程序集的引用、包引用和其他资源。'
- en: You often want to define multiple `ItemGroup` elements for different purposes.
    They will all be merged at build time. For example, you might have one `ItemGroup`
    for all your project references and a separate `ItemGroup` for all your package
    references.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常想为不同的目的定义多个 `ItemGroup` 元素。它们将在构建时合并。例如，你可能有一个 `ItemGroup` 用于所有项目引用，还有一个单独的
    `ItemGroup` 用于所有包引用。
- en: 'The `ItemGroup` element can have a `Label` attribute so that you can document
    what each section should be used for, as shown in the following markup:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemGroup` 元素可以有一个 `Label` 属性，以便你可以记录每个部分应该用于什么，如下所示：'
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Label and Condition attributes
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签和条件属性
- en: 'Both `PropertyGroup` and `ItemGroup` can have a `Label` attribute that can
    be used to document the purpose of the element, and a `Condition` attribute that
    can be used to define when they apply. For example, a typical condition might
    be when building a `DEBUG` release, as shown in the following markup:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyGroup` 和 `ItemGroup` 都可以有一个 `Label` 属性，可以用来记录元素的目的，以及一个 `Condition`
    属性，可以用来定义它们何时应用。例如，一个典型的条件可能是构建 `DEBUG` 版本时，如下面的标记所示：'
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Warning!** `PropertyGroup` and `ItemGroup` elements are both at the same
    level within a root `Project` element. Do not nest `ItemGroup` elements within
    `PropertyGroup` elements, or vice versa!'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** `PropertyGroup` 和 `ItemGroup` 元素都在根 `Project` 元素中的同一级别。不要在 `PropertyGroup`
    元素内部嵌套 `ItemGroup` 元素，反之亦然！'
- en: Namespaces and types in assemblies
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集中的命名空间和类型
- en: 'Many common .NET types are in the `System.Runtime.dll` assembly. There is not
    always a one-to-one mapping between assemblies and namespaces. A single assembly
    can contain many namespaces, and a namespace can be defined in many assemblies.
    You can see the relationship between some assemblies and the namespaces that they
    supply types for in *Table 7.1*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的 .NET 类型都包含在 `System.Runtime.dll` 程序集中。程序集和命名空间之间不一定是一对一映射。单个程序集可以包含多个命名空间，而一个命名空间也可以定义在多个程序集中。您可以在
    *表 7.1* 中查看一些程序集及其为它们提供类型的命名空间之间的关系：
- en: '| **Assembly** | **Example namespaces** | **Example types** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **程序集** | **示例命名空间** | **示例类型** |'
- en: '| `System.Runtime.dll` | `System`, `System.Collections`, `System.Collections.Generic`
    | `Int32`, `String`, `IEnumerable<T>` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `System.Runtime.dll` | `System`, `System.Collections`, `System.Collections.Generic`
    | `Int32`, `String`, `IEnumerable<T>` |'
- en: '| `System.Console.dll` | `System` | `Console` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `System.Console.dll` | `System` | `Console` |'
- en: '| `System.Threading.dll` | `System.Threading` | `Interlocked`, `Monitor`, `Mutex`
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `System.Threading.dll` | `System.Threading` | `Interlocked`, `Monitor`, `Mutex`
    |'
- en: '| `System.Xml.XDocument.dll` | `System.Xml.Linq` | `XDocument`, `XElement`,
    `XNode` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `System.Xml.XDocument.dll` | `System.Xml.Linq` | `XDocument`, `XElement`,
    `XNode` |'
- en: 'Table 7.1: Examples of assemblies and their namespaces'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1：程序集及其命名空间的示例
- en: NuGet packages
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NuGet 包
- en: .NET is split into a set of packages, distributed using a Microsoft-supported
    package management technology named NuGet. Each of these packages represents a
    single assembly of the same name. For example, the `System.Collections` package
    contains the `System.Collections.dll` assembly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 被分割成一系列包，使用名为 NuGet 的微软支持的包管理技术进行分发。这些包中的每一个都代表一个同名的单个程序集。例如，`System.Collections`
    包包含 `System.Collections.dll` 程序集。
- en: 'The following are the benefits of packages:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些包的好处：
- en: Packages can be easily distributed on public feeds.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以轻松地分发到公共源。
- en: Packages can be reused.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以被重用。
- en: Packages can ship on their own schedule.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以按照自己的时间表进行分发。
- en: Packages can be tested independently of other packages.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以在不依赖其他包的情况下独立测试。
- en: Packages can support different OSes and CPUs by including multiple versions
    of the same assembly, built for different OSes and CPUs.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以通过包含为不同操作系统和 CPU 构建的同一程序集的多个版本来支持不同的操作系统和 CPU。
- en: Packages can have dependencies specific to only one library.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以具有仅针对单个库的特定依赖项。
- en: 'Apps are smaller because unreferenced packages aren’t part of the distribution.
    *Table 7.2* lists some of the more important packages and their important types:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序更小，因为未引用的包不是分发的一部分。*表 7.2* 列出了一些重要的包及其重要类型：
- en: '| **Package** | **Important types** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **包** | **重要类型** |'
- en: '| `System.Runtime` | `Object`, `String`, `Int32`, `Array` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `System.Runtime` | `Object`, `String`, `Int32`, `Array` |'
- en: '| `System.Collections` | `List<T>`, `Dictionary<TKey, TValue>` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections` | `List<T>`, `Dictionary<TKey, TValue>` |'
- en: '| `System.Net.Http` | `HttpClient`, `HttpResponseMessage` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net.Http` | `HttpClient`, `HttpResponseMessage` |'
- en: '| `System.IO.FileSystem` | `File`, `Directory` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO.FileSystem` | `File`, `Directory` |'
- en: '| `System.Reflection` | `Assembly`, `TypeInfo`, `MethodInfo` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `System.Reflection` | `Assembly`, `TypeInfo`, `MethodInfo` |'
- en: 'Table 7.2: Some important packages and their important types'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2：一些重要的包及其重要类型
- en: Package sources
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包源
- en: Package sources are locations where NuGet can look for packages, such as [https://www.nuget.org](https://www.nuget.org),
    local directories, or other package repositories. The `nuget.config` file allows
    you to specify, prioritize, and configure these sources, as well as other related
    settings.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 包源是 NuGet 可以查找包的位置，例如 [https://www.nuget.org](https://www.nuget.org)、本地目录或其他包存储库。`nuget.config`
    文件允许您指定、优先级排序和配置这些源，以及其他相关设置。
- en: 'The `nuget.config` file uses XML to define package sources, as shown in the
    following markup:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`nuget.config` 文件使用 XML 定义包源，如下所示：'
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding configuration:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中：
- en: '`<packageSources>`: This section lists all the sources NuGet will use to look
    for packages.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<packageSources>`：此部分列出了 NuGet 将用于查找包的所有源。'
- en: '`<add key="sourceName" value="sourceUrl"/>`: Each `<add>` element defines a
    package source.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<add key="sourceName" value="sourceUrl"/>`：每个 `<add>` 元素定义一个包源。'
- en: 'NuGet can use multiple `nuget.config` files located in different directories.
    The settings are applied in a specific order, with the most specific settings
    taking precedence:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet 可以使用位于不同目录中的多个 `nuget.config` 文件。设置将按特定顺序应用，最具体的设置具有优先权：
- en: 'Project directory: `nuget.config` in the project directory.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目目录：项目目录中的 `nuget.config` 文件。
- en: 'Solution directory: `nuget.config` in the solution directory.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案目录：解决方案目录中的 `nuget.config` 文件。
- en: 'User directory: `nuget.config` in the user’s profile directory—for example,
    `%AppData%\nuget\nuget.config` on Windows.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户目录：用户配置文件目录中的 `nuget.config` 文件——例如，Windows 上的 `%AppData%\nuget\nuget.config`。
- en: 'Machine-wide configuration: `nuget.config` in the machine-wide settings—for
    example, `%ProgramFiles(x86)%\nuget\config` on Windows.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统级配置：系统级设置中的 `nuget.config` 文件——例如，Windows 上的 `%ProgramFiles(x86)%\nuget\config`。
- en: NuGet merges these configurations, with settings from more specific files overriding
    those from less specific files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet 合并这些配置，更具体的文件中的设置将覆盖不那么具体的文件中的设置。
- en: If no `nuget.config` file is found, NuGet uses the default package source, which
    is usually the official NuGet.org repository. This means that, by default, tools
    like Visual Studio, `dotnet`, and `nuget.exe` will look for packages on NuGet.org
    unless otherwise configured.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到 `nuget.config` 文件，NuGet 将使用默认的包源，这通常是官方的 NuGet.org 仓库。这意味着默认情况下，Visual
    Studio、`dotnet` 和 `nuget.exe` 等工具将查找 NuGet.org 的包，除非进行其他配置。
- en: Understanding frameworks
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解框架
- en: There is a two-way relationship between frameworks and packages. Packages define
    the APIs, while frameworks group packages. A framework without any packages would
    not define any APIs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 框架和包之间存在双向关系。包定义了 API，而框架将包分组。没有包的框架不会定义任何 API。
- en: '.NET packages each support a set of frameworks. For example, the `System.IO.FileSystem`
    package version 4.3.0 supports the following frameworks:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 包支持一组框架。例如，`System.IO.FileSystem` 包版本 4.3.0 支持以下框架：
- en: .NET Standard, version 1.3 or later
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 标准版，版本 1.3 或更高版本
- en: .NET Framework, version 4.6 or later
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 框架，版本 4.6 或更高版本
- en: Six Mono and Xamarin platforms (for example, Xamarin.iOS)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个 Mono 和 Xamarin 平台（例如，Xamarin.iOS）
- en: '**More Information**: You can read the details at the following link: [https://www.nuget.org/packages/System.IO.FileSystem/#supportedframeworks-body-tab](https://www.nuget.org/packages/System.IO.FileSystem/#supportedframeworks-body-tab).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中阅读详细信息：[https://www.nuget.org/packages/System.IO.FileSystem/#supportedframeworks-body-tab](https://www.nuget.org/packages/System.IO.FileSystem/#supportedframeworks-body-tab)。'
- en: Importing a namespace to use a type
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入命名空间以使用类型
- en: 'Let’s explore how namespaces are related to assemblies and types:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索命名空间与程序集和类型之间的关系：
- en: 'In the `AssembliesAndNamespaces` project, in `Program.cs`, delete the existing
    statements, and then enter the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AssembliesAndNamespaces` 项目中，在 `Program.cs` 中删除现有的语句，然后输入以下代码：
- en: '[PRE8]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Recent versions of code editors will often automatically add a namespace import
    statement to fix the problem I want you to see. Please delete the `using` statement
    that your code editor writes for you.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 近期版本的代码编辑器通常会自动添加一个命名空间导入语句来修复您想要看到的问题。请删除您的代码编辑器为您编写的 `using` 语句。
- en: 'Build the project and note the compiler error message, as shown in the following
    output:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并注意编译器错误信息，如下所示：
- en: '[PRE9]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `XDocument` type is not recognized because we have not told the compiler
    what the namespace of the type is. Although this project already has a reference
    to the assembly that contains the type, we also need to either prefix the type
    name with its namespace (for example, `System.Xml.Linq.XDocument`) or import the
    namespace.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`XDocument` 类型没有被识别，因为我们没有告诉编译器该类型的命名空间。尽管此项目已经引用了包含该类型的程序集，但我们还需要在类型名称前加上其命名空间（例如，`System.Xml.Linq.XDocument`）或导入命名空间。'
- en: Click inside the `XDocument` class name. Your code editor displays a light bulb,
    showing that it recognizes the type and can automatically fix the problem for
    you.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `XDocument` 类名内点击。您的代码编辑器显示一个灯泡，表示它识别了该类型，并且可以自动为您修复问题。
- en: Click the light bulb, and select `using System.Xml.Linq;` from the menu.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击灯泡图标，从菜单中选择 `using System.Xml.Linq;`。
- en: This will *import the namespace* by adding a `using` statement to the top of
    the file. Once a namespace is imported at the top of a code file, all the types
    within the namespace are available for use in that code file by just typing their
    name, without the type name needing to be fully qualified by prefixing it with
    its namespace.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过在文件顶部添加一个 `using` 语句来导入命名空间。一旦在代码文件的顶部导入了命名空间，该命名空间内的所有类型都可以通过仅输入其名称来在该代码文件中使用，无需通过在其名称前加上命名空间前缀来完全限定类型名称。
- en: 'I like to add a comment after importing a namespace to remind me why I need
    to import it, as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在导入命名空间后添加一条注释，以提醒我为什么需要导入它，如下所示：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you do not comment on your namespaces, you or other developers will not know
    why they are imported and might delete them, breaking the code. Conversely, they
    might never delete imported namespaces “just in case” they are needed, potentially
    cluttering the code unnecessarily. This is why most modern code editors have features
    to remove unused namespaces. This technique also subconsciously trains you, while
    you are learning, to remember which namespace you need to import to use a particular
    type or extension method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不对你的命名空间进行注释，你或其他开发者将不知道为什么需要导入它们，可能会删除它们，导致代码出错。相反，他们可能永远不会删除导入的命名空间“以防万一”它们可能需要，这可能会不必要地使代码变得杂乱。这就是为什么大多数现代代码编辑器都有移除未使用命名空间的功能。这种技术也在你学习的同时无意识地训练你，记住你需要导入哪个命名空间来使用特定的类型或扩展方法。
- en: Relating C# keywords to .NET types
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 C# 关键字关联到 .NET 类型
- en: One of the common questions I get from new C# programmers is, “What is the difference
    between `string` with a lowercase s and `String` with an uppercase S?”
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常收到新 C# 程序员提出的一个常见问题是，“小写 s 的 `string` 和大写 S 的 `String` 之间有什么区别？”
- en: 'The short answer is easy: none. The long answer is that all C# keywords that
    represent types like `string` or `int` are aliases for a .NET type in a class
    library assembly.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是：没有。长一点的回答是，所有代表类型如 `string` 或 `int` 的 C# 关键字都是类库程序集中的一个 .NET 类型的别名。
- en: When you use the `string` keyword, the compiler recognizes it as a `System.String`
    type. When you use the `int` type, the compiler recognizes it as a `System.Int32`
    type.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `string` 关键字时，编译器将其识别为 `System.String` 类型。当你使用 `int` 类型时，编译器将其识别为 `System.Int32`
    类型。
- en: 'Let’s see this in action with some code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码来看看这个操作：
- en: 'In `Program.cs`, declare two variables to hold `string` values, one using lowercase
    `string` and one using uppercase `String`, as shown in the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，声明两个变量来存储 `string` 值，一个使用小写 `string`，一个使用大写 `String`，如下所示：
- en: '[PRE11]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the `AssembliesAndNamespaces` project, and note that `string` and `String`
    both work and literally mean the same thing.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `AssembliesAndNamespaces` 项目，并注意 `string` 和 `String` 都可以正常工作，并且字面上意味着同一件事。
- en: 'In `AssembliesAndNamespaces.csproj`, add an entry to prevent the `System` namespace
    from being globally imported, as shown in the following markup:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AssembliesAndNamespaces.csproj` 文件中，添加一个条目以防止 `System` 命名空间被全局导入，如下所示：
- en: '[PRE12]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `Program.cs`, and the **Error List** or **PROBLEMS** window, note the compiler
    error message, as shown in the following output:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，以及 **错误列表** 或 **问题** 窗口中，注意编译器错误信息，如下所示：
- en: '[PRE13]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the top of `Program.cs`, import the `System` namespace with a `using` statement
    that will fix the error, as shown in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件顶部，使用 `using` 语句导入 `System` 命名空间，这将修复错误，如下所示：
- en: '[PRE14]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Good Practice**: When you have a choice, use the C# keyword instead of the
    actual type because the keywords do not need a namespace to be imported.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当你有选择时，使用 C# 关键字而不是实际类型，因为关键字不需要导入命名空间。'
- en: Mapping C# aliases to .NET types
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 C# 别名映射到 .NET 类型
- en: '*Table 7.3* shows the 18 C# type keywords along with their actual .NET types:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 7.3* 展示了 18 个 C# 类型关键字及其实际的 .NET 类型：'
- en: '| **Keyword** | **.NET type** |  | **Keyword** | **.NET type** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **关键字** | **.NET 类型** |  | **关键字** | **.NET 类型** |'
- en: '| `string` | `System.String` |  | `char` | `System.Char` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `System.String` |  | `char` | `System.Char` |'
- en: '| `sbyte` | `System.SByte` |  | `byte` | `System.Byte` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte` | `System.SByte` |  | `byte` | `System.Byte` |'
- en: '| `short` | `System.Int16` |  | `ushort` | `System.UInt16` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `System.Int16` |  | `ushort` | `System.UInt16` |'
- en: '| `int` | `System.Int32` |  | `uint` | `System.UInt32` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `System.Int32` |  | `uint` | `System.UInt32` |'
- en: '| `long` | `System.Int64` |  | `ulong` | `System.UInt64` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `System.Int64` |  | `ulong` | `System.UInt64` |'
- en: '| `nint` | `System.IntPtr` |  | `nuint` | `System.UIntPtr` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `nint` | `System.IntPtr` |  | `nuint` | `System.UIntPtr` |'
- en: '| `float` | `System.Single` |  | `double` | `System.Double` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `System.Single` |  | `double` | `System.Double` |'
- en: '| `decimal` | `System.Decimal` |  | `bool` | `System.Boolean` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | `System.Decimal` |  | `bool` | `System.Boolean` |'
- en: '| `object` | `System.Object` |  | `dynamic` | `System.Dynamic.DynamicObject`
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `object` | `System.Object` |  | `dynamic` | `System.Dynamic.DynamicObject`
    |'
- en: 'Table 7.3: C# type keywords and their actual .NET types'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.3：C# 类型关键字及其实际的 .NET 类型
- en: Other .NET programming language compilers can do the same thing. For example,
    the Visual Basic .NET language has a type named `Integer`, which is its alias
    for `System.Int32`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 .NET 编程语言编译器也可以做到同样的事情。例如，Visual Basic .NET 语言有一个名为`Integer`的类型，它是`System.Int32`的别名。
- en: Understanding native-sized integers
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解原生大小整数
- en: C# 9 introduced the `nint` and `nuint` keyword aliases for **native-sized integers**,
    meaning that the storage size for the integer value is platform-specific. They
    store a 32-bit integer in a 32-bit process and `sizeof()` returns 4 bytes; they
    store a 64-bit integer in a 64-bit process and `sizeof()` returns 8 bytes. The
    aliases represent pointers to the integer value in memory, which is why their
    .NET names are `IntPtr` and `UIntPtr`. The actual storage type will be either
    `System.Int32` or `System.Int64`, depending on the process.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9 引入了`nint`和`nuint`关键字别名，用于**原生大小整数**，这意味着整数值的存储大小是平台特定的。它们在 32 位进程中存储 32
    位整数，`sizeof()`返回 4 字节；它们在 64 位进程中存储 64 位整数，`sizeof()`返回 8 字节。这些别名代表内存中整数值的指针，这就是为什么它们的
    .NET 名称是`IntPtr`和`UIntPtr`。实际的存储类型将是`System.Int32`或`System.Int64`，具体取决于进程。
- en: 'In a 64-bit process, the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位进程中，以下代码：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'produces this output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 产生以下输出：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Revealing the location of a type
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示类型的定位
- en: 'Most code editors provide built-in documentation for .NET types. Let’s start
    by making sure that you have the expected experience with Visual Studio by checking
    that you have the relevant option set correctly, and then explore:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码编辑器都为 .NET 类型提供了内置文档。让我们首先确保你通过检查是否正确设置了相关选项，来确保你在 Visual Studio 中的预期体验，然后探索：
- en: 'If you are using Visual Studio, then make sure you have disabled the Source
    Link feature:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio，请确保你已经禁用了源链接功能：
- en: Navigate to **Tools** | **Options**.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**工具** | **选项**。
- en: In the search box, enter `navigation to source`.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`导航到源`。
- en: Select **Advanced** in the **Text Editor** | **C#** section.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文本编辑器** | **C#**部分中选择**高级**。
- en: Clear the **Enable navigation to Source Link and Embedded sources** checkbox,
    and then click **OK**.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除**启用导航到源链接和嵌入源**复选框，然后点击**确定**。
- en: Right-click on `XDocument` and choose **Go to Definition**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`XDocument`上右键单击并选择**转到定义**。
- en: 'Navigate to the top of the code file, expand the collapsed region, and note
    that the assembly filename is `System.Xml.XDocument.dll` but the class is in the
    `System.Xml.Linq` namespace, as shown in the following code and *Figure 7.1*:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到代码文件顶部，展开折叠区域，并注意程序集文件名是`System.Xml.XDocument.dll`，但类在`System.Xml.Linq`命名空间中，如下面的代码和*图
    7.1*所示：
- en: '[PRE17]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/B22322_07_01.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_07_01.png)'
- en: 'Figure 7.1: Assembly and namespace that contains the XDocument type'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：包含 XDocument 类的程序集和命名空间
- en: Close the **XDocument [from metadata]** tab.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**XDocument [来自元数据]**选项卡。
- en: Right-click inside `string` or `String` and choose **Go to Definition**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`string`或`String`内部右键单击并选择**转到定义**。
- en: Navigate to the top of the code file, expand the collapsed region, and note
    that the assembly filename is `System.Runtime.dll` but the class is in the `System`
    namespace.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到代码文件顶部，展开折叠区域，并注意程序集文件名是`System.Runtime.dll`，但类在`System`命名空间中。
- en: Your code editor is technically lying to you. If you remember when we wrote
    code in *Chapter 2*, *Speaking C#*, when we revealed the extent of the C# vocabulary,
    we discovered that the `System.Runtime.dll` assembly contains zero types.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码编辑器实际上在对你撒谎。如果你记得我们在*第2章*，*讲 C#*中编写代码时，当我们揭示了 C# 词汇量的范围，我们发现`System.Runtime.dll`程序集包含零个类型。
- en: What the `System.Runtime.dll` assembly does contain are type-forwarders. These
    are special types that appear to exist in an assembly but are implemented elsewhere.
    In this case, they are implemented deep inside the .NET runtime using highly optimized
    code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Runtime.dll`程序集包含的是类型前向器。这些是在程序集中看似存在但实际上在其他地方实现的特殊类型。在这种情况下，它们使用高度优化的代码在
    .NET 运行时深处实现。'
- en: 'You might want to use a type-forwarder if you refactor a type to move it from
    its original assembly to a different one. Without defining a type-forwarder, any
    projects that reference the original assembly will not find the type in it, and
    a runtime exception will be thrown. You can read more about this contrived example
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/assembly/type-forwarding](https://learn.microsoft.com/en-us/dotnet/standard/assembly/type-forwarding).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将一个类型从其原始程序集移动到另一个程序集，你可能需要使用类型前向器。如果没有定义类型前向器，任何引用原始程序集的项目将无法在其中找到该类型，并且会抛出运行时异常。你可以在以下链接中了解更多关于这个虚构示例的信息：[https://learn.microsoft.com/en-us/dotnet/standard/assembly/type-forwarding](https://learn.microsoft.com/en-us/dotnet/standard/assembly/type-forwarding)。
- en: Sharing code with legacy platforms using .NET Standard
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.NET Standard与遗留平台共享代码
- en: Before .NET Standard, there were **Portable Class Libraries** (**PCLs**). With
    PCLs, you could create a library of code and explicitly specify which platforms
    you want the library to support, such as Xamarin, Silverlight, and Windows 8\.
    Your library could then use the intersection of APIs that are supported by the
    specified platforms.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Standard之前，存在**可移植类库**（**PCLs**）。使用PCLs，你可以创建一个代码库，并明确指定你希望库支持的平台，例如Xamarin、Silverlight和Windows
    8。然后，你的库可以使用由指定平台支持的API交集。
- en: Microsoft realized that this was unsustainable, so they created .NET Standard—a
    single API that all future .NET platforms would support. There are older versions
    of .NET Standard, but .NET Standard 2.0 was an attempt to unify all important
    recent .NET platforms. .NET Standard 2.1 was released in late 2019, but only .NET
    Core 3.0 and that year’s version of Xamarin support its new features. For the
    rest of this book, I will use the term .NET Standard to mean .NET Standard 2.0.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 微软意识到这是不可持续的，因此他们创建了.NET Standard——一个所有未来的.NET平台都将支持的单一API。有.NET Standard的旧版本，但.NET
    Standard 2.0是一次尝试统一所有重要的近期.NET平台。.NET Standard 2.1于2019年底发布，但只有.NET Core 3.0和那年的Xamarin版本支持其新功能。在这本书的其余部分，我将使用.NET
    Standard来指代.NET Standard 2.0。
- en: .NET Standard is like HTML5 in that they are both standards that a platform
    should support. Just as Google’s Chrome browser and Microsoft’s Edge browser implement
    the HTML5 standard, .NET Core, .NET Framework, and Xamarin all implement .NET
    Standard. If you want to create a library of types that will work across variants
    of legacy .NET, you can do so most easily with .NET Standard.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard就像HTML5一样，它们都是平台应该支持的标准。就像谷歌的Chrome浏览器和微软的Edge浏览器实现了HTML5标准一样，.NET
    Core、.NET Framework和Xamarin都实现了.NET Standard。如果你想创建一个可以在旧.NET变体之间工作的类型库，你可以使用.NET
    Standard最简单地做到这一点。
- en: '**Good Practice**: Since many of the API additions in .NET Standard 2.1 required
    runtime changes, and .NET Framework is Microsoft’s legacy platform, which needs
    to remain as unchanged as possible, .NET Framework 4.8 remained on .NET Standard
    2.0 rather than implementing .NET Standard 2.1\. If you need to support .NET Framework
    customers, then you should create class libraries on .NET Standard 2.0, even though
    it is not the latest and does not support all the recent language and BCL new
    features.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：由于.NET Standard 2.1中的许多API新增都需要运行时更改，而.NET Framework是微软的遗留平台，需要尽可能保持不变，因此.NET
    Framework 4.8仍然停留在.NET Standard 2.0上，而不是实现.NET Standard 2.1。如果你需要支持.NET Framework客户，那么你应该在.NET
    Standard 2.0上创建类库，即使它不是最新的，也不支持所有最新的语言和BCL新功能。'
- en: Your choice of which .NET Standard version to target comes down to a balance
    between maximizing platform support and available functionality. An older version
    supports more platforms but has a smaller set of APIs. A newer version supports
    fewer platforms but has a larger set of APIs. Generally, you should choose the
    lowest version that supports all the APIs that you need.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的目标.NET Standard版本取决于在最大化平台支持和可用功能之间的平衡。较旧的版本支持更多平台，但API集较小。较新的版本支持较少的平台，但API集较大。通常，你应该选择支持你所需所有API的最低版本。
- en: Understanding defaults for class libraries with different SDKs
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解不同SDK的类库默认设置
- en: 'When using the `dotnet` SDK tool to create a class library, it might be useful
    to know which target framework will be used by default, as shown in *Table 7.4*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`dotnet` SDK工具创建类库时，了解默认将使用哪个目标框架可能很有用，如下表7.4所示：
- en: '| **SDK** | **Default target framework for new class libraries** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **SDK** | **新类库的默认目标框架** |'
- en: '| .NET Core 3.1 | `netstandard2.0` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| .NET Core 3.1 | `netstandard2.0` |'
- en: '| .NET 6 | `net6.0` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| .NET 6 | `net6.0` |'
- en: '| .NET 7 | `net7.0` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| .NET 7 | `net7.0` |'
- en: '| .NET 8 | `net8.0` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| .NET 8 | `net8.0` |'
- en: '| .NET 9 | `net9.0` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| .NET 9 | `net9.0` |'
- en: 'Table 7.4: .NET SDKs and their default target framework for new class libraries'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.4：.NET SDK 及其针对新类库的默认目标框架
- en: Of course, just because a class library targets a specific version of .NET by
    default, it does not mean that you cannot change it after creating a class library
    project using the default template.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个类库默认针对特定的 .NET 版本并不意味着你不能在创建类库项目后更改它。使用默认模板创建类库项目后，你可以更改它。
- en: 'You can manually set the target framework to a value that supports the projects
    that need to reference that library, as shown in *Table 7.5*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动设置目标框架到一个支持需要引用该库的项目值的值，如 *表 7.5* 所示：
- en: '| **Class library target framework** | **Can be used by projects that target
    the following** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **类库目标框架** | **可以被以下项目使用** |'
- en: '| `netstandard2.0` | .NET Framework 4.6.1 or later, .NET Core 2 or later, .NET
    5 or later, Mono 5.4 or later, Xamarin.Android 8 or later, and Xamarin.iOS 10.14
    or later |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `netstandard2.0` | .NET Framework 4.6.1 或更高版本，.NET Core 2 或更高版本，.NET 5 或更高版本，Mono
    5.4 或更高版本，Xamarin.Android 8 或更高版本，以及 Xamarin.iOS 10.14 或更高版本 |'
- en: '| `netstandard2.1` | .NET Core 3 or later, .NET 5 or later, Mono 6.4 or later,
    Xamarin.Android 10 or later, and Xamarin.iOS 12.16 or later |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `netstandard2.1` | .NET Core 3 或更高版本，.NET 5 或更高版本，Mono 6.4 或更高版本，Xamarin.Android
    10 或更高版本，以及 Xamarin.iOS 12.16 或更高版本 |'
- en: '| `net6.0` | .NET 6 or later |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `net6.0` | .NET 6 或更高版本 |'
- en: '| `net7.0` | .NET 7 or later |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `net7.0` | .NET 7 或更高版本 |'
- en: '| `net8.0` | .NET 8 or later |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `net8.0` | .NET 8 或更高版本 |'
- en: '| `net9.0` | .NET 9 or later |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `net9.0` | .NET 9 或更高版本 |'
- en: 'Table 7.5: Class library target frameworks and the projects that can use them'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.5：类库目标框架及其可使用的项目
- en: '**Good Practice**: Always check the target framework of a class library, and
    then manually change it to something more appropriate if necessary. Make a conscious
    decision about what it should be rather than accepting the default.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：始终检查类库的目标框架，并在必要时手动更改它到一个更合适的目标。有意识地决定它应该是什么，而不是接受默认值。'
- en: Creating a .NET Standard class library
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 .NET Standard 类库
- en: 'We will create a class library using .NET Standard 2.0 so that it can be used
    across all important .NET legacy platforms and cross-platform on Windows, macOS,
    and Linux OSes, while also having access to a wide set of .NET APIs:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 .NET Standard 2.0 创建一个类库，以便它可以在所有重要的 .NET 遗留平台上使用，并在 Windows、macOS 和 Linux
    操作系统上跨平台，同时还可以访问广泛的 .NET API：
- en: 'Use your preferred code editor to add a new **Class Library** / `classlib`
    project, named `SharedLibrary`, that targets .NET Standard 2.0 for the `Chapter07`
    solution:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器添加一个新的 **类库** / `classlib` 项目，命名为 `SharedLibrary`，针对 `Chapter07`
    解决方案的目标为 .NET Standard 2.0：
- en: If you use Visual Studio, when prompted for the **Target Framework**, select
    **.NET Standard 2.0**, and then configure the startup project for the solution
    to the current selection.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用 Visual Studio，当提示选择 **目标框架** 时，选择 **.NET Standard 2.0**，然后配置解决方案的启动项目为当前选择。
- en: 'If you use VS Code, include a switch to target .NET Standard 2.0, as shown
    in the following command:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用 VS Code，包括一个目标为 .NET Standard 2.0 的开关，如下所示命令：
- en: '[PRE18]'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Good Practice**: If you need to create types that use new features in .NET
    9, as well as types that only use .NET Standard 2.0 features, then you can create
    two separate class libraries: one targeting .NET Standard 2.0 and one targeting
    .NET 0.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果你需要创建使用 .NET 9 的新功能的类型，以及仅使用 .NET Standard 2.0 功能的类型，那么你可以创建两个独立的类库：一个针对
    .NET Standard 2.0，另一个针对 .NET 0。'
- en: Build the `SharedLibrary` project.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `SharedLibrary` 项目。
- en: 'An alternative to manually creating two class libraries is to create one that
    supports **multi-targeting**. If you would like me to add a section about multi-targeting
    to the next edition, please let me know. You can read about multi-targeting here:
    [https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting](https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建两个类库的替代方法是创建一个支持 **多目标** 的类库。如果你希望我在下一版中添加关于多目标的内容，请告知我。你可以在这里了解多目标：[https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting](https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting)。
- en: Controlling the .NET SDK
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制 .NET SDK
- en: By default, executing `dotnet` commands uses the highest version of the .NET
    SDK installed. There may be times when you want to control which SDK is used.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，执行 `dotnet` 命令会使用已安装的最高版本的 .NET SDK。有时你可能想控制使用哪个 SDK。
- en: For example, once .NET 10 becomes available in preview, starting in February
    2025, or the final version becomes available in November 2025, you might install
    it. But you would probably want your experience to match the book steps, which
    use the .NET 9 SDK. But once you install a .NET 10 SDK, it will be used by default.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一旦 .NET 10 在 2025 年 2 月开始预览版，或者最终版本在 2025 年 11 月发布，您可能会安装它。但您可能希望您的体验与书中步骤相匹配，这些步骤使用
    .NET 9 SDK。但一旦您安装了 .NET 10 SDK，它将默认使用。
- en: You can control the .NET SDK used by default by using a `global.json` file,
    which contains the version to use. The `dotnet` command searches the current folder
    and then each ancestor folder in turn for a `global.json` file, seeing if it should
    use a different .NET SDK version.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用包含要使用版本的 `global.json` 文件来控制默认使用的 .NET SDK，`dotnet` 命令会依次搜索当前文件夹及其父文件夹，查找
    `global.json` 文件，以确定是否应使用不同的 .NET SDK 版本。
- en: 'You do not need to complete the following steps, but if you want to try and
    do not already have .NET 8 SDK installed, then you can install it from the following
    link:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要完成以下步骤，但如果您想尝试并且尚未安装 .NET 8 SDK，则可以从以下链接安装它：
- en: '[https://dotnet.microsoft.com/download/dotnet/8.0](https://dotnet.microsoft.com/download/dotnet/8.0)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dotnet.microsoft.com/download/dotnet/8.0](https://dotnet.microsoft.com/download/dotnet/8.0)'
- en: Create a subdirectory/folder in the `Chapter07` folder named `ControlSDK`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter07` 文件夹中创建一个名为 `ControlSDK` 的子目录/文件夹。
- en: On Windows, start **Command Prompt** or **Windows Terminal**. On macOS, start
    **Terminal**. If you are using VS Code, then you can use the integrated terminal.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 上，启动 **命令提示符** 或 **Windows 终端**。在 macOS 上，启动 **终端**。如果您正在使用 VS Code，则可以使用集成终端。
- en: 'In the `ControlSDK` folder, at the command prompt or terminal, enter a command
    to list the installed .NET SDKs, as shown in the following command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ControlSDK` 文件夹中，在命令提示符或终端中输入命令以列出已安装的 .NET SDK，如下所示：
- en: '[PRE19]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note the results and the version number of the latest .NET 8 SDK installed,
    as shown highlighted in the following output:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意以下输出中突出显示的最新安装的 .NET 8 SDK 的结果和版本号：
- en: '[PRE20]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a `global.json` file that forces the use of the latest .NET 8 SDK that
    you have installed (which might be later than mine), as shown in the following
    command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `global.json` 文件，强制使用您已安装的最新 .NET 8 SDK（可能晚于我的版本），如下所示：
- en: '[PRE21]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note the result, as shown in the following output:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意以下输出中的结果：
- en: '[PRE22]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use your preferred code editor to open the `global.json` file and review its
    contents, as shown in the following markup:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器打开 `global.json` 文件并查看其内容，如下所示：
- en: '[PRE23]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For example, to open it with VS Code, enter the command `code global.json`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用 VS Code 打开它，请输入命令 `code global.json`。
- en: 'In the `ControlSDK` folder, at the command prompt or terminal, enter a command
    to create a class library project, as shown in the following command:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ControlSDK` 文件夹中，在命令提示符或终端中输入命令以创建类库项目，如下所示：
- en: '[PRE24]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you do not have the .NET 8 SDK installed, then you will see an error, as
    shown in the following output:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有安装 .NET 8 SDK，则将看到错误，如下所示：
- en: '[PRE25]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you do have the .NET 8 SDK installed, then a class library project will
    be created that targets .NET 8 by default, as shown highlighted in the following
    markup:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已安装 .NET 8 SDK，则将创建一个默认针对 .NET 8 的类库项目，如下所示：
- en: '[PRE26]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Mixing SDKs and framework targets
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合 SDK 和框架目标
- en: Many organizations decide to target a long-term support version of .NET to get
    up to three years of support from Microsoft. Doing this does not mean you lose
    the benefits of improvements to the C# language during the lifetime of the .NET
    runtime that you need to target.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织决定针对 .NET 的长期支持版本，以从微软获得长达三年的支持。这样做并不意味着您会失去在 .NET 运行时生命周期内 C# 语言改进的好处。
- en: 'You can easily continue to target the .NET 9 runtime while installing and using
    future C# compilers, as shown in *Figure 7.2* and illustrated in the following
    list:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在安装和使用未来的 C# 编译器的同时轻松地继续针对 .NET 9 运行时，如图 7.2 所示，以下列表中也有说明：
- en: '**November 2024**: Install .NET SDK 9.0.100, and use it to build projects that
    target .NET 9 and use the C# 13 compiler by default. Every month, update to .NET
    9 SDK patches on the development computer and update to .NET 9 runtime patches
    on any deployment computers.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2024年11月**：安装 .NET SDK 9.0.100，并使用它来构建默认使用 C# 13 编译器的针对 .NET 9 的项目。每月，更新开发计算机上的
    .NET 9 SDK 补丁，并更新任何部署计算机上的 .NET 9 运行时补丁。'
- en: '**February 2025**: Optionally, install .NET SDK 10 Preview 1 to explore the
    new C# 14 language and .NET 10 library features. Note that you won’t be able to
    use new library features while targeting .NET 9\. Previews are released monthly
    between February and October each year. Read the monthly announcements to find
    out about the new features in that preview at the following link: [https://github.com/dotnet/Announcements/issues](https://github.com/dotnet/Announcements/issues).'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2025年2月**：可选地安装 .NET SDK 10 预览版 1，以探索新的 C# 14 语言和 .NET 10 库功能。请注意，当针对 .NET
    9 时，您将无法使用新的库功能。预览版每年2月至10月每月发布一次。请阅读每月公告，了解以下链接中该预览版的新功能：[https://github.com/dotnet/Announcements/issues](https://github.com/dotnet/Announcements/issues)。'
- en: '**November 2025**: Install .NET SDK 10.0.100, and use it to build projects
    that continue to target .NET 9 and use the C# 14 compiler for its new features.
    You will use a fully supported SDK and fully supported runtime.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2025年11月**：安装 .NET SDK 10.0.100，并使用它来构建继续针对 .NET 9 的项目，并使用 C# 14 编译器来利用其新功能。您将使用完全受支持的
    SDK 和完全受支持的运行时。'
- en: '**February 2026**: Optionally, install .NET 11 previews to explore new C# 15
    language and .NET 11 library features. Start planning for any new library and
    ASP.NET Core features in .NET 10 and .NET 11 that can be applied to your .NET
    9 projects when you are ready to migrate.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2026年2月**：可选地安装 .NET 11 预览版，以探索新的 C# 15 语言和 .NET 11 库功能。当您准备好迁移时，开始规划任何新的库和
    ASP.NET Core 功能，这些功能可以应用于您的 .NET 9 和 .NET 11 项目。'
- en: '**November 2026**: Install .NET 11.0.100 SDK, and use it to build projects
    that target .NET 10 and use the C# 15 compiler.'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**2026年11月**：安装 .NET 11.0.100 SDK，并使用它来构建针对 .NET 10 的项目，并使用 C# 15 编译器。'
- en: '![](img/B22322_07_02.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_07_02.png)'
- en: 'Figure 7.2: Targeting .NET 8 for long-term support while using the latest C#
    compilers'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：针对长期支持的 .NET 8 同时使用最新的 C# 编译器
- en: When deciding to install a .NET SDK, remember that the latest is used by default
    to build any .NET projects. Once you’ve installed a .NET 9 SDK preview, it will
    be used by default for all projects, unless you force the use of an older, fully
    supported SDK version like 8.0.100 or a later patch.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定安装 .NET SDK 时，请记住，默认情况下使用最新版本来构建任何 .NET 项目。一旦您安装了 .NET 9 SDK 预览版，它将默认用于所有项目，除非您强制使用较旧且完全受支持的
    SDK 版本，如 8.0.100 或更高版本的补丁。
- en: Publishing your code for deployment
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为部署发布您的代码
- en: If you write a novel and you want other people to read it, you must publish
    it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您写了一本小说，并且希望其他人阅读它，您必须将其出版。
- en: Most developers write code for other developers to use in their own projects,
    or for users to run as an app. To do so, you must publish your code as packaged
    class libraries or executable applications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者为其他开发者在他们自己的项目中使用或为用户作为应用程序运行而编写代码。为此，您必须将您的代码发布为打包的类库或可执行应用程序。
- en: 'There are three ways to publish and deploy a .NET application. They are:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式可以发布和部署 .NET 应用程序。它们是：
- en: '**Framework-dependent deployment** (**FDD**)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架依赖部署**（**FDD**）'
- en: '**Framework-dependent executable** (**FDE**)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架依赖可执行文件**（**FDE**）'
- en: '**Self-contained**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自包含**'
- en: If you choose to deploy your application and its package dependencies, but not
    .NET itself, then you rely on .NET already being on the target computer. This
    works well for web applications deployed to a server because .NET and lots of
    other web applications are likely already on the server.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择部署您的应用程序及其包依赖项，但不是 .NET 本身，那么您依赖于 .NET 已经在目标计算机上。这对于部署到服务器的 Web 应用程序来说效果很好，因为
    .NET 和许多其他 Web 应用程序可能已经存在于服务器上。
- en: FDD means you deploy a DLL that must be executed by the `dotnet` command-line
    tool. FDE means you deploy an EXE that can be run directly from the command line.
    Both require the appropriate version of the .NET runtime to be installed on a
    system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: FDD 表示您部署一个必须由 `dotnet` 命令行工具执行的 DLL。FDE 表示您部署一个可以直接从命令行运行的 EXE。两者都需要在系统上安装适当的
    .NET 运行时版本。
- en: Sometimes, you want to be able to give someone a USB stick containing your application,
    built for their OS, and know that it can execute on their computer. You would
    want to perform a self-contained deployment. While the size of the deployment
    files will be larger, you’ll know that it will work.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望能够给某人一个包含为他们的操作系统构建的应用程序，并知道它可以在他们的计算机上执行。您将想要执行自包含部署。虽然部署文件的尺寸会更大，但您会知道它将工作。
- en: Creating a console app to publish
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于发布的控制台应用程序
- en: 'Let’s explore how to publish a console app:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何发布一个控制台应用程序：
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `DotNetEverywhere` to the `Chapter07` solution. Make sure you target .NET
    9.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器将一个新的**控制台应用程序**/ `console`项目命名为`DotNetEverywhere`添加到`Chapter07`解决方案中。确保您针对.NET
    9。
- en: Modify the project file to statically import the `System.Console` class into
    all C# files.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改项目文件，将`System.Console`类静态导入到所有C#文件中。
- en: 'In `Program.cs`, delete the existing statements, and then add a statement to
    output a message, saying that the console app can run everywhere, and some information
    about the OS, as shown in the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中删除现有的语句，然后添加一条输出消息的语句，说明控制台应用程序可以在任何地方运行，以及一些关于操作系统的信息，如下所示代码：
- en: '[PRE27]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the `DotNetEverywhere` project, and note the results when run on Windows
    11, as shown in the following output:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`DotNetEverywhere`项目，并注意在Windows 11上运行的结果，如下所示输出：
- en: '[PRE28]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In `DotNetEverywhere.csproj`, add the **runtime identifiers** (**RIDs**) to
    target three OSes inside the `<PropertyGroup>` element, as shown highlighted in
    the following markup:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DotNetEverywhere.csproj`中，在`<PropertyGroup>`元素内添加**运行时标识符**（**RIDs**），以针对三个操作系统进行目标定位，如下所示高亮显示的标记：
- en: '[PRE29]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `win-x64` RID value means Windows on an x64-compatible CPU. Use the `win-arm64`
    RID value to deploy to a Windows ARM device.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`win-x64` RID值表示x64兼容CPU上的Windows。使用`win-arm64` RID值将应用程序部署到Windows ARM设备。'
- en: The `osx-arm64` RID value means macOS on Apple Silicon.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`osx-arm64` RID值表示Apple Silicon上的macOS。'
- en: The `linux-x64` RID value means most desktop distributions of Linux, like Ubuntu,
    CentOS, Debian, or Fedora on an x64-compatible CPU. Use `linux-arm` for Raspbian
    or Raspberry Pi OS 32-bit. Use `linux-arm64` for a Raspberry Pi running Ubuntu
    64-bit.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-x64` RID值表示大多数桌面Linux发行版，如Ubuntu、CentOS、Debian或Fedora在x64兼容CPU上。对于Raspbian或Raspberry
    Pi OS 32位，请使用`linux-arm`。对于运行Ubuntu 64位的Raspberry Pi，请使用`linux-arm64`。'
- en: 'You can check the latest allowed RID values at the following link: [https://learn.microsoft.com/en-us/dotnet/core/rid-catalog#known-rids](https://learn.microsoft.com/en-us/dotnet/core/rid-catalog#known-rids).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中检查最新的允许的RID值：[https://learn.microsoft.com/en-us/dotnet/core/rid-catalog#known-rids](https://learn.microsoft.com/en-us/dotnet/core/rid-catalog#known-rids)。
- en: '**Warning!** There are two elements that you can use to specify runtime identifiers.
    Use `<RuntimeIdentifier>` if you only need to specify one. Use `<RuntimeIdentifiers>`
    if you need to specify multiple, as we did in the preceding example. If you use
    the wrong one, then the compiler will give an error, and it can be difficult to
    understand why with only one character difference!'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**您可以使用两个元素来指定运行时标识符。如果您只需要指定一个，请使用`<RuntimeIdentifier>`。如果您需要指定多个，如前例所示，请使用`<RuntimeIdentifiers>`。如果您使用错误的一个，那么编译器将给出错误，并且仅凭一个字符的差异可能难以理解原因！'
- en: Understanding dotnet commands
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解dotnet命令
- en: When you install the .NET SDK, it includes a **command-line interface** (**CLI**)
    named `dotnet`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装.NET SDK时，它包括一个名为`dotnet`的**命令行界面**（**CLI**）。
- en: 'The .NET CLI has commands that work on the current folder to create a new project,
    using templates:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLI有在当前文件夹中创建新项目的命令，使用模板：
- en: On Windows, start **Command Prompt** or **Windows Terminal**. On macOS, start
    **Terminal**. If you prefer to use Visual Studio or VS Code, then you can use
    the integrated terminal.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上，启动**命令提示符**或**Windows终端**。在macOS上，启动**终端**。如果您更喜欢使用Visual Studio或VS
    Code，则可以使用集成终端。
- en: 'Enter the `dotnet new list` (or `dotnet new -l` or `dotnet new --list` with
    older SDKs) command to list your currently installed templates, the most common
    of which are shown in *Table 7.6*:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`dotnet new list`（或对于较旧的SDK，使用`dotnet new -l`或`dotnet new --list`）命令以列出您当前安装的模板，其中最常见的模板如*表7.6*所示：
- en: '| **Template Name** | **Short Name** | **Language** |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| **模板名称** | **简称** | **语言** |'
- en: '| `.NET MAUI App` | `maui` | C# |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `.NET MAUI App` | `maui` | C# |'
- en: '| `.NET MAUI Blazor App` | `maui-blazor` | C# |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `.NET MAUI Blazor App` | `maui-blazor` | C# |'
- en: '| `ASP.NET Core Empty` | `web` | C# and F# |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `ASP.NET Core Empty` | `web` | C#和F# |'
- en: '| `ASP.NET Core gRPC Service` | `grpc` | C# |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `ASP.NET Core gRPC Service` | `grpc` | C# |'
- en: '| `ASP.NET Core Web API` | `webapi` | C# and F# |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `ASP.NET Core Web API` | `webapi` | C#和F# |'
- en: '| `ASP.NET Core Web API (native AOT)` | `webapiaot` | C# |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `ASP.NET Core Web API (native AOT)` | `webapiaot` | C# |'
- en: '| `ASP.NET Core Web App (Model-View-Controller)` | `mvc` | C# and F# |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `ASP.NET Core Web App (Model-View-Controller)` | `mvc` | C#和F# |'
- en: '| `Blazor Web App` | `blazor` | C# |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `Blazor Web App` | `blazor` | C# |'
- en: '| `Class Library` | `classlib` | C#, F#, and VB |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `Class Library` | `classlib` | C#、F#和VB |'
- en: '| `Console App` | `console` | C#, F#, and VB |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `Console App` | `console` | C#、F#和VB |'
- en: '| `EditorConfig File` | `editorconfig` |  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `EditorConfig File` | `editorconfig` |  |'
- en: '| `global.json File` | `globaljson` |  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `全局.json 文件` | `globaljson` |  |'
- en: '| `Solution File` | `sln` |  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `解决方案文件` | `sln` |  |'
- en: '| `xUnit Test Project` | `xunit` |  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `xUnit 测试项目` | `xunit` |  |'
- en: 'Table 7.6: Project template full and short names'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.6：项目模板的全名和简称
- en: '.NET MAUI projects are not supported for Linux. The team has said they have
    left that work to the open source community. If you need to create a truly cross-platform
    graphical app, then take a look at Avalonia at the following link: [https://avaloniaui.net/](https://avaloniaui.net/).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 项目不支持 Linux。团队表示，他们已将这项工作留给开源社区。如果您需要创建一个真正的跨平台图形应用程序，请查看以下链接中的 Avalonia：[https://avaloniaui.net/](https://avaloniaui.net/)。
- en: Getting information about .NET and its environment
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取有关 .NET 及其环境的详细信息
- en: 'It is useful to see what .NET SDKs and runtimes are currently installed, alongside
    information about the OS, as shown in the following command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 查看当前安装的 .NET SDK 和运行时，以及有关操作系统的信息很有用，如下所示命令：
- en: '[PRE30]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note the results, as shown in the following partial output:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下部分输出中的结果：
- en: '[PRE31]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Managing projects using the dotnet CLI
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 dotnet CLI 管理项目
- en: 'The .NET CLI has the following commands that work on the project in the current
    folder, enabling you to manage the project:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLI 有以下命令在当前文件夹中的项目上工作，使您能够管理项目：
- en: '`dotnet help`: This shows the command-line help.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet help`: 这显示命令行帮助。'
- en: '`dotnet new`: This creates a new .NET project or file.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet new`: 这创建一个新的 .NET 项目或文件。'
- en: '`dotnet tool`: This installs or manages tools that extend the .NET experience.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet tool`: 这安装或管理扩展 .NET 体验的工具。'
- en: '`dotnet workload`: This manages optional workloads like .NET MAUI.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet workload`: 这管理可选的工作负载，如 .NET MAUI。'
- en: '`dotnet restore`: This downloads dependencies for the project.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet restore`: 这为项目下载依赖项。'
- en: '`dotnet build`: This builds, aka compiles, a .NET project. A new switch introduced
    with .NET 8 is `--tl` (meaning terminal logger), which provides a modern output.
    For example, it provides real-time information about what the build is doing.
    You can learn more at the following link: [https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build#options](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build#options).'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet build`: 这将构建，即编译，一个 .NET 项目。.NET 8 中引入的新开关是 `--tl`（表示终端记录器），它提供了一种现代的输出方式。例如，它提供了有关构建正在做什么的实时信息。您可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build#options](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build#options)。'
- en: '`dotnet build-server`: This interacts with servers started by a build.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet build-server`: 这与由构建启动的服务器交互。'
- en: '`dotnet msbuild`: This runs MS Build Engine commands.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet msbuild`: 这将运行 MS Build 引擎命令。'
- en: '`dotnet clean`: This removes the temporary outputs from a build.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet clean`: 这从构建中删除临时输出。'
- en: '`dotnet test`: This builds and then runs unit tests for the project.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet test`: 这将构建并运行项目的单元测试。'
- en: '`dotnet run`: This builds and then runs the project.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet run`: 这将构建并运行项目。'
- en: '`dotnet pack`: This creates a NuGet package for the project.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet pack`: 这为项目创建一个 NuGet 包。'
- en: '`dotnet publish`: This builds and then publishes the project, either with dependencies
    or as a self-contained application. In .NET 7 and earlier, this published the
    `Debug` configuration by default. In .NET 8 and later, it now publishes the `Release`
    configuration by default.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet publish`: 这将构建并发布项目，可以是带依赖项的，也可以是自包含的应用程序。在 .NET 7 及更早版本中，默认发布 `Debug`
    配置。在 .NET 8 及更高版本中，现在默认发布 `Release` 配置。'
- en: '`dotnet add`: This adds a reference to a package or class library to the project.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet add`: 这将包或类库的引用添加到项目中。'
- en: '`dotnet remove`: This removes a reference to a package or class library from
    the project.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet remove`: 这将从项目中移除对包或类库的引用。'
- en: '`dotnet list`: This lists the package or class library references for the project.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet list`: 这列出项目的包或类库引用。'
- en: '`dotnet package search`: This allows you to search one or more package sources
    for packages that match a search term. The command format is `dotnet package search
    [search term] [options]`. You can learn more at the following link: [https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/#support-for-dotnet-search-command](https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/#support-for-dotnet-search-command).'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet package search`: 这允许您搜索一个或多个包源，以查找与搜索词匹配的包。命令格式为 `dotnet package search
    [search term] [options]`。您可以在以下链接中了解更多信息：[https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/#support-for-dotnet-search-command](https://devblogs.microsoft.com/nuget/announcing-nuget-6-9/#support-for-dotnet-search-command)。'
- en: Publishing a self-contained app
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布自包含应用程序
- en: 'Now that you have seen some example `dotnet` tool commands, we can publish
    our cross-platform console app:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了一些示例 `dotnet` 工具命令，我们可以发布我们的跨平台控制台应用程序：
- en: At the command prompt or terminal, make sure that you are in the `DotNetEverywhere`
    folder.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，确保您位于 `DotNetEverywhere` 文件夹中。
- en: 'Enter a command to build and publish the self-contained release version of
    the console application for Windows, as shown in the following command:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入命令以构建和发布 Windows 的控制台应用程序的单文件发布版本，如下所示：
- en: '[PRE32]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The publishing process can take a while, so be patient.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发布过程可能需要一段时间，请耐心等待。
- en: 'Note that the build engine restores any needed packages, compiles the project
    source code into an assembly DLL, and creates a `publish` folder, as shown in
    the following output:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，构建引擎会恢复任何需要的包，将项目源代码编译成程序集 DLL，并创建一个 `publish` 文件夹，如下所示：
- en: '[PRE33]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Enter the following commands to build and publish the release versions for
    the macOS and Linux variants, as shown in the following commands:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以构建和发布 macOS 和 Linux 变体的发布版本，如下所示：
- en: '[PRE34]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Good Practice**: You could automate these commands by using a scripting language
    like PowerShell and execute the script file on any OS, using the cross-platform
    PowerShell Core. I have done this for you at the following link: [https://github.com/markjprice/cs13net9/tree/main/scripts/publish-scripts](https://github.com/markjprice/cs13net9/tree/main/scripts/publish-scripts).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：您可以使用 PowerShell 等脚本语言自动化这些命令，并在任何操作系统上执行脚本文件，使用跨平台的 PowerShell Core。我已经为您在以下链接中完成了这项工作：[https://github.com/markjprice/cs13net9/tree/main/scripts/publish-scripts](https://github.com/markjprice/cs13net9/tree/main/scripts/publish-scripts)。'
- en: Open Windows **File Explorer** or a macOS **Finder** window, navigate to `DotNetEverywhere\bin\Release\net9.0`,
    and note the output folders for the five OSes.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Windows **文件资源管理器**或 macOS **查找器**窗口，导航到 `DotNetEverywhere\bin\Release\net9.0`，并注意五个操作系统对应的输出文件夹。
- en: In the `win-x64` folder, open the `publish` folder, and note all the supporting
    assemblies, like `Microsoft.CSharp.dll`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `win-x64` 文件夹中，打开 `publish` 文件夹，并注意所有支持程序集，如 `Microsoft.CSharp.dll`。
- en: 'Select the `DotNetEverywhere` executable file, and note that it is 154 KB,
    as shown in *Figure 7.3*:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `DotNetEverywhere` 可执行文件，并注意它的大小为 154 KB，如图 *7.3* 所示：
- en: '![](img/B22322_07_03.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_07_03.png)'
- en: 'Figure 7.3: The DotNetEverywhere executable file for Windows 64-bit'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：Windows 64 位 DotNetEverywhere 可执行文件
- en: 'If you are on Windows with an x64-compatible chip, then double-click to execute
    the program and note the result, as shown in the following output:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是具有 x64 兼容芯片的 Windows，则双击程序以执行，并注意结果，如下所示：
- en: '[PRE35]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I executed the program on my Surface Laptop 7, so I targeted and built for the
    `win-arm64` architecture. The preceding output shows the results on my computer.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的 Surface Laptop 7 上执行了程序，因此针对并构建了 `win-arm64` 架构。前面的输出显示了在我的计算机上的结果。
- en: Press any key to close the console app and its window.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按任意键关闭控制台应用程序及其窗口。
- en: Note that the total size of the `publish` folder and all its files is 68.3 MB.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`publish` 文件夹及其所有文件的总大小为 68.3 MB。
- en: In the `osx-arm64` folder, select the `publish` folder, note all the supporting
    assemblies, and then select the `DotNetEverywhere` executable file. Note that
    the executable is 125 KB and the `publish` folder is about 73.9 MB. There is no
    `.exe` file extension for published applications on macOS, so the filename will
    not have an extension.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `osx-arm64` 文件夹中，选择 `publish` 文件夹，注意所有支持程序集，然后选择 `DotNetEverywhere` 可执行文件。请注意，可执行文件大小为
    125 KB，而 `publish` 文件夹大约为 73.9 MB。在 macOS 上发布的应用程序没有 `.exe` 文件扩展名，因此文件名不会有扩展名。
- en: 'If you copy any of those `publish` folders to the appropriate **operating system**
    (**OS**), the console app will run; this is because it is a self-contained, deployable
    .NET application. For example, here it is on macOS:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将任何这些 `publish` 文件夹复制到适当的 **操作系统**（**OS**），控制台应用程序将运行；这是因为它是一个自包含、可部署的 .NET
    应用程序。例如，在 macOS 上就是这样：
- en: '[PRE36]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This example used a console app, but you could just as easily create an ASP.NET
    Core website or web service, or a Windows Forms or WPF app. Of course, you can
    only deploy Windows desktop apps to Windows computers, not Linux or macOS.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用的是控制台应用程序，但您同样可以轻松创建 ASP.NET Core 网站、网络服务或 Windows Forms 或 WPF 应用程序。当然，您只能将
    Windows 桌面应用程序部署到 Windows 计算机，而不是 Linux 或 macOS。
- en: Publishing a single-file app
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布单文件应用程序
- en: 'If you know that .NET is already installed on the computer on which you want
    to run your app, then you can use the extra flags when you publish your app for
    release to say that it does not need to be self-contained and that you want to
    publish it as a single file (if possible), as shown in the following command (which
    must be entered on a single line):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你想要运行你的应用的计算机上已经安装了 .NET，那么你可以在发布你的应用时使用额外的标志来说明它不需要自包含，并且你希望将其发布为单个文件（如果可能），如下所示（必须在单行中输入）：
- en: '[PRE37]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will generate two files: `DotNetEverywhere.exe` and `DotNetEverywhere.pdb`.
    The `.exe` file is the executable. The `.pdb` file is a **program debug database**
    file that stores debugging information.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个文件：`DotNetEverywhere.exe` 和 `DotNetEverywhere.pdb`。`.exe` 文件是可执行文件。`.pdb`
    文件是一个 **程序调试数据库** 文件，用于存储调试信息。
- en: 'If you prefer the `.pdb` file to be embedded in the `.exe` file (for example,
    to ensure that it is deployed with its assembly), then add a `<DebugType>` element
    to the `<PropertyGroup>` element in your `.csproj` file and set it to `embedded`,
    as shown highlighted in the following markup:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 `.pdb` 文件嵌入到 `.exe` 文件中（例如，以确保它与程序集一起部署），那么请将 `<DebugType>` 元素添加到你的 `.csproj`
    文件中的 `<PropertyGroup>` 元素，并将其设置为 `embedded`，如下所示（以下标记已高亮显示）：
- en: '[PRE38]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you cannot assume that .NET is already installed on a computer, then although
    Linux also only generates the two files, expect the following additional files
    for Windows: `coreclr.dll`, `clrjit.dll`, `clrcompression.dll`, and `mscordaccore.dll`.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能假设计算机上已经安装了 .NET，那么尽管 Linux 也只生成两个文件，但对于 Windows，你还需要期待以下额外的文件：`coreclr.dll`、`clrjit.dll`、`clrcompression.dll`
    和 `mscordaccore.dll`。
- en: 'Let’s see an example for Windows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 Windows 为例：
- en: 'At the command prompt or terminal, in the `DotNetEverywhere` folder, enter
    the command to build the self-contained release version of the console app for
    Windows, as shown in the following command:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，在 `DotNetEverywhere` 文件夹中，输入构建 Windows 控制台应用自包含发布版本的命令，如下所示：
- en: '[PRE39]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Navigate to the `DotNetEverywhere\bin\Release\net9.0\win-x64\publish` folder
    and select the `DotNetEverywhere` executable file. Note that the executable is
    now 62.6 MB, and there is also a `.pdb` file that is 11 KB. The sizes of these
    files on your system will vary.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `DotNetEverywhere\bin\Release\net9.0\win-x64\publish` 文件夹，并选择 `DotNetEverywhere`
    可执行文件。请注意，可执行文件现在为 62.6 MB，还有一个 11 KB 的 `.pdb` 文件。这些文件在你的系统中的大小可能会有所不同。
- en: Reducing the size of apps using app trimming
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用应用裁剪减小应用大小
- en: One of the problems with deploying a .NET app as a self-contained app is that
    the .NET libraries take up a lot of space. One of the biggest needs is to reduce
    the size of Blazor WebAssembly components because all the .NET libraries need
    to be downloaded to the browser.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 将 .NET 应用作为自包含应用部署的一个问题是 .NET 库占用大量空间。最大的需求之一是减少 Blazor WebAssembly 组件的大小，因为所有
    .NET 库都需要下载到浏览器。
- en: Luckily, you can reduce this size by not packaging unused assemblies with your
    deployments. Introduced with .NET Core 3, the app trimming system can identify
    the assemblies needed by your code and remove those that are not needed. This
    was known as `copyused` trim mode.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以通过不将未使用的程序集打包到你的部署中来减小这个大小。从 .NET Core 3 开始引入的应用裁剪系统可以识别你的代码需要的程序集，并删除那些不需要的程序集。这被称为
    `copyused` 裁剪模式。
- en: With .NET 5, the trimming went further by removing individual types, and even
    members, like methods from within an assembly if they are not used. For example,
    with a **Hello World** console app, the `System.Console.dll` assembly is trimmed
    from 61.5 KB to 31.5 KB. This was known as `link` trim mode, but it was not enabled
    by default.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 5 中，裁剪进一步扩展，通过删除未使用的单个类型，甚至成员（例如，方法），如果它们在程序集中未被使用。例如，对于一个 **Hello World**
    控制台应用，`System.Console.dll` 程序集从 61.5 KB 裁剪到 31.5 KB。这被称为 `link` 裁剪模式，但默认情况下并未启用。
- en: With .NET 6, Microsoft added annotations to their libraries to indicate how
    they can be safely trimmed, so the trimming of types and members was made the
    default.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 6 中，微软向他们的库添加了注释，以指示它们如何安全地进行裁剪，因此类型和成员的裁剪被设置为默认选项。
- en: With .NET 7, Microsoft renamed `link` to `full` and `copyused` to `partial`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 7 中，微软将 `link` 重命名为 `full`，将 `copyused` 重命名为 `partial`。
- en: The catch is how well the trimming identifies unused assemblies, types, and
    members. If your code is dynamic, perhaps using reflection, then it might not
    work correctly, so Microsoft also allows manual control.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是裁剪如何准确地识别未使用的程序集、类型和成员。如果你的代码是动态的，可能使用了反射，那么它可能无法正确工作，因此微软也允许手动控制。
- en: There are two ways to enable type-level and member-level, aka `full`, trimming.
    Since this level of trimming is the default with .NET 6 or later, all we need
    to do is enable trimming without setting a trim level or mode.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式来启用类型级别和成员级别，也就是所谓的`full`级别的修剪。由于这种修剪级别在.NET 6或更高版本中是默认的，我们只需要启用修剪，而不需要设置修剪级别或模式。
- en: 'The first way is to add an element to the project file, as shown in the following
    markup:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方式是在项目文件中添加一个元素，如下所示：
- en: '[PRE40]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The second way is to add a flag when publishing, as shown highlighted in the
    following command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是在发布时添加一个标志，如下所示高亮显示的命令：
- en: '[PRE41]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are two ways to enable assembly-level, aka `partial`, trimming.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式来启用程序集级别，也就是所谓的`partial`级别的修剪。
- en: 'The first way is to add two elements to the project file, as shown in the following
    markup:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方式是在项目文件中添加两个元素，如下所示：
- en: '[PRE42]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The second way is to add two flags when publishing, as shown highlighted in
    the following command:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是在发布时添加两个标志，如下所示高亮显示的命令：
- en: '[PRE43]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Controlling where build artifacts are created
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制构建工件创建的位置
- en: Traditionally, each project has its own `bin` and `obj` subfolders where temporary
    files are created during the build process. When you publish, the files are created
    in the `bin` folder.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，每个项目都有自己的`bin`和`obj`子文件夹，在构建过程中会创建临时文件。当你发布时，文件会创建在`bin`文件夹中。
- en: 'You might prefer to put all these temporary files and folders somewhere else.
    Introduced with .NET 8 is the ability to control where build artifacts are created.
    Let’s see how:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望将这些临时文件和文件夹放在其他地方。随着.NET 8的引入，现在可以控制构建工件创建的位置。让我们看看如何：
- en: 'At the command prompt or terminal for the `Chapter07` folder, enter the following
    command:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter07`文件夹的命令提示符或终端中，输入以下命令：
- en: '[PRE44]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note the success message, as shown in the following output:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意成功消息，如下所示输出：
- en: '[PRE45]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We could have created this file in the `cs13net9` folder, and it would then
    affect all projects in all chapters.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在`cs13net9`文件夹中创建此文件，然后它将影响所有章节的所有项目。
- en: 'In the `Chapter07` folder, open the `Directory.Build.props` file, as shown
    in the following markup:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter07`文件夹中，打开`Directory.Build.props`文件，如下所示：
- en: '[PRE46]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Build any project or the whole solution.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建任何项目或整个解决方案。
- en: In the `Chapter07` folder, note that there is now an `artifacts` folder that
    contains subfolders for any recently built projects.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter07`文件夹中，请注意现在有一个`artifacts`文件夹，其中包含任何最近构建项目的子文件夹。
- en: You can delete this file, or rename it to something like `Directory.Build.props.disabled`
    so that it does not affect the rest of this chapter by building these artifacts
    in a folder that you do not expect based on default behavior. This is optional
    but recommended.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以删除此文件，或者将其重命名为类似`Directory.Build.props.disabled`的名称，这样它就不会通过在你不期望的文件夹中构建这些工件来影响本章的其余部分。这是可选的，但建议这样做。
- en: '**Warning!** If you leave this build configuration enabled, then remember that
    your build artifacts are now created in this new folder structure.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**如果你保持此构建配置启用，请记住你的构建工件现在将创建在这个新的文件夹结构中。'
- en: Native ahead-of-time compilation
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生提前编译
- en: 'Native AOT produces assemblies that are:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 原生AOT生成的程序集是：
- en: '**Self-contained**, meaning they can run on systems that do not have the .NET
    runtime installed.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自包含**，意味着它们可以在没有安装.NET运行时的系统上运行。'
- en: '**Ahead-of-time (AOT) compiled for native code**, meaning a faster startup
    time and a potentially smaller memory footprint.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提前编译（AOT）为原生代码**，这意味着启动时间更快，内存占用可能更小。'
- en: Native AOT compiles IL code to native code at the time of writing, rather than
    at runtime using the **Just in Time (JIT)** compiler. But native AOT assemblies
    must target a specific runtime environment like Windows x64 or Linux Arm.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 原生AOT在编写时将IL代码编译为原生代码，而不是在运行时使用**即时（JIT）**编译器。但原生AOT程序集必须针对特定的运行时环境，如Windows
    x64或Linux Arm。
- en: Since native AOT happens at publish time, you should remember that while you
    are debugging and working live on a project in your code editor, it still uses
    the runtime JIT compiler, not native AOT, even if you have AOT enabled in the
    project!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原生AOT发生在发布时，你应该记住，当你在你代码编辑器中调试和实时工作在项目上时，它仍然使用运行时JIT编译器，即使你在项目中启用了AOT！
- en: However, some features that are incompatible with native AOT will be disabled
    or throw exceptions, and a source analyzer is enabled to show warnings about potential
    code incompatibilities.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些与原生AOT不兼容的功能将被禁用或抛出异常，并启用源分析器来显示有关潜在代码不兼容性的警告。
- en: Limitations of native AOT
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地 AOT 的限制
- en: 'Native AOT has limitations that apply to projects that enable it, some of which
    are shown in the following list:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 AOT 对启用它的项目有一些限制，以下列出了一些：
- en: No dynamic loading of assemblies.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许动态加载程序集。
- en: No runtime code generation, for example, using `System.Reflection.Emit`.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许运行时代码生成，例如使用 `System.Reflection.Emit`。
- en: It requires trimming, which has its own limitations, as we covered in the previous
    section.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这需要裁剪，正如我们在上一节中提到的，它有其自身的限制。
- en: The projects must be self-contained, so they must embed any libraries they call,
    which increases their size.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目必须是自包含的，因此它们必须嵌入它们所调用的任何库，这增加了它们的大小。
- en: Although your own assemblies might not use the features listed above, major
    parts of .NET itself do. For example, ASP.NET Core MVC (including web API services
    that use controllers) and EF Core do runtime code generation to implement their
    functionality.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您自己的程序集可能没有使用上面列出的功能，但 .NET 本身的主要部分确实使用了。例如，ASP.NET Core MVC（包括使用控制器的 Web
    API 服务）和 EF Core 都会进行运行时代码生成以实现其功能。
- en: The .NET teams are hard at work making as much of .NET compatible with native
    AOT as possible, as soon as possible. But .NET 9 only includes basic support for
    ASP.NET Core if you use Minimal APIs, and no support for EF Core.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 团队正在努力使尽可能多的 .NET 与本地 AOT 兼容，并且尽快实现。但如果你使用 Minimal APIs，.NET 9 只包括对 ASP.NET
    Core 的基本支持，并且没有对 EF Core 的支持。
- en: My guess is that .NET 10 will include support for ASP.NET Core MVC and some
    parts of EF Core, but it could take until .NET 11 or .NET 12 before we can all
    confidently use most of .NET and know we can build our assemblies with native
    AOT to gain the benefits.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我的猜测是，.NET 10 将包括对 ASP.NET Core MVC 和 EF Core 部分的支持，但可能需要到 .NET 11 或 .NET 12
    我们才能自信地使用大多数 .NET，并且知道我们可以使用本地 AOT 构建我们的程序集以获得这些好处。
- en: The native AOT publishing process includes code analyzers to warn you if you
    use any features that are not supported, but not all packages have been annotated
    to work well with these yet.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 AOT 发布过程包括代码分析器来警告您是否使用了不受支持的功能，但并非所有包都已注释以与这些分析器良好协作。
- en: The most common annotation used to indicate that a type or member does not support
    AOT is the `[RequiresDynamicCode]` attribute.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的注释来指示类型或成员不支持 AOT 是 `[RequiresDynamicCode]` 属性。
- en: '**More Information**: You can learn more about AOT warnings at the following
    link: [https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/fixing-warnings](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/fixing-warnings).'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于 AOT 警告的信息：[https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/fixing-warnings](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/fixing-warnings)。'
- en: Reflection and native AOT
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射和本地 AOT
- en: Reflection is frequently used for runtime inspection of type `metadata`, dynamic
    invocation of members, and code generation.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 反射常用于运行时检查类型 `元数据`、成员的动态调用和代码生成。
- en: Native AOT does allow some reflection features, but the trimming performed during
    the native AOT compilation process cannot statically determine when a type has
    members that might be only accessed via reflection. These members would be removed
    by AOT, which would then cause a runtime exception.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 AOT 允许一些反射功能，但在本地 AOT 编译过程中进行的裁剪无法静态确定类型是否有可能仅通过反射访问的成员。这些成员将被 AOT 移除，这会导致运行时异常。
- en: '**Good Practice**: Developers must annotate their types with `[DynamicallyAccessedMembers]`
    to indicate a member that is only dynamically accessed via reflection and should,
    therefore, be left untrimmed.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：开发者必须使用 `[DynamicallyAccessedMembers]` 注释来标记仅通过反射动态访问的成员，因此应保留未裁剪。'
- en: Requirements for native AOT
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地 AOT 的要求
- en: 'There are additional requirements for different OSes:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的操作系统，有一些额外的要求：
- en: On Windows, you must install the Visual Studio **Desktop development with C++**
    workload with all default components.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，您必须安装包含所有默认组件的 Visual Studio **桌面开发与 C++** 工作负载。
- en: 'On Linux, you must install the compiler toolchain and developer packages for
    libraries that the .NET runtime depends on. For example, for Ubuntu 18.04 or later:
    `sudo apt-get install clang zlib1g-dev`.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 上，您必须安装 .NET 运行时所依赖的库的编译器工具链和开发包。例如，对于 Ubuntu 18.04 或更高版本：`sudo apt-get
    install clang zlib1g-dev`。
- en: '**Warning!** Cross-platform native AOT publishing is not supported. This means
    that you must run the publish action on the OS that you will deploy to. For example,
    you cannot publish a native AOT project on Linux to later run on Windows, and
    vice versa.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告！** 不支持跨平台原生 AOT 发布。这意味着您必须在您将要部署的操作系统上运行发布操作。例如，您不能在 Linux 上发布用于在 Windows
    上运行的本地 AOT 项目，反之亦然。'
- en: Enabling native AOT for a project
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用项目的原生 AOT
- en: 'To enable native AOT publishing in a project, add the `<PublishAot>` element
    to the project file, as shown highlighted in the following markup:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中启用原生 AOT 发布，请将 `<PublishAot>` 元素添加到项目文件中，如下所示标记突出显示：
- en: '[PRE47]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Building a native AOT project
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建原生 AOT 项目
- en: 'Now, let’s see a practical example using the new AOT option for a console app:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用控制台应用程序的新 AOT 选项来查看一个实际示例：
- en: 'In the solution named `Chapter07`, add a native AOT-compatible console app
    project, as defined in the following list:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `Chapter07` 的解决方案中，添加一个与以下列表定义的本地 AOT 兼容的控制台应用程序项目：
- en: 'Project template: **Console App** / `console --aot`'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console --aot`
- en: 'Solution file and folder: `Chapter07`'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter07`
- en: 'Project file and folder: `AotConsole`'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`AotConsole`
- en: 'Do not use top-level statements: Cleared'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用顶层语句：已清除
- en: 'Enable native AOT publish: Selected'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用原生 AOT 发布：已选择
- en: If your code editor does not yet provide the option for AOT, create a traditional
    console app, and then you will need to manually enable AOT, as shown in step 2,
    or use the `dotnet` CLI.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码编辑器尚未提供 AOT 选项，请创建一个传统的控制台应用程序，然后您将需要手动启用 AOT，如步骤 2 所示，或使用 `dotnet` CLI。
- en: 'In the project file, note that native AOT publishing is enabled, as well as
    invariant globalization, as shown highlighted in the following markup:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，请注意已启用原生 AOT 发布以及不变全球化，如下所示标记突出显示：
- en: '[PRE48]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Explicitly setting invariant globalization to `true` is new in the **Console
    App** project template with .NET 8\. It is designed to make a console app non-culture-specific
    so that it can be deployed anywhere in the world and have the same behavior. If
    you set this property to `false`, or if the element is missing, then the console
    app will default to the culture of the current computer it is hosted on. You can
    read more about invariant globalization mode at the following link: [https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md](https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md).'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 8 的 **控制台应用程序** 项目模板中，显式设置不变全球化为 `true` 是新的。它旨在使控制台应用程序不受文化限制，以便可以在世界任何地方部署并具有相同的行为。如果您将此属性设置为
    `false`，或者如果元素缺失，则控制台应用程序将默认为当前托管计算机的文化。您可以在以下链接中了解更多关于不变全球化模式的信息：[https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md](https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md)。
- en: Modify the project file to statically import the `System.Console` class in all
    C# files.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改项目文件以在所有 C# 文件中静态导入 `System.Console` 类。
- en: 'In `Program.cs`, delete any existing statements, and then add statements to
    output the current culture and OS version, as shown in the following code:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除任何现有语句，然后添加语句以输出当前文化和操作系统版本，如下所示代码：
- en: '[PRE49]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the console app project and note that the culture is invariant, as shown
    in the following output:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序项目，并注意文化是不变的，如下所示输出：
- en: '[PRE50]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Warning!** Actually, the console app is not AOT-compiled; it is still currently
    JIT-compiled because we have not yet published it.'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**警告！** 实际上，控制台应用程序尚未进行 AOT 编译；它仍然是当前 JIT 编译的，因为我们尚未发布它。'
- en: Publishing a native AOT project
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布原生 AOT 项目
- en: A console app that functions correctly during development when the code is untrimmed
    and JIT-compiled could still fail once you publish it using native AOT, as the
    code is then trimmed and JIT-compiled, and therefore, it is different code with
    different behavior. You should, therefore, perform a publish action before assuming
    your project will work.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发期间代码未裁剪且 JIT 编译时功能正确的控制台应用程序，在您使用原生 AOT 发布后仍可能失败，因为代码此时被裁剪并 JIT 编译，因此它是不同的代码，具有不同的行为。因此，在假设项目将正常工作之前，您应该执行发布操作。
- en: If your project does not produce any AOT warnings at publish time, you can then
    be confident that your service will work after publishing for AOT.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在发布时您的项目没有产生任何 AOT 警告，那么您可以有信心在发布后 AOT 将正常工作。
- en: 'Let’s publish our console app:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发布我们的控制台应用程序：
- en: 'At the command prompt or terminal for the `AotConsole` project, publish the
    console app using native AOT, as shown in the following command:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AotConsole`项目的命令提示符或终端中，使用原生AOT发布控制台应用程序，如下面的命令所示：
- en: '[PRE51]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note the message about generating native code, as shown in the following output:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意关于生成原生代码的消息，如下面的输出所示：
- en: '[PRE52]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Start **File Explorer**, open the `bin\Release\net9.0\win-x64\publish` folder,
    and note that the `AotConsole.exe` file is about 1.2 MB. The `AotConsole.pdb`
    file is only needed for debugging.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动**文件资源管理器**，打开`bin\Release\net9.0\win-x64\publish`文件夹，并注意`AotConsole.exe`文件大约有1.2
    MB。`AotConsole.pdb`文件仅用于调试。
- en: Run the `AotConsole.exe` and note that the console app has the same behavior
    as before.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`AotConsole.exe`，注意控制台应用程序的行为与之前相同。
- en: 'In `Program.cs`, import namespaces to work with dynamic code assemblies, as
    shown in the following code:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入命名空间以处理动态代码程序集，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In `Program.cs`, create a dynamic assembly builder, as shown in the following
    code:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个动态程序集构建器，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At the command prompt or terminal for the `AotConsole` project, publish the
    console app using native AOT, as shown in the following command:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AotConsole`项目的命令提示符或终端中，使用原生AOT发布控制台应用程序，如下面的命令所示：
- en: '[PRE55]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note the warning about calling the `DefineDynamicAssembly` method, which the
    .NET team has decorated with the `[RequiresDynamicCode]` attribute, as shown in
    the following output:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意关于调用带有`[RequiresDynamicCode]`属性装饰的`DefineDynamicAssembly`方法的警告，如下面的输出所示：
- en: '[PRE56]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Comment out the statement that we cannot use in an AOT project.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们无法在AOT项目中使用的语句注释掉。
- en: '**More Information**: You can learn more about native AOT at the following
    link: [https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/).'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接中了解更多关于原生AOT的信息：[https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/)。'
- en: Packaging your libraries for NuGet distribution
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为NuGet分发打包你的库
- en: Before we learn how to create and package our own libraries, we will review
    how a project can use an existing package.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何创建和打包自己的库之前，我们将回顾一个项目如何使用现有的包。
- en: Referencing a NuGet package
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用NuGet包
- en: 'Let’s say that you want to add a package created by a third-party developer,
    for example, `Newtonsoft.Json`, a popular package for working with the **JavaScript
    Object Notation** (**JSON**) serialization format:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想添加一个第三方开发者创建的包，例如，`Newtonsoft.Json`，这是一个用于处理**JavaScript对象表示法**（**JSON**）序列化格式的流行包：
- en: In the `AssembliesAndNamespaces` project, add a reference to the `Newtonsoft.Json`
    NuGet package, either using the GUI for Visual Studio or the `dotnet add package`
    command using the CLI.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AssembliesAndNamespaces`项目中，可以通过Visual Studio的GUI或使用CLI的`dotnet add package`命令添加对`Newtonsoft.Json`
    NuGet包的引用。
- en: 'With the April release of C# Dev Kit, you can now manage your NuGet packages
    directly from VS Code using some commands in the command palette, as described
    at the following link: [https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/](https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/).'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#开发工具包的4月版本中，你现在可以使用命令面板中的某些命令直接从VS Code管理NuGet包，如以下链接所述：[https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/](https://devblogs.microsoft.com/nuget/announcing-nuget-commands-in-c-dev-kit/)。
- en: 'Open the `AssembliesAndNamespaces.csproj` file and note that a package reference
    has been added, as shown in the following markup:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AssembliesAndNamespaces.csproj`文件，注意已经添加了一个包引用，如下面的标记所示：
- en: '[PRE57]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you have a more recent version of the `Newtonsoft.Json` package, then it
    has been updated since this chapter was written.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个更新的`Newtonsoft.Json`包版本，那么自本章编写以来它已经被更新。
- en: Fixing dependencies
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决依赖关系
- en: 'To consistently restore packages and write reliable code, it’s important that
    you **fix dependencies**. Fixing dependencies means you are using the same family
    of packages released for a specific version of .NET, for example, SQLite for .NET
    9, as shown highlighted in the following markup:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一致地还原包并编写可靠的代码，**解决依赖关系**非常重要。解决依赖关系意味着你正在使用为特定版本的.NET发布的同一系列包，例如，SQLite用于.NET
    9，如下面的标记所示：
- en: '[PRE58]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To fix dependencies, every package should have a single version with no additional
    qualifiers. Additional qualifiers include betas (`beta1`), release candidates
    (`rc4`), and wildcards (`*`).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决依赖关系，每个包都应该有一个单一的版本，没有额外的限定符。额外的限定符包括测试版（`beta1`）、发布候选版（`rc4`）和通配符（`*`）。
- en: Wildcards allow future versions to be automatically referenced and used because
    they always represent the most recent release. Wildcards are, therefore, dangerous
    because they could result in the use of future incompatible packages that break
    your code.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符允许自动引用和使用未来的版本，因为它们始终代表最新的发布。因此，通配符是危险的，因为它们可能导致使用未来不兼容的包，从而破坏您的代码。
- en: 'This can be worth the risk while writing a book where new preview versions
    are released every month and you do not want to keep updating the preview package
    references, as I did during 2024, and as shown in the following markup:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写书籍时，这可能值得承担风险，因为每个月都会发布新的预览版本，您不想像我在2024年那样不断更新预览包引用，如下所示：
- en: '[PRE59]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To also automatically use the release candidates that arrive in September and
    October each year, you can make the pattern even more flexible, as shown in the
    following markup:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动使用每年9月和10月到达的发布候选版本，您可以使模式更加灵活，如下所示：
- en: '[PRE60]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you use the `dotnet add package` command or Visual Studio’s **Manage NuGet
    Packages**, then it will by default use the latest specific version of a package.
    But if you copy and paste configuration from a blog article or manually add a
    reference yourself, you might include wildcard qualifiers.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`dotnet add package`命令或Visual Studio的**管理NuGet包**，则默认情况下将使用包的最新特定版本。但如果您从博客文章中复制粘贴配置或手动添加引用，您可能会包含通配符限定符。
- en: 'The following dependencies are examples of NuGet package references that are
    *not* fixed and, therefore, should be avoided unless you know the implications:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些NuGet包引用的示例，它们*不是*固定的，因此除非您知道其影响，否则应避免使用：
- en: '[PRE61]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Good Practice**: Microsoft guarantees that if you fix your dependencies to
    what ships with a specific version of .NET, for example, `9.0.0`, those packages
    will all work together. Almost always fix your dependencies, especially in production
    deployments.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：Microsoft保证，如果您将依赖项固定到与特定.NET版本（例如`9.0.0`）一起提供的版本，那么所有这些包都将一起工作。几乎总是固定依赖项，尤其是在生产部署中。'
- en: Packaging a library for NuGet
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包库以用于NuGet
- en: 'Now, let’s package the `SharedLibrary` project that you created earlier:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打包您之前创建的`SharedLibrary`项目：
- en: 'In the `SharedLibrary` project, note that the class library targets .NET Standard
    2.0 and, therefore, by default, uses the C# 7.3 compiler. Explicitly specify the
    C# 12 compiler, as shown in the following markup:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedLibrary`项目中，请注意类库的目标是.NET Standard 2.0，因此默认情况下使用C# 7.3编译器。如以下标记所示，明确指定C#
    12编译器：
- en: '[PRE62]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the `SharedLibrary` project, rename the `Class1.cs` file `StringExtensions.cs`.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedLibrary`项目中，将`Class1.cs`文件重命名为`StringExtensions.cs`。
- en: 'Modify its contents to provide some useful extension methods to validate various
    text values, using regular expressions, as shown in the following code:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容，以提供一些有用的扩展方法来验证各种文本值，使用正则表达式，如下所示：
- en: '[PRE63]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You will learn how to write regular expressions in *Chapter 8*, *Working with
    Common .NET Types*.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第8章*，*使用常见.NET类型*中学习如何编写正则表达式。
- en: 'In `SharedLibrary.csproj`, modify its contents, as shown highlighted in the
    following markup, and note the following:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedLibrary.csproj`中，修改其内容，如下所示，并注意以下内容：
- en: '`PackageId` must be globally unique, so you must use a different value if you
    want to publish this NuGet package to the [https://www.nuget.org/](https://www.nuget.org/)
    public feed for others to reference and download.'
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageId`必须是全局唯一的，因此如果您想将此NuGet包发布到[https://www.nuget.org/](https://www.nuget.org/)公共源供他人引用和下载，您必须使用不同的值。'
- en: '`PackageLicenseExpression` must be a value from [https://spdx.org/licenses/](https://spdx.org/licenses/),
    or you could specify a custom license.'
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageLicenseExpression`必须是来自[https://spdx.org/licenses/](https://spdx.org/licenses/)的值，或者您可以指定自定义许可。'
- en: '**Warning!** If you rely on IntelliSense to edit the file, then it could mislead
    you to use deprecated tag names. For example, `<PackageIconUrl>` is deprecated
    in favor of `<PackageIcon>`. Sometimes, you cannot trust automated tools to help
    you correctly! The recommended tag names are documented in the **MSBuild Property**
    column in the table found at the following link: [https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#pack-target](https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#pack-target).'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**警告！**如果你依赖IntelliSense来编辑文件，那么它可能会误导你使用已弃用的标签名称。例如，`<PackageIconUrl>`已被`<PackageIcon>`取代。有时，你不能完全信任自动化工具来帮助你正确操作！推荐的标签名称在以下链接中找到的表格的**MSBuild属性**列中有记录：[https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#pack-target](https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#pack-target)。'
- en: 'All the other elements are self-explanatory:'
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他元素都是自解释的：
- en: '[PRE64]'
  id: totrans-510
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`<None>` represents a file that does not participate in the build process.
    `Pack="true"` means the file will be included in the NuGet package created in
    the specified package path location. You can learn more at the following link:
    [https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#packing-an-icon-image-file](https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#packing-an-icon-image-file).'
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<None>`表示一个不参与构建过程的文件。`Pack="true"`表示该文件将被包含在指定包路径位置创建的NuGet包中。你可以通过以下链接了解更多信息：[https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#packing-an-icon-image-file](https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets#packing-an-icon-image-file)。'
- en: '**Good Practice**: Configuration property values that are `true` or `false`
    values cannot have any whitespace.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：配置属性值如果是`true`或`false`，则不能有任何空白字符。'
- en: 'Download the icon file and save it in the `SharedLibrary` project folder from
    the following link: [https://github.com/markjprice/cs13net9/blob/main/code/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png](https://github.com/markjprice/cs13net9/blob/main/code/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png).'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载图标文件，并将其保存到`SharedLibrary`项目文件夹中：[https://github.com/markjprice/cs13net9/blob/main/code/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png](https://github.com/markjprice/cs13net9/blob/main/code/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png).
- en: 'In the `SharedLibrary` project folder, create a file named `readme.md`, with
    some basic information about the package, as shown in the following markup:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`SharedLibrary`项目文件夹中，创建一个名为`readme.md`的文件，其中包含有关包的一些基本信息，如下所示：  '
- en: '[PRE65]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Build the release assembly:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建发布版本：
- en: In Visual Studio, select **Release** in the toolbar, and then navigate to **Build**
    | **Build SharedLibrary**.
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，在工具栏中选择**发布**，然后导航到**生成** | **生成SharedLibrary**。
- en: In VS Code, in **Terminal**, enter `dotnet build -c Release`.
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VS Code中的**终端**中，输入`dotnet build -c Release`。
- en: 'If we had not set `<GeneratePackageOnBuild>` to `true` in the project file,
    then we would have had to create a NuGet package manually using the following
    additional steps:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在项目文件中将`<GeneratePackageOnBuild>`设置为`true`，那么我们就必须手动使用以下额外步骤创建一个NuGet包：
- en: In Visual Studio, navigate to **Build** | **Pack SharedLibrary**.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航到**生成** | **打包SharedLibrary**。
- en: In VS Code, in **Terminal**, enter `dotnet pack -c Release`.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VS Code中的**终端**中，输入`dotnet pack -c Release`。
- en: Publishing a package to a public NuGet feed
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '将包发布到公共NuGet源  '
- en: 'If you want everyone to be able to download and use your NuGet package, then
    you must upload it to a public NuGet feed like Microsoft’s:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望每个人都能下载和使用你的NuGet包，那么你必须将其上传到公共NuGet源，如Microsoft的：
- en: 'Start your favorite browser and navigate to the following link: [https://www.nuget.org/packages/manage/upload](https://www.nuget.org/packages/manage/upload).'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你喜欢的浏览器并导航到以下链接：[https://www.nuget.org/packages/manage/upload](https://www.nuget.org/packages/manage/upload)。
- en: You will need to sign up for, and then sign in with, a Microsoft account at
    [https://www.nuget.org/](https://www.nuget.org/) if you want to upload a NuGet
    package for other developers to reference as a dependency package.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想上传一个NuGet包供其他开发者作为依赖项引用，你需要注册并登录到[https://www.nuget.org/](https://www.nuget.org/)的Microsoft账户。
- en: Click the **Browse...** button and select the `.nupkg` file that was created
    by generating the NuGet package. The folder path should be `cs13net9\Chapter07\SharedLibrary\bin\Release`
    and the file is named `Packt.CSdotnet.SharedLibrary.9.0.0.nupkg`.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**浏览...**按钮，选择由生成NuGet包创建的`.nupkg`文件。文件夹路径应该是`cs13net9\Chapter07\SharedLibrary\bin\Release`，文件名为`Packt.CSdotnet.SharedLibrary.9.0.0.nupkg`。
- en: Verify that the information you entered in the `SharedLibrary.csproj` file has
    been correctly filled in, and then click **Submit**.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您在`SharedLibrary.csproj`文件中输入的信息已正确填写，然后点击**提交**。
- en: 'Wait a few seconds, and then you will see a success message, showing that your
    package has been uploaded, as shown in *Figure 7.4*:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，然后您将看到一个成功消息，显示您的包已上传，如图*7.4*所示：
- en: '![](img/B22322_07_04.png)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_07_04.png)'
- en: 'Figure 7.4: A NuGet package upload message'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：NuGet包上传消息
- en: '**Good Practice**: If you get an error, then review the project file for mistakes,
    or read more information about the `PackageReference` format at [https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets](https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets).'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您遇到错误，请检查项目文件中的错误，或阅读有关`PackageReference`格式的更多信息，请参阅[https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets](https://learn.microsoft.com/en-us/nuget/reference/msbuild-targets)。'
- en: 'Click the **Frameworks** tab, and note that because we targeted .NET Standard
    2.0, our class library can be used by every .NET platform, as shown in *Figure
    7.5*:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**框架**选项卡，并注意，因为我们针对.NET Standard 2.0，我们的类库可以被每个.NET平台使用，如图*7.5*所示：
- en: '![](img/B22322_07_05.png)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_07_05.png)'
- en: 'Figure 7.5: .NET Standard 2.0 class library package can be used by all .NET
    platforms'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：.NET Standard 2.0类库包可以被所有.NET平台使用
- en: Publishing a package to a private NuGet feed
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将包发布到私有NuGet源
- en: 'Organizations can host their own private NuGet feeds. This can be a handy way
    for many developer teams to share work. You can read more at the following link:
    [https://learn.microsoft.com/en-us/nuget/hosting-packages/overview](https://learn.microsoft.com/en-us/nuget/hosting-packages/overview).'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 组织可以托管自己的私有NuGet源。这对于许多开发团队来说是一种方便的共享工作方式。您可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/nuget/hosting-packages/overview](https://learn.microsoft.com/en-us/nuget/hosting-packages/overview)。
- en: Exploring NuGet packages with a tool
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工具探索NuGet包
- en: 'A handy tool named **NuGet Package Explorer**, for opening and reviewing more
    details about a NuGet package, was created by Uno Platform. As well as being a
    website, it can be installed as a cross-platform app. Let’s see what it can do:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为**NuGet包浏览器**的实用工具，用于打开和查看NuGet包的更多详细信息，由Uno Platform创建。它不仅是一个网站，还可以作为跨平台应用程序安装。让我们看看它能做什么：
- en: 'Start your favorite browser and navigate to the following link: [https://nuget.info](https://nuget.info).'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您喜欢的浏览器并导航到以下链接：[https://nuget.info](https://nuget.info)。
- en: In the search box, enter `Packt.CSdotnet.SharedLibrary`.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`Packt.CSdotnet.SharedLibrary`。
- en: Select the package **v9.0.0** published by **Mark J Price**, and then click
    the **Open** button.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择由**马克·J·普莱斯**发布的**v9.0.0**版本包，然后点击**打开**按钮。
- en: In the **Contents** section, expand the `lib` folder and the `netstandard2.0`
    folder.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容**部分，展开`lib`文件夹和`netstandard2.0`文件夹。
- en: 'Select `SharedLibrary.dll`, and note the details, as shown in *Figure 7.6*:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`SharedLibrary.dll`，并注意详细信息，如图*7.6*所示：
- en: '![](img/B22322_07_06.png)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_07_06.png)'
- en: 'Figure 7.6: Exploring my package using NuGet Package Explorer from Uno Platform'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：使用Uno Platform的NuGet包浏览器探索我的包
- en: If you want to use this tool locally in the future, click the **Install** button
    in your browser.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想将来在本地使用此工具，请点击浏览器中的**安装**按钮。
- en: Close your browser.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器。
- en: Not all browsers support installing web apps like this. I recommend Chrome for
    testing and development.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有浏览器都支持安装此类Web应用。我建议使用Chrome进行测试和开发。
- en: Testing your class library package
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试您的类库包
- en: 'You will now test your uploaded package by referencing it in the `AssembliesAndNamespaces`
    project:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将通过在`AssembliesAndNamespaces`项目中引用它来测试您上传的包：
- en: 'In the `AssembliesAndNamespaces` project, add a reference to your (or my) package,
    as shown highlighted in the following markup:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AssembliesAndNamespaces`项目中，添加对您的（或我的）包的引用，如下所示，高亮显示的标记：
- en: '[PRE66]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Build the `AssembliesAndNamespaces` project.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目`AssembliesAndNamespaces`。
- en: In `Program.cs`, import the `Packt.Shared` namespace.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入`Packt.Shared`命名空间。
- en: 'In `Program.cs`, prompt the user to enter some `string` values, and then validate
    them using the extension methods in the package, as shown in the following code:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，提示用户输入一些`string`值，然后使用包中的扩展方法进行验证，如下所示：
- en: '[PRE67]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the `AssembliesAndNamespaces` project, enter some values as prompted, and
    view the results, as shown in the following output:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`AssembliesAndNamespaces`项目，根据提示输入一些值，并查看结果，如下所示：
- en: '[PRE68]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Working with preview features
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预览功能
- en: It is a challenge for Microsoft to deliver some new features that have cross-cutting
    effects across many parts of .NET, like the runtime, language compilers, and API
    libraries. It is the classic chicken and egg problem. What do you do first?
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微软来说，交付一些具有跨.NET多个部分影响的新功能是一个挑战，比如运行时、语言编译器和API库。这是一个典型的“先有鸡还是先有蛋”的问题。你先做什么？
- en: From a practical perspective, it means that although Microsoft might have completed
    most of the work needed for a feature, the whole thing might not be ready until
    very late in their now annual cycle of .NET releases, which is too late for proper
    testing in “the wild.”
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度来看，这意味着尽管微软可能已经完成了实现一个功能所需的大部分工作，但整个功能可能直到他们现在每年一次的.NET发布周期的最后阶段才完全准备好，这对于在“野外”进行适当的测试来说太晚了。
- en: So from .NET 6 onward, Microsoft will include preview features in **general
    availability** (**GA**) releases. Developers can opt into these preview features
    and provide Microsoft with feedback. In a later GA release, they can be enabled
    for everyone.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从.NET 6开始，微软将在**通用可用性**（**GA**）发布中包含预览功能。开发者可以选择加入这些预览功能并向微软提供反馈。在后续的GA发布中，它们可以为所有人启用。
- en: It is important to note that this topic is about *preview features*. This is
    different from a preview version of .NET or Visual Studio. Microsoft releases
    preview versions of Visual Studio and .NET while developing them to get feedback
    from developers, and then they do a final GA release. With GA, the feature is
    available for everyone. Before GA, the only way to get the new functionality was
    to install a preview version. *Preview features* are different because they are
    installed with GA releases and must be optionally enabled.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这个主题是关于 *预览功能*。这与.NET或Visual Studio的预览版不同。在开发过程中，微软会发布Visual Studio和.NET的预览版以获取开发者的反馈，然后进行最终的GA（通用可用性）发布。GA发布后，功能对所有用户可用。在GA发布之前，获取新功能唯一的方式是安装预览版。"预览功能"不同之处在于它们与GA发布一起安装，并且必须选择性地启用。
- en: For example, when Microsoft released .NET SDK 6.0.200 in February 2022, it included
    the C# 11 compiler as a preview feature. This meant that .NET 6 developers could
    optionally set the language version to `preview` and then start exploring C# 11
    features, like raw string literals and the `required` keyword.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当微软在2022年2月发布.NET SDK 6.0.200时，它将C# 11编译器作为一个预览功能包含在内。这意味着.NET 6开发者可以选择将语言版本设置为`preview`，然后开始探索C#
    11功能，如原始字符串字面量和`required`关键字。
- en: Once .NET SDK 7.0.100 was released in November 2022, any .NET 6 developer who
    wanted to continue to use the C# 11 compiler would then need to use the .NET 7
    SDK for their .NET 6 projects and set the target framework to `net6.0`, with a
    `<LangVersion>` set to `11`. This way, they use the supported .NET 7 SDK with
    the supported C# 11 compiler to build .NET 6 projects.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在2022年11月发布了.NET SDK 7.0.100，任何想要继续使用C# 11编译器的.NET 6开发者就需要使用.NET 7 SDK来处理他们的.NET
    6项目，并将目标框架设置为`net6.0`，同时设置`<LangVersion>`为`11`。这样，他们就可以使用受支持的.NET 7 SDK和受支持的C#
    11编译器来构建.NET 6项目。
- en: 'In November 2025, Microsoft is likely to release .NET 10 SDK with a C# 14 compiler.
    You can then install and use the .NET 10 SDK to gain the benefits of whatever
    new features are available in C# 14, while still targeting .NET 9, as shown highlighted
    in the following `Project` file:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 到2025年11月，微软可能会发布带有C# 14编译器的.NET 10 SDK。然后你可以安装并使用.NET 10 SDK来获得C# 14中任何新功能的益处，同时仍然针对.NET
    9，如下面的`Project`文件所示：
- en: '[PRE69]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**Good Practice**: Preview features are not supported in production code. Preview
    features are likely to have breaking changes before the final release. Enable
    preview features at your own risk. Switch to a GA-release future SDK like .NET
    11 to use new compiler features, while still targeting older but longer-supported
    versions of .NET like .NET 8 or 10.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：预览功能不支持在生产代码中使用。预览功能在最终发布前可能会出现破坏性更改。启用预览功能存在风险。切换到GA发布的未来SDK，如.NET
    11，以使用新的编译器功能，同时仍然针对旧版但长期支持的.NET版本，如.NET 8或10。'
- en: Requiring preview features
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要预览功能
- en: The `[RequiresPreviewFeatures]` attribute is used to indicate assemblies, types,
    or members that use, and, therefore, require warnings about, preview features.
    A code analyzer can scan for this attribute and then generate warnings if needed.
    If your code does not use any preview features, you will not see any warnings.
    If your code does use any preview features, then you will see warnings. Your code
    should also be decorated with this attribute to warn other developers that your
    code uses preview features.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`[RequiresPreviewFeatures]` 属性用于指示使用预览功能的程序集、类型或成员，因此需要关于预览功能的警告。代码分析器可以扫描此属性，并在需要时生成警告。如果你的代码没有使用任何预览功能，你将不会看到任何警告。如果你的代码使用了任何预览功能，那么你将看到警告。你的代码也应该带有此属性，以警告其他开发者你的代码使用了预览功能。'
- en: Enabling preview features
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用预览功能
- en: 'In the `Project` file, add an element to enable preview features and an element
    to enable preview language features, as shown highlighted in the following markup:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Project` 文件中，添加一个元素以启用预览功能，并添加一个元素以启用预览语言功能，如下所示，高亮显示的标记：
- en: '[PRE70]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Method interceptors
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法拦截器
- en: An interceptor is a method that substitutes a call to an interceptable method
    with a call to itself. This is an advanced feature most commonly used in source
    generators. If you are interested, then I might add a section about them to the
    ninth edition.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器是一种方法，它用一个对可拦截方法的调用替换成对自身的调用。这是一个在源生成器中最常用的高级功能。如果你感兴趣，我可能会在第9版中添加一个关于它们的章节。
- en: '**More Information**: You can learn more about interceptors at the following
    link: [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12#interceptors](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12#interceptors).'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于拦截器的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12#interceptors](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12#interceptors).'
- en: Practicing and exploring
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and researching the topics of this chapter further.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作练习以及进一步研究本章的主题，来测试你的知识和理解。
- en: Exercise 7.1 – Online material
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.1 – 在线材料
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在线材料可以是我为这本书编写的额外内容，也可以是引用 Microsoft 或第三方创建的内容。
- en: Experimental MSBuild editor
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验性 MSBuild 编辑器
- en: MSBuild is an essential component of the .NET development experience, yet it
    can be difficult for both new and experienced developers to navigate. To help
    developers better understand their project files and utilize advanced features
    that require direct project file editing, the Microsoft team is introducing an
    experimental MSBuild editor. This new editor offers a deeper understanding of
    MSBuild files beyond what the current XML schema provides.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: MSBuild 是 .NET 开发体验的一个基本组件，但对于新开发者和经验丰富的开发者来说，它可能很难导航。为了帮助开发者更好地理解他们的项目文件并利用需要直接编辑项目文件的先进功能，Microsoft
    团队推出了实验性的 MSBuild 编辑器。这个新编辑器提供了比当前 XML 架构提供的更深入的理解 MSBuild 文件。
- en: If you want to try out the extension, search for **MSBuild Editor** in the Visual
    Studio Extension Manager. Currently, the extension is only available for Visual
    Studio, but efforts are underway to port it to VS Code.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试这个扩展，请在 Visual Studio 扩展管理器中搜索**MSBuild 编辑器**。目前，该扩展仅适用于 Visual Studio，但正在进行将其移植到
    VS Code 的工作。
- en: 'You can learn more about the new MSBuild editor experience at the following
    link:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于新的 MSBuild 编辑器体验：
- en: '[https://devblogs.microsoft.com/visualstudio/experimental-msbuild-editor/](https://devblogs.microsoft.com/visualstudio/experimental-msbuild-editor/)'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/visualstudio/experimental-msbuild-editor/](https://devblogs.microsoft.com/visualstudio/experimental-msbuild-editor/)'
- en: Improving performance in .NET
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高 .NET 性能
- en: Microsoft has made significant improvements to .NET performance in the past
    few years. You should review the blog posts written by Stephen Toub to learn what
    the team changed and why. His posts are famously long, detailed, and brilliant!
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，Microsoft 对 .NET 性能进行了重大改进。你应该阅读 Stephen Toub 编写的博客文章，以了解团队做了哪些更改以及为什么。他的文章以其长篇、详细和精彩而闻名！
- en: 'You can find the posts about the improvements at the following links:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到关于改进的帖子：
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core/)
    - 25 pages'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core/)
    - 25 页'
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/)
    - 20 pages'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/)
    - 20 页'
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/)
    - 41 pages'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/)
    - 41 页'
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/)
    - 43 pages'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/)
    - 43 页'
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/)
    - 100 pages'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/)
    - 100 页'
- en: '[https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/](https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/)
    - 156 pages'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/](https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/)
    - 156 页'
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/)
    - 218 pages'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/)
    - 218 页'
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/)
    - 307 pages'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/)
    - 307 页'
- en: Decompiling .NET assemblies
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反编译 .NET 程序集
- en: 'To learn about decompiling .NET assemblies, you can read the following link:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何反编译 .NET 程序集，您可以阅读以下链接：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-decompiling.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-decompiling.md)'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-decompiling.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-decompiling.md)'
- en: Porting from .NET Framework to modern .NET
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 .NET Framework 迁移到现代 .NET
- en: 'If you are interested in porting legacy projects from .NET Framework to modern
    .NET, then I have written an online-only section at the following link:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对将遗留项目从 .NET Framework 迁移到现代 .NET 感兴趣，那么我在以下链接中编写了一个仅在线的部分：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-porting.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-porting.md)'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-porting.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-porting.md)'
- en: Exercise 7.2 – Practice exercises
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.2 – 练习题
- en: Practice exercises to dive deeper into the topics of this chapter.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题以深入了解本章主题。
- en: Creating source generators
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建源生成器
- en: 'If you are interested in creating source generators, then I have written an
    online-only section at the following link:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对创建源生成器感兴趣，那么我在以下链接中编写了一个仅在线的部分：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-source-generators.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-source-generators.md)'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch07-source-generators.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch07-source-generators.md)'
- en: 'You can find examples of source generators at the following link:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中找到源生成器的示例：
- en: '[https://github.com/amis92/csharp-source-generators](https://github.com/amis92/csharp-source-generators)'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/amis92/csharp-source-generators](https://github.com/amis92/csharp-source-generators)'
- en: Explore PowerShell
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索 PowerShell
- en: PowerShell is Microsoft’s scripting language for automating tasks on every OS.
    Microsoft recommends VS Code with the PowerShell extension to write PowerShell
    scripts.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是 Microsoft 用于在所有操作系统上自动化任务的脚本语言。Microsoft 推荐使用带有 PowerShell 扩展的
    VS Code 来编写 PowerShell 脚本。
- en: 'Since PowerShell is its own extensive language, there is not enough space in
    this book to cover it. You can learn about some key concepts from a Microsoft
    training module at the following link: [https://learn.microsoft.com/en-us/training/modules/introduction-to-powershell/](https://learn.microsoft.com/en-us/training/modules/introduction-to-powershell/).'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PowerShell 是一种广泛使用的语言，本书中没有足够的空间来涵盖它。您可以从以下链接中的 Microsoft 培训模块中了解一些关键概念：[https://learn.microsoft.com/en-us/training/modules/introduction-to-powershell/](https://learn.microsoft.com/en-us/training/modules/introduction-to-powershell/).
- en: 'You can read the official documentation at the following link: [https://learn.microsoft.com/en-us/powershell/](https://learn.microsoft.com/en-us/powershell/).'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中阅读官方文档：[https://learn.microsoft.com/en-us/powershell/](https://learn.microsoft.com/en-us/powershell/).
- en: Exercise 7.3 – Test your knowledge
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.3 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What is the difference between a namespace and an assembly?
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间和程序集之间的区别是什么？
- en: How do you reference another project in a `.csproj` file?
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 `.csproj` 文件中引用另一个项目？
- en: What is the benefit of a tool like ILSpy?
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似 ILSpy 这样的工具有什么好处？
- en: Which .NET type does the C# `float` alias represent?
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 中的 `float` 别名代表的是哪种 .NET 类型？
- en: What are the `<PropertyGroup>` and `<ItemGroup>` elements used for in a .NET
    project file?
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<PropertyGroup>` 和 `<ItemGroup>` 元素在 .NET 项目文件中用于什么？'
- en: What is the difference between framework-dependent and self-contained deployments
    of .NET applications?
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET 应用程序的框架依赖型部署和自包含部署之间的区别是什么？
- en: What is a RID?
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RID 是什么？
- en: What is the difference between the `dotnet pack` and `dotnet publish` commands?
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dotnet pack` 和 `dotnet publish` 命令之间的区别是什么？'
- en: How can you control the sources that a build process uses to download NuGet
    packages?
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何控制构建过程使用的源以下载 NuGet 包？
- en: What are some limitations of using AOT compilation?
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 AOT 编译有什么局限性？
- en: Exercise 7.4 – Explore topics
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.4 – 探索主题
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解本章涵盖主题的更多详细信息：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-7---packaging-and-distributing-net-types](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-7---packaging-and-distributing-net-types)'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-7---packaging-and-distributing-net-types](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-7---packaging-and-distributing-net-types)'
- en: Summary
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们：
- en: Reviewed the journey of .NET for BCL functionality.
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾了 .NET 为 BCL 功能所经历的旅程。
- en: Explored the relationship between assemblies and namespaces.
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索了程序集和命名空间之间的关系。
- en: Saw options to publish an app for distribution to multiple OSes.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到了发布适用于多个操作系统的应用程序的选项。
- en: Learned how to publish to native AOT for faster startup and a smaller memory
    footprint.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会了如何发布原生 AOT 以实现更快的启动和更小的内存占用。
- en: Packaged and distributed a class library.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包并分发了一个类库。
- en: Learned how to activate preview features.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会了如何激活预览功能。
- en: In the next chapter, you will learn about some common BCL types that are included
    with modern .NET.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解一些现代 .NET 中包含的常见 BCL 类型。
