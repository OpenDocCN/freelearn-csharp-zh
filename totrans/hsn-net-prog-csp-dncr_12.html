<html><head></head><body>
        

                            
                    <h1 class="header-title">HTTP in .NET</h1>
                
            
            
                
<p>In each of the previous chapters, we explored the fundamental building blocks with which network software is built. In this chapter, we'll use those building blocks to construct an application that leverages the most common network protocol, <strong>Hypertext Transfer Protocol</strong> (<strong>HTTP</strong>). We'll re-examine where in the <strong>Open Systems Interconnection</strong> (<strong>OSI</strong>) network stack HTTP falls, and why it is categorized as such. We'll more deeply consider the conventions around HTTP requests and responses, and spend some time exploring request, response, and content headers. We'll demonstrate how to use standard headers for specifying the content you want from an external HTTP resource, and how custom headers can be used to toggle specific features and functions of your application. Lastly, we'll explore how to serve content over the protocol to service HTTP requests made to your application.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The background for the HTTP protocol, and the strengths and limitations of its specification</li>
<li>The HTTP request methods, including how to generate, and respond to, those requests out of the box with C#</li>
<li>How to construct <kbd>HttpRequestMessage</kbd>, or use <kbd>HttpClient</kbd> to send requests, and the various classes available for responding to requests with a valid HTTP response</li>
<li>How HTTPS is implemented in C#</li>
<li>New features supported by HTTP/2 and how to leverage those features in .NET Core</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>In this chapter, we'll be using sample applications available in the GitHub repository for the book here: <a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%209">https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter 9</a>.<a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%209"/></p>
<p>We'll also be using each of the tools we leveraged in <a href="a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml">Chapter 8</a>, <em>Sockets and Ports</em>. So, if you didn't take the time to install and start working with them before, I suggest you do so now. Specifically, I recommend installing Postman from here: <a href="https://www.getpostman.com/apps">https://www.getpostman.com/apps</a>.</p>
<p style="line-height: 24.0pt">Alternatively, you can use the Insomnia REST client, which can be found here: <a href="https://insomnia.rest/">https://insomnia.rest/</a><a href="https://insomnia.rest/">.</a></p>
<p>And, while it's not going to be featured heavily in this chapter, since deployment options will fall outside the scope of this chapter, I would encourage you to use this opportunity to begin working with Docker. I'll point out opportunities to modify and extend your Dockerfile and deploy your changes locally.</p>
<p>Check out the following video to see the code in action: <a href="http://bit.ly/2HY5WaA">http://bit.ly/2HY5WaA</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cracking open HTTP</h1>
                
            
            
                
<p>In <a href="84e54d31-1726-477b-b753-4408a3ee6286.xhtml">Chapter 3</a>, <em>Communication Protocols</em>, we had a section, <em>The application layer</em>, where we looked at why certain protocols fell at that layer. With a little bit more exposure to the nitty-gritty details of network transactions under our belt, I'm hoping it will be easier to distinguish between the transport layer and the application layer. With HTTP, we have the best opportunity to explore that distinction. As a protocol, it has by far the broadest, and most robust, support from out-of-the-box C# libraries. That depth of in-language resources will give us a sharp lens through which to view the distinction between the application layer and its underlying transport layer. So, before we learn how to use HTTP, let's learn just exactly what it is.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The nature of HTTP</h1>
                
            
            
                
<p>When we worked with low-level streams in <a href="a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml">Chapter 8</a>, <em>Ports and Sockets</em>, we saw the responsibility that falls on a developer when you have to work directly with byte streams, serializing and deserializing data, and manually parsing your input headers. There's a mountain of boilerplate code just to get a simple string from one machine to another. Obviously, writing the same boilerplate code every time you need to make an external resource request is tedious and error-prone. This is where protocols come in.</p>
<p>We discussed the topic briefly in <a href="84e54d31-1726-477b-b753-4408a3ee6286.xhtml">Chapter 3</a>, <em>Communication Protocols</em>, where we looked at the protocols defined for each layer in the network stack. However, in the intervening chapters, we've established a better understanding of how different protocols are separated across the OSI stack. So, hopefully, some of the distinctions that may have been hazy back in <a href="84e54d31-1726-477b-b753-4408a3ee6286.xhtml">Chapter 3</a>, <em>Communication Protocols,</em> will be a bit more clear now.</p>
<p>When writing networked software in .NET, there are two primary tiers in the OSI stack on which we'll be working. The first, and most obvious, is the application layer. That's where HTTP lives, where FTP and SMTP live, and where any web application software that you likely have interacted with in the past would have lived. The other layer that's commonly written for in .NET, though, is the transport layer. Handling TCP and UDP calls directly within a listening server is easily done (and we'll see how in later chapters) using some of the versatile and easy-to-use utility classes you've likely come to expect from .NET Core. But what's the difference between those two layers, from the perspective of the programmer? When we're writing HTTP software, we're still very much concerned with the format and structure of our serialized data. So, why is that concern different when writing HTTP than when handling streams directly with a TCP client?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The application layer and the transport layer</h1>
                
            
            
                
<p>The most important thing to internalize when you're trying to understand this distinction is the smallest piece of data with which each layer is concerned. The application layer is predominantly concerned with application objects<em>.</em> So, as long as the language you're working with provides a fully-realized abstraction of the rest of the network stack (as is the case with C#), you can write code that communicates with external resources exclusively through business and application models. You'll never have to worry about composing those models from their serialized datagrams, or wondering about the character encoding, or the endianness of integers. </p>
<p>Instead, you'll be speaking and thinking in terms of the end result of the network transaction—for example, "<em>I'm requesting a database record,"</em> instead of "<em>I'm requesting a series of bytes for the database record."</em> If you find yourself falling into the anti-pattern of making your application layer software over-generalized and abstract, you'll quickly find that it doesn't provide any meaningful value. Application layer software should describe and rely on at least some concrete business models; otherwise, it's just an unnecessary additional layer in between the transport layer and the segment of your code that does use those business models.</p>
<p>Meanwhile, on the other side of this conceptual coin, we have the transport layer. And as you've likely figured out, software written at this level needs no business context to be implemented properly and provide its expected value. In fact, any representation of non-primitive <kbd>Object</kbd>s beyond simple generics, such as <kbd>Serialize&lt;T&gt;()</kbd>, would render your transport layer software pretty much useless outside the context of a specific business application. Any architecture for transport-layered software built around concrete business objects would be like a house made out of toothpicks and held together with bubblegum: unstable and short-lived.</p>
<p>I highlight the distinction between application- and transport-layer software now to make the content of the rest of this chapter more intuitive. Going forward, some of the classes we'll be working with and thinking about in .NET, and some of the advice I'll be giving you around this, will rely on your understanding of this distinction. Moreover, though, it's good to understand how HTTP came to be, and how it transformed into what it is today.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The history of HTTP</h1>
                
            
            
                
<p>As I mentioned in <a href="84e54d31-1726-477b-b753-4408a3ee6286.xhtml"/><a href="84e54d31-1726-477b-b753-4408a3ee6286.xhtml">Chapter 3</a>, <em>Communication Protocols</em>, while, today, HTTP is the de-facto protocol of web-based software, its original design and intent is actually much simpler and more limited. Even its namesake, <strong>hypertext</strong>, has grown well beyond its original conception.</p>
<p>First described in 1965, hypertext was defined as a specification for rendering text on a computer, or other electronic device, with references to other hypertext documents, which could be immediately accessed through a system of references, known as <strong>hyperlinks</strong>. At its most basic, this describes little more than a primitive web page. In fact, you've undoubtedly already realized the link between <em>hypertext</em> as a concept and the hypertext markup language, or HTML, file format, which is used to render web pages. These basic specifications served as the precursor to the modern internet.</p>
<p>Like much of our modern world, the origins for hypertext, HTML, and HTTP can be traced back to an influential work of science fiction! A 1941 short story titled <em>The Garden of Forking Paths</em>, by Jorge Luis Borges, is often credited with being the inspiration for the first definition of hypertext.</p>
<p>Decades later, in 1989, researchers at the <strong>European Organization for Nuclear Research</strong> (<strong>CERN</strong>) began to formalize their efforts to define the standards for a global computer network, now known as the <strong>World Wide Web</strong> (<strong>WWW</strong>). This work included defining a standard for document representation, as well as a protocol for transmitting those documents between machines. In 1991, the first ever formal definition for HTTP was drafted, and dubbed <strong>v0.9</strong>.</p>
<p>This original definition was extremely limited in its scope, intended only to define the process of requesting hypertext pages from a given server; the specification defined a single method, which is <kbd>GET</kbd>. As the early internet began to reach consumers, however, the needs of the wider audience forced the evolution of the standards for the network. By the time HTTP v1.0 was formalized and broadly recognized in 1996, the standard grew to include message headers, security, and a wider array of operations.</p>
<p>Still, though, it was almost exclusively used to transmit web pages from servers to clients. Each request had to negotiate its own connection with the server, and once that request was serviced, the connection was closed. This kind of behavior makes sense if you're only requesting a static web page, but what if you wanted to incorporate user interaction? That connection negotiation comes at a cost.</p>
<p>The engineers at CERN recognized this, and in only one year, in 1997, they released an updated HTTP v1.1 (often written as HTTP/1.1) specification that provided an even richer feature set. This included headers to specify response-caching behavior, persistent connections, authentication and authorization, message syntax, and routing or redirection behavior. In fact, HTTP/1.1 remains largely unchanged and widely used today. However, while the protocol has remained largely unchanged until the recent advent of HTTP/2, introduced in 2015, the ways in which engineers <em>use</em> the protocol have grown exponentially.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Web services and HTTP</h1>
                
            
            
                
<p class="mce-root">As the internet began to grow from a niche utility for business and engineering professionals to share resources and information in the early-to-mid 1990s to the wide-spread platform it is today, the software written for the internet had to grow along with it. The simplicity and extensibility of HTTP provided such a reliable, broadly understood, and broadly supported protocol that it rapidly outgrew its original stated intent. Engineers began to leverage it for almost every instance of networked services and resource access. Now HTTP is the protocol of choice for almost any open API available on the internet.</p>
<p>Early on, Microsoft recognized this, and when it released the first version of the .NET framework back in 2001, it did so with full support for HTTP as the de-facto application layer protocol for general-purpose network-resource access. Later, with the advent of the <strong>Windows Communication Foundation</strong> (<strong>WCF</strong>), along with the <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>), Microsoft continued to lean heavily on HTTP for application-layer network services.</p>
<p>For those who may not know, WCF was Microsoft's suite of libraries and frameworks for network-specific, service-oriented application development. Meanwhile, WPF was Microsoft's framework for asynchronous user-interface code paradigms. It sought to provide the same rich set of features and controls for any desktop or web applications with a UI, with a consistent look and feel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The advent of SOAP</h1>
                
            
            
                
<p>Much of WCF was tailored specifically to the implementation of <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>) services. At first glance, SOAP seems to be an application-layer protocol in itself. However, in practice, it's actually a protocol that exists one layer above the actual OSI network stack. So, while an application that implements the SOAP protocol ensures reliable behavior for any consumers, it doesn't do so in any way that is necessary for interaction between network-available resources, as we discussed in <a href="84e54d31-1726-477b-b753-4408a3ee6286.xhtml">Chapter 3</a>, <em>Communication Protocols</em>. Instead, it sits comfortably on top of the OSI stack, interacting directly with application-layer protocols to service the actual network interactions required by SOAP applications and their consumers. So, while SOAP-based applications rigidly defined their interactions through a protocol, those interactions were still most often initiated over an HTTP network transaction.</p>
<p>This had an interesting side effect, however. While SOAP services were leaning heavily on HTTP as their transport protocol of choice, it carried with it several drawbacks for the emerging web ecosystem of consumer-facing applications and services. SOAP was notoriously verbose in both its request and response message structure. It had slow transfer and message-parsing performance due to its heavy reliance on XML for serialization. Lastly, as a protocol, its implementations were heavily fragmented, leading to no reliable SOAP request pattern for use across the vast array of services that were, ostensibly, SOAP-based.</p>
<p>Beginning in the year 2007, with the release of the first iPhone, and continuing into the next decade, smartphones rapidly became a viable platform for dedicated, consumer-facing applications. While access to broadband internet connections was exploding across the globe, cellular networks, which served most of the internet-connected devices entering the market, were still several years behind in terms of performance and reliability. Meanwhile, all of the disadvantages of SOAP led to poor performance and longer development cycles for engineers writing applications to consume one or more SOAP-based web services. Across the industry, engineers were realizing that they needed an alternative. Millions of dollars were there to be made, but with the change needing to be made seemingly overnight for the mobile app market, there was almost no time for SOAP to adapt, or even for an alternative version to materialize.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The rise of REST</h1>
                
            
            
                
<p>So, how did engineers and leaders in the market space adapt? They went back to the basics and looked to leverage the underlying protocol more robustly—less bloat, fewer intermediary interactions, and less serializing and parsing and negotiating connections. Instead, they would use HTTP as the interaction protocol and leverage its features to allow for more dynamic and robust interaction while minimizing time spent writing custom, service-specific access protocols. To satisfy these goals, engineers across the world would leverage REST.</p>
<p>Short for <strong>Representational State Transfer</strong>, REST was designed as an architectural pattern, as opposed to an access protocol. It is convention-based, instead of contract-based. This means that anyone familiar with the conventions can use any RESTful web service simply by following those conventions. This reduces development time for engineers, because it means they can learn the architectural patterns once, and then use them everywhere that REST is used. This is obviously much more preferable than having to consume and develop for a given contract for a single SOAP service, and then having to do the same for each new contract for each new service they might have to consume.</p>
<p>By refusing to implement a custom protocol on top of the application layer of the OSI stack, REST reduces overhead in terms of message negotiation and parsing. And since HTTP is, far and away, the most common application-layer protocol used for REST services, those services are free to serve up their responses in whatever format HTTP can deliver. This means no more strict reliance on XML as your serialization language of choice. Instead, JSON has risen as the quick-to-serialize and quick-to-parse format of choice for RESTful web services.</p>
<p>The improved performance and increased flexibility of pure HTTP meant that any APIs or services that were intended for consumption by mobile applications were, almost universally, REST services. So, in effect, REST rose to replace SOAP as the web service paradigm of choice for modern network interactions, and it did so on the back of HTTP.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP web services in .NET core</h1>
                
            
            
                
<p>With the broad applicability of the convention-based REST paradigm, Microsoft's WCF has fallen, somewhat quickly, by the wayside. In its place has risen the web API template from ASP.NET, and now ASP.NET Core. Leveraging the patterns first formally described in the book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, by<em> </em>Gang of Four,<em> </em>ASP.NET released the <strong>Model-View-Controller</strong> (<strong>MVC</strong>) application template and libraries to enable the use of clean, convention-based software patterns right out of the box.</p>
<p>For those not familiar with it, the MVC design pattern describes a strategy for isolating the logical responsibilities of complex, user-interactive software into logical groupings and organizational structures. The view tier was exactly what it sounds like: any UI code or markup that would be sent to the client (typically, a user's web browser of choice). The model tier described your data models, and how you access them from whatever persistence mechanism the application is using. It typically includes your data-access code as well as any data models that are sent to or from your application. Finally, the controller tier describes the business application logic that ties your models into a useful context for your users, and ultimately returns that context to your user as a view. It serves as an intermediary between the other two tiers. </p>
<p>When the ASP.NET team wanted to define a newer, REST-based pattern for full-featured web applications that would leave the bloat of SOAP behind, its members looked to MVC. The MVC project template associates every available public resource (in the case of early MVC, this was almost always a web page, or a fragment of a web page) with a specific HTTP verb at a specific URI. This simplified access to resources, as developers only ever needed to know what the target address was and how to make a generic HTTP request against that address. It also communicated a lot about the nature of the resource based on the HTTP verb required to access it. We'll see more of this later in the chapter, but that correlation of semantic structure to operational use is a massive shortcut when working with new web services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">From MVC to web API</h1>
                
            
            
                
<p>Originally, MVC was designed for full-featured web applications serving a UI with which users could interact with their backend services. However, the extent to which the project template so closely matched the REST paradigm made it a popular choice for backend web services that provided no UI whatsoever. In the early 2010s, it was common for .NET developers to start from an MVC template, only to scrap any semblance of frontend UI code, instead allowing their controller components to return raw JSON responses. Needless to say, it didn't take very long for Microsoft to recognize the trend and release the Web API project template with an update to Visual Studio's project template library.</p>
<p>With the Web API template, developers can have a basic, RESTful web service up and running with only two simple commands in the .NET Core CLI. Controller endpoints listen for designated HTTP request methods and return arbitrary responses, with no assumptions made about any corresponding UI components. Almost every modern REST API implemented in .NET will have been created with this project template as its starting point. To that end, we'll spend the rest of this chapter exploring HTTP from the context of a Web API project, which will both listen for, and respond to, incoming HTTP requests, as well as sending outgoing requests to external APIs. This pattern of writing an intermediary aggregator API is extremely common in modern enterprise web development, especially in the growing trend of microservices and cloud-hosted applications. With that in mind, let's stand up our application and start exploring how .NET makes HTTP programming enjoyable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The many methods of HTTP</h1>
                
            
            
                
<p>While we took some time to explore the concept all the way back in <a href="84e54d31-1726-477b-b753-4408a3ee6286.xhtml">Chapter 3</a>, <em>Communication Protocols</em>, in this section, we'll take a much closer look at the modus operandi of HTTP: the methods. We'll look at each one in the context of our Web API app, and discuss their intended use case, limitations, and the conventions of those methods that you would do well to follow. To do that, though, we'll need our app up and running. So, let's first take a look at how that happens with the Web API project created by the .NET CLI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a web API project</h1>
                
            
            
                
<p>Just as we did for our sample application in <a href="a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml">Chapter 8</a>, <em>Sockets and Ports</em>, we'll be creating an instance of a Web API project with the following command:</p>
<pre><strong>dotnet new webapi -n FitnessApp</strong></pre>
<p>That name might seem odd, so let's describe our application's basic expected functionality, and then hopefully it will make more sense. We'll be writing an API that will allow users to track fitness activity over time, along with an almost identical API that will serve as our data source. This will give us an opportunity to see how to listen for different HTTP requests made of our own app, while also giving us just enough context to work with generating HTTP requests to an outbound service. The actual shape and functionality of our data store app will be almost identical to the user-facing API. The only difference is that when our <kbd>FitnessApp</kbd> needs to persist data, it will do so by making HTTP calls to our <kbd>FitnessDataStore</kbd> app. Meanwhile, when our <kbd>FitnessDataStore</kbd> app needs to store data, it will do so by writing to a file on disk.</p>
<p>The only code we'll be working with in this chapter will be the <kbd>FitnessApp</kbd> code, since that will encapsulate all of the interactions we'll want to learn about. The backend data service is available in the sample code for this chapter, though, so feel free to browse it, extend it, and modify it if you're curious. Also, since our focus will be on the HTTP interactions of this application, and it's for demonstration purposes only, we'll be making a lot of naive assumptions about data modeling, persistence, and error handling. Instead, I'll leave those considerations as an exercise for you to consider and re-evaluate in your own time.</p>
<p>Our application will allow consumers to create new workouts with titles; workout types and comments; look up previous workouts by their title, workout type, or the contents of their comments; retrieve a list of all previous workouts; edit an existing workout's comments; and, finally, it will allow users to delete previous workouts from their history. As I said before, each of these operations is specifically designed to highlight some aspect of HTTP, as implemented by a .NET Core Web API, so the implementation details of these operations will be somewhat simplistic and naive, or even overlooked entirely. What's important here is to understand the expected I/O and how to model these operations to their appropriate HTTP methods. With that in mind, let's look at the project we've just created for ourselves.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The web server</h1>
                
            
            
                
<p>Looking at our Solution Explorer, you'll notice that there's not a whole lot to this project template:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-917 image-border" src="img/89a7ad74-8f22-4e56-bf55-cef7100cbe7b.png" style="width:26.25em;height:20.75em;"/></p>
<p class="mce-root">There's just two configuration <kbd>.json</kbd> files, a single controller class, and then the initialization and program files. At this point, those new to web development in .NET Core might be wondering why we have both a <kbd>Program.cs</kbd> file and a <kbd>Startup.cs</kbd> file. This is because, like all .NET Core applications, our Web API project is actually a console application executed in the context of the <kbd>dotnet</kbd> host application running on the target machine. So, our <kbd>Program.cs</kbd> provides the conventional <kbd>Main()</kbd> method as the entry point for our <kbd>dotnet</kbd> execution context to start our application.</p>
<p class="mce-root">However, since we're running an active web application, we'll want to stand up a listening web server and provide it the context of our application so that it responds to requests appropriately. That's where the <kbd>Startup.cs</kbd> file comes in. This provides all of the configuration, including registering our concrete types for dependency injection, and defining the active features and services we intend to leverage. Once we've defined all of that, the <kbd>Startup</kbd> class is provided to our web server instance and used to configure the server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">IWebHostBuilder</h1>
                
            
            
                
<p>Looking at our <kbd>Program.cs</kbd> file, you can see that's exactly what happens: the <kbd>Main()</kbd> method only builds our web host, and starts it running with no terminating condition:</p>
<pre>public class Program<br/>{<br/>    public static void Main(string[] args)<br/>    {<br/>        CreateWebHostBuilder(args).Build().Run();<br/>    }<br/><br/>    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;<br/>        WebHost.CreateDefaultBuilder(args)<br/>            .UseStartup&lt;Startup&gt;();<br/>}</pre>
<p>The <kbd>WebHost</kbd> class is part of the <kbd>Microsoft.AspNetCore</kbd> namespace, and its default implementation provides a running Kestrel web server that interacts with your application code using the <kbd>Startup.cs</kbd> file provided to the <kbd>UseStartup&lt;T&gt;()</kbd> method on the <kbd>IWebHostBuilder</kbd> instance you return to your <kbd>Main()</kbd> method to be run by your program.</p>
<p>By default, the web server created by the call to <kbd>CreateDefaultBuilder()</kbd> is going to be an instance of a <strong>Kestrel</strong> web server. Kestrel is a cross-platform server that will acquire a designated port so it can listen for inbound requests against that port, passing all received requests through to your application code. It supports HTTP/HTTPS, WebSockets, Unix sockets, and HTTP/2, all out of the box. In modern .NET Core apps, there's rarely an occasion to use anything other than the default Kestrel server anymore. It can run as an edge server, which means it is the first point of contact for any incoming requests made of your application (listening at the edge or boundary of your host machine). Likewise, it can be run behind a reverse proxy, such as <strong>Internet Information Services</strong> (<strong>IIS</strong>) or Nginx, as discussed in <a href="a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml">Chapter 8</a>, <em>Sockets and Ports</em>.</p>
<p>There are a number of advantages to running Kestrel behind a reverse proxy. For example, a reverse proxy allows your Kestrel instance to listen for requests targeting the same port registered for other listening applications, while running it as an edge server blocks the port it is registered to from being used by other applications. This leaves your Kestrel instance to handle every inbound request made to its registered port, regardless of the targeted URI path or host name specified in the requests headers. If the IP is resolved to your application's host machine, and the port is the one Kestrel is registered on, Kestrel will service it.</p>
<p>This port-blocking behavior might make perfect sense if your application is the only software deployed and running inside a Docker container published to a cloud-hosting platform. However, if it's deployed to an on-premises server hosting dozens or even hundreds of other web services, then managing the port registration, traffic load, and other resourcing or configuration would likely be unwise, or at the very least unpleasant. In that case, a reverse proxy would be the most reliable deployment solution. It's up to you to determine the pros and cons of using a reverse proxy or running Kestrel as an edge server, but whatever you choose, you'll have the tools you need to enable your decision.</p>
<p>So, when you want to define the behavior of your application code, you do so in the <kbd>Startup.cs</kbd> file, whereas when you want to define the behavior of the Kestrel web server that exposes your application code, you do so with your <kbd>IWebHostBuilder</kbd>. Let's look at how to configure our server for now, and then dive into our application code's configuration.</p>
<p>First, let's set the URLs we want our application to listen on. For our purposes, we'll have direct control over the entire hosting context of any software on our machine, so we'll be running Kestrel as an edge server for simplicity's sake. Now, to register our server to listen at a specific port, we'll be using the extension methods made available on our <kbd>IWebHostBuilder</kbd> instance that are returned when we call <kbd>WebHost.CreateDefaultBuilder(args)</kbd>.</p>
<p>It might not be obvious when you look at it, but the <kbd>UseStartup&lt;T&gt;()</kbd> method is actually one of those extension methods. It just happens to be so common that the Web API project template pre-configures that for you whenever you create a new project. And this is a good thing. The methods in <kbd>Startup.cs</kbd> provide users with the opportunity to centralize a lot of boilerplate code and dynamically register their concrete classes for dependency injection at runtime. If you haven't used dependency injection before, you'll quickly see why this is a huge quality of life improvement, and why this little snippet of code is included by the default template.</p>
<p>The first extension method we'll use is the <kbd>UseUrls(string[])</kbd> method to register the IP addresses and ports on which our Kestrel instance will be actively listening for incoming requests. To do so, change the <kbd>CreateWebHostBuilder(string[] args)</kbd> method to the following:</p>
<pre>public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;<br/>    WebHost.CreateDefaultBuilder(args)<br/>        .UseUrls(new string[] { "http://[::]:80", "https://[::]:443", "http://[::]:65432", "https://[::]:65431" })<br/>        .UseStartup&lt;Startup&gt;();</pre>
<p>You'll note that I've registered our server to listen on multiple ports for both HTTP and HTTPS requests. I mostly did this for demonstration purposes. It's rare that you'll want to actively listen on multiple ports with a single application, but this highlights that the <kbd>UseUrls()</kbd> method will allow you to register and listen on an arbitrary number of available ports.</p>
<p>This code won't work if you plan to ping your API using a mock host name by adding entries into your <kbd>hosts</kbd> file, as we did in <a href="ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml">Chapter 2</a>, <em>DNS and Resource Location. </em>Because any host entries you create will be explicitly mapped to the IP address <kbd>127.0.0.1</kbd>, you'll have to explicitly configure Kestrel to listen for that exact IP address. You can look at the <kbd>FitnessDataStore</kbd> sample code for an example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using launchSettings.json</h1>
                
            
            
                
<p>Alternately, you can define your application's listening URLs using the <kbd>launchSettings.json</kbd> file. This file allows you to specify behavior based on the specific environment your application is deployed under. Launch profiles can be customized based on the web server hosting your application (IIS Express, or Kestrel, which is defined as a profile under your project's name when you first create a project using the CLI).</p>
<p>When you launch your application with the <kbd>dotnet run</kbd> command, .NET will look for a <kbd>launchSettings.json</kbd> file, then search for the first profile whose <kbd>commandName</kbd> parameter has a value of <kbd>"Project"</kbd>, which will use the Kestrel web server. From within this profile, you can set environment variables that you intend to be leveraged by your application. Any environment variables you define in your launch profile will override the values of environment variables that exist on your host system. This allows you to define different values for environment variables for different circumstances, simply by setting them in their corresponding launch profile.</p>
<p>You can also set various configurations for your web server inside your launch profile. If you look in the <kbd>launchSettings.json</kbd> file that was created when we stood up our <kbd>FitnessApp</kbd>, you'll see that it has a profile named <kbd>FitnessApp</kbd>, with a <kbd>commandName</kbd> value of <kbd>Property</kbd> as seen here:</p>
<pre>"FitnessApp": {<br/>    "commandName": "Project",<br/>    "launchBrowser": true,<br/>    "launchUrl": "api/values",<br/>    "applicationUrl": "https://localhost:5001;http://localhost:5000",<br/>    "environmentVariables": {<br/>        "ASPNETCORE_ENVIRONMENT": "Development"<br/>    }<br/>}</pre>
<p>Pay special attention to the <kbd>applicationUrl</kbd> property there, as it will come up in just a moment, as we're running our app for the first time.</p>
<p>Now, for the sake of simplicity when using Postman, we'll change our server settings to not use HTTPS redirection for inbound requests to <kbd>http://</kbd> URLs. This just prevents us from having to configure Postman to follow re-directs, and gives us a more direct correlation between the code we're writing and the behavior we observe when we test it. To disable the behavior, simply navigate to your <kbd>Startup.cs</kbd> file and, near the bottom of the file, find and remove the line that reads as follows:</p>
<pre>app.UseHttpsRedirection();</pre>
<p>Once that's done, it's time to run our application. Simply navigate to the folder you created the project in with your command prompt and then execute <kbd>dotnet run</kbd>. Once you have, you should see the following in your terminal:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-918 image-border" src="img/b887810c-c368-451f-8bdb-7ecc1cd2b084.png" style="width:81.67em;height:20.33em;"/></p>
<p>You probably noticed that the application is currently listening on each of the ports we specified in the array we passed to the <kbd>UseUrls()</kbd> method, but on none of the ports that were specified by the <kbd>launchSettings.json</kbd> profile.</p>
<p>In order to test this code, you'll first need to prevent Postman from checking for the SSL certificates it's expecting whenever you navigate to an <kbd>https:// url</kbd>. To do so, simply open your SETTINGS and disable SSL certificate verification, as seen here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/317f93f6-9df1-4863-a4a4-51ffd2624251.png"/></p>
<p>We'll look closer at SSL certificates and what this particular Postman setting means in <a href="2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml"/><a href="2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml">Chapter 13</a>, <em>Transport Layer Security</em>. For now, though, it's sufficient to simply disable that setting and proceed accordingly. Once that's done, open Postman and send <kbd>GET</kbd> requests to each of the following URLs:</p>
<pre>http://localhost/api/values <br/>https://localhost/api/values<br/>http://localhost:65432/api/values<br/>https://localhost:65431/api/values</pre>
<p>You should see the following JSON get returned by all four:</p>
<pre>[<br/>    "value1",<br/>    "value2"<br/>]</pre>
<p>You might have noticed we didn't have to specify ports 80 or 443 in that list. This is because, as discussed in <a href="a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml">Chapter 8</a>, <em>Sockets and Ports</em>, each of those ports is reserved for HTTP and HTTPS, respectively. So, no port specification on an <kbd>http://</kbd> or <kbd>https://</kbd> request is the same as specifying 80 or 443.</p>
<p>Meanwhile, if you try to navigate to either of the URLs configured in the <kbd>launchSettings.json</kbd> file, you'll get no response at all. This is because, while settings configured in a launch profile in your <kbd>launchSettings.json</kbd> file will always override any system settings that have already been defined, settings configured inside your application code when you launch and run your Kestrel server will always override any launch profiles. Settings lower down in your scope will always override settings configured higher up in your scope.</p>
<p>Since configuring your web server in your application's code will always override any other configuration values, you should only use that for the most important settings that you always want to behave in a single, specific way. Otherwise, the <kbd>ASPNETCORE_*</kbd> environment variables and launch profiles should be used. They provide a high degree of flexibility with a low maintenance cost.</p>
<p>Now that our web server is configured to listen for requests to our designated ports, let's use our <kbd>Startup.cs</kbd> file to set up our application to make HTTP requests of its own.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Registering dependencies in startup.cs</h1>
                
            
            
                
<p>We'll be using the <kbd>ConfigureServices(IServiceCollection services)</kbd> method in our <kbd>Startup.cs</kbd> class to register our specific classes for dependency injection, starting with our <kbd>IHttpClientFactory</kbd> class instances. If you've never used it before, dependency injection is a great tool for creating loose coupling between different aspects of your software that are likely to change over time. Essentially, whenever one class (<kbd>ClassA</kbd>) leverages the properties or methods of another (<kbd>ClassB</kbd>) in order to perform its own functions, a dependency is created. We can say that <kbd>ClassA</kbd> depends on <kbd>ClassB</kbd>. There are a number of ways to resolve that dependency. The naive approach would have us creating instances of <kbd>ClassB</kbd> directly inside of <kbd>ClassA</kbd> wherever its methods are used, as seen here:</p>
<pre>public class ClassA {<br/>    public string CreateStringWithoutClassB() { ... }<br/>    public string CreateStringWithClassB() {<br/>        var bInstance = new ClassB();<br/>        var builder = new StringBuilder();<br/>        builder.Append(CreateStringWithoutClassB());<br/>        builder.Append(bInstance.GetSpecialString());<br/>        return builder.ToString();<br/>    }<br/>}</pre>
<p>But this brings with it a whole host of problems over the course of development. If <kbd>ClassB</kbd> ever needs to be changed, then we'll have to change it everywhere it's referenced. The more explicit dependencies we have, the more places we have to change it.</p>
<p>Instead, we can inject<em> </em>the dependency. To do so, we define an interface for the useful functionality that <kbd>ClassB</kbd> provides for <kbd>ClassA</kbd> and then define <kbd>ClassB</kbd> as an implementer of that interface. In our example, this <kbd>IClassB</kbd> interface would need to define a method with the signature <kbd>string GetSpecialString();</kbd> and that's it. Next, we can simply say that <kbd>ClassA</kbd> needs something that implements the <kbd>IClassB</kbd> interface. To make this dependency clear, without demanding an instance of the concrete <kbd>ClassB</kbd>, we define a constructor that accepts any implementer of <kbd>IClassB</kbd>. This changes our naive approach into the following definition for <kbd>ClassA</kbd>:</p>
<pre>public class ClassA {<br/>    private IClassB _classB;<br/>    public ClassA(IClassB classBInstance) {<br/>        _classB = classBInstance;<br/>    }<br/>    public string CreateStringWithoutClassB() { ... }<br/>    public string CreateStringWithClassB() {<br/>        var builder = new StringBuilder();<br/>        builder.Append(CreateStringWithoutClassB());<br/>        builder.Append(_classB.GetSpecialString());<br/>        return builder.ToString();<br/>    }<br/>}</pre>
<p>So, now,  the <kbd>ClassA</kbd> class doesn't depend on the <kbd>ClassB</kbd> class; instead, we can say it depends on some functionality that the <kbd>ClassB</kbd> class happens to provide. But it doesn't concern itself with how it gets that functionality. Instead, determining what the best concrete class to use is falls on the calling code that instantiates <kbd>ClassA</kbd>. Whatever uses <kbd>ClassA</kbd> has to determine the best concrete instance of <kbd>IClassB</kbd>, create an instance of it, and then inject it into the newly created instance of <kbd>ClassA</kbd>. If the <kbd>IClassB</kbd> implementer will ever change based on context, or new project requirements, we can make those functional changes without having to modify <kbd>ClassA</kbd> at all. And that is dependency injection in a nutshell!</p>
<p>There's actually a whole lot more to dependency injection when you find yourself using it in a professional context. Entire books have been written about the subject. And, as with any design pattern, you'll find as many opinions about it as engineers you ask for those opinions, and it can be a subject of heated debate in some circles. It is way beyond the scope of this chapter (and even this book) to go into detail about the many nuances of dependency injection. However, my hope is that this explanation will serve as enough of a primer for any readers who have never used it before to understand the concept enough to understand how to register dependencies in our <kbd>Startup.cs</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The IHttpClientFactory class</h1>
                
            
            
                
<p>The first service we'll want to register will be our <kbd>HttpClientFactory</kbd>. This class is an incredibly useful factory class that will provide managed instances of the <kbd>HttpClient</kbd> class. Prior to this wrapper class managing instances of <kbd>HttpClient</kbd> for us, there was actually a very painful and difficult-to-track-down bug that would arise when using common patterns for creating and disposing of instances of <kbd>HttpClient</kbd> by hand. Since the <kbd>HttpClient</kbd> class implements the <kbd>IDisposable</kbd> interface, many developers would instantiate it within the context of a <kbd>using(var client = new HttpClient())</kbd> statement. While this is the recommended pattern for almost every other class that implements <kbd>IDisposable</kbd>, in the specific case of <kbd>HttpClient</kbd>, there was an issue with instances of the client failing to release their listening threads. This bug lead to infrequent and inconsistent thread starvation in applications with high volumes of outbound HTTP requests. It was a painful problem, and the solution we have for it is the <kbd>HttpClientFactory</kbd> class.</p>
<p>With this class, we can request instances of <kbd>HttpClient</kbd> and trust that they will be allocated resources on the thread pool properly, and reused wherever possible to reduce memory overhead and performance concerns. Given that, it only seems appropriate that this is where we take our first steps with registering our dependencies in the <kbd>Startup.cs</kbd> folder.</p>
<p>First, though, we'll need to create a class that<em> </em>has<em> </em>a dependency on the <kbd>HttpClientFactory</kbd> class. In the root of your project folder, create a new folder named <kbd>Services</kbd>, and inside that folder, create a new class file named <kbd>FitnessDataStoreClient.cs</kbd>. This is the class we'll eventually use to write our data back to our <kbd>FitnessDataStore</kbd> API, which means this is the class that will need an <kbd>HttpClient</kbd> class to send those requests.</p>
<p>Once you have the file created, add a <kbd>private readonly</kbd> instance of the <kbd>IHttpClientFactory</kbd> interface. Then create a single constructor for your new class that accepts an instance of <kbd>IHttpClientFactory</kbd> as its only argument. Finally, assign the argument instance to your private member variable. After doing so, your file should look like this:</p>
<pre>namespace FitnessApp {<br/>  public class FitnessDataStoreClient {<br/>    private readonly IHttpClientFactory _httpFactory;<br/><br/>    public FitnessDataStoreClient(IHttpClientFactory factoryInstance) {<br/>      _httpFactory = factoryInstance;<br/>    }<br/>  }<br/>}</pre>
<p>You might be wondering why you can assign to a variable that's marked as <kbd>readonly</kbd>. Any class property or member variable that is marked as <kbd>readonly</kbd> can be written to only in the constructors for the class, or when they are explicitly declared. This little feature of the language is especially nice in the case of dependency injection, as it gives developers the opportunity to inject dependencies that might otherwise need to remain immutable.</p>
<p>And now that we've established our dependency, we'll need to register a concrete instance of it for use in our <kbd>Startup.cs</kbd> file. With this particular class, since the need for an <kbd>HttpClient</kbd> class is so common in so many web applications, there's actually an extension method on the <kbd>IServiceCollection</kbd> to register an <kbd>IHttpClientFactory</kbd> instance for injection. To use it in its most basic form, we'll only need to add a single line to our file. In the <kbd>ConfigureServices(IServiceCollection services)</kbd> method, simply insert the following line:</p>
<pre>services.AddHttpClient();</pre>
<p>And just like that, when you run your application, your <kbd>FitnessDataStoreClient</kbd> will have access to a valid instance of <kbd>HttpClientFactory</kbd>.</p>
<p>Unfortunately, though, this implementation is fairly basic. With what we've written, we'll have to configure our <kbd>HttpClient</kbd> instance every time we request it from the factory class. That means defining the base URL, any default headers we may want to apply, and other minutia. Instead, we can use the overload method of <kbd>AddHttpClient()</kbd> to create a named client. By doing this, we can centralize some of the boilerplate client configuration into our <kbd>Startup.cs</kbd> file, and then when we invoke the named client in our application code, we can skip straight ahead to sending requests with it. Using named clients also gives us a simple way to manage the need to connect to multiple distinct data sources. Doing so not only makes our code easier by eliminating some of the boilerplate of establishing a connection for HTTP requests, but can also improve performance by sharing connections between various references to the same named <kbd>HttpClient</kbd> instance.</p>
<p>To demonstrate this, I'll actually be creating two distinct aliases in my hosts file for the <kbd>FitnessDataStore</kbd> API. So, even though, behind the scenes, all requests to that API will be going to the same IP address, from the perspective of our <kbd>FitnessApp</kbd> API, it will look as though we're leveraging two distinct APIs with two distinct URLs, and two distinct named <kbd>HttpClient</kbd> instances. To test out this code for yourself, add the following lines to your hosts file, similar to how we did it in <a href="ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml">Chapter 2</a>, <em>DNS and Resource Location</em>:</p>
<pre>127.0.0.1 fitness.write.data.com<br/>127.0.0.1 fitness.read.data.com</pre>
<p>Now we can configure our <kbd>HttpClient</kbd> instances for each of these host names. With named instances of <kbd>HttpClientFactory</kbd>, we can specify the name by which we'll identify the specific instance we want to create, as well as define some default behavior for the client we're naming. We'll just call our different clients <kbd>WRITER</kbd> and <kbd>READER</kbd> for now. So, modify our <kbd>ConfigureServices(IServiceCollection services)</kbd> method as follows:</p>
<pre>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);<br/><br/>    services.AddHttpClient("WRITER", c =&gt; {<br/>        c.BaseAddress = new Uri("http://fitness.write.data.com:56789");<br/>        c.DefaultRequestHeaders.Add("Accept", "application/json");<br/>    });<br/><br/>    services.AddHttpClient("READER", c =&gt; {<br/>        c.BaseAddress = new Uri("http://fitness.read.data.com:56789");<br/>        c.DefaultRequestHeaders.Add("Accept", "application/json");<br/>    });<br/>}</pre>
<p>While the <kbd>Accept</kbd> header isn't usually the most important thing to concern ourselves with, this should be sufficient to demonstrate how you might configure the common properties for all requests bound generated by the named client. If you have a common authorization scheme, you can simply define those values once, in your <kbd>Startup.cs</kbd> class, and not have to concern yourself with updating authentication or authorization keys everywhere in your code that makes requests using those keys.</p>
<p>Since named <kbd>HttpClient</kbd> instances must be created using the same name they were registered with, it's usually best to keep the names in a central configuration file, and then reference the value out of that file in both the <kbd>Startup.cs</kbd> code that registers the named client, as well as the application code that requests it. Always avoid magic strings wherever possible.</p>
<p>Now that we have our named clients registered, let's get our data-access client set up to register with the dependency injection framework so we can start working with our controller class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Registering services in Startup.cs</h1>
                
            
            
                
<p>In the sample code, you'll find a simple model representing a record in our fitness activity database. I placed it in a <kbd>Models</kbd> folder, which is located in the root of the <kbd>project</kbd> directory. This is a common convention in MVC/Web API applications, but you can organize your code however makes the most sense for you. This class itself is relatively straightforward, and represents all the fields described in the project requirements I set out at the start of this section:</p>
<pre>namespace FitnessApp {<br/>    public class FitnessRecord {<br/>        public string title { get; set; }<br/>        public string workoutType { get; set; }<br/>        public string comments { get; set; }<br/>        public DateTime workoutDate { get; set; }<br/>    }<br/>}</pre>
<p>So, now, inside our <kbd>FitnessDataStoreClient</kbd> class, we'll want to define the operations we expect to be able to perform on our data store. According to our specs, we'll want to be able to look up all current records, look up individual records by their unique <kbd>title</kbd> property, look up records by <kbd>workoutType</kbd>, modify the <kbd>comments</kbd> field, and delete a record with a given <kbd>title</kbd>. For now, let's define those methods to return either a mock response, or just throw <kbd>NotImplementedException()</kbd> to satisfy our build system. We'll come back to fill out the implementation later in the chapter when we look at formatting and generating our requests using <kbd>HttpClient</kbd>:</p>
<pre>public class FitnessDataStoreClient : IDataStoreClient{<br/>  private readonly IHttpClientFactory _httpFactory;<br/><br/>  public FitnessDataStoreClient(IHttpClientFactory httpFactoryInstance) {<br/>    _httpFactory = httpFactoryInstance;<br/>  }<br/><br/>  public async Task&lt;bool&gt; WriteRecord(FitnessRecord newRecord) {<br/>    return false;<br/>  }<br/><br/>  public async Task&lt;List&lt;FitnessRecord&gt;&gt; GetAllRecords() {<br/>    return new List&lt;FitnessRecord&gt;();<br/>  }<br/><br/>  public async Task&lt;List&lt;FitnessRecord&gt;&gt; GetRecordsByWorkoutType(string workoutType) {<br/>    return new List&lt;FitnessRecord&gt;();<br/>  }<br/><br/>  public async Task&lt;FitnessRecord&gt; GetRecordByTitle(string title) {<br/>    return new FitnessRecord();<br/>  }<br/><br/>  public async Task&lt;bool&gt; UpdateRecord(string title, string newComment) {<br/>    return true;<br/>  }<br/><br/>  public async Task&lt;bool&gt; DeleteRecord(string title) {<br/>    return true;<br/>  }<br/>}</pre>
<p>While we have our implementation defined, we still need to define the interface that we'll use to register the class for dependency injection into our controller. We've already declared our <kbd>FitnessDataStoreClient</kbd> class to implement <kbd>IDataStoreClient</kbd>, so that's the name of the interface we'll create for dependency injection. So, either at the top of the current file, or in a new file located in the same folder, add the following interface definition:</p>
<pre>public interface IDataStoreClient {<br/>  Task&lt;bool&gt; WriteRecord(FitnessRecord newRecord);<br/>  Task&lt;List&lt;FitnessRecord&gt;&gt; GetAllRecords();<br/>  Task&lt;List&lt;FitnessRecord&gt;&gt; GetRecordsByWorkoutType(string workoutType);<br/>  Task&lt;FitnessRecord&gt; GetRecordByTitle(string title);<br/>  Task&lt;bool&gt; UpdateRecord(string title, string newComment);<br/>  Task&lt;bool&gt; DeleteRecord(string title);<br/>}</pre>
<p>And since our data store client is going to be entirely stateless (that is to say, having no instance properties that might vary between instances of the class), we can safely register it as a singleton instance in our <kbd>Startup.cs</kbd> file. So, from inside the <kbd>ConfigureServices(...)</kbd> method, add the following line:</p>
<pre>services.AddSingleton&lt;IDataStoreClient, FitnessDataStoreClient&gt;();</pre>
<p>This particular helper method will allow our dependency injection container to create a single instance of the concrete class the first time the class is created. The dependency injection container will then provide a reference to that single created instance for all subsequent requests for an instance. <kbd>WebHost</kbd> will then inject a reference to that single instance into each other class that requests an implementer of the <kbd>IDataStoreClient</kbd> interface for dependency injection. If you need multiple instances created for requesting your API handles, you can use the <kbd>services.AddScoped&lt;Interface, Implementation&gt;()</kbd> variant of this method, as this allows new instances to be created with a state that lives only as long as it takes to return a response for a given request. Alternatively, if you need a new instance every time an instance is injected anywhere in your application, regardless of scope, you can use the <kbd>services.AddTransient&lt;Interface, Implementation&gt;()</kbd> variant. Each of these alternatives will provide the same inversion of control that is necessary for dependency injection without holding a single managed instance of the implementation class over the lifetime of the application, as is the case with <kbd>AddSingleton()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling incoming HTTP methods</h1>
                
            
            
                
<p>Now that we have our service class defined and registered for use in our <kbd>Startup.cs</kbd> file, it's time to leverage it in our controller and start responding to incoming HTTP requests. First, though, we'll want to modify our controller class so it's a bit more useful for our purposes. Start by changing the name of the class to <kbd>FitnessController</kbd> and removing all of the method stubs provided by the initial project template. At the top of the class definition, you'll see two DataAttributes defined, like so:</p>
<pre>    [Route("api/[controller]")]<br/>    [ApiController]</pre>
<p>These provide context for your <kbd>WebServer</kbd> about the nature of this class file. The first one specifies that your <kbd>WebServer</kbd> should respond to all requests to the URI path <kbd>api/[controller]</kbd> by looking for valid methods inside this particular class. Now, here, <kbd>[controller]</kbd> is a special placeholder that is replaced with the name of your controller class (the segment of your class name that prefixes <kbd>controller</kbd>), so when we change the name of our class file to <kbd>FitnessController</kbd> and run the application, we should begin seeing valid responses by navigating to <kbd>http://localhost/api/fitness</kbd>.</p>
<p>The second DataAttribute, <kbd>[ApiController]</kbd> method, is actually very important if we want our controller to behave as expected. Using that attribute at the top of a type definition tells our <kbd>WebHostBuilder</kbd> to use this particular class as a controller and explore its method signatures to discover endpoints that should be exposed by the server. It also notifies our <kbd>WebServer</kbd> to perform automatic model-binding validation. What that means is that whenever a request comes in targeting one of the controller's endpoints, the inputs specified in the signature of the endpoint should match the shape of the request message. By specifying our controller as an <kbd>ApiController</kbd>, <kbd>WebServer</kbd> will make sure that requests messages match our expected inputs before it invokes our controller's methods.</p>
<p>With the name changed, and the methods removed, we need to set up our controller to use the registered instance of the <kbd>IDataStoreClient</kbd> implementation. So, let's create a private member variable and inject our instance with a constructor for our controller:</p>
<pre>public class FitnessController : ControllerBase {<br/>    private readonly IDataStoreClient _dataStore;<br/><br/>    public FitnessController(IDataStoreClient data) {<br/>        _dataStore = data;<br/>    }<br/>    ...<br/>}</pre>
<p>Now, with the <kbd>IDataStoreClient</kbd> operations as our guide, we can start implementing our controller endpoints. Each of our endpoints will demonstrate a different HTTP method, so let's consider how those methods are used and how that impacts the implementation of our endpoints.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The GET method</h1>
                
            
            
                
<p>The first and most basic method we'll implement a listener for is the <kbd>GET</kbd> method. This method is used to access a resource at a specific endpoint, and, conventionally, <kbd>GET</kbd> requests carry no content, as specific constraints on the lookup are typically passed along as either segments of the URL path, or as key-value specifications sent as part of the URL's query parameters. It's up to you (or your project's specifications) to enforce those conventions, if you choose to. It's worth noting, though, that for most engineers, and for the <kbd>HttpClient</kbd> methods implemented by C#, the assumption is that those conventions will be followed by active HTTP services.</p>
<p>One other important note about the <kbd>GET</kbd> method is that it is generally considered both <em>safe</em> and <em>idempotent</em>. For an HTTP method to be considered <em>safe</em>, then a request of that method must not have any impact on the state of the resource on which the request was made. So, if I request a list of names from a server using a simple <kbd>GET</kbd> request, the server should still have those names stored in its database. The server should be exactly the same after it services my request as it was before it serviced my request. Meanwhile, if an operation is not safe, that means that the state of information stored on the server will be different after it processes a request of that unsafe method. The only HTTP methods that are always considered safe are <kbd>OPTIONS</kbd>, <kbd>HEAD</kbd>, and <kbd>GET</kbd>.</p>
<p>If you've never seen the word idempotent before, don't worry; it's nothing complicated. For a method or operation to be considered idempotent, you should be able to execute that operation any number of times without ever getting a different outcome from the first time you executed it. So, if I request a record with its ID, it doesn't matter how many times I request that record, I should always get the same response back that I got the first time I requested it. So, naturally, <kbd>GET</kbd> is considered an idempotent HTTP method.</p>
<p>So, now that we understand how a <kbd>GET</kbd> method should be handled (that is to say, safely, and in such a way to render <kbd>GET</kbd> requests idempotent), how do we configure our controller to respond to a <kbd>GET</kbd> request? Well, if you read the source code I told you to delete before you deleted it, you already know the answer to this. But for those who don't know, we specify our methods as handlers for <kbd>GET</kbd> requests using the <kbd>[HttpGet]</kbd> method attribute. So, let's look at all of our <kbd>read</kbd> operations and implement their methods in our controller using <kbd>IDataStoreClient</kbd>:</p>
<pre>[HttpGet]<br/>public async Task&lt;ActionResult&lt;IEnumerable&lt;FitnessRecord&gt;&gt;&gt; Get() {<br/>  return await _dataStore.GetAllRecords();<br/>}<br/>        <br/>[HttpGet("{title}")]<br/>public async Task&lt;ActionResult&lt;FitnessRecord&gt;&gt; GetRecord(string title) {<br/>  return await _dataStore.GetRecordByTitle(title);<br/>}<br/>        <br/>[HttpGet("type/{type}")]<br/>public async Task&lt;ActionResult&lt;IEnumerable&lt;FitnessRecord&gt;&gt;&gt; GetRecordsByType(string type) {<br/>  return await _dataStore.GetRecordsByWorkoutType(type);<br/>}</pre>
<p>Note that the attribute takes an optional string argument specifying a more specific URL path that the annotated method is meant to respond to. When the attribute is used without the optional parameter, though, the method annotated by the <kbd>[HttpGet]</kbd> attribute will simply respond to any <kbd>[HttpGet]</kbd> requests made to whatever URL path is handled by the parent <kbd>Controller</kbd> class. So, in this case, our <kbd>Get()</kbd> method will respond to any <kbd>GET</kbd> requests made against the <kbd>api/fitness</kbd> path. Meanwhile, requests made to <kbd>api/fitness/type/{type}</kbd> will return all records whose <kbd>workoutType</kbd> field contains the value of the <kbd>{type}</kbd> parameter.</p>
<p>I should also note here that (as you probably already guessed) the curly-brace syntax in the route specification is used as a placeholder for dynamic path variables. What's more, you can always safely reference any variable used inside curly braces in a route as an argument to your implementing method, and the web server will properly map whatever value was used in the request URL's path to its invocation of your method.</p>
<p>You may have also noticed that each of our methods has a return type of <kbd>ActionResult&lt;T&gt;</kbd> (ignoring the <kbd>Task&lt;T&gt;</kbd> outer type that's required for asynchronous methods). This is a custom wrapper around our return object that is applied to our methods' return values by <kbd>ControllerBase</kbd>. It will provide the appropriate HTTP status code and response headers for whatever result we return within our methods, and it does so entirely behind the scenes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The POST method</h1>
                
            
            
                
<p>So, with our <kbd>GET</kbd> requests serviced, let's look at what a <kbd>POST</kbd> request is, and how to handle it with our application. The <kbd>POST</kbd> method is typically used when a client needs to send a payload of content to the listening server, usually for storage or as an input to some calculation or processing that the server is responsible for. While, in some cases, some specific <kbd>POST</kbd> endpoints might be both safe and idempotent (because, again, it's up to each developer to adhere to the conventions of HTTP and RESTful API development), in the general case, <kbd>POST</kbd> as a method should be assumed to be neither safe nor idempotent.</p>
<p>The primary distinction between a <kbd>POST</kbd> request and a <kbd>GET</kbd> request is the payload associated with the <kbd>POST</kbd> request. So, let's look at how we can access and parse that payload for processing by our Web API:</p>
<pre>[HttpPost]<br/>public async Task&lt;IActionResult&gt; NewRecord([FromBody] FitnessRecord newRecord) {<br/>    if (await _dataStore.WriteRecord(newRecord)) {<br/>        return Ok("new record successfully written");<br/>    }<br/>    return StatusCode(400);<br/>}</pre>
<p>Here, we're using the <kbd>[FromBody]</kbd> parameter attribute on our method's only argument, and we're specifying that we expect to receive an instance of the <kbd>FitnessRecord</kbd> class from our request's content body. This attribute will use the <kbd>Content-Type</kbd> header of the request to determine how to parse the incoming message's content body and attempt to de-serialize the message into the type specified as the parameter. So, here, it would expect the message to be in the format of the <kbd>FitnessRecord</kbd> type. If the message body cannot be deserialized to the expected type, Web API will throw an appropriate 4XX status code response indicating some form of a bad request was sent.</p>
<p>I've used the <kbd>[FromBody]</kbd> attribute here primarily for demonstration purposes, as a way to illustrate the various <kbd>[From*]</kbd> attributes. Interestingly, though, because of our use of the <kbd>[ApiController]</kbd> attribute at the top of our class definition, we actually already reap the benefits of this input validation without needing to specify the <kbd>[FromBody]</kbd> attribute when we only have a single class specified as the input for a <kbd>POST</kbd> method.</p>
<p>There are a number of <kbd>[From*]</kbd> attributes you can apply to incoming messages to map your formal argument variable to some part of the incoming request. These include the following:</p>
<ul>
<li><kbd>[FromBody]</kbd></li>
<li><kbd>[FromForm]</kbd></li>
<li><kbd>[FromQuery]</kbd></li>
<li><kbd>[FromRoute]</kbd></li>
<li><kbd>[FromHeader]</kbd></li>
</ul>
<p>Each of these parameter bindings will attempt to retrieve your the value of your formal parameter from the target location, and, if possible, will attempt to de-serialize the specific message component into the simple type you've declared for your formal parameter.</p>
<p>Additionally, there is a <kbd>[FromServices]</kbd> attribute. This is unique from the others in that it doesn't actually attempt to parse the designated argument from any part of your incoming message. Instead, this allows you to retrieve an instance of a dependency-injected interface from your registered services and assign it to a variable scoped to that single method, instead of having a class member variable whose value is assigned in the constructor.</p>
<p>The other interesting concept we've introduced with this method is sending generalized HTTP responses using the built-in methods of the <kbd>BaseController</kbd> class. Our two possible return values are determined by the <kbd>Ok()</kbd> and <kbd>StatusCode()</kbd> methods. Each of these will do the work of formatting an <kbd>HttpResponse</kbd> object for the desired <kbd>StatusCode</kbd>, with <kbd>Ok()</kbd> obviously returning a <kbd>200</kbd> code, and the <kbd>StatusCode()</kbd> method returning a response with whichever status code you specify as your argument.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The PUT and PATCH methods</h1>
                
            
            
                
<p>Next let's look at the HTTP methods that will allow us to apply updates to records that already exist on the server. This can be done with either of the <kbd>PUT</kbd> or <kbd>PATCH</kbd> methods. Now, since I've just described them as updating the state of the server, it should be obvious that neither of these methods are considered safe. However, a <kbd>PUT</kbd>  method should be idempotent (when properly implemented). We'll see why momentarily, but <kbd>PATCH</kbd> is not considered generally idempotent. The difference between the two is subtle, and often they are implemented in a way as to be interchangeable, so let's learn how they work and think about which is the most appropriate for our update operation.</p>
<p>When a <kbd>PUT</kbd> method has been implemented to the HTTP standard, the client is expected to provide a full instance of a minimum payload and a target destination for that payload. If there is a record at that target destination, then the payload is considered an update to that record, and the entire existing record is overwritten with the payload. Meanwhile, if there is no record at that target destination, then the payload is inserted, just as with <kbd>POST</kbd>, at the target URI. So, now, hopefully, you can see why this operation is idempotent. Using a single given payload, it doesn't matter how many times we execute the <kbd>PUT</kbd> method; it will always set the record at the target location to the value of that same payload. Subsequent executions have no effect after the first operation succeeds.</p>
<p>Some of the more astute readers may have identified a risk inherent to the <kbd>PUT</kbd> operation. Specifically, unless you have the most up-to-date version of the record you intend to update, you run the risk of overwriting recent changes to the record that you were unaware of with your <kbd>PUT</kbd>. Thus, it's usually wise to do a <kbd>GET</kbd>  operation on the target record prior to applying any <kbd>PUT</kbd> updates to it to ensure that no recent updates are accidentally reverted. This introduces a performance hit in the form of additional round trips to your server, and, likely, a resource-locking mechanism to ensure that no one updates your target record in the time between your <kbd>GET</kbd> and your <kbd>PUT</kbd>.</p>
<p>The <kbd>PATCH</kbd> method, on the other hand, only requires that a <em>set of changes, as described in the request payload</em>, be applied to an entity identified by the request URI. This means that our payload could describe a change be made to only a specific property on the target resource, without having to send the new, wholly updated state of the record with each <kbd>PATCH</kbd> request. For example, a properly formatted <kbd>PATCH</kbd> request could have a payload that describes your changes as follows:</p>
<pre>{ "operation": "update", "property": "comments", "new_value": "new comments to use for record" }</pre>
<p>Thus, when the operation is called, your API would have the information necessary to update only the relevant field you hope to update. You'll note, though, that the definition of a patch is vague enough that you could describe a set of changes that apply new content and change the state of the server with each subsequent request. For example, imagine the following description:</p>
<pre>{ "operation": "append", "property": "comments", "suffix": "... and a longer string" }</pre>
<p>If this operation appended the value of a suffix to the target property, then each subsequent <kbd>PATCH</kbd> with the same payload would result in a longer and longer <kbd>comments</kbd> field. Because of this broad spectrum of a possible <em>set of changes, as described by the payload</em>, the <kbd>PATCH</kbd> operation is not assumed to be idempotent.</p>
<p>Now, technically, the standard produced by the <strong>Internet Engineering Task Force</strong> (<strong>IETF</strong>) that describes the <kbd>PATCH</kbd> operation (RFC 5789) specifies that the payload of a <kbd>PATCH</kbd> request contains a set of instructions describing how a resource currently residing on the origin server should be modified to produce the new version. This seems to indicate that the payload actually explicitly describes a sequence of operations to perform on the target resource, as opposed to representing a partial object state with only the fields that are meant to be updated. Under this interpretation, the following <kbd>PATCH</kbd> payload might be considered non-standard, or incorrect:</p>
<pre>{ "comments": "New comment to update the record with" }</pre>
<p>In fact, there are a number of purists who insist that using <kbd>PATCH</kbd> to send only partial object structures is an explicitly incorrect use of the method as defined in the standard. However, I would argue that a payload containing a partial object structure is itself a highly streamlined description of a set of changes to apply to the resource. I would actually make the case that such an implementation does not violate the spirit or letter of the standard. To wit, the stated intent of RFC 5789 is to provide the partial-update functionality that is not provided by the <kbd>PUT</kbd> operation, and a partial object structure does exactly that. In fact, there is even a new standard out for comment that specifies that exact payload structure: RFC 7936.</p>
<p>As you decide how to implement <kbd>PATCH</kbd>, I would encourage you to read the opinions of others on how it should be written so as to meet the standard, and then decide for yourself whether you should take a more pure approach, or allow the partial object structure. I've already explained my reasoning for accepting the partial object approach, and so that's how we'll implement our comment-update method in our API:</p>
<pre>[HttpPatch("{title}/comments")]<br/>public async Task&lt;IActionResult&gt; UpdateComments(string title, [FromBody] string newComments) {<br/>  if (await _dataStore.UpdateRecord(title, newComments)) {<br/>    return Ok("record successfully updated");<br/>  }<br/>  return StatusCode(400);<br/>}</pre>
<p>Here, since we're only allowing our users to update their comments, we'll use the REST paradigm of using our path to describe the most specific part of our system that we want to interact with. Thus, our path and method specify that we want to <kbd>PATCH</kbd> the value of the comments at the record with the given title. This, semantically, communicates everything we need to know about this operation, and I would assert accomplishes all of the goals of RESTful design, within the standards of the HTTP operation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The DELETE method</h1>
                
            
            
                
<p>Finally, we'll look at perhaps the most intuitive method described for HTTP, the <kbd>DELETE</kbd> method. Sending a <kbd>DELETE</kbd> request to a target resource will do exactly that: it will delete the resource from the server, replacing it with nothing. Since this updates the state on the server, the method is not safe. However, since you can't delete a record that's already been deleted, the operation is considered idempotent.</p>
<p>A <kbd>DELETE</kbd> request may receive a response with a body describing the object that was deleted, or the success or failure of the operation, but, typically, just a 2XX status code message is delivered on a successful deletion. This method is as simple as it sounds, so let's implement it in our controller:</p>
<pre>[HttpDelete("{title}")]<br/>public async Task&lt;IActionResult&gt; Delete(string title) {<br/>    if (await _dataStore.DeleteRecord(title)) {<br/>        return Ok("record successfully deleted");<br/>    }<br/>    return StatusCode(400);<br/>}</pre>
<p>Exactly as you would expect, the method is defined as a valid handler for <kbd>DELETE</kbd> requests using the <kbd>[HttpDelete("{title}")]</kbd> attribute, and merely returns a status code of either <kbd>200</kbd> or <kbd>400</kbd>, with a success message.</p>
<p>And just like that, we've written a service that will listen for and properly respond to the full suite of valid HTTP methods for which you'll be expected to write custom software. So, now that we can handle incoming HTTP requests, let's look at how to build and send outbound requests of our own.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP request formatting</h1>
                
            
            
                
<p>With it being such a common aspect of most modern software projects, it should come as no surprise that generating HTTP requests has been so thoroughly streamlined by the .NET Core standard that it's an absolute breeze to use. We'll be using the <kbd>HttpClient</kbd> class to send outbound requests that perfectly mirror the <kbd>FitnessApp</kbd> API we just defined in our controller class, so understanding the expected paths and inputs should be a straightforward endeavor. So, with that in mind, let's crack open our <kbd>FitnessDataStoreClient</kbd> class and start generating requests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating HttpClient instances</h1>
                
            
            
                
<p>We'll start with the simple read operations in our API, but in order to do that, we'll need to spin up an instance of the <kbd>HttpClient</kbd> class for use to use to generate our requests. To do this, we'll want to request the instance of the class that we registered for read operations. This is as simple as calling <kbd>CreateClient()</kbd> with the same key we used to register the <kbd>READER</kbd> instance in the first place. So, inside our <kbd>GetAllRecords()</kbd> method, simply add the following line to the start of the method:</p>
<pre>var client = _httpFactory.CreateClient("READER");</pre>
<p>And now, our client variable contains an instance of <kbd>HttpClient</kbd> that's already configured with the <kbd>BaseAddress</kbd> and <kbd>DefaultHeaders</kbd> properties we set in our <kbd>Startup.cs</kbd> file.</p>
<p>If you ever need to create an <kbd>HttpClient</kbd> class without pre-registering it (suppose you needed it to access a URL that you don't know the value of until runtime), you can do so by simply leaving the arguments of the <kbd>CreateClient()</kbd> call empty. You'll then be responsible for setting the <kbd>BaseAddress</kbd>  property for your requests and any necessary headers on your newly created client, but that's done in exactly the same way as we did it in our <kbd>Startup.cs</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a request message</h1>
                
            
            
                
<p>Now that we have our client, creating an outbound <kbd>GET</kbd> request is as simple as defining an <kbd>HttpRequestMessage</kbd> instance and specifying the method and target path we intend to send our request with. And since <kbd>GET</kbd> requests conventionally have no content body, that initial <kbd>HttpRequestMessage</kbd> definition is sufficient to give to our <kbd>HttpClient</kbd> for transmission. If you need to apply headers, you can do so with the <kbd>Headers</kbd> property of the <kbd>HttpRequestMessage</kbd> class, but since we don't, let's just create our message, and send it with our client:</p>
<pre>HttpRequestMessage message = new HttpRequestMessage(HttpMethod.Get, "/api/fitness-data");<br/><br/>var response = await client.SendAsync(message);</pre>
<p>And just like that, we have the response from our server in a variable for us to work with. Before we proceed with parsing the response message, though, we'll want to make sure that our operation completed successfully. A common pattern is to wrap any error-handling code (which we won't be implementing here, for brevity's sake) in a conditional clause checking the success of the request. Once we've confirmed that behavior, though, we can safely attempt to parse our <kbd>response</kbd> object:</p>
<pre>if (!response.IsSuccessStatusCode) {<br/>  return new List&lt;FitnessRecord&gt;();<br/>}<br/><br/>var json = await response.Content.ReadAsStringAsync();<br/>var result = JsonConvert.DeserializeObject&lt;List&lt;FitnessRecord&gt;&gt;(json);<br/>return result;</pre>
<p>The <kbd>response</kbd> object we get back represents the entirety of the HTTP response from the server, including any headers the server sent back, and the status code, and even the content of the original request message. Typically, though, you'll only be concerned with the <kbd>StatusCode</kbd> property, and the <kbd>Content</kbd> property. The <kbd>StatusCode</kbd> property is actually an enum type that enumerates all valid HTTP response status codes, and is what's used to determine the result of the derived <kbd>IsSuccessStatusCode</kbd> property. Meanwhile, the <kbd>Content</kbd> property is an instance of the <kbd>HttpContent</kbd> class, which contains an array of headers specific to the content, as well as a number of utility methods for reading and parsing the body of the content.</p>
<p>Since we know that the output of our request will be the JSON representation of a list of fitness records, we can use the <kbd>JsonConvert</kbd> static class to de-serialize and return the response content. And with that simple pattern, we can proceed to define the rest of our <kbd>GET</kbd> operations. First, we have the <kbd>GetAllRecords()</kbd> method, which will simply return the list of any records stored in our data source:</p>
<pre>public async Task&lt;List&lt;FitnessRecord&gt;&gt; GetAllRecords() {<br/>    var client = _httpFactory.CreateClient("READER");<br/><br/>    HttpRequestMessage message = new HttpRequestMessage(HttpMethod.Get, "/api/fitness-data");<br/><br/>    var response = await client.SendAsync(message);<br/><br/>    if (!response.IsSuccessStatusCode) {<br/>        return new List&lt;FitnessRecord&gt;();<br/>    }<br/><br/>    var json = await response.Content.ReadAsStringAsync();<br/>    var result = JsonConvert.DeserializeObject&lt;List&lt;FitnessRecord&gt;&gt;(json);<br/>    return result;<br/>}</pre>
<p>Next, we have our <kbd>GetRecordsByWorkoutType()</kbd> method, which allows the user to filter based on the <kbd>workoutType</kbd> field of the fitness record:</p>
<pre>public async Task&lt;List&lt;FitnessRecord&gt;&gt; GetRecordsByWorkoutType(string workoutType) {<br/>    var client = _httpFactory.CreateClient("READER");<br/><br/>    HttpRequestMessage message = new HttpRequestMessage(HttpMethod.Get, $"/api/fitness-data/type/{workoutType}");<br/><br/>    var response = await client.SendAsync(message);<br/><br/>    if (!response.IsSuccessStatusCode) {<br/>        return new List&lt;FitnessRecord&gt;();<br/>    }<br/><br/>    var json = await response.Content.ReadAsStringAsync();<br/>    var result = JsonConvert.DeserializeObject&lt;List&lt;FitnessRecord&gt;&gt;(json);<br/>    return result;<br/>}</pre>
<p>Finally, we'll implement our <kbd>GetRecordByTitle()</kbd> method, which allows us to search our fitness records by the (presumably) unique <kbd>title</kbd> assigned to them:</p>
<pre>public async Task&lt;FitnessRecord&gt; GetRecordByTitle(string title) {<br/>    var client = _httpFactory.CreateClient("READER");<br/><br/>    HttpRequestMessage message = new HttpRequestMessage(HttpMethod.Get, $"/api/fitness-data/{title}");<br/><br/>    var response = await client.SendAsync(message);<br/><br/>    if (!response.IsSuccessStatusCode) {<br/>        return new FitnessRecord();<br/>    }<br/><br/>    var json = await response.Content.ReadAsStringAsync();<br/>    var result = JsonConvert.DeserializeObject&lt;FitnessRecord&gt;(json);<br/>    return result;<br/>}</pre>
<p class="mce-root"/>
<p>With each of these methods, you'll notice that we're not actually implementing any additional filtering logic inside our data service class. Instead, we're relying on that work to be done by the server. The abstraction we're introducing is over the direct interaction with the server, and not on the logic of filtering the records. So, now that we have our <kbd>GET</kbd> operations in place, we can look at what additional steps we need to take to <kbd>POST</kbd> data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Posting request content</h1>
                
            
            
                
<p>Since the main difference between a <kbd>GET</kbd> request and a <kbd>POST</kbd> request is the content attached to the <kbd>POST</kbd> request, let's take a look at how to apply our content to our request message. First, we'll change the method specified when we create our <kbd>HttpRequestMessage</kbd> instance:</p>
<pre> public async Task&lt;bool&gt; WriteRecord(FitnessRecord newRecord) {<br/>  var client = _httpFactory.CreateClient("WRITER");<br/><br/>  HttpRequestMessage message = new HttpRequestMessage(HttpMethod.Post, "/api/fitness-data");</pre>
<p>Then, we'll need to create our <kbd>Content</kbd>. The <kbd>HttpContent</kbd> class is an abstract class instantiated by a variety of sub-classes that each implement different valid formats for <kbd>POST</kbd> content. You can define <kbd>FormContent</kbd> for an <kbd>x-www-form-urlencoded</kbd> request; <kbd>MultiPartFormContent</kbd> for large messages, file transfer, or binary data transmitted in several discrete chunks; <kbd>StreamContent</kbd> to represent an open and active stream connection; and many more. For our purposes, though, since we'll be serializing to and from JSON, we'll just define the payload as an instance of <kbd>StringContent</kbd>.</p>
<p>When you're using <kbd>StringContent</kbd>, there are several override implementations that allow you to specify the specific character encoding and the media type for the message. This is used by the <kbd>HttpClient</kbd> class to apply the appropriate content-type header to the request, which means that in most cases, you'll never have to concern yourself with that specific value. Since our string will be well-formed JSON, the <kbd>HttpClient</kbd> class will be able to infer our media type from the string alone, so applying the <kbd>POST</kbd> body is a fairly straightforward task:</p>
<pre class="mce-root">var requestJson = JsonConvert.SerializeObject(newRecord);<br/>message.Content = new StringContent(requestJson);</pre>
<p>With our message body in place, the rest of our code proceeds exactly as it did with our <kbd>GET</kbd> requests, leaving us with a final implementation:</p>
<pre>public async Task&lt;bool&gt; WriteRecord(FitnessRecord newRecord) {<br/>    var client = _httpFactory.CreateClient("WRITER");<br/><br/>    HttpRequestMessage message = new HttpRequestMessage(HttpMethod.Post, "/api/fitness-data");<br/>    var requestJson = JsonConvert.SerializeObject(newRecord);<br/>    message.Content = new StringContent(requestJson, Encoding.UTF8, "application/json");<br/><br/>    var response = await client.SendAsync(message);<br/>    return response.IsSuccessStatusCode;<br/>}</pre>
<p>So, with this pattern in place, we can complete our implementation by adding the code to update and delete records:</p>
<pre>public async Task&lt;bool&gt; UpdateRecord(string title, string newComment) {<br/>    var client = _httpFactory.CreateClient("WRITER");<br/><br/>    HttpRequestMessage message = new HttpRequestMessage(HttpMethod.Patch, $"/api/fitness-data/{title}/comments");<br/>    message.Content = new StringContent($"\"{newComment}\"", Encoding.UTF8, "application/json");<br/><br/>    var response = await client.SendAsync(message);<br/>    return response.IsSuccessStatusCode;<br/>}<br/><br/>public async Task&lt;bool&gt; DeleteRecord(string title) {<br/>    var client = _httpFactory.CreateClient("WRITER");<br/><br/>    HttpRequestMessage message = new HttpRequestMessage(HttpMethod.Delete, $"/api/fitness-data/{title}");<br/><br/>    var response = await client.SendAsync(message);<br/>    return response.IsSuccessStatusCode;<br/>}</pre>
<p>Running this application side by side with the <kbd>FitnessDataStore</kbd> app, you should see all of the expected behavior described in our initial project description. Fire them up, bring up your REST client of choice, and start hitting every endpoint. Set breakpoints in your code, and see what happens every step of the way. And with that, we've covered the essentials of HTTP in .NET Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTPS – security over HTTP</h1>
                
            
            
                
<p>While we'll discuss it more in <a href="2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml">Chapter 13</a>, <em>Transport Layer Security</em>, we should take a moment to consider how to establish secure connections at the application layer. In the HTTP protocol, security is achieved through <strong>Hypertext Transfer Protocol Secure</strong> (<strong>HTTPS</strong>). This provides a mechanism for authenticating the source of a remote resource, such as a web page or an API response. HTTPS also provides protection of the data in transit that is passed between client and server with each request/response interaction. This is done by leveraging the <strong>Secure Sockets Layer</strong> (<strong>SSL</strong>) or, more recently, the <strong>Transport Layer Security</strong> (<strong>TLS</strong>) on the underlying transport-layer interactions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Establishing outbound HTTPS connections</h1>
                
            
            
                
<p>With outbound connections, using HTTPS is as simple as defining the schema in your request URL to be of type <kbd>https://...</kbd>. While this may seem trivial, the value in HTTPS connections comes from a trusted and validated server certificate, usually signed by a third party, which gives consumers confidence that the site they are trying to access is, in fact, the site they intended to access.</p>
<p>In many cases, you'll want to test out your application on a development server using production-ready configurations. Typically, in these scenarios, you won't have the requested <strong>Certificate Authority</strong> (<strong>CA</strong>) provide you with a trusted, signed SSL certificate for that development server. When that happens, your calling code will throw an error warning users that the HTTPS connection couldn't be validated with an SSL certificate signed by a trusted CA. This happens because, behind the scenes of the <kbd>HttpClient</kbd> class, there is an <kbd>HttpClientHandler</kbd> function that validates any outbound HTTPS connections before checking for an SSL certificate signed by a trusted CA. This means that, in a case where you're connecting to a trusted and certified resource over HTTPS, you don't have to do any additional work to ensure that security. A successful connection with your <kbd>HttpClient</kbd> ensures that security.</p>
<p>There is a way to override that behavior with a custom server certificate validator, which we'll look at in later chapters focusing on security. In general, though, if you're getting that error from any remote resource that you don't directly control, <em>listen to it</em>. It's a fantastic warning system that you get for free from .NET Core, and you'd be wise to leverage it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Supporting HTTPS on your server</h1>
                
            
            
                
<p>This should come as no surprise to any of you, but we've already seen exactly how we can support HTTPS for incoming HTTP requests being made of our application. It's that tricky little line of code we keep removing:</p>
<pre>app.UseHttpsRedirection();</pre>
<p>Provided we have this line of code, and our web server is configured to listen over at least an HTTPS URL, our application will support HTTPS. With this value set, the web server will respond to all incoming HTTP connection attempts with a <kbd>302</kbd>, which is a redirection status code notifying the client that their request should be redirected to the HTTPS URI for processing. </p>
<p>The reason I've been removing this particular piece of code and using HTTP in all of our examples so far is because of what I mentioned in the previous section titled <em>Establishing outbound HTTPS connections.</em> Trying to connect to a server over HTTPS will cause our software (and most REST clients such as Postman or Insomnia) to attempt to validate an SSL certificate. However, while we're in development, our local machines typically won't have a signed certificate to return with HTTPS responses. So, by removing the <kbd>UseHttpsRedirection()</kbd> method, we simply remove that variable from the equation while we're still in development. However, once you're ready to deploy your code to a production environment, you'll want to enforce HTTPS wherever possible, and I would even go so far as to recommend you configure your server to only listen on HTTPS URLs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP/2</h1>
                
            
            
                
<p>In 2015, the <strong>Internet Engineering Task Force</strong> (<strong>IETF</strong>) introduced the first major revision of the HTTP standard since HTTP 1.1 was codified in 1997. This new protocol, now named HTTP/2, introduces a number of extension features on top of the existing HTTP 1.1 protocol definition, while leaving the expected behavior of the previous standard almost entirely unchanged.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">New features of HTTP/2</h1>
                
            
            
                
<p>Originally developed by Google under the moniker <strong>SPDY</strong> (short for <em>speedy</em>), HTTP/2 was designed to provide major speed improvements over HTTP 1.1. Its objectives were to reduce latency to improve the performance of web browsers loading content. This latency reduction is accomplished by the following:</p>
<ul>
<li><strong>Header compression:</strong> All transmission headers are compressed with either gzip or DEFLATE compression mechanisms by default. The reduced packet size and volume for basic protocol/request negotiation has a noticeable impact on high-latency network connections, such as cellular networks (thus improving page-load performance on mobile devices, such as Google's Android phones).</li>
<li><strong>Request multiplexing:</strong> Sends multiple queued outbound requests over a single active connection. This can prevent bottlenecks of outbound requests for web resources on pages with a lot of content, and head-of-line blocking, which occurs when the first request in a queue hangs, preventing the processing of subsequent, potentially smaller and faster requests, from resolving.</li>
<li><strong>Server push:</strong> This allows a server to send content directly with a client over a previously established connection. This is useful if, for instance, you know that every request for a web page will be shortly followed by requests for additional resources referenced by the web page. Instead of forcing the client to initiate an additional HTTP request cycle for those additional resources, the server can simply push out the data directly and, if configured properly, the client can handle the incoming data without the overhead of processing the full HTTP message structure.</li>
<li><strong>Request prioritization:</strong> This enables the developer to determine which requests will most likely need to be resolved first and provide priorities to ensure they are. Similar to multiplexing, it seeks to reduce the impact of head-of-line blocking, but can do so without needing to fully support a multiplexing transport mechanism.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP/2 in .NET core</h1>
                
            
            
                
<p>Configuring your application to start leveraging these features happens at with your <kbd>WebHostBuilder</kbd>, since the web server negotiates all of the incoming HTTP requests and determines support for various protocols. Once that's done, though, your clients will begin seeing the benefits of the protocol extensions without any additional change in your code to support it.</p>
<p>Unfortunately, at the time of writing, Kestrel doesn't support some features, such as server push and stream prioritization. So, while the client can send a prioritization tag with its requests, Kestrel simply won't act on that request. And one other caveat to HTTP/2 support is that your hosting environment's native cryptography library must support <strong>Application Layer Protocol Negotiation</strong> (<strong>ALPN</strong>) to establish the secure connection necessary for HTTP/2. That means HTTP2 is supported only for .NET Core apps deployed to either Windows environments or Linux hosts with OpenSSL 1.0.2 or higher. Thankfully, though, if your environment doesn't support HTTP/2, Kestrel will silently fall back to using standard HTTP 1.1 request processing. That means you can configure the protocol and deploy it to any environment without worrying about environment specific Kestrel configurations.</p>
<p>If you want to support HTTP/2, simply leverage the <kbd>ConfigureKestrel()</kbd> method on your <kbd>WebHostBuilder</kbd>, like so:</p>
<pre>WebHost.CreateDefaultBuilder(args)<br/>  .ConfigureKestrel(options =&gt; {<br/>    options.Listen(IPAddress.Any, 8080, listenOptions =&gt; {<br/>      listenOptions.Protocols = HttpProtocols.Http1AndHttp2;<br/>      listenOptions.UseHttps("testcert.pfx", "testPassword")<br/>    });<br/>  })<br/>  .UseStartup&lt;Startup&gt;();</pre>
<p>And just like that, you've got support for multiplexing, header compression, and request streaming, out of the box, with no change to your application code. And I'll note that further support for HTTP/2 is on the horizon for Kestrel, so as the protocol matures (it's only been a standard for about three years at the time of writing), expect to see wider adoption, and the improved performance that goes with it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We covered a lot in this chapter, and for good reason. HTTP is, as I suggest in the title of this chapter, integral to programming software being able to function on the web. We learned about the distinctions between application-layer protocols and transport-layer protocols with a bit more clarity and context. We explored the history of HTTP, and saw how its design lent itself for use far beyond its original intended purpose.</p>
<p>Once we had that background, we looked at the Web API project template, and learned how .NET Core leverages the cross-platform Kestrel web server to expose network-aware applications to incoming requests. We looked at how to configure our web server using the <kbd>WebHostBuilder</kbd> extension classes. We learned how to configure our application code for use on our web server, in our given hosting environment, using the <kbd>Startup.cs</kbd> class. Then we took the time to set up our application to leverage ASP.NET Core's dependency injection framework for our service and utility classes.</p>
<p>With our application wired up and ready to go, we looked at how to expose the controller endpoints to listen for each specific HTTP method at specific routes, and the various ways we could respond to those requests. Then we looked at how to format outbound HTTP messages of our own, including building a content body, formatting and applying request headers, and finally sending our requests using the <kbd>HttpClient</kbd>. Finally, we took some time to consider how to allow secure connections with HTTPS, and what the future holds with the HTTP/2 specification. With this perspective, we're well positioned to explore how some of the other application-layer protocols are tuned to their specific use cases in the next chapter, where we'll dive into the <strong>File Transfer Protocol</strong> (<strong>FTP</strong>) and the <strong>Simple Mail Transfer Protocol</strong> (<strong>SMTP</strong>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the definition of HTTP?</li>
<li>What does SOAP mean? What does REST mean?</li>
<li>What are some of the primary differences between SOAP services and REST services?</li>
<li>What does MVC stand for, and how does it apply to the Web API project template?</li>
<li>What is Kestrel and how is it used in ASP.NET Core?</li>
<li>What are the various methods of HTTP? Which are safe? Why are they safe?</li>
</ol>
<ol start="7">
<li>What does HTTPS stand for? How does it provide security?</li>
<li>What new features are supported in HTTP/2? What requirements must be met to leverage it?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>For more information about HTTP in .NET Core, or using ASP.NET Core, you have a wealth of resources at your disposal. Particularly, I'd recommend <em>Hands-On Full-Stack Web Development with ASP.NET Core</em>, by Tamir Dresher, Amir Zuker, and Shay Friedman, available through Packt Publishing here: <a href="https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core">https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core</a>.</p>
<p>If you want to take a deeper dive into the patterns and principles that informed the developers of ASP.NET Core, I'd recommend reading <em>ASP.NET Core 2 Fundamentals</em>, by Onur Gumus and Mugilan T S Ragupathi. It's also available from Packt, and you can find it here: <a href="https://www.packtpub.com/web-development/aspnet-core-2-fundamentals">https://www.packtpub.com/web-development/aspnet-core-2-fundamentals</a>.</p>
<p>If you're more interested in the fundamentals of the MVC design pattern, and how ASP.NET Core uses it to provide clean architectural templates for web applications, check out <em>ASP.NET Core MVC 2.0 Cookbook</em>, by Engin Polat and Stephane Belkheraz. That book can be found through Packt Publishing here: <a href="https://www.packtpub.com/application-development/aspnet-core-mvc-20-cookbook">https://www.packtpub.com/application-development/aspnet-core-mvc-20-cookbook</a>.</p>


            

            
        
    </body></html>