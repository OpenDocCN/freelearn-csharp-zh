- en: Chapter 3. Components and State Machines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 组件和状态机
- en: 'In the previous chapter, we learned about Unity''s interface, and the way things
    are organized and displayed in the Editor. You added a FSM to a game object and
    briefly looked at the interface elements related to Playmaker. You also manipulated
    game objects and components using such interface elements as the **Hierarchy**
    and **Inspector** panels, as well as the **Scene** view. In this chapter we will
    cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了Unity的界面，以及事物在编辑器中的组织和显示方式。你向一个游戏对象添加了一个有限状态机（FSM），并简要地查看与Playmaker相关的界面元素。你还使用诸如**层次结构**和**检查器**面板以及**场景**视图等界面元素来操作游戏对象和组件。在本章中，我们将涵盖以下内容：
- en: The Component-based approach to game development that Unity relies on
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity依赖的基于组件的游戏开发方法
- en: Game objects, components, and their properties in more detail
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏对象、组件及其属性的更详细内容
- en: The interchangeable nature of game objects when using components to define appearance
    and behavior
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件定义外观和行为时游戏对象的可互换性
- en: Finite state machines, actions, and transitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限状态机、动作和转换
- en: Making simple game mechanics using Playmaker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Playmaker制作简单的游戏机制
- en: Game objects, components, and properties
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏对象、组件和属性
- en: Unity works using a popular and common approach for game development, which
    is called the component-based architecture. This approach is widely used in software
    development to make things more reusable and easier to manage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用的是一种流行的游戏开发通用方法，称为基于组件的架构。这种方法在软件开发中被广泛使用，以使事物更具可重用性和易于管理。
- en: Let us talk about the way things are organized in Unity. Some of them have already
    been mentioned in previous chapters, but I will repeat them briefly so that you
    can see the game objects, components, and their properties in the larger context.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈在Unity中事物是如何组织的。其中一些已经在之前的章节中提到过，但我会简要重复一遍，这样你可以从更广泛的角度看到游戏对象、组件及其属性。
- en: First of all, you have a project, which is essentially a folder that contains
    all of the files and information about your game. Some of the files are called
    scenes (think of them as levels). A scene contains a number of game objects that
    you have added to it. The contents of your scenes are determined by you, and you
    can have as many of them as you want. You can also make your game switch between
    different scenes, thus making different sets of game objects active.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你有一个项目，本质上是一个文件夹，其中包含你游戏的所有文件和信息。其中一些文件被称为场景（可以将其视为关卡）。场景包含你添加到其中的多个游戏对象。场景的内容由你决定，你可以拥有尽可能多的场景。你也可以让游戏在不同的场景之间切换，从而激活不同的游戏对象集合。
- en: On a smaller scale, you have game objects and components. A game object by itself
    is simply an invisible container that does not do anything. Without adding appropriate
    components to it, it cannot, for instance, appear in the scene, receive input
    from the player, or move and interact with other objects. Using components, you
    can easily assemble powerful game objects while reusing several small parts, each
    responsible for a simple task or behavior—rendering the game object, handling
    the input, taking damage, playing an audio effect, and so on—making your game
    much simpler to develop and manage. Unity relies heavily on this approach, so
    the better you grasp it, the faster you will get good at it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在较小的尺度上，你有游戏对象和组件。一个游戏对象本身只是一个无形的容器，它什么也不做。如果不添加适当的组件，它就无法在场景中显示，接收玩家的输入，或者移动并与其他对象交互。使用组件，你可以轻松地组装功能强大的游戏对象，同时重用几个小型部件，每个部件负责一个简单的任务或行为——渲染游戏对象、处理输入、承受伤害、播放音效等——使你的游戏开发和管理变得更加简单。Unity高度依赖这种方法，所以你掌握得越好，你将越快地精通它。
- en: The only component that each and every game object in Unity has attached to
    it by default is **Transform**. It lets you define the game object's position,
    rotation, and scale. Normally, you can attach, detach, and destroy components
    in any given game object at will, but you cannot remove **Transform**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，每个游戏对象默认都附加了一个名为**变换（Transform）**的组件。它允许你定义游戏对象的位置、旋转和缩放。通常，你可以随意在任意游戏对象中附加、分离和销毁组件，但你不能移除**变换（Transform）**。
- en: 'Each component has a number of properties that you can access and change: these
    can be integer or floating point numbers, strings of text, textures, scripts,
    references to game objects or other components. They are used to change the way
    a certain component behaves, to influence its appearance or interaction. Some
    of the properties that you have already encountered in [Chapter 2](ch02.html "Chapter 2. Unity''s
    and Playmaker''s User Interface"), *Unity''s and Playmaker''s* *User Interface*,
    include the position, rotation, and scale properties of the **Transform** component.
    There are others that you have seen, including FSM, that we will talk about later
    in this chapter.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都有一些您可以访问和更改的属性：这些可以是整数或浮点数、文本字符串、纹理、脚本、游戏对象或其他组件的引用。它们用于更改特定组件的行为，影响其外观或交互。您在[第2章](ch02.html
    "第2章。Unity和Playmaker的用户界面")中已经遇到的某些属性，包括*Unity和Playmaker的用户界面*中的位置、旋转和缩放属性，**变换**组件。还有其他一些您已经看到，包括FSM，我们将在本章后面讨论。
- en: The following screenshot shows the **Wall** game object with the **Transform**,
    **Mesh Filter**, **Box Collider**, **Mesh Renderer**, and **Script** components
    attached to it. the properties of **Transform** are displayed. In order to reveal
    or hide a component's properties you need to left-click on its name or on the
    small arrow on the left of its icon.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了附加了**变换**、**网格过滤器**、**盒子碰撞器**、**网格渲染器**和**脚本**组件的**墙**游戏对象。显示了**变换**的属性。为了显示或隐藏组件的属性，您需要左键单击其名称或其图标左侧的小箭头。
- en: '![Game objects, components, and properties](img/8108OT_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![游戏对象、组件和属性](img/8108OT_03_01.jpg)'
- en: Unity has a number of predefined game objects that already have components attached
    to them, such as cameras, lights, and primitives. You can access them by choosing
    **GameObject** | **Create** from the main menu. Alternatively, you can create
    empty game objects by pressing *command* + *Shift* + *N* (*Ctrl* + *Shift* + *N*
    in Windows) and attach components to them using the **Components** submenu.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Unity有一些预定义的游戏对象，它们已经附加了组件，例如摄像机、灯光和原语。您可以通过从主菜单中选择**GameObject** | **创建**来访问它们。或者，您可以通过按*command*
    + *Shift* + *N* (*Ctrl* + *Shift* + *N* 在Windows上)创建空的游戏对象，并使用**组件**子菜单将组件附加到它们。
- en: The following figure shows the project structure that we have discussed. Note
    that there can be any number of scenes within a single project, any number of
    game objects within a single scene, any number of components attached to a single
    game object, and finally, any number of properties within a single component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了我们所讨论的项目结构。请注意，一个项目中可以有任意数量的场景，一个场景中可以有任意数量的游戏对象，一个游戏对象可以有任意数量的组件附加到它，最后，一个组件中可以有任意数量的属性。
- en: '![Game objects, components, and properties](img/8108OT_03_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![游戏对象、组件和属性](img/8108OT_03_02.jpg)'
- en: One final thing that you need to know about components right now is that you
    can copy them by right-clicking on the name of the component in the **Inspector**
    panel and selecting **Copy Component** from the contextual menu shown in the following
    screenshot. You can also reset the properties of the components to their default
    values, remove components, and move them up or down for your convenience.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前您需要了解的关于组件的最后一件事是，您可以通过在**检查器**面板中右键单击组件的名称，并从以下截图所示的上下文菜单中选择**复制组件**来复制它们。您还可以将组件的属性重置为其默认值，删除组件，或根据您的方便将其上下移动。
- en: '![Game objects, components, and properties](img/8108OT_03_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![游戏对象、组件和属性](img/8108OT_03_03.jpg)'
- en: The copied component can be pasted by right-clicking any component's name in
    the **Inspector** panel and selecting either **Paste Component As New** or **Paste
    Component Values** from the same contextual menu. The difference between these
    two commands is that the former will add a new component identical to the one
    that you have copied, while the latter will simply transfer the values of all
    the properties. These commands become active once you have copied a component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的组件可以通过在**检查器**面板中右键单击任何组件的名称，并从相同上下文菜单中选择**粘贴组件为新组件**或**粘贴组件值**来粘贴。这两个命令之间的区别在于，前者将添加一个与您复制的组件完全相同的新的组件，而后者将简单地传输所有属性的值。一旦您复制了组件，这些命令就会变为活动状态。
- en: Working with prefabs
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预制体
- en: In order to create multiple instances of a game object with the same components
    and properties, or access the same game object from different scenes, you can
    save it as a file in your `Assets` folder. These files are called prefabs in Unity
    and act like game object templates. To create an empty prefab, right-click on
    the empty space in the **Project** panel, then select **Create** | **Prefab**
    from the contextual menu. A new file called `New Prefab` should appear in the
    **Project** panel. Call this prefab `Wall`. Now create an empty folder called
    `Prefabs` and put the `Wall` prefab in this folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建具有相同组件和属性的多个游戏对象实例，或者从不同的场景访问相同的游戏对象，你可以将其保存为`Assets`文件夹中的一个文件。在Unity中，这些文件被称为预制件，它们就像游戏对象模板。要创建一个空预制件，在**项目**面板的空白区域右键单击，然后从上下文菜单中选择**创建**
    | **预制件**。应在**项目**面板中看到一个名为`New Prefab`的新文件。将此预制件命名为`Wall`。现在创建一个名为`Prefabs`的空文件夹，并将`Wall`预制件放入此文件夹中。
- en: Right now the prefab is empty.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目前预制件是空的。
- en: In the **Hierarchy** panel, select the **Wall** game object that you created
    in [Chapter 2](ch02.html "Chapter 2. Unity's and Playmaker's User Interface"),
    *Unity's and Playmaker's* *User Interface*. Click and drag it into the `Wall`
    prefab in the **Project** panel.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，选择你在[第2章](ch02.html "第2章。Unity和Playmaker的用户界面")中创建的**Wall**游戏对象，*Unity和Playmaker的用户界面*。点击并拖动它到**项目**面板中的`Wall`预制件。
- en: The name of the **Wall** game object will become blue in **Hierarchy**, and
    when you select the `Wall` prefab, you will see all of the components that the
    original **Wall** game object had in the **Inspector** panel.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Wall**游戏对象的名字在**层次结构**中会变成蓝色，当你选择`Wall`预制件时，你将在**检查器**面板中看到原始**Wall**游戏对象拥有的所有组件。'
- en: Now, if you drag-and-drop the `Wall` prefab into the scene, a new object called
    **Wall** will be created with exactly the same properties as those defined in
    the prefab.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将`Wall`预制件拖放到场景中，将创建一个名为**Wall**的新对象，其属性与预制件中定义的属性完全相同。
- en: Moreover, if you change some of the components and/or properties in the prefab
    using the **Inspector** panel, these changes will be automatically applied to
    all the instances of the prefab in the scene. This can save you a lot of time
    if you have multiple objects of the same type (that is, walls, monsters, trees,
    and so on) as you do not have to select them one-by-one in the **Hierarchy** and
    make the same changes multiple times.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你使用**检查器**面板更改预制件中的一些组件和/或属性，这些更改将自动应用于场景中该预制件的全部实例。如果你有多个相同类型的对象（即墙壁、怪物、树木等），这将为你节省大量时间，因为你不必在**层次结构**中逐个选择它们并多次进行相同的更改。
- en: You can also modify your prefab (and, by extension, all of its instances in
    the scene) by selecting one of the instances in **Hierarchy**, making your changes,
    and clicking the **Apply** button near the top of the **Inspector** panel. You
    can also undo all of the changes by clicking on the **Revert** button. This will
    reset the currently selected instance to the way its prefab was set up.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过选择**层次结构**中的一个实例，进行更改，并在**检查器**面板顶部附近点击**应用**按钮来修改你的预制件（以及由此扩展的场景中所有实例）。你还可以通过点击**还原**按钮撤销所有更改。这将将当前选定的实例重置为其预制件设置的方式。
- en: This works because, in fact, all the components and properties of an instance
    are linked to the ones of the prefab. Only when you change them in the instance
    they become unlinked, which means that further updates of that property on the
    prefab won't be applied to this instance. These unlinked properties can be distinguished
    because their name becomes bold in the **Inspector** panel. If you want to re-link
    a specific unlinked property you can right-click on it and select **Revert value
    to Prefab**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为实际上实例的所有组件和属性都链接到预制件的组件和属性。只有当你更改实例中的它们时，它们才会解除链接，这意味着对该属性在预制件上的进一步更新不会应用于此实例。这些解除链接的属性可以在**检查器**面板中通过其名称变为粗体来区分。如果你想重新链接一个特定的解除链接属性，你可以右键单击它并选择**将值还原为预制件**。
- en: 'Besides the **Apply** and **Revert** buttons, all prefab instances also have
    a **Select** button. This button lets you select and highlight the prefab corresponding
    to the currently selected instance in the **Project** panel, so you can access
    it more easily. Moreover, as we saw earlier, a prefab instance can be easily identified
    by its blue tinted name in the **Hierarchy** panel. The alternative way of creating
    a prefab is even simpler: you can simply drag-and-drop a game object from the
    **Hierarchy** panel into the **Project** panel. An appropriately named file will
    be created in the `Assets` folder.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**Apply**和**Revert**按钮外，所有预制件实例还有一个**Select**按钮。此按钮允许你选择并突出显示在**Project**面板中对应于当前选中实例的预制件，这样你可以更容易地访问它。此外，正如我们之前看到的，预制件实例可以通过**Hierarchy**面板中其蓝色的名称轻松识别。创建预制件的另一种方法甚至更简单：你可以直接将**Hierarchy**面板中的游戏对象拖放到**Project**面板中。在`Assets`文件夹中会创建一个适当命名的文件。
- en: 'Another very important thing to know about prefabs is that they can be copied
    and shared on the Web, since they are little more than the files recognized by
    Unity that contain information about components and properties. Now, follow these
    steps to modify the `Wall` prefab to suit our needs better:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于预制件，还有一件非常重要的事情需要了解，那就是它们可以在网络上进行复制和共享，因为它们不过是Unity识别的包含组件和属性信息的文件。现在，按照以下步骤修改`Wall`预制件以更好地满足我们的需求：
- en: Create a new folder in the **Project** panel and call it `Materials`. It will
    contain material files that contain information about textures, shaders, and colors
    of your game objects.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Project**面板中创建一个新的文件夹，并将其命名为`Materials`。它将包含包含游戏对象纹理、着色器和颜色的信息文件。
- en: Create a new material file by clicking on the **Create** button in the top-left
    corner of the **Project** panel and selecting **Material** from the drop-down
    list.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**Project**面板左上角的**Create**按钮，并从下拉列表中选择**Material**来创建一个新的材质文件。
- en: Name the new material `WallMaterial` and put it inside the `Materials` folder.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新材质命名为`WallMaterial`并将其放入`Materials`文件夹中。
- en: Select **WallMaterial** in the **Project** panel, then in **Inspector**, click
    on the rectangle next to the text that says **Main Color**. In the **Color** window
    that appears, select the black color and close the **Color** window. The following
    screenshot shows the **Material** modification interface as well as the **Color**
    window:![Working with prefabs](img/8108OT_03_04.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Project**面板中选择**WallMaterial**，然后在**Inspector**中点击文本旁边带有**Main Color**字样的矩形。在出现的**Color**窗口中，选择黑色并关闭**Color**窗口。以下截图显示了**Material**修改界面以及**Color**窗口：![使用预制件](img/8108OT_03_04.jpg)
- en: Now that you have this new material set up, select the `Wall` prefab, then drag-and-drop
    **WallMaterial** into the **Element 0** element of the **Materials** property
    of the prefab's **Mesh Renderer** component. It should replace **Default Diffuse**.
    The following screenshot shows what the **Mesh Renderer** component should look
    like once your are done assigning the new material.![Working with prefabs](img/8108OT_03_05.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经设置了这种新材料，选择`Wall`预制件，然后将**WallMaterial**拖放到预制件**Mesh Renderer**组件的**Materials**属性的**Element
    0**元素中。它应该替换**Default Diffuse**。以下截图显示了分配新材料后**Mesh Renderer**组件应有的样子。![使用预制件](img/8108OT_03_05.jpg)
- en: Now all of the instances of the `Wall` prefab will be black.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，所有`Wall`预制件的实例都将变为黑色。
- en: Also, set the X scale property of the **Transform** component to `15`. This
    will make all the new walls longer.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将**Transform**组件的X缩放属性设置为`15`。这将使所有新墙变得更长。
- en: Select the **Main Camera** game object and set its **Projection** property of
    the **Camera** component to **Orthographic** using the **Inspector** panel. This
    will make the view of the camera flat; the game view will now appear two-dimensional.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Main Camera**游戏对象，并使用**Inspector**面板将其**Camera**组件的**Projection**属性设置为**Orthographic**。这将使摄像机的视图变得扁平；现在游戏视图将呈现二维。
- en: Set the **Size** property to `5`. You can adjust the look later, but for now
    this will help us focus on gameplay.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Size**属性设置为`5`。你可以稍后调整外观，但就目前而言，这将帮助我们专注于游戏玩法。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is often a good idea to restrict yourself to simple primitives, color-coded
    untextured materials, and orthographic projection cameras in the beginning of
    the design process, because it will let you focus on gameplay. This way, if your
    game is fun, you will know about it, and if it is not, you will not get distracted
    by fancy visuals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计过程的初期，限制自己使用简单的原始形状、彩色编码的无纹理材质和正交投影相机通常是一个好主意，因为这会让你专注于游戏玩法。这样，如果你的游戏很有趣，你就会知道，如果它不好，你也不会被花哨的视觉效果所分散注意力。
- en: Make four walls and arrange them in the scene so that what you see in the **Game**
    view looks like the following screenshot. If this is not the case, you can go
    back to the table in [Chapter 2](ch02.html "Chapter 2. Unity's and Playmaker's
    User Interface"), *Unity's and Playmaker's* *User Interface*, and see if your
    **Main Camera** game object is positioned and rotated correctly. Its position
    should be set to (`0`, `10`, `0`) and rotation to (`90`, `0`, `0`). Don't forget
    that you can rotate the objects to precise values such as `90` and `180` degrees
    by changing their rotation angle in the **Transform** component. Also make sure
    that the Y position of all the walls remains equal to `0.5`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 制作四个墙壁并将它们在场景中排列，以便你在**Game**视图中看到以下截图。如果不是这样，你可以回到[第2章](ch02.html "第2章。Unity和Playmaker的用户界面")的表格，*Unity和Playmaker的用户界面*，看看你的**Main
    Camera**游戏对象是否定位和旋转正确。其位置应设置为(`0`, `10`, `0`)，旋转为(`90`, `0`, `0`)。别忘了，你可以通过在**Transform**组件中更改旋转角度将对象旋转到精确值，例如`90`度和`180`度。同时确保所有墙壁的Y位置保持等于`0.5`。
- en: '![Working with prefabs](img/8108OT_03_06.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![与预制体一起工作](img/8108OT_03_06.jpg)'
- en: Finite state machines, states, and actions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限状态机、状态和动作
- en: We have talked about game objects and components. Now it is time to have a look
    at Playmaker FSMs, states, and actions in them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了游戏对象和组件。现在，让我们看看Playmaker中的FSM、状态和动作。
- en: An FSM in Playmaker is a graph that consists of states and transitions between
    them, attached to a game object. It allows for a way of visual programming using
    different states of the graph and events that trigger transitions to other states.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Playmaker中的FSM是一个由状态和它们之间的转换组成的图，附加到一个游戏对象上。它允许使用图的不同状态和触发转换到其他状态的事件进行可视化编程。
- en: 'If you select the `Wall` prefab and open the **playMaker** panel, you will
    see that its FSM has two states: the default **Start** state where everything
    begins and another one called **State 1** by default, with an arrow connecting
    the former to the latter. The arrow is a transition. You cannot remove the Start
    state or the one it is connected to, because if you could you would not need the
    FSM attached to the object. However, you can create new states and define transitions
    to them.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了`Wall`预制体并打开**playMaker**面板，你会看到它的有限状态机（FSM）有两个状态：默认的**Start**状态，一切从这里开始，另一个默认称为**State
    1**的状态，通过一个箭头将前者连接到后者。箭头代表一个转换。你不能移除Start状态或与之相连的状态，因为如果你能这样做，你就不需要将FSM附加到对象上了。然而，你可以创建新的状态并为它们定义转换。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can navigate the FSM view almost exactly the same way you would do the **Scene**
    view. Use the middle mouse button to drag the view. Use the left mouse button
    to move the states around. This does not change anything in the logic of the state
    machine, but lets you organize everything the way that makes sense to you, as
    well as look at the parts of the graph that you are most interested in at the
    moment if the whole state machine is too big to be shown at once.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以几乎以与**Scene**视图相同的方式导航FSM视图。使用中间鼠标按钮拖动视图。使用左鼠标按钮移动状态。这不会改变状态机的逻辑，但让你以对你有意义的方式组织一切，同时如果你整个状态机太大而无法一次性显示，还可以查看你此刻最感兴趣的部分。
- en: A state in FSM is empty by default and does not do anything, a lot like an empty
    game object without any components attached to it. In order to make a state do
    something, you need to attach actions to it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: FSM中的状态默认为空，不做任何事情，就像一个没有任何组件附加的空游戏对象。为了使状态执行某些操作，你需要将其附加到动作。
- en: As we have seen in [Chapter 2](ch02.html "Chapter 2. Unity's and Playmaker's
    User Interface"), *Unity's and Playmaker's* *User Interface*, you can add an FSM
    to an object by selecting the latter, right-clicking in the FSM view of the **playMaker**
    panel, and then selecting **Add FSM** from the contextual menu. You can remove
    an object from the Playmaker control by right-clicking the header of the Playmaker
    FSM (**Script**) component in **Inspector** and selecting **Remove Component**
    from the contextual menu. This will remove the FSM and erase all of the changes
    you made to it, including added states and transitions. An object has an FSM attached
    to it if there is a red Playmaker hieroglyph icon (![Finite state machines, states,
    and actions](img/8108OT_03_07.jpg)) next to its name in the **Hierarchy** panel.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.html "第2章. Unity和Playmaker的用户界面")中看到的，*Unity和Playmaker的用户界面*，你可以通过选择对象，在**playMaker**面板的FSM视图中右键单击，然后从上下文菜单中选择**Add
    FSM**来向对象添加一个FSM。你可以通过在**Inspector**中右键单击**playMaker FSM（Script）**组件的标题并从上下文菜单中选择**Remove
    Component**来从Playmaker控制中移除对象。这将移除FSM并擦除你对它所做的所有更改，包括添加的状态和转换。如果一个对象附加了FSM，那么在**Hierarchy**面板中它的名称旁边会有一个红色的Playmaker象形图标
    (![有限状态机、状态和动作](img/8108OT_03_07.jpg))。
- en: As an example for this book, we will be making a version of the classic air
    hockey game. In order to begin, we will need to add a puck and a mallet. In this
    chapter, you will make the mallet move based on the mouse position and push the
    puck as you would expect it to do in real life.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的一个示例，我们将制作一个经典的空气桌球游戏版本。为了开始，我们需要添加一个冰球和一个球杆。在本章中，你将根据鼠标位置移动球杆，并像在现实生活中那样推动冰球。
- en: Right now in your scene there are four walls, a background quad, a camera, and
    a directional light (created in [Chapter 2](ch02.html "Chapter 2. Unity's and
    Playmaker's User Interface"), *Unity's and Playmaker's User Interface*). Now it
    is time to make things interactive. Let us start with a mallet.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在你的场景中有四面墙，一个背景四边形，一个摄像机和一个方向性光源（在[第2章](ch02.html "第2章. Unity和Playmaker的用户界面")中创建，*Unity和Playmaker的用户界面*)。现在是我们使事物变得交互的时候了。让我们从球杆开始。
- en: Create a new cylinder primitive by selecting **GameObject** | **Create Other**
    | **Cylinder** in the main menu.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中选择**GameObject** | **Create Other** | **Cylinder**来创建一个新的圆柱形原形。
- en: Rename this game object to `Mallet` and make a dark green (RGB color set to
    `10`, `155`, `10` in the **Color** window) material called **MalletMaterial**
    for it, then assign the material to it, as you did for the `Wall` prefab before.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个游戏对象重命名为`Mallet`，并为它创建一个深绿色（在**Color**窗口中RGB颜色设置为`10`，`155`，`10`）的材料，命名为**MalletMaterial**，然后将其分配给它，就像之前为`Wall`预制体所做的那样。
- en: Set the scale of **Mallet** to (`1.35`, `1.35`, `1.35`) and its position to
    (`-6.5`, `1.45`, `0`).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Mallet**的缩放设置为(`1.35`，`1.35`，`1.35`)，并将其位置设置为(`-6.5`，`1.45`，`0`)。
- en: Now we are going to make the mallet move. First of all, we need to add a component
    called **Character Controller** to it. This component is in charge of character
    physics. Select **Mallet**, then click on the **Add Component** button near the
    bottom of the **Inspector** panel. Type `Character Controller` in the search bar,
    and then double-click on the **Character Controller** item in the list (as shown
    in the following screenshot). When Unity asks you if you want to replace the existing
    **CapsuleCollider** component, click on **Replace**.![Finite state machines, states,
    and actions](img/8108OT_03_08.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使球杆移动。首先，我们需要向它添加一个名为**Character Controller**的组件。这个组件负责角色物理。选择**Mallet**，然后在**Inspector**面板底部附近点击**Add
    Component**按钮。在搜索栏中输入`Character Controller`，然后在列表中双击**Character Controller**项（如图所示）。当Unity询问你是否要替换现有的**CapsuleCollider**组件时，点击**Replace**。![有限状态机、状态和动作](img/8108OT_03_08.jpg)
- en: In the **Character Controller** component, set the **Skin Width** property to
    `0` (it will be set to the minimum possible value, which is `0.0001`). We are
    doing this to make sure that our mallet's collisions look precise.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Character Controller**组件中，将**Skin Width**属性设置为`0`（它将被设置为可能的最小值，即`0.0001`）。我们这样做是为了确保我们的球杆碰撞看起来精确。
- en: Add an FSM to Mallet by selecting it, right-clicking in the FSM view of the
    **playMaker** panel, and selecting **Add FSM** from the contextual menu.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择球杆，在**playMaker**面板的FSM视图中右键单击，并从上下文菜单中选择**Add FSM**来向球杆添加一个FSM。
- en: Select **State 1**, then in the **State** tab on the right of the **playMaker**
    panel enter `Move` in the first text field from the top. It is responsible for
    the name of the currently selected state. When you enter the new name, you should
    see the state change in the FSM view as well.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**状态1**，然后在**playMaker**面板右侧的**状态**选项卡中，从顶部第一个文本框输入`Move`。这负责当前选中状态的名称。当您输入新名称时，您应该会看到FSM视图中状态的变化。
- en: Keeping the **Move** state selected, open the **Actions** panel (it should be
    attached to the same area of the **Editor** window as the **Inspector** panel;
    alternatively, click on the **Action Browser** button on the bottom-right of the
    **State** tab) and find the **Mouse Pick** action under the **Input** category.
    Click on it, then click on the **Add Action To State** button in the bottom-right
    corner of the panel. You should notice that the **Mouse Pick** action appeared
    in the **State** tab of the **playMaker** panel.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持**移动**状态选中，打开**动作**面板（它应附加在**检查器**面板相同的区域；或者，点击**状态**选项卡右下角的**动作浏览器**按钮）并找到**输入**类别下的**鼠标拾取**动作。点击它，然后点击面板右下角的**将动作添加到状态**按钮。您应该会注意到**鼠标拾取**动作出现在**playMaker**面板的**状态**选项卡中。
- en: This action gets the cursor position in 3D space when you hover an object. Under
    the hood it draws an invisible ray (this action is called **raycast**) from the
    mouse position on the camera's near clipping plane (you can see it as one of the
    white gizmo rectangles in the **Scene** view when you select **Main Camera**).
    If there is something in the way of the ray, a ray hit gets detected, and Unity
    finds out where exactly it happened. In our case, we will use the background quad
    to get the position of the mouse cursor, and then make the mallet follow it.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此操作在您悬停在对象上时获取3D空间中的光标位置。在底层，它会从鼠标位置在相机的近裁剪平面（当您选择**主相机**时，您可以在**场景**视图中将其视为白色工具箱矩形之一）绘制一条不可见的射线（此操作称为**射线投射**）。如果射线路径上有物体，则会检测到射线碰撞，Unity会找出碰撞的确切位置。在我们的例子中，我们将使用背景四边形来获取鼠标光标的位置，然后使球槌跟随它。
- en: In order to pick a correct ray-hit position, we need to make sure that nothing
    else gets in the way of the ray. To do this, we will tell the ray to interact
    only with the background quad. Select the **Quad** game object and rename it `Background`
    for clarity. Then find the **Layer** drop-down menu in the top-right corner of
    the **Inspector** panel, click on the drop-down button that says **Default** by
    default, and press **Add Layer…** in it. The appearance of **Inspector** should
    now change to reveal a list of tags and layers as shown in the following screenshot:![Finite
    state machines, states, and actions](img/8108OT_03_09.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了选择正确的射线碰撞位置，我们需要确保没有其他物体阻挡射线。为此，我们将告诉射线仅与背景四边形交互。选择**四边形**游戏对象，并将其重命名为`Background`以提高可读性。然后找到**检查器**面板右上角的**层**下拉菜单，点击默认情况下显示为**默认**的下拉按钮，并在其中按下**添加层…**。此时，**检查器**的外观应发生变化，以显示如图所示的标签和层列表：![有限状态机、状态和动作](img/8108OT_03_09.jpg)
- en: This menu is called **TagManager**. Click on the right of **User Layer 8** and
    enter `Background` in the edit field that appears, then press *Return* on your
    keyboard. Select the **Background** object again and set its layer to **Background**
    by choosing the appropriate element from the drop-down **Layer** list you used
    to access the **TagManager** before.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此菜单称为**标签管理器**。点击**用户层8**的右侧，并在出现的编辑字段中输入`Background`，然后按键盘上的*Return*键。再次选择**背景**对象，并通过从您之前用于访问**标签管理器**的下拉**层**列表中选择适当的元素，将其层设置为**背景**。
- en: Select **Mallet** again. In the **Mouse Pick** action of the **Move** state,
    set the **Layer Mask** parameter to `1`. This determines how many layers you will
    set to interact with the raycast. **Element 0** should appear below. In the drop-down
    list to its right, select the **Background** layer you created before.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择**球槌**。在**移动**状态下的**鼠标拾取**操作中，将**层掩码**参数设置为`1`。这决定了您将设置多少层与射线交互。**元素0**应出现在下方。在其右侧的下拉列表中，选择您之前创建的**背景**层。
- en: 'From now on, the raycast in the **Mouse Pick** action will ignore all objects
    that are not in the **Background** layer. Now we need to store the ray-hit position
    in a variable. Go to the **Variable** tab of the **playMaker** panel and enter
    `mousePos` in the **New Variable** field on the bottom. Click on the **Add** button.
    Set the **Variable Type** to **Vector3**. A **Vector 3** variable contains three
    numbers: **X**, **Y**, and **Z**.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在开始，**鼠标拾取**动作中的射线投射将忽略不在**背景**层的所有对象。现在我们需要将射线击中位置存储在一个变量中。转到**playMaker**面板的**变量**选项卡，在底部的**新变量**字段中输入`mousePos`。点击**添加**按钮。将**变量类型**设置为**Vector3**。一个**Vector
    3**变量包含三个数字：**X**、**Y**和**Z**。
- en: Go back to the **State** tab and set the **Store Point** property of the **Mouse
    Pick** action to **mousePos**. This will save the position of the ray hit in the
    **Vector3** type variable that you just created. Finally, check the **Every Frame**
    property checkbox on the bottom of the **Mouse Pick** action to make sure that
    the mouse position is updated continuously as opposed to just once in the beginning
    of the game.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**状态**选项卡，并将**鼠标拾取**动作的**存储点**属性设置为**mousePos**。这将保存射线击中的位置在您刚刚创建的**Vector3**类型变量中。最后，确保在**鼠标拾取**动作的底部勾选**每帧**属性复选框，以确保鼠标位置持续更新，而不是仅在游戏开始时更新一次。
- en: Add the action called **Controller Simple Move** located under the **Character**
    category of the **Actions** panel to your **Move** state. It should appear just
    below the **Mouse Pick** action. If it appears above it, you can move it down
    by clicking and dragging it by its header.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位于**动作**面板**角色**类别下的**控制器简单移动**动作添加到您的**移动**状态。它应该出现在**鼠标拾取**动作下方。如果它出现在上方，你可以通过点击并拖动其标题将其向下移动。
- en: 'It is important to note that the order of actions in the state matters: the
    actions mentioned earlier will be executed before the ones that are mentioned
    later, so if you want to use a variable set in the **Mouse Pick** action, you
    must make sure that **Mouse Pick** is above whatever action is going to use it
    (in our case it is **Controller Simple Move**).'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要注意的是，状态中动作的顺序很重要：前面提到的动作将在后面提到的动作之前执行，所以如果你想使用在**鼠标拾取**动作中设置的变量，你必须确保**鼠标拾取**在将要使用它的任何动作之上（在我们的例子中是**控制器简单移动**）。
- en: Set the **Move Vector** property of the **Controller Simple Move** action to
    **mousePos**. Leave the rest of the properties at their default values.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**控制器简单移动**动作的**移动向量**属性设置为**mousePos**。将其他属性保留为默认值。
- en: Interaction between game objects
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏对象之间的交互
- en: Now that the mallet moves, we are going to make it interact with a puck. When
    the mallet touches the puck, we are going to apply a force to it in the opposite
    direction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在球槌可以移动了，我们将让它与球体交互。当球槌接触到球体时，我们将对其施加一个相反方向的力。
- en: You can click the Play button in the toolbar and see how the mallet moves based
    on the mouse position. You will notice that it collides with the walls, follows
    the mouse cursor smoothly, and changes its movement speed based on how fast and
    far you move your mouse.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击工具栏中的播放按钮，看看球槌如何根据鼠标位置移动。你会注意到它会与墙壁发生碰撞，平滑地跟随鼠标光标，并根据你移动鼠标的速度和距离改变其移动速度。
- en: Create another cylinder called **Puck** and place it in (`-3`, `0.85`, `0`).
    Set its scale to (`1`, `0.7`, `1`).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为**Puck**的圆柱体，并将其放置在(`-3`, `0.85`, `0`)的位置。将其比例设置为(`1`, `0.7`, `1`)。
- en: Add a **Rigidbody** component to it (**Component | Physics | Rigidbody**). Set
    the **Mass** property to `0.1`, uncheck **Use Gravity**, open the **Constraints**
    section, and check **Freeze Position Y** and **Freeze Rotation X**, **Y** and
    **Z**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加一个**Rigidbody**组件（**组件 | 物理 | Rigidbody**）。将**质量**属性设置为`0.1`，取消勾选**使用重力**，打开**约束**部分，并勾选**冻结位置Y**和**冻结旋转X**、**Y**和**Z**。
- en: Make a new dark grey (`65`, `60`, `60`) material (**Assets** | **Create** |
    **Material**) called **PuckMaterial** and assign it to the puck's **Mesh Renderer**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的深灰色（`65`, `60`, `60`）材质（**资产** | **创建** | **材质**），命名为**PuckMaterial**，并将其分配给圆柱体的**Mesh
    Renderer**。
- en: Now that the puck is all set, we will make the mallet push it. Go to the mallet's
    **Move** state in FSM and add an action called **Collision Event** (under Physics)
    to it. Set the **Collision** property to **On Controller Collider Hit**.![Interaction
    between game objects](img/8108OT_03_10.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在球体已经设置好了，我们将让球槌推动它。转到FSM中球槌的**移动**状态，并添加一个名为**碰撞事件**（在物理类别下）的动作。将**碰撞**属性设置为**控制器碰撞器击中**。![游戏对象之间的交互](img/8108OT_03_10.jpg)
- en: Open **TagManager** by selecting the **Puck** game object and choosing **Add
    Tag...** from the **Tag** drop-down menu in **Inspector**. Create a tag called
    **Puck** by adding a new tag the same way you did with a layer for the background.
    Tags are situated near the top of **TagManager**. You can have as many as you
    want if you modify the **Size** variable. Set the **Puck** game object's tag to
    **Puck**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**Puck**游戏对象并在**检查器**的**标签**下拉菜单中选择**添加标签...**来打开**TagManager**。以与为背景层添加标签相同的方式添加一个名为**Puck**的新标签。标签位于**TagManager**的顶部附近。如果您修改**大小**变量，可以拥有任意数量的标签。将**Puck**游戏对象的标签设置为**Puck**。
- en: Go back to the **Move** state in Mallet's FSM. Set the **Collide Tag** property
    of the **Collision Event** action to **Puck**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到球槌的FSM中的**移动**状态。将**碰撞标签**属性设置为**Puck**的**碰撞事件**动作。
- en: Open the **Events** tab in the **playMaker** panel, enter `Push` in the **Add
    Event** field near the bottom of the tab, and press *Return* on your keyboard.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**playMaker**面板中打开**事件**选项卡，在选项卡底部的**添加事件**字段中输入`Push`，然后按键盘上的*Enter*键。
- en: Open the **State** tab again and set the **Send Event** property of the **Collision
    Event** action to **Push**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开**状态**选项卡，并将**Collision Event**动作的**发送事件**属性设置为**Push**。
- en: Now we have to tell the FSM what will happen once the event is called. Create
    a new state in the Mallet's FSM by right-clicking anywhere in the FSM view and
    selecting **Add State** from the context menu. Name the new state `Push Puck`.
    Right-click on the **Move** state in the FSM view and select **Add Transition**
    | **Push** from the contextual menu. A new light label saying **Push** should
    appear below the **Move** state. Click on it and drag the line that appears to
    the **Push Puck** state. This line is the transition that will happen once the
    **Push** event is called in the **Move** state. Add a **FINISHED** event to the
    **Push Puck** state the same way. You do not need to create it, because it is
    a default Playmaker event.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须告诉FSM事件调用后会发生什么。通过在FSM视图中任何位置右键单击并从上下文菜单中选择**添加状态**来在球槌的FSM中创建一个新状态。将新状态命名为`Push
    Puck`。在FSM视图中右键单击**移动**状态并从上下文菜单中选择**添加转换** | **Push**。在**移动**状态下方应出现一个新的标签**Push**。单击它并将出现的线条拖动到**Push
    Puck**状态。这条线是当在**移动**状态中调用**Push**事件时发生的转换。以相同的方式向**Push Puck**状态添加一个**FINISHED**事件。您不需要创建它，因为它是一个默认的Playmaker事件。
- en: Make a transition from the **FINISHED** event to the **Move** state to make
    sure that when the puck is pushed the mallet will remain under the player's control.
    The following figure shows what your FSM is supposed to look like:![Interaction
    between game objects](img/8108OT_03_11.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**FINISHED**事件到**移动**状态创建一个转换，以确保当球被推时，球槌将保持在玩家的控制之下。以下图显示了您的FSM应该看起来像什么：![游戏对象之间的交互](img/8108OT_03_11.jpg)
- en: 'Add the following actions to the **Push Puck** state in Mallet''s FSM one-by-one:
    **Get Controller Hit Info**, **Get Position**, **Vector3 Subtract**, **Vector3
    Normalize**, **Vector3 Multiply**, and **Add Force**. Keep in mind that the order
    of the actions matters, because the ones higher on the list will get executed
    earlier. The following screenshot shows the correct order of the actions.![Interaction
    between game objects](img/8108OT_03_13.jpg)'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下动作逐个添加到球槌的FSM中的**Push Puck**状态：**Get Controller Hit Info**，**Get Position**，**Vector3
    Subtract**，**Vector3 Normalize**，**Vector3 Multiply**，和**Add Force**。请注意动作的顺序很重要，因为列表上方的动作将先执行。以下截图显示了动作的正确顺序。![游戏对象之间的交互](img/8108OT_03_13.jpg)
- en: 'Create the following variables using the **Variables** tab of the **playMaker**
    panel: **hitPos** (**Vector3**), **pushDir** (**Vector3**), **pushMag** (**Float**).
    Select **pushMag** and set its **Float Value** to `20`. This value will determine
    how hard the mallet pushes the puck.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**playMaker**面板的**变量**选项卡创建以下变量：**hitPos**（**Vector3**），**pushDir**（**Vector3**），**pushMag**（**Float**）。选择**pushMag**并将其**浮点值**设置为`20`。此值将决定球槌推球的力度。
- en: Back in the **State** tab, set the **Contact Point** property of **Get Controller
    Hit Info** action to **hitPos**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**状态**选项卡，将**Get Controller Hit Info**动作的**接触点**属性设置为**hitPos**。
- en: Drag the **Puck** game object from **Hierarchy** to the **Game Object** slot
    of the **Get Position** action, then set **Vector** to **pushDir**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Puck**游戏对象从**层次结构**拖动到**Get Position**动作的**游戏对象**槽中，然后将**向量**设置为**pushDir**。
- en: In **Vector3 Subtract** action, set **Vector3 Variable** to `pushDir`. Click
    on the small option (![Interaction between game objects](img/8108OT_03_12.jpg))
    icon next to **Subtract Vector**. This will allow you to pick a variable from
    the list instead of using a numeric value. Set **Subtract Vector** to `hitPos`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Vector3 Subtract**动作中，将**Vector3 变量**设置为`pushDir`。点击**Subtract Vector**旁边的选项图标（![游戏对象之间的交互](img/8108OT_03_12.jpg)）。这将允许你从列表中选择一个变量，而不是使用数值。将**Subtract
    Vector**设置为`hitPos`。
- en: In **Vector3 Normalize** action, set **Vector3 Variable** to **pushDir**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Vector3 Normalize**动作中，将**Vector3 变量**设置为**pushDir**。
- en: In **Vector3 Multiply** action, set **Vector3 Variable** to **pushDir** and
    **Multiply By** to **pushMag**. Click on the small option icon to show the FSM
    variables if needed.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Vector3 Multiply**动作中，将**Vector3 变量**设置为**pushDir**，并将**乘以**设置为**pushMag**。如果需要，点击小选项图标以显示FSM变量。
- en: Finally, in **Add Force**, set the **Game Object** property to **Specify Game
    Object** and drag the **Puck** game object into the slot that will appear below.
    Set **Vector** to **pushDir**. Click on the option icons next to **X**, **Y**,
    and **Z** and leave them at **None** to make sure they are not reset to `0` and
    are simply not assigned instead. Click the small option icon to show the **None**
    option if needed. Then set **Space** to **World**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**添加力**中，将**游戏对象**属性设置为**指定游戏对象**，并将**Puck**游戏对象拖动到下方出现的槽位中。将**向量**设置为**pushDir**。点击**X**、**Y**和**Z**旁边的选项图标，并保持它们在**无**状态，以确保它们不会被重置为`0`，而是简单地没有分配。如果需要，点击小选项图标以显示**无**选项。然后设置**空间**为**世界**。
- en: Your puck should now become interactive if you click on play and make the Mallet
    collide with it. I realize that the last bit was a lot of actions at once, so
    we will discuss what exactly happens in those actions in the next chapter. This
    is an example of some complex logic that we will look into when we talk more about
    game mechanics. For now consider it an exercise to familiarize yourself with actions
    and variables and the way they are added and assigned in the **playMaker** panel.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击播放并使球棒与它碰撞，你的球现在应该变得可交互。我意识到最后一点同时有很多动作，所以我们将在下一章中讨论这些动作中确切发生了什么。这是一个我们在讨论游戏机制时将要探讨的一些复杂逻辑的例子。现在，将其视为一个熟悉动作和变量以及它们在**playMaker**面板中添加和分配方式的练习。
- en: As another exercise, save your scene, create a few new game objects with FSMs,
    and try to experiment with different actions and variables, see how they are added
    and assigned. Don't worry if your actions do not do much. Try to familiarize yourself
    with the Playmaker interface and remember how to add, move, and remove actions,
    create new variables and events, and assign them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个练习，保存你的场景，创建几个带有FSM的新游戏对象，并尝试实验不同的动作和变量，看看它们是如何添加和分配的。如果你的动作没有做什么，不要担心。尝试熟悉Playmaker界面，并记住如何添加、移动和删除动作，创建新的变量和事件，并将它们分配。
- en: Once you feel like you are comfortable with these actions, you can delete the
    objects you used for practice or simply reload the scene without saving it by
    double-clicking the `Scene1` file in the **Project** panel.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你觉得对这些动作很熟悉，你可以删除你用于练习的对象，或者简单地通过在**项目**面板中双击`Scene1`文件来重新加载场景而不保存它。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed the project structure in Unity: scenes, game
    objects, components, and properties. We also took a closer look at the Playmaker
    interface: actions, events, variables, and transitions. You took the first step
    in creating an air hockey game by implementing a real game mechanic—a mallet that
    is moved with the mouse and a puck that is pushed when the mallet touches it.
    In the next chapter, we will add even more game mechanics, explain the ones already
    implemented in more detail, and try to make the game more fun and pretty.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Unity中的项目结构：场景、游戏对象、组件和属性。我们还更详细地了解了Playmaker界面：动作、事件、变量和转换。你通过实现一个用鼠标移动的球棒和一个当球棒接触时被推动的球，迈出了创建冰球游戏的第一步——一个真正的游戏机制。在下一章中，我们将添加更多的游戏机制，更详细地解释已经实现的游戏机制，并尝试使游戏更加有趣和美观。
