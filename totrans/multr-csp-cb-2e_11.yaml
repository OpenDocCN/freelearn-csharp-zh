- en: Chapter 11. There's More
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。还有更多
- en: 'In this chapter, we will look through a new programming paradigm in the Windows
    10 operating system. Also, you will learn how to run .NET programs on OS X and
    Linux. You will learn the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Windows 10 操作系统中的一个新的编程范式。此外，你还将学习如何在 OS X 和 Linux 上运行 .NET 程序。在本章中，你将学习以下食谱：
- en: Using a timer in a Universal Windows Platform application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通用 Windows 平台应用程序中使用计时器
- en: Using WinRT from usual applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在常规应用程序中使用 WinRT
- en: Using `BackgroundTask` in Universal Windows Platform applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通用 Windows 平台应用程序中使用 `BackgroundTask`
- en: Running a .NET Core application on OS X
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OS X 上运行 .NET Core 应用程序
- en: Running a .NET Core application on Ubuntu Linux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 上运行 .NET Core 应用程序
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Microsoft released the first public beta build of Windows 8 at the Build conference
    on September 13, 2011\. The new OS tried to address almost every problem that
    Windows had by introducing features such as a responsive UI suitable for tablet
    devices with touch, lower power consumption, a new application model, new asynchronous
    APIs, and tighter security.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 微软于 2011 年 9 月 13 日在 Build 大会上发布了 Windows 8 的第一个公开测试版。新的操作系统通过引入响应式 UI（适用于具有触摸功能的平板电脑设备）、降低功耗、新的应用程序模型、新的异步
    API 和更严格的安全性等特性，试图解决 Windows 几乎所有的问题。
- en: The core of Windows API improvements was a new multiplatform component system,
    **WinRT**, which is a logical development of COM. With WinRT, a programmer can
    use native C++ code, C# and .NET, and even JavaScript and HTML to develop applications.
    Another change is the introduction of a centralized application store, which did
    not exist on the Windows platform before.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Windows API 改进的核心是一个新的多平台组件系统，**WinRT**，它是 COM 的逻辑发展。使用 WinRT，程序员可以使用原生 C++
    代码、C# 和 .NET，甚至 JavaScript 和 HTML 来开发应用程序。另一个变化是引入了一个集中的应用程序商店，这在 Windows 平台上之前是不存在的。
- en: 'Being a new application platform, Windows 8 had backward compatibility and
    allowed us to run the usual Windows applications. This lead to a situation where
    there were two major classes of applications: the Windows Store applications,
    where new programs are distributed via the Windows Store, and the usual classic
    applications that had not changed since the previous version of Windows.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个新的应用程序平台，Windows 8 具有向后兼容性，并允许我们运行常规的 Windows 应用程序。这导致了一种情况，即存在两个主要的应用程序类别：Windows
    Store 应用程序，新程序通过 Windows Store 分发，以及自 Windows 前一个版本以来没有改变的常规经典应用程序。
- en: However, Windows 8 was only the first step toward the new application model.
    Microsoft got a lot of feedback from the users, and it became clear that Windows
    Store applications were too different from what people were used to. Besides that,
    there was a separate smartphone OS, Windows 8 Phone, that had a different application
    store and a slightly different set of APIs. This made an application developer
    create two separate applications for desktop and smartphone platforms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Windows 8 只是向新的应用程序模型迈出的第一步。微软从用户那里收到了很多反馈，并且很明显，Windows Store 应用程序与人们习惯的太不同了。除此之外，还有一个独立的智能手机操作系统，Windows
    8 Phone，它有一个不同的应用程序商店和略微不同的 API 集合。这使得应用程序开发者必须为桌面和智能手机平台创建两个独立的应用程序。
- en: To improve the situation, the new Windows 10 OS was introduced as a unified
    platform for all Windows-powered devices. There is a single application store
    that supports every device family, and now, it is possible to create an application
    that works on phones, tablets, and desktops. Thus, Windows Store applications
    are now called Universal Windows Platform applications (UWP apps). This, of course,
    means a lot of limitations for your application—it should not use any platform-specific
    APIs, and as a programmer, you have to comply with specific rules. The program
    has to respond in a limited time to start up or to finish, keeping the whole operating
    system and other applications responsive. To save the battery, your applications
    are no longer running in the background by default; instead of that, they get
    suspended and actually stop executing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善这种情况，新的 Windows 10 操作系统被引入作为一个统一的所有 Windows 设备的平台。有一个单一的应用程序商店支持每个设备系列，现在，创建一个可以在手机、平板电脑和桌面电脑上运行的应用程序成为可能。因此，Windows
    Store 应用程序现在被称为通用 Windows 平台应用程序（UWP 应用程序）。这当然意味着你的应用程序会有很多限制——它不应该使用任何平台特定的 API，作为一个程序员，你必须遵守特定的规则。程序必须在有限的时间内响应启动或完成，以保持整个操作系统和其他应用程序的响应。为了节省电池，你的应用程序默认不再在后台运行；相反，它们被挂起并实际上停止执行。
- en: New Windows APIs are asynchronous, and you can only use whitelisted API functions
    in your application. For example, you are not allowed to create a new `Thread`
    class instance anymore. You have to use a system-managed thread pool instead.
    A lot of usual APIs cannot be used anymore, and you have to study new ways to
    achieve the same goals as before.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Windows API是异步的，你只能在你的应用程序中使用白名单中的API函数。例如，你不再被允许创建新的`Thread`类实例。你必须使用系统管理的线程池。许多常规API不能再使用，你必须研究新的方法来实现之前的目标。
- en: But this is not all. Microsoft began to understand that supporting operating
    systems other than Windows is also important. And now, you can write cross-platform
    applications using a new subset of .NET that is called .NET Core. Its source can
    be found on GitHub, and it is supported on platforms such as OS X and Linux. You
    can use any text editor, but I would suggest you take a look at Visual Studio
    Code—a new lightweight, cross-platform code editor, which runs on OS X and Linux
    and understands the C# syntax well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是全部。微软开始意识到支持除Windows以外的操作系统也很重要。现在，你可以使用一个新的.NET子集来编写跨平台应用程序，这个子集被称为.NET
    Core。它的源代码可以在GitHub上找到，并且它在OS X和Linux等平台上得到支持。你可以使用任何文本编辑器，但我建议你看看Visual Studio
    Code——这是一个新的轻量级、跨平台代码编辑器，它在OS X和Linux上运行，并且很好地理解C#语法。
- en: In this chapter, we will see how a Universal Windows Platform application is
    different from the usual Windows application and how we can use some of the WinRT
    benefits from the usual applications. We will also go through a simplified scenario
    of a Universal Windows Platform application with background notifications. You
    will also learn to run a .NET program on OS X and Linux.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解通用Windows平台应用程序与常规Windows应用程序的不同之处，以及我们如何利用一些WinRT从常规应用程序中获得的益处。我们还将通过一个具有后台通知的简化通用Windows平台应用程序场景进行说明。你还将学习如何在OS
    X和Linux上运行.NET程序。
- en: Using a timer in a Universal Windows Platform application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在通用Windows平台应用程序中使用计时器
- en: This recipe shows you how to use a simple timer in Universal Windows Platform
    applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程展示了如何在通用Windows平台应用程序中使用简单的计时器。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, you will need Visual Studio 2015 and the Windows
    10 operating system. No other prerequisites are required. The source code for
    this recipe can be found at `BookSamples\Chapter11\Recipe1`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你需要Visual Studio 2015和Windows 10操作系统。没有其他先决条件。本教程的源代码可以在`BookSamples\Chapter11\Recipe1`找到。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to use a timer in a Windows Store application, perform the
    following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在Windows Store应用程序中使用计时器，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# **Blank App (Universal Windows)**
    project in the `Windows\Universal` folder.![How to do it...](img/B05292_11_01.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。在`Windows\Universal`文件夹中创建一个新的C# **空白应用（通用Windows）**项目。![如何操作...](img/B05292_11_01.jpg)
- en: If you are asked to enable developer mode for Windows 10, you have to enable
    it in the control panel.![How to do it...](img/B05292_11_02.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你被要求为Windows 10启用开发者模式，你必须在控制面板中启用它。![如何操作...](img/B05292_11_02.jpg)
- en: Then, confirm that you are sure you want to turn on developer mode.![How to
    do it...](img/B05292_11_03.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，确认你确实想要开启开发者模式。![如何操作...](img/B05292_11_03.jpg)
- en: 'In the `MainPage.xaml` file, add the `Name` attribute to the `Grid` element:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainPage.xaml`文件中，向`Grid`元素添加`Name`属性：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `MainPage.xaml.cs` file, add the following `using` directives:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainPage.xaml.cs`文件中添加以下`using`指令：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet above the `MainPage` constructor definition:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainPage`构造函数定义上方添加以下代码片段：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Replace the `MainPage()` constructor with the following code snippet:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainPage()`构造函数替换为以下代码片段：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the `OnNavigatedTo()` method under the `MainPage` constructor definition:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainPage`构造函数定义下添加`OnNavigatedTo()`方法：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `OnNavigatedTo` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnNavigatedTo`方法内部添加以下代码片段：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Right-click on the project in Visual Studio **Solution Explorer** and choose
    **Deploy**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio的**解决方案资源管理器**中右键单击项目，然后选择**部署**。
- en: Run the program.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the program runs, it creates an instance of a `MainPage` class. Here, we
    instantiate `DispatcherTimer` in the constructor and initialize the `ticks` counter
    to `0`. Then, in the `OnNavigatedTo` event handler, we create our UI controls
    and bind the start and stop buttons to the corresponding lambda expressions, which
    contain the `start` and `stop` logics.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它会创建一个 `MainPage` 类的实例。在这里，我们在构造函数中实例化 `DispatcherTimer` 并将 `ticks` 计数器初始化为
    `0`。然后，在 `OnNavigatedTo` 事件处理程序中，我们创建我们的 UI 控件并将启动和停止按钮绑定到相应的 lambda 表达式，这些表达式包含
    `start` 和 `stop` 逻辑。
- en: As you can see, the `timer` event handler works directly with the UI controls.
    This is okay because `DispatcherTimer` is implemented in such a way that the handlers
    of the `Tick` event of `timer` are run by the UI thread. However, if you run the
    program and then switch to something else and then switch to the program after
    a couple of minutes, you may notice that the seconds counter is far behind the
    real amount of time that passed. This happens because Universal Windows Platform
    applications have completely different life cycles.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`timer` 事件处理程序直接与 UI 控件一起工作。这是可以的，因为 `DispatcherTimer` 是以这种方式实现的，即 `timer`
    的 `Tick` 事件的处理程序由 UI 线程运行。然而，如果您运行程序，然后切换到其他程序，然后几分钟后切换回程序，您可能会注意到秒表计数器远远落后于实际经过的时间。这是因为通用
    Windows 平台应用程序具有完全不同的生命周期。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that Universal Windows Platform applications behave much like the applications
    on smartphone and tablet platforms. Instead of running in the background, they
    become suspended after some time, and this means that they are actually frozen
    until the user switches back to them. You have a limited time to save the current
    application state before it becomes suspended, and you are able to restore the
    state when the applications run again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通用 Windows 平台应用程序的行为与智能手机和平板电脑平台上的应用程序非常相似。它们不是在后台运行，而是在一段时间后挂起，这意味着它们实际上被冻结，直到用户切换回它们。在应用程序挂起之前，您有有限的时间来保存当前应用程序状态，并且当应用程序再次运行时，您能够恢复状态。
- en: While this behavior could save power and CPU resources, it creates significant
    difficulties for program applications that are supposed to do some processing
    in the background. Windows 10 has a set of special APIs to program such applications.
    We will go through such a scenario later in this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种行为可以节省电源和 CPU 资源，但它为那些需要在后台进行一些处理的应用程序程序创建了许多困难。Windows 10 为此类应用程序提供了一套特殊的
    API。我们将在本章后面讨论此类场景。
- en: Using WinRT from usual applications
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在常规应用程序中使用 WinRT
- en: This recipe shows you how to create a console application that will be able
    to use the WinRT API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方向您展示了如何创建一个能够使用 WinRT API 的控制台应用程序。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, you will need Visual Studio 2015 and the Windows
    10 operating system. There are no other prerequisites. The source code for this
    recipe can be found at `BookSamples\Chapter11\Recipe2`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要 Visual Studio 2015 和 Windows 10 操作系统。没有其他先决条件。这个配方的源代码可以在 `BookSamples\Chapter11\Recipe2`
    中找到。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to use WinRT from usual applications, perform the following
    steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何从常规应用程序中使用 WinRT，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: Right-click on the created project in Visual Studio **Solution Explorer** and
    select the **Unload Project…** menu option.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 的 **解决方案资源管理器** 中右键单击创建的项目，然后选择 **卸载项目…** 菜单选项。
- en: Right-click on the unloaded project and select the **Edit ProjectName.csproj**
    menu option.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击未加载的项目，并选择 **编辑 ProjectName.csproj** 菜单选项。
- en: 'Add the following XML code below the `<TargetFrameworkVersion>` element:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<TargetFrameworkVersion>` 元素下方添加以下 XML 代码：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save the `.csproj` file, right-click on the unloaded project in Visual Studio
    **Solution Explorer**, and select the **Reload Project** menu option.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `.csproj` 文件，在 Visual Studio **解决方案资源管理器** 中右键单击未加载的项目，并选择 **重新加载项目** 菜单选项。
- en: Right-click on the project and select **Add Reference** from the **Core** library
    under **Windows**. Then, click on the **Browse** button.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目，然后在 **Windows** 下的 **核心库** 中选择 **添加引用**。然后，单击 **浏览** 按钮。
- en: Navigate to `C:\Program Files (x86)\Windows Kits\10\UnionMetadata` and click
    on `Windows.winmd`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `C:\Program Files (x86)\Windows Kits\10\UnionMetadata` 并单击 `Windows.winmd`
    文件。
- en: Navigate to `C:\Program Files\Reference Assemblies\Microsoft\Framework\.NETCore\v4.5`
    and click on the `System.Runtime.WindowsRuntime.dll` file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `C:\Program Files\Reference Assemblies\Microsoft\Framework\.NETCore\v4.5`
    并单击 `System.Runtime.WindowsRuntime.dll` 文件。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following code snippet to the `Main` method:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`Main`方法中：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Program` class definition:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类定义下方添加以下代码片段：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the program.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we used quite a tricky way to consume the WinRT API from a common .NET
    console application. Unfortunately, not all available APIs will work in this scenario,
    but still, it could be useful to work with movement sensors, GPS location services,
    and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一种相当巧妙的方法来从常见的.NET控制台应用程序中消费WinRT API。不幸的是，并非所有可用的API都适用于此场景，但仍然，它可以用于处理运动传感器、GPS位置服务等等。
- en: To reference WinRT in Visual Studio, we manually edit the `.csproj` file, specifying
    the target platform for the application as Windows 10\. Then, we manually reference
    `Windows.winmd` to get access to Windows 10 APIs and `System.Runtime.WindowsRuntime.dll`
    to leverage the `GetAwaiter` extension method implementation for WinRT asynchronous
    operations. This allows us to use `await` on WinRT APIs directly. There is a backward
    conversion as well. When we create a WinRT library, we have to expose the WinRT
    native `IAsyncOperation` interfaces family for asynchronous operations, so they
    could be consumed from JavaScript and C++ in a language-agnostic manner.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Visual Studio中引用WinRT，我们手动编辑`.csproj`文件，指定应用程序的目标平台为Windows 10。然后，我们手动引用`Windows.winmd`以获取访问Windows
    10 API的权限，并引用`System.Runtime.WindowsRuntime.dll`以利用WinRT异步操作的`GetAwaiter`扩展方法实现。这允许我们直接在WinRT
    API上使用`await`。也存在反向转换。当我们创建WinRT库时，我们必须公开WinRT本地的`IAsyncOperation`接口家族以进行异步操作，这样它们就可以以语言无关的方式从JavaScript和C++中消费。
- en: File operations in WinRT are quite self-descriptive; here, we have asynchronous
    file create and delete operations. Still, file operations in WinRT contain security
    restrictions, encouraging you to use special Windows folders for your application
    and not allowing you to work with just any file path on your disk drive.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT中的文件操作相当直观；在这里，我们有异步的文件创建和删除操作。尽管如此，WinRT中的文件操作包含安全限制，鼓励你为你的应用程序使用特殊的Windows文件夹，并且不允许你在磁盘驱动器上的任何文件路径上工作。
- en: Using BackgroundTask in Universal Windows Platform applications
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在通用Windows平台应用程序中使用BackgroundTask
- en: This recipe walks you through the process of creating a background task in a
    Universal Windows Platform application, which updates the application's live tile
    on a desktop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱指导你如何在通用Windows平台应用程序中创建后台任务，该任务在桌面上更新应用程序的磁贴。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, you will need Visual Studio 2015 and the Windows
    10 operating system. There are no other prerequisites. The source code for this
    recipe can be found at `BookSamples\Chapter11\Recipe3`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，你需要Visual Studio 2015和Windows 10操作系统。没有其他先决条件。这个食谱的源代码可以在`BookSamples\Chapter11\Recipe3`找到。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to use `BackgroundTask` in Universal Windows Platform applications,
    perform the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在通用Windows平台应用程序中使用`BackgroundTask`，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# **Blank App (Universal Windows)**
    project under `Windows\Universal` folder. If you need to enable the Windows 10
    developer mode, refer to the *Using a timer in a Windows Store application* recipe
    for detailed instructions.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。在`Windows\Universal`文件夹下创建一个新的C# **空白应用（通用Windows）**项目。如果你需要启用Windows
    10开发者模式，请参考*在Windows Store应用程序中使用计时器*食谱以获取详细说明。
- en: Open the `Package.appxmanifest` file. In the **Declarations** tab, add **Background
    Tasks** to **Supported Declarations**. Under **Properties**, check the supported
    properties **System event** and **Timer** and set the name of **Entry point**
    to `YourNamespace.TileSchedulerTask`. `YourNamespace` should be the namespace
    of your application.![How to do it...](img/B05292_11_04.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Package.appxmanifest`文件。在**声明**选项卡下，将**后台任务**添加到**支持声明**中。在**属性**下，检查支持属性**系统事件**和**计时器**，并将**入口点**的名称设置为`YourNamespace.TileSchedulerTask`。`YourNamespace`应该是你的应用程序的命名空间。![如何做...](img/B05292_11_04.jpg)
- en: 'In the `MainPage.xaml` file, insert the following XAML code into the `Grid`
    element:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainPage.xaml`文件中，将以下XAML代码插入到`Grid`元素中：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `MainPage.xaml.cs` file, add the following `using` directives:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainPage.xaml.cs`文件中，添加以下`using`指令：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet above the `MainPage` constructor definition:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainPage`构造函数定义上方添加以下代码片段：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace the `MainPage` constructor with the following code snippet:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainPage`构造函数替换为以下代码片段：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following code snippet above the `OnNavigatedTo` method:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnNavigatedTo`方法上方添加以下代码片段：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet to the `OnNavigatedTo` method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`OnNavigatedTo`方法中：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet below the `MainPage` class definition:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`MainPage`类定义下方：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding program shows how to create a background time-based task and how
    to show the updates from this task on a live tile on the Windows 10 start menu.
    Programming Universal Windows Platform applications is quite a challenging task
    itself—you have to care about an application suspending/restoring its state and
    many other things. Here, we are going to concentrate on our main task, leaving
    behind the secondary issues.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序展示了如何创建一个基于时间的后台任务，以及如何在Windows 10开始菜单上的实时磁贴上显示此任务的更新。编程通用Windows平台应用程序本身就是一个相当具有挑战性的任务——你必须关注应用程序挂起/恢复其状态以及许多其他事情。在这里，我们将集中精力完成我们的主要任务，而将次要问题留在一旁。
- en: Our main goal is to run some code when the application itself is not in the
    foreground. First, we create an implementation of the `IBackgroundTask` interface.
    This is our code, and the `Run` method will be called when we get a trigger signal.
    It is important that if the `Run` method contains asynchronous code with `await`
    in it, we have to use a special deferral object as shown in the recipe to explicitly
    specify when we begin and end the `Run` method execution. In our case, the method
    call is synchronous, but to illustrate this requirement, we work with the deferral
    object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标是当应用程序本身不在前台时运行一些代码。首先，我们创建了一个`IBackgroundTask`接口的实现。这是我们编写的代码，当接收到触发信号时，将调用`Run`方法。如果`Run`方法中包含带有`await`的异步代码，我们必须使用食谱中显示的特殊延迟对象来明确指定何时开始和结束`Run`方法的执行。在我们的情况下，方法调用是同步的，但为了说明这个要求，我们使用延迟对象。
- en: Inside our task in the `Run` method, we create a set of tile updates each minute
    for 4 hours and register it in `TileUpdateManager` with the help of the `ScheduledTaskNotification`
    class. A tile uses a special XML format to specify exactly how the text should
    be positioned in it. When we trigger our task from the system, it schedules one-minute
    tile updates for the next 4 hours. Then, we need to register our background task.
    We do this twice; one registration provides a `UserPresent` trigger, which means
    that this task will be triggered when a user is logged in. The next trigger is
    a time trigger, which runs the task once every 3 hours.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Run`方法中，我们为4个小时创建了一组每分钟一次的磁贴更新，并使用`ScheduledTaskNotification`类将其注册到`TileUpdateManager`中。磁贴使用特殊的XML格式来指定文本在其中的确切位置。当我们从系统中触发任务时，它为接下来的4个小时安排了一分钟的磁贴更新。然后，我们需要注册我们的后台任务。我们这样做两次；一次注册提供了一个`UserPresent`触发器，这意味着当用户登录时，此任务将被触发。下一个触发器是一个时间触发器，每3小时运行一次任务。
- en: When the program runs, it creates a timer, which runs when the application is
    in the foreground. At the same time, it tries to register background tasks; to
    register these tasks, the program needs user permission, and it will show a dialog
    requesting permissions from the user. Now, we have scheduled live tile updates
    for the next 4 hours. If we close our application, the live tile will continue
    to show the new time every minute. In the next 3 hours, the time trigger will
    run our background task once again, and we will schedule another live tile update.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它会创建一个计时器，该计时器在应用程序处于前台时运行。同时，它尝试注册后台任务；为了注册这些任务，程序需要用户权限，并且会显示一个对话框请求用户权限。现在，我们已经为接下来的4小时安排了实时磁贴更新。如果我们关闭我们的应用程序，实时磁贴将继续每分钟显示新的时间。在接下来的3小时内，时间触发器将再次运行我们的后台任务，并且我们将安排另一个实时磁贴更新。
- en: Running a .NET Core application on OS X
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OS X上运行.NET Core应用程序
- en: This recipe shows how to install a .NET Core application on OS X and how to
    build and run a .NET console application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱展示了如何在OS X上安装.NET Core应用程序，以及如何构建和运行.NET控制台应用程序。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, you will need a Mac OS X operating system. There
    are no other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter11\Recipe4`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，你需要一个Mac OS X操作系统。没有其他先决条件。这个食谱的源代码可以在`BookSamples\Chapter11\Recipe4`找到。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to run .NET Core applications, perform the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何运行.NET Core应用程序，请执行以下步骤：
- en: Install .NET Core on your OS X machine. You can visit [http://dotnet.github.io/getting-started/](http://dotnet.github.io/getting-started/)
    and follow the installation instructions there. Since .NET Core is in the pre-release
    stage, the installation and usage scenarios could change before this book is published.
    Refer to the site instructions in that case.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 OS X 机器上安装 .NET Core。您可以访问 [http://dotnet.github.io/getting-started/](http://dotnet.github.io/getting-started/)
    并遵循那里的安装说明。由于 .NET Core 处于预发布阶段，在本书出版之前，安装和使用场景可能会发生变化。在这种情况下，请参考网站上的说明。
- en: After you have downloaded the `.pkg` file, hold the *Control* key while opening
    it. It will unblock the file and will allow you to install it.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您下载了 `.pkg` 文件后，按住 *Control* 键打开它。这将解锁文件，并允许您安装它。
- en: 'After you have installed the package, you will need to install OpenSSL. The
    easiest way is to install the homebrew package manager first. Open the terminal
    window and run the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您安装完软件包后，您需要安装 OpenSSL。最简单的方法是首先安装 homebrew 软件包管理器。打开终端窗口并运行以下命令：
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, you can install OpenSSL by typing the following in it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以在其中输入以下内容来安装 OpenSSL：
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is also the small catch that .NET Core at the time of writing needs to
    increase the open files limit. This can be achieved by typing the following:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时还有一个小的注意事项，即撰写本书时，.NET Core 需要增加打开文件限制。这可以通过输入以下内容来实现：
- en: '[PRE20]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now you have installed .NET Core and are ready to go. To create a sample Hello
    World application, you can create a directory and create an empty application:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经安装了 .NET Core 并准备开始。要创建一个示例 Hello World 应用程序，您可以创建一个目录并创建一个空的应用程序：
- en: '[PRE21]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s check whether the default application works. To run the code, we have
    to restore dependencies and build and run the application. To achieve this, type
    the following commands:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查默认应用程序是否工作。要运行代码，我们必须恢复依赖项并构建和运行应用程序。为此，请输入以下命令：
- en: '[PRE22]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s try to run some asynchronous code. In the `Program.cs` file, change
    the code to the following:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行一些异步代码。在 `Program.cs` 文件中，将代码更改为以下内容：
- en: '[PRE23]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the program with the `dotnet run` command.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 命令运行程序。
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we download a `.pkg` file with the .NET Core installation package from
    the site and install it. We also install the OpenSSL library using the homebrew
    package manager (which also gets installed). Besides that, we increase the open
    files limit in OS X to be able to restore .NET Core dependencies.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从网站上下载包含 .NET Core 安装包的 `.pkg` 文件并将其安装。我们还使用 homebrew 软件包管理器（它也会被安装）安装
    OpenSSL 库。除此之外，我们还在 OS X 中增加打开文件限制，以便能够恢复 .NET Core 依赖项。
- en: Then, we create a separate folder for the .NET Core application, create a blank
    console application, and check whether everything works fine with restoring dependencies
    and running the code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为 .NET Core 应用程序创建一个单独的文件夹，创建一个空白控制台应用程序，并检查恢复依赖项和运行代码是否一切正常。
- en: Finally, we create a simple asynchronous code and try to run it. It should run
    well, showing the messages that the first task completed successfully. The second
    task caused an exception, which was correctly handled. But if you try to uncomment
    a line that is intended to show the thread-specific information, the code will
    not be compiled, since .NET Core has no support for Thread APIs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一段简单的异步代码并尝试运行它。它应该运行良好，显示第一个任务成功完成的消息。第二个任务抛出了异常，但被正确处理。但是，如果您尝试取消注释一行旨在显示线程特定信息的代码，代码将无法编译，因为
    .NET Core 不支持 Thread API。
- en: Running a .NET Core application on Ubuntu Linux
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 上运行 .NET Core 应用程序
- en: This recipe shows how to install a .NET Core application on Ubuntu and how to
    build and run a .NET console application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何在 Ubuntu 上安装 .NET Core 应用程序，以及如何构建和运行 .NET 控制台应用程序。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, you will need an Ubuntu Linux 14.04 operating system.
    There are no other prerequisites. The source code for this recipe can be found
    at `BookSamples\Chapter11\Recipe5`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，您需要一个 Ubuntu Linux 14.04 操作系统。没有其他先决条件。这个菜谱的源代码可以在 `BookSamples\Chapter11\Recipe5`
    找到。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to run .NET Core applications, perform the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何运行 .NET Core 应用程序，请执行以下步骤：
- en: Install .NET Core on your Ubuntu machine. You can visit [http://dotnet.github.io/getting-started/](http://dotnet.github.io/getting-started/)
    and follow the installation instructions there. Since .NET Core is in the pre-release
    stage, the installation and usage scenarios could change by the time this book
    is published. Refer to the site instructions in that case.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Ubuntu机器上安装.NET Core。你可以访问[http://dotnet.github.io/getting-started/](http://dotnet.github.io/getting-started/)并遵循那里的安装说明。由于.NET
    Core处于预发布阶段，安装和使用场景可能会在本书出版时发生变化。在这种情况下，请参考网站上的说明。
- en: 'First, open a terminal window and run the following commands:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个终端窗口并运行以下命令：
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, you can install .NET Core by typing the following in the terminal window:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以在终端窗口中输入以下内容来安装.NET Core：
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, you have installed .NET Core and are ready to go. To create a sample Hello
    World application, you can create a directory and create an empty application:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你已经安装了.NET Core并准备就绪。要创建一个示例Hello World应用程序，你可以创建一个目录并创建一个空的应用程序：
- en: '[PRE26]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s check whether the default application works. To run the code, we have
    to restore dependencies and build and run the application. To achieve this, type
    the following commands:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查默认应用程序是否工作。要运行代码，我们必须恢复依赖项并构建和运行应用程序。为此，请输入以下命令：
- en: '[PRE27]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s try to run some asynchronous code. In the `Program.cs` file, change
    the code to the following:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行一些异步代码。在`Program.cs`文件中，将代码更改为以下内容：
- en: '[PRE28]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the program with `dotnet run` command.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dotnet run`命令运行程序。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we start with setting up the apt-get feed that hosts the .NET Core packages
    that we need. This is necessary since at the time of writing, .NET Core for Linux
    may not have been released. For sure, when the release happens, it will get into
    normal apt-get feeds and you won't have to add custom feeds to it. After completing
    this, we use apt-get to install the currently working version of .NET Core.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先设置apt-get feed，它托管我们需要的.NET Core包。这是必要的，因为在写作的时候，.NET Core for Linux可能尚未发布。当然，当发布发生时，它将进入正常的apt-get
    feed，你不需要向其中添加自定义feed。完成此操作后，我们使用apt-get安装当前正在工作的.NET Core版本。
- en: Then, we create a separate folder for the .NET Core application, create a blank
    console application, and check whether everything works fine with restoring dependencies
    and running the code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为.NET Core应用程序创建一个单独的文件夹，创建一个空白控制台应用程序，并检查在恢复依赖项和运行代码时是否一切正常。
- en: Finally, we create a simple asynchronous code and try to run it. It should run
    well, showing messages that the first task completed successfully, and the second
    task caused an exception, which was correctly handled. But if you try to uncomment
    a line that is intended to show the thread-specific information, the code will
    not be compiled, since .NET Core has no support for Thread APIs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个简单的异步代码并尝试运行它。它应该运行良好，显示第一条任务成功完成的消息，第二条任务抛出了异常，并且被正确处理。但是，如果你尝试取消注释一行旨在显示线程特定信息的代码，代码将无法编译，因为.NET
    Core不支持Thread API。
