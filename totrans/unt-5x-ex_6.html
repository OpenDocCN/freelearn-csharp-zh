<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Continuing the 2D Adventure</h1></div></div></div><p>In the previous chapter, we started work on a 2D adventure game. On reaching this point, we've now created a controllable character that can navigate a level using physics and collision detection as well as gravity. This chapter completes the 2D game project by adding the remaining features. Specifically, this chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Moving <a id="id348" class="indexterm"/>obstacles and features such as an elevator platform</li><li class="listitem" style="list-style-type: disc">Gun turrets to attack the player</li><li class="listitem" style="list-style-type: disc">An NPC with a quest system<div><div><h3 class="title"><a id="note22"/>Note</h3><p>The starting project and assets can be found in the book companion files in the <code class="literal">Chapter06/Start</code> folder. You can start here and follow along with this chapter if you don't have your own project already.</p></div></div></li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Moving platforms</h1></div></div></div><p>Now let's refine the <a id="id349" class="indexterm"/>adventure further by adding a moving <a id="id350" class="indexterm"/>element to the existing scene; specifically, a moving platform object. This platform should move up and then down again on a loop, ping-ponging between extremes. The player will be able to jump onto the platform to hitch a ride, and the object will be constructed as a prefab, allowing it to be reused across scenes. See <em>Figure 6.1</em> for the result:</p><div><img src="img/figure_06_01.jpg" alt="Moving platforms"/><div><p>Figure 6.1: Create a moving platform</p></div></div><p>To start, select the <a id="id351" class="indexterm"/>platform texture in the <strong>Project</strong> panel, <a id="id352" class="indexterm"/>making sure that it's specified as a <strong>Sprite</strong> (2D and UI) texture type in the <strong>Object Inspector</strong>. The <strong>Sprite Mode</strong> should be set to <strong>Single</strong>. Drag and drop the platform texture to the scene and set its <strong>Scale</strong> to (<code class="literal">0.7</code>, <code class="literal">0.5</code>, <code class="literal">1</code>). See <em>Figure 6.2</em>:</p><div><img src="img/figure_06_02.jpg" alt="Moving platforms"/><div><p>Figure 6.2: Building a moving platform</p></div></div><p>Next, the platform should be a solid object, the kind of thing with which the player can collide. Remember, the player should be able to stand on the platform. Consequently, a Collider must be added. In this case, a Box Collider 2D is appropriate. To add this, select the platform object <a id="id353" class="indexterm"/>in the scene and navigate to <a id="id354" class="indexterm"/>
<strong>Component</strong> | <strong>Physics 2D</strong> | <strong>Box Collider 2D</strong> from the menu. See <em>Figure 6.3</em>:</p><div><img src="img/figure_06_03.jpg" alt="Moving platforms"/><div><p>Figure 6.3: Adding a collider to the platform</p></div></div><p>After the collider has been added to the platform, you may need to adjust its properties from the <strong>Object Inspector</strong>; specifically, its <strong>Offset</strong> and <strong>Size</strong> fields to make the collider match the size of the platform sprite closely. Then, finally, test the platform by entering the play mode and standing the player character on the platform. By doing so, the player should not fall through the platform! See <em>Figure 6.4</em>:</p><div><img src="img/figure_06_04.jpg" alt="Moving platforms"/><div><p>Figure 6.4: Testing platform collisions</p></div></div><p>The platform so far is static and motionless, and it should move up and down repeatedly. To fix this, we could create a predefined animation sequence using the <strong>Animation Editor</strong> via the <strong>Window</strong> | <strong>Animation</strong> menu option. However, instead, we'll use a script file. Frequently, when making animations, you'll often need to reach decisions about which option is best: <em>C# animations</em> or <em>Baked animations</em>. Typically, script should be chosen when an animation should be simple and must apply to many objects and vary for each. The following <a id="id355" class="indexterm"/>script file <code class="literal">PingPongMotion.cs</code> <a id="id356" class="indexterm"/>should be created and attached to the platform. See <em>Code Sample 6.1</em>, and code comments follow:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
//--------------------------------
public class PingPongMotion : MonoBehaviour 
{
  //--------------------------------
  //This transformation
  private Transform ThisTransform = null;

  //Original position
  private Vector3 OrigPos = Vector3.zero;

  //Axes to move on
  public Vector3 MoveAxes = Vector2.zero;

  //Speed
  public float Distance = 3f;
  //--------------------------------
  // Use this for initialization
  void Awake ()
  {
    //Get transform component
    ThisTransform = GetComponent&lt;Transform&gt;();

    //Copy original position
    OrigPos = ThisTransform.position;
  }
  //--------------------------------
  // Update is called once per frame
  void Update () 
  {
    //Update platform position with ping pong
    ThisTransform.position = OrigPos + MoveAxes * Mathf.PingPong(Time.time, Distance);
  }
  //--------------------------------
}
//--------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec24"/>Code Sample 6.1</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id357" class="indexterm"/><code class="literal">PingPongMotion</code> class is responsible for moving a <code class="literal">GameObject</code> back and forth from an original starting point.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Awake</code> function uses the <code class="literal">OrigPos</code> variable to record the starting position of the <code class="literal">GameObject</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Update</code> function relies on the <code class="literal">Mathf.PingPong</code> function to transition a value smoothly between a minimum and maximum. This function fluctuates a value between minimum and maximum repeatedly and continuously over time, allowing you move objects linearly. For more information, see the Unity online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Mathf.PingPong.html">http://docs.unity3d.com/ScriptReference/Mathf.PingPong.html</a>.</li></ul></div><p>The completed code should be attached to the platform object in the scene and can be reused easily for any other object that should move up and down regularly (or left and right).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Creating other scenes – levels 2 and 3</h1></div></div></div><p>Unlike the <a id="id358" class="indexterm"/>other games created in the book so far, our adventure game will span multiple scenes. That is, our game features several different screens, which the player may move between by walking off the edge of one screen and entering from the edge of another. Supporting this functionality introduces us to some new and interesting problems in Unity that are well worth exploring, as we'll see later. For now, let's make a second and third scene for the game, using the remaining background and foreground objects, and configuring collisions for each level, allowing the player prefab to work seamlessly with each environment. The details to create a level with collisions (Edge Colliders) are covered in depth in the previous chapter. The final, completed scenes are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Level 2 is divided across two vertically arranged ledges with a set of moving platforms on the lower ledge. These are created from the moving platform prefab created in the previous section. The upper ledge is, for now, non-hazardous but this will be changed later as we add gun turrets that can shoot the player character. This level can be reached from the first original level by walking off the left edge of the screen. See <em>Figure 6.5</em>:<div><img src="img/figure_06_05.jpg" alt="Creating other scenes – levels 2 and 3"/><div><p>Figure 6.5: Scene 2 – dangerous ledges and moving platforms</p></div></div></li><li class="listitem" style="list-style-type: disc">Level 3 is <a id="id359" class="indexterm"/>reached from the first original level by walking off the right edge of the screen. It consists of one ground-level plane featuring a house. It will be home to an NPC character whom the player can meet and receive a quest to collect an item. This character is created later in the chapter. See <em>Figure 6.6</em>:<div><img src="img/figure_06_06.jpg" alt="Creating other scenes – levels 2 and 3"/><div><p>Figure 6.6: Scene 3 – a lonely house for an NPC</p></div></div></li></ul></div><p>Both Levels 2 and 3 were created entirely with the techniques seen so far. However, to give each scene its own charm and character, some unique elements must be added—some of these are specific to <a id="id360" class="indexterm"/>each scene and some are more general. Let's now consider these in turn.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Kill zones</h1></div></div></div><p>A common scripted <a id="id361" class="indexterm"/>feature required by all scenes, but not yet implemented, is the <strong>Kill Zone</strong>. That is, the functionality to mark out a region of 2D space in the level that, when entered by the player, will kill them or damage them. This is especially <a id="id362" class="indexterm"/>useful to kill the player whenever they fall down a hole in the ground. Thus, the Kill Zone will be required in every level because every level created so far contains pits and holes in the ground. To implement this functionality, create a new and empty <strong>GameObject</strong> in any scene. (It doesn't matter which because we'll be making a prefab object that can be reused anywhere.) As mentioned, new <strong>GameObjects</strong> are created with the menu option, <strong>GameObject</strong> | <strong>Create Empty</strong>. Once created, name the object <code class="literal">KillZone</code>, then position it at the world origin (0,0,0), and finally, attach a Box Collider 2D component using the menu command, <strong>Component</strong> | <strong>Physics 2D</strong> | <strong>Box Collider 2D</strong>. The Box Collider will define the Kill Zone area. Remember to make sure that the <strong>Box Collider 2D</strong> is configured as a Trigger by checking the <strong>Is Trigger</strong> checkbox in the Inspector from the <strong>Box Collider 2D</strong> component. See <em>Figure 6.7</em>. A Trigger differs from a Collider; colliders prevent objects from passing through and Triggers detect when objects pass through, allowing you to perform custom behaviors.</p><div><img src="img/figure_06_07.jpg" alt="Kill zones"/><div><p>Figure 6.7: Creating a Kill Zone object and Trigger</p></div></div><p>Next, create a new script file <code class="literal">KillZone.cs</code>, which should be attached to the Kill Zone object in the scene. This script file is responsible for damaging the player's health for as long as they are in the Kill Zone. At this stage, there are several ways to approach kill zone implementation. One way is to destroy the player as soon as they enter the Kill Zone. The other is to damage the player for as long as they are in the Kill Zone. The second method is <a id="id363" class="indexterm"/>preferred here because of its versatility and <a id="id364" class="indexterm"/>contribution toward code reuse. Specifically, we get the option to damage the player by reducing their health at a particular speed (if we need to) as well as killing the player instantly simply by reducing their health by an increase in reduction speed. Let's see this at work in the following <em>Code Sample 6.2</em>:</p><div><pre class="programlisting">//--------------------------------
using UnityEngine;
using System.Collections;
//--------------------------------
public class KillZone : MonoBehaviour {
    //--------------------------------
    //Amount to damage player per second
    public float Damage = 100f;
    //--------------------------------
    void OnTriggerStay2D(Collider2D other)
    {
        //If not player then exit
        if(!other.CompareTag("Player"))return;

        //Damage player by rate
        if(PlayerControl.PlayerInstance!=null)
            PlayerControl.Health -= Damage * Time.deltaTime;
    }
    //--------------------------------
}
//--------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec25"/>Code Sample 6.2</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id365" class="indexterm"/><code class="literal">KillZone</code> class is responsible for continually damaging the player health when a <code class="literal">GameObject</code>, tagged as <code class="literal">Player</code>, enters and remains within a Trigger Volume.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">OnTriggerStay2D</code> function is called automatically by Unity, once per frame, when <a id="id366" class="indexterm"/>an object with <code class="literal">RigidBody</code> enters and remains within a Trigger Volume. Thus, when a physics object enters the Kill Zone trigger, the <code class="literal">OnTriggerStay2D</code> function will be called as frequently as the <code class="literal">Update</code> function. More <a id="id367" class="indexterm"/>information on <code class="literal">OnTriggerStay2D</code> can be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerStay2D.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerStay2D.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Damage</code> variable encodes the reduction of health for the player by adjusting the public static property, <code class="literal">Health</code>, which is part of the <code class="literal">PlayerControl</code> class. When <code class="literal">Health</code> reaches <code class="literal">0</code>, the player will be destroyed.</li></ul></div><p>Now, give <a id="id368" class="indexterm"/>the game a test run, marking out a Kill Zone in the scene and walking the Player into it during play mode. On entry, the player character should be destroyed or damaged. To ensure that the player is killed instantly, increase the damage to a very high number, such as <code class="literal">9000</code>! After testing, create a prefab from the Kill Zone by dragging and dropping it from the scene <strong>Hierarchy</strong> panel to the <strong>Project</strong> panel in the <strong>Prefab</strong> folder. Then, add the <strong>Kill Zone</strong> prefab to each level, adjusting and sizing the Collider as needed. See <em>Figure 6.8</em>:</p><div><img src="img/figure_06_08.jpg" alt="Code Sample 6.2"/><div><p>Figure 6.8: Configuring a Kill Zone to destroy on contact</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec62"/>The UI health bar</h1></div></div></div><p>In the <a id="id369" class="indexterm"/>previous section, we introduced the first danger and hazard to the <a id="id370" class="indexterm"/>game; namely, a Kill Zone that can damage and potentially kill the player. As a result, their health has the potential to reduce from its starting state. It's therefore useful both to us as developers and gamers to visualize the health status. For this reason, let's focus on rendering player health to the screen as a UI health bar. This configuration of objects will also be made as a prefab, allowing reuse across multiple scenes This will prove a highly useful feature. <em>Figure 6.9</em> offers a glimpse of the future, displaying the result of our work to come:</p><div><img src="img/figure_06_09.jpg" alt="The UI health bar"/><div><p>Figure 6.9: Preparing to create player health</p></div></div><p>To get started, create a new GUI Canvas in the scene (any scene) by choosing <strong>GameObject</strong> | <strong>UI</strong> | <strong>Canvas</strong> from the application menu. Selecting this will automatically create an <strong>EventSystem</strong> object in the scene, if one does not exist already. This object is essential for proper <a id="id371" class="indexterm"/>use of the UI system. If you accidentally delete it, <strong>EventSystem</strong> can be recreated by choosing <strong>GameObject</strong> | <strong>UI</strong> | <strong>Event System</strong> from <a id="id372" class="indexterm"/>the application menu. The newly created Canvas object represents the surface on which the GUI will be drawn. See <em>Figure 6.10</em>:</p><div><img src="img/figure_06_10.jpg" alt="The UI health bar"/><div><p>Figure 6.10: Creating a GUI Canvas and Event System</p></div></div><p>Next, we'll create a new and separate camera object for the UI, adding it as a child of the newly created Canvas. By creating a separate camera for UI rendering, we can apply camera effects and other image adjustments separately to the UI, if we need to. To create a Camera as a child, right-click on the <strong>Canvas</strong> object in the <strong>Hierarchy</strong> panel and, from the <strong>Context</strong> menu, choose <strong>Camera</strong>. This adds a new camera object to the scene as a child of the selected object. See <em>Figure 6.11</em>:</p><div><img src="img/figure_06_11.jpg" alt="The UI health bar"/><div><p>Figure 6.11: Creating a camera child object</p></div></div><p>Now, configure the UI camera to be an Orthographic camera. We saw how to do this in the previous chapter, as well as earlier chapters too. <em>Figure 6.12</em> displays the camera settings for an <a id="id373" class="indexterm"/>orthographic camera. Remember that an Orthographic camera is truly 2D insofar as it removes perspective and foreshortening effects from the render result, which is appropriate for GUIs and other objects that live and <a id="id374" class="indexterm"/>work in screen space. In addition, the camera <strong>Depth</strong> field, from the <strong>Object Inspector</strong>, should be higher than the main game camera to ensure that it renders on top of everything else. Otherwise, the GUI could potentially render beneath and be ineffectual in the game.</p><div><img src="img/figure_06_12.jpg" alt="The UI health bar"/><div><p>Figure 6.12: Configuring an Orthographic camera for GUI rendering</p></div></div><p>The created camera is almost ready to go! However, right now, it's configured to render everything in the scene just like any other camera. This means that the scene is effectively being rendered twice by two separate cameras. This is not only wasteful and poor for <a id="id375" class="indexterm"/>performance, but it makes the second camera totally unnecessary. Instead, we want the first and original camera to show everything in the scene, in terms of characters and environments, but to ignore GUI objects, and likewise, the newly created GUI camera should show only GUI objects. To fix this, select the main game camera and, from the <strong>Object Inspector</strong>, click on the <strong>Culling Mask</strong> drop-down list in the <strong>Camera</strong> component. From here, remove the check mark for the UI layer. This drop-down list allows you to select layers to be ignored for the rendering from the selected camera. See <em>Figure 6.13</em>:</p><div><img src="img/figure_06_13.jpg" alt="The UI health bar"/><div><p>Figure 6.13: Ignore the UI layer for the main camera</p></div></div><p>Now, select the GUI camera object and, for the <strong>Culling Mask</strong> field in the <strong>Camera</strong> component, select the <strong>Nothing</strong> option to deselect all options, and then enable the UI layer to render <a id="id376" class="indexterm"/>only UI layer objects. See <em>Figure 6.14</em>. Good <a id="id377" class="indexterm"/>work!</p><div><img src="img/figure_06_14.jpg" alt="The UI health bar"/><div><p>Figure 6.14: Ignoring all layers except the UI layer for the GUI camera</p></div></div><p>By default, any newly created Canvas is configured to work in the Screen Space Overlay mode, which means it renders on top of everything else in the scene that is not associated with any specific camera. In addition, all GUI elements will be sized and scaled on the basis of this. Consequently, to make our work simpler, let's start creating the GUI by first configuring the <strong>Canvas</strong> object to work with the newly created GUI camera. To do this, select the <strong>Canvas</strong> object and, from the <strong>Canvas</strong> component in the <strong>Object Inspector</strong>, change the <strong>Render Mode</strong> from <strong>Screen Space - Overlay</strong> to <strong>Screen Space - Camera</strong>. Then, drag and drop the GUI camera object to the <strong>Camera</strong> field. See <em>Figure 6.15</em>:</p><div><img src="img/figure_06_15.jpg" alt="The UI health bar"/><div><p>Figure 6.15: Configuring the Canvas component for camera rendering</p></div></div><p>Next, let's configure the <strong>Canvas Scaler</strong> component, which is attached to the <strong>Canvas</strong> object. This component is responsible for how the GUI appears when the screen size is changed, from either up-scaling or down-scaling. In short, for our game, the GUI should up- and down-scale relatively to the screen size. For this reason, change the <strong>UI Scale Mode</strong> <a id="id378" class="indexterm"/>drop-down to <strong>Scale With Screen Size</strong>, and then enter the game <a id="id379" class="indexterm"/>resolution of <code class="literal">1024 x 600</code> in the <strong>Reference Resolution</strong> field. See <em>Figure 6.16</em>:</p><div><img src="img/figure_06_16.jpg" alt="The UI health bar"/><div><p>Figure 6.16: Adjusting the Canvas Scaler for responsive UI design</p></div></div><p>Now, we can start adding GUI elements to the game, knowing that they will appear correctly when added to the scene. To display health, a representation of the player will be useful. Create a new <strong>Image</strong> object by right-clicking on the <strong>Canvas</strong> object from the <strong>Hierarchy</strong> panel and choosing <strong>UI</strong> | <strong>Image</strong> from the context menu. Once created, select the <strong>Image</strong> object and, from the <strong>Object Inspector</strong> (in the <strong>Image</strong> component), drag and drop the player head sprite from the <strong>Project</strong> panel to the <strong>Source Image</strong> field. Then, use the <strong>Rect Transform</strong> tool (<em>T</em> on the keyboard) to resize the image in place at the top-left corner of the screen. See <em>Figure 6.17</em>:</p><div><img src="img/figure_06_17.jpg" alt="The UI health bar"/><div><p>Figure 6.17: Adding a head image to the GUI Canvas</p></div></div><div><div><h3 class="title"><a id="note23"/>Note</h3><p>If you cannot see the added head image, remember to assign the UI layer to render by the UI camera. In addition, you may need to offset the GUI camera back along the <em>Z</em> axis to include the head sprite within the <strong>Camera Frustum</strong> (Viewing Area).</p></div></div><p>Finally, anchor the Head Sprite to the top-left of the screen by clicking on the <strong>Anchor Preset</strong> button <a id="id380" class="indexterm"/>in the <strong>Rect Transform</strong> component from the <strong>Object Inspector</strong>. Choose top-left alignment. This locks the head sprite to the screen top-left, ensuring that the interface would look consistent at multiple resolutions. See <em>Figure 6.18</em>:</p><div><img src="img/figure_06_18.jpg" alt="The UI health bar"/><div><p>Figure 6.18: Anchoring the head position</p></div></div><p>To create the health bar, add a new <strong>Image</strong> object to the GUI Canvas by right-clicking on the <strong>Canvas</strong> and selecting <strong>UI</strong> | <strong>Image</strong> from the context menu. For this object, leave the <strong>Source Image</strong> field empty and choose red for the <strong>Color</strong> field, <strong>RGB (255,0,0)</strong>. This will represent the background <a id="id381" class="indexterm"/>or <em>red status</em> for the health bar when it's fully depleted. Then, use the <strong>Rect Transform</strong> tool to resize the bar as needed, anchoring to the top-left screen corner. See <em>Figure 6.19</em>:</p><div><img src="img/figure_06_19.jpg" alt="The UI health bar"/><div><p>Figure 6.19: Creating the red health status</p></div></div><p>To complete the health bar, we'll need to use scripting. Specifically, we're going to overlap two <a id="id382" class="indexterm"/>identical health bars on top of each other, one red and one green. We'll scale the green bar as the health reduces so that it reveals the red bar underneath. Before scripting this behavior, further configuration is necessary. Specifically, let's change the pivot of the health bar away from the center and to the middle-left point—the point from which the health bar should scale as it reduces and increases. To <a id="id383" class="indexterm"/>do this, select the <strong>Health bar</strong> object and, from the <strong>Object Inspector</strong>, enter a new <strong>Pivot</strong> value of <code class="literal">0</code> for <strong>X</strong> and <code class="literal">0.5</code> for <strong>Y</strong>. See <em>Figure 6.20</em>:</p><div><img src="img/figure_06_20.jpg" alt="The UI health bar"/><div><p>Figure 6.20: Repositioning the Pivot for the health bar</p></div></div><p>To create the green overlay for the health, select the red health bar and duplicate it. Name the duplicate <code class="literal">Health_Green</code> and drag and drop it to appear beneath the red version in the <strong>Hierarchy</strong> panel. The ordering of objects in the hierarchy relates to the draw order for GUI elements—lower-order objects are rendered on top of higher-order objects. See <em>Figure 6.21</em>:</p><div><img src="img/figure_06_21.jpg" alt="The UI health bar"/><div><p>Figure 6.21: Creating a duplicate green bar</p></div></div><p>Now, we need to make a new script file linking the width of the green bar to the health of the player. This <a id="id384" class="indexterm"/>means that reductions in health will reduce the width of the green bar, revealing the red bar beneath. Create a new script file named <a id="id385" class="indexterm"/>
<code class="literal">HealthBar.cs</code> and attach it to the green bar. The following is the <em>Code Sample 6.3</em> for the <code class="literal">HealthBar</code> class:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class HealthBar : MonoBehaviour
{
  //Reference to this transform component
  private RectTransform ThisTransform = null;

  //Catch up speed
  public float MaxSpeed = 10f;

    void Awake()
    {
      //Get transform component
      ThisTransform = GetComponent&lt;RectTransform&gt;();
    }

    void Start()
    {
      //Set Start Health
      if(PlayerControl.PlayerInstance!=null)
        ThisTransform.sizeDelta = new Vector2(Mathf.Clamp(PlayerControl.Health,0,100),ThisTransform.sizeDelta.y);
    }

    // Update is called once per frame
    void Update () 
    {
      //Update health property
      float HealthUpdate = 0f;

      if(PlayerControl.PlayerInstance!=null)
        HealthUpdate = Mathf.MoveTowards(ThisTransform.rect.width, PlayerControl.Health, MaxSpeed);

        ThisTransform.sizeDelta = new Vector2(Mathf.Clamp(HealthUpdate,0,100),ThisTransform.sizeDelta.y);
    }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec26"/>Code Sample 6.3</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id386" class="indexterm"/><code class="literal">HealthBar</code> class is responsible for reducing the width of a green (on the top) health bar, based on the player health.</li><li class="listitem" style="list-style-type: disc">The <a id="id387" class="indexterm"/><code class="literal">SizeDelta</code> property of <code class="literal">RectTransform</code> is used to set the width of <code class="literal">RectTransform</code>. More information on this property can be found at the online Unity <a id="id388" class="indexterm"/>documentation at <a class="ulink" href="http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html">http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Mathf.MoveTowards</code> function is used to gradually and smoothly transition the <a id="id389" class="indexterm"/>health bar width from its existing width to its destination width over time. That is, as and when player health is reduced, the health bar will decrease gradually as opposed to instantly. More information can be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html">http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html</a>.</li></ul></div><p>Finally, make a prefab of the UI objects by dragging and dropping the topmost <strong>Canvas</strong> object from the <strong>Hierarchy</strong> panel to the <strong>Project</strong> panel in the <strong>Prefab</strong> folder. This allows the UI system to be reused across multiple scenes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Ammo and hazards</h1></div></div></div><p>Level 2 is a <a id="id390" class="indexterm"/>hazardous place. It should feature not only pits and holes leading to kill zones, but also fixed dangers such as gun turrets that can shoot the player. This section focuses on their creation. To get started, let's make a gun turret. Now, the course companion files don't include a texture or image for the gun turrets, but when using the dark silhouette style as we are here, we can easily make a consistent turret prop from primitives. In particular, create a new cube object (<strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Cube</strong>), rescale it to approximate a gun turret, and then position it to the upper ledge in the scene where it will appear as part of the scenery. See <em>Figure 6.22</em>. Note that you can also use the <strong>Rect Transform</strong> tool to resize primitives!</p><div><img src="img/figure_06_22.jpg" alt="Ammo and hazards"/><div><p>Figure 6.22: Creating a prop for a gun turret</p></div></div><p>Of course, the gun turret created so far is a conspicuous and obvious grey color. To solve this, create a new black material. Right-click in the <strong>Project</strong> panel and choose <strong>Create</strong> | <strong>Material</strong> from the context menu. Assign the material a black color from the <strong>Object Inspector</strong> in the <strong>Albedo</strong> field, and then drag and drop the material from the <strong>Project</strong> panel to the <strong>Turret</strong> object in the scene. Make sure that the <strong>Smoothness</strong> field for the black material is <a id="id391" class="indexterm"/>reduced to <code class="literal">0</code> to prevent a shiny or glowing appearance. After the material is assigned, the turret will mix with the scene and its color scheme will be much better! See <em>Figure 6.23</em>:</p><div><img src="img/figure_06_23.jpg" alt="Ammo and hazards"/><div><p>Figure 6.23: Assigning a black material to the turret</p></div></div><p>Now, the turret must fire ammo. To achieve this, it'll need an empty game object to spawn ammo. Let's create this now by choosing <strong>GameObject</strong> | <strong>Create Empty</strong> and drag and drop the object in the <strong>Hierarchy</strong> panel to the Turret Cube in order to make it a child of the turret. Then, position the empty object to the tip of the cannon. Once positioned, assign an icon representation to the empty to make it visible in the viewport. Ensure that the empty is selected and, from the Inspector, click on the cube icon (beside the object name) to assign it a graphical representation. See <em>Figure 6.24</em>:</p><div><img src="img/figure_06_24.jpg" alt="Ammo and hazards"/><div><p>Figure 6.24: Assigning an icon to the Turret Spawn Point</p></div></div><p>Before moving further with ammo spawning, we'll actually need some ammo to spawn. That is, the turret must fire something, and now it's time to create this something. The ammo should appear as a glowing and pulsating plasma ball. To build this, create a new particle system by choosing <strong>GameObject</strong> | <strong>ParticleSystem</strong> from the application menu. Remember that a particle system is useful to create special effects such as rain, fire, dust, smoke, sparkles, and more. When you create a new particle system from the main menu, a new object is <a id="id392" class="indexterm"/>created in the scene and is automatically selected. When selected, you can preview how the particle system works and looks in the <strong>Scene</strong> viewport. By default, the system will be spawning small blob-like particles. See <em>Figure 6.25</em>:</p><div><img src="img/figure_06_25.jpg" alt="Ammo and hazards"/><div><p>Figure 6.25: Creating a particle system</p></div></div><p>Sometimes, on creating a particle system for a 2D game, the particles themselves may not be visible because they appear behind other 2D objects in the scene, such as the background and characters. You can control the depth order of the particle system from the <strong>Object Inspector</strong>. Scroll down in the <strong>Object Inspector</strong> and click on the <strong>Renderer</strong> roll-out title to expand more options, bringing them into view. From the <strong>Renderer</strong> group, set the <strong>Order In Layer</strong> field to a higher value, above the order of other objects to render the particles in front. See <em>Figure 6.26</em>:</p><div><img src="img/figure_06_26.jpg" alt="Ammo and hazards"/><div><p>Figure 6.26: Controlling the render order of particles</p></div></div><p>Excellent, we should now see particles in the viewport. Getting a particle system to look and behave correctly takes some tweaking and trial and error. It involves testing settings, previewing their effects in the viewport, making judgments about what is needed, and then tweaking and amending as needed. To start creating a more believable ammo object, I want <a id="id393" class="indexterm"/>particles to spawn slowly in multiple directions and not just one direction. To achieve this, expand the <strong>Shape</strong> field from the <strong>Object Inspector</strong> to control the shape of the spawn surface. Change the <strong>Shape</strong> from <strong>Cone</strong> to <strong>Sphere</strong> and set <strong>Radius</strong> to <code class="literal">0.01</code>. On doing this, particles will spawn and travel in all directions emitted from a Sphere surface. See <em>Figure 6.27</em>:</p><div><img src="img/figure_06_27.jpg" alt="Ammo and hazards"/><div><p>Figure 6.27: Changing the shape of the particle system emitter</p></div></div><p>Now, adjust the main particle system properties to create the energy ball effect. From the <strong>Object Inspector</strong>, set <strong>Start Lifetime</strong> to <code class="literal">0.19</code>, <strong>Start Speed</strong> to <code class="literal">0.88</code>, and <strong>Start Size</strong> to <code class="literal">0.59</code>. Then, set <strong>Start Color</strong> to <strong>teal (light blue)</strong>. See <em>Figure 6.28</em>:</p><div><img src="img/figure_06_28.jpg" alt="Ammo and hazards"/><div><p>Figure 6.28: Configuring the particle system main properties</p></div></div><p>Great! The particle system should now look just as we need it. However, if we press play on the toolbar, it doesn't move. Ammo should, of course, hurtle through the air and collide with its target. So, let's make a <code class="literal">Mover</code> script that should be attached to the object. The <a id="id394" class="indexterm"/>following is the code:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
//--------------------------------
public class Mover : MonoBehaviour 
{
    //--------------------------------
    public float Speed = 10f;
    private Transform ThisTransform = null;
    //--------------------------------
    // Use this for initialization
    void Awake() 
    {
        ThisTransform = GetComponent&lt;Transform&gt;();
    }
    //--------------------------------
    // Update is called once per frame
    void Update () 
    {
        //Update object position
        ThisTransform.position += ThisTransform.forward * Speed * Time.deltaTime;
    }
    //--------------------------------
}
//-------------------------------- </pre></div><p>The Mover features nothing that we haven't seen before many times already. It moves an object (the ammo) in direction of its forward vector. For this reason, as our game is two-dimensional, the particle system object may need to be rotated in order to turn the forward <a id="id395" class="indexterm"/>vector along the <em>X</em> axis. See <em>Figure 6.29</em>:</p><div><img src="img/figure_06_29.jpg" alt="Ammo and hazards"/><div><p>Figure 6.29: Aligning the forward vector to the X axis</p></div></div><p>Next, in addition to moving through the level, the ammo object must collide with and damage the player character on impact. To achieve this, several steps must be taken. First, a Rigidbody component must be attached to the ammo, allowing it to collide with other objects. To add Rigidbody, select the Ammo object in the scene and, from the application menu, choose <strong>Component</strong> | <strong>Physics</strong> | <strong>Rigidbody2D</strong>. Once added, enable the <strong>Is Kinematic</strong> checkbox from the Rigidbody component in the <strong>Object Inspector</strong>. This ensures that the object will travel based on the Mover script and still interact with physical objects without being affected by gravity. See <em>Figure 6.30</em>:</p><div><img src="img/figure_06_30.jpg" alt="Ammo and hazards"/><div><p>Figure 6.30: Marking Rigidbody with Is Kinematic</p></div></div><p>Now for a Circle Collider to the ammo object to give the ammo some shape, form, and size in terms of physics, allowing collisions to be detected between the ammo and its target. To do this, choose <strong>Component</strong> | <strong>Physics 2D CircleCollider</strong> from the application menu. Once <a id="id396" class="indexterm"/>added, mark the collider as Trigger and change <strong>Radius</strong> until it approximates the size of the ammo object. See <em>Figure 6.31</em>:</p><div><img src="img/figure_06_31.jpg" alt="Ammo and hazards"/><div><p>Figure 6.31: Configuring the Circle Collider for the Ammo object</p></div></div><p>The ammo should support two final and additional behaviors. First, the ammo should damage and perhaps destroy any target it collides with, and second, the ammo should destroy itself, both after an elapsed time and if it collides with the target. To achieve this, two additional <a id="id397" class="indexterm"/>scripts will be created; specifically, <code class="literal">CollideDestroy.cs</code> and <code class="literal">Ammo.cs</code>. The following code lists the <code class="literal">Ammo.cs</code> file:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
//-----------------------------------------
public class Ammo : MonoBehaviour
{    
    //-----------------------------------------
    //Damage inflicted on Player
    public float Damage = 100f;

    //Lifetime for ammo
    public float LifeTime = 1f;
    //-----------------------------------------
    void Start()
    {
        Invoke ("Die", LifeTime);
    }//-----------------------------------------

    void OnTriggerEnter2D(Collider2D other)
    {
        //If not player then exit
        if(!other.CompareTag("Player"))return;
        
        //Inflict damage
        PlayerControl.Health -= Damage;
    }
    //-----------------------------------------
    public void Die()
    {
        Destroy(gameObject);
    }
}
//-----------------------------------------</pre></div><p>The following code lists the <code class="literal">CollideDestroy.cs</code> file:</p><div><pre class="programlisting">//--------------------------------
using UnityEngine;
using System.Collections;
//--------------------------------
public class CollideDestroy : MonoBehaviour
{
    //--------------------------------
    //When hit objects with associated tag, then destroy
    public string TagCompare = string.Empty;
    //--------------------------------
    void OnTriggerEnter2D(Collider2D other)
    {
        if(!other.CompareTag(TagCompare))return;

        Destroy(gameObject);
    }
    //--------------------------------
}
//-------------------------------- </pre></div><p>The code spanning across these files is functionality that we encountered before when making the <a id="id398" class="indexterm"/>Twin-stick Space Shooter. Both the files should be attached to the ammo object in the scene. Once completed, just drag and drop the ammo object from the scene viewport to the <strong>Project</strong> panel in the <strong>Prefabs</strong> folder. This makes an Ammo prefab, ready to add to any scene. See <em>Figure 6.32</em>:</p><div><img src="img/figure_06_32.jpg" alt="Ammo and hazards"/><div><p>Figure 6.32: Adding the Destroy and Ammo components to the Ammo and then making a prefab</p></div></div><p>Excellent work! You now have an ammo object that fires, moves, and collides with the player. By setting the <strong>Damage</strong> setting high enough, you will be able to destroy the player on impact. Give this a test now by adding an ammo object to the scene and pressing the play icon. Of course, right now, nothing in the scene actually fires the ammo. We'll explore that next.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Gun turrets and ammo</h1></div></div></div><p>We've now <a id="id399" class="indexterm"/>created an ammo object (a projectile) and we've started to engineer a gun turret object, but it doesn't yet spawn ammo. Let's create this functionality now. We have a spawn point positioned in front of the turret parented to it as a child object. We'll attach a new script file called <code class="literal">AmmoSpawner.cs</code> to this object. This script is responsible for generating ammo at regular intervals. Refer to the following code:</p><div><pre class="programlisting">//--------------------------------
using UnityEngine;
using System.Collections;
//--------------------------------
public class AmmoSpawner : MonoBehaviour 
{
    //--------------------------------
    //Reference to ammo prefab
    public GameObject AmmoPrefab = null;

    //Reference to transform
    private Transform ThisTransform = null;

    //Vector for time range
    public Vector2 TimeDelayRange = Vector2.zero;

    //Lifetime for ammo spawned
    public float AmmoLifeTime = 2f;

    //Ammo Speed
    public float AmmoSpeed = 4f;

    //Ammo Damage
    public float AmmoDamage = 100f;
    //--------------------------------
    void Awake()
    {
        ThisTransform = GetComponent&lt;Transform&gt;();
    }
    //--------------------------------
    void Start()
    {
        FireAmmo();
    }
    //--------------------------------
    public void FireAmmo()
    {
        GameObject Obj = Instantiate(AmmoPrefab, ThisTransform.position, ThisTransform.rotation) as GameObject;
        Ammo AmmoComp = Obj.GetComponent&lt;Ammo&gt;();
        Mover MoveComp = Obj.GetComponent&lt;Mover&gt;();
        AmmoComp.LifeTime = AmmoLifeTime;
        AmmoComp.Damage = AmmoDamage;
        MoveComp.Speed = AmmoSpeed;

        //Wait until next random interval
        Invoke("FireAmmo", Random.Range(TimeDelayRange.x, TimeDelayRange.y));
    }
    //--------------------------------
}
//--------------------------------</pre></div><p>The preceding code relies on the <code class="literal">Invoke</code> function called at random intervals using <code class="literal">Random.Range</code> in <a id="id400" class="indexterm"/>order to instantiate a new ammo prefab into the scene. This code could be improved using Object Pooling (or Caching), as discussed in the previous chapter with ammo, but in this case, the code performs acceptably. See <em>Figure 6.33</em>:</p><div><img src="img/figure_06_33.jpg" alt="Gun turrets and ammo"/><div><p>Figure 6.33: A time delay of (0,0) generates ammo continually in a beam. Increase the value to insert reasonable gaps between ammo spawns</p></div></div><p>Excellent! We've now created a gun turret that, like the ammo itself, can be turned into a prefab. Make sure that the <strong>Time Delay</strong> range (the time between ammo spawns) is set to a value higher than zero; otherwise, ammo will be continually generated and become practically impossible <a id="id401" class="indexterm"/>for the player to avoid. Go ahead and position more turrets, if needed, to balance the difficulty of the scene.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec65"/>NPCs and quests</h1></div></div></div><p>
<strong>NPC</strong> stands <a id="id402" class="indexterm"/>for <strong>Non-player Character</strong> and typically refers to any friendly or neutral characters other than the player-controlled character. In our adventure, Level 3 should feature an NPC character standing outside their <a id="id403" class="indexterm"/>house, and they provide us with a quest; specifically, to collect a gem item from Level 2, which features many hazards, including pits and gun turrets, as we've seen. To create the NPC character, we'll simply duplicate the player and adjust the character color, making them appear distinct. Thus, simply drag and drop the <strong>Player</strong> prefab from the <strong>Project</strong> panel to the Level 2 scene and position it near the house area. Then, remove all additional components (such as the Player Controller and Collider) to return this character back to a standard sprite that is not player-controlled. See <em>Figure 6.34</em>:</p><div><img src="img/figure_06_34.jpg" alt="NPCs and quests"/><div><p>Figure 6.34: Creating an NPC from the player character prefab</p></div></div><p>Now, let's invert the character's <strong>X</strong> scale to make him or her face left instead of right. Select the parent NPC object as opposed to its constituent limbs, such as hands and arms, and invert its <strong>X</strong> <a id="id404" class="indexterm"/>scale. All child objects will flip to face the direction of their parent. See <em>Figure 6.35</em>:</p><div><img src="img/figure_06_35.jpg" alt="NPCs and quests"/><div><p>Figure 6.35: Flipping the X scale for a character NPC</p></div></div><p>We should also change the color of the NPC from green to red to distinguish him from the player. Now, the character is a multipart object composed from several sprite renderers. We <a id="id405" class="indexterm"/>could select each object and change its color individually via the <strong>Object Inspector</strong>. However, it's easier to select all the objects and change their color together; Unity 5 supports multi-object editing for common properties. See <em>Figure 6.36</em>:</p><div><img src="img/figure_06_36.jpg" alt="NPCs and quests"/><div><p>Figure 6.36: Setting the NPC color</p></div></div><p>The NPC should talk to the player on approach. This means that when the player approaches the NPC, the NPC should display dialog text. The text to be displayed varies, depending on the status of their quest. On a first visit, the NPC will give the player a quest. On a second visit, the NPC will respond differently, depending on whether the quest has been completed in the meantime. To start creating this functionality, we need to determine when the player approaches the NPC. This is achieved using a Collider. Consequently, select the NPC object in the scene and then choose <strong>Component</strong> | <strong>Physics 2D</strong> | <strong>Box Collider 2D</strong> from the application menu. Size the collider not to approximate the NPC specifically, but to approximate the area around the NPC in which the player should enter to have a conversation. Be sure to mark the collider as a Trigger object, allowing the player to <a id="id406" class="indexterm"/>enter and pass through. See <a id="id407" class="indexterm"/>
<em>Figure 6.37</em>:</p><div><img src="img/figure_06_37.jpg" alt="NPCs and quests"/><div><p>Figure 6.37: Configuring the NPC Collider</p></div></div><p>At this stage, we need a GUI element to act as the conversation panel to display conversation text when the NPC speaks. This configuration simply consists of a GUI Canvas object with a Text object child. Both of these objects can be created from the application menu with <strong>GameObject</strong> | <strong>UI</strong> | <strong>Canvas and GameObject</strong> | <strong>UI</strong> | <strong>Text</strong> respectively. The Canvas object should also have a CanvasGroup component attached using the <strong>Component</strong> | <strong>Layout</strong> | <strong>CanvasGroup</strong> menu option. This lets you set the alpha transparency for the panel and child objects as one complete unit. The Alpha member can be changed from the <a id="id408" class="indexterm"/>
<strong>Object Inspector</strong>. A value of <code class="literal">1</code> means fully visible and value of <code class="literal">0</code> means fully transparent. See <em>Figure 6.38</em>:</p><div><img src="img/figure_06_38.jpg" alt="NPCs and quests"/><div><p>Figure 6.38: Adding a Canvas Group component to the GUI conversation panel</p></div></div><p>Excellent. We now have the ability, if we need to, to fade the panel in and out simply by animating the Alpha value from <code class="literal">0</code> to <code class="literal">1</code> over time. However, we still need functionality to maintain quest information to determine whether a quest has been assigned and to determine which <a id="id409" class="indexterm"/>text should be displayed in the conversation, based on the quest completion status. To do this, a new class must be created, <code class="literal">QuestManager.cs</code>. This class will allow us to create and maintain quest information. Refer to the  <em>Code Sample 6.8</em>:</p><div><pre class="programlisting">//--------------------------------
using UnityEngine;
using System.Collections;
//--------------------------------
[System.Serializable]
public class Quest
{
    //Quest completed status
    public enum QUESTSTATUS {UNASSIGNED=0,ASSIGNED=1,COMPLETE=2};
    public QUESTSTATUS Status = QUESTSTATUS.UNASSIGNED;
    public string QuestName = string.Empty;
}
//--------------------------------
public class QuestManager : MonoBehaviour
{
    //--------------------------------
    //All quests in game
    public Quest[] Quests;
    private static QuestManager SingletonInstance = null;
    public static QuestManager ThisInstance
    {
        get{
                if(SingletonInstance==null)
                {
                    GameObject QuestObject = new GameObject ("Default");
                    SingletonInstance = QuestObject.AddComponent&lt;QuestManager&gt;();
                }
                return SingletonInstance;
            }
    }
    //--------------------------------
    void Awake()
    {
        //If there is an existing instance, then destory
        if(SingletonInstance)
        {
            DestroyImmediate(gameObject);
            return;
        }

        //This is only instance
        SingletonInstance = this;
        DontDestroyOnLoad(gameObject);
    }
    //--------------------------------
    public static Quest.QUESTSTATUS GetQuestStatus(string QuestName)
    {
        foreach(Quest Q in ThisInstance.Quests)
        {
            if(Q.QuestName.Equals(QuestName))
                return Q.Status;
        }

        return Quest.QUESTSTATUS.UNASSIGNED;
    }
    //--------------------------------
    public static void SetQuestStatus(string QuestName, Quest.QUESTSTATUS NewStatus)
    {
        foreach(Quest Q in ThisInstance.Quests)
        {
            if(Q.QuestName.Equals(QuestName))
            {
                Q.Status = NewStatus;
                return;
            }
        }
    }
    //--------------------------------
    //Resets quests back to unassigned state
    public static void Reset()
    {
        if(ThisInstance==null)return;

        foreach(Quest Q in ThisInstance.Quests)
            Q.Status = Quest.QUESTSTATUS.UNASSIGNED;
        
    }
    //--------------------------------
}
//--------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec27"/>Code Sample 6.8</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">QuestManager</code> maintains a list of all quests (<code class="literal">Quest</code>). That is, a list of all possible <a id="id410" class="indexterm"/>quests within the game and not a list of only assigned or completed quests. The <code class="literal">Quest</code> class defines the name and status for a single and specific quest.</li><li class="listitem" style="list-style-type: disc">Any single quest can be <code class="literal">UNASSIGNED</code> (meaning that the player hasn't collected it), <code class="literal">ASSIGNED</code> (the player has collected it but not completed it), and <code class="literal">COMPLETE</code> (the player has collected and completed it).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">GetQuestStatus</code> function retrieves the completed status of the specified quest. The <code class="literal">SetQuestStatus</code> function assigns a new status to the specified quest. These are static functions, and so any script can set or get this data from any place.</li></ul></div><p>To use this object, create an instance in the scene (the first scene of the game), and then define all the quests that can be collected via the <strong>Object Inspector</strong>. In our game, there is only quest available: the quest given by an NPC character to collect a stolen gemstone from Level 2, the hazardous scene protected by gun turrets. See <em>Figure 6.39</em> for how I configured quests to work with <strong>Quest Manager</strong>:</p><div><img src="img/figure_06_39.jpg" alt="Code Sample 6.8"/><div><p>Figure 6.39: Defining in-game quests via QuestManager</p></div></div><p>
<code class="literal">QuestManager</code> defines all the possible quests in the game, whether or not they're collected <a id="id411" class="indexterm"/>by the player. However, the NPC still needs to assign the quest to the player on approach. This can be achieved with the script file, <code class="literal">QuestGiver.cs</code>. See the following code. This script file should be attached to anything that gives quests, such as the NPC:</p><div><pre class="programlisting">//--------------------------------
using UnityEngine;
using System.Collections;
using UnityEngine.UI;
//--------------------------------
public class QuestGiver : MonoBehaviour
{
    //--------------------------------
    //Human readable quest name
    public string QuestName = string.Empty;
    //Reference to UI Text Box
    public Text Captions = null;
    //List of strings to say
    public string[] CaptionText;
    //--------------------------------
    void OnTriggerEnter2D(Collider2D other) 
    {
        if(!other.CompareTag("Player"))return;

        Quest.QUESTSTATUS Status = QuestManager.GetQuestStatus(QuestName);
        Captions.text = CaptionText[(int) Status]; //Update GUI text
    }
    //--------------------------------
    void OnTriggerExit2D(Collider2D other) 
    {
        Quest.QUESTSTATUS Status = QuestManager.GetQuestStatus(QuestName);
        if(Status == Quest.QUESTSTATUS.UNASSIGNED)
            QuestManager.SetQuestStatus(QuestName, Quest.QUESTSTATUS.ASSIGNED);

        if(Status == Quest.QUESTSTATUS.COMPLETE)
            Application.LoadLevel(5); //Game completed, go to win screen
    }
}
//--------------------------------</pre></div><p>After <a id="id412" class="indexterm"/>attaching this script to the NPC, give the game a test by pressing the play icon on the toolbar. Approach the NPC, and the GUI text should change to the specified quest as defined for the <strong>QuestName</strong> field for the <strong>QuestGiver</strong> component in the <strong>Object Inspector</strong>. This name should match <strong>QuestName</strong>, as defined in the <code class="literal">QuestManager</code> class. See <em>Figure 6.40</em>:</p><div><img src="img/figure_06_40.jpg" alt="Code Sample 6.8"/><div><p>Figure 6.40: Defining the QuestGiver component</p></div></div><p>The assigned quest is to collect a gemstone, but our levels lack a stone. Let's now add one for the <a id="id413" class="indexterm"/>player to collect. To do this, drag and drop the GemStone texture from the project panel (<code class="literal">Texture</code> folder) to scene 2 on the topmost ledge so that the player has to climb to reach it (a challenge!). See <em>Figure 6.41</em>. Be sure to attach a <strong>Circle Collider</strong> trigger to the object, allowing it to collide with the player.</p><div><img src="img/figure_06_41.jpg" alt="Code Sample 6.8"/><div><p>Figure 6.41: Creating a Quest object</p></div></div><p>Finally, we'll need a <code class="literal">QuestItem</code> script to set the quest status on the <code class="literal">QuestManager</code> class when the item is collected, allowing <code class="literal">QuestGiver</code> to determine whether the gem has been collected the next time the player visits. The <code class="literal">QuestItem</code> script should be attached to the Gem object. Refer to the following code:</p><div><pre class="programlisting">//--------------------------------
using UnityEngine;
using System.Collections;
//--------------------------------
public class QuestItem : MonoBehaviour 
{
    //--------------------------------
    public string QuestName;
    private AudioSource ThisAudio = null;
    private SpriteRenderer ThisRenderer = null;
    private Collider2D ThisCollider = null;
    //--------------------------------
    void Awake()
    {
        ThisAudio = GetComponent&lt;AudioSource&gt;();
        ThisRenderer = GetComponent&lt;SpriteRenderer&gt;();
        ThisCollider = GetComponent&lt;Collider2D&gt;();
    }
    //--------------------------------
    // Use this for initialization
    void Start () 
    {
        //Hide object
        gameObject.SetActive(false);

        //Show object if quest is assigned
        if(QuestManager.GetQuestStatus(QuestName) == Quest.QUESTSTATUS.ASSIGNED)
            gameObject.SetActive(true);
    }
    //--------------------------------
    //If item is visible and collected
    void OnTriggerEnter2D(Collider2D other) 
    {
        if(!other.CompareTag("Player"))return;

        if(!gameObject.activeSelf)return;
        
        //We are collected. Now complete quest
        QuestManager.SetQuestStatus(QuestName, Quest.QUESTSTATUS.COMPLETE);

        ThisRenderer.enabled=ThisCollider.enabled=false;

        if(ThisAudio!=null)ThisAudio.Play(); //Play sound if any attached
    }
    //-------------------------------
}</pre></div><p>The <a id="id414" class="indexterm"/>preceding code is responsible for setting the quest status to completed when the gem (quest item) object is collected as the player enters the trigger volume. This happens through the <code class="literal">QuestManager</code> class.</p><p>Excellent work! You now have a completed integrated quest system and an NPC character. The complete files for this project can be found in the <code class="literal">Chapter06/End</code> folder. I highly recommend checking them out and playing the game. See <em>Figure 6.42</em>:</p><div><img src="img/figure_06_42.jpg" alt="Code Sample 6.8"/><div><p>Figure 6.42: The completed game!</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec66"/>Summary</h1></div></div></div><p>Great work! We've now completed the 2D adventure game. Some minor details were not covered in this chapter for the sake of clarity and conciseness because we've seen the methods or content already in earlier chapters. Hence, it's important to open the course files and check out the completed project, seeing how the code works. Overall, in having reached this far in the book, you have three completed Unity projects to your name. So, in the next chapter, we'll wrap up everything that we've seen so far and get started on the grand finale: the final, fourth project!</p></div></body></html>