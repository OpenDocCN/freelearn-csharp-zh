<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-17"><a id="_idTextAnchor016"/>1</h1>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Observability Needs of Modern Applications</h1>
<p>With the increasing complexity of distributed systems, we need better tools to build and operate our applications. <strong class="bold">Distributed tracing</strong> is one such technique that allows you to collect<a id="_idIndexMarker000"/> structured and correlated telemetry with minimum effort and enables observability vendors to build powerful analytics and automation.</p>
<p>In this chapter, we’ll explore common observability challenges and see how distributed tracing brings observability to our systems where logs and counters can’t. We’ll see how correlation and causation along with structured and consistent telemetry help answer arbitrary questions about the system and mitigate issues faster.</p>
<p>Here’s what you will learn:</p>
<ul>
<li>An overview of monitoring techniques using counters, logs, and events</li>
<li>Core concepts of distributed tracing – the span and its structure</li>
<li>Context propagation standards</li>
<li>How to generate meaningful and consistent telemetry</li>
<li>How to use distributed tracing along with metrics and logs for performance analysis and debugging</li>
</ul>
<p>By the end of this chapter, you will become familiar with the core concepts and building blocks of distributed tracing, which you will be able to use along with other telemetry signals to debug functional issues and investigate performance issues in distributed applications.</p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Understanding why logs and counters are not enough</h1>
<p>Monitoring and observability cultures vary across the industry; some teams use ad hoc debugging with <code>printf</code> while others employ sophisticated observability solutions and automation. Still, almost every system uses a combination of common telemetry signals: logs, events, metrics or counters, and profiles. Telemetry collection<a id="_idIndexMarker001"/> alone is not enough. A system is <strong class="bold">observable</strong> if we can detect and investigate issues, and to achieve this, we need tools to store, index, visualize, and query the telemetry, navigate across different signals, and automate repetitive analysis.</p>
<p>Before we begin exploring tracing and discovering how it helps, let’s talk about other telemetry signals and their limitations.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Logs</h2>
<p>A <strong class="bold">log</strong> is a record of some event. Logs<a id="_idIndexMarker002"/> typically have a timestamp, level, class name, and formatted message, and may also have a property bag with additional context.</p>
<p>Logs are a low-ceremony tool, with plenty of logging libraries and tools for any ecosystem.</p>
<p>Common problems with logging<a id="_idIndexMarker003"/> include the following:</p>
<ul>
<li><strong class="bold">Verbosity</strong>: Initially, we won’t have enough logs, but eventually, as we fill gaps, we will have too many. They become hard to read and expensive to store.</li>
<li><strong class="bold">Performance</strong>: Logging is a common performance issue even when used wisely. It’s also very common to serialize objects or allocate strings for logging even when the logging level is disabled.</li>
</ul>
<p><em class="italic">One new log statement can take your production down; I did it once. The log I added was written every millisecond. Multiplied by a number of service instances, it created an I/O bottleneck big enough to significantly increase latency and the error rate for users</em>.</p>
<ul>
<li><strong class="bold">Not queryable</strong>: Logs coming from applications are intended for humans. We can add context and unify the format within our application and still only be able to filter logs by context properties. Logs change with every refactoring, disappear, or become out of date. New people joining a team need to learn logging semantics specific to a system, and the learning curve can be steep.</li>
<li><strong class="bold">No correlation</strong>: Logs for different operations are interleaved. The process of finding logs<a id="_idIndexMarker004"/> describing certain operations<a id="_idIndexMarker005"/> is called correlation. In general, log correlation, especially across services, must be implemented manually (spoiler: not in ASP.NET Core).</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Logs are easy to produce but are verbose, and then can significantly impact performance. They are also difficult to filter, query, or visualize.</p>
<p>To be accessible<a id="_idIndexMarker006"/> and useful, logs are sent to some central place, a <strong class="bold">log management system</strong>, which stores, parses, and indexes them so they can be queried. This implies that your logs need to have at least some structure.</p>
<p><code>ILogger</code> in .NET supports structured logging, as we’ll see in <a href="B19423_08.xhtml#_idTextAnchor131"><em class="italic">Chapter 8</em></a>, <em class="italic">Writing Structured and Correlated Logs</em>, so you get the human-readable message, along with the context. Structured logging, combined with structured storage and indexing, converts your logs into rich events that you can use for almost anything.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Events</h2>
<p>An <strong class="bold">event</strong> is a structured record of something. It has a timestamp<a id="_idIndexMarker007"/> and a property bag. It may have a name, or that could just be one of the properties.</p>
<p>The difference between logs and events is semantical – an event is structured and usually follows a specific schema.</p>
<p>For example, an event that describes adding an item to a shopping bag should have a well-known name, such as <code>shopping_bag_add_item</code> with <code>user-id</code> and <code>item-id</code> properties. Then, you can query them by name, item, and user. For example, you can find the top 10 popular items across all users.</p>
<p>If you write it as a log message, you’d probably write something like this:</p>
<pre class="source-code">
logger.LogInformation("Added '{item-id}' to shopping bag
  for '{user-id}'", itemId, userId)</pre>
<p>If your logging provider captures individual properties, you would get the same context as with events. So, now we can find every log for this user and item, which probably includes other logs not related to adding an item.</p>
<p class="callout-heading">Note</p>
<p class="callout">Events<a id="_idIndexMarker008"/> with consistent schema can be queried efficiently but have the same verbosity and performance problems as logs.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Metrics and counters</h2>
<p>Logs and events share the same problem – verbosity and performance overhead. One way to solve them is aggregation.</p>
<p>A <strong class="bold">metric</strong> is a value of something aggregated by dimensions<a id="_idIndexMarker009"/> and over a period of time. For example, a request latency metric can have an HTTP route, status code, method, service name, and instance dimensions.</p>
<p>Common problems with metrics<a id="_idIndexMarker010"/> include the following:</p>
<ul>
<li><strong class="bold">Cardinality</strong>: Each combination of dimensions is a time series, and aggregation happens within one time series. Adding a new dimension causes a combinatorial explosion, so metrics must have low cardinality – that is, they cannot have too many dimensions, and each one must have a small number of distinct values. As a result, you can’t measure granular things such as per-user experience with metrics.</li>
<li><strong class="bold">No causation</strong>: Metrics only show correlation and no cause and effect, so they are not a great tool to investigate issues.</li>
</ul>
<p>As an expert on your system, you might use your intuition to come up with possible reasons for certain types of behavior and then use metrics to confirm your hypothesis.</p>
<ul>
<li><code>queue_is_full</code> or <code>queue_is_empty</code>. Something such as <code>queue_utilization</code> would be more generic. Over time, the number of metrics grows along with the number of alerts, dashboards, and team processes<a id="_idIndexMarker011"/> relying on them.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Metrics have low impact on performance, low volume that doesn’t grow much with scale, low storage costs, and low query time. They are great for dashboards and alerts but not for issue investigation or granular analytics.</p>
<p>A <strong class="bold">counter</strong> is a single time series – it’s a metric <a id="_idIndexMarker012"/>without dimensions, typically used to collect resource utilization such as CPU load or memory usage. Counters don’t work well for application performance or usage, as you need a dedicated counter per each combination of attributes, such as HTTP route, status code, and method. It is difficult to collect and even harder to use. Luckily, .NET supports metrics with dimensions, and we will discuss them in <a href="B19423_07.xhtml#_idTextAnchor115"><em class="italic">Chapter 7</em></a>, <em class="italic">Adding </em><em class="italic">Custom Metrics</em>.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>What’s missing?</h2>
<p>Now you know all you need to monitor a monolith or small distributed system – use metrics for system health analysis and alerts, events for usage, and logs for debugging. This approach has taken the tech industry far, and there is nothing essentially wrong with it.</p>
<p>With up-to-date documentation, a few key performance and usage metrics, concise, structured, correlated, and consistent events, common conventions, and tools across all services, anyone operating your system can do performance analysis and debug issues.</p>
<p class="callout-heading">Note</p>
<p class="callout"><em class="italic">So, the ultimate goal is to efficiently operate a system, and the problem is not a specific telemetry signal or its limitations but a lack of standard solutions and practices, correlation, and structure for </em><em class="italic">existing signals.</em></p>
<p>Before we jump into distributed tracing and see how its ecosystem addresses these gaps, let’s summarize the new requirements we have for the perfect observability solution we intend to solve with tracing and the new capabilities it brings. Also, we should keep in mind the old capabilities – low-performance overhead and manageable costs.</p>
<h3>Systematic debugging</h3>
<p>We need to be able<a id="_idIndexMarker013"/> to investigate issues in a generic way. From an error report to an alert on a metric, we should be able to drill down into the issue, follow specific requests end to end, or bubble up from an error deep in the stack to understand its effect on users.</p>
<p>All this should be reasonably easy to do when you’re on call and paged at 2AM to resolve an incident in production.</p>
<h3>Answering ad hoc questions</h3>
<p>I might want to understand <a id="_idIndexMarker014"/>whether users from Redmond, WA, who purchased a product from my website are experiencing longer delivery times than usual and why – because of the shipment company, rain, cloud provider issues in this region, or anything else.</p>
<p>It should not be required to add more telemetry to answer most of the usage or performance questions. Occasionally, you’d need to add a new context property or an event, but it should be rare on a stable code path.</p>
<h3>Self-documenting systems</h3>
<p>Modern systems<a id="_idIndexMarker015"/> are dynamic – with continuous deployments, feature flag changes in runtime, and dozens of external dependencies with their own instabilities, nobody can know everything.</p>
<p>Telemetry becomes your single source of truth. Assuming it has enough context and common semantics, an observability vendor should be able to visualize it reasonably well.</p>
<h3>Auto-instrumentation</h3>
<p>It’s difficult to instrument <a id="_idIndexMarker016"/>everything in your system – it’s repetitive, error-prone, and hard to keep up to date, test, and enforce common schema and semantics. We need shared instrumentations for common libraries, while we would only add application-specific telemetry<a id="_idIndexMarker017"/> and context.</p>
<p>With an understanding of these requirements, we will move on to distributed tracing.</p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Introducing distributed tracing</h1>
<p><strong class="bold">Distributed tracing</strong> is a technique that brings<a id="_idIndexMarker018"/> structure, correlation and causation to collected telemetry. It defines a special event called <em class="italic">span</em> and specifies causal relationships between spans. Spans follow common conventions that are used to visualize and analyze traces.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Span</h2>
<p>A <strong class="bold">span</strong> describes an operation such as an incoming<a id="_idIndexMarker019"/> or outgoing HTTP<a id="_idIndexMarker020"/> request, a database call, an expensive I/O call, or any other interesting call. It has just enough structure to represent anything and still be useful. Here are the most important<a id="_idIndexMarker021"/> span properties:</p>
<ul>
<li>The span’s name should describe the operation type in human-readable format, have low cardinality, and be human-readable.</li>
<li>The span’s start time and duration.</li>
<li>The status indicates success, failure, or no status.</li>
<li>The span kind distinguishes the client, server, and internal calls, or the producer and consumer for async scenarios.</li>
<li>Attributes (also known as tags or annotations) describe<a id="_idIndexMarker022"/> specific<a id="_idIndexMarker023"/> operations.</li>
<li>Span context identifies spans and is propagated everywhere, enabling correlation. A parent span identifier is also included on child spans for causation.</li>
<li>Events provide additional information about operations within a span.</li>
<li>Links connect traces and spans when parent-child relationships don’t work – for example, for batching<a id="_idIndexMarker024"/> scenarios.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">In .NET, the tracing span is represented by <code>System.Diagnostics.Activity</code>. The <code>System.Span</code> class is not related to distributed tracing.</p>
<h3>Relationships between spans</h3>
<p>A span is a unit of tracing, and to trace<a id="_idIndexMarker025"/> more complex operations, we need multiple spans.</p>
<p>For example, a user may attempt to get an image and send a request to the service. The image is not cached, and the service requests it from the cold storage (as shown in <em class="italic">Figure 1</em><em class="italic">.1</em>):</p>
<div><div><img alt="Figure 1.1 – A GET image request flow" src="img/B19423_01_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – A GET image request flow</p>
<p>To make this operation debuggable, we should report multiple spans:</p>
<ol>
<li>The incoming request</li>
<li>The attempt to get the image from the cache</li>
<li>Image retrieval from the cold storage</li>
<li>Caching the image</li>
</ol>
<p>These spans form a <code>trace-id</code>. Within the trace, each span is identified by <code>span-id</code>. Spans include a pointer to a parent span – it’s just their parent’s <code>span-id</code>.</p>
<p><code>trace-id</code>, <code>span-id</code>, and <code>parent-span-id</code> allow us to not only correlate spans but also record relationships between them. For example, in <em class="italic">Figure 1</em><em class="italic">.2</em>, we can see that Redis <code>GET</code>, <code>SETEX</code>, and <code>HTTP GET</code> spans are siblings and the incoming request is their parent:</p>
<div><div><img alt="Figure 1.2 – Trace visualization showing relationships between spans" src="img/B19423_01_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Trace visualization showing relationships between spans</p>
<p>Spans can have more complicated relationships, which we’ll talk about later in <a href="B19423_06.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <em class="italic">Tracing </em><em class="italic">Your Code</em>.</p>
<p><code>trace-id</code> and <code>span-id</code>) enables even more interesting<a id="_idIndexMarker027"/> cross-signal scenarios. For example, you can stamp parent span context on logs (spoiler: just configure <code>ILogger</code> to do it) and you can correlate logs to traces. For example, if you use <code>ConsoleProvider</code>, you will see something like this:</p>
<div><div><img alt="Figure 1.3 – Logs include span context and can be correlated to other signals" src="img/B19423_01_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Logs include span context and can be correlated to other signals</p>
<p>You could also link metrics to traces using exemplars – metric metadata containing the trace context of operations that contributed to a recorded measurement. For instance, you can check examples of spans that <a id="_idIndexMarker028"/>correspond to the long tail of your latency distribution.</p>
<h3>Attributes</h3>
<p><strong class="bold">Span attributes</strong> are a property bag that contains<a id="_idIndexMarker029"/> details about the operation.</p>
<p>Span attributes should describe this specific operation well enough to understand what happened. OpenTelemetry semantic conventions specify attributes for popular technologies to help with this, which we’ll talk about in the <em class="italic">Ensuring consistency and structure</em> section later in this chapter.</p>
<p>For example, an incoming HTTP request is identified with at least the following attributes: the HTTP method, path, query, API route, and status code:</p>
<div><div><img alt="Figure 1.4 – The HTTP server span attributes" src="img/B19423_01_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – The HTTP server span attributes</p>
<h3>Instrumentation points</h3>
<p>So, we have defined<a id="_idIndexMarker030"/> a span and its properties, but when should we create spans? Which attributes should we put on them? While there is no strict standard to follow, here’s the rule of thumb:</p>
<p><em class="italic">Create a new span for every incoming and outgoing network call and use standard attributes for the protocol or technology </em><em class="italic">whenever available.</em></p>
<p>This is what we’ve done previously with the memes example, and it allows us to see what happened on the service boundaries and detect common problems: dependency issues, status, latency, and errors on each service. This also allows us to correlate logs, events, and anything else we collect. Plus, observability backends are aware of HTTP semantics and will know how to interpret and visualize your spans.</p>
<p>There are exceptions<a id="_idIndexMarker031"/> to this rule, such as socket calls, where requests could be too small to be instrumented. In other cases, you might still be rightfully concerned with verbosity and the volume of generated data – we’ll see how to control it with sampling in <a href="B19423_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Configuration and </em><em class="italic">Control Plane</em>.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Tracing – building blocks</h2>
<p>Now that you are familiar<a id="_idIndexMarker032"/> with the core concepts of tracing and its methodology, let’s talk about implementation. We need a set of convenient APIs<a id="_idIndexMarker033"/> to create and enrich spans and pass context around. Historically, every <strong class="bold">Application Performance Monitoring</strong> (<strong class="bold">APM</strong>) tool had its own SDKs<a id="_idIndexMarker034"/> to collect telemetry with their own APIs. Changing the APM vendor meant rewriting all your instrumentation code.</p>
<p>OpenTelemetry solves this problem – it’s a cross-language telemetry platform for tracing, metrics, events, and logs that unifies telemetry collection. Most of the APM tools, log management, and observability backends support OpenTelemetry, so you can change vendors without rewriting any instrumentation code.</p>
<p>.NET tracing implementation conforms to the OpenTelemetry API specification, and in this book, .NET tracing APIs and OpenTelemetry APIs are used interchangeably. We’ll talk about the difference between them in <a href="B19423_06.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <em class="italic">Tracing </em><em class="italic">Your Code</em>.</p>
<p>Even though OpenTelemetry primitives are baked into .NET and the instrumentation code does not depend on them, to collect telemetry<a id="_idIndexMarker035"/> from the application, we still need to add the <strong class="bold">OpenTelemetry SDK</strong>, which has everything we need to configure a collection and an exporter. You might as well write your own solution compatible with .NET tracing APIs.</p>
<p>OpenTelemetry became an industry standard for tracing and beyond; it’s available in multiple languages, and in addition to a unified collection of APIs it provides configurable SDKs<a id="_idIndexMarker036"/> and a standard wire format for the telemetry – <strong class="bold">OpenTelemetry protocol </strong>(<strong class="bold">OTLP</strong>). You can send telemetry to any compatible vendor, either by adding a specific exporter or, if the backend supports OTLP, by configuring the vendor’s endpoint.</p>
<p>As shown in <em class="italic">Figure 1</em><em class="italic">.5</em>, the application configures the OpenTelemetry SDK to export telemetry to the observability backend. Application code, .NET libraries, and various instrumentations use .NET tracing APIs to create spans, which the OpenTelemetry SDK listens to, processes, and forwards to an exporter.</p>
<div><div><img alt="Figure 1.5 – Tracing building blocks" src="img/B19423_01_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Tracing building blocks</p>
<p>So, OpenTelemetry decouples instrumentation<a id="_idIndexMarker037"/> code from the observability vendor, but it does much more than that. Now, different applications can share instrumentation libraries and observability vendors have unified and structured telemetry on top of which they can build rich experiences.</p>
<h3>Instrumentation</h3>
<p>Historically, all APM vendors<a id="_idIndexMarker038"/> had to instrument popular libraries: HTTP clients, web frameworks, Entity Framework, SQL clients, Redis client libraries, RabbitMQ, cloud providers’ SDKs, and so on. That did not scale well. But with .NET tracing APIs and OpenTelemetry semantics, instrumentation became common for all vendors. You can find a growing list of shared community instrumentations in the OpenTelemetry Contrib repo: <a href="https://github.com/open-telemetry/opentelemetry-dotnet-contrib">https://github.com/open-telemetry/opentelemetry-dotnet-contrib</a>.</p>
<p>Moreover, since OpenTelemetry is a vendor-neutral standard and baked into .NET, it’s now possible for libraries to implement native instrumentation – HTTP and gRPC clients, ASP.NET Core, and several other libraries support it.</p>
<p>Even with native tracing support, it’s off by default – you need to install and register specific instrumentation (which we’ll cover in <a href="B19423_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Native Monitoring in .NET</em>). Otherwise, tracing code<a id="_idIndexMarker039"/> does nothing and, thus, does not add any performance overhead.</p>
<h3>Backends</h3>
<p>The <strong class="bold">observability backend</strong> (aka monitoring, APM tool, and log management system) is a set<a id="_idIndexMarker040"/> of tools responsible<a id="_idIndexMarker041"/> for ingestion, storage, indexing, visualization, querying, and probably other things that help you monitor your system, investigate issues, and analyze performance.</p>
<p><strong class="bold">Observability vendors</strong> build these tools and provide rich user experiences<a id="_idIndexMarker042"/> to help you use traces along with other signals.</p>
<p>Collecting traces for common libraries became easy with the OpenTelemetry ecosystem. As you’ll see in <a href="B19423_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Native Monitoring in .NET</em>, most of it can be done automatically with just a few lines of code at startup. But how do we use them?</p>
<p>While you can send spans to <code>stdout</code> and store them on the filesystem, this would not leverage all tracing benefits. Traces can be huge, but even when they are small, grepping them is not convenient.</p>
<p>Tracing visualizations (such as a Gantt chart, trace viewer, or trace timeline) is one of the common features tracing providers have. <em class="italic">Figure 1</em><em class="italic">.6</em> shows a trace timeline in Jaeger – an open source distributed tracing platform:</p>
<div><div><img alt="Figure 1.6 – Trace visualization in Jaeger﻿ with errors marked with exclamation point" src="img/B19423_01_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Trace visualization in Jaeger with errors marked with exclamation point</p>
<p>While it may take a while to find an error log, the visualization shows what’s important – where failures are, latency, and a sequence of steps. As we can see in <em class="italic">Figure 1</em><em class="italic">.6</em>, the frontend call failed because of failure on the storage side, which we can further drill into.</p>
<p>However, we can also see<a id="_idIndexMarker043"/> that the frontend made four consecutive calls into storage, which potentially could be done in parallel to speed things up.</p>
<p>Another common feature is filtering or querying by any of the span properties such as name, <code>trace-id</code>, <code>span-id</code>, <code>parent-id</code>, name, attribute name, status, timestamp, duration, or anything else. An example of such a query is shown in <em class="italic">Figure 1</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 1.7 – A custom Azure Monitor query that calculates the Redis hit rate" src="img/B19423_01_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – A custom Azure Monitor query that calculates the Redis hit rate</p>
<p>For example, we don’t report a metric for the cache hit rate, but we can estimate it from traces. While they’re not precise because of sampling and might be more expensive to query than metrics, we can still do<a id="_idIndexMarker044"/> it ad hoc, especially when we investigate specific failures.</p>
<p>Since traces, metrics, and logs are correlated, you will fully leverage observability capabilities if your vendor supports multiple signals or integrates well with other tools.</p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Reviewing context propagation</h1>
<p>Correlation and causation<a id="_idIndexMarker045"/> are the foundation of distributed tracing. We’ve just covered how related spans share the same <code>trace-id</code> and have a pointer to the parent recorded in <code>parent-span-id</code>, forming a casual chain of operations. Now, let’s explore how it works in practice.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>In-process propagation</h2>
<p>Even within a single service, we usually<a id="_idIndexMarker046"/> have nested<a id="_idIndexMarker047"/> spans. For example, if we trace a request to a REST service that just reads an item from a database, we’d want to see at least two spans – one for an incoming HTTP request and another for a database query. To correlate them properly, we need to pass span context from ASP.NET Core to the database driver.</p>
<p>One option is to pass context explicitly as a function argument. It’s a viable solution in Go, where explicit context propagation is a standard, but in .NET, it would make onboarding onto distributed tracing difficult and would ruin the auto-instrumentation magic.</p>
<p>.NET Activity (aka the span) is propagated implicitly. Current activity can always be accessed via the <code>Activity.Current</code> property, backed up by <code>System.Threading.AsyncLocal&lt;T&gt;</code>.</p>
<p>Using our previous example of a service reading from the database, ASP.NET Core creates an Activity for the incoming request, and it becomes current for anything that happens within the scope of this request. Instrumentation for the database driver creates another one that uses <code>Activity.Current</code> as its parent, without knowing anything about ASP.NET Core and without the user application passing the Activity around. The logging framework would stamp <code>trace-id</code> and <code>span-id</code> from <code>Activity.Current</code>, if configured to do so.</p>
<p>It works for sync or async code, but if you process items in the background using in-memory queues or manipulate with threads explicitly, you would have<a id="_idIndexMarker048"/> to help runtime and propagate activities explicitly. We’ll talk<a id="_idIndexMarker049"/> more about it in <a href="B19423_06.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <em class="italic">Tracing </em><em class="italic">Your Code</em>.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Out-of-process propagation</h2>
<p>In-process correlation<a id="_idIndexMarker050"/> is awesome, and for monolith<a id="_idIndexMarker051"/> applications, it would be almost sufficient. But in the microservice world, we need to trace requests end to end and, therefore, propagate context over the wire, and here’s where standards come into play.</p>
<p>You can find multiple practices in this space – every complex system used to support something custom, such as <code>x-correlation-id</code> or <code>x-request-id</code>. You can find <code>x-cloud-trace-context</code> or <code>grpc-trace-bin</code> in old Google systems, <code>X-Amzn-Trace-Id</code> on AWS, and <code>Request-Id</code> variations and <code>ms-cv</code> in the Microsoft ecosystem. Assuming your system is heterogeneous and uses a variety of cloud providers and tracing tools, correlation is difficult.</p>
<p>Trace<a id="_idIndexMarker052"/> context (which you can explore in more detail at <a href="https://www.w3.org/TR/trace-context">https://www.w3.org/TR/trace-context</a>) is a relatively new standard, converting context propagation over HTTP, but it’s widely adopted and used by default in OpenTelemetry and .NET.</p>
<h3>W3C Trace Context</h3>
<p>The trace context<a id="_idIndexMarker053"/> standard defines <code>traceparent</code> and <code>tracestate</code> HTTP headers and<a id="_idIndexMarker054"/> the format to populate context on them.</p>
<h4>The traceparent header</h4>
<p>The <code>traceparent</code> is an HTTP request header<a id="_idIndexMarker055"/> that carries the protocol version, <code>trace-id</code>, <code>parent-id</code>, and <code>trace-flags</code> in the following format:</p>
<pre class="source-code">
traceparent: {version}-{trace-id}-{parent-id}-{trace-flags}</pre>
<ul>
<li><code>version</code>: The protocol version – only <code>00</code> is defined at the moment.</li>
<li><code>trace-id</code>: The logical end-to-end operation ID.</li>
<li><code>parent-id</code>: Identifies the client span and serves as a parent for the corresponding server span.</li>
<li><code>trace-flags</code>: Represents the sampling decision (which we’ll talk about in <a href="B19423_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Configuration and Control Plane</em>). For now, we can determine that <code>00</code> indicates that the parent span was sampled out and <code>01</code> means it was sampled in.</li>
</ul>
<p>All identifiers must be present – that is, <code>traceparent</code> has a fixed length<a id="_idIndexMarker056"/> and is easy to parse. <em class="italic">Figure 1</em><em class="italic">.8</em> shows an example of context propagation with the <code>traceparent</code> header:</p>
<div><div><img alt="Figure 1.8 – traceparent is populated from the outgoing span context and becomes a parent for the incoming span" src="img/B19423_01_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – traceparent is populated from the outgoing span context and becomes a parent for the incoming span</p>
<p class="callout-heading">Note</p>
<p class="callout">The protocol does not require creating spans and does not specify instrumentation points. Common practice is to create spans per outgoing and incoming requests, and put client span context into request headers.</p>
<h4>The tracestate header</h4>
<p>The <code>tracestate</code> is another request header, which carries<a id="_idIndexMarker057"/> additional context for the tracing tool to use. It’s <em class="italic">designed for OpenTelemetry or an APM tool to carry additional control information and not for application-specific context</em> (covered in detail later in the <em class="italic">Baggage</em> section).</p>
<p>The <code>tracestate</code> consists of a list of key-value pairs, serialized to a string with the following format: <code>"vendor1=value1,vendor2=value2"</code>.</p>
<p>The <code>tracestate</code> can be used to propagate incompatible legacy correlation IDs, or some additional identifiers vendor needs.</p>
<p>OpenTelemetry, for example, uses it to carry a sampling probability and score. For example, <code>tracestate: "ot=r:3;p:2"</code> represents a key-value pair, where the key is <code>ot</code> (OpenTelemetry tag) and the value is <code>r:3;p:2</code>.</p>
<p>The <code>tracestate</code> header has a soft limitation<a id="_idIndexMarker058"/> on size (512 characters) and can be truncated.</p>
<h4>The traceresponse (draft) header</h4>
<p>Unlike <code>traceparent</code> and <code>tracestate</code>, <strong class="bold">traceresponse</strong> is a response header. At the time<a id="_idIndexMarker059"/> of writing, it’s defined<a id="_idIndexMarker060"/> in W3C Trace-Context Level 2 (<a href="https://www.w3.org/TR/trace-context-2/">https://www.w3.org/TR/trace-context-2/</a>) and has reached W3C Editor’s Draft status. There is no support for it in .NET or OpenTelemetry.</p>
<p><code>traceresponse</code> is very similar to <code>traceparent</code>. It has the same format, but instead of client-side identifiers, it returns the <code>trace-id</code> and <code>span-id</code> values of the server span:</p>
<pre class="source-code">
traceresponse: 00-{trace-id}-{child-id}-{trace-flags}</pre>
<p><code>traceresponse</code> is optional in the sense that the server does not need to return it, even if it supports W3C Trace-Context Level 2. It’s useful to return <code>traceresponse</code> when the client did not pass a valid <code>traceparent</code>, but can log <code>traceresponse</code>.</p>
<p>External-facing services may decide to start a new trace, because they don’t trust the caller’s <code>trace-id</code> generation algorithm. Uniform random distribution is one concern; another reason could be a special <code>trace-id</code> format. If the service restarts a trace, it’s a good idea to return the <code>traceresponse</code> header to caller.</p>
<h3>B3</h3>
<p>The B3<a id="_idIndexMarker061"/> specification (<a href="https://github.com/openzipkin/b3-propagation">https://github.com/openzipkin/b3-propagation</a>) was adopted<a id="_idIndexMarker062"/> by Zipkin – one of the first distributed tracing systems.</p>
<p>B3 identifiers can be propagated as a single <code>b3</code> header in the following format:</p>
<pre class="source-code">
b3: {trace-id}-{span-id}-{sampling-state}-{parent-span-id}</pre>
<p>Another way is to pass individual components, using <code>X-B3-TraceId</code>, <code>X-B3-SpanId</code>, <code>X-B3-ParentSpanId</code>, and <code>X-B3-Sampled</code>.</p>
<p>The sampling state suggests whether a service should trace the corresponding request. In addition to <code>0</code> (don’t record) and <code>1</code> (do record), it allows us to force tracing with a flag set to <code>d</code>. It’s usually done for debugging purposes. The sampling state can be passed without other identifiers to specify the desired sampling decision to the service.</p>
<p class="callout-heading">Note</p>
<p class="callout">The key difference with W3C Trace-Context, beyond header names, is the presence of both <code>span-id</code> and <code>parent-span-id</code>. B3 systems can use the same <code>span-id</code> on the client and server sides, creating a single span for both.</p>
<p>Zipkin reuses <code>span-id</code> from the incoming request, also specifying <code>parent-span-id</code> on it. The Zipkin span represents the client and server at the same time, as shown in <em class="italic">Figure 1</em><em class="italic">.9</em>, recording different durations and statuses for them:</p>
<div><div><img alt="Figure 1.9 – Zipkin creates one span to represent the client and server" src="img/B19423_01_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Zipkin creates one span to represent the client and server</p>
<p>OpenTelemetry and .NET support <code>b3</code> headers<a id="_idIndexMarker063"/> but ignore <code>parent-span-id</code> – they generate a new <code>span-id</code> for every span, as it’s not possible<a id="_idIndexMarker064"/> to reuse <code>span-id</code> (see <em class="italic">Figure 1</em><em class="italic">.10</em>).</p>
<div><div><img alt="Figure 1.10 – OpenTelemetry does not use parent-span-id from B3 headers and creates different spans for the client and server" src="img/B19423_01_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – OpenTelemetry does not use parent-span-id from B3 headers and creates different spans for the client and server</p>
<h3>Baggage</h3>
<p>So far, we have talked about span<a id="_idIndexMarker065"/> context and correlation. But in many cases, distributed<a id="_idIndexMarker066"/> systems have application-specific context. For example, you authorize users on your frontend service, and after that, <code>user-id</code> is not needed for application logic, but you still want to add it as an attribute on spans from all services to query and aggregate it on a per-user basis.</p>
<p>You can stamp <code>user-id</code> once on the frontend. Then, spans recorded on the backend will not have <code>user-id</code>, but they will share the same <code>trace-id</code> as the frontend. So, with some joins in your queries, you can still do per-user analysis. It works to some extent but may be expensive or slow, so you might decide to propagate <code>user-id</code> and stamp it on the backend spans too.</p>
<p>The <strong class="bold">baggage</strong> (<a href="https://www.w3.org/TR/baggage/">https://www.w3.org/TR/baggage/</a>) defines a generic propagation<a id="_idIndexMarker067"/> format for distributed<a id="_idIndexMarker068"/> context, and you can use it for business logic or anything else by adding, reading, removing, and modifying baggage members. For example, you can route requests to the test environment and pass feature flags or extra telemetry context.</p>
<p>Baggage consists of a list of semicolon-separated members. Each member has a key, value, and optional properties in the following formats –<code> key=value;property1;key2=property2</code> or <code>key=value;property1;key2=property2,anotherKey=anotherValue</code>.</p>
<p>OpenTelemetry and .NET only propagate baggage, but don’t stamp it on any telemetry. You can configure <code>ILogger</code> to stamp baggage and need to enrich traces explicitly. We’ll see how it works in <a href="B19423_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Configuration and </em><em class="italic">Control Plane</em>.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You should not put any sensitive information in baggage, as it’s almost impossible to guarantee where it would flow – your application or sidecar infrastructure can forward it to your cloud provider or anywhere else.</p>
<p class="callout">Maintain a list of well-known baggage keys across your system and only use known ones, as you might receive baggage from another system otherwise.</p>
<p>Baggage specification<a id="_idIndexMarker069"/> has a <em class="italic">working draft</em> status and may still<a id="_idIndexMarker070"/> change.</p>
<p class="callout-heading">Note</p>
<p class="callout">While the W3C Trace Context standard is HTTP-specific and B3 applies to any RPC calls, they are commonly used for any context propagation needs – for example, they are passed as the event payload in messaging scenarios. This may change once protocol-specific standards are introduced.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Ensuring consistency and structure</h1>
<p>As we already defined, spans<a id="_idIndexMarker071"/> are structured<a id="_idIndexMarker072"/> events describing interesting operations.</p>
<p>A span’s start time, duration, status, kind, and context are strongly typed – they enable correlation and causation, allowing us to visualize traces and detect failures or latency issues.</p>
<p>The span’s name and attributes describe an operation but are not strongly typed or strictly defined. If we don’t populate them in a meaningful way, we can detect an issue but have no knowledge of what actually happened.</p>
<p>For example, for client HTTP calls, beyond generic properties, we want to capture at least the URL, method, and response code (or exception) – if we don’t know any of these, we’re blind. Once we populate them, we can start doing some powerful analysis with queries over such spans to answer the following common questions:</p>
<ul>
<li>Which dependency calls were made in the scope of this request? Which of them failed? What was the latency of each of them?</li>
<li>Does my application make independent dependency calls in parallel or sequentially? Does it make any unnecessary requests when they can be done lazily?</li>
<li>Are dependency endpoints configured correctly?</li>
<li>What are the success or error rates and latency per dependency API?</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">This analysis relies on an application using the same attributes for all HTTP dependencies. Otherwise, the operator that performs the queries will have a hard time writing and maintaining them.</p>
<p>With unified and community-driven telemetry collection taken off the observability vendor’s plate, they can now fully focus on (semi-)automating analysis and giving us powerful performance and fault analysis tools.</p>
<p>OpenTelemetry defines<a id="_idIndexMarker073"/> a set of semantic<a id="_idIndexMarker074"/> conventions for spans, traces, and resources, which we’ll talk more about in <a href="B19423_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Best Practices</em>.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Building application topology</h2>
<p>Distributed tracing, combined<a id="_idIndexMarker075"/> with semantic conventions, allows us to build visualizations such as an application map (aka service map), as shown in <em class="italic">Figure 1</em><em class="italic">.11</em> – you could see your whole system along with key health metrics. It’s an entry point to any investigation.</p>
<div><div><img alt="Figure 1.11 – An Azure Monitor ﻿application map for a meme service is an up-to-date system diagram with all the basic health metrics" src="img/B19423_01_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – An Azure Monitor application map for a meme service is an up-to-date system diagram with all the basic health metrics</p>
<p>Observability vendors depend on trace and metrics semantics to build service maps. For example, the presence of HTTP attributes on the client span represents an outgoing HTTP call, and we need to show the outgoing arrow to a new dependency node. We should name this node based on the span’s host attribute.</p>
<p>If we see the corresponding<a id="_idIndexMarker076"/> server span, we can now merge the server node with the dependency node, based on span context and causation. There are other visualizations or automation tools that you might find useful – for example, critical path analysis, or finding common attributes that correspond to higher latency or error rates. Each of these relies on span properties and attributes following common semantics<a id="_idIndexMarker077"/> or at least being consistent across services.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Resource attributes</h2>
<p><strong class="bold">Resource attributes</strong> describe the process, host, service, and<a id="_idIndexMarker078"/> environment, and are the same for all spans reported by the service instance – for example, the service name, version, unique service instance ID, cloud provider account ID, region, availability zone, and K8s metadata.</p>
<p>These attributes allow us to detect anomalies specific to certain environments or instances – for example, an error rate increase only on instances that have a new version of code, an instance that goes into a restart loop, or a cloud service in a region and availability zone that experiences issues.</p>
<p>Based on standard attributes, observability vendors can write generic queries to perform this analysis or build common dashboards. It also enables the community to create vendor-agnostic tools and solutions for popular technologies.</p>
<p>Such attributes describe a service instance and don’t have to appear on every span – OTLP, for example, passes resource attributes once per batch of spans.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Performance analysis overview</h1>
<p>Now that you know the core concepts<a id="_idIndexMarker079"/> around distributed<a id="_idIndexMarker080"/> tracing, let’s see how we can use the observability stack to investigate common distributed system problems.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>The baseline</h2>
<p>Before we talk about<a id="_idIndexMarker081"/> problems, let’s establish a baseline representing the behavior of a healthy system. We also need it to make data-driven decisions to help with common design and development tasks such as the following:</p>
<ul>
<li><strong class="bold">Risk estimation</strong>: Any feature work on the hot path is a good candidate for additional performance testing prior to release and guarding new code with feature flags.</li>
<li><strong class="bold">Capacity planning</strong>: Knowing the current load is necessary to understand whether a system can handle planned growth and new features.</li>
<li><strong class="bold">Understand improvement potential</strong>: It makes more sense to optimize frequently executed code, as even small optimizations bring significant performance gains or cost reductions. Similarly, improving reliability brings the most benefits for components that have a higher error rate and that are used by other services.</li>
<li><strong class="bold">Learning usage patterns</strong>: Depending on how users interact with your system, you might change your scaling or caching strategy, extract specific functionality to a new service, or merge services.</li>
</ul>
<p>Generic indicators that describe the performance<a id="_idIndexMarker082"/> of each service include the following:</p>
<ul>
<li><strong class="bold">Latency</strong>: How fast a service responds</li>
<li><strong class="bold">Throughput</strong>: How many requests, events, or bytes the service is handling per second</li>
<li><strong class="bold">Error rate</strong>: How many errors a service returns</li>
</ul>
<p>Your system might need other indicators to measure durability or data correctness.</p>
<p>Each of these signals is useful when it includes an API route, a status code, and other context properties. For example, the error rate could be low overall but high for specific users or API routes.</p>
<p>Measuring signals on the server<a id="_idIndexMarker083"/> and client sides, whenever possible, gives you a better picture. For example, you can detect network failures and avoid “<em class="italic">it works on my machine</em>” situations when clients see issues and servers don’t.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Investigating performance issues</h2>
<p>Let’s divide performance issues<a id="_idIndexMarker084"/> into two overlapping categories:</p>
<ul>
<li>Widespread issues that affect a whole instance, server, or even the system, and move the distribution median.</li>
<li>An individual request or job that takes too much time to complete. If we visualize the latency distribution, as shown in <em class="italic">Figure 1</em><em class="italic">.12</em>, we’ll see such issues in the long tail<a id="_idIndexMarker085"/> of distribution – they are rare, but part of normal behavior.</li>
</ul>
<div><div><img alt="Figure 1.12 – Azure Monitor latency distribution visualization, with a median request (the 50th percentile) taking around 80 ms and the 95th percentile around 250 ms" src="img/B19423_01_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Azure Monitor latency distribution visualization, with a median request (the 50th percentile) taking around 80 ms and the 95th percentile around 250 ms</p>
<h3>Long tails</h3>
<p>Individual issues<a id="_idIndexMarker086"/> can be caused by an unfortunate chain of events – transient<a id="_idIndexMarker087"/> network issues, high contention in optimistic concurrency algorithms, hardware failures, and so on.</p>
<p>Distributed tracing is an excellent tool to investigate such issues. If you have a bug report, you might have a trace context for a problematic operation. To achieve it, make sure you show the <code>traceparent</code> value on the web page and return <code>traceresponse</code> or a document that users need to record, or log <code>traceresponse</code> when sending requests to your service.</p>
<p>So, if you know the trace context, you can start by checking the trace view. For example, in <em class="italic">Figure 1</em><em class="italic">.13</em>, you can see an example of a long request caused by transient network issues.</p>
<div><div><img alt="Figure 1.13 – A request with high latency caused by transient network issues and retries" src="img/B19423_01_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – A request with high latency caused by transient network issues and retries</p>
<p>The frontend request took about 2.6 seconds and the time was spent on the storage service downloading meme content. We see three tries of <code>Azure.Core.Http.Request</code>, each of which was fast, and the time between them corresponds to the back-off interval. The last try was successful.</p>
<p>If you don’t have <code>trace-id</code>, or perhaps if the trace was sampled out, you might be able to filter similar operations based on the context and high latency.</p>
<p>For example, in Jaeger, you can filter<a id="_idIndexMarker088"/> spans based on the service, span<a id="_idIndexMarker089"/> name, attributes, and duration, which helps you to find a needle in a haystack.</p>
<p>In some cases, you will end up with mysterious gaps – the service was up and running but spent significant time doing nothing, as shown in <em class="italic">Figure 1</em><em class="italic">.14</em>:</p>
<div><div><img alt="Figure 1.14 – A request with high latency and gaps in spans" src="img/B19423_01_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – A request with high latency and gaps in spans</p>
<p>If you don’t get enough data from traces, check whether there are any logs available in the scope of this span.</p>
<p>You might also check resource utilization metrics – was there a CPU spike, or maybe a garbage collection pause at this moment? You might find some correlation using timestamps and context, but it’s impossible to tell whether this was a root cause or a coincidence.</p>
<p>If you have a continuous profiler that correlates profiles to traces (yes, they can do it with <code>Activity.Current</code>), you can check whether there are profiles available for this or similar operations.</p>
<p>We’ll see how to investigate this further with .NET diagnostics tools in <a href="B19423_04.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Low-Level Performance Analysis with Diagnostic Tools</em>, but if you’re curious about what happened in <em class="italic">Figure 1</em><em class="italic">.14</em>, the service read a network stream that was not instrumented.</p>
<p>Even though we talk about individual performance<a id="_idIndexMarker090"/> issues, in many cases we<a id="_idIndexMarker091"/> don’t know how widespread they are, especially when we’re at the beginning of an incident. Metrics and rich queries across traces can be used to find out how common a problem is. If you’re on call, checking whether an issue is widespread or becoming more frequent is usually more urgent than finding the root cause.</p>
<p class="callout-heading">Note</p>
<p class="callout">Long-tail latency requests are inevitable in distributed systems, but there are always opportunities for optimization, with caching, collocation, adjusting timeouts and the retry policy, and so on. Monitoring P95 latency and analyzing traces for long-tail issues helps you find such areas for improvement.</p>
<h3>Performance issues</h3>
<p>Performance problems<a id="_idIndexMarker092"/> manifest as latency or throughput degradation beyond usual variations. Assuming you fail fast or rate-limit incoming calls, you might also see an increase in the error rate for <code>408</code>, <code>429</code>, or <code>503</code> HTTP status codes.</p>
<p>Such issues can start as a slight decrease in dependency availability, causing a service to retry. With outgoing requests taking more resources than usual, other operations slow down, and the time to process client requests grows, along with number of active requests and connections.</p>
<p>It could be challenging to understand what happened first; you might see high CPU usage and a relatively high GC rate  – all symptoms you would usually see on an overloaded system, but nothing that stands out. Assuming you measure the dependency throughput and error rate, you could see the anomaly there, but it might be difficult to tell whether it’s a cause or effect.</p>
<p>Individual distributed traces<a id="_idIndexMarker093"/> are rarely useful in such cases – each operation takes longer, and there are more transient errors, but traces may look normal otherwise.</p>
<p>Here’s a list of trivial things to check first, and they serve as a foundation for more advanced analysis:</p>
<ul>
<li>Is there an active deployment or a recent feature rollout? You can find out whether a problem is specific to instances running a new version of code using a <code>service.version</code> resource attribute. If you include feature flags on your traces or events, you can query them to check whether degradation is limited to (or started from) the requests with a new feature enabled.</li>
<li>Are issues specific to a certain API, code path, or combination of attributes? Some backends, such as Honeycomb, automate this analysis, finding attributes corresponding to a higher latency or error rate.</li>
<li>Are all instances affected? How many instances are alive? Attribute-based analysis is helpful here too.</li>
<li>Are your dependencies healthy? If you can, check their server-side telemetry and see whether they experience problems with other services, not just yours.</li>
</ul>
<p>Attribute analysis can help here as well – assuming just one of your cloud storage accounts or database partitions is misbehaving, you will see it.</p>
<ul>
<li>Did the load increase sharply prior to the incident? Or, if your service is auto-scaled, is the auto-scaler functioning properly, and are you able to catch up with the load?</li>
</ul>
<p>There are more questions to ask about infrastructure, the cloud provider, and other aspects. The point of this exercise is to narrow down and understand the problem as much as possible. If the problem is not in your code, investigation helps to find a better way to handle problems like these in the future and gives you an opportunity to fill the gaps in your telemetry, so next time something similar happens, you can identify it faster.</p>
<p>If you suspect a problem<a id="_idIndexMarker094"/> in your code, .NET provides a set of signals and tools to help investigate high CPU, memory leaks, deadlocks, thread pool starvation, and profile code, as we’ll see in <a href="B19423_04.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Low-Level Performance Analysis with </em><em class="italic">Diagnostic Tools</em>.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Summary</h1>
<p>Distributed systems need a new approach to observability that simplifies investigating incidents and minimizes the time to resolve issues. This approach should focus on human experience such as data visualization, the correlation across telemetry signals, and analysis automation. It requires structured, correlated telemetry signals that work together and new tools that leverage them to build a rich experience.</p>
<p>Distributed tracing is one such signal – it follows requests through any system and describes service operations with spans, the events representing operations in the system. .NET supports distributed tracing and integrates natively with OpenTelemetry, which is a cross-language platform to collect, process, and export traces, metrics, and logs in a vendor-agnostic way. Most modern vendors are compatible with OpenTelemetry and leverage distributed tracing capabilities. The OpenTelemetry ecosystem includes a diverse set of shared instrumentation libraries that automate common telemetry collection needs.</p>
<p>Distributed tracing enables correlation and causation by propagating context within the process and between services. OpenTelemetry defines standard semantics for common technologies so that vendors can build trace visualizations, application maps, shared dashboards, alerts, or queries that rely on consistent and standard attributes. Trace context and consistent attributes enable correlation between spans, logs, metrics, and any other signals coming from your system.</p>
<p>Individual issues can be efficiently analyzed with distributed tracing and investigations into widespread performance issues rely on attributes and timestamp correlation on metrics and across traces. Observability vendors may automate this analysis.</p>
<p>A combination of metrics, traces, and events gives the right number of details. Metrics allow us to receive unbiased data in a cost-effective way. By querying traces and events over high-cardinality attributes, we can answer ad hoc questions about the system.</p>
<p>In the next chapter, we’ll get hands-on experience with distributed tracing. We’ll build a demo application and explore native tracing capabilities in .NET.</p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Questions</h1>
<ol>
<li value="1">How would you define spans and traces? What information does a span contain?</li>
<li>How does span correlation work?</li>
<li>Assuming you are on call and receive a report from a user about slow response time from your service, how would you approach the investigation?</li>
</ol>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Further reading</h1>
<ul>
<li><em class="italic">Cloud-Native Observability with OpenTelemetry</em> by Alex Boten</li>
</ul>
</div>
</body></html>