["```cs\n    using UnityEngine;\n    using UnityEngine.AI;\n    public class SimpleNavAgent : MonoBehaviour\n    {\n        public Transform target; // Drag your target in\n                                    the Inspector\n        private NavMeshAgent agent;\n        void Start()\n        {\n            agent = GetComponent<NavMeshAgent>();\n        }\n        void Update()\n        {\n            if(target != null)\n                agent.SetDestination(target.position);\n        }\n    }\n    ```", "```cs\n    public class EnemyController : MonoBehaviour\n    {\n        private Animator animator;\n        private Transform player;\n        private float detectionRange = 10.0f;\n        void Start()\n        {\n            animator = GetComponent<Animator>();\n            player =\n               GameObject.FindWithTag(\"Player\").transform;\n        }\n        void Update()\n        {\n            float distanceToPlayer =\n                Vector3.Distance(transform.position,\n                player.position);\n            if (distanceToPlayer < detectionRange)\n                animator.SetTrigger(\"Chase\");\n            else\n                animator.SetTrigger(\"Patrol\");\n        }\n    }\n    ```", "```cs\n    // Pseudocode for a behavior tree node\n    public class AttackOrRetreatNode : Node\n    {\n        public override NodeState Evaluate()\n        {\n            if (CanSeePlayer() && EnoughHealth())\n                return NodeState.SUCCESS; // Proceed to\n                                             attack\n            else\n                return NodeState.FAILURE; // Retreat or\n                                             take cover\n        }\n    }\n    ```", "```cs\n    public class UtilityDecider : MonoBehaviour\n    {\n        public float attackUtility;\n        public float defendUtility;\n        public float specialAbilityUtility;\n        void DecideAction()\n        {\n            float maxUtility = Mathf.Max(attackUtility,\n                defendUtility,\n                specialAbilityUtility);\n            if (maxUtility == attackUtility)\n                PerformAttack();\n            else if (maxUtility == defendUtility)\n                PerformDefend();\n            else\n                PerformSpecialAbility();\n        }\n        void PerformAttack()\n        {\n            /* Implementation here */\n        }\n        void PerformDefend()\n        {\n            /* Implementation here */\n        }\n        void PerformSpecialAbility()\n        {\n            /* Implementation here */\n        }\n    }\n    ```", "```cs\npublic interface IEnemyState {\n    void EnterState(EnemyController controller);\n    void UpdateState();\n}\npublic class PatrolState : IEnemyState {\n    public void EnterState(EnemyController controller) {\n        controller.SetPatrolBehavior();\n    }\n    public void UpdateState() {\n        // Patrol logic here\n    }\n}\npublic class AttackState : IEnemyState {\n    public void EnterState(EnemyController controller) {\n        controller.SetAttackBehavior();\n    }\n    public void UpdateState() {\n        // Attack logic here\n    }\n}\npublic class EnemyController : MonoBehaviour {\n    private IEnemyState currentState;\n    public void SetState(IEnemyState newState) {\n        currentState = newState;\n        currentState.EnterState(this);\n    }\n    void Update() {\n        currentState.UpdateState();\n    }\n    public void SetPatrolBehavior() {\n        // Specific patrol settings\n    }\n    public void SetAttackBehavior() {\n        // Specific attack settings\n    }\n}\n```", "```cs\npublic void UpdatePathfinding() {\n    if (Time.time - lastPathUpdate > pathUpdateInterval) {\n        navMeshAgent.CalculatePath(target.position, path);\n        navMeshAgent.SetPath(path);\n        lastPathUpdate = Time.time;\n    }\n}\n```", "```cs\nprivate float decisionCooldown = 1.0f;\nprivate float lastDecisionTime = 0.0f;\nvoid Update() {\n    if (Time.time > lastDecisionTime + decisionCooldown) {\n        MakeDecision();\n        lastDecisionTime = Time.time;\n    }\n}\nvoid MakeDecision() {\n    // Complex decision-making logic here\n}\n```", "```cs\npublic class PatrolGuardAI : MonoBehaviour\n{\n    private BehaviorTree tree;\n    void Start()\n    {\n        tree = new BehaviorTree();\n        Node root = new SelectorNode();\n        Node patrolNode = new SequenceNode(new List<Node>\n        {\n            new CheckPatrolAreaNode(),\n            new MoveToNode(patrolPath),\n        });\n        Node chaseNode = new SequenceNode(new List<Node>\n        {\n            new CanSeePlayerNode(),\n            new ChasePlayerNode(),\n        });\n        Node investigateNode =\n            new SequenceNode(new List<Node>\n        {\n            new HeardNoiseNode(),\n            new InvestigateNoiseNode(),\n        });\n        root.AddChild(patrolNode);\n        root.AddChild(chaseNode);\n        root.AddChild(investigateNode);\n        tree.SetRoot(root);\n    }\n    void Update()\n    {\n        tree.Tick(); // Process the behavior tree\n    }\n}\n```", "```cs\nusing Unity.MLAgents;\nusing Unity.MLAgents.Sensors;\nusing Unity.MLAgents.Actuators;\npublic class NPCAgent : Agent\n{\n    public override void OnEpisodeBegin()\n    {\n        // Reset the NPC state for new episode\n    }\n    public override void CollectObservations(VectorSensor\n    sensor)\n    {\n        // Add NPC's observations of the environment\n           for decision making\n    }\n    public override void OnActionReceived(ActionBuffers\n    actionBuffers)\n    {\n        // Actions received from the model\n        int action = actionBuffers.DiscreteActions[0];\n        if (action == 1)\n        {\n            // Perform the action, e.g., move towards a\n               target\n        }\n    }\n    public override void Heuristic(in ActionBuffers\n    actionsOut)\n    {\n        // Provide manual control as fallback\n        actionsOut.DiscreteActions.Array[0] =\n            Convert.ToInt32(Input.GetKey(KeyCode.Space));\n    }\n}\n```", "```cs\npublic class DecisionThrottlingAI : MonoBehaviour\n{\n  public Transform player;\n  private float decisionCooldown = 1.0f; // Time between\n                                            decisions\n  private float lastDecisionTime = 0f;\n  void Update()\n  {\n    if (Time.time > lastDecisionTime + decisionCooldown\n    {\n      MakeDecision();\n      lastDecisionTime = Time.time;\n    }\n  }\n  void MakeDecision()\n  {\n    if (Vector3.Distance(transform.position,\n    player.position) < 10f)\n    {\n      // Logic to hide because the player is too close\n      Debug.Log(\"Hiding\");\n    }\n    else\n    {\n      // Logic to seek the player\n      Debug.Log(\"Seeking\");\n    }\n  }\n}\n```"]