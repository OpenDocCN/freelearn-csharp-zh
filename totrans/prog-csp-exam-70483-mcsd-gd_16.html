<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Serialization, Deserialization, and Collections</h1>
                </header>
            
            <article>
                
<p>When a .NET application interacts with an external network, the data being exchanged must be transformed into a flat or binary format. Similarly, when the data is retrieved from external applications, binary data needs to be formatted to objects on which they can then be worked upon. This is done via the serialization and deserialization of data using different approaches. The process of changing objects into binary format is referred to as serialization. Deserialization is the reverse of serialization. In involves transforming binary data into its object representation so that it can be used in the application.</p>
<p>In this chapter, we will work on different serialization and deserialization approaches available in the .NET Framework. We will look into XML serialization, JSON serialization, and binary serialization. We will also look at how we define data contracts in web services to inform the consuming application of the format of the data that is to be exchanged between different applications. </p>
<p>We will then look at how we can use different collections objects such as arrays, lists, dictionary, queues, and stacks and we'll learn how they can be used for storing and consuming data. Finally, we will look at different things that help us choose collection objects while working with .NET applications.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li class="mce-root"><span>Serialization and deserialization</span></li>
<li class="mce-root">Working with collections</li>
<li class="mce-root">Choosing a collection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The programs explained in this book will be developed in Visual Studio 2017. The sample<span> code for this chapter can be found at GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples">https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples</a></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serialization and deserialization</h1>
                </header>
            
            <article>
                
<p>While working with objects, we often find a need to either save them in different mediums such as a database or file or, in some cases, transfer them to other applications over a network. To do this, we must first convert the object into a stream of bytesâ€”this process is known as <strong>serialization</strong>.</p>
<p>Deserialization is the process of converting bytes received from the external application into objects that can be then used inside the application. With serialization, we can transform an object into bytes and save information related to its state, attributes, assembly version, and so on in external mediums such as databases, or we can exchange them on a network to external applications. An important thing to note here is that we can only apply serialization to objects and their attributes but not to their methods. </p>
<p>.NET Framework provides us with the <kbd>System.Runtime.Serialization</kbd> <span>namespace, </span>which has got helper classes that help us serialize and deserialize the data. .NET provides us with three mechanisms for achieving this: XML serialization, JSON serialization, and data contract serialization.</p>
<p>In the next section, we will learn how we do serialization using <kbd>XMLSerializer</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XmlSerializer</h1>
                </header>
            
            <article>
                
<p>In <kbd>XMLSerialization</kbd>, we convert the data into the format of an XML document, which can then be transferred easily across the network.</p>
<p>During deserialization, we can render an object from the same XML document format. <kbd>XMLSerializer</kbd> is based upon <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>), a protocol for exchanging information with web services. </p>
<p>While working with <kbd>XmLSerlializer</kbd>, we must mark our classes with the <kbd>Serializable</kbd> tag to inform the compiler that this class is serializable. Please refer to the following code implementation wherein we are using this tag against our class to inform the compiler that the class is <kbd>Serializable</kbd>:</p>
<pre>[Serializable]<br/>public class Student<br/>{<br/>     public string FirstName { get; set; }<br/>     public string LastName { get; set; }<br/>     public int ID { get; set; }<br/>     public Student()<br/>     {            <br/>     }<br/>     public Student(string firstName, string lastName, int Id)<br/>     {<br/>         this.FirstName = firstName;<br/>         this.LastName = lastName;<br/>         this.ID = Id;     <br/>     }<br/>}</pre>
<p>In the preceding code implementation, we declared a <kbd>Student</kbd> <span>class </span>and specified it with the <kbd>FirstName</kbd>, <kbd>LastName</kbd>, and <kbd>ID</kbd> <span>attributes. </span>To inform the compiler that the class is serializable, we have used the <kbd>Serializable</kbd> <span>tag on </span>the class. </p>
<p>Sometimes, we need to pick and choose the attributes that we would like to be serialized. In these cases, we can use the <kbd>NonSerialized</kbd> <span>tag </span>on the attribute and convey to the compiler that the attribute will not be serializable. Following is the code implementation for this:</p>
<pre>[Serializable]<br/>public class Student<br/>{<br/>     public string FirstName { get; set; } <br/>     public string LastName { get; set; }<br/>     [NonSerialized()]<br/>     public int ID;<br/>}</pre>
<p>We used the <kbd>Serializable</kbd> <span>tag </span>on the class name but used the <kbd>NonSerialized</kbd> <span>tag </span>to indicate that the <kbd>ID</kbd> <span>attribute </span>cannot be serialized. </p>
<p>Let's go through a code implementation scenario where we will look at a code base in which we will serialize a class object using <kbd>XmlSerializer</kbd> and will save the file on the filesystem. This file can then be transferred across the network:</p>
<pre>XmlSerializer serializer = new XmlSerializer(typeof(Student));<br/>string fileName = "StudentData";<br/>using (TextWriter writer = new StreamWriter(fileName))<br/>{<br/>     Student stu = new Student("Jacob", "Almeida", 78);  <br/>     serializer.Serialize(writer, stu);<br/>}</pre>
<p>In the preceding code example, we are using the same <kbd>Student</kbd> class we used in the previous example. We have created a dummy <kbd>Student</kbd> object and are then serializing the object into bytes. The bytes are then converted into a file using the <kbd>TextWriter</kbd> object. </p>
<p>Once the preceding code gets executed, a file with the name <kbd>StudentData</kbd> gets created in the system:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c7d7dcd6-9cb9-4af2-a1fb-ffbfff6b162a.png"/></div>
<p>If we open the file in Internet Explorer, we will see the student data in XML format:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c5655cae-f6b7-461f-a02f-162c8a69c07c.png"/></div>
<p>In the preceding code example, there was no hierarchy in the data. All of the data is represented as an element in the XML file. However, in most situations, we will need to represent data that is following some sort of hierarchy. Using the preceding example, let's try to represent the course scores for each of the students as well. Let's say there are five courses: English, Maths, Physics, Chemistry, and Computers. Now, let's try to represent the scores for each of the courses for the student using the following code implementation:</p>
<pre>[Serializable]<br/>public class Student<br/>{<br/> public string FirstName { get; set; }<br/> public string LastName { get; set; }<br/> public int ID;<br/> [XmlIgnore]<br/> public string Feedback { get; set; }<br/> [XmlArray("CourseScores")]<br/> [XmlArrayItem("Course")]<br/> public List&lt;CourseScore&gt; CoursePerformance { get; set; } <br/> public void CreateCoursePerformance()<br/> {<br/>        Course phy = new Course { Name = "Physics", Description = <br/>                                  "Physics Subject" };<br/>        CourseScore phyScore = new CourseScore { Course = phy, <br/>                                                 Score = 80 };<br/>        List&lt;CourseScore&gt; scores = new List&lt;CourseScore&gt;();<br/>        scores.Add(phyScore);<br/>        this.CoursePerformance = scores;<br/> }<br/>}<br/>[Serializable]<br/>public class CourseScore<br/>{<br/> [XmlElement("Course")]<br/> public Course Course;<br/> [XmlAttribute]<br/> public int Score;<br/>}<br/>[Serializable]<br/>public class Course<br/>{<br/> [XmlAttribute]<br/> public string Name;<br/> public string Description;<br/>}</pre>
<div class="packt_infobox">The preceding complete code can be found in the GitHub repository for this chapter.</div>
<p>In the preceding code implementation, we declared three classes:</p>
<ul>
<li><kbd>Course</kbd>: To represent the subject along with the description</li>
<li><kbd>CourseScore</kbd>: To represent the score that a student is getting in that particular course</li>
<li><kbd>Student</kbd>: Has a list of <kbd>CourseScore</kbd> to represent the score the student gets in each subject</li>
</ul>
<div class="packt_infobox">Please note the following tags we used in the classes:
<ul>
<li><kbd>XmlIgnore</kbd>: We use this tag against attributes that we don't want to be saved in the generated XML class. In the preceding class example, we have used <kbd>XmlIgnore</kbd> against the <kbd>Feedback</kbd> class. This will ensure that the <kbd>Feedback</kbd> <span>attribute </span>will not be present in the generated XML file.</li>
<li><kbd>XmlElement</kbd>: We can use this tag if we want to represent an element in the generated XML. The element can then have attributes. In the preceding example, we used the <kbd>XmlElement</kbd> tag for the <kbd>Course</kbd> attribute. This will then enable us to add attributes of <kbd>Course Name</kbd> and <kbd>Course Description</kbd> in the generated XML file.</li>
<li><kbd>XMLArray</kbd>: We use this tag when there can be multiple child records in this element. In the preceding example, we used the <kbd>XMLArray</kbd> tag for the <kbd>CourseScores</kbd> attribute to indicate that this is an element in the XML that can have multiple child records. </li>
<li><kbd>XMLArrayItem</kbd>: We use this tag to represent the individual child records in the <kbd>XMLArray</kbd> record. In the preceding example, we used the <kbd>XMLArrayItem</kbd> tag to represent individual records in the list collection variable, <kbd>CourseScores</kbd>.</li>
</ul>
</div>
<p>If we need to serialize the data using <kbd>XMLSerialization</kbd>, we can use the following code. Once the code is executed, it will generate an XML file based on the data structure and tags used in the preceding declaration of the class:</p>
<pre>XmlSerializer serializer = new XmlSerializer(typeof(Student));<br/>string fileName = "StudentDataWithScores";<br/>using (TextWriter writer = new StreamWriter(fileName))<br/>{<br/>       Student stu = new Student("Jacob", "Almeida", 78, "Passed");<br/>       stu.CreateCoursePerformance();<br/>       serializer.Serialize(writer, stu);<br/>       writer.Close();<br/> }</pre>
<p>Once the program is generated, note that an XML file, <kbd>StudentDataWithScores</kbd>, is generated. Now, open the XML file and review the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/218ce068-28a3-439d-ae2b-11053466435c.png"/></div>
<p>Please note the following points in the structure of the XML file that is generated:</p>
<ul>
<li>In the XML file, there is no node for <kbd>Feedback</kbd> as it has been marked with the <kbd>XmlIgnore</kbd> tag in the <kbd>Student</kbd> class file.</li>
<li>In the <kbd>Student</kbd> node, there is a <kbd>CourseScores</kbd> element node in line with the <kbd>XmlArray</kbd> tag that we used in the <kbd>CourseScore</kbd> list collection.</li>
<li>In the element node, <kbd>CourseScores</kbd>, we have an individual node item element, <kbd>Course</kbd>, in line with <kbd>XmlArrayItem</kbd>, which we declared for each element in the <kbd>CourseScores</kbd> collection.</li>
</ul>
<p>Each of the child item nodes has a <kbd>Score</kbd> <span>attribute</span><span>. It is in line with the tagâ€”</span><kbd>XmlElement</kbd><span>â€”that we used for </span><kbd>CoursePerformance</kbd><span>; note that the XML also shows the name and description of the course. </span></p>
<p>Even though we're using <kbd>XMLSerialization</kbd>, we can produce data that we can easily read, but there are certain issues with regard to <kbd>XmlSerialization</kbd>:</p>
<ul>
<li>It consumes more space. If we are sharing XML files, they will ultimately end up saving space on the filesystem, which might not be ideal.</li>
<li>In addition to that, if we declare an attribute with the access modifier of <kbd>private</kbd>, it will not be picked during the XML serialization. For example, if we set the access modifier of the <kbd>LastName</kbd> attribute in the preceding example, we will see that the generated XML file will not have the attribute. </li>
</ul>
<p>The following code is the updated set of access modifiers for the attributes in the <kbd>Student</kbd> class:</p>
<pre>public string FirstName { get; set; }<br/>private string LastName { get; set; }<br/>public int ID;<br/>[XmlIgnore]<br/>public string Feedback { get; set; }<br/>[XmlArray("CourseScores")]<br/>[XmlArrayItem("Course")]<br/>public List&lt;CourseScore&gt; CoursePerformance { get; set; }</pre>
<p>The access modifier for the <kbd>LastName</kbd> <span>attribute</span><span> </span><span>has been changed </span><span>from</span><span> </span><kbd>public</kbd> <span>to</span> <kbd>private</kbd><span>.</span> <span>If we execute the project and open the XML file, we will observe that the</span> <kbd>LastName</kbd><span> </span><span>attribute</span><span> </span><span>no longer exists in the generated XML file:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/88411386-5677-46c2-9331-dfcfd39c88d9.png"/></div>
<p>In the next section, we will go through the binary serialization approach in C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binary serialization</h1>
                </header>
            
            <article>
                
<p>In <kbd>XmlSerialization</kbd>, the output of the serialization is an XML file that can be easily opened by Notepad. However, as explained previously, creating a file adds to the overall storage space required by the application, which may not be desirable in all circumstances. </p>
<p>We also observed that if we marked any attribute with the access modifier of <kbd>private</kbd>, it was not copied across to the generated XML file. This may also be an issue in many cases. </p>
<p>In this section, we will look at an alternative approach in which we will serialize the data to a stream of bytes. This data will not be viewable like the XML file but will save us space and will deal with <kbd>private</kbd> attributes in a much better way. </p>
<p>.NET Framework provides us with the <kbd>System.Runtime.Serialization</kbd> and <kbd>System.Runtime.Serialization.Formatters.Binary</kbd> <span>namespaces,</span><span> </span><span>which provide us with helper classes for dealing with binary serialization. </span></p>
<p>To understand how binary serialization works, let's look at the following example. We will work with <kbd>Student</kbd>,<span> </span><span>a similar class to what</span><span> we created while we were working on XML serialization:</span></p>
<pre>[Serializable]<br/>public class StudentBinary<br/>{<br/>     public string FirstName;<br/>     public string LastName;<br/>     public int ID;<br/>     public string Feedback;<br/><br/>     public StudentBinary(string firstName, string lastName, int Id, string feedback)<br/>     {<br/>         this.FirstName = firstName;<br/>         this.LastName = lastName;<br/>         this.ID = Id;<br/>         this.Feedback = feedback;<br/>     }<br/> }</pre>
<p>Please note that in the class declaration, just like in <kbd>XmlSerialization</kbd>, we used a <kbd>Serializable</kbd> <span>tag</span><span> </span><span>in the declaration of the</span><span> </span><kbd>StudentBinary</kbd><span> </span><span>class</span><span>. This indicates to the compiler that the</span> <kbd>StudentBinary</kbd><span> </span><span>class</span><span> </span><span>can be serialized.</span></p>
<p>We can use the following code to serialize and deserialize an object of this class:</p>
<pre>StudentBinary stu = new StudentBinary("Jacob", "Almeida", 78, "Passed");            <br/>IFormatter formatter = new BinaryFormatter();<br/>using (Stream stream = new FileStream("StudentBinaryData.bin", FileMode.Create))<br/>{<br/>     formatter.Serialize(stream, stu);<br/>}<br/><br/>using (Stream stream = new FileStream("StudentBinaryData.bin", FileMode.Open))<br/>{<br/>     StudentBinary studeseria = (StudentBinary)formatter.Deserialize(stream);<br/>}</pre>
<p>In the code example, we created an object of the <kbd>StudentBinary</kbd> <span>class</span><span> </span><span>and then used a helper class, </span><kbd>BinaryFormatter</kbd>, <span>to serialize the data into binary data. Once the data is serialized, using the </span><kbd>FileStream</kbd> <span>helper class, we saved this binary data in a binary file, </span><kbd>StudentBinaryData.bin</kbd><span>.</span></p>
<p>In the next step, we open the file we created in the previous step and deserialize it back to the <kbd>StudentBinary</kbd> class. If we try to debug the application and do a quick watch on the <kbd>studeseria</kbd> <span>variable,</span><span> </span><span>we will see the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/119bd568-b34a-4a55-b2d1-ee5a6f88f4c0.png" style=""/></div>
<p>Now let's make one change to the preceding class: let's mark the <kbd>LastName</kbd> <span>attribute</span><span> </span><span>as</span> <kbd>private</kbd><span>. When we used</span> <kbd>XmlSerialization</kbd><span>, we saw that any attribute marked with the </span><kbd>private</kbd><span> </span><span>access modifier</span> <span>was excluded from the attribute. Let's do the same with binary serialization and observe the difference:</span></p>
<pre>[Serializable]<br/>public class StudentBinary<br/>{<br/>     public string FirstName;<br/>     private string LastName;<br/>     public int ID;<br/>     public string Feedback;<br/>     public StudentBinary(string firstName, string lastName, int Id, string feedback)<br/>     {<br/>         this.FirstName = firstName;<br/>         this.LastName = lastName;<br/>         this.ID = Id;<br/>         this.Feedback = feedback;<br/>     }<br/> }</pre>
<p>If we now try to debug an application and do a QuickWatch on the <span><kbd>studeseria</kbd></span> <span>variable</span><span>, we will get the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6d6deb19-d1f0-40b8-9049-4de1caf81a3d.png" style=""/></div>
<p>Note that even though we made <kbd>LastName</kbd> as <kbd>private</kbd>, it has no impact on the output. This illustrates the advantage binary serialization has on <kbd>XmlSerialization</kbd>. </p>
<p>Just with <kbd>XmlSerialization</kbd>, we can also set tags on an attribute that would ensure that that attribute is ignored during the serialization. We can do it with the<span> </span><kbd>NonSerialized</kbd><span> </span><span>tag</span><span>. In the following code implementation, we are using this tag for the </span><kbd>Feedback</kbd><span> </span><span>attribute</span><span>:</span></p>
<pre>[Serializable]<br/>public class StudentBinary<br/>{<br/>    public string FirstName;<br/>    private string LastName;<br/>    public int ID;<br/>    [NonSerialized]<br/>    public string Feedback;<br/><br/>    public StudentBinary(string firstName, string lastName, int Id, string feedback)<br/>    {<br/>        this.FirstName = firstName;<br/>        this.LastName = lastName;<br/>        this.ID = Id;<br/>        this.Feedback = feedback;<br/>    }<br/>}</pre>
<p>Even though binary serialization allows us to overcome the restriction around any attribute that is marked with the<span> </span><kbd>private</kbd><span> access modifier</span><span>, there are still some scenarios when we would deliberately want to restrict the exchange of certain data, especially those attributes that are sensitive and that we would like to restrict anyhow. We can do this by using the </span><kbd>ISerializable</kbd><span> </span><span>interface</span><span>.</span></p>
<p>In the following implemented code, we used a similar class, <kbd>StudentBinaryInterface</kbd>, and have implemented an <kbd>ISerializable</kbd> <span>interface </span><span>in it. As part of this interface, we must implement a</span> <kbd>GetObjectData</kbd><span> </span><span>method</span><span> </span><span>in this class. This method is classed when the class gets serialized. In this method, we will do encapsulation and not add any sensitive attributes to the serialized stream. Let's have a look at how to do this:</span></p>
<pre>[Serializable]<br/>public class StudentBinary:ISerializable<br/>{<br/>     public string FirstName;<br/>     private string LastName;<br/>     public int ID;<br/>     public string Feedback;<br/>     protected StudentBinary(SerializationInfo info, <br/>                             StreamingContext context)<br/>     {<br/>         FirstName = info.GetString("Value1");<br/>         Feedback = info.GetString("Value2");<br/>         ID = info.GetInt32("Value3");<br/>     }<br/>     public StudentBinary(string firstName, string lastName, <br/>                          int Id, string feedback)<br/>     {<br/>         this.FirstName = firstName;<br/>         this.LastName = lastName;<br/>         this.ID = Id;<br/>         this.Feedback = feedback;<br/>     }<br/>     [System.Security.Permissions.SecurityPermission(<br/>          SecurityAction.Demand, SerializationFormatter = true)]<br/>     public void GetObjectData(SerializationInfo info, <br/>                               StreamingContext context)<br/>     {<br/>         info.AddValue("Value1", FirstName);<br/>         info.AddValue("Value2", Feedback);<br/>         info.AddValue("Value3", ID);<br/>     }<br/> }</pre>
<p>In the preceding code example, we declared the <kbd>LastName</kbd> <span>attribute</span><span> </span><span>as</span> <kbd>private</kbd><span>. Through this code, we will try to exclude this attribute from being serialized. </span></p>
<p>There are two important functions in this class:</p>
<ul>
<li><kbd>GetObjectData</kbd>: As illustrated previously, this function is called when the class gets serialized. In this method, we will serialize the data present in <kbd>Firstname</kbd>, <kbd>Feedback</kbd>, and <kbd>ID</kbd>. Note that <kbd>LastName</kbd> is not present in this. This has been to make sure that the data in the <kbd>LastName</kbd> attribute will not be added to the stream.</li>
<li>Constructor: As the class implements the <kbd>ISerializable</kbd> interface, it must implement the following constructor with the parameters of <kbd>SerializationInfo</kbd> and <kbd>StreamingContext</kbd>:</li>
</ul>
<pre style="padding-left: 60px">StudentBinary(SerializationInfo info, StreamingContext context)</pre>
<p>This constructor will be called when the data will be deserialized into this class object. Note that in the constructor, we are accessing the values in the <kbd>Value1</kbd>, <kbd>Value2</kbd>, and <kbd>Value3</kbd> <span>attributes </span>and converting them into their respective mapped attributes:</p>
<pre>StudentBinary stu = new StudentBinary("Jacob", "Almeida", 78, "Passed");<br/>IFormatter formatter = new BinaryFormatter();<br/>using (Stream stream = new FileStream("StudentBinaryData.bin", FileMode.Create))<br/>{<br/>     formatter.Serialize(stream, stu);<br/>}<br/>using (Stream stream = new FileStream("StudentBinaryData.bin", FileMode.Open))<br/>{<br/>     StudentBinary studeseria = (StudentBinary)formatter.Deserialize(stream);<br/>}</pre>
<p class="CDPAlignLeft CDPAlign"><span>If we debug this code and do a QuickWatch on the <kbd>studeseria</kbd> </span><span>variable,</span><span> </span><span>we get the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/53957262-df4b-48c2-935f-bc7769ec72f5.png" style=""/></div>
<p>Note that no value is present in the <kbd>LastName</kbd><span> </span><span>attribute</span><span>. In the next section, we will learn how to work with collections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with collections</h1>
                </header>
            
            <article>
                
<p>A collection in .NET defines a group of related data or elements. Elements can be variables of simple data types such as <kbd>int</kbd>, <kbd>float</kbd>, or <kbd>String</kbd> or can be complex data variables such as a class or structure. While working with .NET applications, we often need to work with such collections. We can execute operations such as these:</p>
<ul>
<li>Creating a collection</li>
<li>Adding an element to a collection</li>
<li>Reading elements present in the collection</li>
<li>Removing elements present in the collection</li>
</ul>
<p>In this section, we will understand what the different types of collections available in .NET are and how programmers can execute operations on them. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arrays</h1>
                </header>
            
            <article>
                
<p>Arrays are the most basic collection variable available in .NET Framework. Arrays are used to store a group of data variables that are of the same type as <kbd>int</kbd>, <kbd>String</kbd>, and many more. </p>
<p>Let's go through a code implementation in which we will create an array collection of <kbd>int</kbd> variables and then loop through them:</p>
<pre>public static void CollectionOperations()<br/>{<br/>     int[] arrayOfInt = new int[10];<br/>     for (int x = 0; x &lt; arrayOfInt.Length; x++)<br/>     {<br/>         arrayOfInt[x] = x;<br/>     }<br/>     foreach (int i in arrayOfInt)<br/>     {<br/>         Console.Write(i); <br/>     }<br/> }</pre>
<p>Please note the following in the code implementation:</p>
<ul>
<li>An array is declared by the <kbd>[]</kbd> syntax after the data type. In the implemented code, we are declaring an array of the <kbd>int</kbd> type.</li>
<li>While declaring the array collection, we must define the length of the array collection. In the code, we are declaring that the length of the array is <kbd>10</kbd>. This basically implies that the array can contain <kbd>10</kbd> elements of the <kbd>int</kbd> type.</li>
<li>The index of the array starts at <kbd>0</kbd>. This implies that, in the preceding case, the first element will start at index <kbd>0</kbd> and will end at index <kbd>9</kbd>. If we need to refer to the elements present in the <em>i</em><sup>th</sup> index in the array, we can use the <kbd>array[i]</kbd> declaration.</li>
<li>Each array has a <kbd>length</kbd> property. This attribute indicates the maximum number of elements that can be present in the array. In the code, we are doing a <kbd>for</kbd> loop from <kbd>0</kbd> to <kbd>9</kbd> that is of the length -1 and are setting the value in each element present in that index.</li>
<li>Array implements the <kbd>IEnumerable</kbd> interface. Due to this, we can loop through the array using the <kbd>foreach</kbd> loop.</li>
</ul>
<p>On executing the preceding code, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0148d3f5-1152-48e0-bb87-10343f743202.png" style=""/></div>
<p><span>In the code, we are setting values in each index of the arrayâ€”the same value as the index in itself. </span>Before we move ahead and start looking at the code examples, we need to understand two important concepts regarding arrays:</p>
<ul>
<li>Multidimensional arrays: These are arrays in which we store elements in a matrix structure that has both rows and columns. For example, we can use the following code for declaring a multidimensional array:</li>
</ul>
<pre style="padding-left: 60px">int[,] arrayInt = new int[3,2] { { 1, 2 }, { 3, 4 }, { 5, 6 } };</pre>
<ul>
<li>The use of a single <kbd>,</kbd> mark during the array declaration indicates that this is a two-dimensional array. In the case of a two-dimensional array, the first dimension indicates the number of rows, while the second indicates the number of columns present in the array.<span> Also, note that by using <kbd>3,2</kbd>, we are basically indicating that the number of rows in the array should be <kbd>3</kbd> while the number of columns should be <kbd>2</kbd>.</span></li>
</ul>
<p style="padding-left: 60px">Just like in a normal array, in a multidimensional array, the index for both dimensions starts at <kbd>0</kbd>. Therefore, the first element will be present at index <kbd>{0,0}</kbd>, while the last element will be present at index <kbd>{2,1}</kbd>. </p>
<p class="mce-root" style="padding-left: 60px">Let's look at the following code implementation, in which we will look at the code to loop through this multidimensional array and read each number present in the array:</p>
<pre style="padding-left: 60px">int[,] arrayInt = new int[3,2] { { 1, 2 }, { 3, 4 }, { 5, 6 } };<br/>for (int i=0; i &lt; 3; i++)<br/>{<br/>     for (int j = 0; j &lt; 2; j++)<br/>     {<br/>         Console.WriteLine(arrayInt[i, j]);<br/>     }     <br/>}</pre>
<p>In the preceding code implementation, we are doing two nested loops. In the first loop, we are looping through the number of rows present in the multidimensional array. In the second loop, we are looping through the number of columns present in the multidimensional array. Using the <kbd>arrayInt[i, j]</kbd><span> </span><span>syntax</span><span>, we are printing the element present in that combination of rows and columns in the array. </span></p>
<p>When we execute the code, we get the following result. As we have to loop through the two-dimensional array using a nested loop, at each step, we will access elements present at position <kbd>{i, j}</kbd>. For each iteration of the <kbd>i</kbd><span> </span><span>variable</span><span>, the</span> <kbd>j</kbd> <span><span>variable </span>will iterate from</span> <kbd>0</kbd> <span>to</span> <kbd>1</kbd><span>. Hence, it will start at</span> <kbd>{0,0}</kbd><span>, which will be</span> <kbd>1</kbd> <span>and will end at</span> <kbd>{2,1}</kbd>, <span>which will be</span> <kbd>6</kbd><span>, hence generating the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9b8b2a58-f2f9-4556-abdc-89d5f3f8a608.png" style=""/></div>
<p>In the next section, we will look at another collection type: lists.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lists</h1>
                </header>
            
            <article>
                
<p>While working on arrays, we learned that the length of an array must be specified when the array is declared. Also, we cannot increase the length of an array collection. </p>
<p>To overcome these issues, we can use the list collection. Lists provide us with several helper methods that help us to add and remove items in a list, sort a list, search in a list, and more. A list collection is declared by the following index:</p>
<pre> List&lt;int&gt; vs = new List&lt;int&gt;();</pre>
<p>If we go to the definition of a list, we will realize that, internally, it implements many interfaces, such as <kbd>IEnumerable</kbd>, <kbd>ICollection</kbd>, and <kbd>IList</kbd>. Due to these different interfaces, list collections are extremely powerful and provide different operations. The following screenshot shows what the definition of a list collection looks like in .NET:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c4cd2503-b725-4f02-be3d-a7ec811c95ef.png"/></div>
<p>The <kbd>IEnumerable</kbd> interface allows us to loop through the list collection using the <kbd>foreach</kbd> loop just as we did for arrays. The <kbd>ICollection</kbd> interface allows us to do operations such as count length, add a new element, and remove an element.</p>
<p>Let's look at the following code implementation, in which we will execute all of these operations on the list:</p>
<pre>public static void ListCollectionOperations()<br/>{<br/>     List&lt;int&gt; vs = new List&lt;int&gt; { 1, 2, 3, 4, 5, 6 };<br/>     for (int x = 0; x &lt; vs.Count; x++)<br/>     Console.Write(vs[x]); <br/>     vs.Remove(1);<br/>     Console.WriteLine(vs[0]); <br/>     vs.Add(7);<br/>     Console.WriteLine(vs.Count); <br/>     bool doesExist = vs.Contains(4);<br/>     Console.WriteLine(doesExist); <br/>}</pre>
<p>Let's look at what we did in the preceding code:</p>
<ul>
<li>We have created a list of <kbd>int</kbd> and added the elements 1-6.</li>
<li>We are looping across the list using a <kbd>for</kbd> loop and we are printing the values present in it. To find the length or the number of elements present in a list, we are using the <kbd>Count</kbd> property.</li>
<li>To remove an element from a particular index, we can use the <kbd>Remove</kbd> method. In the preceding code implementation, we are removing the element present at index <kbd>1</kbd>.</li>
<li>To add a new element in the list, we use the <kbd>Add</kbd> method. In the preceding code implementation, we are adding an element, <kbd>7</kbd>, to the list.</li>
<li>To check whether an element is present in the list, we use the <kbd>Contains</kbd> method. In the preceding code implementation, we are checking whether a <kbd>4</kbd> element is present in the list.</li>
</ul>
<p>If we execute this, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bfdb2794-f71c-4f0d-8dc1-a817ecedc97b.png" style=""/></div>
<p>One potential issue with a list collection is that we can have duplicate values in the list. For example, in the preceding example, it's possible to have two elements with the same value as <kbd>1</kbd> in the list. </p>
<p>Due to this issue, we cannot use list collection in scenarios where we must ensure the uniqueness of values. In the next section, we will look at another collection dictionary that overcomes this issue with a list object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dictionary</h1>
                </header>
            
            <article>
                
<p>The dictionary collection can be used in scenarios when we need to maintain uniqueness in values that are being saved. A dictionary collection is comprised of two parts: a key and a value. Together, they are referred to as a key-value pair in .NET. When a dictionary collection is created, it ensures that the key-value is unique and no duplicate keys are present in the collection. Retrieval is also based upon the key, making the operation extremely fast. A dictionary collection is declared by the following index:</p>
<pre>Dictionary&lt;int, int&gt; vs = new Dictionary&lt;int, int&gt;();</pre>
<p>In the preceding code implementation, we are declaring a dictionary collection where both key and value are of the <kbd>int</kbd> format.</p>
<p>Let's right-click on the <kbd>Dictionary</kbd> <span>class</span><span> </span><span>and click on</span> <span class="packt_screen">Go to Definition</span><span>. On doing this, we will be taken to the definition of the dictionary. Upon doing so, we will realize that it implements several interfaces such as </span><kbd>IEnumerable</kbd><span>,</span> <kbd>ICollection&lt;KeyValuePair&lt;Tkey</kbd>, and <kbd>TValue&gt;&gt;</kbd><span>. Please refer to the </span><span>following</span><span> </span><span>definition of the</span> <kbd>Dictionary</kbd><span> class:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/59822b04-ebe1-4cdd-9a77-74228a97ce41.png"/></div>
<p>Due to the implementation of the <kbd>ICollection</kbd> interface based on <kbd>KeyValuePair</kbd>, it ensures that the uniqueness is maintained based on the key.</p>
<p>In the code implementation, we will look at a code example wherein we will implement operations on the <kbd>Dictionary</kbd> object:</p>
<pre>public static void DictionaryCollectionOperations()<br/>{<br/>     Dictionary&lt;int, int&gt; vs = new Dictionary&lt;int, int&gt;();<br/>     for (int x = 0; x &lt; 5; x++)<br/>     {<br/>         KeyValuePair&lt;int, int&gt; pair = new KeyValuePair&lt;int, int&gt;(x, x * 100);<br/>     }<br/>     <br/>     foreach(KeyValuePair&lt;int, int&gt; keyValue in vs)<br/>     {<br/>         Console.WriteLine(keyValue.Key + " " + keyValue.Value);<br/>     }<br/>     vs.Remove(1);<br/>     Console.WriteLine(vs[0]);<br/>     vs.Add(5, 500);<br/>     Console.WriteLine(vs.Count);<br/>     bool hasKey = vs.ContainsKey(4);<br/>     bool hasValue = vs.ContainsValue(900);<br/>     Console.WriteLine(hasKey);<br/>     Console.WriteLine(hasValue);<br/> }</pre>
<p>Please note the following in the preceding code implementation:</p>
<ul>
<li>We have declared a dictionary collection variable. We have implemented a <kbd>for</kbd> loop that runs five times. In the loop, we are creating <kbd>KeyValuePair</kbd> and adding it to the dictionary object. </li>
<li>After we have added elements to the dictionary object, we are looping through the dictionary. We are doing it via a <kbd>foreach</kbd> loop on <kbd>KeyValuePair</kbd> present in the dictionary. </li>
<li>To remove a particular element from the dictionary, we can use the <kbd>Remove</kbd> method. The method takes the input of a key and, based on a key, deletes the respective <kbd>KeyValuePair</kbd> present in the dictionary. </li>
<li>To add a particular element in the dictionary, we can use the <kbd>Add</kbd> method. The method has two parameters, one of the key and another of the value. </li>
<li>To check whether a particular key is present in the dictionary, we can use the <kbd>ContainsKey</kbd> method. The method returns whether the given key exists in the dictionary. If the key exists, it returns <kbd>true</kbd> and, in other cases, it returns <kbd>false</kbd>. </li>
<li>To check whether a particular value is present in the dictionary, we can use the <kbd>ContainsValue</kbd> method. The method returns whether the given value exists in the dictionary. If the value exists, it returns <kbd>true</kbd> and, in other cases, it returns <kbd>false</kbd>.</li>
</ul>
<p>If the preceding code is executed, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/74220baa-fafd-4dc0-90ee-70ceb40fb5dc.png" style=""/></div>
<p>Please note the following points in the output of the code:</p>
<ul>
<li>The values (<kbd>0</kbd>, <kbd>0</kbd>), (<kbd>1</kbd>, <kbd>100</kbd>), (<kbd>2</kbd>, <kbd>200</kbd>), (<kbd>3</kbd>, <kbd>300</kbd>), and (<kbd>4</kbd>, <kbd>400</kbd>) indicate the key-value pairs that are added in the dictionary.</li>
<li><kbd>5</kbd> indicates the length or number of elements present in the dictionary.</li>
<li><kbd>True</kbd> indicates that the dictionary contains <kbd>KeyValuePair</kbd> with the key <kbd>4</kbd>.</li>
<li><kbd>False</kbd> indicates that the dictionary does not contain <kbd>KeyValuePair</kbd> with the value <kbd>900</kbd>. </li>
</ul>
<p>Before we move to the next section, let's try what would happen if we try to add <kbd>KeyValuePair</kbd> in the same dictionary in which the key already exists in the dictionary. For the sake of an example, we will add <kbd>KeyValue</kbd> of <kbd>(1, 1000)</kbd>. Please note that the key <kbd>1</kbd> is already present in the dictionary. When the code is executed, we get the following exception. The exception indicates that if we try to add a value with the same key in the dictionary, it will throw an error:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/653ba67e-fd25-4f30-8974-769ee8363c12.png" style=""/></div>
<p>In the next section, we will go over another set of collection objects: queues and stacks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Queues and stacks</h1>
                </header>
            
            <article>
                
<p>Queues and stacks are collection items that allow us to save data temporarily during the execution of the program. These collections are very similar to the other collections, such as lists, with the major difference being how elements are added and removed from the collection.</p>
<p>A queue is a first-in, first-out type of collection. It basically implies that elements are accessed from the queue in the same order they are added to the collection. When the items are accessed, they can also be removed in the same operation. A queue has three main operations:</p>
<ul>
<li>Adding a new element to the queue: It's executed by the <kbd>Enqueue</kbd> method.</li>
<li>Removing an existing element from the queue: It's executed by the <kbd>Dequeue</kbd> method.</li>
<li>Peeking or retrieving the value of an element in the queue: It's executed by the <kbd>Peek</kbd> method.</li>
</ul>
<p>This diagram shows how the queue works:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/074aa130-4fac-489b-b76f-576f5d20cc42.png" style=""/></div>
<p>In the preceding diagram, the block indicates a queue collection. In the collection, we have added five elements: element A, element B, element C, element D, and element E. Element E was the first element added to the queue and it's at the front of the queue. Element A was the last element added to the queue and it's at the back of the queue. </p>
<p>The green arrows indicate the indexes in the queue at which the different operations will take place. The addition of a new element will always take place at the back of the queue. Removal of an element will take place at the front of the queue.</p>
<p>Let's look at a code implementation to show how it's done programmatically. In the following code, we have created a queue collection object. We will then add elements to the object and execute different operations on it:</p>
<pre>public static void QueueOperations()<br/>{<br/>    Queue&lt;string&gt; que = new Queue&lt;string&gt;();<br/>    que.Enqueue("E");<br/>    que.Enqueue("D");<br/>    que.Enqueue("C");<br/>    que.Enqueue("B");<br/>    que.Enqueue("A");<br/>    int index = 0;<br/>    foreach(string s in que)<br/>    {<br/>        Console.WriteLine("Queue Element at index " + index + " is " + s);<br/>        index++;<br/>    }<br/>    Console.WriteLine("Queue Element at top of the queue is " <br/>                       + que.Peek());<br/>    que.Dequeue();<br/>    index = 0;<br/>    foreach (string s in que)<br/>    {<br/>         Console.WriteLine("Queue Element at index " + index + " is " + s);<br/>         index++;<br/>    }<br/> }</pre>
<p>When the preceding code is executed, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e9ee75b7-c05b-4cfb-8c57-eab160abbd18.png" style=""/></div>
<p>As illustrated by the queue diagram, when we add elements to the queue, they are always added to the end. Therefore, when we add the <kbd>E</kbd>, <kbd>D</kbd>, <kbd>C</kbd>, <kbd>B</kbd>, and <kbd>A</kbd> <span>elements</span><span> </span><span>in the same order,</span> <kbd>A</kbd> <span>will always be at the back of the queue and</span> <kbd>E</kbd> <span>will be at the front of the queue. The indexes in the preceding output indicate the position in the queue where each respective element is present. </span></p>
<p>A peek operation in a queue is always done on the front index, that is, the <kbd><span>0</span></kbd> index of the queue. A removal operation in a queue is always done on the front index, that is, the <kbd>0</kbd> index of the queue. Therefore in the preceding output, both of these operations are executed on the element <kbd>E</kbd>. </p>
<p>Once these operations are done and we reiterate through the queue, we find that<span>, owing to the remove operation,</span><span> element</span> <kbd>E</kbd><span> is no longer present in the queue. Now that we have an understanding of the queue, let's look at how a stack works in .NET Framework.</span></p>
<p>Just like a queue, the stack also provides temporary storage with the only difference being in terms of how the operations are executed on a stack. Stack follows the LIFO model, which implies that the last element added to the stack will be the first one to be removed. The following are the three main operations that we can do on a stack:</p>
<ul>
<li>Add a new element to the stack. It's executed by the <kbd>Push</kbd> method.</li>
<li>Remove an existing element from the stack. It's executed by the <kbd>Pop</kbd> method.</li>
<li>Peek or retrieve the value of an element in the stack. It's executed by the <kbd>Peek</kbd> method.</li>
</ul>
<p>The following diagram shows how the stack works:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9ea5d145-ccfe-4b60-bef5-9d088e1f996e.png" style=""/></div>
<p>In the diagram, the block indicates a stack collection. In the collection, we have added five elements: element A, element B, element C, element D, and element E. Element E was the first element added to the stack and it's at the front of the stack. Element A was the last element added to the stack and it's at the back of the stack. </p>
<p>The green arrows indicate the indexes in the stack at which the different operations will take place. The addition of a new element will always take place at the bottom of the stack. The removal of an element will take place at the top of the stack. </p>
<p>Let's look at a code implementation to show how it's done programmatically. <span>In the following code, we have created a stack collection object. We will then add elements in the object and execute different operations on it:</span></p>
<pre>public static void StackOperations()<br/>{<br/>     Stack&lt;string&gt; sta = new Stack&lt;string&gt;();<br/>     sta.Push("E");<br/>     sta.Push("D");<br/>     sta.Push("C");<br/>     sta.Push("B");<br/>     sta.Push("A");<br/>     int index = 0;<br/>     foreach (string s in sta)<br/>     {<br/>         Console.WriteLine("Stack Element at index " + index + " is " + s);<br/>         index++;<br/>     }<br/>     Console.WriteLine("Stack Element at top of the stack is " <br/>                        + sta.Peek());<br/>     sta.Pop();<br/>     index = 0;<br/>     foreach (string s in sta)<br/>     {<br/>         Console.WriteLine("Stack Element at index " + index + " is " + s);<br/>         index++;<br/>     }<br/> }</pre>
<p>When the preceding code is executed, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0bc29428-0a7b-4de3-bc97-c6e27d4a908b.png" style=""/></div>
<p>A <kbd>Peek</kbd> operation on a stack is always done on the last element added on the stack. Element <kbd>A</kbd> was the last element to be added to the stack. Therefore, when a <kbd>Peek</kbd> operation is done on the stack, it gives an output of <kbd>A</kbd>. Similarly, when a <kbd>Pop</kbd> operation is executed on the stack, it removes the element <kbd>A</kbd>.</p>
<p>With this, we have gone through the different collections that are available in .NET. Each of these collection items has some properties that make them usable in some scenarios and not in others. These criteria need to be evaluated when we are trying to select a collection item to use.</p>
<p>In the next section, we will look at some of the criteria that help us to select the right collection item for each scenario.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing a collection</h1>
                </header>
            
            <article>
                
<p>While choosing a collection type, we have to analyze the scenarios in the application in which we want to use them. The primary difference between these collection types is the way we access elements in them:</p>
<ul>
<li>The array collection needs to have a definite size or length while declaring itself. On the other hand, all other collection types can have their sizes increased dynamically. Also, arrays support random access to the data. This basically implies that as long as the element exists at the specified index in the array, we can access that element without needing to loop through the entire array.</li>
<li>Queues and stacks allow us access the elements in a definite manner. While the queue works in a FIFO manner, the stack works in a LIFO manner. </li>
<li>On the other hand, the list and dictionary collection types allow us to configure random access to the elements. Please note that, conceptually, the list does not support random access; however, in C#, the list is maintained as an array. Due to this, it supports random access.</li>
<li>One important difference between a list and dictionary is the way they save data as well as the performance. In the dictionary collection, we save data in <kbd>KeyValuePair</kbd>. This allows us to maintain the uniqueness of the keys that are present in the dictionary. On the other hand, a list does not provide us with that feature. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary </h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about how we serialize and deserialize data while exchanging it over a network. We looked at the different techniques available for serialization and deserialization. We started with <kbd>XmlSerialization</kbd> and saw how we serialize the data to XML files. We also looked at different attribute tags, such as <kbd>XmlArray</kbd>, <kbd>XmlArrayItem</kbd>, and <kbd>XmlIgnore</kbd>, which we can place in the class object when it's being converted into an XML file. We then looked at binary serialization and learned the advantages it has compared to <kbd>XmlSerialization</kbd>. We also looked at the <kbd>ISerializable</kbd> <span>interface </span>and learned how it provides security while exchanging data over the network.</p>
<p>We then looked at different collection types available in C# and the scenarios in which we should use each of them. We looked at arrays and their restrictions in terms of the length or size of the array, which we must declare during the declaration of the array. We then looked at some other complex collection types, such as list and dictionary. Both of these collection items allow us to increase the collection size during execution but differ in the way they access data. A dictionary saves the data in <kbd>KeyValuePair</kbd> and enforces the uniqueness of the keys that are present in the collection type.</p>
<p>Then, we looked at queues and stack collection types. As opposed to lists and dictionaries, which allow random access to the data, stacks and queues allow us to access to data in a particular order. Queues follow the FIFO model, while stacks follow the FILO model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which of the following statements are true?
<ol type="a">
<li>During serialization, <kbd>XmlSerialization</kbd> automatically includes private attributes in the generated XML class.</li>
<li>In <kbd>XmlSerialization</kbd>, the <kbd>XmlIgnore</kbd> tag can be used to exclude any attribute that we don't want to include in the generated XML class.</li>
<li>In binary serialization, private marked attributes are not serialized.</li>
<li>Using the <kbd>ISerializable</kbd> interface, we can select the attributes and their tags that we want to be present in serialization.</li>
</ol>
</li>
<li>Which of the following statements are true?
<ol type="a">
<li>We can increase the size of an array collection type during program execution.</li>
<li>Queues follow the LIFO model for accessing elements.</li>
<li>A dictionary saves data in <kbd>KeyValuePair</kbd>, ensuring the uniqueness of key-value pairs present in the collection item.</li>
<li>Both a list and dictionary allow random access to the data elements.</li>
</ol>
</li>
<li>You are working with a large group of <kbd>student</kbd> objects. You need to remove all duplicates and then group them by <kbd>studentid</kbd>. Which collections should we use?<br/>
<ol type="a">
<li>List</li>
<li>Stack</li>
<li>Dictionary</li>
<li>Queue</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Answers</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>b and d</strong></li>
<li><strong>c and d</strong></li>
<li><strong>c</strong></li>
</ol>


            </article>

            
        </section>
    </body></html>