- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Reasoning about Expressions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于表达式的推理
- en: So far, we’ve looked at the powerful metadata that is captured and how we can
    access it using reflection. We’ve also looked at how we can leverage this same
    metadata and generate code on the fly at runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了捕获的强大元数据以及我们如何使用反射来访问它。我们还探讨了如何利用相同的元数据并在运行时动态生成代码。
- en: Using reflection and generating code as techniques in metaprogramming are extremely
    powerful, but they’re not applicable to all scenarios. It can also be very involved
    and produce hard-to-read and maybe even hard-to-maintain code going deep with
    reflection and proxy generation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反射和生成代码作为元编程的技术在元编程中非常强大，但它们并不适用于所有场景。这也可能非常复杂，并可能产生难以阅读甚至难以维护的代码，尤其是在深入反射和代理生成时。
- en: C# expressions can, for a lot of scenarios, represent a better approach or an
    additional approach for specific scenarios for doing runtime discovery and extraction
    of metadata.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，C#表达式可以代表更好的方法或特定场景的附加方法，用于运行时发现和提取元数据。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What are expressions?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式是什么？
- en: Traversing an expression tree
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历表达式树
- en: Using expressions as descriptors of members on types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表达式作为类型成员的描述符
- en: From this chapter, you should understand what expressions are and how you can
    leverage them as a technique to reason about the running code at runtime.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中，你应该理解表达式是什么以及你如何利用它们作为在运行时推理运行代码的技术。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7)),
    and it builds on top of the **Fundamentals** code that is found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的特定源代码可以在GitHub上找到（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter7)），并且它建立在[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)中找到的**基础知识**代码之上。
- en: Important note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Both the **GetMemberExpression()** and **GetPropertyInfo()** methods can be
    found in the **ExpressionExtensions.cs** file in **Fundamentals** in the GitHub
    repository.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetMemberExpression()**和**GetPropertyInfo()**方法都可以在GitHub仓库中的**基础知识**文件夹下的**ExpressionExtensions.cs**文件中找到。'
- en: What are expressions?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式是什么？
- en: '**C# 3.0** was introduced in late 2007, and its killer feature was something
    called **Language-Integrated Query** (**LINQ**). With the underlying API model
    and combination of new capabilities in C#, it introduced a programming paradigm
    that bridges into the more functional programming space. The fluent interfaces
    and its use of lambdas can feel foreign if you’re used to more object-oriented
    approaches.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**C# 3.0**于2007年底推出，其杀手级特性是所谓的**语言集成查询**（**LINQ**）。结合底层的API模型和C#中新的功能，它引入了一种编程范式，将编程空间与更函数式编程空间相连接。如果你习惯了更面向对象的方法，流畅的接口和其使用的lambda表达式可能会感觉陌生。'
- en: What it brought to the table was a way of expressing queries for data in a more
    natural native C# way. Not only does it do this for your in-memory collections,
    but also for any other data source, such as a database. It basically gave developers
    a uniform way of expressing queries, filters, and projections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它带来的好处是提供了一种以更自然、更本地的C#方式表达数据查询的方法。这不仅适用于内存中的集合，也适用于任何其他数据源，如数据库。它基本上为开发者提供了一种表达查询、过滤和投影的统一方式。
- en: 'It did this by recognizing that a query operation consists of the following
    three distinct parts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过识别查询操作由以下三个不同的部分组成来实现这一点：
- en: The data source
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源
- en: The query expression
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询表达式
- en: Executing the query
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行查询
- en: 'Let’s look at an example without LINQ and compare it to how you could do the
    same with LINQ in a more expressive way:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个没有使用LINQ的例子，并将其与使用LINQ以更表达性的方式完成相同任务的方法进行比较：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running this would print out **42, 84, 37**, as expected. The challenge with
    something like this is that it is very verbose and coupled to the data source
    and gives no room for optimization.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会打印出**42, 84, 37**，正如预期的那样。这种类型的问题的挑战在于它非常冗长，与数据源耦合，并且没有优化空间。
- en: With LINQ and the recognition of the three distinct parts mentioned earlier
    that make up a query, there is a concept of **deferred execution**. The actual
    execution of the query does not happen until you start enumerating it. That means
    you can build on the query while its final execution won’t occur until we really
    need the data. The execution is performed by the query provider, which could be
    the default in-memory one or something that represents a data source such as a
    database.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LINQ 以及对前面提到的构成查询的三个不同部分的识别，存在一个概念叫做 **延迟执行**。查询的实际执行直到你开始枚举它才会发生。这意味着你可以在查询最终执行之前构建查询。执行是由查询提供者执行的，它可能是默认的内存中提供者，或者代表数据源（如数据库）的某种东西。
- en: 'Representing the previous sample with LINQ is much more expressive:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LINQ 表示前面的示例要表达得多：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code becomes much more readable, but what happens behind the scenes is that
    it also becomes much more flexible in how it runs and makes it possible to optimize
    the execution as it sees fit for the data source the query is running against.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的可读性大大提高，但幕后发生的事情是，它也变得更加灵活，可以根据查询运行的数据源进行优化。
- en: LINQ is a language feature of C#, and it can’t work without support from the
    .NET class libraries and the .NET runtime. This is where expressions come in.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 是 C# 的语言特性，没有 .NET 类库和 .NET 运行时的支持是无法工作的。这就是表达式发挥作用的地方。
- en: As part of the base class libraries that were released at the same time, there
    was a new namespace called **System.Linq** and another within it called **System.Linq.Expressions**.
    This is where the *magic* *sauce* lies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为同时发布的基类库的一部分，有一个新的命名空间叫做 **System.Linq**，以及其中另一个叫做 **System.Linq.Expressions**
    的命名空间。这里的 *魔法* *精华* 就在这里。
- en: The C# compiler translates the native LINQ code using another feature that was
    introduced in C# 3.0 called extension methods. Extension methods are just static
    methods that look like they’re members of the actual type they extend, they can
    be used to form a fluent interface that can chain method calls.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器使用 C# 3.0 中引入的另一个特性——扩展方法来翻译本机 LINQ 代码。扩展方法只是看起来像是它们扩展的实际类型的成员的静态方法，它们可以用来形成一个流畅的接口，可以链式调用方法。
- en: 'Taking the previous LINQ code, we can express it using expressions and the
    extension methods that are found in the **System.Linq** namespace:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的 LINQ 代码出发，我们可以使用 **System.Linq** 命名空间中找到的表达式和扩展方法来表示它：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All three approaches discussed so far do the same thing and print out the same
    result. The biggest difference is readability.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的所有三种方法都做同样的事情，并输出相同的结果。最大的区别在于可读性。
- en: 'Since our data source is just an in-memory array, the extension methods will
    reflect that and you’ll notice the signature of the **.Where()** method it uses:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据源只是一个内存中的数组，扩展方法会反映这一点，你将注意到它使用的 **.Where()** 方法的签名：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first parameter is the source it extends, **IEnumerable<TSource>**, and
    the second parameter is **Func<int, bool>**. This means that you’re giving it
    a callback that will be called to decide whether or not the specific value, while
    it iterates through them, should be included or not.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是它扩展的源，**IEnumerable<TSource>**，第二个参数是 **Func<int, bool>**。这意味着你给它一个回调，该回调将被调用以决定在迭代过程中是否应该包含特定的值。
- en: This doesn’t really bring out the topic of this chapter. Let’s change it up
    a little to bring out the real magic.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有真正引出本章的主题。让我们稍微改变一下，以展示真正的魔法。
- en: Expression
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: For LINQ to work as intended with regard to different data sources and deferred
    execution, there is an interface called **IQueryable**. The **IQueryable** interface
    is something a data source can implement, and instead of having an imperative
    approach to just iterating the data source, it can now get the query represented
    as an expression.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 LINQ 能够针对不同的数据源和延迟执行按预期工作，有一个名为 **IQueryable** 的接口。**IQueryable** 接口是数据源可以实现的，它不再只是迭代数据源的一种命令式方法，现在它可以获取表示为表达式的查询。
- en: 'An **IQueryable** interface gives us different extension methods that expose
    **Expression** as a type. Let’s change the array filtering up a little bit and
    introduce the concept of a queryable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**IQueryable** 接口为我们提供了不同的扩展方法，这些方法公开了 **Expression** 作为一种类型。让我们稍微改变一下数组过滤，并引入查询的概念：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The **.AsQueryable()** array changes from an array, or more exactly, **IEnumerable<int>**
    becomes **IQueryable<int>**. That means we get access to a whole set of LINQ extension
    methods that are extending **IQueryable<>**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**.AsQueryable()**数组从数组，或者更确切地说，从**IEnumerable<int>**变为**IQueryable<int>**。这意味着我们可以访问一系列扩展**IQueryable<>**的LINQ扩展方法。'
- en: 'If you look closer at the **.Where()** method, you’ll notice that one of the
    extension methods now has the following signature:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察**.Where()**方法，你会注意到现在有一个扩展方法具有以下签名：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first parameter is the source it extends, and the second parameter is **Expression<Func<TSource,
    bool>>**. This is the most significant part. The C# compiler recognizes anything
    that is an expression type, and instead of just creating a callback that gets
    called, it expands it into an expression.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是它扩展的源，第二个参数是**Expression<Func<TSource, bool>>**。这是最重要的部分。C#编译器识别任何表达式类型，而不是仅仅创建一个被调用的回调，而是将其展开为一个表达式。
- en: 'In order for us to investigate what the compiler does, we can take the **where**
    clause and separate it into its own line of code, enabling us to set a breakpoint
    in the debugger and look at what is going on:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调查编译器做了什么，我们可以将**where**子句单独成行，这样我们就可以在调试器中设置断点并查看发生了什么：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the expression extracted into its own line of code, we can easily see
    what the compiler generates for us. By setting a breakpoint after the **filter**
    variable construction and looking at the **filter** variable in the watch view
    of your debugger, you can see the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式提取到自己的代码行中，我们可以轻松地看到编译器为我们生成了什么。通过在**filter**变量构造后设置断点，并在调试器的监视视图中查看**filter**变量，你可以看到以下内容：
- en: '![](img/B19418_07_1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_07_1.jpg)'
- en: Figure 7.1 – The filter expression
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 过滤表达式
- en: 'As you can see, it is no longer just a callback. It has captured all the details
    of what you are expressing. Notice the **Body** property. This is the inner expression.
    The type, in our case, is translated into **LogicalBinaryExpression**, which holds
    three things of importance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它不再只是一个回调。它已经捕获了你所表达的所有细节。注意**Body**属性。这是内部表达式。在我们的例子中，类型被转换为**LogicalBinaryExpression**，它包含三个重要内容：
- en: '**Left**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左**'
- en: '**NodeType**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NodeType**'
- en: '**Right**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右**'
- en: The **Left** property represents what is on the left-hand side of the expression,
    and the **Right** property represents what is on the right-hand side. And in the
    middle of this, the operator, **NodeType**, tells us the action it will be performing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**左**属性表示表达式左侧的内容，而**右**属性表示表达式右侧的内容。在这两者之间，操作符**NodeType**告诉我们它将要执行的操作。'
- en: For both the **Left** and **Right** properties, you also see that their type
    is **Expression**. The **Left** expression, in this case, is **PrimitiveParameterExpression**,
    representing the parameter, the value that will be passed if we are iterating
    or calling the expression. While the **Right** expression becomes **ConstantExpression**,
    holding the concrete value, the **NodeType** property is set to **GreaterThanOrEqual**,
    which is what was expressed by **>=**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**左**和**右**属性，你也会看到它们的类型是**Expression**。在这种情况下，**左**表达式是**PrimitiveParameterExpression**，表示参数，即我们在迭代或调用表达式时将传递的值。而**右**表达式变为**ConstantExpression**，持有具体值，**NodeType**属性设置为**GreaterThanOrEqual**，这正是**>=**所表达的含义。
- en: Lambda expression
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: 'When you use the **=>** notation, you form what is known as a **lambda expression**.
    Lambda expressions are anonymous functions. Lambda expressions are divided into
    the following two types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用**=>**符号时，你形成了一个被称为**lambda表达式**的结构。Lambda表达式是无名函数。Lambda表达式分为以下两种类型：
- en: Expression lambdas
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expression lambdas
- en: Statement lambdas
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Statement lambdas
- en: 'Expression lambdas are characterized by having the right side express an expression.
    An expression lambda returns the result of the expression and looks like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式lambda的特点是右侧表达一个表达式。表达式lambda返回表达式的结果，其形式如下：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the type of expression used in the expression you saw earlier:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在之前看到的表达式中使用的表达式类型：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Its signature is defined by **Func<int, bool>**, where the first generic argument
    is the type of the parameter used, and the last generic argument is the return
    type. You can have multiple parameters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它的签名由**Func<int, bool>**定义，其中第一个泛型参数是使用的参数类型，最后一个泛型参数是返回类型。你可以有多个参数。
- en: 'Statement lambdas are characterized by it being enclosed in braces, **{}**,
    and typically having multiple statements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 lambda 的特点是它被括号 **{}** 包围，并且通常包含多个语句：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This could be something like the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能类似于以下代码片段：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With a statement, a lambda is typically something that is not possible to reason
    about, as it will not form an expression tree but rather have multiple statements
    within it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个语句中，lambda 通常是一种无法进行推理的东西，因为它不会形成一个表达式树，而是在其中包含多个语句。
- en: Lambdas represent a very powerful construct that can be used to gain insight
    into what is going on. It’s also a great way to help understand how expressions
    work and can be constructed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Lambdas 代表一个非常强大的结构，可以用来深入了解正在发生的事情。这同样也是一个很好的方法来帮助理解表达式是如何工作和构建的。
- en: Traversing an expression tree
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历表达式树
- en: An **Expression** is a simple construct that represents a node in a tree. The
    expression has a node type, and the implementation decides what the node type
    expresses and means. This forms a tree that can be recursively traversed and reasoned
    about.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Expression** 是一个简单的结构，表示树中的一个节点。表达式有一个节点类型，实现决定节点类型表达什么以及意味着什么。这形成了一个可以递归遍历和推理的树。'
- en: 'For lambda expressions, it means it has a body that consists of an expression
    that is of a specific type; this type could be a **Binary Expression** that holds
    a left and a right and the node itself representing the operand (equals, not equals,
    and so forth):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 lambda 表达式，这意味着它有一个由特定类型的表达式组成的主体；这个类型可以是包含左右操作数和表示操作符（等于、不等于等）的 **Binary
    Expression**：
- en: '![](img/B19418_07_2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_07_2.jpg)'
- en: Figure 7.2 – Binary expression
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 二元表达式
- en: 'Taking the example of the filter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以过滤器为例：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Visually it looks like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，它看起来如下：
- en: '![](img/B19418_07_3.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_07_3.jpg)'
- en: Figure 7.3 - A parameter larger than the constant expression
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 - 一个大于常量表达式的参数
- en: The operand is **greater than or equal**, the left-hand side accesses the parameter
    passed into it, and the right-hand side holds the constant value of **37**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数是 **大于或等于**，左侧访问传递给它的参数，右侧持有常量值 **37**。
- en: Expressions can also represent accessing a member on the type being passed in
    as a parameter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式也可以表示访问作为参数传递的类型上的成员。
- en: 'Let’s say we have an object called **Employee** that looks like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 **Employee** 的对象，其外观如下：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A filter accessing the first name and looking for a person called **Jane**
    would look like the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个过滤器访问名字并寻找名为 **Jane** 的人将看起来如下：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Dissecting the expression tree, we will see that it now changes into the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 解构表达式树，我们会看到它现在变成了以下形式：
- en: '![](img/B19418_07_4.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_07_4.jpg)'
- en: Figure 7.4 – Member access equal constant expression
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 成员访问等于常量表达式
- en: Since we’re now accessing a member, the left-hand expression is now **MemberAccessExpression**.
    **MemberAccessExpression** has an expression on it that represents the source
    that holds the member, in our case, a parameter being passed in. To get the actual
    member, **MemberAccessExpression** holds a property called **Member**. Since the
    member we’re accessing is a property, it will be the actual **PropertyInfo**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在正在访问一个成员，左侧的表达式现在是 **MemberAccessExpression**。**MemberAccessExpression**
    上有一个表达式，表示持有成员的源，在我们的例子中，是一个传递进来的参数。为了获取实际的成员，**MemberAccessExpression** 拥有一个名为
    **Member** 的属性。由于我们访问的成员是一个属性，它将是实际的 **PropertyInfo**。
- en: 'Expressions are not just used for filters; they can represent other operations
    as well. We could have an expression that represents adding values, such as the
    following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式不仅用于过滤器；它们还可以表示其他操作。我们可能有一个表示添加值的表达式，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The expression itself now returns **int** instead of **bool**, takes the parameter
    passed to it, and adds **42**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式现在返回 **int** 而不是 **bool**，接受传递给它的参数，并加上 **42**。
- en: 'The expression tree is shown in the following diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树如下图中所示：
- en: '![](img/B19418_07_5.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_07_5.jpg)'
- en: Figure 7.5 – Parameter adding constant expression
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 参数添加常量表达式
- en: As you can see, the node type is **Add**. This is just one of many types of
    expressions you can use. You can create really complex structures and represent
    in an abstract way the core functionality of what the .NET runtime itself is capable
    of running. We will see more of the different types in [*Chapter 8*](B19418_08.xhtml#_idTextAnchor132),
    *Building and* *Executing Expressions*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，节点类型是 **Add**。这只是你可以使用的许多表达式类型之一。你可以创建非常复杂的结构，并以抽象的方式表示 .NET 运行时本身能够运行的核心功能。我们将在
    [*第 8 章*](B19418_08.xhtml#_idTextAnchor132)，*构建和执行表达式* 中看到更多不同类型。
- en: Using expressions as descriptors of members on types
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将表达式用作类型成员的描述符
- en: Expressions represent a way of describing intent in a declarative fashion. Rather
    than with an imperative approach where we tell the computer exactly what to do,
    we can declaratively describe it and let the code decide the best way to approach
    it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式代表了一种以声明式方式描述意图的方法。而不是通过命令式方法，我们告诉计算机确切要做什么，我们可以声明式地描述它，并让代码决定最佳的处理方式。
- en: As we saw earlier with the filtering of numbers, the imperative approach using
    **foreach** does not open for any other execution than what we have put in. While
    with the LINQ and expression approach, we describe what we want, and the execution
    is deferred, how it is handled and executed, we don’t know – but the results are
    the same.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在数字过滤中看到的那样，使用 **foreach** 的命令式方法不为我们打开任何其他执行方式，而使用 LINQ 和表达式方法，我们描述了我们想要的内容，执行是延迟的，我们不知道如何处理和执行，但我们得到的结果是相同的。
- en: This type of declarative thinking can be a very powerful way to describe what
    you want for your system and can also make your code more readable and easier
    for others to reason about. Imperative code requires you to thoroughly read and
    understand what the code does, while a declarative approach describes the desired
    outcome and is much easier to reason about.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明式思维可以是一种非常强大的方式来描述你希望你的系统有什么，也可以使你的代码更易于阅读，更容易被他人理解。命令式代码要求你彻底阅读和理解代码做了什么，而声明式方法描述了期望的结果，更容易推理。
- en: Obviously, a declarative model is limited in its capabilities, while an imperative
    approach is fully flexible, and you can leverage the full power of the C# language.
    Combining the two methods is best if you can declaratively describe things using
    something such as a fluent interface and take full advantage of the C# extension
    methods to hold methods that represent the imperative actions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，声明式模型在功能上有限，而命令式方法则完全灵活，你可以利用 C# 语言的全部功能。如果你可以使用流畅接口之类的工具声明式地描述事物，并充分利用 C#
    扩展方法来持有表示命令式动作的方法，那么结合这两种方法是最好的。
- en: Let’s take a look at a library called **FluentValidation** ([https://docs.fluentvalidation.net/en/latest/](https://docs.fluentvalidation.net/en/latest/)).
    It is a library that lets you fluently write validation of input. It takes full
    advantage of expressions and gives you a declarative model that is extensible
    using extension methods for describing your intent.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个名为 **FluentValidation** 的库（[https://docs.fluentvalidation.net/en/latest/](https://docs.fluentvalidation.net/en/latest/)）。这是一个允许你流畅地编写输入验证的库。它充分利用了表达式，并为你提供了一个可使用扩展方法进行扩展的声明式模型，以描述你的意图。
- en: 'The following is the sample from their documentation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从他们的文档中的示例：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The validator inherits from a base type called **AbstractValidator<>**, and
    on this type, there is a method called **RuleFor()**. This method is the starting
    point for describing rules for properties on the type passed in as a generic argument
    to **AbstractValidator<>**. The **RuleFor()** signature looks like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器从名为 **AbstractValidator<>** 的基类型继承，在这个类型上有一个名为 **RuleFor()** 的方法。这个方法是描述传递给
    **AbstractValidator<>** 的泛型参数上的属性规则的起点。**RuleFor()** 的签名如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the parameter for **RuleFor()** is an expression. The expected
    expression is one that takes the type that was passed to **AbstractValidator<>**
    as a parameter and returns any type. **TProperty** will automatically be inferred
    by the C# compiler from the expression.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，**RuleFor()** 的参数是一个表达式。预期的表达式是接受传递给 **AbstractValidator<>** 的类型作为参数并返回任何类型的表达式。**TProperty**
    将由 C# 编译器从表达式中自动推断出来。
- en: '**FluentValidation** uses this expression to know what property you’re validating
    by inspecting the expression.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**FluentValidation** 使用这个表达式通过检查表达式来了解你正在验证哪个属性。'
- en: In **Fundamentals** part of the code for the book, you’ll find a class called
    **ExpressionExtensions** that has helper extension methods for doing the same
    type of inspection that **FluentValidation** does.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的**基础知识**部分代码中，您将找到一个名为**ExpressionExtensions**的类，它具有用于执行与**FluentValidation**相同类型检查的辅助扩展方法。
- en: 'Since expressions can describe all kinds of members and the code for finding
    the member it represents is the same, there is a method for getting the expression
    that represents the member:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表达式可以描述各种成员，并且表示该成员的代码是相同的，因此存在一种获取表示成员的表达式的方法：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code assumes that the incoming expression is **LambdaExpression** and then
    checks whether this is a **UnaryExpression** that holds the member. If it is not
    **UnaryExpression**, we assume it is **MemberExpression**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假设传入的表达式是**LambdaExpression**，然后检查这是否是一个包含成员的**UnaryExpression**。如果不是**UnaryExpression**，我们假设它是**MemberExpression**。
- en: If it is not **MemberExpression**, this will cause an invalid cast exception.
    You might want to consider checking types and throw a more specific exception.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不是**MemberExpression**，这将导致无效的强制类型转换异常。您可能想要考虑检查类型并抛出一个更具体的异常。
- en: The reason for the check for **UnaryExpression** is that for expressions that
    have the type of the value as **object** and the actual value is a type that needs
    converting, casting, or unboxing for it to become the **object** type, the compiler
    can decide to put in a unary expression that performs this action.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 检查**UnaryExpression**的原因是，对于值类型为**object**且实际值为需要转换、强制类型转换或拆箱以成为**object**类型的表达式，编译器可以决定插入一个执行此操作的**一元表达式**。
- en: 'Once you have the member expression, we can get the actual member as the **System.Reflection**
    type that represents a property, **PropertyInfo**:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了成员表达式，我们就可以获取实际的成员，作为表示属性的**System.Reflection**类型，即**PropertyInfo**：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code calls **GetMemberExpression()** and casts **Member** to **PropertyInfo**.
    If the member is not **PropertyInfo**, this will throw an exception. You might
    want to check for correctness and throw a more specific exception.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用**GetMemberExpression()**并将**Member**强制转换为**PropertyInfo**。如果成员不是**PropertyInfo**，这将抛出异常。您可能想要检查正确性并抛出一个更具体的异常。
- en: With **PropertyInfo** returned, you now have all the information you need about
    the described property, its name and type, and more.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回**PropertyInfo**，您现在拥有了关于描述的属性、其名称和类型以及更多信息的所有所需信息。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about a valuable member of the .NET class libraries
    called expressions. Thanks to the symbiosis of the C# compiler and the runtime,
    you get another approach to reason about the running code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们学习了.NET类库中的一个宝贵成员，称为表达式。得益于C#编译器和运行时的共生关系，您得到了另一种推理运行代码的方法。
- en: Expressions represent a structured approach for representing, well, expressions.
    There is somewhat of a resemblance to an abstract syntax tree, which all code
    compilers produce when parsing code. Something we’ll get more familiar with in
    [*Chapter 15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn* *Compiler Extensions*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式代表了一种表示表达式的结构化方法。它与抽象语法树有某种相似之处，所有代码编译器在解析代码时都会生成抽象语法树。我们将在[*第15章*](B19418_15.xhtml#_idTextAnchor250)，*Roslyn*
    *编译器扩展*中了解更多。
- en: As we’ve seen in this chapter, the type of expressions can be for just capturing
    information, but they can also be more powerful and capture operations that can
    be executed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章所见，表达式的类型不仅可以用于仅仅捕获信息，还可以更强大，捕获可以执行的操作。
- en: In the next chapter, we will dive deeper into expressions and see how you can
    build out expressions at runtime that you can then execute dynamically.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨表达式，看看您如何在运行时构建可以动态执行的表达式。
