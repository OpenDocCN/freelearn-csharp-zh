- en: Event Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our first subject in the *Decoupling* section of this book, we are going
    to review the Event Bus pattern. But first, we need to address the confusion that
    often arises between the definition of an Event Bus and its close cousin, the
    Event Queue. We can quickly boil down the core difference between both from their
    names.
  prefs: []
  type: TYPE_NORMAL
- en: A bus permits data to flow between different components, while a queue collects
    a list of data that needs processing at sequential intervals. And by this high-level
    definition of a bus, we can conclude that an Event Bus will focus on serving as
    a central hub for the publishing and broadcasting of events, and not as a queue
    of those events.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this chapter, we will be focusing on building an Event Bus that will
    optimize the way we decouple listeners and consumers of events in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the basics of the Event Bus pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a global messaging system that can be adapted to any game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Event Bus is an extension of the Observer pattern, so I recommend revisiting [Chapter
    10](b24cadf0-e8e7-45c8-b2f3-f6d72985f19a.xhtml), *Observer*, before starting this
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also be using the following specific Unity engine API features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UnityEvents`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnityActions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're unfamiliar with these, please review their official Unity API documentation,
    but note that we will be reviewing them in the *Code example* section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2OxHxto](http://bit.ly/2OxHxto)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Event Bus Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a possible point of confusion around the Event Bus pattern. It's sometimes
    referred to as a **Messaging System** or the **Publish-Subscribe** pattern, the
    latter being the most accurate name for what we are implementing in this chapter.
    But because we are taking a very hands-on approach to this book, we are going
    to refer to this pattern's design as an Event Bus, which is a more high-level
    and system-oriented name for it.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in [Chapter 9](b24cadf0-e8e7-45c8-b2f3-f6d72985f19a.xhtml), *Observer*,
    C# has native implementations that simplify the process of integrating events
    by offering an event-driven mechanism that permits Subjects and Observers to communicate
    with each other. But C#'s native event system does have a drawback – observers
    need to be *aware* of the presence of potential subjects, or unexpected behaviors
    can occur.
  prefs: []
  type: TYPE_NORMAL
- en: This, therefore, is why we are going to learn how to use the Event Bus—with
    this pattern, we are going to eliminate this dependency and make it possible for
    any object to publish events and subscribe to them without any direct dependencies
    between each other. Consequently, we will shift from an observer/subject arrangement
    to a more flexible publisher/subscriber approach.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fdc7d33-f5cd-485c-a783-15093ddb647a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the following diagram of the Event Bus and examine its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, there are three main ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Publishers**:These objects can request the hub to manage specific events
    and broadcast them to the right listeners'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Hub**: This object is responsible for coordinating the communication
    of events between the **Publishers** and **Subscribers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscribers**: These objects subscribe themselves to the hub''s event broadcast
    channel so they can listen for specific events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The benefits and drawbacks of the Event Bus are quite moderate—it''s a pattern
    that permits the implementation of an event management system without asking for
    significant architectural changes in your code base:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **benefits** are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decouples systems**: Because publishers and subscribers only communicate
    through the Event Bus, it reduces direct references and decouples objects from
    each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast channels**: Similar to a TV or radio broadcast system, you can
    use the Event Bus as a way to transmit messages through specific channels that
    listeners can subscribe to at their discretion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **drawbacks** to be aware of are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory overhead**: Under the hood of any event system, there''s a lot of
    low-level memory mechanisms that are being triggered to manage the communication
    between objects, so it might not be the best choice if you need to squeeze milliseconds
    of processing out of every frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike other patterns in this book, the Event Bus is a functional and complete
    system in itself. This fact means that we can implement it without having to map
    it into a specific in-game system, and it will still become an instrumental component
    of our game's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We could almost view the Event Bus as a global service that offers a way for
    all our components to message each other on specific channels. So, in the *Code
    example* section, we are going to implement the Event Bus in its native form,
    and make sure that it's globally accessible as a service for all our components.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the *Code example* section, I recommend reviewing [Chapter 6](b8d60568-5961-4e57-b722-36028db5d1a9.xhtml),
    *Singleton*, because we are going to use it as a base for our Event Bus class.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the *An example use case* section, we are going to implement
    the Event Bus as a service that all our components will be able to use when they
    need to broadcast events to other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start by implementing the core of the system by writing our Event
    Bus class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we are making our class into a Singleton; this will permit our
    `EventBus` instance to be globally accessible. But the most critical element that
    we need to notice is that we are using two new specific Unity API features: `UnityEvent`
    and `UnityAction`.
  prefs: []
  type: TYPE_NORMAL
- en: '`UnityEvent` and `UnityAction` are API wrappers over the .NET native delegate
    type. They behave almost exactly like regular delegates under the hood, but they
    offer extra features that are custom to Unity, such as the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspector access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using them in our example for reasons of simplicity while making sure
    we exploit Unity API's features to the fullest.
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed information on the specific features that `UnityEvent` offers,
    please refer the official API documentation in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we break down the class even further, we can see that four core functions
    make the Event Hub function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Init()`: This initializes a dictionary that will hold in memory events to
    which `Subscribers` register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StartListening()`: This is a function that `Listeners` uses to register themselves
    to listen to a specific event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StopListening()`: This function permits `Listeners` to stop listening to a
    specific event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TriggerEvent()`: This function will trigger an event and broadcast it to all
    its `Listeners`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In theory, our work is done—with one class, we were able to implement an Event
    Bus that's globally accessible and ready to manage the communication of events
    between objects. So now, the only thing to do is to write ourselves an example
    of a Publisher object, along with a couple of Subscribers to test our new Event
    Bus service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the Publisher, as without one, our `Listeners` will have
    nothing to listen to except silence. We are going to implement a straightforward
    Publisher that triggers a broadcast of specific events depending on user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our `EventPublisher` class is elementary—it asks the Event Hub to broadcast
    the `Launch` and `Shoot` events depending on user input. This implementation means
    that any `Listeners` that are listening for events named `Launch` or `Shoot` will
    be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate this functionality, let''s implement two Listeners, each with different
    responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Rocket`: This class listens for a `Launch` command event, and when it receives
    it, it triggers a launch sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Cannon`: Similar to the `Rocket` class, `Cannon` listens for a `Shoot` command
    and then triggers the shooting mechanism at the reception of the message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Listeners only need to register themselves as listeners of a specific event
    by calling the `StartListening()` function and specifying the name of the event
    they want to listen to, along with the callback function. The Event Bus will take
    responsibility for coordinating the broadcast of events to the right Listeners
    and trigger their respective callback function when required.
  prefs: []
  type: TYPE_NORMAL
- en: There's something else we need to address. Notice that we are checking if the
    application is quitting with `OnApplicationQuit()` and validating the Boolean
    value of `m_IsQuitting` for `false` before calling the `EventBus.StopListening()`
    function. This approach is to avoid calling objects that might not be in memory
    anymore once the application is quitting.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the Event Bus almost performs a similar function to a motherboard
    bus in the sense that it's acting like a system of communication between separate
    components. But even a simple Event Bus, like the one we just implemented, can
    be extended into a more complex system, such as an Event Queue or a multi-channel
    Messaging System, if need be.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed and implemented the Event Bus, a pattern with a
    focus on decoupling the relationship between the objects that broadcast events
    and those that listen to them. By exploiting new native Unity API features such
    as `UnityEvents`, we were able to implement this pattern with the minimum amount
    of code quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be reviewing the Service Locator, another pattern
    that focuses on decoupling complex relationships between dependencies, but this
    time by offering a way for objects to locate services.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage any Unity programmer to take the time to read the engine's entire
    API documentation, currently available on Unity's official website, and to memorize
    as much of it as you can. This exercise will make you more aware of the features
    it offers, and may even make you a faster coder. The detailed knowledge of this
    API will also impress your colleagues or potential future interviewers.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As indicated at the beginning of this chapter, we decided to focus on the Event
    Bus pattern, and not its cousin, the Event Queue. But a bus mechanism can be converted
    to a queue. So, as a practical exercise, I would recommend to converting the Event
    Bus example we just completed, and instead of just having it forwarding triggered
    events to subscribers, it should hold them in a queue so they can be handled sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the material indicated in the *Further reading* section of
    this chapter for inspiration.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Unity - Manual: UnityEvents:*[https://docs.unity3d.com/Manual/UnityEvents.html](https://docs.unity3d.com/Manual/UnityEvents.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity - Scripting API Documentation:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[https://docs.unity3d.com/ScriptReference/](https://docs.unity3d.com/ScriptReference/)**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Game Programming Patterns* by *Robert Nystrom*:[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
