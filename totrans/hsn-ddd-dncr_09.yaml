- en: CQRS - The Read Side
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS - 读取侧
- en: In the previous chapter, we learned about persisting aggregates to different
    types of databases. However, we haven't looked at the topic of retrieving data
    from a database, except using the repository `Load` method to retrieve a single
    aggregate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了将聚合持久化到不同类型的数据库。然而，我们还没有探讨从数据库中检索数据的话题，除了使用存储库的`Load`方法来检索单个聚合。
- en: It is now time to get a hold on the data we managed to store in the database
    and add some `GET` endpoints to the API. For this book, I had no plans to show
    you how to build repositories with numerous `GetByThat` methods or, even worse,
    a generic repository that returns `IQueryable<T>`. That kind of approach, while
    it might seem attractive, removes the Ubiquitous Language from queries, since
    developers start to retrieve aggregates by filtering properties. For example,
    a query such as `_repository.Query(x => x.State == State.IsActive && x.Price.Amount
    > 100)` tells us very little about the intention of the query consumer. What does
    this filter mean for the business? We would never know unless we study every line
    of code that calls this query, and probably only then can we figure out its purpose.
    Also, free-filter queries open the Pandora's box of hitting the database server
    without any optimization. For relational databases, we end up with numerous heavy
    joins and unindexed queries. With document databases, we might even get failures
    if there are no automatic indexes supported by the database engine itself. RavenDB
    is clever enough to create automatic indexes when we execute a query for which
    the server has not built an index yet. While that is not a big issue during development,
    it will have a severe impact on production systems where the server deals with
    a significant number of documents.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候掌握我们成功存储在数据库中的数据，并在API中添加一些`GET`端点。对于这本书，我本来没有计划向您展示如何构建具有众多`GetByThat`方法的存储库，或者更糟糕的是，一个返回`IQueryable<T>`的通用存储库。这种看似吸引人的方法，却从查询中移除了通用语言，因为开发者开始通过过滤属性来检索聚合。例如，一个查询如`_repository.Query(x
    => x.State == State.IsActive && x.Price.Amount > 100)`告诉我们很少关于查询消费者的意图。这个过滤器对业务意味着什么？除非我们研究调用此查询的每一行代码，否则我们永远不会知道，而且可能只有在那时我们才能弄清楚它的目的。此外，自由过滤查询打开了潘多拉的盒子，在没有优化的情况下击中数据库服务器。对于关系数据库，我们最终会有许多复杂的连接和未索引的查询。对于文档数据库，如果没有数据库引擎支持的自动索引，我们甚至可能会得到失败。RavenDB足够聪明，当我们执行服务器尚未构建索引的查询时，会创建自动索引。虽然这在开发期间不是大问题，但它将对生产系统产生严重影响，其中服务器处理大量的文档。
- en: So, in this book, we will be applying CQRS principles and separate commands
    from queries. Our repository is good enough to persist new aggregates and perform
    updates on existing aggregates when we execute commands. This means that our command
    side is fine. Now, we need to implement the query side, and we'll do it in a different
    way, without using repositories.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这本书中，我们将应用CQRS原则，并将命令与查询分开。我们的存储库足够好，当我们执行命令时，可以持久化新的聚合并对现有聚合进行更新。这意味着我们的命令侧是好的。现在，我们需要实现查询侧，我们将以不同的方式来实现，而不使用存储库。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: The read side of CQRS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS的读取侧
- en: What are the read models?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是读取模型？
- en: Using Ubiquitous Language for queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用语言进行查询
- en: Implementing CQRS with one database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个数据库实现CQRS
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the `Chapter09` folder of the book
    repository on GitHub. There are two subfolders there, `ravendb` and `ef-core`,
    containing the final code that implements the aggregate persistence and queries
    using the RavenDB document database, Entity Framework Core, and PostgreSQL. As
    a starting point, we'll be using the final code from [Chapter 8](4eea9289-d77e-4568-a9c0-c5e1265e3b4e.xhtml),
    *Aggregate Persistence*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上书籍存储库的`Chapter09`文件夹中找到。那里有两个子文件夹，`ravendb`和`ef-core`，包含使用RavenDB文档数据库、Entity
    Framework Core和PostgreSQL实现聚合持久化和查询的最终代码。作为一个起点，我们将使用来自[第8章](4eea9289-d77e-4568-a9c0-c5e1265e3b4e.xhtml)，*聚合持久化*的最终代码。
- en: You will need to use `docker-compose` to run the infrastructure. Check the requirements
    for the previous chapter if you have not completed the installation previously.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用`docker-compose`来运行基础设施。如果您之前没有完成安装，请检查上一章的要求。
- en: Adding user profiles
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户资料
- en: Before we start our journey to the read side of our application, we would benefit
    from adding some more concerns to the domain itself. So far, we have been concentrating
    on the core domain of classified ads. The core domain is what we should focus
    on when we create a new system. In our scenario so far, we have already made some
    progress implementing the core domain, and the team is now discussing what would
    be an absolute *must-have* to add to the system before they start creating the
    prototypes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索应用程序的读取方面之前，我们最好在领域本身中添加一些更多的关注点。到目前为止，我们一直专注于分类广告的核心领域。当我们创建一个新系统时，我们应该专注于核心领域。在我们的场景中，我们已经实施了一些核心领域的进展，现在团队正在讨论在开始创建原型之前，系统必须添加的绝对**必须具备**的功能。
- en: You might remember that we have already partially addressed the concern of who
    owns the ad. We have the `OwnerId` property of the `UserId` type in the `ClassifiedAd`
    aggregate, but so far we haven't got the location where `OwnerId` comes from.
    Apparently, our system needs to have users that must register themselves before
    creating new ads. We need to know who they are and how to get in touch with them.
    So, as the bare minimum, we need to have their name and contact information, such
    as an email address and phone number. Most of the time, people don't like to show
    their real names in classified ads and prefer using nicknames instead, something
    that we call a **display name**. We must address this concern too.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，我们已经在部分解决了广告所有权的关注点。我们在`ClassifiedAd`聚合中已经有了`UserId`类型的`OwnerId`属性，但到目前为止，我们还没有找到`OwnerId`的来源。显然，我们的系统需要用户在创建新广告之前必须注册自己。我们需要知道他们是谁以及如何与他们取得联系。因此，作为最低限度的要求，我们需要有他们的姓名和联系方式，例如电子邮件地址和电话号码。大多数时候，人们不喜欢在分类广告中展示他们的真实姓名，而更喜欢使用昵称，我们称之为**显示名**。我们也必须解决这个问题。
- en: After a short discussion on the EventStorming board, the team came up with something
    very basic to support these requirements. We don't care about the user registration
    process for the whole store; that is a complex topic by itself. It could potentially
    involve social media login, email and phone number confirmations, password requirements,
    and two-phase authentication. It is never a good idea to start implementing those
    features when you are building a new system. Oftentimes, developers fall into
    the **user registration** trap and spend weeks and months polishing the registration/login
    screen experience without any work being done on the core domain. Remember that
    the authentication domain is a generic supportive subdomain, and in most cases,
    it can be very useful to consider using a third-party system to handle these concerns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在EventStorming板上简短讨论后，团队提出了一个非常基本的方案来支持这些需求。我们不在乎整个商店的用户注册过程；这本身就是一个复杂的话题。它可能涉及社交媒体登录、电子邮件和电话号码确认、密码要求以及双因素认证。在你构建新系统时开始实现这些功能从来都不是一个好主意。很多时候，开发者会陷入**用户注册**的陷阱，花费数周甚至数月来完善注册/登录屏幕体验，而核心领域的工作却没有任何进展。记住，身份验证领域是一个通用的支持子领域，在大多数情况下，考虑使用第三方系统来处理这些关注点是非常有用的。
- en: Right now, all we need to do is to implement some basic functionality that will
    allow us to show the user information alongside the classified ad itself, both
    when we show a single ad on a page or a list of ads.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要实现一些基本功能，这样我们就可以在显示单个广告或广告列表时，同时显示用户信息。
- en: 'The following diagram shows what the team generated after a quick modeling
    session:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了团队在快速建模会议后生成的内容：
- en: '![](img/911c5dc5-dc7f-4fbb-b99a-55fb83f51e12.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/911c5dc5-dc7f-4fbb-b99a-55fb83f51e12.png)'
- en: We can easily see that there is very little connection between the users and
    classified ads. In fact, we only need to have the user ID so that we can use it
    as the owner ID. Bearing that in mind, we can try implementing `UserProfile` as
    a new aggregate in our domain project. I'd urge you not to call this object `User`
    since it implies that the same object is used for authentication, and must, therefore,
    contain things such as password and social media login information. But we've
    already decided to keep it aside and resolve it later.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地看出用户和分类广告之间几乎没有联系。事实上，我们只需要用户ID，就可以用它作为所有者ID。考虑到这一点，我们可以在我们的领域项目中尝试实现`UserProfile`作为一个新的聚合。我强烈建议你不要把这个对象称为`User`，因为它暗示了同一个对象用于身份验证，因此必须包含诸如密码和社交媒体登录信息之类的信息。但我们已经决定将其搁置，稍后解决。
- en: User profile domain concerns
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户资料领域关注点
- en: First things first. The only thing we know for sure right now is that we have
    four different events to implement. We also know that we are adding a new aggregate
    to the same domain project that we already have. Since our aggregate will have
    a state, we'll probably need to create new value objects too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们目前确定的是，我们有四个不同的事件要实现。我们还知道，我们正在向已经存在的相同领域项目中添加一个新的聚合。由于我们的聚合将有一个状态，我们可能还需要创建新的值对象。
- en: Before adding new objects to the project, it would be a good idea to organize
    the project so that we get better visibility of its parts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在向项目中添加新对象之前，组织项目以便我们更好地了解其各个部分是一个好主意。
- en: Domain project organization
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域项目组织
- en: 'We start by creating a new project folder called `ClassifiedAd` and moving
    existing relevant files over there. After that, we need to fix the namespace for
    all the files that we moved. The automatic refactoring feature of the IDE makes
    it quite easy. With ReSharper or Rider, you can just press *Alt* + *Enter* on
    the namespace name in the class and tell it to adjust the namespace accordingly.
    Then, we add a new folder for the `UserProfile` objects. It also makes sense to
    move all shared domain concerns, such as the `Exception` class, the `Money` class,
    and others, to the `Shared` folder. Now, the project structure changes to this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的项目文件夹，命名为 `ClassifiedAd`，并将现有的相关文件移动到那里。之后，我们需要为所有移动的文件修复命名空间。IDE的自动重构功能使得这个过程相当简单。使用ReSharper或Rider，你只需在类的命名空间名称上按
    *Alt* + *Enter*，然后告诉它相应地调整命名空间。然后，我们为 `UserProfile` 对象添加一个新的文件夹。将所有共享领域关注点，例如
    `Exception` 类、`Money` 类等，移动到 `Shared` 文件夹也是有意义的。现在，项目结构变为如下：
- en: '![](img/de78c917-f0ce-4c8b-9924-03d0cab337e3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de78c917-f0ce-4c8b-9924-03d0cab337e3.png)'
- en: 'Now we can start implementing those four new events. Let''s add a new `Events`
    class to the `UserProfile` folder and write some code for those events, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始实现这四个新事件。让我们在 `UserProfile` 文件夹中添加一个新的 `Events` 类，并为这些事件编写一些代码，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We consciously keep other things, such as email addresses and telephone numbers,
    out of the version, since we don't need that information for anything that our
    application needs right now, but nothing will stop us from adding more events
    and more details to the domain model in the future.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有意识地将其他东西，如电子邮件地址和电话号码，排除在版本之外，因为我们现在不需要这些信息来满足应用程序的需求，但未来我们添加更多事件和更多细节到领域模型不会有任何阻碍。
- en: Adding new value objects
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的值对象
- en: For the next step, we add a new small aggregate called `UserProfile` to execute
    commands that will emit these events and perform the state transition for the
    aggregate. For the aggregate state, it is a good idea to implement value objects
    for the `DisplayName` and `FullName` state properties, so we will start with that.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一步，我们添加一个新的小聚合 `UserProfile` 来执行将产生这些事件并执行聚合状态转换的命令。对于聚合状态，为 `DisplayName`
    和 `FullName` 状态属性实现值对象是一个好主意，所以我们从这里开始。
- en: 'The `FullName` class is rather trivial, and mostly repeats the code for the
    `ClassifiedAdTitle` class, as shown in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`FullName` 类相当简单，大部分代码与 `ClassifiedAdTitle` 类重复，如下所示：'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I have added a small static class to hold extension methods for the `string`
    class, and currently, there is only one method there, called `IsEmpty`, which
    I use instead of `string.IsNullOrWhitespace`, so you can see that it is being
    used in the code for the `value` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个小的静态类来持有 `string` 类的扩展方法，目前那里只有一个方法，名为 `IsEmpty`，我用它来代替 `string.IsNullOrWhitespace`，所以你可以在值对象的代码中看到它的使用。
- en: Then we can implement the `DisplayName` class. It is not as straightforward,
    because, unlike the full name, the display name will be shown on public pages.
    We can definitely expect some malicious users to write things that we don't want
    to show on our website. While our ads will go through a review stage before getting
    published, user profiles will not be moderated. Normally, a user profile is shown
    in different places, such as discussions, review systems, and so on. Although
    we haven't started modeling these features just yet, we know our roadmap and the
    fact that we need to prevent users from putting malicious content in their public
    profiles.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以实现`DisplayName`类。这并不像全名那样直接，因为，与全名不同，显示名将在公共页面上显示。我们肯定可以预期一些恶意用户会写一些我们不希望在网站上显示的内容。虽然我们的广告在发布前会经过审查阶段，但用户资料将不会进行审核。通常，用户资料会在不同的地方显示，例如讨论区、评论系统等。尽管我们还没有开始建模这些功能，但我们知道我们的路线图以及我们需要防止用户在他们的公共资料中放置恶意内容的事实。
- en: 'One easy thing we can do is to automatically check whether the display name
    contains obscene words. There are openly accessible services out there that can
    help us. The implementation details won''t be a part of the `Domain` project,
    since it is an infrastructural concern. Instead, we will create some abstractions
    for such a service so that we can check the text for profanity without coupling
    with the implementation. We already used a similar technique using the currency
    lookup domain service. Domain services, however, don''t necessarily need to be
    implemented as interfaces. Another way of making a one-method domain service is
    by using delegates. The following code shows the profanity check domain service,
    which is declared as a delegate:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的事情之一是自动检查显示名是否包含粗俗词汇。有一些公开可用的服务可以帮助我们。实现细节不会成为`Domain`项目的一部分，因为它是一个基础设施关注点。相反，我们将为这样的服务创建一些抽象，这样我们就可以在不与实现耦合的情况下检查文本中的粗俗词汇。我们已经使用了一个类似的技术，即货币查找领域服务。然而，领域服务不一定需要实现为接口。另一种创建单方法领域服务的方式是使用委托。下面的代码显示了粗俗词汇检查领域服务，该服务被声明为一个委托：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I put the code in the `Shared/ContentModeration.cs` file. Now we need to implement
    the `DisplayName` value object and make use of the new domain service, as shown
    in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我将代码放在了`Shared/ContentModeration.cs`文件中。现在我们需要实现`DisplayName`值对象并利用新的领域服务，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, you can see that the code will throw an exception of the `ProfanityFound` type if
    the delegate returns `true`, which would mean that the user is using bad language
    in the display name. I have moved all domain exceptions to one place in the `Shared`
    folder. The new code is located in the `DomainExceptions.cs` file and the code
    for this file is shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到，如果委托返回`true`，代码将抛出`ProfanityFound`类型的异常，这意味着用户在显示名中使用了不良语言。我已经将所有领域异常移动到`Shared`文件夹中的一个地方。新代码位于`DomainExceptions.cs`文件中，该文件的代码如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will be adding more exceptions to this file when necessary.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，我们将向此文件添加更多异常。
- en: User profile aggregate root
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户配置文件聚合根
- en: 'It is now time to write the code for the `UserProfile` aggregate. We have built
    one aggregate before, so creating a new one will not be a big issue, especially
    considering that the user profile is a relatively simple object. The following
    is the code for the new `UserProfile.cs` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写`UserProfile`聚合的代码了。我们之前已经创建了一个聚合，所以创建一个新的聚合不会是一个大问题，尤其是考虑到用户资料是一个相对简单的对象。以下是新`UserProfile.cs`文件的代码：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code does nothing new compared to the `ClassifiedAd` aggregate
    root class code. We also use the same workaround to satisfy the database requirements
    for the identity property. Since we start with a RavenDB implementation, we need
    a string property to hold the document's identity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ClassifiedAd`聚合根类的代码相比，前面的代码没有做任何新的工作。我们也使用了相同的解决方案来满足对身份属性的数据库要求。由于我们从RavenDB实现开始，我们需要一个字符串属性来保存文档的身份。
- en: As you can see, I used the `UserId` value object for the aggregate root ID.
    That's because, essentially, the profile identity must be the ID of the user.
    It required me to change the implementation of the `UserId` class by inheriting
    it from the `Value<UserId>` base class for value objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我使用了`UserId`值对象作为聚合根ID。这是因为，本质上，配置文件身份必须是对应用户的ID。这要求我通过从值对象的基础类`Value<UserId>`继承来更改`UserId`类的实现。
- en: 'Finally, we need a repository interface so that our application service will
    know how to retrieve and persist the new entity. The interface is identical to
    the one we made for the `ClassifiedAd` entity, as you can see from the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个存储库接口，以便我们的应用程序服务知道如何检索和持久化新实体。该接口与我们为 `ClassifiedAd` 实体创建的接口相同，正如以下代码所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we are done with the changes in our domain project. Let's continue by adding
    the user profile application service and the command API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了域项目中更改。让我们继续添加用户资料应用程序服务和命令 API。
- en: Application side for the user profile
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户资料的应用程序端
- en: It is time to look at our application project and check what we need to do to
    support the user profile feature. Before we start adding new classes, let's perform
    a similar project restructuring, making different core features differ visually
    in **Solution Explorer**. I don't want the application project to be structured
    according to infrastructure concerns either, but the current organization of the
    project implies just that, since we use the `Api`, `Contracts`, and `Infrastructure`
    folders. To do this, I have moved the `ClassifiedAd` concerns to a separate folder
    in the `Marketplace` project and created a new folder called `UserProfile`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候查看我们的应用程序项目并检查我们需要做什么来支持用户资料功能了。在我们开始添加新类之前，让我们执行类似的项目重构，使不同的核心功能在 **解决方案资源管理器**
    中具有不同的视觉表现。我不想让应用程序项目根据基础设施关注点进行组织，但当前的项目组织方式暗示了这一点，因为我们使用了 `Api`、`Contracts`
    和 `Infrastructure` 文件夹。为此，我已经将 `ClassifiedAd` 关注点移动到 `Marketplace` 项目中的一个单独文件夹，并创建了一个名为
    `UserProfile` 的新文件夹。
- en: 'The project now looks different in the solution explorer, as you can see in
    the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在在解决方案资源管理器中看起来不同，如下面的截图所示：
- en: '![](img/ade9a27b-013b-406b-8d49-fc2c672170a0.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ade9a27b-013b-406b-8d49-fc2c672170a0.png)'
- en: 'Now we have a place to add everything we need to support the new domain functionality.
    We start by adding commands to a new `UserProfile/Contracts.cs` file. We can understand
    what commands are needed by looking at the events since all those events, are
    user-driven. Look at the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个地方可以添加所有支持新域功能所需的内容。我们首先向新的 `UserProfile/Contracts.cs` 文件中添加命令。我们可以通过查看事件来了解需要哪些命令，因为所有这些事件都是用户驱动的。看看以下代码：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By now, you might have noticed there is a mismatch between the name of the `ProfilePhotoUploaded` event, and
    our `UpdateUserProfilePhoto` command.  We must keep the semantics clear as our
    application service will not handle the upload itself. Instead, it will receive
    a URL to a file that has already been uploaded. That is usually the case if we
    have a sophisticated UI that is able to perform file upload and additional operations,
    such as resizing and cropping in the browser. Alternatively, we can let the Web
    API controller deal with uploads. So, in fact, our command needs to represent
    what will happen in the domain—it will update the photograph URL rather than uploading
    the photograph itself. However, if you decide that your user profile application
    service needs to handle the upload too, the command name (and the corresponding
    event name) needs to be changed to reflect the nature of the action.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经注意到 `ProfilePhotoUploaded` 事件名称与我们的 `UpdateUserProfilePhoto` 命令之间存在不匹配。我们必须保持语义清晰，因为我们的应用程序服务不会自己处理上传。相反，它将接收一个指向已上传文件的
    URL。这通常发生在我们有一个复杂的用户界面，能够在浏览器中执行文件上传以及额外的操作，如调整大小和裁剪的情况下。或者，我们可以让 Web API 控制器处理上传。因此，实际上，我们的命令需要表示域中将要发生的事情——它将更新照片
    URL 而不是上传照片本身。然而，如果你决定你的用户资料应用程序服务也需要处理上传，命令名称（以及相应的事件名称）需要更改以反映动作的性质。
- en: 'Let''s start writing the new application service. This work is rather trivial
    if we use the `ClassifiedAdApplicationService` class as an example. I have ended
    up with the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写新的应用程序服务。如果我们以 `ClassifiedAdApplicationService` 类为例，这项工作相当简单。我最终得到了以下代码：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this class, I have one dependency—`IUserProfileRepository`. You might already
    suspect that the repository implementation for the `UserProfile` entity would
    be almost the same as for `ClassifiedAd`, except that it will operate with another
    class type. You might think that you can use a generic repository. But we have
    already touched upon this topic, and you can either revisit it or read some articles
    on the internet that will invariably discourage you from using generic repositories;
    however, we can still either use the generic type as a dependency for our specific
    repository or we can inherit specific repositories from a generic one. Let''s
    try the latter option and see what it looks like. I will add a new class to the
    `Infrastructure` folder for the application project, called `RavenDbRepository`,
    as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我有一个依赖项——`IUserProfileRepository`。你可能已经猜到，`UserProfile` 实体的存储库实现几乎与 `ClassifiedAd`
    相同，只是它将使用另一个类类型。你可能认为你可以使用一个通用存储库。但是，我们已经触及了这个话题，你可以重新审视它，或者阅读一些互联网上的文章，这些文章肯定会劝阻你使用通用存储库；然而，我们仍然可以使用通用类型作为我们特定存储库的依赖项，或者我们可以从一个通用存储库继承特定的存储库。让我们尝试后者，看看它是什么样子。我将为应用程序项目在
    `Infrastructure` 文件夹中添加一个新的类，名为 `RavenDbRepository`，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We still want to use specific repository interfaces and classes, but now we
    can implement `UserProfileRepository` (the file that needs to be added to the
    `UserProfile` folder of the `Marketplace` project) using the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然想使用特定的存储库接口和类，但现在我们可以使用以下代码实现 `UserProfileRepository`（需要添加到 `Marketplace`
    项目的 `UserProfile` 文件夹中的文件）：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The same can be done to implement `ClassifiedAdRepository`, although the unchanged
    version will work as before. The final code for this chapter includes the simplified
    code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以用来实现 `ClassifiedAdRepository`，尽管未更改的版本将像以前一样工作。本章的最终代码包括简化后的代码。
- en: 'It is time to implement the API controller class. If you look at the `ClassifiedAdsCommandApi`
    class, you can see that we have a private method called `HandleRequest` that helps
    us to simplify the request handling by calling the application service using one
    line of code. The code for the new controller will be almost identical, so we
    can reuse the request handler by creating a new static class in the `Infrastructure`
    folder called `RequestHandler` with the following simple code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现 API 控制器类了。如果你看看 `ClassifiedAdsCommandApi` 类，你可以看到一个名为 `HandleRequest`
    的私有方法，它通过一行代码调用应用程序服务来帮助我们简化请求处理。新控制器的代码几乎相同，因此我们可以通过在 `Infrastructure` 文件夹中创建一个新的静态类
    `RequestHandler` 来重用请求处理器，如下面的简单代码所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This generic method can now be used in both controllers. Let''s look at what
    the new controller would look like. I created a new `UserProfileCommandApi` class in
    the `UserProfile` folder of the application project, as shown in the following
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用方法现在可以在两个控制器中使用。让我们看看新的控制器会是什么样子。我在应用程序项目的 `UserProfile` 文件夹中创建了一个新的 `UserProfileCommandApi`
    类，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The classified ad controller can use `RequestHandler` in a similar fashion;
    the new implementation can be found in the chapter code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 广告控制器可以用类似的方式使用 `RequestHandler`；新的实现可以在章节代码中找到。
- en: We are almost done with all the changes, but one thing is still missing, and
    that is an implementation for the profanity check function. I will use PurgoMalum,
    a free web service to filter content and remove profanity, obscenity, and other
    things that we don't want to see on our public website.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了所有的更改，但还有一件事仍然缺失，那就是对粗俗检查函数的实现。我将使用 PurgoMalum，一个免费的在线服务来过滤内容并移除粗俗、下流和其他我们不希望在我们公共网站上看到的内容。
- en: 'The implementation is very simple, since all I need to do is call an HTTP endpoint
    with one argument. For that, I add one more class to the `Infrastructure` folder,
    called `PurgomalumClient`, as shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简单，因为我需要做的只是调用一个带有单个参数的 HTTP 端点。为此，我在 `Infrastructure` 文件夹中添加了一个名为 `PurgomalumClient`
    的类，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the final step, we need to do the wiring in the `Startup` class code. The
    only method we need to change is the `ConfigureServices` method. Here is the new
    code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一步，我们需要在 `Startup` 类代码中进行配置。我们需要更改的唯一方法是 `ConfigureServices` 方法。以下是新的代码：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The registration of `UserProfileApplicationService` is a bit more complicated
    than `ClassifiedAdApplicationService`, since we are using a function, not an interface.
    In general, it is easier and cleaner to use delegates instead of interfaces with
    one method, but you'll need to deal with a bit more code when wiring things up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserProfileApplicationService` 的注册比 `ClassifiedAdApplicationService` 要复杂一些，因为我们使用的是函数而不是接口。一般来说，使用代表一个方法的委托而不是接口会更简单、更干净，但在连接东西时你可能需要处理更多的代码。'
- en: Finally, you can run the app and try creating a new user profile, then change
    the full name or display name for the user. Try using some bad words for the display
    name to see the `ProfanityFound` exception in action. Remember to call `docker-compose
    up` from the `Chapter09/ravendb` folder of the chapter code repository before
    starting the app; otherwise, you won't have access to RavenDB.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以运行应用程序并尝试创建一个新的用户资料，然后更改用户的完整名称或显示名称。尝试使用一些不雅的词作为显示名称，以查看 `ProfanityFound`
    异常的实际效果。记住，在启动应用程序之前，请从章节代码存储库的 `Chapter09/ravendb` 文件夹中调用 `docker-compose up`；否则，你将无法访问
    RavenDB。
- en: And now that all these new things are in place and we have two nice aggregates
    in our system instead of just one, we can look at the query side of things.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些新事物都已经到位，我们系统中有了两个很好的聚合体，而不是只有一个，我们可以看看查询方面的事情。
- en: The query side
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询方面
- en: 'So far, we have focused on state transitions in the system that are represented
    as events. When our domain model emits a new event, by definition, it means that
    we have put the system in a new state. State transitions are triggered by commands—that''s
    why we have two APIs that are purposefully named `ClassifiedAdCommandApi` and
    `UserProfileCommandApi`. That shouldn''t come as a surprise, since I have mentioned
    CQS and CQRS several times before in this book. Commands trigger methods of the
    aggregates, and following the CQS principle, none of those methods return anything,
    but instead change the system state. But no system can have only commands. Our
    users want to see something on the screen and it can''t just be static texts and
    pictures. For our marketplace, the main purpose of the application is not that
    people can place classified ads in it; quite the opposite: we expect people to
    browse these ads, choose what they like, and make deals. This means that our system
    needs to deliver the information it possesses to the outside world so that it
    can be shown on the screen. Right at this moment, we can only see classified ads
    and user profiles that are stored in the database by looking at the database itself.
    Logically, what we need to do now is make this information available via some
    APIs.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注系统中表示为事件的州转换。当我们的领域模型发出一个新事件时，根据定义，这意味着我们已经将系统置于一个新的状态。状态转换是由命令触发的——这就是为什么我们有两个故意命名为
    `ClassifiedAdCommandApi` 和 `UserProfileCommandApi` 的 API。这并不令人惊讶，因为我在这本书中已经多次提到了
    CQS 和 CQRS。命令触发聚合的方法，根据 CQS 原则，这些方法中没有任何一个返回任何内容，而是改变系统状态。但没有任何系统只能有命令。我们的用户希望在屏幕上看到一些东西，而不仅仅是静态文本和图片。对于我们这个市场，应用程序的主要目的并不是让人们可以在其中发布分类广告；恰恰相反：我们期望人们浏览这些广告，选择他们喜欢的，并达成交易。这意味着我们的系统需要将其拥有的信息传递给外部世界，以便可以在屏幕上显示。就在这个时候，我们只能通过查看数据库本身来看到存储在数据库中的分类广告和用户资料。从逻辑上讲，我们现在需要通过一些
    API 使这些信息可用。
- en: CQRS and read-to-write mismatch
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS 和读-写不匹配
- en: If you've studied other books about **Domain-Driven Design** (**DDD**) and done some
    work using DDD tactical patterns, including aggregate and repository, you might
    be wondering why I have not just included a couple of query methods in `ClassifiedAdRepository`
    and called it a day. Of course, I could have done that, but then I wouldn't have
    even started to write this book if I didn't have something else to discuss.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经研究过其他关于 **领域驱动设计**（**DDD**）的书籍，并且使用过 DDD 战术模式进行了一些工作，包括聚合和仓储，你可能想知道为什么我没有在
    `ClassifiedAdRepository` 中简单地包含几个查询方法，然后就此结束。当然，我可以那样做，但如果没有其他东西可以讨论，我就不会开始写这本书。
- en: The point of repositories is that they are always dealing with aggregate state.
    As you might remember from the quote by Eric Evans in [Chapter 8](4eea9289-d77e-4568-a9c0-c5e1265e3b4e.xhtml), *Aggregate
    Persistence*, the role of a repository is to represent aggregates that exist in
    the system in a way that looks like an in-memory collection of objects, hence
    the name of our two repositories so far—`ClassifiedAdRepository` and `UserProfileRepository`.
    This implies that the only details we can ever get from the repository are things
    that we have added to it. Since one repository handles the state of one aggregate—`ClassifiedAd`,
    for example—we can only query and retrieve classified ad details from the repository
    and nothing else. The issue here is that having only one aggregate in a bounded
    context (more about this in [Chapter 12](01e2a3de-465b-48aa-b297-e75269799cbb.xhtml),
    *Bounded Context*) is a rare occurrence, and we are already dealing with two.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的核心在于它们始终在处理聚合状态。正如你可能从[第8章](4eea9289-d77e-4568-a9c0-c5e1265e3b4e.xhtml)中埃里克·埃文斯的引言中记得的，“聚合持久性”，仓库的作用是以内存中对象集合的方式表示系统中存在的聚合，因此我们迄今为止的两个仓库的名称——`ClassifiedAdRepository`和`UserProfileRepository`。这意味着我们能从仓库中获取的唯一细节就是我们添加到其中的内容。由于一个仓库处理一个聚合的状态——例如`ClassifiedAd`——我们只能从仓库中查询和检索分类广告的详细信息，而无法获取其他信息。这里的问题是，在有限上下文中只有一个聚合（更多关于这一点在[第12章](01e2a3de-465b-48aa-b297-e75269799cbb.xhtml)，“有限上下文”）是一种罕见的情况，而我们已经在处理两个了。
- en: The information that we need to show is currently not represented on the EventStorming
    model. Again, that's because our big-picture model is more interested in how the
    system behaves, and what we show on the screen is not considered as behavior.
    However, as I just mentioned, that's still our core business, and we could think
    of something very obvious. If we go live and someone places an ad, they need to
    see how the ad appears to other users. The same screen is also needed when another
    user looks for something to buy and wants to check all the details—the ad title,
    description, and all available pictures, as well as the seller's information.
    Even if we haven't thought of the buying process just yet, that's the bare minimum
    that we definitely need. Also, people want to see all published ads. When the
    system gets more users and more ads are being published, we might consider showing
    ads per category. But when we are in the initial phase, showing all the ads with
    some search possibilities might be just fine.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要展示的信息目前还没有在EventStorming模型中表示出来。同样，这是因为我们的整体模型更关注系统的行为，而我们展示在屏幕上的内容并不被视为行为。然而，正如我刚才提到的，这仍然是我们的核心业务，我们可以考虑一些非常明显的事情。如果我们上线并且有人发布广告，他们需要看到广告对其他用户看起来如何。当另一个用户寻找要购买的东西并想查看所有详细信息——广告标题、描述以及所有可用的图片，以及卖家的信息时，也需要相同的屏幕。即使我们还没有考虑购买过程，这也是我们绝对需要的最基本的东西。此外，人们希望看到所有发布的广告。当系统拥有更多用户并且有更多广告被发布时，我们可能会考虑按类别展示广告。但在初始阶段，展示所有广告并提供一些搜索功能可能就足够了。
- en: All those screens that I have described are read models. These models might
    represent the state of a single aggregate, but in many cases, or in most cases,
    the information from several aggregates might be combined on one screen. For example,
    the screen for a single ad needs to have the information from both aggregate types
    that we currently have in the system. The screen that shows a list of published
    ads needs to display short versions of multiple aggregates, although just of a
    single type. While the latter case might be solved by adding a query method to
    the `IClassifiedAdRepository` interface, the first case would require something
    else. Oftentimes, when we have queries as part of repositories, we need to have
    some aggregation on the client side. Yet, returning a list of large object graphs
    (which is what repositories are supposed to do) too often is a far from optimal
    solution when we just need to show a couple of properties from each aggregate.
    Even worse, we might find ourselves in a situation when the object graph is too
    large and we start using those awkward ORM features of lazy loading that might
    work well in tests, but fail in the stateless world of the web simply because
    the session that we wanted to access in order to lazily load more data from is
    already gone by the time we try to ask it for more data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我所描述的所有屏幕都是读取模型。这些模型可能代表单个聚合的状态，但在许多情况下，或者大多数情况下，多个聚合的信息可能会在一个屏幕上组合。例如，单个广告的屏幕需要包含系统中当前拥有的两种聚合类型的信息。显示已发布广告列表的屏幕需要显示多个聚合的简短版本，尽管只是单一类型。虽然后一种情况可以通过向`IClassifiedAdRepository`接口添加查询方法来解决，但第一种情况则需要其他方法。很多时候，当我们有查询作为存储库的一部分时，我们通常需要在客户端进行一些聚合。然而，当我们只需要从每个聚合中显示几个属性时，返回大量对象图（存储库应该做的事情）往往远非最佳解决方案。更糟糕的是，我们可能会发现自己处于对象图太大而开始使用那些在测试中可能表现良好的尴尬的ORM延迟加载特性，但在无状态的Web世界中却失败，这仅仅是因为我们想要访问以延迟加载更多数据的会话在尝试请求更多数据时已经不存在了。
- en: All of these issues are effectively addressed by CQRS. The pattern postulates
    that there are almost no systems with an equal number of reads and writes. Most
    user-facing systems have a larger number of reads than writes. Think about the
    number of classified ads being created on Craigslist compared to the number of
    requests to retrieve and show them on someone's screen. The difference between
    them could be two orders of magnitude. Even so, most systems out there today struggle
    with scaling issues just because they ignore this simple fact. No database can
    be preoptimized for both reads and writes—you need to choose one. In the beginning,
    we all deal only with writes and try to optimize for them alone. RDBMS third-level
    normalization addresses exactly that—it shows the least amount of information
    that needs to be written to save space and avoid data duplication. When it comes
    to reads, though, third-level normalization doesn't work quite so well. We keep
    adding joins, one after another, to combine the information that we deliberately
    split when writing back together again. Soon, the number of reads overtakes the
    number of writes. Shortly after that, we see tens and hundreds of times more reads
    than writes, and this is where the trouble starts. There are, of course, other
    types of systems, such the world of the **internet of things** (**IoT**), high-frequency
    trading, and other business domains. In these cases, the amount of information
    that is being written to the database is by far greater than the amount of information
    that would ever need to be shown to anyone. Developers start to optimize for writes,
    decreasing the transaction time. This usually comes at the expense of removing
    indices and making the data flat. When it comes to reading, we start to see slow
    response times just because of this.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都有效地通过CQRS得到了解决。该模式假设几乎不存在读写数量相等的系统。大多数面向用户的面板系统读操作的数量要多于写操作。想想在Craigslist上创建的分类广告数量与请求在某人屏幕上检索和显示这些广告的数量相比。它们之间的差异可能是两个数量级。即便如此，今天大多数系统之所以会面临扩展问题，仅仅是因为它们忽略了这个简单的事实。没有数据库可以预先优化以同时处理读和写——你需要选择一个。最初，我们只处理写操作并试图仅针对它们进行优化。关系数据库管理系统（RDBMS）的第三级规范化正是针对这一点——它显示了需要写入的最少信息量，以节省空间并避免数据重复。然而，当涉及到读操作时，第三级规范化并不那么有效。我们不断地添加连接，一个接一个，以将我们在写入时故意分开的信息再次组合在一起。很快，读操作的数量就超过了写操作的数量。不久之后，我们看到读操作的数量比写操作多出十倍甚至百倍，这就是麻烦开始的地方。当然，还有其他类型的系统，比如物联网（**IoT**）的世界、高频交易以及其他商业领域。在这些情况下，写入数据库的信息量远远大于需要向任何人展示的信息量。开发者开始优化写操作，减少事务时间。这通常是以移除索引和使数据扁平化为代价的。当涉及到读操作时，我们开始看到响应时间变慢，仅仅是因为这个原因。
- en: In essence, I am trying to make the point that when a developer is trying to
    address the concerns of either writes or reads to make them more efficient on
    the command side, the query side begins to suffer. It's also true the other way
    around. That's why CQRS was born. In this chapter, we will only look at the query
    side of things when using a single database. That might sound like a contradiction
    given what you just read, because, again, a database can rarely be optimized for
    both. But we need to start somewhere, and since optimization is the source of
    all evil, we'll start slowly. We will look at splitting read and writes into different
    types of storage when we get to Event Sourcing and projections in particular in
    [Chapter 11](c4156d9d-9130-4225-b205-ef76cb4bcca3.xhtml), *Projections and Queries*.
    But for now, let's look at how we can perform more efficient reads from our existing
    storage without using repositories at all.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，我试图说明的是，当开发者试图解决写或读的担忧，以使它们在命令端更加高效时，查询端开始受到影响。反过来也是一样。这就是为什么CQRS应运而生。在本章中，我们将只关注使用单个数据库时的查询端。鉴于你刚刚读到的内容，这可能会听起来有些矛盾，因为，再次强调，数据库很少能同时优化。但我们需要从某个地方开始，既然优化是所有邪恶的根源，我们就慢慢来。当我们到达第11章，特别是“投影和查询”这一特定部分时，我们将探讨将读和写分离到不同类型的存储中。但现在，让我们看看我们如何能够从现有的存储中执行更有效的读操作，而完全不使用仓库。
- en: Queries and read models
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询和读模型
- en: 'When we were building our domain model, we needed to be careful taking dependencies
    so that the domain model stayed pure, free of any infrastructural concerns. Our
    goal was to provide a certain degree of freedom to implement the domain logic
    in a way that made sense from the point of view of the business, using Ubiquitous
    Language. We also defined repository interfaces as part of the domain model so
    that the application layer was able to implement these interfaces in order to
    enable aggregate persistence. Then, we defined commands as contracts that our
    application services could accept in order to perform operations on domain objects
    and potentially execute state transitions. Overall, the isolation and separation
    of concerns between the different parts of the command processing sequence are
    implemented according to the following diagram:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在构建领域模型时，我们需要小心地处理依赖关系，以确保领域模型保持纯净，不受任何基础设施问题的干扰。我们的目标是提供一定程度的自由度，以便从业务的角度出发，使用通用语言来实现领域逻辑。我们还定义了存储库接口作为领域模型的一部分，以便应用层能够实现这些接口，从而实现聚合持久化。然后，我们定义命令为我们的应用服务可以接受的合约，以便对领域对象执行操作并可能执行状态转换。总体而言，命令处理序列不同部分之间的隔离和关注点分离是根据以下图表实现的：
- en: '![](img/9944f9e2-5abb-4d20-ad70-6edf87d2129c.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9944f9e2-5abb-4d20-ad70-6edf87d2129c.png)'
- en: The typical command flow
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的命令流程
- en: When we need to query the data store where we put the state of our domain model
    using the repository, our goal changes. We don't need any business rules in queries;
    queries don't change the domain model state. But we definitely need to know how
    the repository implementation, which is implemented by our application, represents
    the state of our aggregate in the database. That makes queries a purely application-side
    concern. When we add an API to get something from our system, we need the API
    to only deal with persistence. The model that an API `GET` endpoint returns becomes
    our contract for the outside world. We don't need any other model either, such
    as the data model, to fetch the data; we can instead return what we got from the
    database directly as a response.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要使用存储库查询我们放置领域模型状态的数据库时，我们的目标发生了变化。查询中不需要任何业务规则；查询不会改变领域模型的状态。但我们确实需要知道我们的应用实现的存储库实现如何在数据库中表示我们的聚合状态。这使得查询成为纯粹的应用侧关注点。当我们添加一个API从我们的系统中获取某些内容时，我们需要API只处理持久化。API
    `GET` 端点返回的模型成为我们对外界的合约。我们不需要任何其他模型，例如数据模型，来获取数据；我们可以直接将我们从数据库中得到的结果作为响应返回。
- en: 'The flow for querying then becomes much simpler, and we can visualize it as
    shown in the following diagram:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的流程变得更为简单，我们可以将其可视化如下所示：
- en: '![](img/563565b7-ceb0-406a-88cd-1a01f2774277.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/563565b7-ceb0-406a-88cd-1a01f2774277.png)'
- en: The typical query flow
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的查询流程
- en: What we see being returned by the API is the read model. We need to make our
    queries in a way that the read model can be retrieved from the database without
    any translation between different models—we return it as is. This allows us to
    simplify the way in which we obtain the data and return it to those who either
    need to show it on the screen or need it for any other imaginable purpose. That
    is, essentially, the whole idea behind the read side of CQRS. It is now time to
    write some code and show how it works.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过API看到的返回结果是读取模型。我们需要以这种方式进行查询，以便可以从数据库中检索读取模型，而无需在不同模型之间进行任何转换——我们直接返回它。这使我们能够简化获取数据并将其返回给那些需要在屏幕上显示或用于任何其他可想象目的的人的方式。这就是CQRS读取侧背后的整个想法。现在，是时候编写一些代码并展示它是如何工作的了。
- en: Implementing queries
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现查询
- en: When implementing the read side, we don't need to touch anything in the domain
    model. We will concentrate our efforts on the application side. However, this
    doesn't mean that we need to forget about Ubiquitous Language. In the end, read
    models are part of the whole model anyway; we saw them during the EventStorming
    sessions as green sticky notes. Read models help people and other systems make
    decisions, based on the data they receive by executing our queries. Just as commands
    indicate the intent of external parties to run some operations on our domain,
    read models and queries express their intent to get something in return.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现读取侧时，我们不需要触及领域模型中的任何内容。我们将集中精力在应用程序侧。然而，这并不意味着我们需要忘记通用语言。最终，读取模型是整个模型的一部分；我们在
    EventStorming 会话中看到了它们，作为绿色的便利贴。读取模型帮助人们和其他系统根据他们通过执行我们的查询接收到的数据做出决策。正如命令表明外部各方意图在我们的领域上运行某些操作一样，读取模型和查询表达了他们获取某些东西的意图。
- en: For example, for our `Marketplace` application, we would expect shoppers to
    browse through published ads. Ad owners need to see a list of their ads. Everyone
    needs to be able to open a single ad and see everything in it that is public,
    plus the owner's public details, such as their photo and display name. These are
    obvious queries and read models that we can start implementing. We already have
    all the data in the form of the state of multiple aggregates, and we just need
    to get it from the database in a form that is usable for those purposes I've listed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们的 `Marketplace` 应用程序，我们期望购物者浏览已发布的广告。广告所有者需要查看他们广告的列表。每个人都应该能够打开单个广告并查看其中所有公开的内容，以及所有者的公开详细信息，例如他们的照片和显示名称。这些都是显而易见的查询和读取模型，我们可以开始实施。我们已经有所有数据，以多个聚合的状态形式存在，我们只需要从数据库中以可用的形式获取这些数据。
- en: Query API
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询API
- en: We can start implementing queries by specifying read models and the API. We
    already have folders in our `Marketplace` project for different application features.
    It might seem logical to add queries there as well, until we remember that some
    read models combine data from different aggregates, such as classified ad details
    and the owner's profile information. Where do we place that kind of model and
    query? Well, there are some options, but I'd try to concentrate on the essence
    of the requested information. If we need to see a single ad, that's what we want
    to look at, mainly. Although we might also provide some owner details, the owner
    details are not the main things that we want to show. In the end, we query one
    single ad by its ID, and the user's profile information is derived from the ad
    details, such as the owner ID, so we can still quite clearly identify where to
    place those queries.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定读取模型和API来开始实施查询。在我们的 `Marketplace` 项目中，我们已经为不同的应用程序功能创建了文件夹。在那里添加查询似乎合乎逻辑，直到我们想起一些读取模型会结合来自不同聚合的数据，例如分类广告的详细信息以及所有者的个人资料信息。这种类型的模型和查询应该放在哪里呢？好吧，有一些选择，但我倾向于专注于所需信息的本质。如果我们需要查看单个广告，那就是我们主要想看的内容。尽管我们可能也会提供一些所有者详情，但所有者详情并不是我们想要展示的主要内容。最终，我们通过广告ID查询单个广告，用户的个人资料信息是从广告详情中派生出来的，例如所有者ID，因此我们仍然可以相当清楚地确定放置这些查询的位置。
- en: Since we have found several things that we want to return via the API, and all
    of those things are related to ads, we put the stuff there. Now we need to add
    two files to the `ClassifiedAd` folder of the `Marketplace` project—one is `ReadModels.cs`
    and the other one is `ClassifiedAdsQueryApi.cs`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经发现了一些我们想要通过API返回的东西，而且所有这些都与广告相关，所以我们把它们放在那里。现在我们需要向 `Marketplace` 项目的
    `ClassifiedAd` 文件夹中添加两个文件——一个是 `ReadModels.cs`，另一个是 `ClassifiedAdsQueryApi.cs`。
- en: 'Based on the query requirements, let''s define the read models first using
    the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据查询要求，让我们首先使用以下代码定义读取模型：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One way of implementing queries is to create a query service interface that
    will be used by the API. Then, we wire it to the database-specific implementation
    during startup. For our purposes, it could look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实施查询的一种方式是创建一个查询服务接口，该接口将被API使用。然后，在启动时将其连接到特定于数据库的实现。就我们的目的而言，它可能看起来像这样：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach has one disadvantage—all parameters are separated, and when we
    implement the API, we need to add all those parameters to the API method. If you
    decide to use something else for your edges, such as ServiceStack or a messaging
    framework, you will have to use typed requests and then expand the request properties
    to the query service method parameters. Should you need to change the parameters
    for some reason, you'd need to change the code in multiple places. This could
    also affect the UI. For example, if you use a **single-page application** (**SPA**) and
    the API is being called from the frontend JavaScript code, you'd probably abstract
    the API call in some kind of service that will need to change to add new parameters
    to the call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个缺点——所有参数都是分开的，当我们实现API时，我们需要将这些参数全部添加到API方法中。如果你决定为你的边缘使用其他东西，比如ServiceStack或消息框架，你将不得不使用类型化请求，然后扩展请求属性到查询服务方法参数。如果你需要出于某种原因更改参数，你将需要更改多个地方中的代码。这也可能影响UI。例如，如果你使用一个**单页应用**（SPA）并且API是从前端JavaScript代码中调用的，你可能需要在某种服务中抽象API调用，该服务需要更改以添加新的参数到调用中。
- en: 'The ServiceStack framework advocates a message-driven approach for the HTTP
    API for a reason. It makes the request typed and removes the need to have a long
    list of parameters for the API methods and all layers that communicate with the
    API. So, further on in the code, we''ll use typed requests too, and therefore,
    typed queries. If we wanted to implement the query service with typed requests,
    it would look like this instead:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceStack框架之所以提倡为HTTP API使用消息驱动的方法，是有原因的。它使请求类型化，并消除了API方法和所有与API通信的层的长参数列表的需求。因此，在代码的后续部分，我们也将使用类型化请求，因此也将使用类型化查询。如果我们想使用类型化请求来实现查询服务，它将看起来像这样：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we have several overloads of the `Query` method that all accept typed
    query requests. The type of query request defines what we expect to get back.
    We can also use the same types for the API. Let''s implement these query contracts
    and the `ClassifiedAdQueryApi` class without using the query service just yet,
    as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有几个`Query`方法的重载，它们都接受类型化的查询请求。查询请求的类型定义了我们期望得到的内容。我们也可以为API使用相同的类型。现在，让我们在不使用查询服务的情况下实现这些查询合约和`ClassifiedAdQueryApi`类，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here comes the API:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是API：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That looks pretty clean. We used both types of request and typed response. When
    we get one ad by its ID, we can return a `200 OK` or a `404 Not Found` response.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当整洁。我们使用了两种类型的请求和类型化响应。当我们通过ID获取一个广告时，我们可以返回`200 OK`或`404 Not Found`响应。
- en: Now, let's get back to the query service. The big question that you might get
    about this is *why do I need an interface if I only have one implementation?* And
    this question is completely valid. Interfaces aren't meant to be used just to
    make it possible to mock dependencies for tests. Basically, if all you use an
    interface for is a test, you'll need to reconsider having that interface at all.
    Queries are especially relevant in this context because it makes little sense
    to test the API with a mocked query.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到查询服务。你可能会有一个很大的疑问：*如果我只有一个实现，为什么我还需要一个接口？*这个问题是完全合理的。接口并不是为了仅仅为了测试而使用，以使依赖项可以被模拟。基本上，如果你只使用接口进行测试，你可能需要重新考虑是否真的需要这个接口。在这个上下文中，查询尤其相关，因为使用模拟查询来测试API几乎没有什么意义。
- en: If you want to test your queries, and you know that they belong to the infrastructure
    and application, then what is the point of testing them without using the infrastructure?
    You end up only testing the serialization, and while this might be not that bad
    an idea, the main function of the queries will remain untested. Query tests really
    need to use the database they talk to.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要测试你的查询，并且你知道它们属于基础设施和应用，那么在不使用基础设施的情况下测试它们有什么意义呢？你最终只会测试序列化，虽然这可能不是一个坏主意，但查询的主要功能将不会被测试。查询测试确实需要使用它们所交谈的数据库。
- en: After this important issue has been clarified, we can think about implementing
    queries closer to the database-level API. One way of doing this is by using extension
    methods. In the next two sections, we'll be using this approach to implement queries
    for RavenDB and Entity Framework and complete the API accordingly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在澄清了这个重要问题之后，我们可以考虑在接近数据库级别API的地方实现查询。实现这一目标的一种方法是通过使用扩展方法。在接下来的两个部分中，我们将使用这种方法来实现RavenDB和Entity
    Framework的查询，并相应地完成API。
- en: Queries with RavenDB
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RavenDB的查询
- en: As we already know, the RavenDB client library allows us to store documents
    in the database using the document session interface. The document session interface
    represents a single, short-lived connection to the database. Usually, it is scoped
    per request, since the single request is our scope for the unit of work. It is
    not only valid for commands; we can also use the document session that is registered
    in the `Startup` class of our application in query endpoints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，RavenDB客户端库允许我们使用文档会话接口将文档存储在数据库中。文档会话接口代表与数据库的单个、短暂连接。通常，它是按请求范围，因为单个请求是我们工作单元的范围。它不仅适用于命令；我们还可以在查询端点使用在应用程序的`Startup`类中注册的文档会话。
- en: 'In the following code, I try to implement one query to the database using extension
    methods for the `IAsyncDocumentSession` interface, which we register in the services
    container for the API:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我尝试使用`IAsyncDocumentSession`接口的扩展方法实现一个数据库查询，该接口我们在API的服务容器中进行了注册：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The latest version of RavenDB supports inline projections, so all we need to
    do here is to run a normal query with `Where` and then project the complex `ClassifiedAd`
    aggregate state document to the read model object. Then, we need to apply the
    paging and call `ToListAsync` so that the query gets executed on the server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的RavenDB支持内联投影，所以我们在这里需要做的就是运行一个带有`Where`的正常查询，然后将复杂的`ClassifiedAd`聚合状态文档投影到读取模型对象上。然后，我们需要应用分页并调用`ToListAsync`，以便在服务器上执行查询。
- en: 'With this one query ready to be used, we can call it from the API. I will comment
    out the API methods that currently have no queries that we can use. So, the API
    class would have one method, as shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好这个查询后，我们可以从API中调用它。我将注释掉当前没有查询可用的API方法。因此，API类将有一个方法，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since I already have some data in the database (one ad), I can now execute
    it using Swagger. I leave the page number as `0` and set the page size to `10`,
    but the query returns nothing. That''s because my classified ad is not published
    yet, so the query condition filters it out. I need to send the ad for review and
    then approve it using a new `Guid` for `ApproverId`. After doing this, I can see
    the read model that is returned from the API. The API can also be called directly
    in the browser by going to `http://localhost:5000/ad/list?Page=0&PageSize=10`,
    and the browser should show the following JSON:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在数据库中已经有了一些数据（一个广告），我现在可以使用Swagger执行它。我将页面数设置为`0`，将页面大小设置为`10`，但查询没有返回任何结果。这是因为我的分类广告尚未发布，所以查询条件将其过滤掉了。我需要发送广告进行审查，然后使用新的`Guid`为`ApproverId`进行批准。完成此操作后，我可以看到API返回的读取模型。您也可以通过访问`http://localhost:5000/ad/list?Page=0&PageSize=10`直接在浏览器中调用API。浏览器应显示以下JSON：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We want to add other queries now, but this would mean that we need to wrap
    all queries to this `try/catch` block. Let''s see if we can follow the **DRY**
    (short for **don''t repeat yourself**) principle and create a useful function
    to handle all queries. We already did this for commands that use the static `RequestHandler`
    class. I will add a new function here to handle queries too, as shown in the following
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想添加其他查询，但这意味着我们需要将所有查询包装在这个`try/catch`块中。让我们看看我们是否可以遵循**DRY**（即**不要重复自己**）原则，并创建一个有用的函数来处理所有查询。我们已经在使用静态`RequestHandler`类的命令中这样做过了。我将在下面添加一个新的函数来处理查询，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Adding the next query that will allow us to get all classified ads for an owner
    by owner ID is quite trivial; we just need to change the condition and keep the
    read model projection from the document to the read model. To make methods a bit
    shorter, I''ve added the `PagedList` extension method, so the whole class now
    looks like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下一个查询以获取所有按所有者ID分类的广告相当简单；我们只需更改条件并保持从文档到读取模型的读取模型投影。为了使方法更短，我添加了`PagedList`扩展方法，因此整个类现在看起来如下所示：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we wanted to use LINQ-to-objects, we could also move the projection to a
    separate function. However, the query here is being sent to the server, and the
    server has no idea about our client-side code. Therefore, we need to repeat the
    projection code in each method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用LINQ-to-objects，我们也可以将投影移动到单独的函数中。然而，这里的查询是发送到服务器的，服务器对我们的客户端代码一无所知。因此，我们需要在每个方法中重复投影代码。
- en: 'Now I can add the API call and use the new `HandleQuery` function. Here is
    the code for the whole `ClassifiedAdQueryApi` class, which uses both queries:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以添加API调用并使用新的`HandleQuery`函数。以下是整个`ClassifiedAdQueryApi`类的代码，它使用了两个查询：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can see that the methods for the API endpoint become just as concise as
    the command API methods, and all query logic is moved to the extension methods.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，API端点的处理方法变得和命令API方法一样简洁，所有的查询逻辑都被移动到了扩展方法中。
- en: Finally, we get to the point where we need to create a query that will combine
    data from two different documents in one read model. To handle this scenario,
    RavenDB offers a feature of projections using a loaded document. Using this feature,
    we can load another document (`UserProfile`) using an ID that comes from the document
    that we query (`ClassifiedAd`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了需要创建一个查询以结合一个读取模型中两个不同文档的数据的点。为了处理这种情况，RavenDB提供了一个使用已加载文档的投影功能。使用这个功能，我们可以使用来自我们查询的文档（`ClassifiedAd`）的ID加载另一个文档（`UserProfile`）。
- en: 'The query looks a bit more complicated, but not much. Here we go (I only list
    the new function in the following code):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 查询看起来稍微复杂一些，但并不太多。下面是（我只列出了以下代码中的新功能）：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can complete the query API by adding one more method, just as short
    as the previous two, as shown in the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过添加一个方法来完成查询API，这个方法与前面两个一样简短，如下所示：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The difference here is that we have no route because we want to get the resource
    by ID from the `ad` route itself. Now, I can start the application and go to `http://localhost:5000/ad?ClassifiedAdId=d338696a-342e-45cf-a02e-178dcb8e95f8`
    to see the following result:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于我们没有路由，因为我们想从`ad`路由本身通过ID获取资源。现在，我可以启动应用程序并访问`http://localhost:5000/ad?ClassifiedAdId=d338696a-342e-45cf-a02e-178dcb8e95f8`来查看以下结果：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Please note that this GUID is the ad ID in my database; you might need to check
    the database to find out what you have used yourself. Some readers might also
    not be happy that the URL is not fully REST compliant, since it uses a query parameter
    instead of the route. I believe this would be an easy fix, but then you'd need
    to remove the query object and use parameters in the API method that map to the
    route parameter instead.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个GUID是我数据库中的广告ID；你可能需要检查数据库以找出你自己的使用情况。一些读者可能也不满意URL不是完全符合REST规范，因为它使用查询参数而不是路由。我相信这是一个简单的修复，但那时你需要移除查询对象，并在API方法中使用映射到路由参数的参数。
- en: As you can see, we managed to make all the queries we wanted and keep them close
    to the underlying persistence. These queries can be called directly from the API,
    and our domain will remain untouched. We are also able to combine the data from
    two different aggregates in one read model, which we couldn't do using a repository
    because repositories always deal with the aggregate root only.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们成功地实现了所有想要的查询，并将它们与底层持久性保持紧密。这些查询可以直接从API调用，我们的领域模型将保持不变。我们还能够在一个读取模型中结合来自两个不同聚合的数据，这是使用存储库无法做到的，因为存储库总是只处理聚合根。
- en: Our queries use the database features directly, without bringing any abstractions
    on top of `IAsyncDocumentSession`. Using extension methods also allows us to remove
    the need for interfaces, and our queries don't become any less testable because
    of that. We can quite easily write integrated tests that will directly use the
    database, so we can check how our queries work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的查询直接使用数据库功能，没有在`IAsyncDocumentSession`之上引入任何抽象。使用扩展方法还允许我们消除对接口的需求，并且我们的查询不会因为这一点而变得难以测试。我们可以很容易地编写集成测试，这些测试将直接使用数据库，这样我们就可以检查我们的查询是如何工作的。
- en: We also used query objects as our API contracts and as parameters for query
    methods. Similarly, by using read models, we were able to use the same objects
    as the query result and as the API call response, so we didn't need to make any
    useless mappings between models that live in different layers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了查询对象作为我们的API合约和查询方法的参数。同样，通过使用读取模型，我们能够使用相同的对象作为查询结果和API调用响应，因此我们不需要在不同层之间进行任何无用的模型映射。
- en: Queries with Entity Framework
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Entity Framework的查询
- en: Let's now see how we can do the same thing using SQL. You might be wondering
    if I really meant Entity Framework rather than SQL. In fact, I am not going to
    use any features of the Entity Framework itself, since the best way to implement
    the query side of CQRS with relational databases is to use SQL directly. We will
    get to one more issue that arises from using Entity Framework in a moment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用SQL做同样的事情。你可能想知道我是否真的指的是Entity Framework而不是SQL。实际上，我并不打算使用Entity
    Framework本身的任何功能，因为使用关系数据库实现CQRS查询的最佳方式是直接使用SQL。我们将在稍后讨论使用Entity Framework时出现的一个问题。
- en: 'We did a lot of work in the previous section, where we created queries, read
    models, and API endpoints that used RavenDB. I won''t go over all the steps that
    are the same. The following is a brief description of the stages that are exactly
    the same between these two implementations; you can use this list to just copy
    the relevant files over from one implementation to the other:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们做了很多工作，包括创建查询、读取模型和使用了RavenDB的API端点。我不会逐一介绍所有相同的步骤。以下是对这两个实现中完全相同的阶段的简要描述；您可以使用这个列表，只需将相关文件从一种实现复制到另一种实现：
- en: The `UserProfile` aggregate and related value objects
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserProfile`聚合和相关的值对象'
- en: The command API and the application service for user profiles and classified
    ads
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令API和用户资料及分类广告的应用服务
- en: The `ContentModeration` delegate
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentModeration`委托'
- en: Restructuring with feature folders
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用功能文件夹重构
- en: Read models
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取模型
- en: Query classes
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询类
- en: Both query APIs
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个查询API
- en: Of course, we also need to copy a small change in the `ClassifiedAd` aggregate
    to handle the `Publish` command.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要在`ClassifiedAd`聚合中复制一个小改动来处理`Publish`命令。
- en: 'One more thing that I need to add to the Entity Framework-style project is `UserProfileRepository`.
    The interface it needs to implement is exactly the same as before. The repository
    implementation itself is the same as `ClassifiedAdRepository`, which we made in
    the previous chapter. Here we go:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我还需要在Entity Framework风格的项目中添加一个`UserProfileRepository`。它需要实现的接口与之前完全相同。仓库实现本身与我们在上一章中制作的`ClassifiedAdRepository`相同。下面是代码：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It looks like the only thing we need to do is to rename the existing `ClassifiedAdDbContext`
    to `MarketPlaceDbContext`, extend it with all the required configuration for the
    value objects, and then do the wiring. That was my first thought too. I added
    a new entity type configuration, as shown in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们唯一需要做的是将现有的`ClassifiedAdDbContext`重命名为`MarketPlaceDbContext`，为值对象添加所有必要的配置，然后进行连接。这也是我的第一个想法。我添加了一个新的实体类型配置，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that, here, I have to use an extra property to hold the primitive value
    of the ID, just like we did for `ClassifiedAd` in [Chapter 8](4eea9289-d77e-4568-a9c0-c5e1265e3b4e.xhtml),
    *Aggregate Persistence*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，我必须使用一个额外的属性来保存ID的原始值，就像我们在第8章中为`ClassifiedAd`所做的那样，*聚合持久化*。
- en: 'Then, I could just add one more `DbSet`, as shown in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我只需再添加一个`DbSet`，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once that''s done, I can change the `OnModelCreating` override, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我可以更改`OnModelCreating`的重写，如下所示：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we need to make use of it to change the wiring, as shown in the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要利用它来更改连接，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code uses the `AddPostgresDbContext` extension method; it just
    wraps what we had before. You can find the code in the chapter repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了`AddPostgresDbContext`扩展方法；它只是包装了之前的内容。您可以在章节仓库中找到代码。
- en: At this point, we can execute the application and create a new user profile,
    then use the same user ID to create a couple of classified ads, all using the
    command API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以执行应用程序并创建一个新的用户资料，然后使用相同的用户ID创建几个分类广告，所有这些操作都使用命令API。
- en: 'The next step is to start implementing queries. As planned, we go for pure
    SQL. However, using SQL would require us to create additional contexts and have `DbSet`
    for each read model. That seems like overkill. Because of this, I will be using
    Dapper, a lightweight SQL to the object helper library. It adds a number of helpful
    extensions to the `SqlConnection` class, and we will be adding even more extensions,
    so that should be fine. So I added the Dapper package to the `Marketplace` project
    and did the wiring in the `Startup.ConfigureServices` method by adding this code. Now,
    the first query seems to be quite obvious, as you can see from the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是开始实现查询。按照计划，我们采用纯SQL。然而，使用SQL将需要我们创建额外的上下文并为每个读取模型创建`DbSet`。这似乎有些过度。因此，我将使用Dapper，这是一个轻量级的SQL到对象辅助库。它为`SqlConnection`类添加了多个有用的扩展，我们还将添加更多扩展，所以这应该没问题。因此，我在`Marketplace`项目中添加了Dapper包，并在`Startup.ConfigureServices`方法中通过添加以下代码进行连接：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The reason why I am not closing the connection is `DbConnection` is registered
    in the container as scoped, so it gets instantiated per request. Since we are
    using the connection once, it will be automatically disposed and, therefore, closed.
    You could, of course, close it explicitly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有关闭连接的原因是`DbConnection`在容器中注册为作用域，因此它按请求实例化。由于我们只使用一次连接，它将被自动释放并关闭。当然，你也可以显式地关闭它。
- en: 'However, if we try that, we get an empty result. If we check the database table
    to see what data is stored for an active classified ad, we can see that the `State`
    column for an active ad has a value of `2`. At the same time, the `ClassifiedAdState`
    enum has the `Active` value on a second position. A weird thing in Entity Framework
    is, that it counts enum values from `1`, while the `(int)` type case always counts
    from `0`. We could, of course, use the static `2` value in the query, but it won''t
    deliver any safety if we need to change the enum and reorder values. Reordering
    this enum would also be dangerous for the write side, since Entity Framework won''t
    keep the right counter either. To fix this, let''s add explicit `int` values to
    the enum instead of using the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试这样做，我们会得到一个空的结果。如果我们检查数据库表以查看活动分类广告存储的数据，我们可以看到活动广告的`State`列的值为`2`。同时，`ClassifiedAdState`枚举在第二个位置有`Active`值。在Entity
    Framework中有一个奇怪的事情，那就是它从`1`开始计数枚举值，而`(int)`类型总是从`0`开始计数。当然，我们可以在查询中使用静态的`2`值，但这在我们需要更改枚举并重新排序值时不会提供任何安全性。重新排序这个枚举对写入端也会很危险，因为Entity
    Framework也不会保持正确的计数器。为了解决这个问题，让我们在枚举中添加显式的`int`值而不是使用以下代码：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After this change is made, we get a proper result. I have one active ad in
    the database, so I get one element in the JSON array, as shown in the following
    code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此更改后，我们得到了正确的结果。我在数据库中有一个活动广告，所以我得到了JSON数组中的一个元素，如下所示：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So far, so good. Next, we can implement the `myads` route, which queries all
    classified ads for a specific user who owns those ads. The query is almost identical
    to the previous one; we just need to change the `WHERE` condition using the following
    code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。接下来，我们可以实现`myads`路由，该路由查询特定用户拥有的所有分类广告。查询几乎与上一个相同；我们只需更改以下代码中的`WHERE`条件：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If I use the proper owner ID for an ad that I previously added to the system,
    I get exactly the same result as before. To demonstrate things a bit better, I
    added a new classified ad for the same owner ID and changed its title, but haven''t
    published it. So, when I execute the `list` query, I still get the same result
    with a single ad. When I execute the `myads` query, I get the following two results
    instead:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我使用之前添加到系统中的广告的正确所有者ID，我会得到与之前完全相同的结果。为了更好地展示这些内容，我为相同的所有者ID添加了一个新的分类广告并更改了其标题，但尚未发布。因此，当我执行`list`查询时，我仍然得到单个广告的相同结果。当我执行`myads`查询时，我得到以下两个结果而不是一个：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we can see that the price property has `-1` as a value, and that represents
    the `Price.NoPrice` value, which we can render in the UI accordingly when we have
    one.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到价格属性值为`-1`，这代表`Price.NoPrice`值，当我们在UI中渲染时可以相应地处理。
- en: 'The last query is a bit more complicated, since it requires a join. But since
    joins are very common SQL operations, it won''t be hard to implement this query
    as well; we simply use the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个查询稍微复杂一些，因为它需要一个连接。但是，由于连接是SQL操作中非常常见的操作，因此实现这个查询也不会很难；我们只需使用以下代码：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, I can call the API using an existing classified ad ID and get the following
    result:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以使用现有的分类广告ID调用API，并得到以下结果：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Well, that's it! Queries seem to be much easier to implement than commands.
    By using direct access to the database engine itself without much of an abstraction,
    we can fully utilize the full power of the database. We need, however, to be aware
    of some quirks that the write-side persistence has created, such as enumeration
    issues and somewhat weird column titles for value objects, but in the end, it
    wasn't all that bad.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，就是这样！查询似乎比命令更容易实现。通过直接访问数据库引擎本身而不进行太多抽象，我们可以充分利用数据库的全部功能。然而，我们需要意识到一些写入端持久性创建的怪癖，例如枚举问题和值对象的一些奇怪的列标题，但最终，这并不那么糟糕。
- en: Interestingly enough, we didn't need to change anything at all in the query
    API classes between the two different implementations, except for using a different
    type for the database connection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣，我们在两个不同的实现之间根本不需要在查询API类中做任何更改，除了使用不同类型的数据库连接。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we finally got hold of the data that we put in the database.
    Now, our project contains several `GET` endpoints to retrieve the content of the
    underlying database. We used CQRS to create queries, which are completely separate
    from the models that we have in our domain. Certainly, we had to use aggregate
    types to query RavenDB, since these are the document types as well. This could
    be avoided by splitting the state model from the aggregate, but this is something
    you can explore yourself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于掌握了我们放入数据库中的数据。现在，我们的项目包含几个`GET`端点来检索底层数据库的内容。我们使用CQRS创建查询，这些查询与我们的领域中的模型完全分离。当然，我们必须使用聚合类型来查询RavenDB，因为这些也是文档类型。这可以通过将状态模型从聚合中分离出来来避免，但这是你自己可以探索的事情。
- en: We embraced the power of native access to the database engine to do things that
    would otherwise be impossible or cumbersome to do if we'd just used repositories.
    That's because a repository type represents a collection of aggregates of a single
    type, and we would get in trouble if we needed to combine data from different
    aggregates in a single read model.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥抱了原生访问数据库引擎的力量，去做那些如果我们仅仅使用存储库就无法或难以完成的事情。这是因为存储库类型代表了一个单一类型的聚合集合，如果我们需要在单个读模型中结合来自不同聚合的数据，我们就会遇到麻烦。
- en: Read models allowed us to create objects that we can map to the database query
    result and return as is via the API without any additional mapping. Query objects
    nicely encapsulate all the parameters that we need to pass to the query itself.
    By using query objects, it is also easier to avoid signature conflicts if we need
    to send the same parameters to two different queries.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 读模型使我们能够创建可以映射到数据库查询结果的对象，并通过API直接返回，而无需任何额外的映射。查询对象很好地封装了我们传递给查询本身所需的所有参数。通过使用查询对象，如果需要向两个不同的查询发送相同的参数，也更容易避免签名冲突。
- en: Using extension methods to build queries is a powerful pattern. You won't need
    interfaces and additional registrations just to get dependencies to the controller.
    If you are concerned about testing, bear in mind that queries should always be
    tested against the actual database. Therefore, there is no real need to use interfaces
    there; you can use these extension methods in your tests just like we used them
    in the controllers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展方法来构建查询是一个强大的模式。你不需要接口和额外的注册，只需将依赖项传递到控制器。如果你担心测试，请记住，查询应该始终针对实际数据库进行测试。因此，在那里使用接口实际上并没有真正的必要；你可以在测试中使用这些扩展方法，就像我们在控制器中使用它们一样。
- en: By adding a couple of helpful generic static methods, such as `HandleCommand`
    and `HandleQuery`, we decreased the number of lines in our controllers and removed
    all duplicated code. It is always a good idea to look for a helpful abstraction
    if you see repetition in your code; that would make your code cleaner and shorter,
    and the chance of making a mistake when copy-pasting the same code again and again
    would virtually disappear.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加几个有用的通用静态方法，例如`HandleCommand`和`HandleQuery`，我们减少了控制器中的行数，并移除了所有重复的代码。当你看到代码中的重复时，寻找有用的抽象总是一个好主意；这会使你的代码更干净、更短，并且在重复粘贴相同代码时犯错的几率几乎会消失。
- en: This is the last chapter in which we use traditional persistence on the write
    side of CQRS. All of the subsequent chapters will use Event Sourcing to persist
    aggregates, but we will still be using a variety of methods for read models by
    using projections.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在CQRS的写侧使用传统持久化的最后一章。所有随后的章节都将使用事件溯源来持久化聚合，但我们仍然会通过使用投影来采用各种方法来构建读模型。
