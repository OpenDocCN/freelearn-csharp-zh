- en: Chapter 4. Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views are the actual output of the application that is delivered to the user.
    It is what they actually see when they access your application from the screen.
    All the components, be it menus, input elements, dialog boxes, and everything
    the user sees comes from your Views only. If you do not provide good user experience
    when accessing your application, users will not care how great your application
    is. So, Views play a critical role when building an ASP.NET MVC application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of View Engine and Razor View Engine
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming in Razor View Engine and different programming constructs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout in ASP.NET Core and its features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML Helpers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial Views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag Helpers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View engine and the Razor View engine
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](text00014.html#page "Chapter 1. Introduction to
    ASP.NET Core") , *Introduction to ASP.NET Core* , a browser can only understand
    HTML, CSS, and JavaScript. The purpose of the View engine is to generate the HTML
    code from your View and send it to the browser so that it can understand the content.
    Primarily, there are two different types of View engines—Razor View engine and
    Webform View engine. Although these two View engines come out of the box with
    ASP.NET MVC, you can use any custom View engine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Razor View engine
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Razor View engine is the default and recommended View engine in ASP.NET
    Core, and going forward, this may be the only View engine coming out of the box
    when you install ASP.NET MVC.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: You can mix a C# code and HTML code in your Razor View and the Razor View engine
    is intelligent enough to distinguish between these two and generate the expected
    output. In some scenarios, we may have to give additional information to Razor
    View to produce the appropriate results. Razor code blocks start with the `@`
    symbol and do not require a closing `@` .
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Programming in Razor View engine
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Programming in Razor View engine is just like you program in C#. The difference
    is that, in Razor View engine, your C# code will get mixed with HTML to produce
    the desired HTML output.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Variables in Razor View
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can declare a variable inside the razor block and use that variable using
    the `@` symbol.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all the examples in this chapter, we will only present the code samples
    of the view.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss this with an example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Controllers` folder and a Controller called `HomeController` .
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder called `Views` , a subfolder called `Home` , and a View file
    called `Index.cshtml` by right-clicking the context menu and selecting  **Add**
    | **New Item** and then  **MVC Razor View** from the list.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `HomeController.cs` file will have following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next is the updated Razor View where we will declare a variable and use it.
    The first five lines and the last two lines are simple HTML elements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We will concentrate on the lines that are bold. Then, we will create a Razor
    block using `@` { … } and declaring a variable inside it. The Razor block ends
    with the closing curly bracket. The snippet `Value:` is considered as simple HTML
    text. As we would like to use the razor variable value, we will use `@i` to instruct
    the Razor View engine that `i` is not a normal HTML text; and it is a Razor construct
    and is to be treated accordingly. The complete HTML code is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于粗体的行。然后，我们将使用`@` { … } 创建一个Razor代码块，并在其中声明一个变量。Razor代码块以闭合的大括号结束。`Value:`片段被视为简单的HTML文本。由于我们希望使用Razor变量的值，我们将使用`@i`来指示Razor视图引擎，`i`不是一个普通的HTML文本；它是一个Razor构造，应相应地处理。完整的HTML代码如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you run the application, you''ll see the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你会看到以下输出：
- en: '![Variables in Razor View](img/Image00042.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Razor视图中的变量](img/Image00042.jpg)'
- en: Please note that when you access the razor variable, you will need to use the
    `@` symbol. Without this, Razor View engine sees the `i` as text and not as an
    expression.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你访问Razor变量时，你需要使用`@`符号。如果没有这个符号，Razor视图引擎会将`i`视为文本而不是表达式。
- en: 'The following screenshot is the result you will get when you access the variable
    without `@`  symbol:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是当你不使用`@`符号访问变量时将得到的结果：
- en: '![Variables in Razor View](img/Image00043.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Razor视图中的变量](img/Image00043.jpg)'
- en: The for loop
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: for循环
- en: 'You can use most of the programming constructs available in C# in Razor View.
    The following piece of code is the `for` loop construct where we loop through
    five times and print the variable name:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Razor视图中使用大多数C#中可用的编程结构。以下代码片段是`for`循环结构，其中我们循环五次并打印变量名：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are a few points to be noted:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的点：
- en: As the for loop is a razor code, we should enclose the loop with the `@` symbol
    to indicate that the code that follows is a Razor code and not normal HTML.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于for循环是Razor代码，我们应该用`@`符号包围循环，以指示随后的代码是Razor代码而不是普通HTML。
- en: Whenever we use an HTML element or tag, Razor View engine falls back to HTML
    mode. If you want to use any Razor expression within the HTML tags, you will want
    to include the `@` symbol again to tell the Razor View engine that whatever follows
    is a Razor code and not an HTML element. This is the reason we use the `@` symbol
    again in the preceding expression, even within the parent root-level razor code.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论何时我们使用HTML元素或标签，Razor视图引擎都会回退到HTML模式。如果你想在HTML标签内使用任何Razor表达式，你将需要再次包含`@`符号，以告诉Razor视图引擎随后的内容是Razor代码而不是HTML元素。这就是为什么我们在前面的表达式中再次使用`@`符号，即使在父级根级Razor代码内部。
- en: 'The complete code for the View is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的完整代码如下：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The while loop
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: while循环
- en: 'The following piece of code is the `while` loop implementation for the same
    loop. Please note that the emboldened expressions increment the variable i. We
    will not use the @ symbol as it is not within the HTML element:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是相同循环的`while`循环实现。请注意，加粗的表达式增加了变量i的值。我们不会使用@符号，因为它不在HTML元素内：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The foreach loop
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: foreach循环
- en: 'The `foreach` loop in Razor View is the same as the `foreach` loop in C#. In
    the following code, we will initialize a list of integers, iterate through the
    list and print it as a list item:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Razor视图中的`foreach`循环与C#中的`foreach`循环相同。在以下代码中，我们将初始化一个整数列表，遍历列表并将其作为列表项打印出来：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The if condition
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if条件
- en: In the following code, we will check if the value of the variable is less than
    10\. If it is less than 10, we will print `i is less than 10` , otherwise, we
    will say `i is greater than 10` . You may wonder why we have to include the `text`
    tag and what its purpose is. As we are inside the Razor View code block, the text
    `i is less than 10` will be considered as Razor expression, but it is not.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将检查变量的值是否小于10。如果小于10，我们将打印`i is less than 10`，否则，我们将说`i is greater
    than 10`。你可能想知道为什么我们必须包含`text`标签，它的目的是什么。由于我们处于Razor视图代码块内部，文本`i is less than
    10`将被视为Razor表达式，但它不是。
- en: 'This `text` tag is to instruct the Razor View engine that whatever follows
    the `text` tag is to be considered as a text and not as a Razor expression:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`text`标签是为了指示Razor视图引擎，`text`标签之后的内容应被视为文本，而不是Razor表达式：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Layout
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: In all the previous examples we discussed, we have done the complete View coding
    in a single file. This will result in a lack of flexibility and reduced reusability.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前讨论的所有示例中，我们都在单个文件中完成了完整的视图编码。这将导致缺乏灵活性和可重用性降低。
- en: Consider the following web page structure where the **Top Section** contains
    the company logo or banner and the **Side Section** contains the links to various
    sections of the site. The **Content Section** changes for every page.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下网页结构，其中 **顶部部分** 包含公司标志或横幅，而 **侧边部分** 包含到网站各个部分的链接。**内容部分**会因页面而异。
- en: '![Layout](img/Image00044.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![布局](img/Image00044.jpg)'
- en: If we code the complete content in a single view, we may have to duplicate the
    **Top Section** and **Side Section** in every page. If we want to change anything
    in the **Side Section** , we will have to change all the files. This clearly shows
    that a single View file is not the best solution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在单个视图中编写完整的内容，我们可能需要在每个页面上重复 **顶部部分** 和 **侧边部分**。如果我们想更改 **侧边部分** 中的任何内容，我们可能需要更改所有文件。这清楚地表明，单个视图文件并不是最佳解决方案。
- en: The layout comes to the rescue in this scenario. The layout defines the site
    structure that can be reused across all the web pages. The layout does not even
    need to have something like the top section or side section; it can contain even
    a simple HTML structure where you can have common content and the body content
    will be rendered from individual view.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，布局就派上用场了。布局定义了可以在所有网页中重用的网站结构。布局甚至不需要像顶部部分或侧边部分这样的内容；它可以包含一个简单的HTML结构，其中可以包含常见内容，而主体内容将由单个视图渲染。
- en: 'Let''s build our first layout. In order to use the layout, you will need to
    have the following three things:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的第一个布局。为了使用布局，你需要以下三个东西：
- en: Inform the name of the layout file—this information should be made available
    in `_ViewStart.cshtml` . By convention, the names of all the shared files will
    start with an underscore and this file is located directly under the `Views` folder.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知布局文件的名称——这个信息应该在 `_ViewStart.cshtml` 中提供。按照惯例，所有共享文件的名称都将以一个下划线开头，并且此文件位于
    `Views` 文件夹的底部。
- en: Create the Layout file—by convention, the name of the file is `_Layout.cshtml`
    and it will be located in the `Shared` folder. All the shared content, such as
    partial views, will also be available here. Partial Views will be discussed later
    in this chapter.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建布局文件——按照惯例，文件名为 `_Layout.cshtml`，它将位于 `Shared` 文件夹中。所有共享内容，例如部分视图，也将在此处可用。部分视图将在本章后面讨论。
- en: Create the content View file—this View file is almost same as the earlier View
    files that we created so far with only one difference; only page-specific content
    will be available in this file, and this means that you'll not have any `html`
    , `head` , or `title` tags here.![Layout](img/Image00045.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建内容视图文件——这个视图文件几乎与之前创建的视图文件相同，只有一个区别；只有页面特定的内容将在此文件中可用，这意味着你将不会在此处有任何 `html`、`head`
    或 `title` 标签。![布局](img/Image00045.jpg)
- en: After the creation of `_ViewStart.cshtml` , `_Layout.cshtml` , and page-specific
    View files, the folder structure will be like the preceding snapshot.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `_ViewStart.cshtml`、`_Layout.cshtml` 和页面特定的视图文件后，文件夹结构将如前所述。
- en: Creating _ViewStart.cshtml
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 _ViewStart.cshtml
- en: 'Right-click on the **Views** folder and select **Add New Item** from the **Context**
    menu. Then, select **MVC View Start Page** from the **Add New Item** dialog box
    as shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击 **Views** 文件夹，从 **上下文** 菜单中选择 **添加新项**。然后，从 **添加新项** 对话框中选择 **MVC 视图起始页**，如图所示：
- en: '![Creating _ViewStart.cshtml](img/Image00046.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![创建 _ViewStart.cshtml](img/Image00046.jpg)'
- en: 'When you click the **Add** button, it will create a file with the following
    content:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 **添加** 按钮时，它将创建一个包含以下内容的文件：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating _Layout.cshtml
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 _Layout.cshtml
- en: 'Create a folder called **Shared** within the **Views** folder. Then, right-click
    on the **Shared** folder and select **Add New Item** from the **Context** menu
    as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Views` 文件夹中创建一个名为 **Shared** 的文件夹。然后，右键单击 **Shared** 文件夹，从 **上下文** 菜单中选择
    **添加新项**，如图所示：
- en: '![Creating _Layout.cshtml](img/Image00047.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![创建 _Layout.cshtml](img/Image00047.jpg)'
- en: 'When you click the **Add** button, it will create **_Layout.cshtml** with the
    following content:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 **添加** 按钮时，它将创建包含以下内容的 **_Layout.cshtml**：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding layout file is a simple HTML content with a couple of Razor expressions.
    `@ViewBag` . The title is used to display the title information passed from the
    Controller and `@RenderBody` is the Razor expression that calls the page specific
    View and merges that content over there.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述布局文件是一个简单的HTML内容，包含几个Razor表达式。`@ViewBag` 用于显示从控制器传递过来的标题信息，而 `@RenderBody`
    是一个Razor表达式，它调用页面特定的视图并将内容合并到那里。
- en: Adding a page-specific View
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加页面特定的视图
- en: Before adding the View, we will need to add an action method in our `HomeController`
     file from which we will be calling our page-specific view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加视图之前，我们需要在我们的 `HomeController` 文件中添加一个操作方法，我们将从这个方法调用页面特定的视图。
- en: 'Let''s add an action method named `Index2` as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个名为 `Index2` 的操作方法，如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `ViewBag`  is used to pass information from the Controller to the View.
    Here, we are passing the `Title` information from the action method to the View.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewBag` 用于将信息从控制器传递到视图。在这里，我们将 `Title` 信息从操作方法传递到视图。'
- en: Now, right-click on the `Views` folder, select **Add** | **New Item** , select
    **MVC View Page** , and save the file as `Index2.cshtml` .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，右键单击 `Views` 文件夹，选择 **添加** | **新建项**，选择 **MVC 视图页面**，并将文件保存为 `Index2.cshtml`。
- en: 'In the generated view, I have added simple `Hello` text. This text will be
    rendered in the body of the layout page. The complete code of the View file is
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的视图中，我添加了简单的 `Hello` 文本。此文本将在布局页面的主体中渲染。视图文件的完整代码如下：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Everything is set now. Run the application and type the URL `http://localhost:50132/Home/Index2`
    in the browser. Please note that the port number after the local host may vary
    when you run the application from your PC.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了。运行应用程序，并在浏览器中输入 URL `http://localhost:50132/Home/Index2`。请注意，当您从您的电脑运行应用程序时，本地主机后面的端口号可能会变化。
- en: '![Adding a page-specific View](img/Image00048.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![添加页面特定的视图](img/Image00048.jpg)'
- en: As expected, you'll see the text seen in the preceding picture. However, our
    point is not about the text. It's about the structure of the generated HTML content.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，您将看到前面图片中看到的文本。然而，我们的重点不是文本。它是关于生成的 HTML 内容的结构。
- en: 'View the source by pressing *Ctrl* + *U* (on the Chrome browser in Windows).
    You''ll see the following HTML content:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按 *Ctrl* + *U*（在 Windows 的 Chrome 浏览器中）查看源代码。您将看到以下 HTML 内容：
- en: '![Adding a page-specific View](img/Image00049.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![添加页面特定的视图](img/Image00049.jpg)'
- en: The top content (the `html` , `head` , `body` , and `div`  opening tags) and
    bottom content (the `html` , `head` , `body` , and `div`  closing tags) come from
    the layout file and the text comes from the View specific to the page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部内容（`html`、`head`、`body` 和 `div` 开放标签）和底部内容（`html`、`head`、`body` 和 `div` 关闭标签）来自布局文件，文本来自特定于页面的视图。
- en: Generating HTML
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 HTML
- en: As discussed in [Chapter 1](text00014.html#page "Chapter 1. Introduction to
    ASP.NET Core") , *Introduction to ASP.NET Core* , browsers can understand only
    HTML, CSS, and JavaScript, irrespective of the technology that you use to build
    the web application. This holds true when building the application in ASP.NET
    MVC as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](text00014.html#page "第 1 章。ASP.NET Core 简介") 中所述，*ASP.NET Core 简介*，浏览器只能理解
    HTML、CSS 和 JavaScript，无论您使用什么技术构建 Web 应用程序。在 ASP.NET MVC 中构建应用程序时也是如此。
- en: Most applications get the user input, process the input, and then store the
    required information in the database to retrieve them later. In the context of
    web applications, Form HTML elements are used to get the user input.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序获取用户输入，处理输入，然后将所需信息存储在数据库中以供以后检索。在 Web 应用程序的情况下，表单 HTML 元素用于获取用户输入。
- en: 'The following are a couple of ways to generate HTML elements in ASP.NET Core:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 ASP.NET Core 中生成 HTML 元素的一些方法：
- en: HTML Helpers
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 辅助器
- en: Tag Helpers
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签辅助器
- en: HTML Helpers are server-side methods that aid in generating HTML elements, which
    can be understood by the browsers. HTML helpers were the primary method of generating
    the HTML elements up till ASP.NET MVC 5.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 辅助器是服务器端方法，有助于生成浏览器可以理解的 HTML 元素。HTML 辅助器是生成 HTML 元素的主要方法，直到 ASP.NET MVC
    5。
- en: Tag Helpers, introduced in ASP.NET Core, also produce HTML elements. Tag helpers,
    which we will discuss in a later section of this chapter, will look just like
    HTML elements where you add attributes to identify them as Tag Helpers. The advantage
    of using Tag helpers over HTML helpers is that the user interfaces designers/engineers
    do not need to worry about Razor code. They just code with HTML elements and additional
    attributes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 中引入的标签辅助器也会生成 HTML 元素。我们将在本章的后续部分讨论标签辅助器，它们将看起来像 HTML 元素，其中您添加属性来识别它们为标签辅助器。使用标签辅助器而不是
    HTML 辅助器的优点是用户界面设计师/工程师不需要担心 Razor 代码。他们只需使用 HTML 元素和额外的属性进行编码。
- en: Before discussing HTML helpers and Tag helpers, let's take a step back and talk
    about why we need them in the first place.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 HTML 辅助器和标签辅助器之前，让我们退一步，谈谈为什么我们最初需要它们。
- en: 'Let''s consider a simple form, as shown in the following picture, where we
    would like to get the user''s name and their age. If the user enters her age,
    we will display `You are eligible to vote!` . If not, we will display `You are
    not eligible to vote now` :'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的表单，如下面的图片所示，我们希望获取用户的姓名和年龄。如果用户输入了她的年龄，我们将显示 `您有资格投票！` 。如果没有，我们将显示
    `您现在没有资格投票` ：
- en: '![Generating HTML](img/Image00050.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![生成HTML](img/Image00050.jpg)'
- en: 'The following is the HTML code to show the preceding simple form:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将显示前面简单表单的HTML代码：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method of coding HTML elements directly is time-consuming and error-prone.
    For example, in the preceding form, the label and input HTML elements refer to
    the same element (`txtName` in the first group and `txtAge` in the second group).
    If we hand-code the HTML element, there is a possibility of a typo error in building
    the HTML element.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 直接编码HTML元素的方法既耗时又容易出错。例如，在上面的表单中，标签和输入HTML元素引用了同一个元素（第一组中的 `txtName` 和第二组中的
    `txtAge`）。如果我们手动编码HTML元素，在构建HTML元素时可能会出现拼写错误。
- en: HTML Helpers
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML助手
- en: 'HTML helpers are server-side methods that generate HTML for you. We can generate
    the same form using HTML helpers as follows (`HTML.BeginForm` , `@Html.Label`
    , and `@Html.TextBox` generate the HTML `form` element, label, and textbox elements,
    respectively):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: HTML助手是服务器端方法，为您生成HTML。我们可以使用HTML助手生成相同的表单，如下所示（`HTML.BeginForm`、`@Html.Label`
    和 `@Html.TextBox` 分别生成HTML `form` 元素、标签和文本框元素）：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![HTML Helpers](img/Image00051.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![HTML助手](img/Image00051.jpg)'
- en: You might wonder why we need to use HTML helpers when we can write the HTML
    code manually. Things will get more complex when we pass the model from the Controller
    to the view. Using HTML helpers, we can directly build `form` elements from `Models`
     files so that they will pick the names from the `Models` that you are using.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们需要使用HTML助手，因为我们可以手动编写HTML代码。当我们将模型从控制器传递到视图时，事情会变得更加复杂。使用HTML助手，我们可以直接从
    `Models` 文件构建 `form` 元素，这样它们将选择你正在使用的 `Models` 中的名称。
- en: 'For example, let''s create a folder called `Models` and a class called `Person`
    . This class will act as a model as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个名为 `Models` 的文件夹和一个名为 `Person` 的类。此类将充当模型，如下面的截图所示：
- en: '![HTML Helpers](img/Image00052.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![HTML助手](img/Image00052.jpg)'
- en: 'The `Person`  class is just a POCO (Plain Old C# Object) class and will act
    as a model. The complete code for this class is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 类只是一个POCO（Plain Old C# Object）类，将充当模型。此类的完整代码如下：'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s create a new action method called `ValidateAge` . In this method, we
    will create an empty `Person` class and pass the Model to the View. We will also
    create a dynamic property called `Title` in `ViewBag` so that we can display this
    value in View:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `ValidateAge` 的新操作方法。在这个方法中，我们将创建一个空的 `Person` 类并将模型传递给视图。我们还在 `ViewBag`
    中创建了一个名为 `Title` 的动态属性，以便我们可以在视图中显示此值：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the view, create the `form` using the following HTML Helpers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，使用以下HTML助手创建 `form`：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first line, we are telling the View that we are passing the Model of
    type `Person` class. This enables you to use the strong type of Model, that is,
    when you type Model and a dot, **IntelliSense** provides you with all the properties
    of the `Person` class
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们告诉视图我们正在传递 `Person` 类型的模型。这使您能够使用模型的强类型，即当您键入 Model 并加一个点时，**IntelliSense**
    会为您提供 `Person` 类的所有属性
- en: In the second line, we are using the overloaded `BeginForm` HTML helpers which
    accept three parameters—the action method name, the Controller name, and the `Form`
    method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们使用的是重载的 `BeginForm` HTML助手，它接受三个参数——动作方法名称、控制器名称和 `Form` 方法。
- en: Simply, when the user submits the form, the information should be passed to
    the mentioned action of the Controller.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，当用户提交表单时，信息应该传递到提到的控制器动作。
- en: In the `LabelFor` and `TextBox` For HTML helpers, we are just passing Model
    properties (name and age); it automatically queries and gets the Model properties
    and builds the respective HTML elements. This is one of the primary advantages
    of using HTML helpers. Without using the HTML helpers, this process might become
    complex.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LabelFor` 和 `TextBox` For HTML助手中，我们只是传递模型属性（姓名和年龄）；它将自动查询并获取模型属性并构建相应的HTML元素。这是使用HTML助手的优点之一。不使用HTML助手，这个过程可能会变得复杂。
- en: Now, let's write the respective `POST` action method in the same way. In the
    following `POST` action method, based on the age entered in the form, we set the
    dynamic property as `Message` .
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以相同的方式编写相应的`POST`操作方法。在以下`POST`操作方法中，根据表单中输入的年龄，我们将动态属性设置为`Message`。
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It is to be noted that both the `GET` and `POST` action method refer to the
    same View —`ValidateAge.cshtml` . Add the following content to the View just above
    the form element:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`GET`和`POST`操作方法都指向同一个视图——`ValidateAge.cshtml`。在表单元素上方添加以下内容到视图中：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the user submits the form, the `POST` action method sets the dynamic `Message`
    property in `ViewBag` . However, the value of this property will be null when
    the View is rendered as part of the `GET` request. If the value is not null, insert
    the message at the top of the page.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户提交表单，`POST`操作方法会在`ViewBag`中设置动态的`Message`属性。然而，当视图作为`GET`请求的一部分渲染时，此属性的值将为null。如果值不为null，则在页面顶部插入消息。
- en: 'When you run the application, you''ll get the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您将得到以下输出：
- en: '![HTML Helpers](img/Image00053.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![HTML助手](img/Image00053.jpg)'
- en: Partial View
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分视图
- en: Partial Views are just Views that can be reused across your application. Partial
    Views can be thought of as pluggable reusable blocks that you can call from anywhere
    and have the content of the partial view displayed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 部分视图只是可以在应用程序中重用的视图。可以将部分视图视为可插入的可重用块，您可以从任何地方调用它，并显示部分视图的内容。
- en: 'Consider the following structure of a web page—it''s the same layout page that
    we used earlier, but with a couple of changes. The **Latest News** block is added
    to the **Side Section** and the **Login** block is added to the **Top Section**
    . These blocks are not restricted to the **Top Section** or **Side Section** and
    can be used anywhere in your application, including your **Content Section**  as
    shown in the following figure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下网页的结构——这是我们之前使用的相同布局页面，但有一些变化。**最新新闻**块被添加到**侧边栏**，而**登录**块被添加到**顶部区域**。这些块不受**顶部区域**或**侧边栏**的限制，可以在应用程序的任何地方使用，包括以下图中的**内容区域**。
- en: '![Partial View](img/Image00054.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![部分视图](img/Image00054.jpg)'
- en: These Partial Views are not restricted to static content and can contain `form`
    elements. In the preceding screenshot, the **Latest News**  Partial View contains
    the text content and the login Partial View contains `form` elements to get the
    e-mail ID and password.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分视图不仅限于静态内容，还可以包含`form`元素。在前面的截图中，**最新新闻**部分视图包含文本内容，而登录部分视图包含用于获取电子邮件ID和密码的`form`元素。
- en: Location of Partial Views—Framework does not restrict the location of the Partial
    View. However, by convention, if your Partial View will be used only by your Controller,
    you can create that Partial View in the Controller-specific Views folder. For
    example, if your Partial View will only be used in `HomeController` file, you
    can create that Partial View in the `Views\Home` folder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 部分视图的位置——框架不限制部分视图的位置。然而，按照惯例，如果你的部分视图只由你的控制器使用，你可以在控制器特定的视图文件夹中创建该部分视图。例如，如果你的部分视图只会在`HomeController`文件中使用，你可以在`Views\Home`文件夹中创建该部分视图。
- en: Let's take look at how to create a Partial View and use it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建部分视图并使用它。
- en: As discussed earlier, a Partial View is just like a normal View. So, we will
    create a Partial View in the same way we create normal View.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，部分视图就像一个普通视图。因此，我们将以创建普通视图相同的方式创建部分视图。
- en: 'Right-click on the `Shared` folder and select **Add** | **New Item** . By convention,
    like all shared content, the name of the Partial View will also start with "`_`
    "(underscore), as shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`Shared`文件夹，然后选择**添加** | **新建项**。按照惯例，就像所有共享内容一样，部分视图的名称也将以"`_`"（下划线）开头，如下面的截图所示：
- en: '![Partial View](img/Image00055.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![部分视图](img/Image00055.jpg)'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are creating this Partial View based on the assumption that it can be used
    from anywhere in the application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建这个部分视图是基于它可以从应用程序的任何地方使用的假设。
- en: 'In the generated Partial View, I have added the following simple static content—a
    text and a simple table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的部分视图中，我添加了以下简单的静态内容——一段文本和一个简单的表格：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Calling the Partial View
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用部分视图
- en: A Partial View can be called using the `@Html.Partial` HTML helper.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@Html.Partial` HTML助手调用部分视图。
- en: In our case, we will be calling the Partial View from `Index2.cshtml` file.
    The parameter that you pass will be the name of the partial file. It will search
    for the Partial View by that name and render that complete content as part of
    the `Index2.cshtml`  file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将从`Index2.cshtml`文件中调用部分视图。你传递的参数将是部分文件的名称。它将根据该名称搜索部分视图，并将该完整内容作为`Index2.cshtml`文件的一部分进行渲染。
- en: 'The content of `Index2.html`  file will now be as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index2.html`文件的现在内容如下：'
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, run the application and access the URL `http://localhost:50132/Home/Index2`
    . You''ll see the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并访问URL `http://localhost:50132/Home/Index2`。你将看到以下输出：
- en: '![Calling the Partial View](img/Image00056.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![调用部分视图](img/Image00056.jpg)'
- en: View components
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图组件
- en: View components are a new feature introduced in ASP.NET Core, they are almost
    similar to Partial Views but is more powerful. When you use Partial Views, you
    have dependency over the Controller. However, when you use the `ViewComponent`
    attribute, you do not have to depend on the Controller, so we will establish separation
    of concerns and have better testability. Even though the existing Partial View
    HTML helper is still supported, it is preferable to use the View component whenever
    you want to show a reusable piece of information when you are using .NET Core.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 视图组件是ASP.NET Core中引入的新功能，它们几乎与部分视图相似，但功能更强大。当你使用部分视图时，你对Controller有依赖。然而，当你使用`ViewComponent`属性时，你不需要依赖Controller，因此我们将建立关注点的分离，并具有更好的可测试性。尽管现有的部分视图HTML辅助器仍然受支持，但在使用.NET
    Core时，你想要显示可重用信息时，更倾向于使用视图组件。
- en: Creating a View component
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图组件
- en: 'You can create a `ViewComponent` using any of the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下任何一种方式创建`ViewComponent`：
- en: Create a class by deriving from the `ViewComponent` attribute
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从`ViewComponent`属性派生创建一个类
- en: Decorate a class with the `[ViewComponent]` attribute or derive it from the
    class that has the `[ViewComponent]` attribute
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`[ViewComponent]`属性装饰一个类，或者从具有`[ViewComponent]`属性的类派生
- en: You can use the convention by creating a class that ends with a suffix `ViewComponent`
    attribute
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过创建一个以`ViewComponent`属性后缀结尾的类来使用约定。
- en: Whatever option you choose, this `ViewComponent`  should be public, non-nested,
    and non-abstract classes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种选项，这个`ViewComponent`都应该是一个公共的、非嵌套的、非抽象的类。
- en: Like Controllers, you can use the Dependency Injection (via a constructor) in
    the `ViewComponent` attribute as well. As the `ViewComponent`  attribute is separate
    from the Controller lifecycle, you may not be able to use the action filters in
    `ViewComponents` .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与Controller一样，你可以在`ViewComponent`属性中使用依赖注入（通过构造函数）。由于`ViewComponent`属性与Controller的生命周期是分开的，你可能无法在`ViewComponents`中使用操作过滤器。
- en: There is a method called `Invoke` (or `InvokeAync` , the asynchronous equivalent
    of `Invoke` ), that will return the `IComponentViewResult` interface. This method
    is similar to the action method of the Controller that will return the View.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`Invoke`（或`InvokeAync`，`Invoke`的异步等效方法），它将返回`IComponentViewResult`接口。这个方法类似于将返回视图的Controller的动作方法。
- en: Let's get our hands dirty by creating a `ViewComponent` attribute.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们亲自动手创建一个`ViewComponent`属性。
- en: 'Create a new folder called `ViewComponents` in your project and a new class
    called `SimpleViewComponent` , as shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中创建一个名为`ViewComponents`的新文件夹和一个名为`SimpleViewComponent`的新类，如下面的截图所示：
- en: '![Creating a View component](img/Image00057.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图组件](img/Image00057.jpg)'
- en: 'The `SimpleViewComponent` file that we created will look like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`SimpleViewComponent`文件看起来如下：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We just have a couple of methods, one to populate the data and the other is
    the `Invoke` method where we will render the View.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有几个方法，一个用于填充数据，另一个是`Invoke`方法，我们将在这个方法中渲染视图。
- en: 'Once you have created the `ViewComponent` attribute, you will need to include
    the `ViewComponent` namespace in the `Views\_ViewImports.cshtml` file so that
    the `ViewComponents` attributes can be available for all the Views. The highlighted
    code snippet in the following is added to the View:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了`ViewComponent`属性，你需要在`Views_ViewImports.cshtml`文件中包含`ViewComponent`命名空间，以便`ViewComponents`属性对所有视图可用。以下突出显示的代码片段被添加到视图中：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have created the `ViewComponent` and made them available to all of the Views.
    A simple action method in the `HomeController` file just returns the View:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`ViewComponent`并将其提供给所有视图。`HomeController`文件中的一个简单的动作方法只是返回视图：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the associated View, we can just invoke the component as shown in the following
    code snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在关联的视图中，我们可以像以下代码片段所示那样调用组件：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you invoke the component, it will search in the following two folders:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用组件时，它将在以下两个文件夹中搜索：
- en: The `Views\<controller_name>\Components\<view component name>\<view name>` folder
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Views\<controller_name>\Components\<view component name>\<view name>`文件夹'
- en: The `Views\Shared\Components\<view_component_name>/<view_name>` folder
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Views\Shared\Components\<view_component_name>/<view_name>`文件夹'
- en: 'The default View name of the View component is `Default` , which makes your
    file name for the View `Default.cshtml` . So, we will need to create the `Default.cshtml`
     file in `Views\Shared\Simple\Default.cshtml` folder, as shown in the following
    screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 视图组件的默认视图名称是`Default`，这使得视图的文件名为`Default.cshtml`。因此，我们需要在`Views\Shared\Simple\Default.cshtml`文件夹中创建`Default.cshtml`文件，如图所示：
- en: '![Creating a View component](img/Image00058.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图组件](img/Image00058.jpg)'
- en: 'In the the View (`Default.cshtml` file) of the `ViewComponent` file, we are
    just iterating the items in the model and displaying them as an unordered list
    item, as shown in the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewComponent`文件的视图（`Default.cshtml`文件）中，我们只是在迭代模型中的项并将它们显示为无序列表项，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you run the application and access the URL (`http://localhost:50132/Home/Sample`
    ), you should see the following output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序并访问URL（`http://localhost:50132/Home/Sample`）时，您应该看到以下输出：
- en: '![Creating a View component](img/Image00059.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图组件](img/Image00059.jpg)'
- en: The first line, **This is a sample web page** , comes from the parent View file
    (`sample.cshtml` ) whereas the subsequent list comes from `ViewComponent` attribute.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行**这是一个示例网页**来自父视图文件（`sample.cshtml`），而随后的列表来自`ViewComponent`属性。
- en: The `ViewComponent` attributes are usually referred in the Views. However, if
    you want to call the `ViewComponent` directly from your Controller, you can do
    so.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在视图中引用`ViewComponent`属性。但是，如果您想直接从控制器中调用`ViewComponent`，您也可以这样做。
- en: 'I have called the `Sample` action method to call the Simple `ViewComponent`
    directly instead of calling it through some other View as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经调用了`Sample`操作方法来直接调用简单的`ViewComponent`，而不是通过其他视图调用它，如下所示：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Creating a View component](img/Image00060.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图组件](img/Image00060.jpg)'
- en: Thus, these `ViewComponents` have far more flexibility and features, such as
    Dependency Injection, when compared to old HTML Partial Views. This ensures `ViewComponents`
     are separately tested.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与旧的HTML部分视图相比，这些`ViewComponents`具有更多的灵活性和功能，例如依赖注入。这确保了`ViewComponents`可以单独测试。
- en: Tag Helpers
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签助手
- en: Tag Helpers are a new feature in ASP.NET Core; they help generate the HTML elements.
    In HTML helpers, we will write a C#/Razor code to generate the HTML. The disadvantage
    associated with this approach is that many frontend engineers will not know C#/Razor
    code. They work on plain HTML, CSS, and JavaScript. Tag Helpers look just like
    HTML code but have all the features of server-side rendering. You can even build
    your custom Tag Helper for your needs.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 标签助手是ASP.NET Core中的新功能；它们帮助生成HTML元素。在HTML助手中，我们将编写C#/Razor代码来生成HTML。与此方法相关的不利之处在于，许多前端工程师可能不知道C#/Razor代码。他们使用纯HTML、CSS和JavaScript。标签助手看起来就像HTML代码，但具有所有服务器端渲染的功能。您甚至可以根据需要构建自己的自定义标签助手。
- en: Let's take a look at how to use a Tag Helper. In order to use the Tag helper,
    you will need to install the `Microsoft.AspNet.Mvc.TagHelpers` NuGet package.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用标签助手。为了使用标签助手，您需要安装`Microsoft.AspNet.Mvc.TagHelpers` NuGet包。
- en: 'Open the  **Package Manager Console**  window by selecting **View**  | **Other
    Windows**  | **Package Manager Console** , as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择**视图** | **其他窗口** | **包管理控制台**来打开**包管理控制台**窗口，如图所示：
- en: '![Tag Helpers](img/Image00061.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![标签助手](img/Image00061.jpg)'
- en: 'You can install `TagHelpers` methods by entering the following command in the 
    **Package Manager Console**  window, the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在**包管理控制台**窗口中输入以下命令来安装`TagHelpers`方法，以下命令：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following response will appear when you''ve entered the command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入以下命令时，将出现以下响应：
- en: '![Tag Helpers](img/Image00062.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![标签助手](img/Image00062.jpg)'
- en: Once the `TagHelpers` package is installed, we will need to call `ViewImports`
    file, where we will add the `TagHelpers` directive so that Tag Helpers are available
    to our Views.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`TagHelpers`包，我们需要调用`ViewImports`文件，在那里我们将添加`TagHelpers`指令，以便标签助手可以供我们的视图使用。
- en: 'Right-click on the `Views` folder and select the  **Add New Item** option from
    the **Context** menu; you''ll see the following screen:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`Views`文件夹，从**上下文**菜单中选择**添加新项**选项；你会看到以下屏幕：
- en: '![Tag Helpers](img/Image00063.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Tag Helper](img/Image00063.jpg)'
- en: 'Add the following content to the `_ViewImports.cs` file. The first couple of
    lines tells ASP.NET MVC to include the necessary namespaces. The last line tells
    ASP.NET MVC to include all the `TagHelpers` available in `Microsoft.AspNet.Mvc.TagHelpers`
    . The first parameter indicates the name of TagHelper. We have used *, which means
    that we may want to use all the Tag Helpers. The second parameter indicates the
    assembly where the `TagHelpers` will be available:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`_ViewImports.cs`文件中。前几行告诉ASP.NET MVC包含必要的命名空间。最后一行告诉ASP.NET MVC包含`Microsoft.AspNet.Mvc.TagHelpers`中所有可用的`TagHelpers`。第一个参数表示TagHelper的名称。我们使用了*，这意味着我们可能想要使用所有的Tag
    Helper。第二个参数表示`TagHelpers`可用的程序集：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we are creating the `_ViewImports.cshtml` file directly under the `Views`
    folder, as shown in the following screenshot, the Tag Helpers will be available
    for all the Views:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如以下屏幕截图所示，我们直接在`Views`文件夹下创建`_ViewImports.cshtml`文件，因此Tag Helper将对所有视图可用。
- en: '![Tag Helpers](img/Image00064.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Tag Helper](img/Image00064.jpg)'
- en: Had we included the `_ViewImports.cshtml` file under the `Home` folder, the
    Tag Helpers would be available only for the Views under the `Home` folder.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`Home`文件夹下包含了`_ViewImports.cshtml`文件，那么Tag Helper将只对`Home`文件夹下的视图可用。
- en: 'Let''s add a simple action method called `Index3` in the `HomeController` file,
    and in the associated View, we will use Tag Helpers as shown in the following
    code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`HomeController`文件中添加一个简单的操作方法`Index3`，并在相关的视图中使用Tag Helper，如下所示：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the corresponding View (`Index3.cshtml` file) for the `Index3` action method
    with the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码添加`Index3`操作方法的对应视图（`Index3.cshtml`文件）：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following are a few things that you need to note in the preceding code,
    for the use of Tag Helpers:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下是一些需要注意的事项，以便使用Tag Helper：
- en: All the form elements look just like standard HTML elements with just a few
    changes in the attributes. This makes frontend developers work independently,
    without learning HTML/Razor code and thus more easily achieving the separation
    which concerns.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有表单元素看起来就像标准的HTML元素一样，只是在属性上做了一些小的改动。这使得前端开发者可以独立工作，无需学习HTML/Razor代码，从而更容易实现关注点的分离。
- en: The first line of the preceding view indicates the type of model data passed
    to the view from the Controller.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的视图的第一行指示从控制器传递到视图的模型数据类型。
- en: The Form element has a couple of attributes named `asp-controller` and `asp-action`
     which represent Controller names and action method names respectively.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单元素有两个属性名为`asp-controller`和`asp-action`，分别代表控制器名称和操作方法名称。
- en: The Label and input tag helpers are just like HTML elements, with just an additional
    `asp-for` attribute. The values for these attributes represent the model properties.
    You can take advantage of IntelliSense when entering the values for these attributes.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签和输入标签辅助器就像HTML元素一样，只是多了一个`asp-for`属性。这些属性的值代表模型属性。在输入这些属性的值时，你可以利用IntelliSense。
- en: Creating custom Tag Helpers
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义Tag Helper
- en: 'ASP.NET Core provides many built-in Tag Helpers to help you create the necessary
    HTML elements for many scenarios. However, this process is not comprehensive and
    is exhaustive. Sometimes, you may want to make some changes in the generated HTML
    element, or you may want to create an HTML element with new properties or a new
    HTML element altogether. You are not restricted to using only the existing Tag
    Helpers in the ASP.NET Core application. You can create your own Tag Helper if
    the existing Tag Helpers do not suit your needs. Let''s create a simple Tag Helper
    to create an e-mail link:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了许多内置的Tag Helper来帮助你在多种场景下创建必要的HTML元素。然而，这个过程并不全面和详尽。有时，你可能想要对生成的HTML元素进行一些修改，或者你可能想要创建具有新属性或全新的HTML元素。你不仅限于在ASP.NET
    Core应用程序中使用现有的Tag Helper。如果你现有的Tag Helper不能满足你的需求，你可以创建自己的Tag Helper。让我们创建一个简单的Tag
    Helper来创建一个电子邮件链接：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There are a couple of ways to create Tag Helpers to implement the `ITagHelper`
    interface or inherit the `TagHelper` class. The `TagHelper` class has a `Process`
    method that you can override to write your custom Tag Helpers. The `TagHelper`
    class also has the `TagHelperOutput` parameter, which you can use to write and
    generate the desired output HTML. So, it is preferable to create Tag Helpers by
    inheriting from the `TagHelper` class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以创建实现 `ITagHelper` 接口或继承 `TagHelper` 类的 Tag Helper。`TagHelper` 类有一个可以重写的
    `Process` 方法，你可以用它来编写自定义 Tag Helper。`TagHelper` 类还有一个 `TagHelperOutput` 参数，你可以用它来编写和生成所需的输出
    HTML。因此，通过从 `TagHelper` 类继承来创建 Tag Helper 是更可取的。
- en: 'Our objective is to write a custom e-mail Tag Helper so that when someone uses
    that Tag Helper, which is `<email mailTo="mugil@greatestretailstore.com"></email>`
    , it should be converted to the following line of code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是编写一个自定义电子邮件 Tag Helper，以便当有人使用该 Tag Helper，即 `<email mailTo="mugil@greatestretailstore.com"></email>`
    时，它应转换为以下代码行：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The following are the steps that need to be performed to create the custom Tag
    Helper in the ASP.NET Core application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ASP.NET Core 应用程序中的自定义 Tag Helper 需要执行以下步骤。
- en: Create a folder called `TagHelper` and add a new item named the `EmailTagHelper.cs`
    file. By convention, all Tag Helpers class should end with `TagHelper` , even
    though we can override this convention.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `TagHelper` 的文件夹，并添加一个名为 `EmailTagHelper.cs` 的新项。按照惯例，所有 Tag Helper 类都应该以
    `TagHelper` 结尾，即使我们可以覆盖这个惯例。
- en: '![Creating custom Tag Helpers](img/Image00065.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义 Tag Helper](img/Image00065.jpg)'
- en: 'Once you have created the file, you will need to override the `Process` method
    to generate the desired HTML output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件后，你需要重写 `Process` 方法以生成所需的 HTML 输出：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The parameters used in the preceding code are explained as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中使用的参数解释如下：
- en: The `context` parameter will give you all the information that you supply at
    Tag Helper. For example, in the `<emailmailTo="mugil@greatestretailstore.com"></email>`
     Tag Helper, you can get the `mailTo` attribute and its associated value from
    the `context` parameter. In the first line of the preceding `Process` method,
    we will get the `mailTo` attribute value and use that value to create an attribute
    in the generated HTML (anchor tag).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context` 参数将提供你在 Tag Helper 中提供的所有信息。例如，在 `<email mailTo="mugil@greatestretailstore.com"></email>`
    Tag Helper 中，你可以从 `context` 参数中获取 `mailTo` 属性及其相关值。在前面 `Process` 方法的第一行中，我们将获取
    `mailTo` 属性值并使用该值在生成的 HTML（锚点标签）中创建一个属性。'
- en: The `output` parameter is of type `TagHelperOutput` , which is used to generate
    the desired HTML output.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output` 参数是 `TagHelperOutput` 类型，用于生成所需的 HTML 输出。'
- en: The `output.Content.SetContent`  parameter will set the text that is to be displayed
    for the anchor tag.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output.Content.SetContent` 参数将设置要显示在锚点标签中的文本。'
- en: 'We have created the e-mail Tag Helper. Now, we have to make it available to
    our Views so that we can make use of that Tag Helper in our Views. Edit `Views\_ViewImports.cshtml`
    to include the namespace of the `TagHelpers` and add the associated `TagHelpers`
    . In the following `_ViewImports.cshtml` file, we have added the content highlighted
    in bold:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了电子邮件 Tag Helper。现在，我们必须使其可用于我们的视图，以便我们可以在视图中使用该 Tag Helper。编辑 `Views_ViewImports.cshtml`
    以包含 `TagHelpers` 的命名空间并添加相关的 `TagHelpers`。在以下 `_ViewImports.cshtml` 文件中，我们已添加了加粗的内容：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The "`*` " symbol in the following line tells the view engine to include all
    the TagHelpers in the `Chapter4` namespace:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行中的 "`*`" 符号告诉视图引擎包含 `Chapter4` 命名空间中的所有 TagHelpers：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can only specific `TagHelpers` , For example, the following line will include
    only the `EmailTagHelper`  so it is available for our Views:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能指定 `TagHelpers`，例如，以下行将仅包含 `EmailTagHelper`，因此它可用于我们的视图：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s create a simple action method in our Home Controller. In the view of
    the associated action method, we will use the e-mail Tag Helper:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Home 控制器中创建一个简单的操作方法。在相关操作方法的视图中，我们将使用电子邮件 Tag Helper：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is the view of the preceding `AboutUs` action method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是前面 `AboutUs` 操作方法的视图：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When you run the application and access the `http://localhost:50132/Home/AboutUs`
    URL, you will see the following output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序并访问 `http://localhost:50132/Home/AboutUs` URL 时，你将看到以下输出：
- en: '![Creating custom Tag Helpers](img/Image00066.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义 Tag Helper](img/Image00066.jpg)'
- en: Here, we created an anchor tag with the `mailto` attribute and the email value
    as the `href` attribute value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个带有 `mailto` 属性的锚点标签，并将电子邮件值作为 `href` 属性值。
- en: I have opened the **Developer Tools** window (Press *F12* to do this and select
    the **DOM Explorer** tab) to see the generated HTML.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经打开了**开发者工具**窗口（按*F12*键进行此操作并选择**DOM资源管理器**标签页）来查看生成的HTML。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what a View engine is and how to build a View using
    the Razor view engine. We also discussed different programming constructs that
    you can make use of in Razor to produce the desired HTML output. Then, you learned
    about Layout and how to provide a consistent site structure across all of the
    pages in your ASP.NET MVC application. Later, we discussed how to promote re-usability
    using Partial Views with an example. Finally, you learned how to use Tag Helpers
    to produce clean HTML.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了什么是视图引擎以及如何使用Razor视图引擎构建视图。我们还讨论了在Razor中可以使用的不同编程结构，以生成所需的HTML输出。然后，你了解了布局以及如何在你的ASP.NET
    MVC应用程序的所有页面中提供一致的网站结构。稍后，我们通过一个示例讨论了如何使用部分视图来提高可重用性。最后，你学习了如何使用标签助手生成干净的HTML。
- en: 读累了记得休息一会哦~
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
