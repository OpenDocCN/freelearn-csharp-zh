- en: Chapter 4. Event-driven Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 事件驱动编程
- en: The `Update` events for `MonoBehaviour` objects seem to offer a convenient place
    for executing code that should perform regularly over time, spanning multiple
    frames, and possibly multiple scenes. When creating sustained behaviors over time,
    such as artificial intelligence for enemies or continuous motion, it may seem
    that there are almost no alternatives to filling an `Update` function with many
    `if` and `switch` statements, branching your code in different directions depending
    on what your objects need to do at the current time. But, when the `Update` events
    are seen this way, as a default place to implement prolonged behaviors, it can
    lead to severe performance problems for larger and more complex games. On deeper
    analysis, it's not difficult to see why this would be the case. Typically, games
    are full of so many behaviors, and there are so many things happening at once
    in any one scene that implementing them all through the `Update` functions is
    simply unfeasible. Consider the enemy characters alone, they need to know when
    the player enters and leaves their line of sight, when their health is low, when
    their ammo has expired, when they're standing on harmful terrain, when they're
    taking damage, when they're moving or not, and lots more. On thinking initially
    about this range of behaviors, it seems that all of them require constant and
    continuous attention because enemies should always know, instantly, when changes
    in these properties occur as a result of the player input. That is, perhaps, the
    main reason why the `Update` function seems to be the most suitable place in these
    situations but there are better alternatives, namely, event-driven programming.
    By seeing your game and your application in terms of events, you can make considerable
    savings in performance. This chapter then considers the issue of events and how
    to manage them game wide.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoBehaviour` 对象的 `Update` 事件似乎提供了一个方便的位置来执行应该定期执行、跨越多个帧和可能多个场景的代码。当创建需要持续一段时间的行为，例如敌人的人工智能或连续运动时，似乎没有其他替代方案，只能通过在
    `Update` 函数中填充许多 `if` 和 `switch` 语句，根据对象当前需要执行的操作将代码分支到不同的方向。但是，当以这种方式看待 `Update`
    事件，将其视为实现长期行为的默认位置时，它可能会给更大、更复杂的游戏带来严重的性能问题。在深入分析后，不难看出为什么会这样。通常，游戏中充满了许多行为，在任何单个场景中同时发生的事情也很多，通过
    `Update` 函数实现所有这些行为几乎是不切实际的。仅考虑敌人角色，它们需要知道玩家何时进入和离开它们的视线，当它们的健康值低时，当它们的弹药耗尽时，当它们站在有害地形上时，当它们受到伤害时，当它们在移动或停止移动时，以及更多。在最初思考这一系列行为时，似乎它们都需要持续和连续的关注，因为敌人应该始终能够立即知道这些属性的变化是由于玩家输入而发生的。这可能是
    `Update` 函数在这些情况下似乎是最合适的位置的主要原因，但还有更好的替代方案，即事件驱动编程。通过将你的游戏和应用程序视为事件，你可以显著提高性能。因此，本章将考虑事件的问题以及如何在游戏中管理它们。'
- en: Events
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Game worlds are fully deterministic systems; in Unity, the scene represents
    a shared 3D Cartesian space and timeline inside which finite `GameObjects` exist.
    Things only happen within this space when the game logic and code permits them
    to. For example, objects can only move when there is code somewhere that tells
    them to do so, and under specific conditions, such as when the player presses
    specific buttons on the keyboard. Notice from the example that behaviors are not
    simply random but are interconnected; objects move only when keyboard events occur.
    There is an important connection established between the actions, where one action
    entails another. These connections or linkages are referred to as events; each
    unique connection being a single event. Events are not active but passive; they
    represent moments of opportunity but not action in themselves, such as a key press,
    a mouse click, an object entering a collider volume, the player being attacked,
    and so on. These are examples of events and none of them say what the program
    should actually do, but only the kind of scenario that just happened. Event-driven
    programming starts with the recognition of events as a general concept and comes
    to see almost every circumstance in a game as an instantiation of an event; that
    is, as an event situated in time, not just an event concept but as a specific
    event that happens at a specific time. Understanding game events like these is
    helpful because all actions in a game can then be seen as direct responses to
    events as and when they happen. Specifically, events are connected to responses;
    an event happens and triggers a response. Further, the response can go on to become
    an event that triggers further responses and so on. In other words, the game world
    is a complete, integrated system of events and responses. Once the world is seen
    this way, the question then arises as to how it can help us improve performance
    over simply relying on the `Update` functions to move behaviors forward on every
    frame. And the method is simply by finding ways to reduce the frequency of events.
    Now, stated in this way, it may sound a crude strategy, but it's important. To
    illustrate, let's consider the example of an enemy character firing a weapon at
    the player during combat.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏世界是完全确定性的系统；在Unity中，场景代表一个共享的3D笛卡尔空间和时间线，其中存在有限的`GameObjects`。只有当游戏逻辑和代码允许时，事情才会在这个空间内发生。例如，只有当某处有代码告诉它们这样做，并且在特定条件下，比如玩家按下键盘上的特定按钮时，物体才能移动。从示例中可以看出，行为不是简单的随机，而是相互关联的；物体只有在键盘事件发生时才会移动。在这些动作之间建立了一个重要的联系，其中一个动作导致另一个动作。这些联系或链接被称为事件；每个独特的连接都是一个单独的事件。事件不是主动的，而是被动的；它们代表机会的时刻，但本身并不代表行动，例如按键、鼠标点击、物体进入碰撞器体积、玩家被攻击等等。这些都是事件的例子，但它们都没有说明程序实际上应该做什么，而只是刚刚发生的场景类型。事件驱动编程从将事件作为一个一般概念来认识开始，并将游戏中的几乎每一种情况都视为事件的实例化；也就是说，作为一个在特定时间发生的事件，而不仅仅是一个事件概念。理解这类游戏事件是有帮助的，因为这样就可以将游戏中的所有动作视为对事件直接且及时的响应。具体来说，事件与响应相连接；事件发生并触发响应。进一步地，响应可以继续成为触发进一步响应的事件，依此类推。换句话说，游戏世界是一个完整、集成的由事件和响应组成的系统。一旦以这种方式看待世界，接下来就会产生一个问题，那就是如何通过仅仅依赖`Update`函数在每一帧上推进行为来提高性能。而方法就是通过找到减少事件发生频率的方法。现在，这样表述可能听起来像是一种粗略的策略，但它很重要。为了说明这一点，让我们考虑一个例子，即敌人在战斗中对玩家开火的场景。
- en: 'Throughout the gameplay, the enemy will need to keep track of many properties.
    Firstly, their health, because when it runs low the enemy should seek out medical
    kits and aids to restore their health again. Secondly, their ammo, because when
    it runs low the enemy should seek to collect more and also the enemy will need
    to make reasoned judgments about when to fire at the player, such as only when
    they have a clear line of sight. Now, by simply thinking about this scenario,
    we''ve already identified some connections between actions that might be identified
    as events. But before taking this consideration further, let''s see how we might
    implement this behavior using an `Update` function, as shown in the following
    code sample 4-1\. Then, we''ll look at how events can help us improve on that
    implementation:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个游戏过程中，敌人需要跟踪许多属性。首先，他们的健康，因为当它变低时，敌人应该寻找医疗包和辅助工具来恢复他们的健康。其次，他们的弹药，因为当它变低时，敌人应该寻求收集更多，而且敌人还需要对何时向玩家开火做出合理的判断，例如只有当有清晰的视线时。现在，仅仅通过思考这个场景，我们已经确定了可能被识别为事件的动作之间的某些联系。但在进一步考虑这一点之前，让我们看看我们如何可能使用`Update`函数来实现这种行为，如下面的代码示例4-1所示。然后，我们将看看事件如何帮助我们改进这种实现：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code sample 4-1 shows a heavy `Update` function filled with lots
    of condition checking and responses. In essence, the `Update` function attempts
    to merge event handling and response behaviors into one and the results in an
    unnecessarily expensive process. If we think about the event connections between
    these different processes (the health and ammo check), we see how the code could
    be refactored more neatly. For example, ammo only changes on two occasions: when
    a weapon is fired or when new ammo is collected. Similarly, health only changes
    on two occasions: when an enemy is successfully attacked by the player or when
    an enemy collects a first-aid kit. In the first case, there is a reduction, and
    in the latter case, an increase.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例4-1展示了充满大量条件检查和响应的`Update`函数。本质上，`Update`函数试图将事件处理和响应行为合并为一个，导致了一个不必要的昂贵过程。如果我们考虑这些不同过程（如健康和弹药检查）之间的事件连接，我们可以看到代码如何被更整洁地重构。例如，弹药只在两种情况下改变：当武器被发射或当收集到新的弹药时。同样，健康也只在两种情况下改变：当玩家成功攻击敌人或当敌人收集到急救包时。在前一种情况下，会有减少，而在后一种情况下，会有增加。
- en: 'Since these are the only times when the properties change (the events), these
    are the only points where their values need to be validated. See the following
    code sample 4-2 for a refactored enemy, which includes C# properties and a much
    reduced `Update` function:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是属性变化的唯一时间（即事件），因此这些是它们值需要验证的唯一点。请参阅以下代码示例4-2，其中重构了敌人，包括C#属性和大大减少的`Update`函数：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The enemy class in the code sample 4-2 has been refactored to an event-driven
    design, where properties such as `Ammo` and `Health` are validated not inside
    the `Update` function but on assignment. From here, events are raised wherever
    appropriate based on the newly assigned values. By adopting an event-driven design,
    we introduce performance optimization and cleanness into our code; we reduce the
    excess baggage and value checks as found with the `Update` function in the code
    sample 4-1, and instead we only allow value-specific events to drive our code,
    knowing they'll be invoked only at the relevant times.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例4-2中的敌人类已经被重构为事件驱动设计，其中属性如`Ammo`和`Health`的验证不是在`Update`函数内部，而是在赋值时进行。从这里，根据新分配的值，在适当的地方引发事件。通过采用事件驱动设计，我们引入了性能优化和代码整洁性；我们减少了与代码示例4-1中的`Update`函数中发现的过剩负担和价值检查，而只允许特定值的事件驱动我们的代码，因为我们知道它们只会在相关时间被调用。
- en: Event management
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件管理
- en: 'Event-driven programming can make our lives a lot easier. But no sooner than
    we accept events into the design do we come across a string of new problems that
    require a thoroughgoing resolution. Specifically, we saw in the code sample 4-2
    how C# properties for health and ammo are used to validate and detect for relevant
    changes and then to raise events (such as `OnDead`) where appropriate. This works
    fine in principle, at least when the enemy must be notified about events that
    happen to itself. However, what if an enemy needed to know about the death of
    another enemy or needed to know when a specified number of other enemies had been
    killed? Now, of course, thinking about this specific case, we could go back to
    the enemy class in the code sample 4-2 and amend it to call an `OnDead` event
    not just for the current instance but for all other enemies using functions such
    as `SendMessage`, as we''ve seen in the previous chapters. But this doesn''t really
    solve our problem in the general sense. In fact, let''s state the ideal case straight
    away; we want every object to optionally listen for every type of event and to
    be notified about them as and when they happen, just as easily as if the event
    had happened to them. So the question that we face now is about how to code an
    optimized system to allow easy event management like this. In short, we need an
    `EventManager` class that allows objects to listen to specific events. This system
    relies on three central concepts, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程可以使我们的生活变得更加简单。但是，当我们接受事件进入设计时，我们很快就会遇到一系列需要彻底解决的新问题。具体来说，我们在代码示例4-2中看到了如何使用C#的属性来验证和检测相关变化，并在适当的时候引发事件（例如`OnDead`）。在原则上，这工作得很好，至少当敌人需要通知自己发生的事件时是这样。然而，如果敌人需要知道其他敌人的死亡，或者需要知道指定数量的其他敌人被击杀时怎么办？当然，考虑到这个具体案例，我们可以回到代码示例4-2中的敌人类，并对其进行修改，使其不仅为当前实例调用`OnDead`事件，而且为所有其他敌人调用，就像我们在前面的章节中看到的那样，使用`SendMessage`等函数。但这并没有真正解决我们的问题。事实上，让我们直接陈述理想情况；我们希望每个对象都能选择性地监听每种类型的事件，并在事件发生时得到通知，就像事件发生在它们身上一样容易。因此，我们现在面临的问题是如何编写一个优化的系统，以便轻松管理此类事件。简而言之，我们需要一个`EventManager`类，允许对象监听特定事件。这个系统依赖于以下三个核心概念：
- en: '`EventListener`: A listener refers to any object that wants to be notified
    about an event when it happens, even its own events. In practice, almost every
    object will be a listener for at least one event. An enemy, for example, may want
    notifications about low health and low ammo among others. In this case, it''s
    a listener for at least two separate events. Thus, whenever an object expects
    to be told when an event happens, it becomes a listener.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventListener`：监听器指的是任何希望在事件发生时得到通知的对象，即使是其自己的事件。在实践中，几乎每个对象都将是至少一个事件的监听器。例如，一个敌人可能希望得到有关低血量和低弹药的通知等。在这种情况下，它至少是两个单独事件的监听器。因此，每当一个对象期望在事件发生时被告知，它就变成了一个监听器。'
- en: '`EventPoster`: In contrast to listeners, when an object detects that an event
    has occurred, it must announce or post a public notification about it that allows
    all other listeners to be notified. In the code sample 4-2, the enemy class detects
    the `Ammo` and `Health` events using properties and then calls the internal events,
    if required. But to be a true poster in this sense, we require that the object
    must raise events at a global level.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventPoster`：与监听器相反，当一个对象检测到事件发生时，它必须宣布或发布一个公共通知，允许所有其他监听器得到通知。在代码示例4-2中，敌人类使用属性检测`Ammo`和`Health`事件，并在需要时调用内部事件。但为了在这个意义上成为一个真正的发布者，我们需要对象在全局级别引发事件。'
- en: '`EventManager`: Finally, there''s an overarching singleton `EventManager` object
    that persists across levels and is globally accessible. This object effectively
    links listeners to posters. It accepts notifications of events sent by posters
    and then immediately dispatches the notifications to all appropriate listeners
    in the form of events.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventManager`：最后，有一个贯穿所有级别的全局单例`EventManager`对象，它可以在不同级别之间持续存在。这个对象有效地将监听器与发布者联系起来。它接受发布者发送的事件通知，然后立即将通知以事件的形式分发给所有适当的监听器。'
- en: Starting event management with interfaces
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从接口开始事件管理
- en: The first or original entity in the event handling system is the listener—the
    thing that should be notified about specific events as and when they happen. Potentially,
    a listener could be any kind of object or any kind of class; it simply expects
    to be notified about specific events. In short, the listener will need to register
    itself with the `EventManager` as a listener for one or more specific events.
    Then, when the event actually occurs, the listener should be notified directly
    by a function call. So, technically, the listener raises a type-specificity issue
    for the `EventManager` about how the manager should invoke an event on the listener
    if the listener could potentially be an object of any type. Of course, this issue
    can be worked around, as we've seen, using either `SendMessage` or `BroadcastMessage`.
    Indeed, there are event handling systems freely available online, such as `NotificationCenter`
    that rely on these functions. However, in this chapter, we'll avoid them using
    interfaces and use polymorphism instead, as both `SendMessage` and `BroadcastMessage`
    rely heavily on reflection (information on reflection is covered later in [Chapter
    8](ch08.html "Chapter 8. Customizing the Unity Editor"), *Customizing the Unity
    Editor*). Specifically, we'll create an interface from which all listener objects
    derive.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理系统中的第一个或原始实体是监听者——当特定事件发生时，应该通知其关于这些事件的东西。潜在地，监听者可以是任何类型的对象或任何类型的类；它只是期望被通知关于特定事件。简而言之，监听者需要将自己注册到`EventManager`上，作为对一或多个特定事件的监听者。然后，当事件实际发生时，监听者应该通过函数调用直接被通知。因此，从技术上讲，监听者为`EventManager`提出了一个类型特定性问题，即如果监听者可能是任何类型的对象，那么管理者应该如何在监听者上调用事件。当然，这个问题可以通过我们看到的`SendMessage`或`BroadcastMessage`来解决。确实，网上有免费的事件处理系统，例如依赖于这些函数的`NotificationCenter`。然而，在本章中，我们将避免使用它们，而是使用接口和多态，因为`SendMessage`和`BroadcastMessage`都严重依赖于反射（反射的信息将在第8章中介绍，*自定义Unity编辑器*）。具体来说，我们将创建一个所有监听对象都将从中派生的接口。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on the freely available `NotificationCenter` (C# version) is
    available from the Unity wiki at [http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter](http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于免费可用的`NotificationCenter`（C#版本）的更多信息，可以在Unity维基上找到：[http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter](http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter)。
- en: In C#, an interface is like a hollow abstract base class. Like a class, an interface
    brings together a collection of methods and functions into a single template-like
    unit. But, unlike a class, an interface only allows you to define function prototypes
    such as the name, return type, and arguments for a function. It doesn't let you
    define a function body. The reason being that an interface simply defines the
    total set of functions that a derived class will have. The derived class may implement
    the functions however necessary, and the interface simply exists so that other
    objects can invoke the functions via polymorphism without knowing the specific
    type of each derived class. This makes interfaces a suitable candidate to create
    a `Listener` object. By defining a `Listener` interface from which all objects
    will be derived, every object has the ability to be a listener for events.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，接口就像一个空心的抽象基类。就像一个类一样，接口将一组方法和函数组合成一个类似于模板的单个单元。但是，与类不同，接口只允许你定义函数原型，例如函数的名称、返回类型和参数。它不允许你定义函数体。原因在于接口仅仅定义了派生类将拥有的全部函数集。派生类可以按需实现这些函数，而接口的存在只是为了使得其他对象可以通过多态调用这些函数，而不必知道每个派生类的具体类型。这使得接口成为创建`Listener`对象的合适候选者。通过定义一个所有对象都将从中派生的`Listener`接口，每个对象都有能力成为事件的监听者。
- en: 'The following code sample 4-3 demonstrates a sample `Listener` interface:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例4-3演示了一个示例`Listener`接口：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the comments on the code sample 4-3:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例4-3的注释：
- en: '**Lines 06-10**: This enumeration should define a complete list of all possible
    game events that could be raised. The sample code lists only five game events:
    `GAME_INIT`, `GAME_END`, `AMMO_EMPTY`, `HEALTH_CHANGE`, and `DEAD`. Your game
    will presumably have many more. You don''t actually need to use enumerations for
    encoding events; you could just use integers. But I''ve used enumerations to improve
    event readability in code.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行06-10**：此枚举应定义所有可能引发的游戏事件的完整列表。示例代码仅列出了五个游戏事件：`GAME_INIT`、`GAME_END`、`AMMO_EMPTY`、`HEALTH_CHANGE`和`DEAD`。您的游戏可能还有更多。实际上，您不需要使用枚举来编码事件；您可以直接使用整数。但我使用枚举来提高代码中事件的可读性。'
- en: '**Lines 13-17**: The `Listener` interface is defined as `IListener` using the
    C# interfaces. It supports just one event, namely `OnEvent`. This function will
    be inherited by all derived classes and will be invoked by the manager whenever
    an event occurs for which the listener is registered. Notice that `OnEvent` is
    simply a function prototype; it has no body.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行13-17**：使用C#接口定义了`Listener`接口为`IListener`。它支持一个事件，即`OnEvent`。此函数将由所有派生类继承，并在发生注册监听器的事件时由管理者调用。请注意，`OnEvent`只是一个函数原型；它没有主体。'
- en: Tip
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on C# interfaces can be found at [http://msdn.microsoft.com/en-us/library/ms173156.aspx](http://msdn.microsoft.com/en-us/library/ms173156.aspx).
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[http://msdn.microsoft.com/en-us/library/ms173156.aspx](http://msdn.microsoft.com/en-us/library/ms173156.aspx)可以找到有关C#接口的更多信息。
- en: 'Using the `IListener` interface, we now have the ability to make a listener
    from any object using only class inheritance; that is, any object can now declare
    itself as a listener and potentially receive events. For example, a new `MonoBehaviour`
    component can be turned into a listener with the following code sample 4-4\. This
    code, as in the previous chapters, uses multiple inheritance, that is, it inherits
    from two classes. More information on multiple inheritance can be found at [http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp](http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`IListener`接口，我们现在能够仅通过类继承从任何对象创建监听器；也就是说，任何对象现在都可以声明自己为监听器，并可能接收事件。例如，可以将新的`MonoBehaviour`组件通过以下代码示例4-4转换为监听器。此代码，如前几章所述，使用了多重继承，即从两个类继承。有关多重继承的更多信息，请参阅[http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp](http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp)：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating an EventManager
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个`EventManager`
- en: 'Any object can now be turned into a listener, as we''ve seen. But still the
    listeners must register themselves with a manager object of some kind. Thus, it
    is the duty of the manager to call the events on the listeners when the events
    actually happen. Let''s now turn to the manager itself and its implementation
    details. The manager class will be called `EventManager`, as shown in the following
    code sample 4-5\. This class, being a persistent singleton object, should be attached
    to an empty `GameObject` in the scene where it will be directly accessible to
    every other object through a static instance property. More on this class and
    its usage is considered in the subsequent comments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，任何对象现在都可以转换为监听器。但监听器仍然必须以某种方式向管理对象注册自己。因此，当事件实际发生时，调用监听器上的事件是管理者的责任。现在让我们转向管理者本身及其实现细节。该管理类将被命名为`EventManager`，如下面的代码示例4-5所示。作为一个持久化的单例对象，这个类应该附加到场景中的一个空`GameObject`上，这样它就可以通过静态实例属性直接被场景中的其他对象访问。关于这个类及其使用的更多信息将在后续注释中讨论：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on the `OnLevelWasLoaded` event can be found at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`OnLevelWasLoaded`事件的更多信息，请参阅[http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html)。
- en: 'The following are the comments on the code sample 4-5:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例4-5的注释：
- en: '**Line 003**: Notice the addition of the `System.Collections.Generic` namespace
    giving us access to additional mono classes, including the `Dictionary` class.
    This class will be used throughout the `EventManager` class. More information
    on mono and its classes are explained later in [Chapter 6](ch06.html "Chapter 6. Working
    with Mono"), *Working with Mono*. In short, the `Dictionary` class is a special
    kind of 2D array that allows us to store a database of values based on key-value
    pairing. More information on the `Dictionary` class can be found at [http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 003**: 注意添加了 `System.Collections.Generic` 命名空间，这使我们能够访问额外的 mono 类，包括 `Dictionary`
    类。这个类将在整个 `EventManager` 类中使用。关于 mono 及其类的更多信息将在第 6 章 [Chapter 6](ch06.html "Chapter 6. Working
    with Mono")，*Working with Mono* 中解释。简而言之，`Dictionary` 类是一种特殊的二维数组，允许我们根据键值对存储值数据库。关于
    `Dictionary` 类的更多信息可以在 [http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx)
    找到。'
- en: '**Line 007**: The `EventManager` class is derived from `MonoBehaviour` and
    should be attached to an empty `GameObject` in the scene where it will exist as
    a persistent singleton.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 007**: `EventManager` 类是从 `MonoBehaviour` 派生的，并且应该附加到场景中的一个空 `GameObject`
    上，在那里它将作为一个持久的单例存在。'
- en: '**Line 024**: A private member variable `Listeners` is declared using a `Dictionary`
    class. This structure maintains a hash-table array of key-value pairs, which can
    be looked up and searched like a database. The key-value pairing for the `EventManager`
    class takes the form of `EVENT_TYPE` and `List<Component>`. In short, this means
    that a list of event types can be stored (such as `HEALTH_CHANGE`), and for each
    type there could be none, one, or more components that are listening and which
    should be notified when the event occurs. In effect, the `Listeners` member is
    the primary data structure on which the `EventManager` relies to maintain who
    is listening for what. For more detailed information on the Mono Framework and
    common classes within it, refer to [Chapter 6](ch06.html "Chapter 6. Working with
    Mono"), *Working with Mono*.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 024**: 使用 `Dictionary` 类声明了一个私有成员变量 `Listeners`。这种结构维护了一个键值对的哈希表数组，可以像数据库一样进行查找和搜索。`EventManager`
    类的键值对形式为 `EVENT_TYPE` 和 `List<Component>`。简而言之，这意味着可以存储一系列事件类型（如 `HEALTH_CHANGE`），对于每种类型，可能有零个、一个或多个组件正在监听，并且在事件发生时应该被通知。实际上，`Listeners`
    成员是 `EventManager` 依赖的主要数据结构，用于维护谁在监听什么。有关 Mono 框架及其常见类的更详细信息，请参阅第 6 章 [Chapter
    6](ch06.html "Chapter 6. Working with Mono")，*Working with Mono*。'
- en: '**Lines 029-039**: The `Awake` function is responsible for the singleton functionality,
    that is, to make the `EventManager` class into a singleton object that persists
    across scenes. For more information on persistent singletons, refer to [Chapter
    3](ch03.html "Chapter 3. Singletons, Statics, GameObjects, and the World"), *Singletons,
    Statics, GameObjects, and the World*.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 029-039**: `Awake` 函数负责单例功能，即使 `EventManager` 类成为一个跨场景持久存在的单例对象。有关持久单例的更多信息，请参阅第
    3 章 [Chapter 3](ch03.html "Chapter 3. Singletons, Statics, GameObjects, and the
    World")，*Singletons, Statics, GameObjects, and the World*。'
- en: '**Lines 046-063**: The `AddListener` method of `EventManager` should be called
    by a `Listener` object once for each event for which it should listen. The method
    accepts two arguments: the event to listen for (`Event_Type`) and a reference
    to the listener object itself (derived from `IListener`), which should be notified
    if and when the event happens. The `AddListener` function is responsible for accessing
    the `Listeners` dictionary and generating a new key-value pair to store the connection
    between the event and the listener.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 046-063**: `EventManager` 的 `AddListener` 方法应由 `Listener` 对象为每个需要监听的事件调用一次。该方法接受两个参数：要监听的事件（`Event_Type`）和监听者对象本身的引用（从
    `IListener` 派生），如果事件发生，则应通知该对象。`AddListener` 函数负责访问 `Listeners` 字典并生成一个新的键值对来存储事件与监听者之间的连接。'
- en: '**Lines 071-088**: The `PostNotification` function can be called by any object,
    whether a listener or not, whenever an event is detected. When called, the `EventManager`
    cycles all matching entries in the dictionary, searching for all listeners connected
    to the current event, and notifies them by invoking the `OnEvent` method through
    the `IListener` interface.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 071-088**: `PostNotification` 函数可以被任何对象调用，无论是否为监听者，只要检测到事件即可。当被调用时，`EventManager`
    会遍历字典中所有匹配的条目，寻找与当前事件连接的所有监听者，并通过 `IListener` 接口调用 `OnEvent` 方法来通知他们。'
- en: '**Lines 098-127**: The final methods for the `EventManager` class are responsible
    for maintaining data integrity of the `Listeners` structure when a scene change
    occurs and the `EventManager` class persists. Although the `EventManager` class
    persists across scenes, the listener objects themselves in the `Listeners` variable
    may not do so. They may get destroyed on scene changes. If so, scene changes will
    invalidate some listeners, leaving the `EventManager` with invalid entries. Thus,
    the `RemoveRedundancies` method is called to find and eliminate all invalid entries.
    The `OnLevelWasLoaded` event is invoked automatically by Unity whenever a scene
    change occurs.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 098-127 行**: `EventManager` 类的最终方法负责在场景变化时保持 `Listeners` 结构的数据完整性，并且当 `EventManager`
    类持续存在时。尽管 `EventManager` 类在场景之间持续存在，但 `Listeners` 变量中的监听器对象可能不会持续存在。它们可能在场景变化时被销毁。如果是这样，场景变化将使一些监听器无效，留下
    `EventManager` 中无效的条目。因此，调用 `RemoveRedundancies` 方法来查找并消除所有无效条目。Unity 在每次场景变化时都会自动调用
    `OnLevelWasLoaded` 事件。'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Dictionaries**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典**'
- en: The great thing about dictionaries is not just their access speed as a dynamic
    array (which is comparatively fast) but also the way you work with them through
    object types and the array subscript operator. In a typical array, every element
    must be accessed by its numerical and integer index, such as `MyArray[0]` and
    `MyArray[1]`. But with dictionaries, the case is different. Specifically, you
    can access elements using objects of `EVENT_TYPE`, which represents the key part
    of the key-value pair, for example, `MyArray[EVENT_TYPE.HEALTH_CHANGE]`. For more
    information on dictionaries, see the official Microsoft documentation at [http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的伟大之处不仅在于它们作为动态数组的访问速度（这相对较快），还在于您通过对象类型和数组索引操作符与它们交互的方式。在典型的数组中，每个元素必须通过其数值和整数索引来访问，例如
    `MyArray[0]` 和 `MyArray[1]`。但与字典不同。具体来说，您可以使用代表键值对键部分的 `EVENT_TYPE` 对象来访问元素，例如
    `MyArray[EVENT_TYPE.HEALTH_CHANGE]`。有关字典的更多信息，请参阅 Microsoft 官方文档[http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx)。
- en: 'Code folding in MonoDevelop with #region and #endregion'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '使用 #region 和 #endregion 在 MonoDevelop 中进行代码折叠'
- en: 'The two preprocessor directives `#region` and `#endregion` (in combination
    with the code folding feature) can be highly useful for improving the readability
    of your code and also for improving the speed with which you can navigate the
    source file. They add organization and structure to your source code without affecting
    its validity or execution. Effectively, `#region` marks the top of a code block
    and `#endregion` marks the end. Once a region is marked, it becomes foldable,
    that is, it becomes collapsible using the `MonoDevelop` code editor, provided
    the code folding feature is enabled. Collapsing a region of code is useful for
    hiding it from view, which allows you to concentrate on reading other areas relevant
    to your needs, as shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 两个预处理器指令 `#region` 和 `#endregion`（与代码折叠功能结合使用）对于提高代码的可读性和提高导航源文件的速度非常有用。它们在不影响代码的有效性或执行的情况下为源代码添加组织和结构。实际上，`#region`
    标记代码块的顶部，而 `#endregion` 标记其结束。一旦标记了一个区域，它就变得可折叠，也就是说，可以使用 `MonoDevelop` 代码编辑器将其折叠，前提是启用了代码折叠功能。折叠代码区域对于隐藏它以供查看非常有用，这允许您集中精力阅读与您的需求相关的其他区域，如下面的截图所示：
- en: '![Code folding in MonoDevelop with #region and #endregion](img/0655OT_04_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![MonoDevelop 中的 #region 和 #endregion 代码折叠](img/0655OT_04_01.jpg)'
- en: Enabling code folding in MonoDevelop
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中启用代码折叠
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To enable code folding in `MonoDevelop`, select **Options** in **Tools** from
    the application menu. This displays the **Options** window. From here, choose
    the **General** tab in the **Text Editor** option and click on **Enable code folding**
    as well as **Fold #regions by default**.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '要在 MonoDevelop 中启用代码折叠，从应用程序菜单中选择 **工具** 中的 **选项**。这会显示 **选项** 窗口。从这里，在 **文本编辑器**
    选项中选择 **通用** 选项卡，并点击 **启用代码折叠** 以及 **默认折叠 #region**。'
- en: Using EventManager
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件管理器
- en: 'Now, let''s see how to put the `EventManager` class to work in a practical
    context from the perspective of listeners and posters in a single scene. First,
    to listen for an event (any event) a listener must register itself with the `EventManager`
    singleton instance. Typically, this will happen once and at the earliest opportunity,
    such as the `Start` function. Do not use the `Awake` function; this is reserved
    for an object''s internal initialization as opposed to the functionality that
    reaches out beyond the current object to the states and setup of others. See the
    following code sample 4-6 and notice that it relies on the `Instance` static property
    to retrieve a reference to the active `EventManager` singleton:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从单个场景中的监听者和发布者的角度，看看如何在实际环境中使用`EventManager`类。首先，为了监听一个事件（任何事件），监听者必须将自己注册到`EventManager`单例实例中。通常，这将在最早的机会发生，比如`Start`函数。不要使用`Awake`函数；这个函数是为对象的内部初始化保留的，而不是指向当前对象之外的功能，比如其他对象的状态和设置。查看以下代码示例4-6，注意它依赖于`Instance`静态属性来检索活动`EventManager`单例的引用：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Having registered listeners for one or more events, objects can then post notifications
    to `EventManager` as events are detected, as shown in the following code sample
    4-7:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册了一个或多个事件的监听者之后，对象可以在检测到事件时向`EventManager`发布通知，如下面的代码示例4-7所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, after a notification is posted for an event, all the associated listeners
    are updated automatically through `EventManager`. Specifically, `EventManager`
    will call the `OnEvent` function of each listener, giving listeners the opportunity
    to parse event data and respond where needed, as shown in the following code sample
    4-8:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在为事件发布通知之后，所有相关的监听者将通过`EventManager`自动更新。具体来说，`EventManager`将调用每个监听者的`OnEvent`函数，给监听者提供解析事件数据和响应所需的机会，如下面的代码示例4-8所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a demonstration on using `EventManager`, see the `events` folder project
    in the code bundle of this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用`EventManager`的演示，请参阅本章代码包中的`events`文件夹项目。
- en: Alternative with delegates
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托的替代方案
- en: 'Interfaces are an efficient and trim way of implementing an event handling
    system, but they are not the only way. We can also use a C# feature, known as
    delegates. Essentially, we can create a function and store a reference to it inside
    a variable. This variable allows you to treat functions as a reference type variable.
    That is, with delegates, you can store references to functions, which can then
    be used later to invoke the function itself. Other languages, such as C++, offer
    a similar behavior through function pointers. By implementing the event system
    using delegates, we eliminate the need for interfaces. Consider the following
    code sample 4-7, which is an alternative implementation of `EventManager` using
    delegates. Relevant code changes are highlighted to help illustrate the differences
    between the interface and delegate implementations. Apart from minor changes to
    accommodate the delegate types, all other functions remained unchanged, as shown
    here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是实现事件处理系统的有效且简洁的方式，但并非唯一的方式。我们还可以使用C#的一个特性，称为委托。本质上，我们可以在变量中创建一个函数并存储对其的引用。这个变量允许你将函数视为引用类型变量。也就是说，使用委托，你可以存储函数的引用，稍后可以用来调用该函数本身。其他语言，如C++，通过函数指针提供类似的行为。通过使用委托实现事件系统，我们消除了接口的需求。考虑以下代码示例4-7，这是使用委托的`EventManager`的替代实现。相关的代码更改被突出显示，以帮助说明接口和委托实现之间的差异。除了对委托类型的微小更改外，所有其他函数保持不变，如下所示：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on C# delegates can be found in the Microsoft documentation
    at [http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx](http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C#委托的更多信息，可以在微软文档中找到，网址为[http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx](http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx)。
- en: 'The following are the comments on the code sample 4-7:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例4-7的注释：
- en: '**Lines 005-011**: Here, the event type enumeration has been shifted into the
    `EventManager` file from the original `IListener` class. Since the delegate implementation
    avoids the need for interfaces and for `IListener` specifically, the enumeration
    can be shifted to the manager source file.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 005-011**：在这里，事件类型枚举已经从原始的`IListener`类移动到了`EventManager`文件中。由于委托实现避免了接口的需求，特别是对于`IListener`，枚举可以被移动到管理源文件中。'
- en: '**Line 032**: The public member `OnEvent` is declared as a delegate type. Notice
    that the declaration is hybrid insofar as it combines variable declaration style
    with a function prototype. This specifies the function prototype that may be assigned
    to the delegate variable; any function with that structure can be assigned from
    any class or any script file. Thus, the `OnEvent` function becomes a delegate
    type, and this is used in the next statement creating the internal dictionary.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 032 行**：公共成员 `OnEvent` 被声明为代表类型。注意，声明是混合的，因为它结合了变量声明风格和函数原型。这指定了可以分配给代表变量的函数原型；任何具有该结构的函数都可以从任何类或任何脚本文件中分配。因此，`OnEvent`
    函数成为了一个代表类型，并在创建内部字典的下一条语句中使用。'
- en: '**Line 035**: The private dictionary listeners is declared, and for each event
    type, an array of delegates (instead of interfaces) is stored; each delegate refers
    to a function that should be invoked when the event occurs.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 035 行**：声明了私有字典监听器，并且对于每种事件类型，存储了一个代表（而不是接口）的数组；每个代表指向一个在事件发生时应被调用的函数。'
- en: '**Line 097**: Critically, the `PostNotification` function is called on `EventManager`
    to invoke all the delegates (listener functions) when an event occurs. This happens
    at line 097 with the statement `ListenList[i](Event_Type, Sender, Param);`. This
    invokes the delegate just like a function, as shown in the following screenshot:![Alternative
    with delegates](img/0655OT_04_02.jpg)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 097 行**：关键的是，在 `EventManager` 上调用 `PostNotification` 函数来在事件发生时调用所有代表（监听函数）。这发生在第
    097 行的语句 `ListenList[i](Event_Type, Sender, Param);` 中。这就像调用函数一样调用代表，如下面的截图所示：![使用代表的替代方案](img/0655OT_04_02.jpg)'
- en: Exploring the EventManager projects
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 探索 EventManager 项目
- en: The preceding screenshot shows the `EventManager` projects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了 `EventManager` 项目。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To see the `EventManager` delegate implementation in action, see the `events_delgateversion`
    folder project in code bundle of this chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `EventManager` 代表实现的实际应用，请参阅本章代码包中的 `events_delgateversion` 文件夹项目。
- en: MonoBehaviour events
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MonoBehaviour 事件
- en: To close this chapter, let's consider some of the events Unity offers us already
    for working with event-driven programming. The `MonoBehaviour` class already exposes
    a wide range of events that are called automatically under specific conditions.
    These functions or events begin with the prefix `On` and include events such as
    `OnGUI`, `OnMouseEnter`, `OnMouseDown`, `OnParticleCollision`, and others. This
    section considers some details for common event types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，让我们考虑一些 Unity 已经为我们提供的用于事件驱动编程的事件。`MonoBehaviour` 类已经公开了一系列在特定条件下自动调用的事件。这些函数或事件以
    `On` 前缀开始，包括 `OnGUI`、`OnMouseEnter`、`OnMouseDown`、`OnParticleCollision` 等事件。本节考虑了一些常见事件类型的细节。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The full list of `MonoBehaviour` events can be found in the Unity documentation
    at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoBehaviour` 事件的完整列表可以在 Unity 文档中找到，链接为 [http://docs.unity3d.com/ScriptReference/MonoBehaviour.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.html)。'
- en: Mouse and tap events
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标和触摸事件
- en: One set of useful events is the mouse-input and touch-input set of events. These
    include `OnMouseDown`, `OnMouseEnter`, and `OnMouseExit`. In the earlier versions
    of Unity, these events were only triggered for mouse-specific events and not touch
    input. But more recently, touch input has been mapped to them; meaning that a
    tap will now register by default as a mouse event. To clarify, `OnMouseDown` is
    called once when a mouse button is pressed down while the cursor is hovering on
    an object. The event is not, however, called repeatedly until the button is released.
    Likewise, `OnMouseEnter` is called once when a cursor first hovers over an object
    without having exited and `OnMouseExit` is called when the cursor hovers away
    from an object it has previously entered. The success of these events depends
    on an object having a collider component attached to approximate its volume within
    which mouse events are detected. This means that none of the mouse events will
    fire without a collider attached to the object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一组有用的事件是鼠标输入和触摸输入事件集。这些包括`OnMouseDown`、`OnMouseEnter`和`OnMouseExit`。在Unity的早期版本中，这些事件仅针对鼠标特定事件触发，而不是触摸输入。但最近，触摸输入已经映射到它们；这意味着点击现在默认注册为鼠标事件。为了澄清，`OnMouseDown`在鼠标按钮按下且光标悬停在对象上时调用一次。然而，事件不会在按钮释放之前重复调用。同样，`OnMouseEnter`在光标第一次悬停在对象上且未退出时调用一次，而`OnMouseExit`在光标从之前进入的对象上移开时调用。这些事件的成功取决于对象是否附加了碰撞器组件，以近似其体积，其中检测鼠标事件。这意味着如果没有对象附加了碰撞器，则不会触发任何鼠标事件。
- en: However, there are occasions when `MouseEvents` will not fire, even with a collider
    attached, because other objects (with colliders) are obscuring the objects you
    need to click on based on the current view from the active camera. That is, the
    clickable objects are in the background. You can, of course, solve the issue (at
    least in many cases) by simply assigning the foreground objects to an `IgnoreRaycast`
    layer making them immune from physics raycast operations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时即使附加了碰撞器，`MouseEvents`也不会触发，因为其他对象（具有碰撞器）会遮挡你根据当前视图从活动相机需要点击的对象。也就是说，可点击的对象在背景中。当然，你可以通过简单地将前景对象分配到`IgnoreRaycast`层来解决这个问题（至少在许多情况下），使它们免受物理射线投射操作的影响。
- en: 'To assign an object to an `IgnoreRaycast` layer, just select the object in
    the scene and then click on the **Layer** dropdown in the Object Inspector, assigning
    the object to the **Ignore Raycast** layer, as shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要将对象分配到`IgnoreRaycast`层，只需在场景中选择对象，然后点击对象检查器中的**层**下拉菜单，将对象分配到**忽略射线投射**层，如下面的截图所示：
- en: '![Mouse and tap events](img/0655OT_04_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![鼠标和点击事件](img/0655OT_04_03.jpg)'
- en: Assigning objects to the Ignore Raycast layer
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象分配到忽略射线投射层
- en: 'But even this just isn''t feasible sometimes. Often you''ll need multiple cameras
    and many objects with colliders, and they''ll sometimes obscure objects you want
    to select or adjust according to mouse input events. In these cases, you may need
    to manually handle mouse input events. The following code sample 4-8 achieves
    these, invoking specific mouse events manually on the basis of input. In essence,
    this code uses the `Raycast` system to redirect manually detected input events
    to the `MonoBehaviour` mouse events. This code uses **Coroutines** too; considered
    after the code sample:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时这并不可行。通常你需要多个相机和许多具有碰撞器的对象，它们有时会遮挡你想要选择或根据鼠标输入事件调整的对象。在这些情况下，你可能需要手动处理鼠标输入事件。以下代码示例4-8实现了这些功能，根据输入手动调用特定的鼠标事件。本质上，此代码使用`Raycast`系统将手动检测到的输入事件重定向到`MonoBehaviour`鼠标事件。此代码还使用了**协程**；在代码示例之后考虑：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Coroutines**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**协程**'
- en: Coroutines are a special kind of function. They behave like threads insofar
    as they appear to run in parallel or asynchronously to the main game loop, that
    is, once you execute them, they seem to run in the background. Execution doesn't
    pause or wait until the function is completed as it does with traditional functions.
    This makes Coroutines great for creating asynchronous-looking behaviors. Technically,
    all Coroutines must return a type of `IEnumerator`, contain at least one yield
    statement in their body, and must be launched with the `StartCoroutine` function.
    The yield statement is a special statement that suspends execution of the Coroutine
    until its condition is met. The statement yield return new `WaitForSeconds(x)`
    will pause execution for `x` seconds, resuming after the interval at the next
    line. In contrast, the statement yield returned `null` will suspend execution
    for the current frame, resuming execution at the next line on the next frame.
    More information on Coroutines and their use can be found in the Unity documentation
    at [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种特殊类型的函数。它们的行为类似于线程，因为它们似乎与主游戏循环并行或异步运行，也就是说，一旦执行它们，它们似乎在后台运行。执行不会暂停或等待函数完成，就像传统函数那样。这使得协程非常适合创建看起来异步的行为。技术上，所有协程都必须返回
    `IEnumerator` 类型，其体中至少包含一个 yield 语句，并且必须使用 `StartCoroutine` 函数启动。yield 语句是一个特殊语句，它将协程的执行挂起，直到满足其条件。语句
    `yield return new WaitForSeconds(x)` 将暂停执行 `x` 秒，在间隔后从下一行恢复。相比之下，语句 `yield return
    null` 将暂停当前帧的执行，在下一帧的下一行恢复执行。有关协程及其使用的更多信息，请参阅 Unity 文档中的 [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html)。
- en: Application focus and pausing
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用焦点和暂停
- en: 'Three additional `MonoBehaviour` events are notable for causing confusion or
    surprise about their operation. They are: `OnApplicationPause`, `OnApplicationFocus`,
    and `OnApplicationQuit`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 三种额外的 `MonoBehaviour` 事件因其操作而引起混淆或惊讶。它们是：`OnApplicationPause`、`OnApplicationFocus`
    和 `OnApplicationQuit`。
- en: '`OnApplicationQuit` is sent to all objects in the scene just before the game
    exits but before the scene and its contents are effectively destroyed. If the
    game is being tested in the editor, then `OnApplicationQuit` is called when playback
    is stopped. Significantly, however, `OnApplicationQuit` may not be called for
    iOS devices, which usually don''t quit or exit applications but rather suspend
    them while users do other things, which allows them to return and resume from
    where they left off. If you need or want to receive `OnApplicationQuit` events
    on suspension, you''ll need to enable the relevant option from the **Player Settings**
    window. To access this, navigate to **Edit** | **Project Settings** | **Player**
    from the application menu and then from the Object Inspector, expand the **Other
    Settings** tab for the iOS builds and enable the **Exit on Suspend** checkbox,
    as shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnApplicationQuit` 事件在游戏退出之前发送到场景中的所有对象，但在场景及其内容被有效销毁之前。如果在编辑器中测试游戏，则在播放停止时调用
    `OnApplicationQuit`。然而，值得注意的是，对于 iOS 设备，`OnApplicationQuit` 可能不会被调用，因为 iOS 设备通常不会退出或退出应用程序，而是将它们挂起，以便用户做其他事情，这允许他们返回并从离开的地方继续。如果您需要在挂起时接收
    `OnApplicationQuit` 事件，您需要从 **Player Settings** 窗口中启用相关选项。要访问此选项，从应用程序菜单导航到 **Edit**
    | **Project Settings** | **Player**，然后从对象检查器中展开 **Other Settings** 选项卡，为 iOS 构建启用
    **Exit on Suspend** 复选框，如图所示：'
- en: '![Application focus and pausing](img/0655OT_04_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![应用焦点和暂停](img/0655OT_04_04.jpg)'
- en: Enabling the exit on suspend option for iOS
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 iOS 的挂起时退出选项
- en: '`OnApplicationFocus` is an event sent to all objects in the scene when the
    game loses focus, typically when the game window is deactivated on desktop computers
    during multitask operations. This can be a significant in-game event, especially
    for multiplayer games where action and events in a shared world continue, even
    when one or more of the players are not actively participating. In these cases,
    you may need to pause or resume specific behaviors or fade-in or fade-out game
    music.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnApplicationFocus` 是在游戏失去焦点时发送到场景中所有对象的事件，通常在桌面计算机上的多任务操作中游戏窗口被停用时。这可以是一个重要的游戏事件，尤其是在多人游戏中，即使一个或多个玩家没有积极参与，共享世界中的动作和事件也会继续。在这些情况下，您可能需要暂停或恢复特定的行为或淡入或淡出游戏音乐。'
- en: '`OnApplicationPause` is an ambiguous event because the concept of a pause in
    Unity is not clearly defined. There are, I believe, two distinct kinds of pauses,
    namely, an ultimate and relative pause. The ultimate kind is where every activity
    and every event in a game is totally suspended; in this state, there is no passing
    of time and nothing can move forward. The relative kind, in contrast, is the most
    common. Here, the game is self-conscious or aware of being in a paused state;
    it halts some events, such as in-world events, but allows other events to continue
    such as GUI interaction and user input, which can unpause the game. The `OnApplicationPause`
    event refers to the first kind of pause and not the latter. This event will be
    called when several conditions are met. These are considered in the next sections.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnApplicationPause`是一个模糊的事件，因为Unity中暂停的概念并没有明确定义。我相信，存在两种不同的暂停类型，即最终暂停和相对暂停。最终暂停是指游戏中每个活动和每个事件都被完全暂停；在这种状态下，时间不会流逝，什么都不能前进。相对暂停则相反，是最常见的一种。在这种情况下，游戏是自我意识或意识到处于暂停状态的；它暂停了一些事件，例如世界内的事件，但允许其他事件继续，例如GUI交互和用户输入，这可以取消暂停游戏。`OnApplicationPause`事件指的是第一种暂停，而不是后者。当满足几个条件时，此事件将被调用。这些条件将在下一节中讨论。'
- en: First, `OnApplicationPause` will only be called on the desktop if the **Run
    In Background** option is not enabled in the **Player Settings** tab, under the
    **Resolution** group, as shown in the following screenshot. This option, when
    disabled, will automatically pause a desktop game whenever the window focus is
    lost. This means `OnApplicationPause` will follow an `OnApplicationFocus` event.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果**“在后台运行”**选项在**“玩家设置”**标签页下的**“分辨率”**组中未启用，则`OnApplicationPause`仅在桌面版上被调用。此选项禁用时，桌面游戏将在窗口失去焦点时自动暂停。这意味着`OnApplicationPause`将遵循`OnApplicationFocus`事件。
- en: '![Application focus and pausing](img/0655OT_04_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序焦点和暂停](img/0655OT_04_05.jpg)'
- en: Disabling the Run In Background option
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用“在后台运行”选项
- en: In iOS, `OnApplicationPause` will be called whenever the application is minimized
    or pushed into the background.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS中，每当应用被最小化或推入后台时，都会调用`OnApplicationPause`。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not rely on the `OnApplicationPause` event for creating your own relative
    pause functionality. To achieve this, use the `Time.timeScale` variable or code
    a more comprehensive system in which you have selective control over which elements
    are paused.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不要依赖于`OnApplicationPause`事件来创建自己的相对暂停功能。为了实现这一点，请使用`Time.timeScale`变量或编写一个更全面的系统，在该系统中您可以有选择地控制哪些元素被暂停。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on the manifold benefits available for your applications
    by adopting an event-driven framework consistently through the `EventManager`
    class. In implementing such a manager, we were able to rely on either interfaces
    or delegates, and either method is powerful and extensible. Specifically, we saw
    how it's easy to add more and more functionality into an `Update` function but
    how doing this can lead to severe performance issues. Better is to analyze the
    connections between your functionality to refactor it into an event-driven framework.
    Essentially, events are the raw material of event-driven systems. They represent
    a necessary connection between one action (the cause) and another (the response).
    To manage events, we created the `EventManager` class—an integrated class or system
    that links posters to listeners. It receives notifications from posters about
    events as and when they happen and then immediately dispatches a function call
    to all listeners for the event. In the next chapter, we'll examine cameras and
    rendering.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了通过一致地通过`EventManager`类采用事件驱动框架，为您的应用程序提供的多种好处。在实现此类管理器时，我们能够依赖于接口或委托，并且两种方法都很强大且可扩展。具体来说，我们看到了如何轻松地将更多功能添加到`Update`函数中，但这样做可能会导致严重的性能问题。更好的做法是分析功能之间的联系，将其重构为事件驱动框架。本质上，事件是事件驱动系统的原材料。它们代表了一个动作（原因）与另一个动作（反应）之间的必要联系。为了管理事件，我们创建了`EventManager`类——一个将发布者与听众链接的集成类或系统。它接收发布者关于事件的即时通知，然后立即向所有听众发出事件函数调用。在下一章中，我们将检查相机和渲染。
