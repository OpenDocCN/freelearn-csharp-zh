- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to WinUI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WinUI简介
- en: '**WinUI 3** is a set of **user interface** (**UI**) controls and libraries
    that Windows developers can leverage in their desktop applications. It is the
    UI part of the Windows App SDK, which was previously known as **Project Reunion**.
    UWP developers use the **Windows Software Development Kit** (**Windows SDK**)
    to build their applications and are required to select a target SDK version in
    a project’s properties. By extracting the UWP controls and UI components from
    the Windows SDK, rewriting them for use with .NET, and releasing them as a set
    of libraries in the **Windows App SDK** under the name WinUI, Microsoft has been
    able to release versions at a faster cadence than Windows itself (as Windows SDK
    versions are linked to those of Windows). This separation also enables the controls
    to be used on older versions of Windows 10\. While building desktop applications
    with WinUI is the current recommendation, it is important to learn where WinUI
    and the Windows App SDK fit into the larger Windows development landscape.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**WinUI 3**是一套**用户界面**（**UI**）控件和库，Windows开发者可以在他们的桌面应用程序中使用。它是Windows App
    SDK的UI部分，之前被称为**Project Reunion**。UWP开发者使用**Windows软件开发工具包**（**Windows SDK**）来构建他们的应用程序，并在项目属性中必须选择一个目标SDK版本。通过从Windows
    SDK中提取UWP控件和UI组件，为.NET使用重写它们，并以WinUI的名称在**Windows App SDK**中作为一系列库发布，微软能够以比Windows本身更快的节奏发布版本（因为Windows
    SDK版本与Windows版本相关联）。这种分离还使得控件可以在较旧的Windows 10版本上使用。虽然使用WinUI构建桌面应用程序是当前的建议，但了解WinUI和Windows
    App SDK在更大的Windows开发领域中的位置是很重要的。'
- en: In this book, you will learn how to build applications for Windows with the
    WinUI 3 libraries. Throughout the course of the book, we will build a real-world
    application using the recommended patterns and practices for Windows application
    development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将学习如何使用WinUI 3库为Windows构建应用程序。在整个书籍的过程中，我们将使用推荐的Windows应用程序开发模式和最佳实践构建一个真实世界的应用程序。
- en: Before we start building our WinUI app, it’s important to have a good foundation
    in Windows client development, the different types of **Extensible Application
    Markup Language** (**XAML**) UI markup, and how WinUI compares to other Windows
    desktop development frameworks. Therefore, in this first chapter, you will start
    by learning some background on UWP and WinUI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建WinUI应用程序之前，了解Windows客户端开发、不同类型的**可扩展应用程序标记语言**（**XAML**）UI标记以及WinUI与其他Windows桌面开发框架的比较是很重要的。因此，在本章的第一部分，你将开始学习有关UWP和WinUI的一些背景知识。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: What UWP is and why Microsoft created yet another application framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UWP是什么以及为什么微软又创建了一个新的应用程序框架
- en: How XAML can be leveraged to create great UIs on many device sizes and families
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用XAML在多种设备和设备系列上创建出色的UI
- en: Why WinUI was created and how it relates to UWP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么创建WinUI以及它与UWP的关系
- en: Where WinUI fits into the Windows developer landscape
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinUI在Windows开发者领域中的位置
- en: What WinUI 3 brings to the table
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinUI 3带来了什么
- en: Don’t worry! It won’t take very long to cover the background stuff, and it will
    help provide some context as you start building your WinUI app. In the next chapter,
    you will get your hands on some code when you create your first WinUI project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心！覆盖背景知识不会花费很长时间，这将在你开始构建WinUI应用程序时提供一些上下文。在下一章中，当你创建你的第一个WinUI项目时，你将有机会接触一些代码。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    required:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，需要以下软件：
- en: Windows 10 version 1809 or later or Windows 11\. You can find your version of
    Windows in **Settings** | **About**.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10版本1809或更高版本或Windows 11。您可以在**设置** | **关于**中找到您的Windows版本。
- en: 'Visual Studio 2022 version 17.0 or later with the following workload: .NET
    Desktop Development. On the **Installation details** tab of the **Visual Studio
    Installer**, ensure that **Windows App SDK C# Templates** is selected.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要安装Visual Studio 2022版本17.0或更高版本，并包含以下工作负载：.NET桌面开发。在**Visual Studio安装程序**的**安装详情**选项卡中，确保已选择**Windows
    App SDK C#模板**。
- en: 'The source code for this chapter is available on GitHub at this URL: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter01).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在GitHub上通过以下网址获取：[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter01)。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Windows App SDK site on Microsoft Learn has up-to-date guidance on setting
    up a developer workstation for WinUI 3 development: [https://learn.microsoft.com/windows/apps/windows-app-sdk/set-up-your-development-environment](https://learn.microsoft.com/windows/apps/windows-app-sdk/set-up-your-development-environment).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Learn 上的 Windows App SDK 网站提供了关于设置 WinUI 3 开发开发工作站的最新指南：[https://learn.microsoft.com/windows/apps/windows-app-sdk/set-up-your-development-environment](https://learn.microsoft.com/windows/apps/windows-app-sdk/set-up-your-development-environment)。
- en: Before UWP – Windows 8 XAML applications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 UWP 之前 – Windows 8 XAML 应用程序
- en: Before UWP applications were launched with Windows 10 in 2015, there were XAML
    applications for Windows 8 and 8.1\. The XAML syntax and many of the **application
    programming interfaces** (**APIs**) were the same, and they were Microsoft’s next
    step to achieve universal app development across desktop, mobile, and other platforms
    (Xbox, mixed reality, and so on). A XAML app could be written for Windows 8 and
    Windows Phone. These projects would generate separate sets of binaries that could
    be installed on a PC or a Windows Phone.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2015 年 Windows 10 发布之前，Windows 8 和 8.1 有 XAML 应用程序。XAML 语法以及许多**应用程序编程接口**（**API**）是相同的，并且这是微软实现跨桌面、移动和其他平台（Xbox、混合现实等）通用应用程序开发的下一步。可以为
    Windows 8 和 Windows Phone 编写 XAML 应用程序。这些项目会生成可以在 PC 或 Windows Phone 上安装的独立二进制文件集。
- en: 'These apps had many other limitations that modern UWP apps do not. For instance,
    they only ran full-screen, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序还有许多其他限制，而现代 UWP 应用则没有。例如，它们只能全屏运行，如下面的截图所示：
- en: '![Figure 1.1 – Windows 8 full-screen app (sourced from Stack Overflow; reproduced
    under CC BY-SA 4.0 – https://creativecommons.org/licenses/by-sa/4.0/)](img/B20908_01_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – Windows 8 全屏应用（来源：Stack Overflow；根据 CC BY-SA 4.0 复制 – https://creativecommons.org/licenses/by-sa/4.0/）](img/B20908_01_01.jpg)'
- en: Figure 1.1 – Windows 8 full-screen app (sourced from Stack Overflow; reproduced
    under CC BY-SA 4.0 – https://creativecommons.org/licenses/by-sa/4.0/)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Windows 8 全屏应用（来源：Stack Overflow；根据 CC BY-SA 4.0 复制 – https://creativecommons.org/licenses/by-sa/4.0/）
- en: 'Many other early restrictions on Windows 8 apps have been lessened or completely
    removed in UWP app development. *Figure 1**.2*, which follows, documents these
    changes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UWP 应用程序开发中，许多对 Windows 8 应用的早期限制已经减少或完全取消。下述**图 1.2**记录了这些变化：
- en: '![Figure 1.2 – Windows 8 and Windows 10 app comparison table](img/B20908_01_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – Windows 8 和 Windows 10 应用比较表](img/B20908_01_02.jpg)'
- en: Figure 1.2 – Windows 8 and Windows 10 app comparison table
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Windows 8 和 Windows 10 应用比较表
- en: Windows application UI design
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 应用程序 UI 设计
- en: The term *Metro style* was used to define the design and layout of Windows 8
    apps. Metro style apps were designed to be usable with touch input, a mouse and
    keyboard, or a stylus. Microsoft’s introduction of the first Windows Phone was
    a driving factor for Metro style design. Metro style later became Modern UI design,
    with the introduction of Surface devices. Aspects of Metro live on today in UWP
    apps and Windows 10.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**Metro 风格**用于定义 Windows 8 应用的设计和布局。Metro 风格应用程序旨在支持触摸输入、鼠标和键盘或触控笔。微软推出首款
    Windows Phone 是推动 Metro 风格设计的一个关键因素。随着 Surface 设备的推出，Metro 风格后来演变为现代 UI 设计。Metro
    的某些方面至今仍存在于 UWP 应用和 Windows 10 中。
- en: Live Tiles were born with Metro Style. These tiles on the user’s Windows 8 home
    screen and Windows 10 Start menu can update to display live updates to users without
    having to open the app. Most of Microsoft’s own apps for Windows 10 supported
    Live Tiles. The Weather app could show live updates to current weather conditions
    on the tile, based on the user’s current location. Live tiles are no longer part
    of the operating system in Windows 11\. They have been replaced by widgets, which
    app developers can also create. We will discuss widgets further in [*Chapter 5*](B20908_05.xhtml#_idTextAnchor114),
    *Exploring* *WinUI Controls*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Live Tiles 与 Metro 风格一同诞生。这些在用户 Windows 8 主屏幕和 Windows 10 开始菜单上的瓷砖可以更新以显示实时更新，而无需打开应用程序。大多数微软自己的
    Windows 10 应用程序都支持 Live Tiles。天气应用程序可以根据用户的当前位置在瓷砖上显示当前的天气状况更新。在 Windows 11 中，Live
    Tiles 已不再是操作系统的组成部分。它们已被小部件取代，应用程序开发者也可以创建小部件。我们将在[*第 5 章*](B20908_05.xhtml#_idTextAnchor114)“探索
    WinUI 控件”中进一步讨论小部件。
- en: Windows Runtime (WinRT)
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 运行时（WinRT）
- en: Another term that has its roots in Windows 8 app development is **WinRT**. The
    letters RT became a source of great confusion. WinRT was short for **Windows Runtime**,
    the underlying APIs used by Windows XAML apps. There was also a version of Windows
    8 called Windows RT that supported Arm processors. The first Surface PC was the
    Surface RT, which ran the Windows 8 RT operating system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个根植于 Windows 8 应用程序开发的术语是 **WinRT**。RT 字母引起了很多混淆。WinRT 是 **Windows Runtime**
    的缩写，它是 Windows XAML 应用使用的底层 API。还有一个名为 Windows RT 的 Windows 8 版本，它支持 Arm 处理器。第一台
    Surface PC 是 Surface RT，它运行 Windows 8 RT 操作系统。
- en: Although WinRT can still be used today to define the WinRT APIs consumed by
    UWP apps, you will not see the term as often. We will also avoid using WinRT in
    this book and instead refer to the APIs as the UWP or Windows APIs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管WinRT今天仍然可以用来定义 UWP 应用消耗的 WinRT API，但你不会经常看到这个术语。我们也将避免在这本书中使用 WinRT，而是将 API
    称为 UWP 或 Windows API。
- en: User backlash and the path forward to Windows 10
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户反弹和通往 Windows 10 的道路
- en: While Microsoft pushed hard to win over users with Modern UI design, a new app
    model, Surface PCs, and Windows 8 and 8.1, the idea of a full-screen, touch-first
    app experience and a deemphasized Windows desktop was never embraced by customers.
    It turns out that Windows users really liked the Start menu experience they had
    used for years with Windows XP and Windows 7.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软努力通过现代 UI 设计、新的应用模型、Surface PC 以及 Windows 8 和 8.1 来赢得用户时，全屏、以触摸优先的应用体验和淡化
    Windows 桌面的想法从未被客户接受。事实证明，Windows 用户真的很喜欢他们多年来在 Windows XP 和 Windows 7 中使用的开始菜单体验。
- en: The next step in Windows app development was a big one—so big, in fact, that
    Microsoft decided to skip a number in their versioning, jumping straight from
    Windows 8.1 to Windows 10.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 应用程序开发的下一步是一个很大的步骤——实际上，微软决定在版本号中跳过一个数字，直接从 Windows 8.1 跳到 Windows 10。
- en: Windows 10 and UWP application development
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 10 和 UWP 应用程序开发
- en: While taking a leap forward with the launch of Windows 10, Microsoft also blended
    the best of what worked in previous versions of Windows. It brought back the start
    menu, but its contents look an awful lot like the Windows 8 home screen experience.
    In addition to an alphabetized list of all installed apps, there is a resizable
    area for pinned app tiles. In fact, when running Windows in Tablet mode, the start
    menu can transform into the Windows 8-style home screen experience for better
    usability on a touchscreen.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在推出 Windows 10 的同时，微软也融合了之前 Windows 版本中最好的功能。它恢复了开始菜单，但其内容看起来非常像 Windows 8 的主页体验。除了所有已安装应用的字母顺序列表外，还有一个可调整大小的应用磁贴区域。实际上，当在平板模式运行
    Windows 时，开始菜单可以转换为 Windows 8 风格的主页体验，以更好地适应触摸屏的使用。
- en: When Microsoft launched Windows 10, it also introduced UWP applications to Windows
    developers. While UWP apps have their roots in the XAML apps of Windows 8, some
    key differences give developers some major advantages when building apps for the
    platform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软推出 Windows 10 时，它还向 Windows 开发者引入了 UWP 应用。虽然 UWP 应用根植于 Windows 8 的 XAML 应用，但一些关键差异为开发者构建平台应用提供了重大优势。
- en: 'A key advantage is the universal aspect of these apps. Microsoft builds versions
    of Windows 10 to run on different device families, listed as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用的一个关键优势是它们的通用性。微软为不同的设备系列构建了 Windows 10 的版本，如下所示：
- en: Desktop (PC)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面（PC）
- en: Xbox
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xbox
- en: Mobile (Windows Phone)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动（Windows Phone）
- en: HoloLens
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HoloLens
- en: IoT
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IoT
- en: IoT Headless
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IoT 头部无
- en: Team (Surface Hub)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队（Surface Hub）
- en: UWP developers can build apps to target any of these devices. There is a single
    base set of Windows APIs shared across all these targets, and specialized SDKs
    available for the device-specific APIs of some families—for example, there is
    a Mixed Reality Toolkit and SDK for HoloLens development. With UWP, it is possible
    to create a single project to target many device families—for instance, you can
    create a project that creates apps for Desktop, Xbox, and Team families.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: UWP 开发者可以构建应用以针对这些设备中的任何一个。所有这些目标共享一个单一的基础 Windows API 集合，并为一些系列的特定设备 API 提供专门的
    SDK，例如，有一个用于 HoloLens 开发的混合现实工具包和 SDK。使用 UWP，可以创建一个单一的项目以针对许多设备系列——例如，你可以创建一个为桌面、Xbox
    和团队系列创建应用的项目。
- en: Because the UWP XAML for building the app’s UI is the same, the learning curve
    for cross-device development is lowered and code reusability is very high. The
    nature of XAML provides UI flexibility to adapt to different device sizes and
    aspect ratios.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为用于构建应用程序 UI 的 UWP XAML 是相同的，所以跨设备开发的难度降低，代码重用性非常高。XAML 的本质提供了 UI 灵活性，以适应不同的设备尺寸和宽高比。
- en: Language choice with UWP development
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 UWP 开发的语言选择
- en: 'While the underlying UWP APIs were written in C++, UWP developers can choose
    from several programming languages when building apps for Windows. UWP projects
    can be created with any of these popular languages:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然底层的 UWP API 是用 C++ 编写的，但 UWP 开发者在为 Windows 构建应用程序时可以选择多种编程语言。可以使用以下任何流行语言创建
    UWP 项目：
- en: '**C#**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '**C++**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C++**'
- en: '**F#**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F#**'
- en: '**Visual Basic .****NET** (**VB.NET**)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Basic .NET** (**VB.NET**)'
- en: '**JavaScript**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: You may be surprised to see JavaScript on the list. During the Windows 8.x days,
    developers could create JavaScript apps with APIs known as WinJS apps. Today,
    Microsoft has created a branch of **React Native for Windows** developers, known
    as React Native for Windows. These JavaScript client apps have full access to
    the same Windows APIs as other UWP apps and can be packaged and deployed through
    the Windows Store.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地看到 JavaScript 在列表中。在 Windows 8.x 时代，开发者可以使用名为 WinJS 应用的 API 创建 JavaScript
    应用程序。今天，Microsoft 为 Windows 开发者创建了一个名为 **React Native for Windows** 的分支，称为 React
    Native for Windows。这些 JavaScript 客户端应用程序可以完全访问与其他 UWP 应用程序相同的 Windows API，并且可以通过
    Windows Store 打包和部署。
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: React Native for Windows is an open source project hosted by Microsoft on GitHub
    at [https://github.com/Microsoft/react-native-windows](https://github.com/Microsoft/react-native-windows).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: React Native for Windows 是一个开源项目，由 Microsoft 在 GitHub 上托管，网址为 [https://github.com/Microsoft/react-native-windows](https://github.com/Microsoft/react-native-windows)。
- en: While many of the UWP apps developed for Windows 10 and Windows 11 by Microsoft
    are created with C++, most other developers choose C#. We will also use C# when
    building our applications throughout the course of this book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微软为 Windows 10 和 Windows 11 开发的许多 UWP 应用程序是用 C++ 创建的，但大多数其他开发者选择 C#。在本书的整个过程中，我们也将使用
    C# 构建我们的应用程序。
- en: Lifting app restrictions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升应用程序限制
- en: As discussed earlier, apps built for Windows 8 had several restrictions that
    have been either removed or relaxed with UWP.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为 Windows 8 构建的应用程序有几个限制，这些限制已被移除或放宽，使用 UWP。
- en: First and foremost, modern UWP apps can run in resizable windows, just like
    any other Windows desktop application. The trade-off is that developers now need
    to test for and handle the resizing of their app to almost any size. The dynamic
    nature of XAML can handle a lot of the resizing very well, but below a certain
    minimum size, scroll bars will need to be employed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，现代 UWP 应用程序可以在可调整大小的窗口中运行，就像任何其他 Windows 桌面应用程序一样。权衡是开发者现在需要测试并处理应用程序几乎任何大小的调整。XAML
    的动态特性可以很好地处理很多调整，但低于一定最小尺寸，将需要使用滚动条。
- en: 'For end users, one of the benefits of using UWP apps is the inherent security
    they provide due to the limited access of apps to the PC’s filesystem. By default,
    each app can only access its own local storage. In 2018, the Windows developer
    team announced a new feature for UWP developers. By adding some app configuration
    declaring which additional types of access the app requires, applications can
    request access to additional parts of the filesystem. Among them are the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终用户来说，使用 UWP 应用程序的一个好处是它们提供的固有安全性，这是由于应用程序对 PC 文件系统的访问受限。默认情况下，每个应用程序只能访问其自己的本地存储。在
    2018 年，Windows 开发团队宣布为 UWP 开发者推出一项新功能。通过添加一些应用程序配置，声明应用程序需要哪些额外的访问类型，应用程序可以请求访问文件系统的其他部分。其中以下是一些：
- en: User libraries, including documents, pictures, music, and videos
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户库，包括文档、图片、音乐和视频
- en: Downloads
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载
- en: Removable devices
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移动设备
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are additional filesystem permissions that can be requested. See the
    Microsoft Learn documentation for an entire list: [https://learn.microsoft.com/windows/uwp/files/file-access-permissions](https://learn.microsoft.com/windows/uwp/files/file-access-permissions).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以请求额外的文件系统权限。有关完整列表，请参阅 Microsoft Learn 文档：[https://learn.microsoft.com/windows/uwp/files/file-access-permissions](https://learn.microsoft.com/windows/uwp/files/file-access-permissions)。
- en: Any additional permissions requested will be declared on the app’s listing on
    the Microsoft Store.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的任何附加权限都将声明在 Microsoft Store 中的应用程序列表中。
- en: Some less-common scenarios are now available to UWP apps on Windows. Developers
    can add some configuration and startup code to enable multiple instances of their
    app to launch. While many believe the hallmark of a UWP app is the XAML UI, it
    was also possible to create a UWP console app. The app ran at the command line
    and had access to Universal C runtime calls. These are no longer supported, as
    developers can now create .NET console apps and package them with MSIX to provide
    them with package identity in Windows.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Windows上的UWP应用可以访问一些不太常见的场景。开发者可以向应用添加一些配置和启动代码，以启用其应用的多个实例启动。虽然许多人认为UWP应用的特点是XAML
    UI，但也可以创建UWP控制台应用。该应用在命令行中运行，并可以访问通用C运行时调用。这些现在不再受支持，因为开发者现在可以创建.NET控制台应用并将它们打包为MSIX，以在Windows中提供包标识。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will discuss app packaging, MSIX, and package identity in detail in [*Chapter
    14*](B20908_14.xhtml#_idTextAnchor582), *Packaging and Deploying* *WinUI Applications*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第14章*](B20908_14.xhtml#_idTextAnchor582)，*打包和部署WinUI应用*中详细讨论应用打包、MSIX和包标识。
- en: UWP backward compatibility
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UWP向后兼容性
- en: No UWP app is compatible with any version of Windows before Windows 10\. Beyond
    this, each UWP app must declare a **target version** and a **minimum version**
    of Windows with which it is compatible. The target version is your recommended
    version, which will enable all the app’s features and functionality. The minimum
    version is, unsurprisingly, the minimum version of Windows that users must have
    to be able to install an app from the Microsoft Store.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 任何UWP应用都与Windows 10之前的任何版本不兼容。除此之外，每个UWP应用都必须声明与其兼容的**目标版本**和**最低版本**的Windows。目标版本是您推荐版本，它将启用应用的所有特性和功能。最低版本是，不出所料，用户必须拥有的最低Windows版本，才能从Microsoft
    Store安装应用。
- en: Visual Studio will prompt you to select these versions when creating a new UWP
    project. If the two are the same, it keeps things simple. You will have all the
    APIs of that SDK version available to the app. If the target version is greater
    than the minimum version, you need to add some conditional code to light up the
    features of any versions greater than the minimum. The app must still be useful
    to users running the minimum version; otherwise, it is advisable to increase the
    minimum. If any of the newer APIs or controls are fundamental to the app, it is
    also recommended that the minimum version be increased to one where those are
    available.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的UWP项目时，Visual Studio将提示您选择这些版本。如果两者相同，则会使事情变得简单。您将拥有该SDK版本的所有API可用。如果目标版本高于最低版本，则需要添加一些条件代码来启用高于最低版本的任何版本的特性。应用必须对运行最低版本的用户仍然有用；否则，建议提高最低版本。如果任何新的API或控件对应用至关重要，也建议将最低版本提高到这些API或控件可用的版本。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on writing the conditional or version-adaptive code, see
    the Microsoft Learn documentation here: [https://learn.microsoft.com/windows/uwp/debug-test-perf/version-adaptive-code](https://learn.microsoft.com/windows/uwp/debug-test-perf/version-adaptive-code).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关编写条件或版本自适应代码的更多信息，请参阅以下Microsoft Learn文档：[https://learn.microsoft.com/windows/uwp/debug-test-perf/version-adaptive-code](https://learn.microsoft.com/windows/uwp/debug-test-perf/version-adaptive-code).
- en: If you are creating .NET libraries that will be referenced by your UWP project
    and you would like to share them across other platforms, perhaps by a .NET MAUI
    mobile app, a .NET Standard version should be targeted by the shared library project.
    The most common .NET Standard version today is .NET Standard 2.0\. To reference
    a .NET Standard 2.0 project from a UWP project, the target version of the UWP
    project should be 16299 or later.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在创建将被您的UWP项目引用的.NET库，并且希望将它们跨平台共享，例如通过.NET MAUI移动应用，则应针对共享库项目设置.NET Standard版本。目前最常用的.NET
    Standard版本是.NET Standard 2.0。要从UWP项目引用.NET Standard 2.0项目，UWP项目的目标版本应为16299或更高。
- en: The primary benefit of WinUI over UWP is that it lessens the dependency of Windows
    apps on a particular version of Windows. Instead, the controls, styles, and APIs
    are maintained outside of the Windows SDK. At the time of writing, the minimum
    and target versions required for a WinUI 3 app must be set to 17763 or higher.
    Check the latest WinUI 3 documentation for the current minimum requirements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与UWP相比，WinUI的主要优势在于它减少了Windows应用对特定Windows版本的依赖。相反，控件、样式和API在Windows SDK之外维护。在撰写本文时，WinUI
    3应用所需的最低和目标版本必须设置为17763或更高。请查看最新的WinUI 3文档以获取当前最低要求。
- en: The hope for WinUI is to bring a greater number of controls and features to
    more supported versions of Windows as the project matures.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于WinUI来说，随着项目的成熟，希望将更多的控件和功能带到更多支持的Windows版本中。
- en: What is XAML?
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XAML是什么？
- en: '**XAML** is based on **Extensible Markup Language** (**XML**). This would seem
    like a great thing as XML is a flexible markup language familiar to most developers.
    It is indeed flexible and powerful, but it has some drawbacks.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**XAML**基于**可扩展标记语言**(**XML**)。这似乎是一件好事，因为XML是一种灵活的标记语言，大多数开发者都很熟悉。它确实灵活且强大，但它也有一些缺点。'
- en: The primary problem with Microsoft’s implementations of XAML is that there have
    been so many variations of the XAML language created for different development
    platforms over the years. Currently, WinUI/UWP, **Windows Presentation Foundation**
    (**WPF**), and .NET MAUI (formerly Xamarin.Forms) applications all use XAML as
    their UI markup language, in addition to some third-party UI frameworks. However,
    each of these uses a different XAML implementation or schema, and the markup cannot
    be shared across the platforms. In the past, Windows 8, Silverlight, and Windows
    Phone apps also had additional.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 微软实现XAML的主要问题是多年来为不同的开发平台创建了如此多的XAML语言变体。目前，WinUI/UWP、**Windows Presentation
    Foundation** (**WPF**)和.NET MAUI（以前称为Xamarin.Forms）应用程序都使用XAML作为它们的UI标记语言，此外还有一些第三方UI框架。然而，这些中的每一个都使用不同的XAML实现或模式，并且标记无法跨平台共享。在过去，Windows
    8、Silverlight和Windows Phone应用程序也有额外的。
- en: 'If you have never worked with XAML before, you’re probably ready to see an
    example of some UI markup. The following XAML is a fragment that defines `Grid`
    containing several other of the basic WinUI controls (you can download the code
    for this chapter from GitHub here: [https://github.com/PacktPublishing/-Learn-WinUI-3-second-edition/tree/master/Chapter01](https://github.com/PacktPublishing/-Learn-WinUI-3-second-edition/tree/master/Chapter01)):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未使用过XAML，你可能准备好查看一些UI标记的示例。以下XAML是一个片段，定义了包含其他几个基本WinUI控件的`Grid`（你可以从这里下载本章的代码：[https://github.com/PacktPublishing/-Learn-WinUI-3-second-edition/tree/master/Chapter01](https://github.com/PacktPublishing/-Learn-WinUI-3-second-edition/tree/master/Chapter01))：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s break down the XAML here. The top level of a WinUI window is `Window`.
    WinUI 3 app navigation is Window-based (unlike UWP, which is Page-based), and
    the initial navigation happens in the `App.xaml` file in the project. You will
    learn more about navigation in [*Chapter 4*](B20908_04.xhtml#_idTextAnchor097),
    *Advanced MVVM Concepts*. A `Window` must contain only one child, and it will
    be some type of layout panel such as a `Grid` or `StackPanel`. By default, a `StackPanel`
    is inserted as that child. We will discuss other types of panels that serve as
    good parent containers in the next chapter. I made a few modifications and replaced
    the `StackPanel` with a `Grid`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里分解XAML。WinUI窗口的顶层是`Window`。WinUI 3应用程序的导航是基于窗口的（与基于页面的UWP不同），初始导航发生在项目中的`App.xaml`文件中。你将在[*第4章*](B20908_04.xhtml#_idTextAnchor097)中了解更多关于导航的内容，*高级MVVM概念*。一个`Window`必须只包含一个子元素，并且它将是某种类型的布局面板，如`Grid`或`StackPanel`。默认情况下，会插入一个`StackPanel`作为该子元素。我们将在下一章讨论其他类型的好父容器面板。我对它做了一些修改，并将`StackPanel`替换为`Grid`。
- en: The `Height` and `Width` properties provide a static size for the example, and
    the `HorizontalAlignment` and `VerticalAlignment` properties will center the `Grid`
    within the `Window`. Fixed sizes are uncommon at this level of the XAML and limit
    the flexibility of the layout, but they illustrate some of the available attributes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Height`和`Width`属性为示例提供了静态大小，而`HorizontalAlignment`和`VerticalAlignment`属性将`Grid`在`Window`中居中。在XAML的此级别，固定大小并不常见，这限制了布局的灵活性，但它们展示了可用的属性。'
- en: 'A `Grid` is a layout panel that allows developers to define rows and columns
    to arrange its elements. The rows and columns can have their sizes defined as
    fixed, relative to each other, or auto-sized based on their contents. For more
    information, you can read the Microsoft Learn article *Responsive layouts with*
    *XAML*: [https://learn.microsoft.com/windows/uwp/design/layout/layouts-with-xaml](https://learn.microsoft.com/windows/uwp/design/layout/layouts-with-xaml).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`是一种布局面板，允许开发者定义行和列来排列其元素。行和列可以定义为固定大小、相对于彼此的大小，或者根据其内容自动调整大小。有关更多信息，您可以阅读Microsoft
    Learn文章*使用XAML进行响应式布局*：[https://learn.microsoft.com/windows/uwp/design/layout/layouts-with-xaml](https://learn.microsoft.com/windows/uwp/design/layout/layouts-with-xaml)。'
- en: The `Grid.RowDefinitions` block defines the number and behavior of the grid’s
    rows. Our grid will have two rows. The first one has `Height="Auto"`, which means
    it will resize itself to fit its contents, provided enough space is available.
    The second row has `Height="*"`, which means the rest of the grid’s vertical space
    will be allocated to this row. If multiple rows have their height defined like
    this, they will evenly split the available space. We will discuss additional sizing
    options in the next chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid.RowDefinitions`块定义了网格的行数和行为。我们的网格将有两个行。第一个的`Height="Auto"`，这意味着它将根据其内容调整大小，前提是有足够的空间。第二行的`Height="*"`，这意味着网格的剩余垂直空间将分配给这一行。如果有多个行以这种方式定义了高度，它们将平均分配可用空间。我们将在下一章中讨论更多的尺寸选项。'
- en: The `Grid.ColumnDefinitions` block does for the grid’s columns what `RowDefinitions`
    did for the rows. Our grid has two columns defined. The first `ColumnDefinition`
    has `Height` set to `Auto`, and the second has `Height="*"`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid.ColumnDefinitions`块为网格的列做了`RowDefinitions`为行所做的事情。我们的网格定义了两个列。第一个`ColumnDefinition`的`Height`设置为`Auto`，第二个的`Height="*"`。'
- en: '`TextBlock` defines a label in the first `Grid.Row` and `Grid.Column`. When
    working with XAML, all indexes are `0`-based. In this case, the first `Row` and
    `Column` are both at position `0`. The `Text` property conveniently defines the
    text to display, and the `VerticalAlignment` in this case will vertically center
    the text for us. The default `VerticalAlignment` for a `TextBlock` is `Top`. The
    `Margin` property adds some padding around the outside of the control. A margin
    with the same amount of padding on all sides can be set as a single numeric value.
    In our case, we only want to add a couple of pixels to the right side of the control
    to separate it from `TextBox`. The format for entering these numeric values is
    `"<LEFT>,<TOP>,<RIGHT>,<BOTTOM>"`, or `"``0,0,2,0"` here.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBlock`在第一个`Grid.Row`和`Grid.Column`中定义了一个标签。当使用XAML时，所有索引都是从`0`开始的。在这种情况下，第一行和列的位置都是`0`。`Text`属性方便地定义了要显示的文本，而在这个例子中，`VerticalAlignment`将文本垂直居中。`TextBlock`的默认`VerticalAlignment`是`Top`。`Margin`属性为控件的外围添加了一些填充。具有所有边相同填充量的边距可以设置为一个单一的数值。在我们的例子中，我们只想在控件的右侧添加几个像素，以将其与`TextBox`分开。输入这些数值的格式是`"<LEFT>,<TOP>,<RIGHT>,<BOTTOM>"`，或者在这里是`"0,0,2,0"`。'
- en: '`TextBox` is a text entry field defined in the second column of the grid’s
    first row.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`是在网格第一行的第二列中定义的文本输入字段。'
- en: 'Finally, we’ve added a `Button` control to the second column of the grid’s
    second row. A few pixels of upper margin are added to separate it from the controls
    above. The `VerticalAlignment` is set to `Top` (the default is `Center`) and `HorizontalAlignment`
    is set to `Right` (the default is `Center`). To set the text of `Button`, you
    don’t use the `Text` property as we did with `TextBlock`, as you might think.
    In fact, there is no `Text` property. The `Content` property of `Button` is used
    here. `Content` is a special property that we will discuss in more detail in the
    next chapter. For now, just know that a `Content` property can contain any other
    control: text, `Image`, or even a `Grid` control containing multiple other children.
    The possibilities are virtually endless.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在网格的第二行的第二列中添加了一个`Button`控件。为了将其与上面的控件分开，添加了几像素的上边距。`VerticalAlignment`设置为`Top`（默认是`Center`），`HorizontalAlignment`设置为`Right`（默认是`Center`）。要设置`Button`的文本，你不会像`TextBlock`那样使用`Text`属性，正如你可能认为的那样。实际上，没有`Text`属性。这里使用的是`Button`的`Content`属性。`Content`是一个特殊属性，我们将在下一章中更详细地讨论。现在，只需知道`Content`属性可以包含任何其他控件：文本、`Image`，甚至是一个包含多个其他子控件的`Grid`控件。可能性几乎是无限的。
- en: 'Here is the UI that gets rendered by the preceding markup:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面标记生成的UI：
- en: '![Figure 1.3 – WinUI XAML rendered](img/B20908_01_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – WinUI XAML渲染](img/B20908_01_03.jpg)'
- en: Figure 1.3 – WinUI XAML rendered
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – WinUI XAML渲染
- en: This is a very simple example to give you a first taste of what can be created
    with XAML. As we move ahead, you will learn how powerful the language can be.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，让你先尝尝使用XAML可以创建什么。随着我们继续前进，你将了解到这种语言是多么强大。
- en: Creating an adaptive UI for any device
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为任何设备创建自适应UI
- en: 'In the previous example, `Grid` had fixed `Height` and `Width` properties.
    I mentioned that setting fixed sizes can limit a UI’s flexibility. Let’s remove
    the fixed size properties and use the alignment properties to guide the UI elements
    to render how we want them to appear at different sizes and aspect ratios, as
    follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Grid`有固定的`Height`和`Width`属性。我提到设置固定大小可能会限制UI的灵活性。让我们移除固定大小属性，并使用对齐属性来引导UI元素以不同的尺寸和宽高比渲染，如下所示：
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The rest of the markup remains unchanged. The result is `TextBox` resizing
    to fit the width of the window, and `Button` remains anchored to the right of
    the window as it resizes. See the window resized a couple of different ways here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 标记的其余部分保持不变。结果是`TextBox`调整大小以适应窗口的宽度，而`Button`在调整大小时保持在窗口的右侧。请看以下几种调整窗口大小的不同方式：
- en: '![Figure 1.4 – Resized windows](img/B20908_01_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 调整大小的窗口](img/B20908_01_04.jpg)'
- en: Figure 1.4 – Resized windows
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 调整大小的窗口
- en: If you were using this app on a smaller PC such as the Surface Go Laptop, the
    contents would resize themselves to fit in the available space. That is the power
    of XAML’s adaptive nature. When building a UI, you will usually want to choose
    relative and adaptive properties such as alignment to fixed sizes and positions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个较小的PC上使用这个应用，比如Surface Go笔记本电脑，内容会自动调整大小以适应可用空间。这就是XAML自适应特性的力量。在构建UI时，你通常会想要选择相对和自适应属性，比如对固定大小和位置的定位。
- en: It’s this adaptive layout that makes XAML work so well on mobile devices with
    .NET MAUI, and this is why WPF developers have loved using it since its launch
    with Windows Vista.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这种自适应布局使得XAML在.NET MAUI的移动设备上工作得如此出色，这也是为什么WPF开发者自从Windows Vista发布以来就喜欢使用它的原因。
- en: Powerful data binding
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强大的数据绑定
- en: 'Another reason why XAML-based frameworks are so popular is the ease and power
    of their data-binding capabilities. Nearly all properties on WinUI controls can
    be data-bound. The source of the data can be an object or a list of objects on
    the data source. In most cases, that source will be a `ViewModel` class. Let’s
    have a very quick look at using WinUI’s `Binding` syntax for data-binding to a
    property on a `ViewModel` class, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因，为什么基于XAML的框架如此受欢迎，就是它们数据绑定功能的简便性和强大。几乎WinUI控件上的所有属性都可以进行数据绑定。数据源可以是数据源上的一个对象或对象列表。在大多数情况下，这个源将是一个`ViewModel`类。让我们快速看一下如何使用WinUI的`Binding`语法将数据绑定到`ViewModel`类上的一个属性，如下所示：
- en: 'First, we will create a simple `MainViewModel` class with a `Name` property,
    like this:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的`MainViewModel`类，它有一个`Name`属性，如下所示：
- en: '[PRE2]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `MainViewModel` class implements an interface called `INotifyPropertyChanged`.
    This interface is key to the UI receiving updates when data-bound properties have
    changed. This interface implementation is typically wrapped either by a `ViewModelBase`
    class. For now, we will directly invoke a `PropertyChanged` event inside the `Name`
    property’s setter. We will learn more about `ViewModels` and the `INotifyPropertyChanged`
    interface in [*Chapter 3*](B20908_03.xhtml#_idTextAnchor073), *MVVM for Maintainability*
    *and Testability*.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MainViewModel`类实现了一个名为`INotifyPropertyChanged`的接口。这个接口是UI在数据绑定属性更改时接收更新的关键。这个接口的实现通常被`ViewModelBase`类包装。现在，我们将直接在`Name`属性的setter中调用`PropertyChanged`事件。我们将在[*第3章*](B20908_03.xhtml#_idTextAnchor073)中了解更多关于`ViewModels`和`INotifyPropertyChanged`接口的信息，*可维护性和可测试性的MVVM*。'
- en: 'The next step is to create an instance of the `MainViewModel` class and set
    it as `ViewModel` for our `MainWindow`. This happens in the code-behind file for
    the page, `MainWindow.xaml.cs`, as illustrated in the following code snippet:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建`MainViewModel`类的一个实例，并将其设置为`MainWindow`的`ViewModel`。这发生在页面的代码后文件`MainWindow.xaml.cs`中，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have added a `ViewModel` property to `MainWindow` and set it to a new instance
    of our `MainViewModel` class in the constructor.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在`MainWindow`中添加了一个`ViewModel`属性，并在构造函数中将其设置为`MainViewModel`类的新实例。
- en: Tip
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Any code added to a window’s constructor that interacts with any UI elements
    must be added after the call to `InitializeComponent()`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 任何添加到窗口构造函数中并与任何UI元素交互的代码都必须在调用`InitializeComponent()`之后添加。
- en: 'Now it’s time to add the data-binding code to the XAML markup for `TextBox`,
    as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候将数据绑定代码添加到`TextBox`的XAML标记中，如下所示：
- en: '[PRE4]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Some markup has been added to set the `Text` property using the `x:Bind` markup
    extension. The data-binding `Path` is set to the `Name` property on the `ViewModel`,
    which was assigned in the code-behind file in *step 2*. By setting the data-binding
    mode to `TwoWay`, updates in the `ViewModel` will display in the UI, and any updates
    by the user in the UI will also be persisted in the `Name` property of the `MainViewModel`
    class. Now, running the app will automatically populate the name that was set
    in the constructor of the `ViewModel`, as illustrated in the following screenshot:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加了一些标记来使用`x:Bind`标记扩展设置`Text`属性。数据绑定的`Path`设置为`ViewModel`上的`Name`属性，该属性在代码隐藏文件中的*步骤
    2*中分配。通过将数据绑定模式设置为`TwoWay`，`ViewModel`中的更新将在UI中显示，并且用户在UI中的任何更新也将持久保存在`MainViewModel`类的`Name`属性中。现在，运行应用程序将自动填充在`ViewModel`构造函数中设置的名称，如下面的截图所示：
- en: '![Figure 1.5 – Data-binding the TextBox](img/B20908_01_05.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 数据绑定TextBox](img/B20908_01_05.jpg)'
- en: Figure 1.5 – Data-binding the TextBox
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 数据绑定TextBox
- en: 'To illustrate data-binding to another property on another UI element on the
    page, we will first modify the grid to add a name, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明将数据绑定到页面上另一个UI元素的另一个属性，我们首先修改网格以添加一个名称，如下所示：
- en: '[PRE5]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now add another `RowDefinition` to the `Grid` to fit the new UI element on
    the page:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向`Grid`添加另一个`RowDefinition`以适应页面上的新UI元素：
- en: '[PRE6]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, add a `TextBlock` element and use the `Binding` markup extension to bind
    its `Text` property to the `ActualWidth` of the `ElementName` set to `ParentGrid`.
    We are also adding a `TextBlock` to label this as **Actual Width**:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个`TextBlock`元素，并使用`Binding`标记扩展将其`Text`属性绑定到设置为`ParentGrid`的`ElementName`的`ActualWidth`。我们还添加了一个`TextBlock`来标记它为**实际宽度**：
- en: '[PRE7]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, update the `Grid.Row` 2.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`Grid.Row` 2。
- en: 'Now the new `TextBlock` control displays the width of `ParentGrid` when the
    page is loaded. Note that it will not update the value if you resize the window.
    The `ActualWidth` property does not raise a property change notification. This
    is documented in the `FrameworkElement.ActualWidth` documentation: [https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.frameworkelement.actualwidth](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.frameworkelement.actualwidth):'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在新的`TextBlock`控件在页面加载时显示`ParentGrid`的宽度。请注意，如果你调整窗口大小，它不会更新值。`ActualWidth`属性不会引发属性更改通知。这在`FrameworkElement.ActualWidth`文档中有记录：[https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.frameworkelement.actualwidth](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.frameworkelement.actualwidth)：
- en: '![Figure 1.6 – Data-binding to another element](img/B20908_01_06.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 将数据绑定到另一个元素](img/B20908_01_06.jpg)'
- en: Figure 1.6 – Data-binding to another element
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 将数据绑定到另一个元素
- en: The **Submit** button does not function yet. You will learn how to work with
    **Events** and **Commands** with MVVM in [*Chapter 5*](B20908_05.xhtml#_idTextAnchor114),
    *Exploring* *WinUI Controls*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**提交**按钮目前还没有功能。你将在[*第5章*](B20908_05.xhtml#_idTextAnchor114)“探索WinUI控件”中学习如何使用MVVM与**事件**和**命令**一起工作。'
- en: Styling your UI with XAML
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XAML对UI进行样式设计
- en: When working with XAML, styles can be defined and applied at almost any scope,
    global to the application in `App.xaml`, in the current `Window` inside a `Window.Resources`
    declaration, or inside any level or nested control on the page. The `Style` element
    specifies a `TargetType` property, which is the data type of the elements to be
    targeted by the style. It can optionally have a `Key` property defined as a unique
    identifier, like a class identifier in `Key` property can be used to apply the
    style to only selected elements of that type. Only one `Key` property can be assigned
    to an element, unlike with CSS classes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用XAML时，可以在几乎任何范围内定义和应用样式，从全局的`App.xaml`应用到当前`Window`中的`Window.Resources`声明，或者在任何级别或嵌套控件上。`Style`元素指定了一个`TargetType`属性，它是要由样式针对的元素的数据类型。它可以可选地定义一个`Key`属性，作为唯一标识符，就像在`Key`属性中可以使用的类标识符一样，可以用来仅将样式应用于该类型的选定元素。与CSS类不同，一个元素只能分配一个`Key`属性。
- en: 'In the next example, we will modify the page to define a `Style` property for
    all buttons on the window, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将修改页面以定义一个用于窗口上所有按钮的`Style`属性，如下所示：
- en: 'Start by moving the `StackPanel` element. A `StackPanel` element stacks all
    child elements in a horizontal or vertical orientation, with vertical being the
    default orientation. Some of the button’s properties will need to be moved to
    the `StackPanel` element, as it is now the direct child of `Grid`. After adding
    a second button to the `StackPanel` element to act as a `StackPanel` and `Button`
    elements should look like this:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 `StackPanel` 元素移动。`StackPanel` 元素以水平或垂直方向堆叠所有子元素，其中垂直是默认方向。一些按钮的属性需要移动到
    `StackPanel` 元素，因为现在它是 `Grid` 的直接子元素。在 `StackPanel` 元素中添加第二个按钮以充当 `StackPanel`
    之后，`StackPanel` 和 `Button` 元素应如下所示：
- en: '[PRE8]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A new `Margin` attribute has been added to the first button to add some space
    between the elements.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 已为第一个按钮添加了一个新的 `Margin` 属性，以在元素之间添加一些空间。
- en: 'Next, we will add a `Style` block to a `Grid.Resources` section nested inside
    `Grid` before all its controls to style the buttons. Because no `Key` is assigned
    to the `Style` block, it will apply to all `Button` elements that do not have
    their styles overridden in an inner scope. This is known as an *implicit style*.
    The code for this is shown here:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `Grid` 的嵌套 `Grid.Resources` 部分中添加一个 `Style` 块，在所有控件之前对其进行样式化。由于未为 `Style`
    块分配 `Key`，它将应用于所有没有在内部作用域中覆盖样式的 `Button` 元素。这被称为 *隐式样式*。此代码如下所示：
- en: '[PRE9]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, when you run the app, you will see that the new style has been applied
    to both the **Submit** and **Cancel** buttons without adding any styling directly
    to each control, as illustrated in the following screenshot:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序时，你会看到新的样式已应用于 **提交** 和 **取消** 按钮，而无需直接为每个控件添加任何样式，如下面的截图所示：
- en: '![Figure 1.7 – Styled buttons](img/B20908_01_07.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – 样式化按钮](img/B20908_01_07.jpg)'
- en: Figure 1.7 – Styled buttons
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 样式化按钮
- en: If we moved the `Style` block to the `Application.Resources` section in `App.xaml`,
    the defined style would get applied to every button in the entire app unless the
    developer had individually overridden some of the properties in the style. For
    instance, if the `Background` property set to `DarkGreen`, only the **Cancel**
    button would appear as dark blue.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `Style` 块移动到 `App.xaml` 中的 `Application.Resources` 部分，则定义的样式将应用于整个应用程序中的每个按钮，除非开发人员已单独覆盖了样式中的某些属性。例如，如果将
    `Background` 属性设置为 `DarkGreen`，则只有 **取消** 按钮会显示为深蓝色。
- en: We will spend more time on styles and design in [*Chapter 7*](B20908_07.xhtml#_idTextAnchor152),
    *Fluent Design System for* *Windows Applications*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 7 章*](B20908_07.xhtml#_idTextAnchor152)“Windows 应用程序的流畅设计系统”中花费更多的时间来讨论样式和设计。
- en: Separating presentation from business logic
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将展示逻辑与业务逻辑分离
- en: We looked briefly at the MVVM pattern in the earlier section on data binding.
    MVVM is key to the separation of presentation logic from business logic in WinUI
    application development. The XAML elements only need to know that there is a property
    with a particular name somewhere in its data context. The `ViewModel` classes
    have no knowledge of the `View` (our XAML file).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期关于数据绑定的章节中，我们简要地讨论了 MVVM 模式。MVVM 是 WinUI 应用程序开发中展示逻辑与业务逻辑分离的关键。XAML 元素只需要知道在其数据上下文中某个地方存在一个特定名称的属性。`ViewModel`
    类对 `View`（我们的 XAML 文件）没有任何了解。
- en: 'This separation provides several benefits. First, `ViewModels` can be tested
    independently of the UI. If any WinUI elements are referenced by the system under
    test, the UI thread is needed. This will cause tests to fail when they’re running
    on background threads locally or on a **Continuous Integration** (**CI**) server.
    See this Microsoft blog post for more information on unit testing WinUI applications:
    [https://devblogs.microsoft.com/ifdef-windows/winui-desktop-unit-tests/](https://devblogs.microsoft.com/ifdef-windows/winui-desktop-unit-tests/).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离提供了几个好处。首先，`ViewModels` 可以独立于 UI 进行测试。如果系统在测试中引用了任何 WinUI 元素，则需要 UI 线程。这将在本地或
    CI 服务器上运行时导致测试失败。有关 WinUI 应用程序单元测试的更多信息，请参阅这篇 Microsoft 博客文章：[https://devblogs.microsoft.com/ifdef-windows/winui-desktop-unit-tests/](https://devblogs.microsoft.com/ifdef-windows/winui-desktop-unit-tests/)。
- en: The next benefit of `View`/`ViewModel` separation is that businesses with dedicated
    `ViewModels`. When it is time to sync up the two, the developer can add the necessary
    data-binding properties to the XAML, or perhaps the UX designer and developer
    have already agreed upon the names of the properties in the shared data context.
    Visual Studio includes another tool geared toward designers in this workflow,
    called **Blend for Visual Studio**. Blend was first released by Microsoft in 2006
    as Microsoft Expression Blend, as a tool for designers to create UIs for WPF.
    Support was later added for other XAML languages such as Silverlight and UWP.
    Blend is still included with the .NET desktop development workload when installing
    Visual Studio.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`/`ViewModel`分离的下一个好处是，对于拥有专用`ViewModels`的企业来说。当需要同步这两个组件时，开发者可以向XAML添加必要的数据绑定属性，或者UX设计师和开发者可能已经就共享数据上下文中的属性名称达成一致。Visual
    Studio包含另一个针对设计师的工具，称为**Blend for Visual Studio**。Blend最初由微软在2006年作为Microsoft
    Expression Blend发布，作为设计师创建WPF UI的工具。后来增加了对其他XAML语言的支持，如Silverlight和UWP。当安装Visual
    Studio时，Blend仍然包含在.NET桌面开发工作负载中。'
- en: A final benefit we will discuss here is that a good separation of concerns between
    any layers of your application will always lead to better maintainability. If
    there are multiple components involved in a single responsibility or if logic
    is duplicated in multiple places, this leads to buggy code and unreliable applications.
    Follow good design patterns, and you will save yourself a lot of work down the
    road.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要讨论的最后一个好处是，在应用程序的任何层之间良好的关注点分离将始终导致更好的可维护性。如果有多个组件参与单个责任，或者逻辑在多个地方重复，这会导致有缺陷的代码和不可靠的应用程序。遵循良好的设计模式，你将节省自己在未来大量的工作。
- en: 'Now that you have a good understanding of the history of UWP applications,
    it’s time to look at WinUI: what it is, and why it was created.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地理解了UWP应用程序的历史，是时候看看WinUI了：它是什么，以及为什么它被创建。
- en: What is WinUI?
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是WinUI？
- en: The WinUI library is a set of controls and UI components that has been extracted
    from the Windows SDK and included in the Windows App SDK. After this separation,
    many controls have been enhanced and others have been added. The Windows App SDK
    is being developed in the open. Its issues are tracked on GitHub and with input
    from Microsoft and the Windows developer community.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI库是从Windows SDK中提取的一组控件和UI组件，并包含在Windows App SDK中。在此分离之后，许多控件得到了增强，其他控件也被添加。Windows
    App SDK正在公开开发。其问题在GitHub上跟踪，并得到微软和Windows开发者社区的支持。
- en: So, if these WinUI libraries are based on UWP libraries in the Windows SDK,
    you may be wondering why you should choose WinUI as your UI framework instead
    of UWP. UWP has been around since the launch of Windows 10 and is quite robust
    and stable. There are several very good reasons to consider WinUI.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你这些WinUI库是基于Windows SDK中的UWP库，你可能想知道为什么你应该选择WinUI作为你的UI框架而不是UWP。UWP自Windows
    10发布以来一直存在，并且非常健壮和稳定。有多个非常好的理由考虑WinUI。
- en: Choosing WinUI brings with it many of the benefits of **open source software**
    (**OSS**). OSS is typically very reliable. When software is developed in the open
    by an active developer community, issues are found and resolved quickly. In fact,
    if you find an issue with an open source package, you can fix it yourself and
    submit a pull request to have the fix made available to the rest of the community.
    Open source projects can iterate quickly without having to remain in sync with
    product groups in a large enterprise such as the Windows team. Windows releases
    feature updates at a regular cadence now, but this is still less frequent than
    with a typical control library. Although the Windows App SDK and WinUI 3 are not
    yet open source, it is part of the product roadmap.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 选择WinUI带来了许多**开源软件**（**OSS**）的好处。OSS通常非常可靠。当软件由活跃的开发者社区在公开环境中开发时，问题会被发现并迅速解决。实际上，如果你发现开源包中的问题，你可以自己修复它，并通过提交拉取请求将修复提供给整个社区。开源项目可以快速迭代，而无需与大型企业中的产品组（如Windows团队）保持同步。现在，Windows定期发布功能更新，但这仍然比典型的控件库要少。尽管Windows
    App SDK和WinUI 3还不是开源的，但它仍然是产品路线图的一部分。
- en: The best reason to use WinUI is its backward compatibility. When using a UWP
    control, the features and fixes in a specific version of the control cannot be
    deployed in apps to older versions of Windows. With WinUI, so long as you are
    targeting the minimum version of Windows supported by WinUI as a whole, you can
    use those new controls and features in multiple Windows versions. Controls not
    previously available to UWP developers in one version of Windows are now available
    there as WinUI controls.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WinUI 的最佳理由是其向后兼容性。当使用 UWP 控件时，特定版本的控件中的功能和修复无法部署到较旧版本的 Windows 应用程序中。使用
    WinUI，只要你的目标是 WinUI 整体支持的最低 Windows 版本，你就可以在多个 Windows 版本中使用那些新控件和功能。在某个 Windows
    版本中，UWP 开发者之前无法使用的控件现在作为 WinUI 控件可用。
- en: For instance, Microsoft did not introduce the Fluent UI design to Windows until
    the Fall 2017 release (version 16299). However, WinUI controls can be included
    in apps targeting a minimum Windows version of Windows 10, version 1809, the Fall
    2019 release. The controls in WinUI support Fluent UI styles. WinUI adds controls
    and other features that are not available at all in UWP and the Windows SDK.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，微软直到 2017 年秋季发布（版本 16299）才将 Fluent UI 设计引入 Windows。然而，WinUI 控件可以包含在针对最低 Windows
    版本为 Windows 10 版本 1809 的应用程序中，即 2019 年秋季发布。WinUI 中的控件支持 Fluent UI 风格。WinUI 添加了
    UWP 和 Windows SDK 中完全不可用的控件和其他功能。
- en: The first WinUI release
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinUI 的第一个版本
- en: 'The first version of WinUI was released in July 2018 as a preview release for
    Windows developers. It was released as the following two NuGet packages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 的第一个版本于 2018 年 7 月发布，作为 Windows 开发者的预览版。它作为以下两个 NuGet 包发布：
- en: '`Microsoft.UI.Xaml`: The WinUI controls and Fluent UI styles'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.UI.Xaml`：WinUI 控件和 Fluent UI 风格'
- en: '`Microsoft.UI.Xaml.Core.Direct`: Components for middleware developers to access
    the `XamlDirect` API'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.UI.Xaml.Core.Direct`：中间件开发者访问 `XamlDirect` API 的组件'
- en: '3 months later, WinUI 2.0 was released. Despite the version number, it was
    the first production release of WinUI. The release included more than 20 controls
    and brushes. A few notable controls included the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 3 个月后，WinUI 2.0 发布。尽管版本号如此，但它却是 WinUI 的第一个生产版本。该版本包括超过 20 个控件和画笔。一些值得注意的控件包括以下内容：
- en: '`TreeView`: A staple of any UI library.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TreeView`：任何 UI 库的必备品。'
- en: '`ColorPicker`: A rich visual color picker with a color spectrum.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorPicker`：一个具有颜色光谱的丰富视觉颜色选择器。'
- en: '`DropDownButton`: A button with the ability to open a menu.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DropDownButton`：一个可以打开菜单的按钮。'
- en: '`PersonPicture`: An image control for displaying an avatar. It can fall back
    to displaying initials or a generic placeholder image.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersonPicture`：用于显示头像的图像控件。它可以将显示首字母或通用占位符图像。'
- en: '`RatingControl`: Allows users to enter star ratings for items.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RatingControl`：允许用户为项目输入星级评分。'
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: WinUI 2.x versions are libraries that are used by UWP projects. WinUI 3 is part
    of the Windows App SDK and is its own project type, although it shares the same
    XAML schema as a UWP project.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 2.x 版本是 UWP 项目使用的库。WinUI 3 是 Windows App SDK 的一部分，并且是其自己的项目类型，尽管它与 UWP
    项目共享相同的 XAML 架构。
- en: 'Let’s add a few of these controls to our WinUI project and see how they look.
    Change the contents of `StackPanel` to look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的 WinUI 项目中添加一些这些控件，看看它们的外观。将 `StackPanel` 的内容更改为如下所示：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A `PersonPicture` control with the initials `MS` has been added as the first
    item in `StackPanel`, and the first of the two buttons has been replaced by a
    `DropDownButton` control. The `DropDownButton` control has a `FlyoutMenu` serving
    as a drop-down list, and there are two `MenuFlyoutMenuItem` elements. Now, users
    can simply click the `DropDownButton` menu shown:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `StackPanel` 的第一个位置添加了一个带有首字母 `MS` 的 `PersonPicture` 控件，两个按钮中的第一个已被 `DropDownButton`
    控件替换。`DropDownButton` 控件有一个作为下拉列表的 `FlyoutMenu`，并且有两个 `MenuFlyoutMenuItem` 元素。现在，用户可以简单地点击显示的下拉菜单：
- en: '![Figure 1.8 – Adding a PersonPicture and DropDownButton control](img/B20908_01_08.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 添加 PersonPicture 和 DropDownButton 控件](img/B20908_01_08.jpg)'
- en: Figure 1.8 – Adding a PersonPicture and DropDownButton control
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 添加 PersonPicture 和 DropDownButton 控件
- en: We’re only scratching the surface of what WinUI can do for Windows developers.
    Don’t worry, as we will dive much deeper in the chapters ahead. Let’s briefly
    look at what was added in subsequent versions before WinUI 3.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是刚刚触及 WinUI 为 Windows 开发者所能做的事情的表面。不用担心，我们将在接下来的章节中深入探讨。在 WinUI 3 之前，让我们简要看看后续版本中添加了什么。
- en: The road to WinUI 3
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinUI 3 的道路
- en: There have been five additional minor releases of WinUI following version 2.0,
    in addition to many incremental bug fixes and pre-release versions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0版本之后，WinUI还发布了五个额外的次要版本，以及许多增量错误修复和预发布版本。
- en: WinUI 2.1
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinUI 2.1
- en: 'The WinUI 2.1 release brought several new controls and features to the library.
    These are some highlights:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 2.1版本发布带来了几个新的控件和功能，以下是亮点：
- en: '`TeachingTip`: Think of `TeachingTip` as a rich, context-sensitive tooltip.
    It is linked to another element on the page and displays informative details about
    the target element to help guide users with non-intrusive content as needed.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TeachingTip`：将`TeachingTip`视为一个丰富、上下文相关的工具提示。它与页面上的另一个元素相关联，并显示有关目标元素的详细信息，以帮助用户通过非侵入性内容进行引导。'
- en: '`AnimatedVisualPlayer`: This hosts Lottie animations. Lottie files are a popular
    animation format created in **Adobe After Effects** used by designers across Windows,
    the web, and mobile platforms. There are libraries available to host Lottie animations
    for most modern development frameworks.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimatedVisualPlayer`：这个控件用于托管Lottie动画。Lottie文件是由设计师在**Adobe After Effects**中创建的流行动画格式，被Windows、网页和移动平台的设计师所使用。现在大多数现代开发框架都有可用的库来托管Lottie动画。'
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Get more information about Lottie files on their website at [https://airbnb.design/lottie/](https://airbnb.design/lottie/)
    and check out this great repository of Lottie animation files: [https://lottiefiles.com/](https://lottiefiles.com/).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的网站上获取有关Lottie文件的更多信息：[https://airbnb.design/lottie/](https://airbnb.design/lottie/)，并查看这个Lottie动画文件的优秀存储库：[https://lottiefiles.com/](https://lottiefiles.com/)。
- en: '`CompactDensity`: Adding this resource dictionary to your app can provide the
    ability to switch between *Compact* and *Normal* display modes. `CompactDensity`
    will reduce the spacing within and between elements on the page, providing up
    to 33% more visible content to users. This Fluent UI design concept was introduced
    to developers at Microsoft’s Build 2018 conference.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompactDensity`：将此资源字典添加到您的应用程序中可以提供在**紧凑**和**正常**显示模式之间切换的能力。`CompactDensity`将减少页面内和页面之间的间距，为用户提供多达33%的更多可见内容。这个Fluent
    UI设计概念是在微软Build 2018大会上向开发者介绍的。'
- en: WinUI 2.2
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinUI 2.2
- en: This release brought many enhancements to existing features. However, the single
    new control added to the library is one that many Windows developers will find
    useful.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本版本对现有功能带来了许多增强。然而，库中添加的唯一新控件是许多Windows开发者可能会发现有用的控件。
- en: The `TabView` control creates a familiar tabbed UX on the screen. Each tab can
    host a page in your WinUI project.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabView`控件在屏幕上创建了一个熟悉的标签式用户体验。每个标签可以托管WinUI项目中的一个页面。'
- en: WinUI 2.2 enhancements
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WinUI 2.2增强功能
- en: 'A few of the notable updated controls and libraries in version 2.2 are listed
    here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里列出了版本2.2中一些值得注意的更新控件和库：
- en: '`NavigationView` control was enhanced to allow the back button to remain visible
    when the panel is collapsed. Other visual updates maximize the viewable content
    of the control.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigationView`控件得到了增强，允许在面板折叠时保持返回按钮可见。其他视觉更新最大化了控件的可视内容。'
- en: '`CornerRadius`, `BorderThickness`, `CheckBox`, and `RadioButton`. The updates
    all make the WinUI visuals more consistent and in line with Fluent UI design guidelines.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CornerRadius`、`BorderThickness`、`CheckBox`和`RadioButton`。这些更新使WinUI视觉元素更加一致，并与Fluent
    UI设计指南保持一致。'
- en: WinUI 2.3
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinUI 2.3
- en: In the WinUI 2.3 release, `ProgressBar` received some updates, and a couple
    of new controls were added to the library.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在WinUI 2.3版本中，`ProgressBar`控件进行了一些更新，并添加了几个新的控件到库中。
- en: 'There are now two modes available when creating a `ProgressBar` element in
    a WinUI application: **determinate** and **indeterminate**. A determinate progress
    bar has a known amount of the task to complete and a known current state of the
    task. An indeterminate control indicates that a task is ongoing without a known
    completion time. Its purpose is like that of a busy indicator.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在WinUI应用程序中创建`ProgressBar`元素时，现在有两种可用模式：**确定**和**不确定**。确定进度条有一个已知任务完成量和当前任务状态。不确定控件表示任务正在进行中，但没有已知完成时间。它的目的是像忙碌指示器一样。
- en: New controls in WinUI 2.3
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WinUI 2.3中的新控件
- en: 'The following are a few new controls in this update:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本更新中包含了一些新的控件：
- en: '`NumberBox`: A `NumberBox` control is an input editor that makes it easy to
    support numeric formatting, up/down incrementing buttons, and inline mathematic
    calculations. It is a seemingly simple but practical and powerful control.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberBox`：`NumberBox`控件是一个输入编辑器，它使得支持数字格式化、上下增减按钮和内联数学计算变得容易。它看似简单但实用且功能强大。'
- en: '`RadioButtons`: You might be thinking, *radio buttons have always been available.
    How is this a new control?* `RadioButtons` is a control that groups a set of `RadioButton`
    (*singular*) controls, making it easier to work with them as a single unit.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RadioButtons`：你可能认为，“单选按钮一直都有。这怎么算是一个新控件呢？”`RadioButtons` 是一个将一组 `RadioButton`（单数）控件组合在一起的控件，使得作为单个单元处理它们变得更加容易。'
- en: WinUI 2.4
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinUI 2.4
- en: 'When it was released in May 2020, two new features were made available in WinUI
    2.4: a `RadialGradientBrush` visual and a `ProgressRing` control.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当它在 2020 年 5 月发布时，WinUI 2.4 提供了两个新功能：一个 `RadialGradientBrush` 视觉效果和一个 `ProgressRing`
    控件。
- en: The brush is similar in use to the `RadialGradientBrush` used by WPF developers.
    It makes it easy to add a gradient to a visual element that radiates out from
    a central point.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该画笔在用法上与 WPF 开发者使用的 `RadialGradientBrush` 类似。它使得向从中心点辐射出的视觉元素添加渐变变得容易。
- en: The `ProgressRing` control, as it sounds, recreates progress bar functionality
    in a circular format. The control is available with a determinate state and an
    indeterminate state in version 2.4\. An indeterminate `ProgressRing` control displays
    a repeating animation and is the default state of the control.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`ProgressRing` 控件以圆形格式重新创建了进度条功能。在版本 2.4 中，该控件提供了确定状态和不确定状态。不确定的 `ProgressRing`
    控件显示重复动画，并且是控件的默认状态。
- en: Several controls were updated in version 2.4\. The `TabView` control was updated
    to provide more control over how tabs are rendered, including `TextBox` controls
    received a *dark mode* enhancement to keep the content area of the control dark,
    with white text by default. Finally, the `NavigationView` control was updated
    with hierarchical navigation, with `Left`, `Top`, and `LeftCompact` modes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 2.4 中更新了几个控件。`TabView` 控件得到了更新，以提供更多控制选项来渲染标签页，包括 `TextBox` 控件获得了 *深色模式*
    增强，以保持控件内容区域为深色，默认为白色文本。最后，`NavigationView` 控件更新为支持分层导航，包括 `Left`、`Top` 和 `LeftCompact`
    模式。
- en: WinUI 2.5
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinUI 2.5
- en: WinUI 2.5 was released in December 2020 and included a new `InfoBar` control.
    Several control enhancements and bug fixes were also included in the release.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 2.5 于 2020 年 12 月发布，并包含了一个新的 `InfoBar` 控件。该版本还包含了多个控件增强和错误修复。
- en: 'The `InfoBar` control provides a way to display important status messages to
    users. The control can display an alert or informational icon, a status message,
    and a link or button allowing users to act on a message. There is also an option
    to display a close button to the right of the message. By default, the control
    includes an icon, message, and close button. Microsoft Learn provides usage guidelines
    for this new control. This is the documentation for the WinUI 3 version of the
    control: [https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.infobar](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.infobar).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`InfoBar` 控件提供了一种向用户显示重要状态消息的方式。该控件可以显示警报或信息图标、状态消息以及允许用户对消息采取行动的链接或按钮。还有一个选项在消息右侧显示关闭按钮。默认情况下，该控件包括图标、消息和关闭按钮。Microsoft
    Learn 为此新控件提供了使用指南。这是 WinUI 3 版本控件的文档：[https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.infobar](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.infobar)。'
- en: Several updates are also available in version 2.5\. The `ProgressRing` control
    received enhancements to the determinate state of the control. The `NavigationView`
    control was updated to provide customizable `FooterMenuItems`. In previous versions
    of the `NavigationView` control, the footer area could be shown or hidden but
    not customized.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 2.5 中也提供了一些更新。`ProgressRing` 控件在确定状态方面得到了增强。`NavigationView` 控件更新为提供可定制的
    `FooterMenuItems`。在 `NavigationView` 控件的先前版本中，页脚区域可以显示或隐藏，但不能进行自定义。
- en: 'WinUI 2.x continued adding controls and features in versions 2.6, 2.7, and
    2.8\. For a complete listing of the new features in each version, see the following
    release notes pages on Microsoft Learn:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 2.x 在版本 2.6、2.7 和 2.8 中继续添加控件和功能。有关每个版本中新增功能的完整列表，请参阅以下 Microsoft Learn
    上的发布说明页面：
- en: 'WinUI 2.6 release notes: [https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.6](https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.6'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinUI 2.6 发布说明：[https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.6](https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.6)
- en: )
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'WinUI 2.7 release notes: [https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.7](https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.7'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinUI 2.7版本说明：[https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.7](https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.7)
- en: )
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'WinUI 2.8 release notes: [https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.8](https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.8'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinUI 2.8版本说明：[https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.8](https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.8)
- en: )
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: We’ve seen what was available to UWP developers in WinUI 2\. Now, let’s see
    what you get with WinUI 3 and the Windows App SDK.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了WinUI 2中为UWP开发者提供的内容。现在，让我们看看WinUI 3和Windows App SDK能给你带来什么。
- en: What’s new in WinUI 3?
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WinUI 3的新特性是什么？
- en: Unlike WinUI 2.0 and the incremental versions that followed, WinUI 3 is a major
    update featuring more than new and improved controls and libraries to use with
    Windows desktop apps. In fact, the primary goal of WinUI 3 was not to add new
    controls and features beyond its current UWP counterparts. The Windows App SDK
    team has made WinUI a complete UI framework that can sit atop the Windows desktop
    .NET platform.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与WinUI 2.0及其后续的增量版本不同，WinUI 3是一个重大更新，它不仅提供了更多的新控件和库，用于与Windows桌面应用一起使用。实际上，WinUI
    3的主要目标并不是在其当前的UWP对应版本之外添加新的控件和功能。Windows App SDK团队已经将WinUI打造成为一个完整的UI框架，它可以建立在Windows桌面.NET平台之上。
- en: Goodbye UWP?
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再见，UWP？
- en: So, what is happening to UWP? Will our UWP apps stop working?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，UWP会发生什么变化？我们的UWP应用会停止工作吗？
- en: As previously mentioned, the plan for the UWP UI libraries is to keep providing
    important security updates, but they will not receive any new features going forward.
    It is likely that WinUI 2.8 will be the final 2.x version. All new features and
    updates will be developed for WinUI and the Windows App SDK. New applications
    will be developed in WinUI with either .NET, written in C# or VB, or with native
    C++. These clients will sit on top of the Win32 platform. This is all possible
    because the Windows App SDK is developed completely in C++.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，UWP UI库的计划是继续提供重要的安全更新，但它们将不会获得任何新的功能。很可能WinUI 2.8将是最终的2.x版本。所有新的功能和更新都将为WinUI和Windows
    App SDK开发。新应用将使用WinUI开发，可以是.NET，用C#或VB编写，或者使用原生C++。这些客户端将建立在Win32平台之上。这一切都是因为Windows
    App SDK完全用C++开发的。
- en: The fact that it is developed in C++ enables **React Native for Windows** client
    apps to interoperate with the Windows App SDK platform. Between React Native and
    Uno Platform, WinUI has some great cross-platform potential.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是用C++开发的，这使得**Windows的React Native客户端应用**能够与Windows App SDK平台进行交互。在React
    Native和Uno Platform之间，WinUI具有很大的跨平台潜力。
- en: There will be multiple paths available for developers to create apps for Windows
    PCs and tablet devices. Other Windows devices, such as Xbox and HoloLens, will
    need to continue to develop UWP apps and use WinUI 2.x controls.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者将为Windows PC和平板设备创建应用提供多条路径。其他Windows设备，如Xbox和HoloLens，需要继续开发UWP应用并使用WinUI
    2.x控件。
- en: New features for WinUI 3 and the Windows App SDK
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinUI 3和Windows App SDK的新特性
- en: Are there any new features in WinUI 3?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 3有哪些新特性？
- en: While it sounded like the team was very busy creating a UI framework to replace
    the UWP UI libraries, they did find some time to add a few new features. The major
    new control available in WinUI 3 is the new `WebView2` control. It is a web browser
    host control based on the new Chromium-based **Microsoft Edge** browser. Compatibility
    is also a feature. All XAML and Composition features available in the Spring 2019
    Windows SDK will be backward-compatible, back to the Windows 10 1809 update and
    later.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来团队正忙于创建一个用于替换UWP UI库的UI框架，但他们确实抽出时间添加了一些新功能。WinUI 3中可用的主要新控件是新的`WebView2`控件。它是一个基于新Chromium内核的**Microsoft
    Edge**浏览器的网页浏览器宿主控件。兼容性也是一个特性。所有在2019年春季Windows SDK中可用的XAML和Composition功能都将向后兼容，回溯到Windows
    10 1809更新及以后版本。
- en: The Windows App SDK and WinUI
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows App SDK和WinUI
- en: WinUI 3 is bringing desktop application developers together on a single set
    of UI libraries, but that is only the beginning. At Microsoft’s Build 2020 conference,
    the Windows team announced **Project Reunion**, a long-term plan to bring all
    Windows developers together on a single platform. When WinUI was released in 2021,
    Project Reunion was renamed the Windows App SDK. WinUI 3 is focused on the UI
    layer, while the Windows App SDK will encompass WinUI and the entire Windows developer
    platform. In 2021, Microsoft released three versions of the Windows App SDK and
    WinUI 3.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 3正在将桌面应用程序开发者聚集在单一的UI库集合中，但这只是开始。在微软的Build 2020大会上，Windows团队宣布了**Project
    Reunion**，这是一个长期计划，旨在将所有Windows开发者聚集在单一平台上。当WinUI在2021年发布时，Project Reunion被更名为Windows
    App SDK。WinUI 3专注于UI层，而Windows App SDK将包括WinUI和整个Windows开发者平台。2021年，微软发布了三个版本的Windows
    App SDK和WinUI 3。
- en: To read more about the Windows App SDK and to follow its progress, you can check
    out the team’s GitHub repository at [https://github.com/microsoft/WindowsAppSDK](https://github.com/microsoft/WindowsAppSDK).
    Now, let’s see how WinUI compares to other Windows development frameworks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Windows App SDK及其进展，您可以查看团队在GitHub上的仓库[https://github.com/microsoft/WindowsAppSDK](https://github.com/microsoft/WindowsAppSDK)。现在，让我们看看WinUI与其他Windows开发框架相比如何。
- en: WinUI 3 compared to other Windows development frameworks
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WinUI 3与其他Windows开发框架的比较
- en: Where does WinUI fit into the overall landscape of Microsoft’s Windows development
    frameworks? Let’s draw some comparisons to help answer that question, starting
    with those that are most like WinUI.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI在微软的Windows开发框架的整体格局中处于什么位置？让我们通过一些比较来帮助回答这个问题，从与WinUI最相似的那些开始。
- en: WinUI versus UWP
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinUI与UWP
- en: This is a tricky comparison because WinUI apps today share the same XAML schema
    as UWP apps. In fact, WinUI 2.x are controls for UWP applications. They share
    the same XAML schema, base visuals, and underlying Windows APIs. Any UWP app that
    has the same minimum and target versions of Windows specified can add the WinUI
    2.x libraries to leverage the new and updated features. However, UWP will not
    receive any feature updates beyond WinUI 2.8\. Only security and bug-fix updates
    will be released as 2.8x minor releases.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个棘手的比较，因为WinUI应用程序今天与UWP应用程序共享相同的XAML架构。事实上，WinUI 2.x是UWP应用程序的控件。它们共享相同的XAML架构、基础视觉元素和底层Windows
    API。任何指定了相同的最小和目标Windows版本的UWP应用程序都可以添加WinUI 2.x库以利用新的和更新的功能。然而，UWP将不会收到WinUI
    2.8之后的任何功能更新。只有作为2.8x次要版本的补丁和安全更新将会发布。
- en: A key difference between apps that use WinUI versus traditional UWP apps is
    access to new and updated controls and other visual elements without requiring
    an updated Windows SDK. This enables developers to bring apps with the same look
    and features to more users across multiple versions of Windows 10 or Windows 11\.
    This differentiator makes for happier developers and users.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WinUI的应用程序与传统UWP应用程序之间的一个关键区别是，无需更新Windows SDK即可访问新的和更新的控件以及其他视觉元素。这使得开发者能够将具有相同外观和功能的软件带给更多使用Windows
    10或Windows 11多个版本的用户。这种差异化使得开发者和用户都更加满意。
- en: WinUI 3 also has the advantage of using the latest .NET version and C# language
    features. It will continue to benefit from these as new versions of .NET are released.
    As true .NET desktop apps, they are not constrained by the UWP sandbox. They have
    full access to hardware and the filesystem and can use most APIs. WinUI 3 apps
    also have more control over their Window size and appearance than UWP apps. However,
    developers who want to target platforms such as HoloLens or Xbox must stick with
    UWP development.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 3也有使用最新.NET版本和C#语言特性的优势。随着.NET新版本的发布，它将继续从中受益。作为真正的.NET桌面应用程序，它们不受UWP沙盒的限制。它们可以完全访问硬件和文件系统，并可以使用大多数API。WinUI
    3应用程序比UWP应用程序对它们的窗口大小和外观有更多的控制。然而，想要针对HoloLens或Xbox等平台进行开发的开发者必须坚持使用UWP开发。
- en: WinUI versus WPF
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinUI与WPF
- en: WinUI and WPF have many similarities. Both are application frameworks, and both
    types of apps rely on XAML to define UI elements. This means that they both offer
    the same separation of UI and business logic when implementing the MVVM pattern.
    WPF XAML has the same concepts of styles, resources, data binding, and adaptiveness
    as the UI layout.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI和WPF有许多相似之处。它们都是应用程序框架，这两种类型的应用程序都依赖于XAML来定义UI元素。这意味着在实现MVVM模式时，它们都提供了相同的UI和业务逻辑分离。WPF
    XAML具有与UI布局相同的样式、资源、数据绑定和自适应的概念。
- en: WinUI advantages
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinUI优势
- en: A significant performance advantage of WinUI is the availability of `x:Bind`
    syntax in XAML, rather than `Binding`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 的一个显著性能优势是 XAML 中 `x:Bind` 语法的使用，而不是 `Binding`。
- en: Unless your WinUI app is MSIX-packaged with `uap10:TrustLevel="appContainer"`,
    both WinUI and WPF have full access to users’ filesystems and devices. Their access
    is only limited by the configuration of **Windows User Account Control** (**UAC**)
    on the PC. WinUI has the advantage of using GPU-accelerated features such as Mica
    and Acrylic brushes to support the latest Windows styles such as Microsoft’s in-box
    apps. These styles are not available to WPF apps, making them feel less modern.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您的 WinUI 应用程序使用 `uap10:TrustLevel="appContainer"` 进行 MSIX 打包，否则 WinUI 和 WPF
    都可以完全访问用户的文件系统和使用设备。它们的访问仅受 PC 上 **Windows 用户账户控制** (**UAC**) 的配置限制。WinUI 有使用
    GPU 加速功能（如 Mica 和 Acrylic 毛刷）的优势，以支持最新的 Windows 风格，例如微软的内置应用程序。这些样式对 WPF 应用程序不可用，使它们感觉不那么现代。
- en: WPF advantages
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WPF 优势
- en: The primary advantage of WPF applications is the fact that they are not directly
    tied to minimum versions of Windows. WPF apps target a .NET version. Any version
    of Windows that supports the target .NET version can run that WPF app. This significantly
    increases the potential user base of WPF apps. In fact, WPF apps can be deployed
    and run on Windows 7 with .NET Framework, something not possible with UWP or WinUI.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 应用程序的主要优势是它们并不直接绑定到 Windows 的最低版本。WPF 应用程序针对 .NET 版本。任何支持目标 .NET 版本的 Windows
    版本都可以运行该 WPF 应用程序。这显著增加了 WPF 应用程序的可能用户基础。实际上，WPF 应用程序可以在带有 .NET Framework 的 Windows
    7 上部署和运行，这是 UWP 或 WinUI 所无法实现的。
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is a product called **Uno Platform** that enables WinUI XAML to run on
    iOS, Android, macOS, Linux, and even Samsung Tizen watches, and on the web with
    **WebAssembly**. These WinUI web apps can run in the browser on previous versions
    of Windows, including Windows 7\. The Uno Platform goal and tagline is *WinUI
    Everywhere*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 **Uno Platform** 的产品，它使 WinUI XAML 能够在 iOS、Android、macOS、Linux 以及三星 Tizen
    手表上运行，还可以在带有 **WebAssembly** 的网络上运行。这些 WinUI 网络应用程序可以在包括 Windows 7 在内的旧版 Windows
    版本的浏览器中运行。Uno Platform 的目标和口号是 *WinUI 到处都是*。
- en: Learn more about Uno Platform at [https://platform.uno/](https://platform.uno/).
    We will create an Uno Platform project in [*Chapter 13*](B20908_13.xhtml#_idTextAnchor570),
    *Taking Your App Cross-Platform with* *Uno Platform*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://platform.uno/](https://platform.uno/) 了解更多关于 Uno Platform 的信息。我们将在
    [*第 13 章*](B20908_13.xhtml#_idTextAnchor570) “使用 Uno Platform 将您的应用程序跨平台化”中创建一个
    Uno Platform 项目。
- en: Learn more about WebAssembly at [https://webassembly.org/](https://webassembly.org/).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://webassembly.org/](https://webassembly.org/) 了解更多关于 WebAssembly 的信息。
- en: A new WPF advantage emerged with the releases of .NET Core 3.x and .NET 5 and
    later. .NET developers can now create WPF apps with .NET Core, bringing performance
    and deployment advantages of the modern .NET to WPF developers. For instance,
    applications targeting different versions of .NET can be deployed side by side
    on a machine without creating version conflicts. However, as mentioned previously,
    WinUI 3 apps also leverage the latest .NET features and performance.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 WPF 优势随着 .NET Core 3.x 和 .NET 5 以及后续版本的发布而出现。.NET 开发者现在可以使用 .NET Core 创建
    WPF 应用程序，将现代 .NET 的性能和部署优势带给 WPF 开发者。例如，针对不同 .NET 版本的应用程序可以在不创建版本冲突的情况下在同一台机器上并行部署。然而，正如之前提到的，WinUI
    3 应用程序也利用了最新的 .NET 功能和性能。
- en: The difference in deployment models can be debated as to which framework has
    an advantage. The easiest way to deploy a WinUI app is through the Microsoft Store.
    The easiest way to deploy a WPF app with .NET is via an installer package. WPF
    apps can be deployed through the Store by adding a Windows MSIX packaging project,
    and WinUI apps can be deployed without the Store with MSIX installers or **Windows
    Package Manager**. WinUI deployment will be covered in detail in [*Chapter 14*](B20908_14.xhtml#_idTextAnchor582),
    *Packaging and Deploying* *WinUI Applications*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 关于部署模型的差异，可以争论哪个框架具有优势。部署 WinUI 应用程序最简单的方法是通过 Microsoft Store。使用 .NET 部署 WPF
    应用程序的最简单方法是使用安装程序包。WPF 应用程序可以通过添加 Windows MSIX 打包项目通过 Store 进行部署，而 WinUI 应用程序可以使用
    MSIX 安装程序或 **Windows 包管理器** 在没有 Store 的情况下进行部署。WinUI 部署将在 [*第 14 章*](B20908_14.xhtml#_idTextAnchor582)
    “打包和部署 WinUI 应用程序”中详细说明。
- en: WinUI versus Windows Forms (WinForms)
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WinUI 与 Windows Forms (WinForms)
- en: 'WinForms is a .NET UI framework that was introduced with .NET Framework 1.0\.
    Developers can easily create a WinForms UI with the visual design surface in Visual
    Studio, which generates C# or VB code that creates the UI at runtime. Most of
    the advantages and disadvantages of WPF also apply to WinForms: security, deployment,
    and .NET—WinForms apps can also be created with .NET Core 3.x and later.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: WinForms是随着.NET Framework 1.0一起引入的.NET UI框架。开发者可以使用Visual Studio中的可视化设计表面轻松创建WinForms
    UI，该表面会生成在运行时创建UI的C#或VB代码。WPF的大部分优势和劣势也适用于WinForms：安全性、部署和.NET——WinForms应用程序也可以使用.NET
    Core 3.x及更高版本创建。
- en: WinUI advantages
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinUI优势
- en: 'Similarities between WinUI and WPF are their primary advantages over WinForms:
    data binding, adaptive layout, and a flexible styling model. These advantages
    all stem from the use of XAML for UI layout. Another advantage of XAML is offloading
    render processing from the **central processing unit** (**CPU**) to the **graphics
    processing unit** (**GPU**). WinUI controls inherit the Windows styles by default
    and have a more modern appearance than WinForms controls. WinUI applications also
    handle **dots per inch** (**DPI**) scaling and touch input well. The WinForms
    UI framework matured before touch input and DPI scaling were a concern for Windows
    developers. Localization and UI performance are also big advantages of WinUI 3
    over WinForms.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI与WPF之间的相似之处在于它们相对于WinForms的主要优势：数据绑定、自适应布局和灵活的样式模型。这些优势都源于对XAML用于UI布局的使用。XAML的另一个优势是将渲染处理从**中央处理器**（**CPU**）卸载到**图形处理器**（**GPU**）。WinUI控件默认继承Windows样式，比WinForms控件看起来更现代。WinUI应用程序也很好地处理**每英寸点数**（**DPI**）缩放和触摸输入。WinForms
    UI框架在触摸输入和DPI缩放成为Windows开发者关注的问题之前就已经成熟。本地化和UI性能也是WinUI 3相对于WinForms的巨大优势。
- en: WinForms advantages
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinForms优势
- en: 'In addition to the advantages that WinForms shares with WPF over WinUI—greater
    access to Windows, .NET app, and Windows compatibility—WinForms also has a well-deserved
    reputation for rapid UI development. If you need to create a simple Windows application
    in a minimal amount of time, the drag-and-drop WinForms designer is easy and intuitive.
    WinForms has also received some recent updates to improve its data binding support,
    and it now has ICommand support for MVVM. For more information about these enhancements,
    see this .NET blog post: [https://devblogs.microsoft.com/dotnet/winforms-cross-platform-dotnet-maui-command-binding/](https://devblogs.microsoft.com/dotnet/winforms-cross-platform-dotnet-maui-command-binding/).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了WinForms与WinUI共享的Windows、.NET应用程序和Windows兼容性等优势之外，WinForms还因其快速UI开发而享有良好的声誉。如果你需要在最短的时间内创建一个简单的Windows应用程序，WinForms的拖放式设计器既简单又直观。WinForms最近也进行了一些更新，以改进其数据绑定支持，现在它还支持MVVM的ICommand。有关这些改进的更多信息，请参阅这篇.NET博客文章：[https://devblogs.microsoft.com/dotnet/winforms-cross-platform-dotnet-maui-command-binding/](https://devblogs.microsoft.com/dotnet/winforms-cross-platform-dotnet-maui-command-binding/).
- en: Many experienced Windows developers still default to WinForms when tasked with
    creating a simple utility or UI test harness for a .NET library.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 许多经验丰富的Windows开发者仍然在需要为.NET库创建简单的实用程序或UI测试框架时默认选择WinForms。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of the history of Windows application development in this chapter.
    We learned about the origins of UWP and its roots in Windows 8 apps and learned
    of the benefits of XAML when building Windows UIs. We had a taste of what some
    simple WinUI app code and UIs look like. Finally, we examined the recent history
    of WinUI versions and how WinUI 3 is a complete replacement for the UWP UI libraries
    and a viable option for WPF developers going forward.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Windows应用程序开发的历史。我们了解了UWP的起源及其与Windows 8应用程序的渊源，并学习了在构建Windows UI时XAML的优势。我们还体验了一些简单的WinUI应用程序代码和UI的样貌。最后，我们考察了WinUI版本的近期历史，以及WinUI
    3如何完全替代UWP UI库，并成为WPF开发者未来可行的选择。
- en: This will give you a good foundation of what’s to come as we start building
    an app with WinUI in the chapters ahead. In the next chapter, you will set up
    your development environment, learn about the app project that we will create
    throughout the book, and create your first WinUI 3 project. When we get to [*Chapter
    3*](B20908_03.xhtml#_idTextAnchor073), *MVVM for Maintainability and Testability*,
    we will refactor the app to use the MVVM pattern. This will set us up with a solid,
    maintainable design as we later add to and extend the app throughout the rest
    of the book.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们在接下来的章节中开始使用WinUI构建应用提供一个良好的基础。在下一章中，你将设置你的开发环境，了解我们将贯穿整本书创建的应用程序项目，并创建你的第一个WinUI
    3项目。当我们到达[*第3章*](B20908_03.xhtml#_idTextAnchor073)，*可维护性和可测试性的MVVM*时，我们将重构应用以使用MVVM模式。这将为我们提供一个稳固、可维护的设计，以便我们在整本书的其余部分添加和扩展应用。
- en: Questions
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which version of Windows first introduced UWP apps to developers?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个版本的Windows首次向开发者引入了UWP应用？
- en: What is the name of the pattern commonly used by WinUI and other XAML developers
    to separate the UI logic from the business logic?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WinUI和其他XAML开发者通常使用哪种模式来分离UI逻辑和业务逻辑？
- en: WinUI and WPF apps can share the same XAML. True or false?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WinUI和WPF应用可以共享相同的XAML。对还是错？
- en: Which was the first Microsoft UI framework to use XAML to define the UI?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个是第一个使用XAML来定义UI的Microsoft UI框架？
- en: What was the version number of the first WinUI release?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首次WinUI发布的版本号是多少？
- en: What is one of the benefits of developing with WinUI over WinForms?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用WinUI而不是WinForms进行开发有哪些好处？
- en: Can WinUI apps only be developed with .NET languages?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WinUI应用只能使用.NET语言开发吗？
- en: 'Challenge: create a style that will apply to `Button` elements.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：创建一个将应用于`Button`元素的样式。
