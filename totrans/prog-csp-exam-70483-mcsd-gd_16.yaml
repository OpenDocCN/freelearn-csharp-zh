- en: Serialization, Deserialization, and Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化、反序列化和集合
- en: When a .NET application interacts with an external network, the data being exchanged
    must be transformed into a flat or binary format. Similarly, when the data is
    retrieved from external applications, binary data needs to be formatted to objects
    on which they can then be worked upon. This is done via the serialization and
    deserialization of data using different approaches. The process of changing objects
    into binary format is referred to as serialization. Deserialization is the reverse
    of serialization. In involves transforming binary data into its object representation
    so that it can be used in the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当 .NET 应用程序与外部网络交互时，交换的数据必须转换为平面或二进制格式。同样，当从外部应用程序检索数据时，需要将二进制数据格式化为对象，以便可以在其上操作。这是通过使用不同方法对数据进行序列化和反序列化来完成的。将对象转换为二进制格式的过程称为序列化。反序列化是序列化的逆过程。它涉及将二进制数据转换为对象表示，以便可以在应用程序中使用。
- en: In this chapter, we will work on different serialization and deserialization
    approaches available in the .NET Framework. We will look into XML serialization,
    JSON serialization, and binary serialization. We will also look at how we define
    data contracts in web services to inform the consuming application of the format
    of the data that is to be exchanged between different applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 .NET 框架中可用的不同序列化和反序列化方法。我们将研究 XML 序列化、JSON 序列化和二进制序列化。我们还将探讨如何在 Web
    服务中定义数据合同，以通知消费应用程序不同应用程序之间交换的数据格式。
- en: We will then look at how we can use different collections objects such as arrays,
    lists, dictionary, queues, and stacks and we'll learn how they can be used for
    storing and consuming data. Finally, we will look at different things that help
    us choose collection objects while working with .NET applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接着探讨如何使用不同的集合对象，如数组、列表、字典、队列和栈，以及我们将学习它们如何用于存储和消费数据。最后，我们将探讨在处理 .NET 应用程序时，帮助我们选择集合对象的不同因素。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Serialization and deserialization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化和反序列化
- en: Working with collections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理集合
- en: Choosing a collection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择集合
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The programs explained in this book will be developed in Visual Studio 2017\.
    The sample code for this chapter can be found at GitHub at [https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所解释的程序将在 Visual Studio 2017 中开发。本章的示例代码可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples)。
- en: Serialization and deserialization
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化和反序列化
- en: While working with objects, we often find a need to either save them in different
    mediums such as a database or file or, in some cases, transfer them to other applications
    over a network. To do this, we must first convert the object into a stream of
    bytes—this process is known as **serialization**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理对象时，我们经常发现需要将它们保存到不同的介质中，如数据库或文件，或者在某些情况下，通过网络将它们传输到其他应用程序。为此，我们必须首先将对象转换为字节流——这个过程被称为**序列化**。
- en: Deserialization is the process of converting bytes received from the external
    application into objects that can be then used inside the application. With serialization,
    we can transform an object into bytes and save information related to its state,
    attributes, assembly version, and so on in external mediums such as databases,
    or we can exchange them on a network to external applications. An important thing
    to note here is that we can only apply serialization to objects and their attributes
    but not to their methods.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化是将从外部应用程序接收到的字节转换为可以在应用程序内部使用的对象的过程。通过序列化，我们可以将对象转换为字节，并将与其状态、属性、程序集版本等相关信息保存到外部介质中，如数据库，或者在网络中将它们交换到外部应用程序。在此需要注意的是，我们只能对对象及其属性应用序列化，而不能对它们的方法应用序列化。
- en: '.NET Framework provides us with the `System.Runtime.Serialization` namespace,
    which has got helper classes that help us serialize and deserialize the data.
    .NET provides us with three mechanisms for achieving this: XML serialization,
    JSON serialization, and data contract serialization.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework为我们提供了`System.Runtime.Serialization`命名空间，其中包含帮助类，帮助我们序列化和反序列化数据。.NET提供了三种实现此目的的机制：XML序列化、JSON序列化和数据合同序列化。
- en: In the next section, we will learn how we do serialization using `XMLSerializer`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用`XMLSerializer`进行序列化。
- en: XmlSerializer
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XmlSerializer
- en: In `XMLSerialization`, we convert the data into the format of an XML document,
    which can then be transferred easily across the network.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在`XMLSerialization`中，我们将数据转换为XML文档的格式，这样就可以轻松地在网络上传输。
- en: During deserialization, we can render an object from the same XML document format.
    `XMLSerializer` is based upon **Simple Object Access Protocol** (**SOAP**), a
    protocol for exchanging information with web services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在反序列化过程中，我们可以从相同的XML文档格式中渲染一个对象。`XMLSerializer`基于**简单对象访问协议**（**SOAP**），这是一种与Web服务交换信息的协议。
- en: 'While working with `XmLSerlializer`, we must mark our classes with the `Serializable`
    tag to inform the compiler that this class is serializable. Please refer to the
    following code implementation wherein we are using this tag against our class
    to inform the compiler that the class is `Serializable`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`XmLSerlializer`时，我们必须使用`Serializable`标记标记我们的类，以通知编译器这个类是可序列化的。请参考以下代码实现，其中我们使用此标记来通知编译器我们的类是`Serializable`的：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code implementation, we declared a `Student` class and specified
    it with the `FirstName`, `LastName`, and `ID` attributes. To inform the compiler
    that the class is serializable, we have used the `Serializable` tag on the class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码实现中，我们声明了一个`Student`类，并使用`FirstName`、`LastName`和`ID`属性对其进行指定。为了通知编译器该类是可序列化的，我们在类上使用了`Serializable`标记。
- en: 'Sometimes, we need to pick and choose the attributes that we would like to
    be serialized. In these cases, we can use the `NonSerialized` tag on the attribute
    and convey to the compiler that the attribute will not be serializable. Following
    is the code implementation for this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要选择我们希望序列化的属性。在这些情况下，我们可以在属性上使用`NonSerialized`标记，并通知编译器该属性将不可序列化。以下是为此提供的代码实现：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We used the `Serializable` tag on the class name but used the `NonSerialized`
    tag to indicate that the `ID` attribute cannot be serialized.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类名上使用了`Serializable`标记，但使用了`NonSerialized`标记来表示`ID`属性不能被序列化。
- en: 'Let''s go through a code implementation scenario where we will look at a code
    base in which we will serialize a class object using `XmlSerializer` and will
    save the file on the filesystem. This file can then be transferred across the
    network:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码实现场景来了解，我们将查看一个代码库，在这个代码库中，我们将使用`XmlSerializer`序列化一个类对象，并将文件保存到文件系统中。然后，该文件可以跨网络传输：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code example, we are using the same `Student` class we used
    in the previous example. We have created a dummy `Student` object and are then
    serializing the object into bytes. The bytes are then converted into a file using
    the `TextWriter` object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用了与上一个示例中相同的`Student`类。我们创建了一个虚拟的`Student`对象，然后将对象序列化为字节。然后，使用`TextWriter`对象将这些字节转换为文件。
- en: 'Once the preceding code gets executed, a file with the name `StudentData` gets
    created in the system:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行前面的代码，系统将创建一个名为`StudentData`的文件：
- en: '![](img/c7d7dcd6-9cb9-4af2-a1fb-ffbfff6b162a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7d7dcd6-9cb9-4af2-a1fb-ffbfff6b162a.png)'
- en: 'If we open the file in Internet Explorer, we will see the student data in XML
    format:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Internet Explorer中打开该文件，我们将以XML格式看到学生数据：
- en: '![](img/c5655cae-f6b7-461f-a02f-162c8a69c07c.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5655cae-f6b7-461f-a02f-162c8a69c07c.png)'
- en: 'In the preceding code example, there was no hierarchy in the data. All of the
    data is represented as an element in the XML file. However, in most situations,
    we will need to represent data that is following some sort of hierarchy. Using
    the preceding example, let''s try to represent the course scores for each of the
    students as well. Let''s say there are five courses: English, Maths, Physics,
    Chemistry, and Computers. Now, let''s try to represent the scores for each of
    the courses for the student using the following code implementation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，数据没有层次结构。所有数据都表示为XML文件中的一个元素。然而，在大多数情况下，我们需要表示遵循某种层次结构的数据。使用前面的例子，让我们尝试表示每个学生的课程分数。假设有五门课程：英语、数学、物理、化学和计算机。现在，让我们尝试使用以下代码实现来表示每个学生每门课程的分数：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding complete code can be found in the GitHub repository for this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段完整代码可以在本章的GitHub仓库中找到。
- en: 'In the preceding code implementation, we declared three classes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码实现中，我们声明了三个类：
- en: '`Course`: To represent the subject along with the description'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Course`: 用于表示科目及其描述'
- en: '`CourseScore`: To represent the score that a student is getting in that particular
    course'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CourseScore`: 用于表示学生在该特定课程中获得的分数'
- en: '`Student`: Has a list of `CourseScore` to represent the score the student gets
    in each subject'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Student`: 包含`CourseScore`列表，用于表示学生在每个科目中获得的分数'
- en: 'Please note the following tags we used in the classes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们在课程中使用的以下标签：
- en: '`XmlIgnore`: We use this tag against attributes that we don''t want to be saved
    in the generated XML class. In the preceding class example, we have used `XmlIgnore`
    against the `Feedback` class. This will ensure that the `Feedback` attribute will
    not be present in the generated XML file.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlIgnore`: 我们使用此标签针对我们不想在生成的XML类中保存的属性。在上面的类示例中，我们对`Feedback`类使用了`XmlIgnore`。这将确保`Feedback`属性不会出现在生成的XML文件中。'
- en: '`XmlElement`: We can use this tag if we want to represent an element in the
    generated XML. The element can then have attributes. In the preceding example,
    we used the `XmlElement` tag for the `Course` attribute. This will then enable
    us to add attributes of `Course Name` and `Course Description` in the generated
    XML file.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlElement`: 如果我们想在生成的XML中表示一个元素，可以使用这个标签。该元素可以具有属性。在上面的例子中，我们使用了`XmlElement`标签来表示`Course`属性。这将使我们能够在生成的XML文件中添加`Course
    Name`和`Course Description`属性。'
- en: '`XMLArray`: We use this tag when there can be multiple child records in this
    element. In the preceding example, we used the `XMLArray` tag for the `CourseScores`
    attribute to indicate that this is an element in the XML that can have multiple
    child records.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLArray`: 当此元素可以有多个子记录时，我们使用此标签。在上面的例子中，我们使用了`XMLArray`标签来表示`CourseScores`属性，以指示这是一个可以具有多个子记录的XML元素。'
- en: '`XMLArrayItem`: We use this tag to represent the individual child records in
    the `XMLArray` record. In the preceding example, we used the `XMLArrayItem` tag
    to represent individual records in the list collection variable, `CourseScores`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLArrayItem`: 我们使用此标签来表示`XMLArray`记录中的单个子记录。在上面的例子中，我们使用了`XMLArrayItem`标签来表示列表集合变量`CourseScores`中的单个记录。'
- en: 'If we need to serialize the data using `XMLSerialization`, we can use the following
    code. Once the code is executed, it will generate an XML file based on the data
    structure and tags used in the preceding declaration of the class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要使用`XMLSerialization`序列化数据，我们可以使用以下代码。一旦代码执行，它将根据前面类声明中使用的数据结构和标签生成一个XML文件：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the program is generated, note that an XML file, `StudentDataWithScores`,
    is generated. Now, open the XML file and review the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成后，请注意生成了一个XML文件，名为`StudentDataWithScores`。现在，打开XML文件并查看以下内容：
- en: '![](img/218ce068-28a3-439d-ae2b-11053466435c.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/218ce068-28a3-439d-ae2b-11053466435c.png)'
- en: 'Please note the following points in the structure of the XML file that is generated:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意生成的XML文件结构中的以下要点：
- en: In the XML file, there is no node for `Feedback` as it has been marked with
    the `XmlIgnore` tag in the `Student` class file.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XML文件中，没有`Feedback`节点，因为它在`Student`类文件中被标记为`XmlIgnore`标签。
- en: In the `Student` node, there is a `CourseScores` element node in line with the
    `XmlArray` tag that we used in the `CourseScore` list collection.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Student`节点中，有一个与我们在`CourseScore`列表集合中使用的`XmlArray`标签一致的`CourseScores`元素节点。
- en: In the element node, `CourseScores`, we have an individual node item element,
    `Course`, in line with `XmlArrayItem`, which we declared for each element in the
    `CourseScores` collection.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在元素节点`CourseScores`中，我们有一个与`XmlArrayItem`一致的单独节点元素`Course`，这是我们为`CourseScores`集合中的每个元素声明的。
- en: Each of the child item nodes has a `Score` attribute. It is in line with the
    tag—`XmlElement`—that we used for `CoursePerformance`; note that the XML also
    shows the name and description of the course.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子项节点都有一个`Score`属性。它与用于`CoursePerformance`的标签`XmlElement`一致；请注意，XML还显示了课程的名称和描述。
- en: 'Even though we''re using `XMLSerialization`, we can produce data that we can
    easily read, but there are certain issues with regard to `XmlSerialization`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用`XMLSerialization`，我们可以生成易于阅读的数据，但关于`XmlSerialization`存在某些问题：
- en: It consumes more space. If we are sharing XML files, they will ultimately end
    up saving space on the filesystem, which might not be ideal.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它消耗更多的空间。如果我们共享XML文件，它们最终会在文件系统中节省空间，这可能不是理想的。
- en: In addition to that, if we declare an attribute with the access modifier of
    `private`, it will not be picked during the XML serialization. For example, if
    we set the access modifier of the `LastName` attribute in the preceding example,
    we will see that the generated XML file will not have the attribute.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，如果我们用`private`访问修饰符声明一个属性，它将不会被XML序列化选中。例如，如果我们设置前面示例中`LastName`属性的访问修饰符，我们将看到生成的XML文件将没有这个属性。
- en: 'The following code is the updated set of access modifiers for the attributes
    in the `Student` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`Student`类中属性的更新访问修饰符集：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The access modifier for the `LastName` attribute has been changed from `public`
    to `private`. If we execute the project and open the XML file, we will observe
    that the `LastName` attribute no longer exists in the generated XML file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`LastName`属性的访问修饰符已从`public`更改为`private`。如果我们执行项目并打开XML文件，我们将观察到`LastName`属性不再存在于生成的XML文件中：'
- en: '![](img/88411386-5677-46c2-9331-dfcfd39c88d9.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88411386-5677-46c2-9331-dfcfd39c88d9.png)'
- en: In the next section, we will go through the binary serialization approach in
    C#.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过C#中的二进制序列化方法进行介绍。
- en: Binary serialization
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制序列化
- en: In `XmlSerialization`, the output of the serialization is an XML file that can
    be easily opened by Notepad. However, as explained previously, creating a file
    adds to the overall storage space required by the application, which may not be
    desirable in all circumstances.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`XmlSerialization`中，序列化的输出是一个可以轻松用记事本打开的XML文件。然而，正如之前解释的那样，创建文件会增加应用程序所需的总体存储空间，这在所有情况下可能都不是所希望的。
- en: We also observed that if we marked any attribute with the access modifier of
    `private`, it was not copied across to the generated XML file. This may also be
    an issue in many cases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还观察到，如果我们用`private`访问修饰符标记任何属性，它不会被复制到生成的XML文件中。这在许多情况下也可能是一个问题。
- en: In this section, we will look at an alternative approach in which we will serialize
    the data to a stream of bytes. This data will not be viewable like the XML file
    but will save us space and will deal with `private` attributes in a much better
    way.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一种替代方法，我们将数据序列化到一个字节流中。这些数据将无法像XML文件一样查看，但将节省空间，并且以更好的方式处理`private`属性。
- en: .NET Framework provides us with the `System.Runtime.Serialization` and `System.Runtime.Serialization.Formatters.Binary`
    namespaces, which provide us with helper classes for dealing with binary serialization.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework为我们提供了`System.Runtime.Serialization`和`System.Runtime.Serialization.Formatters.Binary`命名空间，它们为我们提供了处理二进制序列化的辅助类。
- en: 'To understand how binary serialization works, let''s look at the following
    example. We will work with `Student`, a similar class to what we created while
    we were working on XML serialization:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解二进制序列化是如何工作的，让我们看看以下示例。我们将使用`Student`类，这与我们在处理XML序列化时创建的类类似：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please note that in the class declaration, just like in `XmlSerialization`,
    we used a `Serializable` tag in the declaration of the `StudentBinary` class.
    This indicates to the compiler that the `StudentBinary` class can be serialized.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在类声明中，就像在`XmlSerialization`中一样，我们在`StudentBinary`类的声明中使用了`Serializable`标签。这向编译器指示`StudentBinary`类可以被序列化。
- en: 'We can use the following code to serialize and deserialize an object of this
    class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来序列化和反序列化此类的一个对象：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the code example, we created an object of the `StudentBinary` class and then
    used a helper class, `BinaryFormatter`, to serialize the data into binary data.
    Once the data is serialized, using the `FileStream` helper class, we saved this
    binary data in a binary file, `StudentBinaryData.bin`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们创建了一个`StudentBinary`类的对象，然后使用一个辅助类`BinaryFormatter`将数据序列化为二进制数据。一旦数据被序列化，使用`FileStream`辅助类，我们将这些二进制数据保存到一个二进制文件中，名为`StudentBinaryData.bin`。
- en: 'In the next step, we open the file we created in the previous step and deserialize
    it back to the `StudentBinary` class. If we try to debug the application and do
    a quick watch on the `studeseria` variable, we will see the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们打开上一步中创建的文件，并将其反序列化回`StudentBinary`类。如果我们尝试调试应用程序并对`studeseria`变量进行快速查看，我们将看到以下输出：
- en: '![](img/119bd568-b34a-4a55-b2d1-ee5a6f88f4c0.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/119bd568-b34a-4a55-b2d1-ee5a6f88f4c0.png)'
- en: 'Now let''s make one change to the preceding class: let''s mark the `LastName`
    attribute as `private`. When we used `XmlSerialization`, we saw that any attribute
    marked with the `private` access modifier was excluded from the attribute. Let''s
    do the same with binary serialization and observe the difference:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对前面的类进行一个更改：将`LastName`属性标记为`private`。当我们使用`XmlSerialization`时，我们看到了任何标记为`private`访问修饰符的属性都被排除在外。让我们用二进制序列化做同样的事情，并观察差异：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we now try to debug an application and do a QuickWatch on the `studeseria`
    variable, we will get the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试调试一个应用程序并对`studeseria`变量进行快速查看，我们将得到以下输出：
- en: '![](img/6d6deb19-d1f0-40b8-9049-4de1caf81a3d.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d6deb19-d1f0-40b8-9049-4de1caf81a3d.png)'
- en: Note that even though we made `LastName` as `private`, it has no impact on the
    output. This illustrates the advantage binary serialization has on `XmlSerialization`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们将`LastName`设置为`private`，但这并没有对输出产生影响。这说明了二进制序列化相对于`XmlSerialization`的优势。
- en: 'Just with `XmlSerialization`, we can also set tags on an attribute that would
    ensure that that attribute is ignored during the serialization. We can do it with
    the `NonSerialized` tag. In the following code implementation, we are using this
    tag for the `Feedback` attribute:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用`XmlSerialization`，我们也可以为属性设置标签，以确保在序列化过程中忽略该属性。我们可以使用`NonSerialized`标签来实现。在以下代码实现中，我们正在使用此标签为`Feedback`属性：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even though binary serialization allows us to overcome the restriction around
    any attribute that is marked with the `private` access modifier, there are still
    some scenarios when we would deliberately want to restrict the exchange of certain
    data, especially those attributes that are sensitive and that we would like to
    restrict anyhow. We can do this by using the `ISerializable` interface.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管二进制序列化使我们能够克服任何标记为`private`访问修饰符的属性的约束，但在某些情况下，我们仍然可能故意想要限制某些数据的交换，特别是那些敏感且我们无论如何都想限制的属性。我们可以通过使用`ISerializable`接口来实现这一点。
- en: 'In the following implemented code, we used a similar class, `StudentBinaryInterface`,
    and have implemented an `ISerializable` interface in it. As part of this interface,
    we must implement a `GetObjectData` method in this class. This method is classed
    when the class gets serialized. In this method, we will do encapsulation and not
    add any sensitive attributes to the serialized stream. Let''s have a look at how
    to do this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下实现的代码中，我们使用了一个类似的类`StudentBinaryInterface`，并在其中实现了`ISerializable`接口。作为此接口的一部分，我们必须在这个类中实现一个`GetObjectData`方法。当类被序列化时，将调用此方法。在这个方法中，我们将进行封装，并且不会将任何敏感属性添加到序列化的流中。让我们看看如何做到这一点：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code example, we declared the `LastName` attribute as `private`.
    Through this code, we will try to exclude this attribute from being serialized.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们将`LastName`属性声明为`private`。通过这段代码，我们将尝试排除此属性以进行序列化。
- en: 'There are two important functions in this class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中有两个重要的函数：
- en: '`GetObjectData`: As illustrated previously, this function is called when the
    class gets serialized. In this method, we will serialize the data present in `Firstname`,
    `Feedback`, and `ID`. Note that `LastName` is not present in this. This has been
    to make sure that the data in the `LastName` attribute will not be added to the
    stream.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetObjectData`: 如前所述，当类被序列化时，将调用此函数。在这个方法中，我们将序列化`Firstname`、`Feedback`和`ID`中存在的数据。请注意，`LastName`不包含在这个中。这是为了确保`LastName`属性中的数据不会被添加到流中。'
- en: 'Constructor: As the class implements the `ISerializable` interface, it must
    implement the following constructor with the parameters of `SerializationInfo`
    and `StreamingContext`:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：由于类实现了 `ISerializable` 接口，它必须实现以下带有 `SerializationInfo` 和 `StreamingContext`
    参数的构造函数：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This constructor will be called when the data will be deserialized into this
    class object. Note that in the constructor, we are accessing the values in the
    `Value1`, `Value2`, and `Value3` attributes and converting them into their respective
    mapped attributes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据被反序列化到这个类对象时，将调用此构造函数。注意，在构造函数中，我们正在访问 `Value1`、`Value2` 和 `Value3` 属性的值，并将它们转换为相应的映射属性：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we debug this code and do a QuickWatch on the `studeseria` variable, we
    get the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调试此代码并对 `studeseria` 变量进行快速监视，我们将得到以下输出：
- en: '![](img/53957262-df4b-48c2-935f-bc7769ec72f5.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53957262-df4b-48c2-935f-bc7769ec72f5.png)'
- en: Note that no value is present in the `LastName` attribute. In the next section,
    we will learn how to work with collections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`LastName` 属性中没有值。在下一节中，我们将学习如何处理集合。
- en: Working with collections
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作集合
- en: 'A collection in .NET defines a group of related data or elements. Elements
    can be variables of simple data types such as `int`, `float`, or `String` or can
    be complex data variables such as a class or structure. While working with .NET
    applications, we often need to work with such collections. We can execute operations
    such as these:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，集合定义了一组相关的数据或元素。元素可以是简单数据类型的变量，如 `int`、`float` 或 `String`，也可以是复杂的数据变量，如类或结构。在处理
    .NET 应用程序时，我们经常需要处理这样的集合。我们可以执行如下操作：
- en: Creating a collection
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建集合
- en: Adding an element to a collection
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向集合中添加元素
- en: Reading elements present in the collection
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取集合中的元素
- en: Removing elements present in the collection
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从集合中删除元素
- en: In this section, we will understand what the different types of collections
    available in .NET are and how programmers can execute operations on them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解 .NET 中可用的不同类型的集合以及程序员如何对它们执行操作。
- en: Arrays
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are the most basic collection variable available in .NET Framework. Arrays
    are used to store a group of data variables that are of the same type as `int`,
    `String`, and many more.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 .NET Framework 中可用的最基本集合变量。数组用于存储一组数据变量，这些变量的类型与 `int`、`String` 等相同。
- en: 'Let''s go through a code implementation in which we will create an array collection
    of `int` variables and then loop through them:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码实现来创建一个 `int` 变量的数组集合，然后遍历它们：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Please note the following in the code implementation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意代码实现中的以下内容：
- en: An array is declared by the `[]` syntax after the data type. In the implemented
    code, we are declaring an array of the `int` type.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组通过在数据类型之后使用 `[]` 语法来声明。在实现的代码中，我们声明了一个 `int` 类型的数组。
- en: While declaring the array collection, we must define the length of the array
    collection. In the code, we are declaring that the length of the array is `10`.
    This basically implies that the array can contain `10` elements of the `int` type.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明数组集合时，我们必须定义数组的长度。在代码中，我们声明数组的长度为 `10`。这基本上意味着数组可以包含 `10` 个 `int` 类型的元素。
- en: The index of the array starts at `0`. This implies that, in the preceding case,
    the first element will start at index `0` and will end at index `9`. If we need
    to refer to the elements present in the *i*^(th) index in the array, we can use
    the `array[i]` declaration.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的索引从 `0` 开始。这意味着，在前面的例子中，第一个元素将从索引 `0` 开始，并结束于索引 `9`。如果我们需要引用数组中第 *i* 个索引的元素，我们可以使用
    `array[i]` 表达式。
- en: Each array has a `length` property. This attribute indicates the maximum number
    of elements that can be present in the array. In the code, we are doing a `for`
    loop from `0` to `9` that is of the length -1 and are setting the value in each
    element present in that index.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个数组都有一个 `length` 属性。这个属性指示数组中可以存在的最大元素数量。在代码中，我们执行了一个从 `0` 到 `9` 的 `for` 循环，长度为
    -1，并设置每个索引处的元素值。
- en: Array implements the `IEnumerable` interface. Due to this, we can loop through
    the array using the `foreach` loop.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组实现了 `IEnumerable` 接口。因此，我们可以使用 `foreach` 循环遍历数组。
- en: 'On executing the preceding code, we get the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，我们得到以下输出：
- en: '![](img/0148d3f5-1152-48e0-bb87-10343f743202.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0148d3f5-1152-48e0-bb87-10343f743202.png)'
- en: 'In the code, we are setting values in each index of the array—the same value
    as the index in itself. Before we move ahead and start looking at the code examples,
    we need to understand two important concepts regarding arrays:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们在数组的每个索引处设置值——与索引本身相同的值。在我们继续前进并查看代码示例之前，我们需要了解关于数组的重要的两个概念：
- en: 'Multidimensional arrays: These are arrays in which we store elements in a matrix
    structure that has both rows and columns. For example, we can use the following
    code for declaring a multidimensional array:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多维数组：这些是存储在具有行和列的矩阵结构中的元素数组。例如，我们可以使用以下代码来声明一个多维数组：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The use of a single `,` mark during the array declaration indicates that this
    is a two-dimensional array. In the case of a two-dimensional array, the first
    dimension indicates the number of rows, while the second indicates the number
    of columns present in the array. Also, note that by using `3,2`, we are basically
    indicating that the number of rows in the array should be `3` while the number
    of columns should be `2`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组声明期间使用单个`,`标记表示这是一个二维数组。在二维数组的情况下，第一个维度表示数组的行数，而第二个维度表示数组中的列数。此外，请注意，通过使用`3,2`，我们实际上是在指示数组的行数应该是`3`，而列数应该是`2`。
- en: Just like in a normal array, in a multidimensional array, the index for both
    dimensions starts at `0`. Therefore, the first element will be present at index
    `{0,0}`, while the last element will be present at index `{2,1}`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在普通数组中一样，在多维数组中，两个维度的索引都是从`0`开始的。因此，第一个元素将存在于索引`{0,0}`处，而最后一个元素将存在于索引`{2,1}`处。
- en: 'Let''s look at the following code implementation, in which we will look at
    the code to loop through this multidimensional array and read each number present
    in the array:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码实现，我们将查看代码以遍历这个多维数组并读取数组中存在的每个数字：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code implementation, we are doing two nested loops. In the
    first loop, we are looping through the number of rows present in the multidimensional
    array. In the second loop, we are looping through the number of columns present
    in the multidimensional array. Using the `arrayInt[i, j]` syntax, we are printing
    the element present in that combination of rows and columns in the array.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码实现中，我们执行了两个嵌套循环。在第一个循环中，我们遍历多维数组中存在的行数。在第二个循环中，我们遍历多维数组中存在的列数。使用`arrayInt[i,
    j]`语法，我们打印出数组中该行和列组合的元素。
- en: 'When we execute the code, we get the following result. As we have to loop through
    the two-dimensional array using a nested loop, at each step, we will access elements
    present at position `{i, j}`. For each iteration of the `i` variable, the `j`
    variable will iterate from `0` to `1`. Hence, it will start at `{0,0}`, which
    will be `1` and will end at `{2,1}`, which will be `6`, hence generating the following
    output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，我们得到以下结果。由于我们必须使用嵌套循环遍历二维数组，在每一步中，我们将访问位置`{i, j}`的元素。对于`i`变量的每次迭代，`j`变量将从`0`迭代到`1`。因此，它将从`{0,0}`开始，这是`1`，并将结束于`{2,1}`，这是`6`，从而生成以下输出：
- en: '![](img/9b8b2a58-f2f9-4556-abdc-89d5f3f8a608.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b8b2a58-f2f9-4556-abdc-89d5f3f8a608.png)'
- en: 'In the next section, we will look at another collection type: lists.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看另一种集合类型：列表。
- en: Lists
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: While working on arrays, we learned that the length of an array must be specified
    when the array is declared. Also, we cannot increase the length of an array collection.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数组时，我们了解到在声明数组时必须指定数组的长度。此外，我们无法增加数组集合的长度。
- en: 'To overcome these issues, we can use the list collection. Lists provide us
    with several helper methods that help us to add and remove items in a list, sort
    a list, search in a list, and more. A list collection is declared by the following
    index:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，我们可以使用列表集合。列表为我们提供了几个辅助方法，帮助我们向列表中添加和删除项目，对列表进行排序，在列表中进行搜索等等。列表集合是通过以下索引声明的：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we go to the definition of a list, we will realize that, internally, it
    implements many interfaces, such as `IEnumerable`, `ICollection`, and `IList`.
    Due to these different interfaces, list collections are extremely powerful and
    provide different operations. The following screenshot shows what the definition
    of a list collection looks like in .NET:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看列表的定义，我们会意识到，在内部，它实现了许多接口，例如`IEnumerable`、`ICollection`和`IList`。由于这些不同的接口，列表集合非常强大，并提供了不同的操作。以下截图显示了在.NET中列表集合的定义看起来是什么样子：
- en: '![](img/c4cd2503-b725-4f02-be3d-a7ec811c95ef.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: The `IEnumerable` interface allows us to loop through the list collection using
    the `foreach` loop just as we did for arrays. The `ICollection` interface allows
    us to do operations such as count length, add a new element, and remove an element.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code implementation, in which we will execute
    all of these operations on the list:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s look at what we did in the preceding code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: We have created a list of `int` and added the elements 1-6.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are looping across the list using a `for` loop and we are printing the values
    present in it. To find the length or the number of elements present in a list,
    we are using the `Count` property.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To remove an element from a particular index, we can use the `Remove` method.
    In the preceding code implementation, we are removing the element present at index
    `1`.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add a new element in the list, we use the `Add` method. In the preceding
    code implementation, we are adding an element, `7`, to the list.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check whether an element is present in the list, we use the `Contains` method.
    In the preceding code implementation, we are checking whether a `4` element is
    present in the list.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we execute this, we get the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfdb2794-f71c-4f0d-8dc1-a817ecedc97b.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: One potential issue with a list collection is that we can have duplicate values
    in the list. For example, in the preceding example, it's possible to have two
    elements with the same value as `1` in the list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Due to this issue, we cannot use list collection in scenarios where we must
    ensure the uniqueness of values. In the next section, we will look at another
    collection dictionary that overcomes this issue with a list object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dictionary collection can be used in scenarios when we need to maintain
    uniqueness in values that are being saved. A dictionary collection is comprised
    of two parts: a key and a value. Together, they are referred to as a key-value
    pair in .NET. When a dictionary collection is created, it ensures that the key-value
    is unique and no duplicate keys are present in the collection. Retrieval is also
    based upon the key, making the operation extremely fast. A dictionary collection
    is declared by the following index:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code implementation, we are declaring a dictionary collection
    where both key and value are of the `int` format.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s right-click on the `Dictionary` class and click on Go to Definition.
    On doing this, we will be taken to the definition of the dictionary. Upon doing
    so, we will realize that it implements several interfaces such as `IEnumerable`,
    `ICollection<KeyValuePair<Tkey`, and `TValue>>`. Please refer to the following
    definition of the `Dictionary` class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59822b04-ebe1-4cdd-9a77-74228a97ce41.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Due to the implementation of the `ICollection` interface based on `KeyValuePair`,
    it ensures that the uniqueness is maintained based on the key.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code implementation, we will look at a code example wherein we will
    implement operations on the `Dictionary` object:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码实现中，我们将查看一个代码示例，其中我们将实现`Dictionary`对象上的操作：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Please note the following in the preceding code implementation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下前述代码实现中的要点：
- en: We have declared a dictionary collection variable. We have implemented a `for`
    loop that runs five times. In the loop, we are creating `KeyValuePair` and adding
    it to the dictionary object.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已声明一个字典集合变量。我们实现了一个运行五次的`for`循环。在循环中，我们创建`KeyValuePair`并将其添加到字典对象中。
- en: After we have added elements to the dictionary object, we are looping through
    the dictionary. We are doing it via a `foreach` loop on `KeyValuePair` present
    in the dictionary.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们将元素添加到字典对象之后，我们正在遍历字典。我们是通过在字典中存在的`KeyValuePair`上使用`foreach`循环来实现的。
- en: To remove a particular element from the dictionary, we can use the `Remove`
    method. The method takes the input of a key and, based on a key, deletes the respective
    `KeyValuePair` present in the dictionary.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从字典中删除特定元素，我们可以使用`Remove`方法。该方法接受一个键作为输入，并根据键删除字典中存在的相应`KeyValuePair`。
- en: To add a particular element in the dictionary, we can use the `Add` method.
    The method has two parameters, one of the key and another of the value.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在字典中添加特定元素，我们可以使用`Add`方法。该方法有两个参数，一个是键，另一个是值。
- en: To check whether a particular key is present in the dictionary, we can use the
    `ContainsKey` method. The method returns whether the given key exists in the dictionary.
    If the key exists, it returns `true` and, in other cases, it returns `false`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查特定键是否存在于字典中，我们可以使用`ContainsKey`方法。该方法返回给定键是否存在于字典中。如果键存在，它返回`true`，在其他情况下返回`false`。
- en: To check whether a particular value is present in the dictionary, we can use
    the `ContainsValue` method. The method returns whether the given value exists
    in the dictionary. If the value exists, it returns `true` and, in other cases,
    it returns `false`.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查特定值是否存在于字典中，我们可以使用`ContainsValue`方法。该方法返回给定值是否存在于字典中。如果值存在，它返回`true`，在其他情况下返回`false`。
- en: 'If the preceding code is executed, we get the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行前面的代码，我们将得到以下输出：
- en: '![](img/74220baa-fafd-4dc0-90ee-70ceb40fb5dc.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74220baa-fafd-4dc0-90ee-70ceb40fb5dc.png)'
- en: 'Please note the following points in the output of the code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下代码输出的要点：
- en: The values (`0`, `0`), (`1`, `100`), (`2`, `200`), (`3`, `300`), and (`4`, `400`)
    indicate the key-value pairs that are added in the dictionary.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值（`0`, `0`）、（`1`, `100`）、（`2`, `200`）、（`3`, `300`）和（`4`, `400`）表示在字典中添加的关键值对。
- en: '`5` indicates the length or number of elements present in the dictionary.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`表示字典中元素的数量或长度。'
- en: '`True` indicates that the dictionary contains `KeyValuePair` with the key `4`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`True`表示字典包含键为`4`的`KeyValuePair`。'
- en: '`False` indicates that the dictionary does not contain `KeyValuePair` with
    the value `900`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`False`表示字典不包含值为`900`的`KeyValuePair`。'
- en: 'Before we move to the next section, let''s try what would happen if we try
    to add `KeyValuePair` in the same dictionary in which the key already exists in
    the dictionary. For the sake of an example, we will add `KeyValue` of `(1, 1000)`.
    Please note that the key `1` is already present in the dictionary. When the code
    is executed, we get the following exception. The exception indicates that if we
    try to add a value with the same key in the dictionary, it will throw an error:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们尝试一下如果我们尝试在键已存在于字典中的相同字典中添加`KeyValuePair`会发生什么。为了举例，我们将添加`KeyValue`为`(1,
    1000)`。请注意，键`1`已经在字典中。当代码执行时，我们得到以下异常。异常表明，如果我们尝试在字典中添加具有相同键的值，它将抛出错误：
- en: '![](img/653ba67e-fd25-4f30-8974-769ee8363c12.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/653ba67e-fd25-4f30-8974-769ee8363c12.png)'
- en: 'In the next section, we will go over another set of collection objects: queues
    and stacks.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍另一组集合对象：队列和栈。
- en: Queues and stacks
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列和栈
- en: Queues and stacks are collection items that allow us to save data temporarily
    during the execution of the program. These collections are very similar to the
    other collections, such as lists, with the major difference being how elements
    are added and removed from the collection.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 队列和栈是允许我们在程序执行期间临时保存数据的集合项。这些集合与其他集合（如列表）非常相似，主要区别在于元素如何添加和从集合中删除。
- en: 'A queue is a first-in, first-out type of collection. It basically implies that
    elements are accessed from the queue in the same order they are added to the collection.
    When the items are accessed, they can also be removed in the same operation. A
    queue has three main operations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一种先进先出（FIFO）类型的集合。这基本上意味着元素是按照它们添加到集合中的相同顺序访问的。当访问项目时，它们也可以在同一个操作中移除。队列有三个主要操作：
- en: 'Adding a new element to the queue: It''s executed by the `Enqueue` method.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向队列中添加新元素：这是通过`Enqueue`方法执行的。
- en: 'Removing an existing element from the queue: It''s executed by the `Dequeue`
    method.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从队列中移除现有元素：这是通过`Dequeue`方法执行的。
- en: 'Peeking or retrieving the value of an element in the queue: It''s executed
    by the `Peek` method.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看或检索队列中元素的值：这是通过`Peek`方法执行的。
- en: 'This diagram shows how the queue works:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了队列的工作原理：
- en: '![](img/074aa130-4fac-489b-b76f-576f5d20cc42.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/074aa130-4fac-489b-b76f-576f5d20cc42.png)'
- en: 'In the preceding diagram, the block indicates a queue collection. In the collection,
    we have added five elements: element A, element B, element C, element D, and element
    E. Element E was the first element added to the queue and it''s at the front of
    the queue. Element A was the last element added to the queue and it''s at the
    back of the queue.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图中，方块表示队列集合。在集合中，我们添加了五个元素：元素A、元素B、元素C、元素D和元素E。元素E是第一个添加到队列中的元素，它位于队列的前端。元素A是最后一个添加到队列中的元素，它位于队列的末尾。
- en: The green arrows indicate the indexes in the queue at which the different operations
    will take place. The addition of a new element will always take place at the back
    of the queue. Removal of an element will take place at the front of the queue.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色箭头表示队列中不同操作将发生的索引。新元素的添加总是在队列的末尾进行。元素的移除总是在队列的前端进行。
- en: 'Let''s look at a code implementation to show how it''s done programmatically.
    In the following code, we have created a queue collection object. We will then
    add elements to the object and execute different operations on it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码实现来展示它是如何以编程方式完成的。在以下代码中，我们创建了一个队列集合对象。然后我们将元素添加到对象中，并对其执行不同的操作：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the preceding code is executed, we get the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前述代码时，我们得到以下输出：
- en: '![](img/e9ee75b7-c05b-4cfb-8c57-eab160abbd18.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9ee75b7-c05b-4cfb-8c57-eab160abbd18.png)'
- en: As illustrated by the queue diagram, when we add elements to the queue, they
    are always added to the end. Therefore, when we add the `E`, `D`, `C`, `B`, and
    `A` elements in the same order, `A` will always be at the back of the queue and
    `E` will be at the front of the queue. The indexes in the preceding output indicate
    the position in the queue where each respective element is present.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如队列图所示，当我们向队列中添加元素时，它们总是添加到队列的末尾。因此，当我们以相同的顺序添加`E`、`D`、`C`、`B`和`A`元素时，`A`将始终位于队列的末尾，而`E`将位于队列的前端。前述输出中的索引表示每个相应元素在队列中的位置。
- en: A peek operation in a queue is always done on the front index, that is, the
    `0` index of the queue. A removal operation in a queue is always done on the front
    index, that is, the `0` index of the queue. Therefore in the preceding output,
    both of these operations are executed on the element `E`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的查看操作总是在前端索引上执行，即队列的`0`索引。队列中的移除操作总是在前端索引上执行，即队列的`0`索引。因此，在前述输出中，这两个操作都是在元素`E`上执行的。
- en: Once these operations are done and we reiterate through the queue, we find that,
    owing to the remove operation, element `E` is no longer present in the queue.
    Now that we have an understanding of the queue, let's look at how a stack works
    in .NET Framework.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些操作并且我们再次遍历队列，我们会发现，由于移除操作，元素`E`不再存在于队列中。现在我们已经了解了队列的工作原理，让我们看看.NET Framework中栈是如何工作的。
- en: 'Just like a queue, the stack also provides temporary storage with the only
    difference being in terms of how the operations are executed on a stack. Stack
    follows the LIFO model, which implies that the last element added to the stack
    will be the first one to be removed. The following are the three main operations
    that we can do on a stack:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就像队列一样，栈也提供临时存储，唯一的区别在于在栈上执行操作的方式。栈遵循后进先出（LIFO）模型，这意味着最后添加到栈中的元素将是第一个被移除的。以下是我们可以在栈上执行的三种主要操作：
- en: Add a new element to the stack. It's executed by the `Push` method.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向栈中添加新元素。这是通过`Push`方法执行的。
- en: Remove an existing element from the stack. It's executed by the `Pop` method.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从栈中移除现有元素。这是通过`Pop`方法执行的。
- en: Peek or retrieve the value of an element in the stack. It's executed by the
    `Peek` method.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`Peek`方法检索栈中元素的值。这是通过`Peek`方法执行的。
- en: 'The following diagram shows how the stack works:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了栈的工作原理：
- en: '![](img/9ea5d145-ccfe-4b60-bef5-9d088e1f996e.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ea5d145-ccfe-4b60-bef5-9d088e1f996e.png)'
- en: 'In the diagram, the block indicates a stack collection. In the collection,
    we have added five elements: element A, element B, element C, element D, and element
    E. Element E was the first element added to the stack and it''s at the front of
    the stack. Element A was the last element added to the stack and it''s at the
    back of the stack.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中，方块表示一个栈集合。在集合中，我们添加了五个元素：元素A、元素B、元素C、元素D和元素E。元素E是第一个添加到栈中的元素，它在栈的前端。元素A是最后添加到栈中的元素，它在栈的后端。
- en: The green arrows indicate the indexes in the stack at which the different operations
    will take place. The addition of a new element will always take place at the bottom
    of the stack. The removal of an element will take place at the top of the stack.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色箭头表示不同操作将在栈中的哪些索引处进行。新元素的添加总是发生在栈的底部。元素的移除将发生在栈的顶部。
- en: 'Let''s look at a code implementation to show how it''s done programmatically.
    In the following code, we have created a stack collection object. We will then
    add elements in the object and execute different operations on it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码实现来展示它是如何程序化完成的。在下面的代码中，我们创建了一个栈集合对象。然后我们将向对象中添加元素并对其执行不同的操作：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the preceding code is executed, we get the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码时，我们得到以下输出：
- en: '![](img/0bc29428-0a7b-4de3-bc97-c6e27d4a908b.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bc29428-0a7b-4de3-bc97-c6e27d4a908b.png)'
- en: A `Peek` operation on a stack is always done on the last element added on the
    stack. Element `A` was the last element to be added to the stack. Therefore, when
    a `Peek` operation is done on the stack, it gives an output of `A`. Similarly,
    when a `Pop` operation is executed on the stack, it removes the element `A`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈上执行`Peek`操作总是针对最后添加到栈上的元素。元素`A`是最后添加到栈上的元素。因此，当在栈上执行`Peek`操作时，它给出输出`A`。同样，当在栈上执行`Pop`操作时，它移除了元素`A`。
- en: With this, we have gone through the different collections that are available
    in .NET. Each of these collection items has some properties that make them usable
    in some scenarios and not in others. These criteria need to be evaluated when
    we are trying to select a collection item to use.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经了解了.NET中可用的不同集合。每个这些集合项都有一些属性，使它们在某些场景中可用，而在其他场景中不可用。当我们试图选择要使用的集合项时，需要评估这些标准。
- en: In the next section, we will look at some of the criteria that help us to select
    the right collection item for each scenario.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些有助于我们为每个场景选择正确集合项的标准。
- en: Choosing a collection
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择集合
- en: 'While choosing a collection type, we have to analyze the scenarios in the application
    in which we want to use them. The primary difference between these collection
    types is the way we access elements in them:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择集合类型时，我们必须分析我们想要在应用程序中使用的场景。这些集合类型之间的主要区别在于我们访问它们元素的方式：
- en: The array collection needs to have a definite size or length while declaring
    itself. On the other hand, all other collection types can have their sizes increased
    dynamically. Also, arrays support random access to the data. This basically implies
    that as long as the element exists at the specified index in the array, we can
    access that element without needing to loop through the entire array.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明数组集合时，它需要有一个确定的大小或长度。另一方面，所有其他集合类型都可以动态地增加其大小。此外，数组支持对数据的随机访问。这基本上意味着只要元素存在于数组中指定的索引处，我们就可以访问该元素，而无需遍历整个数组。
- en: Queues and stacks allow us access the elements in a definite manner. While the
    queue works in a FIFO manner, the stack works in a LIFO manner.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列和栈允许我们以确定的方式访问元素。当队列以FIFO（先进先出）方式工作时，栈以LIFO（后进先出）方式工作。
- en: On the other hand, the list and dictionary collection types allow us to configure
    random access to the elements. Please note that, conceptually, the list does not
    support random access; however, in C#, the list is maintained as an array. Due
    to this, it supports random access.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，列表和字典集合类型允许我们配置对元素的随机访问。请注意，从概念上讲，列表不支持随机访问；然而，在C#中，列表被维护为一个数组。因此，它支持随机访问。
- en: One important difference between a list and dictionary is the way they save
    data as well as the performance. In the dictionary collection, we save data in
    `KeyValuePair`. This allows us to maintain the uniqueness of the keys that are
    present in the dictionary. On the other hand, a list does not provide us with
    that feature.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和字典之间的重要区别在于它们保存数据的方式以及性能。在字典集合中，我们使用 `KeyValuePair` 保存数据。这允许我们保持字典中存在的键的唯一性。另一方面，列表不提供这项功能。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how we serialize and deserialize data while
    exchanging it over a network. We looked at the different techniques available
    for serialization and deserialization. We started with `XmlSerialization` and
    saw how we serialize the data to XML files. We also looked at different attribute
    tags, such as `XmlArray`, `XmlArrayItem`, and `XmlIgnore`, which we can place
    in the class object when it's being converted into an XML file. We then looked
    at binary serialization and learned the advantages it has compared to `XmlSerialization`.
    We also looked at the `ISerializable` interface and learned how it provides security
    while exchanging data over the network.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在通过网络交换数据时进行序列化和反序列化。我们探讨了序列化和反序列化的不同技术。我们从 `XmlSerialization` 开始，看到了如何将数据序列化到
    XML 文件中。我们还探讨了不同的属性标签，如 `XmlArray`、`XmlArrayItem` 和 `XmlIgnore`，我们可以在将类对象转换为 XML
    文件时放置这些标签。然后，我们探讨了二进制序列化，并学习了它相对于 `XmlSerialization` 的优势。我们还探讨了 `ISerializable`
    接口，并学习了它在通过网络交换数据时如何提供安全性。
- en: We then looked at different collection types available in C# and the scenarios
    in which we should use each of them. We looked at arrays and their restrictions
    in terms of the length or size of the array, which we must declare during the
    declaration of the array. We then looked at some other complex collection types,
    such as list and dictionary. Both of these collection items allow us to increase
    the collection size during execution but differ in the way they access data. A
    dictionary saves the data in `KeyValuePair` and enforces the uniqueness of the
    keys that are present in the collection type.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后探讨了 C# 中可用的不同集合类型以及我们应该在什么情况下使用它们。我们探讨了数组及其在数组声明时必须声明的长度或大小的限制。然后，我们探讨了其他一些复杂的集合类型，例如列表和字典。这两个集合项都允许我们在执行过程中增加集合大小，但它们在访问数据的方式上有所不同。字典将数据保存在
    `KeyValuePair` 中，并强制集合类型中键的唯一性。
- en: Then, we looked at queues and stack collection types. As opposed to lists and
    dictionaries, which allow random access to the data, stacks and queues allow us
    to access to data in a particular order. Queues follow the FIFO model, while stacks
    follow the FILO model.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了队列和栈集合类型。与允许随机访问数据的列表和字典不同，栈和队列允许我们以特定顺序访问数据。队列遵循 FIFO 模型，而栈遵循 FILO
    模型。
- en: Questions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following statements are true?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？
- en: During serialization, `XmlSerialization` automatically includes private attributes
    in the generated XML class.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在序列化过程中，`XmlSerialization` 会自动将私有属性包含在生成的 XML 类中。
- en: In `XmlSerialization`, the `XmlIgnore` tag can be used to exclude any attribute
    that we don't want to include in the generated XML class.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `XmlSerialization` 中，可以使用 `XmlIgnore` 标签来排除我们不想包含在生成的 XML 类中的任何属性。
- en: In binary serialization, private marked attributes are not serialized.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在二进制序列化中，标记为私有的属性不会被序列化。
- en: Using the `ISerializable` interface, we can select the attributes and their
    tags that we want to be present in serialization.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ISerializable` 接口，我们可以选择在序列化中要包含的属性及其标签。
- en: Which of the following statements are true?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？
- en: We can increase the size of an array collection type during program execution.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在程序执行期间增加数组集合类型的大小。
- en: Queues follow the LIFO model for accessing elements.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列遵循 LIFO 模型来访问元素。
- en: A dictionary saves data in `KeyValuePair`, ensuring the uniqueness of key-value
    pairs present in the collection item.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字典在 `KeyValuePair` 中保存数据，确保了集合项中键值对的唯一性。
- en: Both a list and dictionary allow random access to the data elements.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表和字典都允许随机访问数据元素。
- en: You are working with a large group of `student` objects. You need to remove
    all duplicates and then group them by `studentid`. Which collections should we
    use?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在处理一组大量的 `student` 对象。你需要移除所有重复项，然后按 `studentid` 对它们进行分组。我们应该使用哪些集合？
- en: List
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表
- en: Stack
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栈
- en: Dictionary
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字典
- en: Queue
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列
- en: Answers
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**b and d**'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**b 和 d**'
- en: '**c and d**'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**c 和 d**'
- en: '**c**'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**c**'
