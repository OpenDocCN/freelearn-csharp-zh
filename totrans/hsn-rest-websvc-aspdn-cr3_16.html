<html><head></head><body>
        

                            
                    <h1 class="header-title">Service Ecosystem Patterns</h1>
                
            
            
                
<p class="mce-root">In the previous chapter, we provided an overview of the containerization process and how to use containers to run a service. We also learned how to host the catalog service on containers using Docker and how to use the multistage build approach to create and run our container images.</p>
<p class="mce-root">This chapter focuses on some patterns that are used when multiple services are part of the same ecosystem. Then, we will look at the implementation of the communication between those services. We will also learn how to build a resilient connection between various web services that are part of the same system in order to avoid some of the common pitfalls related to data exchange.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>An introduction to the cart service</li>
<li>Implementing resilient communication using an HTTP client</li>
<li>An introduction to event buses</li>
<li>How to perform event bus communication using RabbitMQ</li>
</ul>
<p>By the end of this chapter, you will have a general understanding of how to improve resilience using <kbd>Polly</kbd> and how to use an event bus to exchange information between two systems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An introduction to the cart service</h1>
                
            
            
                
<p>While the <kbd>Catalog.API</kbd> project handles the catalog items of our store, we don't have anything that handles the cart features. In this section, we will discover a new .NET Core solution that implements a cart service to do this for us. Furthermore, we will introduce a new implementation approach: the <strong>mediator pattern</strong>. Before we walk through the implementation of this new service, let's take a look at an overview of the project structure, which provides the catalog service and cart service solutions:</p>
<div><img src="img/c779dff6-90f2-4501-8699-c53546ea00fd.png" style=""/></div>
<p>The preceding schema describes the project structure of the catalog service and<em> </em>the cart service<em>.</em> As we already know, the catalog service implements the <kbd>API</kbd>, <kbd>Domain</kbd>, and <kbd>Infrastructure</kbd> projects in order to separate the different layers of the implementation and that it uses SQL Server, combined with Entity Framework Core, as the main data source. However, although the cart service follows a similar project structure, it uses a slightly different implementation pattern and stores cart data in Redis. Therefore, Redis, which is mainly used for caching purposes, offers a very lightweight/high-performance key-value data store that can be also used as a database.</p>
<p>The cart service solution has the following structure:</p>
<ul>
<li>The <kbd>Cart.API</kbd> project contains the controller, which handles the incoming HTTP request from the client. It also includes the error processing aggregation point and the <kbd>Startup</kbd> class, which initializes the dependency injection engine.</li>
<li>The <kbd>Cart.Domain</kbd> project contains the mediator logic and the handlers that dispatch the operations to the underlying layers. Furthermore, it also includes the entities that are used by the application.</li>
<li>The <kbd>Cart.Infrastructure</kbd> project is the bridge between the web services and their dependencies, such as the data store and other third-party services.</li>
</ul>
<p>This chapter won't look at the development process of the cart service in detail: some of the technical aspects have already been discussed, namely, in <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, <em>Building the Data Access Layer, </em><a href="f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml">Chapter 9</a>, <em>Implementing the Domain Logic</em>, and <a href="266d98e8-df54-4024-aefb-b5871b3b35fa.xhtml">Chapter 10</a>, <em>Implementing the RESTful HTTP Layer</em>. The introduction to the cart service will be useful for you to determine the different communication techniques between multiple web services. Although this chapter will cover some of the key parts of the implementation, such as the handlers, in order to proceed, you need to download the cart service source code from <a href="https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3">https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The theory behind the mediator pattern</h1>
                
            
            
                
<p>The mediator pattern is a way to encapsulate logic behind a unique entry point. It uses the concept of requests, responses, commands, or events to abstract the implementations behind a single entry point. This way of implementing the application logic helps the developers in your team keep the logic separated from the web part of the application. To understand how the mediator pattern works, let's take a look at its components.</p>
<p>The preceding schema describes a simple implementation of the mediator pattern. The consumer of the mediator calls the <kbd>Send</kbd> method by referring to the <kbd>IMediator</kbd> interface. The mediator implementation passes a specific type of the <kbd>IRequest</kbd> interface. Therefore, the <kbd>Mediator</kbd> instance dispatches the messages to the destination handler, which is represented by the <kbd>IMessageHandler</kbd> implementation, using the concrete implementation of the <kbd>IRequest</kbd> interface. In the next chapter, we will learn how to use an <kbd>IMediator</kbd> interface to dispatch messages to specific handlers.</p>
<p>Furthermore, we will use the mediator pattern with the command approach. There are slightly different ways to implement the mediator pattern. The project that we'll be covering in this chapter uses a very popular mediator NuGet packaged called <strong>MediatR</strong>. MediatR is an all-in-one implementation of the mediator pattern that covers in-process messaging. You can find more information about the MediatR project on GitHub: <a href="https://github.com/jbogard/MediatR">https://github.com/jbogard/MediatR</a>.</p>
<p>For the purpose of the <em>cart service</em> implementation, we're going to use the following components, all of which have been exposed by the MediatR library:</p>
<ul>
<li>The <kbd>IMediator</kbd> interface is the main entry point of the mediator pattern. It exposes a <kbd>Send</kbd> method, which is used to dispatch a command or a request to a specific handler in order to obtain a result.</li>
<li>The <kbd>IRequestHandler</kbd> interface is a generic interface that's used to define the implementation of a handler. Each <kbd>IRequestHandler</kbd> type requires an <kbd>IRequest</kbd> type, which represents the request that's sent through the <kbd>IMediator</kbd> interface.</li>
<li>The <kbd>IRequest</kbd> interface defines the request or the command type that's used to execute a specific handler.</li>
</ul>
<p>Now that we have more information about how the mediator pattern works, we can continue with the concrete implementation of the cart service solution. In the next section, we will look at how we can define the domain model of the service and implement the data access layer abstraction over the Redis data store. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">The domain model and the data access layer</h1>
                
            
            
                
<p>The domain model of the cart service represents the entities that we require to describe the cart session of a user. Specifically, the domain model of the cart service implements three different entity classes: <kbd>Cart</kbd>, <kbd>CartItem</kbd>, and <kbd>CartUser</kbd>. Like the catalog service, all the entities are stored in the <kbd>Cart.Domain</kbd> project, which will be referred to by the <kbd>Cart.Infrastructure</kbd> and <kbd>Cart.API</kbd> projects. </p>
<p>Let's start with the <kbd>CartSession</kbd> class, which represents a single cart session:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/><br/>namespace Cart.Domain.Entities<br/>{<br/>    public class CartSession<br/>    {<br/>        public string Id { get; set; }<br/>        public IList&lt;CartItem&gt; Items { get; set; }<br/>        public CartUser User { get; set; }<br/>        public DateTimeOffset ValidityDate { get; set; }<br/>    }<br/>}</pre>
<p>The <kbd>CartSession</kbd> entity represents a single cart instance that's been created by a user. Therefore, it refers to the <kbd>CartUser</kbd> class, which contains the user's information. Besides, the <kbd>CartSession</kbd> entity also provides the <kbd>IList&lt;CartItems&gt;</kbd> field, which represents the items in the cart and the quantity associated with each item. Let's proceed by also defining the <kbd>CartItem</kbd> class:</p>
<pre>using System;<br/><br/>namespace Cart.Domain.Entities<br/>{<br/>    public class CartItem<br/>    {<br/>        public Guid CartItemId { get; set; }<br/><br/>        public int Quantity { get; set; }<br/><br/>        public void IncreaseQuantity()<br/>        {<br/>            Quantity = Quantity + 1;<br/>        }<br/><br/>        public void DecreaseQuantity()<br/>        {<br/>            Quantity = Quantity - 1;<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>CartItem</kbd> class implements a <kbd>CartItemId</kbd> field and a <kbd>Quantity</kbd> field. Furthermore, it also provides the <kbd>IncreaseQuantity</kbd> and <kbd>DecreaseQuantity</kbd> fields, which are used to increment and decrement the quantity of a specific item, respectively. Finally, it is possible to determine the <kbd>CartUser</kbd> class, which represents the user related to the cart:</p>
<pre>namespace Cart.Domain.Entities<br/>{<br/>    public class CartUser<br/>    {<br/>        public string Email { get; set; }<br/>    }<br/>}</pre>
<p>For demonstration purposes, we are representing <kbd>CartUser</kbd> with only one property; this will contain the email of the user. The preceding entities are stored in the <kbd>Entities</kbd> folder, inside the <kbd>Cart.Domain</kbd> project. </p>
<p>Once we have defined the domain model, we can proceed with the implementation of the data access abstraction. Specifically, the cart service will use the same access pattern we defined previously for the catalog service in order to get information about the cart sessions:</p>
<pre>// <strong>src/Cart.Domain/Repositories/ICartRepository.cs</strong><br/><br/>using System;<br/>using System.Collections.Generic;<br/>using System.Threading.Tasks;<br/>using Cart.Domain.Entities;<br/><br/>namespace Cart.Domain.Repositories<br/>{<br/>    public interface ICartRepository<br/>    {<br/>        IEnumerable&lt;string&gt; GetCarts();<br/>        Task&lt;CartSession&gt; GetAsync(Guid id);<br/>        Task&lt;CartSession&gt; AddOrUpdateAsync(CartSession item);<br/>    }<br/>}</pre>
<p>The <kbd>ICartRepository</kbd> method implements methods that retrieve and update our data, the <kbd>GetCarts</kbd> method retrieves the IDs of the current carts, and the <kbd>GetAsync</kbd> method gathers information about a specific cart. Finally, the <kbd>AddOrUpdateAsync</kbd> method allows us to update or add a new cart if it's not present in the data store, while <kbd>ICartRepository</kbd> defines the operations that are performed by our data store. In the next subsection, we will look at a concrete implementation of the <kbd>CartRepository</kbd> class.</p>
<p>This domain model has been simplified to provide an example of a possible implementation of the cart. In a real-world application, we should consider other essential information about the state of a cart.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The ICartRepository Redis implementation</h1>
                
            
            
                
<p>The cart service uses Redis (<a href="https://redis.io/">https://redis.io/</a>) to store the cart's data. The actual implementation of the <kbd>CartRepository</kbd> class of the cart service uses a NuGet package powered by Stack Exchange called <kbd>StackExchange.Redis</kbd>. Furthermore, we will use the <kbd>Newtonsoft.Json</kbd> package to serialize the objects into Redis using JSON format.</p>
<p>The concrete implementation of the <kbd>CartRepository</kbd> class will be located in the <kbd>Cart.Infrastructure</kbd> project, while the <kbd>ICartRepository</kbd> interface type will be located in the <kbd>Cart.Domain</kbd> project. Furthermore, the <kbd>Cart.Infrastructure</kbd> project will also depend on the <kbd>StackExchange.Redis</kbd> and <kbd>Newtonsoft.Json</kbd> packages. The <kbd>StackExchange.Redis</kbd> library provides a low-level abstraction of Redis, so that our .NET applications can read or write data on a Redis instance. Let's take a look at the implementation of the <kbd>CartRepository</kbd> class:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Threading.Tasks;<br/>using Cart.Domain.Entities;<br/>using StackExchange.Redis;<br/>using Cart.Domain.Repositories;<br/>using Cart.Infrastructure.Configurations;<br/>using Microsoft.Extensions.Options;<br/>using Newtonsoft.Json;<br/><br/>namespace Cart.Infrastructure.Repositories<br/>{<br/>    public class CartRepository : ICartRepository<br/>    {<br/>        private readonly IDatabase _database;<br/>        private readonly CartDataSourceSettings _settings;<br/><br/>        public CartRepository(IOptions&lt;CartDataSourceSettings&gt; options)<br/>        {<br/>            _settings = options.Value;<br/><br/>            var configuration = ConfigurationOptions<br/>                .Parse(_settings.RedisConnectionString);<br/><br/>            try<br/>            {<br/>                _database = ConnectionMultiplexer<br/>                    .Connect(configuration).GetDatabase();<br/>            }<br/>            catch (Exception e)<br/>            {<br/>                Console.WriteLine(e.ToString());<br/>            }<br/>        }<br/>        ...<br/>    }<br/>}</pre>
<p>The <kbd>CartRepository</kbd> class uses the <kbd>StackExchange.Redis</kbd> library to interact with a Redis instance. It declares an <kbd>IDatabase</kbd> property, which represents a connection with the Redis instance, and it uses a custom settings class that defines the connection string associated with the Redis instance. During the initialization of the class, the constructor calls the <kbd>ConnectionMultiplexer</kbd> static instance to create a new database connection. Let's proceed by having a look at the <kbd>ICartRepository</kbd> interface method's implementations:</p>
<pre>...<br/><br/>        public IEnumerable&lt;string&gt; GetCarts()<br/>        {<br/>            var keys = _database.Multiplexer.GetServer<br/>                (_settings.RedisConnectionString).Keys();<br/><br/>            return keys?.Select(k =&gt; k.ToString());<br/>        }<br/><br/>        public async Task&lt;CartSession&gt; GetAsync(Guid id)<br/>        {<br/>            var data = await _database.StringGetAsync(id.ToString());<br/><br/>            return data.IsNullOrEmpty<br/>                ? null<br/>                : JsonConvert.DeserializeObject<br/>                   &lt;Domain.Entities.CartSession&gt;(data);<br/>        }<br/><br/>        public async Task&lt;CartSession&gt; AddOrUpdateAsync(CartSession <br/>            item)<br/>        {<br/>            var created = await _database.StringSetAsync(item.Id, <br/>                JsonConvert.SerializeObject(item));<br/><br/>            if (!created) return null;<br/><br/>            return await GetAsync(new Guid(item.Id));<br/>        }<br/>..</pre>
<p>The preceding code defines the core methods of the <kbd>ICartRepository</kbd> interface. The <kbd>GetCarts</kbd> method gathers all the keys that represent all the cart IDs stored in the Redis instance. The <kbd>GetAsync</kbd> method retrieves the details of a card by passing the ID of a specific cart and deserializing the resulting content in the <kbd>CartSession</kbd> entity. Finally, the <kbd>AddOrUpdateAsync</kbd> method adds or updates the information related to a cart ID by serializing its content and updating the data source using the <kbd>StringSetAsync</kbd> method, which is provided by the library. We are using Redis because, as an in-memory data structure store, it can retrieve information very quickly. In general, Redis' primary purpose is to act as a caching system, but it can also be used to store information temporarily. Redis is not the best system to prevent data loss, however. All the data is processed in memory and it can only be saved by making a snapshot of the current state of memory. For more information, visit the following website: <a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>.</p>
<p>The preceding implementation of <kbd>CartRepository</kbd> produces two main pitfalls. First of all, Redis is not a database that's designed to scan and retrieve multiple keys. Furthermore, this kind of data store is designed to perform O(1) operations, just like a hash table or a dictionary. Therefore, the <kbd>GetCarts</kbd> method is very performance inefficient. An alternative and more efficient approach would be to store the list IDs in a specific and unique field and keep them updated every time we add/remove new cart records. Secondly, although the constructor of the <kbd>CartRepository</kbd> class calls the <kbd>ConnectionMultiplexer</kbd> static class every time the class is initialized, it is strongly suggested that you initialize the <kbd>IConnectionMultiplexer</kbd> interface as a singleton instance in order to avoid performance pitfalls.</p>
<p>The next subsection describes the implementation of the handlers that expose the cart operations through the mediator logic. Furthermore, the handlers will call the underlying <kbd>ICartRepository</kbd> interface in order to perform the I/O process on Redis. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handlers and routes implementation</h1>
                
            
            
                
<p>The <em>cart service</em> implements the handlers that reflect the different actions that occur on cart data in the domain part of our service. As we will see later in this chapter, the handlers are associated with a specific request and are executed by the <kbd>IMediator</kbd> interface, which is provided by the MediatR library. Also, in this case, these classes are located in the <kbd>Cart.Domain</kbd> project.</p>
<p>Let's start by taking a look at the implementation of the <kbd>CreateCartHandler</kbd> class:</p>
<pre><strong>//Handlers/Cart/CreateCartHandler.cs<br/></strong><br/>using System;<br/>...<br/><br/>namespace Cart.Domain.Handlers.Cart<br/>{<br/>    public class CreateCartHandler : IRequestHandler&lt;CreateCartCommand, CartExtendedResponse&gt;<br/>    {<br/>        private readonly ICatalogService _catalogService;<br/>        private readonly IMapper _mapper;<br/>        private readonly ICartRepository _repository;<br/><br/>        public CreateCartHandler(ICartRepository repository, IMapper <br/>            mapper, ICatalogService catalogService)<br/>        {<br/>            _repository = repository;<br/>            _mapper = mapper;<br/>            _catalogService = catalogService;<br/>        }<br/><br/>        public async Task&lt;CartExtendedResponse&gt; Handle<br/>            (CreateCartCommand command, CancellationToken <br/>            cancellationToken)<br/>        {<br/>            var entity = new CartSession<br/>            {<br/>                Items = command.ItemsIds.Select(x =&gt; new CartItem { <br/>                  CartItemId = new Guid(x), Quantity = 1 }).ToList(),<br/>                  User = new CartUser { Email = command.UserEmail },<br/>                  ValidityDate = DateTimeOffset.Now.AddMonths(2),<br/>                  Id = Guid.NewGuid().ToString()<br/>            };<br/><br/>            var result = await _repository.AddOrUpdateAsync(entity);<br/><br/>            var response = _mapper.Map&lt;CartExtendedResponse&gt;(result);<br/><br/>            var tasks = response.Items<br/>                .Select(async x =&gt; await _catalogService<br/>                .EnrichCartItem(x, cancellationToken));<br/><br/>            response.Items = await Task.WhenAll(tasks);<br/><br/>            return response;<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code is the definition of the <kbd>CreateCartHandler</kbd> class, which performs the creation cart process. The class uses the constructor injection technique to resolve the dependencies through the dependency injection engine of ASP.NET Core. Furthermore, the handler class depends on the <kbd>IMapper</kbd> and <kbd>ICartRepository</kbd> interfaces: the <kbd>IMapper</kbd> interface is used to map the <kbd>CartSession</kbd> instances with the <kbd>CartExtendedResponse</kbd> response class, while the <kbd>ICartRepository</kbd> interface is used to store the cart data on Redis through the use of the <kbd>AddOrUpdateAsync</kbd> method. </p>
<p>The handler assigns a new <kbd>Guid</kbd> to the entity and it adds a <kbd>ValidityDate</kbd> of 2 months. Furthermore, it also assigns the new cart items list to the cart session by setting a default quantity of 1 for each item. In a similar manner, the <kbd>GetCartHandler</kbd> class implements the reading operations based on the <kbd>Id</kbd> of the cart:</p>
<pre>using System.Threading;<br/>...<br/><br/>namespace Cart.Domain.Handlers.Cart<br/>{<br/>    public class GetCartHandler : IRequestHandler&lt;GetCartCommand, <br/>        CartExtendedResponse&gt;<br/>    {<br/>        private readonly ICatalogService _catalogService;<br/>        private readonly IMapper _mapper;<br/>        private readonly ICartRepository _repository;<br/><br/>        public GetCartHandler(ICartRepository repository, IMapper <br/>            mapper, ICatalogService catalogService)<br/>        {<br/>            _repository = repository;<br/>            _mapper = mapper;<br/>            _catalogService = catalogService;<br/>        }<br/><br/>        public async Task&lt;CartExtendedResponse&gt; Handle(GetCartCommand <br/>            command, CancellationToken cancellationToken)<br/>        {<br/>            var result = await _repository.GetAsync(command.Id);<br/>            var extendedResponse = _mapper.Map&lt;CartExtendedResponse&gt;<br/>                (result);<br/><br/>            var tasks = extendedResponse.Items<br/>                .Select(async x =&gt; await _catalogService<br/>                .EnrichCartItem(x, cancellationToken));<br/><br/>            extendedResponse.Items = await Task.WhenAll(tasks);<br/>            return extendedResponse;<br/>        }<br/>    }<br/>}</pre>
<p>In this case, the <kbd>Handle</kbd> method executes the <kbd>GetAsync(Guid id)</kbd> method that's provided by the underlying repository interface and it maps the response to the <kbd>CartExtendedResponse</kbd> type. The last handler that's implemented by the <kbd>Cart.Domain</kbd> project increases or decreases the quantity of an item in a specific cart:</p>
<pre>using System.Linq;<br/>...<br/><br/>namespace Cart.Domain.Handlers.Cart<br/>{<br/>    public class UpdateCartItemQuantity : IRequestHandler<br/>        &lt;UpdateCartItemQuantityCommand, CartExtendedResponse&gt;<br/>    {<br/>        private readonly ICatalogService _catalogService;<br/>        private readonly IMapper _mapper;<br/>        private readonly ICartRepository _repository;<br/><br/>        public UpdateCartItemQuantity(ICartRepository repository, <br/>            IMapper mapper, ICatalogService catalogService)<br/>        {<br/>            _repository = repository;<br/>            _mapper = mapper;<br/>            _catalogService = catalogService;<br/>        }<br/><br/>        public async Task&lt;CartExtendedResponse&gt; Handle(UpdateCartItemQuantityCommand command, CancellationToken cancellationToken)<br/>        {<br/>            var cartDetail = await <br/>                _repository.GetAsync(command.CartId);<br/><br/>            if (command.IsAddOperation)<br/>                cartDetail.Items.FirstOrDefault(x =&gt; x.CartItemId == <br/>                command.CartItemId)?<strong>.IncreaseQuantity();</strong><br/>            else<br/>                cartDetail.Items.FirstOrDefault(x =&gt; x.CartItemId == <br/>                command.CartItemId)?.<strong>DecreaseQuantity();</strong><br/><br/>            var cartItemsList = cartDetail.Items.ToList();<br/><br/>            cartItemsList.RemoveAll(x =&gt; x.Quantity &lt;= 0);<br/><br/>            cartDetail.Items = cartItemsList;<br/><br/>            await _repository.AddOrUpdateAsync(cartDetail);<br/><br/>            var response = _mapper.Map&lt;CartExtendedResponse&gt;<br/>                (cartDetail);<br/>            var tasks = response.Items<br/>                .Select(async x =&gt; await <br/>                _catalogService.EnrichCartItem(x, cancellationToken));<br/><br/>            response.Items = await Task.WhenAll(tasks);<br/><br/>            return response;<br/>        }<br/>    }<br/>}</pre>
<p>The handler accepts <kbd>UpdateCartItemQuantityRequest</kbd>, which defines the <kbd>CartId</kbd>, <kbd>CartItemId</kbd>, and a Boolean that denotes whether the request is to increase or decrease the quantity of the specified item.</p>
<p>The handler uses the same dependencies that the other handlers do and it performs some additional checks about the removal of the item if the amount is equal to zero. If the quantity associated with <kbd>CartItemId</kbd> reaches <kbd>0</kbd>, then the item is removed from the cart session; otherwise, the quantity is updated and the cart proceeds by updating the Redis store and retrieving <kbd>cartDetail</kbd>.</p>
<p>Now that our handlers are in place, we will define the controller classes that will expose the HTTP routes for the web service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exposing functionalities using CartController</h1>
                
            
            
                
<p>As we've already mentioned, the cart service takes care of the operations that are performed on the cart page of the e-commerce store. Moreover, the service exposes the following route table:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>HttpVerb </strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>URL</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>api/cart/{cartId}</kbd></td>
<td class="CDPAlignCenter CDPAlign">This action retrieves information about a specific cart and its inner products.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>POST</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>api/cart</kbd></td>
<td class="CDPAlignCenter CDPAlign">This action creates a new cart with a list of products specified in the body payload of the request.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>PUT</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>api/cart/{cartId}/items/{id}</kbd></td>
<td class="CDPAlignCenter CDPAlign">This action increases the quantity of the specified item in the specified <kbd>cartId</kbd> by adding one unit.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>DELETE</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>api/cart/{cartId}/items/{id}</kbd></td>
<td class="CDPAlignCenter CDPAlign">This action decreases the quantity of the specified item in the specified <kbd>cartId</kbd> by removing one unit.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The preceding table provides some details about the routes we need to define in our controller. Therefore, the following code snippet shows the implementation of this route table while using the <kbd>CartController</kbd> class in the <kbd>Cart.API</kbd> project:</p>
<pre>using System;<br/>using System.Threading.Tasks;<br/>using MediatR;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Cart.API.Infrastructure.Filters;<br/>using Cart.Domain.Commands.Cart;<br/><br/>namespace Cart.API.Controllers<br/>{<br/><br/>    [Route("api/cart")]<br/>    [ApiController]<br/>    [JsonException]<br/>    public class CartController : ControllerBase<br/>    {<br/>        private readonly IMediator _mediator;<br/><br/>        public CartController(IMediator mediator)<br/>        {<br/><br/>            _mediator = mediator;<br/>        }<br/><br/>          [HttpGet("{id:guid}")]<br/>        public async Task&lt;IActionResult&gt; GetById(Guid id)<br/>        {<br/>            var result = await _mediator.Send(new GetCartCommand { Id = <br/>                id });<br/>            return Ok(result);<br/>        }<br/><br/>        [HttpPost]<br/>        public async Task&lt;IActionResult&gt; Post(CreateCartCommand <br/>            request)<br/>        {<br/>            var result = await _mediator.Send(request);<br/>            return CreatedAtAction(nameof(GetById), new { id = <br/>                result.Id }, null);<br/>        }<br/>..</pre>
<p>As you can see, in a similar way to the previously implemented controllers, <kbd>CartController</kbd> uses dependency injection to resolve its dependencies by initializing the <kbd>IMediator</kbd> interface. Let's proceed by having a look at the implementation of the <kbd>Put</kbd> and <kbd>Delete</kbd> action methods:</p>
<pre>...<br/><br/>    [HttpPut("{cartId:guid}/items/{id:guid}")]<br/>        public async Task&lt;IActionResult&gt; Put(Guid cartId, Guid id)<br/>        {<br/>            var result = await _mediator.Send(new <br/>                UpdateCartItemQuantityCommand<br/>            {<br/>                CartId = cartId,<br/>                CartItemId = id,<br/>                IsAddOperation = true<br/>            });<br/>            return Ok(result);<br/>        }<br/>        [HttpDelete("{cartId:guid}/items/{id:guid}")]<br/>        public async Task&lt;IActionResult&gt; Delete(Guid cartId, Guid id)<br/>        {<br/>            var result = await _mediator.Send(new <br/>                UpdateCartItemQuantityCommand<br/>            {<br/>                CartId = cartId,<br/>                CartItemId = id,<br/>                IsAddOperation = false<br/>            });<br/><br/>            return Ok(result);<br/>        }<br/>}</pre>
<p>The <kbd>DELETE</kbd> and <kbd>PUT</kbd> methods use the <kbd>IsAddOperation</kbd> flag to inform the handler of whether the requested operation is being used to increase or decrease the quantity. Therefore, every time we call the routes using the <kbd>DELETE</kbd> HTTP verb and the <kbd>UPDATE</kbd> HTTP verb, the service will increase and reduce the amount of the item ID specified in the URL.</p>
<p>This chapter skips a lot of the validation and REST-compliant features that we covered in <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, <em>Building the Data Access Layer</em>, <a href="f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml">Chapter 9</a>, <em>Implementing the Domain Logic</em>, and <a href="266d98e8-df54-4024-aefb-b5871b3b35fa.xhtml">Chapter 10</a>, <em>Implementing the RESTful HTTP Layer</em>, and then implemented in the <kbd>Catalog.API</kbd> project. As we will see from the next section onward, this chapter aims to show you how to share information and events between independent services. Therefore, the cart service will gather information related to the item by calling the catalog service. </p>
<p>Now that we've looked at the implementation stack, we can proceed by implementing the communication between the catalog service and the cart service<em>.</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing resilient communication using an HTTP client</h1>
                
            
            
                
<p>In the previous section, we looked at an overview of the cart service's project structure. We learned how the cart service stores information inside a Redis instance and how it retrieves cart-related data for the client.</p>
<p>It is necessary to note that there is a gap between the information stored in the Redis data source and the data that's exposed by the service. Furthermore, by examining the <kbd>CartItem</kbd> entity, we can see that it only implements and retrieves <kbd>CartItemId</kbd> and <kbd>Quantity</kbd> information for the item:</p>
<pre>namespace Cart.Domain.Entities<br/>{<br/>    public class CartItem<br/>    {<br/>       <strong> public string CartItemId { get; set; }</strong><br/><br/>        <strong>public int Quantity { get; set; }</strong><br/>        <br/>        ...<br/>    }<br/>}</pre>
<p>On the other hand, we can see that <kbd>CartItemResponse</kbd> provides a lot of fields related to the item's data:</p>
<pre>namespace Cart.Domain.Responses.Cart<br/>{<br/>    public class CartItemResponse<br/>    {<br/>        public string CartItemId { get; set; }<br/><br/>        public string Name { get; set; }<br/><br/>        public string Description { get; set; }<br/><br/>        public string LabelName { get; set; }<br/><br/>        public string Price { get; set; }<br/><br/>        public string PictureUri { get; set; }<br/><br/>        public string GenreDescription { get; set; }<br/><br/>        public string ArtistName { get; set; }<br/><br/>        public int Quantity { get; set; }<br/>    }<br/>}</pre>
<p>The additional information that's presented by the <kbd>CartItemResponse</kbd> class is fetched by calling the catalog services. Therefore, the cart service owns the data about the item ID and it can perform a <kbd>GET /api/items/{itemId}</kbd> request in order to retrieve the item's information. In this section, we will focus on the implementation of an HTTP client to expose the information that's owned by the catalog service.</p>
<p>It is important that you don't replicate information across web services. We need to be able to keep the data sources of web services as separated as possible. Each service owns a single data source and its appropriate information. It is a common practice to share information using HTTP calls to communicate between services. In the following example, we will see how the cart service calls the catalog service directly to retrieve item information. In a real-world application, all the HTTP calls between services are made by passing through a proxy to guarantee the reliability of the service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the catalog HTTP client </h1>
                
            
            
                
<p>It is common practice to implement client libraries along with web services. Furthermore, it is the responsibility of a web service to provide a way to communicate with it. For that reason, we can represent the client's implementation using the following schema:</p>
<div><img src="img/01d7bb66-9842-4ab0-9b42-71226466f10f.png" style=""/></div>
<p>This allows us to publish the catalog service client library in an internal NuGet repository so that we can spread the client to other services. Moreover, the team that owns a specific service should know how it can be implemented and how to expose information in the right way. Let's start by creating two new <kbd>classlib</kbd> projects in the <kbd>Catalog.API</kbd> solution, which can be found in the <kbd>src</kbd> folder:</p>
<pre><strong>dotnet new classlib -n Catalog.API.Client -f netstandard2.1<br/>dotnet sln ../Catalog.API.sln add Catalog.API.Client<br/></strong><br/><strong>dotnet new classlib -n Catalog.API.Contract -f netstandard2.1<br/>dotnet sln ../Catalog.API.sln add Catalog.API.Contract<br/><br/>dotnet add Catalog.API.Client reference Catalog.API.Contract</strong></pre>
<p class="mce-root"/>
<p>The <kbd>Catalog.API.Client</kbd> project will contain all the methods we need to query the catalog service. <kbd>Catalog.API.Contract</kbd> includes the requests and responses that are used by the client to transfer the data, so we can proceed by copying the classes contained in the <kbd>Responses</kbd> folder of the <kbd>Catalog.Domain</kbd> project into the <kbd>Catalog.API.Contract</kbd> project we created previously. The resulting folder structure will look as follows:</p>
<pre>.<br/>├── Item<br/>│   ├── ArtistResponse.cs<br/>│   ├── GenreResponse.cs<br/>│   ├── ItemResponse.cs<br/>│   └── PriceResponse.cs<br/>├── Catalog.API.Contract.csproj<br/>├── bin<br/>└── obj</pre>
<p>In order to use the response models in a project, it is necessary to refer to <kbd>Catalog.API.Contract</kbd>. This practice is usually applied to the request and response classes. By doing this, it is possible to keep the contract of the API in a separate, continuous integration pipeline. As a second step, we need to create a new base client in the <kbd>Catalog.API.Client</kbd> project. The following <kbd>IBaseClient</kbd> interface defines the methods that are exposed by the client:</p>
<pre><strong>// /Base/IBaseClient.cs</strong><br/><br/>using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/><br/>namespace Catalog.API.Client.Base<br/>{<br/>        public interface IBaseClient<br/>        {<br/>            Task&lt;T&gt; GetAsync&lt;T&gt;(Uri uri, CancellationToken <br/>                cancellationToken);<br/>            Uri BuildUri(string format);<br/>        }<br/>}<br/></pre>
<p>The <kbd>IBaseClient</kbd> interface establishes the interface of the client. It exposes two main methods: <kbd>GetAsync</kbd> and <kbd>BuildUri</kbd>. Both of these methods are implemented in the <kbd>BaseClient</kbd> concrete class. The <kbd>BaseClient</kbd> class depends on the <kbd>HttpClient</kbd> and the <kbd>string Url</kbd> of our APIs. The <kbd>GetAsync</kbd> method calls the <kbd>HttpClient</kbd> and uses the <kbd>Newtonsoft.Json</kbd> package to deserialize the response of the client in a generic model, <kbd>T</kbd>.</p>
<p>Let's continue by defining the <kbd>ICatalogItemResource</kbd> interface and the <kbd>CatalogItemResource</kbd> classes. These classes represent the <kbd>Item</kbd> resource:</p>
<pre>// <strong>Resources/ICatalogItemResource.cs</strong><br/><br/>using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Contract.Item;<br/><br/>namespace Catalog.API.Client.Resources<br/>{<br/>    public interface ICatalogItemResource<br/>    {<br/>        Task&lt;ItemResponse&gt; Get(Guid id, CancellationToken <br/>            cancellationToken = default);<br/>    }<br/>}<br/></pre>
<p><kbd>ICatalogItemResource</kbd> exposes the <kbd>Get</kbd> method by accepting the <kbd>id</kbd> and <kbd>cancellationToken</kbd>. It returns a <kbd>Task&lt;ItemResponse&gt;</kbd> type. Therefore, the <kbd>CatalogItemResource</kbd> model is defined in the <kbd>Catalog.API.Client.Resources</kbd> project as follows:</p>
<pre>// <strong>Resources/CatalogItemResource.cs</strong><br/><br/>using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.API.Client.Base;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.API.Client.Resources<br/>{<br/>    public class CatalogItemResource : ICatalogItemResource<br/>    {<br/>        private readonly IBaseClient _client;<br/><br/>        public CatalogItemResource(IBaseClient client)<br/>        {<br/>            _client = client;<br/>        }<br/><br/>        private Uri BuildUri(Guid id, string path = "")<br/>        {<br/>           <strong> return _client.BuildUri(string.Format("api/items/{0}", id, <br/>                path));</strong><br/>        }<br/><br/>        public async Task&lt;ItemResponse&gt; Get(Guid id, CancellationToken <br/>            cancellationToken)<br/>        {<br/>            var uri = BuildUri(id);<br/>           <strong> return await _client.GetAsync&lt;ItemResponse&gt;(uri, <br/>                cancellationToken);</strong><br/>        }<br/>    }<br/>}</pre>
<p><kbd>CatalogItemResource</kbd> refers to the <kbd>IBaseClient</kbd> interface and it implements the <kbd>Get</kbd> method by using the <kbd>IBaseClient</kbd> interface. In the same way, <kbd>CatalogItemResource</kbd> is also in charge of providing the paths of the items' resources by building the <kbd>Uri</kbd> of the web service. Besides this, <kbd>CatalogItemResource</kbd> uses the <kbd>IBaseClient</kbd> wrapper to perform HTTP operations. Let's dig into the implementation of the <kbd>IBaseClass</kbd> interface:</p>
<pre><strong>// /Base/BaseClient.cs</strong><br/><br/>using System;<br/>using System.Net.Http;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Newtonsoft.Json;<br/><br/>namespace Catalog.API.Client.Base<br/>{<br/>    public class BaseClient : IBaseClient<br/>    {<br/>        private readonly HttpClient _client;<br/>        private readonly string _baseUri;<br/><br/>        public BaseClient(HttpClient client, string baseUri)<br/>        {<br/>            _client = client;<br/>            _baseUri = baseUri;<br/>        }<br/><br/>        public async Task&lt;T&gt; GetAsync&lt;T&gt;(Uri uri, CancellationToken <br/>            cancellationToken)<br/>        {<br/>            var result = await _client.GetAsync(uri, <br/>            cancellationToken);<br/>            result.EnsureSuccessStatusCode();<br/><br/>            return JsonConvert.DeserializeObject&lt;T&gt;(await <br/>            result.Content.ReadAsStringAsync());<br/>        }<br/><br/>        public Uri BuildUri(string format)<br/>        {<br/>            return new UriBuilder(_baseUri)<br/>            {<br/>                Path = format<br/>            }.Uri;<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code uses the <kbd>HttpClient</kbd> class that's provided by the framework to implement the <kbd>GetAsync&lt;T&gt;</kbd> generic method. Therefore, using this generic pattern allows us to deserialize the response using a custom model.</p>
<p>Finally, we can implement the actual client of the service by adding the following components:</p>
<pre><strong>// ICatalogClient.cs</strong><br/><br/>using Catalog.API.Client.Resources;<br/><br/>namespace Catalog.API.Client<br/>{<br/>    public interface ICatalogClient<br/>    {<br/>        ICatalogItemResource Item { get; }<br/>    }<br/>}<br/><br/><strong>// CatalogClient.cs</strong><br/><br/>using System.Net.Http;<br/>using Catalog.API.Client.Base;<br/>using Catalog.API.Client.Resources;<br/><br/>namespace Catalog.API.Client<br/>{<br/>    public class CatalogClient : ICatalogClient<br/>    {<br/>        public ICatalogItemResource Item { get; }<br/><br/>        public CatalogClient(HttpClient client)<br/>        {<br/>            Item = new CatalogItemResource(new BaseClient(client, <br/>            client.BaseAddress.ToString()));<br/>        }<br/>    }<br/>}<br/><br/></pre>
<p>Finally, it is possible to use <kbd>Catalog.API.Client</kbd> to instantiate a new HTTP client instance and call the catalog service using a unique and universal contract:</p>
<pre>var catalogClient = new CatalogClient(new HttpClient());<br/>var result = await catalogClient.Item.Get(new Guid(item.CartItemId), cancellationToken);</pre>
<p>Now, we have some standalone DLLs that provide everything we need, so that we can query the catalog web service. In the next section, we will learn how to perform HTTP calls to the catalog service using the client we implemented in this section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integrating an HTTP client into the cart service</h1>
                
            
            
                
<p>The next step is to incorporate the HTTP client provided by the catalog service into the cart service. Therefore, we will add a new class whose ownership is to call the catalog service and retrieve the information that's required for the specific cart. Let's start by creating an interface in the <kbd>Cart.Domain</kbd> project called <kbd>ICatalogService</kbd>:</p>
<pre>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Cart.Domain.Responses.Cart;<br/><br/>namespace Cart.Domain.Services<br/>{<br/>    public interface ICatalogService<br/>    {<br/>        Task&lt;CartItemResponse&gt; <strong>EnrichCartItem</strong>(CartItemResponse item, <br/>            CancellationToken cancellationToken);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>The <kbd>ICatalogService</kbd> interface is contained in the <kbd>Services</kbd> folder of the <kbd>Cart.Domain</kbd> project. It exposes an asynchronous method called <kbd>EnrichCartItem</kbd>, which accepts <kbd>CartItemResponse</kbd> and returns the same type. Like we did for the <kbd>ICartRepository</kbd> interface, we can create the concrete implementation of the <kbd>ICatalogService</kbd> interface in the <kbd>Cart.Infrastructure</kbd> project. Therefore, we can use the <kbd>ICatalogClient</kbd> interface we previously implemented in the <em>catalog service</em> to retrieve the catalog information. In a real-world application, these DLLs are usually managed as NuGet packages in the internal repository of the company. In our case, we will copy them and include them in the <kbd>Cart.Infrastructure</kbd> project, as follows:</p>
<pre>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;<br/><br/>    &lt;PropertyGroup&gt;<br/>        &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;<br/>    &lt;/PropertyGroup&gt;<br/><br/> ...<br/><br/>    &lt;ItemGroup&gt;<br/><strong>      &lt;Reference Include="Catalog.API.Client, Version=1.0.0.0, <br/>        Culture=neutral, PublicKeyToken=null"&gt;<br/>        &lt;HintPath&gt;ExternalDll\Catalog.API.Client.dll&lt;/HintPath&gt;<br/>      &lt;/Reference&gt;<br/>      &lt;Reference Include="Catalog.API.Contract, Version=1.0.0.0, <br/>       Culture=neutral, PublicKeyToken=null"&gt;<br/>        &lt;HintPath&gt;ExternalDll\Catalog.API.Contract.dll&lt;/HintPath&gt;<br/></strong><strong>      &lt;/Reference&gt;</strong><br/>    &lt;/ItemGroup&gt;<br/>&lt;/Project&gt;<br/></pre>
<p>Let's proceed by creating the <kbd>CatalogService</kbd> class in the <kbd>Cart.Infrastructure</kbd> project:</p>
<pre>using System;<br/>using System.Globalization;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Cart.Domain.Responses.Cart;<br/>using Cart.Domain.Services;<br/>using Catalog.API.Client;<br/>using Catalog.API.Contract.Item;<br/><br/>namespace Cart.Infrastructure.Services<br/>{<br/>    public class CatalogService : ICatalogService<br/>    {<br/>        private readonly ICatalogClient _catalogClient;<br/><br/>        public CatalogService(ICatalogClient catalogClient)<br/>        {<br/>            _catalogClient = catalogClient;<br/>        }<br/><br/>        public async Task&lt;CartItemResponse&gt; EnrichCartItem<br/>        (CartItemResponse item, CancellationToken cancellationToken)<br/>        {<br/>            try<br/>            {<br/>                var result = await _catalogClient.Item.Get(new <br/>                    Guid(item.CartItemId), cancellationToken);<br/>                return Map(item, result);<br/>            }<br/>            catch (Exception)<br/>            {<br/>                return item;<br/>            }<br/>        }<br/><br/>        private static CartItemResponse Map(CartItemResponse item, <br/>            ItemResponse result)<br/>        {<br/>            item.Description = result.Description;<br/>            item.LabelName = result.LabelName;<br/>            item.Name = result.Name;<br/>            item.Price = result.Price.Amount.ToString<br/>                (CultureInfo.InvariantCulture);<br/>            item.ArtistName = result.Artist.ArtistName;<br/>            item.GenreDescription = result.Genre.GenreDescription;<br/>            item.PictureUri = result.PictureUri;<br/><br/>            return item;<br/>        }<br/>    }<br/>}</pre>
<p><kbd>CatalogService</kbd> resolves the <kbd>ICatalogClient</kbd> dependency using constructor injection. The class implements the <kbd>EnrichCartItem</kbd> function by calling the catalog service client in the following way:</p>
<pre>var result = await _catalogClient.Item.Get(new Guid(item.CartItemId), cancellationToken);</pre>
<p>Now, the method retrieves information related to the catalog item and it maps that data into <kbd>CartItemResponse</kbd> using the <kbd>Map</kbd> method. As a result, we will have information about each item that's been populated with the new data. It is possible to proceed by referring to the <kbd>ICatalogService</kbd> interface in the handlers that have been implemented in <kbd>Cart.Domain</kbd>. Let's take <kbd>GetCartHandler</kbd> as an example of this:</p>
<pre>using System.Linq;<br/>...<br/><br/>namespace Cart.Domain.Handlers.Cart<br/>{<br/>    public class GetCartHandler : IRequestHandler&lt;GetCartCommand, <br/>        CartExtendedResponse&gt;<br/>    {<br/>     <strong>   private readonly ICatalogService _catalogService;</strong><br/>        private readonly IMapper _mapper;<br/>        private readonly ICartRepository _repository;<br/><br/><br/>        public GetCartHandler( ICartRepository repository, IMapper <br/>            mapper, <strong>ICatalogService catalogService</strong>)<br/>        {<br/>            _repository = repository;<br/>            _mapper = mapper;<br/>            <strong>_catalogService = catalogService;</strong><br/>        }<br/><br/>        public async Task&lt;CartExtendedResponse&gt; Handle(GetCartCommand <br/>        command, CancellationToken cancellationToken)<br/>        {<br/>            var result = await _repository.GetAsync(command.Id);<br/>            var extendedResponse = _mapper.Map&lt;CartExtendedResponse&gt;<br/>                (result);<br/><br/>            var tasks = <strong>extendedResponse.Items<br/>                .Select(async x =&gt; await <br/>                _catalogService.EnrichCartItem(x, cancellationToken));</strong><br/><br/>            extendedResponse.Items = await Task.WhenAll(tasks);<br/>            return extendedResponse;<br/>        }<br/>    }<br/>}</pre>
<p>We can execute the <kbd>_catalogService.EnrichCartItem</kbd> method to retrieve the populated data for each <kbd>Item</kbd> in the <kbd>extendedResponse</kbd> object. In addition, <kbd>GetCartHandler</kbd> uses the <kbd>Task.WhenAll</kbd> method to wait for the tasks to complete and returns their data. To get this process working in the runtime execution, it is necessary to declare the following extension method, which will initialize the dependency and execute it in the <kbd>Startup</kbd> class of the <kbd>Cart.API</kbd> project by passing the endpoints of the APIs:</p>
<pre>using System;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using Cart.Domain.Services;<br/>using Cart.Services;<br/>using Catalog.API.Client;<br/><br/>namespace Cart.Infrastructure<br/>{<br/>    public static class CatalogServiceExtensions<br/>    {<br/>        public static IServiceCollection AddCatalogService(this <br/>        IServiceCollection services, Uri uri)<br/>        {<br/>          <strong> services.AddScoped&lt;ICatalogClient&gt;(x =&gt; new <br/>                CatalogClient(uri));</strong><br/><strong>           services.AddScoped&lt;ICatalogService, CatalogService&gt;();</strong><br/><br/>            return services;<br/>        }<br/>    }</pre>
<p><kbd>AddCatalogService</kbd> will be called in the <kbd>CofigureService</kbd> method of the <kbd>Startup</kbd> class. It adds <kbd>ICatalogClient</kbd> and <kbd>ICatlogService</kbd> to the dependency injection services by using a scoped life cycle. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing resilience using Polly.NET</h1>
                
            
            
                
<p class="mce-root">In the previous sections, we described how to achieve communication between the catalog service and the cart service. Now, we should be asking ourselves the following questions about the runtime execution and the communication between our services: what happens if the catalog service is down? What happens if the catalog service has a slow response time? The <strong>Polly.NET</strong> package comes in handy for these kinds of issues (<a href="https://github.com/App-vNext/Polly">https://github.com/App-vNext/Polly</a>).</p>
<p>Polly.NET is based on <em>policies,</em> where each <em>policy</em> can be used individually or combined with others to provide resilience to the client. Out of the box, the library offers some standard resilience policies, such as retry, circuit breaker, and timeout<em>.</em> Let's have a quick look at a sample policy so that we understand how to use them:</p>
<pre>...<br/><br/>    services.AddHttpClient&lt;IMyService, MyService&gt;()<br/>        <strong>.AddPolicyHandler(RetryPolicy());</strong><br/>  <br/>...<br/><br/>static IAsyncPolicy&lt;HttpResponseMessage&gt; <strong>RetryPolicy</strong>()<br/>{<br/>    return <strong>HttpPolicyExtensions<br/>        .HandleTransientHttpError()</strong><br/><strong>        .OrResult(msg =&gt; msg.StatusCode == <br/>           System.Net.HttpStatusCode.NotFound)</strong><br/><strong>        .WaitAndRetryAsync(6, retryAttempt =&gt;             <br/>            TimeSpan.FromSeconds(Math.Pow(2,</strong><strong>retryAttempt)));</strong><br/>}<br/></pre>
<p>The previous code injects an <kbd>HttpClient</kbd> instance into <kbd>IMyService</kbd>. The <kbd>HttpClient</kbd> instance combines <kbd>RetryPolicy</kbd> with the <kbd>Polly</kbd> package. Furthermore, if the HTTP call returns a <kbd>404 NotFound</kbd> message, it triggers <kbd>RetryPolicy</kbd>, which retries the request after a specified amount of time that increases exponentially. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integrating Polly into ICatalogService</h1>
                
            
            
                
<p>Let's look at how we can incorporate Polly.NET into the cart service<em>.</em> As we saw previously,<em> </em>our use case uses the catalog service to gather detailed information about the items in the user's cart and return them to the client. Furthermore, we will implement <kbd>CircuitBreakerPolicy</kbd> on <kbd>ICatalogClient</kbd>. <kbd>CircuitBreakerPolicy</kbd> follows the failing fast approach, which means that, even if the response of the catalog service doesn't arrive, the runtime continues with the execution of the application<em>.</em></p>
<p>Before starting, let's add some Polly.NET packages to the <kbd>Cart.Infrastructure</kbd> project by using the <kbd>add package</kbd> command in the project folder:</p>
<pre><strong>dotnet add package Polly</strong></pre>
<p>Let's proceed by creating some policies for <kbd>ICatalogClient</kbd> by creating a new <kbd>CatalogServicePolicies</kbd> static class in <kbd>Cart.Infrastructure</kbd>:</p>
<pre>using System;<br/>using System.Net;<br/>using System.Net.Http;<br/>using Polly;<br/>using Polly.Extensions.Http;<br/><br/>namespace Cart.Infrastructure.Extensions.Policies<br/>{<br/>    public static class CatalogServicePolicies<br/>    {<br/>        public static IAsyncPolicy&lt;HttpResponseMessage&gt; RetryPolicy()<br/>        {<br/>            return HttpPolicyExtensions<br/>                .HandleTransientHttpError()<br/>                .OrResult(msg =&gt; msg.StatusCode == <br/>                    HttpStatusCode.NotFound)<br/>                .WaitAndRetryAsync(3, retryAttempt =&gt; <br/>                  TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));<br/>        }<br/><br/>        public static IAsyncPolicy&lt;HttpResponseMessage&gt; <br/>        CircuitBreakerPolicy()<br/>        {<br/>            return HttpPolicyExtensions<br/>                .HandleTransientHttpError()<br/>                .CircuitBreakerAsync(3, TimeSpan.FromMinutes(1));<br/>        }<br/>    }<br/>} </pre>
<p>The preceding code defines two policies:</p>
<ul>
<li>The <kbd>RetryPolicy</kbd> static method defines the number of retries to carry out before proceeding with the other policies. It uses the <kbd>.HandleTransientHttpError</kbd> and <kbd>.OrResult</kbd> methods to detect all the failed conditions that have been returned by the client. Furthermore, it calls the <kbd>WaitAndRetryAsync</kbd> method, which restricts the <kbd>RetryPolicy</kbd> to a maximum of three retries. With each retry, it increases the sleep duration.</li>
<li>The <kbd>CircuitBreaker</kbd> static method catches all the error conditions by using <kbd>.HandleTransientHttpError</kbd>. It calls the <kbd>.CircuitBreakerAsync</kbd> method to define <kbd>CircuitBreakerPolicy</kbd>. <kbd>CircuitBreakerPolicy</kbd> will be triggered after three attempts and will be active for 1 minute.</li>
</ul>
<p>Now, we can inject the definitions of these policies into our <kbd>HttpClient</kbd> instances, as follows:</p>
<pre>public static class CatalogServiceExtensions<br/>{<br/>    public static IServiceCollection AddCatalogService(this <br/>    IServiceCollection services, Uri uri)<br/>    {<br/>        services.AddScoped&lt;ICatalogService, CatalogService&gt;();<br/><br/>        services.AddHttpClient&lt;ICatalogClient, CatalogClient&gt;(client =&gt;<br/>            {<br/>                client.BaseAddress = uri;<br/>            })<br/>          <strong>  .SetHandlerLifetime(TimeSpan.FromMinutes(2))</strong> <br/>            <strong>.AddPolicyHandler(CatalogServicePolicies.RetryPolicy())</strong><br/><strong>            .AddPolicyHandler(CatalogServicePolicies.<br/>             CircuitBreakerPolicy());</strong><br/>        <br/>        return services;<br/>    }<br/>}</pre>
<p>As you can see, we are injecting these policies using the <kbd>AddPolicyHandler</kbd> method, and we are calling the <kbd>CatalogServicePolicies</kbd> static class to get them. It is also essential to notice that, before defining the policies, we use the <kbd>SetHandlerLifetime</kbd> method to determine the lifetime of <kbd>HttpClient</kbd>. This approach guarantees more resilient communication between the cart service and the catalog service. Furthermore, note that <kbd>Polly</kbd> policies can be applied to any third-party dependency call, which means that every time we rely on a third-party service, we need to anticipate this kind of approach in order to gracefully handle errors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sharing events using an event bus</h1>
                
            
            
                
<p>So far in this chapter, we've seen how we can share information over HTTP by calling other web services. As we've already mentioned, it is important to not replicate information between services and, more importantly, that each service must be the owner of a single data source, which needs to be as isolated as possible. Another technique we can use to share information is pushing data using events. In this section, we will begin by examining one use case that is suitable for an event bus.</p>
<p>Let's suppose that one of the catalog items reaches an available stock amount of zero and enters the sold-out state. We need to propagate this information and tell the cart service that this specific item is sold out. This use case can be implemented using an event bus.</p>
<p> To understand this architecture, take a look at the following schema:</p>
<div><img src="img/a923daf3-cd8e-4170-8127-60d1e6e849af.png" style=""/></div>
<p>The catalog service triggers an event each time the available stock of an item reaches zero. The cart service listens for this event and then triggers the update of the cart that's stored in the Redis data source. For this purpose, we will use RabbitMQ, which is one of the most common event buses. RabbitMQ provides a .NET package that can be used to implement the communication between two solutions: <a href="https://github.com/rabbitmq/rabbitmq-dotnet-client">https://github.com/rabbitmq/rabbitmq-dotnet-client</a>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up a RabbitMQ instance and publishing an event</h1>
                
            
            
                
<p>Event bus communication is composed of two parts: the sender and the receiver. In the case of an event, the actors' names are publishers and subscribers. The previous section described the implementation of the subscriber part. In this case, the catalog service will be the publisher and the cart service will be the subscriber. Before we look at how to implement the publisher part, we need to create a RabbitMQ instance using a Docker container by adding a <kbd>docker-compose.yml</kbd> file to the catalog service:</p>
<pre>version: "3.7"<br/>services:<br/>    ...        <br/><strong>  catalog_esb:<br/>    container_name: catalog_esb<br/>    image: rabbitmq:3-management-alpine<br/>    ports:<br/>      - 5672:5672<br/>      - 15672:15672<br/>    networks:<br/>      - my_network<br/>    ...</strong><br/>networks:<br/>    my_network:<br/>        driver: bridge</pre>
<p>The <kbd>docker-compose.yml</kbd> file defines a new container called <kbd>catalog_esb</kbd> using the <kbd>rabbitmq:3-management-alpine</kbd> image. It also determines how two ports are mapped within the localhost network: <kbd>5672:5672</kbd> and <kbd>15672:15672</kbd>. The first port mapping is used to expose the RabbitMQ instance, while the second one is used to reveal the management console.</p>
<p>Furthermore, we need to define an extension method that configures RabbitMQ in the catalog web service. We can add the <kbd>RabbitMQ.Client</kbd> package to the <kbd>Catalog.Infrastructure</kbd> project using the following command:</p>
<pre><strong>dotnet add package RabbitMQ.Client<br/></strong></pre>
<p>Furthermore, we will also need to implement the <kbd>ItemSoldOutEvent</kbd> type in the <kbd>Catalog.Domain</kbd> project, under the <kbd>Events</kbd> folder:</p>
<pre>namespace Catalog.Domain.Events<br/>{<br/>    public class ItemSoldOutEvent<br/>    {<br/>        public string Id { get; set; }<br/>    }<br/>}</pre>
<p>The preceding class reflects the event that we've already implemented in the cart project, and it will be used to send the messages through the event bus. The event bus also requires a configuration class that represents the connection parameters to the RabbitMQ instance. The class will be stored in the <kbd>Configuration</kbd> folder of the <kbd>Catalog.Domain</kbd> project:</p>
<pre>namespace Catalog.Domain.Configurations<br/>{<br/>    public class EventBusSettings<br/>    {<br/>        public string HostName { get; set; }<br/>        public string User { get; set; }<br/>        public string Password { get; set; }<br/>        public string EventQueue { get; set; }<br/>    }<br/>}</pre>
<p>The <kbd>EventBusSettings</kbd> type describes the <kbd>HostName</kbd> of the RabbitMQ instance, the <kbd>User</kbd> and <kbd>Password</kbd> of the user, and the <kbd>EventQueue</kbd> name to use to push messages. Therefore, we can proceed by implementing the extension method that will set up and start the event bus in the <kbd>Catalog.Infrastructure</kbd> project:</p>
<pre>using Catalog.Domain.Configurations;<br/>using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using RabbitMQ.Client;<br/><br/>namespace Catalog.Infrastructure.Extensions<br/>{<br/>    public static class EventsExtensions<br/>    {<br/>        public static IServiceCollection AddEventBus(this <br/>            IServiceCollection services, IConfiguration configuration)<br/>        {<br/>            var config = new EventBusSettings();<br/>            configuration.Bind("EventBus", config);<br/>            services.AddSingleton(config);<br/><br/>            ConnectionFactory factory = new ConnectionFactory<br/>            {<br/>                HostName = config.HostName,<br/>                UserName = config.User,<br/>                Password = config.Password<br/>            };<br/><br/>            services.AddSingleton(factory);<br/>            return services;<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code defines how we can publish events to RabbitMQ. The extension method performs the following operations:</p>
<ul>
<li>It initializes a new <kbd>EventBusSettings</kbd> with the <kbd>EventBus</kbd> string section passed as a parameter and adds the configuration as a singleton instance to the dependency injection engine of ASP.NET Core.</li>
<li>It initializes the transport protocol using the RabbitMQ type by initializing a new <kbd>ConnectionFactory</kbd> type. <kbd>ConnectionFactory</kbd> will provide all the tools related to the publication of messages through RabbitMQ.</li>
<li>It adds the new <kbd>ConnectionFactory</kbd> type into the dependency injection services as a singleton type.</li>
</ul>
<p>Moreover, it is possible to resolve the <kbd>ConnectionFactory</kbd><em> </em>and <kbd>EventBusSettings</kbd> types<em> </em>using the out-of-the-box dependency injection of .NET Core, and proceed by publishing the events using the methods provided by the <kbd>RabbitMQ.Client</kbd> packages:</p>
<pre><strong>using Catalog.Domain.Events</strong><strong>;</strong><br/><strong>using RabbitMQ.Client</strong><strong>;</strong><br/><br/>namespace Catalog.Domain.Services<br/>{<br/>    public class ItemService : IItemService<br/>    {<br/>        private readonly IItemMapper _itemMapper;<br/>        private readonly IItemRepository _itemRepository;<br/><strong>        private readonly ConnectionFactory _eventBusConnectionFactory</strong><strong>;</strong><br/><strong>        private readonly ILogger&lt;ItemService&gt; _logger;<br/>        private readonly EventBusSettings _settings</strong><strong>;</strong><br/><br/>        public ItemService(IItemRepository itemRepository, IItemMapper <br/>            itemMapper,<br/>            <strong>ConnectionFactory eventBusConnectionFactory, <br/>            ILogger&lt;ItemService&gt; logger, EventBusSettings </strong><strong>settings</strong>)<br/>        {<br/>            _itemRepository = itemRepository;<br/>            _itemMapper = itemMapper;<br/><strong>            _eventBusConnectionFactory = eventBusConnectionFactory;<br/>            _logger = logger;<br/>            _settings </strong><strong>= settings;</strong><br/>        }<br/><br/>        ...<br/><br/>        public async Task&lt;ItemResponse&gt; DeleteItemAsync(DeleteItemRequest request,<br/>            CancellationToken cancellationToken = default)<br/>        {<br/>            if (request?.Id == null) throw new ArgumentNullException();<br/><br/>            var result = await _itemRepository.GetAsync(request.Id);<br/>            result.IsInactive = false;<br/><br/>            _itemRepository.Update(result);<br/>            await _itemRepository.UnitOfWork.<br/>                SaveChangesAsync(cancellationToken);<br/><br/>            <strong>SendDeleteMessage(new ItemSoldOutEvent { Id = request.Id.ToString</strong><strong>() });</strong><br/>            return _itemMapper.Map(result);<br/>        }<br/><br/><strong>        private void SendDeleteMessage(ItemSoldOutEvent </strong><strong>message)</strong><br/>        {<br/>            try<br/>            {<br/>                var connection = _eventBusConnectionFactory.<br/>                  CreateConnection();<br/><br/>                using var channel = connection.CreateModel();<br/>                channel.QueueDeclare(queue: _settings.EventQueue, true, <br/>                    false);<br/><br/>                var body = Encoding.UTF8.GetBytes<br/>                    (JsonSerializer.Serialize(message));<br/><br/>                channel.ConfirmSelect();<br/>                channel.BasicPublish(exchange: "", routingKey: <br/>                    _settings.EventQueue, body: body);<br/>                channel.WaitForConfirmsOrDie();<br/>            }<br/>            catch (Exception e)<br/>            {<br/>                _logger.LogWarning("Unable to initialize the event bus: <br/>                    {message}", e.Message);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>Here, the <kbd>ItemService</kbd> class uses dependency injection to inject a new <kbd>ConnectionFactory</kbd> instance and the <kbd>EventBusSettings</kbd> into the class. As you may have noticed, the <kbd>DeleteItemAsync</kbd> method also calls the <kbd>SendDeleteMessage</kbd> we defined. Furthermore, the <kbd>SendDeleteMessage</kbd> method uses the <kbd>CreateConnection</kbd> method in order to create a new connection with RabbitMQ. Then, it continues by creating a new fresh channel using the <kbd>CreateModel</kbd> method and defining a new queue that has the same name as the queue we defined in the <kbd>EventBusSettings</kbd> configuration. Finally, it proceeds by serializing the <kbd>ItemSoldOut</kbd> event and publishing the message using the <kbd>EventQueue</kbd> field. The whole procedure is wrapped into a try-catch block in order to be ignored in case there is a communication error between the catalog service and the queue. Now that we have set up the sender, we can call the previously defined <kbd>AddEventBus</kbd> extension method in the <kbd>Startup</kbd> class of <kbd>Catalog.API</kbd> in the following way:</p>
<pre>public void ConfigureServices(IServiceCollection services)<br/>{<br/>        ... <br/>        <strong>services.AddEventBus(Configuration);</strong><br/>}</pre>
<p>The <kbd>AddEventBus</kbd> method now uses the <kbd>EventBus</kbd> section to provide the necessary configuration to the new instance of the <kbd>ConnectionFactory</kbd> type. Now, we can add the configuration to the <kbd>appsettings.json</kbd> file:</p>
<pre>...   <br/> "EventBus": {<br/>        "HostName": "catalog_esb",<br/>        "User": "guest",<br/>        "Password": "guest",<br/>        "EventQueue": "ItemSoldOut"<br/>    }<br/>...</pre>
<p><kbd>ConnectionString</kbd> specifies the <kbd>catalog_esb</kbd> instance as the name of the host and the default <kbd>username</kbd> and <kbd>password</kbd> provided by RabbitMQ. Furthermore, it also specifies the <kbd>ItemSoldOut</kbd> endpoint name. Now, every time we delete an item in the catalog service, it will queue a new ItemSoldOut event into RabbitMQ. In the next chapter, we will see how to consume these messages in the cart service. In the next section, we will continue by learning how to set up and configure the cart service Docker image.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the cart service using Docker</h1>
                
            
            
                
<p>Let's learn how to run the previously implemented cart service using Docker. As we described in the previous chapter, we are going to define the <kbd>docker-compose.yml</kbd> file and the Dockerfile in the root of the cart service project. The <kbd>docker-compose</kbd> file will define two containers: the first hosts the cart service ASP.NET Core instance, while the other represents the Redis instance:</p>
<pre>version: "3.7"<br/>services:<br/>    cart_api:<br/>        container_name: cart_api<br/>        build:<br/>            context: .<br/>        env_file:<br/>            - .env<br/>        networks:<br/>            - my_network<br/>        ports:<br/>            - 5002:5002<br/>        depends_on:<br/>            - cart_db<br/>        <br/>    cart_db:<br/>        container_name: cart_db<br/>        networks:<br/>            - my_network<br/>        env_file:<br/>            - .env<br/>        ports:<br/>            - 6378:6378<br/>        image: redis:alpine<br/><br/>networks:<br/>    my_network:<br/>        driver: bridge</pre>
<p>First, the preceding code defines the <kbd>cart_api</kbd> container. It is part of <kbd>my_network</kbd>, which is defined in the same file, and it exposes ports <kbd>5002</kbd> (HTTP) and <kbd>5003</kbd> (HTTPS). It also refers to the Dockerfile that's located at the root of the project. Secondly, the <kbd>docker-compose.yml</kbd> file defines the <kbd>cart_db</kbd> container, which exposes the default port of Redis (<kbd>6378</kbd>). The <kbd>cart_db</kbd> container uses the Alpine version of Redis so that it can save on the container size. The container shares <kbd>my_network</kbd>. </p>
<p>In this case, we are using a storage system running on a container. Note that this information is not persistent, for two reasons. The first reason is that Redis stores information using a TTL. The default TTL is 24 hours; after that time, the basket information is cleared. It is possible to specify anther TTL when you add a new key to the Redis instance. The second reason is that, once the <kbd>cart_db</kbd> container is killed, we will lose the information inside it. We are using a Redis instance in the form of a container just for demonstration purposes.</p>
<p>Now, let's look at an overview of the definition of the Dockerfile:</p>
<pre>FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS base<br/>WORKDIR /app<br/>EXPOSE 5002<br/><br/>FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build<br/>WORKDIR /project<br/><br/>COPY ["/src/Cart.API/Cart.API.csproj", "/src/Cart.API/"]<br/>RUN dotnet restore "/src/Cart.API/Cart.API.csproj"<br/><br/>COPY . .<br/>WORKDIR "/project/src/Cart.API"<br/>RUN dotnet build "Cart.API.csproj" -c Release -o /app/build<br/><br/>FROM build AS publish<br/>RUN dotnet publish "Cart.API.csproj" -c Release -o /app/publish<br/><br/>FROM base AS final<br/>WORKDIR /app<br/><br/>COPY --from=publish /app/publish .<br/>ENTRYPOINT ["dotnet", "Cart.API.dll"]</pre>
<p>The Dockerfile fulfills the same instructions as the ones defined for the <kbd>Catalog.API</kbd> project: it uses the <kbd>microsoft/dotnet:sdk</kbd> image to build the project and publish it and then it uses the <kbd>microsoft/dotnet:3.0-aspnetcore</kbd> image to run it. To get the containers working, we need to share information between the <kbd>Catalog.API</kbd> project and the <kbd>Cart.API</kbd> project containers. Moreover, it is necessary to initialize the containers in the same project by adding the following <kbd>.env</kbd> file to the same level that the <kbd>docker-compose.yml</kbd> file is at:</p>
<pre>COMPOSE_PROJECT_NAME=store<br/>ASPNETCORE_URLS=http://*:5002<br/>ASPNETCORE_ENVIRONMENT=Integration</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>COMPOSE_PROJECT_NAME</kbd> variables set the project name. This value is prepended, along with the service name, to the container upon startup. Finally, it is possible to run both projects by executing the <kbd>docker-compose up --build</kbd> command in the <kbd>Catalog.API</kbd> and the <kbd>Cart.API</kbd> project folders: the <kbd>docker-compose</kbd> command in the <kbd>Catalog.API</kbd> folder will initialize the <kbd>catalog_api</kbd>, <kbd>catalog_db</kbd>, and the <kbd>catalog_esb</kbd> containers. On the other side, the execution of the <kbd>docker-compose</kbd> command in the <kbd>Cart.API</kbd> folder will initialize the <kbd>cart_api</kbd> and <kbd>cart_db</kbd> containers.</p>
<p>Furthermore, it is possible to create a new catalog item by executing the following sequence of HTTP calls:</p>
<pre>POST /api/genre HTTP/1.1<br/>Host: localhost:5000<br/>Content-Type: application/json<br/>{<br/> "genreDescription": "R&amp;B"<br/>}<br/><br/>POST /api/artist HTTP/1.1<br/>Host: localhost:5000<br/>Content-Type: application/json<br/>{<br/>    "artistName": "Anderson .Paak"<br/>}</pre>
<p>These two requests are direct to the <kbd>localhost:5000</kbd> URL, which represents the catalog web service. They return a <kbd>201 Created</kbd> HTTP status code with the ID of each created artist and genre entity. Furthermore, we can proceed by creating a new item in the catalog using the following HTTP request:</p>
<pre>POST /api/items HTTP/1.1<br/>Host: localhost:5000<br/>Content-Type: application/json<br/>{<br/> "name": "Test",<br/> "description": "Description",<br/> "labelName": "Label",<br/> "price": {<br/> "currency": "EUR",<br/> "amount": 34.3<br/> },<br/> "pictureUri": "",<br/> "releaseDate": "2019-11-21T16:18:42+00:00",<br/> "format": "",<br/> "availableStock": 4,<br/> "genreId":"&lt;genre_id&gt;",<br/> "artistId":"&lt;artist_id&gt;"<br/>}</pre>
<p>Now, we can proceed by calling the cart API service in order to create a new cart session with the item we just created:</p>
<pre>POST /api/cart/ HTTP/1.1<br/>Host: localhost:5002<br/>Content-Type: application/json<br/>{<br/> "ItemsIds": ["&lt;item_id&gt;"],<br/> "UserEmail":"youremail@gmail.com"<br/>}</pre>
<p>Finally, we can verify the communication between the catalog service and the cart service by calling the detail of the cart session:</p>
<pre>GET /api/cart/&lt;cart_id&gt; HTTP/1.1<br/>Host: localhost:5002<br/>cache-control: no-cache</pre>
<p>The cart service should respond with the details related to the item in the cart by fetching the information that was exposed by the catalog web service. If the catalog web service is down, the cart service will omit all the details of the items by returning only the corresponding ID.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you have learned how to implement different types of communication in service ecosystems. We looked closely at how to use an HTTP client to share information between services. We also looked at how we can use resilience techniques with <kbd>Polly</kbd>.</p>
<p>Then, we described how to use an event bus to fire events to a RabbitMQ queue; we used <kbd>RabbitMQ.Client</kbd> combined with RabbitMQ for this. The topics that were covered in this chapter will be useful when you need to transfer data or perform actions across two or more web services or systems.  </p>
<p>In the next chapter, we will learn how to consume <kbd>ItemSoldOut</kbd> events through the use of the worker services capabilities of ASP.NET Core.</p>


            

            
        
    </body></html>