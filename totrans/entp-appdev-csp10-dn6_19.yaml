- en: '*Chapter 14*: Health and Diagnostics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：健康和诊断'
- en: Modern software applications have evolved to be complex and dynamic and are
    distributed in nature. There is a high demand for these applications to be able
    to work round the clock, anywhere, on any device. To achieve this, it is important
    to know that our application is available and responds to requests at all times.
    Customer experiences will play a big role in the future of service and the revenue
    of an organization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件应用程序已经演变成复杂和动态，并且具有分布式特性。对这些应用程序的需求是能够全天候在任何设备上工作。为了实现这一点，重要的是要知道我们的应用程序始终可用并响应请求。客户体验将在服务未来的发展和组织的收入中扮演重要角色。
- en: Once the application is live, it is critical to monitor the application's health.
    Regular application health monitoring will help us to proactively detect any failures
    and address them before they cause more damage. Application monitoring has now
    become a part of day-to-day operations. To diagnose any failure on a live application,
    we need to have the right telemetry and diagnostic tools. The telemetry that we
    capture will also help us identify those problems not directly seen or reported
    by users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序上线，监控应用程序的健康状况至关重要。定期监控应用程序健康将帮助我们主动检测任何故障，并在它们造成更多损害之前解决它们。应用程序监控现在已成为日常运营的一部分。为了诊断在线应用程序上的任何故障，我们需要拥有正确的遥测和诊断工具。我们捕获的遥测数据也将帮助我们识别那些用户没有直接看到或报告的问题。
- en: Let's learn about application health monitoring and what is on offer in .NET
    6.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解应用程序健康监控以及.NET 6提供了哪些功能。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习以下主题：
- en: Introducing health checks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍健康检查
- en: The health check API in ASP.NET Core 6
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 6中的健康检查API
- en: Monitoring the application with Application Insights
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Application Insights监控应用程序
- en: Performing remote debugging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行远程调试
- en: By the end of this chapter, you'll have a good grasp of building the health
    check API for .NET 6 apps and Azure Application Insights for capturing telemetry
    and diagnosing problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够熟练构建.NET 6应用程序的健康检查API，并使用Azure Application Insights来捕获遥测信息和诊断问题。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following software to work through the tasks in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章中的任务，您需要以下软件：
- en: Visual Studio 2022 Community Edition with the Azure development workload installed
    (certain sections require Enterprise Edition)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Azure开发工作负载的Visual Studio 2022 Community Edition（某些部分需要企业版）
- en: An Azure subscription
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure订阅
- en: A basic understanding of Microsoft .NET and how to create resources in Azure
    is expected.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 预期您对Microsoft .NET有基本了解，以及如何在Azure中创建资源。
- en: The code used in this chapter can be found at [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application)找到。
- en: Introducing health checks
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍健康检查
- en: A health check is a comprehensive review of an application that helps us to
    understand the current state of the application and use visible indicators to
    take corrective measures. Health checks are exposed as HTTP endpoints by applications.
    The health check endpoints are used as health probes for certain orchestrators
    and load balancers to route traffic away from a failing node. Health checks are
    used to monitor application dependencies, such as databases, external services,
    and cache services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是对应用程序的全面审查，帮助我们了解应用程序的当前状态，并使用可见指标采取纠正措施。健康检查由应用程序作为HTTP端点公开。健康检查端点用作某些编排器和负载均衡器的健康探测，以将流量从失败的节点路由出去。健康检查用于监控应用程序依赖项，如数据库、外部服务和缓存服务。
- en: In the next section, we will learn about the support for building the health
    check API in ASP.NET Core 6.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在ASP.NET Core 6中构建健康检查API的支持。
- en: The health check API in ASP.NET Core 6
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 6中的健康检查API
- en: ASP.NET Core 6 has a built-in middleware (available via the `Microsoft.Extensions.Diagnostics.HealthChecks`
    NuGet package) to report the health status of the application components exposed
    as an HTTP endpoint. This middleware makes it so easy to integrate health checks
    for databases, external systems, and other dependencies. It is also extensible,
    so we can create our own custom health checks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 6有一个内置的中间件（通过`Microsoft.Extensions.Diagnostics.HealthChecks` NuGet包提供），用于报告作为HTTP端点公开的应用程序组件的健康状态。这个中间件使得集成数据库、外部系统和其他依赖项的健康检查变得非常简单。它也是可扩展的，因此我们可以创建我们自己的自定义健康检查。
- en: In the next section, we will add a health check endpoint to our `Ecommerce`
    portal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向我们的`Ecommerce`门户添加一个健康检查端点。
- en: Adding a health check endpoint
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加健康检查端点
- en: 'In this section, we will add a health check endpoint to our `Packt.Ecommerce.Web`
    application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向我们的`Packt.Ecommerce.Web`应用程序添加一个健康检查端点：
- en: 'In order to add a health check endpoint, we need to first add the `Microsoft.Extensions.Diagnostics.HealthChecks`
    NuGet package reference to the `Packt.Ecommerce.Web` project, as shown in the
    following screenshot:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了添加一个健康检查端点，我们首先需要将`Microsoft.Extensions.Diagnostics.HealthChecks` NuGet包引用添加到`Packt.Ecommerce.Web`项目中，如下面的截图所示：
- en: '![Figure 14.1 – NuGet reference, Microsoft.Extensions.Diagnostics.HealthChecks'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 14.1 – NuGet引用，Microsoft.Extensions.Diagnostics.HealthChecks'
- en: '](img/Figure_14.1_B18507.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_14.1_B18507.jpg](img/Figure_14.1_B18507.jpg)'
- en: Figure 14.1 – NuGet reference, Microsoft.Extensions.Diagnostics.HealthChecks
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – NuGet引用，Microsoft.Extensions.Diagnostics.HealthChecks
- en: 'Now, we need to register `HealthCheckService` with the dependency container.
    The `Microsoft.Extensions.Diagnostics.HealthChecks` package has the `AddHealthChecks`
    extension method defined to add `HealthCheckService` to the container. We can
    call the `AddHealthChecks` method from the `Program.cs` file to add the `DefaultHealthCheckService`
    module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`HealthCheckService`注册到依赖容器中。`Microsoft.Extensions.Diagnostics.HealthChecks`包定义了`AddHealthChecks`扩展方法，用于将`HealthCheckService`添加到容器中。我们可以从`Program.cs`文件中调用`AddHealthChecks`方法来添加`DefaultHealthCheckService`模块：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s go ahead and configure the health check endpoint to our web application.
    Map the health endpoint using the `MapHealthChecks` method, as shown in the following
    code, in the `Program.cs` file. This will add the health check endpoint route
    to the application. This will internally configure the `HealthCheckResponseWriters.WriteMinimalPlainText`
    framework method to emit the response. `WriteMinimalPlainText` will just emit
    the overall status of the health check services:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续配置健康检查端点到我们的Web应用程序。使用`MapHealthChecks`方法映射健康端点，如下面的代码所示，在`Program.cs`文件中。这将添加健康检查端点路由到应用程序。这将内部配置`HealthCheckResponseWriters.WriteMinimalPlainText`框架方法以输出响应。`WriteMinimalPlainText`将仅输出健康检查服务的总体状态：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the application and browse to the `<<Application URL>>/health` URL. You
    will see following the output:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并浏览到`<<Application URL>>/health` URL。您将看到以下输出：
- en: '![Figure 14.2 – Health check endpoint response'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 14.2 – 健康检查端点响应'
- en: '](img/Figure_14.2_B18507.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_14.2_B18507.jpg](img/Figure_14.2_B18507.jpg)'
- en: Figure 14.2 – Health check endpoint response
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 健康检查端点响应
- en: The health endpoint we added provides basic information on service availability.
    In the next section, we will see how we can monitor the status of dependent services.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的健康端点提供了关于服务可用性的基本信息。在下一节中，我们将看到如何监控依赖服务的状态。
- en: Monitoring dependent URIs
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控依赖URI
- en: An enterprise application depends on multiple other components, such as databases
    and Azure components including `KeyVault`, and other microservices (such as our
    `Ecommerce` website) depend on the Order service, Product service, and so on.
    These services can be owned by other teams within the same organization or, in
    some cases, they might be external services. It is often a good idea to monitor
    dependent services. We can leverage the `AspNetCore.HealthChecks.Uris` NuGet package
    to monitor the availability of dependent services.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序依赖于多个其他组件，例如数据库和包括`KeyVault`在内的Azure组件，以及其他微服务（例如我们的`Ecommerce`网站）依赖于订单服务、产品服务等。这些服务可能属于同一组织内的其他团队，或者在某些情况下，它们可能是外部服务。通常，监控依赖服务是一个好主意。我们可以利用`AspNetCore.HealthChecks.Uris`
    NuGet包来监控依赖服务的可用性。
- en: 'Let''s go ahead and enhance our health endpoint to monitor the Product and
    Order services:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续增强我们的健康端点以监控产品和订单服务：
- en: 'Add the NuGet package reference to `AspNetCore.HealthChecks.Uris`. Now, modify
    the health check registration to register the Product and Order services, as shown
    in the following code snippet:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将NuGet包引用添加到`AspNetCore.HealthChecks.Uris`。现在，修改健康检查注册以注册产品和订单服务，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The health check middleware also provides details about the status of individual
    health checks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查中间件还提供了关于单个健康检查状态的详细信息。
- en: 'Let''s now modify our health check middleware to emit the details as shown
    in the following code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们修改我们的健康检查中间件，以输出如下代码所示的详细信息：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code, the health check middleware is overwritten to write the details
    of the status, health check duration, component name, and a description as its
    response by providing `HealthCheckOptions` with `ResponseWriter`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，健康检查中间件被重写，通过提供`HealthCheckOptions`和`ResponseWriter`来将其状态、健康检查持续时间、组件名称和描述作为其响应写入。
- en: 'Now, if we run the project and navigate to the health check API, we should
    see the following output:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行项目并导航到健康检查API，我们应该看到以下输出：
- en: '![Figure 14.3 – Health check endpoint response with status'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.3 – 健康检查端点响应状态'
- en: '](img/Figure_14.3_B18507.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.3_B18507.jpg)'
- en: Figure 14.3 – Health check endpoint response with status
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 健康检查端点响应状态
- en: We have learned how to customize the response of the health check endpoint and
    how to leverage a third-party library to monitor the status of dependent URIs.
    If you wish to integrate the check for a database used via Entity Framework Core,
    you can leverage the `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore`
    library. More information about using this library can be found at [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0#entity-framework-core-dbcontext-probe](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0#entity-framework-core-dbcontext-probe).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何自定义健康检查端点的响应，以及如何利用第三方库来监控依赖URI的状态。如果您希望集成通过Entity Framework Core使用的数据库的检查，可以利用`Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore`库。有关使用此库的更多信息，请参阅[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0#entity-framework-core-dbcontext-probe](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0#entity-framework-core-dbcontext-probe)。
- en: A wider collection of health check packages for different services can be found
    at [https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks).
    In the next section, we will learn how to build a custom health check.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks)找到针对不同服务的更广泛的健康检查包集合。在下一节中，我们将学习如何构建自定义健康检查。
- en: Building a custom health check
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义健康检查
- en: The health check middleware in ASP.NET Core 6 is extensible, meaning that it
    allows us to extend and create a custom health check. We will learn how to build
    and use custom health checks by building a process monitor. In some scenarios,
    there might be a need to monitor a specific process running on the machine. If
    the process (for example, an anti-malware service) is not running, or if the license
    of a third-party SaaS offering is expiring/expired, we might flag them as health
    issues.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 6中的健康检查中间件是可扩展的，这意味着它允许我们扩展并创建自定义健康检查。我们将通过构建进程监控器来学习如何构建和使用自定义健康检查。在某些场景中，可能需要监控机器上运行的特定进程。如果进程（例如，反恶意软件服务）没有运行，或者如果第三方SaaS服务的许可证即将到期/已到期，我们可能会将它们标记为健康问题。
- en: 'Let''s start creating the `ProcessMonitor` health check in the `Packt.Ecommerce.Common`
    project:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Packt.Ecommerce.Common`项目中开始创建`ProcessMonitor`健康检查：
- en: 'Add a project folder named `HealthCheck` to `Packt.Ecommerce.Common` and add
    two classes, `ProcessMonitor` and `ProcessMonitorHealthCheckBuilderExtensions`,
    as shown in the following screenshot:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Packt.Ecommerce.Common`中添加一个名为`HealthCheck`的项目文件夹，并添加两个类，`ProcessMonitor`和`ProcessMonitorHealthCheckBuilderExtensions`，如下面的截图所示：
- en: '![Figure 14.4 – Project structure after adding a custom health check'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.4 – 添加自定义健康检查后的项目结构'
- en: '](img/Figure_14.4_B18507.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.4_B18507.jpg)'
- en: Figure 14.4 – Project structure after adding a custom health check
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 添加自定义健康检查后的项目结构
- en: The custom `HealthCheck` middleware requires the NuGet reference to be `Microsoft.Extensions.Diagnostics.HealthChecks`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义`HealthCheck`中间件需要NuGet引用为`Microsoft.Extensions.Diagnostics.HealthChecks`。
- en: The custom health check in ASP.NET Core 6 should implement the `IHealthCheck`
    interface. This interface defines the `CheckHealthAsync` method that will get
    called when the request comes to the health endpoint API.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core 6中的自定义健康检查应该实现`IHealthCheck`接口。该接口定义了当请求到达健康端点API时将被调用的`CheckHealthAsync`方法。
- en: 'Implement the `ProcessMonitorHealthCheck` class as shown in the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码实现`ProcessMonitorHealthCheck`类：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `CheckHealthAsync` method, fetch the list of processes with the name
    specified in `processName`. If there is no such process, then return as health
    check failed, otherwise, return the state as failed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CheckHealthAsync`方法中，根据`processName`中指定的名称获取进程列表。如果没有这样的进程，则返回健康检查失败，否则，返回状态为失败。
- en: 'Now that we have the custom health check middleware, let''s add an extension
    method to register. Modify the `ProcessMonitorHealthCheckBuilderExtensions` class
    as shown in the following code snippet:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了自定义健康检查中间件，让我们添加一个扩展方法来注册。修改`ProcessMonitorHealthCheckBuilderExtensions`类，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is an extension method to `IHealthCheckBuilder`. We can see that adding
    `ProcessMonitorHealthCheck` in the code snippet registers it with the container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对`IHealthCheckBuilder`的扩展方法。我们可以看到，在代码片段中添加`ProcessMonitorHealthCheck`会将它注册到容器中。
- en: 'Let''s now make use of the custom health check that we have built. In the following
    code, we registered the `ProcessMonitorHealthCheck` health check for `notepad`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来使用我们构建的自定义健康检查。在下面的代码中，我们为`notepad`注册了`ProcessMonitorHealthCheck`健康检查：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, when you run the application and navigate to the health check API, you
    will see the output shown in *Figure 14.5* if `notepad.exe` is running on your
    machine:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序并导航到健康检查API时，如果你机器上正在运行`notepad.exe`，你将看到*图14.5*中显示的输出：
- en: '![Figure 14.5 – Response from health check endpoint ](img/Figure_14.5_B18507.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 健康检查端点的响应](img/Figure_14.5_B18507.png)'
- en: Figure 14.5 – Response from the health check endpoint
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 健康检查端点的响应
- en: We can enable **cross-origin resource sharing** (**CORS**), authorization, and
    host restriction on our health check endpoints. For details, please refer to [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的健康检查端点上启用**跨源资源共享**（**CORS**）、授权和主机限制。有关详细信息，请参阅[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0)。
- en: 'In some scenarios, the health check APIs are split into two types based on
    the state of the application that they probe. They are the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，根据它们探测的应用程序状态，健康检查API被分为两种类型。它们如下：
- en: '**Readiness probes**: These indicate that the application is running normally
    but is not ready to take requests.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备就绪探针**：这些指示应用程序正在正常运行，但尚未准备好接收请求。'
- en: '**Liveliness probes**: These indicate whether the application has crashed and
    must be restarted.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存活探针**：这些指示应用程序是否已崩溃并需要重启。'
- en: Both readiness and liveliness probes are used to control the health of the application.
    A failing readiness probe will stop the application from serving traffic, whereas
    a failing liveliness probe will restart the node. We use readiness and liveliness
    probes in hosting environments, such as Kubernetes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪探针和存活探针都用于控制应用程序的健康状态。失败的准备就绪探针将阻止应用程序处理流量，而失败的存活探针将重启节点。我们在Kubernetes等托管环境中使用准备就绪和存活探针。
- en: We have learned about how to add the health check API to an ASP.NET Core 6 application.
    In the next section, we will learn about Azure Application Insights and how it
    helps to monitor an application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何将健康检查API添加到ASP.NET Core 6应用程序中。在下一节中，我们将学习Azure Application Insights以及它是如何帮助监控应用程序的。
- en: Monitoring the application with Application Insights
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Application Insights监控应用程序
- en: Monitoring the application is key to providing end users with a top-class experience.
    Application monitoring is needed to drive business return on investment and retain
    a competitive advantage in the current era of super-fast digital markets. The
    parameters we should be focusing on are page/API performance, most-used pages/APIs,
    application errors, and system health, among others. There should be alerts set
    up for when there is an anomaly in the system so that we can correct it and minimize
    the impact on our users.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 监控应用程序对于为最终用户提供一流体验至关重要。在当前这个超级快速数字市场的时代，应用程序监控对于推动业务投资回报率和保持竞争优势至关重要。我们应该关注的参数包括页面/API
    性能、最常使用的页面/API、应用程序错误和系统健康等。当系统出现异常时，应设置警报，以便我们可以纠正它并最小化对用户的影响。
- en: 'You were already introduced to integrating Application Insights into an application
    and its key features in [*Chapter 7*](B18507_07_Epub.xhtml#_idTextAnchor596),
    *Logging in .NET 6*. Let''s open Application Insights in the Azure portal and
    understand its different offerings. On the overview dashboard, along with the
    Azure subscription, location, and instrumentation key, we see key metrics as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在 [*第 7 章*](B18507_07_Epub.xhtml#_idTextAnchor596)，*在 .NET 6 中进行日志记录* 中介绍了将
    Application Insights 集成到应用程序及其关键功能。让我们在 Azure 门户中打开 Application Insights 并了解其不同的功能。在概览仪表板上，除了
    Azure 订阅、位置和仪器密钥外，我们还可以看到以下关键指标：
- en: '![Figure 14.6 – Application Insights dashboard'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.6 – Application Insights 仪表板'
- en: '](img/Figure_14.6_B18507.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.6_B18507.jpg)'
- en: Figure 14.6 – Application Insights dashboard
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – Application Insights 仪表板
- en: The **Failed requests** graph shows the number of requests that failed in the
    selected duration. This is the key metric we should pay attention to; many failures
    represent instability in the system. **Server response time** represents the average
    response time of the server for the calls. If the response time is too high, more
    users will see a lag in the application responsiveness, which might lead to frustration
    and we could lose our users as a result.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**失败的请求** 图显示了在所选时间段内失败的请求数量。这是我们应关注的指标；许多失败表示系统不稳定。**服务器响应时间** 表示服务器对调用的大致响应时间。如果响应时间过高，更多的用户将看到应用程序响应滞后，这可能会导致用户沮丧，我们可能会因此失去用户。'
- en: The **Server requests** graph represents the total number of calls to the application;
    this will give us the patterns of the usage in the system. The **Availability**
    graph represents the uptime of the application. The availability tests that we
    will configure later in this chapter will show the **Availability** graph. By
    clicking on each graph, we can get more details pertaining to the respective metric,
    including requests and exception details. We can change the duration to view the
    graphs for the chosen interval.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器请求** 图表示对应用程序的总调用次数；这将给我们展示系统使用模式。**可用性** 图表示应用程序的运行时间。在本章后面配置的可用性测试将显示
    **可用性** 图。通过点击每个图表，我们可以获取与相应指标相关的更多详细信息，包括请求和异常详情。我们可以更改持续时间来查看所选间隔的图表。'
- en: The graphs on the overview dashboard show recent metrics. This can be useful
    in a situation where we wish to know the working of the system for a particular
    time in the past.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 概览仪表板上的图表显示最近的指标。在希望了解过去特定时间点的系统工作情况时，这可能很有用。
- en: In the next section, we will learn about some of the most important offerings
    from Application Insights, looking at Live Metrics, telemetry events, and remote
    debugging features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解 Application Insights 的一些最重要的功能，包括实时指标、遥测事件和远程调试功能。
- en: Live Metrics
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时指标
- en: Live Metrics is enabled by default. Live metrics are captured with a latency
    of 1 second, unlike the analytics metrics, which are aggregated over time. The
    data for Live Metrics is streamed only when the Live Metrics pane is open. The
    collected data only persists while it is on the chart. During Live Metrics monitoring,
    all the events are transmitted from the server and they won't be sampled. We can
    also filter the events by the server if the application is deployed in a web farm.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下启用了实时指标。实时指标以 1 秒的延迟捕获，与按时间聚合的分析指标不同。只有当实时指标面板打开时，才会流式传输实时指标的数据。收集的数据仅在图表上存在。在实时指标监控期间，所有事件都从服务器传输，并且不会被采样。如果应用程序部署在
    Web 农场中，我们还可以根据服务器过滤事件。
- en: Live Metrics shows various charts, such as the incoming and outgoing requests,
    along with the overall health of the memory and CPU utilization. On the right-hand
    pane, we can see the captured telemetry, which will list the requests, dependency
    calls, and exceptions. Live Metrics is leveraged where we want to evaluate a fix
    that is released to production by watching the failure rates and performance.
    We will also monitor these while running a load test to see the effects of the
    load on the system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Live Metrics 展示了各种图表，例如入站和出站请求，以及内存和 CPU 利用率的整体健康状况。在右侧面板中，我们可以看到捕获的遥测数据，它将列出请求、依赖调用和异常。Live
    Metrics 在我们需要通过观察失败率和性能来评估已发布到生产环境的修复方案时被利用。我们也会在运行负载测试时监控这些数据，以查看负载对系统的影响。
- en: For applications such as our `Ecommerce` app, it is important to know how users
    are using the application, the most-used features, and how users are traversing
    through the application. In the next section, we will learn about usage analysis
    in Application Insights.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像我们的 `Ecommerce` 应用这样的应用程序，了解用户如何使用应用程序、最常用的功能和用户如何遍历应用程序非常重要。在下一节中，我们将学习如何在
    Application Insights 中进行使用分析。
- en: Usage analysis with Application Insights
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Application Insights 进行使用分析
- en: In [*Chapter 11*](B18507_11_Epub.xhtml#_idTextAnchor1228), *Creating an ASP.NET
    Core 6 Web Application*, you learned how to integrate Application Insights with
    views. When Application Insights is integrated with views, Application Insights
    helps us with powerful insights into how people are using an application. The
    **Users** blade under the **Usage** section of Application Insights provides details
    about the number of users using the application. The user is identified by using
    anonymous IDs stored in browser cookies. Please note that a single person using
    different browsers and machines is counted as more than one user. The **Sessions**
    and **Events** blades represent the sessions of user activity and how often certain
    pages or features are used respectively. You can also generate reports on users,
    sessions, and events based on custom events, which you learned about in [*Chapter
    7*](B18507_07_Epub.xhtml#_idTextAnchor596), *Logging in .NET 6*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 11 章*](B18507_11_Epub.xhtml#_idTextAnchor1228)，*创建 ASP.NET Core 6 Web
    应用程序* 中，你学习了如何将 Application Insights 与视图集成。当 Application Insights 与视图集成时，它可以帮助我们深入了解人们如何使用应用程序。Application
    Insights 下的 **使用** 部分的 **用户** 刀片提供了有关使用应用程序的用户数量的详细信息。用户通过存储在浏览器 cookie 中的匿名 ID
    来识别。请注意，使用不同浏览器和机器的单一个人被计为多个用户。**会话** 和 **事件** 刀片分别表示用户活动的会话以及某些页面或功能被使用的频率。你还可以根据你在
    [*第 7 章*](B18507_07_Epub.xhtml#_idTextAnchor596)，*在 .NET 6 中记录日志* 中了解的自定义事件生成关于用户、会话和事件的报告。
- en: 'Another interesting tool available under usage analysis is **User Flows**.
    The **User Flows** tool visualizes how users navigate through different pages
    and features of an application. User flows provide the events that happened before
    and after the given event during the user session. *Figure 14.7* shows the user
    flows at a given time. This tells us that from the home page, users are mainly
    navigating to the **Product Details** page or the **Account Sign In** page:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用分析中，还有一个有趣的工具叫做 **用户流程**。**用户流程** 工具可视化用户如何在不同页面和应用程序功能之间导航。用户流程提供了在用户会话期间给定事件之前和之后发生的事件。*图
    14.7* 展示了给定时间点的用户流程。这告诉我们，从主页开始，用户主要导航到 **产品详情** 页面或 **账户登录** 页面：
- en: '![Figure 14.7 – User flow in our Ecommerce application'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.7 – 我们电商应用的用户流程'
- en: '](img/Figure_14.7_B18507.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.7_B18507.jpg)'
- en: Figure 14.7 – User flow in our Ecommerce application
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 我们电商应用的用户流程
- en: 'Let''s add a couple of custom events and see what the user flow is like against
    those custom events. Add one custom event, as shown in the following code snippet,
    in the `Create` action method of `OrderController` in the `Packt.Ecommerce.Web`
    application. This will track a custom event when the user clicks on the **Place
    Order** button on the **Cart** page:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些自定义事件，并查看用户流程与这些自定义事件之间的关系。在 `Packt.Ecommerce.Web` 应用程序的 `OrderController`
    的 `Create` 动作方法中添加一个自定义事件，如下面的代码片段所示。这将跟踪用户在 **购物车** 页面上点击 **下单** 按钮时发生的自定义事件：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, let''s add a custom event tracking when the user clicks on the **Add
    to Cart** button on the **Product Details** page. To do this, add the following
    code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们添加一个自定义事件跟踪，当用户在 **产品详情** 页面上点击 **加入购物车** 按钮时。为此，添加以下代码片段：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After adding the custom events, the user flow will show the different activities
    of the application with respect to these events. User Flows is a handy tool to
    know how many users are navigating away from a page and what they click on a page.
    Please refer to the Azure Application Insights documentation provided in the *Further
    reading* section at the end of the chapter to learn more about the other interesting
    offerings for usage analysis, including cohorts, funnels, and retention.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义事件后，用户流程将显示与这些事件相关的应用程序的不同活动。用户流程是一个方便的工具，可以了解有多少用户正在离开页面以及他们在页面上点击了什么。请参考章节末尾的*进一步阅读*部分提供的Azure应用洞察文档，以了解更多关于使用分析的其他有趣功能，包括群体、漏斗和保留。
- en: When there are enough telemetry events, you can use an Application Insights
    feature called **Smart Detection**, which automatically detects anomalies in the
    system and alerts us to them. In the next section, we will learn about Smart Detection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当有足够的遥测事件时，你可以使用一个名为**智能检测**的应用洞察功能，它能够自动检测系统中的异常并向我们发出警报。在下一节中，我们将学习关于智能检测的内容。
- en: Smart Detection
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能检测
- en: Smart Detection does not need any configuration or code changes. It works on
    the telemetry data captured from the system. Alerts will be displayed under the
    **Smart Detection** blade in the system and these alerts will go to users with
    the **Monitoring Reader** and **Monitoring Contributor** roles. We can configure
    additional recipients for these alerts under the **Settings** option. Some of
    the Smart Detection rules include **Slow page load time**, **Slow server response
    time**, **Abnormal raise in daily data volume**, and **Degradation in dependency
    volume**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 智能检测不需要任何配置或代码更改。它基于从系统中捕获的遥测数据工作。警报将在系统的**智能检测**选项卡下显示，并且这些警报将发送给具有**监控读取器**和**监控贡献者**角色的用户。我们可以在**设置**选项下为这些警报配置额外的收件人。一些智能检测规则包括**页面加载时间慢**、**服务器响应时间慢**、**每日数据量异常增加**和**依赖项数量下降**。
- en: One of the important aspects we need to monitor for an application is availability.
    In the next section, we will learn how to leverage Application Insights to monitor
    application availability.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序，我们需要监控的一个重要方面是可用性。在下一节中，我们将学习如何利用应用洞察来监控应用程序的可用性。
- en: Application availability
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序可用性
- en: In Application Insights, we can set up availability tests for any `http` or
    `https` endpoints accessible from the internet. This does not require any changes
    to our application code. We can configure the health check endpoint at `(<App
    Root URL>/health)` for an availability test.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用洞察中，我们可以为任何从互联网可访问的`http`或`https`端点设置可用性测试。这不需要对我们的应用程序代码进行任何更改。我们可以为可用性测试配置健康检查端点`(<App
    Root URL>/health)`。
- en: 'To configure an availability test, go to the Application Insights resource
    in the Azure portal and perform the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置可用性测试，请转到Azure门户中的应用洞察资源，并执行以下步骤：
- en: 'Select **Availability** under the **Investigate** menu, as shown here:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**调查**菜单下选择**可用性**，如图所示：
- en: '![Figure 14.8 – Application Insights'' Availability section'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.8 – 应用洞察的可用性部分'
- en: '](img/Figure_14.8_B18507.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_14.8_B18507.jpg]'
- en: Figure 14.8 – Application Insights' Availability section
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 应用洞察的可用性部分
- en: Click on **Add test** to add an availability test, as highlighted in the preceding
    screenshot.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加测试**以添加可用性测试，如前一张截图所示。
- en: In the `Commerce availability test`), select `<<App root url>>/health`. Leave
    the other options at their default values and click on **Create**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Commerce可用性测试`中，选择`<<App root url>>/health`。将其他选项保留在默认值，然后点击**创建**。
- en: 'Once the test is configured, Application Insights will call the configured
    URL every 5 minutes from all the configured regions. We can see the availability
    test results as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试配置完成，应用洞察将从所有配置的区域每5分钟调用一次配置的URL。我们可以如下查看可用性测试结果：
- en: '![Figure 14.9 – Availability test results'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.9 – 可用性测试结果'
- en: '](img/Figure_14.9_B18507.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_14.9_B18507.jpg]'
- en: Figure 14.9 – Availability test results
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – 可用性测试结果
- en: The default regions selected while creating the tests were **Brazil South**,
    **East Asia**, **Japan East**, **Southeast Asia**, and **UK South**. We can add
    or remove any of the regions on which the availability test will be run. It is
    recommended to configure at least five regions.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建测试时选择的默认区域为**巴西南部**、**东亚**、**日本东部**、**东南亚**和**英国南部**。我们可以添加或删除将在其上运行可用性测试的任何区域。建议至少配置五个区域。
- en: 'If we want to add a new region at a later point in time, we can edit the availability
    test and select the new region (for example, **West Europe**) as shown in the
    following screenshot and then click on **Save**:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在以后的时间添加新的区域，我们可以编辑可用性测试并选择新的区域（例如，**西欧**），如下面的屏幕截图所示，然后点击**保存**：
- en: '![Figure 14.10 – Editing availability test regions'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.10 – 编辑可用性测试区域'
- en: '](img/Figure_14.10_B18507.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.10 – 示例图片](img/Figure_14.10_B18507.jpg)'
- en: Figure 14.10 – Editing availability test regions
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.10 – 编辑可用性测试区域'
- en: We can also configure a multi-step web test as an availability test in Application
    Insights.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在Application Insights中将多步骤Web测试配置为可用性测试。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'You can use the following documentation to help you configure a multi-step
    web test: [https://docs.microsoft.com/en-us/azure/azure-monitor/app/availability-multistep](https://docs.microsoft.com/en-us/azure/azure-monitor/app/availability-multistep).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下文档来帮助您配置多步骤Web测试：[https://docs.microsoft.com/en-us/azure/azure-monitor/app/availability-multistep](https://docs.microsoft.com/en-us/azure/azure-monitor/app/availability-multistep)。
- en: Application Insights provides a very good tool to query the telemetry events
    captured. In the next section, we will learn about the **Search** feature in Application
    Insights.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Application Insights提供了一个非常好的工具来查询捕获的遥测事件。在下一节中，我们将了解Application Insights中的**搜索**功能。
- en: Search
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: 'The **Search** feature in Application Insights helps to explore telemetry events
    such as requests, page views, and exceptions. We can also query the traces that
    we have coded in the application. **Search** can be opened from the **Overview**
    tab or from the **Search** option of the **Investigate** tab:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Application Insights中的**搜索**功能有助于探索遥测事件，如请求、页面视图和异常。我们还可以查询我们在应用程序中编码的跟踪。**搜索**可以从**概览**选项卡或从**调查**选项卡的**搜索**选项中打开：
- en: '![Figure 14.11 – Search results'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11 – 搜索结果'
- en: '](img/Figure_14.11_B18507.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11 – 示例图片](img/Figure_14.11_B18507.jpg)'
- en: Figure 14.11 – Search results
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11 – 搜索结果'
- en: With the **Transaction Search** feature, we can filter the telemetry events
    displayed based on time and **Event Type**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**事务搜索**功能，我们可以根据时间和**事件类型**过滤显示的遥测事件。
- en: 'We can also filter on their properties. By clicking on a specific event, we
    can view all the properties of the event along with the telemetry of the event.
    To view the requests with status code **500**, filter the events based on the
    response code as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据它们的属性进行过滤。通过点击特定事件，我们可以查看事件的全部属性以及事件的遥测信息。要查看状态代码为**500**的请求，请根据响应代码过滤事件，如下所示：
- en: '![Figure 14.12 – Filtering search results'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.12 – 过滤搜索结果'
- en: '](img/Figure_14.12_B18507.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.12 – 示例图片](img/Figure_14.12_B18507.jpg)'
- en: Figure 14.12 – Filtering search results
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.12 – 过滤搜索结果'
- en: 'Once we apply the filter, in the search results, we will only see requests
    with the response code 500, as shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用了过滤器，在搜索结果中，我们只会看到响应代码为500的请求，如下面的屏幕截图所示：
- en: '![Figure 14.13 – Filtered search results'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.13 – 过滤后的搜索结果'
- en: '](img/Figure_14.13_B18507.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.13 – 过滤后的搜索结果'
- en: Figure 14.13 – Filtered search results
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 – 过滤后的搜索结果
- en: 'To know more about what caused the failure, click on the event. Clicking on
    the event will show the details of the related telemetry, as shown in the following
    screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于导致失败的原因，请点击事件。点击事件将显示相关遥测的详细信息，如下面的屏幕截图所示：
- en: '![Figure 14.14 – End-to-end transaction details'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.14 – 端到端事务详情'
- en: '](img/Figure_14.14_B18507.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.14 – 示例图片](img/Figure_14.14_B18507.jpg)'
- en: Figure 14.14 – End-to-end transaction details
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14 – 端到端事务详情
- en: We can even drill down more by clicking on the exception. This will show details
    such as the method name and the stack trace, which will help us identify the cause
    of the failure.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过点击异常来进一步深入。这将显示诸如方法名称和堆栈跟踪等详细信息，这将帮助我们确定失败的原因。
- en: With Application Insights, we can write custom queries on the telemetry data
    that was captured to get more meaningful insights. In the next section, we will
    learn about writing queries.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Application Insights，我们可以对捕获的遥测数据编写自定义查询，以获得更有意义的见解。在下一节中，我们将学习如何编写查询。
- en: Logs
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志
- en: 'To write queries on the telemetry data that is captured, let''s navigate to
    it as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要对捕获的遥测数据进行查询，请按照以下步骤导航：
- en: 'Go to **Application Insights** | **Monitoring** | **Logs**. This will show
    the **Logs** page with sample queries that we can run:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Application Insights** | **监控** | **日志**。这将显示**日志**页面，其中包含我们可以运行的示例查询：
- en: '![Figure 14.15 – Application Insights logs'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.15 – Application Insights日志'
- en: '](img/Figure_14.15_B18507.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.15 – 示例图片](img/Figure_14.15_B18507.jpg)'
- en: Figure 14.15 – Application Insights logs
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15 – Application Insights日志
- en: 'Select **Request count trend** in the suggested sample queries. This will generate
    a query for us and run it. Once the run is complete, we will see the results and
    the chart populated, as shown in the following screenshot:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在建议的样本查询中选择**请求计数趋势**。这将为我们生成一个查询并运行它。一旦运行完成，我们将看到结果和图表被填充，如下面的截图所示：
- en: '![Figure 14.16 – Log search results'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.16 – 日志搜索结果'
- en: '](img/Figure_14.16_B18507.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_14.16_B18507.jpg)'
- en: Figure 14.16 – Log search results
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16 – 日志搜索结果
- en: The telemetry that is captured in Application Insights goes into different tables
    covering requests, exceptions, dependencies, traces, and page views. The query
    generated here summarizes the telemetry data from the request table and renders
    a time chart where the time axis is split by 30 minutes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Application Insights中捕获的遥测数据进入不同的表，涵盖请求、异常、依赖项、跟踪和页面视图。这里生成的查询汇总了请求表中的遥测数据，并渲染了一个时间图表，其中时间轴被分成30分钟。
- en: We select the time range as per our requirements. We can even specify the time
    range in the query rather than selecting from the menu options. These queries
    created here can be saved and rerun at a later time. There is also an option to
    configure alerts here, which we learned about in [*Chapter 7*](B18507_07_Epub.xhtml#_idTextAnchor596),
    *Logging in .NET 6*. The language used here to write the queries is Kusto.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据需求选择时间范围。我们甚至可以在查询中指定时间范围，而不是从菜单选项中选择。这里创建的查询可以保存并在以后重新运行。这里还有一个配置警报的选项，我们曾在[*第7章*](B18507_07_Epub.xhtml#_idTextAnchor596)中了解到，即.NET
    6中的*日志记录*。这里编写查询使用的语言是Kusto。
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Refer to the following documentation to learn about Kusto Query Language: [https://docs.microsoft.com/en-us/azure/data-explorer/kusto/concepts/](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/concepts/).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Kusto查询语言的更多信息，请参阅以下文档：[https://docs.microsoft.com/en-us/azure/data-explorer/kusto/concepts/](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/concepts/)。
- en: Kusto is based on relational database constructs. With Kusto Query Language,
    we can write complex analytical queries. Kusto supports group-by aggregation,
    computed columns, and join functions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Kusto基于关系数据库结构。使用Kusto查询语言，我们可以编写复杂的分析查询。Kusto支持按组聚合、计算列和连接函数。
- en: 'Let''s take another example, where we want to identify the 95th percentile
    service response time for each client city. The query for this will be written
    as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子，我们想要识别每个客户城市的95百分位服务响应时间。这个查询将如下编写：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding query, we are using the `percentile` function to identify the
    95th percentile and summarize it per region. The results are rendered as a bar
    chart.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的查询中，我们使用`percentile`函数来识别95百分位并按区域进行汇总。结果以条形图的形式呈现。
- en: 'For the preceding query, we see the following graph:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的查询，我们看到以下图表：
- en: '![Figure 14.17 – Kusto percentile summary results'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.17 – Kusto百分位摘要结果'
- en: '](img/Figure_14.17_B18507.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_14.17_B18507.jpg)'
- en: Figure 14.17 – Kusto percentile summary results
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17 – Kusto百分位摘要结果
- en: From the rendered graph, we can infer that the response time for a request coming
    from **Chennai** is faster than for requests from **Secunderabad**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从渲染的图表中，我们可以推断出来自**钦奈**的请求响应时间比来自**西姆纳巴德**的请求响应时间更快。
- en: 'Now, let''s find any exceptions that caused a request failure and summarize
    them by request and exception type. To get the result for this, we will join the
    `requests` table with `exceptions` and summarize them based on request name and
    exception type, as shown in the following query:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找到任何导致请求失败的异常，并按请求和异常类型进行汇总。为了得到这个结果，我们将`requests`表与`exceptions`表连接，并根据请求名称和异常类型进行汇总，如下面的查询所示：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we run the query, we get the results summarized by the name of the request
    and the type of the exception, as shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个查询，我们会得到以下截图所示的按请求名称和异常类型汇总的结果：
- en: '![Figure 14.18 – Kusto failing request exception'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.18 – Kusto失败的请求异常'
- en: '](img/Figure_14.18_B18507.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_14.18_B18507.jpg)'
- en: Figure 14.18 – Kusto failing request exception
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18 – Kusto失败的请求异常
- en: Search is a powerful feature of Application Insights to diagnose and fix failures
    in a production site. It is recommended to click through the different features
    of Application Insights and explore them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索是Application Insights的强大功能，用于诊断和修复生产站点的故障。建议点击Application Insights的不同功能并探索它们。
- en: When you create an Application Insights resource, a **Log Analytics workspace**
    will be created that persists the telemetry captured through Application Insights.
    Using **Log Analytics** workspaces along with application metrics, we can also
    query and monitor the key metrics related to Azure resources such as RU/s consumed
    in Cosmos DB. All the queries we ran in this section were executed on the **Log
    Analytics** workspace. We can create a dashboard in the Azure portal and pin all
    the charts related to the key metrics we wanted to track for the application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建Application Insights资源时，将创建一个**日志分析工作区**，该工作区将持久保存通过Application Insights捕获的遥测数据。使用**日志分析**工作区以及应用程序度量，我们还可以查询和监控与Azure资源相关的关键指标，例如在Cosmos
    DB中消耗的RU/s。本节中运行的所有查询都是在**日志分析**工作区中执行的。我们可以在Azure门户中创建仪表板，并将所有与我们要跟踪的应用程序关键指标相关的图表固定在仪表板上。
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Refer to the Azure documentation to learn more about Log Analytics: [https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-overview](https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-overview).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 参考Azure文档以了解更多关于日志分析的信息：[https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-overview](https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-overview)。
- en: In this section, we learned how to monitor the application deployed in Azure
    using Azure Monitor. To analyze and troubleshoot any production failures better,
    we might want to know the state of an application when a specific error occurred.
    In the next section, we will learn how the **Snapshot Debugger** feature of Application
    Insights enables us to achieve this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用Azure Monitor监控在Azure中部署的应用程序。为了更好地分析和调试任何生产故障，我们可能想了解特定错误发生时应用程序的状态。在下一节中，我们将学习Application
    Insights的**快照调试器**功能如何使我们实现这一点。
- en: Configuring the Snapshot Debugger
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置快照调试器
- en: The Snapshot Debugger monitors the exception telemetry of our application. It
    automatically collects snapshots of the top exceptions that occurred in the application
    with the current state of the source code and variables.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 快照调试器监控我们应用程序的异常遥测。它自动收集应用程序中发生的顶级异常的快照，包括当前源代码的状态和变量。
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Snapshot Debugger feature is only available in the Enterprise version of
    Visual Studio.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 快照调试器功能仅在Visual Studio的企业版中可用。
- en: 'Let''s now go ahead and configure the Snapshot Debugger for our `Ecommerce`
    application:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续配置我们的`Ecommerce`应用的快照调试器：
- en: Add the `Microsoft.ApplicationInsights.SnapshotCollector` NuGet package to the
    `Packt.Ecommerce.Web` project.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Microsoft.ApplicationInsights.SnapshotCollector` NuGet包添加到`Packt.Ecommerce.Web`项目中。
- en: 'Add the following `using` statement to `Startup.cs`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`语句添加到`Startup.cs`中：
- en: '[PRE18]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a Snapshot Collector to your services by adding the following line to the
    `ConfigureServices` method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`ConfigureServices`方法中添加以下行，将快照收集器添加到您的服务中：
- en: '[PRE19]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To simulate a failure, add the following code to the `GetProductsAsync` method
    of the `EcommerceService` class. This code will throw an error if there are any
    products available:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要模拟失败，请将以下代码添加到`EcommerceService`类的`GetProductsAsync`方法中。如果存在任何产品，此代码将引发错误：
- en: '[PRE20]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's go ahead and run the application. We see an error on the home page.
    Refresh the page again, as the debugging snapshot is for errors that occur at
    least twice.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续运行应用程序。我们在主页上看到一个错误。刷新页面，因为调试快照是为至少发生两次的错误而设计的。
- en: 'Now, open the **Search** tab in Application Insights. Filter by the **Exception**
    event types:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开Application Insights中的**搜索**选项卡。按**异常**事件类型进行筛选：
- en: '![Figure 14.19 – Exceptions telemetry'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.19 – 异常遥测'
- en: '](img/Figure_14.19_B18507.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_14.19_B18507.jpg)'
- en: Figure 14.19 – Exceptions telemetry
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19 – 异常遥测
- en: 'Click on the exception to go to the details page. On the details page, we see
    that the debug snapshot has been created for the exception, as highlighted in
    the following screenshot:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击异常进入详情页面。在详情页面中，我们看到已经为异常创建了调试快照，如以下截图所示：
- en: '![Figure 14.20 – Debug snapshot'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.20 – 调试快照'
- en: '](img/Figure_14.20_B18507.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_14.20_B18507.jpg)'
- en: Figure 14.20 – Debug snapshot
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.20 – 调试快照
- en: 'Click on the **Debug Snapshot** icon. This will take us to the **Debug Snapshot**
    page:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**调试快照**图标。这将带我们到**调试快照**页面：
- en: '![Figure 14.21 – Debug Snapshot window'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.21 – 调试快照窗口'
- en: '](img/Figure_14.21_B18507.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_14.21_B18507.jpg)'
- en: Figure 14.21 – Debug Snapshot window
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.21 – 调试快照窗口
- en: To view the debug snapshots, the **Application Insights Snapshot Debugger Role**
    is required. As the debug state might have sensitive information, this role is
    not added by default. Click on the **Add Application Insights Snapshot Debugger
    Role** button. This will add the role to the currently logged-in user.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看调试快照，需要**应用程序洞察快照调试器角色**。由于调试状态可能包含敏感信息，因此默认情况下不会添加此角色。单击**添加应用程序洞察快照调试器角色**按钮。这将向当前登录用户添加该角色。
- en: 'Once the role addition is complete, we can then see the debug snapshot details
    populated on the page, along with a button to download the snapshot:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦角色添加完成，我们就可以在页面上看到调试快照的详细信息，以及一个下载快照的按钮：
- en: '![Figure 14.22 – Download debug snapshot'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.22 – 下载调试快照'
- en: '](img/Figure_14.22_B18507.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.22_B18507.jpg)'
- en: Figure 14.22 – Download debug snapshot
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.22 – 下载调试快照
- en: 'Click on the `diagsession`. Open the downloaded `diagsession` file in Visual
    Studio:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击 `diagsession`。在 Visual Studio 中打开下载的 `diagsession` 文件：
- en: '![Figure 14.23 – Debug snapshot view in Visual Studio'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.23 – Visual Studio 中的调试快照视图'
- en: '](img/Figure_14.23_B18507.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.23_B18507.jpg)'
- en: Figure 14.23 – Debug snapshot view in Visual Studio
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.23 – Visual Studio 中的调试快照视图
- en: 'Now, click on `InvalidOperationException`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，单击 `InvalidOperationException`：
- en: '![Figure 14.24 – Debugging snapshot in Visual Studio'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.24 – Visual Studio 中的调试快照'
- en: '](img/Figure_14.24_B18507.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.24_B18507.jpg)'
- en: Figure 14.24 – Debugging snapshot in Visual Studio
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.24 – Visual Studio 中的调试快照
- en: In this debug session, we may add a watch to the local variables and class variables
    to understand the state they are in, which will aid in debugging.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在此调试会话中，我们可能需要将监视器添加到局部变量和类变量，以了解它们的状态，这将有助于调试。
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Refer to the following documentation to understand more about the Snapshot
    Debugger configurations: [https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm](https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下文档以了解有关快照调试器配置的更多信息：[https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm](https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm)。
- en: As the application grows and is integrated with multiple other services, it
    will be challenging to troubleshoot and debug those issues that occur in production
    environments. In some cases, it is not possible to reproduce them in the pre-production
    environment. With the telemetry that we capture and the tools available with Application
    Insights, we will be able to analyze the problem and address the issue. The Snapshot
    Debugger is a powerful tool to troubleshoot critical issues. Application Insights
    collects telemetry data and sends it in batches via a background process. The
    impact of using Application Insights on our application is small.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长并与多个其他服务集成，将面临在生产环境中调试和解决出现的问题的挑战。在某些情况下，我们无法在预生产环境中重现它们。通过我们捕获的遥测数据和
    Application Insights 提供的工具，我们将能够分析问题并解决问题。快照调试器是一个强大的工具，用于调试关键问题。Application Insights
    收集遥测数据并通过后台进程批量发送。使用 Application Insights 对我们应用程序的影响很小。
- en: There might be instances where we want to debug a live application. With Visual
    Studio, we are able to attach a debugger to a remotely running application to
    debug it. In the next section, we will learn how to achieve this.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在我们需要调试一个运行中的应用程序的情况。使用 Visual Studio，我们可以将调试器附加到远程运行的应用程序以进行调试。在下一节中，我们将学习如何实现这一点。
- en: Performing remote debugging
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行远程调试
- en: 'In this section, we will learn how to attach a debugger to our deployed application
    in Azure App Service. Debugging a remote application is easy with the tooling
    provided by Visual Studio. Deploying an application in Azure App Service is covered
    in [*Chapter 16*](B18507_16_Epub.xhtml#_idTextAnchor1932), *Deploying the Application
    in Azure*. We can attach a debugger to an already-deployed service by performing
    the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将调试器附加到我们在 Azure App Service 中部署的应用程序。使用 Visual Studio 提供的工具，远程调试应用程序很容易。在
    Azure App Service 中部署应用程序的内容在 [*第 16 章*](B18507_16_Epub.xhtml#_idTextAnchor1932)，*在
    Azure 中部署应用程序* 中介绍。我们可以通过执行以下操作将调试器附加到已部署的服务：
- en: Launch the **Publish** window by right-clicking on the **Packt.Ecommerce.Web**
    project and select **Publish** from the context menu. You can also launch the
    **Publish** window by setting the **Build** | Publish **Packt.Ecommerce.Web**
    menu item.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击**Packt.Ecommerce.Web**项目并从上下文菜单中选择**发布**，或通过设置**构建**|**发布****Packt.Ecommerce.Web**菜单项来启动**发布**窗口。
- en: Create a **Publish** profile to **Packt.Ecommerce.Web** by selecting the Azure
    App Service resource in the Publish Wizard.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在发布向导中选择 Azure App Service 资源，为 **Packt.Ecommerce.Web** 创建一个 **发布** 配置文件。
- en: 'Once the **Publish** profile is created, you can attach the debugger to the
    application instance running in Azure App Service by selecting **Attach Debugger**
    from the **Hosting** options, as shown in the following screenshot:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 **发布** 配置文件后，您可以通过从 **托管** 选项中选择 **附加调试器** 来将调试器附加到在 Azure App Service 中运行的应用程序实例，如下面的屏幕截图所示：
- en: '![Figure 14.25 – Visual Studio''s Publish window'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.25 – Visual Studio 的发布窗口'
- en: '](img/Figure_14.25_B18507.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.25_B18507.jpg)'
- en: Figure 14.25 – Visual Studio's Publish window
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.25 – Visual Studio 的发布窗口
- en: Once the debugger is attached, the application will be opened in the browser
    from Azure App Service. We can add breakpoints in Visual Studio and debug the
    application as we would in a local development environment. To debug effectively,
    we need the debug version of the application deployed to Azure App Service.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦调试器连接，应用程序将在 Azure App Service 中通过浏览器打开。我们可以在 Visual Studio 中添加断点，并像在本地开发环境中一样调试应用程序。为了有效地调试，我们需要将应用程序的调试版本部署到
    Azure App Service。
- en: Though this is a powerful feature for debugging remotely deployed applications,
    we should be extra cautious when attaching the debugger to the production instance,
    as we will be seeing live customer data. We can attach the debugger to the staging
    slot of Azure App Service to debug and fix the issue, and from there, swap the
    staging slot to promote the fix to production. There are many more important features
    in Application Insights and Azure Monitor that are not covered in this chapter.
    It is strongly recommended to explore them further in the Azure documentation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是远程部署应用程序的强大功能，但在将调试器附加到生产实例时应格外小心，因为我们将会看到实时客户数据。我们可以将调试器附加到 Azure App Service
    的预发布槽位以调试和修复问题，然后从那里交换预发布槽位以将修复推广到生产。本章未涵盖 Application Insights 和 Azure Monitor
    的许多其他重要功能。强烈建议在 Azure 文档中进一步探索它们。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the concepts of health checks and diagnosing
    problems with applications using Application Insights. We have learned how to
    build a health check API and add a health check module to our `Ecommerce` application,
    which will help us monitor the health of an application. This chapter also covered
    some of the key features of Azure Application Insights, which is a powerful tool
    to capture telemetry and diagnose problems.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了使用 Application Insights 对应用程序进行健康检查和诊断问题的概念。我们学习了如何构建健康检查 API 并将健康检查模块添加到我们的
    `Ecommerce` 应用程序中，这将帮助我们监控应用程序的健康状况。本章还介绍了 Azure Application Insights 的关键特性，它是一个强大的工具，用于捕获遥测数据和诊断问题。
- en: We have learned how Application Insights detects anomalies and alerts with the
    Smart Detection feature. We have also learned about snapshots and remote debugging,
    which help to troubleshoot problems in live applications running in production
    environments.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用智能检测功能检测 Application Insights 中的异常和警报。我们还了解了快照和远程调试，这些有助于在生产环境中运行的实时应用程序中解决问题。
- en: In the next chapter, we are going to learn about different testing methodologies
    to ensure the quality of an application before deploying it to production.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习不同的测试方法，以确保在部署到生产环境之前应用程序的质量。
- en: Questions
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'After reading this chapter, we should be able to answer the following questions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，我们应该能够回答以下问题：
- en: Periodic monitoring of the application is not that important for an application
    once it is deployed to production. True or false?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序部署到生产环境，定期监控应用程序并不那么重要。对还是错？
- en: a. True
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b. False
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: '**Answer: b**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: What is the interface that a custom health check module should implement?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义健康检查模块应该实现哪个接口？
- en: a. `IHealth`
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: a. `IHealth`
- en: b. `IApplicationBuilder`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: b. `IApplicationBuilder`
- en: c.`IHealthCheck`
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: c. `IHealthCheck`
- en: d. `IWebHostEnvironment`
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: d. `IWebHostEnvironment`
- en: '**Answer: c**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
- en: What is the latency in displaying Live Metrics data in Application Insights?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Application Insights 中显示实时指标数据的延迟是多少？
- en: a. 1 minute
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: a. 1 分钟
- en: b. 1 second
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: b. 1 秒
- en: c. 10 seconds
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: c. 10 秒
- en: d. 5 seconds
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: d. 5 秒
- en: '**Answer: b**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: What is the query language used to write queries in Application Insights logs?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Application Insights 日志中编写查询所使用的查询语言是什么？
- en: a. SQL
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: a. SQL
- en: b. C#
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: b. C#
- en: c. JavaScript
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: c. JavaScript
- en: d. Kusto
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: d. Kusto
- en: '**Answer: d**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：d**'
- en: Further reading
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Azure Application Insights documentation: [https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview](https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 应用洞察文档：[https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview](https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)
