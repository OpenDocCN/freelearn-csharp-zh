- en: Using Resources and MVVM Patterns
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用资源和 MVVM 模式
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Using binary resources inside a WPF application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中使用二进制资源
- en: Using binary resources from another assembly
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个程序集使用二进制资源
- en: Accessing binary resources in code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中访问二进制资源
- en: Using static logical resources in WPF
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 WPF 中使用静态逻辑资源
- en: Using dynamic logical resources in WPF
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 WPF 中使用动态逻辑资源
- en: Managing logical resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理逻辑资源
- en: Using user selected colors and fonts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户选择的颜色和字体
- en: Building an application using the MVVM pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MVVM 模式构建应用程序
- en: Using routed commands in a WPF application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中使用路由命令
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: While binary resources play a vital role in any application, WPF also provides
    a different kind of resource, called a **logical resource**. These logical resources
    are objects that can be shared throughout the application and can be accessed
    across multiple assemblies. These can be of two types, static logical resources
    and dynamic logical resources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然二进制资源在任何应用程序中都发挥着至关重要的作用，但 WPF 还提供了一种不同类型的资源，称为 **逻辑资源**。这些逻辑资源是可以在整个应用程序中共享的对象，并且可以在多个程序集之间访问。这些资源可以分为两种类型，静态逻辑资源和动态逻辑资源。
- en: On the other hand, **MVVM** (**Model-View-ViewModel**) is a pattern that keeps
    a separation between the UI and the code, giving the designers and developers
    the flexibility to work on a single window without depending on each other.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**MVVM**（**模型-视图-视图模型**）是一种保持 UI 和代码之间分离的模式，它为设计师和开发者提供了在单个窗口上工作的灵活性，而不依赖于彼此。
- en: In this chapter, we will first cover binary resources, logical resources, and
    then move forward to learn building applications using the MVVM pattern. We will
    also cover how to use **RoutedCommands** to demonstrate the **Command Design Pattern**
    in WPF applications, which can be invoked from multiple locations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先介绍二进制资源、逻辑资源，然后继续学习使用 MVVM 模式构建应用程序。我们还将介绍如何使用 **RoutedCommands**
    在 WPF 应用程序中演示 **命令设计模式**，它可以从多个位置调用。
- en: Using binary resources inside a WPF application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中使用二进制资源
- en: '**Binary resources** are chunks of bytes added to a project with `Build Action`
    defined for it. Generally, these are images, logos, fonts, files, and so on, which
    are required by the application and are bundled with it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制资源**是添加到项目中并为其定义了 `Build Action` 的字节数据块。通常，这些是应用程序所需的图像、徽标、字体、文件等，它们与应用程序捆绑在一起。'
- en: In this recipe, we will learn how to use binary resources in a WPF application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何在 WPF 应用程序中使用二进制资源。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, open your Visual Studio IDE and create a new project called
    `CH07.BinaryResourceDemo`. Make sure you select the WPF app as the project template.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开您的 Visual Studio IDE 并创建一个名为 `CH07.BinaryResourceDemo` 的新项目。确保您选择 WPF
    应用作为项目模板。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to add images as binary resources inside a WPF application
    and load them into the application window:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤将图像作为二进制资源添加到 WPF 应用程序中，并将它们加载到应用程序窗口中：
- en: 'Right-click on the project to add a new folder. Follow the context menu path
    Add | New Folder. Rename the newly created folder as `Images`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目以添加一个新文件夹。按照上下文菜单路径添加 | 新文件夹。将新创建的文件夹重命名为 `Images`：
- en: '![](img/44e88c7a-c8c1-48b6-937f-30c1f87cff37.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44e88c7a-c8c1-48b6-937f-30c1f87cff37.png)'
- en: 'Now right-click on the Images folder to add a few images. From the context
    menu entry, select Add | Existing Item... and add two images of your choice. In
    this example, we have added two existing images, `image1.png` and `image2.png`,
    for demonstration:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击 Images 文件夹以添加一些图像。从上下文菜单条目中选择添加 | 已存在项... 并添加您选择的两个图像。在这个例子中，我们添加了两个现有图像，`image1.png`
    和 `image2.png`，以供演示：
- en: '![](img/b4680435-a8c0-4974-bd50-7bbe6225cd56.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4680435-a8c0-4974-bd50-7bbe6225cd56.png)'
- en: From the Solution Explorer, right-click on the `image1.png` and go to its Properties.
    Set the Build Action of the image to Resource, which is the default:![](img/036e79bb-4c39-4c89-b047-a31b46c3ed42.png)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，右键单击 `image1.png` 并转到其属性。将图像的构建操作设置为资源，这是默认设置：![](img/036e79bb-4c39-4c89-b047-a31b46c3ed42.png)
- en: Now right-click on the `image2.png` from Solution Explorer, and go to its Properties.
    Set its Build Action to Content.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从解决方案资源管理器中右键单击 `image2.png`，并转到其属性。将其构建操作设置为内容。
- en: Change the Copy to Output Directory to Copy Always:![](img/07e35f07-20d2-488a-8b3e-6b341e52228a.png)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“复制到输出目录”更改为“始终复制”：![](img/07e35f07-20d2-488a-8b3e-6b341e52228a.png)
- en: From the Solution Explorer, open the `MainWindow.xaml` and replace the `Grid`
    with a horizontal `StackPanel`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中打开`MainWindow.xaml`，并将`Grid`替换为水平`StackPanel`。
- en: 'Now insert the two images inside the `StackPanel`, and set their `Source` property
    to `Images/image1.png` and `Images/image2.png`, respectively:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将两个图像插入`StackPanel`中，并将它们的`Source`属性分别设置为`Images/image1.png`和`Images/image2.png`：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build the project and run the application. You will see the following UI on
    the screen:![](img/002cfccd-a915-4aab-935b-d56a35475d18.png)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并运行应用程序。你将在屏幕上看到以下UI：![图片](img/002cfccd-a915-4aab-935b-d56a35475d18.png)
- en: Now go to the project's bin | Debug directory. You will see a folder named Images
    containing the image (`image2.png`) that we defined as `Build Action = Content`
    and `Copy to Output Directory = Copy Always`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到项目的bin | Debug目录。你会看到一个名为Images的文件夹，其中包含我们定义为`Build Action = Content`和`Copy
    to Output Directory = Copy Always`的图像（`image2.png`）。
- en: Now replace the `image2.png` with a different image.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`image2.png`替换为不同的图像。
- en: Run the application now, directly from the bin | Debug folder, instead of recompiling
    the project. Observe the output on the screen. You will see that the second image
    now points to the new image that we have placed in the bin | Debug | Images folder:![](img/a7c3afee-7d81-4e26-9481-788a577e7765.png)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在直接从bin | Debug文件夹中运行应用程序，而不是重新编译项目。观察屏幕上的输出。你会看到第二个图像现在指向我们放置在bin | Debug
    | Images文件夹中的新图像：![图片](img/a7c3afee-7d81-4e26-9481-788a577e7765.png)
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the `Build Action` is set to `Resource`, the file is stored as a resource
    inside the compiled assembly. In our case, `image1.png` was set to `Resource`
    inside the project binary, which makes the actual image file unnecessary while
    deploying the application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Build Action`设置为`Resource`时，文件作为资源存储在编译的程序集中。在我们的例子中，`image1.png`在项目二进制文件中被设置为`Resource`，这使得在部署应用程序时实际的图像文件变得不必要。
- en: When the `Build Action` is set to `Content`, the resource is not included in
    the assembly. To make it available to the application, `Copy to Output Directory`
    needs to be set to either `Copy Always` or `Copy if Newer`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Build Action`设置为`Content`时，资源不会被包含在程序集内。为了使其对应用程序可用，需要将`Copy to Output Directory`设置为`Copy
    Always`或`Copy if Newer`。
- en: This makes it more appropriate for when the resource needs to change often and
    a rebuild would be undesirable. If the resource is not available in the output
    directory, this will render a blank image while executing. If the resource is
    large and not always needed, it's better to leave it to the resulting assembly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得当资源需要经常更改且不希望重新构建时更为合适。如果资源在输出目录中不可用，在执行时将渲染一个空白图像。如果资源较大且不是总是需要的，最好将其留给生成的程序集。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While inserting the image in the XAML, we often use the relative URI (`Images/image1.png`,
    in our case) as it is relative to the application. You can also assign it more
    verbosely as `pack://application:,,,/Images/image1.png`, which is generally used
    while assigning the image source from the code behind.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入图像到XAML时，我们通常使用相对URI（在我们的例子中是`Images/image1.png`），因为它相对于应用程序。你也可以更详细地将其指定为`pack://application:,,,/Images/image1.png`，这通常用于从代码后端分配图像源。
- en: 'You can also use the Visual Studio editor to assign the image source. To do
    so, right-click on the image from the XAML designer view and go to its Properties.
    From the Properties panel, click the dropdown arrow, as shown in the following
    screenshot, to select the desired image from the available items in the list:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用Visual Studio编辑器来指定图像源。为此，在XAML设计视图中的图像上右键单击，并转到其属性。从属性面板中，点击下拉箭头，如以下截图所示，从列表中选择所需的图像：
- en: '![](img/068c8aa0-cf52-49d8-8e07-fad215f2a18a.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/068c8aa0-cf52-49d8-8e07-fad215f2a18a.png)'
- en: Using binary resources from another assembly
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用来自另一个程序集的二进制资源
- en: It is not mandatory to have the resources defined in the same assembly where
    they are going to be used. Sometime, on an as-needed basis, the binary resources
    are defined in one assembly (generally, a class library), and used in another
    assembly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不必在将使用资源的同一程序集中定义资源。有时，根据需要，二进制资源在一个程序集（通常是一个类库）中定义，并在另一个程序集中使用。
- en: WPF provides a uniform way of accessing these resources defined in other assemblies.
    To work with this, we need to use the pack URI scheme. In this recipe, we will
    learn how to use binary resources from another assembly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: WPF提供了一种统一的方式来访问在其他程序集中定义的资源。为了使用它，我们需要使用pack URI方案。在本教程中，我们将学习如何使用来自另一个程序集的二进制资源。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's begin with creating a new project called `CH07.RemoteBinaryResourceDemo`.
    Make sure you select the WPF app template while creating this project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `CH07.RemoteBinaryResourceDemo` 的新项目开始。确保在创建此项目时选择 WPF 应用程序模板。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create a class library to define the binary resource
    and use it from the application that we have already created:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个类库来定义二进制资源，并从我们已创建的应用程序中使用它：
- en: 'Create another project within the same solution. Let''s name it `CH07.ResourceLibrary`,
    and make sure you select Class Library (.NET Framework) as the project template:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一解决方案中创建另一个项目。让我们将其命名为 `CH07.ResourceLibrary`，并确保您选择类库 (.NET Framework) 作为项目模板：
- en: '![](img/dcd734ec-5fcb-4e7a-8a24-5c8f0515d404.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcd734ec-5fcb-4e7a-8a24-5c8f0515d404.png)'
- en: Remove the autogenerated class file `Class1.cs`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除自动生成的类文件 `Class1.cs`。
- en: Now right-click on the project `CH07.ResourceLibrary` and create a new folder
    named `Images`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在右键单击项目 `CH07.ResourceLibrary` 并创建一个名为 `Images` 的新文件夹。
- en: Now right-click on the newly created folder and add an existing image (`image1.png`,
    in our case) into that folder.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在右键单击新创建的文件夹，并将现有的图像（在我们的情况下是 `image1.png`）添加到该文件夹中。
- en: Then right-click on the image (`image1.png`) and navigate to its Properties
    pane.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后右键单击图像（`image1.png`）并导航到其属性窗格。
- en: As demonstrated in the previous recipe, change its Build Action to `Resource`.
    Compile the project `CH07.ResourceLibrary` to make sure that the build is successful.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前一个示例所示，将其构建操作更改为 `Resource`。编译项目 `CH07.ResourceLibrary` 以确保构建成功。
- en: From the Solution Explorer, right-click on the other project named `CH07.RemoteBinaryResourceDemo`
    and navigate through the context menu entry Add | Reference... to add the assembly
    reference of the class library in this project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，右键单击名为 `CH07.RemoteBinaryResourceDemo` 的其他项目，并通过上下文菜单中的“添加 | 引用...”选项添加此项目中类库的引用。
- en: 'From the Reference Manager dialog window, navigate to Projects and select the
    class library (CH07.ResourceLibrary) that we created. As shown in the following
    screenshot, click OK once you are done. This will add our class library as a reference
    to our application project:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从引用管理器对话框窗口中，导航到项目并选择我们创建的类库（CH07.ResourceLibrary）。如图所示，完成后点击确定。这将把我们的类库添加到应用程序项目中：
- en: '![](img/284ff79f-6ca0-4479-84c7-cf1bd16b8292.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/284ff79f-6ca0-4479-84c7-cf1bd16b8292.png)'
- en: 'Now, from the Solution Explorer, navigate to the `MainWindow.xaml` file of
    the `CH07.RemoteBinaryResourceDemo` project and add the following image inside
    the `Grid`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从解决方案资源管理器中，导航到 `CH07.RemoteBinaryResourceDemo` 项目的 `MainWindow.xaml` 文件，并在
    `Grid` 中添加以下图像：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s compile the solution and run the application. You will see that the
    application window launches with an image, which is present in a different assembly.
    Here''s a screenshot, based on our demo application:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译解决方案并运行应用程序。您将看到应用程序窗口启动时带有一个图像，该图像位于不同的程序集。以下是基于我们的演示应用程序的截图：
- en: '![](img/9ec1e76a-333b-4b46-96d0-1d6a2e5d6be4.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ec1e76a-333b-4b46-96d0-1d6a2e5d6be4.png)'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you are using a referenced assembly, the WPF pack URI recognizes it as
    `/AssemblyReference;component/ResourceName` format. In the preceding example,
    the **AssemblyReference** is the name of the assembly, which is `CH07.ResourceLibrary`
    in our case, and the **ResourceName** is the complete path of the resource relative
    to the project component.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用引用的程序集时，WPF 打包 URI 会将其识别为 `/AssemblyReference;component/ResourceName` 格式。在上面的示例中，**AssemblyReference**
    是程序集的名称，在我们的情况下是 `CH07.ResourceLibrary`，而 **ResourceName** 是相对于项目组件的资源完整路径。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'An `AssemblyReference` may also include a version and/or the public key token
    (in case the assembly is strongly named). The version is denoted by prefixing
    it with a `v,` as shown in the following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssemblyReference` 还可能包括版本和/或公钥标记（如果程序集是强命名的）。版本通过在其前缀为 `v,` 来表示，如下面的示例所示：'
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This does not work with resources marked with `Build Action` as `Content`.
    To work with this, we need to use the full pack URI with a `siteOfOrigin` base,
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这不适用于标记为 `Build Action` 为 `Content` 的资源。要使用它，我们需要使用带有 `siteOfOrigin` 基的完整打包
    URI，如下所示：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Please note that the Visual Studio Designer window will fail to load the image
    when `siteOfOrigin` is used, but this will work fine in runtime.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用 `siteOfOrigin` 时，Visual Studio 设计器窗口将无法加载图像，但在运行时这将正常工作。
- en: Accessing binary resources in code
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中访问二进制资源
- en: Accessing binary resources in XAML is very simple, but there is an option to
    read a binary resource from the code behind. In this recipe, we will learn how
    to read a binary resource in code and set it in the UI. We will be using an image
    as an example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XAML 中访问二进制资源非常简单，但有一个选项可以从代码背后读取二进制资源。在这个菜谱中，我们将学习如何在代码中读取二进制资源并将其设置在 UI
    中。我们将使用图像作为示例。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Visual Studio IDE. Let's begin with creating a new WPF project called
    `CH07.BinaryResourceFromCodeDemo`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 Visual Studio IDE。让我们从创建一个名为 `CH07.BinaryResourceFromCodeDemo` 的新 WPF 项目开始。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to read an image file, embedded as a `Resource`, and display
    it in the UI:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤读取图像文件，将其嵌入为 `Resource` 并在 UI 中显示：
- en: First, create a folder named `Images` inside the project and add an image inside
    it. Let's name the image `image1.png`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在项目中创建一个名为 `Images` 的文件夹，并在其中添加一个图像。让我们将其命名为 `image1.png`。
- en: Open the `MainWindow.xaml` file by navigating to Solution Explorer.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到解决方案资源管理器打开 `MainWindow.xaml` 文件。
- en: 'Add an image tag inside the `Grid` panel and name it `img`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Grid` 面板内添加一个图像标签并命名为 `img`：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Go to the `MainWindow.xaml.cs` file and, inside the constructor of the class,
    just after the `InitializeComponent()` call, create the `streamResourceInfo` from
    the resource stream of the image. Here''s the code to get the stream info:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml.cs` 文件，并在类的构造函数中，在 `InitializeComponent()` 调用之后，从图像的资源流中创建
    `streamResourceInfo`。以下是获取流信息的代码：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we need to create the instance of `BitmapImage` from that stream. Copy
    the following content and pass the `streamResourceInfo.Stream` to the `StreamSource`
    property of the `BitmapImage`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要从该流创建 `BitmapImage` 的实例。复制以下内容并将 `streamResourceInfo.Stream` 传递给 `BitmapImage`
    的 `StreamSource` 属性：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now set the `bitmapImage` instance to the `Source` property of the image::'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将 `bitmapImage` 实例设置为图像的 `Source` 属性：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the complete code for accessing the stream and assigning it to the
    image source:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是访问流并将其分配给图像源的完整代码：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once done, build the project and run it. You will see that the assigned image
    is loaded into the application window:![](img/ce158173-a1ee-4262-8b93-569ad106ac6f.png)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，构建项目并运行它。你会看到分配的图像已加载到应用程序窗口中：![图片](img/ce158173-a1ee-4262-8b93-569ad106ac6f.png)
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The static method `Application.GetResourceStream` provides an easy way of accessing
    a resource using its relative URI. It returns a `StreamResourceInfo` object. The
    `Stream` property of the `StreamResourceInfo` object provides access to the actual
    binary data, which has been set as the image source property by converting it
    to an instance of `BitmapImage`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法 `Application.GetResourceStream` 提供了一种使用其相对 URI 访问资源的方法，它返回一个 `StreamResourceInfo`
    对象。`StreamResourceInfo` 对象的 `Stream` 属性提供了对实际二进制数据的访问，这些数据已被转换为 `BitmapImage`
    实例，并设置为图像源属性。
- en: For the `Application.GetResourceStream` method to work, the resource must be
    marked as a `Resource` in `Build Action`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `Application.GetResourceStream` 方法正常工作，资源必须在 `Build Action` 中标记为 `Resource`。
- en: If the resource has been marked as `Content` in the `Build Action` property,
    then the `Application.GetContentStream` method should be used to get the resource
    stream.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源已在 `Build Action` 属性中标记为 `Content`，则应使用 `Application.GetContentStream` 方法来获取资源流。
- en: Using static logical resources in WPF
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 WPF 中使用静态逻辑资源
- en: Logical resources in WPF are the objects that can be shared and reused across
    some part of a Visual Tree or an entire application. These can be colors, brushes,
    geometrics, styles, or any other .NET objects (`int`, `string`, `List<T>`, `T`,
    and more) defined by the .NET Framework or developer. These objects are typically
    placed inside a `ResourceDictionary`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: WPF中的逻辑资源是可以跨 Visual Tree 的某个部分或整个应用程序共享和重用的对象。这些可以是颜色、画笔、几何图形、样式或任何其他由 .NET
    框架或开发者定义的 .NET 对象（`int`、`string`、`List<T>`、`T` 等）。这些对象通常放置在 `ResourceDictionary`
    中。
- en: In this recipe, we will learn how to use logical resources using the binding
    key `StaticResource`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用绑定键 `StaticResource` 来使用逻辑资源。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that Visual Studio is running. Create a project called `CH07.StaticResourceDemo`,
    based on the WPF application template.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Visual Studio正在运行。基于WPF应用程序模板创建一个名为 `CH07.StaticResourceDemo` 的项目。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create a logical resource and use it inside the application
    window:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建逻辑资源并在应用程序窗口中使用它：
- en: Open the `MainWindow.xaml` file and replace the `Grid` with a horizontal `StackPanel`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件并将 `Grid` 替换为一个水平的 `StackPanel`。
- en: 'Insert a `Border` control inside the `StackPanel`. Set its `Height` and `Width`
    properties to `80` and `150,` respectively:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StackPanel`内部插入一个`Border`控件。将其`Height`和`Width`属性分别设置为`80`和`150`：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s add a background color to the `Border` control. We will be using a linear
    gradient brush to decorate the background color. Let''s modify it as shared here:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Border`控件中添加一个背景颜色。我们将使用线性渐变画笔来装饰背景颜色。让我们按照以下方式修改它：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Copy the same border with the preceding background and paste it inside the same
    panel. Now the `StackPanel` will have two border controls with the same properties.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与上一背景相同的边框复制并粘贴到同一面板内部。现在`StackPanel`将具有两个具有相同属性的边框控件。
- en: Let's build the project and run it. You will see two rectangular shapes with
    a nice gradient color as the background:![](img/916b85ed-1009-4414-acf1-c7ecaae40aa3.png)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建项目并运行它。你会看到两个带有漂亮的渐变颜色的矩形形状作为背景：![图片](img/916b85ed-1009-4414-acf1-c7ecaae40aa3.png)
- en: 'As you can see, we have added the same background brush twice to represent
    the color; it''s sometimes difficult to manage, and unnecessarily increases the
    XAML code as well as the complexity. To resolve this, we can now move the brush
    object as a logical resource, and access it within the same window or throughout
    the application. Let''s move it to the window level. Insert the `LinearGradientBrush`
    inside the window resource (`Window.Resources`) and assign a key (`myLinearBrush`)
    to it:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们添加了相同的背景画笔两次来表示颜色；有时这很难管理，并且不必要地增加了XAML代码以及复杂性。为了解决这个问题，我们现在可以将画笔对象作为逻辑资源移动，并在同一窗口或整个应用程序中访问它。让我们将其移动到窗口级别。在窗口资源（`Window.Resources`）内插入`LinearGradientBrush`并为其分配一个键（`myLinearBrush`）：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now remove the background definition in both the controls and replace it with
    a binding to the previously mentioned brush. As it is defined within the resource,
    we will be using `{StaticResource}` to access it. Here''s the modified version
    of the border controls inside the panel:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从两个控件中移除背景定义，并用之前提到的画笔的绑定替换它。由于它是在资源中定义的，我们将使用`{StaticResource}`来访问它。以下是面板内边框控件的修改版本：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's run the application once again. You will see the same background applied
    to the rectangular shaped border controls. In this case, we have used just one
    definition of the brush.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行应用程序。你会看到相同的背景应用于矩形形状的边框控件。在这种情况下，我们只使用了一个画笔的定义。
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Every UI element derived from the `FrameworkElement` has a property called `Resources`,
    which is of type `ResourceDictionary`. Thus, every element can have resources
    associated with it. In XAML, we need to define the `x:Key` attribute to the resource
    to access it, either from the XAML or from the code-behind file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个从`FrameworkElement`派生的UI元素都有一个名为`Resources`的属性，其类型为`ResourceDictionary`。因此，每个元素都可以与其相关联资源。在XAML中，我们需要定义`x:Key`属性来访问资源，无论是从XAML还是从代码隐藏文件中。
- en: 'In our example, we defined `myLinearBrush` as an element of the `ResourceCollection`
    of the `Window`. Thus, it will be accessible by any control within the same window.
    If you move the definition inside the `StackPanel`, it will be accessible within
    that panel:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将`myLinearBrush`定义为`Window`的`ResourceCollection`的元素。因此，它将可以被同一窗口内的任何控件访问。如果你将定义移到`StackPanel`内部，它将可以在该面板内访问：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To use this resource in XAML, we need to use the markup extension, `{StaticResource}`,
    along with the resource key provided, `Background="{StaticResource myLinearBrush}"`,
    which will create the binding between them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在XAML中使用此资源，我们需要使用标记扩展，`{StaticResource}`，以及提供的资源键，`Background="{StaticResource
    myLinearBrush}"`，这将在这两者之间创建绑定。
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is possible to manage the logical resources from the code behind. You can
    call the `FindResource` method, passing the resource key to it, to get the instance
    of the resource. Here''s how you can find the resource named `myLinearBrush`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码隐藏文件中管理逻辑资源是可能的。你可以调用`FindResource`方法，并传递资源键给它，以获取资源的实例。以下是如何查找名为`myLinearBrush`的资源的方法：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also programmatically add or remove a resource to the collection. Call
    the methods `Resources.Add` and `Resources.Remove` to add or remove a specific
    resource, as shown in the following code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过编程方式向集合中添加或删除资源。调用`Resources.Add`和`Resources.Remove`方法来添加或删除特定资源，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As the `Resources` property is basically a `Dictionary` object, make sure you
    check whether the specified key is already present before doing any operation,
    such as `Add`/`Remove`, on it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Resources`属性基本上是一个`Dictionary`对象，确保在执行任何操作之前，例如`Add`/`Remove`，检查指定的键是否已经存在。
- en: Using dynamic logical resources in WPF
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WPF中使用动态逻辑资源
- en: In the previous recipe, we learned how to use logical resources using the `StaticResource`
    markup extension. In this recipe, we will learn how to use logical resources using
    the `DynamicResource` markup extension and will also learn the difference between
    them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们学习了如何使用`StaticResource`标记扩展使用逻辑资源。在本菜谱中，我们将学习如何使用`DynamicResource`标记扩展，并了解它们之间的区别。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Get started by creating a new project. Open the Visual Studio IDE and create
    a new WPF application project called `CH07.DynamicResourceDemo`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个新的项目开始。打开Visual Studio IDE并创建一个名为`CH07.DynamicResourceDemo`的新WPF应用程序项目。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to use logical resources dynamically and modify the values
    of the resource as per the need:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用逻辑资源动态修改资源值：
- en: Open the `MainWindow.xaml` file and replace the `Grid` with a `StackPanel`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`文件并将`Grid`替换为`StackPanel`。
- en: Add a border inside the `StackPanel` and set its dimensions.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StackPanel`内部添加一个边框并设置其尺寸。
- en: 'Add another `StackPanel` inside the panel and add a group of three radio buttons
    inside it. Label them as `Red`, `Green`, and `Blue`. Here''s the complete XAML
    code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板内部添加另一个`StackPanel`并在其中添加一组三个单选按钮。将它们标记为`Red`、`Green`和`Blue`。以下是完整的XAML代码：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now add a `LinearGradientBrush` to the window resources and set its key name
    as `myLinearBrush`. Add some `GradientStop` to define a nice gradient brush, as
    follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向窗口资源添加一个`LinearGradientBrush`并将其键名设置为`myLinearBrush`。添加一些`GradientStop`来定义一个漂亮的渐变画笔，如下所示：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It''s time to bind the defined brush with the `Border` control. Modify the
    XAML to have a `StaticResource` binding between them, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候将定义的画笔绑定到`Border`控件上了。修改XAML以在它们之间创建一个`StaticResource`绑定，如下所示：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Register `Checked` events for all three radio buttons, so that we can perform
    some changes on the checked status change:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有三个单选按钮注册`Checked`事件，这样我们就可以在状态改变时执行一些更改：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Navigate to the `MainWindow.xaml.cs` and add the following implementation for
    all the radio buttons'' `Checked` event:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`MainWindow.xaml.cs`并为所有单选按钮的`Checked`事件添加以下实现：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once this has been done, run the application. You will see a rectangle with
    three radio buttons. By default, the Green radio button will be selected. Change
    the selection to Red or Blue to observe the behavior. You will see that the color
    always stays Green, irrespective of the selection:![](img/4e984e14-d3fd-42d0-84d5-fa27cd5c0407.png)
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成这些操作，运行应用程序。你会看到一个带有三个单选按钮的矩形。默认情况下，绿色单选按钮将被选中。将选择更改为红色或蓝色以观察行为。你会看到颜色始终为绿色，无论选择如何！![图片](img/4e984e14-d3fd-42d0-84d5-fa27cd5c0407.png)
- en: Let's close the application and navigate back to `MainWindow.xaml`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们关闭应用程序并导航回`MainWindow.xaml`。
- en: 'Change the `StaticResource` to `DynamicResource`, as shared in the following
    code snippet:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`StaticResource`更改为`DynamicResource`，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, run the application once again. By default, Green will be selected, and
    the rectangle will have a green gradient background. Change the selection to Red
    or Blue to observe the color change:![](img/f3ebf49a-5140-49cb-a303-c0c53eed5d14.png)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行应用程序。默认情况下，绿色将被选中，矩形将具有绿色渐变背景。将选择更改为红色或蓝色以观察颜色变化！![图片](img/f3ebf49a-5140-49cb-a303-c0c53eed5d14.png)
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you bind the logical resource as a `StaticResource`, it causes the binding
    to occur at construction time. On the other hand, the `DynamicResource` markup
    extension binds to a resource dynamically, only when it is needed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将逻辑资源作为`StaticResource`绑定时，它会在构造时触发绑定。另一方面，`DynamicResource`标记扩展仅在需要时动态绑定资源。
- en: In the preceding example, when we registered the resource to the `Background`
    property of the `Border` control as a `StaticResource`, we were not able to see
    the change reflected in the UI, even though we replaced the resource with a new
    object on selection of the radio button. But when we changed the binding to `DynamicResource`,
    the change was automatically reflected. This is because the dynamic resource binding
    refreshes itself if the object changes. But this is not same with the static resource
    binding, as it always keeps referencing the old object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当我们将资源注册到`Border`控制的`Background`属性作为`StaticResource`时，即使我们在选择单选按钮时用新对象替换了资源，我们也没有在UI中看到变化。但是当我们将绑定更改为`DynamicResource`时，变化会自动反映出来。这是因为动态资源绑定会在对象更改时自动刷新。但是这与静态资源绑定不同，因为它始终引用旧对象。
- en: There's more...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `StaticResource` binding throws an error at design time if the object specified
    by the `x:Key` is not present. On the other hand, `DynamicResource` does not throw
    any exception, and displays as blank. Later, when it finds the `Key`, it binds
    itself with that resource.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定的`x:Key`对象不存在时，`StaticResource`绑定会在设计时抛出错误。另一方面，`DynamicResource`不会抛出任何异常，并且会显示为空白。稍后，当它找到`Key`时，它会将自己与该资源绑定。
- en: '`StaticResource` should be used most of the time, unless there is a need to
    replace resources dynamically. `DynamicResource` should be used by the themes
    that can easily swap the resources.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在大多数情况下使用`StaticResource`，除非需要动态替换资源。`DynamicResource`应该由可以轻松交换资源的主题使用。
- en: Having a large collection of `DynamicResource` on a complex UI can impact the
    performance of the UI. Wherever possible, mark them as `StaticResource`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的UI上拥有大量的`DynamicResource`可能会影响UI的性能。 wherever possible，将它们标记为`StaticResource`。
- en: Managing logical resources
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理逻辑资源
- en: There could be several types of logical resources in a single application, and
    placing them inside a single XAML file (for example, `App.xaml`) will increase
    problems while maintaining them. To resolve this problem, you can separate the
    resources of different types into their own respective files and reference them
    in `App.xaml`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 单个应用程序中可能存在多种类型的逻辑资源，将它们放置在单个XAML文件（例如，`App.xaml`）中在维护时会增加问题。为了解决这个问题，你可以将不同类型的资源分别放入它们各自的文件中，并在`App.xaml`中引用它们。
- en: In this recipe, we will learn how to manage these logical resources with a simple
    example. Though this will be shown with a single file, you can create separate
    files and reference them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过一个简单的示例学习如何管理这些逻辑资源。虽然这将是通过单个文件展示的，但你也可以创建单独的文件并引用它们。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Assuming that you have opened Visual Studio, now create a new WPF application
    project called `CH07.ManagingLogicalResourceDemo`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经打开了Visual Studio，现在创建一个名为`CH07.ManagingLogicalResourceDemo`的新WPF应用程序项目。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these simple steps to create separate resource files and reference them
    in the application:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤创建单独的资源文件并在应用程序中引用它们：
- en: As we want to create a separate resource file, we need to create a file of type
    Resource Dictionary. Inside the Solution Explorer, right-click on the project
    node and create a new folder named `Themes`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想要创建一个单独的资源文件，我们需要创建一个类型为资源字典的文件。在解决方案资源管理器中，右键单击项目节点并创建一个名为`Themes`的新文件夹。
- en: 'Now right-click on the Themes folder and select Add | Resource Dictionary...
    from the context menu entry:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在右键单击“主题”文件夹，并从上下文菜单中选择添加 | 资源字典...：
- en: '![](img/037c287d-47ec-417c-aa89-582f890f6b31.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/037c287d-47ec-417c-aa89-582f890f6b31.png)'
- en: 'In the Add New Item dialog, make sure that the Resource Dictionary (WPF) template
    is selected. Name it `Brushes.xaml`, and click Add:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“添加新项”对话框中，确保选择了资源字典（WPF）模板。将其命名为`Brushes.xaml`，然后点击添加：
- en: '![](img/1e7d9177-bfbb-436f-b2f3-1b5a3a29d9e5.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e7d9177-bfbb-436f-b2f3-1b5a3a29d9e5.png)'
- en: 'From the Solution Explorer, open the newly created file `Brushes.xaml` and
    add the following `LinearGradientBrush` inside the `ResourceDictionary` element
    with a `x:Key` name of `myLinearBrush`. You can add multiple elements inside the
    `ResourceDictionary` to have a resource collection. Make sure you assign a unique
    key name to each one of them:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器打开新创建的文件`Brushes.xaml`，并在`ResourceDictionary`元素内添加以下具有`x:Key`名为`myLinearBrush`的`LinearGradientBrush`。你可以在`ResourceDictionary`内添加多个元素以拥有资源集合。确保为每个元素分配一个唯一的键名：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Open the `MainWindow.xaml` and replace the `Grid` with the following markup
    to have a `Border` control inside it. Set the size of the element and bind the
    `Background` property with the `myLinearBrush` that we have created:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 并将 `Grid` 替换为以下标记，以便在内部有一个 `Border` 控件。设置元素的大小并将 `Background`
    属性绑定到我们创建的 `myLinearBrush`：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the application now, you won't see any elements inside the window,
    because the mapping of the file has not been created yet. As we have the binding
    as `DynamicResource`, you won't see any error.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你将看不到窗口内的任何元素，因为文件映射尚未创建。由于我们有 `DynamicResource` 绑定，你不会看到任何错误。
- en: Let's close the application and open the `App.xaml` file.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们关闭应用程序并打开 `App.xaml` 文件。
- en: 'Inside the `Application.Resources`, add an element named `ResourceDictionary`.
    Inside this, create another element named `ResourceDictionary.MergedDictionaries`
    and load the `ResourceDictionary` that we have created. Here''s how it will look:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Application.Resources` 内部添加一个名为 `ResourceDictionary` 的元素。在这个元素内部，创建另一个名为
    `ResourceDictionary.MergedDictionaries` 的元素，并加载我们创建的 `ResourceDictionary`。以下是它的样子：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now run the application once again. You will see a rectangular shaped border
    control in the application window with a nice gradient color, which we have created
    in the `Brushes.xaml` file. Here a screenshot of the application window:![](img/8f442a66-a199-4115-b9cc-f90493e3e3bb.png)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次运行应用程序。你将在应用程序窗口中看到一个矩形形状的边框控件，它具有我们创建在 `Brushes.xaml` 文件中的漂亮渐变颜色。以下是应用程序窗口的截图！![应用程序窗口截图](img/8f442a66-a199-4115-b9cc-f90493e3e3bb.png)
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A `ResourceDictionary` can load one or more resource dictionaries using its
    `MergedDictionaries` property (`ResourceDictionary.MergedDictionaries`), which
    is a collection. It''s not always mandatory to have a reference to other resource
    dictionaries, but it can also have its own resources as well:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceDictionary` 可以使用其 `MergedDictionaries` 属性（`ResourceDictionary.MergedDictionaries`）加载一个或多个资源字典，它是一个集合。不一定需要引用其他资源字典，但它也可以有自己的资源：'
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Source` property of the `ResourceDictionary` element must point to the
    location of the `ResourceDictionary`. If that location is within a subfolder,
    that subfolder must be included.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceDictionary` 元素的 `Source` 属性必须指向 `ResourceDictionary` 的位置。如果该位置在子文件夹中，则必须包含该子文件夹。'
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When there exist two or more resources with the same key name that originated
    from multiple merged dictionaries, it will not throw any error or exception. Instead,
    it will load the one from the Resource Dictionary that was added last in the element
    tree.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在两个或更多来自多个合并字典且具有相同键名的资源时，它不会抛出任何错误或异常。相反，它将加载元素树中最后添加的 `Resource Dictionary`
    中的资源。
- en: Using user selected colors and fonts
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用用户选择的颜色和字体
- en: Sometimes, it is useful to use the system theme in an application UI to have
    a synchronous flow of colors and fonts between the operating system and the application.
    In these cases, we can dynamically load those values and apply them to our UI
    elements. This is achievable by accessing some special resource keys within the
    `SystemColors` and `SystemFonts` classes. In this recipe, we will learn how to
    use them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在应用程序 UI 中使用系统主题是有用的，以便在操作系统和应用程序之间同步颜色和字体流。在这些情况下，我们可以动态加载这些值并将它们应用到我们的
    UI 元素上。这是通过访问 `SystemColors` 和 `SystemFonts` 类中的某些特殊资源键来实现的。在本教程中，我们将学习如何使用它们。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's get started by creating a new project called `CH07.SystemResourcesDemo`.
    Make sure you select the WPF application template from the available list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `CH07.SystemResourcesDemo` 的新项目开始。确保从可用列表中选择 WPF 应用程序模板。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will now build an application that uses system colors and fonts. Follow
    these steps to proceed with it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将构建一个使用系统颜色和字体的应用程序。按照以下步骤进行：
- en: 'Open the `MainWindow.xaml` file and insert the following `Rectangle` inside
    the `Grid` panel:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件，并在 `Grid` 面板内插入以下 `Rectangle`：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We want to fill the rectangle with the color of the desktop brush. Add the
    following markup to fill the background color of the rectangle `Fill="{DynamicResource
    {x:Static SystemColors.DesktopBrushKey}}"`. Now the XAML will look like the following:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望用桌面刷的颜色填充矩形。添加以下标记来填充矩形的背景颜色 `Fill="{DynamicResource {x:Static SystemColors.DesktopBrushKey}}"`。现在
    XAML 将看起来如下所示：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's run the application now. You will see that a background color for the
    rectangle has been picked up by the application. This is based on the selection
    that you have for the `DesktopBrush` in your system:![](img/1340d9d6-0d62-44ab-94ee-d9d766cac3ad.png)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在运行应用程序。您将看到矩形已选择一个背景颜色。这是基于您在系统中为`DesktopBrush`选择的设置！![图片](img/1340d9d6-0d62-44ab-94ee-d9d766cac3ad.png)
- en: 'To confirm this, right-click on your desktop and select Personalize. If you
    are using Windows 10, you will see the Settings app navigates to the Background
    Settings page. Check the color that is selected in the Background settings and
    the color applied to your application. Both will be the same:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认这一点，右键单击您的桌面并选择个性化。如果您正在使用Windows 10，您将看到设置应用导航到背景设置页面。检查背景设置中选定的颜色以及应用到您应用程序的颜色。两者都将相同：
- en: '![](img/d2c2de3c-5b9f-4421-bf6e-86440924c026.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2c2de3c-5b9f-4421-bf6e-86440924c026.png)'
- en: 'Let''s select a different color from the Background Settings. You will see
    that the color will automatically get applied to your application:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从背景设置中选择不同的颜色。您将看到颜色将自动应用到您的应用程序上：
- en: '![](img/f1450077-c84c-42f0-9ecc-94214a3123c8.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1450077-c84c-42f0-9ecc-94214a3123c8.png)'
- en: Now select the + symbol (Custom color) to select another color of the default
    colors in the palette:![](img/b231a373-0eb6-49e8-ab1b-c9a2c42aa29a.png)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择加号符号（自定义颜色）以选择调色板中默认颜色的另一种颜色！![图片](img/b231a373-0eb6-49e8-ab1b-c9a2c42aa29a.png)
- en: As shown here, pick a custom background color for your desktop and click Done:![](img/1c5b0bbb-caea-4289-8540-c9765f2244fa.png)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如此所示，为您的桌面选择一个自定义背景颜色并点击完成！![图片](img/1c5b0bbb-caea-4289-8540-c9765f2244fa.png)
- en: Check the application window now. You will see that the color selected on the
    Settings app is applied to the rectangle background. Navigate to your desktop,
    the same color will be applied there too:![](img/c0237bf1-4e73-48d5-b5c6-a53605d94aac.png)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查应用程序窗口。您将看到在设置应用中选定的颜色已应用到矩形背景上。导航到您的桌面，同样的颜色也将应用到那里！![图片](img/c0237bf1-4e73-48d5-b5c6-a53605d94aac.png)
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'It is not mandatory to provide a `string` type key name to a resource binding.
    You can also provide a static object to the binding. In this example, we used
    the static value `SystemColors.DesktopBrushKey` in combination with the `{x:Static}`
    markup extension:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 向资源绑定提供一个`string`类型的键名不是强制的。您也可以向绑定提供一个静态对象。在这个例子中，我们使用了静态值`SystemColors.DesktopBrushKey`与`{x:Static}`标记扩展结合使用：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we have learned about the dynamic resource binding in the previous recipes,
    this example also follows the same method, and thus you can see the selected color
    is automatically applied to the rectangle.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们之前在菜谱中学到的动态资源绑定，这个例子也遵循了同样的方法，因此您可以看到选定的颜色已自动应用到矩形上。
- en: There are many static keys under the `SystemColors` class, which you can reference
    in your design. This is often useful when you want your application to be in sync
    with the operating system's theme.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SystemColors`类下有许多静态键，您可以在设计中引用它们。这通常在您希望应用程序与操作系统的主题保持同步时非常有用。
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Just like `SystemColors`, we have the `SystemFonts` class too, which exposes
    font related static properties. You can define `FontFamily`, `FontSize`, and `FontWeight`
    styles from the system palette, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`SystemColors`一样，我们还有`SystemFonts`类，它公开了与字体相关的静态属性。您可以从系统调色板定义`FontFamily`、`FontSize`和`FontWeight`样式，如下所示：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Building an application using the MVVM pattern
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MVVM模式构建应用程序
- en: '**MVVM** stands for **Model**, **View**, and **ViewModel**, which is a pattern
    that facilitates the separation between the **GUI** (**Graphical user interface**)
    from the business logic. It means that a designer and developer can work together,
    without any hassle.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVVM**代表**模型**、**视图**和**ViewModel**，这是一种促进将**GUI**（**图形用户界面**）与业务逻辑分离的模式。这意味着设计师和开发者可以一起工作，而不会遇到任何麻烦。'
- en: In this pattern, the model is the data that gets displayed in the view with
    the help of ViewModel. In this recipe, we will learn how to create an MVVM application,
    expose the properties from the ViewModel to the associated view, and display records
    without writing any code in the XAML code behind file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，模型是帮助通过ViewModel显示在视图中的数据。在这个菜谱中，我们将学习如何创建一个MVVM应用程序，将ViewModel中的属性公开给相关视图，并在XAML代码后文件中不编写任何代码的情况下显示记录。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's open the Visual Studio IDE and create a new project, called `CH07.MVVMDemo`,
    based on the WPF app template.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开Visual Studio IDE并创建一个新的项目，命名为`CH07.MVVMDemo`，基于WPF应用程序模板。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once the project has been created, follow these steps to construct the project
    for the MVVM standard (not mandatory) and build a sample demo using the MVVM pattern:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，按照以下步骤构建符合MVVM标准的项目（非强制），并使用MVVM模式构建一个示例演示：
- en: Each WPF app project has a `MainWindow.xaml`. From the Solution Explorer, let's
    delete the default file.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个WPF应用程序项目都有一个`MainWindow.xaml`。从解决方案资源管理器中，让我们删除默认文件。
- en: Inside the project, create three folders named `Models`, `Views`, and `ViewModels`.
    This is just to create a proper structure for all our code files.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中创建三个名为`Models`、`Views`和`ViewModels`的文件夹。这只是为了创建所有代码文件的正确结构。
- en: Now right-click on the Views folder, create a new `Window` by following the
    context menu path Add | Window..., and name it `MainWindow.xaml`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击`Views`文件夹，通过上下文菜单路径添加 | 窗口...创建一个新的`Window`，并将其命名为`MainWindow.xaml`。
- en: 'Open the `App.xaml` file and modify the `StartupUri` to point to the correct
    file. As shown in the following screenshot, change the `StartupUri` to `ViewsMainWindow.xaml`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.xaml`文件并修改`StartupUri`以指向正确的文件。如图所示，将`StartupUri`更改为`ViewsMainWindow.xaml`：
- en: '![](img/dcefda1d-53a9-4c40-858f-705bf90bf401.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcefda1d-53a9-4c40-858f-705bf90bf401.png)'
- en: Open the `MainWindow.xaml` file from the Views folder and replace the `Grid`
    with a `DockPanel`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`文件并替换`Grid`为`DockPanel`。
- en: 'Add two `StackPanel` inside the `Dock` and design the UI, as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Dock`内部添加两个`StackPanel`并设计UI，如下所示：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you run the application now, you will see the application window looks like
    this:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你会看到应用程序窗口看起来像这样：
- en: '![](img/1f16a9cb-657c-4b98-afef-8ae15e437a8d.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f16a9cb-657c-4b98-afef-8ae15e437a8d.png)'
- en: 'Now, right-click on the Models folder and create a class file named `UserModel.cs`
    and modify the class to have two properties of type `string`. As shown here, name
    them `Firstname` and `Lastname`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，右键单击`Models`文件夹并创建一个名为`UserModel.cs`的类文件，并将类修改为具有两个类型为`string`的属性。如图所示，将它们命名为`Firstname`和`Lastname`：
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Right-click on the ViewModels folder and add another class file. Name it `MainWindowViewModel.cs`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`ViewModels`文件夹并添加另一个类文件。将其命名为`MainWindowViewModel.cs`。
- en: 'Open the `MainWindowViewModel.cs` file and add the following namespaces inside
    it:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindowViewModel.cs`文件并在其中添加以下命名空间：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now inherit the `MainWindowViewModel` class from `INotifyPropertyChanged` interface,
    which is present under the `System.ComponentModel` namespace.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`System.ComponentModel`命名空间下的`INotifyPropertyChanged`接口继承`MainWindowViewModel`类。
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we already know, the `INotifyPropertyChanged` interface exposes the `PropertyChanged`
    event handler; we need to register that inside the class. Copy the following code
    to implement the interface:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们所知，`INotifyPropertyChanged`接口公开了`PropertyChanged`事件处理程序；我们需要在类内部注册该处理程序。将以下代码复制以实现接口：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once this has been done, create two properties inside the `ViewModel`. Name
    one `SelectedUser`, which is of type `UserModel` and the other `UserCollection`,
    which is of type `ObservableCollection<UserModel>`. Make sure you call the `OnPropertyChanged(str)`
    method from both the setters, so that the value change can be automatically reported
    to the UI. Here are the properties that we are going to refer to in this demonstration:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，在`ViewModel`内部创建两个属性。一个命名为`SelectedUser`，类型为`UserModel`，另一个命名为`UserCollection`，类型为`ObservableCollection<UserModel>`。确保在两个设置器中调用`OnPropertyChanged(str)`方法，以便自动将值更改报告给UI。以下是我们在演示中将要引用的属性：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Inside the constructor of the ViewModel, initialize the `UserCollection` property
    with some dummy data:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ViewModel的构造函数中，使用一些示例数据初始化`UserCollection`属性：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As the `viewmodel` is ready, having all the properties that we need, let''s
    associate it with the view as its `DataContext`. You can do this either from the
    code behind or from the XAML itself. As our target is to keep the code behind
    as small as possible, let''s do it from the XAML. Open the `MainWindow.xaml` and
    add the following `XMLNS` entry to it, so that we can access the `viewmodel` that
    we have created:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`viewmodel`准备就绪，拥有我们需要的所有属性时，让我们将其与视图关联起来作为其`DataContext`。你可以从代码后端或从XAML本身进行此操作。由于我们的目标是使代码后端尽可能小，让我们从XAML开始。打开`MainWindow.xaml`并添加以下`XMLNS`条目，以便我们可以访问我们创建的`viewmodel`：
- en: 'Inside the `Window.Resources` tag, add our `viewmodel` as a resource and define
    it as `x:Key="ViewModel"`, as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Window.Resources`标签内，将我们的`viewmodel`作为资源添加，并定义为`x:Key="ViewModel"`，如下所示：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As the `viewmodel` has been registered as a resource, set the `DataContext`
    of the `DockPanel` to the `ViewModel` that we defined. The binding needs to be
    done using the `{StaticResource}` markup extension. Here''s how it will look:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `viewmodel` 已注册为资源，将 `DockPanel` 的 `DataContext` 设置为我们定义的 `ViewModel`。绑定需要使用
    `{StaticResource}` 标记扩展来完成。以下是它的样子：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now set the `ItemsSource` and the `SelectedItem` properties of the `ListBox`
    control to have a data binding with the properties inside our `viewmodel`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将 `ListBox` 控件的 `ItemsSource` 和 `SelectedItem` 属性设置为与 `viewmodel` 内部的属性进行数据绑定。
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similarly, set the `DataContext` property of the `TextBlock` to `SelectedUser`
    and create the data binding, as shown, here to display the selected full name
    of the user:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，将 `TextBlock` 的 `DataContext` 属性设置为 `SelectedUser` 并创建数据绑定，如图所示，以显示选定的用户全名：
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's run this application now. You will see the following UI, where the values
    in `ListBox` control will be shown as the fully qualified name of the `model`
    class:![](img/2f10b6ca-598c-469a-9ad3-491b8969bb8a.png)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行这个应用程序。你将看到以下 UI，其中 `ListBox` 控件中的值将显示为 `model` 类的完全限定名称：![图片](img/2f10b6ca-598c-469a-9ad3-491b8969bb8a.png)
- en: 'To resolve this, we need to create the `DataTemplate` of the `ListBox`. Define
    the `ListBox.ItemTemplate` as follows, to have a `TextBlock` with the user''s
    full name, by concatenating the `Firstname` and `Lastname` properties:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要创建 `ListBox` 的 `DataTemplate`。将 `ListBox.ItemTemplate` 定义如下，以有一个包含用户全名的
    `TextBlock`，通过连接 `Firstname` 和 `Lastname` 属性：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once this has been done, the XAML code of the application UI will look similar
    to this:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，应用程序 UI 的 XAML 代码将类似于以下内容：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's run the application now. You will see the correct values inside the `ListBox`:![](img/b990e214-aec2-4fcd-85be-c5bad3a12a69.png)
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行应用程序。你将在 `ListBox` 中看到正确的值：![图片](img/b990e214-aec2-4fcd-85be-c5bad3a12a69.png)
- en: Select any of the `ListBox` items to see the selected username in the `TextBox`.
    Change the selection to update the UI automatically:![](img/2de2c792-f96b-4fa5-913c-4b58d219d4f8.png)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `ListBox` 中的任何项，以在 `TextBox` 中查看选定的用户名。更改选择以自动更新 UI：![图片](img/2de2c792-f96b-4fa5-913c-4b58d219d4f8.png)
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: MVVM consists of three important parts—**Model**, **View**, and the **ViewModel**.
    The *Model* represents the data; the *View* is the actual UI, which displays the
    relevant parts of the model; and the *ViewModel* is the mechanism that hands out
    the required data to the view. A ViewModel basically exposes properties and commands,
    and maintains the relevant state of the view.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 由三个重要部分组成——**Model**、**View** 和 **ViewModel**。*Model* 代表数据；*View* 是实际的
    UI，它显示模型的有关部分；*ViewModel* 是将所需数据分发给视图的机制。ViewModel 基本上公开属性和命令，并维护视图的相关状态。
- en: 'If we compare the MVVM pattern with a bike (as represented in the following
    screenshot), the bike **Body** is the **View**, the **Fuel** is the **Model**
    and the **Engine** of the bike is the **ViewModel**, which moves the View (bike
    body) by burning/using the Model (Fuel):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 MVVM 模式与自行车（如下面的截图所示）进行比较，自行车的 **Body** 是 **View**，**Fuel** 是 **Model**，自行车的
    **Engine** 是 **ViewModel**，它通过燃烧/使用模型（Fuel）来移动 View（自行车车身）：
- en: '![](img/733f6b5f-896f-4dab-8037-e6a8e5c9b146.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/733f6b5f-896f-4dab-8037-e6a8e5c9b146.png)'
- en: In our application, we used the `DataContext` to define the binding between
    the View and the ViewModel, which we then used to access the properties. If you
    now navigate to the `MainWindow.xaml.cs` file, you won't see any additional code
    except the constructor of the code-behind class.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们使用了 `DataContext` 来定义 View 和 ViewModel 之间的绑定，然后我们使用它来访问属性。如果你现在导航到
    `MainWindow.xaml.cs` 文件，你将看不到除了代码后置类的构造函数之外的其他代码。
- en: In the MVVM pattern, our intention is to keep the code-behind file (`MainWindow.xaml.cs`)
    code free (or less code), so that the direct binding between the UI and the code
    will be reduced. Note that the MVVM is not a framework, but in using this pattern
    you can create a framework. For example, the **MVVMLight** ([http://www.mvvmlight.net](http://www.mvvmlight.net))
    from **GalaSoft** provides a fully customized framework, which you can use in
    your application to keep the development hassle free.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVVM 模式下，我们的目的是保持代码后置文件（`MainWindow.xaml.cs`）的代码尽可能少（或更少），以便减少 UI 和代码之间的直接绑定。请注意，MVVM
    不是一个框架，但在使用此模式时，你可以创建一个框架。例如，来自 **GalaSoft** 的 **MVVMLight** ([http://www.mvvmlight.net](http://www.mvvmlight.net))
    提供了一个完全定制的框架，你可以在应用程序中使用它，以保持开发无烦恼。
- en: Using routed commands in a WPF application
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中使用路由命令
- en: '**Routed commands** are used to navigate a route through the element hierarchy.
    This process is also well known as bubbling and tunneling. The class `RoutedCommand`
    implements the `ICommand` interface and allows the attaching of input gestures,
    such as mouse input and keyboard shortcuts, to the target.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由命令**用于在元素层次结构中导航路径。这个过程也被称为冒泡和隧道。`RoutedCommand` 类实现了 `ICommand` 接口，并允许将输入手势，如鼠标输入和键盘快捷键，附加到目标。'
- en: In this recipe, we will learn how to use routed commands with a simple example.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将通过一个简单的示例学习如何使用路由命令。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work on this recipe, we will be using the previous MVVM demo application.
    Launch your Visual Studio IDE and open the project `CH07.MVVMDemo`. In this example,
    we will be using `RoutedCommand` for the Add button click event.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这个配方，我们将使用之前的 MVVM 示例应用程序。启动你的 Visual Studio IDE 并打开项目 `CH07.MVVMDemo`。在这个例子中，我们将使用
    `RoutedCommand` 来处理添加按钮的点击事件。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these simple steps to register the routed command to the button click
    and perform the operation:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤将路由命令注册到按钮点击并执行操作：
- en: From the Solution Explorer, right-click on the project node and create a folder
    named `Commands`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，右键单击项目节点并创建一个名为 `Commands` 的文件夹。
- en: Right-click on the Commands folder and create a new class named `RoutedCommands.cs`
    by following the Add | Class... context menu path.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“命令”文件夹上右键单击，并按照“添加 | 类...”上下文菜单路径创建一个名为 `RoutedCommands.cs` 的新类。
- en: 'Inside the class implementation, declare a static member of type `RoutedCommand`
    and name it `AddCommand`. Here''s the code implementation:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类实现内部，声明一个类型为 `RoutedCommand` 的静态成员，并将其命名为 `AddCommand`。以下是代码实现：
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the following namespace to resolve the `RoutedCommand` class:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下命名空间以解析 `RoutedCommand` 类：
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once that has been done, navigate to the `MainWindowViewModel.cs` file, present
    under the ViewModels folder, and add a property named `NewUserDetails` of type
    `UserModel`. We will be using this property to bind with the `Text` property of
    the `TextBox` controls present in the UI. The property implementation is as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，导航到 `MainWindowViewModel.cs` 文件，该文件位于 `ViewModels` 文件夹下，并添加一个名为 `NewUserDetails`
    的 `UserModel` 类型属性。我们将使用此属性将 UI 中存在的 `TextBox` 控件的 `Text` 属性进行绑定。属性实现如下：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, inside the constructor of our ViewModel, initialize the `NewUserDetails`
    property:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的 ViewModel 构造函数内部，初始化 `NewUserDetails` 属性：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Navigate to `MainWindow.xaml` now, which is present under the Views folder.
    Modify the XAML as follows, to set a `DataContext` for the `StackPanel` and create
    data bindings with the `TextBox` controls. Make sure you set the data binding
    mode to `TwoWay`, else the code will not receive the updated value received from
    the UI:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `MainWindow.xaml`，它位于 `Views` 文件夹下。按照以下方式修改 XAML，为 `StackPanel` 设置 `DataContext`
    并与 `TextBox` 控件创建数据绑定。确保将数据绑定模式设置为 `TwoWay`，否则代码将无法接收到从 UI 收到的更新值：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now add the following `XMLNS` attribute to the XAML page, so that we can access
    the classes present under the `CH07.MVVMDemo.Commands` namespace:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将以下 `XMLNS` 属性添加到 XAML 页面，以便我们可以访问 `CH07.MVVMDemo.Commands` 命名空间下的类：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <Window.CommandBindings>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <Window.CommandBindings>
- en: <CommandBinding Command="{x:Static commands:RoutedCommands.AddCommand}"
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <CommandBinding Command="{x:Static commands:RoutedCommands.AddCommand}"
- en: CanExecute="CanExecute_AddCommand"
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CanExecute="CanExecute_AddCommand"
- en: Executed="Execute_AddCommand"/>
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Executed="Execute_AddCommand"/>
- en: </Window.CommandBindings>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: </Window.CommandBindings>
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <Button Content="Add"
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <Button Content="Add"
- en: Margin="0 8"
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Margin="0 8"
- en: Command="{x:Static commands:RoutedCommands.AddCommand}"/>
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Command="{x:Static commands:RoutedCommands.AddCommand}"/>
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: <StackPanel Orientation="Vertical"
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <StackPanel Orientation="Vertical"
- en: Margin="4 0"
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Margin="4 0"
- en: DockPanel.Dock="Right"
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: DockPanel.Dock="Right"
- en: DataContext="{Binding NewUserDetails}">
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: DataContext="{Binding NewUserDetails}">
- en: <TextBlock Text="Firstname"/>
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <TextBlock Text="Firstname"/>
- en: <TextBox Text="{Binding Firstname, Mode=TwoWay}"/>
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <TextBox Text="{Binding Firstname, Mode=TwoWay}"/>
- en: <TextBlock Text="Lastname"/>
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <TextBlock Text="Lastname"/>
- en: <TextBox Text="{Binding Lastname, Mode=TwoWay}"/>
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <TextBox Text="{Binding Lastname, Mode=TwoWay}"/>
- en: <Button Content="Add"
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Button Content="Add"
- en: Margin="0 8"
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Margin="0 8"
- en: Command="{x:Static commands:RoutedCommands.AddCommand}"/>
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Command="{x:Static commands:RoutedCommands.AddCommand}"/>
- en: </StackPanel>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: </StackPanel>
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: private MainWindowViewModel ViewModel = null;
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: private MainWindowViewModel ViewModel = null;
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: public MainWindow()
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: public MainWindow()
- en: '{'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: InitializeComponent();
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: InitializeComponent();
- en: ViewModel = Resources["ViewModel"] as
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ViewModel = Resources["ViewModel"] as
- en: MainWindowViewModel;
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: MainWindowViewModel;
- en: if (ViewModel == null)
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (ViewModel == null)
- en: '{'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: throw new NullReferenceException("ViewModel
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: throw new NullReferenceException("ViewModel
- en: can't be NULL");
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: can't be NULL");
- en: '}'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: private void CanExecute_AddCommand(object sender,
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: private void CanExecute_AddCommand(object sender,
- en: CanExecuteRoutedEventArgs e)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: CanExecuteRoutedEventArgs e)
- en: '{'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (ViewModel != null)
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (ViewModel != null)
- en: '{'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: var userDetails = ViewModel.NewUserDetails;
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: var userDetails = ViewModel.NewUserDetails;
- en: e.CanExecute =
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: e.CanExecute =
- en: '!string.IsNullOrWhiteSpace(userDetails.Firstname) &&'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '!string.IsNullOrWhiteSpace(userDetails.Firstname) &&'
- en: '!string.IsNullOrWhiteSpace(userDetails.Lastname);'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '!string.IsNullOrWhiteSpace(userDetails.Lastname);'
- en: '}'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE54]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: private void Execute_AddCommand(object sender,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: private void Execute_AddCommand(object sender,
- en: ExecutedRoutedEventArgs e)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutedRoutedEventArgs e)
- en: '{'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: ViewModel.UserCollection.Add(ViewModel.NewUserDetails);
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ViewModel.UserCollection.Add(ViewModel.NewUserDetails);
- en: ViewModel.SelectedUser = ViewModel.NewUserDetails;
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ViewModel.SelectedUser = ViewModel.NewUserDetails;
- en: ViewModel.NewUserDetails = new Models.UserModel();
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ViewModel.NewUserDetails = new Models.UserModel();
- en: '}'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
