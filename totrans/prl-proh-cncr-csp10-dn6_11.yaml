- en: '*Chapter 9*: Working with Concurrent Collections in .NET'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：在 .NET 中使用并发集合'
- en: This chapter will dive deeper into some of the `System.Collections.Concurrent`
    namespace. These specialized collections help to preserve data integrity when
    using concurrency and parallelism in your C# code. Each section of this chapter
    will provide practical examples of how to use a specific concurrent collection
    provided by .NET.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨 `System.Collections.Concurrent` 命名空间中的一些内容。这些专用集合有助于在使用并发和并行性时保持数据完整性。本章的每一节都将提供使用
    .NET 提供的特定并发集合的实用示例。
- en: We have seen some basic use of parallel data structures in .NET. We have already
    covered the basics of each of the concurrent collections in the *Introduction
    to concurrency* section of [*Chapter 2*](B18552_02_ePub.xhtml#_idTextAnchor034).
    So, we will quickly jump into the examples of their use in this chapter and learn
    more about their application and inner workings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 .NET 中并行数据结构的一些基本用法。我们已经在 [*第2章*](B18552_02_ePub.xhtml#_idTextAnchor034)
    的 *并发简介* 部分介绍了每个并发集合的基础。因此，我们将快速进入本章中它们用法的示例，并进一步了解它们的应用和内部工作原理。
- en: 'In this chapter, we will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行以下操作：
- en: Using `BlockingCollection`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `BlockingCollection`
- en: Using `ConcurrentBag`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentBag`
- en: Using `ConcurrentDictionary`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentDictionary`
- en: Using `ConcurrentQueue`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentQueue`
- en: Using `ConcurrentStack`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentStack`
- en: By the end of this chapter, you will have a deeper understanding of how these
    collections protect your shared data from being mishandled while multithreading.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将更深入地了解这些集合如何保护您的共享数据在多线程中不被错误处理。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，以下软件是推荐给 Windows 开发者的：
- en: Visual Studio 2022 version 17.0 or later.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 版本 17.0 或更高版本。
- en: .NET 6.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6。
- en: To complete any WinForms or WPF samples, you will need to install the .NET desktop
    development workload for Visual Studio. These projects will run only on Windows.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要完成任何 WinForms 或 WPF 示例，您需要安装 Visual Studio 的 .NET 桌面开发工作负载。这些项目只能在 Windows
    上运行。
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是推荐的，但如果您已安装 .NET 6，您可以使用您喜欢的编辑器。例如，macOS 10.13 或更高版本的 Visual Studio 2022
    for Mac、JetBrains Rider 或 Visual Studio Code 都可以同样工作。
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09)。
- en: Let’s get started by learning more about `BlockingCollection<T>` and walk through
    a sample project that leverages the collection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习更多关于 `BlockingCollection<T>` 的知识开始，并浏览一个利用该集合的示例项目。
- en: Using BlockingCollection
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BlockingCollection
- en: '`BlockingCollection<T>` is one of the most useful concurrent collections. As
    we saw in [*Chapter 7*](B18552_07_ePub.xhtml#_idTextAnchor120), `BlockingCollection<T>`
    was created to be an implementation of the **producer/consumer pattern** for .NET.
    Let’s review some of the specifics of this collection before creating a different
    kind of sample project.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>` 是最实用的并发集合之一。正如我们在 [*第7章*](B18552_07_ePub.xhtml#_idTextAnchor120)
    中所看到的，`BlockingCollection<T>` 是为了实现 .NET 的 **生产者/消费者模式** 而创建的。在创建不同类型的示例项目之前，让我们回顾一下这个集合的一些具体细节。'
- en: BlockingCollection details
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BlockingCollection 详细信息
- en: One of the major draws of `BlockingCollection<T>` for developers working with
    parallel code implementations is that it can be swapped to replace `List<T>` without
    too many additional modifications. You can use the `Add()` method for both. The
    difference with `BlockingCollection<T>` is that calling `Add()` to add an item
    will block the current thread if another read or write operation is in process.
    If you want to specify a timeout period on the operation, you can use `TryAdd()`.
    The `TryAdd()` method optionally supports both timeouts and cancellation tokens.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用并行代码实现的开发者来说，`BlockingCollection<T>` 的一个主要吸引力是它可以替换 `List<T>` 而不需要太多额外的修改。您可以使用
    `Add()` 方法为两者。与 `BlockingCollection<T>` 的区别在于，如果另一个读取或写入操作正在进行中，调用 `Add()` 添加项目将阻塞当前线程。如果您想指定操作的超时时间，可以使用
    `TryAdd()`。`TryAdd()` 方法可选地支持超时和取消令牌。
- en: 'Removing items from `BlockingCollection<T>` with `Take()` has an equivalent
    `TryTake()`, which allows timed operations and cancellation. The `Take()` and
    `TryTake()` methods will take and remove the first remaining item that was added
    to the collection. This is because the default underlying collection type within
    `BlockingCollection<T>` is `ConcurrentQueue<T>`. Alternatively, you can specify
    that the collection uses `ConcurrentStack<T>`, `ConcurrentBag<T>`, or any collection
    that implements the `IProducerConsumerCollection<T>` interface. Here’s an example
    of `BlockingCollection<T>` being initialized to use `ConcurrentStack<T>`, with
    its capacity limited to `100` items:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `BlockingCollection<T>` 中使用 `Take()` 方法移除项目有一个等效的 `TryTake()` 方法，它允许定时操作和取消。`Take()`
    和 `TryTake()` 方法将获取并移除添加到集合中的第一个剩余项目。这是因为 `BlockingCollection<T>` 内部的默认底层集合类型是
    `ConcurrentQueue<T>`。或者，您可以指定集合使用 `ConcurrentStack<T>`、`ConcurrentBag<T>` 或任何实现
    `IProducerConsumerCollection<T>` 接口的集合。以下是一个将 `BlockingCollection<T>` 初始化为使用 `ConcurrentStack<T>`
    的示例，其容量限制为 `100` 项：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If your application needs to iterate over the items in `BlockingCollection<T>`,
    the `GetConsumingEnumerable()` method can be used in a `for` or `foreach` loop.
    However, keep in mind that this iteration over the collection is also removing
    items, and it will complete the collection if the enumeration continues until
    the collection is empty. This is the *consuming* part of the `GetConsumingEnumerable()`
    method name.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要遍历 `BlockingCollection<T>` 中的项目，可以在 `for` 或 `foreach` 循环中使用 `GetConsumingEnumerable()`
    方法。然而，请注意，对集合的这种迭代也会移除项目，并且如果枚举继续到集合为空，它将完成集合。这是 `GetConsumingEnumerable()` 方法名称中的
    *消费* 部分。
- en: 'If you need to use multiple `BlockingCollection<T>` classes of the same type,
    you can add to or take from them as one by adding them to an array. An array of
    `BlockingCollection<T>` makes the `TryAddToAny()` and `TryTakeFromAny()` methods
    available. These methods will succeed if any of the collections in the array are
    in the proper state to accept or provide objects to the calling code. Microsoft
    Docs has an example of how to use an array of `BlockingCollection<T>` in a pipeline:
    https://docs.microsoft.com/dotnet/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要使用多个相同类型的 `BlockingCollection<T>` 类，您可以通过将它们添加到一个数组中来将它们作为一个整体添加或移除。`BlockingCollection<T>`
    的数组使 `TryAddToAny()` 和 `TryTakeFromAny()` 方法可用。如果数组中的任何集合都处于适当的状态以接受或提供对象给调用代码，则这些方法将成功。Microsoft
    Docs 有一个如何在一个管道中使用 `BlockingCollection<T>` 数组的示例：https://docs.microsoft.com/dotnet/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections。
- en: Now that we have covered the details needed to understand `BlockingCollection<T>`,
    let’s dive into a sample project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了理解 `BlockingCollection<T>` 所需的详细信息，让我们深入一个示例项目。
- en: Using BlockingCollection with Parallel.ForEach and PLINQ
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 BlockingCollection 与 Parallel.ForEach 和 PLINQ
- en: 'We already covered an example that implements the producer/consumer pattern
    in [*Chapter 7*](B18552_07_ePub.xhtml#_idTextAnchor120), so let’s try something
    a little different in this section. We are going to create a WPF application that
    loads the contents of a book from a 1.5 MB text file and searches for words that
    start with a particular letter:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第7章*](B18552_07_ePub.xhtml#_idTextAnchor120) 中介绍了一个实现生产者/消费者模式的示例，所以在这个部分让我们尝试一些不同的内容。我们将创建一个
    WPF 应用程序，从 1.5 MB 的文本文件中加载书籍内容，并搜索以特定字母开头的单词：
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This sample uses a .NET Standard NuGet package created from a Microsoft extension
    sample that was originally built on .NET Framework 4.0\. The extension is called
    `ParallelExtensionsExtras`, and the original source is available on GitHub: https://github.com/dotnet/samples/tree/main/csharp/parallel/ParallelExtensionsExtras.
    The extension method that we will be using from the package makes `Parallel.ForEach`
    operations and PLINQ queries run more efficiently with concurrent collections.
    To read more about the extensions, you can check out this post on the *.NET Parallel
    Programming* blog: https://devblogs.microsoft.com/pfxteam/parallelextensionsextras-tour-4-blockingcollectionextensions/.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用从最初基于 .NET Framework 4.0 构建的 Microsoft 扩展示例创建的 .NET Standard NuGet 包。该扩展名为
    `ParallelExtensionsExtras`，原始源代码可在 GitHub 上找到：https://github.com/dotnet/samples/tree/main/csharp/parallel/ParallelExtensionsExtras。我们将从包中使用的扩展方法可以使
    `Parallel.ForEach` 操作和 PLINQ 查询在并发集合上运行得更高效。要了解更多关于扩展的信息，你可以查看 *.NET 并行编程* 博客上的这篇文章：https://devblogs.microsoft.com/pfxteam/parallelextensionsextras-tour-4-blockingcollectionextensions/。
- en: Start by creating a new WPF application in Visual Studio. Name the project `ParallelExtras.BlockingCollection`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Visual Studio 中创建一个新的 WPF 应用程序。将项目命名为 `ParallelExtras.BlockingCollection`。
- en: 'On the NuGet Package Manager page, search for and add the latest stable version
    of the **ParallelExtensionsExtras.NetFxStandard** package to your project:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 NuGet 包管理器页面，搜索并添加 **ParallelExtensionsExtras.NetFxStandard** 包的最新稳定版本到你的项目中：
- en: '![Figure 9.1 – The ParallelExtensionsExtras.NetFxStandard NuGet package ](img/Figure_9.1_B18552.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – ParallelExtensionsExtras.NetFxStandard NuGet 包](img/Figure_9.1_B18552.jpg)'
- en: Figure 9.1 – The ParallelExtensionsExtras.NetFxStandard NuGet package
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – ParallelExtensionsExtras.NetFxStandard NuGet 包
- en: We are going to read text from the book *Ulysses* by James Joyce. This book
    is public domain in the United States and most countries around the world. It
    can be downloaded in UTF-8 plain text format from `ulysses.txt`, and place it
    in the main folder with your other project files.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将读取詹姆斯·乔伊斯所著的书籍《尤利西斯》中的文本。这本书在美国以及世界上的大多数国家都是公共领域的。你可以以 UTF-8 纯文本格式从 `ulysses.txt`
    下载它，并将其放置在与你的其他项目文件相同的文件夹中。
- en: In Visual Studio, right-click `ulysses.txt` and select **Properties**. In the
    **Properties** window, update the **Copy to Output Directory** property to **Copy
    if newer**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，右键单击 `ulysses.txt` 并选择 **属性**。在 **属性** 窗口中，将 **复制到输出目录** 属性更新为
    **如果较新则复制**。
- en: 'Open `Grid.RowDefinitions` and `Grid.Columndefinitions` to the `Grid` control,
    as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Grid.RowDefinitions` 和 `Grid.Columndefinitions` 到 `Grid` 控制器，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add `ComboBox` and `Button` inside the `Grid` definition following the `Grid.ColumnDefinitions`
    element. These controls will be in the first row of `Grid`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Grid.ColumnDefinitions` 元素之后的 `Grid` 定义内添加 `ComboBox` 和 `Button`。这些控件将位于
    `Grid` 的第一行：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`ComboBox` will contain nine different letters from which to choose. You can
    add as many of these as you like. `Button` contains a `Click` event handler that
    we will add to `MainWindow.xaml.cs` soon.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComboBox` 将包含九个不同的字母，你可以从中选择。你可以添加你喜欢的这些字母中的任意多个。`Button` 包含一个 `Click` 事件处理程序，我们将在稍后的
    `MainWindow.xaml.cs` 中添加它。'
- en: 'Finally, add `ListView` named `WordsListView` to the second row of `Grid`.
    It will span both of the columns:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将名为 `WordsListView` 的 `ListView` 添加到 `Grid` 的第二行。它将跨越两个列：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, open `MainWIndow.xaml.cs`. The first thing we will do here is to create
    a method named `LoadBookLinesFromFile()`, which reads each line of text from `ulysses.txt`
    into `BlockingCollection<string>`. There is only a single thread reading from
    the file, so using the `Add()` method instead of `TryAdd()` is best:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `MainWIndow.xaml.cs`。在这里，我们首先将创建一个名为 `LoadBookLinesFromFile()` 的方法，该方法将从
    `ulysses.txt` 读取每一行文本到 `BlockingCollection<string>` 中。由于只有一个线程从文件中读取，因此使用 `Add()`
    方法而不是 `TryAdd()` 是最好的选择：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, it is important to call `lines.CompleteAdding()` before the end of
    the method. Otherwise, subsequent queries of this collection will hang and continue
    waiting for more items to be added to the stream.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在方法结束前调用 `lines.CompleteAdding()` 非常重要。否则，后续对这个集合的查询将会挂起，并继续等待更多项目被添加到流中。
- en: 'Now, create a method named `GetWords()` that takes the lines from the text
    file and uses a `BlockingCollection<string>`. In this method, we’re parsing multiple
    lines simultaneously with a `Parallel.ForEach` loop. The `GetConsumingPartitioner()`
    extension method, which tells the `Parallel.ForEach` loop that `BlockingCollection`
    will be doing its own blocking, so the loop does not need to do any. This makes
    the whole process more efficient:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `GetWords()` 的方法，该方法接受文本文件的行并使用 `BlockingCollection<string>`。在此方法中，我们使用
    `Parallel.ForEach` 循环同时解析多行。`GetConsumingPartitioner()` 扩展方法告诉 `Parallel.ForEach`
    循环 `BlockingCollection` 将执行自己的阻塞，因此循环不需要执行任何操作。这使得整个过程更加高效：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `TrimSuffix()` method will remove specific characters from the end of a
    word; in this case, we’re passing the apostrophe character to be removed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrimSuffix()` 方法将从单词的末尾删除特定字符；在这种情况下，我们传递要删除的撇号字符。'
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are unfamiliar with regular expressions, you can read about how to use
    them with .NET on Microsoft Docs: [https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions](https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions).
    They are an extremely efficient way to parse text.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对正则表达式不熟悉，可以在 Microsoft Docs 上阅读有关如何在 .NET 中使用它们的说明：[https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions](https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions)。它们是解析文本的极其高效的方法。
- en: 'Next, create a method named `GetWordsByLetter()` to call the other methods
    we just created. Once `BlockingCollection<string>` containing all the words from
    the book has been fetched, this method will use PLINQ and `GetConsumingPartitioner()`
    to find all words that start with the uppercase or lowercase versions of the selected
    letter:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `GetWordsByLetter()` 的方法来调用我们刚刚创建的其他方法。一旦获取到包含书中所有单词的 `BlockingCollection<string>`，此方法将使用
    PLINQ 和 `GetConsumingPartitioner()` 来查找所有以所选字母的大写或小写版本开头的单词：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we’ll add the `Button_Click` event to kick off the loading, parsing,
    and querying of the book’s text. Don’t forget to mark the event handler as `async`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加 `Button_Click` 事件来启动加载、解析和查询书籍文本。不要忘记将事件处理程序标记为 `async`：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `GetComboBoxValue()` helper method will take the object from `LettersComboBox.SelectedValue`
    and find `string` with the selected letter within.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetComboBoxValue()` 辅助方法将获取 `LettersComboBox.SelectedValue` 中的对象，并找到包含所选字母的
    `string`。'
- en: 'The following `using` declarations are required in `MainWindow.xaml.cs` to
    compile and run the project:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml.cs` 中需要以下 `using` 声明才能编译和运行项目：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, run the project, select a letter, and click **Load Words**:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行项目，选择一个字母，然后点击 **加载单词**：
- en: '![Figure 9.2 – Displaying words that begin with T from ulysses.txt ](img/Figure_9.2_B18552.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 从 ulysses.txt 显示以 T 开头的单词](img/Figure_9.2_B18552.jpg)'
- en: Figure 9.2 – Displaying words that begin with T from ulysses.txt
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 从 ulysses.txt 显示以 T 开头的单词
- en: The whole process runs very quickly considering the book contains over 275,000
    total words. Try adding some sorting to the PLINQ query and see how the performance
    is impacted.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到书中包含超过 275,000 个总单词，整个过程运行得非常快。尝试向 PLINQ 查询添加一些排序，看看性能如何受到影响。
- en: Let’s continue by learning about `ConcurrentBag<T>`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习 `ConcurrentBag<T>`。
- en: Using ConcurrentBag
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConcurrentBag
- en: 'The `ConcurrentBag<T>` is an unordered collection of objects that can be safely
    added, peeked at, or removed concurrently. Keep in mind that, as with all of the
    concurrent collections, the methods exposed by `ConcurrentBag<T>` are thread-safe,
    but any extension methods are not guaranteed to be safe. Always implement your
    own synchronization when leveraging them. To review a list of safe methods, you
    can review this Microsoft Docs page: https://docs.microsoft.com/dotnet/api/system.collections.concurrent.concurrentbag-1#methods.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentBag<T>` 是一个无序的对象集合，可以安全地并发添加、查看或删除。请注意，与所有并发集合一样，`ConcurrentBag<T>`
    提供的方法是线程安全的，但任何扩展方法都不保证是安全的。始终在利用它们时实现自己的同步。要查看安全方法的列表，您可以查看此 Microsoft Docs 页面：https://docs.microsoft.com/dotnet/api/system.collections.concurrent.concurrentbag-1#methods。'
- en: We are going to create a sample application that simulates working with a pool
    of objects. This scenario can be useful if you have some processing that leverages
    a stateful object that is memory-intensive. You want to minimize the number of
    objects created but cannot reuse one until the previous iteration has finished
    using it and returned it to the pool.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个示例应用程序，模拟与对象池一起工作。如果你有一些利用内存密集型状态对象的处理，这种场景可能很有用。你希望最小化创建的对象数量，但不能在之前的迭代完成并返回到池中之前重用它们。
- en: 'In our example, we will use a mocked-up PDF processing class that is assumed
    to be memory-intensive. In reality, document-processing libraries can be quite
    heavy, and they often rely on document states in each instance. The console application
    will iterate in parallel 15 times to create these fake PDF objects and append
    some text to each of them. Each time through the loop, we will output the text
    contents and the current count of PDF processors in the pool. If the current count
    remains low, then the application is working as intended:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用一个假设为内存密集型的模拟PDF处理类。实际上，文档处理库可能相当庞大，并且它们通常依赖于每个实例中的文档状态。控制台应用程序将并行迭代15次来创建这些假PDF对象，并将一些文本附加到每个对象上。每次通过循环时，我们将输出文本内容和池中PDF处理器的当前计数。如果当前计数保持较低，则应用程序按预期工作：
- en: Start by creating a new .NET console application in Visual Studio named `ConcurrentBag.PdfProcessor`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在Visual Studio中创建一个新的.NET控制台应用程序，命名为`ConcurrentBag.PdfProcessor`。
- en: 'Add a new class to represent the mocked-up PDF data. Name the class `ImposterPdfData`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的类来表示模拟的PDF数据。将这个类命名为`ImposterPdfData`：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are storing the plain text and an ASCII-encoded version of the text that
    we will pretend is PDF format. This avoids implementing any third-party libraries
    in our sample application. If you have any PDF libraries with which you are familiar,
    you are welcome to adapt this sample to use them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在存储纯文本及其ASCII编码版本，我们假装它是PDF格式。这避免了在我们的示例应用程序中实现任何第三方库。如果你熟悉任何PDF库，你欢迎将此示例修改为使用它们。
- en: 'Next, add a new class named `PdfParser`. This class will be the one that is
    taken from and returned to `ConcurrentBag<PdfParser>`. We will create the host
    for that collection in an upcoming step:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为`PdfParser`的新类。这个类将是从`ConcurrentBag<PdfParser>`中取出并返回的类。我们将在接下来的步骤中创建该集合的宿主：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This stateful class holds an instance of an `ImposterPdfData` object and can
    return the data as a string or the ASCII-encoded byte array.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此状态类持有`ImposterPdfData`对象的一个实例，并且可以返回数据作为一个字符串或ASCII编码的字节数组。
- en: 'Add a method to `PdfParser` named `AppendString`. This method will add some
    additional text to `ImposterPdfData` on a new line:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`PdfParser`添加一个名为`AppendString`的方法。此方法将在`ImposterPdfData`的新行上添加一些附加文本：
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, add a class named `PdfWorkerPool`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为`PdfWorkerPool`的类：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Be sure to also add a `using System.Collections.Concurrent;` statement to `PdfWorkerPool.cs`.
    The pool stores `ConcurrentBag<PdfParser>` named `_workerPool`. When `PdfWorkerPool`
    is initialized, it adds a new instance to `_workerPool`. The `Get` method will
    return an existing instance from the pool with `TryTake` if one exists. If the
    pool is empty, a new instance is created and returned to the caller. The `Return`
    method adds `PdfParser` back to the pool when the consumer is finished. We will
    use the `WorkerCount` property to track the number of objects in the pool at any
    time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 确保还将`using System.Collections.Concurrent;`语句添加到`PdfWorkerPool.cs`中。池存储名为`_workerPool`的`ConcurrentBag<PdfParser>`。当`PdfWorkerPool`初始化时，它将向`_workerPool`添加一个新的实例。`Get`方法将返回池中的一个现有实例，如果存在的话，使用`TryTake`。如果池为空，则创建一个新的实例并返回给调用者。`Return`方法在消费者完成时将`PdfParser`添加回池中。我们将使用`WorkerCount`属性来跟踪任何时间点池中的对象数量。
- en: 'Finally, replace the contents of `Program.cs` with the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用以下代码替换`Program.cs`的内容：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After creating a new `PdfWorkerPool`, we’re using a `Parallel.For` loop to iterate
    15 times. Each time through the loop, we get `PdfParser`, set the text, append
    `DateTime.UtcNow`, and write the contents to the console, along with the current
    count of parsers in the pool.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`PdfWorkerPool`后，我们使用`Parallel.For`循环迭代15次。每次通过循环时，我们获取`PdfParser`，设置文本，附加`DateTime.UtcNow`，并将内容写入控制台，同时附带池中解析器的当前计数。
- en: 'Run the application and examine the output:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并检查输出：
- en: '![Figure 9.3 – Running the PdfProcessor console application ](img/Figure_9.3_B18552.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 运行PdfProcessor控制台应用程序](img/Figure_9.3_B18552.jpg)'
- en: Figure 9.3 – Running the PdfProcessor console application
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 运行 PdfProcessor 控制台应用程序
- en: In my case, the parser count got to a maximum number of seven. If you tweak
    the `Task.Delay` intervals or remove them entirely, you are likely to see the
    count never exceed one. This kind of pool can be configured to be very efficient.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，解析计数达到了七个的最大值。如果你调整 `Task.Delay` 间隔或完全删除它们，你可能会看到计数永远不会超过一个。这种池可以配置得非常高效。
- en: This application is an example where we do not care which instance of the collection
    is returned, so `ConcurrentBag<T>` is a perfect choice. In the next section, we
    will create a drug lookup example using `ConcurrentDictionary<TKey, TValue>`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们不在乎集合的哪个实例被返回，所以 `ConcurrentBag<T>` 是一个完美的选择。在下一节中，我们将创建一个使用 `ConcurrentDictionary<TKey,
    TValue>` 的药物查找示例。
- en: Using ConcurrentDictionary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConcurrentDictionary
- en: 'In this section, we will create a WinForms application to load United States
    `ConcurrentDictionary`, we can perform fast lookups with a `product.txt` file
    and moved about half of the records to a `product2.txt` file, duplicating the
    header row in the second file. You can get these files in the GitHub repository
    for the chapter at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个 WinForms 应用程序来加载美国的 `ConcurrentDictionary`，我们可以使用 `product.txt`
    文件进行快速查找，并将大约一半的记录移动到 `product2.txt` 文件中，在第二个文件中重复标题行。您可以在 GitHub 仓库中找到这些文件，网址为
    [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup)：
- en: Start by creating a new WinForms project in Visual Studio targeting .NET 6\.
    Name the project `FdaNdcDrugLookup`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Visual Studio 中创建一个新的 WinForms 项目，目标为 .NET 6。将项目命名为 `FdaNdcDrugLookup`。
- en: 'Open the WinForm designer for `Form1.cs`. Lay out two `TextBox` controls, two
    `Button` controls, and `Label`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Form1.cs` 的 WinForm 设计器。布局两个 `TextBox` 控件、两个 `Button` 控件和 `Label`：
- en: '![Figure 9.4 – The layout of Form1.cs ](img/Figure_9.4_B18552.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – Form1.cs 的布局](img/Figure_9.4_B18552.jpg)'
- en: Figure 9.4 – The layout of Form1.cs
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – Form1.cs 的布局
- en: The `btnLoad` and `txtNdc`. The `btnLookup`, `txtDrugName` and **ReadOnly**
    – **True**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`btnLoad` 和 `txtNdc`。`btnLookup`、`txtDrugName` 和 **只读** – **True**。'
- en: Next, add the `product.txt` and `product2.txt` files to your project by right-clicking
    the project in **Solution Explorer** and choosing **Add** | **Existing Item**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过在 **解决方案资源管理器** 中右键单击项目并选择 **添加** | **现有项**，将 `product.txt` 和 `product2.txt`
    文件添加到您的项目中。
- en: In the **Properties** panel, change **Copy to Output Directory** to **Copy if
    newer** for both of the text files we just added.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **属性** 面板中，将两个我们刚刚添加的文本文件的 **复制到输出目录** 更改为 **如果较新则复制**。
- en: 'Add a new class to the project named `Drug` and add the following implementation:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `Drug` 的新类，并添加以下实现：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will contain the data for each record loaded from the NDC drug files.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含从 NDC 药物文件加载的每个记录的数据。
- en: 'Next, add a class to the project named `DrugService` and begin with the following
    implementation. To start, we only have `private` `ConcurrentDictionary<string,
    Drug>`. We will add a method to load the data in the next step:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向项目中添加一个名为 `DrugService` 的类，并从以下实现开始。首先，我们只有 `private` `ConcurrentDictionary<string,
    Drug>`。我们将在下一步添加一个方法来加载数据：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add a public method to `DrugService` named `LoadData`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向 `DrugService` 添加一个名为 `LoadData` 的公共方法：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this method, we are loading data from the provided `fileName` to `StreamReader`,
    adding the column headers to `DataTable`, populating its rows from the file, and
    then iterating over the rows and columns of `DataTable` to create `Drug` objects.
    Each `Drug` object is added to `ConcurrentDictionary` with a call to `TryAdd`,
    using the `Ndc` property as the key.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们从提供的 `fileName` 加载数据到 `StreamReader`，将列标题添加到 `DataTable`，从文件中填充其行，然后遍历
    `DataTable` 的行和列来创建 `Drug` 对象。每个 `Drug` 对象都通过调用 `TryAdd` 添加到 `ConcurrentDictionary`
    中，使用 `Ndc` 属性作为键。
- en: 'Now, add a `GetDrugByNdc` method to `DrugService` to complete the class. This
    method will return `Drug` for the provided `ndcCode`, if found:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向 `DrugService` 添加一个 `GetDrugByNdc` 方法以完成类。此方法将返回提供的 `ndcCode` 对应的 `Drug`，如果找到的话：
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open the code for `Form1.cs` and add a private variable for the `DrugService`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Form1.cs` 的代码，为 `DrugService` 添加一个私有变量：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open the designer for `Form1.cs` and double-click the `btnLoad_Click` event
    handler. Add the following implementation. Note that we made the `async` event
    handler to allow us to use the `await` keyword:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Form1.cs` 的设计器，双击 `btnLoad_Click` 事件处理程序。添加以下实现。请注意，我们创建了一个 `async` 事件处理程序，以便我们可以使用
    `await` 关键字：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To load the two text files, we are creating two tasks to run in parallel before
    using `Task.WhenAll` to await them both. Then, we can safely enable the `btnLookup`
    button and disable the `btnLoad` button to prevent a second load.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载两个文本文件，我们在使用 `Task.WhenAll` 等待它们之前创建了两个并行运行的任务。然后，我们可以安全地启用 `btnLookup`
    按钮并禁用 `btnLoad` 按钮以防止第二次加载。
- en: 'Next, switch back to the designer view for `Form1.cs` and double-click the
    `btnLookup_Click` event handler. Add the following implementation to that handler
    to find a drug name based on the NDC code entered in the UI:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，切换回 `Form1.cs` 的设计视图，双击 `btnLookup_Click` 事件处理程序。向该处理程序添加以下实现以根据在 UI 中输入的
    NDC 代码查找药物名称：
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, run the application and click the `70518-1120` NDC code. Click **Lookup
    Drug**:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并点击 `70518-1120` NDC 代码。点击 **查找药物**：
- en: '![Figure 9.5 – Looking up the drug Prednisone by its NDC code ](img/Figure_9.5_B18552.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 通过 NDC 代码查找药物 Prednisone](img/Figure_9.5_B18552.jpg)'
- en: Figure 9.5 – Looking up the drug Prednisone by its NDC code
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 通过 NDC 代码查找药物 Prednisone
- en: 'Try some other NDC codes and see how quickly each record loads. Here are a
    few random NDC codes taken from each file. If they all succeed, you know that
    both files loaded successfully in parallel: **0002-0800**, **0002-4112**, **43063-825**,
    and **51662-1544**.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一些其他的 NDC 代码，看看每条记录加载得有多快。这里有一些从每个文件中随机选取的 NDC 代码。如果它们都成功，你就知道两个文件已经并行成功加载：**0002-0800**，**0002-4112**，**43063-825**，和
    **51662-1544**。
- en: That’s it! You now have your own quick-and-dirty drug lookup application. Try
    replacing the drug name `TextBox` with `DataGrid` on your own to display an entire
    `Drug` record.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！你现在有了自己的快速且简单的药物查找应用程序。尝试将药物名称 `TextBox` 替换为 `DataGrid` 来显示整个 `Drug` 记录。
- en: In the next section, we will work with customer orders in `ConcurrentQueue<T>`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将处理 `ConcurrentQueue<T>` 中的客户订单。
- en: Using ConcurrentQueue
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConcurrentQueue
- en: 'In this section, we will create a sample project that is a simplified version
    of a realistic scenario. We are going to create an order queuing system using
    `ConcurrentQueue<T>`. This application will be a console application that enqueues
    orders for two customers in parallel. We will create five orders for each customer,
    and to mix up the order of the queue, each customer queuing process will use a
    different `Task.Delay` between calls to `Enqueue`. The final output should show
    a mix of orders dequeued for the first customer and the second customer. Remember
    that `ConcurrentQueue<T>` employs **first in, first out** (**FIFO**) logic:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个示例项目，这是一个现实场景的简化版本。我们将使用 `ConcurrentQueue<T>` 创建一个订单排队系统。这个应用程序将是一个控制台应用程序，并行为两位客户排队订单。我们将为每位客户创建五个订单，并且为了混合队列的顺序，每位客户的排队过程将在调用
    `Enqueue` 之间使用不同的 `Task.Delay`。最终的输出应显示为第一位客户和第二位客户退出的订单混合。请记住，`ConcurrentQueue<T>`
    采用 **先进先出** (**FIFO**) 逻辑：
- en: Let’s start by opening Visual Studio and creating a .NET console application
    named `ConcurrentOrderQueue`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开 Visual Studio 并创建一个名为 `ConcurrentOrderQueue` 的 .NET 控制台应用程序开始。
- en: 'Add a new class to the project named `Order`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `Order` 的新类：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, create a new class named `OrderService` containing a private `ConcurrentQueue<Order>`
    named `_orderQueue`. This class is where we will enqueue and dequeue orders for
    our two customers:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `OrderService` 的新类，其中包含一个名为 `_orderQueue` 的私有 `ConcurrentQueue<Order>`。这个类是我们将在此处为两位客户排队和退队订单的地方：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s start with the implementation of `DequeueOrders`. In this method, we
    will use a `while` loop to call `TryDequeue` until the collection is empty, adding
    each order to `List<Order>` to be returned to the caller:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现 `DequeueOrders` 方法开始。在这个方法中，我们将使用一个 `while` 循环来调用 `TryDequeue`，直到集合为空，将每个订单添加到
    `List<Order>` 中以返回给调用者：
- en: '[PRE25]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we will create public and private `EnqueueOrders` methods. The public
    parameterless method will call the private method twice, once for each `customerId`.
    The two calls will be made in parallel, followed by a `Task.WhenAll` call to await
    them:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建公共和私有 `EnqueueOrders` 方法。公共的无参数方法将调用私有方法两次，一次为每个 `customerId`。这两个调用将并行进行，然后通过
    `Task.WhenAll` 调用来等待它们：
- en: '[PRE26]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The private `EnqueueOrders` method iterates five times to create and `Enqueue`
    orders for the given `customerId`. This is also used to vary `ItemName`, `ItemQty`,
    and the duration of `Task.Delay`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法`EnqueueOrders`迭代五次，为给定的`customerId`创建和`Enqueue`订单。这也用于改变`ItemName`、`ItemQty`和`Task.Delay`的持续时间。
- en: 'Finally, open `Program.cs` and add the following code to enqueue and dequeue
    the orders, and output the resulting list to the console:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`Program.cs`并添加以下代码以入队和出队订单，并将结果列表输出到控制台：
- en: '[PRE27]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the program and view the list of orders in the output. How does yours match
    up?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并查看输出中的订单列表。你的结果是如何的？
- en: '![Figure 9.6 – Viewing the output of the order queue ](img/Figure_9.6_B18552.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 查看订单队列的输出](img/Figure_9.6_B18552.jpg)'
- en: Figure 9.6 – Viewing the output of the order queue
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 查看订单队列的输出
- en: Try varying the delay factor or changing `customerId` for one or both customers
    in the `EnqueueOrders` method to see how the order of the output changes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试改变延迟因子或更改`EnqueueOrders`方法中的`customerId`，以查看输出顺序如何变化。
- en: Next, in the final section of the chapter, we will perform a quick experiment
    with the `ConcurrentStack<T>` collection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在本章的最后部分，我们将对`ConcurrentStack<T>`集合进行快速实验。
- en: Using ConcurrentStack
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ConcurrentStack
- en: In this section, we are going to experiment with `BlockingCollection<T>` and
    `ConcurrentStack<T>`. In the first example in this chapter, we used `BlockingCollection<T>`
    to read the words that started with a specific letter from the book *Ulysses*.
    We are going to make a copy of that project and change the code that reads the
    lines of text to use `ConcurrentStack<T>` inside `BlockingCollection<T>`. This
    will make the lines output in reverse order because a stack uses **last in, first
    out** (**LIFO**) logic. Let’s get started!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对`BlockingCollection<T>`和`ConcurrentStack<T>`进行实验。在本章的第一个例子中，我们使用了`BlockingCollection<T>`来读取从书《尤利西斯》中开始的特定字母的单词。我们将复制该项目并更改读取文本行代码，使其在`BlockingCollection<T>`内部使用`ConcurrentStack<T>`。这将使行以相反的顺序输出，因为栈使用**后进先出**（**LIFO**）逻辑。让我们开始吧！
- en: Make a copy of the **ParallelExtras.BlockingCollection** project from this chapter
    or modify the existing project if you prefer.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本章复制**ParallelExtras.BlockingCollection**项目，或者如果你更喜欢，修改现有的项目。
- en: 'Open `MainWindow.xaml.cs` and modify the `LoadBookLinesFromFile` method to
    pass a new `ConcurrentStack<string>` to the constructor of `BlockingCollection<string>`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml.cs`并修改`LoadBookLinesFromFile`方法，将其传递给`BlockingCollection<string>`构造函数的新`ConcurrentStack<string>`：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that the preceding method was truncated to emphasize the modified code.
    View the complete method on GitHub: [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的方法被截断以强调修改后的代码。在GitHub上查看完整方法：[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack)。
- en: 'Now, when you run the application and search for the same letter as before
    (in our case, `T`), you will see a different set of words at the beginning of
    the list:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序并搜索与之前相同的字母（在我们的例子中是`T`）时，你将在列表的开头看到一组不同的单词：
- en: '![Figure 9.7 – Searching for words that start with T in Ulysses ](img/Figure_9.7_B18552.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 在《尤利西斯》中搜索以T开头的单词](img/Figure_9.7_B18552.jpg)'
- en: Figure 9.7 – Searching for words that start with T in Ulysses
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 在《尤利西斯》中搜索以T开头的单词
- en: If you scroll to the bottom of the list, you should see the words from the beginning
    of the book. Note that the list is not completely reversed because we didn’t use
    `ConcurrentStack<string>` when parsing the words from each line. You can try this
    on your own as another experiment.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你滚动到列表的底部，你应该能看到从本书开头开始的单词。注意，列表并没有完全反转，因为我们没有在解析每一行的单词时使用`ConcurrentStack<string>`。你可以自己尝试这个实验作为另一个实验。
- en: That concludes our tour of the .NET concurrent collections. Let’s wrap up by
    summarizing what we have learned in this chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对.NET并发集合的探索。让我们总结一下本章学到的内容。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into five of the collections in the `System.Collections.Concurrent`
    namespace. We created five sample applications in the chapter to get some hands-on
    experience with each of the concurrent collection types available in .NET 6\.
    Through a mix of WPF, WinForms, and .NET console application projects, we examined
    some real-world methods of leveraging these collections in your own applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 `System.Collections.Concurrent` 命名空间中的五个集合。我们在本章创建了五个示例应用程序，以获得对
    .NET 6 中可用的每个并发集合类型的实际操作经验。通过 WPF、WinForms 和 .NET 控制台应用程序项目的混合，我们研究了在您自己的应用程序中利用这些集合的一些实际方法。
- en: In the next chapter, we will explore the rich set of tools provided by Visual
    Studio for multithreaded development and debugging. We will also discuss some
    techniques for analyzing and improving the performance of parallel .NET code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Visual Studio 为多线程开发和调试提供的丰富工具集。我们还将讨论一些分析和改进并行 .NET 代码性能的技术。
- en: Questions
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which concurrent collection can implement different types of collections under
    the covers?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个并发集合可以在底层实现不同类型的集合？
- en: What is the default internal collection type implemented by the collection in
    question 1?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题 1 中的集合默认实现了哪种内部集合类型？
- en: Which collection type is frequently used as an implementation of the producer/consumer
    pattern?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种集合类型经常被用作生产者/消费者模式的实现？
- en: Which concurrent collection contains key/value pairs?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个并发集合包含键/值对？
- en: Which method is used to add values to `ConcurrentQueue<T>`?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于向 `ConcurrentQueue<T>` 添加值的哪种方法？
- en: Which methods are used to add and get items in `ConcurrentDictionary`?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于在 `ConcurrentDictionary` 中添加和获取项的哪种方法？
- en: Are extension methods used with the concurrent collections thread-safe?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展方法与并发集合一起使用时是否线程安全？
