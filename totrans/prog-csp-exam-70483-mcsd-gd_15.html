<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using LINQ Queries</h1>
                </header>
            
            <article>
                
<p>In .NET, we often need to query data from different sources, such as XML, SQL, and web services. In earlier versions of .NET, we performed these operations using simple strings. The main issue with this approach is that it lacks any IntelliSense and is quite cumbersome in implementation. These queries also differ from one another as to the source from which we are querying the data, thereby increasing the code complexity. </p>
<p>To overcome these issues, LINQ was firstly introduced in .NET 3.5. <span>Compared to conventional data access methods, LINQ introduces an easy and consistent approach for the querying and modification of data across different types of data sources such as XML and even in-memory data structures such as arrays. </span>In LINQ, we query data using a query expression. The query expression enables us to perform filtering, ordering, and grouping of operations on the data using minimal code. </p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li>Introducing LINQ</li>
<li><span>Understanding the language features that make LINQ possible</span></li>
<li>Understanding LINQ query operators</li>
<li><span>Understanding LINQ behind the scenes</span></li>
<li><span>Using LINQ to XML</span></li>
</ul>
<p>By the end of this chapter, we will have learned how we can use LINQ queries while performing operations on an XML file. We will look at how LINQ queries can help us write, query, and modify XML files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Like in the previous chapters covered in this book, the programs explained in this book will be developed in Visual Studio 2017.</p>
<p><span>The sample code for this chapter can be found on GitHub in </span><kbd>Chapter 15</kbd> (<a href="https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples">https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing LINQ</h1>
                </header>
            
            <article>
                
<p>In this section, we will learn the basics of LINQ. We can use LINQ queries against any collection of objects, with the only condition being that the object must support the <kbd>IEnumerable</kbd> or generic <kbd>IEnumerable&lt;T&gt;</kbd> interface.</p>
<p>Along with that, the target framework of the project in which we are planning to use LINQ must be <span>version</span><span> </span><span>3.5 or more recent. </span></p>
<p>In the next section, we will look at queries, which form the basis of LINQ operations. We will be looking at the different components of a query and understand how they are constructed in .NET.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Queries</h1>
                </header>
            
            <article>
                
<p>A query is a string expression that retrieves data from a data source. The expression is usually related to a particular data source such as SQL or XML and will generally be expressed in that respective data source language. However, with LINQ, we can develop a reusable coding pattern that works on different data sources. The pattern is divided into three parts: </p>
<ul>
<li>Obtaining the data source</li>
<li>Creating the query</li>
<li>Executing the query</li>
</ul>
<p><span>The following </span>code that illustrates the three operations in their simplest forms:</p>
<pre>// 1. Obtaining the data source.<br/> int[] numbers = new int[3] { 0, 1, 2};<br/>// 2. Query creation.<br/>var numQuery =<br/>from num in numbers<br/>where (num % 2) == 0<br/>select num;<br/>// 3. Query execution.<br/>foreach (int num in numQuery)<br/>{<br/>     Console.Write("{0,1} ", num);<br/>}</pre>
<p>In the preceding code example, we created an array of integers whose size is <kbd>3</kbd>. As it implements the <kbd>IEnumerable&lt;int&gt;</kbd><span> </span><span>interface</span><span>, we will be able to implement LINQ on the array. In the next step, we created a query in which we are filtering even numbers present in the array. Finally, in the third step, we are looping through the results of the query execution and printing it.</span></p>
<p>In the preceding example, we used an array as the source of data. The array already supports the <kbd>IEnumerable</kbd> or <kbd>IEnumerable &lt;T&gt;</kbd> interface. However, in some cases, that may not always be the case. For example, when we read the data source from sources such as XML files, we need LINQ to load the data in memory as a queryable type. In this case, we can use the <kbd>XElement</kbd> type. <span>The following </span>is the syntax for this:</p>
<pre><span class="hljs-comment">// Create a data source from an XML document.</span><span> </span><span class="hljs-comment">// <br/>using System.Xml.Linq;</span><span> <br/>XElement students = XElement.Load(</span><span class="hljs-string">@"c:\students.xml"</span><span>);</span> </pre>
<p>In the preceding code example, we have loaded the data from the XML file in the <kbd>XElement</kbd> object, which implements an <kbd>IQuerable</kbd> interface. Now, on this, we can easily write LINQ queries to execute any operation.</p>
<p>Before we move ahead and understand more around LINQ, we must understand the built-in features of C# that help us implement LINQ queries. In the next section, we will discuss some of these features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding language features that make LINQ possible</h1>
                </header>
            
            <article>
                
<p>There are several features available in C# that are either necessary for the implementation of LINQ or that help us effectively use LINQ queries. These are some of the topics that we will be going through in this chapter:</p>
<ul>
<li>Implicitly typed variables</li>
<li>Object initialization syntax</li>
<li>Lambda expressions</li>
<li>Extension methods</li>
<li>Anonymous types</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicitly typed variables</h1>
                </header>
            
            <article>
                
<p>In C#, we generally use statically typed variables. This implies that the compiler knows the type of variable at compile time. Due to this, if it finds any operation that may result in an error, it will highlight it at compile time. For example, refer to the following code:</p>
<pre> int i = 1;<br/> FileStream f = new FileStream("test.txt", FileMode.Open);<br/> string s = i + f; // This line gives a compile error</pre>
<p>We will observe that the compiler will give us a compile-time error. <span>The following </span>is the screenshot this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1375d3c9-6bee-4f03-b32a-5163d2fef34c.png" style=""/></div>
<p>As illustrated by the error description, the compiler identifies that the operation is not supported in terms of the type of the two variables, hence, it throws this error. This is referred to as explicit typing. </p>
<p>Implicit typing was added to C# in version 3.0. In implicit typing, the compiler automatically identifies the variable type at compile time. The compiler does this based on the value that is assigned to the variable during declaration. The compiler then strongly types the variable to that particular type.</p>
<p>In C#, we use implicit typing by using the <kbd>var</kbd> keyword. The following shows the same code written earlier, albeit with implicit typing:</p>
<pre>var i = 1;<br/>FileStream f = new FileStream("test.txt", FileMode.Open);<br/>string s = i + f; // This line gives a compile error</pre>
<p>Please note that even though we have not implicitly specified the type of the variable as <kbd>int</kbd>, based upon the value <kbd>1</kbd> assigned to it, the compiler will infer that the type of the variable must be <kbd>int</kbd>. In this case, it will give us the same compile-time error. The following is the screenshot for this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4d910edc-fc1f-465c-8703-3c10af12adde.png" style=""/></div>
<p>Implicit <kbd>Type</kbd> helps in the LINQ query in circumstances when the return type is determined at compile time. In addition to being a mandatory declaration, implicit typing also improves code readability. To illustrate this example, refer to the following declaration in the code.</p>
<p>Note that, instead of declaring the actual type, we have used the <kbd>Type</kbd> variable in the declaration, hence improving code readability:</p>
<pre>Dictionary&lt;string, IEnumerable&lt;Tuple&lt;Type, int&gt;&gt;&gt; implicitData = new Dictionary&lt;string, IEnumerable&lt;Tuple&lt;Type, int&gt;&gt;&gt;();<br/>var implicitData = new Dictionary&lt;string, IEnumerable&lt;Tuple&lt;Type, int&gt;&gt;&gt;();</pre>
<p>In the next section, we will look at initializers and how they can improve code readability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object initialization syntax</h1>
                </header>
            
            <article>
                
<p>Initializers in C# help us combine the creation of objects and set their properties. Let's refer to the following code example. Let's assume we have a <kbd>Student</kbd> <span>class</span><span> that has </span><span>the following declaration:</span></p>
<pre>public class Student<br/>{<br/>     public int rollNum { get; set; }<br/>     public string Name { get; set; }<br/>}</pre>
<p>Now, suppose we need to declare an object for this class. In a conventional way, without the use of object initializers, we can do it in the following manner:</p>
<pre>Student p = new Student();<br/>p.rollNum = 1;<br/>p.Name = "James";<br/>Student p2 = new Student();<br/>p2.rollNum = 2;<br/>p2.Name = "Donohoe";</pre>
<p>Note that in the preceding code, we have to specify the creation of the <kbd>p</kbd> and <kbd>p2</kbd> <span>objects</span><span> </span><span>and set up their respective properties separately. </span></p>
<p>Using object initialization syntax, we will be able to combine the creation of the object and the setting up of its properties in one statement. As an example, if we use object initialization to execute the same functionality that we did earlier, we can use the following syntax:</p>
<pre>// Creating and initializing a new object in a single step<br/>Person p = new Person<br/>{<br/>    FirstName ="James",<br/>    LastName = "Doe"<br/>};</pre>
<p>Please note that even though usage of object initialization is not necessary and doesn't provide any additional capability or feature to us, it can improve the readability of our code. The code can also be enhanced if there is a requirement for creating a collection of the same objects. <span>The following </span>is the syntax for this:</p>
<pre>var students = new List&lt;Student&gt;<br/>{<br/>    new Student<br/>    {<br/>        rollNum = 1,<br/>        Name = "James"<br/>    },<br/>    new Student<br/>    {<br/>        rollNum = 2,<br/>        Name = "Donohoe"<br/>    }<br/>};</pre>
<p>Note that object initialization syntax makes the code much more readable and, in cases where we are working with anonymous types, it is actually required. In the next section, we will look at lambda expressions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lambda expressions</h1>
                </header>
            
            <article>
                
<p>Lambda expressions were introduced to C# in 3.0 version. Lambda expressions are based upon anonymous functions and a lambda expression is a shorter way to represent an anonymous method. </p>
<p>In <a href="66c957f7-4032-461e-91e4-00da1eb6a517.xhtml">Chapter 5</a>, <em>Creating and Implementing Events and Callbacks</em>, in the <em>Initiate delegate using anonymous functions</em><span> </span><span>section</span><span>, we looked at how we can create anonymous functions in C# using the </span><kbd>delegate</kbd><span> </span><span>keyword</span><span>. In a nutshell, just to recap, using anonymous methods, we can create an inline method in some code, assign it to a variable, and pass it around.</span></p>
<p><span>In <a href="66c957f7-4032-461e-91e4-00da1eb6a517.xhtml">Chapter 5</a>, <em>Creating and Implementing Events and Callbacks</em>, in the <em>Lambda expressions</em></span><span> </span><span>section</span><span>, we looked at how we can convert an anonymous function into its equivalent lambda expression. However, just to recap, let's go through the following code example, in which we will first create an anonymous function and then create a lambda expression for the same:</span></p>
<pre>Func&lt;int, int&gt; anonymousFunc = delegate (int y)<br/>{<br/>    return y * 5;<br/>};<br/>Console.WriteLine(anonymousFunc(1));'. </pre>
<p>In the preceding code, we declared a delegate function of the <kbd>Func&lt;T,T&gt;</kbd><span> </span><span>format</span><span>. This implies that this function takes an input of <kbd>int</kbd> and returns an integer output. Hence, the output for the preceding operation would be</span> <em>1 * 5</em>, <span>that is, </span><em>5</em><span>.</span></p>
<p>Now, if we need to write the same code using a lambda expression, we can use the following code syntax<span>:</span></p>
<pre>Func&lt;int, int&gt; anonymousFuncLambda = y =&gt; y * 5; <br/>Console.WriteLine(anonymousFuncLambda(1));</pre>
<p><span>Please also note the usage of the </span><span><kbd>=&gt;</kbd> </span><span>notation</span><span> </span><span>in a lambda expression. This notation translates into</span> <em>becomes</em> <span>or</span> <em>for which</em><span>.</span></p>
<p>If we execute the two code blocks, we will notice that the results of the operations are the same. However, with lambda expressions, we end up with much cleaner code and avoid a lot of code typing. In the next section, we will look at extension methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extension methods</h1>
                </header>
            
            <article>
                
<p>Extension methods in C# allow us to add methods to an existing type without altering them or using inheritance. <span>The extension methods are defined in the <kbd>System.Linq.Enumerables</kbd></span><span> </span><span>namespace</span><span>.</span></p>
<p>An extension method is always defined in a static class and as a static method. Along with that, it also uses the <kbd>this</kbd> <span>keyword</span><span> </span><span>to qualify itself as an extension method. The following is a code example in which we have declared an extension method multiple on the </span><kbd>int</kbd><span> </span><span>type</span><span>. To identify the calling object as the first parameter being passed to the function, we have used the </span><kbd>this</kbd><span> </span><span>keyword</span><span>:</span></p>
<p> </p>
<pre>public static class IntExtensions<br/>{<br/>    public static int MultiplyExtension(<strong>this</strong> int x, int y)<br/>    {<br/>        return x * y;<br/>    }<br/>}<br/>int z = 6;<br/>Console.WriteLine(z.MultiplyExtension(5));<br/>Console.ReadLine();     </pre>
<p>Once the preceding code is executed, we get the output of <kbd>30</kbd>, which is the output when the calling object, <kbd>6</kbd>, is multiplied by <kbd>5</kbd>, which is declared in the extension method. In the next section, we will look at anonymous types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Anonymous types</h1>
                </header>
            
            <article>
                
<p>An anonymous type is a combination of both object initializers and implicit typing. An anonymous type is a type that doesn't have a name. Using anonymous types, using the <kbd>var</kbd> and <kbd>new</kbd> keyword, we create an object without defining its type or class. The type of anonymous type variable is inferred based on the value with which it's initialized. Along with that, the properties of an anonymous variable are read-only, which means we cannot change their values after the variable has been initialized. </p>
<p><span>The following is </span>some sample code syntax where we have declared an object of an anonymous type. In the object, we have specified three properties, <kbd>PropertyNum1</kbd>, <kbd>PropertyNum2</kbd>, and <kbd>PropertyNum3</kbd>:</p>
<pre>var anonymousType = new<br/>{<br/>    PropertyNum1 = "One",<br/>    PropertyNum2 = 2,<br/>    PropertyNum3 = true<br/>};<br/>Console.WriteLine(anonymousType.GetType().ToString());             </pre>
<p>Once the code is executed, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/189311df-d804-4691-a019-dd54358ba221.png" style=""/></div>
<p>Note that, as we are displaying the type of the anonymous type, for each of its respective properties, the execution is displaying the type based upon the value that is assigned to the property. Hence, the output that we see is <kbd>String</kbd>, <kbd>Int32</kbd>, and <kbd>Boolean</kbd>.</p>
<p>In the next section, we will look at some standard LINQ operators that we use often while writing LINQ queries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding LINQ query operators</h1>
                </header>
            
            <article>
                
<p>As described in the <em>Queries</em> section, each LINQ operation is divided into three parts. In the first part, we obtain data from a data source. In the second part, we do operations on the data and finally, in the last part, we extract the data.</p>
<p>While doing the second part, that is, performing operations on the data, there are some standard operators that we can use. These operators help u<span>s to achieve a consistent experience and a code base that can be easily adapted to different data sources. </span></p>
<p>Some of the standard query operators are <kbd>Select</kbd>, <kbd>SelectMany</kbd>, <kbd>Join</kbd>, <kbd>OrderBy</kbd>, <kbd>Average</kbd>, <kbd>GroupBy</kbd>, <kbd>Max</kbd>, <kbd>Min</kbd>, and <kbd>Where</kbd>. In the following sections, let's see some code and learn how some of these operators work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Select and SelectMany</h1>
                </header>
            
            <article>
                
<p>We use <kbd>Select</kbd> in LINQ when we need to select some values from a collection. For example, in the following code syntax, we have declared an array of integers and are selecting all of the numbers present in the array:</p>
<pre>int[] numbers = new int[3] { 0, 1, 2 };<br/>var numQuery =<br/>from num in numbers<br/>select num;<br/> <br/>foreach(var n in numQuery)<br/>{<br/>     Console.Write(n);<br/>}</pre>
<p>Therefore, if the preceding code is executed, it will print all of the numbers present in the array. The following is the output of the preceding code snippet:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/33519f2d-91ab-4f1f-9976-f7b9ac49e50a.png" style=""/></div>
<p>We use <kbd>Select</kbd> when we need to select a value from a collection. However, in scenarios where we need to select values from nested collections, that is, a collection of collections, we use the <kbd>SelectMany</kbd> operator. Refer to the following code example, in which we are using the <kbd>SelectMany</kbd> operator to retrieve individual characters from string objects present in a string array:</p>
<pre>string[] array =<br/>{<br/>     "Introduction",<br/>     "In",<br/>     "C#"<br/>};<br/>var result = array.SelectMany(element =&gt; element.ToCharArray());<br/>foreach (char letter in result)<br/>{<br/>     Console.Write(letter);<br/>}</pre>
<p> The following would be the output of the program:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0b9ee7f5-aace-425b-a5af-f7fd8236a23f.png" style=""/></div>
<p>In the preceding program, the source of data is an array of strings. Now, strings are again an array of characters. Using <kbd>SelectMany</kbd>, we have directly looped through the characters present in the <kbd>Introduction</kbd>, <kbd>In</kbd>, and <kbd>C#</kbd><span> </span><span>strings</span><span>. Hence, using</span> <kbd>SelectMany</kbd><span>, we can perform actions using fewer statements than it would take otherwise. </span></p>
<p>In the next section, we will look at the <kbd>Join</kbd> operator, which helps us join two collections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The join operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>join</kbd> operators in LINQ help us join two collections that could be linked to each other by a common attribute. Refer to the following code example, which will provide a better explanation of this. Consider that we have two class objects, one representing <kbd>ClassDetail</kbd> and another representing <kbd>Students</kbd> that are studying in the class:</p>
<pre>public class Student<br/>{<br/>     public int rollNum { get; set; }<br/>     public string Name { get; set; }<br/>     public string classID { get; set; }<br/>}<br/>public class ClassDetail<br/>{<br/>     public string classID { get; set; }<br/>     public string className { get; set; }<br/>}</pre>
<p>Please note that in the <kbd>ClassDetail</kbd> <span>class</span><span>, we have details specific to the class in itself such as</span> <kbd>ClassID</kbd> <span>and</span> <kbd>ClassName</kbd><span>. In the</span> <kbd>Student</kbd> <span>class</span><span>, we have details specific to the student such as</span> <kbd>rollNum</kbd><span>,</span> <kbd>Name</kbd><span>, and</span> <kbd>ClassID</kbd><span>. In the</span> <kbd>Student</kbd> <span>class</span><span>,</span> <kbd>ClassID</kbd> <span>attribute</span> <span>refers to the class in which the student is currently studying. We will use this attribute to link the collections of</span> <kbd>ClassDetail</kbd> <span>and</span> <kbd>Student</kbd><span>.</span></p>
<p>The following code indicates how we make a join between the two collection items of <kbd>Student</kbd> and <kbd>Class</kbd>:</p>
<pre> List&lt;ClassDetail&gt; classNames = new List&lt;ClassDetail&gt;();<br/> classNames.Add(new ClassDetail { classID = "1", className = "First Standard" });<br/> classNames.Add(new ClassDetail { classID = "2", className = "Second Standard" });<br/> classNames.Add(new ClassDetail { classID = "3", className = "Third Standard" });<br/> List&lt;Student&gt; students = new List&lt;Student&gt;();<br/> students.Add(new Student { rollNum = 1, classID = "1", Name = "Sia Bhalla" });<br/> students.Add(new Student { rollNum = 2, classID = "2", Name = "James Donohoe" });<br/> students.Add(new Student { rollNum = 3, classID = "1", Name = "Myra Thareja" });<br/> var list = (from s in students<br/> join d in classNames on s.classID equals d.classID<br/> select new<br/> {<br/>     StudentName = s.Name,<br/>     ClassName = d.className<br/> });<br/> foreach (var e in list)<br/> {<br/>     Console.WriteLine("Student Name = {0} , Class Name = {1}", e.StudentName, e.ClassName);<br/> }</pre>
<p>In the preceding code, we have created two collections lists, one each of <kbd>Student</kbd> and <kbd>ClassDetail</kbd>. Then, using a <kbd>join</kbd> operator, we are combining the two lists based on a common attribute, <kbd>ClassID</kbd>. In the resultant items, we are then saving the name of the student and the name of the class. If the code is executed, we will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b3655d04-9042-4671-a052-d2831b55f665.png" style=""/></div>
<p>In the next section, we will look at the <kbd>orderby</kbd><span> </span><span>operator</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The orderby operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>orderby</kbd> operator is used to sort your data in ascending or descending order. The following code shows how to sort the data in descending order:</p>
<pre>int[] dataElements = { 8, 11, 6, 3, 9 };<br/>var resultOrder = from dataElement in dataElements<br/>                  where dataElement &gt; 5<br/>                  orderby dataElement descending<br/>                  select dataElement;<br/>Console.WriteLine(string.Join(", ", resultOrder));</pre>
<p>In the preceding code, we have declared an array of integers. Now, from this array, we select all numbers that are greater than <kbd>5</kbd>. After selecting them, we sort them in descending order using the <kbd>orderby</kbd> clause. Finally, we print them. The following is the output of the program when it's executed:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9c8af6ae-a551-4b7c-93f6-f33272e25912.png" style=""/></div>
<p>Note that, in the preceding output, the numbers are in descending order and all are greater than <kbd>5</kbd>. In the next section, we will look at the <kbd>Average</kbd> operator in LINQ.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Average</h1>
                </header>
            
            <article>
                
<p>In LINQ, we sometimes need to calculate the <kbd>Average</kbd> value of any numeric item present in the collection. To execute this operation, we can use the <kbd>Average</kbd> operator. Let's go through the following code example to see how it works. Let's assume we have the following class:</p>
<pre> public class Student<br/> {<br/>     public int rollNum { get; set; }<br/>     public string Name { get; set; }<br/>     public string classID { get; set; }<br/>     public int age { get; set; }<br/> }</pre>
<p>Now, we have created the following objects for the student class:</p>
<pre>List&lt;Student&gt; students = new List&lt;Student&gt;();<br/>students.Add(new Student { rollNum = 1, classID = "1", Name = "Sia Bhalla", age = 1 });<br/>students.Add(new Student { rollNum = 2, classID = "2", Name = "James Donohoe", age = 35 });<br/>students.Add(new Student { rollNum = 3, classID = "1", Name = "Myra Thareja", age = 8 }); </pre>
<p>To calculate the average age of the students, we can use the following code statement:</p>
<pre>var avg = students.Average(s =&gt; s.age); </pre>
<p>If we execute the code, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e1a52ae2-a84b-44db-aefd-c08ebcb570fc.png" style=""/></div>
<p>In the next section, we will look at the <kbd>GroupBy</kbd><span> </span><span>operator</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GroupBy</h1>
                </header>
            
            <article>
                
<p>We use the <kbd>GroupBy</kbd> clause in LINQ when we need to group elements based upon some key value. Each group is represented by a respective key and a collection of grouped elements. </p>
<p>To explain this operator, we will consider the same <kbd>Class</kbd> and <kbd>Student</kbd> example we have been discussing throughout this chapter. Let's consider a scenario wherein we need to group students based upon the classes they are currently enrolled in. </p>
<p>To recap, the following is the structure of the <kbd>Student</kbd> class:</p>
<pre>public class Student<br/>{<br/>     public int rollNum { get; set; }<br/>     public string Name { get; set; }<br/>     public string classID { get; set; }<br/>     public int age { get; set; }<br/>}</pre>
<p>Let's assume that we have the following objects in the <kbd>Student</kbd> class:</p>
<pre>List&lt;Student&gt; students = new List&lt;Student&gt;();<br/>students.Add(new Student { rollNum = 1, classID = "1", Name = "Sia Bhalla", age = 1 });<br/>students.Add(new Student { rollNum = 2, classID = "2", Name = "James Donohoe", age = 35 });<br/>students.Add(new Student { rollNum = 3, classID = "1", Name = "Myra Thareja", age = 8 });<br/>students.Add(new Student { rollNum = 4, classID = "3", Name = "Simaranjit Bhalla", age = 33 });<br/>students.Add(new Student { rollNum = 5, classID = "3", Name = "Jimmy Bhalla", age = 33 });<br/>students.Add(new Student { rollNum = 6, classID = "2", Name = "Misha Thareja", age = 35 });</pre>
<p>To group the students in terms of class ID, we use the following code:</p>
<pre> List&lt;Student&gt; students = new List&lt;Student&gt;();<br/> students.Add(new Student { rollNum = 1, classID = "1", Name = "Sia Bhalla", age = 1 });<br/> students.Add(new Student { rollNum = 2, classID = "2", Name = "James Donohoe", age = 35 });<br/> students.Add(new Student { rollNum = 3, classID = "1", Name = "Myra Thareja", age = 8 });<br/> students.Add(new Student { rollNum = 4, classID = "3", Name = "Simaranjit Bhalla", age = 33 });<br/> students.Add(new Student { rollNum = 5, classID = "3", Name = "Jimmy Bhalla", age = 33 });<br/> students.Add(new Student { rollNum = 6, classID = "2", Name = "Misha Thareja", age = 35 });<br/> var groupedResult = from s in students<br/> group s by s.classID;<br/> //iterate each group <br/> foreach (var classGroup in groupedResult)<br/> {<br/>     Console.WriteLine("Class Group: {0}", classGroup.Key); <br/>     foreach (Student s in classGroup) <br/>     Console.WriteLine("Student Name: {0}", s.Name);<br/> }</pre>
<p>In the preceding code, we have created six objects of student class and are then trying to group them by <kbd>ClassID</kbd>. After the grouping is complete, we are looping through the groups that have been created. We are printing <kbd>Key</kbd>, which is, in this case, the class ID and the name of the student. </p>
<p>If we execute the code, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/276152f8-54ae-4431-827e-238aa2542df6.png" style=""/></div>
<p>In the preceding code, the students are grouped with different classes. It shows the different students present in each class. </p>
<p>With this, we have seen how operators work in LINQ. In the next section, we will look at the behind-the-scenes interfaces that make LINQ queries possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding LINQ behind the scenes</h1>
                </header>
            
            <article>
                
<p>Now that we have a fair understanding of LINQ queries, let's consider a scenario in which we need to alter the way LINQ works. For the sake of explanation, let's consider a scenario in which we need to change the built-in implementation of the <kbd>Where</kbd> clause in the query.</p>
<p>To do that, we first need to understand how the <kbd>Where</kbd> clause works in LINQ queries. We can do this by looking at the definition of the <kbd>Where</kbd> clause in Visual Studio. <span>The following </span>is how the definition of the <kbd>Where</kbd> clause would appear:</p>
<pre>public static IEnumerable&lt;TSource&gt; Where(<br/>    this IEnumerable&lt;TSource&gt; source,<br/>    Func&lt;TSource, bool&gt; predicate)</pre>
<p>Now, to create our own implementation of the <kbd>Where</kbd> clause, we will need to create an extension method with the same signature.</p>
<p>Once this is done, we can remove the <kbd>using</kbd> statement for <kbd>System.Linq</kbd> in the respective class and, instead, use our own method. <span>The following </span>is the complete code in which we have altered the built-in implementation of the <kbd>Where</kbd> clause without its own custom implementation:</p>
<pre>public static class LinqExtensions<br/>{<br/>    public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(<br/>        this IEnumerable&lt;TSource&gt; source,<br/>        Func&lt;TSource, bool&gt; predicate)<br/>    {<br/>        foreach (TSource item in source)<br/>        {<br/>            if (predicate(item))<br/>            {<br/>                yield return item;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>Please note that in the preceding example, we have used the <kbd>Yield</kbd><span> </span><span>keyword</span><span>. The</span> <kbd>Yield</kbd><span> </span><span>keyword</span><span> </span><span>was introduced in C# in 2.0. Using this keyword, the execution will basically remember the item that was returned from the previous execution of the</span> <kbd>Where</kbd> <span>function and will return the next item in the iteration.</span></p>
<p>This is particularly important when we working using LINQ queries on data providers such as SQL. Due to the usage of <kbd>Yield</kbd>, the query won't be sent to the database until the result is iterated over. However, this would also mean if we execute the query multiple times, each time it will hit the database and hence have a negative effect on the performance of the system. </p>
<p>In the next section, we will look at how LINQ queries are used on an XML data source.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using LINQ to XML</h1>
                </header>
            
            <article>
                
<p>While working with XML files, we generally use the <kbd>XmlWriter</kbd>, <kbd>XmlReader</kbd>, and <kbd>XmlDocument</kbd> classes. Apart from these classes, we can also LINQ to execute operations on the XML file. One of the main advantages of using LINQ to execute XML operations is that we can use a consistent query experience that LINQ provides with other data providers. </p>
<p>Using LINQ, we can create, edit, and parse XML files. Apart from providing a consistent query experience, LINQ also helps us in writing much more powerful queries that are more compact than other XML classes. Let's look at the operations that we can perform on XML and understand how we can execute them via LINQ.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Querying XML</h1>
                </header>
            
            <article>
                
<p>While using LINQ on an XML file, we use the <kbd>XDocument</kbd> class to load the XML as a string in the memory.</p>
<p>Until LINQ was introduced in .NET, developers used to work with the <kbd>XmlDocument</kbd> <span>helper class to</span> <span>do operations on the XML file.</span> <kbd>XDocument</kbd> <span>is a similar helper class that we use in LINQ for doing operations on the XML file. Using LINQ for such</span> <kbd>xml</kbd> <span>operations not only helps to provide a consistent query experience but also increases the overall performance of the application. The </span><kbd>XDocument</kbd> <span>class contains the following elements:</span></p>
<ul>
<li><kbd>XDeclaration</kbd>: This component signifies information in regards to <kbd>XmlDeclaration</kbd> and contains information such as XML version and the encoding used.</li>
<li><kbd>XElement</kbd>: This component signifies the root node or object present in the XML class.</li>
<li><kbd>XProcessingInstruction</kbd>: This component contains relevant information for the application that will ultimately be consuming the XML file.</li>
<li><kbd>XComments</kbd>: This component contains any additional information apart from the <kbd>XElement</kbd> component that we want to add in the XML class.</li>
</ul>
<p>All of the preceding components derive from a common abstract class, <kbd>XNode</kbd>, and any operation executed using <kbd>XDocument</kbd> is based upon this <kbd>XNode</kbd><span> </span><span>class</span>. While working with <kbd>XDocument</kbd>, w<span>e can use</span> <kbd>XNode</kbd> <span>in several ways. For example, using </span><span>the <kbd>XDocument.Nodes</kbd></span><span> </span><span>syntax</span><span>, we can loop through all of the nodes present in the XML file.</span></p>
<p><span>Similarly, if we have a scenario to search for a specific element or node, we can also use the <kbd>XDocument.Descendants</kbd> or <kbd>XDocument.Elements</kbd></span><span> </span><span>syntax</span><span>. Using</span> <kbd>XNode</kbd><span>, we can also directly reach a particular element or a node that's present in the XML file. This can greatly enhance the performance of the application as we no longer need to loop through the entire XML file rather than just straightway jumping to the required node.</span></p>
<div class="packt_infobox">Please note that in an XML file, attributes are not considered nodes; instead, they are key-value pairs that belong to a node.</div>
<p>The following code sample shows a sample XML containing a set of students who all have the attributes of <kbd>Name</kbd>, <kbd>rollNum</kbd>, and contact information:</p>
<pre>String xml = @"&lt;?xml version=""1.0"" encoding=""utf-8"" ?&gt;<br/>                &lt;Students&gt;<br/>                    &lt;Student Name=""Simaranjit"" rollNum=""1""&gt;<br/>                        &lt;contactdetails&gt;<br/>                            &lt;emailaddress&gt;sbhalla@gmail.com&lt;/emailaddress&gt;<br/>                            &lt;phoneNumber&gt;0416274824&lt;/phoneNumber&gt;<br/>                        &lt;/contactdetails&gt;<br/>                    &lt;/Student&gt;<br/>                    &lt;Student Name=""James"" rollNum=""2""&gt;<br/>                        &lt;contactdetails&gt;<br/>                            &lt;emailaddress&gt;jamesdonohoe@gmail.com&lt;/emailaddress&gt;<br/>                        &lt;/contactdetails&gt;<br/>                     &lt;/Student&gt;<br/>                 &lt;/Students&gt;";</pre>
<p>Suppose we need to loop through all of the student records that are present in this XML file. Using LINQ, we can execute queries that would load all of the names of the students present in the XML file as a string. To use LINQ on an XML file, we first need to add a reference to the <kbd>System.Xml.Linq</kbd><span> </span><span>namespace</span><span>. The following code syntax shows how we can use the</span> <kbd>Descendants</kbd> <span>method and the</span> <kbd>Attribute</kbd> <span>method to load this data:</span></p>
<pre>XDocument doc = XDocument.Parse(xml);<br/>IEnumerable&lt;string&gt; studentNames = from p in doc.Descendants("Student")<br/>                                  select (string)p.Attribute("Name")<br/>                                  + " " + (string)p.Attribute("rollNum");<br/>foreach (string s in studentNames)<br/>{<br/>         Console.WriteLine(s);<br/>}</pre>
<p>The following is the output of the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5d00938a-7891-4bbd-a387-3d86b3bd4f86.png" style=""/></div>
<p>In the preceding program, using a LINQ query, we are retrieving all of the child nodes present in the <kbd>Student</kbd> descendant in the XML file. Once we have retrieved all of the nodes, we are selecting the values in the attribute nodes, <kbd>Name</kbd> and <kbd>rollNum</kbd>. To select the respective element present in the node, we are using the <kbd>.Attribute</kbd><span> </span><span>syntax</span><span>. The method returns an instance of an </span><kbd>XAttribute</kbd> <span>object. Even though</span> <kbd>XAttribute</kbd> <span>has a</span> <kbd>Value</kbd> <span>property of the string</span><span> </span><span>type</span><span>, we can always use explicit operators to cast the value to other data types in C#.</span></p>
<p>While using LINQ on XML files, we can also use operators such as <kbd>Where</kbd> and <kbd>OrderBy</kbd> in the queries. The following code syntax shows how we can filter all students to only those with a phone number:</p>
<pre>XDocument docFil = XDocument.Parse(xml);<br/>IEnumerable&lt;string&gt; studentNamesFilter = from p in docFil.Descendants("Student")<br/>                                         where p.Descendants("phoneNumber").Any()<br/>                                         select (string)p.Attribute("Name")<br/>                                         + " " + (string)p.Attribute("rollNum");<br/>foreach (string s in studentNamesFilter)<br/>{<br/>         Console.WriteLine(s);<br/>}</pre>
<p>In the preceding code, we have added a <kbd>where</kbd> clause, in which we have added a condition on the phone number. Note that, in the XML string, only one child node has a phone number. When the preceding code is executed, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d016f86a-f41b-43b5-915b-b0387515628e.png" style=""/></div>
<p>In the preceding XML file, only one student record has a phone number, hence it's filtering out that particular record. In the next section, we will look at how we can create an XML file using LINQ.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating XML</h1>
                </header>
            
            <article>
                
<p>Apart from querying XML, we can also use LINQ to create XML files. To do this, we can use the <kbd>XElement</kbd><span> </span><span>class</span><span>. There is an</span> <kbd>ADD</kbd> <span>method available in the class that we can use to construct an XML file. The following code syntax shows how we can create some XML:</span></p>
<pre>XElement root = new XElement("Student",<br/>new List&lt;XElement&gt;<br/>{<br/>     new XElement("Marks"),<br/>     new XElement("Attendance")<br/>},<br/>new XAttribute("Roll Number", 1));<br/>root.Save("StudentTestResults.xml");</pre>
<p>In the preceding code, we have defined an element by the name <kbd>Student</kbd>. In the root element, we have added a child node of <kbd>Marks</kbd> to represent the marks the student has earned. We have also added a child node of <kbd>Attendance</kbd> to represent the attendance of <kbd>Student</kbd>. Finally, we have added a <kbd>"Roll Number"</kbd><span> </span><span>attribute </span><span>to represent the unique identifier of</span> <kbd>Student</kbd><span>. </span></p>
<p>Once the code is executed, we will observe that it has created an XML file with the following structure:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>    &lt;Student RollNumber="1"&gt;<br/>         &lt;Marks /&gt;<br/>         &lt;Attendance /&gt;<br/>    &lt;/Student&gt; </pre>
<p>In the next section, we will look at how we can use LINQ to update XML. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating XML</h1>
                </header>
            
            <article>
                
<p>In this section, we will look at how we can modify an XML file using LINQ. With LINQ, we can modify the XML file by doing the following:</p>
<ul>
<li><span>Removing existing nodes in the XML file</span></li>
<li><span>Inserting new nodes in the XML file</span></li>
<li><span>Changing the content of existing nodes</span></li>
<li><span>Saving the XML file back once the operation finishes</span></li>
</ul>
<p>For the sake of explanation, we will work on the same XML file that we created in the previous section. We will be writing a code that would add a mobile number element for all of the students. We will add this element in the node element of <kbd>ContactDetails</kbd>:</p>
<pre>XElement rootUpd = XElement.Parse(xml);<br/>foreach (XElement p in rootUpd.Descendants("Student"))<br/>{<br/>     XElement contactDetails = p.Element("contactdetails");<br/>     contactDetails.Add(new XElement("MobileNumber", "12345678")); <br/>}<br/>rootUpd.Save("testupd.xml"); </pre>
<p>In the preceding code, we are looping through all <kbd>Students</kbd> present in the XML and are then looping through the child element of <kbd>ChildDetails</kbd>. In that node, we are adding the element of <kbd>MobileNumber</kbd>. Once the code is executed, we will get the following output in the XML file:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;Students&gt;<br/>     &lt;Student Name="Simaranjit" rollNum="1"&gt;<br/>         &lt;contactdetails&gt;<br/>             &lt;emailaddress&gt;sbhalla@gmail.com&lt;/emailaddress&gt;<br/>             &lt;phoneNumber&gt;0416274824&lt;/phoneNumber&gt;<br/>             &lt;MobileNumber&gt;12345678&lt;/MobileNumber&gt;<br/>         &lt;/contactdetails&gt;<br/>     &lt;/Student&gt;<br/>     &lt;Student Name="James" rollNum="2"&gt;<br/>         &lt;contactdetails&gt;<br/>             &lt;emailaddress&gt;jamesdonohoe@gmail.com&lt;/emailaddress&gt;<br/>             &lt;MobileNumber&gt;12345678&lt;/MobileNumber&gt;<br/>             &lt;/contactdetails&gt;<br/>     &lt;/Student&gt;<br/>&lt;/Students&gt;</pre>
<p>In the preceding XML, we have added a <kbd>MobileNumber</kbd><span> </span><span>element </span><span>in the</span> <kbd>ContactDetails</kbd> <span>node of</span> <kbd>Student</kbd><span>. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary </h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how we can use LINQ to write consistent queries against multiple data sources. We learned about the different components of a LINQ query and understood how we can construct them in a query. We then looked at the features in a C# language that allows us to work with LINQ such as implicit typing, object initialization syntax, lambda expressions, extension methods, and anonymous types. </p>
<p>We then looked at the different operators available in LINQ such as <kbd>Select</kbd>, <kbd>SelectMany</kbd>, <kbd>Where</kbd>, <kbd>join</kbd>, and <kbd>Average</kbd>. Using code scenarios, we looked at different situations in which we should use each of them. </p>
<p>We then looked at the different interfaces that LINQ queries are based on. Finally, we looked at how we can use LINQ queries to perform an operation on XML files. Using code examples, we looked at how we perform, create, update, and query operations on LINQ.</p>
<p>In the next chapter, we will look at the serialization and deserialization of data. We will look at the different collection items, such as arrays, lists, and dictionaries, which are available in C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which LINQ code can be used to extract customers that have made sales of over 5,000 dollars and whose name starts with A?
<ol type="a">
<li><kbd><span class="kw1">FROM</span> p <span class="kw1">IN</span> db<span class="sy0">.</span>Purchases<br/></kbd> <kbd><span class="kw1">WHERE</span> p<span class="sy0">.</span>Customer<span class="sy0">.Name.StartsWith("A")</span><br/></kbd> <kbd><span class="kw1">WHERE</span> p<span class="sy0">.</span>PurchaseItems<span class="sy0">.</span>Sum <span class="br0">(</span>pi <span class="sy0">=&gt;</span> pi<span class="sy0">.</span>SaleAmount<span class="br0">)</span> = 5<span class="nu0">000</span><br/></kbd> <kbd><span class="kw1">SELECT</span> p</kbd></li>
<li><kbd><span class="kw1">FROM</span> p <span class="kw1">IN</span> db<span class="sy0">.</span>Purchases<br/></kbd> <kbd><span class="kw1">WHERE</span> p<span class="sy0">.</span>Customer<span class="sy0">.Name.StartsWith("A")</span><br/></kbd> <kbd><span class="kw1">WHERE</span> p<span class="sy0">.</span>PurchaseItems<span class="sy0">.</span>Sum <span class="br0">(</span>pi <span class="sy0">=&gt;</span> pi<span class="sy0">.</span>SaleAmount<span class="br0">)</span> &gt; 5<span class="nu0">000</span><br/></kbd> <kbd><span class="kw1">SELECT</span> p</kbd></li>
<li><kbd><span class="kw1">FROM</span> p <span class="kw1">IN</span> db<span class="sy0">.</span>Purchases<br/></kbd> <kbd><span class="kw1">WHERE</span> p<span class="sy0">.</span>Customer<span class="sy0">.Name.EndsWith("A")<br/></span></kbd> <kbd><span class="kw1">WHERE</span> p<span class="sy0">.</span>PurchaseItems<span class="sy0">.</span>Sum <span class="br0">(</span>pi <span class="sy0">=&gt;</span> pi<span class="sy0">.</span>SaleAmount<span class="br0">)</span> &lt; <span class="nu0">1000</span><br/></kbd><kbd><span class="kw1">SELECT</span> p</kbd></li>
<li><kbd><span class="kw1">FROM</span> p <span class="kw1">IN</span> db<span class="sy0">.</span>Purchases<br/></kbd><kbd><span class="kw1">WHERE</span> p<span class="sy0">.</span>Customer<span class="sy0">.Name.StartsWith("A")</span><br/></kbd><kbd><span class="kw1">WHERE</span> p<span class="sy0">.</span>PurchaseItems<span class="sy0">.</span>Sum <span class="br0">(</span>pi <span class="sy0">=&gt;</span> pi<span class="sy0">.</span>SaleAmount<span class="br0">)</span> &gt;= <span class="nu0">1000</span><br/></kbd><kbd><span class="kw1">SELECT</span> p</kbd></li>
</ol>
</li>
</ol>
<ol start="2">
<li>Which of the following statements in regards to LINQ is incorrect?
<ol type="a">
<li>Compared to languages such as SQL, LINQ is more complex to code.</li>
<li>LINQ supports <kbd>Join</kbd>.</li>
<li>LINQ can be used to do operations on XML files.</li>
<li>All of the above.</li>
</ol>
</li>
</ol>
<ol start="3">
<li>Which of the following supports LINQ queries?
<ol type="a">
<li>Object Collection</li>
<li>Entity Framework</li>
<li>XML Document</li>
<li>All of the above</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Answers</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>b</strong></li>
<li><strong>a</strong></li>
<li><strong>d</strong></li>
</ol>


            </article>

            
        </section>
    </body></html>