- en: '*Chapter 8*: Testing in Solution Architecture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about how to secure an **ASP.NET** web solution.
    We also highlighted some key security recommendations to protect our web **application
    programming interface** (**API**), along with security best practices when it
    comes to hosting on **Azure**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will become familiar with the most common testing types
    you need to know, and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting key testing principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the main types of software testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring testing in Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned about the various types of
    software testing that we can apply to test our software solution, with the aim
    of finding errors and then fixing them. We will also learn how to check whether
    the software works properly and whether it meets the requirements defined during
    the early stages of a project. We will also explore the testing mechanism offered
    by **Azure DevOps**.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to the next section, let's take a look at the key principles of software
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting key testing principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main objective of conducting software testing is to eliminate possible bugs
    and to enhance the overall quality of the software in terms of many aspects, such
    as performance, **user experience** (**UX**), and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before starting any testing activities, there must be some guidelines or
    principles in place to make sure that the outcome of these activities is aligned
    with the main objectives of testing. Here, in this section, we will highlight
    some of the key principles of software testing that we need to consider in our
    software solution, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All test cases should be prepared based on customer requirements; otherwise,
    we will be testing against the wrong requirements. Each feature or function in
    a system should be tested with one or multiple test cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some types of software testing such as **performance testing** and **acceptance
    testing** should be performed by **subject-matter experts** (**SMEs**) such as
    **quality assurance** (**QA**) engineers or senior developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan to start testing the basic functionalities first, then extend to testing
    the advanced features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to start testing at the early stages of a project as, in this
    case, the cost of fixing defects is way less than when testing during later stages
    of the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defect clustering** is based on the **Pareto** principle, which states that
    80% of defects are caused by 20% of the system features. This means that during
    testing, a large number of defects detected are related to a small number of features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not recommended to repeat the same test cases over and over because, after
    a certain time, we won't find any new defects. The best practice is to adjust
    the test cases, with the aim of finding new defects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing is context-dependent, which means we need to apply specific methodologies
    and techniques based on the context of the system we are testing. For instance,
    testing a **content management system** (**CMS**) is different from testing an
    **iOS** e-commerce app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start exploring the various types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the main types of software testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the major reasons for failure in software projects is a lack of product
    quality. Software testing is an integral part of the project life cycle, helping
    to ensure that a product is error-/defect-free and, in the same way, verifying
    the functionalities implemented to make sure they match the requirements defined
    with the client. There are two main categories of software testing, outlined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional testing**: This is used to validate each feature and function
    of the system to verify all functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-functional testing**: This is used to validate non-functional aspects
    of the system, such as performance, usability, and compliance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a diagram showing the different types of testing we will discuss in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Types of testing](img/Figure_8.01_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Types of testing'
  prefs: []
  type: TYPE_NORMAL
- en: We will look at all the different types of testing shown in the preceding diagram
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Unit testing** is a type of testing performed to test every individual function
    or module of a system. Usually, it is performed by .NET developers who are working
    on a product because it requires some coding skills. That''s why it is considered
    a low-level type of testing since it is targeting the behavior of the code only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram showing the unit-test level as an integral part of the entire
    testing life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Unit-test level in the testing life cycle](img/Figure_8.02_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Unit-test level in the testing life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, unit testing represents the first type of testing
    that should be conducted before starting any other testing activity, as the cost
    of fixing defects becomes higher at later levels of testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests allow us to fix defects at the early stages of the development cycle.
    This will save time and costs to fix the same defects later on during the acceptance-testing
    stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps to document the source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the developers to refactor the code and reuse available functions
    to eliminate any repetition in the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing is essential for testing dependencies if we are making changes
    to the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps reduce code complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more details on automating unit tests, see the list of testing tools recommended
    by Microsoft: [https://docs.microsoft.com/en-us/dotnet/core/testing/#testing-tools.](https://docs.microsoft.com/en-us/dotnet/core/testing/#testing-tools'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Integration testing** is intended to test two or more modules of a solution
    to verify whether they work well together. For example, it can involve testing
    the behavior of the integration between the system we are building and **Azure
    Active Directory**, to verify the authentication mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: Another example of this type of testing is when we need to verify the interaction
    between our system and the database layer. Integration testing should be performed
    after completing the development of two modules that are subject to the testing
    we are conducting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we are showing that integration testing should target
    only the integration part between **Module A** and **Module B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Integration testing for two modules](img/Figure_8.03_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Integration testing for two modules'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of integration testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing helps to ensure that the integrated modules are working
    properly as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows for simulating the transition between various modules in the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also helps to detect errors that may occur in the interaction of the modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is normal to test new changes that we perform on a system, such as modifying
    an existing feature or adding a new one. However, this is not enough, because
    in most cases, the code we change or add will have a direct or indirect impact
    on other functionalities, and probably on other features in the system too. This
    is why we need to conduct **regression testing** to make sure that the new code
    didn't cause any new defects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we are showing the three main steps of regression
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Main steps of regression testing](img/Figure_8.04_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Main steps of regression testing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of regression testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Regression testing ensures that existing features remain untouched in case of
    a change to a module or code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated regression testing helps implement **continuous integration** (**CI**),
    which saves time and costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows for the detection of defects caused by changes in the system environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increases client trust and satisfaction, which may lead to expanding business.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smoke testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Smoke testing** is a technique that was adopted in the plumbing industry,
    where they usually used white smoke to identify any leaks in pipes.'
  prefs: []
  type: TYPE_NORMAL
- en: Today, the concept of smoke testing is used in software development to verify
    the basic functionality of a build. If a test fails, the build is considered unstable,
    and the system is not ready to perform any other type of testing activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the main stages of smoke testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: The life cycle of smoke testing](img/Figure_8.05_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: The life cycle of smoke testing'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see that the testing procedure starts by creating
    a new build with a version number. After that, we need to prioritize the test
    cases and decide what to test exactly to certify the new build before moving to
    functional testing. If the smoke testing fails, then we need to fix the defects
    and start over by creating a new build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of smoke testing:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps to detect show-stopping issues in the early stages before starting
    any other type of testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It improves the efficiency of the QA team by detecting defects that may take
    longer to be detected if they want to run functional testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**End-to-end** (**E2E**) **testing** is considered the full-fledged testing
    of an application. It is typically convenient to test the functionalities of the
    entire system; it is important to replicate the production environment to conduct
    this type of testing, and the testing scenarios should imitate the user behavior.
    The main goal of this type of testing is to certify that the different user flows
    are functioning properly with no errors and as per the requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we show the three main steps of the E2E testing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: The three main steps of E2E testing](img/Figure_8.06_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: The three main steps of E2E testing'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the user functions represent the actions performed
    in a particular functionality in the system, and the conditions represent the
    various input data and sequences that can be applied to each user function. As
    for the test cases, these are created based on the previous two actions—that is,
    the user functions along with the conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some major benefits of E2E testing:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps ensure complete readiness and the health of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to test the full system from a user's perspective.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps to test real-life scenarios that can be applied by end users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **user interface** (**UI**) speaks for itself. **UI testing** is performed
    to test an application's **graphical user interface** (**GUI**), with the aim
    of making sure that the UI of the application is developed as per the requirements
    and is user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see that the business layer and the data layer
    can be tested using unit tests. As for the UI, the only way to test it is through
    UI testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: UI testing](img/Figure_8.07_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: UI testing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some major benefits of UI testing:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps to check the alignment of UI elements, along with checking the font
    style, the color, and the clarity of the text displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to check whether a product is rendering correctly on all devices
    and screens that are supposed to be supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps to check error messages, along with warning messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Acceptance testing** (also known as **user acceptance testing**, or **UAT**)
    is considered the last phase of testing and is usually performed by the key users
    of the client to verify that all business requirements have been developed and
    that the system is working properly and efficiently as expected by the end users.
    Typically, acceptance testing is conducted based on test cases that are generated
    from user cases prepared during the analysis phase of a project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we show that UAT is the last testing phase before
    moving to a production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: UAT in the project life cycle](img/Figure_8.08_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: UAT in the project life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of UAT:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps to validate that all business requirements defined at the beginning
    of a project are correctly implemented and working properly without any errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows for the fixing of detected defects during development rather than
    in a production environment, which is less costly, especially in the case of solutions
    with online payment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps to increase users' trust in the new system before the go-live stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Performance testing** is non-functional testing that is often used to check
    whether a system is working properly as per the performance requirements defined
    by the client and the standards.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following four main elements are considered when carrying out performance
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bottlenecks** are major issues that bring down a system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **load time** needed to load a page or a form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **response time** of triggering an action or completing a process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability** is the ability of a system to handle a large number of requests
    without crashing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows us the four main elements of carrying out performance
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9: Performance-testing elements](img/Figure_8.09_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Performance-testing elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of performance testing:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps to measure the response time, accuracy, and stability of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows for the detection of issues that reduce the response time of the application
    or the overall hardware usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps improve the load time of pages and increases user satisfaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stress testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Stress testing** is a type of non-functional testing that certifies the stability
    and reliability of a system. The main target of stress testing is to measure the
    strength and error-handling capabilities of the system when it is under an extremely
    heavy load of requests that is way beyond the normal operating situation of the
    system. Its purpose is to understand how the system behaves under this heavy load.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes the steps of stress testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: Stress-testing main steps](img/Figure_8.10_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Stress-testing main steps'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the stress-testing process starts by planning and deciding on the
    test cases. After that, we should create scripts and execute them in an automated
    process. The results of the stress test should be analyzed carefully to identify
    the root cause of any issues. At the end, we need to fix issues by optimizing
    the code and then rerunning the whole stress-testing process until we have a stable
    build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of stress testing:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows us to check and handle error messages that may occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps to check whether the data was saved correctly before any failure was
    caused by a heavy load of requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compliance testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Compliance testing** (also known as **conformance testing**) is a type of
    audit-testing technique usually performed to verify whether a product meets a
    set of external and internal standards before deciding whether the system is ready
    to be released or not.'
  prefs: []
  type: TYPE_NORMAL
- en: The internal standards are typically set by the organization. For example, a
    website should be designed for various devices and screens, therefore it should
    provide a responsive UI.
  prefs: []
  type: TYPE_NORMAL
- en: As for external standards, these are regulations that are set by a worldwide
    consortium or a third-party organization that specializes in this type of testing.
    An example of an external standard is the **General Data Protection Regulation**
    (**GDPR**) or the **Web Content Accessibility Guidelines** (**WCAG**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the main system attributes that are usually assessed
    by compliance testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: System attributes assessed by compliance testing](img/Figure_8.11_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: System attributes assessed by compliance testing'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding diagram, each attribute is contributing to the overall
    compliance of the system. So, let''s get to know each of these attributes, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Robustness**: This shows the ability of a system to function normally in
    the case of disturbance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: This represents the time needed by a system to complete a
    single task. Compliance testing should measure the performance of the main functions
    in the system and certify that they are performing well, based on predefined testing
    criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperability**: This shows the ability of a system to exchange information
    with other third-party systems. Moreover, it shows how well different functions
    in the system are interacting together to complete a process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**: This assesses the interfaces and functionalities provided by
    a system, along with confirming whether the requirements defined at the early
    stages of the project are met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavior of system**: This assesses the behavior of a system with the environment
    in which it is hosted. It also assesses how the system behaves after executing
    every user story defined previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disaster recovery testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **disaster recovery plan** (**DRP**) should be considered for enterprise solutions
    and mission-critical systems. It consists of a set of detailed guidelines and
    strategies that should be implemented to handle unplanned incidents that would
    disrupt the normal operations of a system. A good DRP should enable us to recover
    quickly from disruptive events such as cyber-attacks, power outages, hardware
    outages, or any other incidents. It should ensure the continuity of business processes
    and minimize damage as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: DR testing is the process of certifying a DRP by evaluating each step in the
    process to make sure that it will work as expected when an incident occurs.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have explored the main testing types and techniques, such as unit
    testing, smoke testing, performance testing, and acceptance testing. It is essential
    to know each of these testing types and when to use them to deliver high-quality
    software products. We should ensure that a product meets standards and requirements,
    all the way from coding to business functionalities of the product as a whole.
    Applying different testing types between functional and non-functional tests will
    boost quality, to achieve exceptional results.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to explore the capabilities of test plans
    in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring testing in Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manual testing can be a key testing technique to deliver a great UX and to certify
    a product before the go-live stage. **Azure Test Plans**, along with **Visual
    Studio 2019**, offers the features we need to manage our testing efforts, from
    manual and exploratory testing to load and stress testing.
  prefs: []
  type: TYPE_NORMAL
- en: The starting point is to create a test plan made up of configurations, test
    suites, and test cases that can be broken down into shared test steps, and use
    the parameters that will allow us to repeat a test but with different input data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following link to sign in to Azure DevOps: [https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After successful login, you can see **Test Plans** in the menu on the left
    side, as per the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: Test Plans in Azure DevOps](img/Figure_8.12_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Test Plans in Azure DevOps'
  prefs: []
  type: TYPE_NORMAL
- en: After creating a test plan, we need to set the configurations upon which we
    intend to run our tests—for example, we can specify the operating system and browser
    configurations if we are testing a web application. Test configurations can be
    assigned to an entire test plan or individual test suites, and even test cases.
    If we assigned the configurations to a test plan, this would ensure that all created
    test cases are automatically assigned to those configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on **Test Plans**, a sliding submenu will be opened, showing
    more capabilities where we can create new test plans, set parameters, and modify
    configurations, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13: Configurations under Test Plans](img/Figure_8.13_B17366.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Configurations under Test Plans'
  prefs: []
  type: TYPE_NORMAL
- en: With our test configurations set, we can now start creating test suites, which
    are collections of test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different types of test suites, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static test suite**: This is a logical container where we can add any test
    case we like.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requirement-based test suite**: This is where we associate our test case
    to a work item to define its acceptance criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query-based test suite**: This is where we create a work-item query to select
    which test cases to include. Any test case that meets the query criteria will
    be added automatically to the test suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we define our test suite, we need to start creating a test case and assigning
    it to the test team. Creating a test case is a very straightforward process. The
    main element is the steps to execute in any expected results. Steps that are repeated
    often can be extracted as shared steps to ease test maintenance. After preparing
    the test cases, we are ready to start the test run manually. Note that from the
    **Runs** page, we can review all our previous test runs, along with their results.
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have learned about manual testing in Azure, which has its benefits.
    But when we develop more features and our source code grows in size, testing all
    functionalities manually can become repetitive and time-consuming. Therefore,
    Azure offers us a mechanism to automate our tests in order to eliminate the burden
    of manual testing and to allow QA engineers to focus on delivering better quality
    and an improved **user experience** (**UX**).
  prefs: []
  type: TYPE_NORMAL
- en: With Azure DevOps, we can automate our tests from Azure Test Plans by using
    Azure pipelines. There are many types of testing that we can automate with Azure
    pipelines, such as unit testing, security testing, and code-coverage testing,
    which calculates the percentage of code that's covered by unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key recommendations when using Azure Test Plans for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the testing is serving a purpose and has a positive impact on the
    product, and try not to test for the sake of testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the tests straightforward, focused, and short. Tests should run quickly,
    especially if they are triggered on the build or release of a product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored some key principles that outline fundamental guidelines
    required to conduct proper testing. We also learned about the essential testing
    types that we must know as solution architects. Being aware of each of these testing
    types will help us decide which functional and non-functional tests we should
    apply to ensure high-quality software products and to deliver products that meet
    requirements. In the last section of this chapter, we explored the capabilities
    of test plans in Azure DevOps, along with the key benefits.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig deep into architecting modern web applications
    with **ASP.NET Core** and **Microsoft Azure**.
  prefs: []
  type: TYPE_NORMAL
