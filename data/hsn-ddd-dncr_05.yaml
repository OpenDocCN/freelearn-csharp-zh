- en: Implementing the Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模型
- en: In previous chapters, we went through a different level of knowledge crunching
    and domain analysis. We used EventStorming as our primary tool, so, as a result
    of our efforts, we got plenty of paper rolls, with lots of colorful sticky notes
    on them. But how can we make some working code from it? That is a good question,
    and this is precisely what we will start doing when moving along in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们经历了一个不同层次的知识压缩和领域分析。我们使用EventStorming作为我们的主要工具，因此，作为我们努力的结果，我们得到了大量的纸卷，上面贴满了五颜六色的便利贴。但如何从这些纸卷中生成一些可工作的代码呢？这是一个好问题，这正是我们在本章继续前进时将开始做的事情。
- en: By the end of this chapter, we will have a basis for our domain model implemented
    in code. We will go through different styles of performing the behavior in domain
    entities and also write some tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将有一个基于代码实现的领域模型的基础。我们将探讨在领域实体中执行行为的不同风格，并编写一些测试。
- en: 'The following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将涵盖以下主题：
- en: Create a project for the domain model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为领域模型创建项目
- en: Add domain objects to the new project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将领域对象添加到新项目中
- en: What the entities and value objects are
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体和值对象是什么
- en: How to ensure that the domain model is always in a valid state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保领域模型始终处于有效状态
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter will provide guidelines to do some hands-on work. To follow up
    with that, you will need to have the following tools:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将提供一些实际操作的指南。为了跟进，你需要以下工具：
- en: .NET Core 2.2.203 or higher ([https://www.asp.net/](https://www.asp.net/))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 2.2.203 或更高版本 ([https://www.asp.net/](https://www.asp.net/))
- en: Visual Studio 2017 or higher ([https://www.visualstudio.com/vs/](https://www.visualstudio.com/vs/)),
    or JetBrains Rider ([https://www.jetbrains.com/rider/](https://www.jetbrains.com/rider/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017 或更高版本 ([https://www.visualstudio.com/vs/](https://www.visualstudio.com/vs/))，或
    JetBrains Rider ([https://www.jetbrains.com/rider/](https://www.jetbrains.com/rider/))
- en: There is no particular requirement on a platform since .NET Core, and the tooling
    is available almost everywhere. Throughout this book, I will be using Rider on
    macOS. Initial screenshots will be from Visual Studio 2017 for Windows since most
    readers would be using this IDE. Some dialog boxes vary significantly between
    Visual Studio for Windows, Visual Studio for Mac, and Rider.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于平台没有特别的要求，因为.NET Core和工具几乎无处不在。在整个书中，我将使用macOS上的Rider。初始截图将来自Windows的Visual
    Studio 2017，因为大多数读者都会使用这个IDE。一些对话框在Windows Visual Studio、Visual Studio for Mac和Rider之间差异很大。
- en: I will be using some features of C# 8.0 in the code, so it is necessary to use
    .**NET Core SDK 2.2.203** or higher.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在代码中使用C# 8.0的一些功能，因此需要使用 .**NET Core SDK 2.2.203** 或更高版本。
- en: I assume that you are familiar with the tool that you are using and with the
    .NET Stack in general, so you know how to create projects, build them and execute
    applications in different environments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你熟悉你正在使用的工具以及.NET Stack，因此你知道如何创建项目、构建它们并在不同的环境中执行应用程序。
- en: Starting up the implementation
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始实施
- en: In this section, we will create a new project and add a domain project to it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的项目并向其中添加一个领域项目。
- en: Since we plan to implement a web application, we will consider this from the
    beginning and will use a web application template. We will also add some projects
    to host different parts of our system and tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们计划实现一个Web应用程序，我们将从一开始就考虑这一点，并使用Web应用程序模板。我们还将添加一些项目来托管我们系统的不同部分和测试。
- en: If you aren't familiar with tools for .NET, you can always check Mapt, the extensive
    library of Packt books and video courses, and use materials from there to improve
    your skills. In this book, we assume that readers have an adequate level of knowledge
    of C# and the tools to develop applications using .NET.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉.NET的工具，你总是可以检查Mapt，Packt书籍和视频课程的广泛图书馆，并使用那里的材料来提高你的技能。在这本书中，我们假设读者对C#和用于开发.NET应用程序的工具有足够的了解。
- en: Creating projects
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: We will start with an empty project. You need to create a .NET Core web application
    and don't forget to enable the creation of a Git repository so it can keep a history
    of your changes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个空项目开始。你需要创建一个.NET Core Web应用程序，并确保启用创建Git仓库，以便它可以记录你的更改历史。
- en: We would expect our system to get more substantial, but we start small. Let's
    call the solution `Marketplace`, and our first project would be called just that.
    The type of project to create is an ASP.NET Core Web Application. This project
    is our startup, which will be executed by the .NET runtime. You need to choose
    the  Empty project type for the new Web API project because we won't be using
    Razor or SPA (single page application) templates.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预期我们的系统会变得更加复杂，但我们从简单开始。让我们将解决方案命名为`Marketplace`，我们的第一个项目也将这样命名。要创建的项目类型是ASP.NET
    Core Web应用程序。这个项目是我们的启动项目，将由.NET运行时执行。您需要为新Web API项目选择`Empty`项目类型，因为我们不会使用Razor或SPA（单页应用程序）模板。
- en: We already discussed that the domain model should not have dependencies on infrastructure.
    In general, it should not have references to anything but standard language types,
    itself, and some set of base classes and interfaces, if necessary. To enforce
    this, let's create a separate project where we will put all our domain objects.
    Add one more project to the solution and call it `Marketplace.Domain`. This project
    will not be executed by itself, so the project type should be Class Library (.NET
    Standard) and don't forget to change the framework for it to netstandard2.0 (or
    later). The .NET Standard is the default for class libraries, but feel free to
    use ASP.NET Core target framework as well if you aren't planning to use your library
    in the legacy .NET Framework applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，领域模型不应该依赖于基础设施。一般来说，它不应该引用任何东西，除了标准语言类型、自身以及如果需要的话，一些基类和接口集合。为了强制执行这一点，让我们创建一个单独的项目，我们将把所有的领域对象放在这个项目中。向解决方案中添加一个更多项目，并将其命名为`Marketplace.Domain`。这个项目将不会独立执行，因此项目类型应该是类库
    (.NET Standard)，并且不要忘记将其框架更改为netstandard2.0（或更高版本）。.NET Standard是类库的默认值，但如果您不打算在旧版.NET
    Framework应用程序中使用您的库，也可以自由使用ASP.NET Core目标框架。
- en: Then, we need to add one more project for unit tests. You can do it by adding
    a project to your solution, which would be called `Marketplace.Tests`. The project
    type is a unit test project, and type is xUnit since we will be using xUnit.net
    testing framework for our tests in this book. The xUnit.NET test project is one
    of the default test project templates of the ASP.NET Core SDK. Remember to add
    a reference to the `Marketplace.Domain` project to the test project, since we'll
    be mostly testing our domain code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要添加一个用于单元测试的更多项目。您可以通过向解决方案中添加一个项目来实现，该项目的名称将是`Marketplace.Tests`。项目类型是单元测试项目，类型是xUnit，因为我们将在本书中使用xUnit.net测试框架进行测试。xUnit.NET测试项目是ASP.NET
    Core SDK的默认测试项目模板之一。请记住将`Marketplace.Domain`项目添加到测试项目中，因为我们主要将测试我们的领域代码。
- en: 'The solution should now look like the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案现在应该看起来像以下截图：
- en: '![](img/06b99eb9-e0d9-40d7-bdd8-2b7ea7bed559.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06b99eb9-e0d9-40d7-bdd8-2b7ea7bed559.png)'
- en: A glimpse of the solution structure
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案结构的初步了解
- en: It makes sense to remove the `wwwroot` and `Properties` folders, `Class1.cs`
    and `UnitTest1.cs` files, since we will create new classes from scratch and we
    do not need empty folders to hang around.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有道理移除`wwwroot`和`Properties`文件夹，`Class1.cs`和`UnitTest1.cs`文件，因为我们将从零开始创建新类，我们不需要空文件夹悬挂在那里。
- en: The framework
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架
- en: We will need somewhere to place *this set of base classes and interfaces* mentioned
    in the previous section. We might dispute whether these things are required at
    all. They are not required to start a simple `Hello World` style project, but,
    as we go along, we will need to create more abstractions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一个地方来放置上一节中提到的**这组基类和接口**。我们可能会争论这些是否真的需要。对于启动一个简单的`Hello World`风格的项目来说，它们不是必需的，但随着我们的深入，我们将需要创建更多的抽象。
- en: Also, we will need some components that will allow our domain model to work
    with things like database, message bus, web server, and so on. According to onion
    architecture principles, these are** adapters**. Our project, in the end, will
    need to have a collection of adapters for all pieces of infrastructure that are
    being used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要一些组件，这些组件将允许我们的领域模型与数据库、消息总线、Web服务器等事物一起工作。根据洋葱架构原则，这些是**适配器**。最终，我们的项目将需要有一组适配器，用于所有正在使用的基础设施。
- en: You might rightfully ask—are we going to build a framework? Aren't frameworks
    considered evil and shouldn't they be avoided? Well, we should take everything
    with a grain of salt and having a set of useful abstractions for our domain object
    and infrastructure would greatly help us while moving along. Also, we definitely
    will need to build some of the adapters, and although these can be separated in
    their own libraries, which will connect to our abstractions (hence ports and adapters),
    for the reason of simplicity, we will put most of these things in one project,
    and this project will be called `Marketplace.Framework`. You can choose any other
    name for this project if you don't like the name `Framework`, but in this book,
    we will be referencing it a lot, so I hope you don't get confused.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会合理地问——我们是要构建一个框架吗？框架不是被认为很糟糕，不应该避免吗？嗯，我们应该对一切持保留态度，并且拥有一套对我们领域对象和基础设施有用的抽象将大大帮助我们前进。此外，我们肯定需要构建一些适配器，尽管这些适配器可以分离到它们自己的库中，这些库将连接到我们的抽象（因此是端口和适配器），出于简单起见，我们将把这些东西的大部分放在一个项目中，这个项目将被称为`Marketplace.Framework`。如果你不喜欢`Framework`这个名字，你可以为这个项目选择任何其他名字，但在这本书中，我们将大量引用它，所以我希望你不要感到困惑。
- en: Most of the abstractions and implementations in this framework would be production
    ready by the end of this book. And unlike third-party frameworks, you keep full
    control of what is inside it and how it works, so this should make it a milder
    evil, even if you don't like frameworks at all.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书结束时，这个框架中的大多数抽象和实现都将准备好投入生产。与第三方框架不同，你完全控制着里面的内容及其工作方式，所以即使你根本不喜欢框架，这也应该使其成为一种较温和的“邪恶”。
- en: Many DDD practitioners keep reciting the mantra *you don't need DDD framework*,
    and this is partially true, but people always need to have some baseline for their
    applications to speed up the development. We use the .NET Framework, built by
    Microsoft, rather than creating all these classes from scratch for every project.
    When we get to the point of having a set of useful abstractions and components
    in our framework, we can use it, or something similar to it, in some other project
    and be entirely in control.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多DDD实践者一直在重复“你不需要DDD框架”的咒语，这在某种程度上是正确的，但人们总是需要为他们的应用程序设定一些基准以加快开发速度。我们使用由微软构建的.NET
    Framework，而不是为每个项目从头开始创建所有这些类。当我们拥有框架中一套有用的抽象和组件时，我们可以在其他项目中使用它或类似的东西，并完全控制。
- en: So, to finish up this section, add a class library project to the same solution.
    The framework for it should be netstandard2.0 (or later), just as it was for the
    `Marketplace.Domain` project. Call this new project `Marketplace.Framework`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了完成本节，向同一解决方案添加一个类库项目。它的框架应该是`netstandard2.0`（或更高版本），就像`Marketplace.Domain`项目一样。将这个新项目命名为`Marketplace.Framework`
- en: Transferring the model to code
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型转换为代码
- en: Since we aren't doing a `Hello World` exercise, we won't be using the executable
    project for a while. Instead, we will concentrate on writing things inside the
    domain project, adding some practical classes and interfaces to the framework
    projects, and writing tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不是在进行“Hello World”练习，所以我们暂时不会使用可执行项目。相反，我们将专注于在领域项目中编写内容，向框架项目添加一些实用的类和接口，并编写测试。
- en: First, we need to identify which building blocks our implementation will be
    based on. These building blocks are often referenced as **Domain-Driven Design**
    (**DDD**) tactical patterns, as opposed to DDD strategic patterns. Some even say
    that tactical patterns can be ignored in favor of strategic patterns. Although
    I agree that Ubiquitous Language, Bounded Context, and Context Map are the essential
    parts of DDD, I still believe that some tactical patterns are useful and bring
    clarity and common language for the implementation. This book is not a collection
    of tactical DDD patterns, and relevant concepts will only be used when necessary
    to implement the model.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确定我们的实现将基于哪些构建块。这些构建块通常被称为**领域驱动设计**（**DDD**）战术模式，而不是DDD战略模式。有些人甚至说可以忽略战术模式，而优先考虑战略模式。虽然我同意通用语言、边界上下文和上下文图是DDD的必要部分，但我仍然相信一些战术模式是有用的，并为实现提供了清晰性和共同语言。这本书不是战术DDD模式的集合，相关概念只有在必要时才会用于实现模型。
- en: Entities
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: 'Let''s get back to our EventStorming session and look at part of our model,
    shown as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的EventStorming会话，并查看我们的模型的一部分，如下所示：
- en: '![](img/3376c726-aa18-4964-9d98-ed835ed7cd00.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3376c726-aa18-4964-9d98-ed835ed7cd00.png)'
- en: The core domain modeled with sticky notes
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用便利贴建模的核心领域
- en: There is a repetition in all those commands. Can you see it? All those commands
    are being executed on something that is called a **Classified Ad**. Also, if you
    recall all those conversations with domain experts, our team members frequently
    referred to this term when talking about the business in general, and also about
    the model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些命令中都有重复。你能看到吗？所有这些命令都是在被称为**分类广告**的东西上执行的。此外，如果你还记得与领域专家的所有那些对话，我们的团队成员在谈论一般业务以及模型时，经常提到这个术语。
- en: 'Mainly, we have an entity here. Entities represent unique objects of the same
    type. In addition to classified ads, we might expect our system to hold information
    about sellers and buyers, and those might be entities too, apart from being just
    roles in the system. It is because we need to identify those people, so we need
    to have something unique, like username or email address, to understand who is
    who. The same is valid for a classified ad. Imagine ads like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 主要地，这里有一个实体。实体代表同一类型的独特对象。除了分类广告外，我们可能还期望我们的系统保存有关卖家和买家的信息，这些信息也可能是实体，而不仅仅是系统中的角色。这是因为我们需要识别这些人，所以我们需要有一些独特的东西，比如用户名或电子邮件地址，来了解谁是谁。对于分类广告也是如此。想象一下以下广告：
- en: '![](img/6d8866b7-3a3f-4597-972b-c469605f5798.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d8866b7-3a3f-4597-972b-c469605f5798.png)'
- en: Draft sketch of the user interface
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面草图
- en: Both ads are the same if we ignore who is selling and for what price. But, most
    probably, these are two different objects. Because of the mass-production of IKEA,
    there is a significant chance that multiple similarly used objects are being sold
    at the same time, but for us, those objects are different. It is because we are
    not using object properties, like model and size, to find out if two objects are
    identical. In our system, these objects will be represented in two different classified
    ads and will have separate identities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略卖家和价格，这两个广告是相同的。但，很可能是两个不同的对象。由于IKEA的大规模生产，同时出售多个类似使用过的对象的可能性很大，但对我们来说，这些对象是不同的。这是因为我们不是使用对象属性，如型号和尺寸，来确定两个对象是否相同。在我们的系统中，这些对象将以两个不同的分类广告形式表示，并将拥有独立的身份。
- en: Identities
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份
- en: We mentioned a username or email as an identity of users in the system, but
    what can be used as an identity for objects? In real life, many objects are already
    identified. The most common identity is an item serial number. Complex objects
    like smartphones, TV sets, computers, and cars have unique identifiers that help
    manufacturers to know in what configuration these objects were produced, and therefore,
    they can provide better support. Also, due to the significant price of such objects,
    they are usually tracked individually.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到用户名或电子邮件作为系统中用户的身份，但什么可以作为对象的身份？在现实生活中，许多对象已经得到了识别。最常见的是物品序列号。像智能手机、电视、电脑和汽车这样的复杂对象具有独特的标识符，这有助于制造商了解这些对象是以何种配置生产的，因此他们可以提供更好的支持。此外，由于这些对象的显著价格，它们通常被单独追踪。
- en: However, when we talk about our system, most of the time we need to use our
    own identity. The only important rule, really, is that all entities need to be
    uniquely identified. There are a few ways to get such an identity, and you might
    already be familiar with some. Probably the most frequently used method to get
    unique identities today (later referenced as **IDs**) is to use unique database
    keys. It is because most systems out there are data-oriented and designed with
    persistence-first in mind. Such a system will not work without persisting stuff
    to a particular database. Such a method has at least one definite advantage—such
    IDs are usually numeric and incremental, so it is straightforward to dictate such
    an ID over the phone. But the most significant disadvantage comes from the ID
    source—the database must be present to get such an identity, even if later in
    the flow, the system will decide not to accept the object and drop it instead,
    so it never gets persisted. Most of the experienced developers have seen weird
    constructs in the code where an empty or dummy row is being inserted into some
    table to get an object ID, and later, such a row either needs to be populated
    with real values or removed. Such an approach creates a whole load of issues,
    and we will not be using it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们谈论我们的系统时，大多数时候我们需要使用我们自己的身份。真正重要的规则是，所有实体都需要有唯一的标识。有几种方法可以获得这样的身份，你可能已经熟悉其中的一些。目前最常用的获取唯一身份的方法（稍后称为**ID**）是使用唯一的数据库键。这是因为大多数系统都是面向数据的，并且以持久性为首要考虑。这样的系统如果没有将数据持久化到特定的数据库中是无法工作的。这种方法至少有一个明显的优势——这样的ID通常是数字和递增的，因此通过电话直接指定这样的ID非常直接。但最显著的缺点来自ID的来源——必须存在数据库才能获得这样的身份，即使后来在流程中，系统决定不接受该对象并丢弃它，因此它永远不会被持久化。大多数经验丰富的开发者都见过代码中一些奇怪的构造，其中在某个表中插入一个空或虚拟行以获取对象ID，稍后这样的行要么需要填充真实值，要么需要删除。这种方法会引发一系列问题，我们不会使用它。
- en: Instead, we will use generated unique IDs. Because we would prefer not to use
    any infrastructure to create our IDs, we will use one reliable method and identity
    type—a **globally unique identifier** (**GUID**), more commonly known as a **universally
    unique identifier** (**UUID**). Such an ID can be generated using the current
    time and some information about the computer, where it is produced. There is a
    very high probability that such an ID is globally unique. When using GUIDs, we
    can generate identities for objects before touching any infrastructure and therefore,
    for example, create references to an object that only exists in memory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用生成的唯一ID。因为我们更愿意不使用任何基础设施来创建我们的ID，我们将使用一种可靠的方法和身份类型——一个**全局唯一标识符**（**GUID**），更常见的是称为**通用唯一标识符**（**UUID**）。这样的ID可以使用当前时间和一些关于计算机的信息生成，其中它被产生。这样的ID具有很高的全球唯一性概率。当使用GUID时，我们可以在接触任何基础设施之前为对象生成身份，例如，创建对仅存在于内存中的对象的引用。
- en: Classified ad entity
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类广告实体
- en: As we have understood from our EventStorming model, we most probably need an
    entity to represent a classified ad. It seems to be one of the central concepts
    of our system. We spent a great deal of time discussing our model with domain
    experts, and this term kept coming up in the conversation. It is a perfect indicator
    that we have identified some vital domain concept also, because we keep getting
    a repeated pattern when one command results in one event, and we keep having a
    *classified ad* as an object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从EventStorming模型中理解的那样，我们很可能需要一个实体来表示分类广告。这似乎是我们系统中的一个核心概念。我们花了很多时间与领域专家讨论我们的模型，这个术语在谈话中不断出现。这是一个完美的指标，表明我们也识别了一些重要的领域概念，因为我们总是在一个命令导致一个事件时得到一个重复的模式，我们总是有一个*分类广告*作为对象。
- en: 'Entities are represented in code as objects, and, therefore, we need a class
    so we can create instances of such a class. Here is our first attempt to create
    a class to represent a classified ad:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实体在代码中以对象的形式表示，因此我们需要一个类，这样我们就可以创建此类实例。这是我们第一次尝试创建一个类来表示分类广告：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You might feel puzzled about this class, and you'd be right to question this
    kind of entity implementation. It looks like a property bag, and the only difference
    with a **DTO** (short for **data transfer object**) here, is that this class only
    has one property, and all other details are represented by private fields. This
    class will compile, but it is practically unusable because even the single public
    property can only be set from inside the class, but we have not exposed any way
    of doing this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对这个类感到困惑，你质疑这种实体实现方式是正确的。它看起来像是一个属性包，与这里的 **DTO**（数据传输对象）的唯一区别是，这个类只有一个属性，所有其他细节都由私有字段表示。这个类可以编译，但实际上是不可用的，因为即使是单个公共属性也只能在类内部设置，但我们没有公开任何这样做的方法。
- en: However, despite being useless, this implementation demonstrates two essential
    principles that we need to keep in mind while going further. First, all entities
    need to have an ID, and it must be accessible from outside the entity. Second,
    since we are using an object-oriented language, we shall try to encapsulate as
    much as we can, and keep our internals safe, and preferably invisible to the outside
    world.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这个实现没有用，但它展示了我们在进一步推进时需要牢记的两个基本原则。首先，所有实体都需要有一个 ID，并且它必须可以从实体外部访问。其次，由于我们正在使用面向对象的语言，我们应该尽可能地封装，并保持我们的内部安全，最好是对外部世界不可见。
- en: 'To be able to instantiate this class correctly, let''s create a constructor
    that will at least allow us to set the entity `id`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够正确地实例化这个类，让我们创建一个构造函数，至少允许我们设置实体的 `id`：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following things are added here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里添加了以下内容：
- en: Since we only set the `Id` property value in the constructor, we can make it
    a read-only property.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们只在构造函数中设置了 `Id` 属性值，我们可以将其设为只读属性。
- en: When creating an instance of `ClassifiedAd`, we must supply `id`, because there
    is no parameterless constructor.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建 `ClassifiedAd` 的实例时，我们必须提供 `id`，因为没有无参数构造函数。
- en: The supplied `id` must be valid. Otherwise, the constructor will throw an argument
    exception.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的 `id` 必须是有效的。否则，构造函数将抛出参数异常。
- en: Right here, we enforced the rule that our entity can only be created giving
    a valid set of arguments (currently only one), and any created entity of the given
    type will be, by definition, legitimate. You might be concerned that a classified
    ad without some human-readable attributes, like title and price, is in fact not
    correct, but this concern is not technical. The business might decide that this
    is indeed a valid entity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这里，我们强制执行了这样一个规则：我们的实体只能通过提供一个有效的参数集（目前只有一个）来创建，并且根据定义，任何给定类型的创建实体都是合法的。你可能担心，如果没有一些人类可读的属性，如标题和价格，分类广告实际上是不正确的，但这种担忧不是技术性的。企业可能会决定这确实是一个有效的实体。
- en: Adding behavior
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加行为
- en: 'The next thing for us to do is to figure out what we can tell our entity to
    do. Remember, we need to design (and implement) behavior-first. The only reason
    for us to add those `private` fields to the entity was actually to support the
    behavior. As we discussed before, each action that is performed in the system
    amends the system state, and those `private` fields represent just that—state.
    But again, encapsulation being enforced, we shall not allow manipulating the entity
    state by changing property values from outside the entity; this will lead us to
    the dusty land of CRUD. Let''s see how we can breathe life into the entity:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是弄清楚我们可以告诉我们的实体做什么。记住，我们需要（设计和实现）首先设计（和实现）行为。我们添加那些 `private` 字段到实体的唯一原因实际上是为了支持行为。正如我们之前讨论的，系统中执行的每个操作都会改变系统状态，而这些
    `private` 字段正是代表这种状态。但是，再次强调，由于封装被强制执行，我们不应允许通过从实体外部更改属性值来操作实体状态；这将把我们引向 CRUD
    的尘土飞扬之地。让我们看看我们如何给实体注入生命：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have added three straightforward methods, and you might feel a bit disappointed
    because these are property setters (not even glorified). But, what we do here
    is express the idea of using Ubiquitous Language in code, and transfer words from
    sticky notes (commands in this case) to methods.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了三种简单的方法，你可能会感到有些失望，因为这些是属性设置器（甚至不是被夸大的）。但是，我们在这里所做的是在代码中表达使用通用语言的想法，并将从粘性笔记（在这种情况下是命令）到方法的词汇转换。
- en: Of course, this is just a start. In the following section, we will look deeper
    into our entity implementation, and find out how methods that express behavior
    can become more useful.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个开始。在下一节中，我们将更深入地探讨我们的实体实现，并找出表达行为的那些方法如何变得更加有用。
- en: Ensuring correctness
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保正确性
- en: In the previous section, we were checking the entity constructor parameter to
    be valid to ensure the newly created entity object is also correct. We applied
    a constraint, which does not allow creating a new entity without specifying the
    valid parameter value. By doing this, we are guarding our domain model against
    getting objects that aren't valid. It is one of the essential functions of the
    domain model as such, and since we are embracing *the behavior-first* approach,
    this type of code needs to be a part of the domain model implementation and not
    outsourced to external layers, like UI or application service layer. Of course,
    since our domain model is the system core, it takes a few hops for data to move
    from the user interface to domain objects. It is a valid approach to do a preliminary
    quality check on the data that tries to enter the domain model before it does.
    It improves the user experience due to much faster feedback. However, the ultimate
    control is always performed inside the domain model itself, since it shall never
    come to an invalid state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们检查了实体构造函数的参数是否有效，以确保新创建的实体对象也是正确的。我们应用了一个约束，不允许在不指定有效参数值的情况下创建新的实体。通过这样做，我们保护了领域模型免受无效对象的影响。这是领域模型的基本功能之一，并且由于我们采用了*行为优先*的方法，这种类型的代码需要成为领域模型实现的一部分，而不是外包给外部层，如UI或应用服务层。当然，由于我们的领域模型是系统核心，数据从用户界面移动到领域对象需要几个步骤。在数据尝试进入领域模型之前对其进行初步质量检查是有效的方法。这由于反馈更快而改善了用户体验。然而，最终的控制始终在领域模型内部执行，因为它绝不应该进入无效状态。
- en: Constraints for input values
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入值的约束
- en: 'You may have recognized some flaws in the entity implementation in the previous
    section. There are quite a few of them at the moment, but let''s look at the most
    obvious one. What is sorely missing here is the owner ID. It is hard to believe
    we can allow having ads without anyone owning them. How in this case will we understand
    who can modify the content of such ads? Plus, we already have the `_ownerId` field
    in this class. So, let''s add one more parameter to the constructor to enforce
    this constraint:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在上一节中注意到了实体实现中的一些缺陷。目前有很多，但让我们看看最明显的一个。这里严重缺失的是所有者ID。很难相信我们可以允许没有所有者就拥有广告。在这种情况下，我们将如何理解谁可以修改这些广告的内容？此外，我们已经在类中有了`_ownerId`字段。所以，让我们给构造函数添加一个额外的参数来强制执行这个约束：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From this moment on, we will not list the whole class, but just a part of it
    that is being changed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们不会列出整个类，而只是列出正在更改的部分。
- en: We have not only added one more parameter but also added one more check. So
    now, our entity is guaranteed to be valid after it is created, since the client
    must supply both the ad ID and the owner ID.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅添加了一个额外的参数，还添加了一个额外的检查。因此，现在我们的实体在创建后保证是有效的，因为客户端必须提供广告ID和所有者ID。
- en: 'The code that creates a classified ad entity would look like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分类广告实体的代码看起来如下：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that we are adding more parameters to the entity constructor, and the
    constructor itself grows since we add more checks for these parameters. In the
    end, it is not very easy to understand what is going on, because many rules are
    mixed in one large chunk of code. Also, it is quite evident that we are not checking
    core complex rules, which involve multiple properties of the entity. In our case,
    all we control is that each parameter has a value. This approach is not wrong
    but is also not ideal. Instead, we can check the validity of such values, even
    before reaching the entity constructor, using **value objects**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在向实体构造函数添加更多参数，构造函数本身也在增长，因为我们为这些参数添加了更多的检查。最终，由于许多规则混合在一个大块代码中，所以很难理解正在发生什么。此外，很明显，我们没有检查涉及实体多个属性的核心理解规则。在我们的案例中，我们控制的是每个参数都有值。这种方法并不错误，但也不是理想的。相反，我们可以在到达实体构造函数之前，使用**值对象**来检查这些值的有效性。
- en: Value objects
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象
- en: Value object pattern is not unique to DDD, but it probably became most popular
    within the DDD community. It probably happened due to such characteristics of
    value objects as expressiveness and strong encapsulation. Fundamentally, value
    objects allow declaring entity properties with explicit types that use Ubiquitous
    Language. Besides, such objects can explicitly define how they can be created
    and what operations can be performed within and between them. It is a perfect
    example of making implicit, explicit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象模式并不仅限于领域驱动设计（DDD），但它可能在DDD社区中变得最为流行。这可能是由于值对象的特点，如表达性和强封装性。从根本上讲，值对象允许使用显式类型声明实体属性，这些类型使用通用语言。此外，这样的对象可以显式定义它们如何被创建，以及它们之间可以执行哪些操作。这是一个将隐式操作显式化的完美例子。
- en: Let's look closer at what a value object is, by creating one in our code. Before,
    we were taking the `ownerId` parameter in the entity constructor, and checking
    it to have a non-default GUID. What we want here is a user ID, since we know that
    the ad owner is one of our users, because people need to be registered in the
    system before creating classified ads. It means that we can embrace the type system
    and make implicit more explicit by using a new type called `UserId`, instead of
    using `Guid`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的代码中创建一个值对象，让我们更深入地了解什么是值对象。之前，我们在实体构造函数中接受`ownerId`参数，并检查它是否具有非默认的GUID。在这里，我们想要的是一个用户ID，因为我们知道广告所有者是我们用户之一，因为人们在创建分类广告之前需要在系统中注册。这意味着我们可以通过使用一个新的类型`UserId`来拥抱类型系统，并通过使用`UserId`而不是`Guid`来使隐式操作更明确。
- en: 'Let''s create a new class in the `Marketplace.Domain` project and call it `UserId`.
    The initial code for this class would look like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Marketplace.Domain`项目中创建一个新的类，命名为`UserId`。这个类的初始代码如下所示：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we moved the assertion that the identity value is not an empty
    GUID, to the `UserId` constructor. It means that we can change our entity constructor
    to the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们将断言身份值不是空GUID的逻辑移动到了`UserId`构造函数中。这意味着我们可以将实体构造函数更改为以下形式：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our entity has no check for the `ownerId`, since, by receiving the argument
    of type `UserId`, we guarantee that the value is valid. Of course, we do not check
    here if the supplied GUID points to a valid user, but this was not our intention,
    at least for now.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实体没有对`ownerId`进行检查，因为我们通过接收类型为`UserId`的参数，保证了值的有效性。当然，我们在这里并没有检查提供的GUID是否指向一个有效的用户，但这至少不是我们的初衷。
- en: 'However, we still have one more check for the argument validity in the entity
    constructor. Let''s make the entity `id` type a value object too by adding a `ClassifiedAdId`
    class with the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然在实体构造函数中对参数的有效性进行了一次检查。让我们通过添加一个名为`ClassifiedAdId`的类，将实体`id`的类型也改为值对象，代码如下：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now our constructor has no checks at all, and it still makes a valid entity:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的构造函数没有任何检查，但它仍然可以创建一个有效的实体：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we move to the application layer, where our entity would be constructed,
    we could imagine that calls to the constructor would look like this (assuming
    that `id` and `ownerId` are of type `Guid`):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移动到应用层，我们的实体将被构建时，我们可以想象构造函数的调用将如下所示（假设`id`和`ownerId`的类型为`Guid`）：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code clearly says that we are sending the classified ad ID first,
    and the owner ID second to the entity constructor. When we use `Guid` as the type
    for both parameters, if we accidentally change the order of parameters, our application
    would still compile, but of course, our entities will be constructed incorrectly,
    and the whole system would break somewhere deep down the execution pipeline. Strongly
    typed parameters of value object types force the compiler to engage type checking,
    and if we messed up arguments, the code won't compile.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码清楚地表明，我们首先向实体构造函数发送分类广告ID，然后是所有者ID。当我们使用`Guid`作为两个参数的类型时，如果我们不小心改变了参数的顺序，我们的应用程序仍然可以编译，但当然，我们的实体将被错误地构建，整个系统可能在执行管道的某个深层位置崩溃。值对象类型的强类型参数迫使编译器参与类型检查，如果我们搞错了参数，代码将无法编译。
- en: But value objects aren't just wrapper types around primitive types. As we learned
    before, entities are considered equal if their identities are the same. Value
    objects are different since their equality is establishing by value, hence the
    pattern name. A classical example of a value object is money. If we take two €5
    banknotes, they represent two different entities, since they are in fact two distinctly
    different objects, and even have unique numbers printed on them. But for payment,
    both are entirely identical, since they have the same value of €5.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是值对象不仅仅是原始类型的包装类型。正如我们之前所学的，实体被认为是相等的，如果它们的身份相同。值对象是不同的，因为它们的相等性是通过值来建立的，这就是模式名称的由来。一个经典的值对象例子是货币。如果我们拿两张€5的银行纸币，它们代表两个不同的实体，因为它们实际上是两个截然不同的对象，甚至上面印有独特的编号。但在支付时，它们是完全相同的，因为它们都有相同的€5价值。
- en: 'But how do we represent it in code? Let''s create the `Money` class and give
    it a try:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何在代码中表示它呢？让我们创建`Money`类并尝试一下：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s write a simple test to check whether two objects of the `Money`
    type are equal if the amount is equal:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个简单的测试来检查两个`Money`类型的对象是否相等，如果金额相等：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, this test fails because a class instance is a reference object, and
    two instances of the same class are different objects, no matter what their properties
    and fields contain. We can conclude that neither the `Money` class nor our `UserId`
    and `ClassifiedAdId` classes can represent value objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个测试失败了，因为类实例是一个引用对象，同一类的两个实例是不同的对象，无论它们的属性和字段包含什么。我们可以得出结论，`Money`类以及我们的`UserId`和`ClassifiedAdId`类都不能表示值对象。
- en: 'To make the `Money` class closer to proper value object type, we need it to
    implement the `IEquatable` interface. The class instance will need to be compared
    with instances of the same type, so we need `Money` to implement `IEquatable<Money>`.
    If you add this interface to the class, in Rider, and in Visual Studio with Resharper,
    there will be an option to generate the necessary code automatically using the
    Generate equality to members refactoring suggestion:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`Money`类更接近于正确的值对象类型，我们需要它实现`IEquatable`接口。类的实例需要与同一类型的实例进行比较，因此我们需要`Money`实现`IEquatable<Money>`。如果你将此接口添加到类中，在Rider中，以及在Visual
    Studio的Resharper中，将会有一个选项自动生成必要的代码，使用“生成相等性成员”重构建议：
- en: '![](img/cb68a9dd-bc5b-4174-8732-b9762ca373e4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb68a9dd-bc5b-4174-8732-b9762ca373e4.png)'
- en: Generate equality members in Rider
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rider中生成相等性成员
- en: 'Therefore, if the Overload equality operators option is enabled, code for implicit
    equality operators will also be created. So, the code for our `Money` class will
    look like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果启用了重载相等性运算符选项，也会创建隐式相等性运算符的代码。所以，我们的`Money`类的代码将看起来像下面这样：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we run the same test now, it will pass, because, when we call `Assert.Equals(firstAmount,
    secondAmount)`, the preceding code will compare the values of the `_value` field
    for both instances when these values are the same. Because we also created code
    for implicit equality operators, we can use comparisons like `if (firstAmount
    == secondAmount)` in our code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行相同的测试，它将通过，因为当我们调用`Assert.Equals(firstAmount, secondAmount)`时，前面的代码将比较两个实例的`_value`字段的值，当这些值相同时。因为我们还创建了隐式相等性运算符的代码，我们可以在代码中使用比较`if
    (firstAmount == secondAmount)`。
- en: Now, imagine we need all this code for each value object type we create. Yes,
    with some nice auto-magic from Resharper, we can generate this code very quickly,
    and then hide it in a region, which will always be collapsed. But, if we decide
    to add one more attribute to the value object, we will need to reopen this region
    and add this new attribute in several places.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要为每个创建的值对象类型编写所有这些代码。是的，通过Resharper的一些很好的自动魔法，我们可以非常快速地生成此代码，然后将其隐藏在一个区域中，该区域始终是折叠的。但是，如果我们决定向值对象添加一个更多属性，我们需要重新打开这个区域，并在几个地方添加这个新属性。
- en: We can reduce the amount of boilerplate code, and provide the ability for equality
    comparison methods to be dynamic, by using a base class. There are at least two
    ways to create such a base class. One includes using reflections to discover all
    fields in the implementation type, and use all of them for equality purposes.
    Another method involves creating an abstract method that needs to be overridden
    in each implementation to provide specific values that are used for equality.
    While the first method allows writing less code since all fields are automatically
    discovered and used, the second method allows us to choose which attributes will
    be used for equality.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用基类来减少样板代码的数量，并使等价比较方法变得动态。创建这样的基类至少有两种方法。一种方法包括使用反射来发现实现类型中的所有字段，并使用它们进行等价比较。另一种方法涉及创建一个抽象方法，每个实现都必须重写它以提供用于等价比较的特定值。虽然第一种方法由于所有字段都是自动发现并使用的，因此可以编写更少的代码，但第二种方法允许我们选择哪些属性将用于等价比较。
- en: In one of the next versions of C#, which might already be available when you
    read this book, the new feature will be introduced that is called record types.
    On a high level, record types will be similar to F# records. Using record types,
    declaration of value objects would become very short, and all boilerplate code
    for equality (and more) will be generated by the compiler.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#的下一个版本中，这个新特性可能会在您阅读这本书的时候已经可用，它被称为记录类型。从高层次来看，记录类型将与F#记录类似。使用记录类型，值对象的声明将变得非常简短，所有与等价（以及更多）相关的样板代码将由编译器生成。
- en: 'For example, declaring the `Money` type earlier would be done in one line like
    this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，提前声明`Money`类型可以这样一行完成：
- en: '`public class Money(double amount);`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`public class Money(double amount);`'
- en: Throughout this book, I use classes, which are reference types, unlike structs,
    which are value types. It means that those value objects aren't completely following
    the immutability principle. We, however, will try to do as much as we can to ensure
    that these objects cannot be changed freely, but using the assignment operator
    for the object instance will only assign the reference to the original object,
    which is different for value types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我使用的是类，它们是引用类型，与结构体不同，结构体是值类型。这意味着这些值对象并不完全遵循不可变原则。然而，我们将尽可能确保这些对象不能被自由更改，但使用对象实例的赋值运算符只会分配对原始对象的引用，这与值类型不同。
- en: 'Using the abstract base class in the `Marketplace.Framework` project, we can
    now refactor the `Money` class to the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Marketplace.Framework`项目中使用抽象基类，我们现在可以将`Money`类重构为以下形式：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, all the boilerplate code is now moved to the base class, and
    we get back to essentials. The test, however, still passes because of the proper
    equality implementation in the base class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有样板代码现在都已移动到基类，我们回到了本质。然而，测试仍然通过，因为基类中实现了适当的等价比较。
- en: 'So far, we have only had straightforward rules in value objects, but when we
    work with money, we should be adding one useful check. Rarely, if we talk about
    money, we mean a negative amount. Yes, such amounts exist in accounting, but we
    are not building an accounting system. In our domain, classified ads need to have
    a price, and the price cannot be negative, as our domain expert explained. So,
    we can represent this rule in a new value object, shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只有直接规则在值对象中，但当我们处理金钱时，我们应该添加一个有用的检查。很少，如果我们谈论金钱，我们指的是负数。是的，这样的金额在会计中存在，但我们不是在构建会计系统。在我们的领域内，分类广告需要有一个价格，价格不能为负，正如我们的领域专家解释的那样。因此，我们可以在以下代码中用一个新的值对象表示这个规则：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Thus, despite our base, `Money` class still allows its amount to be negative
    or zero; the price will always be positive and, as a result, valid in our domain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我们有基类，`Money`类仍然允许其金额为负数或零；价格始终为正，因此在我们的领域内始终有效。
- en: Speaking about immutability, we must ensure that there are no methods that our
    value objects expose, which allow changing field values inside these objects.
    If we want to do some operation on a value object instance, it needs to produce
    a new instance of the same type, but with a new value. By doing this, we ensure
    that the original object will retain its value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到不可变，我们必须确保我们的值对象没有暴露任何方法，这些方法允许在这些对象内部更改字段值。如果我们想在值对象实例上执行某些操作，它需要产生一个相同类型的新实例，但具有新的值。通过这样做，我们确保原始对象将保留其值。
- en: 'Let''s look at the `Money` example and add some useful operations to it, keeping
    immutability in mind:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Money`示例，并给它添加一些有用的操作，同时考虑到不可变性：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we have a sum of €1 coin and two €2 coins, the total value is €5\. If we
    compare it with a banknote of €5, its value is the same. Since we aren''t interested
    in shape, size, and weight of those monetary instruments and we are only interested
    in value, we can conclude that those two have equal value. Our preceding new `Money`
    class lets us express this statement in the test code, which will be green when
    we run it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一枚1欧元硬币和两枚2欧元硬币，总价值是5欧元。如果我们与一张5欧元的纸币相比，其价值相同。由于我们不对这些货币工具的形状、大小和重量感兴趣，我们只对价值感兴趣，我们可以得出结论，这两个的价值是相等的。我们之前的新`Money`类让我们可以在测试代码中表达这个陈述，当我们运行它时，它会变成绿色：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can finally rewrite our identity classes to proper value object implementations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们最终可以重写我们的身份类，以适当的值对象实现：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, let's have a more in-depth look at more advanced ways to instantiate value
    objects and entities.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地探讨更多高级的方式来实例化值对象和实体。
- en: Factories
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: Now, we can implement more value objects that will be used for other fields
    in our entity. Remember, we have three methods in the entity that expressed its
    basic behaviour—`SetTitle(string)`, `UpdateText(string)`, and `UpdatePrice(double)`.
    The easiest one to deal with would be the last one since we already have a value
    object type for it—`Price`. Let's focus on the other two methods and see what
    constraints we can implement using value objects instead of plain strings for
    ad title and text.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现更多值对象，这些值对象将用于我们实体的其他字段。记住，我们在实体中有三个方法表达了其基本行为——`SetTitle(string)`、`UpdateText(string)`和`UpdatePrice(double)`。最容易处理的一个是最后一个，因为我们已经有了它的值对象类型——`Price`。让我们专注于其他两个方法，看看我们可以使用值对象而不是普通字符串来为广告标题和文本实现哪些约束。
- en: 'The complete value object class for the classified ad title could look like
    this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分类广告标题的完整值对象类可能看起来像这样：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's go through it to understand how it works.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来理解它是如何工作的。
- en: First, we use our abstract `Value<T>` base class to remove the boilerplate code,
    just as we did before in the identity and `price` value objects. Then, skipping
    the `static` method, you can see the `private` value field, again, like in other
    value objects we have created before. However, then we have a private constructor,
    which accepts a regular string argument. Inside the constructor, we enforce the
    constraint that the ad title cannot be longer than `100` characters. It will not
    allow us to spread such checks to other parts of the application. You might ask
    the question—why is the constructor `private` in this case? It is because we might
    have different sources of data for the title string, and, before calling the constructor,
    we might need to take some additional operations. It is not done in the preceding
    code snippet just yet, but we will add such functionality later. The next question
    would be—how do we construct new instances of this class if the constructor is
    `private`? It is where the **factory** pattern becomes useful.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用我们的抽象`Value<T>`基类来移除样板代码，就像我们在身份和`price`值对象中之前所做的那样。然后，跳过`static`方法，你可以看到`private`值字段，就像我们在之前创建的其他值对象中一样。然而，然后我们有一个私有的构造函数，它接受一个常规字符串参数。在构造函数内部，我们强制执行约束，即广告标题不能超过`100`个字符。它不会允许我们将此类检查扩展到应用程序的其他部分。你可能会问这样的问题——为什么在这个情况下构造函数是`private`的？这是因为我们可能有不同的数据源用于标题字符串，并且在调用构造函数之前，我们可能需要执行一些额外的操作。这在前面的代码片段中还没有完成，但我们将稍后添加这样的功能。下一个问题将是——如果构造函数是`private`的，我们如何构造这个类的新实例？这就是`**工厂**模式变得有用的地方。
- en: Factories are functions that are used to create instances of domain objects,
    which are, by definition, valid. Factory functions can execute some logic to construct
    valid instances, and such logic could be different per factory. It is why we would
    expect to have multiple factory methods in one value object class, although this
    is not a requirement. Factories also help to make implicit things more explicit
    by using proper naming. In our `ClassifiedAdTitle` class, we only have one factory,
    which converts the string to the value object instance. It is quite clear what
    it does and what kind of argument it accepts.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂是用于创建领域对象实例的函数，根据定义，这些实例是有效的。工厂函数可以执行一些逻辑来构建有效的实例，并且这种逻辑可能因工厂而异。这就是为什么我们期望在一个值对象类中拥有多个工厂方法，尽管这不是一个要求。工厂还有助于通过使用适当的命名来使隐含的事物更加明确。在我们的`ClassifiedAdTitle`类中，我们只有一个工厂，它将字符串转换为值对象实例。它所执行的操作以及它接受的参数类型非常清晰。
- en: 'Let''s see how we can use factories to handle different use cases. Imagine
    that we get a requirement for ad title to support `Markdown` partially. In fact,
    we only need to support italic and bold. We do need to validate the existing factory
    argument since any string is a valid `Markdown` string anyway. But, if we can
    get input from some online editor that can only produce pure HTML, we can do a
    conversion in a new factory function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用工厂来处理不同的用例。想象一下，我们得到一个要求广告标题部分支持`Markdown`的要求。实际上，我们只需要支持斜体和粗体。我们确实需要验证现有的工厂参数，因为任何字符串都是一个有效的`Markdown`字符串。但是，如果我们能从只能生成纯HTML的在线编辑器那里获取输入，我们可以在一个新的工厂函数中进行转换：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I have to admit that this function is not perfect because it is insufficient
    in the number of tags it handles. It also cannot correctly handle HTML tags that
    are written using capital letters. But it is good enough for demo purposes to
    give you an idea of what kind of logic can be included in factory functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，这个函数并不完美，因为它在处理标签的数量上不足。它也无法正确处理使用大写字母编写的HTML标签。但是，对于演示目的来说，它足够好，可以给你一个关于可以在工厂函数中包含哪种逻辑的印象。
- en: 'Now, let''s move to the `Price` class and see if it can create some factories
    and apply more rules to it. Since `Price` inherits from `Amount`, we can look
    to make the `Amount` class more strict:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到`Price`类，看看它是否可以创建一些工厂并对其应用更多规则。由于`Price`类继承自`Amount`类，我们可以考虑使`Amount`类更加严格：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see here, `Money` class now has a `protected` constructor, which
    cannot be called from outside, except inherited classes like `Price`. The constructor
    now checks if the amount argument has more than two decimal points, and throws
    an exception if this is the case. Finally, we have two factory functions that
    create instances of `Money` from decimal or string arguments. Most probably, we
    will receive strings from the API so we can try parsing them inside the factory.
    It will, of course, throw the decimal parsing exception should the given string
    not represent a valid number.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`Money`类现在有一个`protected`构造函数，它不能从外部调用，除了像`Price`这样的继承类。构造函数现在检查金额参数是否有超过两位小数，如果是这样，就会抛出一个异常。最后，我们有两个工厂函数，可以从十进制或字符串参数创建`Money`实例。我们很可能会从API接收字符串，因此我们可以在工厂内部尝试解析它们。当然，如果给定的字符串不表示一个有效的数字，它将抛出十进制解析异常。
- en: We are checking if an amount of money has two decimal places, and usually, this
    is what we need to do. However, bear in mind that not all currencies support two
    decimals. For example, the Japanese Yen must have no decimals at all. Amounts
    in Yen are always round. You'd probably be surprised to know that Omani Rial supports
    three decimal places, so if you plan to deliver your application in Oman, you
    should not use the `Money` class from this book, or at least change the rules.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在检查一个金额是否有两位小数，这通常是我们需要做的。然而，请记住，并非所有货币都支持两位小数。例如，日元必须没有小数点。日元金额总是四舍五入。你可能不知道，阿曼里亚尔支持三位小数，所以如果你计划在阿曼交付你的应用程序，你不应该使用这本书中的`Money`类，或者至少改变规则。
- en: Always check if rules that you apply are valid on all markets that you plan
    to support. Things like currencies, date and time formats, people names, bank
    accounts, and addresses can have surprisingly large varieties across the globe,
    and it is always worth checking if you are applying rules that make sense.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 总是检查你应用的规则是否适用于你计划支持的所有市场。像货币、日期和时间格式、人名、银行账户和地址这样的东西在全球范围内可能有非常大的差异，因此检查你应用的规则是否合理总是值得的。
- en: 'Now, let''s imagine that our application needs to support different currencies.
    I mean that currency information would also need to be included in this value
    object. After adding it, we get code like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们的应用程序需要支持不同的货币。我的意思是，货币信息也需要包含在这个值对象中。添加之后，我们得到如下代码：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we passed currency information to the constructor and both factory methods.
    By default, factories will use `EUR` if no currency is specified. We also keep
    currency information inside the class. Second, `Add` and `Subtract` methods started
    to check if both operands have the same currency. In case currencies of operands
    don't match, these methods throw an exception.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将货币信息传递给了构造函数和两个工厂方法。默认情况下，如果没有指定货币，工厂将使用`EUR`。我们还在类中保留了货币信息。其次，`Add`和`Subtract`方法开始检查两个操作数是否具有相同的货币。如果操作数的货币不匹配，这些方法将抛出异常。
- en: We also added a domain-specific exception that explicitly tells us that operations
    on two instances of `Money` cannot be completed because they have different currencies.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个特定于领域的异常，它明确地告诉我们，由于两个`Money`实例具有不同的货币，它们之间的操作无法完成。
- en: Imagine how many bugs such simple technique can prevent in a multicurrency system,
    where developers too often forget that monetary value for the same decimal amount
    can be drastically different, depending on which currency this amount of money
    is issued? For example, one US Dollar is roughly equal to 110 Japanese Yen and
    adding `1` to `110`, in this case, won't give you the right result.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，这种简单的技术可以防止在多货币系统中出现多少错误，因为在多货币系统中，开发者往往忘记，对于相同的十进制金额，货币价值可能会因货币的不同而截然不同。例如，一美元大约等于110日元，在这种情况下，将`1`加到`110`上不会得到正确的结果。
- en: 'One thing that remains uncovered with our `Money` object is that we can supply
    any string as currency code and it will be accepted. As you might imagine we can
    have this failure very easily:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Money`对象的一个未被覆盖的问题是，我们可以提供任何字符串作为货币代码，它都会被接受。正如你可能想象的那样，我们可以非常容易地出现这种失败：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Looking at the `Money` class code, we can quickly conclude that no operations
    can be performed on combinations of these objects. `firstAmount + secondAmount`
    will crash because our class will decide that they have different currencies.
    The `thirdAmount` is utterly invalid because the Dollar sign is not a valid currency
    code, but our class still accepts it. Let's see what can we do to fix it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下`Money`类的代码，我们可以很快得出结论，不能在这些对象的组合上执行任何操作。`firstAmount + secondAmount`将会崩溃，因为我们的类会决定它们具有不同的货币。`thirdAmount`完全无效，因为美元符号不是一个有效的货币代码，但我们的类仍然接受它。让我们看看我们能做些什么来修复它。
- en: To be able to check the currency code validity, we either need to keep all valid
    country codes inside the code of our value object class or use some external service
    to do the check. The first option is self-contained, so we will not have any dependencies
    for the value object class. However, by doing this, we will inject a somewhat
    alien concept to the value object code, which we will need to change each time
    something happens in the world of finances. One might argue that new currencies
    do not appear every day, but at the same time, Eurozone has been expanded during
    the last few years, and each time a new country starts using Euro, their old currency
    disappears, and this needs to be taken into account. These factors are utterly
    external to our system, and it would not be smart to create such an easy-to-forget
    time bomb in our code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查货币代码的有效性，我们或者需要在我们的值对象类代码中保留所有有效的国家代码，或者使用一些外部服务来进行检查。第一种方法是完全自包含的，因此我们不会为值对象类有任何依赖。然而，这样做会在值对象代码中引入一个相对陌生的概念，每次金融世界发生变化时，我们都需要对其进行修改。有人可能会说，新货币并不是每天都出现，但与此同时，欧元区在过去几年中已经扩大，每次有新国家开始使用欧元时，他们的旧货币就会消失，这一点需要考虑。这些因素完全超出了我们的系统范围，在我们的代码中创建这样一个容易忘记的时间炸弹是不明智的。
- en: Domain services
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域服务
- en: We can go for a dependency on some external service, but we know that domain
    models should not have external dependencies, so how do we solve this issue? We
    can use a pattern called **domain service**. In DDD, domain services can perform
    different kinds of tasks, and here, we will look into one type of them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择依赖某个外部服务，但我们知道领域模型不应该有外部依赖，那么我们如何解决这个问题呢？我们可以使用一个称为**领域服务**的模式。在DDD中，领域服务可以执行不同种类的任务，在这里，我们将探讨其中一种类型。
- en: 'Our domain service needs to check if a given country code is valid. The `Money`
    class will get it as a dependency, so we need to declare the domain service inside
    our domain model. Because we do not want to depend on anything on the outside
    of our domain model, we should not put any implementation details inside the domain
    model. It means that the only thing we are going to have inside the domain project
    is the domain service interface, shown in the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域服务需要检查给定的国家代码是否有效。`Money`类将作为依赖项获取它，因此我们需要在我们的领域模型内部声明领域服务。因为我们不希望依赖于领域模型外部的任何东西，所以我们不应该在领域模型内部放置任何实现细节。这意味着我们将在领域项目中拥有的唯一东西是领域服务接口，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The new interface will not just check if a given currency code can be matched
    with some currency. Since we already discussed that different currencies might
    have a different number of decimal places, the service will return an instance
    of `CurrencyDetails` class with this information included. If there is no currency
    found for the given code, the service will return `CurrencyDetails.None` constant.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 新的接口不仅会检查给定的货币代码是否可以与某种货币匹配。因为我们已经讨论过不同货币可能有不同的小数位数，所以服务将返回包含此信息的`CurrencyDetails`类实例。如果未找到给定代码的货币，服务将返回`CurrencyDetails.None`常量。
- en: It is very common in C#, that if a function is expected to return an instance
    of a reference type, it also can return null to indicate that there is no valid
    result that the function can produce. Although, at first, this approach might
    seem easy, it creates massive problems. Our code becomes full of null checks because
    we suspect that every function can return null, so we must trust no one to avoid `NullReferenceException`.
    Null has a specific null-type, and it is too easy to assign null to something
    that should never be null.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，如果预期函数返回引用类型的一个实例，它也可以返回null来表示该函数无法产生有效结果。尽管这种做法一开始可能看起来很简单，但它会引发大量问题。我们的代码充满了空检查，因为我们怀疑每个函数都可能返回null，因此我们必须信任没有人来避免`NullReferenceException`。空引用有一个特定的空类型，将其分配给不应该为空的东西太容易了。
- en: Sir Charles Antony Richard Hoare, better known as Tony Hoare, introduced null
    references to the Algol programming language back in 1965\. He remembers doing
    this because it was so easy to implement. Much later, at the QCon conference in
    London in 2009, he apologized for null reference saying *I call it my billion
    dollar mistake*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔斯·安东尼·理查德·霍尔爵士，更广为人知的是托尼·霍尔，他在1965年将空引用引入了ALGOL编程语言。他记得这样做是因为它很容易实现。后来，在2009年伦敦的QCon会议上，他为空引用道歉，说“我称之为我的十亿美元错误”。
- en: Video: [https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 视频：[https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)。
- en: In most functional languages, the null reference does not exist, because it
    can easily break the functional composition. Instead, optional types are being
    used. In the preceding code snippet, we use a similar technique to return a pre-defined
    value that indicates that there is no currency found for a given code. This constant
    has the proper type and proper name, and we should never check the function output
    for null.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数函数式语言中，不存在空引用，因为它很容易破坏函数式组合。相反，正在使用可选类型。在先前的代码片段中，我们使用类似的技术来返回一个预定义的值，表示没有找到给定代码的货币。这个常量具有正确的类型和正确的名称，我们永远不应该检查函数输出是否为空。
- en: To mitigate the null reference issue, Microsoft decided to allow explicit declaration
    of nullable reference types. By default, reference types will be assumed as non-nullable.
    This feature will remain until the next version of C#, and you can get more details
    about the proposal here: [https://github.com/dotnet/csharplang/blob/master/proposals/nullable-reference-types.md](https://github.com/dotnet/csharplang/blob/master/proposals/nullable-reference-types.md).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻空引用问题，微软决定允许显式声明可空引用类型。默认情况下，引用类型将被假定为不可为空。这个特性将保留到下一个版本的C#，你可以在以下链接中获取更多关于这个提议的详细信息：[https://github.com/dotnet/csharplang/blob/master/proposals/nullable-reference-types.md](https://github.com/dotnet/csharplang/blob/master/proposals/nullable-reference-types.md)。
- en: 'When the interface is there, we can change our value object like to look like
    the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当接口存在时，我们可以将我们的值对象修改如下：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are a couple of new things going on here, listed as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的变化，如下列所示：
- en: We give the value object a dependency on the currency lookup domain service.
    Since we are using the interface, our domain model still has no external dependencies.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们给值对象添加了对货币查找域服务的依赖。由于我们使用接口，我们的领域模型仍然没有外部依赖。
- en: Since we are not using the null reference to indicate that there is no currency
    found for the specified code, we do not use null checks. Instead, we check if
    the returned currency is valid or not. Since the `CurrencyDetails.NotFound` constant
    has its `InUse` property set to `false`, we will throw an exception just as we
    would do for any currency that exists, but is not in use.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们不使用空引用来指示未找到指定代码的货币，我们不使用空检查。相反，我们检查返回的货币是否有效。由于`CurrencyDetails.NotFound`常量的`InUse`属性设置为`false`，我们将抛出异常，就像我们会对任何存在但未使用的货币做的那样。
- en: We do not use two as the maximum number of decimal places. Instead, we get this
    number from the currency lookup, so our value object becomes more flexible.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不使用两位作为最大小数位数。相反，我们从货币查找中获取这个数字，因此我们的值对象变得更加灵活。
- en: For our public methods, we need a simplified constructor, since these methods
    control that both operands have the same (valid) currency. Because we only trust
    our internals to use this constructor, it needs to be private. Both `Add` and
    `Subtract` methods use this constructor.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们的公共方法，我们需要一个简化的构造函数，因为这些方法控制两个操作数具有相同的（有效）货币。因为我们只信任我们的内部使用此构造函数，所以它需要是私有的。`Add`和`Subtract`方法都使用此构造函数。
- en: Added `ToString` override to be able to see the human-readable value of the
    value object, for example, in test results.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了`ToString`重写，以便能够看到值对象的人类可读值，例如，在测试结果中。
- en: 'Our `Money` value object is still very much testable since we can supply a
    fake currency lookup:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以提供假的货币查找，我们的`Money`值对象仍然非常易于测试：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this implementation in place, we can refactor the tests for `Money` as
    follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现到位后，我们可以按照以下方式重构`Money`的测试：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see here that we are testing some positive and some adverse scenarios
    to ensure those valid operations are correctly completed, and also, those invalid
    operations aren't allowed to be executed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们正在测试一些正面和负面场景，以确保那些有效操作被正确完成，并且那些无效操作不允许被执行。
- en: Entity invariants
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体不变性
- en: We have gone through using value objects to protect invalid values from being
    even used as parameters for entity constructors and methods. This technique allows
    moving a lot of checks to value objects, provides nice encapsulation, and enables
    type safety. Then, when we create a new entity or execute some behavior using
    entity methods, we need to do some more checks. Since we can be quite sure that
    all parameters already contain valid individual values, we need to ensure that
    a given combination of parameters, current entity state, and execute behavior,
    is not going to bring the entity to some invalid state.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过使用值对象来保护无效值不被用作实体构造函数和方法参数。这种技术允许将许多检查移动到值对象中，提供良好的封装，并启用类型安全。然后，当我们创建一个新的实体或使用实体方法执行某些行为时，我们需要进行更多的检查。由于我们可以相当肯定所有参数已经包含有效的单个值，我们需要确保给定的参数组合、当前实体状态和执行行为不会使实体进入某些无效状态。
- en: 'Let''s look at what complex rules we have for our classified ad entity. To
    find such rules, we can use some sticky notes from our detailed EventStorming
    session in [Chapter 3](07ee37fb-0189-467c-865d-18e72868b137.xhtml), *EventStorming*,
    and put them on a chart like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们为我们的分类广告实体定义了哪些复杂规则。为了找到这些规则，我们可以使用[第3章](07ee37fb-0189-467c-865d-18e72868b137.xhtml)中详细的事件风暴会议的一些便签，*事件风暴*，并将它们放在像这样的图表上：
- en: '![](img/73066e67-6f7e-4849-a927-d016e8486af9.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73066e67-6f7e-4849-a927-d016e8486af9.png)'
- en: Analyzing constraints for a command
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 分析命令的约束
- en: We put the command to the left side, the event to the right side, and try to
    find out what could prevent our command being executed in a way that produces
    the desired outcome (the event). In our case here, we need to ensure that, before
    an ad can be put to the review queue, it must have a non-empty title, text, and
    price. By using value objects alone, we cannot guarantee that our entity state
    is correct as a whole. The entity state validity can change depending on what
    state the entity has at a particular moment of its life cycle. Only when a given
    command is being executed, we need to check if these constraints are satisfied. It
    is what we can call an invariant for this entity—an ad that is in a pending review
    cannot have an empty title, an empty text, or zero price.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命令放在左边，事件放在右边，并试图找出什么可能阻止我们的命令以产生预期结果（事件）的方式执行。在我们的案例中，我们需要确保在广告可以放入审查队列之前，它必须有一个非空的标题、文本和价格。仅使用值对象，我们无法保证我们的实体状态作为一个整体是正确的。实体状态的有效性可能会根据实体在其生命周期中的特定时刻的状态而变化。只有在给定命令正在执行时，我们才需要检查这些约束是否得到满足。这就是我们可以称之为该实体的不变量——一个处于待审查状态的广告不能有一个空的标题、空的文本或零价格。
- en: 'There are at least two ways to ensure that our entity never gets to an invalid
    state. The first and most obvious way is to add checks to the operation code.
    We have no method to request the ad to be published, so let''s add it and make
    some changes related to the fact of using value objects for entity state as well:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两种方法可以确保我们的实体永远不会达到无效状态。第一种也是最明显的方法是在操作代码中添加检查。我们没有请求发布广告的方法，所以让我们添加它，并对使用值对象作为实体状态的事实进行一些更改：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the new entity code, we have all properties to be typed as value objects,
    and we got one more property for the classified ad current state. In the beginning,
    it is set to `Inactive`, and when the ad is requested to be published, we change
    the state to `PendingReview`. However, we only do it when all the checks are satisfied.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的实体代码中，我们将所有属性都指定为值对象，并且我们为分类广告的当前状态添加了一个属性。一开始，它被设置为`Inactive`，当广告被请求发布时，我们将其状态更改为`PendingReview`。然而，我们只有在所有检查都满足的情况下才这样做。
- en: 'To let the caller know if our entity is not ready to be published when some
    of those checks fail, we use our custom exception, which is implemented like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让调用者知道如果某些检查失败，我们的实体是否尚未准备好发布，我们使用我们自定义的异常，其实现方式如下：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method of checking constraints before executing the operation, in the operation
    method itself, has one disadvantage. If we now change the price to zero, it will
    go through, because `UpdatePrice` method is not checking the price value.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作方法本身中执行操作之前检查约束的方法有一个缺点。如果我们现在将价格更改为零，它将通过，因为`UpdatePrice`方法没有检查价格值。
- en: We could, of course, copy the price check to the `UpdatePrice` method too, but
    there might be more methods that need the same tests, and we will keep copying
    control blocks. It will lead to a situation when, if we need to change any of
    those rules, we need to go to numerous places to replace all of the checks; this
    is very error-prone.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将价格检查复制到`UpdatePrice`方法中，但也可能有更多需要相同测试的方法，我们将继续复制控制块。这会导致一种情况，即如果我们需要更改这些规则中的任何一个，我们需要去许多地方替换所有的检查；这是非常容易出错的。
- en: To combine rules in one place, we can use techniques of contract programming.
    Part of contract programming can be seen in value objects since we evaluate pre-conditions
    for each parameter of the operation method. When we execute the operation without
    doing any additional checks, we will need to do a combined test (post-condition
    control). This check can be implemented in one place for the whole entity, and
    each operation will need to call it at the last line in the method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在一个地方合并规则，我们可以使用合同编程的技术。合同编程的一部分可以在值对象中看到，因为我们为操作方法的每个参数评估前置条件。当我们执行操作而不进行任何额外的检查时，我们需要进行一个组合测试（后置条件控制）。这个检查可以在整个实体的一个地方实现，并且每个操作都需要在方法的最后一行调用它。
- en: 'For our classified ad entity, it could look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的分类广告实体，它可能看起来像这样：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we have added one method called `EnsureValidState` checking
    that, in any situation, the entity state is valid, and, if it is not valid, an
    exception will be thrown. When we call this method from any operation method,
    we can be sure that, no matter what we are trying to do, our entity will always
    be in a valid state or the caller will get an exception.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们添加了一个名为`EnsureValidState`的方法，该方法检查在任何情况下，实体状态都是有效的，如果不是有效状态，则会抛出异常。当我们从任何操作方法调用此方法时，我们可以确信，无论我们试图做什么，我们的实体都将始终处于有效状态，或者调用者将获得异常。
- en: Also, we converted all `private` fields to public read-only properties. We need
    public properties to write tests, although we don't necessarily need to expose
    the internal entity state. To prevent setting values of these properties outside
    of operation methods, all properties have private setters, or no setters, for
    properties that are set in the constructor.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将所有`private`字段转换为公共只读属性。我们需要公共属性来编写测试，尽管我们不一定需要公开内部实体状态。为了防止在操作方法之外设置这些属性的值，所有属性都有私有设置器，或者对于在构造函数中设置的属性，没有设置器。
- en: 'Now, let''s write some tests to ensure that our constraints work:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些测试来确保我们的约束起作用：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This spec contains several tests for one operation (publish, or submit for review)
    with different pre-conditions. Here, we test a happy path when all necessary details
    are correctly set before the ad can be sent for review; we also test several negative
    cases when publishing is not allowed, due to missing mandatory information. Perhaps
    testing negative scenarios is even more essential, since it is straightforward
    to find out when the happy path does not work—your users will immediately complain.
    Testing negative scenarios prevents bugs in controlling entity invariants, which,
    in turn, prevents entities from becoming invalid.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范包含了对一个操作（发布或提交审查）的几个测试，这些测试有不同的前提条件。在这里，我们测试了一个愉快的路径，即在广告可以提交审查之前，所有必要的细节都正确设置；我们还测试了几个不允许发布的情况，因为这些信息是强制性的。也许测试负面场景甚至更为重要，因为当愉快的路径不起作用时，很容易发现——你的用户会立即抱怨。测试负面场景可以防止在控制实体不变性时出现错误，这反过来又防止实体变得无效。
- en: By now, you might be wondering why we spent so much time talking about domain
    events and have not seen a single one in code? We will be discussing this in the
    next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道为什么我们花了这么多时间讨论领域事件，但在代码中却一个也没有看到？我们将在下一节中讨论这个问题。
- en: Domain events in code
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码中的领域事件
- en: EventStorming allowed us to make useful domain discoveries. We gained some knowledge
    about the domain and managed to visualize it for shared understanding. Commands
    also appeared on the more detailed model. In this chapter, we learned how to create
    entities that protect themselves from executing invalid operations and never come
    to an invalid state. Operations on entities are performed by executing methods,
    which quite closely resemble commands that we discovered on our detailed model.
    So, this part is more or less clear, but events have never appeared in our code
    so far.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: EventStorming使我们能够做出有用的领域发现。我们获得了一些关于领域的知识，并设法将其可视化以便共同理解。命令也出现在更详细的模式中。在这一章中，我们学习了如何创建能够保护自己免受执行无效操作并永远不进入无效状态的实体。对实体的操作是通过执行方法来进行的，这些方法与我们发现的详细模型中的命令非常相似。因此，这部分内容或多或少是清晰的，但事件到目前为止从未出现在我们的代码中。
- en: In fact, you can implement a system using DDD principles and patterns without
    having any domain events. It might sound strange after spending so much time working
    with them using sticky notes, but this is a fact. When we execute an entity method,
    it changes the entity state. This state change is an implicit event. For example,
    when our system executes the `RequestToPublish` method of the `ClassifiedAd` entity,
    it will set the entity `State` property to `ClassifiedAdState.PendingReview` value.
    Effectively, this can be translated to **classified ad sent to revie****w**, and
    this is what we wrote on an orange sticky a while ago.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可以使用 DDD 原则和模式来实现一个系统，而无需任何领域事件。在花费这么多时间使用便利贴与他们一起工作之后，这听起来可能有些奇怪，但这确实是一个事实。当我们执行实体方法时，它会改变实体状态。这种状态变化是一个隐含的事件。例如，当我们的系统执行`ClassifiedAd`实体的`RequestToPublish`方法时，它将实体的`State`属性设置为`ClassifiedAdState.PendingReview`值。实际上，这可以翻译为**分类广告已发送至审查**，这是我们之前写在橙色便利贴上的内容。
- en: 'However, most of the time, making domain events first-class citizens in the
    domain model has excellent benefits. There are two primary use cases for domain
    events that are implemented explicitly as part of the domain model, listed as
    follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数情况下，将领域事件作为领域模型的一等公民具有极佳的好处。以下列出了两个主要用例，这些用例被明确地作为领域模型的一部分实现：
- en: 'Allowing one part of the system to inform other parts of the system about its
    state changes, using Ubiquitous Language, and state change details: we already
    discussed the idea of splitting the system into multiple pieces, and those pieces
    need to play well together by listening to each others'' events and executing
    necessary operations. If a system is built in such a way that different parts
    of the system react to each others'' changes, such a system is called a **reactive
    system**.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许系统的一部分通知系统的其他部分其状态变化，使用通用语言和状态变化细节：我们之前讨论了将系统拆分成多个部分的想法，这些部分需要通过监听彼此的事件并执行必要的操作来良好地协同工作。如果一个系统以这种方式构建，不同的系统部分对彼此的变化做出反应，那么这样的系统被称为**反应式系统**。
- en: 'Persisting domain events to get a full history of state changes inside the
    domain model: then, the state for any entity can be reconstructed by reading those
    events and reapplying them to the entity. This pattern is known as **Event Sourcing**,
    and we will spend a great deal of time discussing it in this book, especially
    in [Chapter 10](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml), *Event Sourcing*.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将领域事件持久化以获取领域模型内部状态变化的完整历史：然后，任何实体的状态都可以通过读取这些事件并将它们重新应用于实体来重建。这种模式被称为**事件源**，我们将在本书中花费大量时间讨论它，特别是在[第10章](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)，*事件源*。
- en: These two techniques can be combined, so when we persist domain events, we can
    also listen to everything that is being written in other parts of the system,
    and execute reactions to those events.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术可以结合使用，因此当我们持久化领域事件时，我们还可以监听系统其他部分的写入操作，并对这些事件执行反应。
- en: In this chapter, we will be looking at how we can bring domain events to code,
    and how our entity methods can raise them so we can use these events later.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何将领域事件引入代码，以及我们的实体方法如何引发它们，以便我们可以在以后使用这些事件。
- en: Domain events as objects
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域事件作为对象
- en: Bringing domain events to code is easy. Each event is an object. It means that
    we can represent event types as classes or structs. Since we will need to serialize
    events later, and structs aren't playing nicely with serializers, we will implement
    domain events as classes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将领域事件引入代码很容易。每个事件都是一个对象。这意味着我们可以将事件类型表示为类或结构体。由于我们稍后需要序列化事件，而结构体与序列化器配合得不好，因此我们将领域事件实现为类。
- en: 'We have the following basic operations on our `ClassifiedAd` entity:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`ClassifiedAd`实体上具有以下基本操作：
- en: Create a new classified ad
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的分类广告
- en: Set the ad title
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置广告标题
- en: Update text
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新文本
- en: Update price
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新价格
- en: Publish the ad (send for review)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布广告（发送进行审查）
- en: 'Each of those operations changes the state of our entity, and by doing this,
    raises an imaginary domain event. We have all those events on our sticky notes,
    shown as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这样的操作都会改变我们实体的状态，并通过这种方式引发一个想象中的领域事件。我们所有的这些事件都记录在我们的便利贴上，如下所示：
- en: '![](img/ca6ec97c-790d-4cdb-abf9-d7e87311f639.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca6ec97c-790d-4cdb-abf9-d7e87311f639.png)'
- en: The full picture for the core business domain
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 核心业务领域的完整图景
- en: Classes that represent events need to clearly describe events (what happened)
    and contain the necessary information that explains how the system state has changed.
    Usually, events are reactions to executions of commands. Therefore, data in events
    typically represent data in commands, and maybe some other details from the entity
    from which the event has been raised.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表示事件的类需要清楚地描述事件（发生了什么）并包含解释系统状态如何改变所必需的信息。通常，事件是对命令执行的响应。因此，事件中的数据通常表示命令中的数据，以及从引发事件的实体中的一些其他细节。
- en: 'Let''s create some domain event classes now. Bear in mind that this is our
    first ever implementation of domain events, and if you were reading about things
    like Event Sourcing, you might find it oversimplified, but this is intentional:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建一些领域事件类。请记住，这是我们第一次实现领域事件，如果你在阅读关于事件源等技术的内容，可能会觉得它过于简化，但这是故意的：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Event classes are wrapped inside the `Events` static class, which gives us some
    namespace.. Therefore, all properties in these classes are of primitive types.
    We do not use value objects in events. It is a significant thing to remember.
    The reason for only using primitive types in events is because domain events,
    as mentioned before, are often used *across* systems. Events can be seen as our
    system published contract. If we use Event Sourcing, and events are being persisted,
    we also cannot tolerate a situation where the rules in some value objects have
    changed. Furthermore, we cannot load our event anymore, because the data for the
    value object is now considered to be invalid. Of course, not using value objects
    in events mean that some more complex value objects need to be flattered. In our
    case, we extract values from the `Price` property to two properties of the `ClassifiedAdPriceUpdated`: `Price`,
    which represents the amount, and `CurrencyCode`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类被封装在`Events`静态类中，这为我们提供了一些命名空间。因此，这些类中的所有属性都是基本类型。我们不在事件中使用值对象。这是一个需要记住的重要事情。只在事件中使用基本类型的原因是，如前所述，域事件通常被跨系统使用。事件可以被视为我们系统发布的合约。如果我们使用事件溯源，并且事件正在被持久化，我们也无法容忍某些值对象中的规则发生变化的情况。此外，我们无法再加载我们的事件，因为值对象的数据现在被认为是无效的。当然，不在事件中使用值对象意味着需要将一些更复杂的价值对象简化。在我们的例子中，我们从`Price`属性提取值到`ClassifiedAdPriceUpdated`的两个属性中：`Price`，表示金额，和`CurrencyCode`。
- en: You can see that each event has the `Id` property because it makes no sense
    to raise an event without knowing which entity it comes from. So, each operation
    needs to take care that the entity `id` is populated in the events that it raises.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到每个事件都有一个`Id`属性，因为没有知道它来自哪个实体就引发事件是没有意义的。因此，每个操作都需要注意在它引发的事件中填充实体`id`。
- en: Again, the most critical thing about domain events is to represent things that
    happened, and these things cannot be changed, because we have no time machine
    or TARDIS to erase or fix the past. Therefore, events should be as simple as possible
    so we can always load past events, and this should never fail.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，关于域事件最关键的是要表示已经发生的事情，这些事情不能被改变，因为我们没有时间机器或TARDIS来擦除或修复过去。因此，事件应该尽可能简单，这样我们就可以始终加载过去的事件，并且这永远不会失败。
- en: Raising events
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引发事件
- en: Now, let's see how domain events are being used in our entity. First, we need
    to raise events from our methods. To do this, we need some event list inside the
    entity so we can keep events that are being created. Otherwise, there is little
    point in creating event instances in the first place.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看域事件是如何在我们的实体中被使用的。首先，我们需要从我们的方法中引发事件。为了做到这一点，我们需要在实体内部有一个事件列表，以便我们可以保留正在创建的事件。否则，最初创建事件实例就几乎没有意义。
- en: Since we expect this functionality of keeping events in some sort of a list
    inside the entity, we can move this to a base class for entities, which we didn't
    have before.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们期望在实体内部以某种形式保持事件的功能，我们可以将其移动到实体的基类中，这是我们之前没有的。
- en: 'Let''s create an abstract class and call it `Entity`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个抽象类，并将其命名为`Entity`：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since raised events will represent changes in the entity, methods that retrieve
    the list of events and clear this list are called `GetChanges` and `ClearChanges`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引发的事件将代表实体的变化，检索事件列表和清除此列表的方法被称为`GetChanges`和`ClearChanges`。
- en: 'The next step is to add this base class to our entity and start raising events
    from methods:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将这个基类添加到我们的实体中，并从方法中引发事件：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So now, if we imagine how our entity is used from the application service layer
    (which we will be discussing in detail later in this book), it could look like
    this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，如果我们想象我们的实体是如何在应用服务层（我们将在本书的后面部分详细讨论）中被使用的，它可能看起来是这样的：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code is not production ready, as you could imagine, but serves the purpose
    of demonstrating how domain events can be used for integration between different
    parts of the system. If we publish events to some message bus, and other components
    in our system subscribe to those messages, they can execute reactive behavior,
    and make some changes in their domain models, or execute some particular actions,
    like sending emails, text messages, or real-time notifications. With modern single-page
    application frameworks that embrace client-side state management, you can even
    update information that your users currently have in their browsers, to enable
    real-time updates in web applications as well.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不是生产就绪的，正如你可以想象的那样，但它演示了如何使用领域事件在不同系统部分之间进行集成。如果我们向某个消息总线发布事件，并且我们系统中的其他组件订阅这些消息，它们可以执行反应性行为，并在它们的领域模型中做出一些更改，或者执行一些特定操作，比如发送电子邮件、短信或实时通知。随着现代单页应用框架拥抱客户端状态管理，你甚至可以更新用户当前在浏览器中拥有的信息，以实现Web应用程序中的实时更新。
- en: 'It is worth adding one small remark about the code that instantiates events.
    There we assign values of value objects to primitive types directly. It is done
    using the implicit conversion feature of C#, and the implementation looks like
    this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实例化事件的代码，值得添加一个小备注。在那里，我们直接将值对象赋值给原始类型。这是通过使用C#的隐式转换功能完成的，实现看起来如下：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Implicit conversion allows us to simplify the assignments between entity properties
    and event properties significantly, although they are of incompatible types.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换使我们能够显著简化实体属性和事件属性之间的赋值，尽管它们是不兼容的类型。
- en: Events change state
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件改变状态
- en: If we move on to the idea of Event Sourcing, events represent the fact of state
    change. It means that an entity state cannot be changed without some interaction
    with a domain event. However, in our code so far, the fact of changing the system
    state and raising a domain event is completely separated. Let's see how we can
    change it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续探讨事件源的概念，事件代表了状态变化的事实。这意味着没有与领域事件的交互，实体状态不能被改变。然而，在我们目前的代码中，改变系统状态和引发领域事件的事实是完全分离的。让我们看看我们如何可以改变它。
- en: 'First, we need to make some changes in the `Entity` base class:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`Entity`基类中做一些更改：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have renamed the `Raise` method to `Apply` since it will not only add events
    to the list of changes but physically apply the content of each event to the entity
    state. We do it by using the `When` method, which each entity needs to implement.
    The `Apply` method also calls the `EnsureValidState` method, which we previously
    had in the entity, but not in the base class. By doing this, we remove the need
    to call this method for each operation on the entity.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Raise`方法重命名为`Apply`，因为它不仅会将事件添加到更改列表中，而且还会将每个事件的内容物理应用到实体状态。我们通过使用每个实体都需要实现的`When`方法来完成。`Apply`方法还调用了我们之前在实体中但不在基类中拥有的`EnsureValidState`方法。通过这样做，我们消除了对每个实体操作调用此方法的必要性。
- en: 'The next step would be to apply domain events and move all state changes to
    the `When` method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是应用领域事件并将所有状态更改移动到`When`方法：
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are two essential things that we changed in the entity class, listed
    as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实体类中改变了两个基本的东西，如下列所示：
- en: All public methods to amend the entity state (operations) now apply to domain
    events. There are no state changes or validity checks left in those methods. As
    you remember, the validity contract method is now being called from the `Apply`
    method in the `Entity` base class.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有用于修改实体状态（操作）的公共方法现在都应用于领域事件。那些方法中不再有状态变化或有效性检查。正如你记得的，有效性合约方法现在是从`Entity`基类的`Apply`方法中调用的。
- en: We have added a `When` method override, where the advanced pattern matching
    feature of C# 7.1 is being used to identify what kind of event is being applied,
    and how the entity state needs to be changed.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个`When`方法重写，其中使用了C# 7.1的高级模式匹配功能来识别正在应用的事件类型，以及实体状态需要如何改变。
- en: Hence, there are no changes in tests. If we execute all tests in the solution
    that have been created so far, they will all pass. It means that raising domain
    events and applying them to change the entity state can be considered as implementation
    details. Indeed, this is a style of working with domain events, typically used
    when DDD is applied with Event Sourcing, which we will be discussing later.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试中没有变化。如果我们执行迄今为止创建的解决方案中的所有测试，它们都将通过。这意味着触发领域事件并将它们应用于更改实体状态可以被视为实现细节。实际上，这是一种使用领域事件的工作方式，通常在应用事件源（Event
    Sourcing）的领域驱动设计（DDD）中使用，我们将在稍后讨论。
- en: Please keep in mind that using DDD in general and domain events, in particular,
    does not imply using Event Sourcing, and vice versa. This book has more of a focus
    on Event Sourcing; therefore, this technique to change the state of the domain
    by applying events is presented quite early.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用DDD以及在特定情况下使用领域事件，并不意味着使用事件源，反之亦然。本书更侧重于事件源；因此，通过应用事件来更改领域状态的技术在早期就提出了。
- en: Some further changes are not that obvious but were required to make the whole
    thing work. If you look closely at the `When` method, entity properties that are
    still of value object types, use constructors for value objects instead of factory
    functions. It is because factory functions apply constraints and perform checks
    while constructing valid value objects. However, domain events represent something
    that already happened, so there is no point in checking these past facts for validity.
    If they were valid at the time, they should be just let through. Even if the logic
    in value object has changed, this should never have any effects on applying events
    with historical data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一些进一步的更改可能并不那么明显，但它们是使整个系统正常工作所必需的。如果您仔细查看`When`方法，仍然属于值对象类型的实体属性，使用值对象的构造函数而不是工厂函数。这是因为工厂函数在构建有效的值对象时应用约束并执行检查。然而，领域事件代表已经发生的事情，因此没有必要检查这些过去事实的有效性。如果它们在那时是有效的，它们应该被允许通过。即使值对象中的逻辑已经改变，这也永远不会对应用历史数据的事件产生影响。
- en: To fix this, we needed to change value objects, so they have internal constructors
    instead of private ones. Also, checks are moved from constructors to factory functions,
    so constructors are now accepting any value. For the more complex `Price` object,
    we needed to add a constructor that does not require a currency lookup service.
    Even if the currency is not valid anymore, when we are trying to load some past
    event, it should get through. However, it does not change the use of factory functions.
    They still require the lookup service and will be using it as soon as we create
    new instances of the value objects in our application service layer. It will keep
    protecting us from executing commands that have some incorrect information, and
    therefore, can bring our model to an invalid state.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要更改值对象，使它们具有内部构造函数而不是私有构造函数。此外，检查已从构造函数移动到工厂函数，因此构造函数现在可以接受任何值。对于更复杂的`Price`对象，我们需要添加一个不需要货币查找服务的构造函数。即使货币已经不再有效，当我们尝试加载某些过去的事件时，它也应该能够通过。然而，这并不改变工厂函数的使用。它们仍然需要查找服务，并且一旦我们在应用程序服务层中创建新的值对象实例，就会立即使用它。这将继续保护我们免受执行包含某些错误信息的命令的影响，这些命令可能会使我们的模型处于无效状态。
- en: 'In the following, you can find changed value object for the classified ad text:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，您可以找到更改后的分类广告文本的值对象：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the full code for the value object that represents the ad title:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是表示广告标题的值对象的完整代码：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, the `Price` class, which is based on the `Money` class but has some
    additional rules in place:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，基于`Money`类但有一些额外规则的`Price`类：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Again, although these changes might seem significant, we were not changing any
    domain logic and constraints. We have all existing tests intact, and they are
    still passing, so our refactoring was successful, and we managed to change implementation
    details while keeping the essence of our domain model intact.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽管这些变化可能看起来很重要，但我们并没有改变任何领域逻辑和约束。我们所有的现有测试都完好无损，并且仍在通过，所以我们的重构是成功的，我们成功地在保持领域模型本质不变的情况下改变了实现细节。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to write a lot of code and learned the basics of
    implementing domain models in code. We looked at entities and value objects, what
    they are needed for, and how different they are. Explaining the power of value
    objects consumed a significant part of this chapter, but this topic is vital since
    value objects are often overlooked.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始编写大量代码，并学习了在代码中实现领域模型的基础。我们研究了实体和价值对象，它们需要什么，以及它们的不同之处。解释价值对象的力量占据了本章相当大的篇幅，但这个主题至关重要，因为价值对象往往被忽视。
- en: We used factory functions to create different ways of constructing value objects.
    A similar technique can be used to form valid entities, but we were not touching
    this topic just yet. We also used a domain service to make use of some external
    services inside our value object, while keeping the domain model itself clean
    from any external dependencies.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了工厂函数来创建构建价值对象的多种方式。类似的技巧也可以用来形成有效的实体，但我们还没有触及这个话题。我们还使用领域服务来利用价值对象内部的一些外部服务，同时保持领域模型本身不受任何外部依赖的影响。
- en: Constraints and invariants that play such an important role in keeping the state
    of the system valid at all times were also discussed, and we used different techniques
    to implement them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持系统状态始终有效方面起着如此重要作用的约束和不变性也得到了讨论，我们使用了不同的技术来实现它们。
- en: Finally, we moved on to domain events and implemented some events that we previously
    only saw on orange stickies, directly in our code. Going forward, we learned how,
    from being a supportive tool, domain events could become the driver for state
    change in our model, and this lays a strong foundation for us before we move on
    to Event Sourcing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们转向领域事件，并在代码中实现了之前仅在橙色便利贴上看到的一些事件。展望未来，我们学习了如何使领域事件从辅助工具转变为模型状态变化的驱动因素，这为我们转向事件溯源奠定了坚实的基础。
- en: In this chapter, we also wrote some tests. Writing tests and keeping them actual
    is crucial in any programming work, but when using DDD and being in an explorative
    mode inside the model, tests become one of the most important instruments to handle
    regression, and even express and document business rules, as we will see in the
    following chapters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们也编写了一些测试。编写测试并保持其有效性在任何编程工作中都是至关重要的，但在使用领域驱动设计（DDD）并在模型内部处于探索模式时，测试成为处理回归问题最重要的工具之一，甚至可以表达和记录业务规则，正如我们将在接下来的章节中看到的。
- en: Since we started to move some of our sticky notes to code, in the next chapter,
    we will look at how to implement commands, and how commands are the glue between
    our domain model and the world outside it. In this state, we will learn how to
    make our model useful by letting people interact with it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们开始将一些便利贴移动到代码中，在下一章中，我们将探讨如何实现命令，以及命令是如何成为我们的领域模型与外部世界之间的粘合剂的。在这种状态下，我们将学习如何通过让人们与之交互来使我们的模型变得有用。
