- en: User Interface and System Feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever seen the top of an iceberg? Well, so far, that's what we have
    done throughout the previous six chapters. In this chapter, we will keep on improving
    on our game's user interface and feedback system. We will create a heads-up display
    that will be responsible for managing the user interaction with the system menus,
    as well as the system giving feedback to the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a heads-up display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HUD basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HUD framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completing our HUD design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character info panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active items panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special items panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemy stats in the HUD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPC stats user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the NPC canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPC taking a hit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Designing a heads-up display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing a **Heads-Up Display** (**HUD**) is a very challenging task. The HUD
    is the interface through which your players can interact with the virtual world
    and receive feedback from the virtual world environment. As with everything else
    we have designed so far, the HUD design is also heavily related to the type and
    the needs of the game you are trying to make.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a **Real-Time Strategy** (**RTS**) game will have a very different
    type of HUD design to a **First-Person Shooter** (**FPS**) or a **Role-Playing
    Game** (**RPG**). They will have some things in common, but their individual design
    is very distinctive, as well as some of the features and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We could have a whole book just about the design and development of user interfaces
    and how to approach them in a scientific manner. But that is outside the scope
    of this book, and we are concerned with the theories.
  prefs: []
  type: TYPE_NORMAL
- en: HUD basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any simple heads-up display will have, at a minimum, a way to display the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic information about the player character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strength
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current inventory items consumed by the player character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current weapon used by the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current armor used by the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available potions and/or health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feedback from the game environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything useful pertaining to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power ups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level ups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go ahead and design our HUD. Once again, we will start with a simple framework
    and slowly build on top of it as and when we need to.
  prefs: []
  type: TYPE_NORMAL
- en: Our design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking everything into consideration, let's go ahead and design a HUD that will
    be useful for our game. At the same time, we will keep it simple but useful. We
    should have a HUD that will display the basic player character information in
    a manner that does not block the gameplay, but at the same time gives critical
    information to the player regarding their character's state.
  prefs: []
  type: TYPE_NORMAL
- en: We should also design a way to display the current inventory items the player
    has activated to be used, such as the weapon or the armor. Finally, we should
    also have a simple way for the player to use any health packets and/or potions
    they might have during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a quick sketch of how I want my HUD to look. Again,
    you are free, and in fact, I encourage you, to come up with your own design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I have clearly marked roughly how I would like my HUD to look during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I have kept it simple. In the top-left corner, I have placed the
    immediate information that the player will need to have, such as their health
    and perhaps their strength.
  prefs: []
  type: TYPE_NORMAL
- en: In the bottom-left corner, I have placed a scroll-able panel that will list
    all of the active inventory items that the player may have active on their player
    character, and on the right-hand side of the screen I have three slots that will
    be used for immediate access to things such as health packets and/or potions that
    the player might need to use during their gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: HUD framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an understanding of how we want our UI to look, let's start
    implementing it in Unity. We need to create a new canvas to hold our HUD. To create
    the canvas, right-click in the Hierarchy window and select UI | Canvas. Rename
    the new canvas GameObject  `CanvasHUD`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and put into place all of the different sections for our UI.
    We will need three main panels for each section, as indicated in the following
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: We need a panel to hold the character information in the top-left corner of
    the screen. We will also need a panel to hold the active inventory items in the
    bottom-left corner of the screen, and another panel to hold the special items
    on the right-hand side of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create each panel by right-clicking the Hierarchy window and selecting UI |
    Panel. Make sure the panels are a child of the `CanvasHUD` GameObject. Rename
    each panel accordingly. I have named mine: `PanelCharacterInfo`, `PanelActiveItems`,
    and `PanelSpecialItems`. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Initial HUD outline
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot gives you a feeling of the HUD framework.
  prefs: []
  type: TYPE_NORMAL
- en: Completing our HUD design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the framework in place, let's go ahead and complete each section
    individually. I would like to start with the `PanelCharacterInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: Character info panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a design point of view, the panel that will contain the visual components
    for the character will be very complex. The panel will be composed of five images.
  prefs: []
  type: TYPE_NORMAL
- en: The main image will be used to hold an avatar of the character. The other four
    images will be used to display the health and mana of the character. Since these
    values will be displayed in a bar format, we will be using two images per item.
    One of the images will host the border, and the other the representation of the
    actual value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To come up with the images, I will use external tools such as Photoshop; Microsoft
    Expression Design is a good tool for creating frames and so on. Take a look at
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, I have made a nice image portraying the avatar
    of the player character. You should take into consideration the actual size of
    the image you will be placing inside the `PanelCharacterInfo` panel. The image
    size I have generated is 301 × 301 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the graphics for the bars representing the health and the mana for
    our character player, we will actually need to have three images. One image representing
    the negative value for the bar, one image representing the positive value of the
    bar, and the third will be the boarder image for the bar. They will be overlaid
    on top of each other to give the illusion of our graphic bars, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Health bar graphics
  prefs: []
  type: TYPE_NORMAL
- en: Creating the three distinct sprites and overlaying them will give you a good
    illusion of what you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: After exporting our images, we need to import them into Unity. Use your file
    system to move your images from their original location to the `Assets` folder
    under your Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have placed my textures in the following directory: Assets | RPG_2E | Textures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have moved them into the desired location within your Unity project,
    you will need to convert the images to sprites. Select all of the images that
    will be used for GUI, and from the Inspector window, change the Texture Type to
    Sprite (2D and UI). Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Image import properties
  prefs: []
  type: TYPE_NORMAL
- en: It's time to apply our textures to the actual UI elements we have defined under
    the `PanelCharacterInfo` panel within the `Canvas` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: There are a few steps that need to be performed before we can fully apply
    the UI elements to the HUD.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you should do if you have not done so already is creating three
    new UI image elements under the `PanelCharacterInfo` panel by right-clicking the
    panel and selecting UI | Image.
  prefs: []
  type: TYPE_NORMAL
- en: I have named my three images `imgHealthRebBackground`, `imgHealthGreenBackground`
    and `imgHealthBorder`. The order of the images does matter. You should take a
    note of it when you are designing the UI. Generally speaking, if a UI element
    is lower in the hierarchy, it will be rendered on top of the other elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Health-bar hookup
  prefs: []
  type: TYPE_NORMAL
- en: Notice the order of the images representing the health bar. The image that represents
    the green bar will need to be modified using the *Inspector *w*indow*. Select
    it, and change the *Image Type* to Filled, change the *Fill Method* to *Horizontal*
    and the *Fill Origin* to *Left*. We will be using the *Fill Amount* to control
    the visual part of our health bar. Notice that I have set it to `0.77` for demonstration
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when the game starts, we will be starting at a *Fill Amount* of
    `1`, which is equivalent to 100 percent for the player character's health. `0.77`
    is equivalent to 77 percent and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will apply the same technique for our mana bar. Go ahead and create two more
    images, which will represent the two backgrounds for our mana bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: We will be using the same border image for both bars.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, don't forget you will need to make the appropriate changes to the imported
    textures within Unity. Convert them to Sprite *(2D and UI) Texture Type*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the necessary image UI elements under the panel, and apply the textures
    to the image element within the canvas. You should have something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Mana-bar hookup
  prefs: []
  type: TYPE_NORMAL
- en: That's all there is to it! Not bad for a person with no artistic background!
  prefs: []
  type: TYPE_NORMAL
- en: Active inventory items panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating the UI for active inventory items is similar to what we have done in
    [Chapter 6](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79), *Inventory
    System*. The difference is that we will be listing only the items that have been
    consumed by the player character using the inventory system.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the Active Inventory Items display is a visual indication of
    the items that have been activated within the inventory. It is important to keep
    in mind that we are more interested in learning the concepts and applying them
    in a simple example that you can expand upon and improve on your own.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is to create a scroll-able panel that will be used to add items
    as needed. We have already seen how to set up the scroll-able view and how to
    configure the UI components to support what we are trying to achieve. I won't
    be getting into the details here again; please refer to [Chapter 6](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *Inventory System* for the necessary steps if needed.
  prefs: []
  type: TYPE_NORMAL
- en: From the *Hierarchy* window right-click on PanelActiveInventoryItems and select
    *UI* | *Scroll View*. Go ahead and remove the `Viewport`*,* `Scrollbar Horizontal`
    and `Scrollbar Vertical` children that have been created with the `Scroll View`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'You just need to make sure that the layout configuration you are applying is
    for horizontal and not vertical, as we did in [Chapter 6](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *Inventory System*. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Active inventory panel
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-check your anchors and alignments in the UI elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And finally, take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The three preceding figures illustrate the different parts of the configuration
    for the Active Inventory Items panel. If you are unsure of how to put this together,
    please go back to [Chapter 6](part0122.html#3KB4K0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *Inventory System*, and read the *Designing a Dynamic Item Viewer* section.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to make a prefab of the UI element that will be representing your
    active inventory item in the panel.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need a script to reference the UI elements designated for your
    items. I have called this script `ActiveInventoryItemUi.cs`, and currently, there
    are two attributes; one is a reference to the `Image` element and the other a
    reference to the `Text` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listing for the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will eventually need to integrate all of these scripts together to make things
    work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Special items panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will look at the design of our last panel. The main difference between
    this panel and the last one we developed is the orientation. Everything else will
    be exactly the same. However, for this panel, our orientation will be vertical
    instead of horizontal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot capturing everything at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Special items panel
  prefs: []
  type: TYPE_NORMAL
- en: The procedure to create the panel has already been discussed several times,
    and you should not have any trouble creating it.
  prefs: []
  type: TYPE_NORMAL
- en: I have let you make your own textures and images to apply to the UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: While designing the Special Items panel, I came up with a better idea of how
    to improve the panel UI. You might want to have a static icon representing each
    special item, and have a counter attached to the UI representing how many of each
    item you have. Each time you collect one, it will increase, and each time you
    consume one it will decrease.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the current HUD looks based on our design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Active inventory and special inventory runtime
  prefs: []
  type: TYPE_NORMAL
- en: We now need to start thinking about the integration of the HUD user interface
    with the code base we have developed so far.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our HUD design up and running, we will need to integrate the
    UI elements with the actual code that will be deriving them. There are a few scripts
    that will be created to support the new UI features and a few that will be updated
    to glue everything together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following scripts have been created: `ActiveInventoryItemUi.cs`, `ActiveSpecialItemUi.cs`,
    and `HudElementUi.cs`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The listing of these scripts is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These scripts will be used on the HUD user interface to give us access to the
    elements. For instance, you will need to attach the `HudElementUi.cs` script to
    the `CanvasHUD` GameObject. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: HUD canvas
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot illustrates how the HUD canvas is configured with the
    `HUDElementsUI.cs` script.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at the prefabs we have created to represent the UI elements
    to be used for the panels. There are two; I have named them `PanelActiveItem`
    and `PanelSpecialItem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will discuss `PanelSpecialItem` as it contains everything `PanelActiveItem`
    contains plus an additional script, which is attached to it for event handling.
    Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: HUD event triggers
  prefs: []
  type: TYPE_NORMAL
- en: What we have just covered was the implementation of the scripts that are used
    to have access to the proper UI elements within the HUD canvas.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that for the `PanelSpecialItem` prefab, we have two new and
    very important components that we have attached to it. One is the **Event Trigger**
    within Unity, and the other is the `ActiveSpecialItemUi.cs` script, which is used
    to handle the `PointerClick` event for the special item.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that we are basically making the item clickable, and when
    the player clicks on the item, something happens. In this case, it applies the
    special item to the player character.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to update the other scripts we have already developed to incorporate
    the HUD functionality. The scripts that will need to be modified are `InventorySystem.cs`
    and `UiController.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listing of `InventorySystem.cs` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The listing for `ClearInventory()` and `AddItem()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`DeleteItem()` will remove a given `InventoryItem` from the list. See the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The listing for `UiController.cs` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A portion of script is listed as follows. Please refer to the download package
    for the full listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have everything in place, you can go ahead and test run the game
    to make sure everything is working as expected. This is also a good time to test/debug
    your code and your project settings if you have not done so already.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have to make the following point once again: the idea is to grasp the concept.
    We are looking at one way to implement what we want to achieve; you might come
    up with a better method along the way, or decide to do something totally different.
    I encourage that!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Initial state
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot illustrates the state of the player character and that
    of the inventory when the level initially loads. I have indicated the critical
    parts that we are testing and will track, to make sure our code works properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next figure, the player character has picked up a few of the inventory
    items we have laid on the level. When you bring up the Inventory window and click
    on any one of the categories defined, such as weapons, you will get a listing
    of all the weapons that we have in our inventory, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have collected one weapon type, one health packet, and a couple of defensive
    items. Note that our Special Items panel is displaying an item. This is the health
    packet we have picked up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Special item interaction
  prefs: []
  type: TYPE_NORMAL
- en: The next screenshot illustrates how the HUD updates itself when the player starts
    to consume some of the inventory items by adding them using the Inventory window
    during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we have activated three inventory items: two weapons, named axe2
    and club1, and two armors of type SP04 and SP03 respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visually see them on the player character as well as the panel holding
    the active inventory items. Pretty cool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Active panel interaction
  prefs: []
  type: TYPE_NORMAL
- en: It's time to go and meet the enemy. We have not discussed much about the interaction
    between the player character and the **non-player characters** (**NPCs**). We
    will do this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: We have applied some of the inventory items from our inventory to the player
    character, and now we can actually go and face the enemy. We will allow the enemy
    to attack us, to see how our health reduces. Then we will use the health packet
    from our special items panel to increase our health once more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two following screenshots illustrate this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows us running away and applying our health packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how, when we apply the health packet, it removes itself from the inventory
    system as well as the special items panel.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy stats in the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have not really discussed how to handle and manage the statistics and the
    visual representation of the NPC with the player. It is now time to do just that!
    We need to decide what it is that we want to display as information to the player.
    At the moment, let's keep it simple and just display the basic health and strength
    of the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, what is the best way to display this information? Should we
    display the information based on a distance threshold between the player character
    and the NPC, or should we display it when the player requests it at some time
    during gameplay?
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and take the first scenario. We will display the information
    of the NPC when there is a certain distance between the player character and the
    NPC. We can even make this distance the same as the line of sight we have set
    for the NPC! This is good, because, if they can see us, then they are close enough
    for us to see their stats! Let's get to work!
  prefs: []
  type: TYPE_NORMAL
- en: NPC stats user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using some of the existing textures that we have created for our
    player character, such as the textures for the health bar and strength bar. We
    just need to create a canvas that will be in the world space and attached to the
    NPC character.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the NPC canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main differences between the canvas we will create for the NPC and that
    of the one we have been creating for the player are some of the configurations.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main differences will be the *Render Mode* of the canvas. The NPC
    canvas will have a *World Space Render Mode*. This will allow us to position the
    canvas as another GameObject within the scene. The next important difference will
    be the *Rect Transform* attributes and, more importantly, the *Scale* and *Rotation*
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: NPC health bar
  prefs: []
  type: TYPE_NORMAL
- en: To make life easier, all you need to do is create the canvas and change the
    properties of the canvas as shown in the preceding screenshot. For the next step,
    you can copy the whole `PanelCharacterInfo` we developed in the previous sections,
    and paste it as a child of the new canvas. This way, you will not have to recreate
    each UI element one by one, which will save a lot of time. However, you will need
    to change the *Scale* and the Tranform properties on the `PanelCharacterInfo`
    panel—the new one—to arrange it so that it renders above the NPC's head!
  prefs: []
  type: TYPE_NORMAL
- en: The next step is for us to be able to control the values of the stat bars from
    the code. For this, we will create a new script called `NPCStatUi.cs` and attach
    it to the canvas object we just created for the NPC stats.
  prefs: []
  type: TYPE_NORMAL
- en: I have renamed the canvas `CanvasNPCStats`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listing of the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The script we just created will only give us a reference to the image elements.
    We still need to be able to have a method to update the values.
  prefs: []
  type: TYPE_NORMAL
- en: We need to find a way to reference all the NPC characters in a given scene.
    Once that is determined, we will need to set the initial values of the health
    and strength bar. Then, during gameplay, we will need to be able to update each
    NPC's stats according to the state of the game.
  prefs: []
  type: TYPE_NORMAL
- en: In order for us to identify the NPCs in a given scene, we will use the `Tag`
    element defined in each GameObject. We need to create a new `Tag` element named
    *Enemy*, and every NPC that is of enemy type will need to be tagged as such. This
    is an easy way to do a quick search and get a list of GameObjects based on their
    `Tag` value.
  prefs: []
  type: TYPE_NORMAL
- en: You should also start thinking about how are you going to dynamically attach
    the NPC stat canvas to the NPC at runtime. At the moment, for testing purposes,
    I will leave it attached to the model. But the question is, where do you actually
    attach it? Well, we have an empty GameObject named *Follow* attached to our model
    prefab. Since this is driven from our player character model, we have embedded
    *Follow* as a placeholder for the main camera during gameplay. For the NPC, we
    will use it to attach the NPC canvas as a child GameObject to the `Follow` GameObject
    in the model hierarchy. You can see these in the preceding screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `NpcAgent.cs` script to initialize the NPC status canvas prefab
    and the appropriate values of the UI elements. This is the best place to place
    the initialization because it will be self-contained. The new listing for the
    script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that you will need to assign `canvasNPCStatsAttachment`*,* which will be
    used to store a reference to the GameObject we will attach to the NCP canvas.
    `canvasNPCStatsPrefab` will be used to assign the prefab representing the NPC
    status canvas at design time. If you run the game now, you will have the prefab
    instantiated dynamically and attached to the `Follow` GameObject in the hierarchy
    with the fill values set to `1f`, that is, 100 percent.
  prefs: []
  type: TYPE_NORMAL
- en: NPC taking a hit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to take a moment and go back to some of the initial scripts and configurations
    we did in earlier chapters, where we defined the player character's *Animator
    Controller* and `BarbarianCharacterController.cs` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Please refer to Chapter 3, *RPG Character Design*, to refresh your memory
    on Animator Controller and Curves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the animator controller we created in [Chapter 3](part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *RPG Character Design*, named `BarbarianAnimatorController`. Select the *Parameters*
    tab and create new parameters called *Attack1, Attack2,* and *Attack3* of the `float`
    datatype. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Animator State Machine
  prefs: []
  type: TYPE_NORMAL
- en: For a refresher, go back to [Chapter 4](part0094.html#2PKKS0-7a1ef7ae3ef249cdb149f8344d2e8e79), *The
    Game Mechanics*, section *PC and NPC Interaction*, and you will recall how we
    defined and configured the curve to assign the parameter based on the animation.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the curve only for one of the attack animations.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have configured the parameter on the *Animator Controller* for the
    player character, then we have to update the `BarbarianCharacterController.cs`
    script to trigger an attack based on the parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing is a partial listing of the script, displaying just the
    modified portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we check to see if any of the attack modes are active and if so
    we check to see what the curve parameter *Attack1* is at the moment of the animation.
    If we are at `1.0f`, then we call the `GameMaster` object to perform the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to take a look at a few functions we have defined/modified in the `GameMaster.cs`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Some explanation is needed here. So the `OnLevelWasLoaded()` function is called
    each time a new scene is loaded at runtime. This is where we query all GameObjects
    that are tagged `Enemy`. We then store them internally, for further processing
    down the line.
  prefs: []
  type: TYPE_NORMAL
- en: For testing purposes and due to the simplicity of the scene, there is only one
    enemy present for testing. I am also setting the `closestNPCEnemy` object to the
    last GameObject tagged `Enemy`. This variable is later used in the `PlayerAttachEnemy()`
    function to set the NPCs `Health` property.
  prefs: []
  type: TYPE_NORMAL
- en: When the `PlayerAttackEnemy()` function is called, we get a reference to the
    NPC component of the NPC character and reduce the health based on the attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this also forces us to update the `BaseCharacter.cs` script. A listing
    of the modification is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the `Health` property, we check to see if we are the player, or an NPC. If
    we are the player, we need to use `GameMaster` to update our `Stats` UI, if we
    are going to update our own NPC `Stats` UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that when you create your player character and/or NPC, you will
    need to make sure you are assigning the data elements properly; see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code and scripts we have looked at have been used to test the ideas we have
    put forth. The results are positive. You might have noticed that when the player
    character attacks, we do not take into consideration its position relative to
    that of the enemy. We are also automatically assigning the closest NPC character
    in `GameMaster` to eventually be the last element of the query we give each time
    a level loads.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One last code implementation I would like to make before I close out the chapter,
    is to make sure that when we are in attack mode for the player character, the
    hit points will affect the NPC that it is intended for automatically. In other
    words, determine which NPC is closest to us based on our distance and view angle
    toward the NPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already created the logic to determine these quantities for the NPC
    character. We now need to implement something similar for the player character.
    Let''s take a look at a partial listing of the code changes we need to make for
    the `BarbarianCharacterMovement.cs` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The way we calculate the sight and distance of the enemy NPCs is through **Raycasting**.
    This is done only when we are in attack mode; we check to see if the NPC is in
    front of us and, if so, we set the `ClosestNpcEnemy` object on `GameMaster` and
    set the `enemyInSight` flag, where we then perform the necessary subtraction from
    the health of the NPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that I have also changed the way we compute the impact of the hit based
    on a simple equation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *pc* is the object reference to our player character. The same equation
    is used on the NPC objects. This is just a simple demonstration that the impact
    of the hit point of the player or the NPC is based on the strength and the health
    of the actors in the scene. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Determining if the NPC is in sight
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot illustrates how we detect if an NPC is in attack range
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, you can derive the strength value from the components that the player
    or the NPC has activated throughout the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: 'A partial listing of `BaseCharacter.cs` illustrating the `HEALTH` property
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are more code changes and updates; please refer to the associated files
    provided for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the implementation process, I have modified a few other code locations,
    which are not listed within the book due to physical limitations. Here are the
    scripts that have been modified: `BaseCharacter.cs`, `BarbarianCharacterController.cs`,
    `GameMaster.cs`, `NpcAgent.cs`, `PlayerAgent.cs` and `NpcBarbarianMovement.cs`.
    Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: GameMaster handling multiple NPCs
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to do some research and try different types of mechanics
    and implementation to enhance your skills.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have expanded on our idea and looked at how to integrate
    all of the major pieces together. The main objective of the chapter was to create
    a heads-up display (HUD) for our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started out with a design concept that was of interest to us, and created
    a layout for our HUD before the actual implementation. Once we concluded how the
    HUD should look, we started building the framework for it. We designed the three
    main sections of the HUD and referred to them as the following: `PanelCharacterInfo`,
    `PanelActiveItems`, and `PanelSpecialItems`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we started to build the UI elements and the code necessary to make the
    panels work with our code. We started with `PanelCharacterInfo`, which represented
    the stats for our character player, that is, a reference to the player's avatar,
    a reference to the health, and a reference to the strength of the character. In
    the process, we had to create or update several of the scripts to work with the
    new UI.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we designed and developed the `PanelActiveItems` panel. The implementation
    and approach to this specific panel was a little more involved. The purpose of
    this panel is to display all of the current active inventory items that the player
    has consumed. We had to make the panel scroll-able since we don't know how many
    items the player will be consuming at any given time. We created the necessary
    prefabs to be placeholders for the inventory items, as well as the scripts that
    make them work together.
  prefs: []
  type: TYPE_NORMAL
- en: The design for `PanelSpecialItems` was very similar to that of `PanelActiveItems`,
    with two main differences. First, we had to make sure that the panel was vertical
    instead of horizontal, so we had to make sure that the proper configuration was
    applied. Secondly, the main functionality was different for this panel. The items
    displayed were supposed to be intractable, which meant that we had to create custom
    event handlers, apply the necessary values to the player character, and update
    the whole game state.
  prefs: []
  type: TYPE_NORMAL
- en: Once we were satisfied with the design of our HUD, we started building the necessary
    scripts to integrate the UI elements with the `GameMaster` and other scripts.
    This was basically making sure that our UI was always reflecting the state of
    the object that was of interest to us. The health, stamina, and inventory are
    the main items we used to communicate the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of the chapter, we concentrated on the implementation of
    the player's character movement and detection of the NPCs, and how to track the
    hit points between the player character and the NPC, which was not done in previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We also had to do some backtracking and make some adjustments to the animation
    controller we had defined for our player character, to have curves defined for
    our attack animation values based on the motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the process, we had to solve the following challenges: How do we know
    if we are in close enough range that we can actually attack and hit the NPC character?
    How are we going to detect which NPC is closer to us? More importantly, how is
    the data going to be passed along from the action of attacking to the actual hit
    on the NPC?'
  prefs: []
  type: TYPE_NORMAL
- en: We have done a lot in a short period of time and in a small number of pages.
    Some of the functions have been left for the reader to solve on their own. For
    instance, we have not discussed how to delete an inventory item and so on. I felt
    this to be trivial, and that the reader will be comfortable enough to implement
    the function on their own once they see the bigger scope and how to connect everything
    together.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, let's move on to the next and final chapter, covering multiplayer!
  prefs: []
  type: TYPE_NORMAL
