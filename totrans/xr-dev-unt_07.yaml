- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Adding Sound and Visual Effects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加声音和视觉效果
- en: Creating immersive XR experiences requires more than just importing 3D assets
    and scripting interactivity. For a truly natural and captivating experience, we
    need to integrate sound and visual effects. Imagine an AR monster hunt game. You’ve
    built the logic, but without sound and visual effects, the blend of real world
    and virtual reality feels off. Adding subtle monster sounds can provide direction
    and distance clues. Integrating a particle effect such as gray fog can enhance
    the spooky, mysterious atmosphere. By stimulating multiple senses and adapting
    these elements to a user’s movements, we can significantly enhance the overall
    immersion and user experience of the AR monster hunt game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建沉浸式XR体验不仅需要导入3D资产和编写交互脚本。为了实现真正自然和吸引人的体验，我们需要整合声音和视觉效果。想象一下一个AR怪物狩猎游戏。您已经构建了逻辑，但没有声音和视觉效果，现实世界与虚拟现实的感觉就会失调。添加微妙的怪物声音可以提供方向和距离线索。整合如灰色雾气这样的粒子效果可以增强神秘、恐怖的氛围。通过刺激多种感官并调整这些元素以适应用户的动作，我们可以显著增强AR怪物狩猎游戏的整体沉浸感和用户体验。
- en: This chapter aims to enhance your XR design skills, targeting more user senses
    for natural, immersive experiences. We’ll delve into sound theory and particle
    behavior basics, making these physics concepts accessible to all. We will delve
    into Unity’s audio and particle systems to understand how they can help us recreate
    real-world phenomena. In line with our hands-on approach, you’ll apply these concepts
    in a practical VR project in Unity, creating your most immersive VR experience
    yet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在提高您的XR设计技能，针对更多用户感官以实现自然、沉浸式的体验。我们将深入研究声音理论和粒子行为的基础知识，使这些物理概念对所有用户都易于理解。我们将深入研究Unity的音频和粒子系统，了解它们如何帮助我们重现现实世界现象。按照我们的动手实践方法，您将在Unity中应用这些概念，创建您迄今为止最沉浸式的VR体验。
- en: 'Let’s dive into this thrilling exploration of creating realistic XR experiences!
    This chapter guides you on your way through these four sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探索创建逼真XR体验的激动人心之旅！本章将引导您通过以下四个部分：
- en: Understanding sound theory and Unity’s audio system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解声音理论和Unity的音频系统
- en: Preparing the VR drum scene and adding sound effects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备VR鼓场景并添加音效
- en: Understanding particle behavior and Unity’s particle system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解粒子行为和Unity的粒子系统
- en: Adding particles to VR scenes with varying properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有不同属性的VR场景中添加粒子
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To fully engage with and benefit from the VR application development process
    outlined in this chapter, your hardware must meet certain technical specifications.
    If you followed the tutorial in [*Chapter 3*](B20869_03.xhtml#_idTextAnchor009)
    and your Unity setup remains the same, you can bypass this section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分参与并从本章概述的VR应用开发过程中受益，您的硬件必须满足某些技术规格。如果您遵循了[*第3章*](B20869_03.xhtml#_idTextAnchor009)中的教程，并且您的Unity设置保持不变，您可以跳过本节。
- en: To follow along with this book’s content and examples, ensure your computer
    system can accommodate *Unity 2021.3 LTS* or a more recent edition, with *Android*
    or *Windows/Mac/Linux Build Support*, depending on the nature of your VR headset
    and PC.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本书的内容和示例，请确保您的计算机系统可以容纳*Unity 2021.3 LTS*或更高版本，以及*Android*或*Windows/Mac/Linux构建支持*，具体取决于您的VR头盔和PC的性质。
- en: Understanding sound theory and Unity’s audio system
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解声音理论和Unity的音频系统
- en: In the subsequent sections, we will delve into the fascinating physics of sound
    waves and explore how Unity’s robust audio system allows us to manipulate these
    properties with its diverse range of audio components. Our journey begins with
    an introduction to the fundamentals of sound, the nature of sound itself, and
    its defining features – frequency and amplitude.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入研究声波的迷人物理特性，并探讨Unity强大的音频系统如何通过其多样化的音频组件来操纵这些属性。我们的旅程从声音的基本原理开始，声音的本质及其定义特征——频率和振幅。
- en: What are frequency and amplitude?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 频率和振幅是什么？
- en: Sound, in essence, is a form of mechanical energy that propagates as a wave
    through a medium – most commonly, air. Simply put, mechanical energy is energy
    associated with the motion of objects. When an object vibrates, it displaces the
    surrounding air particles, setting off a chain reaction of particle displacement
    that travels outward in the form of a sound wave.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，声音是一种机械能，它以波的形式通过介质传播——最常见的是空气。简单来说，机械能是与物体运动相关的能量。当一个物体振动时，它会移动周围的空气粒子，引发一系列粒子位移的连锁反应，这些反应以声波的形式向外传播。
- en: The two main parameters describing a sound wave are frequency and amplitude.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 描述声音波的两个主要参数是频率和振幅。
- en: '**Frequency** is the number of complete wave cycles per second, measured in
    **Hertz** (**Hz**). It determines the pitch of the sound – a higher frequency
    corresponds to a higher pitch, and a lower frequency corresponds to a lower pitch.
    In game development, understanding frequency is crucial. For instance, a small,
    light creature such as a bird would have a high-pitched (high-frequency) chirp,
    while a large creature such as an elephant would have a low-pitched (low-frequency)
    roar.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**频率**是每秒完成的波周期数，以**赫兹**（**Hz**）为单位测量。它决定了声音的音调——频率越高，音调越高；频率越低，音调越低。在游戏开发中，理解频率至关重要。例如，像小鸟这样小而轻的动物会有高音调（高频）的啁啾，而像大象这样大的动物会有低音调（低频）的吼叫。'
- en: '**Amplitude** refers to the maximum displacement of particles by the sound
    wave. In simpler terms, it’s how far the particles are pushed when the wave passes
    through. It corresponds to the loudness of the sound – a larger amplitude means
    a louder sound, and a smaller amplitude means a quieter sound. In games and XR
    applications, amplitude can be used to create a sense of distance. A sound source
    far from the player would have a smaller amplitude and thus sound quieter, while
    a source close to the player would sound louder.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**振幅**指的是声波推动粒子的最大位移。简单来说，就是当波通过时粒子被推得有多远。它对应于声音的响度——振幅越大，声音越响；振幅越小，声音越轻。在游戏和XR应用中，振幅可以用来创造距离感。远离玩家的声音源会有较小的振幅，因此听起来较轻，而靠近玩家的声音源听起来较响。'
- en: Understanding other properties of sound
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解声音的其他特性
- en: 'While frequency and amplitude are fundamental, several other properties can
    add depth to the sound experience in XR. These include timbre (pronounced *tamber*),
    envelope, spatial audio, reverberation, and echo. Let’s go through them step by
    step:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然频率和振幅是基本的，但还有其他几个特性可以增加XR中声音体验的深度。这些包括音色（发音为*tamber*）、包络、空间音频、混响和回声。让我们一步一步地了解它们：
- en: '**Timbre**: This describes the color or quality of a sound and allows us to
    distinguish between different sound sources that may have the same pitch and loudness.
    Here, *color* refers to the unique characteristics and tonal nuances of a sound
    that differentiate it from other sounds. It’s what allows us to tell the difference
    between a violin and a flute, even if they’re playing the same note at the same
    volume. In game development, timbre can be used to give different characters or
    environments their unique sound signatures.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音色**：这描述了声音的颜色或质量，使我们能够区分具有相同音调和响度的不同声音源。在这里，“颜色”指的是声音的独特特征和音调细微差别，使其与其他声音区分开来。这就是我们能够区分小提琴和长笛，即使它们在相同的音量和音调下演奏同一音符的原因。在游戏开发中，音色可以用来给不同的角色或环境赋予它们独特的声音特征。'
- en: '**Envelope**: The envelope of a sound refers to how it evolves over time. It’s
    traditionally broken down into four parts – **Attack, Decay, Sustain, and Release**
    (**ADSR**). ADSR describes the initial spike of a sound (attack), the subsequent
    decrease to a stable level (decay), the maintenance of that level for a duration
    (sustain), and the eventual fading away of the sound (release). In XR, modifying
    the ADSR envelope can make sounds seem more realistic or can be used creatively
    to give sounds a stylized feel.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包络**：声音的包络指的是它随时间的变化。传统上，它被分为四个部分——**攻击、衰减、持续和释放**（**ADSR**）。ADSR描述了声音的初始峰值（攻击），随后降至稳定水平（衰减），在该水平上维持一段时间（持续），以及声音最终逐渐消失（释放）。在XR中，修改ADSR包络可以使声音听起来更真实，或者可以创造性地使用，给声音带来一种风格化的感觉。'
- en: '**Spatial audio**: This refers to the perception of the direction and distance
    of a sound source. Our brains use several cues to pinpoint the location of a sound
    source, such as the time difference between the sound reaching our two ears (binaural
    cues), the change in frequency caused by the shape of our ears (spectral cues),
    and the change in sound as we move our heads (dynamic cues). Game and XR developers
    can simulate these effects to create immersive 3D soundscapes, where players can
    locate a sound source within the game environment. For instance, in a VR horror
    game, you could use spatial audio to make it sound like eerie whispers are coming
    from just over the player’s shoulder, or like the ominous footsteps of a monster
    are getting closer and closer. These techniques can significantly enhance immersion
    and even gameplay, as players could use sound to navigate their environment or
    detect threats.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间音频**：这指的是对声音源方向和距离的感知。我们的大脑使用几个线索来确定声音源的位置，例如声音到达我们两只耳朵之间的时间差（双耳线索）、耳朵形状引起的频率变化（频谱线索），以及我们移动头部时声音的变化（动态线索）。游戏和XR开发者可以模拟这些效果来创建沉浸式的3D声音景观，玩家可以在游戏环境中定位声音源。例如，在VR恐怖游戏中，你可以使用空间音频让玩家听起来像是从玩家肩膀上方传来的诡异低语，或者像怪物逼近的脚步声越来越近。这些技术可以显著增强沉浸感和游戏体验，因为玩家可以利用声音来导航环境或检测威胁。'
- en: '**Reverberation** or **reverb**: This is the persistence of sound in a particular
    space after the original sound is removed. It’s caused by sound waves reflecting
    off surfaces in the environment, such as walls and floors, creating a multitude
    of echoes that gradually fade out. This can give players a sense of the size and
    material of the space they’re in – a large, stone-walled cathedral would have
    a long, bright reverb, while a small, carpeted room would have a short, dull reverb.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混响**或**回声**：这是在原始声音移除后，特定空间中声音的持续存在。它是由声音波在环境中的表面（如墙壁和地板）反射造成的，产生了众多逐渐消失的回声。这可以让玩家感受到他们所在空间的大小和材质——一个大型、石墙的大教堂会有长而明亮的混响，而一个小型、地毯覆盖的房间则会有短而暗淡的混响。'
- en: '**Echo**: This is the distinct, delayed reflection of sound that can be clearly
    identified as a repetition of the original source. It’s caused when sound waves
    bounce off distant obstacles and return to the listener after a noticeable time
    gap. The time it takes for the reflection to return can give listeners an impression
    of the distance to the reflecting surface – a mountain range would produce a long-delayed
    echo, while a closer building might yield a quicker, more immediate echo. Different
    surfaces can also affect the tonal quality of the echo, with hard surfaces such
    as concrete producing clearer echoes compared to softer surfaces such as dense
    foliage.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回声**：这是可以清楚识别为原始声音重复的明显延迟声音反射。它发生在声音波从远处障碍物反弹回来，并在明显的时间间隔后到达听者时。反射返回所需的时间可以让听者对反射表面的距离有印象——山脉会产生长延迟的回声，而较近的建筑可能会产生更快、更直接的回声。不同的表面也会影响回声的音调质量，硬表面如混凝土产生的回声比软表面如茂密的植被更清晰。'
- en: Understanding and manipulating these aspects of sound can allow you to create
    rich, immersive, and interactive soundscapes in your XR applications. With careful
    design, sound can be not only an accompaniment to the visual experience but also
    a key element of gameplay and immersion. The following section introduces you
    to Unity’s audio system, which we will use throughout this chapter to breathe
    even more life and immersion into our XR experiences.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和操作这些声音方面的特性，可以使你在XR应用程序中创建丰富、沉浸和交互式的声音景观。通过精心设计，声音不仅可以作为视觉体验的伴奏，还可以成为游戏玩法和沉浸感的关键元素。以下部分将向您介绍Unity的音频系统，我们将在本章中多次使用它，为我们的XR体验注入更多生命力和沉浸感。
- en: Exploring Unity’s audio system
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Unity的音频系统
- en: Sound design is an essential part of creating immersive XR experiences. With
    Unity’s audio system, you can create dynamic, spatialized audio that reacts to
    the player’s actions and movements, enhancing immersion and even guiding gameplay.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 声音设计是创建沉浸式XR体验的重要组成部分。使用Unity的音频系统，你可以创建动态、空间化的音频，它会对玩家的动作和移动做出反应，增强沉浸感甚至引导游戏玩法。
- en: For instance, in a VR horror game, you could use spatialized sound to create
    an ominous atmosphere and build tension. Distant, eerie noises could hint at unseen
    dangers, while sudden, nearby sounds could provide jump scares. As the player
    navigates the environment, the sounds change based on their position and orientation,
    making the virtual world feel alive and reactive.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 VR 恐怖游戏中，您可以使用空间化声音来创造一种不祥的氛围并建立紧张感。远处的诡异声音可能暗示着看不见的危险，而突然的近距离声音可能提供跳跃惊吓。随着玩家在环境中导航，声音根据他们的位置和方向变化，使虚拟世界感觉生动且反应灵敏。
- en: Understanding and effectively using Unity’s audio system is a crucial skill
    for any XR developer. Sound isn’t just an accessory to the visuals; it’s also
    a powerful tool for storytelling, player guidance, and world-building.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并有效地使用 Unity 的音频系统是任何 XR 开发者必备的关键技能。声音不仅仅是视觉的附属品；它也是叙事、玩家指导和世界构建的强大工具。
- en: Let’s now take a more detailed look at the three core components of Unity’s
    audio system – AudioClips, AudioSources, and AudioListeners.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地看看 Unity 音频系统的三个核心组件——AudioClips、AudioSources 和 AudioListeners。
- en: '`AudioClip` represents a sound file that can be played back in your application.
    It holds the data for the sound, but on its own, it can’t actually produce sound.
    Think of an `AudioClip` file like a CD – it holds music, but you need a CD player
    to actually hear the music. `AudioClip` files are versatile – you can use them
    for short sound effects, such as a character’s footsteps, or for longer pieces
    of audio, such as background music or dialogue. Unity supports a range of audio
    file formats, including `.wav`, `.mp3`, and `.ogg`. When designing sound for XR,
    remember that audio quality is important for immersion. High-quality `AudioClip`
    files can make a virtual environment feel more real.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioClip` 代表一个可以在您的应用程序中播放的声音文件。它包含声音数据，但单独的 `AudioClip` 文件实际上不能产生声音。将 `AudioClip`
    文件想象成一张 CD——它包含音乐，但您需要一个 CD 播放器才能真正听到音乐。`AudioClip` 文件非常灵活——您可以用它们来制作短声音效果，如角色的脚步声，或者用于较长的音频片段，如背景音乐或对话。Unity
    支持多种音频文件格式，包括 `.wav`、`.mp3` 和 `.ogg`。在设计 XR 的声音时，请记住，音质对于沉浸感非常重要。高质量的 `AudioClip`
    文件可以使虚拟环境感觉更加真实。'
- en: '`AudioSource` is like a CD player for your `AudioClip` file. It’s a component
    that can be attached to a GameObject to play sounds. You can think of it as a
    point in your 3D space where sound originates. Every sound you hear in a Unity
    application originates from an `AudioSource` component. An `AudioSource` component
    plays back an `AudioClip` file in the scene and controls how that sound is played.
    The `AudioSource` component offers several properties that you can manipulate:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioSource` 就像是您的 `AudioClip` 文件的 CD 播放器。它是一个可以附加到 GameObject 上的组件，用于播放声音。您可以将其视为您
    3D 空间中声音起源的点。在 Unity 应用程序中听到的每一个声音都源自 `AudioSource` 组件。`AudioSource` 组件在场景中播放
    `AudioClip` 文件，并控制声音的播放方式。`AudioSource` 组件提供了一些您可以操作的属性：'
- en: '`AudioClip` file that will be played.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要播放的 `AudioClip` 文件。
- en: '`AudioSource` component will start playing its `AudioClip` file as soon as
    the scene starts.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioSource` 组件将在场景开始时立即播放其 `AudioClip` 文件。'
- en: '`AudioSource` component will loop its `AudioClip` file, starting it again as
    soon as it ends.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioSource` 组件将循环其 `AudioClip` 文件，一旦结束就重新开始播放。'
- en: '`AudioSource` component, and can be used to fade sounds in or out.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioSource` 组件，并且可以用来淡入或淡出声音。'
- en: '`AudioSource`. Higher values result in a higher pitch, and lower values result
    in a lower pitch. This can be used to create a **Doppler effect**, which is a
    change in the frequency or wavelength of a wave for an observer moving relative
    to its source – for instance, the sound of a passing car changing from high to
    low pitch.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioSource`。值越高，音调越高；值越低，音调越低。这可以用来创建 **多普勒效应**，即观察者相对于其源移动时波频率或波长的变化——例如，行驶的汽车的声音从高音调变为低音调。'
- en: '**3D Sound Settings**: These settings control how the sound is affected by
    distance. You can make the sound get quieter with distance, change the pitch with
    distance, and so on. This is critical for XR applications, as it helps to create
    a sense of space and realism.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3D 声音设置**：这些设置控制声音如何受到距离的影响。您可以设置声音随着距离变远而变弱，改变音调，等等。这对于 XR 应用程序至关重要，因为它有助于创造空间感和现实感。'
- en: '`AudioSource` components in the scene and processes them to create the final
    mixed sound that the player will hear. In most games and XR applications, the
    `AudioListener` is attached to the main camera or the player’s avatar. As the
    player moves through the environment, different sounds will get louder or quieter
    based on their distance and direction from the `AudioListener`, creating a dynamic
    soundscape.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景中的`AudioSource`组件被处理以创建玩家最终听到的混合声音。在大多数游戏和XR应用中，`AudioListener`连接到主相机或玩家的化身。当玩家在环境中移动时，根据它们与`AudioListener`的距离和方向，不同的声音会变得更大或更小，从而创建一个动态的声音景观。
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It’s important to note that you should generally only have one `AudioListener`
    in your scene. Having more than one can cause sounds to be duplicated, which can
    result in distortion and other audio artifacts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，您通常只应在场景中有一个`AudioListener`。拥有多个可能会导致声音重复，这可能导致失真和其他音频伪影。
- en: The following sections guide you on how to implement these components into your
    Unity scene through a new, hands-on VR project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将指导您如何通过一个新的、动手的VR项目将这些组件集成到您的Unity场景中。
- en: Preparing the VR drum scene and adding sound effects
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备VR鼓场景并添加音效
- en: After exploring the physical properties of sound waves and Unity’s audio system,
    you will finally put this theoretical knowledge into use by building your own
    VR drum scene.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索声音波动的物理特性和Unity的音频系统之后，您最终将把理论知识应用于构建自己的VR鼓场景。
- en: Once you’ve created a VR scene featuring various drums, which can be struck
    by a player equipped with VR drumsticks in each hand, you’ll discover how to augment
    your setup by assigning distinct sound files to each drum that gets hit. Moreover,
    you’ll learn how to adjust the sound volume based on the intensity of the strike
    delivered by the VR drumsticks, adding an extra layer of realism. This refined
    VR drumming environment will plunge users into an impressively accurate and engaging
    drumming experience. Let us now set up and prepare our VR drum scene.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了一个包含各种鼓的VR场景，玩家可以用双手的VR鼓槌击打这些鼓，您将发现如何通过为每个被击打的鼓分配不同的声音文件来增强您的设置。此外，您还将学习如何根据VR鼓槌施加的打击强度调整声音音量，增加额外的真实感。这个经过优化的VR鼓击环境将使用户沉浸在令人印象深刻且引人入胜的鼓击体验中。现在让我们设置并准备我们的VR鼓场景。
- en: Setting up and preparing your VR drum scene
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和准备您的VR鼓场景
- en: 'The following steps guide you on how to create your project, set up the needed
    VR settings in the Unity Editor, and add a player with a ground floor:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您如何创建项目、在Unity编辑器中设置所需的VR设置，并添加一个带有地面层的玩家。
- en: Create a new project with the URP by selecting `Drum Scene`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用URP创建一个新项目，选择`Drum Scene`。
- en: Once the scene has loaded, navigate to **Edit** | **Project Settings** | **XR
    Plugin** **Management** and click the **Install** button. After the installation,
    enable the **OpenXR** checkbox. If you are prompted to restart the Editor, follow
    the instructions to do so.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景加载完成后，导航到**编辑** | **项目设置** | **XR插件管理**并点击**安装**按钮。安装完成后，启用**OpenXR**复选框。如果您被提示重新启动编辑器，请按照指示操作。
- en: Under **Edit** | **Project Settings** | **XR Plugin Management**, go to the
    **OpenXR** submenu. Under the **Windows/Linux/Mac** tab, select the interaction
    profile that matches your headset.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**编辑** | **项目设置** | **XR插件管理**下，进入**OpenXR**子菜单。在**Windows/Linux/Mac**选项卡下，选择与您的头戴设备相匹配的交互配置文件。
- en: To add the required prefabs for our VR player to our scene, we need to install
    the XR Interaction Toolkit. To do so, go to `com.unity.xr.interaction.toolkit`
    and `2.5.1`, and then click the **Add** button. This will automatically install
    the XR Interaction Toolkit into your scene. Once the installation process is finished,
    select **XR Interaction Toolkit** in the **Package Manager** window, and click
    the **Import** buttons next to **Starter Assets** and **XR Device Simulator**,
    as shown in *Figure 7**.1*.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将所需的预制件添加到我们的VR玩家场景中，我们需要安装XR交互工具包。为此，请转到`com.unity.xr.interaction.toolkit`和`2.5.1`，然后点击**添加**按钮。这将自动将XR交互工具包安装到您的场景中。安装过程完成后，在**包管理器**窗口中选择**XR交互工具包**，并点击**Starter
    Assets**和**XR设备模拟器**旁边的**导入**按钮，如图*图7.1*所示。
- en: '![Figure 7.1 – The XR Interaction Toolkit successfully installed alongside
    the imported Starter Assets and XR Device Simulator in the Package Manager window](img/B20869_07_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – XR交互工具包成功安装在包管理器窗口中，与导入的Starter Assets和XR设备模拟器一起](img/B20869_07_01.jpg)'
- en: Figure 7.1 – The XR Interaction Toolkit successfully installed alongside the
    imported Starter Assets and XR Device Simulator in the Package Manager window
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – XR交互工具包成功安装在包管理器窗口中，与导入的起始资源和XR设备模拟器一起
- en: Delete the existing main camera in the hierarchy, as the VR player we will add
    comes with a point-of-view camera. Now, navigate to the `Assets` folder in the
    `floor`, and place it at the origin (`0`, `0`, `0`).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中删除现有的主摄像机，因为我们将要添加的VR玩家自带一个视角摄像机。现在，导航到“floor”下的“Assets”文件夹，并将其放置在原点（`0`,
    `0`, `0`）。
- en: Hurray! You’ve set up the framework for a VR-enabled drum scene in Unity! The
    subsequent section will guide you through the process of adding the drums and
    drumsticks to your scene.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽！你已经在Unity中为VR鼓场景搭建了框架！接下来的部分将指导你如何将鼓和鼓槌添加到你的场景中。
- en: Creating and importing 3D models for your VR drum scene
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的VR鼓场景创建和导入3D模型
- en: Although Unity Asset Store provides an extensive collection of different 3D
    models, it doesn’t offer free drum models that are suitable for our project. Therefore,
    we’ll utilize 3D models available on *Sketchfab*, another rich platform that allows
    you to download free and paid 3D models from a wide range of creators.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unity Asset Store提供了大量的不同3D模型，但它不提供适合我们项目的免费鼓模型。因此，我们将利用在*Sketchfab*上可用的3D模型，这是一个丰富的平台，允许你从广泛的创作者那里下载免费和付费的3D模型。
- en: The selected drum models for this chapter were found at [https://skfb.ly/o8QvS](https://skfb.ly/o8QvS)
    and were created by Bora Özakaltun. Open the link and download the free models
    in the `.fbx` file format, as shown in *Figure 7**.2*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所选的鼓模型可在[https://skfb.ly/o8QvS](https://skfb.ly/o8QvS)找到，由Bora Özakaltun创建。打开链接，并按*图7.2*所示下载免费的`.fbx`格式模型。
- en: "![Figure 7.2 – \uFEFFThe required mouse clicks (highlighted in yellow) to download\
    \ the drum models as a\uFEFFn .fbx file](img/B20869_07_02.jpg)"
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 下载鼓模型为.fbx文件所需的鼠标点击（以黄色突出显示）](img/B20869_07_02.jpg)'
- en: Figure 7.2 – The required mouse clicks (highlighted in yellow) to download the
    drum models as an .fbx file
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 下载鼓模型为.fbx文件所需的鼠标点击（以黄色突出显示）
- en: Important note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Should the models be unavailable at your time of reading, you can clone the
    entire project from the GitHub repository for this book and extract the assets
    from there.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在阅读时模型不可用，你可以从本书的GitHub仓库克隆整个项目，并从那里提取资产。
- en: 'Once the folder is downloaded, unzip all the child folders. Then, drag the
    unzipped drum folder into your **Project** window, completing the model importation.
    Now, it’s time to integrate the drums into your virtual environment. Follow these
    steps to position the drums in your scene:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完文件夹后，解压缩所有子文件夹。然后，将解压缩的鼓文件夹拖入你的**项目**窗口，完成模型导入。现在，是时候将鼓整合到你的虚拟环境中了。按照以下步骤将鼓放置在你的场景中：
- en: In the `Assets` folder, and then to `drum` | `source directory`. Here, you will
    find the drum model that you previously imported.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Assets”文件夹中，然后到“drum” | “源目录”。在这里，你可以找到你之前导入的鼓模型。
- en: Select the **drum** file and drag it into your scene. Upon doing so, you might
    observe that the drum appears disproportionately large for the environment.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**鼓**文件并将其拖入你的场景。这样做后，你可能观察到鼓在环境中显得不成比例地大。
- en: To rectify the size issue, select the drum in the hierarchy and scale it down
    to the dimensions (`0.02`, `0.02`, `0.02`). Place the drum at the origin coordinates
    (`0`, `0`, `0`), aligning it perfectly within the virtual space.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了纠正尺寸问题，在层级中选择鼓并将其缩小到尺寸（`0.02`、`0.02`、`0.02`）。将鼓放置在原点坐标（`0`、`0`、`0`），使其在虚拟空间中完美对齐。
- en: Once these adjustments are complete, your scene should resemble the depiction
    in *Figure 7**.3*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些调整后，你的场景应该类似于*图7.3*中的描述。
- en: "![Figure 7.3 – \uFEFFHow your drum scene should currently look in the Game\
    \ \uFEFFview of the Unity Editor](img/B20869_07_03.jpg)"
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 你的鼓场景在Unity编辑器的游戏视图中当前应该看起来是什么样子](img/B20869_07_03.jpg)'
- en: Figure 7.3 – How your drum scene should currently look in the Game view of the
    Unity Editor
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 你的鼓场景在Unity编辑器的游戏视图中当前应该看起来是什么样子
- en: 'Now, we need drumsticks to interact with the drums. By following these steps,
    we will create our own drumsticks within Unity:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要鼓槌来与鼓进行交互。通过以下步骤，我们将在Unity中创建自己的鼓槌：
- en: Right-click in the Scene Hierarchy, navigate to `0.01`, `0.2`, `0.01`). Rename
    this GameObject `Drum Stick`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景层级中右键单击，导航到`0.01`、`0.2`、`0.01`）。将此GameObject重命名为`Drum Stick`。
- en: As you can see in the **Inspector** window, the drumstick automatically includes
    a **Capsule Collider** component. A **Capsule Collider** is a 3D shape used in
    Unity that resembles a capsule or pill-like shape, used to detect collisions between
    objects. Additionally, it is essential to add a **Rigidbody** component to the
    drumstick. This allows the object to be affected by forces and physics within
    the Unity environment, enabling dynamic interactions such as the ones needed for
    an immersive drumming experience. With the drumstick selected, head over to its
    **Inspector** window and select the **Add Component** button. Now, add a **Rigidbody**
    component by searching for it and selecting it. This component allows Unity’s
    physics engine to treat the drumstick as a physical object, simulating interactions
    and reactions to forces, which is critical to realistically model the drumstick’s
    behavior when striking a drum.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您在**Inspector**窗口中所见，鼓棒自动包含一个**Capsule Collider**组件。**Capsule Collider**是Unity中用于模拟胶囊或药丸形状的3D形状，用于检测物体之间的碰撞。此外，向鼓棒添加一个**Rigidbody**组件也是必不可少的。这允许物体在Unity环境中受到力和物理的影响，实现如沉浸式鼓击体验所需的动态交互。选择鼓棒后，转到其**Inspector**窗口并选择**Add
    Component**按钮。现在，通过搜索并选择它来添加一个**Rigidbody**组件。此组件允许Unity的物理引擎将鼓棒视为物理对象，模拟对力的交互和反应，这对于在打击鼓时真实地模拟鼓棒的行为至关重要。
- en: Set **Collision Detection** of the **Rigidbody** component to **Continuous Speculative**.
    This mode enables more accurate and efficient handling of collisions between the
    drumstick and other objects, particularly when dealing with fast motions typical
    of drumming.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Rigidbody**组件的**Collision Detection**设置为**Continuous Speculative**。此模式可以更准确、更高效地处理鼓棒与其他物体之间的碰撞，尤其是在处理鼓击时典型的快速动作。
- en: Create a new material in the `Assets` folder, and name it `Drum Stick Material`.
    Download `Balsa_Wood_Texture.jpg` from [https://commons.wikimedia.org/wiki/File:Balsa_Wood_Texture.jpg](https://commons.wikimedia.org/wiki/File:Balsa_Wood_Texture.jpg)
    and import it into the project. Select `Drum Stick Material`, go to `Balsa_Wood_Texture.jpg`
    into the **Base Map** field. Apply this material to the drumstick.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets`文件夹中创建一个新的材质，命名为`Drum Stick Material`。从[https://commons.wikimedia.org/wiki/File:Balsa_Wood_Texture.jpg](https://commons.wikimedia.org/wiki/File:Balsa_Wood_Texture.jpg)下载`Balsa_Wood_Texture.jpg`并将其导入到项目中。选择`Drum
    Stick Material`，在**Base Map**字段中选择`Balsa_Wood_Texture.jpg`。将此材质应用到鼓棒上。
- en: Select `Drum Stick`, and click on the `Drum`, and save the tag. We will need
    this tag to address the drumsticks in our scene later on.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Drum Stick`，点击`Drum`，并保存标签。我们稍后将需要此标签来引用场景中的鼓棒。
- en: In the `Prefabs`, and drag the drumstick into it. This will create a prefab,
    allowing easy duplication and modification.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prefabs`中，将鼓棒拖入其中。这将创建一个预制体，允许轻松复制和修改。
- en: Finally, attach the prefab as a child to both the left controller and the right
    controller, as detailed in *Figure 7**.4*.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，根据*图7.4*的详细说明，将预制体作为子对象附加到左侧控制器和右侧控制器上。
- en: "![Figure 7.4 – \uFEFFEach drumstick being successfully attached to the respective\
    \ controller of the XR Origin in the Scene Hierarchy window](img/B20869_07_04.jpg)"
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 在场景层次结构窗口中，每个鼓棒成功附加到XR Origin的相应控制器上](img/B20869_07_04.jpg)'
- en: Figure 7.4 – Each drumstick being successfully attached to the respective controller
    of the XR Origin in the Scene Hierarchy window
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 在场景层次结构窗口中，每个鼓棒成功附加到XR Origin的相应控制器上
- en: You have successfully completed all the steps to set up and prepare your VR
    drum scene. In the following section, you will learn how you can utilize Unity’s
    audio system to add sound effects to your scene.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功完成设置和准备VR鼓场景的所有步骤。在下一节中，您将学习如何利用Unity的音频系统为场景添加音效。
- en: Adding sound effects to your VR drum scene
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的VR鼓场景添加音效
- en: This section guides you through the process of adding sound effects to your
    VR drum scene. The first step involves triggering audio when hitting an instrument,
    adding realism and engagement to the scene.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导您通过添加音效到您的VR鼓场景的过程。第一步涉及在击打乐器时触发音频，为场景增添真实感和参与感。
- en: Scripting sound playback on collision for your VR drum scene
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在VR鼓场景中为碰撞触发声音播放的脚本编写
- en: 'To trigger a sound playback once our drumsticks collide with the drums, we
    must use C# scripting. Follow these steps to correctly prepare your drums for
    it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在鼓棒与鼓碰撞时触发声音播放，我们必须使用C#脚本。按照以下步骤正确准备您的鼓：
- en: In the Unity Editor, press *Ctrl* / *Cmd* on your keyboard, and *left-click*
    to select all the drums in your Scene Hierarchy.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，按键盘上的 *Ctrl* / *Cmd*，然后 *左键点击* 以选择场景层次结构中的所有鼓。
- en: With the drums selected, add a **Box Collider** component via the **Inspector**
    window by clicking the **Add Component** button and searching for and selecting
    the **Box** **Collider** component.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择鼓后，通过**检查器**窗口点击**添加组件**按钮，搜索并选择**盒子碰撞体**组件来添加一个**盒子碰撞体**组件。
- en: Then, we must ensure that the collider functions as a trigger, allowing it to
    initiate actions rather than physical interactions. To do this, select the **Is
    Trigger** checkbox in the **Box Collider** component of each drum in the **Inspector**
    window. This option transforms the collider into a non-physical boundary that
    can detect when objects pass through, making it instrumental in triggering sound
    upon collision.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须确保碰撞体作为触发器工作，允许它启动动作而不是物理交互。为此，在**检查器**窗口中，为每个鼓的**盒子碰撞体**组件选择**是触发器**复选框。此选项将碰撞体转换为一个非物理边界，可以检测物体通过时的情况，使其在碰撞时触发声音变得至关重要。
- en: Select all the drums in the Scene Hierarchy, and click on the `PlaySoundOnCollision`,
    and click on **New Script**. This action automatically associates the script with
    all selected drums.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择场景层次结构中的所有鼓，点击 `PlaySoundOnCollision`，然后点击**新建脚本**。此操作自动将脚本与所有选定的鼓关联起来。
- en: '*Double-click* on the `PlaySoundOnCollision` script in the **Inspector** window
    to open it.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，双击 `PlaySoundOnCollision` 脚本来打开它。
- en: 'Once the script opens in your preferred IDE, define the following three variables:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本在您首选的IDE中打开，定义以下三个变量：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will use the public `AudioClip` variable to play the audio, the private `AudioSource`
    variable to play the clip, and assign a public `tag` variable to the drumsticks
    so that only these GameObjects trigger the sound.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用公共的 `AudioClip` 变量来播放音频，使用私有的 `AudioSource` 变量来播放剪辑，并将公共的 `tag` 变量分配给鼓槌，以便只有这些GameObject可以触发声音。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `Start()` function of the `PlaySoundOnCollision` script, add the following
    line of code to access `AudioSource` at the beginning of the experience:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PlaySoundOnCollision` 脚本的 `Start()` 函数中，添加以下代码行以在体验开始时访问 `AudioSource`：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since we are not continuously checking for changes, we don’t need an `Update()`
    function in this script. Instead, we will implement an `OnTriggerEnter()` method,
    which is called when something collides with the trigger collider:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不是持续检查变化，因此在这个脚本中不需要 `Update()` 函数。相反，我们将实现一个 `OnTriggerEnter()` 方法，该方法在某个物体与触发器碰撞时被调用：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`OnTriggerEnter()` is a special Unity method that is automatically called by
    the Unity engine itself when a collision with a trigger occurs. This is also why
    we don’t need to call this function within our script and why we selected the
    **Is Trigger** checkbox earlier in this setup.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter()` 是一个Unity引擎在发生触发器碰撞时自动调用的特殊Unity方法。这也是为什么我们不需要在我们的脚本中调用此函数，以及为什么我们在之前的设置中选择了**是触发器**复选框的原因。'
- en: Within the `OnTriggerEnter()` method, we call `CompareTag()`, a built-in Unity
    function from the `GameObject` class. By calling it inside of an `if` statement,
    we compare the tag of the colliding object to a string. The use of a tag helps
    ensure that the sound is played only when the drumsticks collide with the drum,
    and not when other objects might collide with it. By assigning a unique tag to
    the drumsticks, similar to the `Drum` tag we used, we can easily and efficiently
    identify them within the `OnTriggerEnter()` method and play the sound only in
    response to their collisions with the drum.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnTriggerEnter()` 方法中，我们调用 `CompareTag()`，这是一个来自 `GameObject` 类的内置Unity函数。通过在
    `if` 语句中调用它，我们将碰撞对象的标签与一个字符串进行比较。使用标签有助于确保只有在鼓槌与鼓碰撞时才播放声音，而不是其他物体可能与之碰撞时。通过为鼓槌分配一个唯一的标签，类似于我们使用的
    `Drum` 标签，我们可以在 `OnTriggerEnter()` 方法中轻松高效地识别它们，并且只在它们与鼓的碰撞时播放声音。
- en: Important note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At this point, you might be wondering why we are using `CompareTag()` instead
    of directly comparing the tags with the equality operator (`==`). The reason for
    this is that using `CompareTag()` is more computationally efficient. Tags in Unity
    are stored in an internal hashed format, and `CompareTag()` compares these hashes,
    while the equality operator would first convert the hash to a string, making the
    comparison slower.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能想知道为什么我们使用`CompareTag()`而不是直接使用相等运算符（`==`）来比较标签。这样做的原因是使用`CompareTag()`在计算上更高效。在Unity中，标签存储在一个内部哈希格式中，`CompareTag()`比较这些哈希值，而相等运算符会首先将哈希值转换为字符串，这使得比较速度变慢。
- en: If the tag comparison returns `true`, the next line is executed. The `_soundSource`
    variable refers to the `AudioSource` component that we will attach to the drums
    later on. The `PlayOneShot()` method is another Unity function from the `AudioSource``AudioSource`.
    This functionality is essential for the authenticity of our drum scene. Instead
    of hearing each drum hit in isolation, we seek to create a continuous flow of
    sound. The ability to layer individual hits allows for a more immersive and realistic
    experience, reflecting the natural overlap that occurs when drums are played in
    quick succession. The use of the `PlayOneShot()` method ensures that the sounds
    meld together harmoniously, capturing the essence of a live drumming performance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签比较返回`true`，则执行下一行。`_soundSource`变量指的是我们稍后将要附加到鼓上的`AudioSource`组件。`PlayOneShot()`方法是`AudioSource`组件的另一个Unity函数。这种功能对于我们鼓场景的真实性至关重要。我们不是单独听到每个鼓的敲击声，而是希望创造一个连续的声音流。能够叠加单个敲击声使得体验更加沉浸和真实，反映了鼓快速连续敲击时自然发生的重叠。使用`PlayOneShot()`方法确保声音和谐融合，捕捉到现场鼓演奏的精髓。
- en: By combining these elements, the `OnTriggerEnter()` method ensures that when
    the drumstick comes into contact with the drum, the specified sound is played,
    creating an immediate and realistic response within the virtual environment. It’s
    a powerful way to add immersion and interactivity to your VR experience. After
    finalizing the `PlaySoundOnCollision` script, it is finally time to add sound
    files for each drum to your scene.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这些元素，`OnTriggerEnter()`方法确保当鼓槌接触到鼓时，播放指定的声音，在虚拟环境中产生即时的真实反应。这是一种强大的方式，可以增加沉浸感和交互性到您的VR体验中。在完成`PlaySoundOnCollision`脚本后，现在终于可以给每个鼓添加声音文件了。
- en: Adding sound files to your VR drum scene
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为您的VR鼓场景添加声音文件
- en: 'In this section, you will learn how to import sound files and assign `AudioSource`
    components for each drum. Let’s go through this process step by step:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何导入声音文件并为每个鼓分配`AudioSource`组件。让我们一步一步地完成这个过程：
- en: Download the appropriate sound files for each of the drums in your Unity scene.
    You can find royalty-free `.mp3` sound files on websites such as [https://www.freesoundslibrary.com/](https://www.freesoundslibrary.com/)
    or [https://pixabay.com/sound-effects/](https://pixabay.com/sound-effects/). Alternatively,
    you have the option to utilize the sound files provided within the Unity project
    linked with this chapter. These files are readily available in this book’s GitHub
    repository.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Unity场景中每个鼓的适当声音文件。您可以在[https://www.freesoundslibrary.com/](https://www.freesoundslibrary.com/)或[https://pixabay.com/sound-effects/](https://pixabay.com/sound-effects/)等网站上找到免费的`.mp3`声音文件。或者，您可以选择使用与本章链接的Unity项目中提供的声音文件。这些文件可以在本书的GitHub仓库中找到。
- en: Once you have the necessary sound files on your local system, go to `Assets`
    | `Import New Assets` in the Unity Editor. Navigate to the location of your sound
    files and select the ones you want to import. Click the **Import** button, and
    the sound files will now be available in your Unity project.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您在本地系统上有了必要的声音文件，请转到Unity编辑器的`Assets` | `Import New Assets`。导航到您的声音文件位置，并选择您想要导入的文件。点击**Import**按钮，现在这些声音文件将可用在您的Unity项目中。
- en: Select all drums in the **Hierarchy** window (*Ctrl* / *Cmd* + *left-click*).
    In the **Inspector** window, click the **Add Component** button, search for the
    **Audio Source** component, and select it.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中选择所有鼓（*Ctrl* / *Cmd* + *左键点击*）。在**Inspector**窗口中，点击**Add Component**按钮，搜索**Audio
    Source**组件，并选择它。
- en: Now, select each drum individually in the Scene Hierarchy, and navigate to their`PlaySoundOnCollision`
    script in the **Inspector** window. Click on the small circle next to the **Sound
    Clip** field that we defined earlier, and choose an appropriate sound file for
    each drum.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在场景层次结构中选择每个鼓，并在**检查器**窗口中导航到它们的`PlaySoundOnCollision`脚本。点击我们之前定义的**声音剪辑**字段旁边的小圆圈，并为每个鼓选择一个合适的音频文件。
- en: Upon testing, you’ll find that the drum scene is already quite immersive. However,
    a few adjustments can heighten its realism. The following section guides you on
    how to fine-tune your drum scene.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试后，你会发现鼓场景已经相当沉浸。然而，一些调整可以进一步提高其真实感。以下部分将指导你如何微调你的鼓场景。
- en: Fine-tuning the VR drum scene to heighten its realism
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微调VR鼓场景以增强其真实感
- en: 'The current setup plays the sound at a constant volume, regardless of how hard
    or soft the drum is hit. To enhance realism, we need to adjust the volume in relation
    to the collision velocity. To achieve this, we can utilize an existing script
    from Valve called *VelocityEstimator*. In case you aren’t familiar, Valve is the
    prominent video game developer and distributor behind the Steam gaming platform,
    and they offer a SteamVR plugin for Unity, along with interesting VR scripts available
    on GitHub. The `VelocityEstimator` script is available in the GitHub repository
    of SteamVR’s Unity Plugin at this link: [https://github.com/ValveSoftware/steamvr_unity_plugin/blob/9442d7d7d447e07aa21c64746633dcb5977bdd1e/Assets/SteamVR/InteractionSystem/Core/Scripts/VelocityEstimator.cs#L13](https://github.com/ValveSoftware/steamvr_unity_plugin/blob/9442d7d7d447e07aa21c64746633dcb5977bdd1e/Assets/SteamVR/InteractionSystem/Core/Scripts/VelocityEstimator.cs#L13).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当前设置在鼓敲击的力度无论轻重时都播放恒定音量的声音。为了增强真实感，我们需要根据碰撞速度调整音量。为此，我们可以利用Valve公司的一个现有脚本，名为*VelocityEstimator*。如果您不熟悉，Valve是Steam游戏平台背后的主要视频游戏开发商和发行商，他们为Unity提供了SteamVR插件，并在GitHub上提供了有趣的VR脚本。`VelocityEstimator`脚本可在SteamVR
    Unity插件的GitHub仓库中找到，链接如下：[https://github.com/ValveSoftware/steamvr_unity_plugin/blob/9442d7d7d447e07aa21c64746633dcb5977bdd1e/Assets/SteamVR/InteractionSystem/Core/Scripts/VelocityEstimator.cs#L13](https://github.com/ValveSoftware/steamvr_unity_plugin/blob/9442d7d7d447e07aa21c64746633dcb5977bdd1e/Assets/SteamVR/InteractionSystem/Core/Scripts/VelocityEstimator.cs#L13)。
- en: Tip
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When dealing with complex physical calculations (such as the relationship between
    volume and collision), searching the internet for existing solutions or scripts
    can save time and effort. In XR development, understanding every aspect of physics
    is not always necessary, but knowing how to implement physical calculations accurately
    is crucial.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理复杂的物理计算（如音量和碰撞之间的关系）时，在互联网上搜索现有解决方案或脚本可以节省时间和精力。在XR开发中，理解物理的每一个方面并不总是必要的，但知道如何准确实现物理计算是至关重要的。
- en: 'The purpose of Valve’s `VelocityEstimator` script is to calculate and estimate
    the speed and direction of the GameObject we attach it to – in this case, the
    drumsticks. When applied to our VR drum scene, this script will facilitate the
    adjustment of the sound volume based on the drumstick’s striking speed, thereby
    imitating the natural correlation between the force of a drum hit and the resulting
    sound volume. To add the `VelocityEstimator` script to our drumsticks, let’s perform
    the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Valve的`VelocityEstimator`脚本的目的在于计算和估算我们附加到其上的GameObject的速度和方向 – 在这种情况下，是鼓棒。当应用于我们的VR鼓场景时，此脚本将根据鼓棒的敲击速度调整音量，从而模仿鼓击力度与产生的音量之间的自然相关性。要将`VelocityEstimator`脚本添加到我们的鼓棒上，请按照以下步骤操作：
- en: Download the `VelocityEstimator` script from GitHub (by selecting *Cmd* / *Ctrl*
    + *Shift* + *S*).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub下载`VelocityEstimator`脚本（通过选择*Cmd* / *Ctrl* + *Shift* + *S*）。
- en: In the `Scripts` folder, and drag and drop your downloaded file from your local
    file manager into it.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中，将您从本地文件管理器下载的文件拖放到其中。
- en: Now, add the `VelocityEstimator` script to both drumsticks as a component by
    clicking the `VelocityEstimator` script component should look in the **Inspector**
    window.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过点击**检查器**窗口中的`VelocityEstimator`脚本组件，将其作为组件添加到两个鼓棒上。
- en: "![Figure 7.5 – \uFEFFHow the drumsticks’ fully configured VelocityEstimator\
    \ script component should look in the Inspector window](img/B20869_07_05.jpg)"
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 鼓棒的完全配置好的VelocityEstimator脚本组件在检查器窗口中的样子](img/B20869_07_05.jpg)'
- en: Figure 7.5 – How the drumsticks’ fully configured VelocityEstimator script component
    should look in the Inspector window
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 鼓棒的完全配置好的VelocityEstimator脚本组件在检查器窗口中的样子
- en: 'To take advantage of the drumsticks’ speed in our existing `PlaySoundOnCollision`
    script, we must modify it a bit. Open the script again in an IDE, such as Visual
    Studio, and add the following three lines of code to your script:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用我们现有的`PlaySoundOnCollision`脚本中的鼓槌速度，我们必须对其进行一些修改。在IDE中，例如Visual Studio，再次打开脚本，并将以下三行代码添加到脚本中：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first variable allows us to decide whether we want to take velocity into
    account when playing the sound. By setting this to `true`, we enable the feature.
    The `minimumVelocity` variable defines the lower threshold for velocity, allowing
    us to specify the minimum speed that will impact the volume. Any velocity below
    this value won’t lead to a decrease in volume. Conversely, the `maximumVelocity`
    parameter sets the upper limit of velocity that will influence the volume. Speeds
    above this threshold won’t result in further increases in volume.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量允许我们决定是否在播放声音时考虑速度。通过将其设置为`true`，我们启用此功能。`minimumVelocity`变量定义了速度的下限阈值，允许我们指定将影响音量的最小速度。任何低于此值的速度都不会导致音量降低。相反，`maximumVelocity`参数设置了将影响音量的速度上限。高于此阈值的速度不会导致音量进一步增加。
- en: These new parameters grant us control over how the velocity of the drumsticks
    influences the volume of the sounds produced. By adjusting the minimum and maximum
    velocity values, we can fine-tune the responsiveness of the drum sounds to create
    a nuanced and realistic drumming simulation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新参数使我们能够控制鼓槌速度如何影响产生的声音的音量。通过调整最小和最大速度值，我们可以微调鼓声音响的响应性，以创建细腻且逼真的击鼓模拟。
- en: 'Now, we must modify the `OnTriggerEnter()` method to use the `VelocityEstimator`
    script component if the `enableVelocity` variable is set to `true` like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须修改`OnTriggerEnter()`方法，以便在`enableVelocity`变量设置为`true`时使用`VelocityEstimator`脚本组件，如下所示：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s go through the newly added parts of the `OnTriggerEnter()` method. By
    calling `other.GetComponent<VelocityEstimator>()`, we try to get a component of
    the `VelocityEstimator` type from the object with the `Drum` tag. If the `VelocityEstimator`
    component is found and the `enableVelocity` variable is set to `true`, the code
    inside the `if` statement will be executed. In this case, the code first calls
    the `GetVelocityEstimate` method from the `VelocityEstimator` component to get
    the velocity estimate, and then it takes the magnitude of that vector to get the
    speed as a single float value. Then, the volume of the sound based on the speed
    is calculated and stored in the `soundVolume` variable. The `InverseLerp()` method
    returns a value between `0` and `1`, representing where the value of `v` falls
    between `minimumVelocity` and `maximumVelocity`. By calling `_soundSource.PlayOneShot(soundClip,
    soundVolume)` on the next line, a one-time sound is played at the calculated volume.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`OnTriggerEnter()`方法的新增部分进行说明。通过调用`other.GetComponent<VelocityEstimator>()`，我们尝试从带有`Drum`标签的对象中获取`VelocityEstimator`类型的组件。如果找到`VelocityEstimator`组件并且`enableVelocity`变量设置为`true`，则`if`语句内的代码将被执行。在这种情况下，代码首先从`VelocityEstimator`组件调用`GetVelocityEstimate`方法以获取速度估计值，然后取该向量的模以获得速度作为一个单独的浮点值。然后，根据速度计算音量并将其存储在`soundVolume`变量中。`InverseLerp()`方法返回一个介于`0`和`1`之间的值，表示`v`的值在`minimumVelocity`和`maximumVelocity`之间的位置。在下一行调用`_soundSource.PlayOneShot(soundClip,
    soundVolume)`时，将以计算出的音量播放一次性声音。
- en: The `else` statement at the end of `OnTriggerEnter()` is executed if the previous
    `if` statement is not met. The `if` statement is not met if the `VelocityEstimator`
    script component is not found, or if the `enableVelocity` variable is set to `false`.
    The code inside this block will play the sound at its default volume because the
    velocity of the object was not considered.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnTriggerEnter()`函数末尾的`else`语句会在之前的`if`语句未满足条件时执行。如果找不到`VelocityEstimator`脚本组件，或者`enableVelocity`变量设置为`false`，则`if`语句将不会满足。由于没有考虑物体的速度，因此这个代码块内的代码将以默认音量播放声音。
- en: If we run the scene right now, we will not hear anything at all when we hit
    the drumsticks against the drums. This is because, in the original `VelocityEstimator`
    script from Valve, the velocity estimation routine was meant to start by calling
    `BeginEstimatingVelocity()`. However, in our `PlaySoundOnCollision` script, this
    function wasn’t being called at all; hence, no velocity estimation took place.
    This is why we consistently get a velocity of zero right now when testing out
    the scene and do not hear anything.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行场景，当我们用鼓槌敲击鼓面时，我们将完全听不到任何声音。这是因为，在Valve的原始`VelocityEstimator`脚本中，速度估计例程原本打算通过调用`BeginEstimatingVelocity()`来启动。然而，在我们的`PlaySoundOnCollision`脚本中，这个函数根本没有被调用；因此，没有进行速度估计。这就是为什么我们在测试场景时始终得到零速度，并且听不到任何声音。
- en: 'To solve this problem, we need to ensure that `BeginEstimatingVelocity()` is
    called when the script starts. This can be done by adding the following code lines
    to the `Start()` method of our `VelocityEstimator` script:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要确保在脚本启动时调用`BeginEstimatingVelocity()`。这可以通过将以下代码行添加到我们的`VelocityEstimator`脚本的`Start()`方法中来实现：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By putting the call to `BeginEstimatingVelocity()` inside the `Start()` method,
    we ensure that the velocity estimation begins as soon as the drumstick object
    is ready, which is exactly what we want.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`BeginEstimatingVelocity()`的调用放在`Start()`方法中，我们确保了速度估计在鼓槌对象准备好后立即开始，这正是我们想要的。
- en: We’ve successfully executed all necessary steps to add a sound to each drum
    that reflects the intensity of each hit. Now, it’s time to put on your VR headset
    and put the final scene to the test. Pay close attention to the variation in volume
    for each drum sound, depending on the collision velocity with the drumstick. Also,
    keenly observe the sound dynamics when you strike two drums simultaneously or
    hit several drums in rapid succession. You’ll be amazed by how incredibly realistic
    our VR drum scene has become.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功执行了所有必要的步骤，为每个鼓添加了反映每次敲击强度的声音。现在，是时候戴上你的VR头盔，对最终场景进行测试了。请密切关注每个鼓声音的音量变化，这取决于鼓槌与鼓的碰撞速度。同时，仔细观察当你同时敲击两个鼓或连续快速敲击几个鼓时的声音动态。你会对我们的VR鼓场景变得多么逼真而感到惊讶。
- en: The next sections will teach you yet another valuable skill to make your scenes
    more natural and immersive – adding particles!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将教你另一个非常有价值的技能，让你的场景更加自然和沉浸——添加粒子！
- en: Understanding particle behavior and Unity’s particle system
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解粒子行为和Unity的粒子系统
- en: When designing immersive XR experiences, understanding the physics of particle
    behavior plays an important role. By leveraging Unity’s particle system and the
    fundamentals of particle physics, you can create rich, dynamic, and realistic
    effects that enhance the immersion of your virtual environments. In this section,
    you will learn everything you need to know about real-world particle behavior.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计沉浸式XR体验时，理解粒子行为的物理学起着重要作用。通过利用Unity的粒子系统和粒子物理的基本原理，你可以创建丰富、动态和逼真的效果，从而增强虚拟环境的沉浸感。在本节中，你将了解关于现实世界粒子行为所需了解的一切。
- en: Understanding the behavior of particles in the real world
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解现实世界中粒子的行为
- en: 'Particle behavior in the physical world refers to the ways in which small fragments
    or quantities of matter move and interact, based on forces, environmental conditions,
    and intrinsic properties. Particles in the natural environment behave according
    to certain laws and principles. Key factors include gravity, air resistance, life
    span, and collision behavior. Here is an overview of what all these terminologies
    mean:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 物理世界中粒子的行为指的是物质的小片段或数量如何根据力、环境条件和内在属性移动和相互作用的方式。自然环境中的粒子遵循某些定律和原则。关键因素包括重力、空气阻力、寿命和碰撞行为。以下是所有这些术语的含义概述：
- en: '**Gravitational forces**: Particles are affected by gravitational forces, which
    pull them toward the center of mass. However, it’s important to note that not
    all particles are affected by gravity in the same way. Consider two common particle
    systems – rain falling from the sky, and sparks rising from a fire. In the case
    of rain, gravity pulls the raindrops down toward the ground. Conversely, sparks
    from a fire rise upward because the heat decreases their effective gravitational
    pull (hot air rises).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重力**：粒子受到重力的影响，被拉向质量中心。然而，需要注意的是，并非所有粒子都以相同的方式受到重力的影响。考虑两种常见的粒子系统——从天空落下的雨和从火中升起的火花。在雨的情况下，重力将雨滴拉向地面。相反，火花的上升是因为热量减少了它们的有效重力，热空气上升。'
- en: '**Air resistance**: Air resistance, also known as **drag**, is the resistance
    a particle experiences when moving through a medium such as air. It affects both
    the speed and the direction of particles, often resulting in less linear, more
    natural-looking motion. Smoke from a fire or a chimney provides a good example.
    While the heat and updraft may initially propel the smoke upward, air resistance
    and wind can cause it to billow, curve, and sway. Similarly, consider a particle
    system representing leaves blowing in the wind. Air resistance causes the leaves
    to flutter and spin, rather than moving directly in the direction of the wind.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空气阻力**：空气阻力，也称为**阻力**，是粒子在通过空气等介质移动时遇到的阻力。它影响粒子的速度和方向，通常导致运动轨迹不那么线性，看起来更自然。例如，火焰或烟囱冒出的烟雾就是一个很好的例子。虽然热量和上升气流最初可能将烟雾推向空中，但空气阻力和风力可以使其膨胀、弯曲和摇摆。同样，考虑一个表示风中飘落的树叶的粒子系统。空气阻力使树叶飘动和旋转，而不是直接随风移动。'
- en: '**Life span**: Every particle has a life span, a duration of existence after
    which it disappears or changes state. This life span, along with changes that
    happen during it, contributes to the believability of a particle effect. Consider
    a firefly effect, where each firefly would be a particle that appears, glows brightly
    for a few seconds (reaching peak brightness midway through its life), and then
    fades away. A snowflake particle system offers another example. As snowflakes,
    which are represented by particles in your Unity scene, fall toward the ground,
    they could fade or shrink to give the illusion of snowflakes melting as they touch
    the warmer ground.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期**：每个粒子都有一个生命周期，即存在一段时间后消失或改变状态。这个生命周期以及在此期间发生的变化，有助于提高粒子效果的真实感。考虑萤火虫效果，其中每个萤火虫都是一个粒子，它会出现，亮光几秒钟（在其生命周期中达到峰值亮度），然后逐渐消失。雪花粒子系统也是一个例子。当雪花（在Unity场景中以粒子表示）向地面落下时，它们可能会逐渐消失或缩小，以产生雪花在接触较暖的地面时融化的错觉。'
- en: '**Collision behavior**: When particles come into contact with a surface or
    another particle, they react in a manner that depends on their nature and the
    surface they collide with. This is known as collision behavior. Raindrops, for
    example, splash and disappear upon hitting a hard surface, creating smaller droplet
    particles. Conversely, confetti pieces bounce and scatter instead of splashing
    when they hit a surface.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞行为**：当粒子接触到表面或另一个粒子时，它们会以依赖于其性质和碰撞表面的方式反应。这被称为碰撞行为。例如，雨滴在击中硬表面时会溅起并消失，形成更小的水滴粒子。相反，当纸屑击中表面时，它们会弹跳和散开，而不是溅起。'
- en: Incorporating these principles of particle physics into your Unity Particle
    System will significantly enhance the realism and immersion of your XR experiences.
    You will learn about Unity’s Particle System in the following section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将粒子物理学的这些原理融入你的Unity粒子系统中，将显著增强你的XR体验的真实感和沉浸感。你将在下一节中学习Unity的粒子系统。
- en: Exploring Unity’s Particle System
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Unity的粒子系统
- en: Unity’s Particle System is a powerful tool for XR developers that adds another
    level of immersion to the user experience. It is used to create a wide range of
    special effects such as fire, smoke, sparks, and magic spells, as well as more
    abstract visual elements. Understanding and utilizing Unity’s Particle System
    effectively can significantly enhance the visual appeal of your application and
    deepen the sense of presence within the virtual environment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的粒子系统是XR开发者的一项强大工具，它为用户体验增添了另一个层次的真实感。它用于创建各种特殊效果，如火焰、烟雾、火花和魔法咒语，以及更抽象的视觉元素。理解和有效利用Unity的粒子系统可以显著增强应用程序的视觉吸引力，并加深虚拟环境中的存在感。
- en: 'The following is a detailed exploration of the core components of Unity’s Particle
    System – specifically, the Particle System component and the Particle System Renderer
    component. Both of these components will be vital later on when we add a particle
    system to our drum scene:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对Unity粒子系统核心组件的详细探讨——特别是粒子系统组件和粒子系统渲染器组件。这两个组件在我们向鼓场景添加粒子系统时将至关重要：
- en: 'The **Particle System component** is the main engine of the particle system
    in Unity. The Particle System component itself is attached to a GameObject and
    controls how particles are generated and behave over their lifetime. It offers
    a multitude of modules, each controlling a different aspect of the particle’s
    behavior:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子系统组件**是Unity中粒子系统的主引擎。粒子系统组件本身附加到一个GameObject上，并控制粒子在其生命周期内的生成和行为。它提供了多种模块，每个模块控制粒子行为的不同方面：'
- en: '**Emission Module**: This controls the rate at which new particles are spawned.
    Whether you need a constant trickle of particles or a sudden burst, this module
    has you covered.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射模块**：此模块控制新粒子的生成速率。无论你需要粒子的持续细流还是突然爆发，此模块都能满足你的需求。'
- en: '**Shape Module**: This defines the region and the form from which particles
    are birthed. This could be a simple point, a complex mesh, or anything in between,
    offering a flexible start to your particles’ life journey.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状模块**：此模块定义了粒子诞生的区域和形状。这可能是一个简单的点，一个复杂的网格，或者两者之间的任何东西，为你的粒子生命旅程提供了一个灵活的起点。'
- en: '**Gravity Modifier**: This is a setting within the Particle System component
    that emulates the influence of gravity on particles. You can adjust this setting
    to make the particles fall faster or slower, allowing you to create effects such
    as floating dust or rapid rainfall.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重力修改器**：这是粒子系统组件中的一个设置，模拟重力对粒子的影响。你可以调整此设置以使粒子下落得更快或更慢，从而创建如漂浮灰尘或快速降雨的效果。'
- en: '**Velocity over Lifetime Module**: This dictates how a particle’s speed and
    direction change over its lifetime. Coupled with the Gravity Modifier, this can
    create lifelike effects of particles being caught in wind or turbulence.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期内速度模块**：此模块规定粒子在其生命周期内速度和方向的变化。结合重力修改器，这可以创建出粒子被风吹或湍流捕获的逼真效果。'
- en: '**Drag**: Found under the **Forces over Lifetime** module, which in Unity’s
    Particle System allows users to apply varying forces to particles throughout their
    life span, this property lets you simulate the effect of air or fluid resistance.
    By modifying the Drag property, you can make particles move as if they are in
    a heavier medium, providing a sense of weight and depth to the particles.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻力**：位于**生命周期内力**模块下，在Unity的粒子系统中允许用户在其生命周期内对粒子应用不同的力，这个属性让你可以模拟空气或流体阻力的效果。通过修改阻力属性，你可以使粒子移动得像在更重的介质中一样，为粒子提供重量和深度的感觉。'
- en: '**Color over Lifetime Module**: This specifies how a particle’s color evolves
    over its life span. This module, in conjunction with the Size over Lifetime module,
    allows you to create a natural fade-in and fade-out effect, enhancing the realism
    of particles.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期内颜色模块**：此模块指定粒子在其生命周期内颜色的演变。此模块与大小生命周期模块结合使用，允许你创建自然的淡入淡出效果，增强粒子的真实感。'
- en: '**Size over Lifetime Module**: This determines how a particle’s scale changes
    over its life cycle. By making particles shrink or grow over time, the environment
    seems to evolve and be dynamic to observers.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期内大小模块**：此模块确定粒子在其生命周期内的缩放变化。通过使粒子随时间缩小或增大，环境看起来会演变并变得对观察者来说是动态的。'
- en: '**Collision Module**: This module governs how particles interact with other
    GameObjects in the scene upon collision. You can control properties such as bounce
    (restitution), dampen (loss of speed), and lifetime loss on collision. This can
    offer a high degree of realism to how particles respond to their environment,
    such as sparks bouncing off a surface or water droplets splashing.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞模块**：此模块控制粒子在碰撞时如何与场景中的其他GameObject交互。你可以控制诸如反弹（恢复力）、阻尼（速度损失）和碰撞时寿命损失等属性。这可以为粒子对其环境的反应提供高度的真实感，例如火花从表面弹跳或水滴溅起。'
- en: To illustrate the application of these principles, consider the example of a
    simple campfire. In this case, embers rising from the fire can be created as a
    particle effect where the particles move upward, affected by a slightly randomized
    velocity to simulate the effect of heat and air resistance. Gravity’s influence
    would be negative here (pulling particles upward) due to the heat, and particles
    could have a reddish color at birth, fading to dark as they cool, simulating the
    life cycle of real embers. The smoke, however, can be created with particles moving
    upward with a higher randomized velocity, simulating the churning effect of fire.
    These particles would be less affected by gravity and have a longer life span.
    They could also use a color gradient, changing from dark gray near the fire to
    a lighter color as they rise and cool. Lastly, the fire itself can be simulated
    with a high rate of small, bright particles with short lifetimes and high randomized
    velocity. The effect would be a vibrant, dynamic flickering fire.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了说明这些原理的应用，考虑一个简单的篝火示例。在这种情况下，从火中升起的火星可以创建为一个粒子效果，其中粒子向上移动，受到略微随机的速度影响，以模拟热量和空气阻力的效果。由于热量，重力的影响在这里将是负的（向上拉粒子），粒子在出生时可能呈现红色，随着冷却而变暗，模拟真实火星的生命周期。然而，烟雾可以通过粒子向上移动并具有更高的随机速度来创建，模拟火焰的翻滚效果。这些粒子受重力影响较小，寿命较长。它们还可以使用颜色渐变，从靠近火焰的深灰色变为上升和冷却时的浅色。最后，火焰本身可以通过高频率的小而明亮的粒子来模拟，这些粒子寿命短，随机速度高。效果将是一个生动、动态的闪烁火焰。
- en: 'The **Particle System Renderer component** is responsible for rendering the
    particles on the screen. This component can be customized to fit the specific
    visual needs of your application. Some of its properties include the following:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子系统渲染器组件**负责在屏幕上渲染粒子。此组件可以根据您应用程序的具体视觉需求进行自定义。其一些属性包括以下内容：'
- en: '**Material**: This defines the appearance of the particles and can include
    textures, colors, and shaders'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质**：这定义了粒子的外观，可以包括纹理、颜色和着色器'
- en: '**Render Mode**: This determines how the particles are rendered and can be
    in the form of billboards (always facing the camera), meshes, or other similar
    entities'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染模式**：这决定了粒子的渲染方式，可以是广告牌（始终面向相机）、网格或其他类似实体'
- en: '**Sorting Mode**: This determines the order in which particles are rendered
    and is especially important when particles overlap'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序模式**：这决定了粒子渲染的顺序，当粒子重叠时尤为重要'
- en: Remember, particles aren’t just visual fluff. They can play a crucial role in
    your storytelling, player guidance, and world-building efforts. For instance,
    a trail of mystical sparkles might guide a player toward a hidden treasure, or
    a plume of smoke could hint at a recently extinguished campfire nearby.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，粒子不仅仅是视觉装饰。它们可以在你的叙事、玩家指导和世界构建工作中发挥关键作用。例如，一串神秘的火花可能引导玩家找到隐藏的宝藏，或者一缕烟雾可能暗示附近最近熄灭的篝火。
- en: Now that we’ve explored the key components of Unity’s particle system, let’s
    dive into the following section, which explains how to implement a particle system
    into our drum scene. The goal is that every time we hit a drum, fog is released,
    proportionate to how hard we hit it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了Unity粒子系统的关键组件，接下来让我们深入了解以下部分，该部分解释了如何将粒子系统集成到我们的鼓场景中。目标是每次我们敲击鼓时，都会释放出与敲击力度成比例的雾气。
- en: Adding particles to VR scenes with varying properties
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向VR场景添加具有不同属性的粒子
- en: Do you recall the last time you attended a live concert when, at the pinnacle
    of a legendary song, the stage was enveloped by a blanket of white fog while you
    were lost in the music with your friends? Taking inspiration from the theatrical
    smoke often utilized in real-world concerts, we’re going to apply our recently
    acquired knowledge about Unity’s Particle System to create a similar effect. Our
    objective is to integrate a particle system into our drum scene to release fog
    every time a drum is hit, with the intensity of the fog corresponding to the velocity
    of the strike. The more frequently the drums are played, the more the fog should
    saturate our scene, and vice versa, thereby fully replicating the euphoric sensation
    of being at a genuine concert.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得上一次你参加现场音乐会的时候吗？在传奇歌曲的高潮部分，舞台被一层白色的雾气笼罩，而你和朋友沉浸在音乐中？从现实世界音乐会中常用的舞台烟雾中汲取灵感，我们将应用我们最近学到的
    Unity 粒子系统知识来创建类似的效果。我们的目标是把粒子系统整合到我们的鼓场景中，每次敲击鼓时释放雾气，雾气的强度与敲击速度相对应。鼓敲击得越频繁，雾气应该越饱和我们的场景，反之亦然，从而完全复制在真正音乐会上的愉悦感觉。
- en: To achieve this objective, we need to first initialize a Particle System in
    our scene.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们首先需要在场景中初始化一个粒子系统。
- en: Initializing a Particle System in your VR drum scene
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的 VR 鼓场景中初始化粒子系统
- en: 'Follow these steps to establish a Particle System in your VR drum scene:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在您的 VR 鼓场景中建立粒子系统：
- en: In your Unity scene, *right-click* on the **Hierarchy** window, navigate to
    **Effects**, and select **Particle System**. This will instantiate a new Particle
    System within your scene.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 Unity 场景中，在 **Hierarchy** 窗口中 *右键单击*，导航到 **Effects**，然后选择 **Particle System**。这将在一个新的粒子系统实例化到您的场景中。
- en: The existing Particle System employs Unity’s standard particle material, which
    isn’t ideal for creating fog. However, we can easily customize our own material
    for the Particle System. Go to the `Fog`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现有的粒子系统使用的是 Unity 的标准粒子材质，这并不理想于创建雾效。然而，我们可以轻松地为粒子系统自定义材质。转到 `Fog`。
- en: 'Download a transparent image of a cloud or fog. We will use a cloud image,
    which is available for download at this link: [https://pixlok.com/images/clouds-png-image-free-download/](https://pixlok.com/images/clouds-png-image-free-download/).
    You can also access it through the GitHub folder for this chapter. Drag and drop
    this image into the `Fog` folder you just created.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载一张云或雾的透明图片。我们可以使用一张云的图片，该图片可在以下链接下载：[https://pixlok.com/images/clouds-png-image-free-download/](https://pixlok.com/images/clouds-png-image-free-download/)。您也可以通过本章的
    GitHub 文件夹访问它。将此图片拖放到您刚刚创建的 `Fog` 文件夹中。
- en: Within the `Fog` folder, generate a new material by *right-clicking* and then
    selecting `Fog`. Now, drag and drop the previously downloaded image from your
    local filesystem into the base map of the material. Next, modify the **Shader**
    fieldof the material to **Mobile/Particles/Alpha Blended** in the **Inspector**
    window. This setting allows the particles to overlap with each other and blend
    seamlessly, creating a more realistic fog effect.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Fog` 文件夹中，通过 *右键单击* 并选择 `Fog` 来创建一个新的材质。现在，将之前下载的图片从您的本地文件系统中拖放到材质的基础图中。接下来，在
    **Inspector** 窗口中将材质的 **Shader** 字段修改为 **Mobile/Particles/Alpha Blended**。此设置允许粒子相互重叠并无缝融合，从而创建更逼真的雾效。
- en: Select the Particle System, and drag the `Fog` material into its **Inspector**
    window. This will automatically update the material. As a result, your scene should
    now resemble the scene shown in *Figure 7**.6*.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择粒子系统，并将 `Fog` 材质拖动到其 **Inspector** 窗口中。这将自动更新材质。因此，您的场景现在应该类似于 *图 7.6* 中所示的场景。
- en: "![Figure 7.6 – \uFEFFHow your current Unity scene and the Inspector window\
    \ of the Particle System should look with the newly added fog](img/B20869_07_06.jpg)"
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 当前 Unity 场景和粒子系统检查器的 Inspector 窗口应如何看起来，以及新添加的雾效果](img/B20869_07_06.jpg)'
- en: Figure 7.6 – How your current Unity scene and the Inspector window of the Particle
    System should look with the newly added fog
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 当前 Unity 场景和粒子系统检查器的 Inspector 窗口应如何看起来，以及新添加的雾效果
- en: After successfully adding the Particle System to our VR drum scene, let’s modify
    its properties a bit to achieve a more dynamic behavior for the fog, which is
    dependent on the collision velocity of the drums and drumsticks in the next section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功将粒子系统添加到我们的 VR 鼓场景后，让我们稍微修改其属性，以实现更动态的雾行为，这取决于下一节中鼓和鼓棒的碰撞速度。
- en: Modifying the properties of the Particle System in your VR drum scene
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 VR 鼓场景中粒子系统的属性
- en: Let’s explore the properties of the Particle System in the **Inspector** window
    by expanding it. There are a few critical properties that you need to modify to
    make the fog on your VR drum scene behave naturally. The modified properties can
    be observed in *Figure 7**.7*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过展开**检查器**窗口中的粒子系统来探索其属性。有一些关键属性你需要修改，以使你的VR鼓场景中的雾效表现得更加自然。修改后的属性可以在**图7.7**中观察到。
- en: "![Figure 7.7 – \uFEFFThe expanded Particle System in its modified form in the\
    \ Inspector window](img/B20869_07_07.jpg)"
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![**图7.7** – 在检查器窗口中修改后的扩展粒子系统](img/B20869_07_07.jpg)'
- en: Figure 7.7 – The expanded Particle System in its modified form in the Inspector
    window
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.7** – 在检查器窗口中修改后的扩展粒子系统'
- en: 'These properties are explained in the following list in detail:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性将在以下列表中详细解释：
- en: '`5` seconds to make the scene more dynamic.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`秒来使场景更加动态。'
- en: '`PlaySoundOnCollision` script.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlaySoundOnCollision`脚本。'
- en: '`0`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`。'
- en: '`5`-second life span should be sufficient.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`秒的生命周期应该足够了。'
- en: '`0` and `2`. This randomizes the speed of each particle within these limits,
    creating a more naturalistic fog effect. **Curve** and **Random between Two Curves**
    are two alternative options that you could also choose. They provide even more
    nuanced control over speed variation, allowing you to define how the values change
    over time and within specific ranges.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`和`2`。这将在这些限制内随机化每个粒子的速度，从而创建一个更加自然主义的雾效。**曲线**和**在两个曲线之间随机**是两种你也可以选择的替代选项。它们提供了对速度变化的更细致的控制，允许你定义值随时间以及特定范围内如何变化。'
- en: '`2`,`2`,`2`) to double the size in all dimensions.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`(2,2,2)`来在所有维度上加倍大小。
- en: '**Start Color**: This determines the initial color of each particle. To enhance
    the visual appeal and make our fog effect more dynamic, we’ll introduce some color
    variations. Click on the arrow symbol next to **Start Color** and select the **Random
    between Two Gradients** option. This option allows us to define two color gradients,
    with the color of each individual particle being randomly assigned a value somewhere
    within these two gradients. After switching the option to **Random between Two
    Gradients**, two color gradient preview fields appear. To customize the color
    gradients, you can click on these fields to open the **Gradient Editor** window.
    In the **Gradient Editor** window, you can add, remove, or rearrange color markers
    to achieve the color gradient you desire. *Figure 7**.8* provides a visual guide
    on how to modify a color gradient.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起始颜色**：这决定了每个粒子的初始颜色。为了增强视觉效果并使我们的雾效更加动态，我们将引入一些颜色变化。点击**起始颜色**旁边的箭头符号，并选择**在两个渐变之间随机**选项。此选项允许我们定义两个颜色渐变，每个单独的粒子的颜色将随机分配到这两个渐变之间的某个值。在将选项切换到**在两个渐变之间随机**后，会出现两个颜色渐变预览字段。要自定义颜色渐变，你可以点击这些字段以打开**渐变编辑器**窗口。在**渐变编辑器**窗口中，你可以添加、删除或重新排列颜色标记，以达到你想要的颜色渐变。**图7.8**提供了一个如何修改颜色渐变的视觉指南。'
- en: "![Figure 7.8 – \uFEFFHow to modify the Gradient Editor of the start color](img/B20869_07_08.jpg)"
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![**图7.8** – 如何修改起始颜色的渐变编辑器](img/B20869_07_08.jpg)'
- en: Figure 7.8 – How to modify the Gradient Editor of the start color
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.8** – 如何修改起始颜色的渐变编辑器'
- en: Initially, you can set **Mode** to either **Blend** or **Fixed**. The **Fixed**
    mode presents a solid color, whereas the **Blend** mode enables smooth transitions
    between colors. You can then add multiple keyframes by simply *left-clicking*
    either above or below the color space. The upper keyframes establish the alpha
    values, dictating the transparency, while the lower keyframes determine the colors
    themselves.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，你可以将**模式**设置为**混合**或**固定**。**固定**模式呈现一种纯色，而**混合**模式则允许颜色之间的平滑过渡。然后，你可以通过简单地**左键单击**颜色空间上方或下方来添加多个关键帧。上方的关键帧建立alpha值，决定透明度，而下方的关键帧则确定颜色本身。
- en: At the bottom of the window, you’ll see two existing gradient presets, with
    a third, labeled **New**, that corresponds to the gradient we’re currently editing.
    Create two gradient presets as per your preference, and assign them to the start
    color. In our case, we will choose to use the two pre-existing presets that we
    had (the white and rainbow gradients). At runtime, this configuration will yield
    a captivatingly vibrant and dynamic color spectrum in our fog effect, as shown
    in *Figure 7**.9*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口底部，你会看到两个现有的渐变预设，还有一个标记为**新**的第三个预设，它对应于我们当前正在编辑的渐变。根据你的偏好创建两个渐变预设，并将它们分配给起始颜色。在我们的例子中，我们将选择使用我们已有的两个预设（白色和彩虹渐变）。在运行时，这种配置将在我们的雾效中产生引人入胜的鲜艳和动态的色彩光谱，如图**7.9**所示。
- en: "![Figure 7.9 – \uFEFFThe visual appearance of the fog when choosing two pre-existing\
    \ presets for the start color](img/B20869_07_09.jpg)"
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 选择两个预置起始颜色时的雾的视觉外观](img/B20869_07_09.jpg)'
- en: Figure 7.9 – The visual appearance of the fog when choosing two pre-existing
    presets for the start color
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 选择两个预置起始颜色时的雾的视觉外观
- en: '`0`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`。'
- en: '`0.4`. If the simulation speed is adjusted to a value lower than `0.4`, the
    fog’s movement will be even slower, creating a more languid appearance, whereas
    a value higher than `0.4` will make the fog move more rapidly, giving it a brisker
    motion.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.4`。如果模拟速度调整到低于`0.4`的值，雾的运动将变得更慢，创造出更悠闲的外观，而高于`0.4`的值将使雾移动更快，赋予它更活泼的运动。'
- en: Expand the `13`. `13` is chosen as the ideal rate to achieve the desired particle
    density and appearance for our purpose. By keeping `0`, we ensure that particles
    are emitted based on time alone, not movement, giving us precise control over
    the number of particles being emitted.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开`13`。`13`被选为达到所需粒子密度和外观的理想速率。通过保持`0`，我们确保粒子是根据时间单独发射的，而不是根据运动，这样我们可以精确控制发射的粒子数量。
- en: Further down, expand the `3`,`3`,`1`) to create a larger fog effect. Due to
    the Particle System’s -90-degree rotation on the *X* axis, the *Z* axis now points
    in the *Y* direction and doesn’t need to be scaled.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面，将`(3,3,1)`展开以创建更大的雾效果。由于粒子系统在X轴上的-90度旋转，Z轴现在指向Y方向，因此不需要缩放。
- en: Enable the `30`. This will gradually fade the particles, adding to the realistic
    fog effect. *Figure 7**.10* provides you with a comparison of how the fog looks
    with and without the **Color over Lifetime** module enabled, and with a low **Alpha**
    setting.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用`30`。这将逐渐使粒子褪色，增加逼真的雾效果。*图7.10*提供了启用或未启用**颜色随时间变化**模块以及低**Alpha**设置时雾的外观比较。
- en: "![Figure 7.10 – \uFEFFComparing the visual appearance of the fog with or without\
    \ the Color over Lifetime module enabled](img/B20869_07_10.jpg)"
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – 比较启用或未启用“随时间变化颜色”模块时雾的视觉外观](img/B20869_07_10.jpg)'
- en: Figure 7.10 – Comparing the visual appearance of the fog with or without the
    Color over Lifetime module enabled
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 比较启用或未启用“随时间变化颜色”模块时雾的视觉外观
- en: 'While the Particle System provides a plethora of parameters to play around
    with, the ones we’ve discussed are the most crucial to creating a realistic fog
    effect. If you’re interested in diving deeper into Particle Systems, Unity offers
    a short, free course that we highly recommend: [https://learn.unity.com/tutorial/introduction-to-particle-systems#](https://learn.unity.com/tutorial/introduction-to-particle-systems#).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管粒子系统提供了大量的参数可以调整，但我们讨论的这些参数对于创建逼真的雾效果最为关键。如果您想深入了解粒子系统，Unity提供了一门短小、免费的课程，我们强烈推荐：[https://learn.unity.com/tutorial/introduction-to-particle-systems#](https://learn.unity.com/tutorial/introduction-to-particle-systems#)。
- en: Scripting fog appearance on collision for your VR drum scene
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在VR鼓场景中通过脚本在碰撞时设置雾的外观
- en: After setting up the particle system, we need to go back to the `PlaySoundOnCollision`
    script and make a few adjustments.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好粒子系统后，我们需要回到`PlaySoundOnCollision`脚本并做一些调整。
- en: 'Firstly, we need to create a `public` variable that can reference the Particle
    System we want the particles to emit from. The code for this is relatively simple:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个`public`变量，以便引用我们想要粒子从其发射的粒子系统。这个代码相对简单：
- en: '[PRE7]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, whenever the drum gets struck, we should call a method that enables the
    emission of particles from the Particle System. We base the number of emitted
    particles on the speed of the drumstick’s impact. Since we already have the `OnTriggerEnter()`
    method that adjusts the sound volume based on the velocity of the drumstick, we
    can simply apply the same logic to the particle system. To do this, we add three
    lines of code to the `if` statement in the `OnTriggerEnter()` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每当鼓被击打时，我们应该调用一个方法来启用粒子系统发射粒子。我们根据鼓棒的冲击速度来确定发射粒子的数量。由于我们已经有根据鼓棒速度调整音量的`OnTriggerEnter()`方法，我们可以简单地将相同的逻辑应用于粒子系统。为此，我们在`OnTriggerEnter()`方法中的`if`语句中添加了三行代码：
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`fogParticleSystem` is a reference to the Particle System GameObject we set
    up previously, which will be assigned through the `int numParticles = Mathf.RoundToInt(velocityMagnitude
    * 10f);` line translates the velocity’s magnitude into a corresponding number
    of particles, multiplying it by `10` – an arbitrary factor that can be adjusted
    for your specific needs. The number is rounded to the nearest integer, as the
    particle emission method requires an integer input.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`fogParticleSystem`是对我们之前设置的粒子系统GameObject的引用，它将通过`int numParticles = Mathf.RoundToInt(velocityMagnitude
    * 10f);`这一行将速度的大小转换为相应的粒子数量，乘以`10`——这是一个可以调整以适应你特定需求的任意因子。这个数字被四舍五入到最接近的整数，因为粒子发射方法需要一个整数输入。'
- en: The `ParticleSystem.EmitParams emitParams = new ParticleSystem.EmitParams();`
    line initializes an instance of `EmitParams`. This struct can be used to change
    specific parameters of the Particle System when particles are emitted via scripting.
    In our case, we will use the default settings of the created Particle System.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem.EmitParams emitParams = new ParticleSystem.EmitParams();`这一行初始化了一个`EmitParams`实例。这个结构可以用来在通过脚本发射粒子时改变粒子系统的特定参数。在我们的案例中，我们将使用创建的粒子系统的默认设置。'
- en: Finally, `fogParticleSystem.Emit(emitParams, numParticles);` calls the `Emit()`
    method to instantly emit a defined number of particles. It uses the previously
    created `EmitParams` instance and the calculated number of particles derived from
    the object’s velocity.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`fogParticleSystem.Emit(emitParams, numParticles);`调用`Emit()`方法来立即发射定义数量的粒子。它使用之前创建的`EmitParams`实例和从对象的速率中计算出的粒子数量。
- en: With these adjustments, the desired functionality is added. Back in the Unity
    Editor, simply drag and drop the Particle System into the `fogParticleSystem`
    field in your `PlaySoundOnCollision` script component of your drums via the **Inspector**
    window. Once done, run your scene, and test the implementation while wearing your
    VR headset. Note how the more frequently the drums are hit, the more the fog saturates
    the scene, and vice versa.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些调整，所需的函数功能被添加。回到Unity编辑器中，只需通过**检查器**窗口将粒子系统拖放到你的鼓的`PlaySoundOnCollision`脚本组件中的`fogParticleSystem`字段即可。完成后，运行你的场景，并戴上VR头盔测试实现效果。注意，鼓被敲击的频率越高，雾气越能饱和场景，反之亦然。
- en: Congratulations! You now know how to fully replicate the euphoric sensation
    of being at a concert featuring a real-life drummer!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在知道如何完全复制出现在一场真实鼓手演奏的音乐会现场时的兴奋感觉！
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we embarked on a fascinating journey through the world of sound
    and particles, understanding their physical properties and delving into the implementation
    of these real-world phenomena in Unity scenes for heightened immersive experiences
    in XR.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了一段穿越声音和粒子世界的迷人之旅，理解它们的物理属性，并深入探讨了在Unity场景中实现这些现实世界现象的方法，以增强XR体验的沉浸感。
- en: Upon reaching the end of this chapter, you should now be capable of not only
    constructing end-to-end XR applications with intricate interactions or animations
    but also feel comfortable enhancing these creations, by effectively using Unity’s
    audio and Particle Systems to introduce an additional layer of realism to your
    XR scenes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到达本章的结尾，你现在应该不仅能够构建具有复杂交互或动画的端到端XR应用，而且能够舒适地通过有效地使用Unity的音频和粒子系统来增强这些创作，为你的XR场景引入额外的真实感。
- en: The XR development concepts we’ve covered so far in this book have largely been
    aimed at those at the beginner to intermediate levels. However, as we move forward,
    we have something truly unique and enriching in store for you. The following chapter
    will further elevate your XR development skills by introducing you to some of
    the most significant and advanced techniques in this field, such as hand-tracking,
    eye- and head-tracking, and multiplayer functionalities. This crucial knowledge
    will refine your skillset, transforming you into a more versatile XR developer
    and enabling you to create an even broader array of sophisticated XR applications.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本书迄今为止所涵盖的XR开发概念主要针对初学者到中级水平的人。然而，随着我们继续前进，我们为你准备了一些真正独特且丰富的内容。接下来的章节将进一步通过介绍这个领域的一些最显著和高级技术来提升你的XR开发技能，例如手势追踪、眼动和头部追踪以及多玩家功能。这些关键知识将完善你的技能集，使你成为一个更全能的XR开发者，并能够创建更广泛的复杂XR应用。
- en: 'Part 3 – Advanced XR Techniques: Hand-Tracking, Gaze-Tracking, and Multiplayer
    Capabilities'
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 - 高级XR技术：手势追踪、注视追踪和多玩家功能
- en: Congratulations on completing your journey from being a beginner in XR development
    and Unity to becoming highly proficient in creating various XR technologies with
    sophisticated logic! In this final part of our book, we aim to further enhance
    your skills to become an intermediate-level XR developer. We will introduce you
    to advanced XR techniques that are not only cutting-edge in the XR application
    landscape but will also elevate your XR scenes to a new level of intuitiveness
    and enjoyment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您完成了从XR开发和Unity初学者到熟练掌握创建各种高级XR技术并具有复杂逻辑的进阶者的旅程！在我们这本书的最后一部分，我们旨在进一步提升您的技能，使您成为一名中级XR开发者。我们将向您介绍那些不仅在XR应用领域处于前沿，而且还能提升您的XR场景到新的直观性和娱乐水平的先进XR技术。
- en: This section will also introduce you to the different phases and aspects of
    the XR development life cycle. It will provide you with a precise, research-based
    overview of the current state of the art and future trends in XR development.
    By delving into additional XR toolkits and plugins beyond those covered earlier
    in this book, we will prepare you with the knowledge needed to dive deeper into
    your preferred area of XR development once you’ve completed this book.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还将向您介绍XR开发生命周期的不同阶段和方面。它将为您提供基于研究的、精确的当前XR开发技术状态和未来趋势的概述。通过深入研究本书早期未涵盖的额外XR工具包和插件，我们将为您提供在完成本书后深入您所偏好的XR开发领域的所需知识。
- en: 'This part contains the following chapters:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B20869_08.xhtml#_idTextAnchor026), *Building Advanced XR Techniques*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B20869_08.xhtml#_idTextAnchor026), *构建高级XR技术*'
- en: '[*Chapter 9*](B20869_09.xhtml#_idTextAnchor028), *Best Practices and Future
    Trends in XR Development*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B20869_09.xhtml#_idTextAnchor028), *XR开发中的最佳实践和未来趋势*'
