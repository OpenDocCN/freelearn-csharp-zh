- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best Approaches for Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware is one of the most powerful concepts in ASP.NET Core. For legacy
    ASP.NET developers, *Middleware* is a relatively new term. Before middleware,
    there were HTTP handlers and modules, which required separate code to configure
    through a `web.config`. Middleware is now considered a first-class citizen in
    an ASP.NET application, making it easier to maintain in a single code base. First
    introduced in ASP.NET Core 1.0, the common request and response concepts are considered
    pipelines for your applications with the ability to control a request and response’s
    body. This opens up a number of possibilities to create amazing features for your
    ASP.NET Core web applications.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we’ll examine how to use Middleware and some
    common built-in Middleware components found in almost every ASP.NET Core application.
    Next, we’ll examine the three request delegates (`Run`, `Map`, and `Use`) and
    explain what each is used for in the pipeline. We’ll also cover some ways to clean
    up your middleware and, finally, apply those concepts to building a simple middleware
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Practices for Middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Emoji Middleware Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have learned how Middleware works, how to
    use request delegates and standards when writing your own Middleware, and understand
    how to create your own Middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since this is the first chapter (one of many to come since we’re in coding
    territory now) containing technical requirements, selecting your favorite editor
    that supports ASP.NET Core 7.0 or higher and C# code would be ideal. My top three
    editors are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio (preferably 2022 or newer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains Rider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The editor we’ll be using is Visual Studio 2022 Enterprise, but any version
    (Community or Professional) will work for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is located at Packt Publishing’s GitHub repository
    located here: [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware is software you configure at the beginning of your application when
    the application starts. It’s important to note that the Middleware you add should
    be based on your application’s requirements. It’s not necessary to add every single
    component. Streamlining your Middleware pipeline is important, which we’ll discuss
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: It’s been said that the difference between a library and a framework is that
    a library is the code you call from your application, whereas a framework is structured
    a certain way to call your code. This is what Middleware has evolved into from
    earlier versions of ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll present the common flow of a Middleware pipeline and
    how to control what happens in a middleware component. By the end of this section,
    you’ll understand how a middleware pipeline works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Middleware Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your web application starts, Middleware is called and constructed once
    per *application lifetime*. Once the Middleware components are registered, they
    execute in a certain order. This order is important throughout the pipeline since
    each middleware component can rely on previously registered components.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Authentication component is important to configure before the
    Authorization component since we need to know who someone is before we can determine
    what they can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3**.1*, we can see what a standard Middleware pipeline consists
    of in a web application, which we’ll address next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Standard Middleware pipeline for an ASP.NET 8 Web Application](img/Figure_3.01_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Standard Middleware pipeline for an ASP.NET 8 Web Application
  prefs: []
  type: TYPE_NORMAL
- en: Each one of these components is optional, but some Middleware components are
    dependent on others. When a URL is requested by the user, the first Middleware
    component is hit. In this case, it’s `ExceptionHandler`. Once `ExceptionHandler`
    is done, the pipeline moves on to the next component, which is the HSTS component.
    As we move through each Middleware component, we eventually reach the endpoint.
    Once the endpoint is processed, the response is sent back through the Middleware
    pipeline in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the start of this section, your Middleware depends on what your
    application requires when adding additional components. If your application is
    a **Single-Page Application** (**SPA**), the inclusion of the CORS, Static Files,
    and Routing Middleware would be important.
  prefs: []
  type: TYPE_NORMAL
- en: Each middleware component is responsible for either passing information on to
    the next component in line based on your configuration or terminating the process.
    If they decide to terminate the pipeline, they are called *terminal Middleware*
    components. They purposefully stop the middleware from processing any other requests
    and exit the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Using Request Delegates – Run, Use, and Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With everything we’ve discussed so far, you’re probably wondering how we create
    a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The three request delegates available are the `Run`, `Use`, and `Map` extension
    methods. You’ve no doubt used them in your `Program.cs` code numerous times, but
    what’s the difference between the three of them?
  prefs: []
  type: TYPE_NORMAL
- en: Run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Run()` request delegate is strictly terminal middleware, meaning it will
    run and immediately quit the pipeline. It doesn’t contain a `next` parameter.
    It simply runs and immediately terminates the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the following code, this will immediately terminate the pipeline
    from executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice there isn’t a `next` parameter introduced in the delegate. The preceding
    code will write the message `"This will terminate the web app."` to the browser
    and immediately terminate the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Use()` request delegate is used to chain multiple request delegates together
    in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The key to implementing a proper `Use` request delegate is the use of `await
    next.Invoke()`. `next.Invoke()` will execute the next middleware component in
    sequential order. Anything before this line will be processed on the request,
    and anything after this line will be processed on the response back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a code sample of two anonymous Middleware components in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice anything before the `next.invoke()` line of code is executed and
    then the execution moves on to the next Middleware in the order. Once we get to
    the end of the Middleware pipeline, we make the return trip back, which executes
    all of the code *after* each Middleware’s `await` `next();` statement.
  prefs: []
  type: TYPE_NORMAL
- en: After each Middleware component is executed, the application runs and then returns
    in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Map()` request delegate is meant for branching the pipeline based on a
    certain request path or route. While this is for specific Middleware conditions,
    creating a new map is highly unlikely. It’s usually best to use pre-built Middleware
    components such as `.MapRazorPages()`, `.MapControllers()`, or any of the other
    `.MapXxxx()` methods. These methods already have pre-defined routes in place.
    Most routing occurs inside other extensions like the previously mentioned Middleware
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a `MapWhen()` extension method for conditional middleware branching
    based on the result of a given predicate. For example, if you want to create a
    controlled maintenance page for your site, you could use a simple Boolean called
    `underMaintenance` and use it to display a simple message until your site is available
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we add our `.MapWhen()` delegate to use a specific Boolean
    to identify whether we are under maintenance or not. Notice we’re using the `.Run`
    delegate because we don’t want to continue any further down the Middleware pipeline.
    This approach is just one example of Middleware’s flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Using Built-in Middleware Components
  prefs: []
  type: TYPE_NORMAL
- en: While you can create your own Middleware components, the best approach is to
    see whether a Middleware component exists from the large number of built-in components
    already available to you. The entire list is located at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware).
    This chart provides a description of each Middleware component and the location
    of where to place it in the Middleware pipeline. In addition to the built-in components,
    use NuGet to find innovative Middleware components as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the middleware pipeline, learned how to use the
    request delegates and what each request delegate can do, and learned about all
    of the built-in middleware components available for ASP.NET web applications.
    In the next section, we’ll examine the common practices for using Middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Common Practices for Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll review a number of common practices when writing your
    own middleware to keep everything running optimally in your web application. Let’s
    get started!
  prefs: []
  type: TYPE_NORMAL
- en: Defer to Asynchronous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with Middleware, we want to get the best performance possible so
    our users can begin working in the application. As more users continue to use
    the application, performance may suffer.
  prefs: []
  type: TYPE_NORMAL
- en: A synchronous operation is where code is executed and the application has to
    wait for it to finish, meaning it’s single-threaded and runs on the application’s
    main thread, but when an asynchronous operation is executed, it creates a new
    thread and lets the framework know what to call when it’s finished processing.
    This is signified through the `async`/`await` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: For the majority of Middleware operations, it’s best to use asynchronous calls
    when applicable. This will increase Middleware (and application) performance along
    with better scalability and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing the Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the more important points of setting up your Middleware is to confirm
    everything is in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: Compare your application’s requirements with the previous chart to identify
    what middleware components you need and what their correct order is for your web
    application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to include a W3C Logging Middleware component (which
    is included in the built-in Middleware components from Microsoft), it has to be
    at the beginning of the pipeline to log any subsequent requests made throughout
    the application. Each component has its place in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Consolidating existing Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a new ASP.NET project, you’ll notice the collection of `app.UseXxx()`
    listed in `Program.cs`. While this is the “out-of-the-box” approach for preparing
    your pipeline, there are other ways to organize and register components for your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to use extension methods based on how you logically partition
    your uses into similar groupings while keeping the components in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example would be to move all client Middleware into its own extension method
    called `.``UseClientOptions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the code in your `Program.cs` file contains one line, and you know exactly
    what the extension method does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When using this approach, your `Program.cs` file is cleaner, well maintained,
    and contains fewer lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other possible areas to partition are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UseDataXxxxx()` – Centralized location for connection strings for your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseMapping()/UseRouting()` – Create a collection of routes for your application
    and APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegisterDependencyInjection()` – Centralize the classes in a number of extension
    methods similar to this grouping approach, but partitioned by sections in your
    application – for example, `RegisterDIPayroll()` for registering classes pertaining
    to the Payroll section of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are merely suggestions, the concept is to trim the size of the `Program.cs`
    file so other developers understand the approach with fewer lines of code, and
    it provides enough clarity for other developers to extend the technique further.
  prefs: []
  type: TYPE_NORMAL
- en: As a recommendation, include all of the important Middleware components upfront
    and confirm the application runs as expected, *then* perform your refactoring
    by creating your groups for consolidation. Remember, the order of Middleware components
    matters.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating your Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating your first middleware component, you may be tempted to create
    it and use it in this fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: One problem with this approach is the preceding code can make your `Program.cs`
    file look a little messy if you have a large number of custom middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your custom component working, it’s better to encapsulate it
    into its own class for increased reusability. If we use our previous example,
    our new class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `MyFirstMiddleware` component is a simple class that can
    contain only one method of `Invoke` or `InvokeAsync`. As mentioned before, we’ll
    use the `InvokeAsync` asynchronous method.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering how `ILogger` is passed in, ASP.NET Core has a number of
    classes automatically registered with its out-of-the-box dependency injection
    library. `ILogger` is one of those classes, so we don’t need to worry about passing
    it through to our `MyFirstMiddleware` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our class in our `Program.cs` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since we’re good ASP.NET developers, we can definitely improve the
    code. Most middleware components have extension methods attached to them to make
    them easier to use (which we’ll add now with the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Program.cs` file is much simpler and cleaner now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These simple practices make a developer’s life easier for reusability and encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered a number of standard methods for writing maintainable
    and efficient Middleware by using asynchronous calls, prioritizing the order of
    your components, and consolidating the existing Middleware into extension methods.
    We also examined how to encapsulate components by creating classes and extension
    methods to make the code easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Emoji Middleware Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the rise of emoticons…sorry, emojis…in the 2000s, a number of legacy websites
    use the old-style of text-based emoticons instead of the more modern emojis. Legacy
    **Content Management Systems** (**CMSs**) must have a lot of these text-based
    characters in their content. To update a website’s content to replace all of these
    emoticons with proper emojis sounds extremely time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll apply our standards in creating an emoji Middleware component
    where, if it detects a text-based emoticon, it’ll convert it to a more modern
    emoji.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating the Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this new Middleware component, we want to create it in its own class in
    `EmojiMiddleware.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first draft of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'While this isn’t very exciting, this boilerplate meets all of the previously-mentioned
    standards for building Middleware components, which include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An encapsulated Middleware component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Asynchronous methods (`InvokeAsync()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An extension method for reuse and readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now focus on the conversion process.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the Component’s Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Middleware, there are two ways to process a request and response: by using
    either streams or pipelines. While pipelines are the better option for high performance,
    we’ll focus on streams for our `EmojiMiddleware`. We’ll examine pipelines in a
    later chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Our middleware stream is located in `HttpContext` through `HttpRequest.Body`
    and `HttpResponse.Body`. In our `Invoke` method, we conveniently pass in an `HttpContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Our first order of business is to create the `EmojiStream`. This will accept
    a simple response stream and read it into memory. Once we have our HTML, we can
    search and replace our emoticons. We need a map to identify the text-based characters
    and what image to replace them in our HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our life a little easier, we’ll inherit from the `Stream` base class
    and simply override specific methods to fit our needs. The only implementation
    our `EmojiStream` class needs is our text-based emoticons-to-emojis mapping and
    the `.Write()` method, as shown with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the code, we create our map of emoticons to look for in
    the HTML. The `EmojiStream` class is fairly common, except for the `WriteAsync()`
    method. We’ll grab the HTML using the `GetString()` method and search for each
    emoticon in the response. If we find one, we’ll replace it with an image tag and,
    finally, write the bytes back into the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re focused on using streams in the Middleware, we’ll pass a stream
    into the constructor instead of creating a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the middleware piece left, we can use the `EmojiStream` in our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While our Middleware component takes a simple `RequestDelegate`, the majority
    of the component is in the `InvokeAsync()` method. First, we create a new stream
    for our response. Next, we replace the standard response with our own stream.
    When we are coming back from our endpoint, we create our `EmojiStream` instance
    and pass in our custom stream to the `Response.Body`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `HttpContext` exposes `HttpRequest.Body` and `HttpResponse.Body` as streams,
    it’s easier to pass `HttpContext` into custom middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can’t forget our extension method, which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This extension method is considered a façade to hide the details of what our
    `EmojiStream` is doing behind the scenes. While we could use the `builder.UseMiddleware<EmojiMiddleware>()`
    syntax in our `Program.cs` file, the extension method cleans it up a bit, giving
    it a professional look.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing required is to add the `EmojiMiddleware` to the pipeline in
    your `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating a brand new ASP.NET Core website, we’ll add the following HTML
    to the bottom of our Index page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the application without our middleware component, we have the following
    output (*Figure 3**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 3.2 – Before our EmojiMiddleware is added to the pipeline](img/Figure_3.02_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Before our EmojiMiddleware is added to the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'When we add our Emoji Middleware to our pipeline and run our application again,
    we receive the following output (*Figure 3**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – After our EmojiMiddleware is added to the pipeline](img/Figure_3.03_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – After our EmojiMiddleware is added to the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we built our first Middleware component by encapsulating the
    logic in a class, examined the components pipeline using streams, and used the
    Middleware component in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gained a solid understanding of the Middleware pipeline,
    its components, and best practices for using Middleware in ASP.NET Core. We also
    learned about common practices when using Middleware, such as always using asynchronous
    methods, prioritizing the order, consolidating your Middleware components into
    groups, and encapsulating your Middleware into classes. Knowing these Middleware
    concepts is key to creating maintainable and readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we finished the chapter by creating a simple component to replace text
    with an image in a stream for the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll begin looking at applying security to new and existing
    applications.
  prefs: []
  type: TYPE_NORMAL
