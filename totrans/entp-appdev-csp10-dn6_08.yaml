- en: '*Chapter 6*: Configuration in .NET 6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A configuration in .NET 6 comprises the default settings as well as the runtime
    settings for your application; a configuration is a very powerful feature. We
    can update settings such as feature flags to enable or disable features, dependent
    service endpoints, database connection strings, logging levels, and much more,
    and control application behavior at runtime without recompilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging built-in configuration providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom configuration provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a good grasp of configuration concepts,
    configuration providers, and how to leverage them in your projects, as well as
    being able to identify the configurations and configuration sources that are appropriate
    for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need a basic understanding of.NET and Azure. The code for the chapter
    can be found here: https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter06.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A configuration is generally stored as `Program.cs`), you will get a default
    configuration provided by .NET 6\. In addition, you can configure different built-in
    and custom configuration sources, and then read them using different configuration
    providers whenever you need them anywhere in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Application and configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Application and configuration
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows a high-level relationship between an application,
    a configuration provider, and a configuration file. The application uses the configuration
    provider to read the configuration from the configuration source; the configuration
    can be environment-specific. **Env A** could be your development environment and
    **Env B** could be your production environment. At runtime, the application will
    read the right configurations based on the runtime context and environment where
    it's running.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how a default configuration works and how to
    add and read configurations from the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Default configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how a default configuration works, let''s create a new .NET 6
    web API, set the project name as `TestConfiguration`, and open `Program.cs`. The
    following is a code snippet from the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we see that `WebApplication.CreateBuilder` takes care
    of providing the default configuration for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loading of the configuration is done in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MemoryConfigurationProvider`: This loads configurations from in-memory collection
    as configuration key-value pairs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ChainedConfigurationProvider`: This adds the host configuration and sets it
    as the first source. For more details on the host configuration, you can use this
    link: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-6.0).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`JsonConfigurationProvider`: This loads the configurations from the `appsettings.json`
    file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`JsonConfigurationProvider`: This loads the configurations from the `appsettings.Environment.json`
    file; `Environment` in `appsettings.Environment.json` can be set to refer to development,
    staging, or production.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`EnvironmentVariablesConfigurationProvider`: This loads environment variable
    configurations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this section, a configuration is specified
    as key-value pairs in sources. Configuration providers that are added later (in
    terms of order) override previous key-value pair settings. For example, if you
    have a `DbConnectionString` key in `MemoryConfigurationProvider` as well as in
    `JsonConfigurationProvider`, the value of the `DbConnectionString` key in `JsonConfigurationProvider`
    will override the key-value pair settings of `MemoryConfigurationProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you debug the `Program.cs` code, you can see the default configuration
    provided by `CreateDefaultBuilder` being injected into the configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Default configuration sources'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Default configuration sources
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can add the configurations required for our application in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous section, there are multiple configuration sources
    available. The `appsettings.json` file is what is most widely used in real-world
    projects to add the configuration required for an application unless it's a secret
    and cannot be stored as plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a couple of common scenarios where we need configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: If we need an `ApplicationInsights` instrumentation key to add application telemetry,
    which can be part of our configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have dependent services that need to be invoked, which can be part of
    our configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can change from environment to environment (the values differ between
    development environments and production environments).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the following configurations to the `appsettings.json` file so
    that you can update it directly when there is a change and start consuming it
    without recompilation and deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we see that we have added a key-value pair for the
    `ApplicationInsights` instrumentation key, where the key is the `InstrumentationKey`
    string, and the value is the actual instrumentation key that the application needs
    to instrument telemetry in `ApplicationInsights`. In the `ApiConfigs` section,
    we have added multiple key-value pairs in hierarchical order with the configuration
    required to invoke our dependent services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to read the configuration we have added.
  prefs: []
  type: TYPE_NORMAL
- en: Reading configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how we can add configurations to `appsettings.json`. In this section,
    we will see how we can read them inside our projects using the different options
    that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `builder.Configuration` object that you get in `Program.cs` provided by
    `WebApplication.CreateBuilder` implements the `Microsoft.Extensions.Configuration.IConfiguration`
    type, and you have the following options available to read in `IConfiguration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how we can leverage these options from `Iconfiguration` to read the
    configurations that we added in the previous section, *Adding configurations*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the `ApplicationInsights` instrumentation key from `appsettings.json`,
    we can use the `string this[string key] { get; set; }` option using the following
    code in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To read `ApiConfigs`, we can use the following code. We can use a delimiter
    in the configuration keys for the configuration API to read the hierarchical configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Reading this way using a delimiter is error-prone and difficult to maintain.
    The preferred approach is to use the **options** pattern provided in ASP.NET Core.
    Instead of reading each key/setting value one by one, the options pattern uses
    classes, which will also give you strongly typed access to the related settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'When configuration settings are isolated by scenarios into strongly typed classes,
    the application adheres to two important design principles:'
  prefs: []
  type: TYPE_NORMAL
- en: The **interface segregation principle** (**ISP**), or encapsulation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With ISP or encapsulation, you read the configuration through a well-defined
    interface or contract and depend only on the configuration settings you need.
    Also, if there is a huge configuration file, this will help in the separation
    of concerns, as different parts of the application won't be dependent on the same
    configuration, thus allowing them to be decoupled. Let's see how we can leverage
    the options pattern in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create the following `ApiConfig` and `ApiUrl` classes and add them
    to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code in `Program.cs` to read the configuration using the
    `GetSection` method, and then call `Bind` to have the configuration bound to the
    strongly-typed class that we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '`GetSection` will read the specific section from `appsettings.json` with the
    specified key. `Bind` will attempt to bind the given object instance to the configuration
    values by matching property names to the configuration keys. `GetSection(string
    sectionName)` will return `null` if the requested section does not exist. In real-world
    programs, please ensure that you add null checks.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how we can add and read data from `appsettings.json`
    by using a configuration API. I also mentioned that we should use `appsettings.json`
    for plain text and not for secrets. In the next section, we will look at built-in
    configuration providers as well as how to add and read secrets using the Azure
    Key Vault configuration provider.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging built-in configuration providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple configuration sources available other than `appsettings.json`,
    and .NET 6 provides several built-in configuration providers to read from them.
    The following are built-in providers available for .NET 6:'
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Key Vault configuration provider reads configurations from Azure Key
    Vault.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file configuration provider reads configurations from INI, JSON, and XML
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command-line configuration provider reads configuration from command-line
    parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment variable configuration provider reads configurations from environment
    variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memory configuration provider reads configurations from in-memory collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure App Configuration provider reads configuration from Azure App configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key-per-file configuration provider reads configurations from a directory's
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how we can leverage the Azure Key Vault configuration provider and
    the file configuration provider, as both are important and more widely used when
    compared to others.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following link to learn about other configuration providers
    that we are not covering in detail here: https://docs.microsoft.com/en-us/dotnet/core/extensions/configuration-providers.'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Key Vault configuration provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Key Vault is a cloud-based service that provides a centralized configuration
    source for securely storing passwords, certificates, API keys, and other secrets.
    This helps to keep our application secured and compliant from a security breach.
    Let's see how we can create a key vault, add a secret to it, and access it from
    an application using the Azure Key Vault configuration provider.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a key vault and adding secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will use Azure Cloud Shell to create a key vault and add
    a secret. Azure Cloud Shell is browser-based and can be used to manage Azure resources.
    The following is the list of steps you need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sign in to the Azure portal using [https://portal.azure.com](https://portal.azure.com).
    Select the Cloud Shell icon on the portal page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Azure Cloud Shell'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Azure Cloud Shell
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get the option to select **Bash** or **PowerShell**. Choose **PowerShell**.
    You can change shells at any time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Azure Cloud Shell options – PowerShell and Bash'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Azure Cloud Shell options – PowerShell and Bash
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a resource group with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The actual command I ran for this demonstration is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '`{RESOURCE GROUP NAME}` stands for the resource group name for the new resource
    group, and `{LOCATION}` stands for the Azure region (for your data center).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a key vault in the resource group with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s the actual command I ran for this demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '`{KEY VAULT NAME}` is the unique name for the new key vault.'
  prefs: []
  type: TYPE_NORMAL
- en: '`{RESOURCE GROUP NAME}` is the resource group name for the new resource group
    created in the prior step.'
  prefs: []
  type: TYPE_NORMAL
- en: '`{LOCATION}` is the Azure region (data center).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create secrets in the key vault as name-value pairs with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s the actual command I ran for this demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '`{KEY VAULT NAME}` is the same key vault name that you created in the prior
    step.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SecretName` is the name of your secret.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SecretValue` is the value of your secret.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now successfully created a key vault named `TestKeyVaultForConfig`
    and have added a secret with the key as `TestKey` and the value as `TestValue`
    using Azure Cloud Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Azure Key Vault secrets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.5_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Azure Key Vault secrets
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the Azure **command-line interface** (**CLI**) to create and
    manage Azure resources. You can read more about the Azure CLI here: https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to give our application access to Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Granting application access to Key Vault
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, let''s see how our `TestConfiguration` web API can get access
    to Key Vault using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Register the `TestConfiguration` application in **Azure Active Directory** (**AAD**)
    and create an identity. Sign in to the Azure portal using https://portal.azure.com.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to **Azure Active Directory** | **App Registrations**. Click on **New
    registration**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – AAD new application registration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.6_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – AAD new application registration
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the defaults and click on **Register**, as shown in the following screenshot,
    and note down the **Application (client) ID** value. This will be required later
    to access Key Vault:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – AAD registration completion'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.7_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – AAD registration completion
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Certificates & secrets** (**1**) | **New client secret** (**2**)
    and enter a **Description** (**3**) value, then click on **Add** (**4**), as shown
    in the following screenshot. Note down the **AppClientSecret** value showing under
    **New client secret**, which is what the application can use to prove its identity
    when requesting a token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – AAD new application secret creation for its identity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.8_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – AAD new application secret creation for its identity
  prefs: []
  type: TYPE_NORMAL
- en: 'Give the application access to Key Vault using an access policy. Search for
    the key vault you just created and select it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Key vault search'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.9_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Key vault search
  prefs: []
  type: TYPE_NORMAL
- en: 'In the key vault properties, select **Access policies** under **Settings**
    and click on **Add Access Policy**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Key Vault access policies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Key Vault access policies
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Select principal** field, search for your application and select the
    required permissions for your application to access Key Vault, then click on **Add**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Add access policy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Add access policy
  prefs: []
  type: TYPE_NORMAL
- en: After adding the policy, you must save it. This will complete the process of
    granting your application access to Key Vault.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now given our application access to Key Vault. In the next section,
    we will see how to access Key Vault from our application using the Azure Key Vault
    configuration provider.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the Azure Key Vault configuration provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will make configuration and code changes in our application
    to leverage the Azure Key Vault configuration provider and access secrets from
    Key Vault, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Accessing Key Vault during development'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.12_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – Accessing Key Vault during development
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the key vault name, the `AppClientId` value that you noted down from *Figure
    6.7*, and the `AppClientSecret` value that you noted down from AAD from *Figure
    6.8* to the `appsettings.json` file in your `TestConfiguration` web API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Key Vault section in appsettings.json'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.13_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Key Vault section in appsettings.json
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the following NuGet packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.Azure.KeyVault`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.AzureKeyVault`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Azure.Services.AppAuthentication`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update `Program.cs` to leverage the Azure Key Vault configuration provider
    to use your key vault. The following code will add Azure Key Vault as another
    configuration source and get all configurations using the Azure Key Vault configuration
    provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `WeatherForecastController.cs` to read the secret from Key Vault, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include all references as per the code sample shared here. You can run the
    application and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Results from Key Vault'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.14_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – Results from Key Vault
  prefs: []
  type: TYPE_NORMAL
- en: The application will be able to access the key vault using the Azure Key Vault
    configuration provider and fetch the secrets. It is very simple, as all the heavy
    lifting is done by .NET 6, and we just need to install the NuGet packages and
    add a few lines of code. However, you will now probably be thinking about how
    `AppClientId` and `AppClientSecret` have been added to the `appsettings.json`
    config file and about how this is not very secure. You are 100% correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: One option is to encrypt and store these values in `appsettings.json`; they
    can then be read and decrypted in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For safe storage of app secrets in development, please refer to https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The other option is to use managed identities to access Azure resources, which
    allows the application to authenticate with Azure Key Vault using AAD authentication
    without credentials (the application ID and password/client secret).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your application can be authenticated using its identity by any service that
    supports AAD authentication, such as Azure Key Vault, and this will help us in
    getting rid of credentials from code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Accessing Key Vault in production after deploying an application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Accessing Key Vault in production after deploying an application
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is the best practice we follow for applications that are deployed to production.
    Managing credentials in code is a common challenge and keeping credentials safe
    and secure is an important security requirement. Managed identities for Azure
    resources in AAD help in solving this challenge. Managed identities provide Azure
    services with an automatically managed identity in AAD. You can use this identity
    to authenticate any service that supports AAD authentication, including Key Vault,
    without any credentials in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about managed identities here: https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we saw how to create a key vault, how to add secrets to Key
    Vault, how to register our `TestConfiguration` web API in AAD, how to create a
    secret or identity, how to give the `TestConfiguration` web API access to Key
    Vault, and how to access Key Vault from our code using the Azure Key Vault configuration
    provider. You can also add Key Vault to your web application by using Visual Studio
    Connected Services, as described at https://docs.microsoft.com/en-us/azure/key-vault/general/vs-key-vault-add-connected-service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Azure Key Vault as a connected service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.16_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – Azure Key Vault as a connected service
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how we can leverage the file configuration
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: File configuration provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The file configuration provider helps us to load a configuration from the filesystem.
    The JSON configuration provider and XML configuration provider derive their inheritance
    from the file configuration provider class and are used to read key-value pair
    configurations from JSON files and XML files, respectively. Let's see how we can
    add them to configuration sources as part of `CreateHostBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: JSON configuration provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The JSON configuration provider can be configured using the following code
    in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the JSON configuration provider will load the `AdditionalConfig.json`
    file, and three parameters to the `AddJsonFile` method provide us with options
    to specify the filename, whether the file is optional, and whether the file must
    be reloaded when any changes are made to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `AdditionalConfig.json` sample file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we update `WeatherForecastController.cs` to read key-value pairs from
    the configurations loaded from the `AdditionalConfig.json` config file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: You can run the application and see the results. The application will be able
    to access the `AdditionalConfig.json` file and read the configuration. In the
    next section, we will look at the XML configuration provider.
  prefs: []
  type: TYPE_NORMAL
- en: XML configuration provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will add a new file to the project with the name `AdditionalXMLConfig.xml`
    and the required configurations. The XML configuration provider can then be configured
    using the following code in `Program.cs` to read from the file we added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the XML configuration provider will load the `AdditionalXMLConfig.xml`
    file and the three parameters provide us with options to specify the XML file,
    whether the file is optional or not, and whether the file must be reloaded when
    any changes are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AdditionalXMLConfig.xml` sample file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update `WeatherForecastController.cs` to read key-value pairs from
    the configuration loaded from `AdditionalXMLConfig.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: You can run the application and see the results. The application will be able
    to access `AdditionalXMLConfig.xml` and read the configuration. With the JSON
    config file and the JSON configuration provider available in .NET 6, you don't
    need the XML config file and the XML configuration provider. That said, what we
    just covered is for folks who like XML files and open and close tags, for example.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see why a custom configuration provider is required
    and how to build one.
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom configuration provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at built-in or pre-existing configuration
    providers in .NET 6\. There are scenarios where many systems maintain application
    configuration settings in a database. These could be managed by the admin from
    the portal or by the support engineer by running database scripts to create/update/delete
    application configuration settings as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET 6 doesn''t come with a built-in provider to read configurations from a
    database. Let''s see how to build a custom configuration provider to read from
    a database with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement configuration source**: To create an instance of the configuration
    provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement configuration provider**: To load the configuration from the appropriate
    source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement configuration extension**: To add the configuration source to the
    configuration builder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with the configuration source.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The responsibility of the configuration source is to create an instance of the
    configuration provider and return it to the source. It needs to inherit from the
    `IConfigurationSource` interface, which requires us to implement the `ConfigurationProvider
    Build(IConfigurationBuilder builder)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Build` method implementation, we need to create an instance of
    the custom configuration provider and return the same. There should also be the
    parameters needed to build the builder. In this case, as we are building a custom
    SQL configuration provider, the important parameters are the connection string
    and the SQL query. The following code snippet shows an example implementation
    of a `SqlConfigurationSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: It is very simple and easy to implement this, as you can see. You get the parameters
    required to build the provider and create a new instance of the provider, then
    return the parameters. Let's see how we can build a SQL configuration provider
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The responsibility of the configuration provider is to load the required configuration
    from the appropriate source and return the same. It needs to inherit from the
    `IConfigurationProvider` interface, which requires us to implement the `Load()`
    method. The configuration provider class can instead inherit from the `ConfigurationProvider`
    base class as it has already implemented all the methods in the `IConfigurationProvider`
    interface. This will help us save time as we don't need to implement unused methods
    and can, instead, implement just the `Load` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Load` method implementation, we need to have the logic to fetch
    the configuration data from the source. In this case, we will execute a query
    to fetch the data from the SQL store. The following code snippet shows an example
    implementation of a `SqlConfigurationProvider` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how to build a configuration extension in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with other providers, we can use an extension method to add the configuration
    source to the configuration builder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods are static methods in which you can add methods to existing
    classes without modifying or recompiling the original class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows an example implementation of a `SqlConfigurationExtensions`
    class in the configuration builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The extension method will reduce the code in our application startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add bootstrapping code to `Program.cs` just as we added it for other
    configuration providers, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows some sample configuration settings in a database.
    You can pass the appropriate connection string and SQL query in `config.AddSql()`
    and load the following configuration from the database. The SQL query may be a
    simple `select` statement to read all key-value pairs, as it is in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Database configuration settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – Database configuration settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `WeatherForecastController.cs` as follows to read key-value pairs from
    the configuration loaded from the SQL configuration provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: You can run the application and see the results. The application will be able
    to access the SQL configuration and read the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of just one custom configuration provider. You may be able
    to think of different scenarios where you would build other different custom configuration
    providers, such as when reading from CSV files or reading encrypted values from
    JSON or XML files and decrypting them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how configuration works in .NET 6, how the default configuration
    is provided to the application, how to add key-value pair configurations in a
    hierarchical order, how to read a configuration, how to leverage the Azure Key
    Vault configuration provider and the file configuration provider, and how to build
    a custom configuration provider to read from a SQL database. You now have the
    knowledge that's needed to implement different configurations in your project
    depending on the specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about logging and how it works in .NET 6.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading this chapter, you should be able to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What takes care of providing the default configuration for an application in
    .NET 6?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `CreateDefaultBuilder`
  prefs: []
  type: TYPE_NORMAL
- en: b. `ChainedConfigurationProvider`
  prefs: []
  type: TYPE_NORMAL
- en: c. `JsonConfigurationProvider`
  prefs: []
  type: TYPE_NORMAL
- en: d. All of the above
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: a**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is not correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The Azure Key Vault configuration provider reads configurations from Azure
    Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: b. The file configuration provider reads configurations from INI, JSON, and
    XML files.
  prefs: []
  type: TYPE_NORMAL
- en: c. The command-line configuration provider reads configurations from a database.
  prefs: []
  type: TYPE_NORMAL
- en: d. The memory configuration provider reads configurations from in-memory collections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
- en: Which interface is used to access a configuration at runtime and is injected
    via dependency injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `IConfig`
  prefs: []
  type: TYPE_NORMAL
- en: b. `IConfiguration`
  prefs: []
  type: TYPE_NORMAL
- en: c. `IConfigurationSource`
  prefs: []
  type: TYPE_NORMAL
- en: d. `IConfigurationProvider`
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: Which provider/source is recommended for storing secrets in production?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. JSON from `appsettings.json`
  prefs: []
  type: TYPE_NORMAL
- en: b. `FileConfiguration` from an XML file
  prefs: []
  type: TYPE_NORMAL
- en: c. `AzureKeyVaultProvider` from `AzureKeyVault`
  prefs: []
  type: TYPE_NORMAL
- en: d. The command-line configuration provider from the command line
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: https://docs.microsoft.com/en-us/aspnet/core/blazor/fundamentals/configuration?view=aspnetcore-6.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
