- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-Time Messaging with SignalR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve created various tests, added telemetry data, monitored the solution,
    and scaled our services, starting with this chapter, we’ll continue creating services
    and using different communication technologies.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use ASP.NET Core SignalR. SignalR is a technology that
    allows us to send real-time information from services to clients. The client initiates
    a connection to the service, which is then kept alive to send messages to the
    clients as information becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a SignalR service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send real-time information to clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a SignalR client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Azure SignalR Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, like the previous chapters, you’ll need an Azure subscription
    and Docker Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  prefs: []
  type: TYPE_NORMAL
- en: The `ch13` folder contains this chapter’s projects, as well as their results.
    To add the functionality from this chapter, you can start with the source code
    from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The projects we’ll be considering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost`: The .NET Aspire host project. The app model has been
    enhanced by an additional project running a SignalR hub and using Azure SignalR
    Service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Live`: This is a new project that hosts minimal APIs invoked by
    the `game-apis` service and the SignalR hub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs`: This project has been enhanced and can forward completed
    games to `live-service`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveTestClient`: This is a new console application that registers with the
    SignalR hub to receive completed games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a SignalR service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll create a new service that offers real-time information
    to return games that are played to every connected client. *Figure 13**.1* shows
    how the services of the solution collaborate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Codebreaker services](img/B21217_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Codebreaker services
  prefs: []
  type: TYPE_NORMAL
- en: The `game-apis` service has existed since [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031).
    The client of `game-apis` invokes the REST API to start games and set moves. What’s
    new is Codebreaker’s `live-service`. This service offers a simple REST API that’s
    invoked by the `game-apis` service every time a game completes. The main functionality
    of this service makes use of ASP.NET Core SignalR to offer real-time information
    to all connected clients. Clients need to subscribe before they can receive game
    completion messages.
  prefs: []
  type: TYPE_NORMAL
- en: What’s offered by SignalR? As connections can never be started from a server
    to a client, and this is also true of SignalR, a client needs to connect to the
    SignalR service and subscribe to receive real-time information. The connection
    stays open, which allows the service to send information to the clients.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core SignalR makes use of **WebSockets** if this technology is available
    – but the programming model with SignalR is a lot easier than using WebSockets
    directly. Contrary to HTTP, with WebSockets, the connection that’s initiated by
    the client stays open, which allows the service to send messages when these are
    available.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets isn’t always available and can be disabled by a proxy or a firewall
    and are not available everywhere. For example, **Azure Front Door** doesn’t support
    WebSockets at this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If WebSockets isn’t available, SignalR switches to other communication techniques,
    such as `text/event-stream` data and asks the server to keep the connection alive
    (via the `Connection: keep-alive` HTTP header). All modern browsers support SSE
    nowadays. With polling, the client repeatedly asks the server if new data is available,
    opening new connections again and again. Long polling is a technique that reduces
    the number of requests from the client by the server not returning information
    immediately, stating that nothing new is available. Instead, the server waits
    for the timeout to nearly end before returning. If some new information is available
    while waiting, this new information is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using SignalR, there’s no need to change programming constructs to decide between
    WebSockets, SSE, and long polling. This is done automatically by SignalR. However,
    in all these scenarios, compared to simple HTTP requests, the server has more
    overhead: connections with the clients need to stay alive and thus be kept in
    memory. To remove this overhead from our services, we’ll use Azure SignalR Service
    later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a SignalR service, we just need to create an empty ASP.NET Core Web
    project. Because this service also offers a REST API, let’s create a new Web API
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This creates a minimal API project, similar to what we have for the `game-apis`
    project. This project needs to be configured as a .NET Aspire project. With Visual
    Studio, use `Codebreaker.Live` project. Then, add a project reference to the `ServiceDefaults`
    project to the live project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Codebreaker.Live` service project needs to be configured with the .NET
    Aspire app model:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, the project is added to the app model and referenced from the
    `game-apis` service as it needs the link from `live-service` to invoke the REST
    API on game completions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add a SignalR hub that can be used by clients to connect.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SignalR hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SignalR is already part of ASP.NET Core, so we don’t need to add another NuGet
    package. Let’s add the SignalR hub class – that is, `LiveHub`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Endpoints/LiveHub.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A SignalR hub derives from the `Hub` base class (the `Microsoft.AspNetCore.SignalR`
    namespace). This class defines the `OnConnectedAsync` and `OnDisconnectedAsync`
    methods, both of which can be overridden to react on client connects and disconnects.
    Here, we define the `RegisterGameCompletions` method with `gameType` as its parameter.
    This method is invoked by SignalR clients.
  prefs: []
  type: TYPE_NORMAL
- en: Using SignalR, a hub can send real-time information to all clients, one client,
    or a group of clients. With this implementation, we allow clients to register
    with a group. Game types are used to differentiate different groups. The `Hub`
    class defines a `Groups` property to subscribe and unsubscribe from a group. The
    `AddToGroupAsync` method adds the client and `RemoveFromGroupAsync` removes the
    client from the group. A connected client can be identified using `ConnectionId`,
    which can be accessed using the `Context` property.
  prefs: []
  type: TYPE_NORMAL
- en: To send information to connected clients, the `Hub` class offers the `Clients`
    property, which allows you to send to all clients (`Clients.All.SendAsync`), or
    a group (`Clients.Group("group-name").SendAsync`). However, in this case, we need
    to send the information outside of the `LiveHub` class (after receiving a REST
    invocation) from the `game-apis` service. We’ll do this by implementing the `LiveGamesEndpoints`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Returning live information to the clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LiveGamesEndpoints` class uses minimal APIs to implement a REST endpoint.
    What’s special is that it can send information to connected clients:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Endpoints/LiveGamesEndpoints.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `GameSummary` class that’s received by the `MapPost` method is implemented
    in the `CNinnovation.Codebreaker.BackendModels` NuGet package. This class contains
    summary information of a completed game. Along with this HTTP POST body parameter,
    the `MapPost` method receives an `IHubContext<LiveHub>` instance from the DI container.
    This interface is registered when the DI container is configured for SignalR to
    retrieve a context to the registered hub to send information to clients. Using
    the `Clients.Group` method, when passing the name of the group, an `IClientProxy`
    object is returned. This proxy is then used to send the `GameCompleted` method
    with the game summary.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all we need to do is register SignalR and the hub with the DI container
    and the middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Registering SignalR services and the hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use SignalR, and to make the hub available as an endpoint, we must implement
    the `ApplicationServices` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `AddApplicationServices` method extends `IHostApplicationBuilder` to register
    the service classes that are needed for SignalR by invoking the `AddSignalR` method.
    The `MapApplicationEndpoints` method registers the SignalR hub and minimal API
    endpoint. The SignalR hub is registered with the endpoints by passing the `Hub`
    class with the generic parameter of the `MapHub` method. `/livesubscribe` is the
    link that’s used by clients to connect to this service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods of the `ApplicationServices` class are invoked from the top-level
    statements of the SignalR project:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The DI container is configured by invoking the `AddServiceDefaults` method,
    which is defined by the common `ServiceDefaults` project. This adds the DI container
    registration that’s needed by all projects of the solution. The `AddApplicationServices`
    method adds the services that are needed from `live-service`, such as SignalR.
    Using `builder.Build` concludes the information that’s needed via the DI container.
    The app instance starts configuring the middleware, which is where `MapDefaultEndpoints`
    and `MapApplicationEndpoints` are invoked. `MapDefaultEndpoints` registers links
    such as common health checks (covered in [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294)).
    `MapApplicationEndpoints` registers the endpoints offered by this service project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that `live-service` is ready to go, let’s call the API from the `game-apis`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding requests from the game-apis service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall the sequence diagram from earlier. We’ve updated this diagram to show
    how `game-apis` and `live-service` communicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – REST calls to live-service](img/B21217_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – REST calls to live-service
  prefs: []
  type: TYPE_NORMAL
- en: 'After a game is completed, the `game-apis` service invokes `live-service` with
    game completion information. To invoke `live-service`, create the `LiveReportClient`
    class, which injects `HttpClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/LiveReportClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `ReportGameEndedAsync` method uses the `HttpClient` class to make an HTTP
    POST request to `/live/game` and send `GameSummary` information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s configure the `HttpClient` class by updating the `ApplicationServices`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using .NET Aspire orchestration, the URL of the live client is retrieved by
    using service discovery with the `https+http://live` expression. This expression
    prefers the `https` schema, but if it isn’t available, it uses the `http` schema.
    The name is resolved with service discovery via the app model, as explained in
    [*Chapter 1*](B21217_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: With that, `game-apis` has been configured to send game summary information.
    Now, all we need to do is create a client that receives real-time information
    from the SignalR service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SignalR client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a simple client receiving real-time information, all we need is a console
    application that connects to `live-service`. By doing this, it’s simple to implement
    this functionality with any other client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a console project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Microsoft.AspNetCore.SignalR.Client` NuGet package needs to be added to
    call a SignalR service. We must also add `Microsoft.Extensions.Hosting` for the
    DI container and `CNinnovation.Codebreaker.BackendModels` with the `GameSummary`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `LiveClient` class, which will communicate with the SignalR service:'
  prefs: []
  type: TYPE_NORMAL
- en: LiveTestClient/LiveClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `LiveClient` class specifies a constructor with `IOptions<LiveClientOptions>`.
    This will be configured with the DI container so that it can pass the URL string
    from `live-service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `appsettings.json` to configure the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: LiveTestClient/appsettings.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For local testing, the port number needs to match the port number that’s specified
    with `launchSettings.json`. Don’t forget to configure so that `appsettings.json`
    is copied to the output directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection to the service is initiated by the `StartMonitorAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: LiveTestClient/LiveClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To connect to the SignalR hub, `HubConnectionBuilder` is used to set up a connection.
    With this builder, the connection can be configured – for example, logging, server
    timeout, and reconnect behaviors can be set up. The connection is then initiated
    by invoking the `StartAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `On` method of `HubConnection` configures the receiving side: when a `GameCompleted`
    message is received, the `GameSummary` parameter specifies the data that’s been
    received and writes a message about the game to the console. The name `GameCompleted`
    needs to match the name that has been passed with the `SendAsync` method of the
    service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To subscribe to the messages from the service, implement the `SubscribeToGame`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: LiveTestClient/LiveClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, the `InvokeAsync` method of `HubConnection` is used.
    `SubscribeToGameCompletions` matches the name of the hub method, which uses the
    `game-type` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level statements of the client application make use of the `LiveClient`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: LiveTestClient/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After configuring the `LiveClient` class in the DI container, the `StartMonitorAsync`
    and `SubscribeToGame` methods are invoked.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, you can start the AppHost so that it runs all the services
    and multiple instances of the client application. Use `bot-service` to play multiple
    games. You’ll see success messages from the bot, as shown in *Figure 13**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Live client receiving game summaries](img/B21217_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Live client receiving game summaries
  prefs: []
  type: TYPE_NORMAL
- en: Using the bot, multiple games have been started with a think time of 0 and 1
    seconds between game moves. These results show game wins that occur between 0.27
    and 4.79 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the serialization protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, SignalR serializes messages with JSON. Using the `Microsoft.AspNetCore.SignalR.Protocols.MessagePack`
    NuGet package, a binary serialization format can be used instead. This is an optimization
    that reduces the data that’s sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support this, all we need to do is update the DI configuration in the service,
    after adding the NuGet package:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `AddMessagePackProtocol` method adds `MessagePack` as another option for
    serialization. JSON is still available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the client, the same NuGet package is required, but this time with
    the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: LiveTestClient/LiveClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Like the server, the same NuGet package for the protocol is needed for the client,
    as well as the `AddMessagePackProtocol` API. With the client, logging is now turned
    on as well. Logging providers for SignalR can be configured using the `ConfigureLogging`
    method. Here, the console provider is added, and the minimum logging level is
    set to `LogLevel.Debug`. With this, we can see all communication between the client
    and the server, including the message protocols that are used and the ping messages
    that are sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using MessagePack, you need to be aware of an important restriction: `DateTime.Kind`
    is not serialized. Thus, this type should be converted into UTC before being sent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, you can start the solution again, start the bot to play
    some games, and start the SignalR client. When you look at the logging information,
    you’ll see WebSockets and MessagePack in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging from the client application
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve switched the serialization format, let’s reduce the load from
    the service when a larger number of clients is connected by using Azure SignalR
    Service.
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure SignalR Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s some overhead associated with SignalR since the server has open connections
    with all SignalR clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove this overhead from our services, we can use **Azure SignalR Service**.
    This service acts as an intermediary between clients and the SignalR service,
    as depicted in *Figure 11**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF3.4 – Using Azure SignalR Service](img/B21217_13_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Using Azure SignalR Service
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows multiple monitor clients that each have a connection
    open to Azure SignalR Service. `live-service` just needs to deal with a single
    connection. Azure SignalR subscribes to the events and forwards them to a single
    client, a group of clients, or all clients, as specified by `live-service`.
  prefs: []
  type: TYPE_NORMAL
- en: The load for every client connection is handled by Azure SignalR Service, while
    this service just acts as a single client to the SignalR service.
  prefs: []
  type: TYPE_NORMAL
- en: A free version of this service without SLA that’s limited to 20 connections
    and 20,000 messages per day can be used for development purposes. Standard and
    premium SKUs can scale up to 1,000 connections per unit, 100 units, and unlimited
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate Azure SignalR Service within the app model, we need to update `app-model`
    within the AppHost project:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With .NET Aspire provisioning, Azure SignalR Service is created when the application
    is started. When using the `WithReference` method, the URI is forwarded to the
    `Codebreaker.Live` service. Here, the `Microsoft.Azure.SignalR` NuGet package
    is required to connect this service:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using `AddNamedAzureSignalR`, the connection string is retrieved via service
    discovery, and the SignalR hub is connected to this Azure service.
  prefs: []
  type: TYPE_NORMAL
- en: Now, start the application again and check the Azure portal to see that the
    service has been created. Use the Aspire dashboard to see the environment variable
    that’s been assigned to the `Codebreaker.Live` service, and check the logs to
    see the connections that have been made to Azure SignalR Service. Run the bot
    so that it plays several games and then start several SignalR client (`LiveTestClient`)
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open the Azure portal, open the resource group of the developer environment
    (`rg-aspire-<yourhost>-codebreaker.apphost`) and select Azure SignalR Service.
    In the **Monitoring** category in the left bar, select **Live trace settings**.
    Click the **Enable Live Trace** checkbox and choose to collect information for
    **ConnectivityLogs**, **MessagingLogs**, and **HttpRequestLogs**. Then, click
    the **Open Live Trace Tool** button. You’ll receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Azure SignalR Service live trace. This screenshot only intends
    to show the output result page; text readability is not essential](img/B21217_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Azure SignalR Service live trace. This screenshot only intends
    to show the output result page; text readability is not essential
  prefs: []
  type: TYPE_NORMAL
- en: With the Azure SignalR Service live trace, you can see all the messages that
    have been sent from the Codebreaker live service, as well as the messages that
    have been sent to the subscribing clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see metrics data, go back (or open a new browser window) to the **Overview**
    page of Azure SignalR Service. There, you can see the number of connections that
    have been opened, as shown in *Figure 13**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Azure SignalR Service connection metrics](img/B21217_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Azure SignalR Service connection metrics
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13**.7* shows the number of messages that have been sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Azure SignalR Sevice message metrics](img/B21217_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Azure SignalR Sevice message metrics
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything is up and running, you’ve earned a well-deserved break so
    that you can play some games (which you can monitor as well).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to offer real-time data using SignalR. You
    created a live service containing a SignalR hub that offers real-time information
    about completed games. Clients can register to a subset – a group – of the information
    offered. You also created a simple console application that acts as a client.
    The same functionality can be implemented in other clients. You can check this
    out in the Blazor client application provided in this book’s GitHub repository,
    which contains the SignalR client functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned how to use Azure SignalR Service, which reduces the load on
    the service hosting the SignalR hub as the clients directly interact with Azure
    SignalR Service while this service acts as one client to SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: With the implementation of this chapter, we created a REST API that’s invoked
    by the `game-apis` service to send completed games. REST is great for easy communication
    with all clients, but it doesn’t offer the best performance. The only client for
    the `Codebreaker.Live` service is the `game-apis` service.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding service-to-service communication, instead of using REST APIs, less
    overhead is used when binary serialization is used alongside protocols such as
    gRPC. This will be covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were discussed in this chapter, please
    refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ASP.NET Core* *SignalR*: [https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction](https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Message Pack* *protocol*: [https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol](https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Azure SignalR* *Service*: [https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview](https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.*NET Aspire support for Azure SignalR* *Service*: [https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario](https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
