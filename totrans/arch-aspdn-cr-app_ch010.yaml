- en: 9 Options, Settings, and Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 选项、设置和配置
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“EARLY ACCESS SUBSCRIPTION”下找到“architecting-aspnet-core-apps-3e”频道）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file44.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file44.png)'
- en: This chapter covers the .NET Options pattern, a building block of any application.
    .NET Core introduced new predefined mechanisms to enhance the usage of application
    settings available to ASP.NET Core applications. These allow us to divide our
    configuration into multiple smaller objects, configure them during various stages
    of the startup flow, validate them, and even watch for runtime changes with minimal
    effort.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 .NET 选项模式，这是任何应用程序的构建块。.NET Core 引入了新的预定义机制来增强 ASP.NET Core 应用程序可用的应用程序设置的用法。这些机制允许我们将配置分成多个更小的对象，在启动流程的各个阶段对其进行配置，验证它们，甚至以最小的努力监视运行时更改。
- en: The new options system repurposed the `ConfigurationManager` class as an internal
    piece. We no longer can use it as the old .NET Framework-era static methods are
    gone. The new patterns and mechanisms help avoid useless coupling, add flexibility
    to our designs, and are DI-native. The system is also simpler to extend.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新的选项系统将 `ConfigurationManager` 类重新定位为内部组件。我们不能再像旧 .NET Framework 时代的静态方法那样使用它。新的模式和机制有助于避免无用的耦合，增加我们的设计灵活性，并且是
    DI 原生的。该系统也更容易扩展。
- en: 'The Options pattern goal is to use settings at runtime, allowing changes to
    the application to happen without changing the code. The settings could be as
    simple as a `string`, a `bool`, a database connection string, or a complex object
    that holds an entire subsystem’s configuration.This chapter delves into various
    tools and methodologies we can use for managing, injecting, and loading configurations
    and options into our ASP.NET Core applications. Our journey spans a broad spectrum
    of scenarios, covering everything from commonly encountered to more complex use
    cases.At the end of the chapter, you will know how to leverage the .NET options
    and settings infrastructure.In this chapter, we cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 选项模式的目标是在运行时使用设置，允许在不更改代码的情况下对应用程序进行更改。设置可能只是一个 `string`、一个 `bool`、一个数据库连接字符串，或者是一个包含整个子系统配置的复杂对象。本章深入探讨了我们可以用于管理、注入和加载配置和选项到我们的
    ASP.NET Core 应用程序的各种工具和方法。我们的旅程涵盖了从常见场景到更复杂用例的广泛范围。在本章结束时，您将了解如何利用 .NET 选项和设置基础设施。在本章中，我们涵盖了以下主题：
- en: Loading the configuration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载配置
- en: Learning the building blocks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习构建块
- en: Exploring common usage scenarios
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索常见使用场景
- en: Learning options configuration
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习选项配置
- en: Validating our options objects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证我们的选项对象
- en: Validating options using FluentValidation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 FluentValidation 验证选项
- en: Injecting options objects directly—a workaround
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接注入选项对象——一种解决方案
- en: Centralizing the configuration for easier management
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中配置以简化管理
- en: Using the configuration-binding source generator
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置绑定源生成器
- en: Using the options validation source generator
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项验证源生成器
- en: Using the options validation source generator
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项验证源生成器
- en: Let’s get started!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Loading the configuration
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载配置
- en: 'ASP.NET Core allows us to load settings from multiple sources seamlessly. We
    can customize these sources from the `WebApplicationBuilder`, or use the defaults
    set by calling the `WebApplication.CreateBuilder(args)` method.The default sources,
    in order, are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 允许我们无缝地从多个来源加载设置。我们可以从 `WebApplicationBuilder` 中自定义这些来源，或者通过调用
    `WebApplication.CreateBuilder(args)` 方法使用默认设置。默认来源按顺序如下：
- en: '`appsettings.json`'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`appsettings.json`'
- en: '`appsettings.{Environment}.json`'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`appsettings.{Environment}.json`'
- en: User secrets; these are only loaded when the environment is `Development`
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户密钥；这些仅在环境为 `Development` 时加载
- en: Environment variables
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Command-line arguments
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: The order is essential, as the last to be loaded overrides previous values.
    For example, you can set a value in `appsettings.json` and override it in `appsettings.Staging.json`
    by redefining the value in that file, user secrets, an environment variable or
    by passing it as a command-line argument when you run your application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序至关重要，因为最后加载的值会覆盖之前的值。例如，你可以在 `appsettings.json` 中设置一个值，然后通过在该文件中重新定义该值、用户密钥、环境变量或在你运行应用程序时将其作为命令行参数传递来在
    `appsettings.Staging.json` 中覆盖它。
- en: You can name your environments as you want, but by default, ASP.NET Core has
    built-in helper methods for `Development`, `Staging`, and `Production`.
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以按自己的意愿命名环境，但默认情况下，ASP.NET Core 为 `Development`、`Staging` 和 `Production` 提供了内置的辅助方法。
- en: On top of the default providers, we can register other configuration sources
    out of the box, like `AddIniFile`, `AddInMemoryCollection`, and `AddXmlFile`,
    for example. We can also load NuGet packages to install custom providers, like
    Azure KeyVault and Azure App Configuration, to centralize secrets and configuration
    management into the Azure cloud. The most interesting part of those configuration
    providers is that no matter the sources, it does not affect the consumption of
    the settings, only the composition root. This means we can start loading settings
    one way, then change our mind later or have different strategies for dev and prod,
    and none of that affects the codebase but the composition root.We explore a few
    building blocks next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认提供者之上，我们可以注册其他配置源，例如 `AddIniFile`、`AddInMemoryCollection` 和 `AddXmlFile`。我们还可以加载
    NuGet 包来安装自定义提供者，例如 Azure KeyVault 和 Azure App Configuration，以将机密和配置管理集中到 Azure
    云中。这些配置提供者的最有趣之处在于，无论来源如何，都不会影响设置的消费，只会影响组合根。这意味着我们可以开始以某种方式加载设置，然后稍后改变主意或为开发和生产使用不同的策略，而这些都不会影响代码库，只会影响组合根。我们将在下一部分探索一些构建块。
- en: Learning the building blocks
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习构建块
- en: 'There are four main interfaces to use settings: `IOptionsMonitor<TOptions>`,
    `IOptionsFactory<TOptions>`, `IOptionsSnapshot<TOptions>`, and `IOptions<TOptions>`.
    We must inject that dependency into a class to use the available settings. `TOptions`
    is the type that represents the settings that we want to access.The framework
    returns an empty instance of your options class if you don’t configure it. We
    learn how to configure options properly in the next subsection; meanwhile, remember
    that using property initializers inside your options class can also be a great
    way to ensure certain defaults are used. You can also use constants to centralize
    those defaults somewhere in your codebase (making them easier to maintain). Nevertheless,
    proper configuration and validation are always preferred, but both combined can
    add a safety net. Don’t use initializers or constants for default values that
    change based on the environment (dev, staging, or production) or for secrets such
    as connection strings and passwords.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设置有四个主要接口：`IOptionsMonitor<TOptions>`、`IOptionsFactory<TOptions>`、`IOptionsSnapshot<TOptions>`
    和 `IOptions<TOptions>`。我们必须将这个依赖注入到类中才能使用可用的设置。`TOptions` 是代表我们想要访问的设置的类型。如果你没有配置它，框架会返回你的选项类的空实例。我们将在下一小节中学习如何正确配置选项；同时，记住在选项类内部使用属性初始化器也可以确保某些默认值被使用。你还可以使用常量将那些默认值集中存储在代码库的某个位置（使它们更容易维护）。然而，适当的配置和验证始终是首选的，但两者结合可以增加一层安全网。不要使用初始化器或常量来设置基于环境（开发、预发布或生产）变化的默认值，或者用于连接字符串和密码等机密信息。
- en: You should always keep secrets out of your Git history, whether it's out of
    the C# code or out of setting files. Use ASP.NET Core secrets locally and a secret
    store like Azure KeyVault for Staging and Production environments.
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你应该始终将机密信息从 Git 历史记录中移除，无论是从 C# 代码中还是从设置文件中。在本地使用 ASP.NET Core 机密信息，并在预发布和生产环境中使用
    Azure KeyVault 等机密存储库。
- en: If we create the following class, since the default value of an `int` is `0`,
    the default number of items to display per page would be 0, leading to an empty
    list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建以下类，由于 `int` 的默认值为 `0`，每页显示的默认项目数将是 0，从而导致空列表。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, we can configure this using a property initializer, as next:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用属性初始化器来配置它，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default number of items to display per page is now 20.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每页显示的默认项目数现在是 20。
- en: In the source code for this chapter, I’ve included a few tests in the `CommonScenarios.Tests`
    project that assert the lifetime of the different options interfaces. I haven’t
    included this code here for brevity, but it describes the behavior of the different
    options via unit tests. See [https://adpg.link/AXa5](https://adpg.link/AXa5) for
    more information.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章的源代码中，我在 `CommonScenarios.Tests` 项目中包含了一些测试，以断言不同选项接口的生命周期。为了简洁，我没有在这里包含此代码，但它通过单元测试描述了不同选项的行为。更多信息请见
    [https://adpg.link/AXa5](https://adpg.link/AXa5)。
- en: 'The options served by each interface have different DI lifetimes and other
    features. The following table exposes some of those features:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接口提供的服务具有不同的DI生命周期和其他功能。以下表格揭示了其中的一些功能：
- en: '| **Interface** | **Lifetime** | **Support named options** | **Support change
    notification** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **接口** | **生命周期** | **支持命名选项** | **支持变更通知** |'
- en: '| `IOptionsMonitor<TOptions>` | Singleton | Yes | Yes |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `IOptionsMonitor<TOptions>` | 单例 | 是 | 是 |'
- en: '| `IOptionsFactory<TOptions>` | Transient | Yes | No |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `IOptionsFactory<TOptions>` | 原型 | 是 | 否 |'
- en: '| `IOptionsSnapshot<TOptions>` | Scoped | Yes | No |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `IOptionsSnapshot<TOptions>` | 作用域 | 是 | 否 |'
- en: '| `IOptions<TOptions>` | Singleton | No | No |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `IOptions<TOptions>` | 单例 | 否 | 否 |'
- en: 'Table 9.1: The different options interfaces, their DI lifetime, and support
    for other features.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1：不同的选项接口、它们的DI生命周期和其他功能支持。
- en: Next, we explore those interfaces more in-depth.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更深入地探讨这些接口。
- en: IOptionsMonitor<TOptions>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IOptionsMonitor<TOptions>
- en: 'This interface is the most versatile of them all:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口是其中最灵活的一个：
- en: It supports receiving notifications about reloading the configuration (like
    when the setting file changed).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持接收有关重新加载配置的通知（例如设置文件更改时）。
- en: It supports caching.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持缓存。
- en: It supports named configuration (identifying multiple different `TOptions` with
    a name).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持命名配置（通过名称识别多个不同的 `TOptions`）。
- en: The injected `IOptionsMonitor<TOptions>` instance is always the same (**singleton
    lifetime**).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入的 `IOptionsMonitor<TOptions>` 实例始终相同（**单例生命周期**）。
- en: It supports unnamed default settings through its `Value` property.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过其 `Value` 属性支持未命名的默认设置。
- en: If we only configure named options or no instance at all, the consumer will
    receive an empty `TOptions` instance (`new TOptions()`).
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们只配置了命名选项或根本未配置实例，消费者将接收到一个空的 `TOptions` 实例 (`new TOptions()`).
- en: IOptionsFactory<TOptions>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IOptionsFactory<TOptions>
- en: This interface is a factory, as we saw in *Chapter 7*, *Strategy, Abstract Factory,
    and Singleton*, and in *Chapter 8*, *Dependency Injection*, we use factories to
    create instances; this interface is no different.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口是一个工厂，正如我们在*第7章*，*策略、抽象工厂和单例*，以及*第8章*，*依赖注入*中看到的，我们使用工厂来创建实例；此接口并无不同。
- en: Unless necessary, I suggest sticking with `IOptionsMonitor<TOptions>` or `IOptionsSnapshot<TOptions>`
    instead.
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非必要，我建议坚持使用 `IOptionsMonitor<TOptions>` 或 `IOptionsSnapshot<TOptions>`。
- en: 'How the factory works is simple: the container creates a new factory every
    time you ask for one (transient lifetime), and the factory creates a new options
    instance every time you call its `Create(name)` method (**transient lifetime**).To
    get the default instance (non-named options), you can use the `Options.DefaultName`
    field or pass an empty string; this is usually handled for you by the framework.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂的工作原理很简单：每次你请求一个新工厂时（原型生命周期），容器都会创建一个新的工厂；每次你调用其 `Create(name)` 方法时，工厂都会创建一个新的选项实例（原型生命周期）。要获取默认实例（非命名选项），你可以使用
    `Options.DefaultName` 字段或传递一个空字符串；这通常由框架为你处理。
- en: If we only configure named options or no instance at all, the consumer will
    receive an empty `TOptions` instance (`new TOptions()`) after calling `factory.Create(Options.DefaultName)`.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们只配置了命名选项或根本未配置实例，在调用 `factory.Create(Options.DefaultName)` 后，消费者将接收到一个空的
    `TOptions` 实例 (`new TOptions()`)。
- en: IOptionsSnapshot<TOptions>
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IOptionsSnapshot<TOptions>
- en: This interface is useful when you need a snapshot of the settings for the duration
    of an HTTP request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要获取 HTTP 请求持续期间的设置快照时，此接口非常有用。
- en: The container creates only one instance per request (**scoped lifetime**).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器为每个请求创建一个实例（**作用域生命周期**）。
- en: It supports named configuration.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持命名配置。
- en: It supports unnamed default settings through its `CurrentValue` property.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过其 `CurrentValue` 属性支持未命名的默认设置。
- en: If we only configure named options or no instance at all, the consumer will
    receive an empty `TOptions` instance (`new TOptions()`).
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们只配置了命名选项或根本未配置实例，在调用 `factory.Create(Options.DefaultName)` 后，消费者将接收到一个空的
    `TOptions` 实例 (`new TOptions()`).
- en: IOptions<TOptions>
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IOptions<TOptions>
- en: This interface is the first that was added to ASP.NET Core.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口是第一个添加到 ASP.NET Core 的。
- en: It does not support advanced scenarios such as what snapshots and monitors do.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持像快照和监控这样的高级场景。
- en: Whenever you request an `IOptions<TOptions>` instance, you get the same instance
    (**singleton lifetime**).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次您请求一个`IOptions<TOptions>`实例时，您都会得到相同的实例（**单例生命周期**）。
- en: '`IOptions<TOptions>` does not support named options, so you can only access
    the default instance.'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`IOptions<TOptions>`不支持命名选项，因此您只能访问默认实例。'
- en: Now that we looked at the building blocks, we dig into some code to explore
    leveraging those interfaces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了构建块，我们将深入研究一些代码来探索利用这些接口。
- en: Project – CommonScenarios
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – CommonScenarios
- en: This first example covers multiple basic use cases, such as injecting options,
    using named options, and storing options values in settings.Let’s start with the
    shared building block.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个示例涵盖了多个基本用例，例如注入选项、使用命名选项以及将选项值存储在设置中。让我们从共享构建块开始。
- en: Manual configuration
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动配置
- en: 'In the composition root, we can manually configure options, which is very useful
    for configuring ASP.NET Core MVC, the JSON serializer, other pieces of the framework,
    or our own handcrafted options.Here’s the first options class we use in the code,
    which contains only a `Name` property:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合根中，我们可以手动配置选项，这对于配置ASP.NET Core MVC、JSON序列化器、框架的其他部分或我们自己的定制选项非常有用。以下是我们在代码中使用的第一个选项类，它只包含一个`Name`属性：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the composition root, we can use the `Configure` extension method that extends
    the `IServiceCollection` interface to achieve this. Here’s how we can set the
    default options of the `MyOptions` class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合根中，我们可以使用扩展`IServiceCollection`接口的`Configure`扩展方法来实现这一点。以下是如何设置`MyOptions`类的默认选项：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With that code, if we inject that options instance into a class, the value of
    the `Name` property will be `Default Options`.We explore loading settings from
    a non-hardcoded configuration source next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用那段代码，如果我们将该选项实例注入到一个类中，`Name`属性的值将是`Default Options`。接下来，我们将探讨从非硬编码配置源加载设置。
- en: Using the settings file
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用设置文件
- en: 'Loading configurations from a file is often more convenient than hardcoding
    the values in C#. Moreover, the mechanism allows overriding the configurations
    using different sources, bringing even more advantages.To load `MyOptions` from
    the `appsettings.json` file, we must first get the configuration section, then
    configure the options, like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中加载配置通常比在C#中硬编码值更方便。此外，该机制允许使用不同的来源覆盖配置，从而带来更多的优势。要从`appsettings.json`文件中加载`MyOptions`，我们首先必须获取配置部分，然后配置选项，如下所示：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code loads the following data from the appsettings.json file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码从appsettings.json文件中加载以下数据：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The **defaultOptions** section maps to objects with the same key in the JSON
    file (highlighted code). The `name` property of the `defaultOptions` section translates
    to the `Name` property of the `MyOptions` class.That code does the same as the
    preceding hardcoded version. However, manually loading the section this way allows
    us to load a different section for different named options.Alternatively, we can
    also “bind” a configuration section to an existing object using the `Bind` method
    like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**defaultOptions**部分映射到JSON文件中具有相同键的对象（高亮代码）。`defaultOptions`部分的`name`属性对应于`MyOptions`类的`Name`属性。那段代码与前面的硬编码版本做的是同样的事情。然而，以这种方式手动加载部分允许我们为不同的命名选项加载不同的部分。或者，我们也可以使用`Bind`方法将配置部分“绑定”到现有对象，如下所示：'
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That code loads the settings and assigns them to the object’s properties, matching
    the settings key to the properties name. However, this does not add the object
    to the IoC container.To overcome this, if we do not want to register the dependency
    manually and don’t need the object, we can use the `Bind` or `BindConfiguration`
    methods from the `OptionsBuilder<TOptions>`. We create that object with the `AddOptions`
    method, like for `Bind`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码加载了设置并将它们分配给对象的属性，将设置键与属性名称匹配。然而，这并没有将对象添加到IoC容器中。为了克服这个问题，如果我们不想手动注册依赖项并且不需要该对象，我们可以使用`OptionsBuilder<TOptions>`中的`Bind`或`BindConfiguration`方法。我们使用`AddOptions`方法创建该对象，就像`Bind`一样：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code loads the `options3` configuration section using the `GetSection`
    method (highlighted), then the `OptionsBuilder<TOptions>` binds that value to
    the name `Options3` through the `Bind` method. This registers a named instance
    of `MyOptions` with the container. We dig into named options later.Then again,
    we can skip the use of the `GetSection` method by using the `BindConfiguration`
    method instead, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用`GetSection`方法（已突出显示）加载`options3`配置部分，然后通过`Bind`方法将此值绑定到名称`Options3`。这将在容器中注册`MyOptions`的命名实例。我们稍后会深入探讨命名选项。再次，我们可以通过使用`BindConfiguration`方法来跳过`GetSection`方法的使用，如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code loads the settings from the `options4` section, then registers
    that new setting with the IoC container.These are just a subset of the different
    ways we can leverage the ASP.NET Core Options pattern and configuration system.
    Now that we know how to configure the options, it is time to use them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从`options4`部分加载设置，然后注册这个新设置到IoC容器中。这只是我们可以利用ASP.NET Core选项模式和配置系统的不同方式的一个子集。现在我们知道了如何配置选项，是时候使用它们了。
- en: Injecting options
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入选项
- en: 'Let’s start by learning how to leverage the `IOptions<TOptions>` interface,
    the first and simplest interface that came out of .NET Core.To try this out, let’s
    create an endpoint and inject the `IOptions<MyOptions>` interface as a parameter:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习如何利用`IOptions<TOptions>`接口开始，这是从.NET Core中出现的第一个也是最简单的接口。为了尝试这个，让我们创建一个端点并将`IOptions<MyOptions>`接口作为参数注入：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, the `Value` property returns the configured value, which
    is the following, serialized as JSON:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Value`属性返回配置的值，如下所示，序列化为JSON：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And voilà! We can also use constructor injection or any other method we know
    to use the value of our options object.Next, we explore configuring multiple instances
    of the same options class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们还可以使用构造函数注入或我们知道的任何其他方法来使用选项对象的值。接下来，我们将探讨配置相同选项类的多个实例。
- en: Named options
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名选项
- en: Now, let’s explore named options by configuring two more instances of the `MyOptions`
    class. The concept is to associate a configuration of the options with a name.
    Once that is done, we can request the configuration we need.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过配置`MyOptions`类的两个更多实例来探索命名选项。概念是将选项的配置与一个名称关联起来。一旦完成，我们就可以请求所需的配置。
- en: Unfortunately, the ways we explore named options and most online examples break
    the Inversion of Control principle.
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不幸的是，我们探索命名选项和大多数在线示例都违反了控制反转原则。
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why? By injecting an interface that is directly tied to a lifetime, the consuming
    class controls that part of the dependency.
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么？通过注入一个直接与生存期相关的接口，消费者类控制了依赖关系的那一部分。
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rest assured, we are revisiting this at the end of the chapter.
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请放心，我们将在本章末尾重新探讨这个问题。
- en: 'First, in the `appsettings.json` file, let’s add the highlighted sections:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`appsettings.json`文件中，让我们添加突出显示的部分：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have those configs, let’s configure them in the `Program.cs` file
    by adding the following lines:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些配置，让我们在`Program.cs`文件中通过添加以下行来配置它们：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, the highlighted strings represent the names of the options
    we are configuring. We associate each configuration section with a named instance.Now
    to consume those named options, we have multiple choices. We can inject an `IOptionsFactory<MyOptions>`,
    `IOptionsMonitor<MyOptions>`, or an `IOptionsSnapshot<MyOptions>` interface. The
    final choice depends on the lifetime the consumer of the options needs. However,
    in our case, we use all of them to ensure we explore them all.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，突出显示的字符串代表我们正在配置的选项名称。我们将每个配置部分与一个命名实例关联。现在，为了消费这些命名选项，我们有多种选择。我们可以注入`IOptionsFactory<MyOptions>`、`IOptionsMonitor<MyOptions>`或`IOptionsSnapshot<MyOptions>`接口。最终的选择取决于选项消费者所需的生存期。然而，在我们的情况下，我们使用所有这些以确保我们探索了它们。
- en: IOptionsFactory<MyOptions>
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IOptionsFactory<MyOptions>
- en: 'Let’s start with creating an endpoint where we inject a factory:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个注入工厂的端点开始：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The factory interface forces us to pass in a name that is convenient for us.
    When we execute the program, the endpoint serves us the options based on the specified
    name. For example, when we send the following request:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂接口迫使我们传入一个对我们方便的名称。当我们执行程序时，端点根据指定的名称提供选项。例如，当我们发送以下请求时：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The endpoint returns the following JSON:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 端点返回以下JSON：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we pass Options2 instead, we get the following JSON:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递Options2，我们将得到以下JSON：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As simple as that, we can now choose between three different options. Of course,
    once again, we can leverage any other technique we know, like constructor injections.Let’s
    explore the next interface.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单，我们现在可以在三种不同的选项之间进行选择。当然，再次利用我们知道的任何其他技术，比如构造函数注入。让我们探索下一个接口。
- en: IOptionsMonitor<MyOptions>
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IOptionsMonitor<MyOptions>
- en: 'We use the `IOptionsMonitor` interface similarly to the `IOptionsFactory` interface
    when we need named options. So, let’s start by creating a similar endpoint:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要命名选项时，我们使用 `IOptionsMonitor` 接口的方式与 `IOptionsFactory` 接口类似。所以，让我们先创建一个类似的端点：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code is almost the same as the factory one, but the `IOptionsMonitor`
    interface exposes a `Get` method instead of a `Create` method. This semantically
    expresses that the code is getting an options instance (singleton) instead of
    creating a new one (transient).Again, similarly, if we send the following request:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码几乎与工厂代码相同，但 `IOptionsMonitor` 接口暴露了一个 `Get` 方法而不是 `Create` 方法。这在语义上表达了代码是获取一个选项实例（单例）而不是创建一个新的（瞬时的）。同样，如果我们发送以下请求：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The server returns the following JSON:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器返回以下 JSON：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One difference is that we can access the default options as well; here’s how:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区别是我们可以访问默认选项；以下是方法：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, the `CurrentValue` property returns the default options.
    So, when calling this endpoint, we should receive the following JSON:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`CurrentValue` 属性返回默认选项。因此，当调用此端点时，我们应该收到以下 JSON：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As simple as that, we can either access the default value or a named value.
    We explore one other scenario that the `IOptionsMonitor` interface supports after
    we cover the `IOptionsSnapshot` interface next.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单，我们既可以访问默认值，也可以访问命名值。在接下来覆盖 `IOptionsSnapshot` 接口之后，我们再探索 `IOptionsMonitor`
    接口支持的另一个场景。
- en: IOptionsSnapshot<MyOptions>
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IOptionsSnapshot<MyOptions>
- en: 'The `IOptionsSnapshot` interface inherits the `IOptions` interface, contributing
    its `Value` property, and also offers a `Get` method (scoped lifetime) that works
    like the `IOptionsMonitor` interface.Let’s start with the first endpoint:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`IOptionsSnapshot` 接口继承自 `IOptions` 接口，贡献了其 `Value` 属性，并且还提供了一个 `Get` 方法（作用域生命周期），该方法的工作方式类似于
    `IOptionsMonitor` 接口。让我们从第一个端点开始：'
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It should be no surprise that the preceding endpoint returns the following
    default options:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的端点返回以下默认选项：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then the following parametrized endpoint returns the specified named options:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以下参数化端点返回指定的命名选项：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Say we are passing the name `Options1`, then the endpoint will return the following
    options:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们传递的名称是 `Options1`，那么端点将返回以下选项：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And we are done. It is quite simple to use the options as .NET does most of
    the work for us. The same goes for configuring options classes.But wait, our exploration
    isn't over yet! Up next, we delve into the process of reloading options at runtime.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就完成了。使用选项非常简单，因为 .NET 为我们做了大部分工作。配置选项类也是如此。但是等等，我们的探索还没有结束！接下来，我们将深入了解在运行时重新加载选项的过程。
- en: Reloading options at runtime
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时重新加载选项
- en: 'A fascinating aspect of the ASP.NET Core options is that the system reloads
    the value of the options when someone updates a configuration file like `appsettings.json`.
    To try it out, you can:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 选项的一个迷人之处在于，当有人更新配置文件，如 `appsettings.json` 时，系统会重新加载选项的值。要尝试它，你可以：
- en: Run the program.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: Query an endpoint using the request available in the `CommonScenarios.http`
    file.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `CommonScenarios.http` 文件中可用的请求查询端点。
- en: Change the value of that option in the `appsettings.json` file and save the
    file.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `appsettings.json` 文件中更改该选项的值并保存文件。
- en: Query the same endpoint again, and you should see the updated value.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次查询相同的端点，你应该会看到更新的值。
- en: 'This is an out-of-the-box feature. However, the system rebuilds the options
    instance, which does not update the references on the previous instance. The good
    news is that we can hook into the system and react to the changes.For most scenarios,
    we don’t need to manually check for change since the value of the `CurrentValue`
    property gets updated. However, if you directly reference that value, this mechanism
    can be useful.In this scenario, we have a notification service that sends emails.
    The SMTP client’s configurations are settings. In this case, we only have the
    `SenderEmailAddress` since sending actual emails is unnecessary. We are logging
    the notification in the console instead, allowing us to see the configuration
    changes appear live.Let’s start with the `EmailOptions` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个即用型功能。然而，系统会重建选项实例，这不会更新先前实例上的引用。好消息是我们可以挂钩到系统中并响应变化。对于大多数场景，我们不需要手动检查变化，因为`CurrentValue`属性的值会自动更新。然而，如果你直接引用该值，这个机制可能很有用。在这种情况下，我们有一个发送电子邮件的通知服务。SMTP客户端的配置是设置。在这种情况下，我们只有`SenderEmailAddress`，因为发送实际的电子邮件是不必要的。我们正在控制台中记录通知，这样我们可以看到配置更改实时出现。让我们从`EmailOptions`类开始：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we have the `NotificationService` class itself. Let’s start with its
    first iteration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看`NotificationService`类本身。让我们从它的第一个迭代开始：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, the class holds a reference on the `EmailOptions` class
    upon creation (highlighted lines). The `NotifyAsync` method writes an information
    message in the console and then returns.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，类在创建时持有对`EmailOptions`类的引用（高亮行）。`NotifyAsync`方法在控制台写入一条信息消息然后返回。
- en: We explore logging in the next chapter.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在下一章探讨日志记录。
- en: 'Because the `NotificationService` class has a singleton lifetime and references
    the options class itself, if we change the configuration, the value will not update
    since the system recreates a new instance with the updated configuration. Here’s
    the service registration method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`NotificationService`类具有单例生命周期并且引用了选项类本身，如果我们更改配置，值将不会更新，因为系统会使用更新的配置重新创建一个新的实例。以下是服务注册方法：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'How to fix this? In this case, we could fix the issue by referencing the `IOptionsMonitor`
    interface instead of its `CurrentValue` property. However, if you face a scenario
    where it’s impossible, we can tap into the `OnChange` method of the `IOptionsMonitor`
    interface. In the constructor, we could add the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解决这个问题？在这种情况下，我们可以通过引用`IOptionsMonitor`接口而不是它的`CurrentValue`属性来修复这个问题。然而，如果你面临一个不可能的场景，我们可以利用`IOptionsMonitor`接口的`OnChange`方法。在构造函数中，我们可以添加以下代码：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With that code, when the `appsettings.json` file changes, the code updates the
    `_emailOptions` field. As easy as this, we reactivated the reloading feature.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，当`appsettings.json`文件更改时，代码会更新`_emailOptions`字段。就像这样，我们重新激活了重新加载功能。
- en: 'One more thing, the `OnChange` method returns an `IDisposable` we can dispose
    of to stop listening for changes. I implemented two additional methods in the
    source code: `StartListeningForChanges` and `StopListeningForChanges`, and three
    endpoints, one to send notifications, one to stop listening for changes, and one
    to start listening for changes again.'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有一点，`OnChange`方法返回一个`IDisposable`，我们可以通过它来停止监听变化。我在源代码中实现了两个额外的函数：`StartListeningForChanges`和`StopListeningForChanges`，以及三个端点，一个用于发送通知，一个用于停止监听变化，另一个用于再次开始监听变化。
- en: Now that we know how to use the options, let’s explore additional ways to configure
    them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用选项，让我们探索配置它们的额外方法。
- en: Project – OptionsConfiguration
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – 选项配置
- en: 'Now that we have covered basic usage scenarios, let’s attack some more advanced
    possibilities, such as creating types to configure, initialize, and validate our
    options.We start by configuring options which happen in two phases:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了基本的使用场景，让我们来探讨一些更高级的可能性，例如创建用于配置、初始化和验证我们选项的类型。我们首先配置选项，这分为两个阶段：
- en: The configuration phase.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置阶段。
- en: The post-configuration phase.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置后阶段。
- en: 'In a nutshell, the post-configuration phase happens later in the process. This
    is a good place to enforce that some values are configured a certain way or to
    override configuration, for example, in integration tests.To configure an options
    class, we have many options, starting with the following interfaces:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，配置后阶段在处理过程中稍后发生。这是一个很好的地方，可以强制某些值以某种方式配置，或者覆盖配置，例如在集成测试中。要配置一个选项类，我们有多种选择，从以下接口开始：
- en: '| **Interface** | **Description** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **接口** | **描述** |'
- en: '| `IConfigureOptions<TOptions>` | Configure the default `TOptions` type. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `IConfigureOptions<TOptions>` | 配置默认的`TOptions`类型。 |'
- en: '| `IConfigureNamedOptions<TOptions>` | Configure the default and named `TOptions`
    type. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `IConfigureNamedOptions<TOptions>` | 配置默认和命名的`TOptions`类型。 |'
- en: '| `IPostConfigureOptions<TOptions>` | Configure the default and named `TOptions`
    type during the post-configuration phase. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `IPostConfigureOptions<TOptions>` | 在配置后阶段配置默认和命名的`TOptions`类型。 |'
- en: 'Table 9.2: interfaces to configure options classes.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.2：配置选项类接口。
- en: If a configuration class implements both `IConfigureOptions` and `IConfigureNamedOptions`
    interfaces, the `IConfigureNamedOptions` interface will take precedence, and the
    `Configure` method of the `IConfigureOptions` interface will not be executed.
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果配置类实现了`IConfigureOptions`和`IConfigureNamedOptions`接口，则`IConfigureNamedOptions`接口将具有优先权，并且`IConfigureOptions`接口的`Configure`方法将不会执行。
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can configure the default instance using the `Configure` method of the `IConfigureNamedOptions`
    interface; the name of the options will be empty (equal to the member `Options.DefaultName`).
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用`IConfigureNamedOptions`接口的`Configure`方法配置默认实例；选项的名称将为空（等于成员`Options.DefaultName`）。
- en: 'We can also leverage the following methods that extend the `IServiceCollection`
    interface:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用以下扩展`IServiceCollection`接口的方法：
- en: '| **Method** | **Description** |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Configure<TOptions>` | Configure the default and named `TOptions` type inline
    or from a configuration section. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `Configure<TOptions>` | 内联或从配置部分配置默认和命名的`TOptions`类型。 |'
- en: '| `ConfigureAll<TOptions>` | Configure all options of type `TOptions` inline.
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `ConfigureAll<TOptions>` | 内联配置`TOptions`类型的所有选项。 |'
- en: '| `PostConfigure<TOptions>` | Configure the default and named `TOptions` type
    inline during the post-configuration phase. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `PostConfigure<TOptions>` | 在配置后阶段内联配置默认和命名的`TOptions`类型。 |'
- en: '| `PostConfigureAll<TOptions>` | Configure all options of type `TOptions` inline
    during the post-configuration phase. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `PostConfigureAll<TOptions>` | 在配置后阶段内联配置`TOptions`类型的所有选项。 |'
- en: 'Table 9.3: configuration methods.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.3：配置方法。
- en: As we are about to see, the registration order is very important. The configurators
    are executed in order of registration. Each phase is independent of the other;
    thus, the sequence in which we arrange the configuration and post-configuration
    phases doesn't influence one another.First, we must lay out the groundwork for
    our little program.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要看到的，注册顺序非常重要。配置器按照注册顺序执行。每个阶段都是独立的；因此，我们安排配置和配置后阶段的顺序不会相互影响。首先，我们必须为我们的小程序打下基础。
- en: Creating the program
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建程序
- en: 'After creating an empty web application, the first building block is to create
    the options class that we want to configure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个空的Web应用程序后，第一个构建块是创建我们想要配置的选项类：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We use the `Lines` property as a trace bucket. We add lines to it to visually
    confirm the order that the configurators are executed.Next, we define application
    settings in the `appsettings.json` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Lines`属性作为跟踪桶。我们向其中添加行以直观地确认配置器的执行顺序。接下来，我们在`appsettings.json`文件中定义应用程序设置：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We use the configuration as a starting point. It defines the value of the `Title`
    property and adds a first line to the `Lines` property, allowing us to trace the
    order it is executed.Next, we need an endpoint to access the settings, serialize
    the result to a JSON string, and then write it to the response stream:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用配置作为起点。它定义了`Title`属性的值，并为`Lines`属性添加了一行，使我们能够追踪其执行顺序。接下来，我们需要一个端点来访问设置，将结果序列化为JSON字符串，然后写入响应流：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By calling this endpoint, we can consult the values of the default and named
    instances we are about to create.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用此端点，我们可以咨询即将创建的默认和命名实例的值。
- en: ASP.NET Core configures the options when they are requested for the first time.
    In this case, both instances of the `ConfigureMeOptions` class are configured
    when calling the `/configure-me` endpoint for the first time.
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ASP.NET Core在首次请求选项时配置选项。在这种情况下，当首次调用`/configure-me`端点时，`ConfigureMeOptions`类的两个实例都被配置。
- en: If we run the program now, we end up with two empty instances, so before doing
    that, we need to tell ASP.NET about the `configureMe` configuration section we
    added to the `appsettings.json` file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行程序，我们将得到两个空实例，所以在做那之前，我们需要告诉ASP.NET关于我们添加到`appsettings.json`文件的`configureMe`配置部分。
- en: Configuring the options
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置选项
- en: 'We want two different options to test out many possibilities:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要两个不同的选项来测试许多可能性：
- en: A default options (unnamed)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个默认选项（未命名）
- en: A named instance.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个命名实例。
- en: 'To achieve this, we must add the following lines in the `Program.cs` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们必须在`Program.cs`文件中添加以下行：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code registers a default instance (highlighted code) and a named
    instance. Both use the `configureMe` configuration sections and so start with
    the same initial values, as we can see when running the project:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码注册了一个默认实例（高亮代码）和一个命名实例。这两个实例都使用`configureMe`配置部分，因此以相同的初始值开始，正如我们在运行项目时可以看到的那样：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `defaultInstance` and `namedInstance` properties are self-explanatory and
    relate to their respective options instance.Now that we completed our building
    blocks, we are ready to explore the `IConfigureOptions<TOptions>` interface.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultInstance`和`namedInstance`属性是自解释的，并与其相应的选项实例相关。现在我们已经完成了我们的构建块，我们准备探索`IConfigureOptions<TOptions>`接口。'
- en: Implementing a configurator object
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现配置器对象
- en: 'We can encapsulate the configuration logic into classes to apply the single
    responsibility principle (SRP). To do so, we must implement an interface and create
    the binding with the IoC container.First, we must create a class that we name
    `ConfigureAllConfigureMeOptions`, which configures all `ConfigureMeOptions` instances;
    default and named:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将配置逻辑封装到类中，以应用单一责任原则（SRP）。为此，我们必须实现一个接口并创建与IoC容器的绑定。首先，我们必须创建一个名为`ConfigureAllConfigureMeOptions`的类，该类配置所有`ConfigureMeOptions`实例；默认和命名：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we implement the interface (highlighted code), which
    contains two methods. The second `Configure` method should never be called, but
    just in case, we can simply redirect the call to the other method if it happens.
    The body of the first `Configure` method (highlighted) adds a line to all options
    and a second line when the options is not the default one.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了接口（高亮代码），其中包含两个方法。第二个`Configure`方法永远不会被调用，但以防万一，如果发生，我们可以简单地将调用重定向到另一个方法。第一个`Configure`方法（高亮）的正文向所有选项添加一行，当选项不是默认选项时，再添加一行。
- en: Instead of testing if the options is not the default one (`name != Options.DefaultName`),
    you can check for the options name or use a `switch` to configure specific options
    by name.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而不是测试选项是否不是默认选项（`name != Options.DefaultName`），你可以检查选项名称或使用`switch`根据名称配置特定选项。
- en: 'We can tell the IoC container about this code, so ASP.NET Core executes it
    like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向IoC容器告知此代码，因此ASP.NET Core将按以下方式执行它：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now with this binding in place, ASP.NET Core will run our code the first time
    we request our endpoint. Here’s the result:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这个绑定，ASP.NET Core 将在我们第一次请求端点时运行我们的代码。以下是结果：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see from that JSON output, the configurator ran and added the expected
    lines to each instance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个JSON输出中我们可以看到，配置器已运行并向每个实例添加了预期的行。
- en: It is important to note that you must bind the `IConfigureOptions<TOptions>`
    to your configuration class even if you implemented the `IConfigureNamedOptions<TOptions>`
    interface.
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是要注意，即使你实现了`IConfigureNamedOptions<TOptions>`接口，你也必须将`IConfigureOptions<TOptions>`绑定到你的配置类。
- en: And voilà—we have a neat result that took almost no effort. This can lead to
    so many possibilities! Implementing `IConfigureOptions<TOptions>` is probably
    the best way to configure the default values of an options class.Next, we add
    post-configuration to the mix!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们得到了一个整洁的结果，几乎不需要任何努力。这可以带来许多可能性！实现`IConfigureOptions<TOptions>`可能是配置选项类默认值的最好方法。接下来，我们将后配置添加到混合中！
- en: Adding post-configuration
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加后配置
- en: 'We must take a similar path to add post-configuration values but implement
    the `IPostConfigureOptions<TOptions>` instead. To achieve this, we update the
    `ConfigureAllConfigureMeOptions` class to implement that interface:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须采取类似的路径来添加后配置值，但实现`IPostConfigureOptions<TOptions>`接口。为了实现这一点，我们将更新`ConfigureAllConfigureMeOptions`类以实现该接口：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding code, we implemented the interface (highlighted lines). The
    `PostConfigure` method simply adds a line to the `Lines` property. To register
    it with the IoC container, we must add the following line:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了接口（高亮行）。`PostConfigure`方法简单地向`Lines`属性添加一行。为了将其注册到IoC容器中，我们必须添加以下行：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The big difference is that this runs during the post-configuration phase, independent
    of the initial configuration phase. Executing the application now leads to the
    following result:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的不同之处在于，这发生在配置后阶段，独立于初始配置阶段。现在执行应用程序会导致以下结果：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding JSON, the highlighted lines represent our post-configuration
    code that was added at the end. You might tell yourself, of course, it’s the last
    line; it’s the last code we registered, which is a legitimate assumption. However,
    here’s the complete registration code, which clearly shows the `IPostConfigureOptions<TOptions>`
    interface was registered first (highlighted), proving the post-configuration code
    runs last:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的JSON中，高亮行代表我们添加到末尾的配置后代码。你可能会想，当然，它是最后一行；它是我们最后注册的代码，这是一个合理的假设。然而，这里是完整的注册代码，它清楚地显示了`IPostConfigureOptions<TOptions>`接口首先注册（高亮），证明配置后代码是最后运行的：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Next, we create a second configuration class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建第二个配置类。
- en: Using multiple configurator objects
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个配置器对象
- en: 'A very interesting concept with the ASP.NET Core options pattern is that we
    can register as many configuration classes as we want. This creates many possibilities,
    including code from one or more assemblies configuring the same options class.Now
    that we know how this works, let’s add the `ConfigureMoreConfigureMeOptions` class,
    which also adds a line to the `Lines` property:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core选项模式的一个非常有趣的概念是，我们可以注册尽可能多的配置类。这创造了多种可能性，包括来自一个或多个程序集的代码配置相同的选项类。现在我们知道了它是如何工作的，让我们添加`ConfigureMoreConfigureMeOptions`类，它也会向`Lines`属性添加一行：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This time, we want that class only to augment the default instance, so it implements
    the **IConfigureOptions<TOptions>** interface (highlighted lines).Next, we must
    register the binding:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们希望这个类只增强默认实例，因此它实现了**IConfigureOptions<TOptions>**接口（高亮行）。接下来，我们必须注册绑定：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As we can see, it’s the same binding but pointing to the `ConfigureMoreConfigureMeOptions`
    class instead of the `ConfigureAllConfigureMeOptions` class.Executing the application
    and querying the endpoint outputs the following JSON:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个相同的绑定，但指向的是`ConfigureMoreConfigureMeOptions`类而不是`ConfigureAllConfigureMeOptions`类。执行应用程序并查询端点会输出以下JSON：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding JSON shows the line our new class added to only the default instance
    (highlighted) before the post-configure option.The possibilities are great, right?
    The code can contribute configuration objects and register them in one of the
    two phases to configure options objects. Next, we explore a few more possibilities.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的JSON显示了我们的新类添加到仅默认实例的行（高亮），在配置后选项之前。可能性很大，对吧？代码可以贡献配置对象并将它们注册在两个阶段之一以配置选项对象。接下来，我们将探索更多可能性。
- en: Exploring other configuration possibilities
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索其他配置可能性
- en: 'We can mix those configuration classes with extension methods. For example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些配置类与扩展方法混合使用。例如：
- en: We can call the `Configure` and `PostConfigure` methods multiple times.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以多次调用`Configure`和`PostConfigure`方法。
- en: We can call the `ConfigureAll` and `PostConfigureAll` methods to configure all
    the options of a given `TOptions`.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以调用`ConfigureAll`和`PostConfigureAll`方法来配置给定`TOptions`的所有选项。
- en: 'Here, we use the `PostConfigure` method to demonstrate that. Let’s add the
    following two lines of code (highlighted):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`PostConfigure`方法来演示。让我们添加以下两行代码（高亮）：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code registers two configuration delegates that target our named
    instance. They both run in the post-configuration phase. So running the app and
    accessing the endpoint shows the order in which all lines are added:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码注册了两个针对我们命名实例的配置委托。它们都在配置后阶段运行。所以运行应用程序并访问端点显示了所有行添加的顺序：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding JSON, we can see that the two highlighted lines are the ones
    we just added, loaded in order, and not applied to the default options.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的JSON中，我们可以看到两个高亮行是我们刚刚添加的，按顺序加载，并且没有应用到默认选项上。
- en: There is one more possibility, which comes from the validation API. This is
    most likely an unintended side effect, but it works nonetheless.
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有一种可能性，它来自验证API。这很可能是无意中产生的副作用，但不管怎样它还是有效果的。
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following code adds the `"Inline Validate"` line after the post-configuration
    phase:'
  id: totrans-242
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码在配置后阶段添加了`"Inline Validate"`行：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: On the separation of concerns aspect, we should stay away from this. However,
    knowing this may help you work around a post-configuration order issue one day.
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在关注点分离方面，我们应该避免这样做。然而，了解这一点可能有助于你有一天解决配置顺序问题。
- en: Now that we know the options interface types, their lifetimes, and many ways
    to configure their values, it is time to validate them and enforce a certain level
    of integrity in our programs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了选项接口类型、它们的生命周期以及配置它们值的各种方法，现在是时候验证它们并在我们的程序中强制执行一定程度的完整性。
- en: Project – OptionsValidation
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – 选项验证
- en: 'Another feature that comes out of the box is options validation, which allows
    us to run validation code when a `TOptions` object is created. The validation
    code is guaranteed to run the first time an option is created and does not account
    for subsequent options modifications. Depending on the lifetime of your options
    object, the validation may or may not run. For example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个开箱即用的功能是选项验证，它允许我们在创建 `TOptions` 对象时运行验证代码。验证代码保证在创建选项时第一次运行，并且不考虑后续的选项修改。根据你的选项对象的生存期，验证可能会运行或不会运行。例如：
- en: '| **Interface** | **Lifetime** | **Validation** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **接口** | **生命周期** | **验证** |'
- en: '| `IOptionsMonitor<TOptions>` | Singleton | Validate the options once. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `IOptionsMonitor<TOptions>` | 单例 | 一次性验证选项。 |'
- en: '| `IOptionsFactory<TOptions>` | Transient | Validate the options every time
    the code calls the `Create` method. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `IOptionsFactory<TOptions>` | 委托 | 每次代码调用 `Create` 方法时验证选项。 |'
- en: '| `IOptionsSnapshot<TOptions>` | Scoped | Validate the options once per HTTP
    request (per scope). |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `IOptionsSnapshot<TOptions>` | 范围 | 每个HTTP请求（每个范围）一次性验证选项。 |'
- en: '| `IOptions<TOptions>` | Singleton | Validate the options once. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `IOptions<TOptions>` | 单例 | 一次性验证选项。 |'
- en: 'Table 9.4: the effect of validation on options lifetime.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.4：验证对选项生命期的影响。
- en: I wrote three test cases in the `ValidateLifetime.cs` file if you are interested
    to see this in action.
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想看到这个动作，我在 `ValidateLifetime.cs` 文件中写了三个测试用例。
- en: We can create validation types to validate options classes. They must implement
    the `IValidateOptions<TOptions>` interface or use data annotations such as `[Required]`.
    Implementing the interface works very similarly to the options configuration.First,
    let’s see how to force the validation when the program starts.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建验证类型来验证选项类。它们必须实现 `IValidateOptions<TOptions>` 接口或使用如 `[Required]` 之类的数据注释。实现接口的工作方式与选项配置非常相似。首先，让我们看看如何在程序启动时强制进行验证。
- en: Eager validation
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 急切验证
- en: 'Eager validation has been added to .NET 6 and allows catching incorrectly configured
    options at startup time in a fail-fast mindset.The `Microsoft.Extensions.Hosting`
    assembly adds the `ValidateOnStart` extension method to the `OptionsBuilder<TOptions>`
    type.There are different ways of using this, including the following, which binds
    a configuration section to an options class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 急切验证已添加到 .NET 6 中，并允许在启动时以快速失败的心态捕获配置错误的选项。`Microsoft.Extensions.Hosting` 程序集向
    `OptionsBuilder<TOptions>` 类型添加了 `ValidateOnStart` 扩展方法。有几种使用方法，包括以下方法，它将配置部分绑定到选项类：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The highlighted line is all we need to apply our validation rules during startup.
    I recommend using this as your new default so you know that options are misconfigured
    at startup time instead of later at runtime, limiting unexpected issues.Now that
    we know that, let’s look at how to configure options validation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的那一行是我们需要在启动时应用验证规则的全部内容。我建议将其作为你的新默认设置，这样你就可以知道在启动时而不是在运行时晚些时候配置了选项，从而限制意外问题的发生。现在我们知道了这一点，让我们看看如何配置选项验证。
- en: Data annotations
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据注释
- en: Let’s start by using `System.ComponentModel.DataAnnotations` types to decorate
    our options with validation attributes. We activate this feature with the `ValidateDataAnnotations`
    extension method. This also works with eager validation by chaining both methods.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 `System.ComponentModel.DataAnnotations` 类型用验证属性装饰我们的选项开始，以激活此功能。这也与急切验证一起使用，通过链式调用这两个方法。
- en: If you are unfamiliar with `DataAnnotations`, they are attributes used to validate
    EF Core and MVC model classes. Don’t worry, they are very explicit, so you should
    understand the code.
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你对 `DataAnnotations` 不熟悉，它们是用于验证 EF Core 和 MVC 模型类的属性。别担心，它们非常明确，所以你应该能理解代码。
- en: 'To demonstrate this, let’s look at the skeleton of two small tests:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们看看两个小型测试的框架：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code shows that the `MyImportantProperty` property of the `Options`
    class is required and cannot be `null` (highlighted line). Next, we look at the
    test cases.The first test is expecting the validation to pass:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示，`Options` 类的 `MyImportantProperty` 属性是必需的，不能为 `null`（突出显示的行）。接下来，我们看看测试用例。第一个测试是期望验证通过：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The test simulates the execution of a program where the IoC container creates
    the options class, and its consumer (the test) leverages it. The highlighted line
    sets the property to `"A value"`, making the validation pass. The code also enables
    eager validation (`ValidateOnStart`) on top of the validation of data annotations
    (`ValidateDataAnnotations`).The second test is expecting the validation to fail:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模拟了一个程序的执行，其中 IoC 容器创建选项类，并且它的消费者（测试）利用它。高亮行将属性设置为 `"A value"`，使验证通过。代码还启用了贪婪验证（`ValidateOnStart`），在数据注释验证（`ValidateDataAnnotations`）之上。第二个测试期望验证失败：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code, the `MyImportantProperty` is never set (highlighted code),
    leading to the validation failing and throwing an `OptionsValidationException`.
    The test simulates catching that exception.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`MyImportantProperty` 永远没有被设置（高亮代码），导致验证失败并抛出 `OptionsValidationException`。测试模拟捕获该异常。
- en: The eager validation does not work in the tests because it is not an ASP.NET
    Core program but xUnit test cases (Fascts).
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 贪婪验证在测试中不起作用，因为它不是一个 ASP.NET Core 程序，而是 xUnit 测试用例（Facts）。
- en: That’s it—.NET does the job for us and validates our instance of the `Options`
    class using the data annotation like you can do when using EF Core or MVC model.Next,
    we explore how to create validation classes to validate our options objects manually.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——.NET 为我们完成了这项工作，并使用数据注释验证我们的 `Options` 类实例，就像你在使用 EF Core 或 MVC 模型时可以做到的那样。接下来，我们将探讨如何创建验证类来手动验证我们的选项对象。
- en: Validation types
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证类型
- en: To implement options validation types or options validators, we can create a
    class that implements one or more `IValidateOptions<TOptions>` interfaces. One
    type can validate multiple options, and multiple types can validate the same options,
    so the possible combinations should cover all use cases.Using a custom class is
    no harder than using data annotations. However, it allows us to remove the validation
    concerns from the options class and code more complex validation logic. You should
    pick the way that makes the most sense for your project.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现选项验证类型或选项验证器，我们可以创建一个类，该类实现一个或多个 `IValidateOptions<TOptions>` 接口。一个类型可以验证多个选项，多个类型可以验证相同的选项，因此可能的组合应该覆盖所有用例。使用自定义类并不比使用数据注释更难。然而，它允许我们将验证关注点从选项类和代码中移除，并编写更复杂的验证逻辑。你应该选择对你项目最有意义的方法。
- en: On top of personal preferences, say you use a third-party library with options.
    You load that library into your application and expect the configuration to be
    a certain way. You could create a class to validate that the options class provided
    by the library is configured appropriately for your application and even validate
    this at startup time.
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了个人偏好之外，假设你使用了一个带有选项的第三方库。你将这个库加载到你的应用程序中，并期望配置以某种方式。你可以创建一个类来验证该库提供的选项类是否已适当地配置为适用于你的应用程序，甚至可以在启动时进行验证。
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can’t use data annotations for that because you don’t control the code.
    Moreover, it is not a general validation that should apply to all consumers but
    specific validation for that one app.
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你不能使用数据注释来验证，因为你无法控制代码。此外，它不是适用于所有消费者的通用验证，而是针对那个特定应用程序的特定验证。
- en: 'Let’s start with the skeleton of the test class:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试类的骨架开始：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the preceding code, we have the `Options` class that is similar to the previous
    example but without the data annotation. The difference is that instead of using
    the `[Required]` attribute, we created the `OptionsValidator` class (highlighted)
    containing the validation logic.`OptionsValidator` implements `IValidateOptions<Options>`,
    which only contains a `Validate` method. This method allows named and default
    options to be validated. The `name` argument represents the options’ names. In
    our case, we implemented the required logic for all options. The `ValidateOptionsResult`
    class exposes a few members to help us, such as the `Success` and `Skip` fields,
    and two `Fail()` methods.`ValidateOptionsResult.Success` indicates success. `ValidateOptionsResult.Skip`
    indicates that the validator did not validate the options, most likely because
    it only validates certain named options but not the given one.The `ValidateOptionsResult.Fail(message)`
    and `ValidateOptionsResult.Fail(messages)` methods take a single message or a
    collection of messages as an argument.To make this work, we must make the validator
    available to the IoC container, as we did with the options configuration. We explore
    the two test cases next, which are very similar to the data annotation example.Here’s
    the first test case that passes the validation:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有`Options`类，它类似于前面的示例，但没有数据注释。区别在于，我们不是使用`[Required]`属性，而是创建了一个包含验证逻辑的`OptionsValidator`类（突出显示）。`OptionsValidator`实现了`IValidateOptions<Options>`接口，它只包含一个`Validate`方法。这个方法允许验证命名和默认选项。`name`参数表示选项的名称。在我们的例子中，我们实现了所有选项的必需逻辑。`ValidateOptionsResult`类公开了一些成员来帮助我们，例如`Success`和`Skip`字段，以及两个`Fail()`方法。`ValidateOptionsResult.Success`表示成功。`ValidateOptionsResult.Skip`表示验证器没有验证选项，这很可能是由于它只验证某些命名选项，但没有验证给定的选项。《ValidateOptionsResult.Fail(message)》和《ValidateOptionsResult.Fail(messages)》方法接受一个消息或消息集合作为参数。为了使这可行，我们必须使验证器对IoC容器可用，就像我们对选项配置所做的那样。接下来，我们探索两个测试用例，这两个测试用例与数据注释示例非常相似。以下是第一个通过验证的测试用例：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The test case simulates an application that configures the `MyImportantProperty`
    correctly, which passes validation. The highlighted line shows how to register
    the validator class. The rest is done by the framework when using the options
    class.Next, we explore a test that fails the validation:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例模拟了一个正确配置`MyImportantProperty`的应用程序，它通过了验证。突出显示的行显示了如何注册验证器类。其余的由框架在使用选项类时完成。接下来，我们探索一个失败的验证测试用例：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The test simulates a program where the `Options` class is not configured appropriately.
    When accessing the options object, the framework builds the class and validates
    it, throwing an `OptionsValidationException` because of the validation rules (highlighted
    lines).Using types to validate options is handy when you don’t want to use data
    annotations, can’t use data annotations, or need to implement certain logic that
    is easier within a method than with attributes.Next, we glance at how to leverage
    options with FluentValidation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试模拟了一个程序，其中`Options`类未正确配置。当访问选项对象时，框架构建类并验证它，由于验证规则（突出显示的行），抛出`OptionsValidationException`。使用类型来验证选项在你不希望使用数据注释、不能使用数据注释或需要实现某些逻辑，而这些逻辑在方法中比用属性更容易实现时很有用。接下来，我们简要看看如何利用FluentValidation中的选项。
- en: Project – OptionsValidationFluentValidation
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – OptionsValidationFluentValidation
- en: 'In this project, we validate options classes using FluentValidation. FluentValidation
    is a popular open-source library that provides a validation framework different
    from data annotations. We explore FluentValidation more in *Chapter 15*, *Getting
    Started with Vertical Slice Architecture*, but that should not hinder you from
    following this example.Here, I want to show you how to leverage a few patterns
    we’ve learned so far to implement this ourselves with only a few lines of code.
    In this micro-project, we leverage:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们使用FluentValidation来验证选项类。FluentValidation是一个流行的开源库，它提供了一个与数据注释不同的验证框架。我们将在第15章“使用垂直切片架构入门”中更深入地探讨FluentValidation，但这不应阻碍你跟随这个示例。在这里，我想向你展示如何利用我们迄今为止学到的几个模式，只用几行代码就实现这一点。在这个微型项目中，我们利用：
- en: Dependency injection
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: The Strategy design pattern
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The Options pattern
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项模式
- en: 'Options validation: validation types'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项验证：验证类型
- en: 'Options validation: eager validation'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项验证：急切验证
- en: 'Let’s start with the options class itself:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从选项类本身开始：
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The options class is very thin, containing only a nullable `Name` property.
    Next, let’s look at the FluentValidation validator, which validates that the `Name`
    property is not empty:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 选项类非常简单，只包含一个可空的 `Name` 属性。接下来，让我们看看 FluentValidation 验证器，它验证 `Name` 属性不为空：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you have never used FluentValidation before, the `AbstractValidator<T>`
    class implements the `IValidator<T>` interface and adds utility methods like `RuleFor`.
    The `MyOptionsValidator` class contains the validation rules.To make ASP.NET Core
    validate `MyOptions` instances using FluentValidation, we implement an `IValidateOptions<TOptions>`
    interface as we did in the previous example, inject our validator in it, and then
    leverage it to ensure the validity of `MyOptions` objects. This implementation
    of the `IValidateOptions` interface creates a bridge between the FluentValidation
    features and the ASP.NET Core options validation.Here is a generic implementation
    of such a class that could be reused for any type of options:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过 FluentValidation，`AbstractValidator<T>` 类实现了 `IValidator<T>` 接口，并添加了如
    `RuleFor` 这样的实用方法。`MyOptionsValidator` 类包含了验证规则。为了使 ASP.NET Core 使用 FluentValidation
    验证 `MyOptions` 实例，我们像上一个示例中那样实现了一个 `IValidateOptions<TOptions>` 接口，将其中的验证器注入其中，然后利用它来确保
    `MyOptions` 对象的有效性。这个 `IValidateOptions` 接口的实现，在 FluentValidation 功能和 ASP.NET
    Core 选项验证之间建立了一个桥梁。以下是一个通用的类实现，它可以用于任何类型的选项：
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding code, the `FluentValidateOptions<TOptions>` class adapts the
    `IValidateOptions<TOptions>` interface to the `IValidator<TOptions>` interface
    by leveraging FluentValidation in the `Validate` method. In a nutshell, we use
    the output of one system and make it an input of another system.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`FluentValidateOptions<TOptions>` 类通过在 `Validate` 方法中使用 FluentValidation，将
    `IValidateOptions<TOptions>` 接口适配到 `IValidator<TOptions>` 接口。简而言之，我们使用一个系统的输出作为另一个系统的输入。
- en: This type of adaptation is known as the Adapter design pattern. We explore the
    Adapter pattern in the next chapter.
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种类型的适配被称为适配器设计模式。我们将在下一章探讨适配器模式。
- en: 'Now that we have all the building blocks, let’s have a look at the composition
    root:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有构建块，让我们看看组合根：
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The highlighted code is the key to this system:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码是这个系统的关键：
- en: It registers the FluentValidation `MyOptionsValidator` that contains the validation
    rules.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它注册了包含验证规则的 FluentValidation `MyOptionsValidator`。
- en: It registers the generic `FluentValidateOptions` instance, so .NET uses it to
    validate `MyOptions` class.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它注册了通用的 `FluentValidateOptions` 实例，因此 .NET 使用它来验证 `MyOptions` 类。
- en: Under the hood, The `FluentValidateOptions` class uses the `MyOptionsValidator`
    to validate the options internally.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底层，`FluentValidateOptions` 类使用 `MyOptionsValidator` 来内部验证选项。
- en: 'When running the program, the console yields the following error, as expected:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行程序时，控制台输出了预期的以下错误：
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This may look like a lot of trouble for a simple required field; however, the
    `FluentValidateOptions<TOptions>` is reusable. We could also scan one or more
    assemblies to register the validator with the IoC container automatically.Now
    that we’ve explored many ways to configure and validate options objects, it is
    time to look at a way to inject options classes directly, either by choice or
    to work around a library capability issue.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的必填字段来说，这可能会显得有些麻烦；然而，`FluentValidateOptions<TOptions>` 是可重用的。我们还可以扫描一个或多个程序集，以自动将验证器注册到
    IoC 容器中。现在我们已经探索了许多配置和验证选项对象的方法，是时候看看如何直接注入选项类了，无论是出于选择还是为了解决库功能问题。
- en: Workaround – Injecting options directly
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 – 直接注入选项
- en: The only negative point about the .NET Options pattern is that we must tie our
    code to the framework’s interfaces. We must inject an interface like `IOptionsMonitor<Options>`
    instead of the `Options` class itself. By letting the consumers choose the interface,
    we let them control the lifetime of the options, which breaks the inversion of
    control, dependency inversion, and open/closed principles. We should move that
    responsibility out of the consumer up to the composition root.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 .NET 选项模式唯一的缺点是我们必须将我们的代码绑定到框架的接口上。我们必须注入一个接口，如 `IOptionsMonitor<Options>`
    而不是 `Options` 类本身。通过让消费者选择接口，我们让他们控制选项的生命周期，这打破了控制反转、依赖反转和开闭原则。我们应该将这个责任从消费者移到组合根。
- en: As we explored at the beginning of this chapter, the `IOptions`, `IOptionsFactory`,
    `IOptionsMonitor`, and `IOptionsSnapshot` interfaces define the options object’s
    lifetime.
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所探讨的，`IOptions`、`IOptionsFactory`、`IOptionsMonitor` 和 `IOptionsSnapshot`
    接口定义了选项对象的生存周期。
- en: 'In most cases, I prefer to inject `Options` directly, controlling its lifetime
    from the composition root, instead of letting the class itself control its dependencies.
    I’m a little *anti-control-freak*, I know. Moreover, writing tests using the `Options`
    class directly over mocking an interface like `IOptionsSnapshot` is easier.It
    just so happens that we can circumvent this easily with the following two parts
    trick:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我更喜欢直接注入`Options`，从组合根控制其生命周期，而不是让类本身控制其依赖关系。我知道我有点儿**反控制狂**。此外，直接使用`Options`类编写测试，而不是模拟像`IOptionsSnapshot`这样的接口，要简单得多。碰巧我们可以用以下两个部分的小技巧轻松绕过这个问题：
- en: Set up the options class normally, as explored in this chapter.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正常设置选项类，如本章所探讨的那样。
- en: Create a dependency binding that instructs the container to inject the options
    class directly using the Options pattern.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个依赖绑定，指示容器直接使用选项模式注入选项类。
- en: 'The xUnit test of the `ByPassingInterfaces` class from the `OptionsValidation`
    project demonstrates this. Here’s the skeleton of that test class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionsValidation`项目中的`ByPassingInterfaces`类的xUnit测试演示了这一点。以下是该测试类的框架：'
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding `Options` class has only a `Name` property. We are using it next
    to explore the workaround in the test case:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Options`类只有一个`Name`属性。我们将在下一个测试用例中用它来探索这个解决方案：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding code block, we registered the `Options` class using a factory
    method. That way, we can inject the `Options` class directly (with a scoped lifetime).
    Moreover, the delegate now controls the `Options` class's creation and lifetime
    (highlighted code).And voilà, this workaround allows us to inject `Options` directly
    into our system without tying our classes with any .NET-specific options interface.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用工厂方法注册了`Options`类。这样，我们可以直接注入`Options`类（具有作用域生命周期）。此外，现在委托控制了`Options`类的创建和生命周期（高亮代码）。就这样，这个解决方案允许我们直接将`Options`注入到我们的系统中，而不需要将我们的类与任何.NET特定的选项接口绑定。
- en: Consuming options through the `IOptionsSnapshot<TOptions>` interface results
    in a *scoped* lifetime.
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过`IOptionsSnapshot<TOptions>`接口消费选项会导致具有**作用域**的生命周期。
- en: The *Act & Assert* section of the test validates the correctness of the setup
    by creating two scopes and ensuring that each scope returns a different instance
    while returning the same instance within the scope. For example, both `options1`
    and `options2` come from `scope1`, so they should be the same. On the other hand,
    `options3` comes from `scope2`, so it should be different than `options1` and
    `options2`.This workaround also applies to existing systems that could benefit
    from the Options pattern without updating its code—assuming the system is dependency
    injection-ready. We can also use this trick to compile an assembly that does not
    depend on `Microsoft.Extensions.Options`. By using this trick, we can set the
    lifetime of the options from the composition root, which is a more classic dependency
    injection-enabled flow. To change the lifetime, use a different interface, like
    `IOptionsMonitor` or `IOptionsFactory`.Next, we explore a way to organize all
    this code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的**行为与断言**部分通过创建两个作用域并确保每个作用域返回不同的实例（在作用域内返回相同的实例）来验证设置的正确性。例如，`options1`和`options2`都来自`scope1`，所以它们应该是相同的。另一方面，`options3`来自`scope2`，所以它应该与`options1`和`options2`不同。这个解决方案也适用于可以从选项模式中受益但无需更新其代码的现有系统——假设系统已经准备好依赖注入。我们还可以使用这个技巧来编译一个不依赖于`Microsoft.Extensions.Options`的程序集。通过使用这个技巧，我们可以从组合根设置选项的生命周期，这是一种更经典的依赖注入流程。要更改生命周期，可以使用不同的接口，如`IOptionsMonitor`或`IOptionsFactory`。接下来，我们将探讨一种组织所有这些代码的方法。
- en: Project – Centralizing the configuration
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – 集中配置
- en: 'Creating classes and classes is very object-oriented and follows the single-responsibility
    principle, among others. However, dividing responsibilities into programming concerns
    is not always what leads to the easiest code to understand because it creates
    a lot of classes and files, often spread across multiple layers and more.An alternative
    is to regroup the initialization and validation with the options class itself,
    shifting the multiple responsibilities to a single one: an end-to-end options
    class.In this example, we explore `ProxyOptions` class, which carries the name
    of the service and the time the proxy service should cache items in seconds. We
    want to set a default value for the `CacheTimeInSeconds` property and validate
    that the `Name` property is not empty.On the other hand, we don’t want the consumer
    of that class to have access to any other methods, like `Configure` or `Validate`.To
    achieve this, we can implement the interfaces explicitly, hiding them from the
    `ProxyOptions` but showing them to the consumers of the interfaces. For example,
    binding the `ProxyOptions` class to the `IValidateOptions<ProxyOptions>` interface
    gives the consumer access to the `Validate` method through the `IValidateOptions<ProxyOptions>`
    interface. Explaining this should be simpler in code; here’s the class:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类和类非常面向对象，遵循单一职责原则等。然而，将职责划分为编程关注点并不总是导致最容易理解的代码，因为它会创建很多类和文件，通常分布在多个层和更多。一个替代方案是将初始化和验证与选项类本身重新组合，将多个职责转移到单一的一个：一个端到端选项类。在这个例子中，我们探讨了`ProxyOptions`类，它携带服务的名称和代理服务应该缓存项的秒数。我们希望为`CacheTimeInSeconds`属性设置默认值，并验证`Name`属性不为空。另一方面，我们不希望该类的消费者能够访问任何其他方法，如`Configure`或`Validate`。为了实现这一点，我们可以明确实现接口，隐藏它们从`ProxyOptions`中，但向接口的消费者展示。例如，将`ProxyOptions`类绑定到`IValidateOptions<ProxyOptions>`接口，通过`IValidateOptions<ProxyOptions>`接口给消费者访问`Validate`方法。在代码中解释这一点应该更简单；以下是该类的代码：
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding code implements both `IConfigureOptions<ProxyOptions>` and `IValidateOptions<ProxyOptions>`
    interfaces explicitly (highlighted) by omitting the visibility modifier and prefixing
    the name of the method with the name of the interface, like the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码明确实现了`IConfigureOptions<ProxyOptions>`和`IValidateOptions<ProxyOptions>`接口（已突出显示），通过省略可见性修饰符并在方法名称前加上接口名称来实现，如下所示：
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, to leverage it, we must register it with the IoC container like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了利用它，我们必须像这样将其注册到IoC容器中：
- en: '[PRE64]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the preceding code, we combined many notions we explored, like:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们结合了许多我们探讨的概念，如：
- en: Registering the options class
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册选项类
- en: Using the workaround to access the `ProxyOptions` class directly
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绕过方法直接访问`ProxyOptions`类
- en: Configuring the options inline and through a configurator class
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过内联和配置器类配置选项
- en: Leverage a validation class
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用验证类
- en: Enforcing the validation by eager loading our options during the startup.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在启动时急切加载我们的选项来强制执行验证。
- en: If you comment out the highlighted line, the application will throw an exception
    on startup.
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您取消注释突出显示的行，应用程序将在启动时抛出异常。
- en: 'The only endpoint defined in the application is the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中定义的唯一端点是以下内容：
- en: '[PRE65]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When we run the application, we get the following output:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们得到以下输出：
- en: '[PRE66]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As expected, the value of the `cacheTimeInSeconds` property equals the value
    of the `DefaultCacheTimeInSeconds` field, and the value of the `name` property
    to what we configured in the `Program.cs` file.When using the IntelliSense feature
    inside your favorite IDE, I’m using Visual Studio 2022 here, we can see only the
    properties, no method:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`cacheTimeInSeconds`属性的值等于`DefaultCacheTimeInSeconds`字段的值，而`name`属性的值是我们配置在`Program.cs`文件中的值。当在您最喜欢的IDE中使用IntelliSense功能时（这里我使用的是Visual
    Studio 2022），我们只能看到属性，没有方法：
- en: '![Figure 9.1: VS IntelliSense not showing explicitly implemented interfaces
    members.](img/file45.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：VS IntelliSense未显示显式实现的接口成员](img/file45.png)'
- en: 'Figure 9.1: VS IntelliSense not showing explicitly implemented interfaces members.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：VS IntelliSense未显示显式实现的接口成员。
- en: That’s it; we are done with this organizational technique.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们完成了这种组织技术。
- en: To keep the composition cleaner, we could encapsulate the bindings in an extension
    method, and, even better, make that extension method register the whole proxy
    feature. For example, `services.AddProxyService()`.
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了保持组合的简洁性，我们可以将绑定封装在一个扩展方法中，甚至更好的是，让这个扩展方法注册整个代理功能。例如，`services.AddProxyService()`。
- en: ''
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I’ll let you practice this one on your own as we already explored this.
  id: totrans-345
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我会留给你自己练习这个，因为我们已经探索了这个。
- en: Next, we explore code generators!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探索代码生成器！
- en: Using the configuration-binding source generator
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用配置绑定源生成器
- en: .NET 8 introduces a **configuration-binding source generator** that provides
    an alternative to the default reflection-based implementation. In simple terms,
    the name of the options class properties and the settings keys are now hard-coded,
    accelerating the configuration retrieval.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 引入了一个 **配置绑定源生成器**，它为默认的基于反射的实现提供了一种替代方案。简单来说，选项类属性的名称和设置密钥现在是硬编码的，加速了配置检索。
- en: Beware, the settings keys are case-sensitive and map one-on-one with the C#
    class property name, unlike the non-generated code.
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，设置密钥是区分大小写的，并且与 C# 类属性名称一对一映射，与非生成代码不同。
- en: Web applications using Native AOT deployment (ahead-of-time compilation to native
    code) or trimming self-contained deployments to ship only the bits in use now
    leverage this option by default.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生 AOT 部署（提前编译到原生代码）或裁剪自包含部署以仅发送当前使用的位的应用程序默认利用此选项。
- en: The native AOT deployment model compiles the code to a single runtime environment
    like Windows x64\. It does not need the just-in-time (JIT) compiler since the
    code is already compiled to the native version of the targetted environment. AOT
    deployments are self-contained and do not need the .NET runtime to work.
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原生 AOT 部署模型将代码编译到单个运行时环境，如 Windows x64。由于代码已经编译为目标环境的原生版本，因此不需要即时 (JIT) 编译器。AOT
    部署是自包含的，并且不需要 .NET 运行时才能工作。
- en: 'We can use the `EnableConfigurationBindingGenerator` property in your `csproj`
    file to manually activate or deactivate the generator:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在您的 `csproj` 文件中使用 `EnableConfigurationBindingGenerator` 属性手动激活或停用生成器：
- en: '[PRE67]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now that the generator is enabled, let’ see how this works. The generator looks
    for a few options, including the Configure and Bind methods. It then generates
    the binding code.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在生成器已启用，让我们看看它是如何工作的。生成器会查找一些选项，包括 Configure 和 Bind 方法。然后生成绑定代码。
- en: 'Project – ConfigurationGenerators: Part 1'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 配置生成器：第一部分
- en: 'In this first part of the project, we create an options class and register
    it with the IoC container to consume it through an API endpoint.We use the following
    options class:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的第一部分中，我们创建一个选项类，并将其注册到 IoC 容器中，以便通过 API 端点使用它。我们使用以下选项类：
- en: '[PRE68]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the `Program.cs` file, we can use the source generator like this:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，我们可以像这样使用源生成器：
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you may have noticed, the preceding code is the same as we used before and
    does what you expect it to do, but the new source generator generates the code
    under the hood—no functional or usage changes.Let’s explore another source generator
    next.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，前面的代码与我们之前使用的相同，并且执行您期望的操作，但新的源生成器在底层生成代码——没有功能或使用上的变化。让我们探索另一个源生成器。
- en: Using the options validation source generator
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选项验证源生成器
- en: '.NET 8 introduces the **options validation source generator**, which generates
    the validation code based on data annotations. The idea is similar to the configuration-binding
    source generator but for the validation code.To leverage the validation generator,
    we must add a reference on the `Microsoft.Extensions.Options.DataAnnotations`
    package.Afterward, we must:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 引入了 **选项验证源生成器**，它根据数据注释生成验证代码。这个想法与配置绑定源生成器类似，但用于验证代码。为了利用验证生成器，我们必须在
    `Microsoft.Extensions.Options.DataAnnotations` 包上添加引用。之后，我们必须：
- en: Create an empty validator class.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的验证器类。
- en: Ensure the class is `partial`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保类是 `partial`。
- en: Implement the `IValidateOptions<TOptions>` interface (but not the methods).
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `IValidateOptions<TOptions>` 接口（但不实现方法）。
- en: Decorate the validator class with the `[OptionsValidator]` attribute.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `[OptionsValidator]` 属性装饰验证器类。
- en: Register the validator class with the container.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将验证器类注册到容器中。
- en: This procedure sounds complicated but is way simpler in code; let's look at
    that now.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程听起来很复杂，但在代码中要简单得多；现在让我们看看。
- en: 'Project – ConfigurationGenerators: Part 2'
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 配置生成器：第二部分
- en: 'In this second part of the project, we continue to build on the previous pieces
    and add validation to our `MyOptions` class. Of course, we also want to test the
    new source generator.Here''s the updated `MyOptions` class:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的第二部分中，我们继续构建前面的组件，并为我们的 `MyOptions` 类添加验证。当然，我们还想测试新的源生成器。以下是更新的 `MyOptions`
    类：
- en: '[PRE70]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The highlighted line represents the changes. We want to ensure the `Name` property
    is not empty.Now that we updated our options class, let''s create the following
    validator class:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行代表更改。我们想要确保`Name`属性不为空。现在我们已经更新了我们的选项类，让我们创建以下验证器类：
- en: '[PRE71]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The preceding code is an empty shell that prepares the class for the code generator.
    The `[OptionsValidator]` attribute represents the generator hook (a.k.a. that’s
    the flag the generator is looking for). And with this code, we are done with steps
    1 to 4; simpler than English, right?Now, for the last step, we register our validator
    like normal:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码是一个空壳，为代码生成器准备了这个类。`[OptionsValidator]`属性代表生成器钩子（即这是生成器正在寻找的标志）。有了这段代码，我们就完成了步骤1到4；比英语简单，对吧？现在，对于最后一步，我们像平常一样注册我们的验证器：
- en: '[PRE72]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To test this out, let''s add a `valid` named options instance bound to the
    following configuration section in the `appsettings.json` file:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，让我们在`appsettings.json`文件中添加一个绑定到以下配置部分的`valid`命名选项实例：
- en: '[PRE73]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here''s how we bind it in the `Program.cs` file:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`Program.cs`文件中绑定它的方式：
- en: '[PRE74]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The preceding code registers the `valid` named options, binds it to the configuration
    section `MyOptions`, and validates it when the application starts.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码注册了`valid`命名选项，将其绑定到配置部分`MyOptions`，并在应用程序启动时进行验证。
- en: Other ways to register the named options also work. I used this one for convenience
    purposes only.
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其他注册命名选项的方法也有效。我仅出于方便目的使用这种方法。
- en: 'If we were to inspect the content of the options at runtime, it would be what
    we expect; nothing is different from what we explored throughout the chapter:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在运行时检查选项的内容，它应该是我们预期的；与我们在本章中探索的内容没有不同：
- en: '[PRE75]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'At this point, the program should start.Next, to test this out, let''s add
    another named options class, but an invalid one this time. We won''t change anything
    in the `appsettings.json` file, and add the following registration code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，程序应该已经开始。接下来，为了测试这一点，让我们添加另一个命名选项类，但这次是一个无效的类。我们不会在`appsettings.json`文件中做任何更改，并添加以下注册代码：
- en: '[PRE76]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding code binds a missing section to the `invalid` named options,
    making the `Name` property equal to `null`. That object will not pass our validation
    because the `Name` property is required.If we run the application now, we get
    the following message:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将一个缺失的部分绑定到`invalid`命名选项，使`Name`属性等于`null`。这个对象将无法通过我们的验证，因为`Name`属性是必需的。如果我们现在运行应用程序，我们会得到以下消息：
- en: '[PRE77]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: From that error, we know the validation works as expected. It is not every day
    that we are happy when our application doesn’t start but this is one of those
    time.That's it for the code generation, it behaves the same, but the code under
    the hood is different, enabling technologies like AOT and trimming that do not
    support reflection-based mechanisms well. Moreover, code generation should speed
    up the program execution because the behaviors are hard-coded instead of relying
    on a dynamic reflection-based approach.Next, let’s dig into another class introduced
    in .NET 8.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个错误中，我们知道验证按预期工作。我们并不总是因为我们的应用程序无法启动而感到高兴，但这次就是这样。代码生成到此结束，它的行为相同，但底层的代码是不同的，这使AOT和trimming等技术能够更好地支持不依赖反射机制的机制。此外，代码生成应该会加快程序执行速度，因为行为是硬编码的，而不是依赖于动态的基于反射的方法。接下来，让我们深入了解.NET
    8中引入的另一个类。
- en: Using the ValidateOptionsResultBuilder class
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ValidateOptionsResultBuilder类
- en: The `ValidateOptionsResultBuilder` is a new type in .NET 8\. It allows to dynamically
    accumulate validation errors and create a `ValidateOptionsResult` object representing
    its current state.Its basic usage is straightforward, as we are about to see.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidateOptionsResultBuilder`是.NET 8中的一个新类型。它允许动态累积验证错误并创建一个表示其当前状态的`ValidateOptionsResult`对象。其基本用法非常简单，正如我们即将看到的。'
- en: Project - ValidateOptionsResultBuilder
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 - ValidateOptionsResultBuilder
- en: 'In this project, we are validating the `MyOptions` object. The type has multiple
    validation rules, and we want to ensure we are not stopping after the first rule
    fails validation so a consumer would know all the errors in one go. To achieve
    this, we decided to use the `ValidateOptionsResultBuilder` class.Let''s start
    with the options class:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们正在验证`MyOptions`对象。该类型有多个验证规则，我们想要确保在第一个规则验证失败后不会停止，这样消费者就可以一次性知道所有错误。为了实现这一点，我们决定使用`ValidateOptionsResultBuilder`类。让我们从选项类开始：
- en: '[PRE78]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, let''s implement a validator class that enforces both properties are
    not empty:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现一个验证器类，强制两个属性都不为空：
- en: '[PRE79]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the preceding code, we create a `ValidateOptionsResultBuilder` object, add
    errors to it, then returns an instance of the `SimpleMyOptionsValidator` class
    by leveraging its `Build` method. The usage of the `ValidateOptionsResultBuilder`
    class is highlighted.Next, to test this out, we must register the options. Let''s
    also create an endpoint. Here''s the `Program.cs` file:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个 `ValidateOptionsResultBuilder` 对象，向其中添加错误，然后通过利用其 `Build` 方法返回
    `SimpleMyOptionsValidator` 类的实例。`ValidateOptionsResultBuilder` 类的使用被突出显示。接下来，为了测试这一点，我们必须注册选项。让我们也创建一个端点。以下是
    `Program.cs` 文件：
- en: '[PRE80]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The preceding code is as normal as it can get after a whole chapter on the
    Options pattern. We register our options class, the validator, and create an endpoint.When
    we call the endpoint, we get the following result:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个关于选项模式的章节之后，前面的代码可以说是再正常不过了。我们注册了选项类、验证器并创建了一个端点。当我们调用端点时，我们得到以下结果：
- en: '[PRE81]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As expected, the application failed to start because the validation of the
    `MyOptions` class failed. One difference is that we have two combined error messages
    instead of one.As a reference, a validator doing the same without using the `ValidateOptionsResultBuilder`
    type would look like this:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，应用程序未能启动，因为 `MyOptions` 类的验证失败。一个不同之处在于，我们有两个合并的错误消息而不是一个。作为一个参考，一个没有使用
    `ValidateOptionsResultBuilder` 类执行相同操作的验证器看起来像这样：
- en: '[PRE82]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The highlighted code represents the standard process which get replaced by the
    use of the `ValidateOptionsResultBuilder` type in the `SimpleMyOptionsValidator`
    class.This concludes our project. Nothing very complex, yet it is a nice addition
    to help accumulate multiple error messages. On top of that, the `ValidateOptionsResultBuilder`
    type can also accumulate `ValidationResult` and `ValidateOptionsResult` objects
    which can lead to more complex systems like collecting results from multiple validators.
    I’ll let you fiddle with this one.Let’s recap this chapter before jumping into
    ASP.NET Core logging.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码代表了标准流程，在 `SimpleMyOptionsValidator` 类中使用 `ValidateOptionsResultBuilder`
    类型时会被替换。这标志着我们项目的结束。虽然没有什么特别复杂的，但它是一个很好的补充，有助于累积多个错误消息。除此之外，`ValidateOptionsResultBuilder`
    类型还可以累积 `ValidationResult` 和 `ValidateOptionsResult` 对象，这可能导致更复杂的系统，例如从多个验证器收集结果。我会让你自己尝试这个。在我们跳入
    ASP.NET Core 日志记录之前，让我们回顾一下本章内容。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter explored the Options pattern, a powerful tool allowing us to configure
    our ASP.NET Core applications. It enables us to change the application without
    altering the code. The capability even allows the application to reload the options
    at runtime when a configuration file is updated without downtime. We learned to
    load settings from multiple sources, with the last loaded source overriding previous
    values. We discovered the following interfaces to access settings and learned
    that the choice of interface influences the lifetime of the options object:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了选项模式（Options pattern），这是一种强大的工具，使我们能够配置我们的 ASP.NET Core 应用程序。它使我们能够在不更改代码的情况下更改应用程序。这种能力甚至允许应用程序在配置文件更新时在运行时重新加载选项，而无需停机。我们学习了从多个来源加载设置，并且最后加载的来源将覆盖之前的值。我们发现以下接口可以访问设置，并了解到接口的选择会影响选项对象的生存期：
- en: '`IOptionsMonitor<TOptions>`'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptionsMonitor<TOptions>`'
- en: '`IOptionsFactory<TOptions>`'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptionsFactory<TOptions>`'
- en: '`IOptionsSnapshot<TOptions>`'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptionsSnapshot<TOptions>`'
- en: '`IOptions<TOptions>`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOptions<TOptions>`'
- en: 'We delved into manually configuring options in the composition root and loading
    them from a settings file. We also learned how to inject options into a class
    and configure multiple instances of the same options type using named options.
    We explored encapsulating the configuration logic into classes to apply the single
    responsibility principle (SRP). We achieved this by implementing the following
    interfaces:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了在组合根中手动配置选项以及从设置文件中加载它们的方法。我们还学习了如何将选项注入到类中，并使用命名选项配置相同选项类型的多个实例。我们探讨了将配置逻辑封装到类中以应用单一职责原则（SRP）。我们通过实现以下接口实现了这一点：
- en: '`IConfigureOptions<TOptions>`'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IConfigureOptions<TOptions>`'
- en: '`IConfigureNamedOptions<TOptions>`'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IConfigureNamedOptions<TOptions>`'
- en: '`IPostConfigureOptions<TOptions>`'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPostConfigureOptions<TOptions>`'
- en: 'We also learned that we could mix configuration classes with inline configurations
    using the `Configure` and `PostConfigure` methods and that the registration order
    of configurators is crucial as they are executed in order of registration.We also
    delved into options validation. We learned that the frequency at which options
    objects are validated depends on the lifetime of the options interface used. We
    also discovered the concept of eager validation, which allows us to catch incorrectly
    configured options classes at startup time. We learned to use data annotations
    to decorate our options with validation attributes such as `[Required]`. We can
    create validation classes to validate our options objects for more complex scenarios.
    Those validation classes must implement the `IValidateOptions<TOptions>` interface.
    We also learned how to bridge other validation frameworks like *FluentValidation*
    to complement the out-of-the-box functionalities or accommodate your taste for
    a different validation framework.We explored a workaround allowing us to inject
    options classes directly into their consumers. Doing this allows us to control
    their lifetime from the composition root instead of letting the types consuming
    them control their lifetime. This approach aligns better with dependency injection
    and Inversion of Control principles. That also makes testing the classes easier.Finally,
    we looked at the .NET 8 code generators that change how the options are handled
    but do not impact how we use the Options pattern. We also explored the `ValidateOptionsResultBuilder`
    type, also introduced in .NET 8.The Options pattern helps us adhere to the SOLID
    principles, as illustrated next:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，我们可以使用 `Configure` 和 `PostConfigure` 方法将配置类与内联配置混合使用，并且配置器的注册顺序至关重要，因为它们是按照注册顺序执行的。我们还深入研究了选项验证。我们了解到，选项对象验证的频率取决于所使用的选项接口的生命周期。我们还发现了急切验证的概念，它允许我们在启动时捕获配置错误的选项类。我们学会了使用数据注释来用验证属性（如
    `[Required]`）装饰我们的选项。我们可以创建验证类来验证我们的选项对象，以处理更复杂的情况。这些验证类必须实现 `IValidateOptions<TOptions>`
    接口。我们还学会了如何将其他验证框架（如 *FluentValidation*）桥接起来，以补充开箱即用的功能或适应你对不同验证框架的喜好。我们探索了一个解决方案，允许我们直接将选项类注入到它们的消费者中。这样做允许我们从组合根处控制它们的生命周期，而不是让消费它们的类型控制它们的生命周期。这种方法与依赖注入和反转控制原则更一致。这也使得测试这些类更容易。最后，我们研究了
    .NET 8 代码生成器，它改变了处理选项的方式，但不会影响我们使用选项模式的方式。我们还探索了在 .NET 8 中引入的 `ValidateOptionsResultBuilder`
    类型。选项模式帮助我们遵守 SOLID 原则，如下所示：
- en: '**S**: The Options pattern divides managing settings into multiple pieces where
    each has a single responsibility. Loading unmanaged settings into strongly typed
    classes is one responsibility, validating options using classes is another, and
    configuring options from multiple independent sources is one more.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 选项模式将管理设置划分为多个部分，每个部分都承担单一职责。将未管理的设置加载到强类型类中是一个职责，使用类验证选项是另一个职责，从多个独立来源配置选项又是另一个职责。'
- en: On the other hand, I find data annotations validation to mix two responsibilities
    in the options class, bending this principle. If you like data annotations, I
    don’t want to stop you from using them.
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，我发现数据注释验证在选项类中将两个职责混合在一起，违背了这一原则。如果你喜欢数据注释，我不希望你因为使用它们而受阻。
- en: ''
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Data annotations can seem to improve development speed but make testing validation
    rules harder. For example, testing a `Validate` method that returns a `ValidateOptionsResult`
    object is easier than attributes.
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据注释似乎可以提高开发速度，但会使测试验证规则更困难。例如，测试返回 `ValidateOptionsResult` 对象的 `Validate` 方法比属性更容易。
- en: '**O**: The different `IOptions*<Toptions>` interfaces break this principle
    by forcing the consumer to decide what lifetime and capabilities the options should
    have. To change the lifetime of a dependency, we must update the consuming class
    when using those interfaces. On the other hand, we explored an easy and flexible
    workaround that allows us to bypass this issue for many scenarios and inject the
    options directly, inverting the dependency flow again, leading to open/closed
    consumers.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 不同的 `IOptions*<Toptions>` 接口通过迫使消费者决定选项应该具有什么生命周期和功能来违反这一原则。要更改依赖项的生命周期，我们必须在使用这些接口时更新消费类。另一方面，我们探索了一个简单且灵活的解决方案，允许我们在许多场景中绕过这个问题，直接注入选项，再次反转依赖项流，导致开放/关闭消费者。'
- en: '**L**: N/A'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: 无内容'
- en: '**I**: The `IValidateOptions<TOptions>` and `IConfigureOptions<TOptions>` interfaces
    are two good examples of segregating a system into smaller interfaces where each
    has a single purpose.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：`IValidateOptions<TOptions>` 和 `IConfigureOptions<TOptions>` 接口是分离系统为更小接口的很好例子，每个接口只有一个单一的目的。'
- en: '**D**: The options framework is built around interfaces, allowing us to depend
    on abstractions.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：选项框架围绕接口构建，允许我们依赖抽象。'
- en: Again, the `IOptions*<Toptions>` interfaces are the exceptions to this. Even
    if they are interfaces, they tie us to implementation details like the options
    lifetime. In this case, I think it is more beneficial to inject the options object
    directly (a data contract) instead of those interfaces.
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次强调，`IOptions*<Toptions>` 接口是这一规则的例外。即使它们是接口，它们也使我们依赖于实现细节，如选项的生命周期。在这种情况下，我认为直接注入选项对象（一个数据契约）比注入这些接口更有益。
- en: Next, we explore .NET logging, which is another very important aspect of building
    applications; good traceability can make all the difference when observing or
    debugging applications.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索 .NET 日志记录，这是构建应用程序的另一个非常重要的方面；良好的可追溯性在观察或调试应用程序时可以起到决定性作用。
- en: Questions
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习问题：
- en: Name one interface we can use to inject a settings class.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名一个可以用来注入设置类的接口。
- en: Name the two phases the ASP.NET Core uses when configuring options.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请命名 ASP.NET Core 在配置选项时使用的两个阶段。
- en: How significant is the order in which we register configuration objects and
    inline delegates?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们注册配置对象和内联委托的顺序有多重要？
- en: Can we register multiple configuration classes?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否注册多个配置类？
- en: What is eager validation, and why should you use it?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贪婪验证是什么，为什么你应该使用它？
- en: What interface must we implement to create a validator class?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须实现哪个接口来创建一个验证类？
- en: Further reading
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build upon what we learned in the chapter:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'Options pattern in ASP.NET Core (official docs): [https://adpg.link/RTGc](https://adpg.link/RTGc)'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的选项模式（官方文档）：[https://adpg.link/RTGc](https://adpg.link/RTGc)
- en: 'Quickstart: Create an ASP.NET Core app with Azure App Configuration: [https://adpg.link/qhLV](https://adpg.link/qhLV)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速入门：使用 Azure App Configuration 创建 ASP.NET Core 应用：[https://adpg.link/qhLV](https://adpg.link/qhLV)
- en: 'Secret storage in the Production environment with Azure Key Vault: [https://adpg.link/Y5D7](https://adpg.link/Y5D7)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境中的密钥存储与 Azure Key Vault：[https://adpg.link/Y5D7](https://adpg.link/Y5D7)
- en: Answers
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: 'We can use one of the following interfaces: `IOptionsMonitor<TOptions>`, `IOptionsFactory<TOptions>`,
    `IOptionsSnapshot<TOptions>`, or `IOptions<TOptions>`.'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下接口之一：`IOptionsMonitor<TOptions>`、`IOptionsFactory<TOptions>`、`IOptionsSnapshot<TOptions>`
    或 `IOptions<TOptions>`。
- en: The configuration and the post-configuration phases.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置和后配置阶段。
- en: Configurators are executed in the order of their registration, so their order
    is crucial.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置器按照它们的注册顺序执行，因此它们的顺序至关重要。
- en: Yes, we can register as many configuration classes as we want.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，我们可以注册尽可能多的配置类。
- en: Eager validation allows catching incorrectly configured options at startup time,
    which can save you runtime issues.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贪婪验证允许在启动时捕获配置错误的选项，这可以节省运行时问题。
- en: We must implement the `IValidateOptions<TOptions>` interface.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须实现 `IValidateOptions<TOptions>` 接口。
