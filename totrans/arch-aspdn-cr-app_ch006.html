<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>5 Minimal API</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="6">5 Minimal API</h1>

<h2 data-number="6.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file24.png" style="width:10em"/></p>
<p>This chapter covers Minimal APIs, a simplified way of setting up and running .NET applications. We explore what makes Minimal Hosting and Minimal APIs a pivotal update in ASP.NET Core as we unravel the simplicity of creating APIs with less ceremony. We cover many possibilities that ASP.NET Core Minimal API brings, like how to configure, customize, and organize those endpoints.We also explore using Minimal APIs with Data Transfer Objects (DTOs), combining simplicity with effective data management to structure API contracts effectively.Inspired by other technologies, these topics bring a fresh perspective to the .NET world, allowing us to build lean and performant APIs without compromising resiliency.In this chapter, we cover the following topics:</p>
<ul>
<li>Top-level statements</li>
<li>Minimal Hosting</li>
<li>Minimal APIs</li>
<li>Using Minimal APIs with Data Transfer Objects</li>
</ul>
<p>Let’s begin with Top-level statements.</p>


<h2 data-number="6.2">Top-level statements</h2>
<p>The .NET team introduced top-level statements to the language in .NET 5 and C# 9. From that point, writing statements before declaring namespaces and other members is possible. Under the hood, the compiler emits those statements into a <code>Program.Main</code> method.With top-level statements, a minimal .NET “Hello World” console program looked like this (<code>Program.cs</code>):</p>
<div><pre><code>using System;
Console.WriteLine("Hello world!");</code></pre>
</div>
<p>Unfortunately, we still need a project to run it, so we have to create a <code>.csproj</code> file with the following content:</p>
<div><pre><code>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;
        &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;/PropertyGroup&gt;
&lt;/Project&gt;</code></pre>
</div>
<p>From there, we can use the .NET CLI to <code>dotnet run</code> the application, and it will output the following in the console before the program terminates:</p>
<div><pre><code>Hello world!</code></pre>
</div>
<p>On top of such statements, we can also declare other members, like classes, and use them in our application. However, we must declare classes at the end of the top-level code.</p>
<blockquote>
<p>Be aware that the top-level statement code is not part of any namespace, and creating classes in a namespace is recommended, so you should limit the number of declarations done in the <code>Program.cs</code> file to what is internal to its inner workings, if anything.</p>
</blockquote>
<p>Top-level statements are great for getting started with C#, writing code samples, and cutting out boilerplate code.</p>
<blockquote>
<p>The highlighted line of the preceding C# code (<code>using System;</code>) is unnecessary when the <em>implicit usings</em> feature is enabled, which is the default in .NET 6+ projects. The templates add the following line to the <code>.csproj</code> file:</p>
</blockquote>
<pre><code>&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;</code></pre>
<p>Next, we explore the minimal hosting model built using top-level statements.</p>


<h2 data-number="6.3">Minimal Hosting</h2>
<p>.NET 6 introduced the minimal hosting model. It combines the <code>Startup</code> and <code>Program</code> classes into a single <code>Program.cs</code> file. It leverages top-level statements to minimize the boilerplate code necessary to bootstrap the application. It also uses <em>global using directives</em> and the <em>implicit usings</em> feature to reduce the amount of boilerplate code further. This model only requires one file with the following three lines of code to create a web application:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.Run();</code></pre>
</div>
<p>Let’s call that way leaner than before. Of course, the preceding code starts an app that does nothing, but doing the same before would have required tens of lines of code.The minimal hosting code is divided into two pieces:</p>
<ul>
<li>The <em>web application builder</em> we use to configure the application, register services, settings, environment, logging, and more (the highlighted code).</li>
<li>The <em>web application</em> we use to configure the HTTP pipeline and routes (the non-highlighted lines).</li>
</ul>
<p>That simplified model led to minimal APIs that we explore next.</p>


<h2 data-number="6.4">Minimal APIs</h2>
<p>ASP.NET Core’s Minimal APIs are built on the minimal hosting model and bring a lean approach to constructing web applications. Highly inspired by Node.js, they facilitate the development of APIs by reducing the boilerplate code. By emphasizing simplicity and performance, they enhance readability and maintainability. They are an excellent fit for microservices architecture and applications that aim to remain lean.</p>
<blockquote>
<p>You can also build large applications using Minimal APIs; the word minimal refers to their lean approach, not the type of application you can make with them.</p>
</blockquote>
<p>This minimalist approach does compromise a little on functionalities but improves flexibility and speed, ensuring you have complete control over your API’s behavior while keeping your project lean and efficient. Minimal APIs include the necessary features we need for most applications, like model binding, dependency injection, filters, and a route-to-delegate model. If you need all the features from MVC, you can still opt to use MVC. You can even use both; this is not one or the other.</p>
<blockquote>
<p>We explore the Model-View-Controller (MVC) pattern in <em>Chapter 6</em>, <em>MVC</em>.</p>
</blockquote>
<p>Let’s have a look at how to map routes next.</p>

<h3 data-number="6.4.1">Map route-to-delegate</h3>
<p>How does it work? Minimal APIs bring multiple extension methods to configure the HTTP pipeline and configure endpoints. We can use those methods to map a route (a URL pattern) to a <code>RequestDelegate</code> delegate.We can use the following methods to map different HTTP methods:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>MapGet</code></td>
<td>Maps a <code>GET</code> request to a <code>RequestDelegate</code> .</td>
</tr>
<tr class="odd">
<td><code>MapPost</code></td>
<td>Maps a <code>POST</code> request to a <code>RequestDelegate</code> .</td>
</tr>
<tr class="even">
<td><code>MapPut</code></td>
<td>Maps a <code>PUT</code> request to a <code>RequestDelegate</code> .</td>
</tr>
<tr class="odd">
<td><code>MapDelete</code></td>
<td>Maps a <code>DELETE</code> request to a <code>RequestDelegate</code> .</td>
</tr>
<tr class="even">
<td><code>MapMethods</code></td>
<td>Maps a route pattern and multiple HTTP methods to a <code>RequestDelegate</code> .</td>
</tr>
<tr class="odd">
<td><code>Map</code></td>
<td>Maps a route pattern to a <code>RequestDelegate</code> .</td>
</tr>
<tr class="even">
<td><code>MapFallback</code></td>
<td>Maps a fallback <code>RequestDelegate</code> which runs when no other routes match.</td>
</tr>
<tr class="odd">
<td><code>MapGroup</code></td>
<td>Allows configuring a route pattern and properties that apply to all endpoints defined under that group.</td>
</tr>
</tbody>
</table>
Table 5.1: Map route-to-delegate extension methods.
<p>Here’s a minimal GET example:</p>
<div><pre><code>app.MapGet("minimal-endpoint-inline", () =&gt; "GET!");</code></pre>
</div>
<p>When executing the program, navigating to the <code>/minimal-endpoint-inline</code> URI routes the request to the registered <code>RequestDelegate</code> (highlighted code), which outputs the following string:</p>
<div><pre><code>GET!</code></pre>
</div>
<p>As simple as that, we can route requests to delegates and create endpoints.</p>
<blockquote>
<p>On top of registering endpoints, we can also register middleware like any other ASP.NET Core application. Moreover, the built-in middlewares, like authentication and CORS, work the same with Minimal APIs.</p>
</blockquote>
<p>Next, we explore ways to configure endpoints so we can create better APIs than an endpoint returning a literal string.</p>


<h3 data-number="6.4.2">Configuring endpoints</h3>
<p>Now that we know that with minimal APIs, we map routes to delegates and that we have learned of a few methods to do that, let’s explore how to register the delegates:</p>
<ul>
<li>Inline, as with the preceding example.</li>
<li>Using a method.</li>
</ul>
<p>To declare the delegate inline, we can do the following:</p>
<div><pre><code>app.MapGet("minimal-endpoint-inline", () =&gt; "GET!");</code></pre>
</div>
<p>To use a method, we can do the following:</p>
<div><pre><code>app.MapGet("minimal-endpoint-method", MyMethod);
void MyMethod() { }</code></pre>
</div>
<blockquote>
<p>When enabled, ASP.NET Core registers the class name that contains the method with the <code>ApiExplorer</code> as a tag. We dig deeper into metadata further in the chapter.</p>
</blockquote>
<p>All the concepts we explore in this chapter apply to both ways of registering delegates. Let’s start by studying how to input data in our endpoints.</p>

<h4 data-number="6.4.2.1">Inputs</h4>
<p>An endpoint rarely has no parameter (no input value). Minimal APIs, like MVC, support a wide variety of binding sources. A binding source represents the conversion from the HTTP request into a strongly typed C# object, inputted as a parameter. Most of the parameter binding happens implicitly, but in case you need to bind a parameter explicitly, here are the supported binding sources:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Source</strong></td>
<td><strong>Attribute</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>Route</code></td>
<td><code>[FromRoute]</code></td>
<td>Binds the route value that matches the name of the parameter.</td>
</tr>
<tr class="odd">
<td><code>Query</code></td>
<td><code>[FromQuery]</code></td>
<td>Binds the query string value that matches the name of the parameter.</td>
</tr>
<tr class="even">
<td><code>Header</code></td>
<td><code>[FromHeader]</code></td>
<td>Binds the HTTP header value that matches the name of the parameter.</td>
</tr>
<tr class="odd">
<td><code>Body</code></td>
<td><code>[FromBody]</code></td>
<td>Binds the JSON body of the request to the parameter’s type.</td>
</tr>
<tr class="even">
<td><code>Form</code></td>
<td><code>[FromForm]</code></td>
<td>Binds the form value that matches the name of the parameter.</td>
</tr>
<tr class="odd">
<td><code>Services</code></td>
<td><code>[FromServices]</code></td>
<td>Inject the service from the ASP.NET Core dependency container.</td>
</tr>
<tr class="even">
<td><code>Custom</code></td>
<td><code>[AsParameters]</code></td>
<td>Binds the form values to a type. The matches happen between the form keys and the properties' names.</td>
</tr>
</tbody>
</table>
Table 5.2: supported binding sources
<p>Next is a demo where we implicitly bind the <code>id</code> parameter from the route (highlighted code) to a parameter in the delegate:</p>
<div><pre><code>app.MapGet(
    "minimal-endpoint-input-route-implicit/{id}", 
    (int id) =&gt; $"The id was {id}."
);</code></pre>
</div>
<p>In most cases, the bindings work implicitly. However, you can explicitly bind the delegate’s parameters like this:</p>
<div><pre><code>app.MapGet(
    "minimal-endpoint-input-route-explicit/{id}",
    ([FromRoute] int id) =&gt; $"The id was {id}."
);</code></pre>
</div>
<p>We can also implicitly inject dependencies into our delegates and even mix that with a route parameter like this:</p>
<div><pre><code>app.MapGet(
    "minimal-endpoint-input-service/{value}",
    (string value, SomeInternalService service)
        =&gt; service.Respond(value)
);
public class SomeInternalService {
    public string Respond(string value)
        =&gt; $"The value was {value}";
}</code></pre>
</div>
<p>Following this pattern opens endless possibilities to input data into our endpoints.</p>
<blockquote>
<p>If you are unfamiliar with Dependency Injection (DI), we explore DI more in-depth in <em>Chapter 8</em>, <em>Dependency Injection</em>. Meanwhile, remember that we can bind objects to parameters, whether they are a DTO or a service.</p>
</blockquote>
<p>On top of that, ASP.NET Core provides us with a few special types, which we explore next.</p>

<h5 data-number="6.4.2.1.1">Special types</h5>
<p>We can inject the following objects into our delegates as parameters, and ASP.NET Core manages them for us:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Class</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>HttpContext</code></td>
<td><p>The <code>HttpContext</code> encompasses all the current HTTP request and response details.</p>
<p>The <code>HttpContext</code> exposes all the other special types we are exploring here, so if you need more than one, you can inject the <code>HttpContext</code> directly to reduce the number of parameters.</p></td>
</tr>
<tr class="odd">
<td><code>HttpRequest</code></td>
<td>We can use the <code>HttpRequest</code> to do basic HTTP operations on the current request, like query the parameters manually and bypass the ASP.NET Core data-binding mechanism. Same as the <code>HttpContext.Request</code> property.</td>
</tr>
<tr class="even">
<td><code>HttpResponse</code></td>
<td>Like the <code>HttpRequest</code> , we can leverage the <code>HttpResponse</code> object to execute manual operations on the HTTP response, like writing directly to the response stream, managing HTTP headers manually, etc. Same as the <code>HttpContext.Response</code> property.</td>
</tr>
<tr class="odd">
<td><code>CancellationToken</code></td>
<td>Passing a cancellation token to an asynchronous operation is a recommended practice. In this case, it allows canceling the operation when the request is canceled. Same as the <code>HttpContext.RequestAborted</code> property.</td>
</tr>
<tr class="even">
<td><code>ClaimsPrincipal</code></td>
<td>To access the current user, we can inject a <code>ClaimsPrincipal</code> instance. Same as the <code>HttpContext.User</code> property.</td>
</tr>
</tbody>
</table>
Tabel 5.3: special HTTP types
<p>Here’s an example where two endpoints write to the response stream, one using the <code>HttpContext</code> and the other the <code>HttpResponse</code> object:</p>
<div><pre><code>app.MapGet(
    "minimal-endpoint-input-HttpContext/",
    (HttpContext context)
        =&gt; context.Response.WriteAsync("HttpContext!")
);
app.MapGet(
    "minimal-endpoint-input-HttpResponse/",
    (HttpResponse response)
        =&gt; response.WriteAsync("HttpResponse!")
);</code></pre>
</div>
<p>We can treat those special types like any other bindings and seamlessly integrate them with other types, such as route values and services.We cover one last piece of data-binding next.</p>


<h5 data-number="6.4.2.1.2">Custom binding</h5>
<p>We can manually bind data from the request to an instance of a custom class. We can achieve this in the following ways:</p>
<ul>
<li>Create a static <code>TryParse</code> method that parses a string from a route, query, or header value.</li>
<li>Create a static <code>BindAsync</code> method that directly controls the binding process using the <code>HttpContext</code>.</li>
</ul>
<p>We must write those static methods in the class we intend to create using the HTTP request’s data. We explore those two scenarios next.</p>

<h6 data-number="6.4.2.1.2.1">Manual parsing</h6>
<p>The <code>TryParse</code> method takes a string and an <code>out</code> parameter of the type itself. The framework uses that method to parse a value into the desired type.The parsing API supports the implementation of one of the following methods:</p>
<div><pre><code>public static bool TryParse(string value, TSelf out result);
public static bool TryParse(string value, IFormatProvider provider, TSelf out result);</code></pre>
</div>
<blockquote>
<p>Implementing the <code>IParsable&lt;TSelf&gt;</code> interface provides the appropriate <code>TryParse</code> method.</p>
</blockquote>
<p>Here is an example that parses latitude and longitude coordinates:</p>
<div><pre><code>app.MapGet(
    "minimal-endpoint-input-Coordinate/",
    (Coordinate coordinate) =&gt; coordinate
);
public class Coordinate : IParsable&lt;Coordinate&gt;
{
    public double Latitude { get; set; }
    public double Longitude { get; set; }
    public static Coordinate Parse(
        string value, 
        IFormatProvider? provider)
    {
        if (TryParse(value, provider, out var result))
        {
            return result;
        }
        throw new ArgumentException(
            "Cannot parse the value into a Coordinate.",
            nameof(value)
        );
    }
    public static bool TryParse(
        [NotNullWhen(true)] string? s,
        IFormatProvider? provider,
        [MaybeNullWhen(false)] out Coordinate result)
    {
        var segments = s?.Split(
            ',',
            StringSplitOptions.TrimEntries |
            StringSplitOptions.RemoveEmptyEntries
        );
        if (segments?.Length == 2)
        {
            var latitudeIsValid = double.TryParse(
                segments[0],
                out var latitude
            );
            var longitudeIsValid = double.TryParse(
                segments[1],
                out var longitude
            );
            if (latitudeIsValid &amp;&amp; longitudeIsValid)
            {
                result = new() {
                    Latitude = latitude,
                    Longitude = longitude
                };
                return true;
            }
        }
        result = null;
        return false;
    }
}</code></pre>
</div>
<p>In the preceding code, the endpoint returns a JSON representation of the <code>Coordinate</code> class, while the <code>TryParse</code> method parses the input string into a <code>Coordinate</code> object.</p>
<blockquote>
<p>The <code>Parse</code> method of the <code>Coordinate</code> class comes from the <code>IParsable&lt;TSelf&gt;</code> interface and is not needed for model binding.</p>
</blockquote>
<p>For example, if we request the following URI:</p>
<div><pre><code>/minimal-endpoint-input-Coordinate?coordinate=45.501690%2C%20-73.567253</code></pre>
</div>
<p>The endpoint returns:</p>
<div><pre><code>{
  "latitude": 45.50169,
  "longitude": -73.567253
}</code></pre>
</div>
<p>Parsing a string into an object is a viable choice for simple scenarios. However, more complex scenarios require another technique that we explore next.</p>


<h6 data-number="6.4.2.1.2.2">Manual binding</h6>
<p>The <code>BindAsync</code> method takes an <code>HttpContext</code> and a <code>ParameterInfo</code> parameter and returns a <code>ValueTask&lt;TSelf&gt;</code> where <code>TSelf</code> is the type we are writing data binding for. The <code>HttpContext</code> represents the source of the data (the HTTP request), and the <code>ParameterInfo</code> represents the delegate’s parameter, from which we could want to know something, like its name.The data-binding API supports the implementation of one of the following methods:</p>
<div><pre><code>public static ValueTask&lt;TSelf?&gt; BindAsync(HttpContext context, ParameterInfo parameter);
public static ValueTask&lt;TSelf?&gt; BindAsync(HttpContext context);</code></pre>
</div>
<blockquote>
<p>Implementing the <code>IBindableFromHttpContext&lt;TSelf&gt;</code> interface provides the appropriate <code>BindAsync</code> method.</p>
</blockquote>
<p>Here is an example that binds a <code>Person</code> from the HTTP request’s query parameters:</p>
<div><pre><code>app.MapGet(
    "minimal-endpoint-input-Person/",
    (Person person) =&gt; person
);
public class Person : IBindableFromHttpContext&lt;Person&gt;
{
    public required string Name { get; set; }
    public required DateOnly Birthday { get; set; }
    public static ValueTask&lt;Person?&gt; BindAsync(
        HttpContext context,
        ParameterInfo parameter)
    {
        var name = context.Request.Query["name"].Single();
        var birthdayIsValid = DateOnly.TryParse(
            context.Request.Query["birthday"],
            out var birthday
        );
        if (name is not null &amp;&amp; birthdayIsValid) {
            var person = new Person() {
                Name = name,
                Birthday = birthday
            };
            return ValueTask.FromResult(person)!;
        }
        return ValueTask.FromResult(default(Person));
    }
}</code></pre>
</div>
<p>The preceding code returns a JSON representation of the person. For example, if we request the following URI:</p>
<div><pre><code>/minimal-endpoint-input-Person?name=John%20Doe&amp;birthday=2023-06-14</code></pre>
</div>
<p>The endpoint returns:</p>
<div><pre><code>{
  "name": "John Doe",
  "birthday": "2023-06-14"
}</code></pre>
</div>
<p>As we can see, the <code>BindAsync</code> method is way more powerful than the <code>TryParse</code> method because we can access a broader range of options using the <code>HttpContext</code>, allowing us to cover complex use cases.However, in this case, we could have leveraged the <code>[AsParameters]</code> attribute to achieve the same result and get the data from the query without needing to write the data-binding code manually. What a great opportunity to explore this attribute; here’s the updated version of the same code:</p>
<div><pre><code>app.MapGet(
    "minimal-endpoint-input-Person2/",
    ([AsParameters] Person2 person) =&gt; person
);
public class Person2
{
    public required string Name { get; set; }
    public required DateOnly Birthday { get; set; }
}</code></pre>
</div>
<p>That’s it; the <code>AsParameters</code> attribute did the work for us!Now that we covered reading the input values from different places in the HTTP request, it is time to explore how to output results.</p>




<h4 data-number="6.4.2.2">Outputs</h4>
<p>There are several ways to output data from our delegates:</p>
<ul>
<li>Return a serializable object.</li>
<li>Return an <code>IResult</code> implementation.</li>
<li>Return a <code>Results&lt;TResult1, TResult2, …, TResultN&gt;</code> where the <code>TResult</code> generic parameters represent the different <code>IResult</code> implementation the endpoint can return.</li>
</ul>
<p>We explore those possibilities next.</p>

<h5 data-number="6.4.2.2.1">Serializable object</h5>
<p>The first is to return a serializable object, as we did in the previous section about inputs. ASP.NET Core serializes the object into a JSON string and sets the <code>Content-Type</code> header to <code>application/json</code>. This is the easiest way to do it but also the less flexible.For example, the following code:</p>
<div><pre><code>app.MapGet(
    "minimal-endpoint-output-coordinate/",
    () =&gt; new Coordinate {
        Latitude = 43.653225,
        Longitude = -79.383186
    }
);</code></pre>
</div>
<p>Outputs the following JSON string:</p>
<div><pre><code>{
  "latitude": 43.653225,
  "longitude": -79.383186
}</code></pre>
</div>
<p>The problem with this approach is that we don’t control the status code, nor can we return multiple different results from the endpoint. For example, if the endpoint returns <code>200 OK</code> in one case and <code>404 Not Found</code> in another. To help us with this, we explore the <code>IResult</code> abstraction next.</p>


<h5 data-number="6.4.2.2.2">IResult</h5>
<p>The next option is to return the <code>IResult</code> interface. We can leverage the <code>Results</code> or <code>TypedResults</code> classes from the <code>Microsoft.AspNetCore.Http</code> namespace to do that.</p>
<blockquote>
<p>I recommend defaulting to using <code>TypedResults</code>, which .NET 7 introduced.</p>
</blockquote>
<p>The main difference between the two is that the methods in the <code>Results</code> class return <code>IResult</code>, while those in <code>TypedResults</code> return a typed implementation of the <code>IResult</code> interface. This difference may sound insignificant, but it changes everything regarding discoverability by the API Explorer. The API Explorer can’t automatically discover the API contract of the former, while it can for the latter. This is possible because the compiler can infer the return type, but it creates challenges when returning more than one result type.</p>
<blockquote>
<p>This choice impacts the amount of work you’ll have to put into getting well-crafted OpenAPI specifications automatically (or not so automatically).</p>
</blockquote>
<p>The following two endpoints explicitly state the result is 200 OK, one with each class:</p>
<div><pre><code>app.MapGet(
    "minimal-endpoint-output-coordinate-ok1/",
    () =&gt; Results.Ok(new Coordinate {
        Latitude = 43.653225,
        Longitude = -79.383186
    })
);
app.MapGet(
    "minimal-endpoint-output-coordinate-ok2/",
    () =&gt; TypedResults.Ok(new Coordinate {
        Latitude = 43.653225,
        Longitude = -79.383186
    })
);</code></pre>
</div>
<p>When looking at the generated OpenAPI specifications, the first endpoint has no return value, while the other has a <code>Coordinate</code> definition mimicking our C# class. Next, we dig deeper into the <code>TypedResults</code> class.</p>


<h5 data-number="6.4.2.2.3">Typed results</h5>
<p>We can use the methods of the <code>TypedResults</code> class to generate strongly-typed outputs. They allow us to control the output while informing ASP.NET Core of the specifics, like the status code and return type.</p>
<blockquote>
<p>Please note that for the sake of simplicity, I've omitted variants and overloads, focusing solely on the fundamental of each method in the tables.</p>
</blockquote>
<p>Let’s start with the successful status code, where the <code>200 OK</code> status code is most likely the most common:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>Accepted</code></td>
<td>Produces a <code>202 Accepted</code> response, indicating the beginning of an asynchronous process.</td>
</tr>
<tr class="odd">
<td><code>Created</code></td>
<td>Produces a <code>201 Created</code> response, indicating the system created the entity, the location of the entity, and the entity itself.</td>
</tr>
<tr class="even">
<td><code>Ok</code></td>
<td>Produces a <code>200 OK</code> response, indicating the operation was successful.</td>
</tr>
</tbody>
</table>
Table 5.4: TypedResults successful status code methods.
<p>On top of the successes, we must know how to tell clients about the errors. For example, the <code>400 Bad Request</code> and <code>404 Not Found</code> are very common to point out the issues with the request. The following table contains methods to assist in indicating such issues to the clients:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>BadRequest</code></td>
<td>Produces a <code>400 Bad Request</code> response, indicating an issue with the client request, often a validation error.</td>
</tr>
<tr class="odd">
<td><code>Conflict</code></td>
<td>Produces a <code>409 Conflict</code> response, indicating a conflict occurred when processing the request, often a concurrency error.</td>
</tr>
<tr class="even">
<td><code>NotFound</code></td>
<td>Produces a <code>404 Not Found</code> response, indicating the resource was not found.</td>
</tr>
<tr class="odd">
<td><code>Problem</code></td>
<td>Produces a response adhering to the <em>Problem Details</em> structure defined by <strong>RFC7807</strong> , providing a standardized encapsulation of the error. We can modify the status code, which defaults to a <code>500 Internal Server Error</code> .</td>
</tr>
<tr class="even">
<td><code>UnprocessableEntity</code></td>
<td>Produces a <code>422 Unprocessable Content</code> response, indicating that while the server comprehends the request's content type and the syntax is correct, it cannot process the instructions or the entity.</td>
</tr>
<tr class="odd">
<td><code>ValidationProblem</code></td>
<td>Produces a <code>400 Bad Request</code> response adhering to the <em>Problem Details</em> structure defined by <strong>RFC7807</strong> . We can use this method to communicate input validation problems to the client.</td>
</tr>
</tbody>
</table>
Table 5.5: TypedResults problematic status code.
<blockquote>
<p>Leveraging the <em>Problem Details</em> structure improves the interoperability of our API by choosing a standard instead of crafting a custom way of returning our API errors.</p>
</blockquote>
<p>It is rarer in APIs than with conventional web applications to send redirections to clients, yet, we can redirect the clients to another URL with one of the following methods when needed:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>LocalRedirect</code></td>
<td><p>Produces a <code>301 Moved Permanently</code>, <code>302 Found</code>, <code>307 Temporary Redirect</code>, or <code>308 Permanent Redirect</code> based on the specified arguments.</p>
<p>This method throws an exception at runtime if the URL is not local, which is an excellent option to ensure dynamically generated URLs are not sending users away. For example, when the URL is composed using user inputs.</p></td>
</tr>
<tr class="odd">
<td><code>Redirect</code></td>
<td>Produces a <code>301 Moved Permanently</code> , <code>302 Found</code> , <code>307 Temporary Redirect</code> , or <code>308 Permanent Redirect</code> based on the specified arguments.</td>
</tr>
</tbody>
</table>
Table 5.6: TypedResults redirection status code.
<p>Sending files to the client is another helpful feature; for example, the API could protect the files using authorization. The following table showcases a few helper methods to send files to the client:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>File</code></td>
<td><p>Writes the file content to the response stream.</p>
<p>The <code>File</code> methods are aliases for the <code>Bytes</code> and <code>Stream</code> methods. We look at those soon.</p></td>
</tr>
<tr class="odd">
<td><code>PhysicalFile</code></td>
<td><p>Writes the content of a physical file to the response using an absolute or relative path.</p>
<p>Caution: Do not expose this method to raw user inputs because it can read files outside the web content root. So a malicious actor could craft a request to access restricted files.</p></td>
</tr>
<tr class="even">
<td><code>VirtualFile</code></td>
<td><p>Writes the content of a physical file to the response using an absolute or relative path.</p>
<p>This method limits the file's location to the web content root and is safer when dealing with user inputs.</p></td>
</tr>
</tbody>
</table>
Table 5.7: TypedResults methods for downloading files.
<p>On top of the methods we have explored so far, the following table lists ways to handle the content directly in its raw format. These content-handling methods can become handy when you need more control over what is happening:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>Bytes</code></td>
<td>Writes the byte-array or <code>ReadOnlyMemory&lt;byte&gt;</code> content directly to the response. It defaults to sending an <code>application/octet-stream</code> MIME Type to the client. This default behavior can be customized as needed.</td>
</tr>
<tr class="odd">
<td><code>Content</code></td>
<td>Writes the specified content <code>string</code> to the response stream. It defaults to sending a <code>text/plain</code> MIME Type to the client. This default behavior can be customized as needed.</td>
</tr>
<tr class="even">
<td><code>Json</code></td>
<td><p>Serializes the specified object to JSON. It defaults to sending an <code>application/json</code> MIME Type to the client with a <code>200 OK</code> status code. These default behaviors can be customized as needed.</p>
<p>Compared to the other methods, like the <code>Ok</code> method, the primary advantage is that it allows us to use a non-default instance of the <code>JsonSerializerOptions</code> class to configure the serialization of the response.</p></td>
</tr>
<tr class="odd">
<td><code>NoContent</code></td>
<td>Produces an empty <code>204 No Content</code> response.</td>
</tr>
<tr class="even">
<td><code>StatusCode</code></td>
<td>Produces an empty response with the specified status code.</td>
</tr>
<tr class="odd">
<td><code>Stream</code></td>
<td><p>Allows writing directly to the response stream from another <code>Stream</code>. It defaults to sending an <code>application/octet-stream</code> MIME Type to the client. This default behavior can be customized as needed.</p>
<p>This method is highly customizable, returns a <code>200 OK</code> status code by default, and supports range requests that produce a status code <code>206 Partial Content</code> or <code>416 Range Not Satisfiable</code>.</p></td>
</tr>
<tr class="even">
<td><code>Text</code></td>
<td>Writes the content string to the HTTP response. It defaults to sending a <code>text/plain</code> MIME Type to the client. This default behavior can be customized as needed, as well as the text encoding.</td>
</tr>
</tbody>
</table>
Table 5.8: TypedResults raw content handling methods.
<blockquote>
<p>The <code>application/octet-stream</code> MIME Type suggests that the response body is a file without specifying its type, which typically prompts the browser to download the file.</p>
</blockquote>
<p>Finally, we can leverage the following methods of the <code>TypedResults</code> class to create security flows. Most of these methods rely on the current implementation of the <code>IAuthenticationService</code> interface, which dictates their behavior:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>Challenge</code></td>
<td>Initiates a challenge for authentication when an unauthenticated user requests an endpoint that necessitates authentication.</td>
</tr>
<tr class="odd">
<td><code>Forbid</code></td>
<td><p>Invoke when an authenticated user tries to access a resource for which they do not have the necessary permissions.</p>
<p>By default, it produces a <code>403 Forbidden</code> response, although the behavior may vary depending on the specific authentication scheme.</p></td>
</tr>
<tr class="even">
<td><code>SignIn</code></td>
<td>Commences the sign-in process for a user, based on the specified authentication scheme.</td>
</tr>
<tr class="odd">
<td><code>SignOut</code></td>
<td>Initiates the sign-out process for the given authentication scheme.</td>
</tr>
<tr class="even">
<td><code>Unauthorized</code></td>
<td>Produces a <code>401 Unauthorized</code> response.</td>
</tr>
</tbody>
</table>
Table 5.9: TypedResults security-related methods.
<p>Now that we have covered the <code>TypedResults</code> possibilities, we explore how to return those typed results next.</p>


<h5 data-number="6.4.2.2.4">Returning multiple typed results</h5>
<p>While returning a single typed result is helpful, the capability to produce multiple results is better aligned with real-life scenarios. As we previously examined, it's possible to return multiple <code>IResult</code> objects, but we're restricted to a single typed result. This limitation arises from the compiler's inability to identify a shared interface and deduce an <code>IResult</code> return type from the typed results. Even if the compiler could, that wouldn't enhance discoverability.To overcome this limitation, .NET 7 introduced the <code>Results&lt;T1, TN&gt;</code> types, allowing us to return up to six different typed results.Here’s an example that returns <code>200 OK</code> when the random number is even and <code>209 Conflict</code> when it is odd:</p>
<div><pre><code>app.MapGet(
    "multiple-TypedResults/",
    Results&lt;Ok, Conflict&gt; ()
        =&gt; Random.Shared.Next(0, 100)  %  2  ==  0
            ? TypedResults.Ok()
            : TypedResults.Conflict()
);</code></pre>
</div>
<p>This also works with methods like this:</p>
<div><pre><code>app.MapGet(
    "multiple-TypedResults-delegate/",
    MultipleResultsDelegate
);
Results&lt;Ok, Conflict&gt; MultipleResultsDelegate()
{
    return Random.Shared.Next(0, 100) % 2 == 0
        ? TypedResults.Ok()
        : TypedResults.Conflict();
}</code></pre>
</div>
<p>Adopting this approach enhances the API Explorer's comprehension of the API, thereby allowing libraries like Swagger and Swagger UI to automatically generate more accurate and detailed API documentation.Next, we explore adding more metadata to endpoints.</p>



<h4 data-number="6.4.2.3">Metadata</h4>
<p>Sometimes, relying solely on automatic metadata is not enough. That’s why ASP.NET Core offers different helper methods to fine-tune the metadata of our endpoints. We can use most helper methods with groups and routes. In the case of a group, the metadata cascades to its children, whether it is another group or a route. However, a child can override the inherited values by changing the metadata.Here’s a partial list of helpers and their usage:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>Accepts</code></td>
<td><p>Specifies the supported request content types.</p>
<p><em>Only applicable to routes.</em></p></td>
</tr>
<tr class="odd">
<td><code>AllowAnonymous</code></td>
<td>Specifies that anonymous users can access the endpoint(s).</td>
</tr>
<tr class="even">
<td><code>CacheOutput</code></td>
<td>Adds an output caching policy to the endpoint(s).</td>
</tr>
<tr class="odd">
<td><code>DisableRateLimiting</code></td>
<td>Turns off the rate-limiting feature on the endpoint(s).</td>
</tr>
<tr class="even">
<td><code>ExcludeFromDescription</code></td>
<td>Excludes the item from the API Explorer data.</td>
</tr>
<tr class="odd">
<td><p><code>Produces</code></p>
<p><code>ProducesProblem</code></p>
<p><code>ProducesValidationProblem</code></p></td>
<td><p>Describes a response, including its type, content type, and status code.</p>
<p><em>Only applicable to routes.</em></p></td>
</tr>
<tr class="even">
<td><code>RequireAuthorization</code></td>
<td><p>Specifies that only authorized users can access the endpoint(s). We can be more granular by using one of the overloads. For example, we can specify a policy name or an <code>AuthorizationPolicy</code> instance.</p>
<p><em>You must configure authorization for this to work</em>.</p></td>
</tr>
<tr class="odd">
<td><code>RequireCors</code></td>
<td><p>Specifies that the endpoint(s) must follow a CORS policy.</p>
<p><em>You must configure CORS for this to work</em>.</p></td>
</tr>
<tr class="even">
<td><code>RequireRateLimiting</code></td>
<td><p>Adds a rate-limiting policy to the endpoint(s).</p>
<p><em>You must configure rate-limiting for this to work</em>.</p></td>
</tr>
<tr class="odd">
<td><code>WithDescription</code></td>
<td><p>Describes the route.</p>
<p>When used on a group, the description cascades to all routes within that group.</p></td>
</tr>
<tr class="even">
<td><code>WithName</code></td>
<td><p>Attributes a name to the route. We can use this name to identify the route, which must be unique.</p>
<p>For example, we can use the route name with the <code>LinkGenerator</code> class to generate the URL of that endpoint.</p></td>
</tr>
<tr class="odd">
<td><code>WithOpenApi</code></td>
<td><p>Ensure the builder adds the compatible metadata about the endpoint so tools like Swagger can generate the Open API specifications.</p>
<p>We can also use this method to configure the operation and parameters instead of the other extension methods.</p>
<p><em>You must call this method for many others to work.</em></p></td>
</tr>
<tr class="even">
<td><code>WithSummary</code></td>
<td><p>Add a summary to the route.</p>
<p>When used on a group, the summary cascades to all routes within that group.</p></td>
</tr>
<tr class="odd">
<td><code>WithTags</code></td>
<td><p>Add tags to the route.</p>
<p>When used on a group, the tags cascade to all routes within that group.</p></td>
</tr>
</tbody>
</table>
Table 5.10: Metadata helper methods.
<p>Let’s look at an example that creates a group, tags it, then ensures that all routes under that group have their metadata harvestable by SwaggerGen (the API Explorer):</p>
<div><pre><code>var metadataGroup = app
    .MapGroup("minimal-endpoint-metadata")
    .WithTags("Metadata Endpoints")
    .WithOpenApi()
;</code></pre>
</div>
<p>We can now define endpoints on that group using the <code>metadataGroup</code> as if it was the <code>app</code> variable. Next, we create an endpoint that we name <code>"Named Endpoint"</code> and describe it using the <code>WithOpenApi</code> method, including deprecating it:</p>
<div><pre><code>const string NamedEndpointName = "Named Endpoint";
metadataGroup
    .MapGet(
        "with-name",
        () =&gt; $"Endpoint with name '{NamedEndpointName}'."
    )
    .WithName(NamedEndpointName)
    .WithOpenApi(operation =&gt; {
        operation.Description = "An endpoint that returns its name.";
        operation.Summary = $"Endpoint named '{NamedEndpointName}'.";
        operation.Deprecated = true;
        return operation;
    })
;</code></pre>
</div>
<p>Next, we generate a URL based on the preceding named endpoint, we describe the endpoint using the <code>WithDescription</code> method and add metadata to the <code>endpointName</code> parameter, including an example. Once again we leverage the <code>WithOpenApi</code> method:</p>
<div><pre><code>metadataGroup
    .MapGet(
        "url-of-named-endpoint/{endpointName?}",
        (string? endpointName, LinkGenerator linker) =&gt; {
            var name = endpointName ?? NamedEndpointName;
            return new {
                name,
                uri = linker.GetPathByName(name)
            };
        }
    )
    .WithDescription("Return the URL of the specified named endpoint.")
    .WithOpenApi(operation =&gt; {
        var endpointName = operation.Parameters[0];
        endpointName.Description = "The name of the endpoint to get the URL for.";
        endpointName.AllowEmptyValue = true;
        endpointName.Example = new OpenApiString(NamedEndpointName);
        return operation;
    })
;</code></pre>
</div>
<p>When requesting the preceding endpoint, we get the URL of the specified route. By default, we get the URL of the <code>"Named Endpoint"</code> route—our only named route—in the following JSON format:</p>
<div><pre><code>{
  "name": "Named Endpoint",
  "uri": "/minimal-endpoint-metadata/with-name"
}</code></pre>
</div>
<p>As a last example, we can exclude a route from the metadata with the <code>ExcludeFromDescription</code> method:</p>
<div><pre><code>metadataGroup
    .MapGet("excluded-from-open-api", () =&gt; { })
    .ExcludeFromDescription()
;</code></pre>
</div>
<p>When looking at the Swagger UI, we can see the following section representing the group we just defined:</p>
<figure>
<img alt="Figure 5.1: a screenshot of the Swagger UI “Metadata Endpoints” route group." src="img/file25.png"/><figcaption aria-hidden="true">Figure 5.1: a screenshot of the Swagger UI “Metadata Endpoints” route group.</figcaption>
</figure>
<p>We can see two endpoints in the preceding screenshot and, as expected, the third endpoint was excluded.The first route is marked as deprecated and shows a summary. When we open it, we see a warning, a description, no parameters, and one 200 OK response with a mime-type <code>text/plain</code>.</p>
<blockquote>
<p>I omitted to add a screenshot of the Swagger UI for the first endpoint since it does not add much and would be hard to read. It is better to run the <code>Minimal.API</code> program and navigate to the <code>/swagger/index.html</code> URL instead.</p>
</blockquote>
<p>The second route does not have a summary, but when we open it, we have a description. The metadata we added for the <code>endpointName</code> parameter is there, and most interestingly, the example became the default value:</p>
<figure>
<img alt="Figure 5.2: a screenshot of the Swagger UI showcasing the metadata of the endpointName parameter." src="img/file26.png"/><figcaption aria-hidden="true">Figure 5.2: a screenshot of the Swagger UI showcasing the metadata of the <code>endpointName</code> parameter.</figcaption>
</figure>
<p>Swagger UI can become very handy for manually calling our API during development or leveraging other Open API compatible tools. For example, we could generate code based on the Open API specs, like a TypeScript client.Next, we explore how to configure the Minimal API JSON serializer.</p>


<h4 data-number="6.4.2.4">Configuring JSON serialization</h4>
<p>In ASP.NET Core, we can customize the JSON serializer globally or create a new one for a specific scenario.To change the default serializer behaviors, we can invoke the <code>ConfigureHttpJsonOptions</code> method, which configures the <code>JsonOptions</code> object. From there, we can change the options like this:</p>
<div><pre><code>builder.Services.ConfigureHttpJsonOptions(options =&gt; {
    options.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.KebabCaseLower;
});</code></pre>
</div>
<p>With the preceding code in the <code>Program.cs</code> file, we tell the serializer to serialize the property name following a <code>lower-case-kebab</code> naming convention. Here is an example:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Endpoint</strong></td>
<td><strong>Response</strong></td>
</tr>
<tr class="even">
<td><p>jsonGroup.MapGet(</p>
<p>"kebab-person/",</p>
<p>() =&gt; new {</p>
<p>FirstName = "John",</p>
<p>LastName = "Doe"</p>
<p>}</p>
<p>);</p></td>
<td><p>{</p>
<p>"first-name": "John",</p>
<p>"last-name": "Doe"</p>
<p>}</p></td>
</tr>
</tbody>
</table>
Table 5.11: Showcasing the output of the JsonNamingPolicy.KebabCaseLower policy.
<p>We can achieve the same for specific endpoints by using the <code>TypedResults.Json</code> method and specifying an instance of <code>JsonSerializerOptions</code>. The following code accomplishes the same outcome while preserving the default serialization options:</p>
<div><pre><code>var kebabSerializer = new JsonSerializerOptions(JsonSerializerDefaults.Web)
{
    PropertyNamingPolicy = JsonNamingPolicy.KebabCaseLower
};
jsonGroup.MapGet(
    "kebab-person/",
    () =&gt; TypedResults.Json(new {
        FirstName = "John",
        LastName = "Doe"
    }, kebabSerializer)
);</code></pre>
</div>
<p>I highlighted the changes between this code and the previous example. First, we create an instance of the <code>JsonSerializerOptions</code> class. To simplify the configuration, we start with the default web serialization values by passing the <code>JsonSerializerDefaults.Web</code> argument to the constructor. Then, in the object initializer, we set the value of the <code>PropertyNamingPolicy</code> property to <code>JsonNamingPolicy.KebabCaseLower</code>, which end up with the same result as before. Finally, to use our options, we pass the <code>kebabSerializer</code> variable as the second argument of the <code>TypedResults.Json</code> method.</p>

<h5 data-number="6.4.2.4.1">Serializing enums as string</h5>
<p>I often find myself changing a configuration to output the string representation of an <code>enum</code> value. To do so, we must register an instance of the <code>JsonStringEnumConverter</code> class. Afterward, enums will be serialized as strings. Here is an example:</p>
<div><pre><code>var enumSerializer = new JsonSerializerOptions(JsonSerializerDefaults.Web);
enumSerializer.Converters.Add(new JsonStringEnumConverter());
jsonGroup.MapGet(
    "enum-as-string/",
    () =&gt; TypedResults.Json(new {
        FirstName = "John",
        LastName = "Doe",
        Rating = Rating.Good,
    }, enumSerializer)
);</code></pre>
</div>
<p>When executing the preceding code, we obtain the following result:</p>
<div><pre><code>{
  "firstName": "John",
  "lastName": "Doe",
  "rating": "Good"
}</code></pre>
</div>
<p>Using the default options yields the following instead:</p>
<div><pre><code>{
  "firstName": "John",
  "lastName": "Doe",
  "rating": 2
}</code></pre>
</div>
<blockquote>
<p>I usually change this option globally since having a human-readable value instead of a number is more explicit, easier to understand for a human, and easier to leverage for a client (machine).</p>
</blockquote>
<p>Many other options exist to tweak the serializer, but we can’t explore them all here. Next, we look at endpoint filters.</p>




<h3 data-number="6.4.3">Leveraging endpoint filters</h3>
<p>ASP.NET Core 7.0 added the possibility to register endpoint filters. This way, we can encapsulate and reuse cross-cutting concerns and logic across endpoints.</p>
<blockquote>
<p>An example of reusability is that I prefer FluentValidation to .NET attributes, so I created an open-source project implementing a filter that ties Minimal APIs with FluentValidation. I can then reuse that filter across projects by referencing a NuGet package. We explore FluentValidation in <em>Section 4: Application Patterns</em>, and I left a link to that project in the <em>Further Reading</em> section.</p>
</blockquote>
<p>How does it work?</p>
<ul>
<li>We can register endpoint filters inline or by creating a class.</li>
<li>We can add filters to an endpoint or a group using the <code>AddEndpointFilter</code> method.</li>
<li>When adding a filter to a group, it applies to all its children.</li>
<li>We can add multiple filters per endpoint or group.</li>
<li>ASP.NET Core executes the filters in the order they are registered.</li>
</ul>
<p>Let’s look at a simple inline filter:</p>
<div><pre><code>inlineGroup
    .MapGet("basic", () =&gt; { })
    .AddEndpointFilter((context, next) =&gt;
    {
        return next(context);
    });</code></pre>
</div>
<p>The highlighted code represents the filter in the form of a delegate. The filter does nothing but executes the next delegate in the chain, in this case, the endpoint delegate itself.In the following example, we use the <code>Rating</code> enum and only accept positive ratings in the endpoint. To achieve this, we add a filter that validates the input value before reaching the endpoint:</p>
<div><pre><code>public enum Rating
{
    Bad = 0,
    Ok,
    Good,
    Amazing
}
// ...
inlineGroup
    .MapGet("good-rating/{rating}", (Rating rating)
        =&gt; TypedResults.Ok(new { Rating = rating }))
    .AddEndpointFilter(async (context, next) =&gt;
    {
        var rating = context.GetArgument&lt;Rating&gt;(0);
        if (rating == Rating.Bad)
        {
            return TypedResults.Problem(
                detail: "This endpoint is biased and only accepts positive ratings.",
                statusCode: StatusCodes.Status400BadRequest
            );
        }
        return await next(context);
    });</code></pre>
</div>
<p>From the filter, we leveraged the <code>EndpointFilterFactoryContext</code> to access the rating argument. The code then validates that the rating is not <code>Bad</code>. If the rating is <code>Bad</code>, the filter immediately returns a <em>problem details</em> with a <code>400 Bad Request</code> status code before reaching out to the endpoint delegate. Otherwise, the endpoint code is executed.You probably wonder how useful writing code like this can be; well, this case is purely educational and not that useful in a real-world scenario. We could have validated the parameter in the endpoint delegate directly and saved ourselves the trouble of accessing it through its index. Nonetheless, it shows how filters work so that you can build helpful real-life filters with this knowledge; remember that coding is like playing LEGO® blocks.To improve on this foundation and make the previous example reusable, we can extract the filter logic into a class and apply it to multiple endpoints. We could also move the inline implementation to a group so it affects all its children. Let’s have a look at making our inline filter a class.A filter class must implement the <code>IEndpointFilter</code> interface. Here’s the reimplementation of the previous logic in the <code>GoodRatingFilter</code> class, and two endpoints using it:</p>
<div><pre><code>filterGroup
    .MapGet("good-rating/{rating}", (Rating rating)
        =&gt; TypedResults.Ok(new { Rating = rating }))
    .AddEndpointFilter&lt;GoodRatingFilter&gt;();
;
filterGroup
    .MapPut("good-rating/{rating}", (Rating rating)
        =&gt; TypedResults.Ok(new { Rating = rating }))
    .AddEndpointFilter&lt;GoodRatingFilter&gt;();
;
public class GoodRatingFilter : IEndpointFilter
{
    public async ValueTask&lt;object?&gt; InvokeAsync(
        EndpointFilterInvocationContext context, 
        EndpointFilterDelegate next)
    {
        var rating = context.GetArgument&lt;Rating&gt;(0);
        if (rating == Rating.Bad)
        {
            return TypedResults.Problem(
                detail: "This endpoint is biased and only accepts positive ratings.",
                statusCode: StatusCodes.Status400BadRequest
            );
        }
        return await next(context);
    }
}</code></pre>
</div>
<p>The <code>GoodRatingFilter</code> class <code>InvokeAsync</code> method code is the same as the inline version. However, we used it twice, keeping our code DRY.Encapsulating pieces of logic in filters can be very beneficial, whether it is input validation, logging, exception handling, or another scenario.And this is not it; there is one more thing about filters we must explore.</p>


<h3 data-number="6.4.4">Leveraging the endpoint filter factory</h3>
<p>We can use an endpoint filter factory to run code when ASP.NET Core builds the endpoint (makes the <code>RequestDelegate</code>) before declaring the filter. Then, from the factory, we control the creation of the filter itself.</p>
<blockquote>
<p>We explore the factory pattern in <em>Chapter 7</em>.</p>
</blockquote>
<p>The following code registers an endpoint filter factory:</p>
<div><pre><code>inlineGroup
    .MapGet("endpoint-filter-factory", () =&gt; "RAW")
    .AddEndpointFilterFactory((filterFactoryContext, next) =&gt;
    {
        // Building RequestDelegate code here.
        var logger = filterFactoryContext.ApplicationServices
            .GetRequiredService&lt;ILoggerFactory&gt;()
            .CreateLogger("endpoint-filter-factory");
        logger.LogInformation("Code that runs when ASP.NET Core builds the RequestDelegate");
        // Returns the EndpointFilterDelegate ASP.NET Core executes as part of the pipeline.
        return async invocationContext =&gt;
        {
            logger.LogInformation("Code that ASP.NET Core executes as part of the pipeline");
            // Filter code here
            return await next(invocationContext);
        };
    });</code></pre>
</div>
<p>The preceding code adds an endpoint filter factory that logs some information to the console, which allows us to track what is happening. The highlighted code represents the filter itself. For example, we could write the same code as the <code>GoodRatingFilter</code> class there.Next, let’s look at what happens when we execute the program and load the endpoint five times:</p>
<div><pre><code>[11:22:56.673] info: Microsoft.Hosting.Lifetime[14]
      Now listening on: https://localhost:7298
[11:22:56.698] info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5085
[11:22:56.702] info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
[11:22:56.705] info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
[11:22:56.708] info: Microsoft.Hosting.Lifetime[0]
      Content root path: .../C05/Minimal.API
[11:23:28.349] info: endpoint-filter-factory[0]
      Code that runs when ASP.NET Core builds the RequestDelegate
[11:23:45.181] info: endpoint-filter-factory[0]
      Code that runs when ASP.NET Core builds the RequestDelegate
[11:24:56.043] info: endpoint-filter-factory[0]
      Code that ASP.NET Core executes as part of the pipeline
[11:24:57.439] info: endpoint-filter-factory[0]
      Code that ASP.NET Core executes as part of the pipeline
[11:24:58.443] info: endpoint-filter-factory[0]
      Code that ASP.NET Core executes as part of the pipeline
[11:24:59.262] info: endpoint-filter-factory[0]
      Code that ASP.NET Core executes as part of the pipeline
[11:25:00.154] info: endpoint-filter-factory[0]
      Code that ASP.NET Core executes as part of the pipeline</code></pre>
</div>
<p>Here’s what happened from the preceding output:</p>
<ol>
<li>The API starts (the first ten lines).</li>
<li>ASP.NET Core executes the factory code when building the <code>RequestDelegate</code> from the <code>EndpointRoutingMiddleware</code> (the next two lines).</li>
<li><code>SwaggerGen</code>, using the <code>ApiExplorer</code>, also does the same from the <code>SwaggerMiddleware</code>, hence the second factory call (the next two lines).</li>
<li>Afterward, ASP.NET Core only executes the filters during requests—in this case, five times (the last 10 lines).</li>
</ol>
<p>Now that we’ve seen how it runs, it is time to learn how it works.</p>
<blockquote>
<p>Don’t worry if you don’t understand how the <code>GetRequiredService</code> method or the <code>ILoggerFactory</code> interface work; we explore those topics in <em>Chapter 8</em>, <em>Dependency Injection</em>, and <em>Chapter 10</em>, <em>Logging</em>.</p>
</blockquote>
<p>We start by registering the endpoint filter factory using the <code>AddEndpointFilterFactory</code> method, which applies to groups and individual routes (we dig deeper into groups next). The factory delegate is of type <code>Func&lt;EndpointFilterFactoryContext, EndpointFilterDelegate, EndpointFilterDelegate&gt;</code>.Inside the delegate, using the <code>EndpointFilterFactoryContext</code> parameter named <code>filterFactoryContext</code>, we have access to the following objects:</p>
<ul>
<li>The <code>ApplicationServices</code> property provides access to an <code>IServiceProvider</code> interface, allowing us to extract services from the container, as demonstrated with the <code>ILoggerFactory</code> interface.</li>
<li>The <code>MethodInfo</code> property offers a <code>MethodInfo</code> object granting access to the caller to which we add the endpoint filter factory. This object encapsulates the reflection data, including types, generic parameters, attributes, and more.</li>
</ul>
<p>Finally, the factory delegate returns the filter ASP.NET Core executes when a request hits the endpoint(s). In this case, the filter is the following:</p>
<div><pre><code>async invocationContext =&gt;
{
    logger.LogInformation("Code that ASP.NET Core executes as part of the pipeline");
    return await next(invocationContext);
};</code></pre>
</div>
<p>The <code>next</code> parameter (highlighted code) represents the next filter in line or the endpoint itself—it works the same here as with any endpoint filter. Not calling the <code>next</code> parameter means ASP.NET Core will never execute the endpoint code, which is a way to control the flow of the application.</p>
<blockquote>
<p>To make an endpoint filter factory more reusable, we could create a class, an extension method, or return an existing filter class. We can also combine those ways to craft a more testable and DRY implementation of an endpoint filter factory. While we won't delve into these specific approaches in this context, by the end of the book, you should have acquired enough knowledge to achieve these tasks by yourself.</p>
</blockquote>
<p>Next, we look at organizing our endpoints.</p>


<h3 data-number="6.4.5">Organizing endpoints</h3>
<p>Grouping endpoints using the <code>MapGroup</code> method is an effective organizational strategy. However, defining all routes directly within the <code>Program.cs</code> file can result in a long and challenging-to-navigate file. To mitigate this, we can arrange these groups of endpoints in separate classes and create an extension method to add these endpoints to the <code>IEndpointRouteBuilder</code>. We can also encapsulate the groups, or even multiple groups, within another assembly, which we can load from the API.</p>
<blockquote>
<p>We explore ways to design applications in <em>Section 4: Application Patterns</em>, including in <em>Chapter 18</em>, <em>Request-EndPoint-Response (REPR)</em>, and <em>Chapter 20</em>, <em>Modular Monolith</em>.</p>
</blockquote>
<p>Let’s start with simple groups.</p>

<h4 data-number="6.4.5.1">MapGroup</h4>
<p>Creating groups is the first tool to organize the routes of our APIs. It comes with the following advantages:</p>
<ul>
<li>We can create a shared URL prefix for the group’s children.</li>
<li>We can add metadata that applies to the group’s children.</li>
<li>We can add endpoint filters that apply to the group’s children.</li>
</ul>
<p>Here is an example of a group that configures those three items:</p>
<div><pre><code>// Create a reusable logger
var loggerFactory = app.ServiceProvider
    .GetRequiredService&lt;ILoggerFactory&gt;();
var groupLogger = loggerFactory
    .CreateLogger("organizing-endpoints");
// Create the group
var group = app
    .MapGroup("organizing-endpoints")
    .WithTags("Organizing Endpoints")
    .AddEndpointFilter(async (context, next) =&gt; {
        groupLogger.LogTrace("Entering organizing-endpoints");
        // Omited argument logging 
        var result = await next(context);
        groupLogger.LogTrace("Exiting organizing-endpoints");
        return result;
    })
;
// Map endpoints in the group
group.MapGet("demo/", ()
    =&gt; "GET endpoint from the organizing-endpoints group.");
group.MapGet("demo/{id}", (int id)
    =&gt; $"GET {id} endpoint from the organizing-endpoints group.");</code></pre>
</div>
<p>The highlighted code does the following:</p>
<ul>
<li>Configures the <code>organizing-endpoints</code> URL prefix.</li>
<li>Add the <code>Organizing Endpoints</code> tag (metadata).</li>
<li>Add an inline filter that logs information about the requests.</li>
</ul>
<p>We can reach the endpoints at the following URL:</p>
<ul>
<li><code>/organizing-endpoints/demo</code></li>
<li><code>/organizing-endpoints/demo/123</code></li>
</ul>
<p>As the following Swagger UI screenshot shows, the two endpoints are tagged correctly:</p>
<figure>
<img alt="Figure 5.3: The two endpoints under the Organizing Endpoints tag" src="img/file27.png"/><figcaption aria-hidden="true">Figure 5.3: The two endpoints under the Organizing Endpoints tag</figcaption>
</figure>
<p>Then, after requesting the two endpoints, we end up with the following logs excerpt:</p>
<div><pre><code>[23:55:01.516] trce: organizing-endpoints[0]
      Entering organizing-endpoints
[23:55:01.516] trce: organizing-endpoints[0]
      Exiting organizing-endpoints
[23:55:06.028] trce: organizing-endpoints[0]
      Entering organizing-endpoints
[23:55:06.028] dbug: organizing-endpoints[0]
      Argument 1: Int32 = 123
[23:55:06.028] trce: organizing-endpoints[0]
      Exiting organizing-endpoints</code></pre>
</div>
<p>As demonstrated, leveraging groups for shared configuration streamlines the process of setting up aspects like authorization rules, caching, and more. By adopting this approach, we uphold the DRY (Don't Repeat Yourself) principle, improving the maintainability of our code.Next, we encapsulate mapping endpoints into classes.</p>


<h4 data-number="6.4.5.2">Create a custom Map extension method</h4>
<p>Now that we explored how to create groups, it is time to move the endpoints out of the <code>Program.cs</code> file. One way is to create an extension method that registers the route. To achieve this, we must extend the <code>IEndpointRouteBuilder</code> interface as follows:</p>
<div><pre><code>namespace Minimal.API;
public static class OrganizingEndpoints
{
    public static void MapOrganizingEndpoints(
        this IEndpointRouteBuilder app)
    {
        // Map endpoints and groups here
    }
}</code></pre>
</div>
<p>Then we must call our extension method in the <code>Program.cs</code> file, as follows:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapOrganizingEndpoints();
app.Run();</code></pre>
</div>
<p>And with that, we've seen how a simple technique allows us to group our routes together, offering an organized way to structure our APIs.We can improve on this technique by returning the <code>IEndpointRouteBuilder</code> instead of <code>void</code> in our extension method, which makes our extension “fluent”, as demonstrated below:</p>
<div><pre><code>namespace Minimal.API;
public static class OrganizingEndpoints
{
    public static IEndpointRouteBuilder MapOrganizingEndpointsFluently(
        this IEndpointRouteBuilder app)
    {
        var group = app
            .MapGroup("organizing-endpoints-fluently")
            .WithTags("Organizing Fluent Endpoints")
        ;
        // Map endpoints and groups here
        return app;
    }
}</code></pre>
</div>
<p>Then from the <code>Program.cs</code> file, we can call multiple maps in a “single line of code” like the following:</p>
<div><pre><code>app
    .MapOrganizingEndpointsFluently()
    .MapOrganizingEndpoints()
;</code></pre>
</div>
<p>Creating fluent APIs is very convenient, especially in such cases.</p>
<blockquote>
<p>This technique allows you to create fluent APIs for anything, not just registering routes.</p>
</blockquote>
<p>Another variation of this pattern exists that's worth noting. Rather than returning the <code>IEndpointRouteBuilder</code>, the extension method can return the <code>RouteGroupBuilder</code> instead, granting the caller access to the group itself. Here is an example:</p>
<div><pre><code>namespace Minimal.API;
public static class OrganizingEndpoints
{
    public static RouteGroupBuilder MapOrganizingEndpointsComposable(
        this IEndpointRouteBuilder app)
    {
        var group = app
            .MapGroup("organizing-endpoints-composable")
            .WithTags("Organizing Composable Endpoints")
        ;
        // Map endpoints and groups here
        return group;
    }
}</code></pre>
</div>
<p>We can use such methods to create a complex hierarchy of routes and groups by splitting the registration into multiple files. The second version is the most common way. It does not expose the group to the outside (encapsulation) and allows fluent chaining of other method calls.And voilà! We now know how basic extension methods can help us organize our endpoints. Next, we explore how to move those extension methods into class libraries.</p>


<h4 data-number="6.4.5.3">Class libraries</h4>
<p>This last technique allows us to create and register routes from class libraries using the previously explored techniques.First, we must create a class library project, which we can do using the <code>dotnet new classlib</code> CLI command.Unfortunately, a class library project cannot access everything we need, like the <code>IEndpointRouteBuilder</code> interface. The good news is that it is trivial to change this fact. All we have to do is add a <code>FrameworkReference</code> element in an <code>ItemGroup</code> element in the <code>csproj</code> file, as follows:</p>
<div><pre><code>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;/PropertyGroup&gt;
    &lt;ItemGroup&gt;
        &lt;FrameworkReference Include="Microsoft.AspNetCore.App" /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;</code></pre>
</div>
<p>That minor addition equips us with everything necessary to create an ASP.NET Core-enabled library, including mapping endpoints! Transferring the preceding C# code into this class library project should yield the same functional results as in a web application.</p>
<blockquote>
<p>I used this technique in the <code>Shared</code> project of the solution we explore in this chapter and the next. If you are curious, the complete source code is available on GitHub.</p>
</blockquote>
<p>Next, we mix Minimal APIs and DTOs.</p>




<h2 data-number="6.5">Using Minimal APIs with Data Transfer Objects</h2>
<p>This section explores leveraging the <strong>Data Transfer Object</strong> (<strong>DTO</strong>) pattern with minimal APIs.</p>
<blockquote>
<p>This section is the same as we explore in <em>Chapter 6</em>, <em>MVC</em>, but in the context of Minimal APIs. Moreover, the two code projects are part of the same Visual Studio solution for convenience, allowing you to compare the two implementations.</p>
</blockquote>

<h3 data-number="6.5.1">Goal</h3>
<p>As a reminder, DTOs aim to <em>control the inputs and outputs of an endpoint</em> by decoupling the API contract from the application’s inner workings. DTOs empower us to define our APIs without thinking about the underlying data structures, leaving us to craft our REST APIs how we want.</p>
<blockquote>
<p>We discuss REST APIs and DTOs more in-depth in <em>Chapter 4</em>, <em>REST APIs</em>.</p>
</blockquote>
<p>Other possible objectives are to save bandwidth by limiting the amount of information the API transmits, flattening the data structure, or adding API features that cross multiple entities.</p>


<h3 data-number="6.5.2">Design</h3>
<p>Let’s start by analyzing a diagram that shows how minimal APIs work with DTOs:</p>
<figure>
<img alt="Figure 5.4: An input DTO hitting some domain logic, then the endpoint returning an output DTO" src="img/file28.png"/><figcaption aria-hidden="true">Figure 5.4: An input DTO hitting some domain logic, then the endpoint returning an output DTO</figcaption>
</figure>
<p>DTOs allow the decoupling of the domain (3) from the request (1) and the response (5). This model empowers us to manage the inputs and outputs of our REST APIs independently from the domain. Here’s the flow:</p>
<ol>
<li>The client sends a request to the server.</li>
<li>ASP.NET Core leverages its data binding and parsing mechanism to convert the information of the HTTP request to C# (input DTO).</li>
<li>The endpoint does what it is supposed to do.</li>
<li>ASP.NET Core serializes the output DTO to the HTTP response.</li>
<li>The client receives and handles the response.</li>
</ol>
<p>Let’s explore some code to understand the concept better.</p>


<h3 data-number="6.5.3">Project – Minimal API</h3>
<p><em>This code sample is the same as the next chapter but uses Minimal APIs instead of the MVC framework</em>.<strong>Context</strong>: we must build an application to manage customers and contracts. We must track the state of each contract and have a primary contact in case the business needs to contact the customer. Finally, we must display the number of contracts and the number of opened contracts for each customer on a dashboard.The model is the following:</p>
<div><pre><code>namespace Shared.Models;
public record class Customer(
    int Id,
    string Name,
    List&lt;Contract&gt; Contracts
);
public record class Contract(
    int Id,
    string Name,
    string Description,
    WorkStatus Status,
    ContactInformation PrimaryContact
);
public record class WorkStatus(int TotalWork, int WorkDone)
{
    public WorkState State =&gt;
        WorkDone == 0 ? WorkState.New :
        WorkDone == TotalWork ? WorkState.Completed :
        WorkState.InProgress;
}
public record class ContactInformation(
    string FirstName,
    string LastName,
    string Email
);
public enum WorkState
{
    New,
    InProgress,
    Completed
}</code></pre>
</div>
<p>The preceding code is straightforward. The only piece of logic is the <code>WorkStatus.State</code> property that returns <code>WorkState.New</code> when the work has not yet started on that contract, <code>WorkState.Completed</code> when all the work is completed, or <code>WorkState.InProgress</code> otherwise.The endpoints (<code>CustomersEndpoints.cs</code>) leverage the <code>ICustomerRepository</code> interface to simulate database operations. The implementation is unimportant. It uses a <code>List&lt;Customer&gt;</code> as the database. Here’s the interface that allows querying and updating the data:</p>
<div><pre><code>using Shared.Models;
namespace Shared.Data;
public interface ICustomerRepository
{
    Task&lt;IEnumerable&lt;Customer&gt;&gt; AllAsync(
        CancellationToken cancellationToken);
    Task&lt;Customer&gt; CreateAsync(
        Customer customer, 
        CancellationToken cancellationToken);
    Task&lt;Customer?&gt; DeleteAsync(
        int customerId, 
        CancellationToken cancellationToken);
    Task&lt;Customer?&gt; FindAsync(
        int customerId, 
        CancellationToken cancellationToken);
    Task&lt;Customer?&gt; UpdateAsync(
        Customer customer, 
        CancellationToken cancellationToken);
}</code></pre>
</div>
<p>Now that we know about the underlying foundation, we explore CRUD endpoints that do not leverage DTOs.</p>

<h4 data-number="6.5.3.1">Raw CRUD endpoints</h4>
<p>Many issues can arise if we create CRUD endpoints to manage the customers directly (see <code>CustomersEndpoints.cs</code>). First, a little mistake from the client could erase several data points. For example, if the client forgets to send the contracts during a <code>PUT</code> operation, that would delete all the contracts associated with that customer. Here’s the controller code:</p>
<div><pre><code>// PUT raw/customers/1
group.MapPut("/{customerId}", async (int customerId, Customer input, ICustomerRepository customerRepository, CancellationToken cancellationToken) =&gt;
{
    var updatedCustomer = await customerRepository.UpdateAsync(
        input, 
        cancellationToken
    );
    if (updatedCustomer == null)
    {
        return Results.NotFound();
    }
    return Results.Ok(updatedCustomer);
});</code></pre>
</div>
<p>The highlighted code represents the customer update. So to mistakenly remove all contracts, a client could send the following HTTP request (from the <code>Minimal.API.http</code> file):</p>
<div><pre><code>PUT {{Minimal.API.BaseAddress}}/customers/1
Content-Type: application/json
{
  "id": 1,
  "name": "Some new name",
  "contracts": []
}</code></pre>
</div>
<p>That request would result in the following response entity:</p>
<div><pre><code>{
  "id": 1,
  "name": "Some new name",
  "contracts": []
}</code></pre>
</div>
<p>Previously, however, that customer had contracts (seeded when we started the application). Here’s the original data:</p>
<div><pre><code>{
  "id": 1,
  "name": "Jonny Boy Inc.",
  "contracts": [
    {
      "id": 1,
      "name": "First contract",
      "description": "This is the first contract.",
      "status": {
        "totalWork": 100,
        "workDone": 100,
        "state": "Completed"
      },
      "primaryContact": {
        "firstName": "John",
        "lastName": "Doe",
        "email": "john.doe@jonnyboy.com"
      }
    },
    {
      "id": 2,
      "name": "Some other contract",
      "description": "This is another contract.",
      "status": {
        "totalWork": 100,
        "workDone": 25,
        "state": "InProgress"
      },
      "primaryContact": {
        "firstName": "Jane",
        "lastName": "Doe",
        "email": "jane.doe@jonnyboy.com"
      }
    }
  ]
}</code></pre>
</div>
<p>As we can see, by exposing our entities directly, we are giving a lot of power to the consumers of our API. Another issue with this design is the dashboard. The user interface would have to calculate the statistics about the contracts. Moreover, if we implement paging the contracts over time, the user interface could become increasingly complex and even overquery the database, hindering our performance.</p>
<blockquote>
<p>I implemented the entire API, which is available on GitHub but without UI.</p>
</blockquote>
<p>Next, we explore how we can fix those two use cases using DTOs.</p>


<h4 data-number="6.5.3.2">DTO-enabled endpoints</h4>
<p>To solve our problems, we reimplement the endpoints using DTOs. These endpoints use methods instead of inline delegates and returns <code>Results&lt;T1, T2, …&gt;</code> instead <code>IResult</code>. So, let’s start with the declaration of the endpoints:</p>
<div><pre><code>var group = routes
    .MapGroup("/dto/customers")
    .WithTags("Customer DTO")
    .WithOpenApi()
;
group.MapGet("/", GetCustomersSummaryAsync)
    .WithName("GetAllCustomersSummary");
group.MapGet("/{customerId}", GetCustomerDetailsAsync)
    .WithName("GetCustomerDetailsById");
group.MapPut("/{customerId}", UpdateCustomerAsync)
    .WithName("UpdateCustomerWithDto");
group.MapPost("/", CreateCustomerAsync)
    .WithName("CreateCustomerWithDto");
group.MapDelete("/{customerId}", DeleteCustomerAsync)
    .WithName("DeleteCustomerWithDto");</code></pre>
</div>
<p>Next, to make it easier to follow along, here are all the DTOs as a reference:</p>
<div><pre><code>namespace Shared.DTO;
public record class ContractDetails(
    int Id,
    string Name,
    string Description,
    int StatusTotalWork,
    int StatusWorkDone,
    string StatusWorkState,
    string PrimaryContactFirstName,
    string PrimaryContactLastName,
    string PrimaryContactEmail
);
public record class CustomerDetails(
    int Id,
    string Name,
    IEnumerable&lt;ContractDetails&gt; Contracts
);
public record class CustomerSummary(
    int Id,
    string Name,
    int TotalNumberOfContracts,
    int NumberOfOpenContracts
);
public record class CreateCustomer(string Name);
public record class UpdateCustomer(string Name);</code></pre>
</div>
<p>First, let’s fix our update problem, starting with the reimplementation of the update endpoint leveraging DTOs (see the <code>DTOEndpoints.cs</code> file):</p>
<div><pre><code>// PUT dto/customers/1
private static async Task&lt;Results&lt;
    Ok&lt;CustomerDetails&gt;,
    NotFound,
    Conflict
&gt;&gt; UpdateCustomerAsync(
        int customerId,
        UpdateCustomer input,
        ICustomerRepository customerRepository,
        CancellationToken cancellationToken)
{
    // Get the customer
    var customer = await customerRepository.FindAsync(
        customerId,
        cancellationToken
    );
    if (customer == null)
    {
        return TypedResults.NotFound();
    }
    // Update the customer's name using the UpdateCustomer DTO
    var updatedCustomer = await customerRepository.UpdateAsync(
        customer with { Name = input.Name },
        cancellationToken
    );
    if (updatedCustomer == null)
    {
        return TypedResults.Conflict();
    }
    // Map the updated customer to a CustomerDetails DTO
    var dto = MapCustomerToCustomerDetails(updatedCustomer);
    // Return the DTO
    return TypedResults.Ok(dto);
}</code></pre>
</div>
<p>In the preceding code, the main differences are (highlighted):</p>
<ul>
<li>The request body is now bound to the <code>UpdateCustomer</code> class instead of the <code>Customer</code> itself.</li>
<li>The action method returns an instance of the <code>CustomerDetails</code> class instead of the <code>Customer</code> itself when the operation succeeds.</li>
</ul>
<p>However, we can see more code in our endpoint than before. That’s because it now handles the changes instead of the clients. The action now does:</p>
<ol>
<li>Load the data from the database.</li>
<li>Ensure the entity exists.</li>
<li>Use the input DTO to update the data, limiting the clients to a subset of properties.</li>
<li>Proceed with the update.</li>
<li>Ensure the entity still exists (handles conflicts).</li>
<li>Copy the Customer into the output DTO and return it.</li>
</ol>
<p>By doing this, we now control what the clients can do when they send a <code>PUT</code> request through the input DTO (<code>UpdateCustomer</code>). Moreover, we encapsulated the logic to calculate the statistics on the server. We hid the computation behind the output DTO (<code>CustomerDetails</code>), which lowers the complexity of our user interface and allows us to improve the performance without impacting any of our clients (loose coupling).Furthermore, we now use the <code>customerId</code> parameter.If we send the same HTTP request as before, which sends more data than we accept, only the customer's name will change. On top of that, we get all the data we need to display the customer’s statistics. Here’s a response example:</p>
<div><pre><code>{
  "id": 1,
  "name": "Some new name",
  "contracts": [
    {
      "id": 1,
      "name": "First contract",
      "description": "This is the first contract.",
      "statusTotalWork": 100,
      "statusWorkDone": 100,
      "statusWorkState": "Completed",
      "primaryContactFirstName": "John",
      "primaryContactLastName": "Doe",
      "primaryContactEmail": "john.doe@jonnyboy.com"
    },
    {
      "id": 2,
      "name": "Some other contract",
      "description": "This is another contract.",
      "statusTotalWork": 100,
      "statusWorkDone": 25,
      "statusWorkState": "InProgress",
      "primaryContactFirstName": "Jane",
      "primaryContactLastName": "Doe",
      "primaryContactEmail": "jane.doe@jonnyboy.com"
    }
  ]
}</code></pre>
</div>
<p>As we can see from the preceding response, only the customer’s name changed, but we now received the <code>statusWorkDone</code> and <code>statusTotalWork</code> fields. Lastly, we flattened the data structure.</p>
<blockquote>
<p>DTOs are a great resource to flatten data structures, but you don’t have to. You must always design your systems, including DTOs and data contracts, for specific use cases.</p>
</blockquote>
<p>As for the dashboard, the “get all customers” endpoint achieves this by doing something similar. It outputs a collection of <code>CustomerSummary</code> objects instead of the customers themselves. In this case, the endpoint executes the calculations and copies the entity's relevant properties to the DTO. Here’s the code:</p>
<div><pre><code>// GET: dto/customers
private static async Task&lt;Ok&lt;IEnumerable&lt;CustomerSummary&gt;&gt;&gt; GetCustomersSummaryAsync(
    ICustomerRepository customerRepository,
    CancellationToken cancellationToken)
{
    // Get all customers
    var customers = await customerRepository
        .AllAsync(cancellationToken);
    // Map customers to CustomerSummary DTOs
    var customersSummary = customers.Select(customer =&gt; new CustomerSummary(
        Id: customer.Id,
        Name: customer.Name,
        TotalNumberOfContracts: customer.Contracts.Count,
        NumberOfOpenContracts: customer.Contracts
            .Count(x =&gt; x.Status.State != WorkState.Completed)
    ));
    // Return the DTOs
    return TypedResults.Ok(customersSummary);
}</code></pre>
</div>
<p>In the preceding code, the action method:</p>
<ol>
<li>Read the entities</li>
<li>Create the DTOs and calculate the number of open contracts.</li>
<li>Return the DTOs.</li>
</ol>
<p>As simple as that, we now encapsulated the computation on the server.</p>
<blockquote>
<p>You should optimize such code based on your real-life data source. In this case, a <code>static</code> <code>List&lt;T&gt;</code> is low latency. However, querying the whole database to get a count can become a bottleneck.</p>
</blockquote>
<p>Calling the endpoint results in the following:</p>
<div><pre><code>[
  {
    "id": 1,
    "name": "Some new name",
    "totalNumberOfContracts": 2,
    "numberOfOpenContracts": 1
  },
  {
    "id": 2,
    "name": "Some mega-corporation",
    "totalNumberOfContracts": 1,
    "numberOfOpenContracts": 1
  }
]</code></pre>
</div>
<p>It is now super easy to build our dashboard. We can query that endpoint once and display the data in the UI. The UI offloaded the calculation to the backend.</p>
<blockquote>
<p>User interfaces tend to be more complex than APIs because they are stateful. As such, offloading as much complexity to the backend helps. You can use a Backend-for-frontend (BFF) to help with this task. We explore ways to layer APIs, including the BFF pattern in <em>Chapter 19</em>, <em>Introduction to Microservices Architecture</em>.</p>
</blockquote>
<p>Lastly, you can play with the API using the HTTP requests in the <code>MVC.API.DTO.http</code> file. I implemented all the endpoints using a similar technique. If your endpoints become too complex, it is good practice to encapsulate them into other classes. We explore many techniques to organize application code in <em>Section 4</em>: <em>Applications patterns</em>.</p>



<h3 data-number="6.5.4">Conclusion</h3>
<p>A data transfer object allows us to design an API endpoint with a specific data contract (input and output) instead of exposing the domain or data model. This separation between the presentation and the domain is a crucial element that leads to having multiple independent components instead of a bigger, more fragile one.We use DTOs to control the endpoints' inputs and outputs, giving us more control over what the clients can do or receive.Using the data transfer object pattern helps us follow the SOLID principles in the following ways:</p>
<ul>
<li><strong>S</strong>: A DTO adds clear boundaries between the domain or data model and the API contract. Moreover, having an input and an output DTO help further separate the responsibilities.</li>
<li><strong>O</strong>: N/A</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: A DTO is a small, specifically crafted data contract (abstraction) with a clear purpose in the API contract.</li>
<li><strong>D</strong>: Due to those smaller interfaces (ISP), DTOs allow changing the implementation details of the endpoint without affecting the clients because they depend only on the API contract (the abstraction).</li>
</ul>
<p>You should now understand the added value of DTOs and what part in an API contract they play. Finally, you should have a strong base of Minimal APIs possibilities.</p>



<h2 data-number="6.6">Summary</h2>
<p>Throughout the chapter, we explored ASP.NET Core Minimal APIs and their integration with the DTO pattern. Minimal APIs simplify web application development by reducing boilerplate code. The DTO pattern helps us decouple the API contract from the application's inner workings, allowing flexibility in crafting REST APIs. DTOs can also save bandwidth and flatten or change data structures. Endpoints exposing their domain or data entities directly can lead to issues, while DTO-enabled endpoints offer better control over data exchanges. We also discussed numerous Minimal APIs aspects, including input binding, outputting data, metadata, JSON serialization, endpoint filters, and endpoint organization. With this foundational knowledge, we can begin to design ASP.NET Core minimal APIs.</p>
<blockquote>
<p>For more information about Minimal APIs and what they have to offer, you can visit the <em>Minimal APIs quick reference</em> page of the official documentation: <a href="https://adpg.link/S47i">https://adpg.link/S47i</a></p>
</blockquote>
<p>In the next chapter, we revisit the same notions in an ASP.NET Core MVC context.</p>


<h2 data-number="6.7">Questions</h2>
<p>Let’s look at a few practice questions:</p>
<ol>
<li>How to map different HTTP requests to delegates with Minimal APIs?</li>
<li>Can we use middleware with Minimal APIs?</li>
<li>Can you name at least two binding sources that minimal APIs supports?</li>
<li>What is the difference between using the <code>Results</code> and <code>TypedResults</code> classes?</li>
<li>What is the purpose of endpoint filters?</li>
</ol>


<h2 data-number="6.8">Further reading</h2>
<p>Here are some links to build on what we have learned in the chapter:</p>
<ul>
<li>Minimal APIs quick reference: <a href="https://adpg.link/S47i">https://adpg.link/S47i</a></li>
<li>Problem Details for HTTP APIs (RFC7807): <a href="https://adpg.link/1hpM">https://adpg.link/1hpM</a></li>
<li>FluentValidation.AspNetCore.Http: <a href="https://adpg.link/sRtU">https://adpg.link/sRtU</a></li>
</ul>


<h2 data-number="6.9">Answers</h2>
<ol>
<li>Minimal APIs provide extension methods such as <code>MapGet</code>, <code>MapPost</code>, <code>MapPut</code>, and <code>MapDelete</code> to configure the HTTP pipeline and map specific HTTP requests to delegates.</li>
<li>Yes, we can use middleware with Minimal APIs, just like any other ASP.NET Core application.</li>
<li>Minimal APIs support various binding sources, including <code>Route</code>, <code>Query</code>, <code>Header</code>, <code>Body</code>, <code>Form</code>, and <code>Services</code>.</li>
<li>The methods in the <code>Results</code> class return <code>IResult</code>, while those in <code>TypedResults</code> return a typed implementation of the <code>IResult</code> interface. This difference is significant because the API Explorer can automatically discover the API contract from the typed results (<code>TypedResults</code> methods) but not from the generic <code>IResult</code> interface (<code>Results</code> methods).</li>
<li>Endpoint filters allow encapsulation and reuse of cross-cutting logic across endpoints. For example, they're helpful for input validation, logging, exception handling, and promoting code reusability.</li>
</ol>


</body>
</html>
