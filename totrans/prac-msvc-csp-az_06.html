<html><head></head><body>
		<div><h1 id="_idParaDest-138" class="chapter-number"><a id="_idTextAnchor137"/>6</h1>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Microsoft Azure for Hosting Applications</h1>
			<p>After creating Docker images with the previous chapters, and running the complete application using Docker containers locally, let’s move over to run the solution with Microsoft Azure.</p>
			<p>In this chapter, you’ll learn how to push Docker images to an Azure container registry, run Docker containers with Azure Container Apps, access a database using Azure Cosmos DB, and configure environment variables and secrets with Azure Container Apps.</p>
			<p>Using Bicep scripts, you learn how to create multiple Azure resources at once.</p>
			<p>In this chapter, you’ll learn about the following topics:</p>
			<ul>
				<li>Experiencing Microsoft Azure</li>
				<li>Creating Azure resources</li>
				<li>Creating an Azure Cosmos database</li>
				<li>Pushing <a id="_idIndexMarker331"/>images to the <strong class="bold">Azure Container Registry</strong> (<strong class="bold">ACR</strong>) instance</li>
				<li>Creating Azure container apps</li>
				<li>Creating <a id="_idIndexMarker332"/>Azure resources using .NET Aspire and the <strong class="bold">Azure Developer </strong><strong class="bold">CLI</strong> (<strong class="bold">azd</strong>)</li>
			</ul>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Technical requirements</h1>
			<p>For this chapter, you need to have Docker Desktop installed. You also need a Microsoft Azure subscription. You <a id="_idIndexMarker333"/>can activate Microsoft Azure for free at <a href="https://azure.microsoft.com/free">https://azure.microsoft.com/free</a>, which gives you an amount of about USD 200, Azure credits that are available for the first 30 days, and several services that can be used for free for the time after.</p>
			<p>What many developers miss: if you have a Visual Studio Professional or Enterprise subscription, you also have a free amount of Azure resources every month. You just need to <a id="_idIndexMarker334"/>activate this with your Visual Studio subscription: <a href="https://visualstudio.microsoft.com/subscriptions/">https://visualstudio.microsoft.com/subscriptions/</a>.</p>
			<p>To work through the samples of this chapter, besides Docker Desktop, the Azure CLI and <code>azd</code> are needed.</p>
			<p>To create and manage resources, install the Azure CLI and <code>azd</code>:</p>
			<pre class="console">
winget install microsoft.azureCLI
winget install microsoft.azd</pre>
			<p>These tools <a id="_idIndexMarker335"/>are available on Mac and Linux as well. To install the Azure CLI on different platforms, see <a href="https://learn.microsoft.com/cli/azure/install-azure-cli">https://learn.microsoft.com/cli/azure/install-azure-cli</a>, and for <code>azd</code>, see <a href="https://learn.microsoft.com/azure/developer/azure-developer-cli/install-azd">https://learn.microsoft.com/azure/developer/azure-developer-cli/install-azd</a>.</p>
			<p>An easy way <a id="_idIndexMarker336"/>to use the Azure Cloud Shell is from a web browser. As you log in to the Azure portal at <a href="https://portal.azure.com">https://portal.azure.com</a> using your Microsoft Azure account, on the top button bar, you’ll see an icon for <em class="italic">Cloud Shell</em>. Clicking on this button, a terminal opens. Here, the Azure CLI is already installed – along with many other tools such as <code>wget</code> to download files, <code>git</code> to work with repositories, <code>docker</code>, the .NET CLI, and more. You can also use a Visual Studio Code editor (just run <code>code</code> from the terminal) to edit files. All the files you create and change are persisted within an Azure Storage account that is automatically created when you start the Cloud Shell. For a <a id="_idIndexMarker337"/>fullscreen Cloud Shell, you can open <a href="https://shell.azure.com">https://shell.azure.com</a>.</p>
			<p>The code for this chapter can be found in the following GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>.</p>
			<p>In the <code>ch06</code> folder, these are the important projects:</p>
			<ul>
				<li><code>Codebreaker.GameAPIs</code> – The <code>gamesAPI</code> project we used in the previous chapter. There’s one change: instead of including the projects with the database access code and the models, NuGet packages are referenced.</li>
				<li><code>Codebreaker.Bot</code> – The bot service calling the game APIs.</li>
				<li><code>Codebreaker.AppHost</code> – This project contains important changes in this chapter to define the app model with Azure resources.</li>
				<li><code>Codebreaker.ServiceDefaults</code> – This project is unchanged in this chapter.</li>
			</ul>
			<p>You can start with the results from the previous chapter to work on your own through this chapter.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Experiencing Microsoft Azure</h1>
			<p>Microsoft Azure <a id="_idIndexMarker338"/>offers cloud services from many different <a id="_idIndexMarker339"/>categories. You can create <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>), which belong to the <strong class="bold">Infrastructure as a Service</strong> (<strong class="bold">IaaS</strong>) category, where you <a id="_idIndexMarker340"/>are in control of the machines but also need to manage them as you do in on-premises environments, up to ready-to-use software <a id="_idIndexMarker341"/>such as Office 365 from the <strong class="bold">Software as a Service</strong> (<strong class="bold">SaaS</strong>) category. Something <a id="_idIndexMarker342"/>in between is <strong class="bold">Platform as a Service</strong> (<strong class="bold">PaaS</strong>), where you don’t have full control over the VMs but instead get many functionalities out of the box.</p>
			<p>The focus here is on PaaS services. With the PaaS category, there’s also a category named <strong class="bold">serverless</strong>. This category allows for easy scaling, starting from zero, where no or low costs are associated, up to a maximum amount of automatic scaling based on the needs. Many Azure services have offerings in this category.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Cost</h2>
			<p>When <a id="_idIndexMarker343"/>creating resources in a cloud environment, there’s always a question about the cost. Many are afraid of the need to pay unexpected amounts, but this fear is not necessary. Some subscriptions (such as a Visual Studio subscription) are limited to the amount available every month. If this amount is reached, resources are automatically stopped (unless you explicitly allow the cost to go above the limits), so no additional cost applies.</p>
			<p>With subscriptions and also just with resource groups, you can specify a budget to specify the <a id="_idIndexMarker344"/>amount that’s planned to be spent. To do this, open the Azure portal and select a resource group. Within a resource group, you’ll see the <strong class="bold">Cost Management</strong> category with the <strong class="bold">Budgets</strong> option. By creating a budget (see <em class="italic">Figure 6</em><em class="italic">.1</em>), you can define limits month by month. Before this limit is reached, you specify alerts where you can be informed. With an alert, you can specify to receive a notification via email, SMS, push, or voice notification, and in addition to that, you can define an action that should be invoked to call an Azure function, a logic app, an Automation runbook, or other Azure resources where custom functionality can be implemented. Based on usage and requirements, stopping services could be an option:</p>
			<div><div><img src="img/B21217_06_01.jpg" alt="Figure 6.1 – Specifying budgets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Specifying budgets</p>
			<p>To get price <a id="_idIndexMarker345"/>information about services, at <a href="https://azure.microsoft.com">https://azure.microsoft.com</a>, you can select <strong class="bold">Azure pricing</strong>, search for products, or select a product from a category to get details of different offerings available. You will also see a pricing calculator where you select multiple products and get complete price information based on selections made.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Naming conventions and more</h2>
			<p>When creating resources within Azure, we should think about some important foundations <a id="_idIndexMarker346"/>to easily find resources based on the needs of IT but also based on the needs of business organizations. Which resources are for production, and which are for testing environments? Which resources are used by different organizations in the company? Which resources are used by one product? What are the resources potentially being impacted by a technical issue? For all these scenarios, these features help:</p>
			<ul>
				<li>Every resource <a id="_idIndexMarker347"/>needs to be put into one <code>codebreaker</code> solution, resource groups will be created for the test and production environments.</li>
				<li>It should also <a id="_idIndexMarker348"/>be easy to find multiple resources across resource groups. <strong class="bold">Resource tags</strong> can be used here.</li>
				<li>Define a convention for how you name your resources. The number of resources will grow over time! You might create multiple instances for scaling, run the same services around the globe in different regions for better latency, run services in different environments… there are many reasons the number of resources grows. To deal with this, a good naming strategy used from the start can help a lot!</li>
			</ul>
			<p>With the <code>codebreaker</code> application, we can use <code>rg-codebreaker-dev</code>, <code>rg-codebreaker-test</code>, and <code>rg-codebreaker-prod</code> resource groups for <em class="italic">development</em>, <em class="italic">test</em>, and <em class="italic">production</em> environments.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Besides separating the environments with different resource groups, it’s a good practice to separate the development and production environments into different subscriptions. As there’s an Azure subscription with some free amount available with a Visual Studio subscription, this subscription can be used with the development environment.</p>
			<p>Some resources are used across different resource groups. For example, you might use a central Azure DNS resource. You might also share resources across different applications. You can share an Azure app service that hosts many small websites. With every Azure resource, you can add custom tags and search for resources using different tags and their values. For example, you can specify a tag named <code>cc</code> (for cost center), and the value specifies the cost center.</p>
			<p>To define a <a id="_idIndexMarker349"/>naming convention for resources, Microsoft not only has a guideline (available at <a href="https://learn.microsoft.com/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming">https://learn.microsoft.com/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming</a>), but also an Excel template you can use (available at https://raw.githubusercontent.com/microsoft/CloudAdoptionFramework/master/ready/naming-and-tagging-conventions-tracking-template.xlsx), and even a Blazor application that you can host on-premises (or in the cloud) for your administrators to manage naming conventions with a simple user interface: https://github.com/mspnp/AzureNamingTool.</p>
			<p>Components that can be part of the name of resources include the following:</p>
			<ul>
				<li>The <em class="italic">resource type</em>. Microsoft has a list of proposed abbreviations; for example, <code>rg</code> for resource group, <code>cosmos</code> for an Azure Cosmos DB database, <code>cr</code> for ACR, <code>ca</code> for container apps, and <code>cae</code> for Container Apps environments.</li>
				<li>The project, application, or service name. We’ll use <code>codebreaker</code> for the application name.</li>
				<li>The environment where the resource is used; for example, <code>prod</code> for production, <code>dev</code> for development, and <code>test</code> for testing.</li>
				<li>The location of the Azure resource; for example, <code>eastus2</code> for the second East US region, and <code>westeu</code> for West Europe. Creating resources in multiple regions can be useful for failover scenarios, for better performance for customers around the globe, and because of data regulations.</li>
			</ul>
			<p>Now, we are ready to create Azure resources.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Creating Azure resources</h1>
			<p>Using <a id="_idIndexMarker350"/>Microsoft Azure, there are different ways to create and manage Azure resources. Azure resources are accessible via a REST API. You can send <code>GET</code> requests to read information about resources and <code>POST</code> requests to create new resources, but of course, there’s an easier way to do it. The Azure portal (<a href="https://portal.azure.com">https://portal.azure.com</a>) is a great way to learn and see the different options you have. To automatically create Azure resources, you can use the Azure CLI, PowerShell scripts, and many more options to use. In this book, we’ll use the Azure portal, Bicep scripts, .NET Aspire, and <code>azd</code>. Bicep scripts give you a simple syntax from Microsoft to easily recreate Azure resources. .NET Aspire offers to define Azure resources using .NET code and directly create the resources.</p>
			<p>Within company environments, there are different ways Azure resources are created and how teams are organized. .NET Aspire, together with <code>azd</code>, offers great functionality for creating Azure <a id="_idIndexMarker351"/>resources, but this might not (yet?) fit into your environment. You can also decide to use parts of .NET Aspire that fit into your company environment, or use all that .NET Aspire and <code>azd</code> offer. The second option is the easiest one. To better understand the options, and for you to map it into your environment, we’ll start using the Azure CLI and the Azure portal. With this, you can easily see what options a resource offers for configuration. Later in this chapter, we’ll use .NET Aspire and <code>azd</code>. Specifying Azure resources with .NET code just needs a few statements to create all the resources needed with the solution.</p>
			<p>What are the resources we create? In this section, we’ll do the following:</p>
			<ol>
				<li>Create a resource group that groups all Azure resources together.</li>
				<li>Create an Azure Cosmos DB database that is added to the previously created resource group and used by the EF Core context we created in <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>.</li>
				<li>Create an Azure container registry to publish the Docker images we created in <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>.</li>
				<li>Create two Azure container apps to run the <code>gamesAPI</code> service and the bot service.</li>
			</ol>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Creating a resource group</h2>
			<p>Resource <a id="_idIndexMarker352"/>groups are used to manage Azure resources together. With a resource group, you can specify permissions for who is allowed to create or manage resources within the resource group. From a price standpoint, you easily can see the cost of the complete resource group and which resources of this resource group were responsible for which cost. You can also delete a resource group, which deletes all resources within the group.</p>
			<p>To create a resource group, let’s use the Azure CLI.</p>
			<p>To log in to Azure, use the following command:</p>
			<pre class="console">
az login</pre>
			<p>This command opens the default browser to authenticate the user.</p>
			<p>If you have multiple Azure subscriptions, you can check these with <code>az account list</code>. The current active subscription where you create resources is shown with <code>az </code><code>account show</code>.</p>
			<p>To create <a id="_idIndexMarker353"/>a resource group, use the <code>az </code><code>group</code> command:</p>
			<pre class="console">
az group create -l westeurope -n rg-codebreaker-test</pre>
			<p>The <code>create</code> subcommand creates a resource group. With <code>-l</code>, we specify the location of this Azure resource. Here, I’m using <code>westeurope</code> because this region is near my location. With the <code>-n</code> value, the name of the resource group is set.</p>
			<p>The location of the resource group is independent of the location of the resources within the resource group. Resources within the resource group can have other regions. A resource group is just metadata. The location for the resource group specifies the primary location for the resource group. In a fatal case where the location is not available, you cannot make changes to the resource group.</p>
			<p>To get the regions available with your subscription, you can use <code>az account list-locations -</code><code>o table</code>.</p>
			<p>After the resource group is created, we can create resources within this resource group.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Creating an Azure Cosmos DB account</h2>
			<p>In <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, we used the Azure Cosmos DB emulator to store games and moves. Now, let’s change <a id="_idIndexMarker354"/>this to the real database in the Azure cloud. First, we’ll use the Azure portal to create an Azure Cosmos DB account.</p>
			<p>Within the Azure portal, by clicking on <code>Azure Cosmos DB</code>. When you click <strong class="bold">Create</strong> with the Azure Cosmos DB resource, this does not immediately create the resource. Instead, you need to do some configuration beforehand.</p>
			<p>With the <a id="_idIndexMarker355"/>Azure Cosmos DB resource, you first need to select one of the APIs available. Read back to <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a> for the different APIs available and what they offer. Now, select <strong class="bold">Azure Cosmos DB for NoSQL</strong>, and click the <strong class="bold">Create</strong> button. This opens the configuration, as shown in <em class="italic">Figure 6</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/B21217_06_02.jpg" alt="Figure 6.2 – Creating an Azure Cosmos DB account"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Creating an Azure Cosmos DB account</p>
			<p>You have some pages for configuration before you can click the <code>cosmos-codebreaker-test</code> for the test environment, but be aware this name needs to be globally unique), and the capacity. Azure Cosmos DB offers one free tier with a subscription. In case you haven’t used this yet with your subscription, you can choose this <a id="_idIndexMarker356"/>option. This gives you 1,000 <strong class="bold">request units per second</strong> (<strong class="bold">RU/s</strong>) and 25 GB of storage for free. Using provisioned throughput, you define a RU/s limit by database or by database container, at least 400 RU/s. The serverless <a id="_idIndexMarker357"/>option starts with a higher minimum limit but automatically scales to the RU/s needed. With serverless, you need to be aware of some limits. With serverless, the maximum database container size is 1 TB; there’s no limit with the provisioned configuration. Serverless also doesn’t support geo-distribution, which is available with the provisioned setting.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Creating an Azure Cosmos DB account registers a DNS name, thus the name needs to be globally unique. For your account, you can add a number following the account name, and check by clicking <strong class="bold">Review + create</strong> if your selected name is available.</p>
			<p>With the next configurations, you can configure the global distribution of a database, networking, a policy to automatically create backups, encryption with a service-managed key or a customer-managed key, and tags (which are available with every resource). You can use the default values with all the settings other than the basic configuration. Upon clicking on the <strong class="bold">Review + create</strong> button, final checks are made, and you can click the final <strong class="bold">Create</strong> button. Now, you just need to wait for a few minutes until the database account is created.</p>
			<p>Using the Azure CLI, you can use the <code>az cosmosdb </code><code>create</code> command.</p>
			<p>The database account is created! Next, we’ll create an Azure container registry.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, we not only created a library to write to Azure Cosmos DB but also to SQL Server. With Microsoft Azure, you can also configure Azure SQL Database. Just be aware of the low <a id="_idIndexMarker358"/>cost in the development environment; select a <strong class="bold">Database Transaction Unit</strong> (<strong class="bold">DTU</strong>) tier instead of the vCore tier. With 5 Basic DTUs, there’s just a cost lower than USD 5, for a month for 2 GB storage (at the time of this writing) compared to USD 400,- where a VM with 2 vCores is allocated.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Creating an Azure container registry</h2>
			<p>In the previous chapter, we created Docker images and used them locally. You can publish <a id="_idIndexMarker359"/>Docker images to the Docker hub, or any container <a id="_idIndexMarker360"/>registry. ACR offers a registry for Docker images that greatly integrates with Microsoft Azure.</p>
			<p>While creating an ACR instance, three different tiers are available:</p>
			<ul>
				<li><code>codebreaker</code> application, the Basic tier (SKU) fits the <a id="_idIndexMarker361"/>purpose and is a lot cheaper than the other options. You just need to be aware of the limits.</li>
				<li><strong class="bold">Standard</strong>: The Standard <a id="_idIndexMarker362"/>tier offers more storage (the Basic tier is limited to 10 GB storage) and image throughput.</li>
				<li><strong class="bold">Premium</strong>: The Premium <a id="_idIndexMarker363"/>tier adds some features, such as geo-replication replicates images across different regions and private access points.</li>
			</ul>
			<p><em class="italic">Figure 6</em><em class="italic">.3</em> shows how to create an ACR instance via the portal. Clicking on <code>Container Registry</code> in the search box. Selecting the <strong class="bold">Azure services only</strong> checkbox doesn’t show the many third-party offerings:</p>
			<div><div><img src="img/B21217_06_03.jpg" alt="Figure 6.3 – Creating a container registry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Creating a container registry</p>
			<p>With the <a id="_idIndexMarker364"/>configuration, we just need the <a id="_idIndexMarker365"/>name of the resource group, the name of the registry, the location, and the SKU. Availability zones, where the images are stored in different data centers in the same region, are only available with the Premium tier. Other configurations to change the networking and encryption require the Premium tier as well.</p>
			<p>Filling out this form, after clicking <strong class="bold">Review + create</strong>, you still can verify all the options before clicking <strong class="bold">Create</strong> to create the resources.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The name of the registry is a globally available DNS name (with the <code>azurecr.io</code> extension) and thus needs to be unique. Choose your own name where creating the resource succeeds with an available name.</p>
			<p>We now <a id="_idIndexMarker366"/>have a database and a registry for container <a id="_idIndexMarker367"/>images running. With the first resources created, all we need to run the application in the cloud is a compute service where we can run the Docker images. We will use Azure Container Apps.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Creating an Azure Container Apps environment</h2>
			<p>Microsoft Azure has several compute offerings to run Docker containers. You can publish <a id="_idIndexMarker368"/>a Docker image <a id="_idIndexMarker369"/>to an <strong class="bold">Azure app service</strong>, and use a <a id="_idIndexMarker370"/>Windows or Linux server to run your APIs. Another option is <a id="_idIndexMarker371"/>to use <strong class="bold">Azure Container Instances</strong> (<strong class="bold">ACI</strong>), which allows you to host a group of Docker containers, including one frontend container (the API service) and multiple backend containers. While Azure app services offer automatic scaling to create multiple instances based on rules, this feature is not available with ACI. ACI is great with a fast startup – you spin up a VM where just the smaller Docker image needs to be uploaded, but it doesn’t offer orchestration and scaling features.</p>
			<p>For full-blown <a id="_idIndexMarker372"/>orchestration and scaling of Docker containers, Azure offers <code>kubectl</code>. To remove the complexity of Kubernetes, defining an Ingress controller is just a matter of changing <a id="_idIndexMarker373"/>some settings; <strong class="bold">Azure Container Apps</strong> instances are available. This service makes use of Kubernetes behind the scenes but removes a lot of its complexity.</p>
			<p>Let’s get into creating an Azure container app.</p>
			<h3>Creating a Log Analytics workspace</h3>
			<p>When <a id="_idIndexMarker374"/>creating an <a id="_idIndexMarker375"/>Azure container app, having space for logging is a good idea. With previous versions of Azure Container Apps, it was a requirement to have a <strong class="bold">Log Analytics workspace</strong>. This is no longer a requirement, as you can <a id="_idIndexMarker376"/>also use Azure Monitor to log to an Azure storage account, an Azure event hub, or a third-party monitoring solution. Azure Monitor can also be configured to route logs to Log Analytics.</p>
			<p>A Log Analytics workspace is a storage unit for log data to analyze data and metrics. In <a href="B21217_10.xhtml#_idTextAnchor239"><em class="italic">Chapter 10</em></a>, <em class="italic">Logging</em>, we’ll dive into logging and metrics with microservices, and make use of Log Analytics, Azure Monitor, and Application Insights to get information about running services.</p>
			<p>To create a <a id="_idIndexMarker377"/>Log Analytics workspace, we will use the Azure CLI:</p>
			<pre class="console">
az monitor log-analytics workspace create -g rg-codebreaker-test -n logs-codebreaker-test-westeu</pre>
			<p>Log <a id="_idIndexMarker378"/>Analytics belongs to Azure Monitor, thus the <code>az monitor log-analytics</code> command is used to create and manage Log Analytics. With the <code>workspace create</code> subcommand, a Log Analytics workspace is created. This command requires the resource group and the name of the workspace. If the location is not supplied with the command, the workspace uses the same location as the resource group.</p>
			<h3>Creating a container app environment</h3>
			<p>Creating a container app environment uses a Kubernetes cluster behind the scenes. You can <a id="_idIndexMarker379"/>create this environment to create a Log Analytics workspace automatically. Using an existing <a id="_idIndexMarker380"/>workspace (we created one in the previous step), we need the customer ID and a key from the workspace. Get the customer ID using the following command:</p>
			<pre class="console">
az monitor log-analytics workspace show -g rg-codebreaker-test -n logs-codebreaker-test-westeu --query customerId</pre>
			<p>Without supplying <code>--query customerId</code>, you get more complete information about the workspace, including the <code>customerId</code> value. Using the <code>--query</code> command, we can <a id="_idIndexMarker381"/>supply a <code>customerId</code> with the query, just the unique identifier of this id (a GUID) is returned. Copy this GUID as well as the key from the next command as we’ll need these values when creating the environment.</p>
			<p>This command returns keys to connect to the log workspace:</p>
			<pre class="console">
az monitor log-analytics workspace get-shared-keys -g rg-codebreaker-test -n logs-codebreaker-test-westeu</pre>
			<p>The <a id="_idIndexMarker382"/>output returns primary and secondary shared keys. Copy the primary shared key.</p>
			<p>Using <a id="_idIndexMarker383"/>the customer ID as well as the key from the Log Analytics workspace, we can create a container app environment:</p>
			<pre class="console">
az containerapp env create -g rg-codebreaker-test -n cae-codebreaker-test-westeu --logs-workspace-id &lt;customer-id&gt; --logs-workspace-key &lt;logs-key&gt; --location westeurope</pre>
			<p>To create the environment, you need to specify the resource group, the name of the environment, information to connect log analytics, as well as the location of the newly created resource. This command does not use the location of the resource group if the location is not supplied. Be aware that this command might take several minutes. But think about how many minutes you would need to create a Kubernetes cluster manually.</p>
			<h3>Creating a hello container app</h3>
			<p>After creating <a id="_idIndexMarker384"/>the environment, let’s create our first app <a id="_idIndexMarker385"/>within this environment:</p>
			<pre class="console">
az containerapp create -n ca-hello-westeu -g rg-codebreaker-test --environment cae-codebreaker-test-westeu --image mcr.microsoft.com/azuredocs/containerapps-helloworld:latest --ingress external --target-port 80 --min-replicas 0 --max-replicas 2 --cpu 0.5 --memory 1.0Gi</pre>
			<p>Using the <code>create</code> command creates a new app. The name of this app is specified with the <code>-n</code> parameter. The environment is specified with the resource group (<code>-g</code>) and the <code>--environment</code> parameter. The image referenced with the <code>--image</code> parameter is a sample Docker image from Microsoft that hosts a web server with a static page. To access the web server running on port 80 within the container, the Ingress service is configured with the <code>--ingress</code> and <code>--target-port</code> parameters. Using the <code>--min-replicas</code> and <code>--max-replicas</code> parameters, scaling is defined to scale from 0 up to 2 instances. With 0 instances, the first user accessing the service needs to wait until the container is started. With the supplied configuration, the application scales up to 2 running containers. One container allocates 0.5 CPUs and 1.0 Gi memory.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><em class="italic">Chapters 9</em> to <em class="italic">11</em> will give you information about scaling services. In <a href="B21217_09.xhtml#_idTextAnchor216"><em class="italic">Chapter 9</em></a>, you’ll create load tests to stress-test services, in <a href="B21217_10.xhtml#_idTextAnchor239"><em class="italic">Chapter 10</em></a>, we’ll use these load tests to monitor metrics information, and in <a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a>, we’ll configure scaling with information learned in the previous two chapters.</p>
			<p>When <a id="_idIndexMarker386"/>the app is created, a link for the app service is shown. You <a id="_idIndexMarker387"/>can also get the URL using this command:</p>
			<pre class="console">
az containerapp show -n ca-hello-westeu -g rg-codebreaker-test --query properties.configuration.ingress.fqdn</pre>
			<p>The <code>containerapp show</code> command shows properties of the Azure container app. Using <a id="_idIndexMarker388"/>the <code>properties.configuration.ingress.fqdn</code> JMESPath query returns the <code>https://</code> instance shows the running application (see <em class="italic">Figure 6</em><em class="italic">.4</em>):</p>
			<div><div><img src="img/B21217_06_04.jpg" alt="Figure 6.4 – Accessing the hello Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Accessing the hello Azure container app</p>
			<p>Now, opening the <code>rg-codebreaker-test</code> resource group with the Azure portal, we can see <a id="_idIndexMarker389"/>the Azure Cosmos DB, ACR, and Azure Container <a id="_idIndexMarker390"/>Apps environments, the Log Analytics workspace, and the container app, as shown in <em class="italic">Figure 6</em><em class="italic">.5</em>. Just check the options you have with the categories on the left side of the <strong class="bold">Resource group</strong> view. The <strong class="bold">Overview</strong> view shows the resources, as shown here. Clicking on <strong class="bold">Access control</strong>, you can configure who has access to the resources of this group. The <em class="italic">activity log</em> shows who created, updated, and deleted resources within this group. The <em class="italic">resource visualizer</em> gives a graphical view of resources and how they relate to each other. The <strong class="bold">Cost Management</strong> category might also be of interest.</p>
			<p>You might need to wait for a day before seeing the detailed cost of each resource. With the tiers we used, the cost will be within a few cents. But you can also click on <strong class="bold">Recommendations</strong> to see what should be changed and configured with a production environment. Some of these recommendations require different tiers where you need to check into the cost changes. In case your company already experienced hacking into the company’s site, the cost of turning security features on with Microsoft Azure is really low compared to the cost of a hacking attack:</p>
			<div><div><img src="img/B21217_06_05.jpg" alt="Figure 6.5 – Resource group with Azure resources"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Resource group with Azure resources</p>
			<p>Now, as <a id="_idIndexMarker391"/>the Azure <a id="_idIndexMarker392"/>resources are created, let’s publish the <code>codebreaker</code> services to Microsoft Azure.</p>
			<p>Let’s start with creating an Azure Cosmos database within an Azure Cosmos DB account.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Creating an Azure Cosmos database</h1>
			<p>From the <a id="_idIndexMarker393"/>Azure portal, you can open the page for your Azure Cosmos DB account, open <strong class="bold">Data Explorer</strong>, and from there, click on <strong class="bold">New Database</strong> to create a new database, and <strong class="bold">New Container</strong> to create a container within the database. Here, we’ll use the Azure CLI instead:</p>
			<pre class="console">
az cosmosdb sql database create --account-name &lt;your cosmos account name&gt; -n codebreaker -g rg-codebreaker-test --throughput 400</pre>
			<p>This command creates a database named <code>codebreaker</code> in the existing account. Setting the throughput option with this command defines the scale of the database. Here, all containers within this database share the 400 RU/s throughput. 400 is the smallest value that can be set. Instead of supplying this value when creating the database, scaling can also be configured with every container. In case some containers should not take away scaling from other containers, configure the RU/s with every container – but here, the minimum value to be used with each container is 400 as well.</p>
			<p>After creating the database, let’s create a container:</p>
			<pre class="console">
az cosmosdb sql container create -g rg-codebreaker-test -a &lt;your cosmos account name&gt; -d codebreaker -n GamesV3, --partition-key-path "/PartitionKey"</pre>
			<p>The implementation of the <code>gamesAPI</code> service uses a container named <code>GamesV3</code>. This container is <a id="_idIndexMarker394"/>created within the previously created database, using the <code>/PartitionKey</code> partition key, as was specified with the EF Core context in <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>.</p>
			<p>After this command is completed, check <strong class="bold">Data Explorer</strong> in the Azure portal, as shown in <em class="italic">Figure 6</em><em class="italic">.6</em>:</p>
			<div><div><img src="img/B21217_06_06.jpg" alt="Figure 6.6 – Data Explorer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Data Explorer</p>
			<p>You can see the database, the container, and, with the container, the configured partition key.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Configuring replication with Azure Cosmos DB</h2>
			<p>A great <a id="_idIndexMarker395"/>feature of Azure Cosmos DB is global data replication. Within the Azure portal, in the <strong class="bold">Settings</strong> category, click on <strong class="bold">Replicate data globally</strong>. <em class="italic">Figure 6</em><em class="italic">.7</em> shows the replication view:</p>
			<div><div><img src="img/B21217_06_07.jpg" alt="Figure 6.7 – Replication with Azure Cosmos DB"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Replication with Azure Cosmos DB</p>
			<p>You just need to click on the Azure regions that are available with your subscription to replicate data within the selected regions. You can also configure it to write to multiple regions.</p>
			<p>With the <code>codebreaker</code> application where users around the world can play, for faster performance for users in the US, Europe, Asia, and Africa, writing to multiple regions can be configured. For this option to be available, automatic scaling cannot be configured. For the best scalability across the globe, we also need to think about the partition key. By using different partition key values for every game that’s stored, games can be stored within different partitions.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Configuring consistency</h2>
			<p>With <a id="_idIndexMarker396"/>the <strong class="bold">Settings</strong> category in the Azure portal of Azure Cosmos DB, we can configure the default consistency level. The outcomes are shown using music notes, reading, and writing from multiple regions, as shown in <em class="italic">Figure 6</em><em class="italic">.8</em>:</p>
			<div><div><img src="img/B21217_06_08.jpg" alt="Figure 6.8 – Outcome shown using music notes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Outcome shown using music notes</p>
			<p>The default setting is <strong class="bold">Session consistency</strong> – the data is consistent within the same session. With this setting, write latencies, availability, and read throughput are comparable to <strong class="bold">Eventual consistency</strong>. Using the Azure Cosmos DB API, a session can be created and distributed within the application.</p>
			<p>The <strong class="bold">Strong consistency</strong> option is not available if multiple regions are configured. With <a id="_idIndexMarker397"/>multiple regions, <strong class="bold">Bounded staleness</strong> can be configured, which specifies a maximum lag time and a number of maximum lag operations before the data is consistently replicated.</p>
			<p>The database is now ready to use, so let’s publish Docker images to the registry!</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Pushing images to the ACR instance</h1>
			<p>The ACR instance is ready, and we created Docker images in the previous chapter – now, let’s publish <a id="_idIndexMarker398"/>the images to this registry.</p>
			<p>After <a id="_idIndexMarker399"/>you’ve logged in to Microsoft Azure (using <code>az login</code>), to log in to the ACR instance, you can use <code>az acr login</code>. Make sure to use the name you defined with the ACR instance:</p>
			<pre class="console">
az login
az acr login -n &lt;the name of your azure container registry&gt;</pre>
			<p>This command needs to have Docker Desktop installed and running.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Referencing the ACR instance using the Azure CLI, just the name of the registry is needed (such as <code>codebreakertest</code>). The <code>docker</code> and <code>dotnet</code> commands support different registries, thus with these commands, the complete domain name is needed, such as <code>codebreakertest.azurecr.io</code>.</p>
			<p>Next, let’s <a id="_idIndexMarker400"/>build the images. With <a id="_idIndexMarker401"/>the game APIs, we created a Dockerfile in the previous chapter. With the Windows terminal, make sure to set the current directory to the <code>ch06</code> folder and build the game image locally:</p>
			<pre class="console">
docker build -f Codebreaker.GameAPIs\Dockerfile . -t codebreaker/gamesapi:3.5.1</pre>
			<p>This command – as in the previous chapter – builds the Docker image locally, referencing the Dockerfile, setting the context for <code>docker build</code>, and setting the tag.</p>
			<p>To publish the image to ACR, we need to tag the local images:</p>
			<pre class="console">
docker tag codebreaker/gamesapi:3.5.1 &lt;full DNS name of your ACR&gt;/codebreaker/gamesapi:3.5.1
docker tag codebreaker/gamesapi:3.5.1 &lt;full DNS name of your ACR&gt;/codebreaker/gamesapi:latest</pre>
			<p>The images are tagged with a link to the ACR instance. The same image is tagged with the version number as well as the <code>latest</code> tag. The <code>latest</code> tag is a convention where the newest version is stored and is always overridden in the repository.</p>
			<p>Next, push the image to the registry with <code>docker push</code>:</p>
			<pre class="console">
docker push &lt;full DNS name of your ACR&gt;/codebreaker/gamesapi:3.5.1
docker push &lt;full DNS name of your ACR&gt;/codebreaker/gamesapi:latest</pre>
			<p>Make sure you are already logged in to the ACR instance; otherwise, the push will fail.</p>
			<p>With a successful push, you can see the images in the Azure portal within the <strong class="bold">Repositories</strong> menu, as shown in <em class="italic">Figure 6</em><em class="italic">.9</em>:</p>
			<div><div><img src="img/B21217_06_09.jpg" alt="Figure 6.9 – Repositories in ACR"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Repositories in ACR</p>
			<p>With the <a id="_idIndexMarker402"/>bot service, we didn’t create <a id="_idIndexMarker403"/>a Dockerfile in the previous chapter and used the dotnet CLI instead. Using <code>dotnet publish</code>, we just need to add this <code>PropertyGroup</code> instance to the project file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Bot/Codebreaker.Bot.csproj project file</p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
<strong class="bold">  </strong><strong class="bold">&lt;ContainerRegistry&gt;add your registry</strong>
<strong class="bold">  &lt;/ContainerRegistry&gt;</strong>
<strong class="bold">  &lt;ContainerRepository&gt;codebreaker/bot</strong>
<strong class="bold">  &lt;/ContainerRepository&gt;</strong>
<strong class="bold">  &lt;ContainerImageTags&gt;3.5.3;latest&lt;/ContainerImageTags&gt;</strong>
&lt;/PropertyGroup&gt;</pre>
			<p>The <code>dotnet publish</code> command uses <code>ContainerRegistry</code>, <code>ContainerRepository</code>, and <code>ContainerImageTags</code> elements to create the image and publish it to the registry. Pay attention to configuring your own registry with the <code>ContainerRegistry</code> element.</p>
			<p>All that needs to be done with the current directory is to set the directory of the project file of the bot and run <code>dotnet publish</code>:</p>
			<pre class="console">
cd Codebreaker.Bot
dotnet publish --os linux --arch x64 /t:PublishContainer -c Release</pre>
			<p>This <a id="_idIndexMarker404"/>command builds the image and <a id="_idIndexMarker405"/>directly publishes it to the registry, as specified with the <code>ContainerRegistry</code> element. Just make sure to enter the link to your registry, and be logged in using <code>docker login</code>.</p>
			<p>As the images are ready, let’s continue using them with Azure container apps!</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Creating Azure container apps</h1>
			<p>Let’s create a <code>gamesAPI</code> service running with an Azure container app. This one needs a configuration containing a secret to the Azure Cosmos database.</p>
			<p>With the <a id="_idIndexMarker406"/>Azure Cosmos database, in the Azure portal, go to the <strong class="bold">Settings</strong> category and open <strong class="bold">Keys</strong>. From this page, copy the primary or the secondary connection string.</p>
			<p>With such keys, it’s useful to regenerate them from time to time – that’s why pairs are available. When you use the primary key from apps, regenerate the secondary key. After the regeneration, use the secondary key from within the apps, and regenerate the primary key. With this, you have some time to configure all the apps for the new key.</p>
			<p>When creating an Azure container app for game APIs, there are quite some values to configure. While you can pass all the configuration values to the <code>az containerapp create</code> command, let’s start creating this with the Azure portal. Opening the resource of the Azure container app environment, click on <strong class="bold">Apps</strong>, and create a new app. <em class="italic">Figure 6</em><em class="italic">.10</em> shows the basic settings:</p>
			<div><div><img src="img/B21217_06_10.jpg" alt="Figure 6.10 – Basic settings for the Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Basic settings for the Azure container app</p>
			<p>With the <a id="_idIndexMarker407"/>basic settings, these values need to be configured:</p>
			<ul>
				<li>The subscription for the resource.</li>
				<li>The resource group (<code>rg-codebreaker-test</code>).</li>
				<li>The name of the container app. We use <code>cae-codebreaker-gamesapi-3</code>. The suffix 3 names version 3 of this API. You can run different versions of this app in parallel.</li>
				<li>The region – select the region that best fits your location.</li>
				<li>The container app environment. Select the environment created earlier.</li>
			</ul>
			<p>The configuration screen for the container app is shown in <em class="italic">Figure 6</em><em class="italic">.11</em>:</p>
			<div><div><img src="img/B21217_06_11.jpg" alt="Figure 6.11 – Container settings for the Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Container settings for the Azure container app</p>
			<p>Here, we select <a id="_idIndexMarker408"/>the image that will be published by selecting the ACR instance and the image name and tag, the CPU and memory resources that should be allocated for one running instance, and environment variables. Setting the <code>DataStorage</code> environment variable to <code>Cosmos</code> overrides the values defined in the <code>appsettings.json</code> file.</p>
			<p><em class="italic">Figure 6</em><em class="italic">.12</em> shows the <strong class="bold">Ingress</strong> configuration:</p>
			<div><div><img src="img/B21217_06_12.jpg" alt="Figure 6.12 – Ingress settings for the Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Ingress settings for the Azure container app</p>
			<p>We need <a id="_idIndexMarker409"/>to enable <code>8080</code>, as defined by the .NET 8 images.</p>
			<p>Clicking on <strong class="bold">Create</strong> creates the Azure container app by getting the image from the ACR instance. Be aware that starting the app will fail, as the connection string to the Cosmos database still needs to be configured. We will do this after creating the app for the bot service.</p>
			<p>To create the app for the bot service, open the newly created container app in the Azure portal, and copy the <em class="italic">application URL</em> from the <strong class="bold">Overview</strong> view. This URL is needed for the configuration of the bot.</p>
			<p>When creating <a id="_idIndexMarker410"/>an app for the bot service, you can configure it similarly to the game APIs. The <code>codebreaker/bot</code> image. Create an environment variable with the name <code>ApiBase</code>, and the value with the application URL from the game APIs.</p>
			<p>We still need to add some configuration values, which we’ll do next.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Configuring secrets and environment variables</h2>
			<p>Defining <a id="_idIndexMarker411"/>secrets for the application is not directly possible with the portal when creating the app. This would be possible directly using the <code>az containerapp </code><code>create</code> command.</p>
			<p>With the portal, the secret can be configured afterward. When opening the container app within the Azure portal, in the <code>cosmosconnectionstring</code>, as shown in <em class="italic">Figure 6</em><em class="italic">.13</em>, and copy the connection string you copied from Azure Cosmos DB to the value:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <a id="_idIndexMarker412"/>screenshot in <em class="italic">Figure 6</em><em class="italic">.13</em> shows another option where secrets can be stored: a Key Vault reference. In <a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a>, we’ll discuss using other options to use configurations, which include <strong class="bold">Azure </strong><strong class="bold">Key Vault</strong>.</p>
			<div><div><img src="img/B21217_06_13.jpg" alt="Figure 6.13 – Secret configuration with the Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Secret configuration with the Azure container app</p>
			<p>To create an environment variable that references the secret, we can use the Azure CLI:</p>
			<pre class="console">
az containerapp update -n cae-codebreaker-gamesapi-3 -g rg-codebreaker-test --set-env-vars ConnectionStrings__GamesCosmosConnection=secretref:cosmosconnectionstring</pre>
			<p>Using <a id="_idIndexMarker413"/>the <code>az containerapp update</code> command, we need to reference the container app and the resource group and set environment variables using <code>--set-env-vars</code>. Contrary to passing hierarchical configuration values to the command line where <code>:</code> is used as a separator, such as <code>ConnectionStrings:GamesCosmosConnection</code>, with environment variables, using <code>:</code> is not possible. Instead, here, <code>__</code> maps values. The key that’s specified for the connection to the Azure Cosmos DB instance is <code>ConnectionStrings__GamesCosmosConnection</code>. The value for this is stored in a secret. A secret is referenced with <code>secretref</code>, followed by the secret key.</p>
			<p>The application should be running now, but let’s make sure to configure scaling.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Configuring scaling with Azure Container Apps</h2>
			<p>The <a id="_idIndexMarker414"/>default scaling configured with Azure Container Apps is scaling from 0 to 10. If no load is on the app, it scales down to 0 where CPU and memory costs are reduced to zero. However, scaling to 0 also means that the first user accessing the service needs to wait for a few seconds before the service returns results. With the bot service that’s running in the background and doesn’t need some user interaction after the first invocation, this can be fast enough. With app jobs that are triggered from messages or events, this is also OK. However, with the <code>gamesAPI</code> service, this should be responsive for the first user accessing the service.</p>
			<p>Configuring the minimum scale to 1 has a reduced price for the CPU if there’s no load. With idle pricing, the memory doesn’t have a price difference, but the CPU is about 10% of the cost compared to a running service.</p>
			<p>Let’s <a id="_idIndexMarker415"/>configure the <code>gamesAPI</code> service to scale from 1 to 3 replicas, and the bot service to scale from 0 to 3. Within the Azure portal, select the container app, the <strong class="bold">Applications</strong> category, and the <strong class="bold">Scale and replicas</strong> menu. Click the <strong class="bold">Edit and deploy</strong> menu, select <strong class="bold">Scale</strong>, and change the replicas to 1 to 3 and to 0 to 3 depending on the app. In case the UI elements are not easily movable to change the values accordingly, you can use the arrow keys to change the values one by one. The maximum scale count (at the time of this writing) is 300.</p>
			<p>Clicking on <strong class="bold">Create</strong> does a redeploy and creates a new revision of the app. By default, only one revision is active at a time. As soon as the new revision successfully starts up, the load balancer moves 100% of the traffic to the new revision. With the <strong class="bold">Applications</strong> | <strong class="bold">Revisions</strong> menu, you can see active and inactive revisions. There, you also can configure the revision mode. The default revision mode is <strong class="bold">Single</strong>, where just one revision is active. You can change this to <strong class="bold">Multiple</strong>, where several revisions are running concurrently, and you can configure how much percentage of the traffic should be distributed to which revision. This can be useful to test different versions running on a user load.</p>
			<p>With this in place, let’s try to run the application. You can open the Swagger page of the bot to let the bot play some games. You can also use a client you created in <a href="B21217_04.xhtml#_idTextAnchor092"><em class="italic">Chapter 4</em></a>, configure the address with the Container App game API’s URL, and play a game. Check into the <strong class="bold">Data Explorer</strong> section of Cosmos DB to see the games stored.</p>
			<p>As you now know all the Azure services used in the first place, you can delete Azure resources and recreate them easily in the next section.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Creating Azure resources with .NET Aspire and azd</h1>
			<p>Here, we’ll <a id="_idIndexMarker416"/>look into how to easily create <a id="_idIndexMarker417"/>Azure resources from the development system. First, we <a id="_idIndexMarker418"/>use some <a id="_idIndexMarker419"/>resources from the Azure cloud, while most of the projects are running locally on the development system, before we publish the complete solution to Azure.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>Provisioning Azure resources while debugging</h2>
			<p>When creating API services and using databases, you might not need any Azure resources <a id="_idIndexMarker420"/>when debugging the application locally. The API can run locally; even building Docker images is not required here. To run the database, a Docker image can be used easily, as you’ve already seen in <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>. However, for some Azure resources that you might also use during development, creating and connecting Azure resources is required. One example is Azure Application Insights (which is covered in detail in <a href="B21217_08.xhtml#_idTextAnchor183"><em class="italic">Chapter 8</em></a>).</p>
			<p>To use Azure resources with the application map in the <code>AppHost</code> project, you need to add the <code>A</code><code>spire.Hosting.Azure.* packages</code>. To use Azure resources to define the app model, packages such as <code>Aspire.Hosting.Azure</code> and <code>Aspire.Hosting.Azure.cosmosDB</code> are available.</p>
			<p>Provisioning of Azure resources happens automatically when the Azure resources are specified with the app model:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
string dataStore = builder.Configuration["DataStore"] ?? "InMemory";
<strong class="bold">var cosmos = builder.AddAzureCosmosDB("codebreakercosmos")</strong>
<strong class="bold">  .AddDatabase("codebreaker");</strong>
// code removed for brevity</pre>
			<p>The <code>AddAzureProvisioning</code> method creates Azure resources or retrieves the connection string when starting the application. Before this can successfully run, you need to specify your subscription ID and the location where the resources are created:</p>
			<pre class="source-code">
{
  "Azure": {
    "SubscriptionId": "your subscription id",
    "Location": "westeurope",
    "CredentialSource":"AzureCli"
  }
}</pre>
			<p>This <a id="_idIndexMarker421"/>information should not be part of the source code repository, thus add it to the user secrets. The <code>SubscriptionId</code> and <code>Location</code> keys need to be specified within the <code>Azure</code> category. Adding a <em class="italic">CredentialSource</em> is optional. The user to create the resources is selected using the DefaultAzureCredential (see <a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a> for details). In case this is not working in your environment, you can configure AzureCli which uses the account you are logged in with the Azure CLI.</p>
			<p>To get the subscription ID, you can use the following command:</p>
			<pre class="console">
az account show -–query id</pre>
			<p>You need to be logged in to your subscription not only to see the subscription ID but also to deploy the resources automatically. After running the application, you can see the deployed resources are written to the user secrets as well.</p>
			<p>This app model defines provisioning and using the Azure Cosmos DB database without using the emulator:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
string dataStore = builder.Configuration["DataStore"] ?? "InMemory";
<strong class="bold">var cosmos = builder.AddAzureCosmosDB("codebreakercosmos")</strong>
<strong class="bold">  .AddDatabase("codebreaker");</strong>
var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
<strong class="bold">  </strong>.WithExternalHttpEndpoints()
<strong class="bold">  .WithReference(cosmos)</strong>
  .WithEnvironment("DataStore", dataStore);
builder.AddProject&lt;Projects.CodeBreaker_Bot&gt;("bot")
.WithExternalHttpEndpoints()
  .WithReference(gameAPIs);
<strong class="bold">builder.AddProject&lt;Projects.Codebreaker_CosmosCreate&gt;("cosmoscreate")</strong>
<strong class="bold">  .WithReference(cosmos);</strong>
builder.Build().Run();</pre>
			<p>To avoid the need to install and run the local Azure Cosmos DB emulator, and to get rid of some <a id="_idIndexMarker422"/>issues using Azure Cosmos DB in the Docker image, we can use Azure Cosmos DB in the cloud. Not using the <code>RunAsEmulator</code> method with <code>AddAzureCosmosDB</code>, we use the resource running in Azure. The <code>AddDatabase</code> method adds the <code>codebreaker</code> database to the account. The <code>Codebreaker.CosmosCreate</code> project is used to run once, invoking the <code>EnsureCreatedAsync</code> method of the EF Core context to create a container with the partition key. The <code>WithReference</code> method used both with the <code>gamesAPI</code> service and the <code>CosmosCreate</code> project passes the newly created Azure Cosmos DB connection string to these resources. The <code>WithExternalEndpoints</code> method configures the Ingress controller of the Azure App Configuration to make this service external available.</p>
			<p><em class="italic">Figure 6</em><em class="italic">.14</em> shows the .NET Aspire dashboard with the application running:</p>
			<div><div><img src="img/B21217_06_14.jpg" alt="Figure 6.14 – .NET Aspire dashboard with deployed Azure resources"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – .NET Aspire dashboard with deployed Azure resources</p>
			<p>The <code>codebreakercosmos</code> resource shows an endpoint with the <code>deployment</code> link text. This is a resource deployed to Azure. Clicking this link, you are directly navigated to this cloud resource and can check the database and container name are created. The <code>cosmoscreate</code> reference is in the <strong class="bold">Finished</strong> state, thus the creation of the container is done.</p>
			<p>Now let’s <a id="_idIndexMarker423"/>start the bot and let it run some games, then open <strong class="bold">Data Explorer</strong> with Azure Cosmos DB, and you’ll see the games created. You can debug the solution locally while using some of the resources in the cloud, just by adding one API method.</p>
			<p>The resource group created here uses the name <code>rg-aspire-{yourhost}-codebreaker.apphost</code>. If multiple developers use the same Azure subscription, resources are created independently of each other to not get into conflicts. Make sure to delete resources when not needed.</p>
			<p>Next, let’s create the complete solution to run with Azure.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Provisioning the complete solution with azd up</h2>
			<p>For <a id="_idIndexMarker424"/>this, we use <code>azd</code>. First, in the directory of the solution, use the following command:</p>
			<pre class="console">
azd init</pre>
			<p>This initializes an application to be used with <code>azd</code>. You can use a template to create a new solution or analyze an existing application. As we already have a running application, select <code>Use code in the current directory</code> to analyze the application. The application needs to be stopped because <code>azd</code> also starts the compilation. With a successful scan, <code>azd</code> informs to host the app using <code>bot</code> and <code>gamesAPI</code> services. Then, define an environment (for example, <code>codebreaker-06</code>) using a chapter suffix.</p>
			<p>What happened? This command created a <code>.azure</code> folder and <code>azure.yaml</code> and <code>next-steps.md</code> files. <code>next-steps.md</code> gives information about what you can do next. <code>azure.yaml</code> is a short file containing information that references the <code>AppHost</code> project running with a <code>containerapp</code>. The most interesting generated information can <a id="_idIndexMarker425"/>be found in the <code>.azure</code> folder. This folder is excluded from the source code repository as it can contain secrets. In this folder, you can see the environments that are configured, as well as the configuration about which services should be public.</p>
			<p>To publish the complete solution to Azure, just use the following command:</p>
			<pre class="console">
azd up</pre>
			<p>With the first run, you need to select the Azure subscription to deploy the resources to, and the location for the Azure region. Next, you just need to wait several minutes until all the resources have been deployed.</p>
			<p>In the provisioning phase, these resources are deployed:</p>
			<ul>
				<li>A resource group</li>
				<li>A container registry</li>
				<li>A key vault</li>
				<li>A Log Analytics workspace</li>
				<li>A Container Apps environment</li>
			</ul>
			<p>After the provisioning phase, the deployment phase starts with these actions:</p>
			<ul>
				<li>Pushing Docker images to the ACR instance</li>
				<li>Creating container apps in the Container Apps environment using the images from the ACR instance</li>
			</ul>
			<p>As you make any changes to the source code or the configuration, you just need to use <code>azd up</code> again to deploy the updates. As the created environment is no longer needed, use <code>azd down</code> to delete all the resources again. Make sure to wait until you are asked for verification as to whether the number of resources should really be deleted.</p>
			<p>Checking <a id="_idIndexMarker426"/>the resource group within the Azure portal, you can see all resources created, as shown in <em class="italic">Figure 6</em><em class="italic">.15</em>:</p>
			<div><div><img src="img/B21217_06_15.jpg" alt="Figure 6.15 – Resources created from azd up"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Resources created from azd up</p>
			<p>Now, you can check the resources deployed, the images published to the container registry, the applications published to the container apps environment, the key vault containing a secret, and the Azure Cosmos DB account with the database and the configured container. Let the bot play games and verify if everything is running.</p>
			<p>Next, let’s get into the details of what happened with <code>azd up</code>.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>Diving into azd up stages</h2>
			<p>Running <a id="_idIndexMarker427"/>the <code>AppHost</code> project, command-line arguments can be passed to create a manifest file describing all the resources:</p>
			<pre class="console">
dotnet run --project Codebreaker.AppHost/Codebreaker.AppHost.csproj -- --publisher manifest --output-path aspire-manifest.json</pre>
			<p>When using <code>dotnet run</code>, command-line arguments can be passed to the application by using <code>--</code> to differentiate from the arguments of <code>dotnet run</code>. Using the -<code>–publisher manifest</code> option creates an Aspire manifest describing the app model of the application. This manifest specifies all resources with the resource type, bindings, environment variables, and paths to the projects. This information is used by <code>azd</code> to create Azure resources and can be used from other tools to, for example, deploy the solution to Kubernetes.</p>
			<p>Next, <code>azd provision</code> is used. In case you just want to provision Azure resources without pushing Docker images and deploying the Azure container apps, use the following command:</p>
			<pre class="console">
azd provision</pre>
			<p><code>azd provision</code> uses the manifest file to create Bicep files in memory and creates Azure resources.</p>
			<p>You can <a id="_idIndexMarker428"/>use this command when any Azure resources are added to the app model, then just these resources are created.</p>
			<p>The next step is the following:</p>
			<pre class="console">
azd deploy</pre>
			<p><code>azd deploy</code> pushes the container images to the ACR instance using <code>dotnet publish</code>, and then creates or updates Azure resources using these images.</p>
			<p><code>azd up</code> creates Bicep scripts in memory. It’s also possible to create Bicep scripts on disk to use them to create Azure resources, as we’ll do next.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>Creating Bicep files using azd</h2>
			<p>Bicep is <a id="_idIndexMarker429"/>a domain-specific language using <a id="_idIndexMarker430"/>declarative syntax. Before Bicep was available, we created <strong class="bold">Azure Resource Manager</strong> (<strong class="bold">ARM</strong>) templates to create Azure resources. ARM templates are defined using JSON. Bicep is simpler to write than ARM templates. During deployment, Bicep files are converted to ARM templates.</p>
			<p>Here, we use <code>azd infra</code> to create Bicep files for the solution.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of this writing, <code>azd infra</code> is in an early stage. Check the README file of this chapter for updates.</p>
			<p>Start this command from the directory of the solution:</p>
			<pre class="console">
azd infra synth</pre>
			<p>This <a id="_idIndexMarker431"/>command creates an <code>infra</code> folder with these files:</p>
			<ul>
				<li><code>main.bicep</code> – The main bicep file that creates a resource group and references modules to create more resources.</li>
				<li><code>main.parameters.json</code> – A parameters file that is used to pass parameters such as the environment name and the location to the <code>main.bicep</code> file.</li>
				<li><code>resources.bicep</code> – This file is referenced by <code>main.bicep</code> and contains resources such as the ACR instance, the Log Analytics workspace, the Container Apps environment, and the Azure key vault that are created.</li>
				<li><code>codebreakercosmos/codebreakercosmos.bicep</code> – This file is referenced from <code>main.bicep</code> as well and contains resource information for Azure Cosmos DB, as well as an Azure Key Vault secret that’s written to the Azure key vault. The secret itself is not part of this file; the secret is retrieved dynamically from the Azure Cosmos DB account when creating this resource.</li>
			</ul>
			<p>In case you customize these generated Bicep files, the customized files are used by <code>azd up</code> or <code>azd provision</code> on creating the Azure resources.</p>
			<p>With the <code>bot</code> and <code>gamesAPI</code> projects, <code>azd infra</code> also creates an infra folder with template files in the AppHost project; for example <code>gameapis.tmpl.yaml</code>. With these files, the Azure Container Apps instances can be customized; for example, by changing CPU and memory sizes or changing the number of replicas that should be used. Changing these values, <code>azd up</code> or <code>azd deploy</code> makes use of these files.</p>
			<p>When you open the resource group you previously created with <code>azd up</code>, open <strong class="bold">Deployments</strong> in the <strong class="bold">Settings</strong> category. This shows deployments of the resource group, as shown in <em class="italic">Figure 6</em><em class="italic">.16</em>:</p>
			<div><div><img src="img/B21217_06_16.jpg" alt="Figure 6.16 – Deployments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Deployments</p>
			<p>The deployments match the Bicep files used. When you open <strong class="bold">Related events</strong>, you can see all the steps that have been done with these deployments.</p>
			<p>After you don’t need the resources anymore, use this command to delete all the resources again:</p>
			<pre class="console">
azd down</pre>
			<p>This tool <a id="_idIndexMarker432"/>retrieves the number of Azure resources to delete and asks if this should be done – thus, make sure to wait until you can answer yes. After the deletion of the resources is complete, which usually takes more than 10 minutes, another question is asked if the data from the key vault should be purged. If you don’t answer yes to this question, this data can be recovered for 90 days, and during that time you cannot create the resource with the same name again until the end of this recovery time.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Summary</h1>
			<p>In this chapter, you learned to create Microsoft Azure resources using the Azure CLI, the Azure portal, and .NET Aspire with <code>azd</code>. The <code>gamesAPI</code> service is now running with Microsoft Azure resources using ACR, Azure Container Apps, and the Azure Cosmos DB database. When using <code>azd</code> together with .NET Aspire, just one command was needed to deploy all the services.</p>
			<p>Before moving on to the next chapter, let’s configure the client application you used in previous chapters to now use the URL from the Azure container app instead of the local services, and play some games.</p>
			<p>In this chapter, the Azure key vault was already created. In the next chapter, we look into the configuration of the backend services, which includes Azure Key Vault, and use Azure App Configuration as a central place for the configuration of all <code>codebreaker </code>services.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the following links:</p>
			<ul>
				<li>Azure round-trip latency statistics with Azure regions: <a href="https://learn.microsoft.com/azure/networking/azure-network-latency">https://learn.microsoft.com/azure/networking/azure-network-latency</a></li>
				<li>Azure Cosmos DB – databases, containers, and items: <a href="https://learn.microsoft.com/azure/cosmos-db/resource-model">https://learn.microsoft.com/azure/cosmos-db/resource-model</a></li>
				<li>Stored procedures, triggers, and user-defined functions: https://learn.microsoft.com/azure/cosmos-db/nosql/how-to-write-stored-procedures-triggers-udfs</li>
				<li>Azure Container Apps: <a href="https://learn.microsoft.com/azure/container-apps/">https://learn.microsoft.com/azure/container-apps/</a></li>
				<li>Bicep: https://learn.microsoft.com/azure/azure-resource-manager/bicep</li>
				<li><code>azd</code> reference: <a href="https://learn.microsoft.com/en-gb/azure/developer/azure-developer-cli/reference">https://learn.microsoft.com/en-gb/azure/developer/azure-developer-cli/reference</a></li>
			</ul>
		</div>
	</body></html>