- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Code Analysis and Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter elevates our skills by focusing on advanced code analysis and refactoring
    techniques in Visual Studio 2022.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the fundamentals of code analysis, particularly through the lens
    of static code analysis powered by Roslyn, lays a robust foundation for identifying
    vulnerabilities and ensuring code correctness. Moreover, with built-in IntelliCode,
    which harnesses machine learning to optimize code bases, you’ll learn how to enhance
    maintainability and scalability effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond these foundational concepts, we’ll also delve into the importance of
    code metrics, providing invaluable insights into evaluating the maintainability
    and security postures of your projects. By using these metrics, you’ll gain the
    strategic foresight required to make informed decisions and enact targeted enhancements
    to your code base.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, I’ll illustrate these concepts with real-world code
    review refactoring case studies. By exploring the practical applications of Visual
    Studio tools, you’ll not only grasp theoretical concepts but also understand how
    to implement them effectively in your day-to-day development workflows.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll emerge equipped with the knowledge and required
    tools to elevate the quality of your code, enhance security practices, and streamline
    maintenance efforts—all within the familiar and powerful environment of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding code analysis in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing static code analysis for quality assurance and security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging IntelliCode for code refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using code metrics for maintainability and security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring case studies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022, version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch03](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch03)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding code analysis in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let’s discuss how Visual Studio and .NET work to analyze our code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code analysis** in Visual Studio 2022 is designed to help us improve the
    quality of our code. It provides several tools and metrics to analyze and enhance
    code maintainability, readability, and performance. By identifying potential issues
    and suggesting improvements, it aims to streamline the development process, reduce
    bugs, and improve overall code quality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 can perform code analysis in two primary ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Legacy analysis (FxCop static analysis)** : This method analyzes compiled
    code to identify issues. It’s an old approach that only checks the code after
    it has been compiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET Compiler Platform-based code analyzers** : These are modern analyzers
    that analyze your code live as you type. They are dynamic and can provide real-time
    feedback, making it easier to catch and fix issues early in the development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s delve into the .NET Compiler Platform, also known as **Roslyn** ,
    which revolutionizes code analysis capabilities in Visual Studio 2022. Roslyn
    is a platform that exposes the C# and Visual Basic compilers’ code analysis capabilities
    to developers. It provides a set of APIs that allow the creation of tools and
    applications focused on code analysis, refactoring, and transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some benefit of Roslyn:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rich language support** : Roslyn supports the C# and Visual Basic languages,
    providing comprehensive language features and syntax support for building custom
    developer tools and extensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programmatic code manipulation** : With Roslyn, we can programmatically analyze,
    refactor, and generate code using .NET APIs, empowering them to automate repetitive
    tasks and improve code quality and consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IDE extensibility** : Roslyn enables the development of custom IDE extensions
    and tools that enhance the functionality of Visual Studio and other .NET IDEs,
    extending their capabilities to support specialized workflows and development
    scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source community** : Roslyn is an open source project hosted on GitHub
    that fosters collaboration and contributions from the developer community. Developers
    can contribute enhancements, bug fixes, and new features to the Roslyn code base,
    driving the innovation and evolution of the platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roslyn significantly reduces the difficulty of creating tools and applications
    focused on code, paving the way for innovation in various domains, including meta-programming,
    generating and transforming code, integrating interactive features into C# and
    Visual Basic languages, and embedding these languages into specialized domains.
  prefs: []
  type: TYPE_NORMAL
- en: How Roslyn works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Roslyn revolutionizes the traditional compiler structure by decomposing it into
    distinct components. Moreover, it provides access to each phase of the compiler
    pipeline through APIs that mirror the compiler’s internal processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an illustration of how this mirroring is organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Compiler API and Complier Pipeline](img/B22218_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Compiler API and Complier Pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler API and compiler pipeline provide access to several key phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parse Phase** : Source code undergoes tokenization and parsing, resulting
    in a syntax tree that adheres to the language’s grammar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declaration Phase** : Declarations from both source code and imported metadata
    are analyzed to construct named symbols. These symbols are organized into a hierarchical
    symbol table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bind Phase** : Identifiers within the code are matched to symbols, generating
    a semantic model that reflects the compiler’s analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emit Phase** : The compiler accumulates all relevant information and emits
    it as an assembly. This assembly is represented through an API that produces **Intermediate
    Language** ( **IL** ) byte code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This modular approach grants comprehensive access to information at each stage
    of the compiler pipeline. It empowers developers with rich capabilities for code
    analysis and manipulation. The availability of three-phase compiler APIs (syntax
    trees, semantic model, and workspace level) is particularly instrumental in facilitating
    robust code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: First, the **syntax trees** serve as a foundational representation of the structure
    of source code, encompassing both lexical and syntactic elements. They are pivotal
    in various stages of software development, including compilation, code analysis,
    binding, refactoring, and IDE functionalities. Offering a complete reflection
    of the source information, syntax trees maintain fidelity with the original text,
    ensuring immutability and thread safety. This facilitates the natural manipulation
    of source code without direct textual edits.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to semantics, the **semantic model** delves deeper into the meaning behind
    the code. It captures all semantic details within a single source file, shedding
    light on symbol references, expression types, diagnostics (errors and warnings),
    variable flow within source regions, and other nuanced aspects. By encapsulating
    language rules, this model enables clear distinctions between program elements
    in source code and those from precompiled libraries.
  prefs: []
  type: TYPE_NORMAL
- en: At the workspace level, a central hub organizes information across entire solutions,
    streamlining code analysis and refactoring processes. This layer consolidates
    project data into a cohesive object model, offering seamless access to compiler
    layer object models without the need for file parsing, configuration adjustments,
    or inter-project dependency management. Crucially, it underpins the development
    of robust code analysis and refactoring tools within integrated development environments
    such as Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How does Visual Studio 2022 use Roslyn?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio 2022 uses the .NET Compiler Platform (Roslyn) to analyze and refactor
    C# or Visual Basic code in real time as developers write code. This process is
    integrated into the development environment, providing immediate feedback on code
    style, quality, maintainability, design, and other issues. In the subsequent sections,
    we’ll learn how Visual Studio 2022 utilizes Roslyn for analysis and refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing with Roslyn analyzers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual Studio 2022 includes built-in code style analyzers (IDExxxx, e.g., IDE0001)
    and code quality analyzers (CAxxxx, e.g., CA1822) that inspect your code during
    design time in all open files. These analyzers are part of the .NET 5 SDK and
    are enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: We can install external analyzers, such as **StyleCop** , **Roslynator** , **XUnit
    Analyzers** , and **SonarAnalyzer** , as NuGet packages or Visual Studio extensions.
    These analyzers extend the built-in capabilities, allowing more specialized checks
    and rules.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we create our own custom analyzer using the **Analyzer with Code
    Fix** template, which includes a VSIX extension and a separate project for the
    analyzer. This can be deployed via NuGet. That allows us to create our own custom
    analyzer. The analyzer can show a squiggly line below the matching code and an
    entry in the error list, with optional code fixes. This approach allows a more
    integrated development experience, with feedback and fixes available directly
    within the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: For scenarios where analysis does not require integration with Visual Studio,
    such as on a build server, we can use the **Standalone Code Analysis Tool** template.
    This tool opens a solution workspace and analyzes projects without requiring VSIX
    extensions or NuGet packages to be installed in the project or IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring with Roslyn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Roslyn’s Syntax API parses C# code into a tree of nodes (class nodes, method
    nodes, etc.), enabling detailed manipulation of the code structure. This API is
    crucial for automating code refactoring, such as automating the migration of applications
    to . NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: The **SyntaxEditor** class is used to apply changes to the code tree. It ensures
    that when a node is replaced or deleted, all its child nodes are updated accordingly,
    avoiding contention and exceptions. This is particularly useful for refactoring
    scripts that need to modify the code based on certain patterns or rules.
  prefs: []
  type: TYPE_NORMAL
- en: The **Code Refactoring** template in Visual Studio allows the creation of a
    VSIX extension that integrates with the **Quick Actions** menu in the IDE. This
    enables developers to apply quick code fixes directly from the editor without
    needing to define additional analyzer IDs or show entries in the error list.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how Visual Studio uses Roslyn to help us analyze and
    refactor our code, let’s dive deeper into the use of static code analysis for
    quality assurance and security.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing static code analysis for quality assurance and security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The built-in **code quality analysis** feature is enabled by default in Visual
    Studio for projects that target .NET 5 or later. However, we can enable it for
    our older .NET project adding and setting to **true** the **EnabeNETAnalyzers**
    property in the **.** **csproj** file.
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis fosters a culture of continuous improvement and collaboration
    within development teams. By providing actionable insights and recommendations,
    these tools facilitate constructive code reviews, foster knowledge sharing, and
    ultimately elevate the skill and proficiency of developers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to use code analysis in Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code quality analysis will inspect our codebase for security, performance,
    design, and other potential areas for improvement. By default, the analysis runs
    automatically, so we can see errors, warnings, and information directly when we
    are typing through squiggles under our code or on the error list windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we write code like the one shown in *Figure 3* *.2* , we will see squiggles
    appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Information squiggles](img/B22218_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Information squiggles
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the analyzer informs us that our **using** statement can be
    simplified according to the feature introduced by C# 8.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The analysis rules are organized into categories: Design, Documentation, Globalization,
    Portability and Interoperability, Maintainability, Naming, Performance, Reliability,
    Security, Style, and Usage. You can find detailed information about each rule
    category in the Microsoft documentation: [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/categories](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/categories)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each rule has a severity level that determines its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default** : This is the default severity level for rules that are enabled
    but do not have a specific severity set. It typically means that the rule is active
    and will report issues, but the exact behavior (e.g., whether it’s treated as
    a warning, error, or suggestion) depends on the rule’s configuration or the default
    behavior of the tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error** : When a rule is set to the Error severity level, any violation of
    the rule will be reported as an error. This means that the code will not be compiled
    until the issue is resolved. Errors are typically used for critical issues that
    must be fixed before the code can be considered correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning** : A rule set to Warning will report violations as warnings. Warnings
    do not prevent the code from compiling, but they are typically used to indicate
    potential issues that should be addressed to improve code quality or maintainability.
    Warnings can be configured to be treated as errors in certain build configurations,
    allowing developers to enforce stricter standards for production code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Suggestion** : Rules with the Suggestion severity level report issues that
    are not critical but could improve the code. These rules are typically used for
    stylistic issues or practices that are not required but are recommended. Suggestions
    are often used in conjunction with code fixes that automatically apply the recommended
    changes, making it easier for developers to improve their code quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Silent** : A rule set to Silent will not report any issues, effectively disabling
    the rule. This is useful for rules that are not relevant to your project or when
    you want to temporarily disable a rule without removing it from your configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None** : This severity level is like Silent but is used to explicitly indicate
    that a rule should not be applied. It’s a way to make the intention clear that
    the rule is intentionally disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how we can use the level of severity to enhance the quality of our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the level of severity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can adjust the severity level of rules by right-clicking on the suggestion
    through the **Error List** and selecting **Set Severity** .
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to prioritize and customize how Visual Studio presents and addresses
    potential issues identified by the rules. Depending on the project’s requirements
    and development context, adjusting the severity levels can focus attention on
    critical issues while minimizing distractions from less impactful ones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The Set severity option](img/B22218_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The Set severity option
  prefs: []
  type: TYPE_NORMAL
- en: This action generates an **.editorconfig** file in our solution’s root containing
    the overridden severity rule, which we can share with our team to ensure consistent
    coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – .editorconfig file generated](img/B22218_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – .editorconfig file generated
  prefs: []
  type: TYPE_NORMAL
- en: An alternative method of adjusting the severity level is through the *light
    bulb* context menu, which also offers code fixes through Quick Actions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Setting the severity using the light bulb](img/B22218_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Setting the severity using the light bulb
  prefs: []
  type: TYPE_NORMAL
- en: During a code review, we might encounter practices that could be improved, as
    shown in *Figure 3* *.6* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Pyramid code](img/B22218_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Pyramid code
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a pyramid code structure might not trigger a squiggle, but the
    IDE might suggest simplifying an **if** statement ( **IDE0046** ). If you want
    to enforce a specific coding standard, you can set the severity level of this
    rule to **Error** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Change the severity level of IDE0046](img/B22218_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Change the severity level of IDE0046
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, when we and our teammates encounter this rule, we are forced to refactor
    our code. We can notice that Visual Studio provides four code fixes for this Rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Convert to a conditional expression** : This fix transforms an **if-else**
    statement into a conditional ( ternary) expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invert if** : This fix inverts the condition of an if statement and swaps
    the code blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convert to a switch statement** : This fix is applicable when you have multiple
    conditions based on the same variable or expression. It converts an if-else chain
    into a switch statement, which is more readable and maintainable for such case,
    like handling multiple conditions based on the same variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convert to a switch expression** : Like converting to a **switch** statement,
    this fix converts an **if-else** chain into a **switch** expression, which is
    a more concise and functional way to handle multiple conditions. It’s available
    in C# 8.0 and later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For better readability, I prefer to use Invert if in this example, but the IDE0046
    rule force is used to turn it into a conditional expression. Keep in mind that
    this is just an example, and we can adapt the level of severity of the analysis
    rules in our solution according to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, adjusting the severity level generates a **.editorConfig**
    file containing our custom configurations. Let’s explore how we can generate such
    a file to easily share our Visual Studio settings with our team.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a .editorconfig file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What I recommend if you work in a team environment is to generate a **.editorconfig**
    file that you can tweak according to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: To generate a **.editorconfig** file, we *right-click* on our solution, and
    in the contextual menu, select **Add** | **New** **Editor Config** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – New EditorConfig](img/B22218_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – New EditorConfig
  prefs: []
  type: TYPE_NORMAL
- en: This will generate a new file that will contain all configurations of our IDE.
    In this file, we will retrieve all the rules of the **Analyzer** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – EditorConfig Analyzer](img/B22218_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – EditorConfig Analyzer
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to list and set the severity level of each rule easily.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that Visual Studio Analyzer provides 94 rules about security.
    These rules cover all the topics of the OWASP Top Ten and more. The OWASP Top
    10 serves as a widely recognized reference document for developers and web application
    security, highlighting the most significant security vulnerabilities faced by
    web applications based on a collective agreement within the industry.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find all the security rules in Microsoft documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/visualstudio/code-quality/security-rules-rule-set-for-managed-code?view=vs-2019&viewFallbackFrom=vs-2022](https://learn.microsoft.com/en-us/visualstudio/code-quality/security-rules-rule-set-for-managed-code?view=vs-2019&viewFallbackFrom=vs-2022)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how we can use static code analysis, let’s dive into
    a new feature. Indeed, Visual Studio 2022 now integrates IntelliCode as a built-in
    feature, available to all subscriptions. Let’s explore how it works and how we
    can leverage its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging IntelliCode for code refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we need to constantly refactor our code to improve its structure,
    readability, or performance, especially when we are working with TDD, with respect
    to the flow explained in [*Chapter 1*](B22218_01.xhtml#_idTextAnchor015) .
  prefs: []
  type: TYPE_NORMAL
- en: One tool that has significantly enhanced our refactoring process is **IntelliCode**
    , which uses artificial intelligence and machine learning to offer intelligent
    suggestions and automate repetitive tasks. IntelliCode is now integrated into
    Visual Studio 2022 for C#. In this section, we’ll explore strategies for effective
    code refactoring using IntelliCode, drawing from our experience and insight.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to ensure that we have IntelliCode installed in our Visual
    Studio by going to the **Options** menu through the top bar menu, which is **Tools**
    | **Options** | **IntelliCode** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – IntelliCode Options](img/B22218_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – IntelliCode Options
  prefs: []
  type: TYPE_NORMAL
- en: If you can't find IntelliCode in the **Options** menu, install it with your
    Visual Studio Installer by ticking the **IntelliCode** checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Visual Studio Installer IntelliCode](img/B22218_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Visual Studio Installer IntelliCode
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve ensured that IntelliCode is enabled in Visual Studio, let’s explore
    how it can enhance our coding experience.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting code with whole-line autocompletion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IntelliCode, introduced in Visual Studio 2022, provides whole-line autocompletion
    with suggestions. This feature is designed to streamline the development process,
    improve code quality, and increase productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows whole-line autocompletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Whole-line autocompletion from typing](img/B22218_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Whole-line autocompletion from typing
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3* *.12* , we can see *gray text line prediction* generated according
    to the context. The prediction is based on a large amount of public, open source
    GitHub repositories. The IntelliCode suggestions are seamlessly integrated with
    those from in the IntelliSense. These IntelliCode recommendations are highlighted
    and easily indentifiable by the *black star* icon located on the left of the suggestion.
  prefs: []
  type: TYPE_NORMAL
- en: If we select another suggestion than one provided by the whole-line autocompletion,
    IntelliCode generates a new prediction according to our choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Whole-line autocompletion from IntelliSense](img/B22218_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Whole-line autocompletion from IntelliSense
  prefs: []
  type: TYPE_NORMAL
- en: To accept the whole-line autocompletion, we just need to press *Tab* or click
    on the *arrow* that pops above the suggestion. We can press *Esc* or *Delete*
    to dismiss it.
  prefs: []
  type: TYPE_NORMAL
- en: IntelliCode runs locally on the machine, providing whole-line autocompletion,
    which enhances code security and consideration for properties, unlike ChatGPT
    and other AI predictions tools, which are generated inline.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how IntelliCode can help us generate code, let’s explore
    how it can assist us in understanding the code by providing direct access to documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing GitHub documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using external libraries or nuggets, we can encounter methods that we don’t
    know how to use efficiently. IntelliCode provides a helpful feature called **API
    Usage Examples** , which provides practical examples of how to use these methods
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: To activate this feature, go to the **Options** menu (see *Figure 3* *.10* )
    and tick **Enable API** **Usage Examples** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can hover our cursor on the method we want to know more about, and
    we get a link labeled **GitHub Examples** **and Documentation** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – GitHub Examples and Documentation link](img/B22218_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – GitHub Examples and Documentation link
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking on the link ( **GitHub Examples and Documentation** ), a side
    pin window opens with an example of the implementation of the method through several
    GitHub repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – GitHub examples](img/B22218_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – GitHub examples
  prefs: []
  type: TYPE_NORMAL
- en: This feature helps us to plan our refactoring according to the examples of implementation
    in other projects, using the experience of other developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s dive into code metrics, which point to the areas
    of our project where we need to do some refactoring to improve maintainability
    and quality.
  prefs: []
  type: TYPE_NORMAL
- en: Code metrics, maintainability, and security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we rely on **code metrics** to evaluate the quality of a software
    system. These quantitative measures provide insights into various aspects of our
    code, such as complexity, maintainability, and security. By understanding these
    metrics, we can identify areas that may need improvement, ensuring that our code
    base remains manageable, secure, and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio allows us to generate a report containing a list of metrics,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability Index** assesses how easy it is to maintain code, giving
    a score from 0 to 100, where higher scores indicate better maintainability. Ratings
    are color-coded: green (20-100) for *good* , yellow (10-19) for *moderate* , and
    red (0-9) for *low* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyclomatic Complexity** measures a code’s structural complexity by counting
    its different flow paths. High complexity suggests more tests are needed for good
    coverage and lower maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth of Inheritance** gauges how many classes inherit from one another,
    with lower values being better to prevent widespread changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class Coupling** measures how tightly classes are connected, with high coupling
    indicating poor design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines of Source Code** counts all lines in a source file, while **Lines of
    Executable Code** approximates the number of executable lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the metrics, let’s delve deeper into how to use them
    through Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Using code metrics in Visual Studio 2022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 provides a powerful suite of tools for analyzing code metrics.
    Here are two ways to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: In the top bar menu, select **Analyze** | **Calculate Code Metrics** and choose
    if you want to calculate the metrics on a specific project or on the solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Calculate Code Metrics from the top menu](img/B22218_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Calculate Code Metrics from the top menu
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can *right-click* directly on the solution or project you
    want to measure and, from the contextual menu, choose **Analyze and Code Cleanup**
    | **Calculate** **Code Metrics**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Calculate Code Metrics for a project](img/B22218_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Calculate Code Metrics for a project
  prefs: []
  type: TYPE_NORMAL
- en: 'After the analysis is complete, a window will open displaying the code metrics
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Code Metrics Results](img/B22218_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Code Metrics Results
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can view metrics such as **Cyclomatic Complexity** , **Depth of Inheritance**
    , **Class Coupling** , **Lines of Source code** , and **Lines of Executable code**
    . We can apply a custom filter to clamp the result between the minimum and maximum
    values for a metric. Furthermore, for better manipulation of the data, we can
    export the code metric results to an Excel file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and utilizing code metrics is essential for maintaining high-quality
    software. Visual Studio 2022 provides powerful tools for analyzing code metrics,
    helping developers identify and address issues relating to security and maintainability.
    By focusing on these aspects, developers can ensure that their code bases remain
    robust, secure, and easy to manage.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve navigated through tools that identify parts of code that
    need improvement and used IntelliCode for refactoring. In the final section, let’s
    delve into a practical use case of refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring case studies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Refactoring** entails restructuring code while preserving its initial functionality.
    The objective is to enhance the internal structure through incremental modifications
    without affecting the code’s external behavior. To check the integrity of our
    code, we use unit tests (see [*Chapter 1*](B22218_01.xhtml#_idTextAnchor015) of
    this book). Refactoring is the last step in the test-driven design process.'
  prefs: []
  type: TYPE_NORMAL
- en: This section showcases a small piece of code containing bad practices. We will
    see how to fix these issues efficiently with the help of Visual Studio. Remember
    that norms and practices must be discussed with all teams and can change from
    one team to another.
  prefs: []
  type: TYPE_NORMAL
- en: Handling common bad practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a code with bad naming and a condition check that can be easily simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the *light bulb* to fix the naming violation ( **IDE1006** ) provided
    by the live code analyzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Fixing the name violation](img/B22218_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Fixing the name violation
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can simplify the age check with the *light bulb* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Simplifying the age check](img/B22218_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Simplifying the age check
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the **Preview changes** window allows us to be more aggressive
    in fixing all occurrences in the different levels of our solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, as our method contains only **return** , we can improve the readability
    by turning it into an **expression body** (a concise way to define the body of
    a method). We will use the *screwdriver* to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Using an expression body](img/B22218_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – Using an expression body
  prefs: []
  type: TYPE_NORMAL
- en: 'The last bad practice to handle is the usage of the magic number. A magic number
    refers to a numeric literal that appears directly in the source code without any
    explanation of its meaning or purpose. It can be challenging to change or understand
    without proper context. So, we will introduce a constant with a human-readable
    name to explain the purpose of this number. We will once again use the *light
    bulb* to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Introducing a constant](img/B22218_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – Introducing a constant
  prefs: []
  type: TYPE_NORMAL
- en: Now we get a simple expression body, which is well named, and one that respects
    clean code practices.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For instance, imagine we get a **AirTraffic** class with a **RegisterAircraft**
    method. Now to add abstraction to our code we want to create an **IAirTraffic**
    interface. We’ll use the *screwdriver* to effortlessly extract the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Extracting an interface](img/B22218_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – Extracting an interface
  prefs: []
  type: TYPE_NORMAL
- en: This will open a window with options to allow us to choose the configuration
    of our interface. We will keep the default choices to create the interface in
    a new file, named **IairTraffic.cs** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are adding a new method, **SendMessage** , and we want it to belong
    to the interface as well. Again, we can use the *screwdriver* to pull the new
    method up to the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Pulling the method up to interface](img/B22218_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 – Pulling the method up to interface
  prefs: []
  type: TYPE_NORMAL
- en: This refactoring ensures that all classes implementing **IAirTraffic** will
    have access to the **SendMessage** method, promoting a consistent interface and
    code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: File-scoping our namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **file-scoped namespace** feature, introduced in C# 10, offers a more concise
    approach to declaring namespaces. It eliminates the need for curly braces to enclose
    the namespace body, streamlining the syntax and enhancing readability.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when we create classes in Visual Studio, it uses the older version
    of namespace, which wraps the entire content of the file using curly braces. We
    can add a semicolon at the end of the declaration of the namespace and Visual
    Studio will automatically understand that you want to turn it in file-scoped namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this repetitive action, we can set file-scoped namespace as the default
    in Visual Studio by using the top menu bar: select **Tools** | **Options** | **Text
    Editor** | **C#** | **Code Style** | **General** and change the namespace declaration
    value to **File scoped** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Making namespace declarations file scoped](img/B22218_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 – Making namespace declarations file scoped
  prefs: []
  type: TYPE_NORMAL
- en: If we work in teams, we can generate the **.editorconfig** file directly for
    the **Options** window by clicking on the **Generate .editor file from setting**
    option, as we can see in *Figure 3* *.25* .
  prefs: []
  type: TYPE_NORMAL
- en: 'If we already have a **.editorconfig** file, (created manually or generated
    by changing the severity level, as seen in the *Utilizing static code analysis
    for quality assurance and security* section in this chapter), we can add the following
    line to set namespace declarations to **file_scoped** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want Visual Studio to trigger compile-time errors when file-scoped namespaces
    are not used, the syntax would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to commit the configuration to our Git repository, ensuring it’s
    shared with our team.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the inner workings of Roslyn within Visual Studio
    2022, empowering developers to use its capabilities fully. By mastering static
    code analysis, we can enhance quality assurance and security measures in our projects
    through nuanced control over severity levels and generating **.editorconfig**
    files and spreading them to our team.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how IntelliCode redefines productivity, offering predictive coding via
    whole-line autocompletion and seamless access to GitHub documentation.
  prefs: []
  type: TYPE_NORMAL
- en: We navigated code metrics of maintainability and security, which equip us with
    invaluable insights that allow us to evaluate and improve code bases. Armed with
    Visual Studio 2022’s built-in tools, projects can be optimized for long-term sustainability
    and robustness.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter with practical refactoring case studies, addressing
    common pitfalls and demonstrating techniques such as interface generation and
    namespace refinement. By analyzing real-world scenarios, we gained hands-on experience
    in applying advanced refactoring principles.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we explore strategies for identifying performance
    bottlenecks, optimizing code execution, and leveraging Visual Studio 2022’s profiling
    tools to ensure peak performance in our applications.
  prefs: []
  type: TYPE_NORMAL
