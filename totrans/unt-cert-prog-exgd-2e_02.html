<html><head></head><body>
		<div><h1 id="_idParaDest-47"><em class="italic"><a id="_idTextAnchor048"/>Chapter 2</em>: Adding and Manipulating Objects</h1>
			<p>In the previous chapter, we discussed the importance of the Official Unity Programmer exam and what benefits it can produce for any developer who is looking to reassure either themselves or others in understanding programming in Unity. We also discussed the building blocks of being a programmer in general and our game's design brief.</p>
			<p>As we are programmers working on a game engine, it is likely you will be working for a range of industries. In many of these industries, you will be issued with a technical brief/documentation (well, you should be!) for building an application. With this project, we are making a game, and the game design brief is effectively the blueprint for making this game. In this chapter, we will be applying the majority of our code, game objects, prefabs, and more based on the guidance of the brief and the game framework. We will be reminding ourselves of the brief and game framework during this chapter and will transfer specific information into our code.</p>
			<p>With regard to our code, we will be covering the importance of interfaces and scriptable objects to help structure and uniform our code, preventing it from bloating unnecessarily, which we covered in <a href="B18381_01_Epub.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up and Structuring Our Project</em>, with SOLID principles. We will also be getting used to the Unity Editor and becoming familiar with game objects, prefabs, and importing three-dimensional models to animate.</p>
			<p>In this chapter, we'll be covering the following topics:</p>
			<ul>
				<li>Setting up our Unity project</li>
				<li>Introducing our interface (<code>IActorTemplate</code>)</li>
				<li>Introducing our <code>ScriptableObject</code> (<code>SOActorModel</code>)</li>
				<li>Setting up our <code>Player</code>, <code>PlayerSpawner</code>, and <code>PlayerBullet</code> scripts</li>
				<li>Planning and creating our enemy</li>
				<li>Setting up our <code>EnemySpawner</code> and enemy script</li>
			</ul>
			<p>The next section will outline the exam objectives covered in this chapter.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor049"/>Core exam skills covered in this chapter</h1>
			<p><em class="italic">Programming core interactions</em>:</p>
			<ul>
				<li>Implement and configure game object behavior and physics.</li>
				<li>Implement and configure input and controls.</li>
				<li>Implement and configure camera views and movement.</li>
			</ul>
			<p><em class="italic">Working in the art pipeline</em>:</p>
			<ul>
				<li>Understand lighting and write scripts that interact with Unity's lighting API.</li>
				<li>Understand two- and three-dimensional animation and write scripts that interact with Unity's animation API.</li>
			</ul>
			<p><em class="italic">Programming for scene and environment design</em>:</p>
			<ul>
				<li>Identify methods for implementing game object instantiation, destruction, and management.</li>
				<li>Demonstrate knowledge of developer testing and its impact on the software development process, including Unity Profiler and traditional debugging and testing techniques.</li>
				<li>Recognize techniques for structuring scripts for modularity, readability, and re-usability.</li>
			</ul>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Technical requirements</h1>
			<p>The project content for this chapter can be found at <a href="https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02">https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02</a>.</p>
			<p>You can download the entire chapter project files at <a href="https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition">https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition</a>.</p>
			<p>All content for this chapter is held in the relevant <code>unitypackage</code> file, including a <code>Complete</code> folder that contains all of the work we'll carry out in the chapter, so if at any point you need some reference material or extra guidance, be sure to check it out.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3yfWyt5">https://bit.ly/3yfWyt5</a>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor051"/>Setting up our Unity project</h1>
			<p>Things can get<a id="_idIndexMarker095"/> messy quickly in a project if we don't manage our files correctly by placing them in the allocated folders. If you want to structure your folders your own way, or during the book, you decide to stray away from how I'm doing it, that's also fine. Just try and be conscious of your future self or other people working on this project when it comes to finding and organizing files.</p>
			<p>Open the project up if you haven't already and create the following folders:</p>
			<ul>
				<li><code>Model</code> contains 3D models (the player ship, enemies, bullets, and so on).</li>
				<li><code>Prefab</code> holds instances of game objects (these are created within Unity).</li>
				<li><code>Scene</code> stores our first-level scene as well as other levels.</li>
				<li><code>Script</code> contains all of our code.</li>
				<li><code>Material</code> stores our game object materials.</li>
				<li><code>Resources</code> stores assets and objects to load into our game.</li>
				<li><code>ScriptableObject</code> are data containers that are capable of storing large amounts of data.<p class="callout-heading">Tip</p><p class="callout">You should know what a prefab is, as it's one of the main parts of what makes Unity so quick and easy to use. However, if you don't: it's typically your game object with its settings and components stored in an instance. You can store your game objects in your <strong class="bold">Project</strong> window as prefabs by dragging the game object from the <strong class="bold">Hierarchy</strong> window. A blue box icon will be generated following the game object's name, and if you select the prefab in the <strong class="bold">Project</strong> window, its <strong class="bold">Inspector</strong> window details will show all its stored values. If you would like to know more about prefabs, you can check out the documentation at <a href="https://docs.unity3d.com/Manual/Prefabs.html">https://docs.unity3d.com/Manual/Prefabs.html</a>.</p></li>
			</ul>
			<p>The following screenshot shows <a id="_idIndexMarker096"/>you how to create these folders:</p>
			<div><div><img src="img/Figure_2.01_B18381.jpg" alt="Figure 2.1 – Creating a folder in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Creating a folder in the Unity Editor</p>
			<p>Next, we will <a id="_idIndexMarker097"/>create subfolders; we need to do the following:</p>
			<ol>
				<li>Within our <code>Prefab</code> folder, create another two folders, <code>Enemies</code> and <code>Player</code>:</li>
			</ol>
			<div><div><img src="img/Figure_2.02_B18381.jpg" alt="Figure 2.2 – Folders created in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Folders created in the Unity Editor</p>
			<p><code>Resources</code> is a special folder that Unity recognizes. It will allow us to load assets while the game is <a id="_idIndexMarker098"/>running. For more information about the <code>Resources</code> folder, check the documentation at <a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html">https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html</a>.</p>
			<p class="callout-heading">Further Information</p>
			<p class="callout">It's worth mentioning the <code>StreamingAssets</code> folder at this point. Even though we aren't using it in this project, it relates well to how similar (and how different) it is to the <code>Resources</code> folder.</p>
			<p class="callout">The <code>Resources</code> folder imports assets and converts them into internal formats that will be compatible with the target platform. So, for example, a PNG file will get converted and compressed when the project is being built.</p>
			<p class="callout">The <code>StreamingAssets</code> folder will hold the PNG file, not convert or compress it. For more information on Streaming Assets, check out the following link: <a href="https://docs.unity3d.com/Manual/StreamingAssets.html">https://docs.unity3d.com/Manual/StreamingAssets.html</a>.</p>
			<p>Provided in the <em class="italic">Technical requirements</em> section is the download link for the GitHub repository of this chapter. Once downloaded, double-click the <code>Chapter2.unitypackage</code> file, and we will be given a list of assets to import into our Unity project:</p>
			<ul>
				<li><code>Player_ship.fbx</code></li>
				<li><code>enemy_wave.fbx</code></li>
			</ul>
			<p>The following screenshot shows the <strong class="bold">Import</strong> window of the assets we are about to bring into our project:</p>
			<div><div><img src="img/Figure_2.03_B18381.jpg" alt="Figure 2.3 – Importing assets into your project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Importing assets into your project</p>
			<p>Make sure all assets are ticked and click the <strong class="bold">Import</strong> button at the bottom-right corner of the window. We <a id="_idIndexMarker099"/>can now move on to organizing our files and folders in the <strong class="bold">Project</strong> window in the next section.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Creating prefabs</h2>
			<p>In this section, we <a id="_idIndexMarker100"/>are going to create three prefabs: the player, the player's bullet, and the enemy. These prefabs will hold components, settings, and other property values for our game that we can instantiate throughout our game.</p>
			<p>Let's start by making our <code>player_ship.fbx</code> file into a prefab instance by doing the following.</p>
			<p>Sometimes, when importing any three-dimensional file, it may contain extra data that we might not need. For example, our <code>player_ship</code> model comes with its own material and animation properties. We don't require any of these, so let's remove these properties before continuing to import our models fully into our Unity project.</p>
			<p>To remove the <code>player_ship</code> model, we need to do the following:</p>
			<ol>
				<li value="1">In the <code>Assets/Model</code> and select the <code>player_ship</code> file.</li>
				<li>In the <strong class="bold">Inspector</strong> window, select the <strong class="bold">Materials</strong> button.</li>
				<li>Make sure the<strong class="bold"> Material Creation Mode</strong> is set to <strong class="bold">None</strong> from the drop-down list, and then click the <strong class="bold">Apply</strong> button.</li>
				<li>Now, click the <strong class="bold">Animation</strong> button next to the <strong class="bold">Materials</strong> button.</li>
				<li>Untick the <strong class="bold">Import Animation</strong> checkbox, followed by clicking the <strong class="bold">Apply</strong> button.</li>
				<li>Select the <strong class="bold">Rig</strong> button next to the <strong class="bold">Animation</strong> button.</li>
				<li>Select the current value in the <strong class="bold">Animation Type</strong> drop-down menu and select <strong class="bold">None</strong>, followed by the <strong class="bold">Apply</strong> button.</li>
				<li>That's all<a id="_idIndexMarker101"/> of the <code>player_ship</code> model.<p class="callout-heading">Important Information</p><p class="callout">Throughout the book, whenever we select a three-dimensional model, make sure to run through the same process, as we will not require imported extras such as the ones we just removed. This means I would like you now to repeat the process we have just gone through with the <code>enemy_wave.fbx</code> model.</p></li>
			</ol>
			<p>Let's continue preparing our <code>player_ship</code> model for our game:</p>
			<ol>
				<li value="1">Click and drag <code>player_ship</code> from <code>Assets/Model</code> into the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Select the <code>player_ship</code> in the <code>player_ship</code></li><li><code>0</code> apart from <code>1</code> on all axes</li></ul></li>
			</ol>
			<p>The following screenshot shows the <code>player_ship</code> values in the <strong class="bold">Inspector</strong> window:</p>
			<div><div><img src="img/Figure_2.04_B18381.jpg" alt="Figure 2.4 – The player_ship values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The player_ship values in the Inspector window</p>
			<ol>
				<li value="3">Click <a id="_idIndexMarker102"/>and drag the <code>player_ship</code> from the <code>Assets/Prefab/Player</code> folder.</li>
			</ol>
			<p>When creating a prefab, sometimes you might be asked if this is an <strong class="bold">Original</strong> or <strong class="bold">Variant</strong>:</p>
			<div><div><img src="img/Figure_2.05_B18381.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – The Create Prefab Dialog</p>
			<p>A variant prefab will be a copy of an original prefab but will also carry any changes made from the prefab it originates from. So, for example, if the original prefab was a car with 4 wheels, the variant will have the same. If the original prefab changes it's numbers from 4 to 3, the variant will copy the original prefab.</p>
			<p>Note that <code>player_ship</code> in the <strong class="bold">Hierarchy</strong> window has turned blue, which means it has become a prefab.</p>
			<ol>
				<li value="4">Delete the <code>player_ship</code> from the <strong class="bold">Hierarchy</strong> window.</li>
			</ol>
			<p>We are going<a id="_idIndexMarker103"/> to use a similar process to create our <code>enemy_wave</code> prefab, but we will also need to create its own name tag because there isn't an <strong class="bold">Enemy</strong> tag... yet.</p>
			<h3>An Enemy prefab and custom tags</h3>
			<p>In this<a id="_idIndexMarker104"/> section, we<a id="_idIndexMarker105"/> are going to create an <code>enemy_wave</code> prefab along with a custom tag. The tag will be used to identify and categorize all related enemies under one tag.</p>
			<p>To create an <code>enemy_wave</code> prefab and custom name tag, follow these instructions:</p>
			<ol>
				<li value="1">In the <code>enemy_wave.fbx</code> file from <code>Assets/Model</code> into the <strong class="bold">Hierarchy</strong> window.</li>
				<li>With the <code>enemy_wave</code> file selected in the <code>enemy_wave</code>.</li><li><code>0</code> apart from <code>1</code> on all axes:</li></ul></li>
			</ol>
			<div><div><img src="img/Figure_2.06_B18381.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – The enemy_wave values in the Inspector window</p>
			<p>Now, let's <a id="_idIndexMarker106"/>create a new tag for the <code>enemy_wave</code> game <a id="_idIndexMarker107"/>object by doing the following:</p>
			<ol>
				<li value="1">Choose the <strong class="bold">Untagged</strong> parameter in the <strong class="bold">Inspector</strong> window.</li>
				<li>From the <strong class="bold">Tag</strong> drop-down menu, select <strong class="bold">Add Tag...</strong>.</li>
				<li>The <strong class="bold">Inspector</strong> window will now show the <strong class="bold">Tags &amp; Layers</strong> window.</li>
				<li>Click the <strong class="bold">+</strong> to add a new tag, as circled in the following screenshot.</li>
				<li>Enter <code>Enemy</code> in the pop-up window, as shown in the following screenshot, and then click the <strong class="bold">Save</strong> button:</li>
			</ol>
			<div><div><img src="img/Figure_2.07_B18381.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Add a tag to the Tags &amp; Layers list</p>
			<ol>
				<li value="6">Back in the <code>enemy_wave</code> game object to bring back our <strong class="bold">Inspector</strong> window details.</li>
				<li>Click the <strong class="bold">Untagged</strong> parameter again.</li>
				<li>We can now see <strong class="bold">Enemy</strong> in our drop-down list, so select it.</li>
				<li>Drag the <code>enemy_wave</code> game object from the <code>Assets/Prefab/Enemies</code>.</li>
				<li>Delete <code>enemy_wave</code> from the <strong class="bold">Hierarchy</strong> window</li>
			</ol>
			<p>We now move on to our third prefab creation – the player's bullet. But this time, we won't import <a id="_idIndexMarker108"/>a three-dimensional model – we are goin<a id="_idIndexMarker109"/>g to create one in the Unity Editor, and then create a prefab from it in the next section.</p>
			<h3>Creating the player's bullet prefab</h3>
			<p>Next, we are <a id="_idIndexMarker110"/>going to create the<a id="_idIndexMarker111"/> visuals for the player's bullet in the Unity Editor. We will make a blue sphere and give it a surrounding light source. Let's start by creating a three-dimensional sphere game object.</p>
			<p>In the <strong class="bold">Hierarchy</strong> window, right-click, and from the drop-down list, select <strong class="bold">3D Object</strong> | <strong class="bold">Sphere</strong>.</p>
			<p>With the newly created <code>Sphere</code> in the <strong class="bold">Hierarchy</strong> window still selected, make the following changes to the <strong class="bold">Inspector</strong> window:</p>
			<ol>
				<li value="1">Change the game object name from <code>Sphere</code> to <code>player_bullet</code>.</li>
				<li>Change <strong class="bold">Tag</strong> from <strong class="bold">Untagged</strong> to <strong class="bold">Player</strong>. The tag name makes it easier to identify later on in the chapter.</li>
				<li>The <code>0</code>, apart from the <code>2</code> on all axes.</li>
			</ol>
			<p>The following screenshot shows all three changes:</p>
			<div><div><img src="img/Figure_2.08_B18381.jpg" alt="Figure 2.8 – The player_bullet values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – The player_bullet values in the Inspector window</p>
			<p>Next, we will<a id="_idIndexMarker112"/> give the <code>player_bullet</code> game<a id="_idIndexMarker113"/> object a new blue material.</p>
			<h4>Creating and applying a material to the player's bullet</h4>
			<p>In this section, we <a id="_idIndexMarker114"/>will be creating a simple unlit material that will not take up much of the device's performance, thanks to the simplicity of the material. To create a basic material and apply it to the <code>player_bullet</code> object, do the following:</p>
			<ol>
				<li value="1">In the <code>Assets/Material</code> folder.</li>
				<li>Inside the <code>Material</code> folder, make a new folder (the same way we did in the <em class="italic">Setting up our Unity project</em> section) and name the folder <code>Player</code>. That way, any material related to the player can be stored inside.</li>
				<li>Double click the newly created <code>Player</code> folder and right-click in the <strong class="bold">Project</strong> window (in the open space in the right section of the window) again, and from the drop-down list, select <strong class="bold">Create</strong> | <strong class="bold">Material</strong>.</li>
				<li>A new material file will be made. Rename it <code>player_bullet</code>.</li>
				<li>Select the <code>player_bullet</code> material, and in the <strong class="bold">Inspector</strong> window, change the material from a <strong class="bold">Standard</strong> shader to <strong class="bold">Unlit</strong> | <strong class="bold">Color</strong> by following the three steps in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_2.09_B18381.jpg" alt="Figure 2.9 – Creating an Unlit Color Material&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Creating an Unlit Color Material</p>
			<p>The <strong class="bold">Inspector</strong> window will remove the majority of the properties and strip the material <a id="_idIndexMarker115"/>back to something simpler and easier to perform on any device.</p>
			<ol>
				<li value="6">Still in the <code>0</code>, <code>190</code>, <code>255</code>, and <code>255</code>.</li>
			</ol>
			<p>We have created and calibrated our player's bullet, so now, we can apply the material to the <code>player_bullet</code> prefab by doing the following:</p>
			<ol>
				<li value="7">Select the <code>player_bullet</code> prefab in the following location of the <code>Assets/Prefab/Player</code>.</li>
				<li>In the <code>player_bullet</code> in the drop-down list until you see the material, and then select it.</li>
			</ol>
			<p>The following screenshot shows the <code>player_bullet</code> prefab's <strong class="bold">Mesh Renderer</strong> component updated to our new unlit material: </p>
			<div><div><img src="img/Figure_2.10_B18381.jpg" alt="Figure 2.10 – player_bullet now has a player_bulletMat material&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – player_bullet now has a player_bulletMat material</p>
			<p>In <a href="B18381_04_Epub.xhtml#_idTextAnchor087"><em class="italic">Chapter 4</em></a><em class="italic">, Applying Art, Animation, and Particles</em>, we will return to materials and art in general, which will be of note if you found this interesting. We will also play around <a id="_idIndexMarker116"/>with particle systems to create a fleet of stars rushing past the player's ship.</p>
			<p>The last component we will add to our player's bullet is a surrounding light to give our bullet an energy glow.</p>
			<h4>Adding a light to the player's bullet</h4>
			<p>In this section, we<a id="_idIndexMarker117"/> will be adding a light component to the player's bullet to hide the impression that all that we are doing is firing spheres. It will also introduce us to Unity's point light, which acts as a glowing ball.</p>
			<p>To add and customize a ball of light to the player's bullet, we need to do the following:</p>
			<ol>
				<li value="1">In the <code>Assets/Prefab/Player</code> folder, select the <code>player_bullet</code> prefab, and drag it into the <strong class="bold">Hierarchy</strong> window (if it isn't in the Hierarchy window already).</li>
				<li>In the <strong class="bold">Inspector</strong> at the bottom of the components listed, click the <strong class="bold">Add Component</strong> button and select <strong class="bold">Light</strong> from the drop-down list.</li>
			</ol>
			<p>The <code>player_bullet</code> prefab will now have a <strong class="bold">Light</strong> component attached to it. We just need to change three property values to make the light suit the game object more. </p>
			<ol>
				<li value="3">Change the following property values in the <code>player_bullet</code> file's <code>50</code></li><li><code>0</code>, <code>190</code>, <code>255</code>, and <code>255</code></li><li><code>20</code></li></ul></li>
			</ol>
			<p>The following<a id="_idIndexMarker118"/> screenshot shows the <strong class="bold">Light</strong> component after the values have been updated:</p>
			<div><div><img src="img/Figure_2.11_B18381.jpg" alt="Figure 2.11 – The Light component values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – The Light component values in the Inspector window</p>
			<p>Before moving onto the next section, because we have taken an existing prefab and added a material and a light component, we need to click the <strong class="bold">Override</strong> button to confirm the new changes.</p>
			<p>The following screenshot shows the <code>player_bullet</code> prefab:</p>
			<div><div><img src="img/Figure_2.12_B18381.jpg" alt="Figure 2.12 – Updating the player_bullet prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 2.12 – Updating the player_bullet prefab</p>
			<ol>
				<li value="4">Finally, click on <code>player_bullet</code> from the <strong class="bold">Hierarchy</strong>.</li>
			</ol>
			<p>In the next<a id="_idIndexMarker119"/> section, we will continue to update our three prefabs by applying Unity's own physics system, the <strong class="bold">Rigidbody</strong> component, to help detect collisions.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Adding Rigidbody components and fixing game objects</h2>
			<p>Because <a id="_idIndexMarker120"/>this<a id="_idIndexMarker121"/> game<a id="_idIndexMarker122"/> involves collisions<a id="_idIndexMarker123"/> with game objects, we need to apply collision detection to the player, the player's bullets, and the enemy. Unity offers a range of different shapes to wrap around a game object that functions as an invisible shield; we can set our code to react to contact being made with the shield.</p>
			<p>Before we add colliders to the player and enemy game objects (the <strong class="bold">Sphere</strong> game object automatically comes with a collider), we need to add a Unity component called <strong class="bold">Rigidbody</strong>. If a game object is going to collide with at least one other game object, it requires a <strong class="bold">Rigidbody</strong> component, which can affect a game object's mass, gravity, drag, constraints, and more. If you would like to know more about <strong class="bold">Rigidbody</strong> components, check out the documentation at <a href="https://docs.unity3d.com/Manual/class-Rigidbody.html">https://docs.unity3d.com/Manual/class-Rigidbody.html</a>.</p>
			<p class="callout-heading">Rigidbody Joints</p>
			<p class="callout">Unity has other physics types apart from the collider. <strong class="bold">Joints</strong> also require the <strong class="bold">Rigidbody</strong> system, and they come in different forms, such as <strong class="bold">Hinge</strong>, <strong class="bold">Spring</strong>, and others.</p>
			<p class="callout">These <strong class="bold">Joints</strong> will simulate at a fixed point; for example, the <strong class="bold">Hinge</strong> <strong class="bold">Joint</strong> would be good at making a door swing back and forth around a door hinge's pivot point. </p>
			<p class="callout">If you would like to know more about Joints, check the documentation at <a href="https://docs.unity3d.com/Manual/Joints.html">https://docs.unity3d.com/Manual/Joints.html</a>.</p>
			<p>Let's add<a id="_idIndexMarker124"/> the <code>player_ship</code> and <code>player_bullet</code> prefabs<a id="_idIndexMarker126"/> in <a id="_idIndexMarker127"/>one go:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, navigate to <strong class="bold">Prefab | Player</strong>.</li>
				<li>Hold <em class="italic">Ctrl</em> (<em class="italic">command</em> on a Mac) and click on the <code>player_ship</code> and <code>player_bullet</code> files.</li>
				<li>In the <strong class="bold">Inspector</strong> window, click the <strong class="bold">Add Component</strong> button.</li>
				<li>From the drop-down menu, type <code>Rigidbody</code>.</li>
				<li>Select <strong class="bold">Rigidbody</strong> (not <strong class="bold">Rigidbody 2D</strong>).</li>
				<li>The <strong class="bold">Rigidbody</strong> component has now been assigned to our two game objects.</li>
				<li>With the two game objects still selected in the <strong class="bold">Inspector</strong> window, under <strong class="bold">Rigidbody</strong>, make sure that the <strong class="bold">Gravity</strong> checkbox isn't ticked. If it was, our game objects would begin to sink into the scene while the game is being played.</li>
			</ol>
			<p>Now, we can add colliders to our <code>player_ship</code> and <code>enemy_wave</code> game objects (our <code>player_bullet</code> already has a <strong class="bold">SphereCollider</strong>). We will be adding a <strong class="bold">SphereCollider</strong> to our game objects because it's the cheapest collider to use, relative to performance costs:</p>
			<ol>
				<li value="1">Click and drag the <code>player_ship</code> prefab from the <code>Assets/Prefab/Player</code> into the <strong class="bold">Hierarchy</strong> window.</li>
				<li>With the <code>player_ship</code> still selected in the <code>Sphere Collider</code> in the drop-down menu.</li>
				<li>As soon as you see <code>player_ship</code> game object.</li>
			</ol>
			<p>You will notice a green wireframe around the <code>player_ship</code> in the <code>player_ship</code> still selected in the <code>player_ship</code> collider that will be used to detect hits. It may be too big for the purpose of a hitbox, so let's reduce its size.</p>
			<ol>
				<li value="4">With the <code>player_ship</code> prefab still selected in the <code>0.3</code> in the <strong class="bold">Inspector</strong> window, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_2.13_B18381.jpg" alt="Figure 2.13 – The triggered sphere collider added to the player_ship prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13 – The triggered sphere collider added to the player_ship prefab</p>
			<ol>
				<li value="5">Also, while we still have the <code>player_ship</code> prefab selected, check the <code>player_ship</code> prefab look for another collider without causing any form of potential physics collision.</li>
				<li>Click <strong class="bold">Override</strong> at the top-right corner followed by <strong class="bold">Apply All</strong> in  the <strong class="bold">Inspector</strong> window to update the modifications we've made to our prefab with its <strong class="bold">Rigidbody</strong> and <strong class="bold">SphereCollider</strong> components.</li>
				<li>We can now select the <code>player_ship</code> prefab in the <strong class="bold">Hierarchy</strong> window and press <em class="italic">Delete</em> on our keyboard, as we no longer need it in our <strong class="bold">Scene</strong>.</li>
			</ol>
			<p>We <a id="_idIndexMarker132"/>now <a id="_idIndexMarker133"/>need<a id="_idIndexMarker134"/> to <a id="_idIndexMarker135"/>apply the same methodology to the <code>player_bullet</code>:</p>
			<ol>
				<li value="1">In the <code>player_bullet</code> prefab from <code>Assets /Prefab/Player</code> into the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Check the <strong class="bold">Is Trigger</strong> box and adjust the <strong class="bold">Radius</strong> in the <strong class="bold">SphereCollider</strong> component in the <strong class="bold">Inspector</strong> window.</li>
				<li>Click <code>player_bullet</code> changes, and delete the <code>player_bullet</code> prefab from the <strong class="bold">Hierarchy</strong> window.</li>
			</ol>
			<p>The last game object we need to update is the <code>enemy_wave</code> prefab. We have already covered the steps with the <code>player_ship</code> and <code>player_bullet</code> prefabs, so it's not ideal to repeat the instructions in full; however, we need to do the following:</p>
			<ol>
				<li value="1">Briefly, I want you to drag and drop the <code>enemy_wave</code> prefab from its location at <code>Assets/Prefab/Enemies</code> in the <strong class="bold">Project</strong> window into the <strong class="bold">Hierarchy</strong> window..</li>
				<li>Add a <code>enemy_wave</code> prefab in the <strong class="bold">Inspector</strong> window.</li>
				<li>Adjust the <code>enemy_wave</code> prefab with the correct proportions, as we did with <code>player_ship</code>.</li>
				<li>The <code>enemy_wave</code> prefab doesn't require a <strong class="bold">Rigidbody</strong> component, as it will be colliding with relevant game objects that hold one themselves.</li>
				<li>Finally, <code>enemy_wave</code> prefab from the <strong class="bold">Hierarchy</strong> window.</li>
			</ol>
			<p>Use the following <a id="_idIndexMarker136"/>screenshot as a reference for the preceding<a id="_idIndexMarker137"/> mini-brief, and if you get stuck, use<a id="_idIndexMarker138"/> the <a id="_idIndexMarker139"/>previous steps that we discussed in this section:</p>
			<div><div><img src="img/Figure_2.14_B18381.jpg" alt="Figure 2.14 – The trigger collider added and scaled to the enemy_wave prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.14 – The trigger collider added and scaled to the enemy_wave prefab</p>
			<p>Hopefully, that went well for you. If you get stuck at any point, refer to the <a href="https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage">https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage</a> folder containing all the completed files to check them out and compare.</p>
			<p>Before moving on, note that if a game object is pink, such as our <code>enemy_wave</code> object in the previous screenshot, it simply means that it doesn't have a material attached. In other cases, it can also mean there is something wrong with the shader attached to the material.</p>
			<p>We can fix this pink issue by doing the following:</p>
			<ol>
				<li value="1">In the <code>Assets/Prefab/Enemies</code>.</li>
				<li>Drag and drop enemy_wave into the Hierarchy window. Expand the drop down next to <code>enemy_wave</code> in the Hierarchy window..</li>
				<li>Select the first game object, titled <code>enemy_wave_core</code>.</li>
				<li>In the <strong class="bold">Inspector</strong> window, select the small <strong class="bold">remote</strong> circle next to the <strong class="bold">Element 0</strong> parameter<a id="_idIndexMarker140"/> in the <strong class="bold">Mesh Renderer</strong> component (denoted<a id="_idIndexMarker141"/> by <strong class="bold">1</strong> in the following screenshot), and<a id="_idIndexMarker142"/> then<a id="_idIndexMarker143"/> select <strong class="bold">Default-Material</strong> (denoted by <strong class="bold">2</strong>) from the drop-down list, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_2.15_B18381.jpg" alt="Figure 2.15 – Adding a Default Material to the enemy_wave_core gameobject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.15 – Adding a Default Material to the enemy_wave_core gameobject</p>
			<ol>
				<li value="5">Follow the same steps for its sibling game object, <code>enemy_wave_ring</code>.</li>
			</ol>
			<p>The <code>enemy_wave</code> object will now have a default material applied.If any changes were made to the prefab be sure to click <strong class="bold">Override, Apply All</strong>.</p>
			<p class="callout-heading">Attributes</p>
			<p class="callout">If a game object requires a component such as <code>Rigidbody</code>, we can place, above the class name, what is effectively a reminder to the script that the game object needs it:</p>
			<p class="callout"><code>[RequireComponent(typeof(Rigidbody))]</code></p>
			<p class="callout">If the game object doesn't have the component, the script will create one, and if we try to remove the <code>Rigidbody</code> component, we will receive a message in the Unity Editor that it is a required component.</p>
			<p class="callout">This code isn't a requirement as such, more of a good practice with components in general.</p>
			<p class="callout">If you would like to know more about the <code>RequireComponent</code> attribute, check the documentation at <a href="https://docs.unity3d.com/ScriptReference/RequireComponent.html">https://docs.unity3d.com/ScriptReference/RequireComponent.html</a>.</p>
			<p>So, now we <a id="_idIndexMarker144"/>have <a id="_idIndexMarker145"/>our <a id="_idIndexMarker146"/>colliders and <strong class="bold">Rigidbody</strong> components<a id="_idIndexMarker147"/> applied to our game objects. This gives us the ability to create a reaction when colliders come into contact with each other.</p>
			<p>Because we are starting to build up our project, let's quickly discuss saving our scenes, projects, and so on.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor054"/>Saving and publishing our work</h2>
			<p>It's easy to<a id="_idIndexMarker148"/> get stuck into our project, but as a brief reminder, save your work as often as possible. That way, if anything bad happens, you can always revert back.</p>
			<p>Because we have created and saved our <code>testLevel</code> scene from the previous chapter, we can also add this scene to the <strong class="bold">Build Settings</strong> window. The reason for this is so that Unity is aware of what scenes we want to include in our project. It is also a requirement when it comes to packaging up our game as a build for deployment.</p>
			<p>To add our scene to <strong class="bold">Build Settings</strong>, do the following:</p>
			<ol>
				<li value="1">At the top of the Unity Editor, click <strong class="bold">File | Build Settings</strong>. The <strong class="bold">Build Settings</strong> window will appear.</li>
				<li>Click the <code>testLevel</code> scene.</li>
				<li>The following screenshot shows the <code>testLevel</code> scene. When we add more scenes later, each scene will be numbered:</li>
			</ol>
			<div><div><img src="img/Figure_2.16_B18381.jpg" alt="Figure 2.16 – Adding the testLevel scene to the Scenes In Build list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.16 – Adding the testLevel scene to the Scenes In Build list</p>
			<ol>
				<li value="4">Close<a id="_idIndexMarker149"/> the <strong class="bold">Build Settings</strong> window. We will come back to this when we have more scenes to add in the next chapter.</li>
				<li>It's a good habit to save the project by clicking <strong class="bold">File | Save Project</strong>.</li>
			</ol>
			<p>Let's now continue with setting up <a id="_idIndexMarker150"/>our scene camera in the Unity Editor.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/>Unity Editor Layout</h2>
			<p>For our <a id="_idIndexMarker151"/>side-scrolling shooter game <em class="italic">Killer Wave</em>, we need control over a camera to display the aspect ratio and visible depth of the scene, and to make sure we show the correct amount of our game's environment.</p>
			<p>Let's get started and decide on the screen ratio of our game. We'll create our own resolution, which will be fairly common across most platforms. </p>
			<p>To change the <strong class="bold">Game</strong> window's screen ratio to a custom aspect, do the following:</p>
			<ol>
				<li value="1">Click the current aspect ratio under the <strong class="bold">Game</strong> window tab and select the <strong class="bold">+</strong> symbol.</li>
				<li>Enter the custom aspect ratio values shown in the following screenshot.</li>
				<li>Click <code>1080</code> resolution we have just made:</li>
			</ol>
			<div><div><img src="img/Figure_2.18_B18381.jpg" alt="Figure 2.18 – Setting a custom Game window resolution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.17 – Setting a custom Game window resolution</p>
			<p>It is good to be aware of the need to make our game's artwork support (or to give it the scope to extend to) as many screen ratios as possible, especially if we ever wanted to make a game for portable devices such as tablets or mobile phones. This is because nearly every major brand of phone and tablet comes in different ratio sizes, and we don't want to start squashing and squeezing our content, as it won't look right. It's also possible that our small mobile games will become successful and could later be ported to a console or PC. If that's the case, we need to make the game screen support these ratios too. The main point to take from all of this is that we are targeting our game to cover all possible common screen ratios. The more platforms (consoles, portable devices, and so on) we can cover with flexible screen ratios, the easier it will be to extend our game out to those devices without requiring extra work. We explain more about screen size ratios in <a href="B18381_08_Epub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Adding Custom Fonts and UI</em>, and <a href="B18381_09_Epub.xhtml#_idTextAnchor161"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating a 2D Shop Interface and In-Game HUD</em>, where we discuss UI display settings. Additionally, in <a href="B18381_13_Epub.xhtml#_idTextAnchor219"><em class="italic">Chapter 13</em></a>, <em class="italic">Effects, Testing, Performance, and Alt Controls</em>, we will explain how to display our game screen on a raw image component.</p>
			<p>Before we continue any further with our project, it's probably a good time to confirm our understanding of Unity's own UI layout. The following screenshot shows the Unity Editor, where<a id="_idIndexMarker152"/> I have outlined and labeled the relevant windows:</p>
			<div><div><img src="img/Figure_2.19_B18381.jpg" alt="Figure 2.19 – The Unity editor window layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.18 – The Unity Editor window layout</p>
			<p>Typically, the <a id="_idIndexMarker153"/>Unity Editor window is made up of five main windows:</p>
			<ul>
				<li><strong class="bold">Scene</strong>: This is our two-/three-dimensional workspace.</li>
				<li><strong class="bold">Game</strong>: This window is what the end user will see. By default, the <strong class="bold">Game</strong> tab shares the same space as the <strong class="bold">Scene</strong> window.</li>
				<li><strong class="bold">Hierarchy</strong>: All game objects in our scene will be listed here.</li>
				<li><strong class="bold">Inspector</strong>: When an object is selected, information about it will be displayed here.</li>
				<li><strong class="bold">Project</strong>: This is our Unity project folder. Consider it a structure of files and folders that we <a id="_idIndexMarker154"/>can use in our game.<p class="callout-heading">Tip</p><p class="callout">To drag each window around individually, left-click and drag the name of the tab, and it will then snap into different locations.</p></li>
			</ul>
			<p>My <strong class="bold">Game</strong> window is set to <strong class="bold">1080</strong>, and because I don't have the luxury of a second screen, I've clicked its name tab (<strong class="bold">Game</strong>) and pulled it down in the bottom-right corner. The window is small, but as you can see at the top of the <strong class="bold">Game</strong> window, the scale is set to 1x, which means I have a full picture; nothing is hidden or cut out of view.</p>
			<p>To check that we <a id="_idIndexMarker155"/>have the main camera's <code>0</code>. We can also reset the <strong class="bold">Transform</strong> option as follows:</p>
			<ol>
				<li value="1">With the main camera selected in the <strong class="bold">Hierarchy</strong> window, click the three dots at the top-right corner of the <strong class="bold">Transform</strong> panel in the <strong class="bold">Inspector</strong> window, as shown in the following screenshot:  </li>
			</ol>
			<div><div><img src="img/Figure_2.20_B18381.jpg" alt="Figure 2.20 – The Transform settings cog location&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.19 – The Transform settings cog location</p>
			<ol>
				<li value="2">When the dropdown appears, click <strong class="bold">Reset</strong>.</li>
			</ol>
			<p>Continuing with setting up our main camera, let's get rid of the landscape background in our <strong class="bold">Scene</strong>/<strong class="bold">Game</strong> window by changing its <strong class="bold">Background</strong> setting:</p>
			<ol>
				<li value="3">Click the <strong class="bold">Main Camera</strong> in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>In the <strong class="bold">Inspector</strong> window, we have the <strong class="bold">Camera</strong> component with a property called <strong class="bold">Clear Flags</strong>. Click the <strong class="bold">Skybox</strong> value. </li>
				<li>A dropdown <a id="_idIndexMarker156"/>will appear. Click <strong class="bold">Solid Color</strong>, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_2.21_B18381.jpg" alt="Figure 2.21 – Changing Background to a Solid Color&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.20 – Changing Background to a Solid Color</p>
			<ol>
				<li value="6">We will now be presented with a blue background, which is less distracting.</li>
				<li>If you don't like blue, you can change it to any color in the <code>0</code>, <code>0</code>, <code>0</code>, and <code>255</code>, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_2.22_B18381.jpg" alt="Figure 2.22 – Setting Background color values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.21 – Setting Background color values</p>
			<p>Great, now let's<a id="_idIndexMarker157"/> move on to coding these properties for our main camera.</p>
			<h3>Updating our camera properties via a script</h3>
			<p>We now<a id="_idIndexMarker158"/> have our main camera's behavior set in our <strong class="bold">Scene</strong>. Next, we need to code this into a script so that whenever a scene is loaded, Unity will read the script and understand how the main camera should be set up.</p>
			<p>Observing our framework again, let's see where the camera script should be placed:</p>
			<div><div><img src="img/Figure_2.23_B18381.jpg" alt="Figure 2.23 – Killer Wave UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.22 – Killer Wave UML</p>
			<p>As you can see in the diagram, there is no reference to the camera, so should we make a script to support this? Arguably, the only reason to make a script based on the camera would be if the<a id="_idIndexMarker159"/> camera had a complex purpose filled with multiple properties and functions. The camera in our game, however, is put in place when the game starts. Later on, on the third level, the camera will move from left to right with a simple component script, but it doesn't hold any other complexity. It would, therefore, be more ideal to use the <code>GameManager</code>, as it only takes up a small role. If the game became bigger and the camera took on more of a role, then this might justify the camera having a class of its own. Others might disagree based on personal preference, but this is the approach we'll take.</p>
			<p>Let's make the <code>GameManager</code> script, as follows:</p>
			<ol>
				<li value="1">Create a script in the same way that we created a folder. Right-click the open space area in the <strong class="bold">Project</strong> window, and a dropdown will appear. Click <strong class="bold">Create | C# Script</strong>, as follows:</li>
			</ol>
			<div><div><img src="img/Figure_2.24_B18381.jpg" alt="Figure 2.24 – Creating a C# script in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.23– Creating a C# script in the Unity Editor</p>
			<ol>
				<li value="2">The script appears <a id="_idIndexMarker160"/>with the title <code>NewBehaviourScript</code>. We don't want to call it that, so type (in camel case) <code>GameManager</code>.<p class="callout-heading">What's camel casing? </p><p class="callout">Camel casing is a way to avoid spacing between words. This is fairly common with programming, as spaces are typically not welcomed for various reasons. Each new word starts with a capital letter, so in this case, the M in <code>GameManager</code> is the hump of the camel. However, variables typically start with lowercase, as you will see shortly.</p></li>
			</ol>
			<p>We now have our <code>GameManager</code> script. Notice how Unity is trying to be helpful by changing the icon to a silver cog because what we are doing is a recognized method with Unity:</p>
			<div><div><img src="img/Figure_2.25_B18381.jpg" alt="Figure 2.25 – The GameManager icon&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.24 – The GameManager icon</p>
			<p>As we did when placing our three-dimensional models into the <code>GameManager</code> into the <code>Script</code> folder.</p>
			<p>Good. Now, before we open our script to code in it, we need to attach it to a game object in our<a id="_idIndexMarker161"/> scene so that when the scene runs, the script attached to the game object also runs.</p>
			<p>To create our <code>GameManager</code> game object, we need to do the following:</p>
			<ol>
				<li value="1">Right-click in an open space in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>From the drop-down menu, select <strong class="bold">Create Empty</strong>.</li>
				<li>Right-click the newly created game object and select <strong class="bold">Rename</strong> from the drop-down menu.</li>
				<li>Rename this game object <code>GameManager</code>.</li>
				<li>Finally, with the <code>GameManager</code> game object still selected, click the <strong class="bold">Add Component</strong> button in the far-right <strong class="bold">Inspector</strong> window.</li>
				<li>Type <code>GameManager</code> from the drop-down menu until you see the <code>GameManager</code> script and select it.<p class="callout-heading">Tip</p><p class="callout">Whenever we make an empty game object, we must be sure that all of its <strong class="bold">Transform</strong> property values are reset to their default values unless we are specifically changing them.</p><p class="callout">To reset a game object's <strong class="bold">Transform</strong> value, make sure that the game object we are resetting is selected. Click the metal cog at the top-right corner of the <strong class="bold">Inspector</strong> window, and then select <strong class="bold">Reset</strong>.</p></li>
			</ol>
			<p>Double-click the <code>GameManager</code> script to open it up in your IDE (Visual Studio or whatever <a id="_idIndexMarker162"/>IDE you use), and then proceed as follows:</p>
			<ol>
				<li value="1">Inside the <code>GameManager</code> script, we will be faced with the <code>UnityEngine</code> library being imported into our script to add extra functionality to Unity's own components:<pre><strong class="bold">using UnityEngine;</strong>
<strong class="bold">      public class GameManager : MonoBehaviour </strong>
<strong class="bold">      {</strong></pre></li>
			</ol>
			<p>Also in the preceding code, we have the name of our script along with <code>MonoBehaviour</code> being inherited yet again to add more functionality to our script. <code>MonoBehaviour</code> is also required if the game object that attaches to this script needs to be used in the Unity Editor.</p>
			<p>Let's start adding some of our own code into our <code>GameManager</code> script.</p>
			<ol>
				<li value="2">Create an empty method, <code>CameraSetup</code>, and then run this method in the <code>Start</code> function:<pre>    void Start()
              {
             CameraSetup();  
         }
         void CameraSetup()
         {
     
         }</pre></li>
				<li>Inside the <code>CameraSetup</code> method, add a reference to the camera and set the position and angle of the camera to zero apart from its <em class="italic">z</em> axis. We'll set <code>Z</code> to <code>-300</code>, which will<a id="_idIndexMarker163"/> move the camera back and ensure all game objects are in the shot:<pre>GameObject gameCamera =
         GameObject.FindGameObjectWithTag("MainCamera");
     
     //Camera Transform
     gameCamera.transform.position = new Vector3(0,0,-300);
     gameCamera.transform.eulerAngles = new Vector3(0,0,0);</pre></li>
				<li>Next, we will change the properties of the camera within our <code>CameraSetup</code> method:<pre> //Camera Properties
      gameCamera.GetComponent&lt;Camera&gt;().clearFlags =
         CameraClearFlags.SolidColor;
      gameCamera.GetComponent&lt;Camera&gt;().backgroundColor = 
         new Color32(0,0,0,255);
      }</pre></li>
			</ol>
			<p>This does the following:</p>
			<ul>
				<li>Removes the sky background and replaces it with a solid color</li>
				<li>Changes the solid color from the default blue to black</li>
			</ul>
			<ol>
				<li value="5">Finally, save the script.</li>
			</ol>
			<p>Now, you <a id="_idIndexMarker164"/>should have something like this:</p>
			<div><div><img src="img/Figure_2.26_B18381.jpg" alt="Figure 2.26 – The current code layout for the GameManager script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.25– The current code layout for the GameManager script</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you would like to change other settings relating to the camera, you can find out about them at <a href="https://docs.unity3d.com/ScriptReference/Camera.html">https://docs.unity3d.com/ScriptReference/Camera.html</a>.</p>
			<p>Press the <strong class="bold">Play</strong> button in the upper middle of the editor window, or by using the shortcut <em class="italic">Ctrl</em> + <em class="italic">P</em> (<em class="italic">Command</em> + <em class="italic">P</em> on the Mac). The following screenshot shows where the <strong class="bold">Play</strong> button is located:</p>
			<div><div><img src="img/Figure_2.27_B18381.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.26 – The Play, Pause, and Step button locations</p>
			<p>With the scene in play mode, we can now check out the <strong class="bold">Main Camera</strong> game object's properties by doing the following:</p>
			<ol>
				<li value="1">In <a id="_idIndexMarker165"/>the <strong class="bold">Hierarchy</strong> window, select <strong class="bold">Main Camera</strong>.</li>
			</ol>
			<p>Observe the <strong class="bold">Inspector</strong> window in the next screenshot to see the following changes our script has made.</p>
			<ol>
				<li value="2">In the <strong class="bold">Transform</strong> component of the <strong class="bold">Inspector</strong> window, we can see that the <strong class="bold">Position</strong> and <strong class="bold">Rotation</strong> properties are set to the same values set in our script (denoted by <strong class="bold">1</strong> in the following screenshot).</li>
				<li>In the <strong class="bold">Camera</strong> component of the <strong class="bold">Inspector</strong> window, we can see that the <strong class="bold">Clear Flags</strong> and <strong class="bold">Background</strong> values are also set to the same values set in our script (denoted by <strong class="bold">2i</strong> and <strong class="bold">2ii</strong>).</li>
			</ol>
			<p>The following screenshot shows the <strong class="bold">Main Camera</strong> component properties being updated in Play mode:</p>
			<div><div><img src="img/Figure_2.28_B18381.jpg" alt="Figure 2.28 – Main Camera values changing with our script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.27 – Main Camera values changing with our script</p>
			<p>Now, hopefully, our properties should be the same as what we have scripted (with no errors). If not, you will likely have an error message in the <strong class="bold">Console</strong> window. If there is an error, it will likely tell you what line the error is on. You can also double-click the error, and it will take you to the line the error is on.</p>
			<p>To double-check <a id="_idIndexMarker166"/>everything has worked, change the <strong class="bold">Position</strong> and <strong class="bold">Rotation</strong> of the camera in the editor, and then press the <strong class="bold">Play</strong> button. The properties for the camera should now be set to our script's <strong class="bold">Position</strong> and <strong class="bold">Rotation</strong> properties. </p>
			<p>At this point, while the editor is still playing, we can also make a prefab of the camera:</p>
			<ol>
				<li value="1">Click and drag the <strong class="bold">Camera</strong> from the <strong class="bold">Hierarchy</strong> window down into the <strong class="bold">Project</strong> window, and we will generate a blue cube with the camera's name or an empty icon. Depending on the scale of our icons, the size of the icon can be altered by moving the slider shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_2.29_B18381.jpg" alt="Figure 2.29 – The slider in the bottom right of the Project window zooms in and out of thumbnails&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.28 – The slider in the bottom right of the Project window zooms in and out of thumbnails</p>
			<ol>
				<li value="2">Move this camera prefab into the <code>Prefab</code> folder.</li>
			</ol>
			<p>You might be thinking, <em class="italic">why didn't we just make a prefab of the camera in the first place instead of fiddling with its property settings in code?</em> However, two key things are important <a id="_idIndexMarker167"/>here: firstly, we are studying for an exam that is likely to cover such properties; and secondly, you now know how to change these settings dynamically through code.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Another benefit to scripting Unity's components is that we can sometimes be offered more functionality than what is displayed in the Editor. For example, the <code>Camera</code> component has a <code>layerCullDistances</code> property that is only accessible via scripting. This can offer functionality such as skipping the rendering of smaller game objects in the far distance to increase a game's performance.</p>
			<p class="callout">To read more about <code>layerCullDistances</code>, check the documentation at <a href="https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html">https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html</a>.</p>
			<p>This brings this section to a close. So far, we have covered the following:</p>
			<ul>
				<li>Setting up a ratio for our game camera</li>
				<li>Setting up our Unity Editor with individual windows</li>
				<li>Changing the properties of our <strong class="bold">Camera</strong> component in the Unity Editor</li>
				<li>Repeating the changes we made to our camera in the <code>GameManager</code> script</li>
				<li>Adding our <code>GameManager</code> script to our scene as a game object</li>
			</ul>
			<p>As a programmer, the importance of being able to understand and change the settings in the Unity Editor (but also being able to do the same in code) can be expanded to other components that are in the editor. This is what we will do next, with a focus on directional light.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/>Setting up our light</h2>
			<p>As a default<a id="_idIndexMarker168"/> setup, each scene comes with a directional light, and currently, this is all we need to get going; ideally, we want the scene to be well lit.</p>
			<p>With the directional light already present in the scene as the default light, select it in the <code>50</code>, <code>-30</code>, and <code>0</code>.</p>
			<p>When we put our player ship into the scene, this will light it up well, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_2.30_B18381.jpg" alt="Figure 2.30 – The player ship lit up&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.29 – The player ship lit up</p>
			<p class="callout-heading">Different Lights</p>
			<p class="callout">Unity provides three different types of real-time lights. As well as the <strong class="bold">directional</strong> light we mentioned, it also provides a <strong class="bold">point</strong> light, which is like a 360° glow that we will cover in <a href="B18381_04_Epub.xhtml#_idTextAnchor087"><em class="italic">Chapter 4</em></a>, <em class="italic">Applying Art, Animation, and Particles</em>. The third type of light is a spotlight or, as Unity refers to it, a <strong class="bold">spot</strong>. The <strong class="bold">spot</strong> can also have masks applied, so it can project images known as cookies.</p>
			<p class="callout">For more information about the three types of lights, check out <a href="https://docs.unity3d.com/Manual/Lighting.html">https://docs.unity3d.com/Manual/Lighting.html</a>.</p>
			<p>We can now make<a id="_idIndexMarker169"/> sure these settings stay in place by adding them to the <code>GameManager</code> script. We can also alter the light's color.</p>
			<h3>Updating our light properties via a script</h3>
			<p>In the <code>GameManager</code>, we <a id="_idIndexMarker170"/>will set the <strong class="bold">Transform</strong> <strong class="bold">Rotation</strong> values and change the color tint from a light yellow to a cold blue:</p>
			<ol>
				<li value="1">Open the <code>GameManager</code> script and enter the following method:<pre>void LightSetup()
       {
          GameObject dirLight = GameObject.Find("Directional Light");
          dirLight.transform.eulerAngles = new Vector3(50,-30,0);
          dirLight.GetComponent&lt;Light&gt;().color = 
             new Color32(152,204,255,255);
       }</pre></li>
				<li>Add <code>LightSetup();</code> in the scope of the <code>Start</code> function.</li>
				<li>Save the script. </li>
			</ol>
			<p>The <code>LightSetup</code> method does three things:</p>
			<ol>
				<li value="1">It grabs the light from the scene and stores it as a reference.</li>
				<li>It sets the rotation of the light with <code>EulerAngles</code>.</li>
				<li>Finally, it changes the light's color.<p class="callout-heading">EulerAngles</p><p class="callout"><code>eulerAngles</code> allows us to give <code>Vector3</code> coordinates instead of <code>Quaternion</code> values. <code>eulerAngles</code> makes rotations less complicated to work with. More information about <code>eulerAngles</code> can be found at <a href="https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html">https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html</a>.</p></li>
			</ol>
			<p>That's all we need to do with our light. As with the camera, we can access the light and change its properties via a script.</p>
			<p>We have become <a id="_idIndexMarker171"/>familiar with our light by changing its settings in the Unity Editor and the <code>GameManager</code> script. Next, we will set up our interface for the majority of our game objects.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor057"/>Introducing our interface – IActorTemplate</h1>
			<p>The <code>IActorTemplate</code> interface<a id="_idIndexMarker172"/> is what we are using to prompt damage control, death, and scriptable object assets. The reason for using an interface such as this is that it ties general uses together between classes that inherit it. </p>
			<p>A total of six classes <a id="_idIndexMarker173"/>will be using the <code>IActorTemplate</code> interface, which is as follows:</p>
			<ul>
				<li><code>Player</code></li>
				<li><code>PlayerBullet</code></li>
				<li><code>PlayerSpawner</code></li>
				<li><code>Enemy</code></li>
				<li><code>EnemyBullet</code></li>
				<li><code>EnemySpawner</code></li>
			</ul>
			<p>The following diagram shows the <code>IActorTemplate</code> interface with a partial overview of our game framework:</p>
			<div><div><img src="img/Figure_2.31_B18381.jpg" alt="Figure 2.31 – IActorTemplate UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.30 – IActorTemplate UML</p>
			<p>Let's create our<a id="_idIndexMarker174"/> interface and explain its content along the way:</p>
			<ol>
				<li value="1">Create a script in the <code>Assets/Scripts</code> folder with the filename <code>IActorTemplate</code>.</li>
				<li>Open the script and enter the following code:<pre>public interface IActorTemplate
      {
      int SendDamage();
      void TakeDamage(int incomingDamage);
      void Die();
      void ActorStats(SOActorModel actorModel);
      }</pre></li>
				<li>Make sure to save the script.</li>
			</ol>
			<p>The code we just entered looks like we have declared a class, but it acts fundamentally differently. Instead of using the <code>class</code> keyword, we enter <code>interface</code> followed by the name of the interface, <code>IActorTemplate</code>. It's not a requirement to start any interface name with an <code>I</code>, but it makes the script easily identifiable.</p>
			<p>Within the <code>interface</code>, we make a list of methods that act like contracts to whichever class implements them. For example, the <code>Player</code> script that we'll create later on in the chapter inherits the <code>IActorTemplate</code> interface. The <code>Player</code> script must declare the function names from <code>IActorTemplate</code> or the <code>Player</code> script will throw an error.</p>
			<p>Inside the scope of the <code>interface</code>, we declare methods without accessors (it doesn't require <code>private</code> or <code>public</code> at the beginning of each method). Methods also don't require any <a id="_idIndexMarker175"/>content in them (that is, they are empty bodies). </p>
			<p>For more <a id="_idIndexMarker176"/>information about interfaces, check out <a href="https://learn.unity.com/tutorial/interfaces">https://learn.unity.com/tutorial/interfaces</a>.</p>
			<p>The last method in our <code>interface</code> is <code>ActorStats</code>, which takes a <code>SOActorModel</code> type. <code>SOActorModel</code> is a scriptable object that we are going to explain and create in the next section.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor058"/>Introducing our ScriptableObject – SOActorModel</h1>
			<p>In this section, we <a id="_idIndexMarker177"/>are going to cover scriptable objects<a id="_idIndexMarker178"/> and their benefits. Similar to our <code>interface</code>, scriptable objects cover the same six classes. The reason for this is that our <code>interface</code> uses the <code>SOActorModel</code> and, therefore, creates an attachment with the other variables. </p>
			<p>It is also good to remind ourselves of <a id="_idIndexMarker179"/>the <strong class="bold">Game Design Document </strong>(<strong class="bold">GDD</strong>) and how it is incorporated into the overview of the creation of our game.</p>
			<p>Our game has three series of game objects that will hold similar properties: <code>EnemyWave</code>, <code>EnemyFlee</code>, and <code>Player</code>. These properties will include health, speed, score value, and more. The difference between each of these as described in the game design brief is the way they act and also how they are instantiated in our game.</p>
			<p><code>Player</code> will be instantiated at every level, <code>EnemyWave</code> will be spawned from <code>EnemySpawner</code>, and <code>EnemyFlee</code> will be placed in particular areas of the third level.</p>
			<p>All of the aforementioned game objects will relate to the <code>SOActorModel</code> object.</p>
			<p>The following diagram is also a partial view of our game framework, showing the scriptable object<a id="_idIndexMarker180"/> and <a id="_idIndexMarker181"/>the six classes that inherit it:</p>
			<div><div><img src="img/Figure_2.32_B18381.jpg" alt="Figure 2.32 – SOActorModel UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.31 – SOActorModel UML</p>
			<p>Similar to what was mentioned with the <code>interface</code> script is that the name of the scriptable object name starts with <code>SO</code>, which isn't a standard way of naming the script, but it's easier to identify as a <code>ScriptableObject</code>. </p>
			<p>The purpose of this scriptable object is to hold general values for each of the game objects it's being given to. For example, all game objects have a name, so within our <code>SOActorModel</code> is a <code>string</code> named <code>actorName</code>. This <code>actorName</code> will be used to name the type of enemy, spawner, or bullet it is.</p>
			<p>Let's create a scriptable object, as follows:</p>
			<ol>
				<li value="1">In the <code>Assets/Scripts</code> folder with the filename <code>SOActorModel</code>.</li>
				<li>Open<a id="_idIndexMarker182"/> the <a id="_idIndexMarker183"/>script and enter the following code:<pre>using UnityEngine; 
     [CreateAssetMenu(fileName = "Create Actor", menuName = 
         "Create  Actor")]
     public class SOActorModel : ScriptableObject 
     
     { 
          public string actorName;
          public AttackType attackType;
     
          public enum AttackType
           {
              wave, player, flee, bullet
           }
          public string description;
          public int health;
          public int speed;
          public int hitPower;
          public GameObject actor;
          public GameObject actorsBullets;
     }</pre></li>
				<li>Save<a id="_idIndexMarker184"/> the script.</li>
			</ol>
			<p>Inside the <code>SOActorModel</code>, we will be naming most, if not all, of these variables in the <code>Player</code> script. Similar to how an <code>interface</code> signs a contract with a class, the <code>SOActorModel</code> does the same because it's being inherited, but isn't as strict as an <code>interface</code> by throwing an error if the content from the scriptable object isn't applied.</p>
			<p>The following is an overview of the <code>SOActorModel</code> code we just entered.</p>
			<p>We named our scriptable object <code>SOActorModel</code> as a generic term to try and cover as many game <a id="_idIndexMarker185"/>objects as will likely use the scriptable object. This way of <a id="_idIndexMarker186"/>working also supports the SOLID principles we covered in the first chapter by encouraging us to try and keep our code concise and efficient.</p>
			<p>The main categories we'll <a id="_idIndexMarker187"/>cover for this script are as follows:</p>
			<ul>
				<li><code>SOActorModel</code> script is <code>using UnityEngine</code>; no other libraries are required.</li>
				<li><code>CreateAssetMenu</code> attribute creates an extra selection from the drop-down list in the <strong class="bold">Project</strong> window in the Unity Editor when we right-click and select <strong class="bold">Create</strong>, as shown in the following screenshot:</li>
			</ul>
			<div><div><img src="img/Figure_2.33_B18381.jpg" alt="Figure 2.33 – Creating an Actor in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.32 – Creating an Actor in the Unity Editor</p>
			<ul>
				<li><code>MonoBehaviour</code> but <code>ScriptableObject</code> instead, as it's a requirement when it comes to creating an asset.</li>
				<li><strong class="bold">Variables</strong>: Finally, these <a id="_idIndexMarker189"/>are the variables that will be sent to our selected classes.</li>
			</ul>
			<p>In the<a id="_idIndexMarker190"/> following <a id="_idIndexMarker191"/>sections, we are going to create assets from the scriptable object script to give our scripts different values.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Creating a PlayerSpawner ScriptableObject asset</h2>
			<p>With <a id="_idIndexMarker192"/>our <code>SOActorModel</code> <code>ScriptableObject</code> made, we can now create an asset that will act as a template that can be used not just by programmers but also by designers who want to tweak game properties/settings without needing to know how to code.</p>
			<p>To create an <code>Actor Model</code> asset, do the following: </p>
			<ol>
				<li value="1">Back in the Unity Editor, in the <strong class="bold">Project</strong> window, right-click and choose <strong class="bold">Create | Create Actor</strong>.</li>
				<li>Rename the newly created asset file in the <code>Player_Default</code> and store the file in the <code>Assets/Resources</code> folder.</li>
				<li>Click on the new asset, and in the <strong class="bold">Inspector</strong> window, you'll see the content of the asset.</li>
			</ol>
			<p>The following screenshot shows the <code>Actor Model</code> asset's fields, where I have entered my own values: </p>
			<div><div><img src="img/Figure_2.34_B18381.jpg" alt="Figure 2.34 – Player values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.33 – Player values</p>
			<p>Let's break down <a id="_idIndexMarker193"/>each of the values that have been added to our newly created asset:</p>
			<ul>
				<li><code>Player</code>).</li>
				<li><strong class="bold">Ship Type</strong>: Choose which category this game object belongs to.</li>
				<li><strong class="bold">Description</strong>: Designer/internal notes that don't affect the game but can be helpful.</li>
				<li><strong class="bold">Health</strong>: How many times the player can get hit before dying.</li>
				<li><strong class="bold">Speed</strong>: The movement speed of the player.</li>
				<li><strong class="bold">Hit Power</strong>: Determines how much damage the player will cause if they collide with the enemy.</li>
				<li><code>player_ship</code> prefab here (<code>Assets/Prefab/Player</code></li>
				<li><code>player_bullet</code> prefab here (<code>Assets/Prefab /Player/</code>).</li>
			</ul>
			<p>We will add this asset to our <code>PlayerSpawner</code> script once it's built later on in the chapter. Let's<a id="_idIndexMarker194"/> move on to the next scriptable object asset.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>Creating an EnemySpawner ScriptableObject asset</h2>
			<p>In this <a id="_idIndexMarker195"/>section, we are going to make our enemy asset attach to <code>EnemySpawner</code> for later on in the chapter. For the sake of keeping our work fresh and complete, let's continue with that before moving on to the <code>EnemySpawner</code> script.</p>
			<p>To make an enemy asset, follow these instructions:</p>
			<ol>
				<li value="1">Back in the Editor, in the <strong class="bold">Project</strong> window, right-click and choose <strong class="bold">Create | Create Actor</strong>.</li>
				<li>Rename the new file to refer to what it's being attached to (<code>BasicWave Enemy</code>) and store the file in the <code>Assets/ScriptableObject</code> location.</li>
				<li>Click on the new script, and our <strong class="bold">Inspector</strong> window will show the content of our script.</li>
			</ol>
			<p>The following screenshot shows what the <code>BasicWave Enemy</code> asset is going to look like once we've finished:</p>
			<div><div><img src="img/Figure_2.35_B18381.jpg" alt="Figure 2.35 – The Basic Wave Enemy values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.34 – The Basic Wave Enemy values</p>
			<p>Let's briefly go through each of the values for our enemy:</p>
			<ul>
				<li><code>enemy_wave</code>.</li>
				<li><code>Wave</code>. This explains what type of enemy it is and how it attacks the player.</li>
				<li><code>Typically in groups</code>. As mentioned before, it's more of a guideline than a rule to comment on anything.</li>
				<li><code>1</code>, which means it takes 1 hit to die. </li>
				<li><code>-50</code>, because our enemy is moving from right to left, so we give it a minus figure.</li>
				<li><code>1</code>, which means that if this enemy collides with the player, it will cause 1 hit point of damage.</li>
				<li><code>enemy_wave</code> prefab here (<code>Assets/Prefab/Enemies</code>).</li>
				<li><strong class="bold">Actors Bullets</strong>: This enemy doesn't fire bullets.</li>
			</ul>
			<p>Hopefully, you can<a id="_idIndexMarker196"/> see how useful scriptable objects are. Imagine continuing to develop this game with <code>50</code> enemies, where all we need to do is create an asset and customize it.</p>
			<p>We are going to move on to the final scriptable object asset for this chapter in the next section.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Creating a PlayerBullet ScriptableObject Asset</h2>
			<p>In this <a id="_idIndexMarker197"/>section, we are going to create an asset for the player's bullet for when they fire. As with the last two sections, create an asset, name it <code>PlayerBullet</code>, and store it in the same folder as the other assets.</p>
			<p>The following screenshot shows the final results for the <code>PlayerBullet</code> asset:</p>
			<div><div><img src="img/Figure_2.36_B18381.jpg" alt="Figure 2.36 – The Player Bullet values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.35 – The Player Bullet values</p>
			<p>Let's briefly go <a id="_idIndexMarker198"/>through each variable's values:</p>
			<ul>
				<li><code>player_bullet</code>.</li>
				<li><strong class="bold">Ship Type</strong>: Bullet.</li>
				<li><strong class="bold">Description</strong>: It is optional to enter any details about the asset here.</li>
				<li><code>1</code>.</li>
				<li><code>700</code>.</li>
				<li><code>1</code> sends a hit point of 1.</li>
				<li><code>player_bullet</code> prefab here (<code>Assets/Prefab/Player</code>).</li>
				<li><strong class="bold">Actors Bullets</strong>: <strong class="bold">None (Game Object)</strong>.</li>
			</ul>
			<p>In a later chapter, when we build a shop for our game, we will be able to buy power-ups for our player's ship. One of the power-ups will be similar to the one that we just made, but the <strong class="bold">Actor Name</strong> will be different, and the <strong class="bold">Hit Power</strong> will have a higher number.</p>
			<p>Now, we can move on to the next section and create the player's scripts and attach these assets to them.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/>Setting up our Player, PlayerSpawner, and PlayerBullet scripts</h1>
			<p>In the following series of sections, we are going to create three of the scripts that will cover the following: spawning the player, the player's controls, and the player's bullet.</p>
			<p>The scripts we will be creating and including are as follows:</p>
			<ul>
				<li><code>PlayerSpawner</code>: Creates and calibrates the player</li>
				<li><code>Player</code>: Player controls and general functionality</li>
				<li><code>PlayerBullet</code>: Bullet movement and general functionality</li>
				<li><code>IActorTemplate</code>: A template of the expected rules assigned to a given object (already made)</li>
				<li><code>SOActorModel</code>: A set of values that can be altered by non-programmers (already made)</li>
			</ul>
			<p>We will cover all of these scripts thoroughly and break down each of their purposes, as well as how they depend on and communicate with one another. We will start with the <code>PlayerSpawner</code>, which will create the player's ship and issue its values.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Setting up our PlayerSpawner script</h2>
			<p>The purpose<a id="_idIndexMarker199"/> of the <code>PlayerSpawner</code> script is to be attached to a game object, resulting in the player appearing at its position in the game. The <code>PlayerSpawner</code> script will also set the player's values when it is created. For example, if our player had a particular speed value, or if they had received an upgrade from the shop, the <code>PlayerSpawner</code> script would grab these values and apply them to the <code>Player</code> script.</p>
			<p>The following diagram shows a partial view of the <code>PlayerSpawner</code> class in the game's framework and its relationship with the other classes around it:</p>
			<div><div><img src="img/Figure_2.37_B18381.jpg" alt="Figure 2.37 – PlayerSpawner UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.36 – PlayerSpawner UML</p>
			<p>As we can <a id="_idIndexMarker200"/>see, the <code>PlayerSpawner</code> script is connected to four other scripts:</p>
			<ul>
				<li><code>Player</code>: <code>PlayerSpawner</code> is connected to <code>Player</code> because it creates the player.</li>
				<li><code>SOActorModel</code>: This is a <code>ScriptableObject</code> that gives the <code>PlayerSpawner</code> its values, which are then passed on to the <code>Player</code>.</li>
				<li><code>IActorTemplate</code>: This is the <code>interface</code> that generalizes the script with other common functions.</li>
				<li><code>GameManager</code>: This will send and receive general game information from and to the <code>PlayerSpawner</code> script.</li>
			</ul>
			<p>Before we create our <code>PlayerSpawner</code> script, it would be good housekeeping to create an empty game object to store anything to do with our player, their bullets, and whatever else the player might create in our <code>testLevel</code> scene.</p>
			<p>Make and name the game object by following these steps:</p>
			<ol>
				<li value="1">Right-click the <strong class="bold">Hierarchy</strong> window in its open space.</li>
				<li>A drop-down list will appear. From the list, select <strong class="bold">Create Empty</strong>.</li>
				<li>Name the game object <code>_Player</code>.</li>
			</ol>
			<p>That's all that we need to do. Now, let's make a start with the <code>PlayerSpawner</code> script:</p>
			<ol>
				<li value="1">In the <code>Assets/Scripts</code> folder with the filename <code>PlayerSpawner</code>.</li>
				<li>Open the<a id="_idIndexMarker201"/> script and make sure that we have the following library entered at the top of our script:<pre><strong class="bold">using UnityEngine;</strong></pre></li>
			</ol>
			<p>We only require <code>using UnityEngine</code>, as it covers all of the objects we need in the script.</p>
			<ol>
				<li value="3">Continue by making sure our class is labeled as follows:<pre><strong class="bold">public class PlayerSpawner : MonoBehaviour</strong> 
     {</pre></li>
			</ol>
			<p>It is common in Unity to inherit <code>MonoBehaviour</code> to give the script more functionality within Unity. Its common purpose is so the script can be attached to a game object. </p>
			<ol>
				<li value="4">Continue by entering the script's variables:<pre>   SOActorModel actorModel;
        GameObject playerShip;</pre></li>
			</ol>
			<p>Inside the <code>PlayerSpawner</code> class, we add two global variables: the first variable is the <code>actorModel</code>, which holds a scriptable object asset that will contain values for the player ship, and the second variable will hold our player ship once it's been created from our <code>CreatePlayer</code> method.</p>
			<ol>
				<li value="5">Continue by entering the script's <code>Start</code> function:<pre>void Start()
      {
        CreatePlayer();
      }</pre></li>
			</ol>
			<p>After the global variables, we add a <code>Start</code> function that will run automatically as soon as the game object holding the <code>PlayerSpawner</code> script is active at runtime.</p>
			<p>Inside the scope of the <code>Start</code> function is a method that we are going to create called <code>CreatePlayer</code>.</p>
			<ol>
				<li value="6">Continue <a id="_idIndexMarker202"/>by entering the <code>CreatePlayer</code> method:<pre>void CreatePlayer()
       {
         //CREATE PLAYER
         actorModel = Object.Instantiate(Resources.Load
            ("Player_Default")) 
                as SOActorModel;
         playerShip = GameObject.Instantiate(actorModel.actor) 
            as GameObject;
         playerShip.GetComponent&lt;Player&gt;().ActorStats(actorModel);
      
     //SET PLAYER UP
     
      }
     }</pre></li>
			</ol>
			<p>I have split the <code>CreatePlayer</code> method into two commented-out parts (<code>//CREATE PLAYER</code> and <code>//SET PLAYER UP</code>) due to its size.</p>
			<p>This first part of the <code>CreatePlayer</code> method will <code>instantiate</code> the player ship's <code>ScriptableObject</code> asset and store it in the <code>actorModel</code> variable. We then <code>instantiate</code> a game object that refers to our <code>ScriptableObject</code> that holds the game object called <code>actor</code> in our game object variable named <code>playerShip</code>. Finally, we apply our <code>ScriptableObject</code> asset to the <code>playerShip</code> method called <code>ActorStats</code> that exists in the <code>Player</code> component script (which we will create later on in this chapter).</p>
			<ol>
				<li value="7">Continue <a id="_idIndexMarker203"/>on inside the <code>CreatePlayer</code> method to add the second half:<pre>//SET PLAYER UP
     playerShip.transform.rotation = Quaternion.Euler(0,180,0);
     playerShip.transform.localScale = new Vector3(60,60,60);
     playerShip.name = "Player";
     playerShip.transform.SetParent(this.transform);
     playerShip.transform.position = Vector3.zero;</pre></li>
			</ol>
			<p>In the second half of the <code>CreatePlayer</code> method, we add more code at the same point where we have commented <code>//SET PLAYER UP</code>.</p>
			<p>The code from <code>//SET PLAYER UP</code> onward is dedicated to setting up the player's ship in the correct position at the start of the level. </p>
			<p>The code does the following: </p>
			<ul>
				<li>Sets the rotation of the player's ship to face the right way.</li>
				<li>Sets the scale of the player ship to <code>60</code> on all axes.</li>
				<li>When we <code>instantiate</code> any game object, Unity will add <code>(Clone)</code> to the end of the game object's name. We can rename it <code>Player</code>.</li>
				<li>We make the <code>playerShip</code> game object a child of the <code>_Player</code> game object in the <strong class="bold">Hierarchy</strong> window so that we can easily find it.</li>
				<li>Finally, we reset the player ship's position.</li>
			</ul>
			<p>That is our <code>PlayerSpawner</code> script coded. Now, in the next section, we need to create and attach<a id="_idIndexMarker204"/> this script to a game object and name it. Make sure to save the script before moving on.</p>
			<h3>Creating the PlayerSpawner game object</h3>
			<p>In this<a id="_idIndexMarker205"/> section, we will create a game object that will hold our newly created <code>PlayerSpawner</code> script, and then we will position the <code>PlayerSpawner</code> game object in the <code>testLevel</code> scene.</p>
			<p>To create and set up our <code>PlayerSpawner</code> game object, we need to do the following:</p>
			<ol>
				<li value="1">In the <code>PlayerSpawner</code>.</li>
				<li>Drag and drop the <code>PlayerSpawner</code> game object onto the <code>_Player</code> (remember that <code>_Player</code> is the empty game object in our scene) game object to make the <code>PlayerSpawner</code> its child.</li>
			</ol>
			<p>Because our <code>PlayerSpawner</code> game object doesn't have anything visually applied to it, we can give it an icon.</p>
			<ol>
				<li value="3">With the <code>PlayerSpawner</code> game object still selected in the <strong class="bold">Inspector</strong> window, click the multi-colored box to the left of its name. A selection of colors will be offered, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_2.38_B18381.jpg" alt="Figure 2.38 – Selecting an icon for the PlayerSpawner&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.37 – Selecting an icon for the PlayerSpawner</p>
			<ol>
				<li value="4">Pick a color. Now, the <code>PlayerSpawner</code> game object will be given a label to show us where it is in the scene. This will now appear in the <strong class="bold">Scene</strong> window.<p class="callout-heading">Tip</p><p class="callout">If you still can't see the icon in the <strong class="bold">Scene</strong> window, make sure <strong class="bold">3D icons</strong> are turned off. You can check by clicking the <strong class="bold">Gizmos</strong> button in the top right of the <strong class="bold">Scene</strong> window and unchecking the <strong class="bold">3D Icons</strong> box.</p></li>
			</ol>
			<p>With<a id="_idIndexMarker206"/> the <code>PlayerSpawner</code> game object sitting inside the <code>_Player</code> game object in the <code>PlayerSpawner</code> game object the following values:</p>
			<ol>
				<li value="1">With the <code>PlayerSpawner</code> game object still selected, in the <strong class="bold">Inspector</strong> window, give it the following <strong class="bold">Transform</strong> values:</li>
			</ol>
			<div><div><img src="img/Figure_2.39_B18381.jpg" alt="Figure 2.39 – PlayerSpawner Transform values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.38 – PlayerSpawner Transform values in the Inspector window</p>
			<ol>
				<li value="2">While still in the <code>PlayerSpawner</code> until you see the script appear in the drop-down list.</li>
				<li>Click the <code>PlayerSpawner</code> script to add this to the <code>PlayerSpawner</code> game object.</li>
			</ol>
			<p>We can't move the ship yet, nor can we fire because we haven't coded this in yet. In the following <a id="_idIndexMarker207"/>section, we will go through the player's controls, then we will move on to coding our player and its bullet to travel across the screen.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>Setting up our Input Manager</h2>
			<p>Remember that <a id="_idIndexMarker208"/>this is a side-scrolling shooter game, so the controls will be two-dimensional even though our visuals are three-dimensional. Our focus now is to get the <code>Players</code> controls set up. To do this, we need to access the <strong class="bold">Input Manager</strong>:</p>
			<ol>
				<li value="1">Select <strong class="bold">Edit</strong>, followed by <strong class="bold">Project Settings</strong>, and then select <strong class="bold">Input Manager</strong> from the list:</li>
			</ol>
			<div><div><img src="img/Figure_2.40_B18381.jpg" alt="Figure 2.40 – Selecting the Input Manager in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.39 – Selecting the Input Manager in the Unity Editor</p>
			<p>The <strong class="bold">Input Manager</strong> will offer a list of all available controls for our game. We will first check what the <a id="_idIndexMarker209"/>controls are set to by default. There are a lot of options here, but as mentioned, we only need to browse through the properties that matter to us, namely the following:</p>
			<ul>
				<li><strong class="bold">Horizontal</strong>: Moves the player's ship along its x-axis</li>
				<li><strong class="bold">Vertical</strong>: Moves the player's ship along its y-axis</li>
				<li><strong class="bold">Fire1</strong>: Makes our player shoot</li>
			</ul>
			<p>To check these three properties, we need to do the following:</p>
			<ul>
				<li>Expand the <strong class="bold">Axes</strong> dropdown by clicking the arrow next to it.</li>
				<li>Expand <strong class="bold">Horizontal</strong>, as shown in the following screenshot:</li>
			</ul>
			<div><div><img src="img/Figure_2.41_B18381.jpg" alt="Figure 2.41 – The Input Manager&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.40 – The Input Manager</p>
			<ul>
				<li><code>-1</code>), and the right button configures it positively (<code>+1</code>). Alternative key presses to this effect are <em class="italic">A</em> for left and <em class="italic">D</em> for right.</li>
			</ul>
			<p>If we had analog controls such as a joystick or a steering wheel, we would likely need to be concerned about the influence of gravity when the player releases the controls and it returns to its center. Dead refers to the center of the analog controls. Sometimes, controllers can be unbalanced and naturally lean to one side, so by increasing the dead zone, we can eliminate false feedback from the player that could be detected as a movement. </p>
			<ul>
				<li><code>-1</code>) and the positive button is up (<code>+1</code>). Alternative buttons are <em class="italic">S</em> for down and <em class="italic">W</em> for up.</li>
				<li><code>mouse 0</code> (that is, the left mouse button). For now, remove <code>mouse 0</code> from the alternative button.</li>
			</ul>
			<p>To find out more about the <strong class="bold">Input Manager</strong> window, click the little blue book at the top-right corner of the <strong class="bold">Input Manager</strong> panel.</p>
			<p>Our controls <a id="_idIndexMarker211"/>are now set in the <code>Player</code> script to take advantage of these controls.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Setting up our Player script</h2>
			<p>The <code>Player</code> script will<a id="_idIndexMarker212"/> be attached to the player ship game object, from which the player will be able to move and shoot, as well as inflict and receive damage. We will also make the player ship not go outside of the screenplay area. Before we continue, let's remind ourselves where the <code>Player</code> script lies in our game framework:</p>
			<div><div><img src="img/Figure_2.42_B18381.jpg" alt="Figure 2.42 – Player UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.41 – Player UML</p>
			<p>The <code>Player</code> script will<a id="_idIndexMarker213"/> be in contact with the following scripts:</p>
			<ul>
				<li><code>PlayerBullet</code>: The <code>Player</code> script will create bullets to fire.</li>
				<li><code>PlayerSpawner</code>: The <code>Player</code> script is created from the <code>PlayerSpawner</code>.</li>
				<li><code>IActorTemplate</code>: Contains damage control and the properties for <code>Player</code>.</li>
				<li><code>GameManager</code>: Extra information such as the number of lives, the score, the level, and whatever upgrades the player ship has accumulated will be stored in <code>GameManager</code>.</li>
				<li><code>SOActorModel</code>: Holds <code>ScriptableObject</code> properties for <code>Player</code>.</li>
			</ul>
			<p>Now that we are familiar with the <code>Player</code> script's relation to the other scripts, we can start coding it:</p>
			<ol>
				<li value="1">In the <code>Assets/Scripts</code> folder with the filename <code>Player</code>.</li>
				<li>Open the script and add the <code>IActorTemplate</code> interface to the existing default code:<pre>using UnityEngine;
      
      public class Player : MonoBehaviour, IActorTemplate
      {</pre></li>
			</ol>
			<p>The script will by default import a <code>UnityEngine</code> library (including some others), the name of the class, and <code>MonoBehaviour</code>. All of these are essential to make the script work in the Unity Editor.</p>
			<ol>
				<li value="3">Continuing with the <code>Player</code> script, enter the following global variables:<pre>         int travelSpeed;
         int health;
         int hitPower;
         GameObject actor;
         GameObject fire;    
     
         public int Health
         {
             get {return health;}
             set {health = value;}
         }
        
         public GameObject Fire
         {
             get {return fire;}
             set {fire = value;}
         }
     
         GameObject _Player;
         
         float width;
         float height;
      </pre></li>
			</ol>
			<p>We have entered <a id="_idIndexMarker215"/>a mixture of integers, floats, and game objects in our global variables; starting from the top, the first six variables will be updated from the player's <code>SOActorModel</code> script. <code>travelSpeed</code> is the speed of the player's ship, <code>health</code> is how many hits the player can take before dying, <code>hitPower</code> is the damage the ship will cause when colliding into something that can receive damage (the enemy), <code>actor</code> is the three-dimensional model used to represent the player, and finally, the <code>fire</code> variable is the three-dimensional model from which the player fires. If that seemed a little rushed, go back to the <em class="italic">Introducing our ScriptableObject – SOActorModel</em> section, where we went into more detail about these variables.</p>
			<p>The two public properties of <code>Health</code> and <code>Fire</code> are there to give access to our two <code>private health</code> and <code>fire</code> variables from other classes that require access. </p>
			<p>The <code>_Player</code> variable will be used as a reference to the <code>_Player</code> game object in the scene. </p>
			<p>The last two variables of <code>width</code> and <code>height</code> will be used to store the measured results of the world space dimensions of the screen that the game is played in. We <a id="_idIndexMarker216"/>will discuss these two more in the next block of code.</p>
			<p>Before we begin the following <code>Start</code> function code block, you may question why we would pick <code>Start</code> over <code>Awake</code> when it comes to running a function's code content. Both functions run once at runtime; the only noticeable difference is that <code>Awake</code> runs when the object is created. <code>Start</code> is executed when it's enabled, as can be seen in the documentation at <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a>.</p>
			<p>For simplicity in our Unity project, we will vary between which of the two functions to use. This is so we avoid conflicts between several <code>Awake</code> functions running at the same time. As an example, one script may try to update its Text UI, but the variable updating the text may still be null at runtime because the script with the variable is still waiting for its content to be updated.</p>
			<p>There is a way to avoid conflicts between several <code>Awake</code> functions being called by several scripts at runtime, by going to Unity's <strong class="bold">Script Execution Order</strong> in <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Script Execution Order</strong>.</p>
			<p>If you would like to know more about the <strong class="bold">Script Execution Order</strong>, check the documentation at <a href="https://docs.unity3d.com/Manual/class-MonoManager.html">https://docs.unity3d.com/Manual/class-MonoManager.html</a>.</p>
			<ol>
				<li value="4">Continuing with entering code into the <code>Player</code> script, next up, we will type out the <code>Start</code> function along with its content:<pre> void Start()
      {
        height = 1/(Camera.main.WorldToViewportPoint (new
           Vector3(1,1,0)).y - .5f);
        width = 1/(Camera.main.WorldToViewportPoint(new Vector3(1,1,0))
           .x - .5f);
        
        _Player = GameObject.Find("_Player");
      }</pre></li>
			</ol>
			<p>As previously<a id="_idIndexMarker217"/> mentioned, the <code>height</code> and <code>width</code> variables will store our world space measurements. These are required so that we can clamp the player's ship inside the screen. Both the height and width lines of code use similar methods; the only difference is with the axis we are reading.</p>
			<p>The <code>Camera.main</code> component refers to the camera in our scene, and the function it uses, <code>WorldToViewportPoint</code>, is to take the results from the game's three-dimensional world space and convert the results into viewport space. If you aren't sure what viewport space is, it's similar to what we know as a screen resolution, except its measurements are in points and not pixels, and these points are measured from <code>0</code> to <code>1</code>. The following diagram shows the comparison between screen and viewport measurements:</p>
			<div><div><img src="img/Figure_2.43_B18381.jpg" alt="Figure 2.43 – Screen versus viewport measurements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.42 – Screen versus viewport measurements</p>
			<p>So, with<a id="_idIndexMarker218"/> viewports, no matter what the screen's resolution is, the full height and width are <code>1</code> and everything between that is a fraction. So, for the height, we feed <code>Vector3</code> to <code>WorldToViewportPoint</code>, where <code>Vector3</code> represents a world space value, followed by <code>-0.5f</code>, which sets its offset back to <code>0</code>. Then, we divide <code>1</code> (which is our full-screen size) by the result of our formula. This will give us our current world space height of the screen. We then apply the same principles for the width and use <code>x</code> instead of <code>y</code> and store the result.</p>
			<p>Finally, the last line of code takes the reference of the <code>_Player</code> game object in the scene and stores it into our variable.</p>
			<ol>
				<li value="5">Continuing with the <code>Player</code> script, we have our <code>Update</code> function that is called on every frame. Enter the function along with the following two methods:<pre> void Update ()
      {
          //Movement();
          //Attack();
      }</pre></li>
			</ol>
			<p>The <code>Update</code> function runs the <code>Movement</code> method and <code>Attack</code> method on every frame. We will go into depth about these two methods later on in the chapter, for now we will comment ("//") these two methods out to avoid the script not being able to run. </p>
			<p>The next method we are going to put into our <code>Player</code> script is the <code>ActorStats</code> method. This method is a requirement, as we declare it in the interface we are inheriting.</p>
			<ol>
				<li value="6">Just after the <a id="_idIndexMarker219"/>scope of our <code>Update</code> function, enter the following piece of code:<pre>public void ActorStats(SOActorModel actorModel)
      {
          health = actorModel.health;
          travelSpeed = actorModel.speed;
          hitPower = actorModel.hitPower;
          fire = actorModel.actorsBullets;
      }</pre></li>
			</ol>
			<p>The code we have just entered assigns values from the player's <code>SOActorModel</code> <code>ScriptableObject</code> asset that we made earlier on in the chapter.</p>
			<p>This method doesn't get run in our script but gets accessed by other classes, the reason being that these variables hold values regarding our player and don't need to be anywhere else.</p>
			<ol>
				<li value="7">Save the <code>Player</code> script.</li>
			</ol>
			<p>Before we test what we have so far, we need to attach our <code>Player</code> script to our <code>player_ship</code> in the <strong class="bold">Project</strong> window.</p>
			<ol>
				<li value="8">In the <code>Assets/Prefab</code> and select the <code>player_ship</code> prefab.</li>
				<li>Select the <code>Player</code> until the script appears and then select it.</li>
			</ol>
			<p>With our <code>_Player</code>, <code>PlayerSpawner</code>, and the <code>GameManager</code> game objects, it's time to test out the game. We can see the player ship get created in our <strong class="bold">Game</strong> window by pressing <strong class="bold">Play</strong> in the Editor.</p>
			<p>The following screenshot shows our game in <code>PlayerSpawner</code> game object as the parent of the <code>Player</code> game object; also note the <code>PlayerSpawner</code> icon:</p>
			<div><div><img src="img/Figure_2.44_B18381.jpg" alt="Figure 2.44 – The current Player setup in our game&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.43 – The current Player setup in our game</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Before moving on to the next section, create a prefab of the <code>PlayerSpawner</code> game object by dragging and dropping it into the <code>Assets/Player</code>. That way, if you lose the scene for whatever reason along with its <strong class="bold">Hierarchy</strong> content, you can drag and drop your prefab back in. This should be a rule with any common active game object.</p>
			<p>Let's move on to the next section where we'll continue to work on the <code>Player</code> script, but this time, we will look at what happens when our player's game object comes into contact with an enemy.</p>
			<h3>Colliding with an enemy – OnTriggerEnter</h3>
			<p>In this section, we <a id="_idIndexMarker221"/>are going to add a function to our <code>Player</code> script<a id="_idIndexMarker222"/> that will check to see what has collided with our player's game object during runtime. Currently, the only thing that can collide with our player is an enemy, but we can still demonstrate the use of Unity's own <code>OnTriggerEnter</code> function, which handles most of the work for us:</p>
			<ol>
				<li value="1">Continuing after the scope of our last method (<code>ActorStats</code>) in the <code>Player</code> script, we are going to add the following code that detects our enemy colliding with the player's ship:<pre>  void OnTriggerEnter(Collider other)
       {
         if (other.tag == "Enemy")
         {
           if (health &gt;= 1)
           {
            if (transform.Find("energy +1(Clone)"))
             {
              Destroy(transform.Find("energy +1(Clone)").              gameObject);
              health -= other.GetComponent&lt;IActorTemplate&gt;
                ().SendDamage();
             }
             else
             {
                 health -= 1;
             }
           }
           
           if (health &lt;= 0)
           {
             Die();
           }
         }
       }</pre></li>
			</ol>
			<p>Let's explain some of the code we have just entered into the <code>Player</code> script:</p>
			<ul>
				<li><code>OnTriggerEnter(Collider other)</code> is a function that Unity recognizes to check what has entered into the player's trigger collider.</li>
				<li>We use an <code>if</code> statement to check whether the <code>tag</code> to the collider is called <code>Enemy</code>. Note <a id="_idIndexMarker223"/>when we create our enemy, we <a id="_idIndexMarker224"/>will give them an <code>Enemy</code> <code>tag</code> so they are easily identified. If the <code>tag</code> is equal to <code>Enemy</code>, we drop it into that <code>if</code> statement.</li>
				<li>The next <code>if</code> statement checks to see whether our player's <code>health</code> is equal to or more than <code>1</code>. If it is, that means the player can take a hit and continue without dying and also means we can go into its <code>if</code> statement.</li>
				<li>We approach the third <code>if</code> statement that checks to see whether the collider has a game object named <code>energy +1(Clone)</code>. The name of this object is the name of the shield the player can purchase in the game shop, which we will add in <a href="B18381_06_Epub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Purchasing In-Game Items and Advertisements</em>. If the player has this <code>energy +1(Clone)</code> object, we can <code>Destroy</code> it with Unity's premade function. We also deduct the player's extra health from the enemies' <code>SendDamage</code> function. We will discuss <code>SendDamage</code> later on in the chapter.</li>
				<li>Following the third <code>if</code> statement is an <code>else</code> condition where, in the event that the player doesn't have an <code>energy +1(Clone)</code> game object, they get their health deducted.</li>
				<li>Finally, if the player's <code>health</code> is at a value of zero or under, we run the <code>Die</code> method, which we will cover later in the chapter.<p class="callout-heading">Tip</p><p class="callout">Don't forget to keep saving your work as we continue to add more code to the project.</p></li>
			</ul>
			<p>Let's <a id="_idIndexMarker225"/>continue with our <code>Player</code> script <a id="_idIndexMarker226"/>and add the functionality so that the player can receive and send damage from and to the enemy respectively.</p>
			<ol>
				<li value="2">In the next method, we are going to add two methods. The first method (<code>TakeDamage</code>) will take an integer called <code>incomingDamage</code> and use whatever the value is to deduct from our player's <code>health</code> value.</li>
			</ol>
			<p>The second method (<code>SendDamage</code>) will <code>return</code> an integer of our <code>hitPower</code> value.</p>
			<ol>
				<li value="3">Just below and outside of the scope of our <code>ActorStats</code> method, now add the following code:<pre>public void TakeDamage(int incomingDamage)
      {
        health -= incomingDamage;
      }
      
      public int SendDamage()
      {
        return hitPower;
      }</pre></li>
			</ol>
			<p>Let's continue with another method for the <code>Player</code> script and make it possible for the player to<a id="_idIndexMarker227"/> control<a id="_idIndexMarker228"/> the player ship around the <strong class="bold">Game</strong> window.</p>
			<h3>The Movement method</h3>
			<p>In this <a id="_idIndexMarker229"/>section, we<a id="_idIndexMarker230"/> will code the <code>Movement</code> method, which will take input from the player's joypad/keyboard and also make use of the <code>height</code> and <code>width</code> floats to keep the player's ship within the scree:.</p>
			<ol>
				<li value="1">Still in the <code>Player</code> script, make a start with the following method using the following content to check for the player's input:<pre>void Movement()
     {
       if (Input.GetAxisRaw("Horizontal") &gt; 0)
       {
          if (transform.localPosition.x &lt; width +              width/0.9f)
          {
            transform.localPosition += new Vector3
               (Input.GetAxisRaw("Horizontal")
                 *Time.deltaTime*travelSpeed,0,0);                                                                                                                            
          }
       }</pre><ul><li>The <code>Movement</code> method will consist of detecting movement in four directions being made from the player; we'll start with when the player presses right on the controller/keyboard. We run an <code>if</code> statement that checks whether the Input Manager has detected any movement from the <code>Horizontal</code> property. If the <code>GetAxisRaw</code> detects a value higher than zero, we fall into the <code>if</code> statement's condition. Note that <code>GetAxisRaw</code> has no smoothing, so the player's ship will instantly move unless extra code is added.</li><li>Next, we have another <code>if</code> statement; this checks whether the player has exceeded past the <code>width</code> (that is, of the screen's world space that we calculated earlier on in the chapter). We've also added an extra partial <code>width</code> to avoid the geometry of the player's ship leaving the screen. If the player's position is still under the <code>width</code> (and its buffer) value, we run the content inside the <code>if</code> statement.</li><li>The player's<a id="_idIndexMarker231"/> position is updated with a <code>Vector3</code> struct, which<a id="_idIndexMarker232"/> holds the value of the <code>Horizontal</code> direction, multiplied by time per frame and by the <code>travelSpeed</code> we set from our <code>ScriptableObject</code>.</li></ul></li>
				<li>Let's continue in the <code>Movement</code> method and add a similar <code>if</code> statement for moving the player ship to the left:<pre>if (Input.GetAxisRaw("Horizontal") &lt; 0)
        {
          if (transform.localPosition.x &gt; width +               width/6)
          {
           transform.localPosition += new Vector3
             (Input.GetAxisRaw("Horizontal")
               *Time.deltaTime*travelSpeed,0,0);                                                                       
          }
        } </pre></li>
			</ol>
			<p>As we can see, the code is close to the previous block; the only difference is that our first <code>if</code> statement checks whether we are moving left; the second <code>if</code> statement checks whether the player's position is greater than the width and a slightly different buffer.</p>
			<p>Apart from that, the <code>if</code> statement and its content serve the same position, just in the opposite direction.</p>
			<ol>
				<li value="3">Let's continue with our <code>Movement</code> method and add the <code>if</code> statement code for moving<a id="_idIndexMarker233"/> the<a id="_idIndexMarker234"/> player's ship down:<pre>if (Input.GetAxisRaw("Vertical") &lt; 0)
     {
         if (transform.localPosition.y &gt; -height/3f)
         {
          transform.localPosition += new Vector3
           (0,Input.GetAxisRaw("Vertical")*Time.deltaTime*travelSpeed,0);
         }
     }</pre></li>
			</ol>
			<p>Yet again, we follow the same rule from the previous two <code>if</code> statements, but this time, instead of <code>Horizontal</code>, we add the <code>Vertical</code> <code>string</code> property. In the second <code>if</code> statement, we check whether the player's y-axis is higher than a negative <code>height/3</code>. The reason why we divide by this value is that later on in the book (<a href="B18381_09_Epub.xhtml#_idTextAnchor161"><em class="italic">Chapter 9</em></a><em class="italic">, Creating a 2D Shop Interface and In-Game HUD</em>), we will be adding graphics at the bottom of the screen that will restrict the player's view.</p>
			<ol>
				<li value="4">Let's move on to the last <code>if</code> statement in the <code>Movement</code> method, moving up:<pre>if (Input.GetAxisRaw("Vertical") &gt; 0)
        {
         if (transform.localPosition.y &lt; height/2.5f)
        {
         transform.localPosition += new Vector3
           (0,Input.GetAxisRaw("Vertical")*Time.deltaTime*travelSpeed,0);
        }
       }
     }</pre></li>
			</ol>
			<p>As before, this <code>if</code> statement carries a similar role, but this time, it's checking whether <a id="_idIndexMarker235"/>the player's position is under the <code>height/2.5f</code> value. A<a id="_idIndexMarker236"/> buffer is applied to stop the three-dimensional geometry from leaving the top of the screen.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When making a game, sometimes it occurs that when the player moves diagonally, their speed increases. This is because the player is effectively pressing two directions at the same time instead of just one.</p>
			<p class="callout">To ensure a direction has just the magnitude of <code>1</code>, we can use Unity's pre-made <code>Normalize</code> function.</p>
			<p class="callout">To find out more about this function, check the documentation at <a href="https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html">https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html</a>.</p>
			<ol>
				<li value="5">Don't forget to save the script.</li>
			</ol>
			<p>We will continue with the <code>Player</code> script by adding the <code>Die</code> method.</p>
			<h3>The Die method</h3>
			<p>Adding<a id="_idIndexMarker237"/> the <code>Die</code> method to the <code>Player</code> script will make it possible for<a id="_idIndexMarker238"/> our player to be destroyed. Currently, inside the <code>Die</code> method is a Unity function called <code>Destroy</code>; this function will delete whatever game object is within its parameter. </p>
			<p>Enter the following method in the <code>Player</code> script to destroy the player:</p>
			<pre>public void Die()
      {
          Destroy(this.gameObject);
      }</pre>
			<p>Let's move on to the last method in the <code>Player</code> script, which is to attack.</p>
			<h3>The Attack method</h3>
			<p>In this<a id="_idIndexMarker239"/> section, we <a id="_idIndexMarker240"/>will add content to the <code>Attack</code> method in the <code>Player</code> script.</p>
			<p>The purpose of this <code>Attack</code> method is to receive input from the player, create a bullet, point the bullet in the correct direction, and make the bullet a child of the <code>Player</code> game object to keep our <strong class="bold">Hierarchy</strong> window tidy.</p>
			<p>Enter the following <code>Attack</code> method into the <code>Player</code> script to allow the player to fire bullets:</p>
			<pre>public void Attack()
      {
       if (Input.GetButtonDown("Fire1"))
         {
             GameObject bullet = GameObject.Instantiate
                (fire,transform.position,Quaternion.Euler
                  (new Vector3(0, 0, 0))) as GameObject;
             bullet.transform.SetParent(_Player.transform);
             bullet.transform.localScale = new Vector3(7,7,7);
         }
       }
     </pre>
			<p>Inside the <code>Attack</code> method, we call an <code>if</code> statement that checks whether the player has pressed the <code>Fire1</code> button (<em class="italic">Left Ctrl</em> on Windows; <em class="italic">command</em> if you are using a Mac). If <a id="_idIndexMarker241"/>the<a id="_idIndexMarker242"/> player has pressed the <code>Fire1</code> button, we will drop into the <code>if</code> statement's scope.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When a developer refers to the scope of a function, <code>if</code> statement, class, and so on, they are referring to what is happening between the opening and closing of the curly braces. For example, if the following code has a higher value in its <code>money</code> variable, the following <code>if</code> statement will run:</p>
			<p class="callout">     </p>
			<p class="callout">     <code>if (money &gt; costOfPizza)</code></p>
			<p class="callout">     <code>{</code></p>
			<p class="callout">     <code>//Whatever happens between the top and bottom of the two curly braces is within the if statements scope.</code></p>
			<p class="callout">     <code>}</code></p>
			<p>Within the <code>if</code> statement, we make another <code>if</code> statement to make sure that when clicking the mouse, we are clicking on the screen and not anything UI-related. This will become more relevant when we look at adding a Pause button in <a href="B18381_10_Epub.xhtml#_idTextAnchor173"><em class="italic">Chapter 10</em></a>, <em class="italic">Pausing the Game, Altering Sound, and a Mock Test</em>. If we do click on something UI-related, we call <code>return</code>, which means we exit the <code>if</code> statement so that we don't fire a shot.</p>
			<p>Because we have entered the movement and attack function content we can scroll back up to the <code>Update</code> function and remove the comments we added.</p>
			<p>Our <code>Update</code> function will now look like the following:</p>
			<pre>void Update()
{
	Movement();
	Attack();
}</pre>
			<p>Next, we <code>Instantiate</code> our <code>PlayerBullet</code> game object from its instance name, <code>fire</code>. We also face the <code>fire</code> game object to the right, relative to the screen, and move it toward oncoming enemies. We store the results of creating and orienting our game object in a variable named <code>bullet</code>.</p>
			<p>We then set the size of the bullet to be seven times larger than its original size, which makes it look bigger.</p>
			<p>Finally, within the <code>if</code> statement, we make our <code>bullet</code> game object sit within a single game object with the variable name <code>_Player</code>.</p>
			<p>That is all of the code required for the <code>Player</code> script! Make sure to save the script before<a id="_idIndexMarker243"/> moving <a id="_idIndexMarker244"/>on.</p>
			<p>In the next section, we are going to move on to a different player script that controls what happens when the player fires their bullet.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>Setting up our PlayerBullet script</h2>
			<p>In this section, we <a id="_idIndexMarker245"/>will be creating a bullet that will travel across the screen from the player's ship.</p>
			<p>You will notice how similar the <code>PlayerBullet</code> script is to the <code>Player</code> script because it carries the <code>IActorTemplate</code> and <code>SOActorModel</code> scripts, which are already coded into the <code>Player</code> script.</p>
			<p>Let's create our <code>PlayerBullet</code> script:</p>
			<ol>
				<li value="1">In the <code>Assets/Scripts</code> folder with the filename <code>PlayerBullet</code>.</li>
				<li>Open the script and check/enter the following code at the top of the script:<pre><strong class="bold">using UnityEngine;</strong></pre></li>
			</ol>
			<p>By default, we require the <code>UnityEngine</code> library, as previously mentioned.</p>
			<ol>
				<li value="3">Let's continue by checking the correct class name and entering the following inheritance:<pre><strong class="bold">public class PlayerBullet : MonoBehaviour, IActorTemplate {</strong></pre></li>
			</ol>
			<p>We declare the <code>public</code> class and by default inherit <code>MonoBehaviour</code>. We also inherit the <code>IActorTemplate</code> interface to give our game object-related methods from the other game object scripts, such as <code>SendDamage</code> and <code>TakeDamage</code>.</p>
			<ol>
				<li value="4">Enter the<a id="_idIndexMarker246"/> following global variables into the <code>PlayerBullet</code> script:<pre>GameObject actor;
     int hitPower;
     int health;
     int travelSpeed;
      
     [SerializeField]
     SOActorModel bulletModel;</pre></li>
			</ol>
			<p>All the variables we add are <code>private</code>. The last variable has a <code>SerializeField</code> attribute added. <code>SerializeField</code> makes it possible for this variable to be visible in the <code>private</code>, we can still drag and drop assets into its field (which we will do shortly). More information on the <code>SerializeField</code> attributes can be found at <a href="https://docs.unity3d.com/ScriptReference/SerializeField.html">https://docs.unity3d.com/ScriptReference/SerializeField.html</a>.</p>
			<ol>
				<li value="5">Next, we'll move on and enter the <code>Awake</code> function along with its content:<pre>void Awake()
      {
          ActorStats(bulletModel);
      }</pre></li>
			</ol>
			<p>In our <code>Awake</code> function is the <code>ActorStats</code> method, which is a requirement because we are inheriting an <code>interface</code> that declares it.</p>
			<ol>
				<li value="6">Continue by entering the <code>SendDamage</code> and <code>TakeDamage</code> methods:<pre> public int SendDamage()
      {
        return hitPower;
      }
      
      public void TakeDamage(int incomingDamage)
      {
        health -= incomingDamage;
      }</pre></li>
			</ol>
			<p>As <a id="_idIndexMarker247"/>mentioned already in this chapter, we require these methods to send and receive damage.</p>
			<ol>
				<li value="7">Moving on, we enter the <code>Die</code> method along with its content:<pre> public void Die()
      {
          Destroy(this.gameObject);
      }</pre></li>
			</ol>
			<p>Another method to include from our <code>interface</code> is the <code>Die</code> method.</p>
			<ol>
				<li value="8">Next, enter the <code>ActorStats</code> method:<pre> public void ActorStats(SOActorModel actorModel)
      {
        hitPower = actorModel.hitPower;
        health = actorModel.health;
        travelSpeed = actorModel.speed;
        actor = actorModel.actor;
      }</pre></li>
			</ol>
			<p>The last method that we inherit from our <code>interface</code> is the <code>ActorStats</code> method, which will hold our <code>ScriptableObject</code> asset. This asset will then be assigned to our <code>PlayerBullet</code> script's global variables.</p>
			<ol>
				<li value="9">The next function is the <code>OnTriggerEnter</code>, along with its <code>if</code> statement<a id="_idIndexMarker248"/> condition checks, as follows:<pre>void OnTriggerEnter(Collider other)
      {
      if (other.tag == "Enemy")
      {
          if(other.GetComponent&lt;IActorTemplate&gt;() != null)
          {
              if (health &gt;= 1)
              {
                  health -= other.GetComponent&lt;IActorTemplate&gt;
                    ().SendDamage();
              }
              if (health &lt;= 0)
              {
                  Die();
              }
          }
       }
      }</pre></li>
			</ol>
			<p>In the preceding block of code, we run a check to see whether our bullet has collided with an <code>"Enemy"</code> tagged collider. If the collider is tagged as <code>"Enemy"</code> to the player, we then check to see whether the collider holds an <code>IActorTemplate</code> interface. If it doesn't, then it's likely the <code>"Enemy"</code> collider is an obstacle. Otherwise, we deduct <code>health</code> from the <code>Enemy</code> game object and check to see whether it's dead.</p>
			<ol>
				<li value="10">Now, let's<a id="_idIndexMarker249"/> enter Unity's <code>Update</code> function for the bullet's movement:<pre>void Update ()
      {
        transform.position += new
           Vector3(travelSpeed,0,0)*Time.deltaTime;
      }</pre></li>
			</ol>
			<p>The <code>Update</code> function adds to its x-axis each frame based on its <code>travelSpeed</code> value multiplied by <code>Time.deltaTime</code> (<code>Time.deltaTime</code> is the time in seconds from the last frame).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you would like to know more about <code>Time.deltaTime</code>, check the documentation at <a href="https://docs.unity3d.com/ScriptReference/Time-deltaTime.html">https://docs.unity3d.com/ScriptReference/Time-deltaTime.html</a>.</p>
			<ol>
				<li value="11">Next, enter Unity's <code>OnBecameInvisible</code> function:<pre>    void OnBecameInvisible() 
         {
           Destroy(gameObject);
         }
     }</pre></li>
			</ol>
			<p>This last function will remove any unnecessary bullets that have left the screen. This will help the performance of our game and keep it tidy. Make sure you have saved the script before continuing.</p>
			<p>Next, we need <a id="_idIndexMarker250"/>to apply the <code>PlayerBullet</code> script to our <code>player_bullet</code> prefab:</p>
			<ol>
				<li value="1">Navigate to <code>Assets/Prefab/Player</code> and select <code>player_bullet</code>.</li>
				<li>With <code>Player_Bullet</code> selected, click the <code>PlayerBullet</code> until you see the <code>PlayerBullet</code> script.</li>
				<li>Select the script and add the <code>PlayerBullet</code> asset to it from the <strong class="bold">Bullet Model</strong> field (drag the asset into the field or click the remote button to the right of its field).</li>
			</ol>
			<p>The following screenshot shows our <code>player_bullet</code> with its script and asset:</p>
			<div><div><img src="img/Figure_2.45_B18381.jpg" alt="Figure 2.45 – The player_bullet components in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.44 – The player_bullet components in the Inspector window</p>
			<p>We can now <a id="_idIndexMarker251"/>move on to the next section about making enemies for the player to attack!</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/>Planning and creating our enemy</h1>
			<p>We have a <a id="_idIndexMarker252"/>player that moves, shoots, and takes damage; we can now start looking into creating an enemy that shares these attributes.</p>
			<p>To remind ourselves of the genre we are making, our game carries the same traits as classic arcade shooters such as Konami's <em class="italic">Gradius</em>, Capcom's <em class="italic">UN Squadron</em>, and Irem's <em class="italic">R-Type</em> (<a href="https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png">https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png</a>). Typically, with these types of games, the player is swarmed by enemies coming from the right of the screen and exiting to the left.</p>
			<p>In this section, we will be repeating similar aspects of the <code>PlayerSpawner</code> and <code>Player</code> scripts. The <code>EnemySpawner</code> script needs to be tweaked so that it will instantiate a given number of enemy ships at a certain rate.</p>
			<p>The <code>Enemy</code> game objects will be moving on their own, so there needs to be some extra code applied to their behavior. Before we go into creating our first enemy script, let's look at a part of our game framework and note that the layout is basically the same as the player's side of the game framework:</p>
			<div><div><img src="img/Figure_2.46_B18381.jpg" alt="Figure 2.46 – EnemySpawner and Enemy UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.45 – EnemySpawner and Enemy UML</p>
			<p>Before we <a id="_idIndexMarker253"/>jump into the <code>EnemySpawner</code> script, let's do the same housekeeping we did for our player game objects, namely creating an empty game object and storing all game objects relating to it in that one game object. The reason we did this is to remove the clutter in the <strong class="bold">Hierarchy</strong> window, so let's do the same for our enemies:</p>
			<ol>
				<li value="1">Right-click in the <strong class="bold">Hierarchy</strong> window's open space.</li>
				<li>A drop-down list will appear; select <strong class="bold">Create Empty</strong>.</li>
				<li>Name the game object <code>_Enemies</code>.</li>
			</ol>
			<p>Let's move on to our enemy scripts.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor068"/>Setting up our EnemySpawner and Enemy scripts</h1>
			<p>In this<a id="_idIndexMarker254"/> section, we<a id="_idIndexMarker255"/> are going to make a start on our <code>EnemySpawner</code> script and game object. The purpose of the <code>EnemySpawner</code> script is to have a game object spawn an enemy game object a series of times at a set rate. As soon as our <code>testLevel</code> scene begins, our enemy spawners will start releasing enemies. It will then be up to the enemies to move to the left of the screen. This is fairly simple, and as mentioned briefly in the previous section, the <code>EnemySpawner</code> uses the same <code>interface</code> and scriptable object as the <code>PlayerSpawner</code> to <code>instantiate</code> enemies. Let's start by creating our <code>EnemySpawner</code> script:</p>
			<ol>
				<li value="1">In the <code>Assets/Scripts</code> folder with the filename <code>EnemySpawner</code>.</li>
				<li>Open the script and enter the following code:<pre><strong class="bold">using System.Collections;</strong>
     <strong class="bold">using UnityEngine;</strong></pre></li>
			</ol>
			<p>As usual, we are using the default <code>UnityEngine</code> library.</p>
			<p>We are also going to be using another library, called <code>System.Collections</code>. This is required when we come to use <code>Coroutines</code>, which will be explained later in this section.</p>
			<ol>
				<li value="3">Next, we will check/enter the class name and its inheritance:<pre><strong class="bold">public class EnemySpawner : MonoBehaviour</strong>
<strong class="bold">     {</strong></pre></li>
			</ol>
			<p>Make sure the class is named <code>EnemySpawner</code> and that it also inherits <code>MonoBehaviour</code> by default.</p>
			<ol>
				<li value="4">Following this, add four global variables to the <code>EnemySpawner</code> script:<pre> [SerializeField]
      SOActorModel actorModel;
      [SerializeField]
      float spawnRate;
      [SerializeField]
      [Range(0,10)]
 int quantity;
      GameObject enemies;</pre></li>
			</ol>
			<p>All variables entered in the previous code have an accessibility level of <code>private</code>, and all of the variables apart from the <code>enemies</code> variable have a <code>SerializeField</code> and a <code>Range</code> attribute of between <code>0</code> to <code>10</code> applied. The reason <a id="_idIndexMarker256"/>for<a id="_idIndexMarker257"/> this is so that we or other designers can easily change the spawn rate and quantity of enemies from our <code>EnemySpawner</code> in the <strong class="bold">Inspector</strong> window, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_2.47_B18381.jpg" alt="Figure 2.47 – Enemy spawn rate slider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.46 – Enemy spawn rate slider</p>
			<ol>
				<li value="5">Now, let's enter Unity's <code>Awake</code> function along with some content:<pre>void Awake()
      {
          enemies = GameObject.Find("_Enemies");
          StartCoroutine(FireEnemy(quantity, spawnRate));
      }</pre></li>
			</ol>
			<p>Inside the <code>Awake</code> function, we make an instance from the empty <code>_Enemies</code> game object divider and store it in the <code>enemies</code> variable.</p>
			<p>The second line of code inside our <code>Awake</code> function is a <code>StartCoroutine</code>.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout"><code>StartCoroutine()</code> and <code>IEnumerator</code> go hand in hand with each other. They act similarly to a method, taking parameters and running the code inside it. The main difference with coroutines is that they can be delayed by frame updates or time. You can consider them a more advanced version of Unity's own <code>Invoke</code> function.</p>
			<p class="callout">To find out more about coroutines and how to implement them in <code>IEnumerator</code> instances, check Unity's documentation at <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html</a>.</p>
			<p>This will be<a id="_idIndexMarker258"/> used <a id="_idIndexMarker259"/>to run our method of creating an enemy, but as you may also notice, it takes two parameters. The first is the <code>quantity</code> of enemies it holds and the second is the <code>spawnRate</code>, which delays each spawned enemy.</p>
			<ol>
				<li value="6">Next, in our <code>EnemySpawner</code> script, we have the <code>FireEnemy</code>, which will be used to run a cycle of creating and positioning each enemy, before waiting to repeat the process.</li>
				<li>Next, below and outside of the <code>Awake</code> function, we can add our <code>IEnumerator</code>:<pre>IEnumerator FireEnemy(int qty, float spwnRte)
      {
       for (int i = 0; i &lt; qty; i++)
       {
        GameObject enemyUnit = CreateEnemy();
        enemyUnit.gameObject.transform.SetParent(this.transform);
        enemyUnit.transform.position = transform.position;
        yield return new WaitForSeconds(spwnRte); 
       }
        yield return null;
       }</pre></li>
			</ol>
			<p>Inside the <code>FireEnemy</code> <code>IEnumerator</code>, we start a <code>for</code> loop that will iterate over its <code>qty</code> value.</p>
			<p>Within the <code>for</code> loop, the following is added:</p>
			<ul>
				<li>A method that we haven't covered yet, called <code>CreateEnemy</code>. The result of <code>CreateEnemy</code> will <a id="_idIndexMarker260"/>be turned into a game object <a id="_idIndexMarker261"/>instance called <code>enemyUnit</code>.</li>
				<li>The <code>enemyUnit</code> is the enemy flying out of the <code>EnemySpawner</code> game object.</li>
				<li>Our <code>EnemySpawner</code> position is issued to our <code>enemyUnit</code>.</li>
				<li>We then wait however many seconds the <code>spwnRte</code> value is set to.</li>
				<li>Finally, the process is repeated up until the <code>for</code> loop has reached its total.</li>
			</ul>
			<ol>
				<li value="8">Finally, below and outside of the <code>FireEnemy</code> <code>IEnumerator</code>, add the following method:<pre>GameObject CreateEnemy()
     {
       GameObject enemy = GameObject.Instantiate(actorModel.actor) 
          as GameObject;
       enemy.GetComponent&lt;IActorTemplate&gt;().ActorStats(actorModel);
       enemy.name = actorModel.actorName.ToString();
       return enemy;
     }
     }</pre></li>
			</ol>
			<p>As we mentioned, there is a method called <code>CreateEnemy</code>. Apart from the obvious, this method will do the following:</p>
			<ol>
				<li value="1"><code>Instantiate</code> the <code>enemy</code> game object from its <code>ScriptableObject</code> asset.</li>
				<li>Apply values to our enemy from its <code>ScriptableObject</code> asset.</li>
				<li>Name the enemy game object from its <code>ScriptableObject</code> asset.</li>
			</ol>
			<p>Don't forget to save the script.</p>
			<p>We can now <a id="_idIndexMarker262"/>move <a id="_idIndexMarker263"/>on to the next section where we will create and prepare the <code>EnemySpawner</code> with its game object.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>Adding our script to the EnemySpawner game object</h2>
			<p>Finally, we<a id="_idIndexMarker264"/> need to attach our <code>EnemySpawner</code> script to an empty game object so that we can use it in our <code>testLevel</code> scene. To set up the <code>EnemySpawner</code> game object, do the following:</p>
			<ol>
				<li value="1">Create an empty game object and name it <code>EnemySpawner</code>.</li>
				<li>As we did with the <code>_Player</code> and <code>PlayerSpawner</code>, we need to move the <code>EnemySpawner</code> game object inside the <code>_Enemies</code> game object in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>After moving the <code>EnemySpawner</code> game object into the <code>_Enemies</code> game object, we now need to update the <code>EnemySpawner</code> game object's <strong class="bold">Transform</strong> property values in the <strong class="bold">Inspector</strong> window:</li>
			</ol>
			<div><div><img src="img/Figure_2.48_B18381.jpg" alt="Figure 2.48 – The EnemySpawner Transform values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.47 – The EnemySpawner Transform values in the Inspector window</p>
			<ol>
				<li value="4">Still in the <code>EnemySpawner</code> until you see it in the list, and then click it.</li>
			</ol>
			<p>Also, for a visual <a id="_idIndexMarker265"/>aid in the <code>EnemySpawner</code> game object, as we did with our <code>PlayerSpawner</code> game object in the <em class="italic">Creating the PlayerSpawner game object</em> section.</p>
			<p>The following screenshot shows the icon I gave to my <code>EnemySpawner</code>:</p>
			<div><div><img src="img/Figure_2.49_B18381.jpg" alt="Figure 2.49 – The EnemySpawner icon&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.48 – The EnemySpawner icon</p>
			<p>We can now add an enemy to our <code>EnemySpawner</code> game object with its script in the <strong class="bold">Inspector</strong> window:</p>
			<div><div><img src="img/Figure_2.50_B18381.jpg" alt="Figure 2.50 – The EnemySpawner component holding the BasicWave Enemy actor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.49 – The EnemySpawner component holding the BasicWave Enemy actor</p>
			<p>We can now <a id="_idIndexMarker266"/>move on to creating our enemy script in the next section.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Setting up our enemy script</h2>
			<p>As with our player<a id="_idIndexMarker267"/> ship being created from the <code>PlayerSpawner</code>, our first enemy will be created from its <code>EnemySpawner</code>. The enemy script will hold similar variables and functions, but it will also have its own movement, similar to the <code>PlayerBullet</code> moving along its <em class="italic">x</em> axis.</p>
			<p>Let's make a start and create our enemy script:</p>
			<ol>
				<li value="1">In the <code>Assets/Scripts</code> folder with the filename <code>EnemyWave</code>. </li>
				<li>Open the script and check/enter the following required library code at the top of the script:<pre><strong class="bold">using UnityEngine;</strong></pre></li>
			</ol>
			<p>Like the majority of our classes, we require the <code>UnityEngine</code> library.</p>
			<ol>
				<li value="3">Check and enter the class name and its inheritance:<pre><strong class="bold">public class EnemyWave : MonoBehaviour, IActorTemplate</strong>
<strong class="bold">     {</strong></pre></li>
			</ol>
			<p>We have a <code>public class</code> named <code>EnemyWave</code> that inherits <code>MonoBehaviour</code> by default but also adds our <code>IActorTemplate</code> interface.</p>
			<ol>
				<li value="4">Within the <code>EnemyWave</code> class, enter<a id="_idIndexMarker268"/> the following global variables:<pre> int health;
      int travelSpeed;
      int fireSpeed;
      int hitPower;
      
      //wave enemy
      [SerializeField]
      float verticalSpeed = 2;
      [SerializeField]
      float verticalAmplitude = 1;
      Vector3 sineVer;
      float time;</pre></li>
			</ol>
			<p>The global variables for the <code>EnemyWave</code> class are the top four variables updated with values from its <code>ScriptableObject</code> asset. The other variables are specific to the enemy, and we have given two of these variables <code>SerializeField</code> attributes for debugging purposes in the <strong class="bold">Inspector</strong> window. </p>
			<ol>
				<li value="5">Add Unity's <code>Update</code> function along with its content:<pre>void Update ()
      {
          Attack();
      }</pre></li>
			</ol>
			<p>After the global variables, we add an <code>Update</code> function containing an <code>Attack</code> method.</p>
			<ol>
				<li value="6">Add our <code>ScriptableObject</code> method, <code>ActorStats</code>, and its content:<pre>public void ActorStats(SOActorModel actorModel)
      {
          health = actorModel.health;
          travelSpeed = actorModel.speed;
          hitPower = actorModel.hitPower;
      }</pre></li>
			</ol>
			<p>We have <a id="_idIndexMarker269"/>our <code>ActorStats</code> method that takes in a <code>ScriptableObject</code> <code>SOActorModel</code>. This <code>ScriptableObject</code> then applies the variable values it holds and applies them to the <code>EnemyWave</code> script's variables.</p>
			<ol>
				<li value="7">Still in the <code>EnemyWave</code> script, add the <code>Die</code> method along with its content:<pre>public void Die()
      {
          Destroy(this.gameObject);
      }</pre></li>
			</ol>
			<p>Another familiar method if you have been following along is the <code>Die</code> method, which is called when the enemy has been destroyed by the player. </p>
			<ol>
				<li value="8">Add Unity's <code>OnTriggerEnter</code> function to the <code>EnemyWave</code> script:<pre>void OnTriggerEnter(Collider other)
      {
        // if the player or their bullet hits you.
        if (other.tag == "Player")
        {
           if (health &gt;= 1)
           {
              health -= other.GetComponent&lt;IActorTemplate&gt;
                ().SendDamage();
           }
           if (health &lt;= 0)
           {
              Die();
           }
         }
       }
      </pre></li>
			</ol>
			<p>Unity's own <code>OnTriggerEnter</code> function will check to see whether they have collided with <a id="_idIndexMarker270"/>the player and, if so, will send damage, and the enemy will destroy themselves with the <code>Die</code> method.</p>
			<ol>
				<li value="9">Continue and enter the <code>TakeDamage</code> and <code>SendDamage</code> methods:<pre>public void TakeDamage(int incomingDamage)
      {
        health -= incomingDamage;
      }
      public int SendDamage()
      {
        return hitPower;
      }</pre></li>
			</ol>
			<p>Another common set of methods from the <code>IActorTemplate</code> interface is to send and receive damage from the <code>EnemyWave</code> script.</p>
			<p>Next is the <code>Attack</code> method, which controls the movement/attack of the enemy. This method is called in the <code>Update</code> function on every frame.</p>
			<p>With this attack, we will make the enemy move from right to left in a wavy animation (like a snake) instead of just going straight right to left. The following image shows our<a id="_idIndexMarker271"/> enemies moving from right to left in a wavy line:</p>
			<div><div><img src="img/Figure_2.51_B18381.jpg" alt="Figure 2.51 – The enemies' wave attack pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.50 – The enemies' wave attack pattern</p>
			<ol>
				<li value="10">Enter the following <code>Attack</code> method code into the <code>EnemyWave</code> script:<pre>public void Attack()
      {
        time += Time.deltaTime;
        sineVer.y = Mathf.Sin(time * verticalSpeed) *     verticalAmplitude;
        transform.position = new Vector3(transform.            position.x + travelSpeed * Time.deltaTime,
        transform.position.y + sineVer.y,
        transform.position.z);
      }}</pre></li>
			</ol>
			<p>The <code>Attack</code> method starts with <code>Time.deltaTime</code> being collected in a <code>float</code> variable labeled <code>time</code>. </p>
			<p>We then use a premade function from Unity that returns a sine (<a href="https://docs.unity3d.com/ScriptReference/Mathf.Sin.html">https://docs.unity3d.com/ScriptReference/Mathf.Sin.html</a>) using our <code>time</code> variable, multiplied by a set speed from the <code>verticalSpeed</code> variable, followed by the result being multiplied by <code>verticalAmplitude</code>.</p>
			<p>The end result is stored in the <code>Vector3</code> <em class="italic">y</em> axis. What this basically does is make our enemy ship move up and down. The <code>verticalSpeed</code> parameter sets its speed and <code>verticalAmplitude</code> alters how far it goes up and down.</p>
			<p>Then, we do a <a id="_idIndexMarker272"/>similar task to what we did with the <code>PlayerBullet</code> to make the enemy ship move along the <em class="italic">x</em> axis, and we also add a sine calculation to its <code>Y</code> position for it to move up and down.</p>
			<p>Make sure to save the script before we wind down this chapter.</p>
			<p>Before we summarize, click <strong class="bold">Play</strong> in the Editor, and hopefully, if all is well, you will have a player ship that you will be able to fly around within the boundaries of the <strong class="bold">Game</strong> window's aspect ratio; enemies will come floating into the screen and move from right to left; you will be able to destroy these enemies with your bullets. These enemies will also be able to destroy you if they make contact with you. Finally, our <strong class="bold">Hierarchy</strong> window is all neat and well-structured both before and after playing our game. The following screenshot shows what I have just explained: </p>
			<div><div><img src="img/Figure_2.52_B18381.jpg" alt="Figure 2.52 – The Game window with the current gameplay and the Hierarchy game object structured&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.51 – The Game window with the current gameplay and the Hierarchy game object structured</p>
			<p>You have done so much already! The good news is that you've just conquered one of the biggest chapters <a id="_idIndexMarker273"/>in the book – quite sneaky of me, I know. But we already have the backbone of our game, and most importantly, we've covered a good chunk of the Unity Programmer exam.</p>
			<p>Understandably, you may have come across some possible issues on the way, and you may feel stuck. Don't worry if this is the case – check the <code>Complete</code> folder for this chapter to load up the Unity project and compare the code in that folder with your own to double-check. Make sure you have the right game objects in your scene, check that the right game objects are tagged, check the radius size of your <strong class="bold">Sphere</strong> colliders, and if you have any errors or warnings appear in the <strong class="bold">Console</strong> window, double-click them, and they will<a id="_idIndexMarker274"/> take you to the code that's causing the issue.</p>
			<p>Let's wrap up this chapter and talk about our game so far.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>Summary</h1>
			<p>We have reached the end of this chapter, and we have conquered the majority of our game framework, as we can see in the following diagram:</p>
			<div><div><img src="img/Figure_2.53_B18381.jpg" alt="Figure 2.53 – Killer Wave UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.52 – Killer Wave UML</p>
			<p>We have created a game framework that would need only a few changes whether we added 1 or 1,000 more enemies to our game. Some of the benefits of this use of reusable code and <code>ScriptableObject</code> is that it will benefit non-programmers, save time, and prevent collaborators from being bogged down in the code.</p>
			<p>We have also made it possible that if and when we want to add more <code>EnemySpawner</code> points, we can drag and drop more prefabs into our scene and update its <code>ScriptableObject</code> to change the enemy without coding in exact <code>Vector3</code> locations.</p>
			<p>We've covered other common Unity features, including instantiating game objects such as enemies and player bullets. </p>
			<p>In the next chapter, we will be covering the following scripts:</p>
			<ul>
				<li><code>ScoreManager</code>: When an enemy is destroyed, the player will receive a score.</li>
				<li><code>ScenesManager</code>: If the player dies, one life will be deducted; if the player loses all of their lives, the level will reset.</li>
				<li><code>Sounds</code>: Our ships and bullets will also have added sounds.</li>
			</ul>
			<p>Finally, we will be updating the overall structure of our code.</p>
		</div>
	</body></html>