- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Security and Identity in ASP.NET Core
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的安全和身份
- en: In [*Chapter 7*](B18971_07.xhtml#_idTextAnchor272), we discussed some more advanced
    topics of EF Core, such as `DbContext` pooling, performance optimization, and
    concurrency control. At this point, you should have the skills to create a web
    API application that accesses the database using EF Core. However, the application
    is not secure. Without any authentication, anyone who knows the URL can access
    the API, potentially exposing sensitive data to the public. To ensure the security
    of the web API application, we must take additional steps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 7 章*](B18971_07.xhtml#_idTextAnchor272)中，我们讨论了 EF Core 的更多高级主题，例如 `DbContext`
    缓存、性能优化和并发控制。到这一点，你应该已经具备创建使用 EF Core 访问数据库的 Web API 应用程序所需的技能。然而，该应用程序并不安全。在没有任何身份验证的情况下，任何知道
    URL 的人都可以访问 API，可能会将敏感数据暴露给公众。为了确保 Web API 应用程序的安全性，我们必须采取额外的步骤。
- en: 'Security is a broad topic, and it is a crucial aspect of any application. In
    this chapter, we will explore some of the security features that ASP.NET Core
    provides, including authentication, authorization, and some best practices for
    securing your web API application. We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个广泛的话题，它是任何应用程序的关键方面。在本章中，我们将探讨 ASP.NET Core 提供的一些安全功能，包括身份验证、授权以及保护您的 Web
    API 应用程序的最佳实践。我们将涵盖以下主题：
- en: Getting started with authentication and authorization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用身份验证和授权
- en: Delving deeper into authorization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解授权
- en: Managing users and roles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户和角色
- en: New Identity API endpoints in ASP.NET Core 8
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 8 中的新身份验证 API 端点
- en: Understanding OAuth 2.0 and OpenID Connect
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 OAuth 2.0 和 OpenID Connect
- en: Other security topics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他安全主题
- en: After reading this chapter, you will have a basic understanding of the security
    features in ASP.NET Core. You will also know how to implement authentication and
    various authorization types in your web API applications, such as role-based authorization,
    claim-based authorization, and policy-based authorization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你将基本了解 ASP.NET Core 中的安全功能。你还将了解如何在 Web API 应用程序中实现身份验证和不同的授权类型，例如基于角色的授权、基于声明的授权和基于策略的授权。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8).
    You can use VS Code or VS 2022 to open the solutions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在 [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8)
    找到。您可以使用 VS Code 或 VS 2022 打开解决方案。
- en: Getting started with authentication and authorization
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用身份验证和授权
- en: Authentication and authorization are two important aspects of security. Although
    these two terms are often used together, they are distinct concepts. Before we
    dive into the code, it is important to gain an understanding of the differences
    between authentication and authorization.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权是安全性的两个重要方面。尽管这两个术语经常一起使用，但它们是不同的概念。在我们深入代码之前，了解身份验证和授权之间的区别非常重要。
- en: We have already built some web API applications. However, these APIs will be
    publicly available to anyone who knows the URL. For some resources, we want to
    restrict access to only authenticated users. For example, we have a resource that
    contains some sensitive information that should not be available to everyone.
    In this case, the application should be able to identify the user who is making
    the request. If the user is anonymous, the application should not allow the user
    to access the resource. This is where authentication comes into play.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一些 Web API 应用程序。然而，这些 API 将对任何知道 URL 的人公开。对于某些资源，我们希望仅允许认证用户访问。例如，我们有一个包含一些敏感信息的资源，这些信息不应向每个人开放。在这种情况下，应用程序应该能够识别发起请求的用户。如果用户是匿名的，应用程序不应允许用户访问资源。这就是身份验证发挥作用的地方。
- en: For some scenarios, we also want to restrict access to some specific users.
    For example, we want to allow authenticated users to read the resource, but only
    admin users to update or delete the resource. In this case, the application should
    be able to check whether the user has the required permissions to execute the
    operation. This is where authorization is used.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些场景，我们还想限制某些特定用户对某些资源的访问。例如，我们希望允许认证用户读取资源，但只有管理员用户可以更新或删除资源。在这种情况下，应用程序应该能够检查用户是否具有执行操作所需的权限。这就是授权发挥作用的地方。
- en: Long story short, authentication is used to know who the user is, while authorization
    is used to know what the user can do. Together, these processes are used to ensure
    that the user is who they claim to be and that they have the required permissions
    to access the resource.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，身份验证用于了解用户是谁，而授权用于了解用户可以做什么。这两个过程共同用于确保用户是他们所声称的人，并且他们有权访问资源。
- en: ASP.NET Core provides the Identity framework, which has a rich set of features
    for authentication and authorization. In this chapter, we will explore how to
    use the Identity framework to implement authentication and authorization in ASP.NET
    Core. We will also introduce some third-party authentication providers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了Identity框架，该框架具有丰富的身份验证和授权功能。在本章中，我们将探讨如何使用Identity框架在ASP.NET
    Core中实现身份验证和授权。我们还将介绍一些第三方身份验证提供者。
- en: Think about a scenario where we want to build a web API application that allows
    users to register and log in. For a specific endpoint, we only want to allow authenticated
    users to access the resource. In this section, we will explore how to implement
    this scenario. From this example, you will learn how to implement a basic authentication
    and authorization system in ASP.NET Core; this will help you prepare for the next
    section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样一个场景：我们想要构建一个允许用户注册和登录的Web API应用程序。对于特定的端点，我们只想允许经过身份验证的用户访问资源。在本节中，我们将探讨如何实现这个场景。通过这个示例，你将学习如何在ASP.NET
    Core中实现基本的身份验证和授权系统；这将帮助你为下一节做准备。
- en: 'We will use the following resources in this example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将使用以下资源：
- en: '`POST /account/register`: This resource will be used to register a new user.
    The user should send the username and password in the request body. After validating
    the username and password, the application will create a new user in the database
    and return a JWT token to the user. This JWT token will be used to authenticate
    the user in subsequent requests.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /account/register`：此资源将用于注册新用户。用户应在请求体中发送用户名和密码。验证用户名和密码后，应用程序将在数据库中创建新用户并向用户返回JWT令牌。此JWT令牌将用于在后续请求中验证用户。'
- en: '`POST /account/login`: This resource will be used to log into an existing user.
    After the user sends the username and password, the application will validate
    the credentials and return a JWT token to the user if the credentials are valid.
    The JWT token will be used to authenticate the user in subsequent requests.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /account/login`：此资源将用于登录现有用户。用户发送用户名和密码后，应用程序将验证凭据，如果凭据有效，则向用户返回JWT令牌。JWT令牌将用于在后续请求中验证用户。'
- en: '`GET /WeatherForecast`: This resource will be used to get the weather forecast.
    It only allows authenticated users to access the resource. The user should send
    the JWT token in the Authorization header to authenticate the user.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /WeatherForecast`：此资源将用于获取天气预报。它只允许经过身份验证的用户访问资源。用户应在Authorization头中发送JWT令牌以进行用户身份验证。'
- en: There should be more endpoints to manage users, such as updating the user profile,
    deleting the user, resetting the password, and more. However, we are not building
    a complete application in this chapter. To keep things simple, we will only focus
    on the minimal features required to demonstrate the authentication and authorization
    features in ASP.NET Core.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有更多端点来管理用户，例如更新用户资料、删除用户、重置密码等。然而，我们在这个章节中不会构建一个完整的应用程序。为了保持简单，我们只会关注演示ASP.NET
    Core中身份验证和授权功能所需的最小特性。
- en: What is JWT?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是什么？
- en: 'JWT stands for *JSON Web Token*. It is an industry standard for representing
    claims securely between two parties. The RFC for JWT is RFC 7519: [https://www.rfc-editor.org/rfc/rfc7519](https://www.rfc-editor.org/rfc/rfc7519).
    A JWT token consists of three parts: header, payload, and signature. So, typically,
    a JWT token looks like `xxxxx.yyyyy.zzzzz`. The header contains the algorithm
    used to sign the token, the payload contains the claims, and the signature is
    used to verify the integrity of the token. For more information about JWT, see
    [https://jwt.io/introduction](https://jwt.io/introduction).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JWT代表*JSON Web Token*。它是在两个当事人之间安全表示声明的行业标准。JWT的RFC是RFC 7519：[https://www.rfc-editor.org/rfc/rfc7519](https://www.rfc-editor.org/rfc/rfc7519)。JWT令牌由三部分组成：头部、负载和签名。因此，典型的JWT令牌看起来像`xxxxx.yyyyy.zzzzz`。头部包含用于签名令牌的算法，负载包含声明，签名用于验证令牌的完整性。有关JWT的更多信息，请参阅[https://jwt.io/introduction](https://jwt.io/introduction)。
- en: Creating a sample project with authentication and authorization
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建具有身份验证和授权的示例项目
- en: 'To begin, we must prepare the project and add any necessary NuGet packages.
    Additionally, we need to configure the database context to enable us to store
    user information in the database. Follow these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须准备项目并添加任何必要的 NuGet 包。此外，我们需要配置数据库上下文，以便我们能够在数据库中存储用户信息。按照以下步骤操作：
- en: 'Create a new ASP.NET Core web API project by running the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个新的 ASP.NET Core Web API 项目：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, it’s time to add the required NuGet packages. We will use ASP.NET Core
    Identity to implement the authentication. ASP.NET Core Identity is a membership
    system that provides authentication and authorization features. It is a part of
    the ASP.NET Core framework. We need to install the following NuGet packages:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候添加所需的 NuGet 包了。我们将使用 ASP.NET Core Identity 来实现身份验证。ASP.NET Core Identity
    是一个提供身份验证和授权功能的成员系统。它是 ASP.NET Core 框架的一部分。我们需要安装以下 NuGet 包：
- en: '`Microsoft.AspNetCore.Identity.EntityFrameworkCore`: This package is used for
    the EF Core implementation of ASP.NET Core Identity.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Identity.EntityFrameworkCore`: 此包用于 ASP.NET Core Identity
    的 EF Core 实现。'
- en: '`Microsoft.EntityFrameworkCore.SqlServer`: This package is used to connect
    to SQL Server.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.SqlServer`: 此包用于连接到 SQL Server。'
- en: '`Microsoft.EntityFrameworkCore.Tools`: This package is used to enable the necessary
    EF Core tools.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.Tools`: 此包用于启用必要的 EF Core 工具。'
- en: '`Microsoft.AspNetCore.Authentication.JwtBearer`: This package is used to enable
    JWT authentication.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Authentication.JwtBearer`: 此包用于启用 JWT 身份验证。'
- en: The ASP.NET Core Identity package already comes with the default project template,
    so we do not need to install it.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity 包已经包含在默认项目模板中，因此我们不需要安装它。
- en: 'Next, we will add the database context. We will use EF Core to access the database.
    But first, we need an entity model to represent the user. Create a new folder
    named `Authentication` and add a new class named `AppUser` to it. The `AppUser`
    class inherits from the `IdentityUser` class, which is provided by ASP.NET Core
    Identity, as shown in the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加数据库上下文。我们将使用 EF Core 来访问数据库。但首先，我们需要一个实体模型来表示用户。创建一个名为 `Authentication`
    的新文件夹，并向其中添加一个名为 `AppUser` 的新类。`AppUser` 类继承自 ASP.NET Core Identity 提供的 `IdentityUser`
    类，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `IdentityUser` class already contains the properties that we need to represent
    a user for most of the scenarios, such as `UserName`, `Email`, `PasswordHash`,
    `PhoneNumber`, and others.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IdentityUser` 类已经包含了我们在大多数场景中表示用户所需的属性，例如 `UserName`、`Email`、`PasswordHash`、`PhoneNumber`
    等。'
- en: 'Next, we need to create a database context to access the database. Add a new
    class named `AppDbContext` to the `Authentication` folder. The `AppDbContext`
    class inherits from the `IdentityDbContext` class, which is provided by ASP.NET
    Core Identity, as shown in the following code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个数据库上下文来访问数据库。在 `Authentication` 文件夹中添加一个名为 `AppDbContext` 的新类。`AppDbContext`
    类继承自 ASP.NET Core Identity 提供的 `IdentityDbContext` 类，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, this `AppDbContext` is purely for ASP.NET Core Identity. If you
    have other entities in your application, you can create a separate `DbContext`
    for them if you want to. You can use the same connection string for both `DbContexts`.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，这个 `AppDbContext` 完全是为 ASP.NET Core Identity 而设计的。如果你的应用程序中还有其他实体，你可以为它们创建一个单独的
    `DbContext`。你可以为这两个 `DbContext` 使用相同的连接字符串。
- en: Next, we will need to create a few models for registering and logging in users
    because, when we register a user, we need to send the username, password, and
    email address. When we log a user in, we need to send the username and password.
    It would be good if we had separate models for these different scenarios.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一些模型来注册和登录用户，因为当我们注册用户时，我们需要发送用户名、密码和电子邮件地址。当我们登录用户时，我们需要发送用户名和密码。如果为这些不同场景创建单独的模型会更好。
- en: 'Create a new class named `AddOrUpdateAppUserModel` in the `Authentication`
    folder. This class will be used to represent the user when we register a new user.
    The `AddOrUpdateAppUserModel` class should contain the following properties:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Authentication` 文件夹中创建一个名为 `AddOrUpdateAppUserModel` 的新类。此类将用于在注册新用户时表示用户。`AddOrUpdateAppUserModel`
    类应包含以下属性：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similarly, create a new class named `LoginModel` in the `Authentication` folder,
    as shown in the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在 `Authentication` 文件夹中创建一个名为 `LoginModel` 的新类，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you add additional properties to the `AppUser` class, you need to add the
    corresponding properties for the `AddOrUpdateAppUserModel` as well.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您向 `AppUser` 类添加了额外的属性，您还需要为 `AddOrUpdateAppUserModel` 添加相应的属性。
- en: 'Next, we need to configure the authentication service. First, let’s update
    the `appsettings.json` file to provide the configurations for JWT tokens:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置身份验证服务。首先，让我们更新 `appsettings.json` 文件以提供 JWT 令牌的配置：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Update the configurations as per your requirements. Because we use the same
    web API to issue and validate the JWT token, we use the same URL for the `ValidAudiences`
    and `ValidIssuer` properties. The `Secret` property is used to sign the JWT token.
    You can use any string as the secret. In this case, we can use a GUID value. Also,
    please note that this is for demo purposes only. In a real-world application,
    you should store the secret in a secure location, such as Azure Key Vault.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据您的需求更新配置。因为我们使用相同的 Web API 来颁发和验证 JWT 令牌，所以我们使用相同的 URL 作为 `ValidAudiences`
    和 `ValidIssuer` 属性。`Secret` 属性用于签名 JWT 令牌。您可以使用任何字符串作为密钥。在这种情况下，我们可以使用一个 GUID
    值。请注意，这只是为了演示目的。在实际应用程序中，您应该将密钥存储在安全的位置，例如 Azure Key Vault。
- en: 'Update the code in the `Program.cs` file, as shown in the following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示更新 `Program.cs` 文件中的代码：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we configured the authentication service to use JWT tokens.
    The `AddIdentityCore()` method adds and configures the identity system for the
    specified `User` type. We also added `AppDbContext` and `AppUser` to the service
    collection and specified that we want to use EF Core to store the user data. The
    `AddDefaultTokenProviders()` method adds the default token providers for the application,
    which are used to generate tokens. The `Services.AddAuthentication()` method configures
    the authentication service to use JWT tokens. The `AddJwtBearer()` method configures
    the JWT bearer authentication handler, including the token validation parameters.
    We use some configurations from the `appsettings.json` file to configure the token
    validation parameters.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们配置了身份验证服务以使用 JWT 令牌。`AddIdentityCore()` 方法为指定的 `User` 类型添加并配置了身份系统。我们还向服务集合中添加了
    `AppDbContext` 和 `AppUser`，并指定我们想要使用 EF Core 来存储用户数据。`AddDefaultTokenProviders()`
    方法为应用程序添加了默认的令牌提供者，这些提供者用于生成令牌。`Services.AddAuthentication()` 方法配置了身份验证服务以使用 JWT
    令牌。`AddJwtBearer()` 方法配置了 JWT 携带者身份验证处理程序，包括令牌验证参数。我们使用 `appsettings.json` 文件中的某些配置来配置令牌验证参数。
- en: Finally, we need to call the `UseAuthentication()` and `UseAuthorization()`
    methods to enable authentication and authorization in the application.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们需要调用 `UseAuthentication()` 和 `UseAuthorization()` 方法来在应用程序中启用身份验证和授权。
- en: 'Now, it’s time to create and update the database. We have already created the
    database context and the user entity. So, now, we need to create the database.
    To do that, just run the following command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候创建和更新数据库了。我们已经创建了数据库上下文和用户实体。因此，现在我们需要创建数据库。为此，只需运行以下命令：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the commands are executed successfully, you should see the database created
    with the following tables:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果命令执行成功，您应该看到以下表创建的数据库：
- en: '![Figure 8.1 – The database tables created by ASP.NET Core Identity](img/B18971_08_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 由 ASP.NET Core Identity 创建的数据库表](img/B18971_08_01.jpg)'
- en: Figure 8.1 – The database tables created by ASP.NET Core Identity
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 由 ASP.NET Core Identity 创建的数据库表
- en: 'Another way to check whether the database has been created is to add the following
    code to the `Program.cs` file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种检查数据库是否已创建的方法是将以下代码添加到 `Program.cs` 文件中：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can use either of the methods to check whether the database is created in
    the development environment.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用这两种方法中的任何一种来检查数据库是否在开发环境中创建。
- en: The data for the users will be stored in these tables, which is convenient when
    using the default tables provided by ASP.NET Core Identity.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户数据将存储在这些表中，当使用 ASP.NET Core Identity 提供的默认表时，这很方便。
- en: 'Next, let’s apply the `Authorize` attribute to enable authentication and authorization
    for `WeatherForecastController`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将 `Authorize` 属性应用于 `WeatherForecastController` 以启用身份验证和授权：
- en: 'Update `WeatherForecastController` by adding an `[Authorize]` attribute, as
    shown in the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加 `[Authorize]` 属性来更新 `WeatherForecastController`，如下所示：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This attribute will ensure that the user is authenticated before accessing
    the controller. If the user is not authenticated, the controller will return a
    `401 Unauthorized` response. Test this by running the application and calling
    the `/WeatherForecast` endpoint. You should see a `401` response:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此属性将确保在访问控制器之前用户已认证。如果用户未认证，则控制器将返回 `401 未授权` 响应。通过运行应用程序并调用 `/WeatherForecast`
    端点来测试此功能。您应该看到一个 `401` 响应：
- en: '![Figure 8.2 – When the user is not authenticated, the controller returns a
    401 response](img/B18971_08_02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 当用户未认证时，控制器返回 401 响应](img/B18971_08_02.jpg)'
- en: Figure 8.2 – When the user is not authenticated, the controller returns a 401
    response
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 当用户未认证时，控制器返回 401 响应
- en: The `Authorize` attribute can be applied to the controller or the action method.
    If the attribute is applied to the controller, all the action methods in the controller
    will be protected. If the attribute is applied to the action method, only that
    action method will be protected.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorize` 属性可以应用于控制器或操作方法。如果属性应用于控制器，则控制器中的所有操作方法都将受到保护。如果属性应用于操作方法，则只有该操作方法将受到保护。'
- en: You can also use the `AllowAnonymous` attribute to allow anonymous access to
    the controller or action method. Note that the `AllowAnonymous` attribute overrides
    the `Authorize` attribute. So, if you apply both attributes to the controller
    or action method, the `AllowAnonymous` attribute will take precedence, which means
    that the controller or action method will be accessible to all the users.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `AllowAnonymous` 属性来允许控制器或操作方法进行匿名访问。请注意，`AllowAnonymous` 属性会覆盖 `Authorize`
    属性。因此，如果您将这两个属性都应用于控制器或操作方法，`AllowAnonymous` 属性将具有优先权，这意味着控制器或操作方法将对所有用户开放。
- en: Next, let’s add `AccountController` to handle the authentication requests. For
    example, we need to provide a `/account/register` endpoint. When the user sends
    the username and password, the application will create a record of the user in
    the database and generate a JWT token.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加 `AccountController` 来处理认证请求。例如，我们需要提供一个 `/account/register` 端点。当用户发送用户名和密码时，应用程序将在数据库中创建用户的记录并生成
    JWT 令牌。
- en: 'To generate a JWT token, we need to provide the following information:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要生成 JWT 令牌，我们需要提供以下信息：
- en: '`appsettings.json` file as described in the previous steps.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.json` 文件，如前所述。'
- en: 'Next, create a new controller named `AccountController` to handle the authentication
    requests. Create a new class named `AccountController` in the `Controllers` folder.
    The `AccountController` class should inherit from the `ControllerBase` class,
    as shown in the following code:'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的控制器名为 `AccountController` 来处理认证请求。在 `Controllers` 文件夹中创建一个新的类名为 `AccountController`。`AccountController`
    类应继承自 `ControllerBase` 类，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We use the `UserManager` class to manage the users. The `UserManager` class
    is provided by ASP.NET Core Identity. We also need to inject the `IConfiguration`
    interface to get the configuration values from the `appsettings.json` file.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `UserManager` 类来管理用户。`UserManager` 类由 ASP.NET Core Identity 提供。我们还需要注入
    `IConfiguration` 接口以从 `appsettings.json` 文件中获取配置值。
- en: 'Create a new method named `Register()` in the `AccountController` class. This
    method will be used to register a new user. The `Register()` method should accept
    an `AddOrUpdateAppUserModel` object as a parameter, as shown in the following
    code:'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `AccountController` 类中创建一个名为 `Register()` 的新方法。此方法将用于注册新用户。`Register()` 方法应接受一个
    `AddOrUpdateAppUserModel` 对象作为参数，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we are using the `JwtSecurityTokenHandler` class to generate
    the JWT token. The `JwtSecurityTokenHandler` class is provided by the `System.IdentityModel.Tokens.Jwt`
    NuGet package. First, we get the configuration values from the `appsettings.json`
    file. Then, we create a `SymmetricSecurityKey` object using the secret key. The
    `SymmetricSecurityKey` object is used to sign the token.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `JwtSecurityTokenHandler` 类来生成 JWT 令牌。`JwtSecurityTokenHandler`
    类由 `System.IdentityModel.Tokens.Jwt` NuGet 包提供。首先，我们从 `appsettings.json` 文件中获取配置值。然后，我们使用密钥创建一个
    `SymmetricSecurityKey` 对象。`SymmetricSecurityKey` 对象用于签名令牌。
- en: 'Next, we created a `SecurityTokenDescriptor` object, which contains the following
    properties:'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个 `SecurityTokenDescriptor` 对象，它包含以下属性：
- en: '`Subject`: The subject of the token. The subject can be any value, such as
    the username, email address, and so on.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subject`：令牌的主题。主题可以是任何值，例如用户名、电子邮件地址等。'
- en: '`Expires`: The expiration date of the token.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Expires`：令牌的过期日期。'
- en: '`Issuer`: The issuer of the token.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Issuer`：令牌的发行者。'
- en: '`Audience`: The audience of the token.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Audience`：令牌的受众。'
- en: '`SigningCredentials`: The credentials to sign the token. Note that we use the
    `HmacSha256Signature` algorithm to sign the token. It is a 256-bit HMAC cryptographic
    algorithm for digital signatures. If you encounter an error such as `IDX10603:
    The algorithm: ''HS256'' requires the SecurityKey.KeySize to be greater than ''128''
    bits.`, please check the secret key in the `appsettings.json` file. The secret
    key should be at least 16 characters long (16 * 8 = 128).'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SigningCredentials`：用于签名令牌的凭据。注意，我们使用 `HmacSha256Signature` 算法来签名令牌。这是一个用于数字签名的
    256 位 HMAC 密码学算法。如果你遇到类似 `IDX10603: The algorithm: ''HS256'' requires the SecurityKey.KeySize
    to be greater than ''128'' bits.` 的错误，请检查 `appsettings.json` 文件中的密钥。密钥长度应至少为 16
    个字符（16 * 8 = 128）。'
- en: Finally, we used the `JwtSecurityTokenHandler` class to create and write the
    token to a string value.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们使用了 `JwtSecurityTokenHandler` 类来创建并将令牌写入字符串值。
- en: 'Now, we can test the `Register()` method. Use `dotnet run` to run the application.
    You can use the Swagger UI or any other tools to test the API. Send a `POST` request
    with the following JSON data to the `http://localhost:5056/account/register` endpoint:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以测试 `Register()` 方法。使用 `dotnet run` 运行应用程序。你可以使用 Swagger UI 或其他任何工具来测试
    API。向 `http://localhost:5056/account/register` 端点发送以下 JSON 数据的 `POST` 请求：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see the response similar to the following:'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到以下类似的响应：
- en: '![Figure 8.3 – Registering a new user](img/B18971_08_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 注册新用户](img/B18971_08_03.jpg)'
- en: Figure 8.3 – Registering a new user
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 注册新用户
- en: 'As we can see, the `Register()` method returns a JWT token. The token is valid
    for 1 day. We can use this token to authenticate the user in the future. If you
    check the database, you will see that a new user has been created in the `AspNetUsers`
    table, and the password is hashed, as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Register()` 方法返回一个 JWT 令牌。该令牌有效期为 1 天。我们可以使用此令牌在未来对用户进行身份验证。如果你检查数据库，你将看到在
    `AspNetUsers` 表中已创建新用户，密码已散列，如下面的截图所示：
- en: '![Figure 8.4 – The new user has been created in the database](img/B18971_08_04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 新用户已在数据库中创建](img/B18971_08_04.jpg)'
- en: Figure 8.4 – The new user has been created in the database
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 新用户已在数据库中创建
- en: 'Copy the token value and send a `GET` request to the `/WeatherForecast` endpoint.
    You need to attach the `Bearer` token to the request header, as shown in the following
    screenshot:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制令牌值并向 `/WeatherForecast` 端点发送 `GET` 请求。你需要将 `Bearer` 令牌附加到请求头中，如下面的截图所示：
- en: '![Figure 8.5 – Sending a request with the Bearer token](img/B18971_08_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 使用 Bearer 令牌发送请求](img/B18971_08_05.jpg)'
- en: Figure 8.5 – Sending a request with the Bearer token
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 使用 Bearer 令牌发送请求
- en: Important note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When you attach the bearer token to the request, please note that there is a
    prefix of `Bearer` before the token value. So, the actual format should be
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 Bearer 令牌附加到请求时，请注意令牌值之前有一个 `Bearer` 前缀。因此，实际格式应该是
- en: '`Authorization:` `Bearer <token>`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorization:` `Bearer <token>`。'
- en: 'OK, it works! Your API is now secured. The next step is to create a login method
    to authenticate the user. It is quite straightforward. Create a new method named
    `Login` in the `AccountController` class. The `Login()` method should accept an
    `AddOrUpdateAppUserModel` object as a parameter, as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它工作了！你的 API 现在已经安全。下一步是创建一个登录方法来对用户进行身份验证。这相当直接。在 `AccountController` 类中创建一个名为
    `Login` 的新方法。`Login()` 方法应该接受一个 `AddOrUpdateAppUserModel` 对象作为参数，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `UserManager` class to find the user by the username. If the user
    is found, we use the `CheckPasswordAsync()` method to check the password. If the
    password is correct, we generate a new token and return it to the client. If the
    user is not found or the password is incorrect, we return an error message to
    the client.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `UserManager` 类通过用户名查找用户。如果找到用户，我们使用 `CheckPasswordAsync()` 方法来检查密码。如果密码正确，我们生成一个新的令牌并将其返回给客户端。如果未找到用户或密码不正确，我们向客户端返回错误消息。
- en: So far, we have created a web API project with basic authentication and authorization.
    We also created a controller to handle account-related operations. Note that in
    this example, we have not implemented any specific authorization rules. All authenticated
    users can access the `WeatherForecast` endpoint.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个具有基本身份验证和授权的 Web API 项目。我们还创建了一个控制器来处理与账户相关的操作。注意，在这个例子中，我们没有实现任何特定的授权规则。所有经过身份验证的用户都可以访问
    `WeatherForecast` 端点。
- en: Next, we will discuss the details of the JWT token.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 JWT 令牌的详细信息。
- en: Understanding the JWT token structure
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 JWT 令牌结构
- en: 'A JWT token is a string value. It is composed of three parts, separated by
    a dot (`.`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 令牌是一个字符串值。它由三部分组成，由点（`.`）分隔：
- en: Header
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部
- en: Payload
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效载荷
- en: Signature
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名
- en: 'The header and payload are encoded using the `Base64Url` algorithm. We can
    use `jwt.io` to decode the token. Copy the token in the response body and paste
    it into the `Encoded` field on the `jwt.io` website. You will see the decoded
    token, as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 头部和有效载荷使用 `Base64Url` 算法进行编码。我们可以使用 `jwt.io` 来解码令牌。将响应体中的令牌复制并粘贴到 `jwt.io` 网站上的
    `Encoded` 字段。您将看到解码后的令牌，如下面的截图所示：
- en: '![Figure 8.6 – Decoding the JWT token](img/B18971_08_06.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 解码 JWT 令牌](img/B18971_08_06.jpg)'
- en: Figure 8.6 – Decoding the JWT token
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 解码 JWT 令牌
- en: 'The header contains the algorithm used to sign the token. In our case, we use
    the `HmacSha256Signature` algorithm. So, the decoded header is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 头部包含用于签名令牌的算法。在我们的案例中，我们使用 `HmacSha256Signature` 算法。因此，解码后的头部如下所示：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The payload contains the claims of the token and some other additional data.
    In our case, the decoded payload is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷包含令牌的声明和一些其他附加数据。在我们的案例中，解码后的有效载荷如下所示：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are some recommended (but not mandatory) registered claim names defined
    in RFC7519:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RFC7519 中定义了一些推荐（但不是强制性的）已注册的声明名称：
- en: '`sub`: The `sub` (subject) claim identifies the principal that is the subject
    of the token'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub`: `sub`（主题）声明标识了令牌的主题主体'
- en: '`nbf`: The `nbf` (not before) claim identifies the time before which the token
    *must not* be accepted for processing'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nbf`: `nbf`（不可用之前）声明标识了令牌必须不被接受处理的之前的时间'
- en: '`exp`: The `exp` (expiration time) claim identifies the expiration time on
    or after which the token *must not* be accepted for processing'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp`: `exp`（过期时间）声明标识了令牌必须不被接受处理的过期时间或之后的时间'
- en: '`iat`: The `iat` (issued at) claim identifies the time at which the token was
    issued'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`: `iat`（发行时间）声明标识了令牌被发行的时间'
- en: '`iss`: The `iss` (issuer) claim identifies the principal that issued the token'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`: `iss`（发行者）声明标识了发行令牌的主体'
- en: '`aud`: The `aud` (audience) claim identifies the recipients that the token
    is intended for'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aud`: `aud`（受众）声明标识了令牌旨在为其提供的接收者'
- en: Note that in our case, we use the same value for the `iss` and `aud` claims
    because we use the same web API to issue and validate the token. In a real-world
    application, normally, there is a separate authentication server to issue the
    token so that the `iss` and `aud` claims have different values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的案例中，我们使用相同的值用于 `iss` 和 `aud` 声明，因为我们使用相同的 Web API 发行和验证令牌。在实际应用中，通常有一个单独的认证服务器来发行令牌，这样
    `iss` 和 `aud` 声明就有不同的值。
- en: 'The signature is used to verify the token to make sure the token does not tamper.
    There are various algorithms to generate the signature. In our case, we use the
    `HmacSha256Signature` algorithm, so the signature is generated using the following
    formula:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 签名用于验证令牌，以确保令牌未被篡改。有各种算法可以生成签名。在我们的案例中，我们使用 `HmacSha256Signature` 算法，因此签名是使用以下公式生成的：
- en: '`HMACSHA256(base64UrlEncode(header) + "." +` `base64UrlEncode(payload), secret)`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`'
- en: Therefore, the token typically looks like `xxxxx.yyyyy.zzzzz`, which can be
    easily passed in the HTTP request header, or stored in the local storage of the
    browser.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，令牌通常看起来像 `xxxxx.yyyyy.zzzzz`，可以轻松地通过 HTTP 请求头传递，或者存储在浏览器的本地存储中。
- en: Consuming the API
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费 API
- en: 'At this point, we have a secured API. You can find a sample client application
    named `AuthenticationDemoClient` in the `samples\chapter8\AuthenticationDemo\BasicAuthenticationDemo\end`
    folder. The client application is a simple console application. It uses the `HttpClient`
    class to send HTTP requests to the API. The main code is like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个安全的 API。您可以在 `samples\chapter8\AuthenticationDemo\BasicAuthenticationDemo\end`
    文件夹中找到一个名为 `AuthenticationDemoClient` 的示例客户端应用程序。客户端应用程序是一个简单的控制台应用程序。它使用 `HttpClient`
    类向 API 发送 HTTP 请求。主要代码如下：
- en: 'Login:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 登录：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Get weather forecast:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 获取天气预报：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, the client application sends a request to the login API to get the token.
    Then, it attaches the token to the request header and sends the request to the
    weather forecast API. If the token is valid, the API will return the data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，客户端应用程序向登录 API 发送请求以获取令牌。然后，它将令牌附加到请求头并发送请求到天气预报 API。如果令牌有效，API 将返回数据。
- en: Configuring the Swagger UI to support authorization
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Swagger UI 以支持授权
- en: 'You probably prefer to use the Swagger UI to test the APIs. The default configuration
    of the Swagger UI does not support authorization. We need to update the `AddSwaggerGen()`
    method in the `Program` class to support authorization. Update the `Program` class
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更喜欢使用 Swagger UI 来测试 API。Swagger UI 的默认配置不支持授权。我们需要更新 `Program` 类中的 `AddSwaggerGen()`
    方法以支持授权。更新 `Program` 类如下：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code adds the `Bearer` security definition to the Swagger UI.
    The `AddSecurityRequirement` method adds the `Authorization` header to the Swagger
    UI. Now, when you run the application, you will see the **Authorize** button in
    the Swagger UI. Click the **Authorize** button; you will see a pop-up window that
    allows you to enter the token, as shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码向 Swagger UI 添加了 `Bearer` 安全定义。`AddSecurityRequirement` 方法向 Swagger UI
    添加了 `Authorization` 标头。现在，当你运行应用程序时，你将在 Swagger UI 中看到 **授权** 按钮。点击 **授权** 按钮；你将看到一个弹出窗口，允许你输入令牌，如图下所示：
- en: '![Figure 8.7 – Entering the token in the Swagger UI](img/B18971_08_07.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 在 Swagger UI 中输入令牌](img/B18971_08_07.jpg)'
- en: Figure 8.7 – Entering the token in the Swagger UI
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 在 Swagger UI 中输入令牌
- en: 'Enter the token in the **Value** field. Then, click the **Authorize** button.
    Now, you can test the APIs using the Swagger UI directly:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **值** 字段中输入令牌。然后，点击 **授权** 按钮。现在，你可以直接使用 Swagger UI 测试 API：
- en: Caution
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You need to add the `Bearer` prefix to the token with a space.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在令牌前添加 `Bearer` 前缀，并空一格。
- en: '![Figure 8.8 – The Swagger UI is authorized](img/B18971_08_08.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – Swagger UI 已授权](img/B18971_08_08.jpg)'
- en: Figure 8.8 – The Swagger UI is authorized
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – Swagger UI 已授权
- en: 'You can find more information about the configuration for the Swagger UI here:
    [https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到有关 Swagger UI 配置的更多信息：[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)。
- en: In this section, we discussed the implementation of a web API project that supports
    authentication and authorization, including the creation of a controller to handle
    the login request. Additionally, we explored how to generate a JWT token and validate
    it, as well as how to use a console application to access the project resource
    and how to configure the Swagger UI to test the APIs with authorization.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了支持身份验证和授权的 Web API 项目的实现，包括创建控制器来处理登录请求。此外，我们还探讨了如何生成 JWT 令牌并验证它，以及如何使用控制台应用程序访问项目资源以及如何配置
    Swagger UI 以授权测试 API。
- en: In the next section, we will learn more about authorization in ASP.NET Core.
    We will explore a couple of authorization types, including role-based authorization,
    claim-based authorization, and policy-based authorization.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习更多关于 ASP.NET Core 中的授权知识。我们将探讨几种授权类型，包括基于角色的授权、基于声明的授权和基于策略的授权。
- en: Delving deeper into authorization
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨授权
- en: Authorization is the process of determining whether a user is allowed to perform
    a specific action. In the previous section, we implemented a web API project that
    enables simple authentication and authorization. By using the `Authorize` attribute,
    only authenticated users can access the API. However, in many scenarios, we need
    to implement granular authorization. For example, some resources are only accessible
    to the administrator, while some resources are accessible to normal users. In
    this section, we will explore how to implement granular authorization in ASP.NET
    Core, including role-based authorization, claim-based authorization, and policy-based
    authorization.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是确定用户是否允许执行特定操作的过程。在上一节中，我们实现了一个支持简单身份验证和授权的 Web API 项目。通过使用 `Authorize` 属性，只有经过身份验证的用户才能访问
    API。然而，在许多场景中，我们需要实现细粒度授权。例如，某些资源仅对管理员可访问，而某些资源则对普通用户可访问。在本节中，我们将探讨如何在 ASP.NET
    Core 中实现细粒度授权，包括基于角色的授权、基于声明的授权和基于策略的授权。
- en: Role-based authorization
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的授权
- en: 'You can find the starter app and the completed app in this book’s GitHub repository
    at `chapter8/AuthorizationDemo/RoleBasedAuthorizationDemo`. The starter app is
    similar to the application we created in the previous section:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到入门应用程序和完成的应用程序，位于 `chapter8/AuthorizationDemo/RoleBasedAuthorizationDemo`。入门应用程序与我们之前章节中创建的应用程序类似：
- en: 'We’ll start with the starter app. Don’t forget to create the database and run
    the migrations using the following commands:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从入门级应用程序开始。别忘了创建数据库并使用以下命令运行迁移：
- en: '[PRE19]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: public static class AppRoles{    public const string Administrator = "Administrator";    public
    const string User = "User";    public const string VipUser = "VipUser";}
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static class AppRoles{    public const string Administrator = "Administrator";    public
    const string User = "User";    public const string VipUser = "VipUser";}
- en: '[PRE20]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `Program` class, we need to explicitly call the `AddRoles()` method
    after the `AddIdentityCore()` method. The updated code is as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类中，我们需要在 `AddIdentityCore()` 方法之后显式调用 `AddRoles()` 方法。更新的代码如下：
- en: '[PRE21]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you use the `AddIdentity()` method, you do not need to call the `AddRoles()`
    method. The `AddIdentity()` method will call the `AddRoles()` method internally.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您使用 `AddIdentity()` 方法，则不需要调用 `AddRoles()` 方法。`AddIdentity()` 方法将内部调用 `AddRoles()`
    方法。
- en: 'We also need to check whether the roles exist in the database. If not, we will
    create the roles. Add the code, as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要检查角色是否存在于数据库中。如果不存在，我们将创建角色。添加以下代码：
- en: '[PRE22]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use `dotnet run` to run the application. You will see that the roles are created
    in the database:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 运行应用程序。您将看到角色已创建在数据库中：
- en: '![Figure 8.9 – Roles in the database](img/B18971_08_09.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 数据库中的角色](img/B18971_08_09.jpg)'
- en: Figure 8.9 – Roles in the database
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 数据库中的角色
- en: 'In the `AccountController` class, we have a `Register()` method that is used
    to register a new user. Let’s update the `Register()` method to assign the `User`
    role to the new user. The updated code is as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AccountController` 类中，我们有一个 `Register()` 方法，用于注册新用户。让我们更新 `Register()` 方法，将
    `User` 角色分配给新用户。更新的代码如下：
- en: '[PRE23]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Similarly, we can create a new action to register an administrator or a VIP
    user. You can check the code in the completed app.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，我们可以创建一个新的操作来注册管理员或VIP用户。您可以在完成的应用程序中查看代码。
- en: 'You can register a new administrator using any HTTP client you like. After
    the users are created, you can view the users and their roles in the database,
    as shown in *Figure 8**.10*:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用您喜欢的任何HTTP客户端注册新的管理员。用户创建后，您可以在数据库中查看用户及其角色，如图*图8**.10*所示：
- en: '![Figure 8.10 – Users and their roles in the database](img/B18971_08_10.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 数据库中的用户及其角色](img/B18971_08_10.jpg)'
- en: Figure 8.10 – Users and their roles in the database
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 数据库中的用户及其角色
- en: The data of the `AspNetUserRoles` table is used to store the relationship between
    users and roles. The `UserId` column is the primary key of the `AspNetUsers` table,
    while the `RoleId` column is the primary key of the `AspNetRoles` table.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`AspNetUserRoles` 表的数据用于存储用户和角色之间的关系。`UserId` 列是 `AspNetUsers` 表的主键，而 `RoleId`
    列是 `AspNetRoles` 表的主键。'
- en: 'Next, we need to update the method that is used to generate the JWT token.
    When we generate the token, we need to include the roles of the user in the token.
    We can use the `GetRolesAsync()` method to get the roles and then add them to
    the claims. The updated code is as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新用于生成JWT令牌的方法。当我们生成令牌时，我们需要在令牌中包含用户的角色。我们可以使用 `GetRolesAsync()` 方法获取角色，然后将它们添加到声明中。更新的代码如下：
- en: '[PRE24]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Try to run the application and register a new user or log in with an existing
    user. Copy the token in the response and paste it to the `jwt.io` website to decode
    the payload. You will see that the roles are included in the token, as shown here:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行应用程序并注册一个新用户或使用现有用户登录。复制响应中的令牌并将其粘贴到 `jwt.io` 网站以解码负载。您将看到令牌中包含了角色，如下所示：
- en: '[PRE25]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s update the `WeatherForecastController` class to implement role-based
    authorization. Add a new action for administrators, as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新 `WeatherForecastController` 类以实现基于角色的授权。添加一个新的管理员操作，如下所示：
- en: '[PRE26]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `Authorize` attribute is used to specify the role that is allowed to access
    the API. In the preceding code, only authenticated users with the `Administrator`
    role can access the API.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Authorize` 属性用于指定允许访问API的角色。在上面的代码中，只有具有 `Administrator` 角色的认证用户可以访问API。'
- en: Now, you can test the API. If you use the token of a normal user to access the
    `/WeatherForecast/admin` endpoint, you will get a 403 Forbidden response.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您可以测试API。如果您使用普通用户的令牌访问 `/WeatherForecast/admin` 端点，您将收到403禁止访问的响应。
- en: Generally, the `administrator` role should have permission to access all resources.
    But in our current application, the administrator user cannot access the `/WeatherForecast`
    endpoint. There are multiple ways to fix this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`管理员`角色应该有权限访问所有资源。但在我们当前的应用程序中，管理员用户无法访问`/WeatherForecast`端点。有多种方法可以解决这个问题。
- en: The first way is that when we register a new administrator, we can assign the
    `Administrator` role to the user and also assign the `User` role (or any other
    roles) to the user. This way, the administrator user can access all resources.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是，当我们注册一个新的管理员时，我们可以将`Administrator`角色分配给用户，并将`User`角色（或任何其他角色）分配给用户。这样，管理员用户就可以访问所有资源。
- en: 'We can also update the `Authorize` attribute to allow multiple roles, like
    so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更新`Authorize`属性以允许多个角色，如下所示：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code means that the user must have at least one of the specified
    roles to access the API.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表示用户必须至少拥有指定的其中一个角色才能访问API。
- en: 'Note that if you apply multiple `Authorize` attributes with specified roles
    to an action, the user must have all the roles to access the API. For example,
    consider the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你对一个操作应用了多个具有指定角色的`Authorize`属性，用户必须拥有所有这些角色才能访问API。例如，考虑以下代码：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code states that the user must have both the `User` and `VipUser`
    roles to access the API. If the user has only one of the roles, the user will
    get a 403 Forbidden response.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表示用户必须同时拥有`User`和`VipUser`角色才能访问API。如果用户只有一个角色，用户将收到403禁止响应。
- en: 'Besides this, we can also define a policy to specify the roles that are allowed
    to access the API. For example, in the `Program` class, we can add the following
    code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以定义一个策略来指定允许访问API的角色。例如，在`Program`类中，我们可以添加以下代码：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can update the `Authorize` attribute to use the policy like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更新`Authorize`属性以使用策略，如下所示：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If the `policy.RequireRole()` method has multiple roles in parameters, the user
    must have at least one of the roles to access the API. You can check the code
    in the completed app.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`policy.RequireRole()`方法在参数中具有多个角色，用户必须至少拥有其中一个角色才能访问API。您可以在完成的应用程序中查看代码。
- en: With that, we’ve implemented role-based authorization in ASP.NET Core. In the
    next section, we will learn how to implement claim-based authorization.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就实现了ASP.NET Core中的基于角色的授权。在下一节中，我们将学习如何实现基于声明的授权。
- en: Claim-based authorization
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于声明的授权
- en: When a user is authenticated, the user will have a set of claims that are used
    to store the information about the user. For example, the user can have a claim
    that specifies the user’s role. So, technically, roles are also claims, but they
    are special claims that are used to store the roles of the user. We can store
    other information in the claims, such as the user’s name, email address, date
    of birth, driving license number, and more. Once we’ve done this, the authorization
    system can check the claims to determine whether the user is allowed to access
    the resource. Claim-based authorization provides more granular access control
    than role-based authorization, but it can be more complex to implement and manage.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进行身份验证时，用户将有一组声明，这些声明用于存储有关用户的信息。例如，用户可以有一个指定用户角色的声明。因此，从技术上讲，角色也是声明，但它们是用于存储用户角色的特殊声明。我们可以在声明中存储其他信息，例如用户的名字、电子邮件地址、出生日期、驾照号码等。一旦我们这样做，授权系统就可以检查声明以确定用户是否有权访问资源。基于声明的授权比基于角色的授权提供了更细粒度的访问控制，但实现和管理可能更复杂。
- en: 'You can find the starter app and the completed app in the `chapter8/AuthorizationDemo/ClaimBasedAuthorizationDemo`
    folder in this book’s GitHub repository:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书GitHub仓库的`chapter8/AuthorizationDemo/ClaimBasedAuthorizationDemo`文件夹中找到入门应用程序和完成的应用程序：
- en: 'We’ll start with the starter app. Don’t forget to create the database and run
    the migrations using the following commands:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从入门应用程序开始。不要忘记使用以下命令创建数据库并运行迁移：
- en: '[PRE31]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: public static class AppClaimTypes{    public const string DrivingLicenseNumber
    = "DrivingLicenseNumber";    public const string AccessNumber = "AccessNumber";}
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`public static class AppClaimTypes{    public const string DrivingLicenseNumber
    = "DrivingLicenseNumber";    public const string AccessNumber = "AccessNumber";}`'
- en: '[PRE32]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Also, create a new `AppAuthorizationPolicies` class to define the authorization
    policies:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以创建一个新的`AppAuthorizationPolicies`类来定义授权策略：
- en: '[PRE33]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we can add the claims to the token when the user logs in. Update the
    `GenerateToken` method in the `AccountController` class, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在用户登录时将声明添加到令牌中。更新 `AccountController` 类中的 `GenerateToken` 方法，如下所示：
- en: '[PRE34]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can add any claims to the token. In the preceding code, we added the `Country`,
    `AccessNumber`, and `DrivingLicenseNumber` claims to the token.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将任何声明添加到令牌中。在前面提到的代码中，我们向令牌中添加了 `Country`、`AccessNumber` 和 `DrivingLicenseNumber`
    声明。
- en: 'Imagine that we have a requirement that only users who have their driving licenses
    can access the resource. We can implement this by adding the following code to
    the `Program` class:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个要求，只有拥有驾驶执照的用户才能访问资源。我们可以通过向 `Program` 类中添加以下代码来实现这一点：
- en: '[PRE35]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, the difference between role-based authorization and claim-based authorization
    is that claim-based authorization uses `policy.RequireClaim()` to check the claims,
    while role-based authorization uses `policy.RequireRole()` to check the roles.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，基于角色的授权和基于声明的授权之间的区别在于，基于声明的授权使用 `policy.RequireClaim()` 来检查声明，而基于角色的授权使用
    `policy.RequireRole()` 来检查角色。
- en: 'At this point, we can update the `Authorize` attribute so that it uses the
    policy, like this:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以更新 `Authorize` 属性，使其使用策略，如下所示：
- en: '[PRE36]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the application and test the `/WeatherForecast/driving-license` endpoint.
    You will get a `401` Unauthorized response because the user does not have the
    `DrivingLicenseNumber` claim. Register a user or log in to get the token. Then,
    add the token to the `Authorization` header and call the `/WeatherForecast/driving-license`
    endpoint again. You will get a 200 OK response with `drivingLicenseNumber` in
    the response body.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并测试 `/WeatherForecast/driving-license` 端点。您将得到一个 `401` 未授权响应，因为用户没有 `DrivingLicenseNumber`
    声明。注册一个用户或登录以获取令牌。然后，将令牌添加到 `Authorization` 标头中，再次调用 `/WeatherForecast/driving-license`
    端点。您将得到一个包含 `drivingLicenseNumber` 的响应体中的 200 OK 响应。
- en: 'The token now contains the claims, as shown in the following JSON response:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 令牌现在包含声明，如下面的 JSON 响应所示：
- en: '[PRE37]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is the simplest way to implement claim-based authorization. The current
    approach only checks whether the token contains the claim; it does not check the
    value of the claim. We can check the values as well. The `RequireClaim()` method
    also has an overload that accepts `allowedValues` as a parameter. For example,
    we have a resource that can only be accessed by users based in New Zealand. We
    can update the `Program` class as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是最简单的基于声明的授权实现方式。当前方法仅检查令牌是否包含声明；它不检查声明的值。我们也可以检查值。`RequireClaim()` 方法还有一个接受
    `allowedValues` 作为参数的重载版本。例如，我们有一个只能由新西兰用户访问的资源。我们可以更新 `Program` 类，如下所示：
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The action in the controller looks like this:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 控制器中的操作如下所示：
- en: '[PRE39]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can test the API by calling the `/WeatherForecast/country` endpoint. Now,
    only users who have the `Country` claim with the value of `New Zealand` can access
    the resource.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过调用 `/WeatherForecast/country` 端点来测试 API。现在，只有具有 `Country` 声明且值为 `New Zealand`
    的用户才能访问资源。
- en: 'Similar to roles, we can apply multiple policies to a resource. For example,
    we can require the user to have both the `DrivingLicense` and `AccessNumber` claims
    to access the resource. Just like roles, you can add two policies to the `Authorize`
    attribute, which means that the user must have both the `DrivingLicense` and `AccessNumber`
    claims to access the resource. Here’s an example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与角色类似，我们可以将多个策略应用于资源。例如，我们可以要求用户必须同时拥有 `DrivingLicense` 和 `AccessNumber` 声明才能访问资源。就像角色一样，您可以将两个策略添加到
    `Authorize` 属性中，这意味着用户必须同时拥有 `DrivingLicense` 和 `AccessNumber` 声明才能访问资源。以下是一个示例：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Another way is to use the `RequireAssertion()` method, which allows us to execute
    a custom logic to check the claims. Update the `Program` class, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `RequireAssertion()` 方法，它允许我们执行自定义逻辑来检查声明。更新 `Program` 类，如下所示：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, the `context` parameter contains the `User` property
    that contains the claims. We can use the `HasClaim()` method to check whether
    the user has the claim. Then, we can return `true` if the user has both the `DrivingLicenseNumber`
    and `AccessNumber` claims; otherwise, we return `false`. You can also use the
    `context.User.Claims` property to get the claims and check the values per your
    requirement.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`context` 参数包含一个 `User` 属性，该属性包含声明。我们可以使用 `HasClaim()` 方法来检查用户是否有声明。然后，如果用户同时拥有
    `DrivingLicenseNumber` 和 `AccessNumber` 声明，我们可以返回 `true`；否则，返回 `false`。您也可以使用
    `context.User.Claims` 属性来获取声明并按照您的要求检查值。
- en: 'The action in the controller looks like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器中的操作如下所示：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this section, we learned how to implement claim-based authorization in ASP.NET
    Core. We also learned how to use the `RequireAssertion()` method to check the
    claims. If we need a more complex authorization logic, we can use policy-based
    authorization. But first, let’s learn how authorization works in ASP.NET Core.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在 ASP.NET Core 中实现基于声明的授权。我们还学习了如何使用 `RequireAssertion()` 方法来检查声明。如果我们需要更复杂的授权逻辑，我们可以使用策略授权。但首先，让我们学习在
    ASP.NET Core 中授权是如何工作的。
- en: Understanding the authorization process
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解授权过程
- en: 'In the previous section, we learned how to implement role-based authorization
    and claim-based authorization. Let’s delve deeper into the details. You may have
    noticed that when we use role-based authorization or claim-based authorization,
    we need to call the `AddPolicy()` method in the `AddAuthorization` method. The
    signature of the `AddPolicy()` method is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何实现基于角色的授权和基于声明的授权。让我们深入了解细节。您可能已经注意到，当我们使用基于角色的授权或基于声明的授权时，我们需要在
    `AddAuthorization` 方法中调用 `AddPolicy()` 方法。`AddPolicy()` 方法的签名如下：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `AddPolicy()` method accepts two parameters:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddPolicy()` 方法接受两个参数：'
- en: A `name` parameter, which is the name of the policy
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `name` 参数，它是策略的名称
- en: A `configurePolicy` parameter, which is a delegate that accepts an `AuthorizationPolicyBuilder`
    parameter
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configurePolicy` 参数，它是一个接受 `AuthorizationPolicyBuilder` 参数的委托'
- en: 'You can press *F12* to check the source code of the `AuthorizationPolicyBuilder`
    class. You will find that it has some methods to configure the policy, such as
    `RequireRole()`, `RequireClaim()`, and others. The source code of the `RequireRole`
    method looks like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按 *F12* 查看类 `AuthorizationPolicyBuilder` 的源代码。您会发现它有一些配置策略的方法，例如 `RequireRole()`、`RequireClaim()`
    等。`RequireRole` 方法的源代码如下：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The source code of the `RequireClaim()` method is shown here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequireClaim()` 方法的源代码如下所示：'
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Both the `RequireRole()` and `RequireClaim()` methods call the `Requirements.Add()`
    method under the hood. So, what is the `Requirements` object?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequireRole()` 和 `RequireClaim()` 方法在底层调用 `Requirements.Add()` 方法。那么，`Requirements`
    对象是什么？'
- en: 'We are getting closer to the core of authorization in ASP.NET Core. The definition
    of the `Requirements` object is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接近 ASP.NET Core 授权的核心。`Requirements` 对象的定义如下：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `Requirements` object in the `AuthorizationPolicyBuilder` class is a list
    of `IAuthorizationRequirement` objects. The `IAuthorizationRequirement` interface
    is just a marker service, and it does not have any methods. Let’s press *F12*
    on the `RolesAuthorizationRequirement` class and the `ClaimsAuthorizationRequirement`
    class. We will see their source code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizationPolicyBuilder` 类中的 `Requirements` 对象是一个 `IAuthorizationRequirement`
    对象的列表。`IAuthorizationRequirement` 接口只是一个标记服务，它没有任何方法。让我们在 `RolesAuthorizationRequirement`
    类和 `ClaimsAuthorizationRequirement` 类上按 *F12*。我们将看到它们的源代码：'
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we can see, both the `RolesAuthorizationRequirement` and `ClaimsAuthorizationRequirement`
    classes implement the `IAuthorizationRequirement` interface. They also implement
    the `AuthorizationHandler<TRequirement>` class, which is defined as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`RolesAuthorizationRequirement` 和 `ClaimsAuthorizationRequirement` 类都实现了
    `IAuthorizationRequirement` 接口。它们还实现了 `AuthorizationHandler<TRequirement>` 类，该类定义如下：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'So, each implementation of the `AuthorizationHandler<TRequirement>` class implements
    the `HandleRequirementAsync()` method to check the requirements. For example,
    the `RolesAuthorizationRequirement` class consists of the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`AuthorizationHandler<TRequirement>` 类的每个实现都实现了 `HandleRequirementAsync()`
    方法来检查要求。例如，`RolesAuthorizationRequirement` 类由以下代码组成：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When a `RolesAuthorizationRequirement` instance is instantiated, it accepts
    a collection of roles from the constructor. Then, it uses the `HandleRequirementAsync()`
    method to check whether the user is in the role. If the user is in the role, it
    calls the `context.Succeed()` method to set the `Succeeded` property to `true`.
    Otherwise, it sets the `Succeeded` property to `false`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `RolesAuthorizationRequirement` 实例被创建时，它从构造函数中接受一组角色。然后，它使用 `HandleRequirementAsync()`
    方法来检查用户是否在角色中。如果用户在角色中，它调用 `context.Succeed()` 方法将 `Succeeded` 属性设置为 `true`。否则，它将
    `Succeeded` 属性设置为 `false`。
- en: If you check the implementation of the `ClaimsAuthorizationRequirement` class,
    you will find it is similar to the `RolesAuthorizationRequirement` class. It accepts
    `claimType` and a set of `allowValues` and checks whether the user has the claim,
    and whether the claim value is in the `allowValues` set.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查 `ClaimsAuthorizationRequirement` 类的实现，您会发现它与 `RolesAuthorizationRequirement`
    类类似。它接受 `claimType` 和一组 `allowValues`，并检查用户是否有该声明，以及声明值是否在 `allowValues` 集合中。
- en: The next question is – who is responsible for calling these methods?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是——谁负责调用这些方法？
- en: 'Let’s go back to the `Program` class to understand the middleware pipeline.
    We have the `app.UseAuthorization()` method in the `Program` file, which is used
    to add the authorization middleware. Press *F12* on the `UseAuthorization` method.
    We’ll be able to view its source code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `Program` 类来理解中间件管道。我们在 `Program` 文件中有 `app.UseAuthorization()` 方法，它用于添加授权中间件。在
    `UseAuthorization` 方法上按 *F12*。我们将能够查看其源代码：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Continue to press *F12* to check the source code of `AuthorizationMiddleware`.
    You will see the following code in the `Invoke()` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 持续按 *F12* 检查 `AuthorizationMiddleware` 的源代码。您将在 `Invoke()` 方法中看到以下代码：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we are closer. The `AuthorizationMiddleware` class gets the policies from
    the endpoint metadata and then calls the `IPolicyEvaluator.AuthenticateAsync()`
    method to check whether the user is authenticated, after which it calls the `IPolicyEvaluator.AuthorizeAsync()`
    method to check whether the user is authorized. The `IPolicyEvaluator` interface
    is defined as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们更接近了。`AuthorizationMiddleware` 类从端点元数据中获取策略，然后调用 `IPolicyEvaluator.AuthenticateAsync()`
    方法来检查用户是否已认证，之后它调用 `IPolicyEvaluator.AuthorizeAsync()` 方法来检查用户是否被授权。`IPolicyEvaluator`
    接口定义如下：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The default implementation of `IPolicyEvaluator` has been injected into the
    DI container by the ASP.NET Core framework. You can find the source code of the
    `PolicyEvaluator` class here: `https://source.dot.net/#Microsoft.AspNetCore.Authorization.Policy/PolicyEvaluator.cs`.
    You will see it has an `IAuthorizationService` object injected into it, which
    is defined as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 框架已将 `IPolicyEvaluator` 的默认实现注入到 DI 容器中。您可以在以下位置找到 `PolicyEvaluator`
    类的源代码：`https://source.dot.net/#Microsoft.AspNetCore.Authorization.Policy/PolicyEvaluator.cs`。您将看到它注入了一个
    `IAuthorizationService` 对象，该对象定义如下：
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With that, we’ve found the `IAuthorizationRequirement` class we described earlier!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们找到了之前描述的 `IAuthorizationRequirement` 类！
- en: 'You can find the source code of the default implementation of `IAuthorizationService`
    here: [https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs](https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs).
    It is also injected into the DI container by the framework. The core code is as
    follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到 `IAuthorizationService` 的默认实现源代码：[https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs](https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs)。它也被框架注入到
    DI 容器中。核心代码如下：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'So, we end up with the following call stack:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了以下调用堆栈：
- en: Define the authorization policy (requirement) in the `Program` class.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类中定义授权策略（要求）。
- en: Apply the authorization policy to the endpoint.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将授权策略应用于端点。
- en: Apply the authorization middleware to the pipeline.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将授权中间件应用于管道。
- en: The request comes in with the `Authorization` header, which can be retrieved
    from the `HttpContext` object.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求带有 `Authorization` 标头进入，该标头可以从 `HttpContext` 对象中检索。
- en: '`AuthorizationMiddleware` calls the `IPolicyEvaluator.AuthorizeAsync()` method.'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AuthorizationMiddleware` 调用 `IPolicyEvaluator.AuthorizeAsync()` 方法。'
- en: The `IPolicyEvaluator.AuthorizeAsync()` method calls the `IAuthorizationService.AuthorizeAsync()`
    method.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IPolicyEvaluator.AuthorizeAsync()` 方法调用 `IAuthorizationService.AuthorizeAsync()`
    方法。'
- en: The `IAuthorizationService.AuthorizeAsync()` method calls the `IAuthorizationHandler.HandleAsync()`
    method to check whether the user is authorized.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IAuthorizationService.AuthorizeAsync()` 方法调用 `IAuthorizationHandler.HandleAsync()`
    方法来检查用户是否被授权。'
- en: Once we understand the call stack, we can easily implement an authorization
    policy by implementing the `IAuthorizationRequirement`, `IAuthorizationHandler`,
    and `IAuthorizationService` interfaces.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了调用堆栈，我们就可以通过实现 `IAuthorizationRequirement`、`IAuthorizationHandler` 和
    `IAuthorizationService` 接口轻松实现授权策略。
- en: Policy-based authorization
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于策略的授权
- en: In the previous section, we explained that both role-based authorization and
    claim-based authorization are implemented by the `IAuthorizationRequirement`,
    `IAuthorizationHandler`, and `IAuthorizationService` interfaces under the hood.
    If we have more complex authorization logic, we can use policy-based authorization
    directly, which allows us to define custom authorization policies to execute complex
    authorization logic.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们解释了基于角色的授权和基于声明的授权都是在 `IAuthorizationRequirement`、`IAuthorizationHandler`
    和 `IAuthorizationService` 接口下实现的。如果我们有更复杂的授权逻辑，我们可以直接使用基于策略的授权，这允许我们定义自定义的授权策略来执行复杂的授权逻辑。
- en: 'For example, we have a scenario where we need to support the following authorization
    logic:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个需要支持以下授权逻辑的场景：
- en: The special premium content can be accessed by the user who has a `Premium`
    subscription and is also based in New Zealand
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有 `Premium` 订阅并且基于新西兰的用户可以访问特殊付费内容
- en: Users who have a `Premium` subscription, but are not based in New Zealand, cannot
    access the special premium content
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有 `Premium` 订阅但不在新西兰的用户无法访问特殊付费内容
- en: 'There may be other complex authorization logic in the real world. Let’s implement
    the aforementioned authorization logic using policy-based authorization. You can
    find the sample code in the `/``samples/chapter8/AuthorizationDemo/PolicyBasedAuthorization`
    folder:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，可能还有其他复杂的授权逻辑。让我们使用基于策略的授权来实现上述授权逻辑。你可以在 `/samples/chapter8/AuthorizationDemo/PolicyBasedAuthorization`
    文件夹中找到示例代码：
- en: 'First, add two classes to the `Authentication` folder, as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向 `Authentication` 文件夹中添加两个类，如下所示：
- en: '[PRE55]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: These classes define the claim types and authorization policies we need. You
    can also use strings directly in the code, but it is recommended to use constants
    to avoid typos.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些类定义了我们需要的声明类型和授权策略。你也可以直接在代码中使用字符串，但建议使用常量以避免拼写错误。
- en: 'In the `AccountController` class, update the `GenerateToken()` method with
    a new claim, as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AccountController` 类中，更新 `GenerateToken()` 方法以添加一个新的声明，如下所示：
- en: '[PRE56]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We added a new claim, `AppClaimTypes.Subscription`, with a value of `Premium`
    to the token. This claim represents the user’s subscription type. We also added
    a new claim, `ClaimTypes.Country`, to the token. This claim represents the user’s
    country. In the real world, you can get the user’s subscription type and country
    from the database. Let’s assume we have the subscription type and country information
    in the token for simplicity.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们向令牌中添加了一个新的声明，`AppClaimTypes.Subscription`，其值为 `Premium`。这个声明表示用户的订阅类型。我们还向令牌中添加了一个新的声明，`ClaimTypes.Country`。这个声明表示用户的国籍。在现实世界中，你可以从数据库中获取用户的订阅类型和国籍信息。为了简化，我们假设令牌中包含了订阅类型和国籍信息。
- en: 'Next, update the `Login()` method in the `AccountController` class to add the
    country to the claims and create another method for New Zealand users, as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `AccountController` 类中的 `Login()` 方法，将国家添加到声明中，并为新西兰用户创建另一个方法，如下所示：
- en: '[PRE57]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Again, this is a simplified implementation for demonstration purposes. In the
    real world, generally, there is only one login endpoint, and the country information
    is retrieved from the database or other sources, such as IP addresses.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，这只是为了演示目的的简化实现。在现实世界中，通常只有一个登录端点，国家信息是从数据库或其他来源检索的，例如 IP 地址。
- en: 'Next, we need to implement the authorization policy. Create a new class named
    `SpecialPremiumContentRequirement` in the `Authorization` folder, as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现授权策略。在 `Authorization` 文件夹中创建一个名为 `SpecialPremiumContentRequirement`
    的新类，如下所示：
- en: '[PRE58]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This class implements the `IAuthorizationRequirement` interface. The `Country`
    property represents the country where the premium content can be accessed. We
    can use this property to check whether the user is authorized to access the premium
    content.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类实现了 `IAuthorizationRequirement` 接口。`Country` 属性表示可以访问付费内容的国家。我们可以使用这个属性来检查用户是否有权访问付费内容。
- en: 'Next, we need to implement the `AuthorizationHandler` interface. Create a `SpecialPremiumContentAuthorizationHandler`
    class in the `Authorization` folder, as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现 `AuthorizationHandler` 接口。在 `Authorization` 文件夹中创建一个名为 `SpecialPremiumContentAuthorizationHandler`
    的类，如下所示：
- en: '[PRE59]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This handler is used to check whether the requirement is satisfied. If the user
    has a `Premium` subscription and is based in the country where the premium content
    can be accessed, the requirement is satisfied. Otherwise, the requirement is not
    satisfied.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此处理器用于检查要求是否满足。如果用户拥有 `Premium` 订阅且位于可以访问高级内容的国家，则满足要求。否则，要求不满足。
- en: 'Next, we need to register the authorization policy and the authorization handler.
    Update the `Program` class, as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要注册授权策略和授权处理器。更新 `Program` 类，如下所示：
- en: '[PRE60]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding code, we registered the authorization policy, `AppAuthorizationPolicies.SpecialPremiumContent`,
    with the `SpecialPremiumContentRequirement` requirement. The `SpecialPremiumContentRequirement`
    requirement is satisfied if the user has a `Premium` subscription and is based
    in New Zealand. We also registered the `SpecialPremiumContentAuthorizationHandler`
    handler as a singleton service.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `SpecialPremiumContentRequirement` 要求注册了授权策略 `AppAuthorizationPolicies.SpecialPremiumContent`。如果用户拥有
    `Premium` 订阅且位于新西兰，则满足 `SpecialPremiumContentRequirement` 要求。我们还注册了 `SpecialPremiumContentAuthorizationHandler`
    处理器作为单例服务。
- en: 'Finally, we need to apply the authorization policy to the controller. Open
    the `WeatherForecastController` class and add a new action, as shown in the following
    code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将授权策略应用到控制器上。打开 `WeatherForecastController` 类并添加一个新的操作，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This action can only be accessed by users who have a `Premium` subscription
    and are based in New Zealand. If the user does not have a `Premium` subscription
    or is not based in New Zealand, the authorization policy will not be satisfied,
    and the user will not be able to access the action.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此操作只能由拥有 `Premium` 订阅且位于新西兰的用户访问。如果用户没有 `Premium` 订阅或不在新西兰，授权策略将不会满足，用户将无法访问该操作。
- en: You can test the application as we did in the previous section. The application
    has two login endpoints – one for New Zealand users and one for Australian users.
    If you log in as a New Zealand user, you can access the `WeatherForecast/special-premium`
    endpoint. Otherwise, you will get a `403` response.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像上一节那样测试应用程序。应用程序有两个登录端点——一个用于新西兰用户，一个用于澳大利亚用户。如果您以新西兰用户身份登录，您可以访问 `WeatherForecast/special-premium`
    端点。否则，您将收到 `403` 响应。
- en: 'There are some points to note for policy-based authorization:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于策略的授权，有一些需要注意的点：
- en: You can use one `AuthorizationHandler` instance to handle multiple requirements.
    in the `HandleAsync()` method, you can use `AuthorizationHandlerContext.PendingRequirements`
    to get all the pending requirements and then check them one by one.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用一个 `AuthorizationHandler` 实例来处理多个要求。在 `HandleAsync()` 方法中，您可以使用 `AuthorizationHandlerContext.PendingRequirements`
    来获取所有挂起的请求，然后逐个检查它们。
- en: If you have multiple `AuthorizationHandler` instances, they will be invoked
    in any order, which means you cannot expect the order of the handlers.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有多个 `AuthorizationHandler` 实例，它们将以任何顺序被调用，这意味着您不能期望处理器的顺序。
- en: You need to call `context.Succeed(requirement)` to mark the requirement as satisfied.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要调用 `context.Succeed(requirement)` 来标记要求已满足。
- en: 'What if the requirement is not satisfied? There are two options:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要求不满足会怎样？有两种选择：
- en: Generally, you do not need to call `context.Fail()` to mark the failed requirement
    because there may be other handlers to handle the same requirement, which may
    be satisfied.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，您不需要调用 `context.Fail()` 来标记失败的要求，因为可能有其他处理器来处理相同的要求，这些要求可能已经满足。
- en: 'If you want to make sure the requirement fails and indicate that the whole
    authorization process fails, you can call `context.Fail()` explicitly, and set
    the `InvokeHandlersAfterFailure` property to `false` in the `AddAuthorization()`
    method, like this:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想确保要求失败并指示整个授权过程失败，您可以显式调用 `context.Fail()`，并在 `AddAuthorization()` 方法中将
    `InvokeHandlersAfterFailure` 属性设置为 `false`，如下所示：
- en: '[PRE62]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this section, we explored the three types of authorization available in
    ASP.NET Core: role-based, claim-based, and policy-based. We examined the source
    code to gain a deeper understanding of how authorization works. With this knowledge,
    you should now be able to confidently use the authorization features of ASP.NET
    Core. Next, we will learn how to manage users and roles.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 ASP.NET Core 中可用的三种授权类型：基于角色、基于声明和基于策略。我们检查了源代码以深入了解授权的工作原理。有了这些知识，您现在应该能够自信地使用
    ASP.NET Core 的授权功能。接下来，我们将学习如何管理用户和角色。
- en: Managing users and roles
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户和角色
- en: In the previous sections, we implemented the authentication and authorization
    features. Generally, the application should also provide a way to manage users
    and roles. ASP.NET Core Identity provides a set of APIs to manage users and roles.
    In this section, we will introduce how to use these APIs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们实现了身份验证和授权功能。通常，应用程序还应提供一种管理用户和角色的方式。ASP.NET Core Identity提供了一套API来管理用户和角色。在本节中，我们将介绍如何使用这些API。
- en: Previously, we learned that the `IdentityDbContext` class is used to store the
    user and role information. So, we do not need to create a new database context
    class. Similarly, we can use `UserManager` and `RoleManager` to manage users and
    roles without having to write any code.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了`IdentityDbContext`类用于存储用户和角色信息。因此，我们不需要创建一个新的数据库上下文类。同样，我们可以使用`UserManager`和`RoleManager`来管理用户和角色，而无需编写任何代码。
- en: 'Here are some common operations for managing users by using the `UserManager`
    class:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`UserManager`类管理用户的一些常见操作：
- en: '| **Method** | **Description** |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CreateAsync(TUser user,` `string password)` | Creates a user with the given
    password. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `CreateAsync(TUser user, string password)` | 使用给定的密码创建用户。 |'
- en: '| `UpdateUserAsync(TUser user)` | Updates a user. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `UpdateUserAsync(TUser user)` | 更新用户。 |'
- en: '| `FindByNameAsync(string userName)` | Finds a user by name. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `FindByNameAsync(string userName)` | 通过用户名查找用户。 |'
- en: '| `FindByIdAsync(string userId)` | Finds a user by ID. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `FindByIdAsync(string userId)` | 通过ID查找用户。 |'
- en: '| `FindByEmailAsync(string email)` | Finds a user by email. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `FindByEmailAsync(string email)` | 通过电子邮件查找用户。 |'
- en: '| `DeleteAsync(TUser user)` | Deletes a user. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `DeleteAsync(TUser user)` | 删除用户。 |'
- en: '| `AddToRoleAsync(TUser user,` `string role)` | Adds the user to a role. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `AddToRoleAsync(TUser user, string role)` | 将用户添加到角色中。 |'
- en: '| `GetRolesAsync(TUser user)` | Gets a list of roles for the user. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `GetRolesAsync(TUser user)` | 获取用户的角色列表。 |'
- en: '| `IsInRoleAsync(TUser user,` `string role)` | Checks whether the user has
    a role. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `IsInRoleAsync(TUser user, string role)` | 检查用户是否具有该角色。 |'
- en: '| `RemoveFromRoleAsync(TUser user,` `string role)` | Removes the user from
    a role. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `RemoveFromRoleAsync(TUser user, string role)` | 从角色中移除用户。 |'
- en: '| `CheckPasswordAsync(TUser user,` `string password)` | Checks whether the
    password is correct for the user. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `CheckPasswordAsync(TUser user, string password)` | 检查密码是否正确。 |'
- en: '| `ChangePasswordAsync(TUser user, string currentPassword,` `string newPassword)`
    | Changes the user’s password. The user must provide the correct current password.
    |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `ChangePasswordAsync(TUser user, string currentPassword, string newPassword)`
    | 更改用户的密码。用户必须提供正确的当前密码。 |'
- en: '| `GeneratePasswordResetTokenAsync(TUser user)` | Generates a token for resetting
    the user’s password. You need to specify `options.Token.PasswordResetTokenProvider`
    in the `AddIdentityCore()` method. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `GeneratePasswordResetTokenAsync(TUser user)` | 生成用于重置用户密码的令牌。您需要在`AddIdentityCore()`方法中指定`options.Token.PasswordResetTokenProvider`。
    |'
- en: '| `GenerateEmailConfirmationTokenAsync(TUser user)` | Generates a token for
    confirming the user’s email. You need to specify `options.Tokens.EmailConfirmationTokenProvider`
    in the `AddIdentityCore()` method. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `GenerateEmailConfirmationTokenAsync(TUser user)` | 生成用于确认用户电子邮件的令牌。您需要在`AddIdentityCore()`方法中指定`options.Tokens.EmailConfirmationTokenProvider`。
    |'
- en: '| `ConfirmEmailAsync(TUser user,` `string token)` | Checks whether the user
    has a valid email confirmation token. If the token matches, this method will set
    the `EmailConfirmed` property of the user to `true`. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `ConfirmEmailAsync(TUser user, string token)` | 检查用户是否具有有效的电子邮件确认令牌。如果令牌匹配，此方法将用户的`EmailConfirmed`属性设置为`true`。
    |'
- en: Table 8.1 – Common operations for managing users
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 – 管理用户常见操作
- en: 'Here are some common operations for managing roles by using the `RoleManager`
    class:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`RoleManager`类管理角色的一些常见操作：
- en: '| **Method** | **Description** |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CreateAsync(TRole role)` | Creates a role |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `CreateAsync(TRole role)` | 创建角色 |'
- en: '| `RoleExistsAsync(string roleName)` | Checks whether the role exists |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `RoleExistsAsync(string roleName)` | 检查角色是否存在 |'
- en: '| `UpdateAsync(TRole role)` | Updates a role |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `UpdateAsync(TRole role)` | 更新角色 |'
- en: '| `DeleteAsync(TRole role)` | Deletes a role |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `DeleteAsync(TRole role)` | 删除角色 |'
- en: '| `FindByNameAsync(string roleName)` | Finds a role by name |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `FindByNameAsync(string roleName)` | 通过名称查找角色 |'
- en: Table 8.2 – Common operations for managing roles
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 – 管理角色常见操作
- en: These APIs encapsulate the database operations, so we can use them to manage
    users and roles easily. Some of the methods return a `Task<IdentityResult>` object.
    The `IdentityResult` object contains a `Succeeded` property to indicate whether
    the operation is successful. If the operation is not successful, you can get the
    error messages by using the `Errors` property.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 API 封装了数据库操作，因此我们可以使用它们轻松地管理用户和角色。一些方法返回 `Task<IdentityResult>` 对象。`IdentityResult`
    对象包含一个 `Succeeded` 属性，用于指示操作是否成功。如果操作不成功，您可以通过使用 `Errors` 属性来获取错误消息。
- en: We will not cover all the APIs in this book. You can find more information in
    the ASP.NET Core documentation. Next, we will learn about the new built-in Identity
    API endpoints in ASP.NET Core 8.0.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中涵盖所有 API。您可以在 ASP.NET Core 文档中找到更多信息。接下来，我们将学习关于 ASP.NET Core 8.0 中的新内置身份验证
    API 端点。
- en: New Identity API endpoints in ASP.NET Core 8
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 8 中的新身份验证 API 端点
- en: In the previous sections, we learned how to implement authentication and authorization
    using the built-in Identity APIs in ASP.NET Core. We developed a couple of endpoints
    to register, log in, and manage users and roles. ASP.NET Core 8.0 introduces a
    new set of features to simplify authentication for web APIs. In this section,
    we will introduce these new endpoints.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用 ASP.NET Core 内置的身份验证 API 实现身份验证和授权。我们开发了一些端点来注册、登录和管理用户和角色。ASP.NET
    Core 8.0 引入了一组新功能，以简化 Web API 的身份验证。在本节中，我们将介绍这些新端点。
- en: 'Note that this new feature is only for simple authentication scenarios. The
    token generated by the Identity API endpoints is opaque, not a JWT token, which
    means it is intended to be used by the same application only. However, it is still
    a choice for a quick start. In ASP.NET Core 8.0, we can use a new `MapIdentityApi()`
    method to map the Identity API endpoints without writing any implementation as
    we did in the previous sections. Let’s learn how to use it:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个新功能仅适用于简单的身份验证场景。由身份验证 API 端点生成的令牌是透明的，不是 JWT 令牌，这意味着它仅适用于同一应用程序。然而，它仍然是一个快速入门的选择。在
    ASP.NET Core 8.0 中，我们可以使用新的 `MapIdentityApi()` 方法来映射身份验证 API 端点，而无需像前几节那样编写任何实现。让我们来学习如何使用它：
- en: First, follow *steps 1* to *5* in the *Creating a sample project with authentication
    and authorization* section to create a new web API project named `NewIdentityApiDemo`.
    Note that you do not need to install the `Microsoft.AspNetCore.Authentication.JwtBearer`
    package because we will not use JWT tokens in this sample project.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照 *步骤 1* 到 *5* 在 *创建具有身份验证和授权的示例项目* 部分中创建一个名为 `NewIdentityApiDemo` 的新 Web
    API 项目。请注意，您不需要安装 `Microsoft.AspNetCore.Authentication.JwtBearer` 包，因为我们在这个示例项目中不会使用
    JWT 令牌。
- en: 'Add the authorization policy service and register `DbContext` in the `Program.cs`
    file, as follows:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加授权策略服务和注册 `DbContext`，如下所示：
- en: '[PRE63]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the following commands to create the database and the migration:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建数据库和迁移：
- en: '[PRE64]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Register the Identity API endpoints in the `Program.cs` file, as follows:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中注册身份验证 API 端点，如下所示：
- en: '[PRE65]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `AddIdentityApiEndpoints()` method adds a set of common identity services
    to the application by calling the `AddIdentityCore<TUser>()` method under the
    hood. It also configures authentication to support identity bearer tokens and
    cookies, so we do not need to explicitly call the `AddIdentityCore<AppUser>()`
    method.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AddIdentityApiEndpoints()` 方法通过在内部调用 `AddIdentityCore<TUser>()` 方法向应用程序添加一组常见的身份验证服务。它还配置了身份验证以支持身份令牌和
    cookie，因此我们不需要显式调用 `AddIdentityCore<AppUser>()` 方法。'
- en: 'Map the Identity API endpoints in the `Program.cs` file, as follows:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中映射身份验证 API 端点，如下所示：
- en: '[PRE66]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code maps the Identity API endpoints to the `/identity` path.
    You can change it to any path you like, such as `api/accounts`, `/users`, and
    so on. Note that as we use an `AppUser` instead of the default `IdentityUser`,
    we must specify the `AppUser` type in the `MapIdentityApi()` method.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码将身份验证 API 端点映射到 `/identity` 路径。您可以将其更改为您喜欢的任何路径，例如 `api/accounts`、`/users`
    等。请注意，由于我们使用 `AppUser` 而不是默认的 `IdentityUser`，我们必须在 `MapIdentityApi()` 方法中指定 `AppUser`
    类型。
- en: 'Apply the `[Authorize]` attribute to the `WeatherForecastController` class,
    as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `[Authorize]` 属性应用于 `WeatherForecastController` 类，如下所示：
- en: '[PRE67]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the application using `dotnet run`. You will see the new Identity API endpoints
    in the Swagger UI:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 运行应用程序。您将在 Swagger UI 中看到新的身份验证 API 端点：
- en: '![Figure 8.11 – Identity API endpoints in the Swagger UI](img/B18971_08_11.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – Swagger UI 中的身份验证 API 端点](img/B18971_08_11.jpg)'
- en: Figure 8.11 – Identity API endpoints in the Swagger UI
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – Swagger UI 中的身份验证 API 端点
- en: 'Now, you can explore the new Identity API endpoints. Send a `POST` request
    with the following body to the `/identity/register` endpoint to register a new
    user:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以探索新的身份验证 API 端点。向 `/identity/register` 端点发送以下内容的 `POST` 请求以注册新用户：
- en: '[PRE68]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You will get a response that contains the access token and refresh token:'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得一个包含访问令牌和刷新令牌的响应：
- en: '[PRE69]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Then, you can use the access token to request the protected `/weatherforecast`
    endpoint with the `Authorization` header, as we introduced in the previous sections.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用访问令牌通过 `Authorization` 标头请求受保护的 `/weatherforecast` 端点，正如我们在前面的章节中介绍的那样。
- en: This new feature also provides endpoints such as `refreshToken`, `confirmEmail`,
    `resetPassword`, `2fa`, and others. Feel free to explore them on your own.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新功能还提供了 `refreshToken`、`confirmEmail`、`resetPassword`、`2fa` 等端点。请随意自行探索它们。
- en: Understanding OAuth 2.0 and OpenID Connect
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OAuth 2.0 和 OpenID Connect
- en: Previously, we learned how to implement authentication and authorization using
    built-in Identity APIs in ASP.NET Core. However, you may encounter some terms
    such as OAuth 2.0 and OpenID Connect when you work on a real project. It would
    be helpful to understand what they are and how to use them in ASP.NET Core. It
    is worth authoring a full book on OAuth 2.0 and OpenID Connect. In this section,
    we will introduce some basic concepts surrounding OAuth 2.0 and OpenID Connect,
    as well as some third-party authentication and authorization providers.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何使用 ASP.NET Core 内置的身份验证 API 来实现身份验证和授权。然而，在实际项目中，你可能会遇到一些术语，例如 OAuth
    2.0 和 OpenID Connect。了解它们是什么以及如何在 ASP.NET Core 中使用它们将非常有帮助。撰写一本关于 OAuth 2.0 和
    OpenID Connect 的完整书籍是值得的。在本节中，我们将介绍围绕 OAuth 2.0 和 OpenID Connect 的一些基本概念，以及一些第三方身份验证和授权提供商。
- en: What is OAuth 2.0?
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 OAuth 2.0？
- en: 'Let’s start with a real example. When you use LinkedIn, you may see a window
    that prompts you to sync your contacts from Outlook, Gmail, Yahoo, or other email
    services. This is because LinkedIn would like to know your contacts so that it
    can recommend you to invite your friends to join LinkedIn or to connect with them.
    This is a typical example where OAuth 2.0 is used:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从真实示例开始。当你使用领英时，你可能会看到一个窗口提示你从 Outlook、Gmail、Yahoo 或其他电子邮件服务同步你的联系人。这是因为领英希望了解你的联系人，以便它可以推荐你邀请你的朋友加入领英或与他们建立联系。这是一个典型的
    OAuth 2.0 应用示例：
- en: '![Figure 8.12 – Syncing contacts on LinkedIn](img/B18971_08_12.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 在领英上同步联系人](img/B18971_08_12.jpg)'
- en: Figure 8.12 – Syncing contacts on LinkedIn
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 在领英上同步联系人
- en: 'If you fill in your email address and click the **Continue** button, you will
    be redirected to the email service provider’s website. For example, I use Outlook,
    so I will see a window like this because I have multiple accounts:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你填写了你的电子邮件地址并点击 **继续** 按钮，你将被重定向到电子邮件服务提供商的网站。例如，我使用 Outlook，所以我将看到一个像这样的窗口，因为我有多个账户：
- en: '![Figure 8.13 – Prompting to log into Outlook](img/B18971_08_13.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – 提示登录 Outlook](img/B18971_08_13.jpg)'
- en: Figure 8.13 – Prompting to log into Outlook
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 提示登录 Outlook
- en: 'Note the URL in the address bar. It will look something like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意地址栏中的 URL。它看起来可能像这样：
- en: '[PRE70]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The URL contains the **client ID** of the application, which is used to identify
    the application. It also contains the **redirect URL** so that the authorization
    server can redirect the user back to the application after the user grants permission.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: URL 包含应用程序的 **客户端 ID**，用于标识应用程序。它还包含 **重定向 URL**，以便授权服务器在用户授予权限后可以将用户重定向回应用程序。
- en: 'You need to log into the email service provider’s website and authorize LinkedIn
    to access your contacts. If you have already logged in, you will see this window:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要登录电子邮件服务提供商的网站并授权领英访问你的联系人。如果你已经登录，你会看到这个窗口：
- en: '![Figure 8.14 – Authorizing LinkedIn to access your contacts](img/B18971_08_14.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.14 – 授权领英访问你的联系人](img/B18971_08_14.jpg)'
- en: Figure 8.14 – Authorizing LinkedIn to access your contacts
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 授权领英访问你的联系人
- en: After you authorize LinkedIn, you will be redirected back to LinkedIn. LinkedIn
    will get the contacts from the email service provider and show them to you.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在你授权领英后，你将被重定向回领英。领英将从电子邮件服务提供商那里获取联系人信息并展示给你。
- en: We do not want to allow LinkedIn to know the password of our email address.
    In this case, OAuth 2.0 and OpenID Connect are used to authorize LinkedIn to access
    our contacts without knowing our password.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望LinkedIn知道我们电子邮件地址的密码。在这种情况下，OAuth 2.0和OpenID Connect被用来授权LinkedIn访问我们的联系人，而无需知道我们的密码。
- en: 'OAuth 2.0 implements a **delegated authorization** model. It allows a client
    to access a protected resource on behalf of a user. There are some entities involved
    in the OAuth 2.0 model:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0实现了一个**委托授权**模型。它允许客户端代表用户访问受保护资源。OAuth 2.0模型中涉及一些实体：
- en: '**Resource owner**: The user who owns the protected resource. In our example,
    the resource owner is the user who owns the email address.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：拥有受保护资源的用户。在我们的例子中，资源所有者是拥有电子邮件地址的用户。'
- en: '**Client**: The client application that wants to access the protected resource.
    In our example, the client is LinkedIn. Note that this client is not the user’s
    browser.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：想要访问受保护资源的客户端应用程序。在我们的例子中，客户端是LinkedIn。请注意，此客户端不是用户的浏览器。'
- en: '**Resource server**: The server that hosts the protected resource. In our example,
    the resource server is the email service provider – for example, Outlook.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：托管受保护资源的服务器。在我们的例子中，资源服务器是电子邮件服务提供商——例如，Outlook。'
- en: '**Authorization server**: The server that handles the delegated authorization.
    In our example, the authorization server is Microsoft Identity Platform. An **Authorization**
    server has at least two endpoints:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：处理委托授权的服务器。在我们的例子中，授权服务器是Microsoft身份平台。一个**授权**服务器至少有两个端点：'
- en: The **authorization endpoint** is used to interact with the end user and obtain
    an authorization grant
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权端点**用于与最终用户交互并获得授权授予'
- en: 'The **token endpoint** is used with the client to exchange an authorization
    grant for an access token:'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌端点**用于与客户端交换授权授予以获取访问令牌：'
- en: '![Figure 8.15 – OAuth 2.0 flow](img/B18971_08_15.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – OAuth 2.0流程](img/B18971_08_15.jpg)'
- en: Figure 8.15 – OAuth 2.0 flow
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – OAuth 2.0流程
- en: Note that the client (LinkedIn) must register itself as a known client to the
    authorization server (Microsoft) before it can access the protected resource.
    The client must provide a **client ID** and a **client secret** to the authorization
    server to prove its identity. That is why we can see LinkedIn’s Microsoft Graph
    Connector in *Figure 8**.14*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，客户端（LinkedIn）在能够访问受保护资源之前，必须将其自身注册为授权服务器（Microsoft）的已知客户端。客户端必须向授权服务器提供**客户端ID**和**客户端密钥**以证明其身份。这就是为什么我们可以在*图8*中看到LinkedIn的Microsoft
    Graph Connector。14*。
- en: 'The common steps of OAuth 2.0 are as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0的常见步骤如下：
- en: The client requests access to a protected resource.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端请求访问受保护资源。
- en: The client redirects the user to the authorization server, such as Microsoft,
    Google, and so on. Specifically, it redirects to the authorization endpoint of
    the authorization server. After the user is authenticated, the authorization server
    will prompt the user, asking something like “Hi, I have a **known** client named
    LinkedIn, which wants to access my APIs using your privileges. Specifically, it
    wants to access your contacts so that it can send emails on your behalf. Do you
    want to grant access to LinkedIn?” This is what *Figure* *8**.14* shows.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将用户重定向到授权服务器，如Microsoft、Google等。具体来说，它重定向到授权服务器的授权端点。用户认证后，授权服务器将提示用户，询问类似“嗨，我有一个**已知**的客户端名为LinkedIn，它想使用您的权限访问我的API。具体来说，它想访问您的联系人，以便代表您发送电子邮件。您想授予LinkedIn访问权限吗？”的内容。这正是*图*
    *8*.14*所展示的。
- en: Once the user accepts the request, the authorization server will generate an
    **authorization code**, which is just an opaque string that confirms the user
    did grant access to the client (LinkedIn). The authorization server will redirect
    the user back to the client (LinkedIn).
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户接受请求，授权服务器将生成一个**授权代码**，它只是一个不透明的字符串，确认用户确实授予了客户端（LinkedIn）访问权限。授权服务器将用户重定向回客户端（LinkedIn）。
- en: The authorization code is sent to the client (LinkedIn) as a query string parameter.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权代码作为查询字符串参数发送到客户端（LinkedIn）。
- en: The client (LinkedIn) now has an authorization code. Next, it will use the authorization
    code, client ID, and client secret to request an **access token** from the token
    endpoint of the authorization server. It may ask something like “Hi, I am LinkedIn.
    This user has granted me access to the contacts of this email address. This is
    my client credentials (client id and client secret). I also have an authorization
    code. Can I get access to this?”
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端（LinkedIn）现在拥有一个授权码。接下来，它将使用授权码、客户端ID和客户端密钥从授权服务器的令牌端点请求一个**访问令牌**。它可能会问：“嗨，我是LinkedIn。这个用户已经授权我访问这个电子邮件地址的联系人。这是我的客户端凭证（客户端ID和客户端密钥）。我还有一个授权码。我能访问吗？”
- en: The authorization server will verify the client credentials and the authorization
    code. If all is good, it will generate an access token and send it back to the
    client (LinkedIn). The access token is a string that can be used to access the
    protected resource. It is usually a JWT token. It may also contain the **scope**,
    which is the permission that the client (LinkedIn) has been granted. For example,
    it may be **Contacts.Read**.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将验证客户端凭证和授权码。如果一切正常，它将生成一个访问令牌并将其发送回客户端（LinkedIn）。访问令牌是一个可以用来访问受保护资源的字符串。它通常是JWT令牌。它也可能包含**作用域**，这是客户端（LinkedIn）被授予的权限。例如，它可能是**Contacts.Read**。
- en: The client (LinkedIn) can now use this access token to access the protected
    resource. It may ask something like “Hi, I am LinkedIn. I have an access token.
    Can I access the contacts of this email address?” The resource server checks the
    access token and if it is valid, it will return the protected resource to the
    client (LinkedIn).
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端（LinkedIn）现在可以使用这个访问令牌来访问受保护的资源。它可能会问：“嗨，我是LinkedIn。我有一个访问令牌。我能访问这个电子邮件地址的联系人吗？”资源服务器检查访问令牌，如果它是有效的，它将返回受保护的资源给客户端（LinkedIn）。
- en: In this way, the client can access the protected resource without knowing the
    user’s password. Because the access token has a scope, it can only access the
    protected resource within the scope. For example, if the scope is `Contacts.Read`,
    the client can only read the contacts, but it cannot modify the contacts. This
    mechanism provides a good balance between security and usability.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，客户端可以在不知道用户密码的情况下访问受保护的资源。因为访问令牌有一个作用域，它只能访问作用域内的受保护资源。例如，如果作用域是`Contacts.Read`，客户端只能读取联系人，但不能修改联系人。这种机制在安全性和可用性之间提供了良好的平衡。
- en: What is OpenID Connect?
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenID Connect 是什么？
- en: OAuth was initially designed and released in 2006 and later revised and standardized
    in 2012 as OAuth 2.0\. OAuth 2.0 solves the problem of delegated authorization.
    However, there are some other scenarios that OAuth 2.0 cannot solve. For example,
    your API may need to know the identity of the user who is accessing the API, but
    users may not want to create an account for your API. They may already have an
    account in some other services, such as Microsoft, Google, and others. In this
    case, it would be more convenient if the user could use their existing account
    to access your API. However, OAuth 2.0 was not designed to implement sign-in with
    an existing account. This is where a new specification named OpenID Connect comes
    in.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 最初于 2006 年设计和发布，后来在 2012 年作为 OAuth 2.0 进行修订和标准化。OAuth 2.0 解决了委托授权的问题。然而，还有一些其他场景
    OAuth 2.0 无法解决。例如，您的 API 可能需要知道访问 API 的用户的身份，但用户可能不想为您的 API 创建账户。他们可能已经在某些其他服务中拥有账户，例如
    Microsoft、Google 等。在这种情况下，如果用户可以使用他们现有的账户来访问您的 API，那就更方便了。然而，OAuth 2.0 并未设计用于实现使用现有账户的登录。这就是新的规范
    OpenID Connect 出现的地方。
- en: OpenID Connect is an authentication layer on top of OAuth 2.0 that was designed
    by the OpenID Foundation in 2014\. OpenID Connect is like an extension of OAuth
    2.0 that adds and defines some new features to retrieve the identity of the user,
    including profile information such as the user’s name, email address, and so on.
    OpenID Connect uses similar terminology and concepts as OAuth 2.0, such as **client**,
    **resource owner**, **authorization server**, and others. However, keep in mind
    that OpenID Connect is not a replacement for OAuth 2.0\. Instead, it is a specification
    that extends OAuth 2.0 to support authentication.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect 是 OAuth 2.0 之上的一个认证层，由 OpenID 基金会在 2014 年设计。OpenID Connect 类似于
    OAuth 2.0 的扩展，它添加并定义了一些新功能来检索用户的身份，包括用户名、电子邮件地址等个人资料信息。OpenID Connect 使用与 OAuth
    2.0 相似的术语和概念，如**客户端**、**资源所有者**、**授权服务器**等。然而，请记住，OpenID Connect 并不是 OAuth 2.0
    的替代品。相反，它是一个规范，它扩展了 OAuth 2.0 以支持认证。
- en: 'Many popular identity providers, such as Microsoft, Google, Facebook, and others,
    have implemented OpenID Connect so that you can integrate your API application
    with their identity provider. Then, users can use their existing account to sign
    into your API application. Here is an example of how OpenID Connect works on [Medium.com](http://Medium.com):'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的身份提供者，如Microsoft、Google、Facebook等，已实现了OpenID Connect，以便您可以将您的API应用程序与他们的身份提供者集成。然后，用户可以使用他们现有的账户登录到您的API应用程序。以下是在[Medium.com](http://Medium.com)上OpenID
    Connect工作的一个示例：
- en: '![Figure 8.16 – Medium.com sign-in with multiple identity providers](img/B18971_08_16.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图8.16 – Medium.com使用多个身份提供者登录](img/B18971_08_16.jpg)'
- en: Figure 8.16 – Medium.com sign-in with multiple identity providers
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 – Medium.com使用多个身份提供者登录
- en: If you click **Sign in with Google**, you will be redirected to Google to sign
    in. Then, you will be redirected back to Medium.com so that you can use your existing
    Google account to sign in to Medium.com. This is what OpenID Connect does.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击**使用Google登录**，您将被重定向到Google进行登录。然后，您将被重定向回Medium.com，以便您可以使用现有的Google账户登录到Medium.com。这就是OpenID
    Connect所做的事情。
- en: Similar to OAuth 2.0, OpenID Connect also generates an access token. It also
    introduces a new token called **ID token**, which is a JWT token that contains
    the identity of the user. The client application can inspect and validate the
    ID token to extract identity information about the user.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 与OAuth 2.0类似，OpenID Connect也会生成一个访问令牌。它还引入了一种新的令牌，称为**ID令牌**，这是一个包含用户身份信息的JWT令牌。客户端应用程序可以检查和验证ID令牌以提取有关用户身份的信息。
- en: Integrating with other identity providers
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他身份提供者集成
- en: 'Many identity providers support OpenID Connect so that you can integrate your
    API application with these platforms. Here are some popular identity providers:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 许多身份提供者支持OpenID Connect，以便您可以将您的API应用程序与这些平台集成。以下是一些流行的身份提供者：
- en: '**Microsoft**: Microsoft provides Microsoft Identity Platform for authentication
    and authorization. For more information, see [https://learn.microsoft.com/zh-cn/azure/active-directory/develop/](https://learn.microsoft.com/zh-cn/azure/active-directory/develop/).'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft**：Microsoft为身份验证和授权提供了Microsoft Identity Platform。更多信息，请参阅[https://learn.microsoft.com/zh-cn/azure/active-directory/develop/](https://learn.microsoft.com/zh-cn/azure/active-directory/develop/)。'
- en: '**Google**: Sign in with Google is a service that helps you quickly and easily
    manage user authentication and share the user’s profile information with your
    application. For more information, see [https://developers.google.com/identity/gsi/web/guides/overview](https://developers.google.com/identity/gsi/web/guides/overview).'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google**：使用Google登录是一项帮助您快速轻松地管理用户身份验证并与您的应用程序共享用户配置文件信息的服务的服务。更多信息，请参阅[https://developers.google.com/identity/gsi/web/guides/overview](https://developers.google.com/identity/gsi/web/guides/overview)。'
- en: '**Facebook**: Facebook Login is a convenient way for people to log into your
    application using their Facebook account. For more information, see [https://developers.facebook.com/products/facebook-login/](https://developers.facebook.com/products/facebook-login/).'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Facebook**：Facebook登录是人们使用他们的Facebook账户登录到您的应用程序的一种便捷方式。更多信息，请参阅[https://developers.facebook.com/products/facebook-login/](https://developers.facebook.com/products/facebook-login/)。'
- en: '**Auth0**: Auth0 is a cloud-based identity management platform that provides
    authentication, authorization, and related security services for web, mobile,
    and legacy applications. For more information, see [https://auth0.com/docs/quickstart/backend](https://auth0.com/docs/quickstart/backend).'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Auth0**：Auth0是一个基于云的身份管理平台，为Web、移动和传统应用程序提供身份验证、授权和相关安全服务。更多信息，请参阅[https://auth0.com/docs/quickstart/backend](https://auth0.com/docs/quickstart/backend)。'
- en: '**Okta**: Okta is also a cloud-based identity platform that allows organizations
    to manage and secure user authentication and authorization across multiple applications
    and services. For more information, see [https://www.okta.com/](https://www.okta.com/).'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Okta**：Okta也是一个基于云的身份平台，允许组织跨多个应用程序和服务管理并保护用户身份验证和授权。更多信息，请参阅[https://www.okta.com/](https://www.okta.com/)。'
- en: Important note
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In March 2021, Okta acquired Auth0\. However, the two companies will continue
    to operate separately. Generally, Auth0 targets smaller companies and is known
    for its developer-friendly features, but Okta is considered to be more focused
    on large enterprises and offers more advanced features such as network integration,
    single sign-on, and more.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 2021 年 3 月，Okta 收购了 Auth0。然而，两家公司将继续独立运营。通常，Auth0 面向小型公司，以其对开发者友好的功能而闻名，但 Okta
    被认为更专注于大型企业，并提供更多高级功能，如网络集成、单点登录等。
- en: 'If you need to build an identity provider yourself, there are also some open-source
    projects that you can use:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要自己构建身份提供者，也有一些开源项目你可以使用：
- en: '`IdentityServer`: `IdentityServer` is one of the most flexible and standards-compliant
    OpenID Connect and OAuth 2.0 frameworks for ASP.NET Core. It is widely used by
    many companies to secure their applications and APIs. Note that `IdentityServer`
    is open-source, but it is not free now. The last free version is IdentityServer4,
    which was released in 2021, but it is no longer maintained. Duende Software now
    provides a commercial version of `IdentityServer`. For more information, see [https://duendesoftware.com/products/identityserver](https://duendesoftware.com/products/identityserver).'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IdentityServer`：`IdentityServer` 是 ASP.NET Core 中最灵活和符合标准规范的 OpenID Connect
    和 OAuth 2.0 框架之一。许多公司使用它来保护他们的应用程序和 API。请注意，`IdentityServer` 是开源的，但现在不再是免费的。最后一个免费版本是
    2021 年发布的 IdentityServer4，但它不再维护。Duende Software 现在提供 `IdentityServer` 的商业版本。有关更多信息，请参阅
    [https://duendesoftware.com/products/identityserver](https://duendesoftware.com/products/identityserver)。'
- en: '`OpenIddict`: `OpenIddict` is an open-source OpenID Connect stack for ASP.NET
    Core. It provides a versatile solution to implement OpenID Connect client, server,
    token validation, and more. However, it is not a turnkey solution. You need to
    write some custom code to implement some business logic, such as an authorization
    controller, and more. For more information, see [https://github.com/openiddict/openiddict-core](https://github.com/openiddict/openiddict-core).'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenIddict`：`OpenIddict` 是一个针对 ASP.NET Core 的开源 OpenID Connect 栈。它提供了一个灵活的解决方案来实现
    OpenID Connect 客户端、服务器、令牌验证等。然而，它不是一个即插即用的解决方案。你需要编写一些自定义代码来实现一些业务逻辑，例如授权控制器等。有关更多信息，请参阅
    [https://github.com/openiddict/openiddict-core](https://github.com/openiddict/openiddict-core)。'
- en: '`KeyCloak`: `KeyCloak` is an open-source identity and access management solution.
    It provides features such as single sign-on, user federation, strong authentication,
    user management, fine-grained authorization, and more. It is container-based,
    so it can easily be deployed in a containerized environment. For more information,
    see [https://www.keycloak.org/](https://www.keycloak.org/).'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyCloak`：`KeyCloak` 是一个开源的身份和访问管理解决方案。它提供单点登录、用户联合、强认证、用户管理、细粒度授权等功能。它是基于容器的，因此可以轻松地在容器化环境中部署。有关更多信息，请参阅
    [https://www.keycloak.org/](https://www.keycloak.org/)。'
- en: We will not cover the details of how to integrate with these identity providers
    in this book. Please refer to the documentation instead.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中详细说明如何将这些身份提供者集成。请参阅文档。
- en: Other security topics
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他安全主题
- en: As we mentioned at the beginning of this chapter, security is a very broad topic.
    In this section, we will briefly introduce some other security topics.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，安全是一个非常广泛的话题。在本节中，我们将简要介绍一些其他安全主题。
- en: Always use Hypertext Transfer Protocol Secure (HTTPS)
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总是使用超文本传输协议安全（HTTPS）
- en: HTTPS is a protocol that provides secure communication between a client and
    a server. It is a combination of the HTTP and **Secure Sockets Layer/Transport
    Layer Security** (**SSL/TLS**) protocols. HTTPS is used to encrypt communication
    between the client and the server, ensuring that sensitive data transmitted over
    the internet is secure and cannot be intercepted by unauthorized third parties.
    Google Chrome and other modern browsers will display a warning if you try to access
    a website that does not use HTTPS. Therefore, it is very important to use HTTPS
    for all your web applications.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 是一种协议，它为客户端和服务器之间提供安全的通信。它是 HTTP 和 **安全套接字层/传输层安全性**（**SSL/TLS**）协议的结合。HTTPS
    用于加密客户端和服务器之间的通信，确保通过互联网传输的敏感数据安全，并且不能被未经授权的第三方截获。如果你尝试访问一个不使用 HTTPS 的网站，Google
    Chrome 和其他现代浏览器将显示警告。因此，为所有你的网络应用程序使用 HTTPS 非常重要。
- en: The default ASP.NET Core web API template can use both HTTP and HTTPS. It is
    recommended to use HTTPS only. So, we need to configure the project to redirect
    all HTTP requests to HTTPS.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的ASP.NET Core Web API模板可以使用HTTP和HTTPS。建议只使用HTTPS。因此，我们需要配置项目以将所有HTTP请求重定向到HTTPS。
- en: 'To do that, we need to add the following code to the `Program.cs` file:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要将以下代码添加到`Program.cs`文件中：
- en: '[PRE71]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This code applies the `UseHttpsRedirection` middleware to redirect HTTP requests
    to HTTPS.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码应用了`UseHttpsRedirection`中间件，将HTTP请求重定向到HTTPS。
- en: When you run the application locally, ASP.NET Core will automatically generate
    a self-signed certificate and use it to encrypt communication. However, when you
    deploy the application to a production environment, you need to use a certificate
    issued by a trusted **certificate authority** (**CA**), such as DigiCert, Comodo,
    GeoTrust, and so on.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本地运行应用程序时，ASP.NET Core将自动生成一个自签名证书并使用它来加密通信。然而，当你将应用程序部署到生产环境时，你需要使用由受信任的**证书颁发机构**（**CA**）签发的证书，例如DigiCert、Comodo、GeoTrust等。
- en: Using a strong password policy
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用强密码策略
- en: The default password policy we implemented in previous sections is not secure
    enough. Users can use any password, which might be a security risk. It is important
    to force users to use strong, unique passwords that are difficult for others to
    guess or crack. Generally, a good password should be a combination of uppercase
    and lowercase letters, numbers, and special characters. The length of the password
    should be at least 8 characters. We can define a password policy to enforce these
    rules.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前章节中实现的默认密码策略不够安全。用户可以使用任何密码，这可能会带来安全风险。强制用户使用强大、唯一的密码，对他人难以猜测或破解，这一点非常重要。通常，一个好的密码应该是由大小写字母、数字和特殊字符的组合。密码长度至少为8个字符。我们可以定义一个密码策略来强制执行这些规则。
- en: 'We can specify the password policy in the `Program` class. Add the following
    code after the `AddAuthentication()` method:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Program`类中指定密码策略。在`AddAuthentication()`方法之后添加以下代码：
- en: '[PRE72]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The preceding code is easy to understand. In this example, we require the password
    to contain at least one uppercase letter, one lowercase letter, one number, and
    one special character, and the length of the password should be at least 8 characters.
    We also require the user’s email to be unique. So, if a user tries to register
    with an email that is already in use, the registration will fail. Now, the user’s
    password should be hard to guess.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码易于理解。在这个例子中，我们要求密码至少包含一个大小写字母、一个数字和一个特殊字符，并且密码长度至少为8个字符。我们还要求用户的电子邮件必须是唯一的。因此，如果用户尝试使用已存在的电子邮件进行注册，注册将失败。现在，用户的密码应该难以猜测。
- en: 'We can also enforce the password policy when the user fails to log in. For
    example, if the user fails to log in three times, the account will be locked for
    5 minutes. This can help prevent brute-force attacks. To enable this feature,
    add the following code after the `AddAuthentication()` method:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在用户登录失败时强制执行密码策略。例如，如果用户连续三次登录失败，账户将被锁定5分钟。这有助于防止暴力攻击。要启用此功能，在`AddAuthentication()`方法之后添加以下代码：
- en: '[PRE73]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This change works when we use `SignInManager.CheckPasswordSignInAsync()` method
    to sign in. In previous examples, we used `UserManager`. So, we need to update
    the `Login()` method in the `AuthenticationController` class. First, we need to
    inject `SignInManager` into the controller. Then, we must update the `AuthenticationController`
    class, as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`SignInManager.CheckPasswordSignInAsync()`方法进行登录时，此更改将生效。在之前的例子中，我们使用了`UserManager`。因此，我们需要更新`AuthenticationController`类中的`Login()`方法。首先，我们需要将`SignInManager`注入到控制器中。然后，我们必须更新`AuthenticationController`类，如下所示：
- en: '[PRE74]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The preceding code uses the `SignInManager.CheckPasswordSignInAsync()` method
    to sign in, which has a parameter named `lockoutOnFailure` that specifies whether
    the account should be locked out when the user fails to log in. The default value
    is `false`, so we need to use `true` to enable the lockout feature.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码使用了`SignInManager.CheckPasswordSignInAsync()`方法进行登录，该方法有一个名为`lockoutOnFailure`的参数，用于指定当用户登录失败时是否应该锁定账户。默认值是`false`，因此我们需要使用`true`来启用锁定功能。
- en: 'Note that if you use `AddIdentityCore<AppUser>()` in `Program.cs`, as we mentioned
    in the previous section, `SignInManager` is not available by default. In this
    case, you need to explicitly add the `SignInManager` service to the `ConfigureServices()`
    method, like this:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你在 `Program.cs` 中使用 `AddIdentityCore<AppUser>()`，正如我们在上一节中提到的，`SignInManager`
    默认不可用。在这种情况下，你需要显式地将 `SignInManager` 服务添加到 `ConfigureServices()` 方法中，如下所示：
- en: '[PRE75]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let’s test the application. Run the application using `dotnet run` and create
    a new user using the `Register` API. You will find that if the password is too
    simple, you will get an error message. Here is a sample request:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试这个应用程序。使用 `dotnet run` 运行应用程序，并使用 `Register` API 创建一个新用户。你会发现，如果密码太简单，你会收到一个错误信息。以下是一个示例请求：
- en: '[PRE76]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You will get a `400` response with the following error message:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到一个 `400` 响应，并显示以下错误信息：
- en: '[PRE77]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If you attempt to log in with an incorrect password more than three times, you
    will be locked out of the system for 5 minutes. During this period, you will not
    be able to access the system, even if you enter the correct password. After those
    5 minutes have elapsed, you will be able to log in again.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用错误的密码登录超过三次，你将被锁定系统5分钟。在此期间，即使你输入正确的密码，也无法访问系统。5分钟后，你将能够再次登录。
- en: Implementing two-factor authentication (2FA)
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现双因素认证（2FA）
- en: 2FA is a security process that requires users to provide two different forms
    of authentication to verify their identity. Besides the common username and password,
    2FA adds an extra layer of security by requiring users to provide a second authentication
    factor, such as a code sent to their mobile phone or authenticator app, fingerprint,
    face recognition, and so on. This makes it harder for hackers to gain access to
    user accounts. Even if the hacker gets the user’s password, they still cannot
    get the second factor. 2FA is widely used in banking and financial services to
    protect users’ sensitive information.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 双因素认证（2FA）是一种需要用户提供两种不同形式的认证以验证其身份的安全流程。除了常见的用户名和密码外，2FA通过要求用户提供第二个认证因素（如发送到其手机或认证器应用程序的代码、指纹、面部识别等）来增加一个额外的安全层。这使得黑客更难访问用户账户。即使黑客获得了用户的密码，他们仍然无法获取第二个因素。2FA在银行和金融服务中广泛使用，以保护用户的敏感信息。
- en: '**Multi-factor authentication** (**MFA**) is a superset of 2FA. It requires
    users to provide more than two factors to verify their identity. There are two
    types of MFA:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**多因素认证**（**MFA**）是双因素认证（2FA）的超集。它要求用户提供超过两个因素来验证其身份。有两种类型的MFA：'
- en: '**MFA Time-based One-Time Password** (**TOTP**): MFA TOTP is a type of MFA
    that requires users to provide a code generated by an authenticator app (such
    as Google Authenticator or Microsoft Authenticator). The code is valid for a short
    period, usually 30 seconds. After the code expires, the user needs to generate
    a new code. This type of MFA is widely used in banking and financial services.
    If you use a bank app, you might have seen this type of MFA. It requires the server
    and authenticator app to have an accurate time.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于时间的多因素认证一次性密码**（**TOTP**）：基于时间的多因素认证TOTP是一种需要用户通过认证器应用程序（如Google Authenticator或Microsoft
    Authenticator）生成代码的多因素认证。该代码的有效期很短，通常为30秒。代码过期后，用户需要生成一个新的代码。这种类型的多因素认证在银行和金融服务中广泛使用。如果你使用银行应用程序，你可能已经见过这种类型的多因素认证。它要求服务器和认证器应用程序具有准确的时间。'
- en: '**MFA Fast Identity Online 2** (**FIDO2**): MFA FIDO2 is a type of MFA that
    requires users to authenticate using a hardware key, such as a USB key or a biometric
    device (such as a fingerprint scanner). It has become more popular in recent years.
    However, ASP.NET Core does not support FIDO2 directly yet.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速身份在线2**（**FIDO2**）：基于FIDO2的多因素认证要求用户使用硬件密钥（如USB密钥或生物识别设备，如指纹扫描仪）进行认证。近年来，它变得越来越受欢迎。然而，ASP.NET
    Core目前尚不支持FIDO2。'
- en: '**MFA SMS**: MFA SMS is no longer recommended because there are many security
    issues with SMS.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于短信的多因素认证**（**MFA SMS**）：基于短信的多因素认证不再推荐，因为短信存在许多安全问题。'
- en: To learn more about MFA, please refer to [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于多因素认证（MFA）的信息，请参阅[https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa)。
- en: Implementing rate-limiting
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现速率限制
- en: Rate-limiting is a security mechanism that limits the number of requests a client
    can make to a server. It can prevent malicious clients from making too many requests,
    which can cause a **denial of service** (**DoS**) attack. ASP.NET Core provides
    a built-in rate-limiting middleware. We explained how to use it in [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制是一种安全机制，限制客户端可以向服务器发送的请求数量。它可以防止恶意客户端发送过多的请求，这可能导致 **拒绝服务**（**DoS**）攻击。ASP.NET
    Core 提供了内置的速率限制中间件。我们在 [*第 4 章*](B18971_04.xhtml#_idTextAnchor170) 中解释了如何使用它。
- en: Using model validation
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模型验证
- en: Model validation is a security mechanism that prevents malicious users from
    sending invalid data to the server. We should always validate the data sent by
    the client. In other words, the client is not trusted. For example, we expect
    a property in the model to be an integer, but what if the client sends a string?
    The application should be able to handle this situation and reject the request
    directly before executing any business logic.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 模型验证是一种安全机制，可以防止恶意用户向服务器发送无效数据。我们应该始终验证客户端发送的数据。换句话说，客户端是不可信的。例如，我们期望模型中的一个属性是整数，但客户端发送字符串怎么办？应用程序应该能够处理这种情况，并在执行任何业务逻辑之前直接拒绝请求。
- en: 'ASP.NET Core provides a built-in model binding and model validation mechanism.
    Model binding is used to convert the data sent by the client to the corresponding
    model. The data sent by the client can be in different formats, such as JSON,
    XML, form fields, or query strings. Model validation is used to check whether
    the data sent by the client is valid. We used model validation in the previous
    sections. For example, here is the code we used to register a new user:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了内置的模型绑定和模型验证机制。模型绑定用于将客户端发送的数据转换为相应的模型。客户端发送的数据可以有不同的格式，例如 JSON、XML、表单字段或查询字符串。模型验证用于检查客户端发送的数据是否有效。我们在前面的章节中使用了模型验证。例如，以下是注册新用户时我们使用的代码：
- en: '[PRE78]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `ModelState.IsValid` property represents whether the model is valid. So,
    how does ASP.NET Core validate the model? Look at the `AddOrUpdateAppUserModel`
    class:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelState.IsValid` 属性表示模型是否有效。那么，ASP.NET Core 是如何验证模型的呢？看看 `AddOrUpdateAppUserModel`
    类：'
- en: '[PRE79]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We use the validation attributes to specify the validation rules. For example,
    `Required` is a built-in attribute annotation that specifies that the property
    is required. Here are some of the most commonly used ones besides `Required`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用验证属性来指定验证规则。例如，`Required` 是一个内置属性注释，指定该属性是必需的。除了 `Required` 之外，还有一些最常用的属性：
- en: '`CreditCard`: This specifies that the property must be a valid credit card
    number'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreditCard`: 这指定了该属性必须是一个有效的信用卡号'
- en: '`EmailAddress`: This specifies that the property must be a valid email address'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailAddress`: 这指定了该属性必须是一个有效的电子邮件地址'
- en: '`Phone`: This specifies that the property must be a valid phone number'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phone`: 这指定了该属性必须是一个有效的电话号码'
- en: '`Range`: This specifies that the property must be within a specified range'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range`: 这指定了该属性必须在一个指定的范围内'
- en: '`RegularExpression`: This specifies that the property must match a specified
    regular expression'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegularExpression`: 这指定了该属性必须匹配指定的正则表达式'
- en: '`StringLength`: This specifies that the property must be a string with a specified
    length'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringLength`: 这指定了该属性必须是一个具有指定长度的字符串'
- en: '`Url`: This specifies that the property must be a valid URL'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Url`: 这指定了该属性必须是一个有效的 URL'
- en: '`Compare`: This specifies that the property must be the same as another property'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compare`: 这指定了该属性必须与另一个属性相同'
- en: 'If these built-in attributes cannot meet your requirements, you can also create
    custom attributes. For example, you can create an `Adult` attribute to validate
    the age of the user based on the user’s birthday:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些内置属性无法满足您的需求，您也可以创建自定义属性。例如，您可以创建一个 `Adult` 属性来根据用户的生日验证用户的年龄：
- en: '[PRE80]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, you can use the `Adult` attribute in the model:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在模型中使用 `Adult` 属性：
- en: '[PRE81]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can also manually validate the model in the controller. For example, you
    can check whether the user’s email is unique:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在控制器中手动验证模型。例如，您可以检查用户的电子邮件是否唯一：
- en: '[PRE82]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the preceding code, we use the `AddModelError()` method to add a validation
    error to the model. The `ModelState.IsValid` property will return `false` if there
    is any validation error. In [*Chapter 16*](B18971_16.xhtml#_idTextAnchor671),
    we will discuss how to use the `ProblemDetails` class to return error information
    to the client and how to use `FluentValidation` to validate the model for more
    complex scenarios. You can refer to that chapter for more information.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`AddModelError()`方法向模型添加验证错误。如果存在任何验证错误，`ModelState.IsValid`属性将返回`false`。在[*第16章*](B18971_16.xhtml#_idTextAnchor671)中，我们将讨论如何使用`ProblemDetails`类向客户端返回错误信息，以及如何使用`FluentValidation`对模型进行更复杂场景的验证。您可以参考该章节以获取更多信息。
- en: Using parameterized queries
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用参数化查询
- en: 'We explained how to use EF Core to execute SQL queries in previous chapters.
    Generally, if you use LINQ to query data, EF Core will generate parameterized
    queries for you. However, you need to take care of SQL injection attacks when
    you use the following methods:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中解释了如何使用EF Core执行SQL查询。通常，如果您使用LINQ查询数据，EF Core会为您生成参数化查询。但是，当您使用以下方法时，您需要小心SQL注入攻击：
- en: '`FromSqlRaw()`'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromSqlRaw()`'
- en: '`SqlQeuryRaw()`'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SqlQeuryRaw()`'
- en: '`ExecuteSqlRaw()`'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecuteSqlRaw()`'
- en: These methods allow you to execute raw SQL queries without sanitizing the input.
    So, please make sure you sanitize the query statements before executing them.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法允许您在不清理输入的情况下执行原始SQL查询。因此，请在执行之前确保清理查询语句。
- en: Using data protection
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据保护
- en: Data protection is a security mechanism that prevents malicious users from accessing
    sensitive data. For example, if you store the user’s password in the database,
    you should encrypt it before storing it. Another example is the user’s credit
    card number, which should also be encrypted before it is stored.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 数据保护是一种安全机制，它阻止恶意用户访问敏感数据。例如，如果您在数据库中存储用户的密码，您应该在存储之前对其进行加密。另一个例子是用户的信用卡号，也应该在存储之前进行加密。
- en: 'The reason for this is that if the database is compromised, the attacker can
    easily access the user’s sensitive data. In other words, the database is not trusted,
    just like the client. Data protection is another big topic, but it is beyond the
    scope of this book. ASP.NET Core provides a built-in data protection mechanism.
    If you would like to learn more about it, please refer to the official documentation:
    [https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction](https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction).'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果数据库遭到破坏，攻击者可以轻易地访问用户的敏感数据。换句话说，数据库不可信，就像客户端一样。数据保护是另一个重要话题，但超出了本书的范围。ASP.NET
    Core提供了一个内置的数据保护机制。如果您想了解更多信息，请参阅官方文档：[https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction](https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction)。
- en: Keeping secrets safe
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护秘密安全
- en: Secrets are sensitive data that should not be exposed to the public. In our
    applications, we may have many secrets, such as the database connection string,
    the API keys, the client secrets, and so on. In the previous chapters, we often
    stored them in the `appsettings.json` file. However, we need to emphasize that
    this is not a good practice. These secrets should be stored in a safe place, such
    as Azure Key Vault, AWS Secrets Manager, or `kube-secrets`. Never upload them
    to the source code repository.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密是敏感数据，不应向公众公开。在我们的应用程序中，我们可能有多个秘密，例如数据库连接字符串、API密钥、客户端密钥等。在前面的章节中，我们经常将它们存储在`appsettings.json`文件中。然而，我们需要强调这不是一个好的做法。这些秘密应该存储在安全的地方，例如Azure
    Key Vault、AWS Secrets Manager或`kube-secrets`。永远不要将它们上传到源代码仓库。
- en: We will introduce **continuous integration/continuous deployment** (**CI/CD**)
    and explain how to store secrets safely in [*Chapter 14*](B18971_14.xhtml#_idTextAnchor585).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第14章*](B18971_14.xhtml#_idTextAnchor585)中介绍**持续集成/持续部署**（**CI/CD**）并解释如何安全地存储秘密。
- en: Keeping the framework up to date
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持框架更新
- en: 'The .NET Core framework is an open-source project. It is constantly being updated.
    We should always keep the framework up to date, including the NuGet packages.
    Note the life cycle of the .NET Core framework. Use the latest version of the
    framework as much as possible. If you are using an older version, you should consider
    upgrading it. You can find the life cycle of the .NET Core framework here: [https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core](https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core).'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 框架是一个开源项目。它不断在更新。我们应该始终保持框架的最新状态，包括 NuGet 包。注意 .NET Core 框架的生命周期。尽可能使用框架的最新版本。如果你正在使用较旧版本，你应该考虑升级它。你可以在这里找到
    .NET Core 框架的生命周期：[https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core](https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core)。
- en: Checking the Open Web Application Security Project (OWASP) Top 10
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 Open Web Application Security Project (OWASP) Top 10
- en: 'OWASP is a nonprofit organization that provides information about web application
    security. It publishes a list of the most common web application security risks,
    which is called the OWASP Top 10\. You can find the OWASP Top 10 here: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/).
    You should check the list regularly to make sure your application is not vulnerable
    to any of the risks.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP 是一个非营利组织，提供有关 Web 应用程序安全性的信息。它发布了一份最常见的 Web 应用程序安全风险列表，称为 OWASP Top 10。你可以在这里找到
    OWASP Top 10：[https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)。你应该定期检查列表，以确保你的应用程序不会受到任何风险的威胁。
- en: 'Also, OWASP provides a free resource called *DotNet Security Cheat Sheet*,
    where you can find the best practices for securing .NET Core applications. You
    can find it here: [https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html).'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，OWASP 提供了一个名为 *DotNet Security Cheat Sheet* 的免费资源，其中包含了确保 .NET Core 应用程序安全性的最佳实践。你可以在这里找到它：[https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html)。
- en: Summary
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the security and identity features of ASP.NET
    Core. We mainly learned how to use its built-in authentication and authorization
    mechanisms. We learned how to use the Identity framework to manage users and roles,
    and also explained role-based authorization, claim-based authorization, and policy-based
    authorization.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 ASP.NET Core 的安全和身份功能。我们主要学习了如何使用其内置的认证和授权机制。我们学习了如何使用 Identity 框架来管理用户和角色，并解释了基于角色的授权、基于声明的授权和基于策略的授权。
- en: Then, we introduced OAuth 2.0 and OpenID Connect, which are the most popular
    authentication and authorization standards. After that, we explained several security
    practices, such as using HTTPS, strong passwords, parameterized queries, and more.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了 OAuth 2.0 和 OpenID Connect，它们是最受欢迎的认证和授权标准。之后，我们解释了几个安全实践，例如使用 HTTPS、强密码、参数化查询等。
- en: Again, security is a big topic, and we cannot cover all the details in one chapter.
    Please treat security as a continuous process, and always keep your application
    secure.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，安全性是一个大主题，我们无法在一章中涵盖所有细节。请将安全性视为一个持续的过程，并始终确保你的应用程序安全。
- en: In the next chapter, we will get starssseted with testing, which is an important
    part of any software project. We will learn how to write unit tests for ASP.NET
    Core applications.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始测试，这是任何软件项目的重要部分。我们将学习如何为 ASP.NET Core 应用程序编写单元测试。
