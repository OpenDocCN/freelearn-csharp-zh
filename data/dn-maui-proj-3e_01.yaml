- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to .NET MAUI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET MAUI简介
- en: This chapter is all about getting to know **.NET Multi-platform App UI** (**.NET
    MAUI**) and what to expect from it. .NET MAUI enables you to build native cross-platform
    mobile and desktop apps for Android, iOS, macOS, and Windows using .NET and C#.
    This is the only chapter that is purely theoretical; all the others cover hands-on
    projects. You are not expected to write any code at this point, but instead, simply
    read through this chapter to develop a high-level understanding of what .NET MAUI
    is, how .NET MAUI relates to .NET, and how to set up a development machine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍如何了解**.NET多平台应用程序用户界面**（.NET MAUI）以及可以期待它带来什么。.NET MAUI允许您使用.NET和C#构建针对Android、iOS、macOS和Windows的原生跨平台移动和桌面应用。这是唯一一个纯粹理论性的章节；其他所有章节都涵盖实际项目。在这个阶段，您不需要编写任何代码，而是简单地阅读本章，以形成一个高级理解.NET
    MAUI是什么，.NET MAUI如何与.NET相关联，以及如何设置开发机器。
- en: We will start by defining what a native app is and what .NET as a technology
    brings to the table. After that, we will look at how .NET MAUI fits into the bigger
    picture and learn when it is appropriate to use the traditional .NET mobile and
    .NET MAUI apps. We often use the term **traditional .NET mobile app** to describe
    apps that don’t use .NET MAUI, even though .NET MAUI apps are bootstrapped through
    a traditional .NET mobile app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义什么是原生应用，以及.NET作为一项技术带来了什么。然后，我们将探讨.NET MAUI如何融入更大的图景，并了解何时使用传统的.NET移动和.NET
    MAUI应用是合适的。我们经常使用“传统.NET移动应用”这个术语来描述不使用.NET MAUI的应用，即使.NET MAUI应用是通过传统的.NET移动应用启动的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining native applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义原生应用
- en: .NET mobile
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET移动
- en: Exploring the .NET MAUI framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索.NET MAUI框架
- en: Setting up our development machine
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的开发机器
- en: .NET mobile productivity tooling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET移动生产力工具
- en: Let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Defining native applications
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义原生应用
- en: 'The term **native application** means different things to different people.
    For some people, it refers to an app that is developed using the tools specified
    by the creator of the platform, such as an app developed for iOS with Objective-C
    or Swift, an Android app developed with Java or Kotlin, or a Windows app developed
    with C/C++ or the .NET Framework. Others use the term native application to refer
    to apps that are compiled into machine code that is native to the platform architecture,
    for example, x86, x64, or ARM. In this book, we will define a native application
    as one that has a native UI, performance, and API access. The following list explains
    these three concepts in greater detail:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “原生应用”这个术语对不同的人有不同的含义。对一些人来说，它指的是使用平台创建者指定的工具开发的应用，例如使用Objective-C或Swift开发的iOS应用，使用Java或Kotlin开发的Android应用，或使用C/C++或.NET
    Framework开发的Windows应用。其他人使用“原生应用”一词来指代编译成平台架构的机器码的应用，例如x86、x64或ARM。在这本书中，我们将原生应用定义为具有原生UI、性能和API访问的应用。以下列表更详细地解释了这三个概念：
- en: '**Native UI**: Apps built with .NET MAUI use the standard controls for each
    platform. This means, for example, that an iOS app built with .NET MAUI will look
    and behave as an iOS user would expect and an Android app built with .NET MAUI
    will look and behave as an Android user would expect.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生UI**：使用.NET MAUI构建的应用使用每个平台的标准控件。这意味着，例如，使用.NET MAUI构建的iOS应用将看起来和表现得像一个iOS用户所期望的那样，而使用.NET
    MAUI构建的Android应用将看起来和表现得像一个Android用户所期望的那样。'
- en: '**Native performance**: Apps built with .NET MAUI are compiled for native performance,
    meaning that they execute at nearly the same levels as apps built with the tools
    designed for the platform, that is, Java or Swift, and can use platform-specific
    hardware acceleration.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生性能**：使用.NET MAUI构建的应用针对原生性能进行编译，这意味着它们的执行速度几乎与为平台设计的工具构建的应用相同，即Java或Swift，并且可以使用平台特定的硬件加速。'
- en: '**Native API access**: Native API access means that apps built with .NET MAUI
    can use everything that the target platforms and devices offer to developers.
    For example, .NET MAUI applications can use hardware-specific features such as
    the camera or maps.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生API访问**：原生API访问意味着使用.NET MAUI构建的应用可以访问目标平台和设备为开发者提供的一切。例如，.NET MAUI应用可以使用特定的硬件功能，如相机或地图。'
- en: .NET mobile
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET移动
- en: .NET mobile (formerly known as Xamarin) is a set of extensions to .NET that
    is used to develop native applications for iOS (**.NET for iOS/tvOS/Mac Catalyst**),
    Android (**.NET for Android**), and macOS (**.NET for macOS**). .NET is the evolution
    of the .NET Framework, designed for cross-platform development. .NET mobile was
    introduced in .NET Core 5 as optional workloads. It is technically a binding layer
    on top of these platforms. Using bindings to platform APIs enables .NET developers
    to use C# (and F#) to develop native applications with the full capacity of each
    platform.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 移动（以前称为 Xamarin）是一组用于开发 iOS（**.NET for iOS/tvOS/Mac Catalyst**）、Android（**.NET
    for Android**）和 macOS（**.NET for macOS**）原生应用程序的 .NET 扩展。.NET 是 .NET Framework
    的演变，旨在进行跨平台开发。.NET 移动是在 .NET Core 5 中作为可选工作负载引入的。从技术上讲，它是在这些平台之上的绑定层。使用绑定到平台 API
    可以使 .NET 开发者能够使用 C#（和 F#）利用每个平台的全部能力来开发原生应用程序。
- en: The C# APIs we use when we develop apps with .NET mobile match the platform
    APIs, but they are modified to adhere to conventions used in .NET Core. For example,
    APIs are often customized to follow .NET naming conventions, and the Android `set`
    and `get` methods are often replaced by properties. This makes using the APIs
    easier and more familiar for .NET developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 .NET 移动开发应用程序时，我们使用的 C# API 与平台 API 匹配，但它们被修改以符合 .NET Core 中的约定。例如，API
    通常被定制以遵循 .NET 命名约定，Android 的 `set` 和 `get` 方法通常被属性替换。这使得使用 API 对 .NET 开发者来说更容易也更熟悉。
- en: '**Mono** ([https://www.mono-project.com](https://www.mono-project.com)) is
    an open source implementation of the Microsoft .NET Framework, which is based
    on the **European Computer Manufacturers Association** (**ECMA**) standards for
    C# and the **Common Language Runtime** (**CLR**). Mono was created to bring the
    .NET Framework to platforms other than Windows. It is part of the .NET Foundation
    ([http://www.dotnetfoundation.org](http://www.dotnetfoundation.org)), an independent
    organization that supports open development and collaboration involving the .NET
    ecosystem. Since .NET 5, Mono is now a supported runtime for applications built
    on .NET. No separate installer is needed to use Mono with .NET; it is included
    in the installer for .NET. The Mono runtime is used for iOS, tvOS, Mac Catalyst,
    and Android applications, while the .NET Core CLR is used for all other supported
    platforms.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mono** ([https://www.mono-project.com](https://www.mono-project.com)) 是微软
    .NET Framework 的开源实现，它基于欧洲计算机制造商协会（**ECMA**）的 C# 标准和 **通用语言运行时（CLR**）。Mono 的创建是为了将
    .NET Framework 带到除 Windows 之外的平台。它是 .NET 基金会（[http://www.dotnetfoundation.org](http://www.dotnetfoundation.org)）的一部分，这是一个支持涉及
    .NET 生态系统的开放开发和协作的独立组织。自 .NET 5 以来，Mono 现在是 .NET 上构建的应用程序的支持运行时。使用 Mono 与 .NET
    无需单独的安装程序；它包含在 .NET 安装程序中。Mono 运行时用于 iOS、tvOS、Mac Catalyst 和 Android 应用程序，而 .NET
    Core CLR 用于所有其他支持的平台。'
- en: With a combination of the .NET mobile platforms, .NET, and Mono, we can use
    both the platform-specific APIs and the platform-independent parts of .NET, including
    namespaces such as `System`, `System.Linq`, `System.IO`, `System.Net`, and `System.Threading.Tasks`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合 .NET 移动平台、.NET 和 Mono，我们可以使用特定平台的 API 以及 .NET 的平台无关部分，包括 `System`、`System.Linq`、`System.IO`、`System.Net`
    和 `System.Threading.Tasks` 等命名空间。
- en: There are several reasons for using .NET mobile for mobile app development,
    which we will cover in the following sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET 移动进行移动应用程序开发有几个原因，我们将在以下章节中介绍。
- en: Code sharing
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码共享
- en: 'If we use one common programming language for multiple mobile platforms (and
    even server platforms), then we can share a lot of code between our target platforms,
    as illustrated in the following diagram. All code that isn’t related to the target
    platform can be shared with other .NET platforms. Code that is typically shared
    in this way includes business logic, network calls, and data models:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为多个移动平台（甚至服务器平台）使用一种通用的编程语言，那么我们可以在我们的目标平台之间共享大量代码，如下面的图示所示。所有与目标平台无关的代码都可以与其他
    .NET 平台共享。以这种方式共享的代码通常包括业务逻辑、网络调用和数据模型：
- en: '![Figure 1.1 – .NET MAUI code sharing](img/Figure_1.1_B19214.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – .NET MAUI 代码共享](img/Figure_1.1_B19214.jpg)'
- en: Figure 1.1 – .NET MAUI code sharing
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – .NET MAUI 代码共享
- en: There is also a large community based around the .NET platforms, providing a
    different form of code sharing. There is a wide range of third-party libraries
    and components that can be downloaded from NuGet ([https://nuget.org](https://nuget.org))
    that can provide you with additional features or capabilities that work across
    all supported .NET MAUI platforms. For example, you can find NuGet packages that
    provide databases, graphs, or barcode reading to include in your apps.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 平台周围也有一个庞大的社区，提供不同形式的代码共享。可以从 NuGet ([https://nuget.org](https://nuget.org))
    下载各种第三方库和组件，这些库和组件可以为您提供额外的功能或能力，这些功能或能力可以在所有支持的 .NET MAUI 平台上工作。例如，您可以找到提供数据库、图形或条形码读取的
    NuGet 包，以便包含在您的应用程序中。
- en: Code sharing across platforms leads to shorter development times. It also produces
    apps of a higher quality because, for example, we only need to write the code
    for business logic once. There is a lower risk of bugs, and it is also able to
    guarantee that a calculation returns the same result, regardless of what platform
    our users use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台代码共享可以缩短开发时间。它还产生了更高品质的应用程序，例如，我们只需要编写一次业务逻辑的代码。降低错误的风险，并且也能保证无论用户使用什么平台，计算都能返回相同的结果。
- en: Use of existing knowledge
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用现有知识
- en: For .NET developers who want to start building native mobile apps, it is easier
    to just learn the APIs for the new platforms than it is to learn programming languages
    and APIs for both old and new platforms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要开始构建原生移动应用的 .NET 开发者来说，学习新平台的 API 比学习旧平台和新平台的编程语言和 API 更容易。
- en: Similarly, organizations that want to build native mobile apps can use existing
    developers with their knowledge of .NET to develop apps. Because there are more
    .NET developers than Objective-C and Swift developers, it’s easier to find new
    developers for mobile app development projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，想要构建原生移动应用的组织可以使用熟悉 .NET 的现有开发者来开发应用程序。由于 .NET 开发者比 Objective-C 和 Swift 开发者多，因此更容易为移动应用开发项目找到新的开发者。
- en: .NET mobile platforms
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 移动平台
- en: The different .NET mobile platforms available are .NET for iOS/tvOS/Mac Catalyst,
    .NET for Android, and .NET for macOS. In this section, we will take a look at
    each of them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的不同 .NET 移动平台包括 .NET for iOS/tvOS/Mac Catalyst、.NET for Android 和 .NET for
    macOS。在本节中，我们将查看每个平台。
- en: .NET for iOS/tvOS/Mac Catalyst
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET for iOS/tvOS/Mac Catalyst
- en: '.NET for iOS/tvOS/Mac Catalyst is used to build apps for iOS, tvOS, or Mac
    Catalyst, respectively, with .NET and contains the bindings to the iOS APIs mentioned
    previously. .NET for iOS/tvOS/Mac Catalyst uses `System.Linq` or `System.Net`,
    is executed by the Mono runtime, while code that uses iOS-specific namespaces
    is executed by the Objective-C runtime. Both the Mono runtime and the Objective-C
    runtime run on top of the **X is Not Unix** (**XNU**) Unix-like kernel ([https://github.com/apple/darwin-xnu](https://github.com/apple/darwin-xnu)),
    which was developed by Apple. The following diagram shows an overview of the iOS
    architecture:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: .NET for iOS/tvOS/Mac Catalyst 用于使用 .NET 分别构建 iOS、tvOS 或 Mac Catalyst 应用程序，并包含之前提到的
    iOS API 的绑定。.NET for iOS/tvOS/Mac Catalyst 使用 `System.Linq` 或 `System.Net`，由 Mono
    运行时执行，而使用 iOS 特定命名空间的代码则由 Objective-C 运行时执行。Mono 运行时和 Objective-C 运行时都运行在 **X
    is Not Unix** (**XNU**) 类 Unix 内核之上 ([https://github.com/apple/darwin-xnu](https://github.com/apple/darwin-xnu))，该内核由苹果公司开发。以下图展示了
    iOS 架构的概述：
- en: '![Figure 1.2 – .NET for iOS](img/Figure_1.2_B19214.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – .NET for iOS](img/Figure_1.2_B19214.jpg)'
- en: Figure 1.2 – .NET for iOS
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – .NET for iOS
- en: .NET for macOS
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET for macOS
- en: '.NET for macOS is used to build apps for macOS with .NET and contains the bindings
    to the macOS APIs. .NET for macOS has the same architecture as .NET for iOS—the
    only difference is, .NET for macOS apps are **just-in-time** (**JIT**)-compiled,
    unlike .NET for iOS apps, which are AOT-compiled. This is shown in the following
    diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: .NET for macOS 用于使用 .NET 构建 macOS 应用程序，并包含对 macOS API 的绑定。.NET for macOS 与 .NET
    for iOS 具有相同的架构——唯一的区别是，.NET for macOS 应用程序是即时编译的（**JIT**），而 .NET for iOS 应用程序是
    AOT 编译的。这将在以下图中展示：
- en: '![Figure 1.3 – .NET for macOS](img/Figure_1.3._B19214.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – .NET for macOS](img/Figure_1.3._B19214.jpg)'
- en: Figure 1.3 – .NET for macOS
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – .NET for macOS
- en: .NET for Android
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET for Android
- en: .NET for Android is used to build apps for Android with .NET and contains bindings
    to the Android APIs. The Mono runtime and the **Android Runtime** (**ART**) run
    side by side on top of a Linux kernel. .NET for Android apps could either be JIT-compiled
    or AOT-compiled, but to AOT-compile them, we need to use Visual Studio Enterprise.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: .NET for Android 用于使用 .NET 构建安卓应用，并包含对安卓 API 的绑定。Mono 运行时和 Android 运行时（**ART**）在
    Linux 内核之上并行运行。.NET for Android 应用可以是 JIT 编译或 AOT 编译，但为了进行 AOT 编译，我们需要使用 Visual
    Studio Enterprise。
- en: 'Communication between the Mono runtime and ART occurs via a **Java Native Interface**
    (**JNI**) bridge. There are two types of JNI bridges—**Manage Callable Wrapper**
    (**MCW**) and **Android Callable Wrapper** (**ACW**). An MCW is used when code
    needs to run in ART and an ACW is used when ART needs to run code in the Mono
    runtime, as shown:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Mono 运行时和 ART 之间的通信通过 **Java 本地接口**（**JNI**）桥进行。有两种类型的 JNI 桥——**管理可调用包装器**（**MCW**）和
    **安卓可调用包装器**（**ACW**）。当代码需要在 ART 中运行时使用 MCW，而当 ART 需要在 Mono 运行时中运行代码时使用 ACW，如下所示：
- en: '![Figure 1.4 – .NET for Android](img/Figure_1.4._B19214.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – .NET for Android](img/Figure_1.4._B19214.jpg)'
- en: Figure 1.4 – .NET for Android
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – .NET for Android
- en: .NET for Tizen
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: .NET for Tizen
- en: .NET MAUI has additional support for the Tizen platform from Samsung. Samsung
    provides the binding layer and runtime to allow .NET MAUI to run on the Tizen
    platform. To learn more about how to install and develop for the Tizen platform,
    visit [https://github.com/Samsung/Tizen.NET](https://github.com/Samsung/Tizen.NET)
    in your browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 从三星获得了对 Tizen 平台的支持。三星提供了绑定层和运行时，以允许 .NET MAUI 在 Tizen 平台上运行。要了解更多关于如何安装和为
    Tizen 平台开发的信息，请访问您的浏览器中的 [https://github.com/Samsung/Tizen.NET](https://github.com/Samsung/Tizen.NET)。
- en: Now that we understand what .NET mobile is and how each platform works, we can
    explore .NET MAUI in detail.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 .NET 移动是什么以及每个平台的工作方式，我们可以详细探索 .NET MAUI。
- en: Exploring the .NET MAUI framework
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 .NET MAUI 框架
- en: '.NET MAUI is a cross-platform framework that is built on top of .NET mobile
    (for iOS and Android) and the **Windows UI** (**WinUI**) library. .NET MAUI allows
    developers to create a UI for iOS, Android, and WinUI in XAML. .NET MAUI improves
    on Xamarin.Forms by placing all platform-specific functionality in the same project
    as cross-platform functionality, making it easier to find and edit your code.
    .NET MAUI also includes all of what used to be in Xamarin.Essentials, which provides
    cross-platform capabilities, such as permissions, location, photos and camera,
    contacts, and maps, and leverages that cross-platform functionality with one shared
    code base, as illustrated in the following diagram:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 是一个基于 .NET 移动（用于 iOS 和 Android）和 **Windows UI**（**WinUI**）库的跨平台框架。.NET
    MAUI 允许开发者使用 XAML 创建 iOS、Android 和 WinUI 的用户界面。.NET MAUI 通过将所有特定于平台的功能放在与跨平台功能相同的项目中，改进了
    Xamarin.Forms，这使得查找和编辑代码变得更加容易。.NET MAUI 还包括了之前在 Xamarin.Essentials 中所有的内容，它提供了跨平台功能，如权限、位置、照片和相机、联系人以及地图，并通过一个共享代码库利用这些跨平台功能，如下面的图示所示：
- en: '![Figure 1.5 – .NET MAUI architecture](img/Figure_1.5_B19214.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – .NET MAUI 架构](img/Figure_1.5_B19214.jpg)'
- en: Figure 1.5 – .NET MAUI architecture
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – .NET MAUI 架构
- en: If we build an app with .NET MAUI, we can use XAML, C#, or a combination of
    both to create the UI.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 .NET MAUI 构建应用，我们可以使用 XAML、C# 或两者的组合来创建用户界面。
- en: The architecture of .NET MAUI
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET MAUI 的架构
- en: .NET MAUI is an abstraction layer on top of each platform. .NET MAUI has a shared
    layer that is used by all platforms, as well as a platform-specific layer. The
    platform-specific layer contains **handlers**. A handler is a class that maps
    a .NET MAUI control to a platform-specific native control. Each .NET MAUI control
    has a platform-specific handler.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 是在每个平台之上的一个抽象层。.NET MAUI 有一个共享层，该层被所有平台使用，以及一个特定于平台的层。特定于平台的层包含 **处理程序**。处理程序是一个将
    .NET MAUI 控件映射到特定于平台的本地控件的类。每个 .NET MAUI 控件都有一个特定于平台的处理程序。
- en: The following diagram illustrates how the entry control in .NET MAUI is mapped
    to the correct native control for each platform. The entry control is mapped to
    a `UITextField` control from the `UIKit` namespace when the shared .NET MAUI code
    is used in an iOS app. On Android, the entry control is mapped to an `EditText`
    control from the `AndroidX.AppCompat.Widget` namespace. Finally, for Windows,
    .NET MAUI `Entry` handlers map to `TextBox` from the `Microsoft.UI.Xaml.Controls`
    namespace.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了.NET MAUI中的输入控件如何映射到每个平台的正确原生控件。当在iOS应用程序中使用共享.NET MAUI代码时，输入控件映射到`UIKit`命名空间中的`UITextField`控件。在Android上，输入控件映射到`AndroidX.AppCompat.Widget`命名空间中的`EditText`控件。最后，对于Windows，.NET
    MAUI `Entry`处理程序映射到`Microsoft.UI.Xaml.Controls`命名空间中的`TextBox`。
- en: '![Figure 1.6 – .NET MAUI control architecture](img/Figure_1.6_B19214.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – .NET MAUI控制架构](img/Figure_1.6_B19214.jpg)'
- en: Figure 1.6 – .NET MAUI control architecture
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – .NET MAUI控制架构
- en: With a firm grasp of .NET MAUI architecture and .NET mobile platforms, it is
    time to explore how to create UIs in .NET MAUI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在牢固掌握.NET MAUI架构和.NET移动平台之后，是时候探索如何在.NET MAUI中创建UI了。
- en: Defining a UI using XAML
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XAML定义UI
- en: The most common way to declare our UI in .NET MAUI is by defining it in a XAML
    document. It is also possible to create the GUI in C#, since XAML is a markup
    language for instantiating objects. We could, in theory, use XAML to create any
    type of object, provided it has a parameterless constructor. A XAML document is
    an **Extensible Markup Language** (**XML**) document with a specific schema.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI中声明我们的UI最常见的方式是在XAML文档中定义它。由于XAML是用于实例化对象的标记语言，因此也可以在C#中创建GUI。从理论上讲，只要它有一个无参构造函数，我们就可以使用XAML创建任何类型的对象。XAML文档是一个具有特定模式的**可扩展标记语言**（**XML**）文档。
- en: Over the next few sections, we are going to learn about a few controls in .NET
    MAUI to get us started. Then, we will compare different ways that you can construct
    the UI using .NET MAUI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将学习一些.NET MAUI的控制，以帮助我们入门。然后，我们将比较使用.NET MAUI构建UI的不同方法。
- en: Defining a Label control
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义标签控件
- en: 'As a simple example, let’s look at the following snippet of a XAML document:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的例子，让我们看看以下XAML文档片段：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the XAML parser encounters this snippet, it creates an instance of a `Label`
    object and then sets the properties of the object that correspond to the attributes
    in the XAML. This means that if we set a `Text` property in XAML, it sets the
    `Text` property on the instance of the `Label` object that is created. The XAML
    in the preceding example has the same effect as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当XAML解析器遇到此片段时，它将创建一个`Label`对象的实例，然后设置与XAML中的属性相对应的对象属性。这意味着如果我们设置XAML中的`Text`属性，它将设置创建的`Label`对象实例的`Text`属性。前面示例中的XAML具有以下相同的效果：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'XAML exists to make it easier to view the object hierarchy that we need to
    create in order to make a GUI. An object model for a GUI is also hierarchical
    by design, so XAML supports adding child objects. We can simply add them as child
    nodes, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: XAML的存在是为了使查看我们需要创建以制作GUI的对象层次结构变得更加容易。GUI的对象模型也是按设计分层的，因此XAML支持添加子对象。我们可以简单地将其作为子节点添加，如下所示：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`StackLayout` is a container control that organizes the children vertically
    or horizontally within a container. Vertical organization is the default value
    and is used unless we specify otherwise. There are other containers, such as `Grid`
    and `FlexLayout`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackLayout`是一个容器控件，它在一个容器内垂直或水平地组织子控件。默认情况下是垂直组织，除非我们指定其他方式。还有其他容器，例如`Grid`和`FlexLayout`。'
- en: These will be used in many of the projects in the following chapters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将在后续章节的许多项目中使用。
- en: Creating a page in XAML
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在XAML中创建页面
- en: 'A single control is no use unless it has a container that hosts it. Let’s see
    what an entire page would look like. A fully valid `ContentPage` object defined
    in XAML is an XML document. This means that we must start with an XML declaration.
    After that, we must have one—and only one—root node, as shown:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个控件如果没有容器来承载它就没有用处。让我们看看一个完整的页面会是什么样子。在XAML中定义的完全有效的`ContentPage`对象是一个XML文档。这意味着我们必须从一个XML声明开始。之后，我们必须有一个——并且只有一个——根节点，如下所示：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we defined a `ContentPage` object that translates
    into a single view on each platform. In order to make it valid XAML, we need to
    specify a default namespace (`http://schemas.microsoft.com/dotnet/2021/maui">http://schemas.microsoft.com/dotnet/2021/maui**"**`**)
    and then add the `x` namespace (`http://schemas.microsoft.com/winfx/2009/xaml">http://schemas.microsoft.com/winfx/2009/xaml**"**`**).****
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个 `ContentPage` 对象，它在每个平台上转换为一个单独的视图。为了使其成为有效的 XAML，我们需要指定一个默认命名空间（`http://schemas.microsoft.com/dotnet/2021/maui`）并添加
    `x` 命名空间（`http://schemas.microsoft.com/winfx/2009/xaml`）。
- en: The default namespace lets us create objects without prefixing them, such as
    the `StackLayout` object. The `x` namespace lets us access properties such as
    `x:Class`, which tells the XAML parser which class to instantiate to control the
    page when the `ContentPage` object is created.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认命名空间让我们可以创建对象而无需前缀，例如 `StackLayout` 对象。`x` 命名空间让我们可以访问诸如 `x:Class` 这样的属性，它告诉
    XAML 解析器在创建 `ContentPage` 对象时实例化哪个类来控制页面。
- en: A `ContentPage` object can have only one child. In this case, it’s a `StackLayout`
    control. Unless we specify otherwise, the default layout orientation is vertical.
    A `StackLayout` object can, therefore, have multiple children. Later in the book,
    we will touch on more advanced layout controls, such as the `Grid` and `FlexLayout`
    controls.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPage` 对象只能有一个子元素。在这种情况下，它是一个 `StackLayout` 控件。除非我们指定其他方式，否则默认布局方向是垂直的。因此，`StackLayout`
    对象可以有多个子元素。本书后面我们将讨论更高级的布局控件，如 `Grid` 和 `FlexLayout` 控件。'
- en: As the first child of `StackLayout`, we will create a `Label` control.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `StackLayout` 的第一个子元素，我们将创建一个 `Label` 控件。
- en: Creating a page in C#
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 C# 中创建页面
- en: 'For clarity, the following code shows you how the previous example would look
    in C#:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，以下代码显示了上一个示例在 C# 中的样子：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`MainPage` is a class that inherits from .NET MAUI’s `ContentPage`. This class
    is automatically generated for us if we create a XAML page, but if we just use
    code, we will need to define it ourselves.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage` 是一个继承自 .NET MAUI 的 `ContentPage` 类。如果我们创建一个 XAML 页面，这个类会自动为我们生成，但如果我们只使用代码，我们就需要自己定义它。'
- en: 'Let’s create the same control hierarchy as the XAML page we defined earlier
    using the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码创建与之前定义的 XAML 页面相同的控件层次结构：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first statement creates a `page` object. We could, in theory, create a new
    `ContentPage` page directly, but this would prohibit us from writing any code
    behind it. For this reason, it’s good practice to subclass each page that we plan
    to create.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句创建了一个 `page` 对象。理论上，我们可以直接创建一个新的 `ContentPage` 页面，但这将阻止我们为其编写任何代码。因此，为每个我们计划创建的页面进行子类化是一个好的实践。
- en: The block following this first statement creates the `StackLayout` control,
    which contains the `Label` control that is added to the `Children` collection.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此第一个语句之后的块创建了 `StackLayout` 控件，它包含添加到 `Children` 集合中的 `Label` 控件。
- en: Finally, we need to assign `StackLayout` to the `Content` property of the page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将 `StackLayout` 分配给页面的 `Content` 属性。
- en: Since XAML is a markup language that mainly instantiates objects for us, we
    can see how easy it is to replicate that in C#. Next, we will take a look at some
    extensions that make developing your UI in C# a little better.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 XAML 是一种主要为我们实例化对象的标记语言，我们可以看到在 C# 中复制它有多么容易。接下来，我们将看看一些使您在 C# 中开发 UI 更好的扩展。
- en: Using the .NET MAUI Markup Community Toolkit
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 .NET MAUI Markup Community Toolkit
- en: 'The Community Toolkit organization on GitHub has a project to add **Fluent**
    extensions to MAUI for creating the UI in C#. The project **.NET MAUI Markup Community
    Toolkit** ([https://github.com/CommunityToolkit/Maui.Markup](https://github.com/CommunityToolkit/Maui.Markup)),
    or **MAUI.Markup** for short, is described on the website as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 上的 Community Toolkit 组织有一个项目，为 MAUI 添加 **Fluent** 扩展，以使用 C# 创建 UI。该项目
    **.NET MAUI Markup Community Toolkit** ([https://github.com/CommunityToolkit/Maui.Markup](https://github.com/CommunityToolkit/Maui.Markup))，或简称
    **MAUI.Markup**，在网站上描述如下：
- en: The .NET MAUI Markup Community Toolkit is a collection of Fluent C# Extension
    Methods that allows developers to continue architecting their apps using MVVM,
    Bindings, Resource Dictionaries, etc., without the need for XAML*.*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI Markup Community Toolkit 是一组 Fluent C# 扩展方法，允许开发者在无需 XAML 的情况下继续使用
    MVVM、绑定、资源字典等来架构他们的应用程序。
- en: 'Using MAUI Markup to create the same page we did in the previous two sections
    would look something like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MAUI 标记来创建我们在前两个部分中创建的相同页面看起来可能如下所示：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For more information on how to use MAUI Markup in your applications, visit [https://github.com/CommunityToolkit/Maui.Markup](https://github.com/CommunityToolkit/Maui.Markup)
    using your favorite web browser.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在您的应用程序中使用MAUI标记的更多信息，请使用您喜欢的网络浏览器访问[https://github.com/CommunityToolkit/Maui.Markup](https://github.com/CommunityToolkit/Maui.Markup)。
- en: So, what is better for creating our UI, XAML or C#?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，创建我们的UI，XAML还是C#更好呢？
- en: XAML or C#?
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XAML或C#？
- en: Generally, using XAML provides a much better overview, since the page is a hierarchical
    structure of objects, and XAML is a very nice way of defining that structure.
    In code, the structure is flipped around as we need to define the innermost object
    first, making it harder to read the structure of our page. This was demonstrated
    in the *Creating a page in XAML* section of this chapter. Having said that, it
    is generally a matter of preference as to how we decide to define the GUI. This
    book will use XAML rather than C# in the projects to come.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用XAML可以提供一个更好的概览，因为页面是一个对象的分层结构，而XAML是定义这种结构的一种非常好的方式。在代码中，结构是颠倒的，因为我们需要首先定义最内层的对象，这使得阅读我们页面的结构变得困难。这在本章的“在XAML中创建页面”部分中得到了演示。话虽如此，我们决定如何定义GUI通常是一个个人偏好的问题。这本书将在未来的项目中使用XAML而不是C#。
- en: Now that we’ve explored how to create our pages using .NET MAUI, it is time
    to review how .NET MAUI and .NET mobile compare.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何使用.NET MAUI创建我们的页面，是时候回顾.NET MAUI和.NET移动之间的比较了。
- en: .NET MAUI versus traditional .NET mobile
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET MAUI与传统.NET移动的比较
- en: 'While this book is about .NET MAUI, we will also highlight the differences
    between using traditional .NET mobile and .NET MAUI. Traditional .NET mobile is
    used when developing UIs that use the iOS or Android **software development kit**
    (**SDK**) without any means of abstraction. For example, we can create an iOS
    app that defines its UI in a storyboard or in the code directly. This code would
    not be reusable for other platforms, such as Android. Apps built using this approach
    can still share non-platform-specific code by simply referencing a .NET standard
    library. This relationship is shown in the following diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书是关于.NET MAUI的，但我们也会突出使用传统.NET移动和.NET MAUI之间的差异。当开发使用iOS或Android **软件开发套件**（**SDK**）且没有任何抽象手段的UI时，会使用传统.NET移动。例如，我们可以创建一个iOS应用程序，该应用程序在故事板或直接在代码中定义其UI。这段代码对于其他平台，如Android，是不可重用的。使用这种方法构建的应用程序仍然可以通过简单地引用.NET标准库来共享非平台特定的代码。这种关系在以下图中显示：
- en: '![Figure 1.7 – Traditional .NET UI](img/Figure_1.7_B19214.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 传统.NET UI](img/Figure_1.7_B19214.jpg)'
- en: Figure 1.7 – Traditional .NET UI
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 传统.NET UI
- en: '.NET MAUI, on the other hand, is an abstraction of the GUI, which allows us
    to define UIs in a platform-agnostic way. It still builds on top of .NET for iOS,
    .NET for Android, and all the other supported platforms. The .NET MAUI app is
    created as a .NET standard library where the shared source files and platform-specific
    source files are all built within the same project for the platform we are currently
    building for. This relationship is shown in the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，.NET MAUI是GUI的抽象，它允许我们以平台无关的方式定义UI。它仍然基于.NET for iOS、.NET for Android以及所有其他支持的平台。.NET
    MAUI应用程序被创建为一个.NET标准库，其中共享源文件和特定于平台的源文件都在我们当前构建的平台上的同一个项目中构建。这种关系在以下图中显示：
- en: '![Figure 1.8 – .NET MAUI UI with a single project](img/Figure_1.8_B19214.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 单个项目中的.NET MAUI UI](img/Figure_1.8_B19214.jpg)'
- en: Figure 1.8 – .NET MAUI UI with a single project
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 单个项目中的.NET MAUI UI
- en: Having said that, .NET MAUI cannot exist without traditional .NET mobile since
    it’s bootstrapped through an app for each platform. This gives us the ability
    to extend .NET MAUI on each platform using custom renderers and platform-specific
    code that can be exposed to our shared code base through interfaces. We’ll look
    at these concepts in more detail later in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，.NET MAUI无法在没有传统.NET移动的情况下存在，因为它通过每个平台的应用程序进行引导。这使我们能够使用自定义渲染器和特定于平台的代码在每个平台上扩展.NET
    MAUI，这些代码可以通过接口暴露给我们的共享代码库。我们将在本章后面更详细地探讨这些概念。
- en: When to use .NET MAUI
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用.NET MAUI
- en: We can use .NET MAUI in most cases and for most types of apps. If we need to
    use controls that are not available in .NET MAUI, we can always use the platform-specific
    APIs. There are, however, cases where .NET MAUI is not useful. The most common
    situation where we might want to avoid using .NET MAUI is if we build an app that
    should look very different across our different target platforms.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下和大多数类型的应用中，我们可以使用 .NET MAUI。如果我们需要使用 .NET MAUI 中不可用的控件，我们始终可以使用特定平台的
    API。然而，有些情况下 .NET MAUI 并不适用。我们可能想要避免使用 .NET MAUI 的最常见情况是，如果我们构建的应用在不同目标平台上看起来应该非常不同。
- en: Enough theory for now; let’s get our development machines ready to develop using
    .NET MAUI.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在理论部分已经足够了；让我们准备我们的开发机器，以便使用 .NET MAUI 进行开发。
- en: Setting up our development machine
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的开发机器
- en: 'Developing an app for multiple platforms imposes higher demands on our development
    machine. One reason for this is that we often want to run one or multiple simulators
    or emulators on our development machine. Different platforms also have different
    requirements for what is needed to begin development. Regardless of whether we
    use macOS or Windows, Visual Studio will be our **integrated development environment**
    (**IDE**). There are several versions of Visual Studio, including the free community
    edition. Go to [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)
    to compare the available versions, and select the version that is right for you;
    .NET MAUI is included in all versions of Visual Studio for Windows and macOS.
    The following list is a summary of what we need to begin development for each
    platform:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为多个平台开发应用对我们的开发机器提出了更高的要求。其中一个原因是，我们通常希望在开发机器上运行一个或多个模拟器或仿真器。不同的平台对开始开发所需的内容也有不同的要求。无论我们使用
    macOS 还是 Windows，Visual Studio 都将是我们的 **集成开发环境**（**IDE**）。Visual Studio 有几个版本，包括免费的社区版。请访问
    [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/) 比较可用的版本，并选择适合你的版本；.NET
    MAUI 包含在所有 Windows 和 macOS 的 Visual Studio 版本中。以下列表是针对每个平台开始开发所需内容的总结：
- en: '**iOS**: To develop an app for iOS, we need a **Macintosh** (**Mac**) device.
    This could either be the machine that we are developing on or a machine on our
    network, if we are using one. The reason we need to connect to a Mac is we need
    Xcode to build the app package. Xcode also provides various simulators to run
    and debug your app. It is possible to do some iOS development on Windows without
    a connected Mac; you can read more about this in the *Xamarin Hot Restart* section
    of this chapter.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**：要为 iOS 开发应用，我们需要一个 **Macintosh**（**Mac**） 设备。这可以是我们在其上开发的那台机器，或者如果我们使用的是网络上的机器。我们需要连接到
    Mac 的原因是我们需要 Xcode 来构建应用包。Xcode 还提供了各种模拟器来运行和调试你的应用。在没有连接 Mac 的情况下，你可以在 Windows
    上进行一些 iOS 开发；你可以在本章的 *Xamarin Hot Restart* 部分中了解更多信息。'
- en: '**Android**: Android apps can be developed on either macOS or Windows. Everything
    we need, including SDKs and simulators, is installed with Visual Studio.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**：Android 应用可以在 macOS 或 Windows 上开发。我们需要的所有东西，包括 SDK 和模拟器，都可以通过 Visual
    Studio 安装。'
- en: '**WinUI**: WinUI apps can only be developed in Visual Studio on a Windows machine.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WinUI**：WinUI 应用只能在 Windows 机器上的 Visual Studio 中开发。'
- en: We’ll start with setting up a Mac first, and then later cover Windows. If you
    do not own a Mac, you can skip this section and head straight to the *Setting
    up a Windows* *machine* section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置 Mac，然后稍后介绍 Windows。如果你没有 Mac，你可以跳过这一部分，直接进入 *设置 Windows 机器* 部分。
- en: Setting up a Mac
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Mac
- en: There are two main tools that are required to develop apps for iOS and Android
    with .NET mobile on a Mac. These are Visual Studio for Mac (if we are only developing
    Android apps, this is the only tool we need) and Xcode. In the following sections,
    we will look at how to set up a Mac for app development.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上使用 .NET 移动开发 iOS 和 Android 应用需要两个主要工具。这些是 Visual Studio for Mac（如果我们只开发
    Android 应用，这就是我们需要的唯一工具）和 Xcode。在接下来的章节中，我们将探讨如何设置 Mac 以进行应用开发。
- en: Installing Xcode
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Xcode
- en: Before we install Visual Studio, we need to download and install Xcode. Xcode
    is the official development IDE from Apple and contains all the tools available
    for iOS development, including SDKs for iOS, macOS, Mac Catalyst, and tvOS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装 Visual Studio 之前，我们需要下载并安装 Xcode。Xcode 是苹果的官方开发 IDE，包含所有 iOS 开发工具，包括 iOS、macOS、Mac
    Catalyst 和 tvOS 的 SDK。
- en: We can download Xcode from the Apple developer portal ([https://developer.apple.com](https://developer.apple.com))
    or the Apple App Store. I recommend that you download it from the App Store because
    this guarantees you have the latest stable version. The only reason to download
    Xcode from the developer portal is if you want to use a prerelease version of
    Xcode to develop it for a prerelease of iOS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 Apple 开发者门户（[https://developer.apple.com](https://developer.apple.com)）或
    Apple App Store 下载 Xcode。我建议您从 App Store 下载，因为这可以保证您拥有最新的稳定版本。唯一需要从开发者门户下载 Xcode
    的原因是为了使用 Xcode 的预发布版本来开发 iOS 的预发布版本。
- en: When using prerelease versions of macOS and its accompanying version of Xcode,
    it is possible that .NET for iOS/tvOS/Mac Catalyst/macOS has not been updated
    to work with the latest Xcode changes. It is recommended to check the compatibility
    before installing the latest Xcode to ensure a working environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 macOS 的预发布版本及其相应的 Xcode 版本时，可能 .NET for iOS/tvOS/Mac Catalyst/macOS 还未更新以与最新的
    Xcode 变更兼容。建议在安装最新 Xcode 之前检查兼容性，以确保工作环境正常。
- en: After the first installation, and after each update of Xcode, it is important
    that you open it. Xcode often needs to install additional components after an
    installation or an update. We also need to open Xcode to accept the license agreement
    with Apple.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次安装之后，以及每次 Xcode 更新之后，打开 Xcode 都非常重要。Xcode 在安装或更新后通常需要安装额外的组件。我们还需要打开 Xcode
    来接受与 Apple 的许可协议。
- en: Installing Visual Studio
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Visual Studio
- en: To install Visual Studio, we first need to download it from [https://visualstudio.microsoft.com](https://visualstudio.microsoft.com).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Visual Studio，我们首先需要从 [https://visualstudio.microsoft.com](https://visualstudio.microsoft.com)
    下载它。
- en: Visual Studio for Mac deprecation
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio for Mac 弃用
- en: On August 31, 2023, Microsoft announced the deprecation of Visual Studio for
    Mac in accordance with their Modern Lifecycle Policy, which will mean the end
    of support on August 31, 2024\. Visual Studio for Mac will remain supported until
    that date. If you have a Visual Studio subscription, you can always download the
    latest version of Visual Studio for Mac from [my.visualstudio.com](http://my.visualstudio.com).
    Microsoft has released the C# Dev Kit and .NET MAUI Dev Kit extensions for Visual
    Studio Code. The extensions work on Windows, macOS, and Linux. You can use Visual
    Studio Code and these extensions to complete the projects in this book, although
    the instructions pertaining to the UI for Visual Studio for Mac will not match
    Visual Studio Code. To learn more, visit [https://learn.microsoft.com/en-us/visualstudio/mac/what-happened-to-vs-for-mac?view=vsmac-2022](https://learn.microsoft.com/en-us/visualstudio/mac/what-happened-to-vs-for-mac?view=vsmac-2022).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 2023 年 8 月 31 日，微软根据其现代生命周期政策宣布了 Visual Studio for Mac 的弃用，这意味着支持将在 2024 年 8
    月 31 日结束。Visual Studio for Mac 将一直支持到那个日期。如果您有 Visual Studio 订阅，您可以从 [my.visualstudio.com](http://my.visualstudio.com)
    下载 Visual Studio for Mac 的最新版本。微软已发布了 C# Dev Kit 和 .NET MAUI Dev Kit 扩展程序，这些扩展程序在
    Windows、macOS 和 Linux 上运行。您可以使用 Visual Studio Code 和这些扩展程序来完成本书中的项目，尽管与 Visual
    Studio for Mac 的 UI 相关的说明将不匹配 Visual Studio Code。要了解更多信息，请访问 [https://learn.microsoft.com/en-us/visualstudio/mac/what-happened-to-vs-for-mac?view=vsmac-2022](https://learn.microsoft.com/en-us/visualstudio/mac/what-happened-to-vs-for-mac?view=vsmac-2022)。
- en: When we start the Visual Studio installer via the file we downloaded, it will
    start to check what we already have installed on our machine. When the check is
    finished, we can select which platforms and tools we would like to install.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过下载的文件启动 Visual Studio 安装程序时，它将开始检查我们机器上已经安装的内容。当检查完成后，我们可以选择我们想要安装的平台和工具。
- en: 'Once we have selected the platforms that we want to install, Visual Studio
    downloads and installs everything that we need to get started with app development
    using .NET mobile, as shown:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了想要安装的平台，Visual Studio 将下载并安装我们使用 .NET 移动进行应用程序开发所需的所有内容，如下所示：
- en: "![Figure 1.9 – Visual Studio f\uFEFF\uFEFFor Mac installer](img/Figure_1.9_B19214.jpg)"
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – Visual Studio for Mac 安装程序](img/Figure_1.9_B19214.jpg)'
- en: Figure 1.9 – Visual Studio for Mac installer
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – Visual Studio for Mac 安装程序
- en: Configuring the Android Emulator
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Android 模拟器
- en: Visual Studio uses the Android emulators provided by Google. They are installed
    and configured through SDK Manager.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 使用 Google 提供的 Android 模拟器。它们通过 SDK 管理器进行安装和配置。
- en: Special note for Intel-based Mac device
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基于 Intel 的 Mac 设备的特别说明
- en: If we want our emulator to be fast, then we need to ensure that it is hardware-accelerated.
    To hardware-accelerate the Android emulator, we need to install the Intel **Hardware
    Accelerated Execution Manager** (**HAXM**), which can be downloaded from [https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm](https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们的模拟器运行得快，那么我们需要确保它是硬件加速的。为了硬件加速Android模拟器，我们需要安装Intel **硬件加速执行管理器**（**HAXM**），可以从[https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm](https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm)下载。
- en: 'The next step is to create the Android emulator. First, we need to ensure that
    the Android emulator and the Android OS images are installed. To do this, take
    the following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建Android模拟器。首先，我们需要确保已安装Android模拟器和Android操作系统图像。为此，请执行以下步骤：
- en: 'Go to the **Tools** tab to install the Android emulator:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**工具**选项卡安装Android模拟器：
- en: "![Figure 1.10 – Install\uFEFFing Android Emulator in Vi\uFEFFsual Studio for\
    \ Mac](img/Figure_1.10_B19214.jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图1.10 – 在Visual Studio for Mac中安装Android模拟器](img/Figure_1.10_B19214.jpg)'
- en: Figure 1.10 – Installing Android Emulator in Visual Studio for Mac
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 – 在Visual Studio for Mac中安装Android模拟器
- en: 'We also need to install one or multiple images to use with the emulator. We
    can install multiple images if, for example, we want to run our app on different
    versions of Android. We can select emulators with Google Play (as in the following
    screenshot) so that we can use Google Play services in our app, even when we are
    running it in an emulator. This is required if, for example, we want to use Google
    Maps in our app:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要安装一个或多个图像以供模拟器使用。例如，如果我们想在不同的Android版本上运行我们的应用，我们可以安装多个图像。我们可以通过Google
    Play（如下面的截图所示）选择模拟器，这样我们就可以在我们的应用中使用Google Play服务，即使我们在模拟器中运行它。例如，如果我们想在我们的应用中使用Google
    Maps，这是必需的：
- en: "![Figure 1.11 – Install\uFEFFing emulator images in Visual Studio for Mac](img/Figure_1.11_B19214.jpg)"
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11 – 在Visual Studio for Mac中安装模拟器图像](img/Figure_1.11_B19214.jpg)'
- en: Figure 1.11 – Installing emulator images in Visual Studio for Mac
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – 在Visual Studio for Mac中安装模拟器图像
- en: Intel versus Apple M1
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔与苹果M1的比较
- en: If you have an Apple Mac that uses the M1 chipset, then you should use emulator
    images that have **ARM 64** in the name; otherwise, if you are using older Mac
    devices with the Intel chipset, then use images with **Intel x86** in the name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一台使用M1芯片组的Apple Mac，那么您应该使用名称中包含**ARM 64**的模拟器图像；否则，如果您正在使用带有Intel芯片组的较旧Mac设备，则使用名称中包含**Intel
    x86**的图像。
- en: 'Then, to create and configure an emulator, go to **Device Manager** in the
    **Tools** menu in Visual Studio. From **Android Device Manager**, we can start
    an emulator if we already have one created, or we can create new emulators, as
    shown:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，要创建和配置模拟器，请转到Visual Studio中的**工具**菜单下的**设备管理器**。从**Android设备管理器**，如果我们已经创建了一个模拟器，我们可以启动它，或者我们可以创建新的模拟器，如下所示：
- en: '![Figure 1.12 – Android Device Manager in Visual Studio for Mac](img/Figure_1.12_B19214.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图1.12 – Visual Studio for Mac中的Android设备管理器](img/Figure_1.12_B19214.jpg)'
- en: Figure 1.12 – Android Device Manager in Visual Studio for Mac
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 – Visual Studio for Mac中的Android设备管理器
- en: If we click on the **New Device** button, we can create a new emulator with
    the specifications that we need. The easiest way to create a new emulator here
    is to select a base device that matches our needs. These base devices are preconfigured,
    which is often enough. However, it is also possible to edit the properties of
    the device so that we have an emulator that matches our specific needs.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们点击**新建设备**按钮，我们可以创建一个具有所需规格的新模拟器。在这里创建新模拟器最简单的方法是选择一个与我们需求匹配的基础设备。这些基础设备是预先配置的，这通常已经足够。然而，我们也可以编辑设备的属性，以便我们有一个符合我们特定需求的模拟器。
- en: The processor dropdown will be preselected with the correct architecture of
    your device. If you change this, for example, from ARM to x86 or x86 to ARM, then
    the emulator will be slower; always try to use the architecture that matches your
    device.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理器下拉菜单将预先选择与您的设备正确的架构。如果您更改此设置，例如，从ARM更改为x86或从x86更改为ARM，那么模拟器将变慢；始终尝试使用与您的设备匹配的架构。
- en: "![Figure 1.13 – Creat\uFEFFing a new Android device](img/Figure_1.13_B19214.jpg)"
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图1.13 – 创建新的Android设备](img/Figure_1.13_B19214.jpg)'
- en: Figure 1.13 – Creating a new Android device
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 创建新的Android设备
- en: If you only have a Mac, then you are done and can skip to the *.NET mobile productivity
    tooling* section. If you have a Windows device, then the next section, *Setting
    up a Windows machine*, is for you.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只有 Mac，那么我们已经完成，可以跳转到 *.NET 移动生产力工具* 部分。如果我们有 Windows 设备，那么下一部分，*设置 Windows
    机器*，就是为您准备的。
- en: Setting up a Windows machine
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Windows 机器
- en: We can use either a virtual or physical Windows machine for development with
    .NET mobile. We can, for example, run a virtual Windows machine on our Mac. The
    only tool we need for app development on our Windows machine is Visual Studio.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用虚拟或物理 Windows 机器来使用 .NET 移动进行开发。例如，我们可以在我们的 Mac 上运行虚拟 Windows 机器。我们只需要在我们的
    Windows 机器上安装 Visual Studio 就可以进行应用开发。
- en: Installing .NET mobile for Visual Studio 2022 or later
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 Visual Studio 2022 或更高版本安装 .NET 移动
- en: If we already have Visual Studio 2022 or later installed, we first need to open
    **Visual Studio Installer**; otherwise, we need to go to [https://visualstudio.microsoft.com](https://visualstudio.microsoft.com)
    to download the installation files. Under the banner in the **Meet the Visual
    Studio Family** section, you can find the links to download Visual Studio 2022
    for Windows or Visual Studio 2022 for Mac.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已安装 Visual Studio 2022 或更高版本，我们首先需要打开 **Visual Studio 安装程序**；否则，我们需要前往 [https://visualstudio.microsoft.com](https://visualstudio.microsoft.com)
    下载安装文件。在 **认识 Visual Studio 家族** 部分的横幅下，您可以找到下载 Visual Studio 2022 for Windows
    或 Visual Studio 2022 for Mac 的链接。
- en: Before the installation starts, we need to select which workloads we want to
    install.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装开始之前，我们需要选择我们想要安装的工作负载。
- en: For .NET MAUI development, we need to install **.NET Multi-platform App UI development**.
    Select the **ASP.NET and web development** workload to be able to develop MAUI/Blazor
    hybrid apps.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 .NET MAUI 开发，我们需要安装 **.NET 多平台应用程序 UI 开发**。选择 **ASP.NET 和 Web 开发** 工作负载，以便能够开发
    MAUI/Blazor 混合应用。
- en: '![Figure 1.14 – Visual Studio 2022 installer](img/Figure_1.14_B19214.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14 – Visual Studio 2022 安装程序](img/Figure_1.14_B19214.jpg)'
- en: Figure 1.14 – Visual Studio 2022 installer
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – Visual Studio 2022 安装程序
- en: 'Hyper-V is the default hardware acceleration method when using .NET MAUI. If
    you want to use Intel HAXM, you will need to check the checkbox for Intel HAXM
    in the **Individual components** tab, as in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 .NET MAUI 时，Hyper-V 是默认的硬件加速方法。如果我们想使用 Intel HAXM，我们需要在 **单个组件** 选项卡中勾选
    Intel HAXM，如下面的截图所示：
- en: "![Figure 1.15 – Add\uFEFFing Intel HAXM](img/Figure_1.15_B19214.jpg)"
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15 – 添加 Intel HAXM](img/Figure_1.15_B19214.jpg)'
- en: Figure 1.15 – Adding Intel HAXM
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 添加 Intel HAXM
- en: When we first start Visual Studio, we will be asked whether we want to sign
    in. It is not necessary for us to sign in unless we want to use Visual Studio
    Professional or Enterprise, in which case we will need to sign in so that our
    license can be verified.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次启动 Visual Studio 时，系统会询问我们是否想要登录。除非我们想要使用 Visual Studio Professional 或
    Enterprise，在这种情况下我们需要登录以验证我们的许可证，否则我们不需要登录。
- en: Now that Visual Studio is installed, we can finish the configuration needed
    to run and debug apps for iOS and Android.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Visual Studio 已经安装，我们可以完成运行和调试 iOS 和 Android 应用的配置。
- en: Pairing Visual Studio with a Mac
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Visual Studio 与 Mac 配对
- en: If we want to run, debug, and compile our iOS app from a Windows development
    machine, then we need to connect it to a Mac. We can set up our Mac manually,
    as described earlier in this chapter, or we can use **Automatic Mac Provisioning**
    from within Visual Studio. This installs Mono and .NET for iOS on the Mac that
    we are connecting to. It will not install the Visual Studio IDE, but this isn’t
    necessary if we just want to use it as a build machine. We do, however, need to
    install Xcode manually.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 Windows 开发机器上运行、调试和编译我们的 iOS 应用，那么我们需要将其连接到 Mac。我们可以手动设置我们的 Mac，如本章前面所述，或者我们可以使用
    Visual Studio 中的 **自动 Mac 配置**。这将安装 Mono 和 .NET for iOS 到我们连接的 Mac 上。它不会安装 Visual
    Studio IDE，但如果我们只是想将其用作构建机器，则这不是必需的。然而，我们确实需要手动安装 Xcode。
- en: 'To connect to the Mac from Visual Studio, use the **Pair to Mac** button in
    the toolbar (as in the following screenshot), or, in the top menu, go to **Tools**
    | **iOS** | **Pair** **to Mac**:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Visual Studio 连接到 Mac，请使用工具栏中的 **配对到 Mac** 按钮（如下面的截图所示），或者在顶部菜单中转到 **工具**
    | **iOS** | **配对** | **到 Mac**：
- en: '![Figure 1.16 – Pair to Mac button](img/Figure_1.16_B19214.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16 – 配对到 Mac 按钮](img/Figure_1.16_B19214.jpg)'
- en: Figure 1.16 – Pair to Mac button
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 配对到 Mac 按钮
- en: If this is the first time you have attempted to pair to a Mac, Visual Studio
    will open a wizard that will guide you through the steps you need to take on your
    Mac to enable Visual Studio to connect.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次尝试配对到Mac，Visual Studio将打开一个向导，该向导将指导您在Mac上执行使Visual Studio能够连接所需的步骤。
- en: '![Figure 1.17 – Pair to Mac wizard](img/Figure_1.17_B19214.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图1.17 – 配对到Mac向导](img/Figure_1.17_B19214.jpg)'
- en: Figure 1.17 – Pair to Mac wizard
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17 – 配对到Mac向导
- en: To be able to connect to a Mac—either manually or using **Automatic Mac Provisioning**—we
    need to be able to access the Mac via our network, and we need to enable **Remote
    Login** on the Mac.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够连接到Mac——无论是手动还是使用**自动Mac配置**——我们需要能够通过网络访问Mac，并且需要在Mac上启用**远程登录**。
- en: 'To do this, go to **Settings** | **Sharing** and select the checkbox for **Remote
    Login**. To the left of the window, we can select which users are allowed to connect
    with **Remote Login**, as shown:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，请转到**设置** | **共享**并选中**远程登录**的复选框。在窗口的左侧，我们可以选择允许使用**远程登录**连接的用户，如图所示：
- en: "![Figure 1.18 – Enabl\uFEFFing Remote Login on macOS](img/Figure_1.18_B19214.jpg)"
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图1.18 – 在macOS上启用远程登录](img/Figure_1.18_B19214.jpg)'
- en: Figure 1.18 – Enabling Remote Login on macOS
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18 – 在macOS上启用远程登录
- en: 'A dialog box will appear showing all the Macs that can be found on the network.
    If your Mac doesn’t appear in the list of available Macs, you can use the **Add
    Mac...** button in the bottom-left corner of the window to enter an IP address,
    as shown:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将会弹出一个对话框，显示网络上可以找到的所有Mac。如果您的Mac不在可用的Mac列表中，您可以在窗口左下角的**添加Mac...**按钮中输入IP地址，如图所示：
- en: "![Figure 1.19 – Pair to \uFEFFMac](img/Figure_1.19_B19214.jpg)"
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图1.19 – 配对到Mac](img/Figure_1.19_B19214.jpg)'
- en: Figure 1.19 – Pair to Mac
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.19 – 配对到Mac
- en: 'If everything that we need is installed on the Mac, then Visual Studio will
    connect, and we can start building and debugging our iOS app. If Mono is missing
    on the Mac, a warning will appear. This warning will also give us the option to
    install it, as shown:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Mac上安装了所有必需的软件，Visual Studio将连接，我们可以开始构建和调试我们的iOS应用。如果Mac上缺少Mono，将出现警告。此警告还将提供安装它的选项，如图所示：
- en: '![Figure 1.20 – Missing Mono installation dialog](img/Figure_1.20_B19214.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图1.20 – 缺少Mono安装对话框](img/Figure_1.20_B19214.jpg)'
- en: Figure 1.20 – Missing Mono installation dialog
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.20 – 缺少Mono安装对话框
- en: Now that we have our Mac paired, we can get the Android emulator configured.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将Mac配对成功，我们可以配置Android模拟器。
- en: Configuring an Android emulator and hardware acceleration
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Android模拟器和硬件加速
- en: If we want a fast Android emulator that works smoothly, we need to enable hardware
    acceleration. This can be done using either Intel HAXM or Hyper-V. The disadvantage
    of Intel HAXM is that it can’t be used on machines with an **Advanced Micro Devices**
    (**AMD**) processor; we must use a machine with an Intel processor. We can’t use
    Intel HAXM in parallel with Hyper-V.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个运行流畅的快速Android模拟器，我们需要启用硬件加速。这可以通过Intel HAXM或Hyper-V来完成。Intel HAXM的缺点是它不能在带有**高级微设备公司**（**AMD**）处理器的机器上使用；我们必须使用带有Intel处理器的机器。我们无法在Hyper-V并行使用Intel
    HAXM。
- en: Because of this, Hyper-V is the preferred way to hardware-accelerate an Android
    emulator on a Windows machine. To use Hyper-V with our Android emulator, we need
    to have Windows 11 or Windows 10 with the April 2018 update (or later), and Visual
    Studio 2017 version 15.8 (or later) installed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，Hyper-V是在Windows机器上硬件加速Android模拟器的首选方式。要使用Hyper-V与我们的Android模拟器，我们需要安装Windows
    11或带有2018年4月更新（或更高版本）的Windows 10，以及安装了Visual Studio 2017版本15.8（或更高版本）。
- en: Find your version of Visual Studio
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 查找您的Visual Studio版本
- en: 'To determine the version of Visual Studio you are using, when Visual Studio
    is open, use the **Help** | **About Visual Studio** menu, and you should be presented
    with a dialog similar to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定您正在使用的Visual Studio版本，当Visual Studio打开时，使用**帮助** | **关于Visual Studio**菜单，您应该会看到一个类似于以下对话框：
- en: '![](img/Figure_1.21._B19214.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_1.21._B19214.jpg)'
- en: Figure 1.21 – Help | About
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.21 – 帮助 | 关于
- en: 'To enable Hyper-V, we need to take the following steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Hyper-V，我们需要采取以下步骤：
- en: 'Open the search menu and type in `Turn Windows features on or off`. Click the
    option that appears to open it, as shown:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开搜索菜单，输入`打开或关闭Windows功能`。点击出现的选项以打开它，如图所示：
- en: "![Figure 1.22 – Turn Windows feature\uFEFFs on or off](img/Figure_1.22._B19214.jpg)"
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图1.22 – 打开或关闭Windows功能](img/Figure_1.22._B19214.jpg)'
- en: Figure 1.22 – Turn Windows features on or off
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.22 – 打开或关闭Windows功能
- en: 'To enable Hyper-V, select the **Hyper-V** checkbox. Also, expand the **Hyper-V**
    option and check the **Hyper-V Platform** checkbox. We also need to select the
    **Windows Hypervisor Platform** checkbox, as shown:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用 Hyper-V，选中 **Hyper-V** 复选框。同时，展开 **Hyper-V** 选项并选中 **Hyper-V 平台** 复选框。我们还需要选中
    **Windows 虚拟机平台** 复选框，如下所示：
- en: "![Figure 1.23 – Enabl\uFEFFing Hyper-V in Windows Features](img/Figure_1.23._B19214.jpg)"
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.23 – 在 Windows 功能中启用 Hyper-V](img/Figure_1.23._B19214.jpg)'
- en: Figure 1.23 – Enabling Hyper-V in Windows Features
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23 – 在 Windows 功能中启用 Hyper-V
- en: Restart the machine when Windows prompts you to do so.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Windows 提示您时，请重新启动计算机。
- en: Because we didn’t install an Android emulator during the installation of Visual
    Studio, we need to install it now. Go to the **Tools** menu in Visual Studio,
    then click on **Android** and then **Android** **SDK Manager**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在安装 Visual Studio 时没有安装 Android 模拟器，现在我们需要安装它。在 Visual Studio 的 **工具** 菜单中，然后点击
    **Android**，再点击 **Android SDK 管理器**。
- en: 'Under **Tools** in **Android SDK Manager**, we can install the emulator by
    selecting **Android Emulator**, as in the following screenshot. Also, we should
    ensure that the latest version of **Android SDK Build Tools** is installed:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Android SDK 管理器** 的 **工具** 下，我们可以通过选择 **Android 模拟器** 来安装模拟器，如下截图所示。同时，我们应确保已安装最新版本的
    **Android SDK 构建工具**：
- en: "![Figure 1.24 – Install\uFEFFing Android Emulator in Android SDK Manager](img/Figure_1.24._B19214.jpg)"
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.24 – 在 Android SDK 管理器中安装 Android 模拟器](img/Figure_1.24._B19214.jpg)'
- en: Figure 1.24 – Installing Android Emulator in Android SDK Manager
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.24 – 在 Android SDK 管理器中安装 Android 模拟器
- en: The Android SDK allows multiple emulator images to be installed simultaneously.
    We can install multiple images if, for example, we want to run our app on different
    versions of Android. Select emulators with **Google Play** (as in the following
    screenshot) so that we can use Google Play services in our app, even when we are
    running it in an emulator.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android SDK 允许同时安装多个模拟器镜像。如果我们想在不同的 Android 版本上运行我们的应用，我们可以安装多个镜像。选择带有 **Google
    Play** 的模拟器（如以下截图所示），这样我们就可以在我们的应用中使用 Google Play 服务，即使我们在模拟器中运行它。
- en: 'This is required if, for example, we want to use Google Maps in our app:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果我们想在我们的应用中使用 Google Maps，这是必需的：
- en: "![Figure 1.25 – I\uFEFFnstall\uFEFFing Android Emulator images in Android SDK\
    \ Manager](img/Figure_1.25._B19214.jpg)"
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.25 – 在 Android SDK 管理器中安装 Android 模拟器镜像](img/Figure_1.25._B19214.jpg)'
- en: Figure 1.25 – Installing Android Emulator images in Android SDK Manager
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.25 – 在 Android SDK 管理器中安装 Android 模拟器镜像
- en: Be sure to click the **Apply Changes** button to install any components you
    selected before closing the window.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关闭窗口之前，务必点击 **应用更改** 按钮来安装您之前选择的任何组件。
- en: 'The next step is to create a virtual device to use the emulator image. To create
    and configure an emulator, go to **Android Device Manager**, which we can open
    from the **Tools** tab in Visual Studio. From the device manager, we can either
    start an emulator—if we already have one created—or we can create new emulators,
    as shown:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个虚拟设备来使用模拟器镜像。要创建和配置一个模拟器，请转到 **Android 设备管理器**，我们可以从 Visual Studio 的
    **工具** 选项卡中打开它。从设备管理器中，我们可以启动一个模拟器（如果我们已经创建了一个）或者创建新的模拟器，如下所示：
- en: '![Figure 1.26 – Android Device Manager](img/Figure_1.26._B19214.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.26 – Android 设备管理器](img/Figure_1.26._B19214.jpg)'
- en: Figure 1.26 – Android Device Manager
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.26 – Android 设备管理器
- en: If we click on the **New** button, we can create a new emulator with the specifications
    that we need. The easiest way to create a new emulator here is to select a base
    device that matches our needs. These base devices are preconfigured, which is
    often enough. However, it is possible to edit the properties of the device so
    that we have an emulator that matches our specific needs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击 **新建** 按钮，我们可以创建一个具有所需规格的新模拟器。在这里创建新模拟器最简单的方法是选择一个与我们需求匹配的基础设备。这些基础设备是预先配置的，这通常就足够了。然而，我们可以编辑设备的属性，以便我们有一个符合我们特定需求的模拟器。
- en: We must select the correct processor for the emulator to match the processor
    in our Windows development machine. If it doesn’t match, then the emulator will
    be slower than it needs to be. Select the **x86_64** processor (as in the following
    screenshot) if you are using Intel or AMD x86-based hardware, or **arm64-v***
    if you have an ARM device running Windows.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为模拟器选择正确的处理器，以匹配我们的 Windows 开发机器中的处理器。如果它们不匹配，那么模拟器将比所需的运行得更慢。如果您使用的是基于
    Intel 或 AMD x86 的硬件，请选择 **x86_64** 处理器（如下截图所示），或者如果您有一个运行 Windows 的 ARM 设备，请选择
    **arm64-v***。
- en: "![Figure 1.27 – Creat\uFEFFing a new device in Android Device Manager](img/Figure_1.27._B19214.jpg)"
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图1.27 – 在Android设备管理器中创建新设备](img/Figure_1.27._B19214.jpg)'
- en: Figure 1.27 – Creating a new device in Android Device Manager
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.27 – 在Android设备管理器中创建新设备
- en: Configuring Developer Mode
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置开发者模式
- en: 'If we want to develop desktop apps for Windows, we need to activate Developer
    Mode on our development machine. To do this, go to **Settings** | **Privacy &
    security** | **For developers**. Then, select **Developer Mode**, as in the following
    screenshot. This makes it possible for us to sideload and debug apps via Visual
    Studio:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为Windows开发桌面应用程序，我们需要在我们的开发机器上激活开发者模式。为此，转到**设置** | **隐私和安全** | **开发者选项**。然后，选择**开发者模式**，如以下截图所示。这使得我们可以通过Visual
    Studio侧载和调试应用程序：
- en: "![Figure 1.28 – Enabl\uFEFFing Developer Mode](img/Figure_1.28._B19214.jpg)"
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图1.28 – 启用开发者模式](img/Figure_1.28._B19214.jpg)'
- en: Figure 1.28 – Enabling Developer Mode
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.28 – 启用开发者模式
- en: At this point, our Windows machine is ready for development. Before we dive
    into creating our first project, there are a few more optional features that we
    should review. These will help your development process as you build your apps.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的Windows机器已准备好进行开发。在我们开始创建第一个项目之前，还有一些其他可选功能需要我们审查。这些功能将有助于您在构建应用程序时提高开发效率。
- en: .NET mobile productivity tooling
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET移动生产力工具
- en: '**Xamarin Hot Restart** and **Hot Reload** are two tools that increase productivity
    for .NET MAUI developers. To get even better performance from your Android emulators,
    you can use the **Windows Subsystem for** **Android** (**WSA**).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**Xamarin热重启**和**热重载**是两种提高.NET MAUI开发者生产力的工具。为了从Android模拟器中获得更好的性能，您可以使用**Windows子系统**为**Android**（**WSA**）。'
- en: Xamarin Hot Restart
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xamarin热重启
- en: 'Hot Restart is a Visual Studio feature to make developers more productive.
    It also gives us a way of running and debugging iOS apps on an iPhone without
    having to use a Mac connected to Visual Studio. Microsoft describes Hot Restart
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 热重启是Visual Studio的一个功能，旨在提高开发者的生产力。它还为我们提供了一种在iPhone上运行和调试iOS应用程序的方法，而无需使用连接到Visual
    Studio的Mac。微软将热重启描述如下：
- en: Xamarin Hot Restart enables you to quickly test changes to your app during development,
    including multi-file code edits, resources, and references. It pushes the new
    changes to the existing app bundle on the debug target which results in a much
    faster build and deploy cycle.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin热重启允许您在开发过程中快速测试对应用程序的更改，包括多文件代码编辑、资源和引用。它将新更改推送到调试目标上的现有应用程序包，从而实现更快的构建和部署周期。
- en: 'To use Hot Restart, you need the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用热重启，您需要以下内容：
- en: Visual Studio 2019 version 16.5
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019版本16.5
- en: iTunes (Microsoft Store or 64-bit versions)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iTunes（微软商店或64位版本）
- en: An Apple Developer account and paid Apple Developer Program ([https://developer.apple.com/programs/](https://developer.apple.com/programs/))
    enrollment
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个苹果开发者账户和付费的苹果开发者计划([https://developer.apple.com/programs/](https://developer.apple.com/programs/))注册
- en: Hot Restart can currently only be used with .NET for iOS apps.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 热重启目前只能与iOS应用程序的.NET一起使用。
- en: Read more about the current state of Hot Restart at [https://docs.microsoft.com/en-us/xamarin/xamarin-forms/deploy-test/hot-restart](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/deploy-test/hot-restart).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有关热重启当前状态的更多信息，请参阅[https://docs.microsoft.com/en-us/xamarin/xamarin-forms/deploy-test/hot-restart](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/deploy-test/hot-restart)。
- en: Hot Reload
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热重载
- en: 'Hot Reload is a runtime technology that allows us to update our running app
    with the changes we are making in the IDE. There are two major flavors of Hot
    Reload today: **XAML Hot Reload** and **C#** **Hot Reload**.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 热重载是一种运行时技术，允许我们在IDE中做出更改时更新我们的运行中的应用程序。目前热重载有两种主要类型：**XAML热重载**和**C#热重载**。
- en: XAML Hot Reload allows us to make changes to our XAML without having to redeploy
    our app. When we have carried out changes to the XAML, we just save the file,
    and it updates the page on the simulator/emulator or on a device. XAML Hot Reload
    is currently supported by all .NET MAUI platforms.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: XAML热重载允许我们在不重新部署应用程序的情况下更改我们的XAML。当我们对XAML进行了更改后，我们只需保存文件，它就会更新模拟器/模拟器或设备上的页面。XAML热重载目前支持所有.NET
    MAUI平台。
- en: C# Hot Reload allows us to make changes to our code without having to redeploy
    our app. C# Hot Reload is like *Edit & Continue*; however, you do not have to
    be in break mode in order to apply the changes to the app. Once you have made
    changes to your code, you can click the **Hot Reload** button in the toolbar of
    Visual Studio and Hot Reload will update the running app. If, for some reason,
    the changes cannot be applied, Hot Reload will display a dialog either asking
    you to fix any compilation errors or, in some cases, requiring you to restart
    the app.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: C# 热重载允许我们在不重新部署我们的应用的情况下修改代码。C# 热重载类似于 *编辑并继续*；然而，您不需要处于中断模式才能将更改应用到应用中。一旦您修改了代码，您可以在
    Visual Studio 工具栏中点击 **热重载** 按钮，热重载将更新运行中的应用。如果由于某些原因无法应用更改，热重载将显示一个对话框，要求您修复任何编译错误，或者在某些情况下，要求您重新启动应用。
- en: To enable XAML Hot Reload for Visual Studio on Windows, go to **Tools** | **Options**
    | **Xamarin** | **Hot Reload**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上为 Visual Studio 启用 XAML 热重载，请转到 **工具** | **选项** | **Xamarin** |
    **热重载**.
- en: To enable XAML Hot Reload for Visual Studio on Mac, go to **Visual Studio**
    | **Preferences** | **Tools for Xamarin** | **XAML** **Hot Reload**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Mac 上为 Visual Studio 启用 XAML 热重载，请转到 **Visual Studio** | **首选项** | **Xamarin
    工具** | **XAML** **热重载**.
- en: C# Hot Reload is only available in Visual Studio for Windows; to enable it,
    go to **Tools** | **Options** | **Debugger** | **.NET / C++** **Hot Reload**.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: C# 热重载仅在 Windows Visual Studio 中可用；要启用它，请转到 **工具** | **选项** | **调试器** | **.NET
    / C++** **热重载**.
- en: Windows Subsystem for Android
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows Subsystem for Android
- en: If you are using Windows 11 in a supported region, you can use WSA as your debugging
    target instead of the Android emulators. To learn more about WSA and how to set
    up your machine to use it, visit [https://learn.microsoft.com/en-us/windows/android/wsa/](https://learn.microsoft.com/en-us/windows/android/wsa/).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在支持的地区使用 Windows 11，您可以使用 WSA 作为调试目标，而不是使用 Android 模拟器。要了解更多关于 WSA 以及如何设置您的机器以使用它，请访问
    [https://learn.microsoft.com/en-us/windows/android/wsa/](https://learn.microsoft.com/en-us/windows/android/wsa/).
- en: If you want to use WSA to debug your .NET MAUI apps, it will help if you install
    the WSA Barista Visual Studio extension ([https://marketplace.visualstudio.com/items?itemName=Redth.WindowsSubsystemForAndroidVisualStudioExtension](https://marketplace.visualstudio.com/items?itemName=Redth.WindowsSubsystemForAndroidVisualStudioExtension)).
    This will add the **Windows Subsystem for Android** menu item under **Tools**,
    which will prompt you to install WSA from the Windows Store, and then automatically
    configure WSA and set up Visual Studio to use WSA as a device.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 WSA 调试您的 .NET MAUI 应用，如果您安装了 WSA Barista Visual Studio 扩展 ([https://marketplace.visualstudio.com/items?itemName=Redth.WindowsSubsystemForAndroidVisualStudioExtension](https://marketplace.visualstudio.com/items?itemName=Redth.WindowsSubsystemForAndroidVisualStudioExtension))，这将有所帮助。这将添加
    **Windows Subsystem for Android** 菜单项到 **工具** 下，这将提示您从 Windows Store 安装 WSA，然后自动配置
    WSA 并设置 Visual Studio 以使用 WSA 作为设备。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now feel a bit more comfortable with what .NET mobile is and how
    .NET MAUI relates to .NET mobile.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对 .NET 移动是什么以及 .NET MAUI 如何与 .NET 移动相关有更多的了解。
- en: In this chapter, we established a definition of what a native app is and saw
    how it has a native UI, performance, and API access. We talked about how .NET
    mobile uses Mono, which is an open source implementation of the .NET Framework,
    and discussed how, at its core, .NET mobile is a set of bindings to platform-specific
    APIs. We then looked at how .NET for iOS and .NET for Android work under the hood.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们定义了什么是原生应用，并看到了它如何具有原生 UI、性能和 API 访问。我们讨论了 .NET 移动如何使用 Mono，Mono 是 .NET
    Framework 的开源实现，并讨论了在核心上，.NET 移动是一组绑定到特定平台 API 的绑定。然后我们查看 .NET for iOS 和 .NET
    for Android 在底层是如何工作的。
- en: After that, we began to touch on the core topic of this book, which is .NET
    MAUI. We started with an overview of how platform-agnostic controls are rendered
    to platform-specific controls and how to use XAML to define a hierarchy of controls
    to assemble a page. We then spent some time looking at the difference between
    a .NET MAUI app and a traditional .NET mobile app.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始触及本书的核心主题，即 .NET MAUI。我们首先概述了平台无关控件如何渲染为特定平台的控件，以及如何使用 XAML 定义控件层次结构来组装页面。然后，我们花了一些时间来查看
    .NET MAUI 应用与传统 .NET 移动应用之间的区别。
- en: A traditional .NET mobile app uses platform-specific APIs directly, without
    any abstraction, other than what .NET adds as a platform. .NET MAUI is an API
    that is built on top of the traditional .NET APIs and allows us to define platform-agnostic
    GUIs in XAML or in code that is rendered to platform-specific controls. There’s
    more to .NET MAUI than this, but this is what it does at its core.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个传统的 .NET 移动应用直接使用特定平台的 API，除了 .NET 作为平台添加的任何抽象之外，没有任何抽象。.NET MAUI 是一个建立在传统
    .NET API 之上的 API，允许我们使用 XAML 或代码定义平台无关的 GUI，这些代码被渲染为特定平台的控件。.NET MAUI 的功能远不止于此，但这正是其核心所在。
- en: 'In the last part of this chapter, we discussed how to set up a development
    machine on Windows or macOS. Finally, we looked at three optional features that
    you can use to help improve your development cycle: Hot Restart, Hot Reload, and
    WSA.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们讨论了如何在 Windows 或 macOS 上设置开发机器。最后，我们查看了一些可选功能，这些功能可以帮助改善您的开发周期：热重启、热重载和
    WSA。
- en: Now, it’s time to put our newly acquired knowledge to use! We will start by
    creating a *to-do* app from the ground up in the next chapter. We will look at
    concepts such as **Model–View–ViewModel** (**MVVM**) for a clean separation between
    business logic and the UI and SQLite.NET to persist data to a local database on
    our device. We will do this for three platforms at the same time—so, read on!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将我们新获得的知识付诸实践了！在下一章中，我们将从头开始创建一个 *待办事项* 应用程序。我们将探讨诸如 **模型-视图-视图模型** (**MVVM**)
    等概念，以实现业务逻辑和 UI 之间的清晰分离，以及 SQLite.NET 将数据持久化到设备上的本地数据库。我们将同时为三个平台进行此操作——所以，继续阅读吧！
