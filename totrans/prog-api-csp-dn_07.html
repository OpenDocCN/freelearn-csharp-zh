<html><head></head><body>
  <div id="_idContainer072">
   <h1 class="chapter-number" id="_idParaDest-94">
    <a id="_idTextAnchor094">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     7
    </span>
   </h1>
   <h1 id="_idParaDest-95">
    <a id="_idTextAnchor095">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Azure Durable Functions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In the previous chapter, we discussed how HTTP APIs in Azure Functions provide an alternative hosting model, as well as solve many traditional problems associated with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      manual hosting.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     Do you need to massively parallelize hundreds of millions of tasks on an arbitrary number of physical processes or nodes (fan-out) and then wait for them all to complete (fan-in)?
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Do you then need the app to wait for a human or other process to review and take action to continue the next step?
    </span>
    <span class="koboSpan" id="kobo.5.3">
     What if that human is unavailable and you need to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.6.1">
      timeout
     </span>
    </em>
    <span class="koboSpan" id="kobo.7.1">
     the review process instead?
    </span>
    <span class="koboSpan" id="kobo.7.2">
     This situation of events is easily expressible in code, and we’ll be tackling a subset of this scenario in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     In this chapter, we will look at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Expanding on standard APIs to create resilient,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       stateful workflows
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      Differences in debugging these workflows compared to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       previous chapters
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      Interacting and injecting data into live systems using standard
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       HTTP APIs
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      Briefly discussing how to set up other common
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       usage patterns
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-96">
    <a id="_idTextAnchor096">
    </a>
    <span class="koboSpan" id="kobo.19.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.20.1">
     Building Azure Durable Functions in Visual Studio has the same requirements as for
    </span>
    <a href="B21998_06.xhtml#_idTextAnchor077">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.21.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.22.1">
     .
    </span>
    <span class="koboSpan" id="kobo.22.2">
     The source code for this chapter is available at
    </span>
    <a href="https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter07">
     <span class="koboSpan" id="kobo.23.1">
      https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter07
     </span>
    </a>
    <span class="koboSpan" id="kobo.24.1">
     .
    </span>
   </p>
   <h1 id="_idParaDest-97">
    <a id="_idTextAnchor097">
    </a>
    <span class="koboSpan" id="kobo.25.1">
     Overview of Durable Functions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     Durable Functions gets its very descriptive name from what it does under the hood: save its state to persistent storage in case of crashes, outages, dependency
    </span>
    <a id="_idIndexMarker180">
    </a>
    <a id="_idIndexMarker181">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     problems, and so on.
    </span>
    <span class="koboSpan" id="kobo.27.2">
     Not only does this allow for problems to be recovered from easily but it also allows scalability and coordination among tasks.
    </span>
    <span class="koboSpan" id="kobo.27.3">
     Durability in an Azure function is provided using a standard storage account by default.
    </span>
    <span class="koboSpan" id="kobo.27.4">
     Tables, blobs, and queues are all used under
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      the hood:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.29.1">
      Tables are used for managing function execution history, including parameters and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.30.1">
       return values
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.31.1">
      Blob storage is used for the automatic storage of large parameters passed
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.32.1">
       to activities
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.33.1">
      Queues are used for triggering activities and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.34.1">
       orchestration instances
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.35.1">
     SQL Server and Netherite are the other two supported durable store options that are not covered in this book but can be used in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.36.1">
      advanced scenarios.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.37.1">
     While there is never an “easy button” for scaling in a
    </span>
    <a id="_idIndexMarker182">
    </a>
    <a id="_idIndexMarker183">
    </a>
    <span class="koboSpan" id="kobo.38.1">
     distributed system, the following two specific rules simplify an enormous amount of platform- and dependency-related overhead, allowing you to focus on the logic of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      code itself:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.40.1">
      Orchestrator functions must
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.41.1">
       be deterministic
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.42.1">
      Activity functions must
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.43.1">
       be idempotent
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.44.1">
     Orchestrator functions are exactly what they
    </span>
    <a id="_idIndexMarker184">
    </a>
    <a id="_idIndexMarker185">
    </a>
    <span class="koboSpan" id="kobo.45.1">
     sound like: they orchestrate, or control the execution order of, activities, which usually contain the bulk of the work or logic of the application.
    </span>
    <span class="koboSpan" id="kobo.45.2">
     A major restriction that must be followed with orchestrators is that they must be deterministic, which also means that they cannot do any form of I/O directly.
    </span>
    <span class="koboSpan" id="kobo.45.3">
     All activity, sub-orchestrator, or other awaited calls must be in the same order to return the executing code to its exact state just prior to the next
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.46.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.47.1">
     call.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     Other nondeterministic APIs that you must be aware of fall into categories such as DateTimes, GUIDs, I/O, and other async APIs.
    </span>
    <span class="koboSpan" id="kobo.47.3">
     In general, if you need data from outside the durable context, use activities to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      retrieve it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.49.1">
     Activity functions are always called by orchestrators, and cannot be called directly from anything else.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     These are where the bulk of the application logic usually happens, and compared to orchestrators, activity functions have one restriction: they must be idempotent.
    </span>
    <span class="koboSpan" id="kobo.49.3">
     There is no guarantee that an activity instance will run exactly once, so be sure that multiple runs in succession have the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      same result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.51.1">
     Adding durable support to your existing function is as easy as adding a NuGet package.
    </span>
    <span class="koboSpan" id="kobo.51.2">
     All the functions, triggers, and so on can interoperate and coexist in a single project, depending on your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      application requirements.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.53.1">
     Before Durable Functions, in a manually written situation with only basic OS platform support, you had to manage the state yourself.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     This included handling crashes, and marking tasks as done, errored, in progress, and so on.
    </span>
    <span class="koboSpan" id="kobo.53.3">
     Restarts also had to be managed, as did advanced processing such as a parallel fan-out situation.
    </span>
    <span class="koboSpan" id="kobo.53.4">
     Using Durable Functions simplifies all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.54.1">
      these requirements.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.55.1">
     Now, let’s look at starting up a durable instance, and how these objects coordinate tasks in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      stateful system.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-98">
    <a id="_idTextAnchor098">
    </a>
    <span class="koboSpan" id="kobo.57.1">
     Orchestrators
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     The main “entry point” into the
    </span>
    <a id="_idIndexMarker186">
    </a>
    <a id="_idIndexMarker187">
    </a>
    <span class="koboSpan" id="kobo.59.1">
     Durable system is through an orchestrator.
    </span>
    <span class="koboSpan" id="kobo.59.2">
     These are started up inside the running function using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.60.1">
      DurableTaskClient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     , or outside of a function process by using the HTTP management APIs discussed later in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.62.1">
      Programming and debugging walk-through
     </span>
    </em>
    <span class="koboSpan" id="kobo.63.1">
     section.
    </span>
    <span class="koboSpan" id="kobo.63.2">
     I say
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.64.1">
      entry point
     </span>
    </em>
    <span class="koboSpan" id="kobo.65.1">
     because I find it conceptually easier to think about it in this way.
    </span>
    <span class="koboSpan" id="kobo.65.2">
     While the OS process itself still uses the classic
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.66.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.67.1">
     or void
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      Main(...)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     , data or message processing in a Durable system usually begins with a method marked with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.70.1">
      Function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.71.1">
     attribute, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.72.1">
      DurableTaskClient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.73.1">
     marked with an
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.74.1">
       OrchestrationTrigger
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.75.1">
      attribute.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.76.1">
     Serializable data objects, usually in JSON form, can be passed into the orchestrator when an instance is created.
    </span>
    <span class="koboSpan" id="kobo.76.2">
     These can be things such as larger descriptive objects, SAS tokens to blob storage, binary data that must be deserialized, or all of them combined.
    </span>
    <span class="koboSpan" id="kobo.76.3">
     While you can work with standard strings or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.77.1">
      JsonNodes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.78.1">
     (sometimes you must), my preferred way is to use the generic method overloads and create serialization classes to mirror the structure of the data being passed around in the system.
    </span>
    <span class="koboSpan" id="kobo.78.2">
     This ensures that it is easy to modify the objects over time, delegating the type-checking to the compiler.
    </span>
    <span class="koboSpan" id="kobo.78.3">
     This also sidesteps a runtime issue that sometimes occurs during development: missing or mismatched serialization classes, which are not immediately apparent as there would be no standard compilation errors or runtime exceptions.
    </span>
    <span class="koboSpan" id="kobo.78.4">
     The same will apply
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.79.1">
      to activities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.80.1">
     Since orchestration instances are durable and their
    </span>
    <a id="_idIndexMarker188">
    </a>
    <a id="_idIndexMarker189">
    </a>
    <span class="koboSpan" id="kobo.81.1">
     state is written to persistent storage, this means that a running orchestration instance does not need to stay loaded into RAM while it waits for an activity to finish.
    </span>
    <span class="koboSpan" id="kobo.81.2">
     Taking this a step further, it need not resume running on the same OS process, virtual machine, or physical machine.
    </span>
    <span class="koboSpan" id="kobo.81.3">
     This can lead to highly performant and efficient allocation of compute and memory resources.
    </span>
    <span class="koboSpan" id="kobo.81.4">
     In the extreme case, you could have hundreds or thousands of orchestration instances awaiting future completion of tasks, all without using compute or memory, only
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      minimal storage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.83.1">
     Continuing to take this further, you could have an infinite loop that also does not use any compute or memory while awaiting a task.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     This concept, called an eternal orchestrator, could respond to outside events, act, and durably wait until the next event.
    </span>
    <span class="koboSpan" id="kobo.83.3">
     A
    </span>
    <a id="_idIndexMarker190">
    </a>
    <a id="_idIndexMarker191">
    </a>
    <span class="koboSpan" id="kobo.84.1">
     small caveat though: since orchestration instances save their history to rebuild their state in the future, an eternal orchestrator could have an ever-growing history, which would eventually cause performance problems.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     A method called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.85.1">
      ContinueAsNew
     </span>
    </strong>
    <span class="koboSpan" id="kobo.86.1">
     truncates that history, which prevents it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.87.1">
      from growing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.88.1">
     With any API or stateful workflow, you’ll almost certainly need to process something, make network calls, and so on.
    </span>
    <span class="koboSpan" id="kobo.88.2">
     Since we are unable to do so in orchestrators, this is where activities
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.89.1">
      come in.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-99">
    <a id="_idTextAnchor099">
    </a>
    <span class="koboSpan" id="kobo.90.1">
     Activities
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     The pieces of code that actually
    </span>
    <a id="_idIndexMarker192">
    </a>
    <a id="_idIndexMarker193">
    </a>
    <span class="koboSpan" id="kobo.92.1">
     contain most of your logic are activities.
    </span>
    <span class="koboSpan" id="kobo.92.2">
     They have one very specific requirement: they must be idempotent.
    </span>
    <span class="koboSpan" id="kobo.92.3">
     This means your code must have no side effects if it happens to execute more than once, as there is no guarantee that a specific instance will execute exactly once.
    </span>
    <span class="koboSpan" id="kobo.92.4">
     Due to various reasons, some out of your control, activities may be terminated in the middle of execution.
    </span>
    <span class="koboSpan" id="kobo.92.5">
     This must be handled in your activity code so that when the Durable system detects an incomplete instance, starting from the beginning is not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.93.1">
      a problem.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.94.1">
     Various built-in programming constructs that you would normally not think about, now have a profound potential impact on the rest of the system.
    </span>
    <span class="koboSpan" id="kobo.94.2">
     For example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.95.1">
      Guid.NewGuid()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.96.1">
     should likely not be used in an activity.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     Creating files, saving database records, or calling other APIs with this random GUID could now result in an orphaned record if the activity needed to be restarted from the beginning.
    </span>
    <span class="koboSpan" id="kobo.96.3">
     Instead, you could create the new GUID inside the orchestrator, and pass that into the activity with its object
    </span>
    <a id="_idIndexMarker194">
    </a>
    <a id="_idIndexMarker195">
    </a>
    <span class="koboSpan" id="kobo.97.1">
     parameter.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.98.1">
      TaskOrchestrationContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.99.1">
     instance passed into the orchestrator has a specific method called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.100.1">
      NewGuid
     </span>
    </strong>
    <span class="koboSpan" id="kobo.101.1">
     to facilitate this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.102.1">
      exact need.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-100">
    <a id="_idTextAnchor100">
    </a>
    <span class="koboSpan" id="kobo.103.1">
     Programming and debugging walk-through
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.104.1">
     Using the existing
    </span>
    <a href="B21998_06.xhtml#_idTextAnchor077">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.105.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.106.1">
     function code, let’s add support for
    </span>
    <a id="_idIndexMarker196">
    </a>
    <a id="_idIndexMarker197">
    </a>
    <span class="koboSpan" id="kobo.107.1">
     Durable to it.
    </span>
    <span class="koboSpan" id="kobo.107.2">
     Right-click on the project and select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.108.1">
      Add
     </span>
    </strong>
    <span class="koboSpan" id="kobo.109.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.110.1">
      New Azure Function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.111.1">
     just as you did with the first HTTP endpoint.
    </span>
    <span class="koboSpan" id="kobo.111.2">
     Give it a name, and then select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.112.1">
      Durable
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.113.1">
       Functions Orchestration
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.114.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer067">
     <span class="koboSpan" id="kobo.115.1">
      <img alt="Figure 7.1 – Adding a new Durable Functions orchestration" src="image/B21998_07_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.116.1">
     Figure 7.1 – Adding a new Durable Functions orchestration
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.117.1">
     You can see from the provided template that three static methods were created corresponding to each of the concepts we discussed earlier: a regular function with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.118.1">
      HttpTrigger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.119.1">
     , which schedules a new orchestration instance to run, which then calls one or more activities.
    </span>
    <span class="koboSpan" id="kobo.119.2">
     Visual Studio should have added a reference to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.120.1">
      Microsoft.Azure.Functions.Worker.Extensions.DurableTask
     </span>
    </strong>
    <span class="koboSpan" id="kobo.121.1">
     automatically, but add it via NuGet if it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.122.1">
      did not.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.123.1">
     Note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.124.1">
     Notice that these methods are all static.
    </span>
    <span class="koboSpan" id="kobo.124.2">
     Though this does work, it leaves a lot to be desired as it prevents impactful concepts discussed in the last chapter such as options, dependency injection, and easier testing.
    </span>
    <span class="koboSpan" id="kobo.124.3">
     Durable Functions also supports migrating the code to the non-static style in the previous chapter.
    </span>
    <span class="koboSpan" id="kobo.124.4">
     This exercise is left up to you.
    </span>
    <span class="koboSpan" id="kobo.124.5">
     We are using the word “the” when referring to the orchestrator and activity we are working on.
    </span>
    <span class="koboSpan" id="kobo.124.6">
     This may seem out of place since we are referring to single static methods and not necessarily an object or thing you can see visually.
    </span>
    <span class="koboSpan" id="kobo.124.7">
     The same static method may also be executing in different threads, processes, and virtual machines concurrently with different data.
    </span>
    <span class="koboSpan" id="kobo.124.8">
     If you do decide to undertake the code migration, the individual files with regular constructors and non-static methods may help you conceptually
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      visualize them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.126.1">
     We’ll focus on saving some data to a file and waiting for an event that will then update the file again.
    </span>
    <span class="koboSpan" id="kobo.126.2">
     Let’s begin by deleting the contents of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.127.1">
      SayHello
     </span>
    </strong>
    <span class="koboSpan" id="kobo.128.1">
     method, which contains a string parameter,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.129.1">
      name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.130.1">
     , with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.131.1">
      ActivityTrigger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.132.1">
     on it.
    </span>
    <span class="koboSpan" id="kobo.132.2">
     This is your one and only
    </span>
    <a id="_idIndexMarker198">
    </a>
    <a id="_idIndexMarker199">
    </a>
    <span class="koboSpan" id="kobo.133.1">
     parameter that can be passed to your activity from your orchestrator.
    </span>
    <span class="koboSpan" id="kobo.133.2">
     Though this can be a string, generally, it is some kind of data transfer or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.134.1">
      Plain Old C# Class
     </span>
    </strong>
    <span class="koboSpan" id="kobo.135.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.136.1">
      POCO
     </span>
    </strong>
    <span class="koboSpan" id="kobo.137.1">
     ) object that must be JSON serializable.
    </span>
    <span class="koboSpan" id="kobo.137.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.138.1">
      FunctionContext executionContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.139.1">
     parameter can be used to
    </span>
    <a id="_idIndexMarker200">
    </a>
    <a id="_idIndexMarker201">
    </a>
    <span class="koboSpan" id="kobo.140.1">
     discover information about the running activity, among other things.
    </span>
    <span class="koboSpan" id="kobo.140.2">
     Change the return type to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.141.1">
      Task&lt;string&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.142.1">
     , and add a line that awaits a call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      File.WriteAllTextAsync
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     , giving it a filename of your choosing, and then the contents will be the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.145.1">
      name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.146.1">
     string parameter marked with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.147.1">
      ActivityTrigger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.148.1">
     .
    </span>
    <span class="koboSpan" id="kobo.148.2">
     Rename this parameter and its references to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.149.1">
      contents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.150.1">
     by pressing
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.151.1">
      F2
     </span>
    </em>
    <span class="koboSpan" id="kobo.152.1">
     .
    </span>
    <span class="koboSpan" id="kobo.152.2">
     This activity is simple and straightforward, which will add extra value to the orchestrator when we use it more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.153.1">
      than once.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.154.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.155.1">
      SayHello
     </span>
    </strong>
    <span class="koboSpan" id="kobo.156.1">
     method should
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.157.1">
      resemble this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.158.1">
[Function(nameof(SayHello))]
public static async Task&lt;string&gt; SayHello([ActivityTrigger] string contents, FunctionContext executionContext)
{
    await File.WriteAllTextAsync(“myfile.txt”, contents);
    return default;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.159.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.160.1">
      RunOrchestrator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     method, delete the contents and add an awaited call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      context.CallActivityAsync
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     , passing it the name of the activity, which, in our case, is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.164.1">
      SayHello
     </span>
    </strong>
    <span class="koboSpan" id="kobo.165.1">
     .
    </span>
    <span class="koboSpan" id="kobo.165.2">
     Change the return to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      Task&lt;object&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     and then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      return default
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     to make the compiler happy.
    </span>
    <span class="koboSpan" id="kobo.169.2">
     Add an awaited call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.170.1">
      context.WaitForExternalEvent&lt;ExpandoObject&gt;(“MyEvent”)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.171.1">
     after that, and save that into a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.172.1">
      dynamic
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     variable.
    </span>
    <span class="koboSpan" id="kobo.173.2">
     Finally, let’s add another call to our first activity, but this time, pass it the dynamic awaited event’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     property that we received from the external
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.176.1">
      event call.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.177.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.178.1">
     Though you can use a normal double-quoted string when calling an activity via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.179.1">
      CallActivityAsync
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     , using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.181.1">
      nameof
     </span>
    </strong>
    <span class="koboSpan" id="kobo.182.1">
     expression is particularly powerful here as it not only evaluates to a string during compile time but also responds to symbol renaming.
    </span>
    <span class="koboSpan" id="kobo.182.2">
     We’ll use this in the sample.
    </span>
    <span class="koboSpan" id="kobo.182.3">
     The same idea can be used for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.183.1">
      WaitForExternalEvent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.184.1">
     by using the POCO class name,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.185.1">
      for example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      RunOrchestrator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     method should
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.189.1">
      resemble this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.190.1">
[Function(nameof(MyOrchestrator))]
public static async Task&lt;object&gt; RunOrchestrator(
    [OrchestrationTrigger] TaskOrchestrationContext context)
{
    await context.CallActivityAsync(nameof(SayHello)
);
    dynamic eventValue = await context.
</span><span class="koboSpan" id="kobo.190.2">    WaitForExternalEvent&lt;ExpandoObject&gt;(“MyEvent”);
    await context.CallActivityAsync(nameof(SayHello)
    , eventValue.value);
    return default;
}</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.191.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.192.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.193.1">
      Function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.194.1">
     runtime mandates that we pass JSON data to this endpoint, which would then be automatically deserialized and returned from our awaited
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.195.1">
      WaitForExternalEvent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.196.1">
     call.
    </span>
    <span class="koboSpan" id="kobo.196.2">
     This ensures a baseline level of backward compatibility in case things need to change in the future.
    </span>
    <span class="koboSpan" id="kobo.196.3">
     For our testing purposes, we are using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.197.1">
      dynamic
     </span>
    </strong>
    <span class="koboSpan" id="kobo.198.1">
     to reduce the number of boilerplate files that would need to be created during this chapter.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.199.1">
     Let’s start debugging in Visual Studio, and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.200.1">
      Ctrl
     </span>
    </em>
    <span class="koboSpan" id="kobo.201.1">
     /
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.202.1">
      CMD
     </span>
    </em>
    <span class="koboSpan" id="kobo.203.1">
     click on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.204.1">
      MyOrchestrator_HttpStart
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     HTTP trigger to run our orchestrator entrypoint.
    </span>
    <span class="koboSpan" id="kobo.205.2">
     Navigate to the output folder on the function, likely in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      bin/debug/net8.0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     , and
    </span>
    <a id="_idIndexMarker202">
    </a>
    <a id="_idIndexMarker203">
    </a>
    <span class="koboSpan" id="kobo.208.1">
     notice there’s an empty file.
    </span>
    <span class="koboSpan" id="kobo.208.2">
     This is the result of the first call to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.209.1">
      SayHello
     </span>
    </strong>
    <span class="koboSpan" id="kobo.210.1">
     activity.
    </span>
    <span class="koboSpan" id="kobo.210.2">
     What is the function doing now?
    </span>
    <span class="koboSpan" id="kobo.210.3">
     It is currently awaiting the call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      WaitForExternalEvent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     .
    </span>
    <span class="koboSpan" id="kobo.212.2">
     Copy or save the URI specified by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.213.1">
      sendEventPostUri
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     element, as we’ll need that in a moment.
    </span>
    <span class="koboSpan" id="kobo.214.2">
     Let’s stop debugging now so that the physical application process terminates.
    </span>
    <span class="koboSpan" id="kobo.214.3">
     Immediately start debugging again, but do not click on the link again to start a new instance.
    </span>
    <span class="koboSpan" id="kobo.214.4">
     Our previous instance is still “running” in the Durable Functions sense, only it is not taking up memory, CPU, or any other OS resource, except for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.215.1">
      storage space.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.216.1">
     Open up your favorite REST client interface such as the new built-in one from Visual Studio, Postman, and so on.
    </span>
    <span class="koboSpan" id="kobo.216.2">
     You’ll need the URI you copied previously to signal our running orchestration instance event.
    </span>
    <span class="koboSpan" id="kobo.216.3">
     We’ll be using Visual Studio.
    </span>
    <span class="koboSpan" id="kobo.216.4">
     Create a new text file by right-clicking on the project, selecting
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.217.1">
      Add
     </span>
    </strong>
    <span class="koboSpan" id="kobo.218.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.219.1">
      New Item...
     </span>
    </strong>
    <span class="koboSpan" id="kobo.220.1">
     , and then selecting
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.221.1">
      Text File
     </span>
    </strong>
    <span class="koboSpan" id="kobo.222.1">
     .
    </span>
    <span class="koboSpan" id="kobo.222.2">
     The name of this file should end with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.223.1">
      .http
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     so that Visual Studio recognizes it.
    </span>
    <span class="koboSpan" id="kobo.224.2">
     Type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.225.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     in all uppercase, and then paste in the URI that you copied earlier.
    </span>
    <span class="koboSpan" id="kobo.226.2">
     Replace
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.227.1">
      {eventName}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     with the name that you chose in the code; we used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.229.1">
      MyEvent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.230.1">
     .
    </span>
    <span class="koboSpan" id="kobo.230.2">
     Add a header with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      Content-Type: application/json
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     value so that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.233.1">
      Function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.234.1">
     runtime accepts it.
    </span>
    <span class="koboSpan" id="kobo.234.2">
     Ensure that there is an empty line after
    </span>
    <a id="_idIndexMarker204">
    </a>
    <a id="_idIndexMarker205">
    </a>
    <span class="koboSpan" id="kobo.235.1">
     the URI, then type some valid JSON with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.236.1">
      value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.237.1">
     property and value.
    </span>
    <span class="koboSpan" id="kobo.237.2">
     To end the body of the request, make sure that there is also an empty
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.238.1">
      line afterward.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer068">
     <span class="koboSpan" id="kobo.239.1">
      <img alt="Figure 7.2 – REST client setup in Visual Studio" src="image/B21998_07_2.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.240.1">
     Figure 7.2 – REST client setup in Visual Studio
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     Switch to the orchestrator file and place a breakpoint on both calls to our activity.
    </span>
    <span class="koboSpan" id="kobo.241.2">
     Send the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.242.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.243.1">
     request using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.244.1">
      Send
     </span>
    </strong>
    <span class="koboSpan" id="kobo.245.1">
     request link in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.246.1">
      .http
     </span>
    </strong>
    <span class="koboSpan" id="kobo.247.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.247.2">
     The first breakpoint should now hit.
    </span>
    <span class="koboSpan" id="kobo.247.3">
     But wait, why was the first one hit when we already ran this line and are waiting on the line after that?
    </span>
    <span class="koboSpan" id="kobo.247.4">
     Hover over the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.248.1">
      context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     variable and expand it to look at the read-only
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.250.1">
      IsReplaying
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     property.
    </span>
    <span class="koboSpan" id="kobo.251.2">
     Notice that it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      is
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.253.1">
       true
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer069">
     <span class="koboSpan" id="kobo.255.1">
      <img alt="Figure 7.3 – IsReplaying is true" src="image/B21998_07_3.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.256.1">
     Figure 7.3 – IsReplaying is true
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     This is exactly what the property’s name sounds like; it is quite literally rebuilding its internal state line by line.
    </span>
    <span class="koboSpan" id="kobo.257.2">
     It will do this after every single
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.258.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.259.1">
     .
    </span>
    <span class="koboSpan" id="kobo.259.2">
     This is why orchestrators must be deterministic so that the internal state is always exactly the same no matter how many times it must rerun the same logic over and over.
    </span>
    <span class="koboSpan" id="kobo.259.3">
     Every single call to these
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.260.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.261.1">
     methods is saved in durable storage.
    </span>
    <span class="koboSpan" id="kobo.261.2">
     At some point in the future, they are queried, deserialized, and returned to the calling orchestrator.
    </span>
    <span class="koboSpan" id="kobo.261.3">
     Press
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.262.1">
      F10
     </span>
    </em>
    <span class="koboSpan" id="kobo.263.1">
     to step over the first activity call, and check to see that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.264.1">
      IsReplaying
     </span>
    </strong>
    <span class="koboSpan" id="kobo.265.1">
     property is still
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.266.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     .
    </span>
    <span class="koboSpan" id="kobo.267.2">
     Step again over
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.268.1">
      WaitForExternalEvent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.269.1">
     , which should return immediately.
    </span>
    <span class="koboSpan" id="kobo.269.2">
     Now, look at the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.270.1">
      IsReplaying
     </span>
    </strong>
    <span class="koboSpan" id="kobo.271.1">
     property again; it should be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.272.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.273.1">
     .
    </span>
    <span class="koboSpan" id="kobo.273.2">
     This means it is the very first time that this code has been run for this orchestration instance.
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer070">
     <span class="koboSpan" id="kobo.274.1">
      <img alt="Figure 7.4 – IsReplaying is false" src="image/B21998_07_4.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.275.1">
     Figure 7.4 – IsReplaying is false
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.276.1">
     Press
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.277.1">
      F5
     </span>
    </em>
    <span class="koboSpan" id="kobo.278.1">
     to continue; it should immediately call the activity.
    </span>
    <span class="koboSpan" id="kobo.278.2">
     Navigate to the output folder again and open the file.
    </span>
    <span class="koboSpan" id="kobo.278.3">
     You should see the contents of the value property that you set in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.279.1">
      .http
     </span>
    </strong>
    <span class="koboSpan" id="kobo.280.1">
     file’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.281.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.282.1">
     request.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     The orchestration instance is now
    </span>
    <a id="_idIndexMarker206">
    </a>
    <a id="_idIndexMarker207">
    </a>
    <span class="koboSpan" id="kobo.283.1">
     completed.
    </span>
    <span class="koboSpan" id="kobo.283.2">
     If you query durable storage, you’ll find the complete history of this orchestration instance, including all input and output parameters, errors if there are any, and timestamps.
    </span>
    <span class="koboSpan" id="kobo.283.3">
     This will allow you to analyze the orchestration instance later if needed or for tracking, logging, and so on.
    </span>
    <span class="koboSpan" id="kobo.283.4">
     We’ll look at how to view this in a moment.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.284.1">
     Waiting on activities, external events, and sub-orchestrators is powerful all on its own.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     However, we can take it one step further.
    </span>
    <span class="koboSpan" id="kobo.284.3">
     Using the existing language features such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.285.1">
      List&lt;Task&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.287.1">
      Task.WhenAny
     </span>
    </strong>
    <span class="koboSpan" id="kobo.288.1">
     , or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.289.1">
      Task.WhenAll
     </span>
    </strong>
    <span class="koboSpan" id="kobo.290.1">
     , we can have an arbitrarily long stateful execution system.
    </span>
    <span class="koboSpan" id="kobo.290.2">
     This can scale, wait for potentially hundreds or thousands of activity instances to run, and then move on to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.291.1">
      next code.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.292.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.293.1">
     Using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.294.1">
      Task.WhenAny
     </span>
    </strong>
    <span class="koboSpan" id="kobo.295.1">
     , we can wait on an external human event or a timeout.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     This allows us to default to an action if an external event is not received
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      in time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.297.1">
     To have an easier time debugging, you’re likely to want to be familiar with clearing the durable storage.
    </span>
    <span class="koboSpan" id="kobo.297.2">
     This allows you to start from a clean state.
    </span>
    <span class="koboSpan" id="kobo.297.3">
     If you have many outstanding orchestration instances, timers, and so on, it can be difficult when debugging anything in the same project.
    </span>
    <span class="koboSpan" id="kobo.297.4">
     Using Azure Storage Explorer, navigate to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.298.1">
      Emulator &amp; Attached
     </span>
    </strong>
    <span class="koboSpan" id="kobo.299.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.300.1">
      (Emulator – Default Ports) (Key)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.301.1">
     |
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.302.1">
      Tables
     </span>
    </strong>
    <span class="koboSpan" id="kobo.303.1">
     , and open two tables that end with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.304.1">
      History
     </span>
    </strong>
    <span class="koboSpan" id="kobo.305.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.306.1">
      Instances
     </span>
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     .
    </span>
    <span class="koboSpan" id="kobo.307.2">
     Look around for a bit to see how the data is physically stored if interested.
    </span>
    <span class="koboSpan" id="kobo.307.3">
     When
    </span>
    <a id="_idIndexMarker208">
    </a>
    <a id="_idIndexMarker209">
    </a>
    <span class="koboSpan" id="kobo.308.1">
     done, right-click on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.309.1">
      History
     </span>
    </strong>
    <span class="koboSpan" id="kobo.310.1">
     table and select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.311.1">
      Delete
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     .
    </span>
    <span class="koboSpan" id="kobo.312.2">
     Do the same
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      for
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.314.1">
       Instances
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer071">
     <span class="koboSpan" id="kobo.316.1">
      <img alt="Figure 7.5 – Clearing the local History table" src="image/B21998_07_5.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.317.1">
     Figure 7.5 – Clearing the local History table
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.318.1">
     There are additional advanced topics not covered here.
    </span>
    <span class="koboSpan" id="kobo.318.2">
     Some of them are durable entities, and a counterpart, critical sections (.NET only).
    </span>
    <span class="koboSpan" id="kobo.318.3">
     These together let you coordinate distributed locks inside
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.319.1">
      an orchestrator.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-101">
    <a id="_idTextAnchor101">
    </a>
    <span class="koboSpan" id="kobo.320.1">
     Additional options
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.321.1">
     Sometimes, you want an orchestrator to continuously wait for an external event without ever exiting.
    </span>
    <span class="koboSpan" id="kobo.321.2">
     Using a standard
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.322.1">
      for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.323.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.324.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.325.1">
     loop around the
    </span>
    <a id="_idIndexMarker210">
    </a>
    <a id="_idIndexMarker211">
    </a>
    <span class="koboSpan" id="kobo.326.1">
     call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      WaitForExternalEvent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     is reasonable for a low number of events.
    </span>
    <span class="koboSpan" id="kobo.328.2">
     But recall how previously I mentioned that every single
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.329.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.330.1">
     is some type of network call to the durable storage.
    </span>
    <span class="koboSpan" id="kobo.330.2">
     Having
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.331.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.332.1">
     inside of a loop has the potential to drastically increase the latency for building up the internal state.
    </span>
    <span class="koboSpan" id="kobo.332.2">
     An alternative way to support this exact scenario is to use eternal orchestrations with a call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.333.1">
      ContinueAsNew
     </span>
    </strong>
    <span class="koboSpan" id="kobo.334.1">
     .
    </span>
    <span class="koboSpan" id="kobo.334.2">
     Though these are especially suited for the situation described, it’s worth noting that they have some considerations you need to keep in mind.
    </span>
    <span class="koboSpan" id="kobo.334.3">
     While they do prevent the continuous growth of durable storage for that instance, they do so by truncating the history.
    </span>
    <span class="koboSpan" id="kobo.334.4">
     This may be acceptable in your situation, but it could also not be.
    </span>
    <span class="koboSpan" id="kobo.334.5">
     Note that while you have lost the underlying execution history in the durable store, nothing is preventing you from manually logging things that you need or want to keep.
    </span>
    <span class="koboSpan" id="kobo.334.6">
     You could have a logging activity in place throughout your code to log various important events to, for example, Table storage.
    </span>
    <span class="koboSpan" id="kobo.334.7">
     There’s also the option of logging to Application Insights.
    </span>
    <span class="koboSpan" id="kobo.334.8">
     However, Insights is not a permanent log
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.335.1">
      storage solution.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.336.1">
     Sometimes, you want a single instance of a global orchestrator throughout your entire application.
    </span>
    <span class="koboSpan" id="kobo.336.2">
     These can be useful in background tasks, for example.
    </span>
    <span class="koboSpan" id="kobo.336.3">
     This is accomplished with what is known as singleton orchestrators.
    </span>
    <span class="koboSpan" id="kobo.336.4">
     It does not have a
    </span>
    <a id="_idIndexMarker212">
    </a>
    <a id="_idIndexMarker213">
    </a>
    <span class="koboSpan" id="kobo.337.1">
     specific method call per se, but to enable this functionality, all you need to do is start an orchestration instance normally with a specified instance ID that will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      not change.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-102">
    <a id="_idTextAnchor102">
    </a>
    <span class="koboSpan" id="kobo.339.1">
     Exceptions
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.340.1">
     While most programming
    </span>
    <a id="_idIndexMarker214">
    </a>
    <a id="_idIndexMarker215">
    </a>
    <span class="koboSpan" id="kobo.341.1">
     constructs are available, a bit of special care must be taken when working with exceptions.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     Using C#, we do have first-class handling of them.
    </span>
    <span class="koboSpan" id="kobo.341.3">
     However, since this is potentially across a process boundary, a notable incompatibility is when catching derived exception types.
    </span>
    <span class="koboSpan" id="kobo.341.4">
     You should, in general, catch the normal base exception, and then handle
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      it appropriately.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-103">
    <a id="_idTextAnchor103">
    </a>
    <span class="koboSpan" id="kobo.343.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.344.1">
     In this chapter, we discussed how the durable orchestration system comprising activities and orchestrators helps to solve a wide variety of use cases.
    </span>
    <span class="koboSpan" id="kobo.344.2">
     We then walked through adding Durable Functions to our existing Functions code from the previous chapter.
    </span>
    <span class="koboSpan" id="kobo.344.3">
     Via debugging, we demonstrated how the orchestrator rebuilds its internal state, and how to get information into a running orchestration instance.
    </span>
    <span class="koboSpan" id="kobo.344.4">
     We then discussed some helpful tips to clear the local durable store during development and touched on some additional features and pitfalls.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.345.1">
     In the next chapter, we‘ll take a look at related concepts including Table storage, Aspire, and some additional advanced
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.346.1">
      API topics.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-104">
    <a id="_idTextAnchor104">
    </a>
    <span class="koboSpan" id="kobo.347.1">
     You try it
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     Create or modify an existing HTTP trigger to start a new Orchestration instance.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     Have your new Orchestrator await at least two Activities (they can be the same one) so you can debug and step through to watch it rebuild its internal state.
    </span>
    <span class="koboSpan" id="kobo.348.3">
     The Activity can be something minimal for this, a single API call to anywhere or something else.
    </span>
    <span class="koboSpan" id="kobo.348.4">
     After it completes, view the Table Storage durable logs in Azure or Azure Storage Explorer.
    </span>
    <span class="koboSpan" id="kobo.348.5">
     Examine how the logs in the history table line up with your orchestrator.
    </span>
   </p>
  </div>
 </body></html>