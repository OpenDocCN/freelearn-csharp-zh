<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-133"><a id="_idTextAnchor708"/>8</h1>
<h1 id="_idParaDest-134"><a id="_idTextAnchor709"/>Building a Weather App for Multiple Form Factors</h1>
<p>.NET MAUI isn’t just for creating apps for phones; it can also be used to create apps for tablets and desktop computers. In this chapter, we will build an app that will work on all of these platforms and optimize the user interface for each form factor. As well as using three different form factors, we are also going to be working on four different operating systems: iOS, macOS, Android, and Windows.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Using <code>FlexLayout</code> in .NET MAUI</li>
<li>Using <code>VisualStateManager</code></li>
<li>Using different views for different form factors</li>
<li>Using behaviors</li>
</ul>
<p>Let’s get started!</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor710"/>Technical requirements</h1>
<p>To work on this project, we need to have Visual Studio for Mac or PC installed, as well as the necessary .NET MAUI components. See <a id="_idTextAnchor711"/><em class="italic">Chapter 1</em>, <em class="italic">Introduction to .NET MAUI</em>, for more details on how to set up your environment. To build an iOS app using Visual Studio for PC, you need to have a Mac connected. If you don’t have access to a Mac at all, you can choose to just work on the Windows and Android parts of this project. Similarly, if you only have a Mac, you can choose to work on only the iOS and Android parts of this project.</p>
<p>You can find the full source for the code in this chapter at <a id="_idTextAnchor712"/><a href="https://github.com/PacktPubliching/MAUI-Projects-3rd-Edition">https://github.com/PacktPubliching/MAUI-Projects-3rd-Edition</a>.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor713"/><a id="_idTextAnchor714"/>Project overview</h1>
<p>Applications for iOS and Android can run on both phones and tablets. Often, apps are just optimized <a id="_idIndexMarker786"/>for phones. In this chapter, we will build an app that will work on different form factors, but we aren’t going to stick to just phones and tablets – we are going to target desktop computers as well. The desktop version will be for <strong class="bold">Window UI Library</strong> (<strong class="bold">WinUI</strong>) and macOS via Mac Catalyst.</p>
<p>The app that we are going to build is a weather app that displays the weather forecast<a id="_idTextAnchor715"/> based on the location of the user. For this chapter, we will be referencing Visual Studio for Mac in the instructions. If you are using Visual Studio for Windows, you should be able to follow along. Use one of the other chapters for reference if you need help.<a id="_idTextAnchor716"/></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor717"/>Building the weather app</h1>
<p>It’s time to <a id="_idIndexMarker787"/>start building the app. Create a new blank .NET MAUI ap<a id="_idTextAnchor718"/>p using the following steps for Visual Studio for Mac<a id="_idTextAnchor719"/>:</p>
<ol>
<li>Open Visual Studio for Mac and click on <strong class="bold">New</strong>:</li>
</ol>
<div><div><img alt="Figure 8.1 – Visual Studio 2022 for Mac start screen" src="img/B19214_08_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Visual Studio 2022 for Mac start screen</p>
<ol>
<li value="2">In the <strong class="bold">Choose </strong><strong class="bold"><a id="_idIndexMarker788"/></strong><strong class="bold">a template for your new project</strong> dialog, use the<strong class="bold"> .NET MAUI App</strong> template, which is under<strong class="bold"> Multiplatform | App</strong>, then click <strong class="bold">Continue</strong>:</li>
</ol>
<div><div><img alt="Figure 8.2 – New project " src="img/B19214_08_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – New project </p>
<ol>
<li value="3">In the <strong class="bold">Configure </strong><strong class="bold"><a id="_idIndexMarker789"/></strong><strong class="bold">your new .NET MAUI App</strong> dialog, ensure the <strong class="bold">.NET 7.0</strong> target framework is selected, then click <strong class="bold">Continue</strong>:</li>
</ol>
<div><div><img alt="Figure 8.3 – Choosing the target framework" src="img/B19214_08_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Choosing the target framework</p>
<ol>
<li value="4">In the <code>Weather</code>, then click <strong class="bold">Create</strong>:</li>
</ol>
<div><div><img alt="Figure 8.4 – Naming the new app" src="img/B19214_08_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Naming the new app</p>
<p>If you run <a id="_idIndexMarker791"/>the app now, you should see something like the following:</p>
<div><div><img alt="Figure 8.5 – Weather app on macOS" src="img/B19214_08_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Weather app on macOS</p>
<p>Now that we <a id="_idIndexMarker792"/>have created the project from a template, it’s time to start coding<a id="_idTextAnchor720"/>!</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor721"/>Creating models for the weather data</h2>
<p>Before we write the code to fetch data from the external weather service, we will create models to <a id="_idIndexMarker793"/>deserialize the results from the service. We will do this so that we have a common model that we can use to return data from the service.</p>
<p>As the data source for this app, we will use an external Weather API. This project will use <strong class="bold">OpenWeatherMap</strong>, a service <a id="_idIndexMarker794"/>that offers a couple of free APIs. You can find this service at <a href="https://openweathermap.org/api">https://openweathermap.org/api</a>. We will use the <strong class="bold">5 day / 3 hour forecast</strong> service in this project, which provides a 5-day forecast in 3-hour intervals. To use the OpenWeatherMap API, we have to create an account to get an API key. If you don’t want<a id="_idTextAnchor722"/> to create an API key, you can mock the data instead.</p>
<p>Follow the instructions at <a href="https://home.openweathermap.org/users/sign_up">https://home.openweathermap.org/users/sign_up</a> to create your account and get your API key, which you will need to call the API.</p>
<p>The easiest <a id="_idIndexMarker795"/>way to generate models to use when we are deserializing results from the service is to make a call to the service either in the browser or with <a id="_idIndexMarker796"/>a tool (such as <code>https://api.openweathermap.org/data/2.5/forecast?lat=44.34&amp;lon=10.99&amp;appid={API key}</code> in your browser, replacing <code>{API KEY}</code> with your API key.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you got a 401 error, please wait a couple of hours before you can use your API, as mentioned at <a href="https://openweathermap.org/faq#error401">https://openweathermap.org/faq#error401</a>.</p>
<p>We can create classes manually or use a tool that can generate C# classes from the JSON. One tool that <a id="_idIndexMarker797"/>can be used is <strong class="bold">quicktype</strong>, which can be found at <a href="https://quicktype.io/">https://quicktype.io/</a>. Just paste the output from the API call into quicktype to generate your C# models.</p>
<p>If you generate them using a tool, make sure you set the namespace to <code>Weather.Models</code>.</p>
<p>As mentioned previously, you can also create these models manually. We will describe how to do this in the next se<a id="_idTextAnchor723"/><a id="_idTextAnchor724"/><a id="_idTextAnchor725"/><a id="_idTextAnchor726"/>ction.</p>
<h3>Adding the Weather API models manually</h3>
<p>If you wish to add the models manually, then go through the following instructions. We will be <a id="_idIndexMarker798"/>adding a single code file called <code>WeatherData.cs</code>, which will contain multiple classes:</p>
<ol>
<li>Create a folder called <code>Models</code>.</li>
<li>Add a file called <code>WeatherData.cs</code> to the newly created folder.</li>
<li>Add the <a id="_idIndexMarker799"/>following code to the <code>WeatherData.<a id="_idTextAnchor727"/>cs</code> file:<pre class="source-code">
using System.Collections.Generic;
namespace Weather.Models
{
    public class Main
    {
        public double temp { get; set; }
        public double temp_min { get; set; }
        public double temp_max { get; set; }
        public double pressure { get; set; }
        public double sea_level { get; set; }
        public double grnd_level { get; set; }
        public int humidity { get; set; }
        public double temp_kf { get; set; }
    }
    public class Weather
    {
        public int id { get; set; }
        public string main { get; set; }
        public string description { get; set; }
        public string icon { get; set; }
    }
    public class Clouds
    {
        public int all { get; set; }
    }
    public class Wind
    {
        public double speed { get; set; }
        public double deg { get; set; }
    }
    public class Rain
    {
    }
    public class Sys
    {
        public string pod { get; set; }
    }
    public class List
    {
        public long dt { get; set; }
        public Main main { get; set; }
        public List&lt;Weather&gt; weather { get; set; }
        public Clouds clouds { get; set; }
        public Wind wind { get; set; }
        public Rain rain { get; set; }
        public Sys sys { get; set; }
        public string dt_txt { get; set; }
    }
    public class Coord
    {
        public double lat { get; set; }
        public double lon { get; set; }
    }
    public class City
    {
        public int id { get; set; }
        public string name { get; set; }
        public Coord coord { get; set; }
        public string country { get; set; }
    }
    public class WeatherData
    {
        public string cod { get; set; }
        public double message { get; set; }
        public int cnt { get; set; }
        public List&lt;List&gt; list { get; set; }
        public City city { get; set; }
    }
}</pre></li> </ol>
<p>As you <a id="_idIndexMarker800"/>can see, there are quite a lot of classes. These classes map directly to the respon<a id="_idTextAnchor728"/>se we get from the service. In most cases, you only want to use these classes when communicating with the service. To represent the data in your app, you will need to use a second set of classes that exposes only the information you need in <a id="_idTextAnchor729"/><a id="_idTextAnchor730"/><a id="_idTextAnchor731"/>your app.</p>
<h3>Adding the app-specific models</h3>
<p>In this section, we will create the models that our app will translate the Weather API models <a id="_idIndexMarker801"/>into. Let’s start by adding the <code>WeatherData</code> class (unless you created this manually in the preceding section):</p>
<ol>
<li>Create a new folder called <code>Models</code> in the <code>Weather</code> project.</li>
<li>Add a new file called <code>WeatherData.cs</code>.</li>
<li>Paste the generated code from quicktype or write the code for the classes based on the JSON. If code other than the properties is generated, ignore it and just use the properties.</li>
<li>Rename <code>MainClass</code> (this is what <code>WeatherData</code>.</li>
</ol>
<p>Now, we will create models based on the data we are interested in. This will mak<a id="_idTextAnchor732"/>e the rest of the code more loosely coupled to the da<a id="_idTextAnchor733"/><a id="_idTextAnchor734"/>ta source.</p>
<h3>Adding the ForecastItem model</h3>
<p>The first <a id="_idIndexMarker802"/>model we are going to add is <code>ForecastItem</code>, which represents a specific forecast for a point in time. We can do this as follows:</p>
<ol>
<li>In the <code>Weather</code> project and the <code>Models</code> folder, create a new class called <code>ForecastItem</code>.</li>
<li>Add the following code:<pre class="source-code">
using System;
using System.Collections.Generic;
namespace Weather.Models
{
    public class ForecastItem
    {
        public DateTime DateTime { get; set; }
        public string TimeAsString =&gt; DateTime.ToShortTimeString();
        public double Temperature { get; set; }
        public double WindSpeed { get; set; }
        public string Description { get; set; }
        public string Icon { get; set; }
    }
}</pre></li> </ol>
<p>Now that <a id="_idIndexMarker803"/>we have a model for each forecast, we need a container model that will group <code>ForecastIt<a id="_idTextAnchor735"/><a id="_idTextAnchor736"/>ems</code> by <code>City</code>.</p>
<h3>Adding the Forecast model</h3>
<p>In this section, we’ll create a model called <code>Forecast</code> that will keep track of a single forecast <a id="_idIndexMarker804"/>for a city. The <code>Forecast</code> model keeps a list of multiple <code>ForeCastItem</code> objects, each representing a forecast for a specific point in time. Let’s set this up:</p>
<ol>
<li>Create a new class called <code>Forecast</code> in the <code>Models</code> folder.</li>
<li>Add the fo<a id="_idTextAnchor737"/>llowing code:<pre class="source-code">
using System;
using System.Collections.Generic;
namespace Weather.Models;
public class Forecast
{
    public string City { get; set; }
    public List&lt;ForecastItem&gt; Items { get; set; }
}</pre></li> </ol>
<p>Now that <a id="_idIndexMarker805"/>we have our models for both the Weather API and the app, we need<a id="_idTextAnchor738"/> to fetch data from th<a id="_idTextAnchor739"/><a id="_idTextAnchor740"/>e Weather API.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor741"/>Creating a service to fetch the weather data</h2>
<p>To make <a id="_idIndexMarker806"/>it easier to change the external weather service and to make the code more testable, we will create an interface for the service. Here’s how we can go about it:</p>
<ol>
<li>Create a new folder called <code>Services</code>.</li>
<li>Create a new <code>public interface</code> called <code>IWeatherService</code>.</li>
<li>Add a method for fetching data based on the location of the user, as shown in the following code. Name the method <code>Ge<a id="_idTextAnchor742"/>tForecastAsync</code>:<pre class="source-code">
using System.Threading.Tasks;
using Weather.Models;
namespace Weather.Services;
public interface IWeatherService
{
    Task&lt;Forecast&gt; GetForecastAsync(double latitude, double longitude);
}</pre></li> </ol>
<p>Now that we have an interface, we can create an implementation for it, as follows:</p>
<ol>
<li>In the <code>Services</code> folder, create a new class called <code>OpenWeatherMapWeatherService</code>.</li>
<li>Implement <a id="_idIndexMarker807"/>the interface and add the <code>async</code> keyword to the <code>GetForecastAsync</code> method:<pre class="source-code">
using System;
using System.Globalization;
using Weather.Models;
using System.Text.Json;
namespace Weather.Services;
public class OpenWeatherMapWeatherService : IWeatherService
{
    public async Task&lt;Forecast&gt; GetForecastAsync(double latitude, double longitude)
    {
    }
}</pre></li> </ol>
<p>Before we call the OpenWeatherMap API, we need to build a URI for the call to the Weather API. This will be a GET call, and the latitude and longitude of the position will be added as query parameters. We will also add the API key and the language that we would like the response to be in. Let’s set this up:</p>
<ol>
<li>Open the <code>OpenWeatherMapWeatherService</code> class.</li>
<li>Add the highlighted code in the following code snippet to the <code>OpenWeatherMap</code><strong class="source-inline">
</strong><code>WeatherService</code> class:<pre class="source-code">
public async Task&lt;Forecast&gt; GetForecastAsync(double latitude, double longitude)
{
<strong class="bold">    var language = CultureInfo.CurrentUICulture.TwoLetterISOLanguageName;</strong>
<strong class="bold">    var apiKey = “{A<a id="_idTextAnchor743"/>ddYourApiKeyHere}”;</strong>
<strong class="bold">    var uri = $”https://api.openweathermap.org/data/2.5/forecast?lat={latitude}&amp;lon={longitude}&amp;units=metric&amp;lang={language}&amp;appid={apiKey}”;</strong>
}</pre></li> </ol>
<p>Replace the {<code>AddYourApiKeyHere</code>} with the key you obtained from the <em class="italic">Creating models for the weather </em><em class="italic">data</em> section</p>
<p>To deserialize <a id="_idIndexMarker808"/>the JSON that we will get from the external service, we will use <code>System.Text.JSON</code>.</p>
<p>To make a call to the <code>Weather</code> service, we will use the <code>HttpClient</code> class and the <code>GetStringAsync</code> method, as follows:</p>
<ol>
<li>Create a new instance of the <code>HttpClient</code> class.</li>
<li>Call <code>GetStringAsync</code> and pass the URL as the argument.</li>
<li>Use the <code>JsonSerializer</code> class and the <code>DeserializeObject</code> method from <code>System.Text.Json</code> to convert the JSON string into an object.</li>
<li>Map the <code>WeatherData</code> object to a <code>Forecast</code> object.</li>
<li>The code for this should look like the highlighted code shown in the following snippet:<pre class="source-code">
public async Task&lt;Forecast&gt; GetForecastAsync(double latitude, double longitude)
{
    var language = CultureInfo.CurrentUICulture.
TwoLetterISOLanguageName;
    var apiKey = “{AddYourApiKeyHere}”;
    var uri = $”https://api.openweathermap.org/data/2.5/forecast?lat={latitude}&amp;lon={longitude}&amp;units=metric&amp;lang={language}&amp;appid={apiKey}”;
<strong class="bold">    var httpClient = new HttpClient();</strong>
<strong class="bold">    var result = await httpClient.GetStringAsync(uri);</strong>
<strong class="bold">    var data = JsonSerializer.Deserialize&lt;WeatherData&gt;(result);</strong>
<strong class="bold">    var forecast = new Forecast()</strong>
<strong class="bold">    {</strong>
<strong class="bold">        City = data.city.name,</strong>
<strong class="bold">        Items = data.list.Select(x =&gt; new ForecastItem()</strong>
<strong class="bold">        {</strong>
<strong class="bold">            DateTime = ToDateTime(x.dt),</strong>
<strong class="bold">            Temperature = x.main.temp,</strong>
<strong class="bold">            WindSpeed = x.wind.speed,</strong>
<strong class="bold">            Description = x.weather.First().description,</strong>
<strong class="bold">            Icon = $”http://openweathermap.org/img/w/{x.weather.First().icon}.png”</strong>
<strong class="bold">        }).ToList()</strong>
<strong class="bold">    };</strong>
<strong class="bold">    return forecast;</strong>
}</pre></li> </ol>
<p class="callout-heading">Performance tip</p>
<p class="callout">To optimize the performance of the app, we can use <code>HttpClient</code> as a singleton and reuse it for all network calls in the application. The following information is from Microsoft’s documentation: “<em class="italic">HttpClient is intended to be instantiated once and reused throughout the life of an application. Instantiating an HttpClient class for every request will exhaust the number of sockets available under heavy loads. This will result in SocketException errors</em>.” This can be found at <a href="https://learn.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0">https://learn.microsoft.com/en-gb/dotnet/api/system.net.http.httpclient?view=netstandard-2.0</a>.</p>
<p>In the <a id="_idIndexMarker809"/>preceding code, we have a call to a <code>ToDateTime</code> method, which is a method that we will need to create. This method converts the date from a Unix timestamp into a <code>DateTime</code> object, as shown in t<a id="_idTextAnchor744"/>he following code:</p>
<pre class="source-code">
private DateTime ToDateTime(double unixTimeStamp)
{
    DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
    dateTime = dateTime.AddSeconds(unixTimeStamp).ToLocalTime();
    return dateTime;
}</pre> <p class="callout-heading">Performance tip</p>
<p class="callout">By default, <code>HttpClient</code> uses the Mono implementation of <code>HttpClient</code> (iOS and Android). To increase performance, we can use a platform-specific implementation instead. For iOS, use <code>NSUrlSession</code>. This can be set in the project settings of the iOS project under the <strong class="bold">iOS Build</strong> tab. For Android, use <strong class="bold">Android</strong>. This can be set in the project settings of the Android project under <strong class="bold">Android O<a id="_idTextAnchor745"/><a id="_idTextAnchor746"/><a id="_idTextAnchor747"/>ptions</strong> | <strong class="bold">Advanced</strong>.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor748"/>Configuring the application platforms so that they use location services</h2>
<p>To be <a id="_idIndexMarker810"/>able to use location services, we need to carry out some configuration on each platform.</p>
<h3>Configuring the iOS platform so that it uses location services</h3>
<p>To use location services in an iOS app, we need to add a description to indicate why we want to <a id="_idIndexMarker811"/>use the location in the <code>info.plist</code> file. In this app, we only need to get the location when we are using the app, so we only need to add a description for this. Let’s set this up:</p>
<ol>
<li>Open <code>info.plist</code> in <code>Platforms/iOS</code> with <strong class="bold">XML (</strong><strong class="bold">Text) Editor</strong>.</li>
<li>Add the <code>NSLocationWhenInUseUsageDescription</code> key using<a id="_idTextAnchor749"/> the following code:<pre class="source-code">
&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;
&lt;string&gt;We are using your location to find a forec<a id="_idTextAnchor750"/><a id="_idTextAnchor751"/>ast for you&lt;/string&gt;</pre></li> </ol>
<h3>Configuring the Android platform so that it uses location services</h3>
<p>For Android, we <a id="_idIndexMarker812"/>need to set up the app so that it requires the following two permissions:</p>
<ul>
<li><strong class="bold">ACCESS_COARSE_LOCATION </strong></li>
<li><strong class="bold">ACCESS_FINE_LOCATION</strong></li>
</ul>
<p>We can set this in the <code>AndroidManifest.xml</code> file, which can be found in the <code>Platforms\Android\</code> folder. However, we can also set this in the project properties on the <strong class="bold">Android Manifest</strong> tab, as shown in the following screenshot:</p>
<div><div><img alt="Figure 8.6 – Selecting ﻿﻿﻿﻿location permissions" src="img/B19214_08_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Selecting <a id="_idTextAnchor752"/><a id="_idTextAnchor753"/><a id="_idTextAnchor754"/><a id="_idTextAnchor755"/>location permissions</p>
<h3>Configuring the WinUI platform so that it uses location services</h3>
<p>Since we <a id="_idIndexMarker813"/>will be using location services in the WinUI platform, we need to add the <code>Location</code> capability under <code>Package.appxmanifest</code> file of the project, which is located in the <code>Platforms/Windows</code> folder, as shown in the fo<a id="_idTextAnchor756"/><a id="_idTextAnchor757"/>llowing screenshot:</p>
<div><div><img alt="Figure 8.7 – Adding a location to the WinUI app" src="img/B19214_08_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Adding a location to the WinUI app</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor758"/>Creating the ViewModel class</h2>
<p>Now that we have a service that’s responsible for fetching weather data from the external <a id="_idIndexMarker814"/>weather source, it’s time to create a <code>ViewModel</code>. First, however, we will create a base view model where we can put the code <a id="_idIndexMarker815"/>that can be shared between all the <code>ViewModels</code> of the app. Let’s set this up:</p>
<ol>
<li>Create a new folder called <code>ViewModels</code>.</li>
<li>Create a new c<a id="_idTextAnchor759"/>lass called <code>ViewModel</code>.</li>
<li>Make the new clas<a id="_idTextAnchor760"/>s <code>public</code> and <code>abstract</code>.</li>
<li>Add a package reference to CommunityToolkit.MVVM:<pre class="source-code">
public abstract partial class ViewModel : ObservableObject
{
}</pre></li> </ol>
<p>We now have <a id="_idIndexMarker816"/>a base view model. We can use this for <a id="_idIndexMarker817"/>the view model that we’re about to create.</p>
<p>Now, it’s time to create <code>MainViewModel</code>, which will be the ViewModel for our <code>MainView</code> in the app. Perform the following steps to do so:</p>
<ol>
<li>In the <code>ViewModels</code> folder, create a new class called <code>MainViewModel</code>.</li>
<li>Add the abstract <code>ViewModel</code> class as a base class.</li>
<li>Because we are going to use constructor injection, we will add a constructor with the <code>IWeatherService</code> i<a id="_idTextAnchor761"/>nterface as a parameter.<p class="list-inset">Create a <code>read-only private</code> field. We will use this to store the <code>I<a id="_idTextAnchor762"/>weatherService</code> instance:</p><pre class="source-code">
public class MainViewModel : ViewModel
{
    private readonly IWeatherService weatherService;
    public MainViewModel(IWeatherService weatherService)
    {
        this.weatherService = weatherService;
    }
}</pre></li> </ol>
<p><code>MainViewModel</code> takes any object that implements <code>IWeatherService</code> and stores a reference to that service in a field. We will be adding functionality<a id="_idTextAnchor763"/> that will fetch weather d<a id="_idTextAnchor764"/>ata in the next section.</p>
<h3>Getting the weather data</h3>
<p>Now, we will create a new method for loading the data. This will be a three-step process. First, we will <a id="_idIndexMarker818"/>get the location of the user. Once we have this, we can fetch data related to that location. The final step is to prepare the data that the views can consume to create a user interface for the user.</p>
<p>To get the location of the user, we will use the <code>Geolocation</code> class, which exposes methods that can fetch the location of the user. Perform the following steps:</p>
<ol>
<li>Create a new method called <code>LoadDataAsync</code>. Make it an asynchronous method that returns <code>Task</code>.</li>
<li>Use the <code>GetLocationAsync</code> method on the <code>Geolocation</code> class to get the location of the user.</li>
<li>Pass the latitude and longitude from the result of the <code>GetLocationAsync</code> call and pass it to the <code>GetForecast</code> method on the object that implements <code>IWeatherService</code> using the following code:<pre class="source-code">
public async Task LoadDataAsync()
{
    var location = await Geolocation.GetLocationAsync();
    var forecast = await weatherService.GetForecastAsync(location.Latitude, location.Longitude);
}</pre></li> </ol>
<p>Now that we can get data from the service, we need to structure it for our user interface by grouping t<a id="_idTextAnchor765"/><a id="_idTextAnchor766"/><a id="_idTextAnchor767"/>he individual data items.</p>
<h3>Grouping the weather data</h3>
<p>When we <a id="_idIndexMarker819"/>present the weather data, we will group it by day so that all of the forecasts for one day will be under the same header. To do this, we will create a new model called <code>ForecastGroup</code>. To make it possible to use this model with the .NET MAUI <code>CollectionView</code>, it has to have an <code>IEnumerable</code> type as the base class. Let’s set this up:</p>
<ol>
<li>Create a new class called <code>ForecastGroup</code> in the <code>Models</code> folder.</li>
<li>Add <code>List&lt;ForecastItem&gt;</code> as the base class for the new model.</li>
<li>Add an empty constructor and a constructor that has a list of <code>ForecastItem</code> instances as a parameter.</li>
<li>Add a <code>Date</code> property.</li>
<li>Add a <a id="_idIndexMarker820"/>property, <code>DateAsString</code>, that returns the <code>Date</code> property as a short date string.</li>
<li>Add a property, <code>Items</code>, that returns the list of <code>ForecastItem</code> instances, as shown in the following code:<pre class="source-code">
using System;
namespace Weather.Models;
public class ForecastGroup : List&lt;ForecastItem&gt;
{
    public ForecastGroup() { }
    public ForecastGroup(IEnumerable&lt;ForecastItem&gt; items)
    {
        AddRange(items);
    }
    public DateTime Date { get; set; }
    public string DateAsString =&gt; Date.ToShortDateString();
    public List&lt;ForecastItem&gt; Items =&gt; this;
}</pre></li> </ol>
<p>When we <a id="_idIndexMarker821"/>have done this, we can update <code>MainViewModel</code> with two new properties, as follows:</p>
<ol>
<li>Create a privat<a id="_idTextAnchor768"/>e field called <code>city</code> with the <code>ObservableProperty</code> attribute for the name of the city we are fetching the weather data.</li>
<li>Create a private field called <code>days</code> with the <code>ObservableProperty</code> attribute that will conta<a id="_idTextAnchor769"/>in the grouped weather data.</li>
<li>The <code>MainViewModel</code> class should look like the highlighted code shown in the following snippet:<pre class="source-code">
public partial class MainViewModel : ViewModel
{
    <strong class="bold">[ObservableProperty]</strong>
<strong class="bold">    private string city;</strong>
<strong class="bold">[ObservableProperty]</strong>
<strong class="bold">    private ObservableCollection&lt;ForecastGroup&gt; days;</strong>
    // Rest of the class is omitted for brevity
}</pre></li> </ol>
<p>Now, we are ready to group the data. We will do this in the <code>LoadDataAsync</code> method. We will loop through the data from the service and add items to various groups, as follows:</p>
<ol>
<li>Create an <code>itemGroups</code> variable of the <code>List&lt;ForecastGroup&gt;</code> type.</li>
<li>Create a <code>foreach</code> loop that loops through all the items in the <code>forecast</code> variable.</li>
<li>Add an <code>if</code> statement that checks whether the <code>itemGroups</code> property is empty. If it is empty, add a new <code>ForecastGroup</code> to the variable and continue to the next item in the item list.</li>
<li>Use the <code>SingleOrDefault</code> method (this is an extension method from <code>System.Linq</code>) on the <code>itemGroups</code> variable to get a group based on the date of the current <code>ForecastItem</code>. Add the result to a new variable, <code>group</code>.</li>
<li>If the <code>group</code> property is <code>null</code>, then there is no group with the current day in the list of groups. If this is the case, a new <code>ForecastGroup</code> should be added to the list <a id="_idIndexMarker822"/>in the <code>itemGroups</code> variable. The code will continue executing until it gets to the next <code>forecast</code> item in the <code>forecast.Items</code> list. If a group is found, it should be added to the list in the <code>itemGroups</code> variable.</li>
<li>After the <code>foreach</code> loop, set the <code>Days</code> property with a new <code>ObservableCollection</code><strong class="source-inline">
&lt;ForecastGroup&gt;</strong> and use the <code>itemGroups</code> variable as an argument in the constructor.</li>
<li>Set the <code>City</code> property to the <code>City</code> prope<a id="_idTextAnchor770"/>rty of the <code>forecast</code> variable.</li>
<li>The <code>LoadDataAsync</code> method should now look as follows:<pre class="source-code">
public async Task LoadDataAsync()
{
    var location = await Geolocation.GetLocationAsync();
    var forecast = await weatherService.GetForecastAsync(location.Latitude, location.Longitude);
    var itemGroups = new List&lt;ForecastGroup&gt;();
    foreach (var item in forecast.Items)
    {
        if (!itemGroups.Any())
        {
            itemGroups.Add(new ForecastGroup(new List&lt;ForecastItem&gt;() { item })
            {
                Date = item.DateTime.Date
            });
            continue;
        }
        var group = itemGroups.SingleOrDefault(x =&gt; x.Date == item.DateTime.Date);
        if (group == null)
        {
            itemGroups.Add(new ForecastGroup(new List&lt;ForecastItem&gt;() { item })
            {
                Date = item.DateTime.Date
            });
            continue;
        }
        group.Items.Add(item);
    }
    Days = new ObservableCollection&lt;ForecastGroup&gt;(itemGroups);
    City = forecast.City;
}</pre></li> </ol>
<p class="callout-heading">Tip</p>
<p class="callout">Don’t use the <code>Add</code> method on <code>ObservableCollection</code> when you want to add more than <a id="_idIndexMarker823"/>a couple of items. It is better to create a new instance of <code>ObservableCollection</code> and pass a collection to the constructor. The reason for this is that every time you use the <code>Add</code> method, you will have a binding to it from the view, which will cause the view to be rendered. We will get better performance if <a id="_idTextAnchor771"/><a id="_idTextAnchor772"/><a id="_idTextAnchor773"/><a id="_idTextAnchor774"/>we avoid using the <code>Add</code> method.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor775"/>Creating the view for tablets and desktop computers</h2>
<p>The next <a id="_idIndexMarker824"/>step is to create the view <a id="_idIndexMarker825"/>that we will use when the app is running on a tablet or a desktop computer. Let’s set this up:</p>
<ol>
<li>Create a new folder in t<a id="_idTextAnchor776"/>he <code>Weather</code> project called <code>Views</code>.</li>
<li>In the <code>Views</code> folder, create a new folder called <code>Desktop</code>.</li>
<li>Create a new <code>.NET MAUI ContentPage (XAML)</code> file called <code>MainView</code> in the <code>Views\Desktop</code> folder:</li>
</ol>
<div><div><img alt="Figure 8.8 – Addi﻿ng a .NET MAUI XAML ContentPage" src="img/B19214_08_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Addi<a id="_idTextAnchor777"/>ng a .NET MAUI XAML ContentPage</p>
<ol>
<li value="4">Pass <a id="_idIndexMarker826"/>an instance <a id="_idIndexMarker827"/>of <code>MainViewModel</code> in the constructor of the view to set <code>BindingContext</code>, as shown in the following code:<pre class="source-code">
public MainView (<strong class="bold">MainViewModel mainViewModel</strong>)
{
    InitializeComponent ();
    <strong class="bold">BindingContext = mainViewModel;</strong>
}</pre><p class="list-inset">Later, in the <em class="italic">Adding services and ViewModels to dependency injection</em> section, we will configure dependency injection<a id="_idTextAnchor778"/> to provide the instances for us.</p></li> </ol>
<p>To trigger the <code>LoadDataAsync</code> method in <code>MainViewModel</code>, call the <code>LoadDataAsync</code> method by overriding the <code>OnNavigatedTo</code> method on the main thread. We need <a id="_idIndexMarker828"/>to make sure <a id="_idIndexMarker829"/>that the call is executed on the UI thread since it will interact with the user interface.</p>
<p>To do this, perform the following steps:</p>
<ol>
<li>Open the <code>MainView.xaml.cs</code> file in the <code>Views\Desktop</code> folder.</li>
<li>Create an ov<a id="_idTextAnchor779"/>erride of the <code>OnNavigatedTo</code> method.</li>
<li>Add the highlighted code shown in the following snippet to the <code>OnNavigateTo</code> method:<pre class="source-code">
    protected override void OnNavigatedTo(NavigatedToEventArgs args)
    {
        base.OnNavigatedTo(args);
<strong class="bold">        if (BindingContext is MainViewModel viewModel)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            MainThread.BeginInvokeOnMainThread(async () =&gt;</strong>
<strong class="bold">            {</strong>
<strong class="bold">                await viewModel.LoadDataAsync();</strong>
<strong class="bold">            });</strong>
<strong class="bold">        }</strong>
    }</pre></li> </ol>
<p>In the <code>MainView</code> XAML file, add a binding for the <code>Title</code> property of <code>ContentPage</code> to the <code>City</code> property in <code>ViewModel</code>, as follows:</p>
<ol>
<li>Open the <code>MainView.xaml</code> file in the <code>Views\Desktop</code> folder.</li>
<li>Add the <code>Title</code> binding to the <code>ContentPage</code> element, as highlighted in the following code snippet:<pre class="source-code">
&lt;ContentPage
    xmlns=”http://schemas.microsoft.com/dotnet/2021/maui”
    xmlns:x=”http://schemas.microsoft.com/winfx/2009/xaml”
    x:Class=”Weather.Views.Desktop.MainView”
    <strong class="bold">Title=”{Binding City}”</strong>&gt;</pre></li> </ol>
<p>In this <a id="_idIndexMarker830"/>next section, we will use <code>FlexLayout</code> to render <a id="_idIndexMarker831"/>the dat<a id="_idTextAnchor780"/><a id="_idTextAnchor781"/>a from the ViewModel onto the screen.</p>
<h3>Using FlexLayout</h3>
<p>In .NET MAUI, we can use <code>CollectionView</code> or <code>ListView</code> if we want to show a collection of data. Using both <code>CollectionView</code> and <code>ListView</code> works great in most cases, and we will use <code>CollectionView</code> later in this chapter, but <code>ListView</code> can only show <a id="_idIndexMarker832"/>data vertically. In this app, we want to show data in both directions. In the vertical direction, we will have the days (we group forecasts based on days), while in the horizontal direction, we will have the forecasts within a particular day. We also want the forecasts within a day to wrap if there <a id="_idIndexMarker833"/>is not enough space for all of them in one row. <code>CollectionView</code> can show data in a horizontal direction, but it will not wrap. With <code>FlexLayout</code>, we can add items in both directions and we can use <code>BindableLayout</code> to bind items to it. When we use <code>BindableLayout</code>, we will use <code>ItemSource</code> an<a id="_idTextAnchor782"/>d <code>ItemsTemplate</code> as attached properties.</p>
<p>Perform the following steps to build the view:</p>
<ol>
<li>Add <code>Grid</code> as the root view of the page.</li>
<li>Add <code>ScrollView</code> to <code>Grid</code>. We need this to be able to scroll if the content is higher than the height of the page.</li>
<li>Add <code>FlexLayout</code> to <code>ScrollView</code> and set the direction to <code>Column</code> so that the content will be in a vertical direction.</li>
<li>Add a <a id="_idIndexMarker834"/>binding to the <code>Days</code> property in <code>MainViewModel</code> using <code>BindableLayout.ItemsSource</code>.</li>
<li>Set <code>DataTemplate</code> to the <a id="_idIndexMarker835"/>content of <code>Items<a id="_idTextAnchor783"/>Template</code>, as shown in the following code:<pre class="source-code">
&lt;Grid&gt;
  &lt;ScrollView BackgroundColor=”Transparent”&gt;
    &lt;FlexLayout BindableLayout.ItemsSource=”{Binding Days}” Direction=”Column”&gt;
      &lt;BindableLayout.ItemTemplate&gt;
        &lt;DataTemplate&gt;
          &lt;!--Content will be added here --&gt;
        &lt;/DataTemplate&gt;
      &lt;/BindableLayout.ItemTemplate&gt;
    &lt;/FlexLayout&gt;
  &lt;/ScrollView&gt;
&lt;/Grid&gt;</pre></li> </ol>
<p>The content for each item will be a header with the date and a horizontal <code>FlexLayout</code> with the forecasts for the day. Let’s set this up:</p>
<ol>
<li>Open the <code>MainView.xaml</code> file.</li>
<li>Add <code>StackLayout</code> so that the children we add to it will be placed in a vertical direction.</li>
<li>Add <code>ContentView</code> to <code>StackLayout</code> with <code>Padding</code> set to <code>10</code> and <code>BackgroundColor</code> set to <code>#9F5010</code>. This will be the header. The reason we need <code>ContentView</code> is that we want to have padding around the text.</li>
<li>Add <code>Label</code> to <code>ContentView</code> with <code>TextColor</code> set to <code>White</code> and <code>FontAttributes</code> set to <code>Bold</code>.</li>
<li>Add a binding to <code>DateAsString</code> for the <code>Text</code> property of <code>Label</code>.</li>
<li>The code <a id="_idIndexMarker836"/>should be placed <a id="_idIndexMarker837"/>at the <code>&lt;!-- Content will be added h<a id="_idTextAnchor784"/>ere --&gt;</code> comment and should look as follows:<pre class="source-code">
&lt;StackLayout&gt;
  &lt;Content<a id="_idTextAnchor785"/>View Padding=”10” BackgroundColor=”#9F5010”&gt;
    &lt;Label Text=”{Binding DateAsString}” TextColor=”White” FontAttributes=”Bold” /&gt;
  &lt;/ContentView&gt;
&lt;/StackLayout&gt;</pre></li> </ol>
<p>Now that we have the date in the user interface, we need to add a <code>FlexLayout</code> property, which will repeat through any items in <code>MainViewModel</code>. Perform the following steps to do so:</p>
<ol>
<li>Add <code>FlexLayout</code> after the <code>&lt;/ContentView&gt;</code> tag but before the <code>&lt;/</code><code>StackLayout&gt;</code> tag.</li>
<li>Set <code>JustifyContent</code> to <code>Start</code> to set the items so that they’re added from the left-hand side, without distributing them over the available space.</li>
<li>Set <code>AlignItems</code> to <code>Start</code> to set the content to the left of each item in <a id="_idTextAnchor786"/><code>FlexLayout</code>, as shown in the following code:<pre class="source-code">
&lt;FlexLayout BindableLayout.ItemsSource=”{Binding Items}” Wrap=”Wrap” JustifyContent=”Start” AlignItems=”Start”&gt;
&lt;/FlexLayout&gt;</pre></li> </ol>
<p>After defining <code>FlexLayout</code>, we need to provide an <code>ItemsTemplate</code> property, which defines <a id="_idIndexMarker838"/>how each item in the list should be rendered. Continue <a id="_idIndexMarker839"/>adding the XAML directly under the <code>&lt;FlexLayout&gt;</code> tag you just added, as follows:</p>
<ol>
<li>Set the <code>ItemsTemplate</code> property to <code>DataTemplate</code>.</li>
<li><code>FillDataTemplate</code> with elements, as shown in the following code:</li>
</ol>
<p class="callout-heading">Tip</p>
<p class="callout">If we want to add formatting to a binding, we can use <code>StringFormat</code>. In this case, we want to add the degree symbol after the temperature. We can do this by using the <code>{Binding Temperature, StringFormat=’{0}° C’}</code> phrase. With the <code>StringFormat</code> property of the binding, we can format data with the same arguments that we would use if we were to do this in C#. This is the same as <code>string.Format(“{0}° C”, Temperature)</code> in C#. We can also use it to format a date; for example, <code>{Binding Date, StringFormat=’yyyy’}</code>. In C#<a id="_idTextAnchor787"/>, this would look like <code>Date.ToString(“yyyy”)</code>.</p>
<pre class="source-code">
&lt;BindableLayout.ItemTemplate&gt;
  &lt;DataTemplate&gt;
    &lt;StackLayout Margin=”10” Padding=”20” WidthRequest=”150” BackgroundColor=”#99FFFFFF”&gt;
      &lt;Label FontSize=”16” FontAttributes=”Bold” Text=”{Binding TimeAsString}” HorizontalOptions=”Center” /&gt;
     <a id="_idTextAnchor788"/> &lt;Image WidthRequest=”100” HeightRequest=”100” Aspect=”AspectFit” Horizont<a id="_idTextAnchor789"/>alOptions=”Center” Source=”{Binding Icon}” /&gt;
      &lt;Label FontSize=”14” FontAttributes=”Bold” Text=”{Binding Temperature, StringFormat=’{0}° C’}” HorizontalOptions=”Center” /&gt;
      &lt;Label FontSize=”14” FontAttributes=”Bold” Text=”{Binding Description}” HorizontalOptions=”Center” /&gt;
    &lt;/StackLayout&gt;
  &lt;/DataTemplate&gt;
&lt;/BindableLayout.ItemTemplate&gt;</pre> <p class="callout-heading">Tip</p>
<p class="callout">The <code>AspectFill</code> phrase, as a value of the <code>Aspect</code> property for <code>Image</code>, means that the whole image will always be visible and that the aspects will not be changed. The <code>AspectFit</code> phrase will also keep the aspect of an image, but the image can be zoomed into and out of and cropped so that it fills the whole <code>Image</code> element. The last value that <code>Aspect</code> can be set to, <code>Fill</code>, means that the image can be stretched or compressed to match the <code>Image</code> <a id="_idTextAnchor790"/><a id="_idTextAnchor791"/><a id="_idTextAnchor792"/>view to ensure that the aspect ratio is kept.</p>
<h3>Adding a toolbar item to refresh the weather data</h3>
<p>To be able to refresh the data without restarting the app, we will add a <code>Refresh</code> button <a id="_idIndexMarker840"/>to the toolbar. <code>MainViewModel</code> is responsible for handling any logic that we want to perform, and we <a id="_idIndexMarker841"/>must expose any action as an <code>ICommand</code> bindable that we can bind to.</p>
<p>Let’s start by creating the <code>Refresh</code> command method on <code>MainViewModel</code>:</p>
<ol>
<li>Open the <code>MainViewModel</code> class.</li>
<li>Add a <code>using</code> declaration for <code>CommunityToolkit.Mvvm.Input</code>:<pre class="source-code">
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
<strong class="bold">using CommunityToolkit.Mvvm.Input;</strong>
using Weather.Models;
using Weather.Services;</pre></li> <li>Add a method called <code>RefreshAsync</code> that calls the <code>LoadDataAsync</code> method, as shown in the following code:<pre class="source-code">
    public async Task RefreshAsync()
    {
        await LoadDataAsync();
    }</pre></li> <li>Since <a id="_idIndexMarker842"/>these methods <a id="_idIndexMarker843"/>are asynchronous, <code>Refresh</code> will return <code>Task</code>, and we can use <code>async</code> and <code>await</code> to call <code>LoadDataAsync</code> without blocking the UI thread.</li>
<li>Add a <code>RelayCommand</code> attribute to the <code>RefreshAsync</code> method to auto-generate the <code>ICommand</code> bindable property to the method:<pre class="source-code">
<strong class="bold">[RelayCommand]</strong>
    public async Task RefreshA<a id="_idTextAnchor793"/>sync()
    {
        await LoadDataAsync();
    }</pre></li> </ol>
<p>Now that we have defined the <code>Refresh</code> command, we need to bind it to the user interface so that when the user clicks the toolbar button, the action will be executed.</p>
<p>To do this, perform the following steps:</p>
<ol>
<li>Open the <code>MainView.xaml</code> file.</li>
<li>Download the <code>refresh.png</code> file from <a href="https://raw.githubusercontent.com/PacktPublishing/MAUI-Projects-3rd-Edition/main/Chapter08/Weather/Resources/Images/refresh.png">https://raw.githubusercontent.com/PacktPublishing/MAUI-Projects-3rd-Edition/main/Chapter08/Weather/Resources/Images/refresh.png</a> and save it to the <code>Resources/Images</code> folder of the project.</li>
<li>Add a new <code>ToolbarItem</code> with the <code>Text</code> property set to <code>Refresh</code> to the <code>ToolbarItems</code> property of <code>ContentPage</code> and set the <code>IconImageSource</code> property to <code>refresh.png</code> (alternatively, you can set the <code>IconImageSource</code> property to the URL of the image and .NET MAUI will download the image).</li>
<li>Bind the <code>Command</code> property to the <code>Refresh</code> property <a id="_idTextAnchor794"/>in <code>MainViewModel</code>, as shown in the following code:<pre class="source-code">
&lt;ContentPage.ToolbarItems&gt;
  &lt;ToolbarItem IconImageSource=”refresh.png” Text=”Refresh” Command=”{Binding RefreshCommand}” /&gt;
&lt;/ContentPage.ToolbarItems&gt;</pre></li> </ol>
<p>That’s <a id="_idIndexMarker844"/>all for refreshing <a id="_idIndexMarker845"/>the data. N<a id="_idTextAnchor795"/>ow, we ne<a id="_idTextAnchor796"/><a id="_idTextAnchor797"/>ed some kind of indicator that the data is loading.</p>
<h4>Adding a loading indicator</h4>
<p>When we <a id="_idIndexMarker846"/>refresh the data, we want to show a loading indicator so that the user knows that something is happening. To do this, we will add <code>ActivityIndicator</code>, which is what this control is called in .NET MAUI. Let’s set this up:</p>
<ol>
<li>Open the <code>MainViewModel</code> class.</li>
<li>Add a <code>Boolean</code> field called <code>isRefreshing</code> to <code>MainViewModel</code>.</li>
<li>Add the <code>ObservableProperty</code> attribute to <code>isRefreshingField</code> to generate the <code>IPropertyChanged</code> implementation.</li>
<li>Set the <code>IsRefreshing</code> property to <code>true</code> at the beginning of the <code>LoadDataAsync</code> method.</li>
<li>At the end of the <code>LoadDataAsync</code> method, set the <code>IsRefreshing</code> property to <code>false</code>, as shown in the following code:<pre class="source-code">
    [ObservableProperty]
    private bool isRefreshing;
....// The rest of the code<a id="_idTextAnchor798"/> is omitted for brevity
pub<a id="_idTextAnchor799"/>lic async Task LoadData()
{
    IsRefreshing = true;
....// The rest of the code is omitted for brevity
    IsRefreshing = false;
}</pre></li> </ol>
<p>Now that we <a id="_idIndexMarker847"/>have added some code to <code>MainViewModel</code>, we need to bind the <code>IsRefreshing</code> property to a user interface element that will be displayed when the <code>IsRefreshing</code> property is <code>true</code>, as shown in the following steps:</p>
<ol>
<li>In <code>MainView.xaml</code>, add <code>Frame</code> after <code>ScrollView</code> as the last element in <code>Grid</code>.</li>
<li>Bind the <code>IsVisible</code> property to the <code>IsRefreshing</code> method that we created in <code>MainViewModel</code>.</li>
<li>Set <code>HeightRequest</code> and <code>WidthRequest</code> to <code>100</code>.</li>
<li>Set <code>VerticalOptions</code> and <code>HorizontalOptions</code> to <code>Center</code> so that <code>Frame</code> will be in the middle of the view.</li>
<li>Set <code>BackgroundColor</code> to <code>#99000000</code> to set the background to white with a little bit of transparency.</li>
<li>Add <code>ActivityIndicator</code> to <code>Frame</code> with <code>Color</code> set to <code>Black</code> and <code>I<a id="_idTextAnchor800"/>sRunning</code> set to <code>True</code>, as shown in the following code:<pre class="source-code">
&lt;Frame IsVisible=”{Binding IsRefreshing}” BackgroundColor=”#99FFFFFF” WidthRequest=”100” HeightRequest=”100” VerticalOptions=”Center” HorizontalOptions=”Center”&gt;
  &lt;ActivityIndicator Color=”Black” IsRunning=”True” /&gt;
&lt;/Frame&gt;</pre></li> </ol>
<p>This will <a id="_idIndexMarker848"/>create a spinner that will be visible while data is loading, which is a really good practice when creating any user in<a id="_idTextAnchor801"/>terface. Now, we’ll ad<a id="_idTextAnchor802"/>d a background image to make the app look a bit nicer.</p>
<h3>Setting a background image</h3>
<p>The last thing we will do to this view, for the moment, is add a background image. The image we <a id="_idIndexMarker849"/>will be using in this example is a result of a Google search for images that are free to use. Let’s set this up:</p>
<ol>
<li>Open the <code>MainView.xaml</code> file.</li>
<li>Se<a id="_idTextAnchor803"/>t the <code>Background</code> property of <code>ScrollView</code> to <code>Transparent</code>.</li>
<li>Add an <code>Image</code> element in <code>Grid</code> with <code>UriImageSource</code> as the value of the <code>Source</code> property.</li>
<li>Set the <code>CachingEnabled</code> property to true and <code>CacheValidity</code> to <code>5</code>. This means that the image will be cached for <code>5</code> days.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You could also set these properties if you used a URL for the <code>Refresh</code> <code>IconImageSource</code> property to avoid downloading the image on every run of the app.</p>
<ol>
<li value="5">The XAML should now look as follows:<pre class="source-code">
&lt;ContentPage xmlns=”http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=”http://schemas.microsoft.com/winfx/2009/xaml”
    x:Class=”Weather.Views.Desktop.MainView”
    Title=”{Binding City}”&gt;
  &lt;ContentPage.ToolbarItems&gt;
    &lt;ToolbarItem Icon=”refresh.png” Text=”Refresh” Command=”{Binding Ref<a id="_idTextAnchor804"/><a id="_idTextAnchor805"/>reshCommand}” /&gt;
  &lt;/ContentPage.ToolbarItems&gt;
<strong class="bold">  &lt;Grid&gt;</strong>
<strong class="bold">    &lt;Image Aspect=”AspectFill”&gt;</strong>
<strong class="bold">      &lt;Image.Source&gt;</strong>
<strong class="bold">        &lt;UriImageSource Uri=”https://upload.wikimedia.org/wikipedia/commons/7/79/Solnedg%C3%A5ng_%C3%B6ver_Laholmsbukten_augusti_2011.jpg” CachingEnabled=”true” CacheValidity=”5” /&gt;</strong>
<strong class="bold">      &lt;/Image.Source&gt;</strong>
<strong class="bold">    &lt;/Image&gt;</strong>
    &lt;ScrollView <strong class="bold">BackgroundColor=”Transparent”</strong>&gt;
&lt;!-- The rest of the code is omitted for brevity --&gt;</pre></li> </ol>
<p>We can <a id="_idIndexMarker850"/>also set the URL directly in the <code>Source</code> property by using <code>&lt;Image Source=”https://ourgrea<a id="_idTextAnchor806"/>timage.url” /&gt;</code>. However, if we do this, we can’t specify caching for the image.</p>
<p>With the desktop view complete, we need to consider how this page wil<a id="_idTextAnchor807"/>l look when we are running the app on a phone or tablet.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor808"/>Creating the view for phones</h2>
<p>Structuring content on a tablet and a desktop computer is very similar in many ways. On phones, however, we are much more limited in what we can do. Therefore, in this section, we will <a id="_idIndexMarker851"/>create a specific view for this app when it’s <a id="_idIndexMarker852"/>used on phones. To do so, perform the following steps:</p>
<ol>
<li>Create a new XAML-based <code>Views</code> folder.</li>
<li>In the <code>Views</code> folder, create a new folder called <code>Mobile</code>.</li>
<li>Create a new <code>.NET MAUI ContentPage (XAML)</code> file called <code>MainView</code> in the <code>Views\Mobile</code> folder:</li>
</ol>
<div><div><img alt="Figure 8.9 – Adding a .NET MAUI XAML ContentPage" src="img/B19214_08_9..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Adding a .NET MAUI XAML ContentPage</p>
<ol>
<li value="4">Pass an instance of <code>MainViewModel</code> in the constructor of the view to set <code>BindingContext</code>, as shown in the following code:<pre class="source-code">
public MainView (<strong class="bold">MainViewModel mainViewModel</strong>)
{
    InitializeComponent();
    <strong class="bold">BindingContext = mainViewModel;</strong>
}</pre><p class="list-inset">Later, in the <em class="italic">Adding services and ViewModels to dependency injection</em> section, we will config<a id="_idTextAnchor809"/><a id="_idTextAnchor810"/><a id="_idTextAnchor811"/><a id="_idTextAnchor812"/><a id="_idTextAnchor813"/>ure dependency injection to provide the instances for us.</p></li> </ol>
<p>To trigger the <code>LoadDataAsync</code> method in <code>MainViewModel</code>, call the <code>LoadDataAsync</code> method by overriding the <code>OnNavigatedTo</code> method on the main thread. We need <a id="_idIndexMarker853"/>to make sure that the call is executed on <a id="_idIndexMarker854"/>the UI thread since it will interact with the user interface.</p>
<p>To do this, perform the following steps:</p>
<ol>
<li>Open the <code>MainView.xaml.cs</code> file in the <code>Views\Mobile</code> folder.</li>
<li>Create an override of the <code>OnNavigatedTo</code> method.</li>
<li>Add the highlighted code in the following snippet to the <code>OnNavigateTo</code> method:<pre class="source-code">
    protected override void OnNavigatedTo(NavigatedToEventArgs args)
    {
        base.OnNavigatedTo(args);
<strong class="bold">        if (BindingContext is MainViewModel viewModel)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            MainThread.BeginInvokeOnMainThread(async () =&gt;</strong>
<strong class="bold">            {</strong>
<strong class="bold">                await viewModel.LoadDataAsync();</strong>
<strong class="bold">            });</strong>
<strong class="bold">        }</strong>
    }</pre></li> </ol>
<p>In the <code>MainView</code> XAML file, add a binding for the <code>Title</code> property of <code>ContentPage</code> to the <code>City</code> property in <code>ViewModel</code>, as follows:</p>
<ol>
<li>Open the <code>MainView.xaml</code> file in the <code>Views\Mobile</code> folder.</li>
<li>Add the <code>Title</code> binding to the <code>ContentPage</code> element, as highlighted in the following code snippet:<pre class="source-code">
&lt;ContentPage xmlns=”http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=”http://schemas.microsoft.com/winfx/2009/xaml”
    x:Class=”Weather.Views.Desktop.MainView”
    <strong class="bold">Title=”{Binding City}”</strong>&gt;</pre></li> </ol>
<p>In the <a id="_idIndexMarker855"/>next section, we will use <code>CollectionView</code> to display <a id="_idIndexMarker856"/>the weather data instead of using <code>FlexView</code>, as we did for the desktop view.</p>
<h3>Using a grouped CollectionView</h3>
<p>We could use <code>FlexLayout</code> for the phone’s view, but because we want our user experience <a id="_idIndexMarker857"/>to be as good as possible, we will use <code>CollectionView</code> instead. To get the headers for each day, we will use grouping for <code>CollectionView</code>. For <code>FlexLayout</code>, we had <code>ScrollView</code>, but for <code>CollectionView</code>, we don’t need this because <code>CollectionView</code> can handle scrolling by default.</p>
<p>Let’s continue creating the user interface for the phone’s view:</p>
<ol>
<li>Open the <code>MainView.xaml</code> file in the <code>Views\Mobile</code> folder.</li>
<li>Add <code>CollectionView</code> to the root of the page.</li>
<li>Set a binding to the <code>Days</code> property in <code>MainViewModel</code> for the <code>ItemSource</code> property.</li>
<li>Set <code>IsGrouped</code> to <code>True</code> to enable grouping in <code>CollectionView</code>.</li>
<li>Set <code>B<a id="_idTextAnchor814"/>ackgroundColor</code> to <code>Transparent</code>, as shown in the following code:<pre class="source-code">
&lt;CollectionView ItemsSource=”{Binding Days}” IsGrouped=”True” BackgroundColor=”Transparent”&gt;
&lt;/CollectionView&gt;</pre></li> </ol>
<p>To format <a id="_idIndexMarker858"/>how each header will look, we will create a <code>DataTemplate</code> property, as follows:</p>
<ol>
<li>Add a <code>DataTemplate</code> property to the <code>GroupHeaderTemplate</code> property of <code>CollectionView</code>.</li>
<li>Add the content for the row to <code>DataTemplate</code>, as shown in the following code:<pre class="source-code">
&lt;CollectionView ItemsSource=<a id="_idTextAnchor815"/>”{Binding Days}” IsGrouped=”True” BackgroundColor=”Transparent”&gt;
<strong class="bold">  &lt;CollectionView.GroupHeaderTemplate&gt;</strong>
<strong class="bold">    &lt;DataTemplate&gt;</strong>
<strong class="bold">      &lt;ContentView Padding=”15,5” BackgroundColor=”#9F5010”&gt;</strong>
<strong class="bold">        &lt;Label FontAttributes=”Bold” TextColor=”White” Text=”{Binding DateAsString}” VerticalOptions=”Center”/&gt;</strong>
<strong class="bold">      &lt;/ContentView&gt;</strong>
<strong class="bold">    &lt;/DataTemp<a id="_idTextAnchor816"/>late&gt;</strong>
<strong class="bold">  &lt;/CollectionView.GroupHeaderTemplate&gt;</strong>
&lt;/CollectionView&gt;</pre></li> </ol>
<p>To format how each forecast will look, we will create a <code>DataTemplate</code> property, as we did with the group header. Let’s set this up:</p>
<ol>
<li>Add a <code>DataTemplate</code> property to the <code>ItemTemplate</code> property of <code>CollectionView</code>.</li>
<li>In <code>DataTemplate</code>, add a <code>Grid</code> property that contains four columns. Use the <code>ColumnDefinition</code> property to specify the width of the columns. The second column should be <code>50</code>; the other three will share the rest of the space. We will <a id="_idIndexMarker859"/>d<a id="_idTextAnchor817"/>o this by setting <code>Width</code> to <code>*</code>.</li>
<li>Add the following content to <code>Grid</code>:<pre class="source-code">
&lt;CollectionView.ItemTemplate&gt;
  &lt;DataTemplate&gt;
    &lt;Grid Padding=”15,10” ColumnSpacing=”10” <a id="_idTextAnchor818"/>BackgroundColor=”#99FFFFFF”&gt;
      &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width=”*” /&gt;
        &lt;ColumnDefinition Width=”50” /&gt;
        &lt;ColumnDefinition Width=”*” /&gt;
        &lt;ColumnDefinition Width=”*” /&gt;
      &lt;/Grid.ColumnDefinitions&gt;
      &lt;Label FontAttributes=”Bold” Text=”{Binding TimeAsString}” VerticalOptions=”Center” /&gt;
      &lt;Image Grid.Column=”1” HeightRequest=”50” WidthRequest=”50” Source=”{Binding Icon}” Aspect=”AspectFit” VerticalOptions=”Center” /&gt;
      &lt;Label Grid.Column=”2” Text=”{Binding Temperature, StringFormat=’{0}° C’}”
VerticalOptions=”Center” /&gt;
      &lt;Label Grid.Column=”3” Text=”{Binding Description}” VerticalOptions=”Center” <a id="_idTextAnchor819"/><a id="_idTextAnchor820"/>/&gt;
    &lt;/Grid&gt;
  &lt;/DataTemplate&gt;
&lt;/CollectionView.ItemTemplate&gt;</pre></li> </ol>
<h3>Adding pull-to-refresh functionality</h3>
<p>For the tablet and desktop versions of the view, we added a button to the toolbar to refresh <a id="_idIndexMarker860"/>the weather forecast. In the phone version of the view, however, we will add pull-to-refresh functionality, which is a common way to refresh content in a list of data. <code>CollectionView</code> in .NET <a id="_idTextAnchor821"/>MAUI has no built-in support for pull-to-refresh as <code>ListView</code> has.</p>
<p>Instead, we can use <code>RefreshView</code>. <code>RefreshView</code> can be used to add pull-to-refresh behavior to any control. Let’s set this up:</p>
<ol>
<li>Go to <code>Views\Mobile\MainView.xaml</code>.</li>
<li>Wrap <code>CollectionView</code> inside <code>RefreshView</code>.</li>
<li>Bind the <code>RefreshCommand</code> property in <code>MainViewModel</code> to the <code>Command</code> property of <code>RefreshView</code> to trigger a refresh when the user performs a pull-to-refresh gesture.</li>
<li>To show a loading icon when the refresh is in progress, bind the <code>IsRefreshing</code> property in <code>MainViewModel</code> to the <code>IsRefreshing</code> property of <code>RefreshView</code>. When we are setting this up, we will also get a loading indicator <a id="_idTextAnchor822"/>when the initial load is running, as shown in the following code:<pre class="source-code">
&lt;RefreshView Command=”{Binding Refresh}” IsRefreshing=”{Binding IsRefreshing}”&gt;
  &lt;CollectionView ItemsSource=”{Binding Days}” IsGrouped=”True” Backg<a id="_idTextAnchor823"/><a id="_idTextAnchor824"/><a id="_idTextAnchor825"/>roundColor=”Transparent”&gt;
....
  &lt;/CollectionView&gt;
&lt;/RefreshView&gt;</pre></li> </ol>
<p>That <a id="_idIndexMarker861"/>concludes the views for the moment. Now, let’s wire them up into dependency injection so that we can see our work.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor826"/>Adding services and ViewModels to dependency injection</h2>
<p>For <a id="_idIndexMarker862"/>our views to get an instance of <code>MainViewModel</code> and <code>MainViewModel</code> to get an instance of <code>OpenWeatherMapWeatherService</code>, we need to add them to dependency injection. Let’s set this up:</p>
<ol>
<li>Open <code>MauiProgram.cs</code>.</li>
<li>Add the following highlighted code:<pre class="source-code">
#if DEBUG
    builder.Logging.AddDebug();
#endif
<strong class="bold">    builder.Services.AddSingleton&lt;IWeatherService, OpenWeatherMapWeatherService&gt;();</strong>
<strong class="bold">    builder.Services.AddTransient&lt;MainViewModel, MainViewModel&gt;();</strong>
    return builder.Build();</pre></li> </ol>
<p>In the next section, we will add the navigation to the views based on the device’s form factor.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor827"/>Navigating to different views based on the form factor</h2>
<p>We now have two different views that should be loaded in the same place in the app. <code>Weather.Views.Desktop.MainView</code> should be loaded if the app is running on a tablet or <a id="_idIndexMarker863"/>a desktop, while <code>Weather.Views.Mobile.MainView</code> should be loaded if the app is running on a phone.</p>
<p>The <code>Device</code> class in .NET MAUI has a static <code>Idiom</code> property that we can use to check which form factor the app is running on. The value of <code>Idiom</code> can be <code>Phone</code>, <code>Tablet</code>, <code>Desktop</code>, <code>Watch</code>, or <code>TV</code>. Because we only have one view in this app, we could have used an <code>if</code> statement when we were setting <code>MainPage</code> in <code>App.xaml.cs</code> and checked what the <code>Idiom</code> value was. </p>
<p>Since we are only ever going to need one view, we can register just the view that we need in dependency injection – all we need is a common type to register the views with. Let’s create a new interface that our views will implement:</p>
<ol>
<li>Create a new interface in the <code>Views</code> folder named <code>IMainView</code>.<p class="list-inset">We won’t add any additional pro<a id="_idTextAnchor828"/>perties or methods to the interface – we’ll just use it as a marker.</p></li>
<li>Open <code>Views\Desktop\MainView.xaml.cs</code> and add the <code>IMainView</code> interface to the class:<pre class="source-code">
public partial class MainView : ContentPage<code>Views\Mobile\MainView.xaml.cs</code> and add the <code>IMainView</code> interface to the class:<pre class="source-code">
public partial class MainView : ContentPage<strong class="bold">, IMainView</strong></pre></li> </ol>
<p>Now that we have a co<a id="_idTextAnchor829"/>mmon interface, we can register the views with dependency injection:</p>
<ol>
<li>Open the <code>MauiProgram.cs</code> file.</li>
<li>Add the following code:<pre class="source-code">
#if DEBUG
    builder.Logging.AddDebug();
#endif
    builder.Services.AddSingleton&lt;IWeatherService, OpenWeatherMapWeatherService&gt;();
    builder.Services.AddTransient&lt;MainViewModel, MainViewModel&gt;();
<strong class="bold">    if (DeviceInfo.Idiom == DeviceIdiom.Phone)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        builder.Services.AddTransient&lt;IMainView, Views.Mobile.MainView&gt;();</strong>
<strong class="bold">    }</strong>
<strong class="bold">    else</strong>
<strong class="bold">    {</strong>
<strong class="bold">        builder.Services.AddTransient&lt;IMainView, Views.Desktop.MainView&gt;();</strong>
<strong class="bold">    }</strong>
    return builder.Build();</pre></li> </ol>
<p>With these <a id="_idIndexMarker864"/>changes, we can now test our applicatio<a id="_idTextAnchor830"/>n. If you run your app, you should see something like the following:</p>
<div><div><img alt="Figure 8.10 – App running on macOS and iOS" src="img/B19214_08_10..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – App running on macOS and iOS</p>
<p>Next, let’s <a id="_idIndexMarker865"/>update the de<a id="_idTextAnchor831"/><a id="_idTextAnchor832"/><a id="_idTextAnchor833"/>sktop views to handle resizing properl<a id="_idTextAnchor834"/>y by using <code>VisualStateManager</code>.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor835"/>Handling states with VisualStateManager</h2>
<p><code>VisualStateManager</code> is a way to make changes in the UI from the code. We can define <a id="_idIndexMarker866"/>states and set values for selected properties to apply to a specific state. <code>VisualStateManager</code> can be useful in <a id="_idIndexMarker867"/>cases where we want to use the same view for devices with different screen resolutions. It was first introduced in <code>VisualStateManager</code> is interesting for us as .NET MAUI developers, especially when both iOS and Android can run on both phones and tablets.</p>
<p>In this project, we will use it to make a <code>forecast</code> item bigger when the app is running in landscape mode on a tablet or a desktop. We will also make the weather icon bigger. Let’s set this up:</p>
<ol>
<li>Open the <code>Views\Desktop\MainView.xaml</code> file.</li>
<li>In the first <code>FlexLayout</code> and <code>DataTemplate</code>, insert a <code>VisualStateManager.VisualStateGroups</code> element into the first <code>StackLayout</code>:<pre class="source-code">
&lt;StackLayout M<a id="_idTextAnchor836"/>argin=”10” Padding=”20” WidthRequest=”150” BackgroundColor=”#99FFFFFF”&gt;
<strong class="bold">  &lt;VisualStateMan<a id="_idTextAnchor837"/>ager.VisualStateGroups&gt;</strong>
<strong class="bold">    &lt;VisualStateGroup&gt;</strong>
<strong class="bold">    &lt;/VisualStateGroup&gt;</strong>
<strong class="bold">  &lt;/VisualStateManager.VisualStateGroups&gt;</strong>
<strong class="bold">......</strong>
&lt;/StackLayout&gt;</pre></li> </ol>
<p>Regarding <code>VisualStateGroup</code>, we should add two states, as follows:</p>
<ol>
<li>Add a <a id="_idIndexMarker868"/>new <code>VisualState</code> called <code>Portrait</code> to <code>VisualStateGroup</code>.</li>
<li>Create <a id="_idIndexMarker869"/>a setter in <code>VisualState</code> and set <code>WidthRequest</code> to <code>150</code>.</li>
<li>Add another <code>VisualState</code> called <code>Landscape</code> to <code>VisualStateGroup</code>.</li>
<li>Create a setter in <code>VisualState</code> and se<a id="_idTextAnchor838"/>t <code>WidthRequest</code> to <code>200</code>, as shown in the following code:<pre class="source-code">
&lt;VisualStateGroup&gt;
<strong class="bold">  &lt;VisualState Name=”Portrait”&gt;</strong>
<strong class="bold">    &lt;VisualState.Setters&gt;</strong>
<strong class="bold">      &lt;Setter Property=”Wid<a id="_idTextAnchor839"/>thRequest” Value=”150” /&gt;</strong>
<strong class="bold">      &lt;/VisualState.Setters&gt;</strong>
<strong class="bold">    &lt;/VisualState&gt;</strong>
<strong class="bold">  &lt;VisualState Name=”Landscape”&gt;</strong>
<strong class="bold">    &lt;VisualState.Setters&gt;</strong>
<strong class="bold">      &lt;Setter Property=”WidthRequest” Value=”200” /&gt;</strong>
<strong class="bold">    &lt;/VisualState.Setters&gt;</strong>
<strong class="bold">  &lt;/VisualState&gt;</strong>
&lt;/VisualStateGroup&gt;</pre></li> </ol>
<p>We also <a id="_idIndexMarker870"/>want the icons in a forecast <a id="_idIndexMarker871"/>item to be bigger when the item itself is bigger. To do this, we will use <code>VisualStateManager</code> again. Let’s set this up:</p>
<ol>
<li>Insert a <code>VisualStateManager.VisualStateGroups</code> element into the second <code>FlexLayout</code> and in the <code>Image</code> element in <code>DataTemplate</code>.</li>
<li>Add <code>VisualState</code> for both <code>Portrait</code> and <code>Landscape</code>.</li>
<li>Add setters to the states to set <code>WidthRequest</code> and <code>HeightRequest</code>. The value should be <code>100</code> in the <code>Portrait</code> state and <code>150</code> in the <code>Landscape</code> state, as shown in the following code:<pre class="source-code">
&lt;Image WidthRequest=”100” HeightRequest=”<a id="_idTextAnchor840"/>100” Aspect=”AspectFit” HorizontalOptions=”Center” Source=”{Binding Icon}”&gt;
<strong class="bold">  &lt;VisualStateManager.VisualStateGroups&gt;</strong>
<strong class="bold">    &lt;VisualStateGroup&gt;</strong>
<strong class="bold">      &lt;VisualState Name=”Portrait”&gt;</strong>
<strong class="bold">        &lt;VisualState.Setters&gt;</strong>
<strong class="bold">          &lt;Setter Property=”WidthRequest” Value=”100” /&gt;</strong>
<strong class="bold">          &lt;Setter Property=”HeightRequest” Value=”100” /&gt;</strong>
<strong class="bold">        &lt;/VisualState.Setters&gt;</strong>
<strong class="bold">      &lt;/VisualState&gt;</strong>
<strong class="bold">      &lt;VisualState Name=”Landscape”&gt;</strong>
<strong class="bold">        &lt;VisualState.Setters&gt;</strong>
<strong class="bold">          &lt;Setter Property=”WidthRequest” Value=”150” /&gt;</strong>
<strong class="bold">          &lt;Setter Property=”HeightRequest” Value=”150” /&gt;</strong>
<strong class="bold">        &lt;/VisualState.Setters&gt;</strong>
<strong class="bold">      &lt;/VisualState&gt;</strong>
<strong class="bold"><a id="_idTextAnchor841"/><a id="_idTextAnchor842"/><a id="_idTextAnchor843"/>    &lt;/VisualStateGroup&gt;</strong>
<strong class="bold">  &lt;/VisualStateManager.VisualStateGroups&gt;</strong>
&lt;/Image&gt;</pre></li> </ol>
<h3>Creating a behavior to set state changes</h3>
<p>With <code>Behavior</code>, we can add functionality to controls without having to subclass them. With behaviors, we can also create more reusable code than we could if we subclassed a control. The <a id="_idIndexMarker872"/>more specific <code>Behavior</code> we create, the more reusable it will be. For example, <code>Behavior</code> that inherits from <code>Behavior&lt;View&gt;</code> could be used on all controls, but <code>Behavior</code> that inherits from <code>Button</code> can only be used for buttons. Because of this, we always want to create behaviors with a less specific base class.</p>
<p>When we create <code>Behavior</code>, we need to override two methods: <code>OnAttached</code> and <code>OnDetachingFrom</code>. It is really important to remove event listeners in the <code>OnDeattached</code> method if we have added them to the <code>OnAttached</code> method. This will make the app use less memory. It is also important to set values back to the values that they had before the <code>OnAppearing</code> method ran; otherwise, we might see some strange behavior, especially if the behavior is in a <code>CollectionView</code> or <code>ListView</code> view that is reusing cells.</p>
<p>In this app, we will create a behavior for <code>FlexLayout</code>. This is because we can’t set the state of an item in <code>FlexLayout</code> from the code-behind. We could have added some code to check whether the app runs in portrait or landscape in <code>FlexLayout</code>, but if we use <code>Behavior</code> instead, we can separate that code from <code>FlexLayout</code> so that it will be more reusable. Perform the following steps to do so:</p>
<ol>
<li>Create a new folder called <code>Behaviors</code>.</li>
<li>Create a new class called <code>FlexLayoutBehavior</code>.</li>
<li>Add <code>Behavior&lt;FlexLayoutView&gt;</code> as a base class.</li>
<li>Create a <code>private<a id="_idTextAnchor844"/></code> field of the <code>FlexLayout</code> type called <code>view</code>.</li>
<li>The code should look as follows:<pre class="source-code">
using System;
namespace Weather.Behaviors;
public class FlexLayoutBehavior : Behavior&lt;FlexLayout&gt;
{
    private FlexLayout view;
}</pre></li> </ol>
<p><code>FlexLayout</code> is a class that inherits from the <code>Behavior&lt;FlexLayout&gt;</code> base class. This will give <a id="_idIndexMarker873"/>us the ability to override some virtual methods that will be called when we attach and detach the behavior from a <code>FlexLayout</code> class.</p>
<p>But first, we need to create a method that will handle the change in state. Perform the following steps to do so:</p>
<ol>
<li>Open the <code>FlexlayoutBehavior.cs</code> file.</li>
<li>Create a <code>private</code> method called <code>SetState</code>. This method will have a <code>VisualElement</code> value and a <code>string</code> argument.</li>
<li>Call <code>VisualStateManager.GoToState</code> and pass the parameters to it.</li>
<li>If the view is of the <code>Layout</code> type, there might be child elements that also need to get the new state. To do that, we will loop through all the children of the layout. Instead of just setting the state directly to the children, we will call the <code>SetState</code> method, which is the method that we are already inside. T<a id="_idTextAnchor845"/>he reason for this is that some of the children may have their own children:<pre class="source-code">
private void SetState(VisualElement view, string state)
{
    VisualStateManager.GoToState(view, state);
    if (view is Layout layout)
    {
        foreach (VisualElement child in layout.Children)
        {
            SetState(child, state);
        }
    }
}</pre></li> </ol>
<p>Now that <a id="_idIndexMarker874"/>we have created the <code>SetState</code> method, we need to write a method that uses it and determines what state to set. Perform the following steps to do so:</p>
<ol>
<li>Create a <code>private</code> method called <code>UpdateState</code>.</li>
<li>Run the code on <code>MainThread</code> to check whether the app is running in portrait or landscape mode.</li>
<li>Cre<a id="_idTextAnchor846"/>ate a variable called <code>page</code> and set its value to <code>Application.Current.MainPage</code>.</li>
<li>Check whether <code>Width</code> is larger than <code>Height</code>. If this is <code>true</code>, set the <code>VisualState</code> property on the <code>view</code> variable to <code>Landscape</code>. If this is <code>false</code>, set the <code>VisualSta<a id="_idTextAnchor847"/>te</code> property on the <code>view</code> variable to <code>Portrait</code>, as shown in the following code:<pre class="source-code">
private void UpdateState()
{
    MainThread.BeginInvokeOnMainThread(() =&gt;
    {
        var page = Application.Current.MainPage;
        if (page.Width &gt; page.Height)
        {
            SetState(view, “Landscape”);
            return;
        }
        SetState(view, “Portrait”);
    });
}</pre></li> </ol>
<p>With <a id="_idIndexMarker875"/>that, the <code>UpdateState</code> method has been added. Now, we need to override the <code>OnAttachedTo</code> method, which will be called when the behavior is added to <code>FlexLayout</code>. When it is, we want to update the state by calling this method and hook it up to the <code>SizeChanged</code> event of <code>MainPage</code> so that when the size changes, we will update the state again.</p>
<p>Let’s set this up:</p>
<ol>
<li>Open the <code>FlexLayoutBehavior</code> file.</li>
<li>Override the <code>OnAttachedTo</code> method from the base class.</li>
<li>Set the <code>view</code> property to the parameter from the <code>OnAttachedTo</code> method.</li>
<li>Add an event listener to <code>Application.Current.MainPage.SizeChanged</code>. In the event l<a id="_idTextAnchor848"/>istener, add a call to the <code>UpdateState</code> method, as shown in the following code:<pre class="source-code">
protected override void OnAttachedTo(FlexLayout view)
{
    this.view = view;
    base.OnAttachedTo(view);
    UpdateState();
    Application.Current.MainPage.SizeChanged += MainPage_SizeChanged;
}
void MainPage_SizeChanged(object sender, EventArgs e)
{
    UpdateState();
}</pre></li> </ol>
<p>When we <a id="_idIndexMarker876"/>remove behaviors from a control, it’s very important to also remove any event handlers from it to avoid memory leaks, and in the worst case, the app crashing. Let’s do this:</p>
<ol>
<li>Open the <code>FlexLayoutBehavior.cs</code> file.</li>
<li>Override <code>OnDetachingFrom</code> from the base class.</li>
<li>Remove the event listener from <code>Application.Current.MainPage.SizeChanged</code>.</li>
<li>Set the <code>view</code> field to <code>null</code>, as shown in the following code:<pre class="source-code">
protected override void OnDetachingFrom(FlexLayout view)
{
    base.OnDetachingFrom(view);
    Application.Current.MainPage.SizeChanged -= MainPage_SizeChanged;
    this.view = null;
}</pre></li> </ol>
<p>Perform <a id="_idIndexMarker877"/>the following steps to add <code>behavior</code> to the view:</p>
<ol>
<li>Open the <code>MainView.xaml</code> file inside the <code>Views/Desktop</code> folder.</li>
<li>Import the <code>Weather.Behaviors</code> namespace, as shown in the following code:<pre class="source-code">
&lt;ContentPage xmlns=”http://schemas.microsoft.com/dotnet/2021/maui”
             xmlns:x=”http://schemas.microsoft.com/winfx/2009/xaml”
<strong class="bold">    xmlns:behaviors=”clr-namespace:Weather.Beha<a id="_idTextAnchor849"/>viors”</strong> 
    x:Class=”Weather.Views.Desktop.MainView”
    Title=”{Binding City}”&gt;</pre></li> </ol>
<p>The last thing we will do is add <code>FlexLayoutBehavior</code> to the second <code>FlexLayout</code>, as shown in the following code:</p>
<pre class="source-code">
&lt;FlexLayout Ite<a id="_idTextAnchor850"/>msSource=”{Binding Items}” Wrap=”Wrap” JustifyContent=”Start” AlignItems=”Start”&gt;
<strong class="bold">  &lt;FlexLayout.Behaviors&gt;</strong>
<strong class="bold">    &lt;behaviors:FlexLayoutBehavior /&gt;</strong>
<strong class="bold">  &lt;/FlexLayout.Behaviors&gt;</strong>
&lt;FlexLayout.ItemsTemplate&gt;</pre> <p>Congratulations – that <a id="_idIndexMarker878"/>is a wrap on <a id="_idTextAnchor851"/>the weather app!</p>
<div><div><img alt="Figure 8.11 – Completed app on tablet, phone, and desktop" src="img/B19214_08_11..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Completed app on tablet, phone, and desktop</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor852"/>Summary</h1>
<p>In this chapter, we successfully created an app for four different operating systems – iOS, macOS, Android, and Windows – and three different form factors – phones, tablets, and desktop computers. To create a good user experience on all platforms and form factors, we used <code>FlexLayout</code> and <code>VisualStateManager</code>. We also learned how to handle different views for different form factors, as well as how to use <code>Behaviors</code>.</p>
<p>The next app we will build will be a game with real-time communication. In the next chapter, we will take a look at how we can use the <strong class="bold">SignalR</strong> service in <strong class="bold">Azure</strong> as the backend game service.</p>
</div>


<div><h1 id="_idParaDest-148" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor853"/>Part 3: Advanced Projects</h1>
<p>In this part, you will work with more advanced topics and complicated projects. You will learn how to create and deploy a service in Azure. Additionally, you will work with Azure Storage and SignalR services. You will learn how to call your service from a .NET MAUI application, properly handle error conditions, and integrate the camera into your app. You will explore a project using Blazor embedded into a .NET MAUI app, and learn how to integrate artificial intelligence services into a .NET MAUI app.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19214_09.xhtml#_idTextAnchor854"><em class="italic">Chapter 9</em></a>, <em class="italic">Setting Up a Backend for a Game Using Azure Services</em></li>
<li><a href="B19214_10.xhtml#_idTextAnchor867"><em class="italic">Chapter 10</em></a>, <em class="italic">Building a Real-Time Game</em></li>
<li><a href="B19214_11.xhtml#_idTextAnchor895"><em class="italic">Chapter 11</em></a>, <em class="italic">Building a Calculator Using .NET MAUI Blazor</em></li>
<li><a href="B19214_12.xhtml#_idTextAnchor919"><em class="italic">Chapter 12</em></a>, <em class="italic">Hot Dog or Not Hot Dog Using Machine Learning</em></li>
</ul>
</div>
<div><div></div>
</div>
</body></html>