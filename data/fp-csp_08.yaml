- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Recursion and Tail Calls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归和尾调用
- en: In this chapter, we will look at the concept of recursion, which is particularly
    powerful for tackling problems with inherent hierarchical or repetitive structures,
    such as directory traversal, parsing nested data formats, or implementing algorithms
    on tree-like data structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨递归的概念，这对于解决具有固有层次或重复结构的难题特别有效，例如目录遍历、解析嵌套数据格式或实现树形数据结构的算法。
- en: 'As we delve into recursion, we’ll explore its two main components: the base
    case and the recursive case. The base case acts as a stop signal for recursion,
    preventing infinite loops, while the recursive case is where the function makes
    progress toward the base case. In addition to these cases, we will discuss the
    following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入递归，我们将探讨其两个主要组成部分：基本情况（base case）和递归情况（recursive case）。基本情况充当递归的停止信号，防止无限循环，而递归情况是函数向基本情况迈进的地方。除了这些情况之外，我们还将讨论以下主题：
- en: 'Types of recursion: simple and tail recursions'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归类型：简单递归和尾递归
- en: 'Challenges of recursion: stack overflow risk and performance considerations'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归的挑战：栈溢出风险和性能考虑
- en: 'C# features for recursion: local functions and pattern matching'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 的递归特性：局部函数和模式匹配
- en: 'Advanced recursive patterns: mutual recursion and memoization'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级递归模式：相互递归和记忆化
- en: 'Comparison with iterative solutions: readability and performance'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与迭代解决方案的比较：可读性和性能
- en: 'Recursion in asynchronous programming: async recursion'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程中的递归：异步递归
- en: As always, we start with a self-evaluation to measure your current understanding
    of recursion. The following tasks are designed to test your grasp of the concepts
    we’ll be covering. If you find these tasks challenging, this chapter will be a
    very valuable resource for you. On the other hand, if you solve these tasks with
    ease, you may still discover new insights and applications of recursion or just
    move on to the next chapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们从一个自我评估开始，以衡量你对递归当前的理解。以下任务旨在测试你对我们将要涵盖的概念的掌握。如果你发现这些任务具有挑战性，那么这一章将是非常有价值的资源。另一方面，如果你轻松地解决了这些任务，你仍然可以发现递归的新见解和应用，或者继续阅读下一章。
- en: Task 1 – Recursive enemy count
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 1 – 递归敌人计数
- en: 'Steve’s game has a hierarchical structure of enemy waves, where each wave can
    contain both individual enemies and sub-waves. Implement a recursive function,
    `CountAllEnemies`, that navigates through a `Wave` object (which can contain both
    `Enemy` objects and `Wave` objects) and returns the total count of enemies found
    within that wave, including all its sub-waves (flying, armored, quick, etc.):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫的游戏具有敌人波次的层次结构，其中每个波次可以包含单个敌人和子波次。实现一个递归函数 `CountAllEnemies`，该函数遍历 `Wave`
    对象（可以包含 `Enemy` 对象和 `Wave` 对象），并返回在该波次及其所有子波次（飞行、装甲、快速等）中找到的敌人总数：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Test your method with a `Wave` containing a mix of `Enemy` objects and `Wave`
    objects to ensure that it accurately counts all enemies, including those in nested
    sub-waves.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包含混合 `Enemy` 对象和 `Wave` 对象的 `Wave` 测试你的方法，以确保它准确计算所有敌人，包括嵌套子波中的敌人。
- en: Task 2 – Wave generation
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 2 – 波次生成
- en: Using the same wave structure from Task 1, Steve wants to generate increasingly
    complex waves as the game progresses. Implement a recursive function, `GenerateWave`,
    that creates a `Wave` object with a nested structure of enemies and sub-waves
    based on the current level number.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与任务 1 相同的波次结构，史蒂夫希望在游戏进行过程中生成越来越复杂的波次。实现一个递归函数 `GenerateWave`，该函数根据当前级别数量创建具有嵌套敌人子波次的
    `Wave` 对象。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function should create more complex wave structures as the level number
    increases. Consider the following guidelines:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数应随着级别数量的增加创建更复杂的波形结构。请考虑以下指南：
- en: For every 5 levels, add a sub-wave.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每 5 个级别增加一个子波次。
- en: The number of enemies in each wave or sub-wave should increase with the level
    number.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个波次或子波次中的敌人数量应随着级别数量的增加而增加。
- en: Introduce more varied enemy types as the levels progress.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着级别的提升，引入更多样化的敌人类型。
- en: Every 10th level should include a boss enemy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每 10 个级别应包括一个Boss敌人。
- en: Test your method with different level numbers to ensure it generates appropriate
    wave structures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的级别数量测试你的方法，以确保它生成适当的波形结构。
- en: 'Example usage:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Task 3 – Asynchronously updating enemy stats
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 3 – 异步更新敌人状态
- en: Updating the stats of enemies (such as health, speed, or damage) might need
    to be done asynchronously, especially if it involves fetching or syncing information
    from a game server. Implement an `UpdateAllEnemyStatsAsync` method that recursively
    goes through a hierarchy of waves (containing both enemies and sub-waves) and
    updates stats for each enemy asynchronously.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更新敌人的统计数据（如健康、速度或伤害）可能需要异步进行，特别是如果它涉及到从游戏服务器获取或同步信息。实现一个`UpdateAllEnemyStatsAsync`方法，该方法递归地遍历波次层次结构（包含敌人和子波次）并异步更新每个敌人的统计数据。
- en: 'For the sake of this exercise, simulate the asynchronous update operation with
    the `UpdateStatsAsync(Enemy enemy)` method, which returns `Task`. Your recursive
    function should await the completion of stat updates for each enemy before moving
    to the next:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个练习，使用`UpdateStatsAsync(Enemy enemy)`方法模拟异步更新操作，该方法返回`Task`。你的递归函数应在移动到下一个敌人之前等待每个统计数据更新的完成：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you tackle these tasks, pay attention to how you break down each problem
    into smaller pieces and how you identify the base case and recursive case for
    each scenario. This initial self-evaluation will not only prepare you for the
    concepts ahead but also provide a practical context for their application. Now,
    let’s dive in and explore recursion in detail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '当你处理这些任务时，注意你如何将每个问题分解成更小的部分，以及你如何识别每个场景的基本情况和递归情况。这种初步的自我评估不仅会为你准备前面的概念，还会提供一个实际的应用背景。现在，让我们深入探讨递归。 '
- en: Introducing recursion
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍递归
- en: As Steve continued developing his tower defense game, he found himself struggling
    with complex nested structures for enemy waves. He called Julia, hoping she might
    have some insights.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随着史蒂夫继续开发他的塔防游戏，他发现自己难以处理复杂的嵌套结构敌波。他打电话给朱莉娅，希望她可能有一些见解。
- en: 'Julia: *It sounds like you’re dealing with hierarchical data structures. Have
    you considered* *using recursion?*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*听起来你正在处理层次化的数据结构。你考虑过* *使用递归吗？*
- en: 'Steve: *Recursion? Isn’t that when a function calls itself? It always seemed
    a bit confusing* *to me.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*递归？这不是函数调用自身吗？这对我来说一直有点令人困惑* *。*
- en: 'Julia: *That’s right, but it’s a powerful tool for handling nested structures.
    Let’s explore how it could help with* *your game.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*没错，但它是一个处理嵌套结构的强大工具。让我们看看它如何帮助你* *的游戏。*
- en: Recursion is a programming technique where a function calls itself to solve
    a problem. It’s like breaking down a task into smaller tasks of the same type.
    This approach is very useful for tasks that have a repetitive structure, such
    as navigating through folders and files, working with data structures such as
    trees, or doing calculations that follow a pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种编程技术，其中函数调用自身来解决问题。这就像将任务分解成相同类型的小任务。这种方法对于具有重复结构的任务非常有用，例如导航文件夹和文件、处理如树这样的数据结构或进行遵循模式的计算。
- en: 'In recursion, there are two main parts: the base case and the recursive case.
    The base case stops the recursion from going on forever. It’s where the function
    doesn’t call itself again. The recursive case is where the function does call
    itself but with a simpler version of the original problem.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归中，有两个主要部分：基本情况和对递归情况。基本情况阻止递归无限进行。这是函数不再调用自身的地方。递归情况是函数调用自身，但使用原始问题的简化版本。
- en: Let’s apply recursion to a practical example. Imagine we need to count the total
    number of views for a series of videos organized in a nested playlist, where a
    playlist can contain both videos and other playlists.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将递归应用于一个实际例子。想象一下，我们需要计算一系列嵌套播放列表中视频的总观看次数，其中播放列表可以包含视频和其他播放列表。
- en: 'Here’s how we might write a recursive function to solve this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样编写一个递归函数来解决这个问题：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code, `CountViews` is a recursive function that can handle both videos
    and playlists. If it encounters a video, it returns the number of views (the base
    case). If it encounters a playlist, it goes through each item in the playlist
    and calls itself to count the views, adding up all the views for a total (the
    recursive case).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`CountViews`是一个递归函数，它可以处理视频和播放列表。如果它遇到视频，它返回观看次数（基本情况）。如果它遇到播放列表，它遍历播放列表中的每个项目，并调用自身来计算观看次数，将所有观看次数加起来得到总数（递归情况）。
- en: Recursion is powerful for problems like this because it simplifies the code
    and makes it more readable, especially when dealing with nested or hierarchical
    data. However, it’s important to always have a clear base case to prevent the
    function from calling itself indefinitely.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类问题，递归非常强大，因为它简化了代码并使其更易于阅读，尤其是在处理嵌套或层次化数据时。然而，始终要有明确的基准情况，以防止函数无限期地调用自身。
- en: Recursive thinking
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归思维
- en: When managing a complex hierarchy of videos, such as sorting them into categories
    and subcategories, thinking recursively can simplify the process. Recursive thinking
    means breaking down a big problem into smaller versions of the same problem until
    it becomes easy to solve.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理复杂的视频层次结构，如将它们分类到类别和子类别中时，递归思维可以简化这个过程。递归思维意味着将一个大问题分解成相同问题的较小版本，直到它变得容易解决。
- en: Let’s take organizing a tree of video categories and subcategories as our example.
    The goal is to go through each category, visit all its subcategories, and organize
    the videos in each. This task sounds complex, but recursion makes it easier by
    handling one category (and its subcategories) at a time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以组织视频类别和子类别的树状结构为例。目标是遍历每个类别，访问其所有子类别，并组织每个类别中的视频。这项任务听起来很复杂，但递归通过一次处理一个类别（及其子类别）来简化了任务。
- en: 'Here’s how you might write a recursive function to do this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会这样编写一个递归函数来完成这个任务：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, `OrganizeVideos` is a recursive function. It looks at a category,
    and for each subcategory, it calls itself, diving deeper into the hierarchy. This
    is the recursive case. After it has visited all subcategories, it then organizes
    the videos in the current category. That’s where you’d put your sorting or organizing
    logic, but for now, we’re keeping it simple with a `print` statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`OrganizeVideos` 是一个递归函数。它查看一个类别，并为每个子类别调用自身，深入到层次结构的更深处。这是递归情况。在访问完所有子类别后，它然后在当前类别中组织视频。这就是你放置排序或组织逻辑的地方，但现在我们保持简单，使用一个
    `print` 语句。
- en: The beauty of recursive thinking is how it simplifies managing a complex hierarchy.
    You deal with organizing videos at just one level at a time, and recursion takes
    care of diving into the depths of the hierarchy for you. Just like in the previous
    example, having a clear base case (in this case, reaching a category with no subcategories)
    ensures that the recursion doesn’t go on indefinitely.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 递归思维的美丽之处在于它如何简化对复杂层次结构的管理。你只需一次处理一个级别的视频组织，递归会为你处理层次结构的深度。就像之前的例子一样，有一个清晰的基准情况（在这种情况下，到达没有子类别的类别）可以确保递归不会无限期地进行。
- en: Now, let’s look at an example demonstrating the power of recursive thinking
    in parsing nested JSON data. Consider a scenario where we need to process a JSON
    string representing a book publishing system’s catalog and convert it into a corresponding
    object hierarchy. This example will showcase how recursion can simplify the task
    of navigating and constructing complex data structures.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个示例，展示递归思维在解析嵌套JSON数据中的强大功能。考虑一个场景，我们需要处理表示图书出版系统目录的JSON字符串，并将其转换为相应的对象层次结构。这个例子将展示递归如何简化导航和构建复杂数据结构的任务。
- en: 'Assume we have the following JSON string representing a book catalog with nested
    genres and sub-genres:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个表示图书目录的JSON字符串，其中包含嵌套的流派和子流派：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To parse this JSON string and create a corresponding object hierarchy, we define
    the following classes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析这个JSON字符串并创建相应的对象层次结构，我们定义了以下类：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s implement the recursive functions to parse the JSON string and construct
    the object hierarchy:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现递归函数来解析JSON字符串并构建对象层次结构：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `ParseCatalog` function serves as the entry point, recursively calling `ParseGenre`
    for each genre in the catalog. `ParseGenre`, in turn, recursively calls itself
    for each subgenre and invokes `ParseBook` for each book within the genre or subgenre.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseCatalog` 函数作为入口点，递归地为目录中的每个流派调用 `ParseGenre`。`ParseGenre` 然后，递归地为每个子流派调用自身，并为流派或子流派中的每本书调用
    `ParseBook`。'
- en: With recursion, we can effectively navigate the nested structure of the JSON
    string, handling the parsing of sub-elements (genres, subgenres, and books) within
    the context of their parent elements (catalog and genres). This approach results
    in cleaner and more maintainable code compared to an iterative solution, which
    would require explicit management of multiple levels of nesting and conditional
    checks for the presence of subgenres and books.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归，我们可以有效地导航JSON字符串的嵌套结构，处理在父元素（目录和类别）上下文中子元素（流派、子流派和书籍）的解析。与需要显式管理多层嵌套和检查子流派和书籍存在性的迭代解决方案相比，这种方法的结果代码更干净、更易于维护。
- en: Types of recursion
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归的类型
- en: 'Recursion can be classified into two main types based on how the recursive
    call is made and its position within the function: simple recursion and tail recursion.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据递归调用方式和其在函数中的位置，递归可以分为两种主要类型：简单递归和尾递归。
- en: Simple recursion
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单递归
- en: 'Simple recursion occurs when a function calls itself directly. This type is
    the most common and easiest to understand. Let’s use it to count the total number
    of videos in a hierarchy of video categories and subcategories:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 简单递归发生在函数直接调用自身时。这种类型是最常见且最容易理解的。让我们用它来计算视频类别和子类别层次结构中的总视频数量：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code, `CountTotalVideos` counts all videos in the given category, including
    those in its subcategories. It starts by counting videos in the current category.
    Then, it goes through each subcategory, calls itself for each one, and adds their
    video counts to the total.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`CountTotalVideos` 函数计算给定类别中的所有视频，包括其子类别中的视频。它首先计算当前类别中的视频数量。然后，它遍历每个子类别，对每个子类别调用自身，并将它们的视频计数添加到总数中。
- en: Tail recursion
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归
- en: Tail recursion is a special case of recursion where the recursive call is the
    last operation in the function. It’s important because many compilers optimize
    it to avoid increasing the call stack, which makes the function more efficient
    and prevents stack overflow errors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归是递归的一个特殊情况，其中递归调用是函数中的最后一个操作。它很重要，因为许多编译器会优化它以避免增加调用栈，这使得函数更高效，并防止栈溢出错误。
- en: Let’s look at an example where we flatten the video category tree into a single
    list of videos. This task can benefit from tail recursion optimization.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，我们将视频类别树扁平化为一个包含视频的单列表。这个任务可以从尾递归优化中受益。
- en: 'First, we need a slight modification in our approach to allow tail recursion.
    Instead of returning the result directly, we pass along an accumulator—a container
    that collects the result as we go:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对我们的方法进行轻微的修改，以允许尾递归。而不是直接返回结果，我们传递一个累加器——一个收集结果的容器：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To use this function, you’d start with an empty list and pass it in:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数，您可以从一个空列表开始，并将其传递进去：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function is tail-recursive because the last action it takes is the recursive
    call (or adding to the accumulator, which doesn’t change the nature of the recursion).
    However, it’s worth noting that not all programming languages or compilers automatically
    optimize tail recursion. In .NET, for example, tail call optimization is at the
    discretion of the CLR, and it might not always apply it. Still, writing tail-recursive
    functions can be a good practice for efficiency and clarity, especially in languages
    and environments that support optimization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是尾递归的，因为它的最后一个操作是递归调用（或添加到累加器，这并不改变递归的本质）。然而，值得注意的是，并非所有编程语言或编译器都会自动优化尾递归。例如，在.NET中，尾调用优化由CLR决定，并且可能并不总是应用。尽管如此，编写尾递归函数对于效率和清晰度来说是一种良好的实践，尤其是在支持优化的语言和环境中。
- en: Challenges of recursion
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归的挑战
- en: 'When using recursion in programming, two main challenges often arise: the risk
    of stack overflow and the considerations for performance. Let’s dive into these
    challenges with our characters.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中使用递归时，通常会遇到两个主要挑战：栈溢出的风险和性能考虑。让我们通过我们的角色深入探讨这些挑战。
- en: As Steve began implementing recursive functions in his game, he ran into some
    issues.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当Steve开始在游戏中实现递归函数时，他遇到了一些问题。
- en: 'Steve: *Julia, I’m getting stack overflow errors when I have too many nested
    waves. What’s* *going on?*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Steve：*Julia，当我有很多嵌套层时，我遇到了栈溢出错误。这是* *怎么回事* *？
- en: 'Julia: *Ah, you’ve discovered one of the challenges of recursion. Let’s talk
    about stack overflow risk and how to* *mitigate it.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Julia：*啊，你已经发现了递归的一个挑战。让我们来谈谈栈溢出的风险以及如何* *缓解它* *。
- en: Stack overflow risk
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈溢出风险
- en: A stack overflow occurs when there’s too much information to store in the call
    stack—the part of memory that tracks where each function is in its execution.
    This can happen if a recursive function calls itself too many times without reaching
    a base case.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 栈溢出发生在调用栈中存储的信息过多——这是跟踪每个函数在其执行中位置的内存部分。如果递归函数调用自己太多次而没有达到基本情况，就会发生这种情况。
- en: 'For example, when counting the total number of videos in all categories and
    subcategories, if the hierarchy is very deep or there’s a circular reference (a
    category somehow includes itself), the `CountVideos` function could keep calling
    itself indefinitely:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当计算所有类别和子类别的视频总数时，如果层次结构非常深或存在循环引用（某个类别以某种方式包含了自己），`CountVideos` 函数可能会无限期地调用自己：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the category structure is very deep, this could lead to thousands of nested
    calls, each one adding a frame to the call stack, potentially causing a stack
    overflow error.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分类结构非常深，这可能会导致成千上万的嵌套调用，每个调用都会向调用栈添加一个帧，从而可能引发栈溢出错误。
- en: Default stack size and limitations
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认栈大小和限制
- en: When using recursion, it’s crucial to be aware of the limitations imposed by
    the default stack size. The stack is a region of memory used to store method calls,
    local variables, and other information. Each recursive call adds a new frame to
    the stack, consuming a portion of the available stack space. If the recursion
    depth becomes too large, it can exhaust the stack, leading to a stack overflow
    exception.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用递归时，了解默认栈大小带来的限制至关重要。栈是用于存储方法调用、局部变量和其他信息的内存区域。每次递归调用都会向栈添加一个新的帧，消耗一部分可用的栈空间。如果递归深度变得过大，可能会耗尽栈，导致栈溢出异常。
- en: 'In .NET, the default stack size varies depending on the architecture:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，默认栈大小根据架构的不同而有所不同：
- en: '32-bit: 1 MB'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位：1 MB
- en: '64-bit: 4 MB'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64位：4 MB
- en: It’s important to note that these default sizes are subject to change and may
    vary based on the specific runtime environment and configuration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些默认大小可能会变化，并且可能根据特定的运行时环境和配置而有所不同。
- en: To understand the impact of stack size on recursion, let’s use the example of
    the preceding `CountVideos` function. If the category hierarchy is very deep,
    the recursive calls to `CountVideos` can quickly consume the available stack space.
    For example, with a stack size of 1 MB and assuming an average stack frame size
    of 32 bytes (for simplicity), the maximum recursion depth would be approximately
    32,000 (1 MB / 32 bytes). Exceeding this depth would result in a stack overflow
    exception.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解栈大小对递归的影响，让我们以先前的 `CountVideos` 函数为例。如果分类层次结构非常深，对 `CountVideos` 的递归调用会迅速消耗可用的栈空间。例如，如果栈大小为
    1 MB，并且假设平均栈帧大小为 32 字节（为了简化），最大递归深度大约为 32,000（1 MB / 32 字节）。超过这个深度将导致栈溢出异常。
- en: 'To mitigate the risk of stack overflow, you can employ several techniques:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻栈溢出的风险，您可以采用几种技术：
- en: '**Tail call optimization** (**TCO**): If your recursive function is tail-recursive,
    the compiler may optimize it to avoid adding new frames to the stack. However,
    TCO is not guaranteed in .NET and depends on the runtime’s discretion.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尾递归优化**（**TCO**）：如果您的递归函数是尾递归的，编译器可能会优化它以避免向栈添加新的帧。然而，在 .NET 中，TCO 并不保证，并且取决于运行时的决定。'
- en: '**Iterative alternatives**: Convert the recursive algorithm to an iterative
    one using loops and data structures such as stacks or queues. Iterative solutions
    generally have a smaller stack footprint compared to recursive ones.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代替代方案**：使用循环和数据结构（如栈或队列）将递归算法转换为迭代算法。与递归算法相比，迭代解决方案通常具有更小的栈占用。'
- en: '`System.Threading.Thread.MaxStackSize` property or by configuring the runtime
    environment.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `System.Threading.Thread.MaxStackSize` 属性或配置运行时环境。
- en: '**Limit recursion depth**: Implement a maximum depth limit in your recursive
    function to prevent excessive recursion. This can be done by passing a depth counter
    as a parameter and checking against a predefined limit.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制递归深度**：在您的递归函数中实现最大深度限制，以防止过度递归。这可以通过传递一个深度计数器作为参数，并检查预定义的限制来完成。'
- en: 'Here’s an example of limiting the recursion depth in the `CountVideos` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `CountVideos` 函数中限制递归深度的示例：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this modified version, the `CountVideos` function takes additional parameters:
    `depth` to track the current recursion depth, and `maxDepth` to specify the maximum
    allowed depth. If `depth` exceeds `maxDepth`, a `StackOverflowException` is thrown
    to prevent further recursion.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改后的版本中，`CountVideos`函数增加了额外的参数：`depth`用于跟踪当前递归深度，`maxDepth`用于指定允许的最大深度。如果`depth`超过`maxDepth`，则会抛出`StackOverflowException`以防止进一步的递归。
- en: Performance considerations
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: Recursion can sometimes be less efficient than iterative solutions, especially
    in languages and environments that don’t optimize recursive calls. The main reasons
    are the overhead of multiple function calls and, in non-tail-recursive cases,
    the additional memory required to maintain the call stack.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 递归有时可能不如迭代解决方案高效，尤其是在不优化递归调用的语言和环境中。主要原因包括多次函数调用的开销以及在非尾递归情况下，维护调用栈所需的额外内存。
- en: Again, in the best case scenario, a smart compiler could optimize this to avoid
    a stack overflow and make it run as efficiently as a loop. However, not all environments
    support this optimization, and without it, tail recursion offers no performance
    benefit over simple recursion.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在最佳情况下，智能编译器可以优化它以避免栈溢出，并使其运行得像循环一样高效。然而，并非所有环境都支持这种优化，并且没有这种优化，尾递归在性能上并不比简单递归有优势。
- en: To mitigate the risk of stack overflow with deep recursion, you can sometimes
    refactor recursive functions to use an iterative approach or ensure your recursion
    has a guaranteed termination condition. For performance, it’s often about weighing
    the readability and elegance of recursion against the efficiency of iteration.
    In some cases, using iterative algorithms can be a more practical choice, especially
    for very large datasets or when working in environments that don’t optimize tail
    recursion.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻深度递归导致栈溢出的风险，有时可以将递归函数重构为使用迭代方法，或者确保递归有一个保证终止的条件。在性能方面，通常是在递归的可读性和优雅性与迭代的效率之间权衡。在某些情况下，使用迭代算法可能是一个更实际的选择，尤其是在处理非常大的数据集或在未优化尾递归的环境中。
- en: Leveraging C# features for recursion
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 C# 功能进行递归
- en: C# offers several features that can make writing recursive functions easier
    and your code cleaner. Two of these features are local functions and pattern matching.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了几个功能，可以使编写递归函数更容易，代码更简洁。其中两个功能是局部函数和模式匹配。
- en: Local functions
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部函数
- en: Local functions allow you to define functions inside the body of another function.
    This can be particularly useful for recursion when you want to encapsulate all
    the logic within a single method, keeping the recursive part separate for clarity
    and maintainability.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数允许你在另一个函数体内定义函数。这在需要将所有逻辑封装在单个方法中，并保持递归部分独立以提高清晰性和可维护性时特别有用。
- en: 'Here’s an example showing how to use a local function for recursively processing
    video categories and counting videos:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了如何使用局部函数递归处理视频类别并计数视频：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, `CountVideos` is a local function defined within `ProcessAndCount`
    **VideosInCategory**. It’s used to traverse the hierarchy of video categories,
    counting videos in all subcategories. The total count is kept in the `videoCount`
    variable, which is accessible to the local function thanks to C#’s closure capabilities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`CountVideos`是一个在`ProcessAndCount VideosInCategory`中定义的局部函数。它用于遍历视频类别的层次结构，计算所有子类别中的视频数量。总数保存在`videoCount`变量中，由于C#的闭包功能，局部函数可以访问这个变量。
- en: Pattern matching
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Pattern matching makes it easier to work with complex data by letting you check
    types and conditions more simply. It’s particularly useful in recursive functions
    where you need to handle different types or scenarios.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配通过允许你更简单地检查类型和条件，使得处理复杂数据变得更容易。它在需要处理不同类型或场景的递归函数中特别有用。
- en: 'Let’s see how pattern matching can streamline our function for processing video
    categories:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模式匹配如何简化我们处理视频类别的函数：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, pattern matching is used to check whether the `category` has
    subcategories. If it does, the function recursively processes each subcategory.
    This approach makes the code more readable and eliminates the need for multiple
    `if` statements or type checks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用模式匹配来检查`category`是否有子类别。如果有，函数会递归地处理每个子类别。这种方法使代码更易于阅读，并消除了需要多个`if`语句或类型检查的需求。
- en: Both local functions and pattern matching are powerful tools, especially when
    dealing with recursion. They not only make your recursive logic more understandable
    but also keep your code organized and concise.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数和模式匹配都是强大的工具，尤其是在处理递归时。它们不仅使您的递归逻辑更易于理解，而且使您的代码更有组织性和简洁性。
- en: Advanced recursive patterns
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级递归模式
- en: In more complex scenarios, recursion can be taken a step further with techniques
    such as mutual recursion and memoization. These advanced patterns can optimize
    performance and manage tasks that require alternating between different operations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的场景中，可以通过相互递归和缓存等技术将递归进一步扩展。这些高级模式可以优化性能并管理需要在不同操作之间交替的任务。
- en: Mutual recursion
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相互递归
- en: Mutual recursion occurs when two or more functions call each other in a cycle.
    This pattern can be particularly useful when you have a problem that requires
    switching between different types of tasks. Imagine a scenario where one function
    organizes video metadata and another validates it. Each function calls the other
    as part of its process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多函数在循环中相互调用时，发生相互递归。这种模式在您有一个需要在不同类型任务之间切换的问题时特别有用。想象一个场景，其中一个函数组织视频元数据，另一个验证它。每个函数都将其作为其过程的一部分调用另一个函数。
- en: In a book creation process, books often undergo a meticulous cycle of editing
    and review before being deemed ready for publication. This process, inherently
    iterative and dependent on passing various checks at each stage, lends itself
    well to a mutual recursion model. Here, we explore a scenario where a book’s manuscript
    is edited for both content and format, each process potentially unveiling the
    need for further alterations in the other.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍创建过程中，书籍通常在被视为出版就绪之前经历细致的编辑和审查周期。这个过程本质上是一个迭代过程，依赖于每个阶段的检查，非常适合相互递归模型。在这里，我们探讨了一个场景，即书籍的手稿在内容和格式方面都进行了编辑，每个过程都可能揭示需要对另一个过程进行进一步修改的需求。
- en: Consider a system where after a manuscript is initially edited for content (such
    as narrative structure, character development, etc.); it must then be formatted
    to meet publishing standards (including font consistency, margin settings, and
    header/footer content). However, the formatting process might introduce or reveal
    content issues that need re-editing, illustrating a dynamic interdependence between
    these stages.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个系统，在稿件内容（如叙事结构、人物发展等）初步编辑后，它必须格式化以满足出版标准（包括字体一致性、页边距设置和页眉/页脚内容）。然而，格式化过程可能会引入或揭示需要重新编辑的内容问题，说明了这些阶段之间的动态相互依赖性。
- en: 'Here’s a conceptual implementation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个概念性的实现：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, the `PublishingWorkflow` class contains two mutually recursive
    functions: `EditContent` and `EditFormat`. `EditContent` handles narrative and
    textual corrections, while `EditFormat` ensures that the manuscript adheres to
    the publisher’s formatting standards. The discovery of issues in one stage can
    lead back to the other, mirroring the real-world intricacies of preparing a manuscript
    for publication.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`PublishingWorkflow` 类包含两个相互递归的函数：`EditContent` 和 `EditFormat`。`EditContent`
    处理叙事和文本的修正，而 `EditFormat` 确保稿件符合出版商的格式标准。一个阶段发现的问题可能导致回到另一个阶段，反映了为出版准备稿件的现实世界的复杂性。
- en: This mutual recursion effectively captures the cyclic nature of book editing
    and formatting, ensuring that neither content quality nor presentation standards
    are compromised. It highlights the iterative process of refinement that manuscripts
    undergo, embodying the collaborative effort between content editors and formatting
    specialists to achieve a publication-ready book. Through this model, the publishing
    workflow is optimized for thoroughness and quality, ensuring that readers receive
    well-crafted and professionally presented books.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相互递归有效地捕捉了书籍编辑和格式化的循环性质，确保内容质量和展示标准都不会受损。它突出了稿件经历的迭代改进过程，体现了内容编辑和格式化专家之间的协作努力，以实现出版就绪的书籍。通过这个模型，出版工作流程被优化以实现彻底性和质量，确保读者收到精心制作且专业呈现的书籍。
- en: Memoization
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: Memoization is a technique to speed up recursive functions by caching the results
    of expensive function calls and reusing those results when the same inputs occur
    again. This can significantly reduce the computation time for functions that are
    called repeatedly with the same arguments, such as calculating viewership statistics
    for categories.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是一种通过缓存昂贵函数调用的结果并在相同的输入再次出现时重用这些结果来加速递归函数的技术。这可以显著减少重复使用相同参数调用的函数的计算时间，例如计算类别观看统计。
- en: 'Let’s explore how memoization can be applied to optimize a recursive function
    for calculating Fibonacci numbers—a common scenario that illustrates the power
    of memoization in recursive algorithms:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨如何将记忆化应用于优化计算斐波那契数的递归函数——这是一个常见的场景，它说明了记忆化在递归算法中的强大作用：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this implementation, the `FibonacciCalculator` class uses a dictionary to
    cache the results of Fibonacci calculations. When the `Calculate` method is called,
    before doing the calculations, it checks whether the result for the given `n`
    is already cached. If so, it returns the cached result immediately, avoiding further
    recursive calls. If not, it proceeds with the recursive calculation and then caches
    the result before returning it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，`FibonacciCalculator` 类使用字典来缓存斐波那契计算的成果。当调用 `Calculate` 方法时，在执行计算之前，它会检查给定
    `n` 的结果是否已经被缓存。如果是，则立即返回缓存的结果，避免进一步的递归调用。如果不是，它将进行递归计算，并在返回结果之前将其缓存。
- en: 'This memoized approach to calculating Fibonacci numbers is vastly more efficient
    than a simple recursive solution without memoization. Without caching, the time
    complexity of calculating the *n*th Fibonacci number recursively is exponential
    (specifically, `O(2^n)`) due to the repeated computation of the same values. In
    other words, each call to `Calculate(n)` results in two additional calls: `Calculate(n-1)`
    and `Calculate(n-2`), each of which branches out similarly. The only exceptions
    are the base cases where `n = 0` or `n = 1`. With memoization, the complexity
    is reduced to linear (`O(n)`), as each unique Fibonacci number up to `n` is calculated
    exactly once.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种计算斐波那契数的记忆化方法比没有记忆化的简单递归解决方案要高效得多。没有缓存的情况下，递归计算第 `n` 个斐波那契数的时间复杂度是指数级的（具体为
    `O(2^n)`），这是因为重复计算相同的值。换句话说，每次对 `Calculate(n)` 的调用都会导致两个额外的调用：`Calculate(n-1)`
    和 `Calculate(n-2)`，每个都类似地分支。唯一的例外是基例，当 `n = 0` 或 `n = 1` 时。有了记忆化，复杂度降低到线性（`O(n)`），因为每个独特的斐波那契数直到
    `n` 都只计算一次。
- en: To illustrate the impact of memoization on the efficiency of recursive function
    calls, let’s analyze the specific case of calculating Fibonacci numbers for `n
    = 13`, `n = 29`, and `n = 79`, comparing the number of function calls required
    with and without memoization.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明记忆化对递归函数调用效率的影响，让我们分析计算斐波那契数 `n = 13`、`n = 29` 和 `n = 79` 的具体案例，比较在有和没有记忆化时所需的函数调用次数。
- en: For `n = 13`, the total number of function calls would be `F(13)` + `F(12)`
    + `F(11)` + `...` + `F(1)` + `F(0)`, which adheres to the Fibonacci sequence itself,
    leading us to 753 function calls. However, if we use memoization, the number of
    function calls will be only 25.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `n = 13`，总的函数调用次数将是 `F(13)` + `F(12)` + `F(11)` + `...` + `F(1)` + `F(0)`，这遵循斐波那契数列本身，导致我们得到
    753 次调用。然而，如果我们使用记忆化，函数调用次数将只有 25。
- en: For `n = 29`, we must call our function 1,664,079 times. On the other hand,
    the memoized approach will require only 57 calls.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `n = 29`，我们必须调用我们的函数 1,664,079 次。另一方面，记忆化方法只需要 57 次调用。
- en: Lastly, for `n = 79`, the number of function calls grows astronomically, making
    it impractical to calculate the exact number here. It’s in the order of trillions.
    For the memoization solution, 157 calls will be enough.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 `n = 79`，函数调用的次数会呈天文数字般增长，使得在这里计算确切的数字变得不切实际。它的数量级是万亿级别的。对于记忆化解决方案，只需要
    157 次调用就足够了。
- en: This analysis demonstrates the power of memoization to enhance performance and
    its critical role in making recursive solutions viable for complex problems. By
    leveraging memoization, developers can use recursion without incurring extra computational
    costs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析展示了记忆化在提升性能方面的强大作用，以及在使递归解决方案适用于复杂问题中的关键作用。通过利用记忆化，开发者可以在不承担额外计算成本的情况下使用递归。
- en: To sum up, mutual recursion and memoization are powerful techniques that can
    make your recursive solutions more efficient and capable. Mutual recursion allows
    for an elegant alternation between related tasks, while memoization optimizes
    performance by avoiding redundant calculations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，相互递归和记忆化是强大的技术，可以使你的递归解决方案更高效和强大。相互递归允许在相关任务之间优雅地交替，而记忆化通过避免重复计算来优化性能。
- en: Comparison with iterative solutions
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与迭代解决方案的比较
- en: When managing video playlists or similar hierarchical data structures, both
    recursive and iterative approaches have their place. The choice between them often
    depends on readability and performance considerations. Let’s explore how these
    two approaches compare in the context of a video management system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理视频播放列表或类似层次数据结构时，递归和迭代方法都有其适用之处。选择它们通常取决于可读性和性能考虑。让我们探讨这两种方法在视频管理系统中的比较。
- en: Readability
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性
- en: 'Recursion naturally fits scenarios where the problem can be divided into smaller,
    similar problems. For instance, traversing a tree of video playlists and sub-playlists
    is intuitively understood with recursion:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 递归自然适合可以将问题分解为更小、相似问题的场景。例如，使用递归遍历视频播放列表和子播放列表是直观理解的：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This recursive function is clear and mirrors the hierarchical nature of playlists.
    It’s easy to read and understand, especially for those familiar with recursion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归函数清晰且反映了播放列表的层次结构。它易于阅读和理解，尤其是对于那些熟悉递归的人来说。
- en: 'Iterative solutions, using loops and data structures such as stacks or queues,
    can manage the same tasks but often require more setup. An iterative version of
    the playlist traversal might not be as intuitive:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代解决方案，使用循环和数据结构如栈或队列，可以管理相同的任务，但通常需要更多的设置。播放列表遍历的迭代版本可能不那么直观：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While effective, the iterative solution is more verbose and its logic is less
    direct compared to the recursive approach. Using a stack to mimic the call stack
    of recursion also adds complexity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有效，但迭代解决方案比递归方法更冗长，其逻辑不如递归方法直接。使用栈来模拟递归的调用栈也增加了复杂性。
- en: Performance
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The performance characteristics of recursive and iterative approaches can vary
    depending on the specific problem and implementation. Let’s examine the benchmark
    results for the video playlist that contains 10 levels of sub-playlists with 10
    of them on each level:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 递归和迭代方法的性能特征可能因具体问题和实现而异。让我们检查包含10级子播放列表的视频播放列表的基准结果，每级有10个子播放列表：
- en: '![](img/B21069_08_001.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21069_08_001.jpg)'
- en: 'These results provide interesting insights:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果提供了有趣的见解：
- en: The recursive method is approximately 14% faster, with a mean execution time
    of 299.2 ms compared to 348.9 ms for the iterative method.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归方法大约快14%，平均执行时间为299.2毫秒，而迭代方法的平均执行时间为348.9毫秒。
- en: The recursive approach shows slightly less variation in performance, with smaller
    error and standard deviation values.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归方法在性能上略有较少的变化，误差和标准差值较小。
- en: Contrary to common assumptions, the recursive method allocates less memory (876
    bytes) compared to the iterative method (2840 bytes), which is more than three
    times as much.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与常见的假设相反，递归方法分配的内存（876字节）比迭代方法（2840字节）少，后者多出三倍以上。
- en: 'These findings challenge the conventional wisdom that iterative solutions are
    always more efficient:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些发现挑战了传统观念，即迭代解决方案总是更有效：
- en: '**Speed**: The recursive approach outperforms the iterative one, possibly due
    to the compiler’s optimizations or the specific nature of the traversal task.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**: 递归方法优于迭代方法，可能是因为编译器的优化或遍历任务的特定性质。'
- en: '**Memory usage**: Surprisingly, the recursive method uses significantly less
    memory. This could be due to efficient tail-call optimization or other compiler
    optimizations for recursive calls.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用**: 意想不到的是，递归方法使用的内存显著更少。这可能是由于高效的尾调用优化或其他编译器对递归调用的优化。'
- en: '**Consistency**: The recursive method shows slightly more consistent performance
    across runs, as indicated by the lower standard deviation.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**: 递归方法在运行中的性能略更一致，这从较低的标准差中可以看出。'
- en: 'It’s important to note that these results are specific to this particular implementation
    and dataset. Factors that could influence the outcomes include:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些结果仅适用于这个特定的实现和数据集。可能影响结果的因素包括：
- en: The depth and breadth of the playlist structure
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放列表结构的深度和广度
- en: The specific operations performed during traversal
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历过程中执行的具体操作
- en: The compiler’s optimization capabilities
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器的优化能力
- en: The runtime environment
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时环境
- en: In conclusion, while traditional wisdom often favors iterative approaches for
    performance reasons, our benchmark demonstrates that recursive methods can be
    more efficient for certain hierarchical structures. This underscores the importance
    of empirical testing rather than relying solely on general principles. When choosing
    between recursion and iteration, consider not only code readability and problem
    structure but also conduct performance tests tailored to your specific use case.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，虽然传统智慧通常出于性能原因倾向于迭代方法，但我们的基准测试表明，对于某些层次结构，递归方法可能更有效。这强调了实证测试的重要性，而不是仅仅依赖一般原则。在递归和迭代之间进行选择时，不仅要考虑代码的可读性和问题结构，还要进行针对你特定用例的性能测试。
- en: Recursion in asynchronous programming
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程中的递归
- en: Asynchronous programming has become a cornerstone for developing responsive
    applications, especially when dealing with I/O-bound operations, such as network
    requests. When you combine recursion with asynchronous programming, you can handle
    complex tasks such as fetching and processing data from external APIs or managing
    video content across a network efficiently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程已成为开发响应式应用程序的基石，尤其是在处理I/O密集型操作，如网络请求时。当你将递归与异步编程结合使用时，你可以高效地处理诸如从外部API获取和处理数据或跨网络管理视频内容等复杂任务。
- en: Async recursion allows you to perform recursive operations without blocking
    the main thread, ensuring that your application remains responsive. For example,
    when fetching video data from an external API where videos are organized into
    categories that may contain subcategories, you can process each category and its
    subcategories recursively without freezing the UI.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 异步递归允许你在不阻塞主线程的情况下执行递归操作，确保你的应用程序保持响应。例如，当从外部API获取视频数据，其中视频被组织成可能包含子类别的类别时，你可以递归地处理每个类别及其子类别，而不会冻结UI。
- en: 'Here’s how you might write an asynchronous recursive function to process videos:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何编写一个异步递归函数来处理视频的示例：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, `ProcessVideosAsync` processes each subcategory by making recursive
    calls to itself, ensuring that all levels of the category hierarchy are covered.
    It then asynchronously processes each video in the current category. The use of
    `await` ensures that each operation is complete before moving to the next, maintaining
    the order of operations without blocking.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`ProcessVideosAsync`通过对自己进行递归调用处理每个子类别，确保覆盖了类别层次结构的所有级别。然后，它异步地处理当前类别中的每个视频。`await`的使用确保在移动到下一个操作之前，每个操作都是完整的，从而保持了操作顺序，而没有阻塞。
- en: Explaining asynchronous recursion under the hood
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入解释异步递归的工作原理
- en: To understand how asynchronous recursion works under the hood, let’s dive into
    the asynchronous programming model in .NET and explore the use of state machines
    and the interaction with `ThreadPool`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解异步递归在底层是如何工作的，让我们深入了解.NET中的异步编程模型，并探讨状态机的使用以及与`ThreadPool`的交互。
- en: In .NET, asynchronous methods are implemented using state machines. When an
    asynchronous method is called, the compiler generates a state machine that keeps
    track of the method’s execution state. Each `await` expression in the method marks
    a point where the method can be suspended, allowing other work to be performed
    while the awaited operation completes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，异步方法是通过状态机实现的。当调用异步方法时，编译器生成一个状态机来跟踪方法的执行状态。方法中的每个`await`表达式都标记了一个方法可以暂停的点，允许在等待的操作完成时执行其他工作。
- en: When an asynchronous recursive call is made, the state machine is created for
    each recursive invocation. The state machines are managed by the .NET runtime,
    which coordinates their execution and resumption.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行异步递归调用时，为每个递归调用创建一个状态机。状态机由.NET运行时管理，它协调它们的执行和恢复。
- en: 'Here’s a simplified representation of how the `ProcessVideosAsync` method’s
    state machine might look:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`ProcessVideosAsync`方法的状态机可能的一个简化表示：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this state machine representation, the `MoveNext` method encapsulates the
    logic of the asynchronous recursive function. It uses a `switch` statement to
    handle different states of the asynchronous operation. The `await` expressions
    are translated into asynchronous continuations using `TaskAwaiter` and `OnCompleted`
    callbacks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种状态机表示中，`MoveNext` 方法封装了异步递归函数的逻辑。它使用 `switch` 语句来处理异步操作的不同状态。`await` 表达式通过
    `TaskAwaiter` 和 `OnCompleted` 回调转换为异步延续。
- en: When an asynchronous recursive call is awaited, the state machine is suspended,
    and the control is returned to the caller. The .NET runtime then schedules the
    continuation of the state machine on a `ThreadPool` thread when the awaited operation
    completes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步递归调用被 `await` 时，状态机被挂起，控制权返回给调用者。当 `await` 操作完成时，.NET 运行时会在 `ThreadPool`
    线程上安排状态机的延续。
- en: It’s important to note that asynchronous recursive calls interact with `ThreadPool`
    differently compared to synchronous recursive calls. Instead of consuming stack
    space, asynchronous recursive calls are managed by the `ThreadPool`, which has
    a limited number of threads. If the number of asynchronous recursive calls exceeds
    the available `ThreadPool` threads, the `ThreadPool` may create additional threads
    or queue the work items until threads become available.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，与同步递归调用相比，异步递归调用与 `ThreadPool` 的交互方式不同。异步递归调用不会消耗栈空间，而是由 `ThreadPool`
    管理，`ThreadPool` 有有限的线程数。如果异步递归调用的数量超过了可用的 `ThreadPool` 线程数，`ThreadPool` 可能会创建额外的线程或将工作项排队，直到线程可用。
- en: 'To avoid overloading the `ThreadPool` and ensure efficient resource utilization,
    consider the following best practices when using asynchronous recursion:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免过载 `ThreadPool` 并确保资源利用效率，在使用异步递归时，请考虑以下最佳实践：
- en: '**Limit recursion depth**: Similar to synchronous recursion, it’s crucial to
    have a base case that terminates the recursion to prevent excessive recursive
    calls. Implement a maximum depth limit or use other conditions to control the
    recursion depth.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制递归深度**：与同步递归类似，拥有一个终止递归的基本情况至关重要，以防止过多的递归调用。实现最大深度限制或使用其他条件来控制递归深度。'
- en: '`SemaphoreSlim` or TPL Dataflow to avoid overwhelming the system.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SemaphoreSlim` 或 TPL Dataflow 来避免系统过载。
- en: '`CancellationToken`. This allows you to gracefully cancel the recursive operation
    if needed, preventing unnecessary work and resource consumption.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CancellationToken`。这允许你在需要时优雅地取消递归操作，防止不必要的劳动和资源消耗。'
- en: '`try`-`catch` blocks to handle exceptions and consider using libraries such
    as Polly for retry and circuit-breaker policies.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `try`-`catch` 块来处理异常，并考虑使用如 Polly 这样的库来实现重试和断路器策略。
- en: By understanding how asynchronous recursion works under the hood and following
    best practices, you can effectively leverage the power of asynchronous programming
    in combination with recursion to build responsive and efficient applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解异步递归在底层的工作原理并遵循最佳实践，你可以有效地利用异步编程与递归结合的力量，构建响应迅速且高效的程序。
- en: Asynchronous recursion is a powerful technique that allows you to perform recursive
    operations without blocking the main thread, enabling your application to remain
    responsive even when dealing with complex hierarchical data structures or remote
    API calls. By combining the benefits of asynchronous programming with the elegance
    of recursion, you can write more efficient and maintainable code for a wide range
    of scenarios.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 异步递归是一种强大的技术，它允许你在不阻塞主线程的情况下执行递归操作，即使在处理复杂的分层数据结构或远程 API 调用时，也能使你的应用程序保持响应。通过结合异步编程的优势和递归的优雅性，你可以为各种场景编写更高效、更易于维护的代码。
- en: Synchronous versus asynchronous recursion
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步与异步递归
- en: When it comes to implementing recursive algorithms, we have the choice between
    using synchronous or asynchronous approaches. Each approach has its own characteristics,
    benefits, and trade-offs. Let’s compare synchronous and asynchronous recursive
    code using an example of traversing a filesystem hierarchy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到实现递归算法时，我们可以在使用同步或异步方法之间进行选择。每种方法都有其自身的特点、优势和权衡。让我们通过遍历文件系统层次结构的示例来比较同步和异步递归代码。
- en: 'Here is a synchronous recursive example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个同步递归的例子：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, the `TraverseDirectory` function takes a directory path as
    input and recursively traverses its subdirectories. For each file encountered,
    it calls the `ProcessFile` function to perform some operation on the file. The
    function blocks until all files and subdirectories have been processed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`TraverseDirectory` 函数接收一个目录路径作为输入，并递归遍历其子目录。对于遇到的每个文件，它调用 `ProcessFile`
    函数对文件执行某些操作。该函数会阻塞，直到所有文件和子目录都被处理。
- en: 'Now, let’s consider an asynchronous version of the same example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑相同示例的异步版本：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the asynchronous version, the `TraverseDirectoryAsync` function uses the
    `async` and `await` keywords to enable asynchronous execution. It uses `Task.Run`
    to execute the filesystem operations (`Directory.GetFiles` and `Directory.GetDirectories`)
    on a separate thread, allowing the calling thread to continue execution without
    blocking.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步版本中，`TraverseDirectoryAsync` 函数使用 `async` 和 `await` 关键字来启用异步执行。它使用 `Task.Run`
    在单独的线程上执行文件系统操作（`Directory.GetFiles` 和 `Directory.GetDirectories`），允许调用线程继续执行而不会阻塞。
- en: The `ProcessFileAsync` function is assumed to perform some asynchronous operation
    on each file, such as reading its contents or making an API call. The `await`
    keyword is used to wait for the completion of each asynchronous operation without
    blocking the calling thread.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `ProcessFileAsync` 函数对每个文件执行某些异步操作，例如读取其内容或进行 API 调用。使用 `await` 关键字等待每个异步操作的完成，而不会阻塞调用线程。
- en: 'Let’s now look at a comparison and the benefits of each:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来比较一下每种方法的优缺点：
- en: '**Responsiveness**: The main advantage of asynchronous recursion is that it
    allows the calling thread to remain responsive while the recursive operations
    are being performed. In the synchronous example, the thread is blocked until all
    files and subdirectories have been processed, which can lead to a frozen UI or
    unresponsive application. Asynchronous recursion, on the other hand, allows the
    thread to continue executing other tasks while waiting for the asynchronous operations
    to complete.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：异步递归的主要优点是它允许在递归操作执行期间调用线程保持响应。在同步示例中，线程会阻塞，直到所有文件和子目录都被处理，这可能导致 UI
    冻结或应用程序无响应。另一方面，异步递归允许线程在等待异步操作完成的同时继续执行其他任务。'
- en: '**Performance**: Asynchronous recursion can improve performance by allowing
    multiple operations to be executed concurrently. In the asynchronous example,
    the filesystem operations and file processing can happen in parallel, potentially
    reducing the overall execution time. However, the actual performance gains depend
    on the nature of the operations being performed and the available system resources.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：异步递归可以通过允许多个操作并发执行来提高性能。在异步示例中，文件系统操作和文件处理可以并行进行，可能减少总体执行时间。然而，实际的性能提升取决于所执行操作的性质和可用的系统资源。'
- en: '**Resource utilization**: Asynchronous recursion can help optimize resource
    utilization by allowing the system to process other tasks while waiting for I/O-bound
    operations to complete. In the synchronous example, the thread is blocked and
    cannot be used for other purposes until the recursive operation finishes. Asynchronous
    recursion enables better utilization of system resources by allowing the thread
    to be freed up for other tasks.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源利用**：异步递归可以通过在等待 I/O 密集型操作完成的同时允许系统处理其他任务来帮助优化资源利用。在同步示例中，线程会阻塞，无法用于其他目的，直到递归操作完成。异步递归通过允许线程为其他任务释放出来，从而更好地利用系统资源。'
- en: '`async`, `await`, and `Task` adds an extra layer of abstraction and requires
    an understanding of asynchronous programming concepts. Error handling and exception
    propagation also become more involved in asynchronous code.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`、`await` 和 `Task` 添加了一个额外的抽象层，并需要理解异步编程概念。错误处理和异常传播在异步代码中也变得更加复杂。'
- en: Scenarios for asynchronous recursion
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步递归的场景
- en: 'Asynchronous recursion is particularly beneficial in scenarios where the recursive
    operations involve I/O-bound tasks or long-running CPU-bound operations. Some
    examples are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 异步递归在涉及 I/O 密集型任务或长时间运行的 CPU 密集型操作的场景中特别有益。以下是一些示例：
- en: '**Filesystem operations**: Traversing a large filesystem hierarchy and performing
    I/O operations on files, such as reading or writing data, can benefit from asynchronous
    recursion. It allows the application to remain responsive while the file operations
    are being performed asynchronously.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统操作**：遍历大型文件系统层次结构并在文件上执行I/O操作（如读取或写入数据）可以从异步递归中受益。它允许应用程序在异步执行文件操作时保持响应。'
- en: '**Network operations**: Recursive algorithms that involve making network requests
    or API calls can leverage asynchronous recursion to prevent blocking the calling
    thread. Asynchronous recursion enables concurrent execution of network operations,
    improving overall performance.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络操作**：涉及发起网络请求或API调用的递归算法可以利用异步递归来防止阻塞调用线程。异步递归允许并发执行网络操作，从而提高整体性能。'
- en: '**Database operations**: Recursive queries or operations that involve interacting
    with a database can be implemented using asynchronous recursion. It allows the
    application to continue executing other tasks while waiting for the database operations
    to complete.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库操作**：递归查询或涉及与数据库交互的操作可以使用异步递归实现。它允许应用程序在等待数据库操作完成的同时继续执行其他任务。'
- en: '**Complex calculations**: Recursive algorithms that perform complex calculations
    or computations can benefit from asynchronous recursion, especially if the calculations
    can be parallelized. Asynchronous recursion can help distribute the workload across
    multiple threads or tasks, potentially improving the overall execution time.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂计算**：执行复杂计算或计算的递归算法可以从异步递归中受益，特别是如果计算可以并行化。异步递归可以帮助将工作负载分配到多个线程或任务，从而可能提高整体执行时间。'
- en: It’s important to note that not all recursive algorithms are suitable for asynchronous
    execution. Asynchronous recursion is most effective when the recursive operations
    involve I/O-bound tasks or can be parallelized efficiently. In cases where the
    recursive operations are primarily CPU-bound and cannot be parallelized, synchronous
    recursion may be more appropriate.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，并非所有递归算法都适合异步执行。异步递归在涉及I/O密集型任务或可以高效并行化的递归操作时最为有效。在递归操作主要是CPU密集型且无法并行化的情况下，同步递归可能更合适。
- en: Understanding the differences between synchronous and asynchronous recursion
    can help you write more performance code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 理解同步递归和异步递归之间的区别可以帮助你编写更高效的代码。
- en: Exercises
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: To help Steve apply recursion concepts to his tower defense game, Julia prepared
    three coding challenges. Let’s see if you can help Steve solve them!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助Steve将递归概念应用到他的塔防游戏中，Julia准备了三个编程挑战。让我们看看你是否能帮助Steve解决这些问题！
- en: Exercise 1
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1
- en: 'Steve’s game has a hierarchical structure of enemy waves, where each wave can
    contain both individual enemies and sub-waves. Implement a recursive function,
    `CountAllEnemies`, that navigates through a `Wave` object (which can contain both
    `Enemy` objects and `Wave` objects) and returns the total count of enemies found
    within that wave, including all its sub-waves:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Steve的游戏具有敌人波的层次结构，其中每个波可以包含单个敌人和子波。实现一个递归函数`CountAllEnemies`，该函数遍历一个`Wave`对象（可以包含`Enemy`对象和`Wave`对象），并返回该波及其所有子波中找到的敌人总数：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Test your method with a `Wave` containing a mix of `Enemy` objects and `Wave`
    objects to ensure that it accurately counts all enemies, including those in nested
    sub-waves.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包含`Enemy`对象和`Wave`对象混合的`Wave`来测试你的方法，以确保它准确计算所有敌人，包括嵌套子波中的敌人。
- en: Exercise 2
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2
- en: Using the same wave structure from Task 1, Steve wants to generate increasingly
    complex waves as the game progresses. Implement a recursive function, `GenerateWave`,
    that creates a `Wave` object with a nested structure of enemies and sub-waves
    based on the current level number.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与任务1相同的波形结构，Steve希望在游戏进行过程中生成越来越复杂的波形。实现一个递归函数`GenerateWave`，该函数根据当前关卡编号创建一个具有嵌套结构（敌人和小波）的`Wave`对象。
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function should create more complex wave structures as the level number
    increases. Consider the following guidelines:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数应随着关卡编号的增加创建更复杂的波形结构。请考虑以下指南：
- en: For every 5 levels, add a sub-wave.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每过5个关卡，增加一个子波。
- en: The number of enemies in each wave or sub-wave should increase with the level
    number.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个波或子波中的敌人数量应随着关卡编号的增加而增加。
- en: Introduce more varied enemy types as the levels progress.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着关卡的推进，引入更多样化的敌人类型。
- en: Every 10th level should include a boss enemy.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每10个关卡应包括一个Boss敌人。
- en: Test your method with different level numbers to ensure it generates appropriate
    wave structures.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的级别数字测试你的方法，以确保它生成适当的波结构。
- en: 'Example usage:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用法：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Exercise 3
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: Updating the stats of enemies (such as health, speed, or damage) might need
    to be done asynchronously, especially if it involves fetching or syncing information
    from a game server. Implement an `UpdateAllEnemyStatsAsync` method that recursively
    goes through a hierarchy of waves (containing both enemies and sub-waves) and
    updates stats for each enemy asynchronously.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 更新敌人的统计数据（如健康、速度或伤害）可能需要异步完成，特别是如果它涉及到从游戏服务器获取或同步信息。实现一个 `UpdateAllEnemyStatsAsync`
    方法，该方法递归遍历波层次结构（包含敌人和子波）并异步更新每个敌人的统计数据。
- en: 'For the sake of this exercise, simulate the asynchronous update operation with
    the `UpdateStatsAsync(Enemy enemy)` method, which returns `Task`. Your recursive
    function should await the completion of stat updates for each enemy before moving
    to the next:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这个练习，使用 `UpdateStatsAsync(Enemy enemy)` 方法模拟异步更新操作，该方法返回 `Task`。你的递归函数应在移动到下一个敌人之前等待每个敌人统计数据更新的完成：
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By tackling these tasks, you’ll enhance your ability to think recursively, manage
    complex data structures, and leverage asynchronous programming techniques effectively.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过处理这些任务，你将提高你的递归思维能力，管理复杂数据结构，并有效地利用异步编程技术。
- en: Solutions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Now, let’s delve into the solutions for these exercises. As always, these solutions
    represent one of the ways in which the problem can be solved. They are provided
    just to help you verify your work and to offer insights into different ways of
    approaching recursive problems.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨这些练习的解决方案。像往常一样，这些解决方案代表了问题可以解决的一种方式。它们提供只是为了帮助你验证你的工作，并提供对递归问题不同方法的见解。
- en: Exercise 1
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This solution demonstrates a basic application of recursion to navigate through
    nested wave structures. It incrementally counts enemies and dives deeper into
    sub-waves when encountered.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案展示了递归在导航嵌套波结构中的基本应用。它逐步计算敌人数量，并在遇到子波时进一步深入。
- en: Exercise 2
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To use and test this function, Steve could implement a helper method to print
    the wave structure:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用和测试这个函数，Steve 可以实现一个辅助方法来打印波结构：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This solution demonstrates how recursion can be used to generate complex game
    structures. As the level number increases, the waves become more challenging with
    more enemies, different types of enemies, and nested sub-waves. The recursive
    nature of the function allows for easy scalability and the creation of intricate
    wave patterns as the game progresses.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案展示了如何使用递归生成复杂的游戏结构。随着级别数字的增加，波变得更加具有挑战性，有更多的敌人、不同类型的敌人和嵌套的子波。函数的递归性质允许在游戏进展过程中轻松扩展并创建复杂的波模式。
- en: Exercise 3
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This `async` recursive solution iterates through each content item of a wave,
    updating stats for enemies directly and diving deeper into sub-waves with recursive
    calls. The use of `await` ensures that updates are processed sequentially within
    each wave and sub-wave, maintaining order and ensuring completeness before proceeding.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `async` 递归解决方案遍历波中的每个内容项，直接更新敌人的统计数据，并通过递归调用深入子波。使用 `await` 确保在每个波和子波内顺序处理更新，保持顺序并确保在继续之前完成完整性。
- en: By completing these exercises, you’ve practiced applying recursion to solve
    different problems. Whether counting items in nested structures, determining the
    depth of hierarchies, or performing batch operations asynchronously, recursion
    is a powerful tool in your software development toolkit.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这些练习，你已经练习了将递归应用于解决不同问题。无论是计算嵌套结构中的项目数量，确定层次结构的深度，还是异步执行批量操作，递归都是你的软件开发工具包中的一个强大工具。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Throughout this chapter on recursion, we’ve explored how it allows us to solve
    complex problems cleanly and elegantly. By breaking down tasks into smaller, manageable
    parts, recursion provides a direct approach to tackling problems that are naturally
    hierarchical or repetitive, such as organizing books into genres and sub-genres
    or processing book metadata.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章关于递归的整个过程中，我们探讨了递归如何让我们以干净和优雅的方式解决复杂问题。通过将任务分解成更小、更易于管理的部分，递归提供了一种直接的方法来解决自然具有层次结构或重复性的问题，例如将书籍组织成流派和子流派或处理书籍元数据。
- en: We started by understanding the essence of recursion, distinguishing between
    the base case and the recursive case, and highlighting the importance of always
    having a clear base case to prevent infinite loops. Then, through practical examples,
    we demonstrated how recursion simplifies code and enhances readability, especially
    when dealing with nested or hierarchical data structures.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先理解了递归的本质，区分了基本情况与递归情况，并强调了始终要有清晰的基例以防止无限循环的重要性。然后，通过实际示例，我们展示了递归如何简化代码并提高可读性，尤其是在处理嵌套或分层数据结构时。
- en: Leveraging C# features such as local functions and pattern matching, we explored
    how the language’s capabilities can enhance our recursive functions, making them
    more readable and maintainable. Advanced recursive patterns such as mutual recursion
    and memoization were also introduced, showing how recursion can be extended to
    handle more complex scenarios efficiently.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 利用C#的本地函数和模式匹配等特性，我们探讨了语言的能力如何增强我们的递归函数，使它们更易于阅读和维护。还介绍了高级递归模式，如相互递归和记忆化，展示了递归如何高效地扩展以处理更复杂的场景。
- en: In conclusion, this chapter aimed to equip you with a deeper understanding of
    recursion, its principles, and its practical applications in real-world scenarios
    such as those encountered in a book publishing system. As you move forward, you
    will learn about currying and partial application and their application in real-world
    scenarios.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，本章旨在帮助你更深入地理解递归、其原理以及在现实世界场景中的实际应用，例如在图书出版系统中遇到的情况。随着你继续前进，你将学习到柯里化和部分应用以及它们在现实世界场景中的应用。
