- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Roslyn Compiler Extensions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Roslyn编译器扩展
- en: Roslyn compiler extensions offer a powerful way to modify and extend the behavior
    of the C# compiler. With the Roslyn compiler, developers can write code that analyzes
    and modifies C# code at compile-time, opening new possibilities for code generation,
    code transformation, and optimization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn编译器扩展提供了一种强大的方式来修改和扩展C#编译器的行为。使用Roslyn编译器，开发者可以编写在编译时分析和修改C#代码的代码，为代码生成、代码转换和优化开辟了新的可能性。
- en: In this chapter, we will explore the technical setup of a Roslyn compiler extension
    project. The chapter itself is not focused on metaprogramming, but rather, on
    the technical setup for the two following chapters. We’ll delve into the process
    of packaging a Roslyn compiler extension for reuse. We’ll explore the different
    packaging options available, such as NuGet packages, and discuss best practices
    for making your extension easy to consume by other developers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Roslyn编译器扩展项目的技术设置。本章本身并不专注于元编程，而是关注为接下来的两章提供的技术设置。我们将深入研究打包Roslyn编译器扩展以供重用的过程。我们将探讨不同的打包选项，例如NuGet包，并讨论使您的扩展易于其他开发者使用的最佳实践。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: How to set up a project and its moving parts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置项目和其组成部分
- en: How to package your extension for reuse
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何打包您的扩展以供重用
- en: By the end of this chapter, you will have a solid understanding of how to set
    up a Roslyn compiler extension project and package it for reuse. You’ll be equipped
    with the knowledge and tools needed to start building powerful and flexible extensions
    that can significantly enhance the functionality of the C# compiler.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将牢固地理解如何设置Roslyn编译器扩展项目并将其打包以供重用。您将具备构建强大且灵活的扩展所需的知识和工具，这些扩展可以显著增强C#编译器的功能。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to the chapter can be found on GitHub, ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter15](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter15))
    and it builds on top of the **Fundamentals** code that is found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该章节的特定源代码可以在GitHub上找到，([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter15](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter15))，并且它建立在GitHub上可找到的**基础**代码之上
    ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals))。
- en: How to set up a project and its moving parts
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何设置项目和其组成部分
- en: The C# compiler, powered by the Roslyn framework ([https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/)),
    provides a mechanism to load and use custom extensions in the form of analyzer
    and code fix providers. These extensions can be packaged as NuGet packages or
    included as project references, and they are loaded into the compilation process
    to analyze or modify the source code being compiled.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由Roslyn框架([https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/))驱动的C#编译器提供了一个机制来加载和使用自定义扩展，这些扩展以分析器和代码修复提供者的形式存在。这些扩展可以打包成NuGet包或作为项目引用包含在内，并且它们被加载到编译过程中以分析或修改正在编译的源代码。
- en: When the C# compiler encounters a project that includes a reference to a Roslyn
    extension, it uses .NET’s **AssemblyLoadContext** to load the extension’s assembly
    into the compilation process. This allows the extension’s code to be executed
    during the compilation process and participate in the analysis and transformation
    of the source code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当C#编译器遇到包含对Roslyn扩展引用的项目时，它使用.NET的**AssemblyLoadContext**将扩展的程序集加载到编译过程中。这允许扩展的代码在编译过程中执行，并参与源代码的分析和转换。
- en: The Roslyn extensions are loaded into the compiler as analyzers, or source generators.
    Analyzers are responsible for examining the source code and reporting diagnostics,
    which are warnings, errors, or suggestions about potential issues in the code.
    Code fix providers provide suggestions or automated fixes to resolve the reported
    issues and are used by your code editor. Source generators, on the other hand,
    generate additional source code during compilation based on specific rules or
    templates.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn扩展作为分析器或源生成器加载到编译器中。分析器负责检查源代码并报告诊断信息，这些诊断信息是关于代码中潜在问题的警告、错误或建议。代码修复提供者提供建议或自动修复以解决报告的问题，并用于你的代码编辑器。另一方面，源生成器根据特定的规则或模板在编译期间生成额外的源代码。
- en: The C# compiler scans the loaded assemblies for types that implement interfaces
    defined by the Roslyn framework for different extension points. It then creates
    instances of these types and invokes their methods to perform the analysis and
    transformation of the source code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C#编译器扫描加载的程序集，寻找实现由Roslyn框架定义的不同扩展点的接口的类型。然后它创建这些类型的实例并调用它们的方法来执行源代码的分析和转换。
- en: The loading of Roslyn extensions occurs dynamically at compile-time, allowing
    for flexibility in adding or removing extensions without modifying the compiler
    itself, a great example of how the open / closed principle can be applied.. This
    dynamic loading also enables the reuse of extensions across different projects
    and solutions, as they can be packaged and distributed as NuGet packages or shared
    as project references.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn扩展在编译时动态加载，允许在不修改编译器本身的情况下灵活地添加或删除扩展，这是开放/封闭原则应用的绝佳例子。这种动态加载还使得扩展可以在不同的项目和解决方案之间重用，因为它们可以作为NuGet包打包和分发，或者作为项目引用共享。
- en: What can they do?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 他们能做什么？
- en: Roslyn compiler extensions provide a robust and flexible platform for metaprogramming
    in C#. With Roslyn, you have full access to the syntax tree and semantic model
    of the code being compiled, giving you deep insights into the structure, syntax,
    and semantics of the code. This allows you to perform sophisticated code analysis,
    generate code based on patterns or conventions, and apply transformations to the
    code to achieve various goals.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn编译器扩展为C#中的元编程提供了一个强大且灵活的平台。使用Roslyn，你可以完全访问正在编译的代码的语法树和语义模型，这让你对代码的结构、语法和语义有了深入的了解。这允许你执行复杂的代码分析，根据模式或约定生成代码，并对代码应用转换以实现各种目标。
- en: 'Here are some ways in which Roslyn compiler extensions can be powerful tools
    for metaprogramming:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些Roslyn编译器扩展如何成为元编程强大工具的方式：
- en: '**Code generation**: Roslyn compiler extensions allow you to generate code
    during compilation. This can be used to automatically generate repetitive code
    patterns, such as data access layers, serialization code, or boilerplate code
    for repetitive tasks. You can also generate code based on conventions, configuration,
    or metadata, making it easy to create reusable and customizable code-generation
    tools.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码生成**：Roslyn编译器扩展允许你在编译过程中生成代码。这可以用于自动生成重复的代码模式，例如数据访问层、序列化代码或重复任务的样板代码。你还可以根据约定、配置或元数据生成代码，这使得创建可重用和可定制的代码生成工具变得容易。'
- en: '**Code analysis**: Roslyn compiler extensions enable you to perform custom
    code analysis during compilation. This can help you catch potential issues, enforce
    coding standards, and provide automated code review feedback. For example, you
    can use a Roslyn extension to identify and flag code smells, security vulnerabilities,
    or other code quality issues early in the development process, helping you maintain
    a high level of code quality in your projects.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码分析**：Roslyn 编译器扩展允许你在编译过程中执行自定义代码分析。这可以帮助你捕捉潜在问题，强制执行编码标准，并提供自动化的代码审查反馈。例如，你可以使用
    Roslyn 扩展在开发早期阶段识别并标记代码异味、安全漏洞或其他代码质量问题，帮助你保持项目中的代码质量处于高水平。'
- en: '**Domain-Specific Language** (**DSL**): Roslyn compiler extensions can be used
    to create DSLs that provide specialized syntax and semantics tailored to specific
    problem domains. This allows you to define your own DSL and use it in your projects
    to improve expressiveness and maintainability. With a Roslyn extension, you can
    create custom syntax, create custom semantic rules, and enforce domain-specific
    conventions, making it easier to work with complex domain-specific concepts.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域特定语言**（**DSL**）：Roslyn 编译器扩展可用于创建针对特定问题域提供专用语法和语义的 DSL。这允许您定义自己的 DSL 并在项目中使用它来提高可表达性和可维护性。使用
    Roslyn 扩展，您可以创建自定义语法，创建自定义语义规则，并强制执行领域特定约定，使处理复杂领域特定概念变得更加容易。'
- en: '**Tooling and productivity**: Roslyn compiler extensions can be used to create
    custom tools and productivity features for development environments such as Visual
    Studio or VSCode. For example, you can create code refactoring tools, code completion
    providers, or diagnostics and quick fixes to streamline development workflows
    and catch common mistakes. With a Roslyn extension, you can create tailored tooling
    that fits your team’s specific needs and development practices, enhancing productivity
    and code quality.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具和生产力**：Roslyn 编译器扩展可用于为 Visual Studio 或 VSCode 等开发环境创建自定义工具和生产力功能。例如，您可以创建代码重构工具、代码补全提供者或诊断和快速修复，以简化开发工作流程并捕捉常见错误。使用
    Roslyn 扩展，您可以创建符合团队特定需求和开发实践的定制工具，从而提高生产力和代码质量。'
- en: '**Experimentation and innovation**: Roslyn compiler extensions provide a platform
    for experimentation and innovation in the field of programming languages and compilers.
    You can use a Roslyn extension to prototype new language features, experiment
    with different programming paradigms, or implement novel programming techniques.
    This allows you to push the boundaries of what’s possible with C# and explore
    new ideas in the field of software development.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实验和创新**：Roslyn 编译器扩展为编程语言和编译器领域的实验和创新提供了一个平台。您可以使用 Roslyn 扩展来原型设计新的语言功能，尝试不同的编程范式，或实现新颖的编程技术。这允许您推动
    C# 的可能性边界，并在软件开发领域探索新想法。'
- en: Roslyn compiler extensions are a valuable tool in the toolbox of any C# developer
    interested in metaprogramming and pushing the boundaries of what’s possible with
    C#.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn 编译器扩展是任何对元编程和推动 C# 可能性边界感兴趣的 C# 开发者的工具箱中的宝贵工具。
- en: Setting it up
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: In Visual Studio and other IDEs, you have project templates that allow you to
    create a Roslyn compiler extension easily. An extension is nothing more than a
    class library with the correct package references, depending on what type of extension
    you are creating.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 和其他 IDE 中，您有项目模板，可以轻松创建一个 Roslyn 编译器扩展。扩展实际上只是一个具有正确包引用的类库，具体取决于您创建的扩展类型。
- en: Since we’re not targeting a specific IDE, we’ll be doing this from scratch with
    the .NET CLI and configuring the different files manually.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不针对特定的 IDE，我们将从头开始使用 .NET CLI 并手动配置不同的文件。
- en: The first thing we’ll need is a project folder. Since we’re going to be reusing
    the extension project for the following chapters, let’s create a folder called
    **Roslyn.Extensions**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的是一个项目文件夹。由于我们将重用扩展项目来编写后续章节，让我们创建一个名为 **Roslyn.Extensions** 的文件夹。
- en: 'Within the **Roslyn.Extensions** folder, run the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Roslyn.Extensions** 文件夹中，运行以下命令：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should now get two files called **Roslyn.Extensions.csproj** and **Class1.cs**.
    Delete the **Class1.cs** file, as you won’t be needing it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该得到两个名为 **Roslyn.Extensions.csproj** 和 **Class1.cs** 的文件。删除 **Class1.cs**
    文件，因为您将不需要它。
- en: 'Open the **Roslyn.Extensions.csproj** file in your editor. It should look something
    like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开 **Roslyn.Extensions.csproj** 文件。它应该看起来像以下这样：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You need to change this up a little bit for it to work with the compiler:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要稍作修改才能使其与编译器一起工作：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The change of **TargetFramework** is necessary for it to work. The C# compiler
    won’t be able to load it otherwise. However, you might still want to write your
    extension using the latest C# edition, so you set **LangVersion** to reflect the
    version of C# you want. You keep **ImplicitUsings** and **Nullable** if that is
    desirable. A project containing analyzers or source generators needs also to set
    **EnforceExtendedAnalyzerRules** to **true**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**TargetFramework** 的更改对于其正常工作是必要的。否则，C# 编译器将无法加载它。然而，你可能仍然希望使用最新的 C# 版本来编写你的扩展，因此你需要将
    **LangVersion** 设置为反映你想要的 C# 版本。如果你希望保留 **ImplicitUsings** 和 **Nullable**，则可以这样做。包含分析器或源生成器的项目还需要将
    **EnforceExtendedAnalyzerRules** 设置为 **true**。'
- en: For developing analyzers or source code generators, we’re going to have to add
    a couple of NuGet package references. As mentioned earlier, the goal of this chapter
    is to set up a common package for the chapters following this one, so we’ll be
    including what we want for those and a little bit more.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发分析器或源代码生成器，我们可能需要添加几个 NuGet 包引用。如前所述，本章的目标是为随后的章节设置一个通用的包，因此我们将包括我们想要的那些，以及一些额外的内容。
- en: 'Within the **<Project>** tag of the **Roslyn.Extensions.csproj** file, after
    the initial **<PropertyGroup>** add the following **<****ItemGroup>** block:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Roslyn.Extensions.csproj** 文件的 **<Project>** 标签内，在初始 **<PropertyGroup>**
    之后添加以下 **<ItemGroup>** 块：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first three packages are for the development of analyzers and source code
    generators. While the next two packages are analyzers, we want to be used to making
    sure our code adheres to standards.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个包用于分析器和源代码生成器的开发。而接下来的两个包是分析器，我们希望确保我们的代码遵循标准。
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **PrivateAssets** attribute used in the packages is for dependencies for
    the project they’re added to, and anyone referencing this will not inherit these
    dependencies directly. This is important for when we package this project as a
    NuGet package.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在包中使用的 **PrivateAssets** 属性用于它们所添加的项目中的依赖项，并且引用此属性的人将无法直接继承这些依赖项。这对于我们将此项目打包为
    NuGet 包时非常重要。
- en: 'If you want all the package references to be private to this package, you can
    do a neat little MSBuild trick by adding the following **ItemGroup** code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望所有包引用都仅限于这个包，你可以通过添加以下 **ItemGroup** 代码来执行一个巧妙的小 MSBuild 技巧：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By doing that, you don’t have to have the **PrivateAssets="All"** attribute
    for all your references.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你不需要为所有引用设置 **PrivateAssets="All"** 属性。
- en: 'Depending on the version of your .NET installation, the version numbers of
    referenced packages might be different. You can read more about which version
    is right for you here: [https://github.com/dotnet/roslyn/blob/main/docs/wiki/NuGet-packages.md](https://github.com/dotnet/roslyn/blob/main/docs/wiki/NuGet-packages.md).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的 .NET 安装版本，引用包的版本号可能会有所不同。你可以在此处了解更多关于哪个版本适合你的信息：[https://github.com/dotnet/roslyn/blob/main/docs/wiki/NuGet-packages.md](https://github.com/dotnet/roslyn/blob/main/docs/wiki/NuGet-packages.md)。
- en: Adding common rules
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加通用规则
- en: One of the great things about how the .NET compiler and the underlying MSBuild
    engine that handles all the building works is that you can have a project with
    all your rules for how you want things. Every project that references it will
    then inherit this.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 编译器和处理所有构建工作的底层 MSBuild 引擎的一个优点是，你可以有一个包含你想要的所有规则的项目。然后，引用它的每个项目都将继承这些规则。
- en: EditorConfig ([https://editorconfig.org](https://editorconfig.org)) is one of
    these items that can be reused among projects. Most IDEs and code editors out
    there honor the configuration of EditorConfig, which is great, because you can
    have a team using all kinds of editors, and they all adhere to the same settings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: EditorConfig ([https://editorconfig.org](https://editorconfig.org)) 是这些可以在项目间重复使用的项目之一。大多数
    IDE 和代码编辑器都尊重 EditorConfig 的配置，这很好，因为你可以有一个团队使用各种编辑器，并且他们都会遵循相同的设置。
- en: At the root of a repository, you can place a file called **.editorconfig**,
    which contains the common setup of rules that apply to every file within your
    project. The rules can be anything from formatting, tabs versus spaces, indentation
    levels, and specific rules picked up by compilers such as the C# compiler.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库的根目录下，你可以放置一个名为 **.editorconfig** 的文件，该文件包含适用于项目内每个文件的通用规则设置。规则可以是格式化、制表符与空格、缩进级别，以及由编译器（如
    C# 编译器）拾取的特定规则。
- en: This is great to get consistency in your codebase, avoid potential problems,
    and increase the maintainability of the source code. With .NET, we can go one
    further by packaging it in a project and making it so that every project that
    references it will get these rules. The benefit of this is that you can then reuse
    it outside the realms of your repository, which we’ll come back to a little bit
    later in this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于确保代码库的一致性、避免潜在问题以及提高源代码的可维护性非常有用。在.NET中，我们可以更进一步，通过将其打包到项目中，并确保所有引用该项目的项目都将获得这些规则。这种做法的好处是，您可以在仓库之外重用这些规则，我们将在本章稍后讨论这一点。
- en: 'Let’s create a file called **.globalconfig** in the **Roslyn.Extensions** folder.
    Add the following code to it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在**Roslyn.Extensions**文件夹中创建一个名为**.globalconfig**的文件。向其中添加以下代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This configuration sets **is_global** to **true** to indicate it should be a
    global settings file. It then goes on to specify how the end of the line is, the
    indentation style, and size, and then the charset used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将**is_global**设置为**true**，以指示它应该是一个全局设置文件。然后继续说明行尾格式、缩进样式和大小，以及使用的字符集。
- en: 'You can then go on and specify different rules specific to .NET. There are
    quite a few settings and rules you can configure, and I recommend reading more
    [about it all here: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options)-style-rule-options.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以继续指定针对.NET的特定规则。有许多设置和规则可以进行配置，我建议您在这里了解更多信息：[https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options)。
- en: Important note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the GitHub repository for this book, you’ll find a more complete **.globalconfig**
    file with a lot of .NET and C#-specific rules specified. Be aware that the rules
    put in place are a reflection of how I personally like the code to be.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的GitHub仓库中，您将找到一个更完整的**.globalconfig**文件，其中指定了许多.NET和C#特定的规则。请注意，这些规则反映了我个人喜欢代码的方式。
- en: 'Since you added a dependency to **StyleCop**, we can also configure global
    options for it. Add a file called **stylecop.json** in the **Roslyn.Extensions**
    folder and add the following code to it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您添加了对**StyleCop**的依赖，我们还可以为其配置全局选项。在**Roslyn.Extensions**文件夹中添加一个名为**stylecop.json**的文件，并向其中添加以下代码：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, it duplicates the indentation style, which is recommended.
    It then goes on to specify specific rules for how you want the code to look. In
    this case, it specifies that the **using** directives should be sorted with those
    prefixed with **System** first. Then, it says that the using directives should
    be outside the namespace blocks and then omit any blank lines between using groups.
    These and more option[s can be found here: https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documenta](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md)tion/Configuration.md.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它重复了缩进样式，这是推荐的。然后继续具体说明您希望代码呈现的规则。在这种情况下，它指定了**using**指令应该按照以**System**为前缀的顺序排序。接着，它说明**using**指令应该放在命名空间块之外，并且使用指令组之间不应有空行。这些选项以及更多可以在以下链接中找到：[https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documenta](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md)。
- en: Common project settings
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规项目设置
- en: If you have a set of configuration properties you want for all your projects,
    you can create a common **.props** file that will automatically be picked up and
    used. All you need is a file called the same as the project with a **.props**
    extension. In our case, the project name is **Roslyn.Extensions**, so the file
    needed would be called **Roslyn.Extensions.props**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一组希望用于所有项目的配置属性，您可以创建一个通用的**.props**文件，该文件将自动被拾取并使用。您只需要一个与项目同名的文件，并带有**.props**扩展名。在我们的例子中，项目名称是**Roslyn.Extensions**，因此所需的文件应命名为**Roslyn.Extensions.props**。
- en: A props file is basically just an MSBuild project file as the **.csproj** file.
    MSBuild has a convention of automatically importing this file from a common extension
    project like this into consumers of the extension package.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: props文件基本上就是一个MSBuild项目文件，就像**.csproj**文件一样。MSBuild有一个约定，即自动从像这样的公共扩展项目导入此文件到扩展包的消费者。
- en: Within a common project settings file, you can do more than just add properties.
    You can include files, add package references, or do anything that you can do
    in a regular **.csproj** file. That is super powerful when you want to apply and
    enforce common settings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个通用的项目设置文件中，你不仅可以添加属性，还可以包含文件、添加包引用，或者做任何你可以在常规 **.csproj** 文件中做的事情。当你想要应用和强制执行通用设置时，这非常强大。
- en: 'Add a file called **Roslyn.Extensions.props** to the **Roslyn.Extensions**
    project and put the following code into it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个名为 **Roslyn.Extensions.props** 的文件添加到 **Roslyn.Extensions** 项目中，并将以下代码放入其中：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The properties added configure first a couple of standard C# compiler settings.
    It enables **Nullable** and then tells the compiler to be strict and treat any
    warnings as errors. Then, it tells the MSBuild engine to do the same.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的属性首先配置了一些标准的 C# 编译器设置。它启用了 **Nullable**，然后告诉编译器要严格，并将任何警告视为错误。然后，它告诉 MSBuild
    引擎做同样的事情。
- en: Since we included code analysis, the next section configures it to force the
    compiler to run analyzers during the build and enable them all.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们包括了代码分析，下一节配置它强制编译器在构建期间运行分析器并启用所有分析器。
- en: Lastly, it sets up the style cop analyzers to specifically not treat errors
    as warnings and enforces it during build.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它设置了样式检查分析器，以特别不将错误视为警告，并在构建期间强制执行。
- en: 'The last thing you’re going to need is to make sure the **.globalconfig** file
    and **stylecop.json** file get used in any projects referencing this one. This
    is done by adding **ItemGroup** after **PropertyGroup** in the **Roslyn.Extensions.props**
    file, and it looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你最后需要确保的是，**.globalconfig** 文件和 **stylecop.json** 文件被任何引用此项目的项目使用。这是通过在 **Roslyn.Extensions.props**
    文件中在 **PropertyGroup** 之后添加 **ItemGroup** 来实现的，看起来是这样的：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This lets the compiler know about the two files for configuring static code
    analysis and code styles. It uses a variable called **MSBuildThisFileDirectory**,
    which is a well-known MSBuild variable that gets set to the folder of the file
    it is processing. Omitting this would make it look for this file relative to the
    current directory, which would be different for every project referencing this
    common project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这让编译器知道关于配置静态代码分析和代码样式的两个文件。它使用一个名为 **MSBuildThisFileDirectory** 的变量，这是一个众所周知的
    MSBuild 变量，它被设置为正在处理的文件的文件夹。省略此变量将使它相对于当前目录查找此文件，这对于每个引用此通用项目的项目来说都是不同的。
- en: To this point, all you’ve done is wrap up common things in a common project
    that can, within a repository, be referenced and automatically configure all projects
    referencing it. Sometimes, you want to go beyond the boundaries of a single repository
    and publish the common project as a package that can then be reused by other projects
    and get the same benefits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所做的一切只是将通用的事情封装在一个通用项目中，这个项目可以在仓库中被引用，并自动配置所有引用它的项目。有时，你希望超越单个仓库的边界，将通用项目发布为一个包，然后其他项目可以重用它并获得相同的益处。
- en: How to package your extension for reuse
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何打包你的扩展以供重用
- en: 'One of the key advantages of Roslyn compiler extensions is their potential
    for reuse across different projects and solutions. Once you have developed a Roslyn
    extension, you can package it for reuse and share it with other developers or
    teams, providing a number of benefits and advantages:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn 编译器扩展的一个关键优势是它们在不同项目和解决方案中的重用潜力。一旦你开发了一个 Roslyn 扩展，你可以打包它以供重用，并与其他开发者或团队共享，从而提供许多好处和优势：
- en: '**Code consistency**: Reusing Roslyn extensions can help enforce consistent
    coding practices across different projects and solutions. You can create Roslyn
    extensions that encapsulate coding standards, conventions, or best practices,
    and share them across your organization. This ensures that all projects adhere
    to the same coding guidelines, reducing inconsistencies and improving code quality.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码一致性**：重用 Roslyn 扩展可以帮助在不同项目和解决方案中强制执行一致的编码实践。你可以创建封装编码标准、约定或最佳实践的 Roslyn
    扩展，并在你的组织中共享它们。这确保了所有项目都遵守相同的编码指南，减少了不一致性并提高了代码质量。'
- en: '**Productivity**: Reusing Roslyn extensions can enhance developer productivity
    by automating repetitive tasks and providing productivity features. For example,
    you can create Roslyn extensions that generate boilerplate code, automate code
    refactoring, or provide custom code completion providers. By reusing such extensions,
    you can save time and effort, and improve overall development productivity.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产力**：重用 Roslyn 扩展可以通过自动化重复性任务和提供生产力功能来提高开发者生产力。例如，你可以创建生成样板代码、自动化代码重构或提供自定义代码补全提供者的
    Roslyn 扩展。通过重用此类扩展，你可以节省时间和精力，并提高整体开发生产力。'
- en: '**Maintainability**: Reusing Roslyn extensions can improve code maintainability
    by encapsulating complex logic or code generation patterns. You can create Roslyn
    extensions that encapsulate DSLs, custom syntax, or semantic rules, and share
    them across projects. This makes it easier to maintain and update the codebase,
    as changes can be made in a central location and propagated to all projects using
    the shared extension.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：重用 Roslyn 扩展可以通过封装复杂的逻辑或代码生成模式来提高代码的可维护性。你可以创建封装 DSL、自定义语法或语义规则的 Roslyn
    扩展，并在项目之间共享它们。这使得维护和更新代码库变得更加容易，因为更改可以在中央位置进行，并通过共享扩展传播到所有使用该扩展的项目。'
- en: '**Extensibility**: Reusing Roslyn extensions can make your codebase more extensible
    by providing hooks or extension points for other developers. You can create Roslyn
    extensions that provide extensibility points, such as custom code generation templates
    or code analysis rules, which can be extended or customized by other developers
    as needed. This promotes collaboration and enables other teams or developers to
    extend the functionality of your codebase.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：重用 Roslyn 扩展可以通过提供钩子或扩展点来使你的代码库更具可扩展性，供其他开发者使用。你可以创建提供扩展点的 Roslyn
    扩展，例如自定义代码生成模板或代码分析规则，这些可以由其他开发者根据需要扩展或定制。这促进了协作，并使其他团队或开发者能够扩展你的代码库的功能。'
- en: '**Innovation**: Reusing Roslyn extensions can foster innovation by sharing
    new ideas, techniques, or approaches with the community. If you have developed
    a novel or innovative Roslyn extension, sharing it with the community can encourage
    others to build upon your work, leading to new discoveries, solutions, or techniques.
    This contributes to the growth and advancement of the Roslyn ecosystem, benefiting
    the entire community.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创新**：重用 Roslyn 扩展可以通过与社区分享新想法、技术或方法来促进创新。如果你开发了一个新颖或创新的 Roslyn 扩展，将其与社区分享可以鼓励他人在此基础上进行构建，从而带来新的发现、解决方案或技术。这有助于
    Roslyn 生态系统的增长和进步，使整个社区受益。'
- en: By sharing and reusing Roslyn extensions, you can improve code quality, enhance
    productivity, and foster collaboration, contributing to a more robust and vibrant
    Roslyn ecosystem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过共享和重用 Roslyn 扩展，你可以提高代码质量，增强生产力，并促进协作，为更强大和充满活力的 Roslyn 生态系统做出贡献。
- en: Roslyn extensions can be a powerful tool for metaprogramming, which involves
    writing code that generates or manipulates other code. By creating and packaging
    Roslyn extensions, you can leverage metaprogramming techniques to automate repetitive
    tasks, enforce coding standards, or apply compliance rules such as **General Data
    Protection Regulation** (**GDPR**) across different projects and solutions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn 扩展可以是元编程的强大工具，元编程涉及编写生成或操作其他代码的代码。通过创建和打包 Roslyn 扩展，你可以利用元编程技术来自动化重复性任务，强制执行编码标准，或在不同的项目和解决方案中应用合规规则，例如
    **通用数据保护条例**（**GDPR**）。
- en: For example, consider a scenario where you have multiple projects that need
    to comply with GDPR by ensuring that certain data handling practices are followed
    consistently. Instead of manually checking and updating each project’s codebase,
    you can create a Roslyn extension that encapsulates the compliance rules and distributes
    them across the projects. This way, you can ensure that the same compliance rules
    are applied uniformly in all projects, saving time and effort and reducing the
    risk of human error.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个场景，你有多个项目需要遵守 GDPR，确保遵循一致的数据处理实践。而不是手动检查和更新每个项目的代码库，你可以创建一个封装合规规则的 Roslyn
    扩展，并将它们分布到各个项目中。这样，你可以确保在所有项目中统一应用相同的合规规则，节省时间和精力，并降低人为错误的风险。
- en: Furthermore, Roslyn extensions can also provide powerful metaprogramming capabilities
    to generate code or refactor existing code based on specific requirements. For
    instance, you can create a Roslyn extension that generates code snippets for common
    patterns or templates, such as implementing design patterns, handling common scenarios,
    or generating boilerplate code. By packaging and sharing this extension across
    projects, you can ensure that the generated code adheres to your organization’s
    coding standards or follows specific patterns, promoting consistency and maintainability.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Roslyn扩展还可以提供强大的元编程能力，根据特定要求生成代码或重构现有代码。例如，你可以创建一个Roslyn扩展，用于生成常见模式或模板的代码片段，例如实现设计模式、处理常见场景或生成样板代码。通过在项目之间打包和共享此扩展，你可以确保生成的代码符合你组织的编码标准或遵循特定模式，从而促进一致性和可维护性。
- en: Common package properties
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见包属性
- en: All NuGet packages can have additional metadata. This metadata is very useful
    when published to a NuGet package repository [such as the off](https://nuget.org)icial
    one at [https://nuget.org](https://nuget.org). This metadata is typically then
    displayed on the information page of a package. The metadata you add contains
    information about the authors, copyright notices, where the project is located,
    and more.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有NuGet包都可以有额外的元数据。当发布到NuGet包仓库[例如官方的](https://nuget.org) [https://nuget.org](https://nuget.org)时，这些元数据非常有用。这些元数据通常会在包的信息页面上显示。你添加的元数据包含有关作者、版权声明、项目位置等信息。
- en: 'Let’s add all the properties for the metadata. Open the **Roslyn.Extensions.csproj**
    file and add the following code, typically after the first **<PropertyGroup>**
    instance within the **<****Project>** tag:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加所有元数据的属性。打开**Roslyn.Extensions.csproj**文件，并在**<****Project>**标签内的第一个**<PropertyGroup>**实例之后添加以下代码：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Obviously, you can set all these properties to what is right for your project.
    It includes also **logo.png** and a **README.md** file. If you don’t have these,
    you can just take these out. Having a **README.md** file is, however, recommended
    when publishing to a package repository. Putting information into this file about
    how to use the package and what it is for would then be very helpful for the consumer
    of the package.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可以将这些属性设置为适合你项目的内容。它还包括**logo.png**和一个**README.md**文件。如果你没有这些，可以简单地将其删除。然而，当发布到包仓库时，拥有一个**README.md**文件是推荐的。将有关如何使用包及其用途的信息放入此文件将对包的用户非常有帮助。
- en: 'The metadata only points to the **logo.png** file and **README.md** file, but
    they have to be explicitly added for them to be part of the package. Add the following
    **ItemGroup** text after the **PropertyGroup** metadata:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据仅指向**logo.png**文件和**README.md**文件，但它们必须明确添加才能成为包的一部分。在**PropertyGroup**元数据之后添加以下**ItemGroup**文本：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice the use of the **PackagePath** attribute. This instructs the NuGet packager
    which target path to put the file into. For the **README.md** file, it will be
    put at the root of the package.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**PackagePath**属性的使用。这指示NuGet打包器将文件放入哪个目标路径。对于**README.md**文件，它将被放置在包的根目录下。
- en: 'For the common code properties, code analysis, and code style rules you added
    to the project earlier, they also need to be explicitly added to the package for
    them to work. Add another **ItemGroup** block for these files:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你之前添加到项目中的常见代码属性、代码分析和代码风格规则，它们也需要明确添加到包中才能生效。为这些文件添加另一个**ItemGroup**块：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For the **Roslyn.Extensions.props** file to work when used as a package reference,
    it needs to sit inside a folder called **build** within the package. Since we
    referred to the common files with a path prefixed with the **MSBuildThisFileDirectory**
    MSBuild variable, it means that the common files also have to be in the **build**
    path within the package.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当**Roslyn.Extensions.props**文件作为包引用使用时，它需要位于包内的**build**文件夹中。由于我们使用带有**MSBuildThisFileDirectory**
    MSBuild变量的路径前缀引用了常见文件，这意味着常见文件也必须在包内的**build**路径中。
- en: Analyzer
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析器
- en: The last piece of the puzzle is for the analyzer itself. For it to work, it
    needs to be within a specific part of the NuGet package, in a directory called
    **analyzers/dotnet/cs**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是分析器本身。为了使其工作，它需要位于NuGet包的特定部分，在名为**analyzers/dotnet/cs**的目录中。
- en: 'Add another **ItemGroup** block to the **Roslyn.Extensions.csproj** file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Roslyn.Extensions.csproj**文件中添加另一个**ItemGroup**块：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**ItemGroup** adds the DLL file of the project based on **OutputPath**, which
    will vary depending on whether you’re building a debug or release version. Typically,
    for a release version, it would be **bin/Release/netstandard2.0** and then the
    **AssemblyName** variable reflects the output assembly name, which, in our case,
    would be **Roslyn.Extensions**.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**ItemGroup**根据**OutputPath**添加项目的DLL文件，这将根据您是构建调试版本还是发布版本而有所不同。通常，对于发布版本，它将是**bin/Release/netstandard2.0**，然后**AssemblyName**变量反映了输出程序集的名称，在我们的例子中，将是**Roslyn.Extensions**。'
- en: Running **dotnet pack -c release** in a terminal from the root of the **Roslyn.Extensions**
    project should now create a package with all the artifacts in place.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Roslyn.Extensions**项目的根目录下从终端运行**dotnet pack -c release**现在应该会创建一个包含所有组件的包。
- en: The package will be output to the **bin/release** folder and called **Roslyn.Extensions.1.0.0.nupkg**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 包将被输出到**bin/release**文件夹，并命名为**Roslyn.Extensions.1.0.0.nupkg**。
- en: We can investigate the content of the package to see that everything we wanted
    it to include is included and in the correct locations. The NuGet package is nothing
    more than a compressed ZIP file. That means we can open it with your favorite
    ZIP utility and see whether the content is as expected.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查包的内容，以确认我们希望包含的所有内容都已包含，并且位于正确的位置。NuGet包不过是一个压缩的ZIP文件。这意味着我们可以使用您喜欢的ZIP实用程序打开它，并查看内容是否符合预期。
- en: 'The content should be something like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 内容应类似于以下内容：
- en: '![](img/B19418_15_01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_15_01.jpg)'
- en: Figure 15.1 – Checking package content
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – 检查包内容
- en: This package would now be ready to be published to a centralized package manager
    such as NuGet. You can read more about how to package NuGet packages at Microsoft’s
    official documentation for this ([https://learn.microsoft.com/en-us/nuget/nuget-org/publish-a-package](https://learn.microsoft.com/en-us/nuget/nuget-org/publish-a-package)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此包现在已准备好发布到集中式包管理器，如NuGet。您可以在微软的官方文档中了解更多关于如何打包NuGet包的信息（[https://learn.microsoft.com/en-us/nuget/nuget-org/publish-a-package](https://learn.microsoft.com/en-us/nuget/nuget-org/publish-a-package)）。
- en: That is pretty much it. You’ve now configured everything for a Roslyn extension
    and also put in common properties you want for every project referencing the package
    you have just created.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大致就是这样。您现在已为Roslyn扩展配置了一切，并且还添加了您希望每个引用您刚刚创建的包的项目都拥有的公共属性。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the technical setup of a Roslyn compiler extension
    project, covering the key moving parts of a Roslyn compiler extension. We discussed
    the various ways in which a Roslyn compiler extension can modify C# code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Roslyn编译器扩展项目的技术设置，涵盖了Roslyn编译器扩展的关键组成部分。我们讨论了Roslyn编译器扩展可以修改C#代码的各种方式。
- en: We also delved into the process of packaging a Roslyn compiler extension for
    reuse, exploring the different packaging options available and discussing best
    practices for making your extension easy to consume by other developers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还深入探讨了打包Roslyn编译器扩展以供重用的过程，探讨了可用的不同打包选项，并讨论了使您的扩展易于其他开发者使用的最佳实践。
- en: In the next chapter, we will focus on generating code with Roslyn compiler extensions.
    We’ll explore techniques for generating new code based on existing code, and we’ll
    discuss best practices for ensuring that the generated code is of high quality
    and conforms to established conventions and standards. With the knowledge gained
    in this chapter and the next, you’ll be well on your way to building powerful
    and flexible Roslyn compiler extensions that can significantly enhance the functionality
    of the C# compiler.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于使用Roslyn编译器扩展生成代码。我们将探讨基于现有代码生成新代码的技术，并讨论确保生成的代码质量高且符合既定约定和标准的最佳实践。通过本章和下一章获得的知识，您将能够构建功能强大且灵活的Roslyn编译器扩展，这些扩展可以显著增强C#编译器的功能。
