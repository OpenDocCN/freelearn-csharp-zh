- en: Concealing Complexity with a Facade Pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Facade pattern is an easy pattern to grasp because its name implies its
    purpose. The primary intent of the Facade pattern is to offer a simplified front-facing
    interface that abstracts the intricate inner workings of a complex system. This
    approach is beneficial for game development because games are composed of complex
    interactions between various systems. As a use case, we will write code that simulates
    the behavior and interactions of a vehicle's engine core components and then offers
    a simple interface to interact with the overall system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a bike engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a bike engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic implementation of a vehicle's engine with the Facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section includes a simplified version of the implementation of an engine
    for simplicity and brevity reasons. A complete implementation of this code example
    can be found in the `/FPP` folder of the GitHub project—the link is available
    under the *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a hands-on chapter, so you will need to have a basic understanding of
    Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/36wJdxe](https://bit.ly/36wJdxe)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Facade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Facade pattern''s name is analogous to the facade of a building—as the
    name implies, it''s an exterior face that hides a complex inner structure. Contrary
    to building architecture, in software development, the goal of a facade is not
    to beautify; instead, it is to simplify. As we are going to see in the following
    diagram, an implementation of the Facade pattern is usually limited to a single
    class that acts as a simplified interface to a collection of interacting subsystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7948ddd6-8d2d-4779-a345-a4a5cccf0d76.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Unified Modeling Language (UML) diagram of the Facade pattern
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding diagram, `EngineFacade` acts as an interface
    to the various components of the engine, thereupon the client is unaware of what
    is happening behind the scenes when calling `StartEngine()` on `EngineFacade`.
    It's unaware of the components that make up the engine and how to reach them;
    it only knows what it needs to know. This is similar to what happens when you
    turn the ignition key in your car—you don't see what's happening under the hood,
    and you don't need to; your only concern is that the engine starts. And so, the
    Facade pattern offers this same level of abstraction in your code, keeping the
    details of the system under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: The Facade pattern is part of the structural pattern category. Patterns in this
    classification are concerned with how classes and objects are composed to form
    larger structures.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some **benefits** of the Facade pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplified interface to a complex body of code**: A solid Facade class will
    conceal complexity from a client while providing a simplified interface to interact
    with an intricate system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy refactoring**: It''s easier to refactor code that''s isolated behind
    a Facade because the system''s interface remains consistent to the client while
    its components are being modified behind the scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some **drawbacks** to watch out for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It makes it easier to hide the mess**: Using the Facade pattern to hide messy
    code behind a clean front-facing interface will defeat the pattern''s core benefits
    in the long run, but this pattern does offer a way to mask some code smells until
    you have time to refactor them. However, expecting to have enough time later to
    fix stuff is a trap in itself because we rarely have enough time to refactor things
    correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Too many facades**: Globally accessible manager classes that act as facades
    to core systems are popular among Unity developers; they often implement them
    by combining the Singleton and Facade patterns. Unfortunately, it''s too easy
    to abuse this combination and end up with a code base comprising too many manager
    classes, each dependent on the other to function. As a consequence, debugging,
    refactoring, and unit testing components becomes very difficult.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Facade pattern establishes a new interface, whereas the Adapter pattern
    adapts an old interface. Therefore, when implementing patterns that might look
    and sound similar, it's essential to keep in mind that they're not necessarily
    identical in their purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a bike engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not aiming to implement a complete simulation of an actual gas engine
    for a bike; this will take too long and demands an in-depth understanding of the
    physics and mechanics of a real-world engine. But we will aim to simulate, to
    a minimal degree, some standard components of a high-speed vehicle''s motor. So
    first, let''s break down the expected behavior of each part of our engine, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cooling system**: The cooling system is responsible for making sure the engine
    is not overheating. When the turbocharger is activated, the cooling system shuts
    down during a turbocharge. This behavior means that if the player overuses the
    turbocharger, this can overheat the engine, and in consequence, the engine will
    stop or explode and the bike will stop moving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuel pump**: This component is responsible for managing the fuel consumption
    of the bike. It knows the amount of gas remaining and stops the engine if it runs
    out of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turbocharger**: If the turbocharger is activated, the vehicle''s top speed
    is increased, but the cooling system shuts down temporarily so that the engine''s
    circuitry can relay power to the charger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will implement a skeleton class for each of these components
    and establish an engine `Facade` class so that clients can start and stop the
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: The design intention of having the cooling system shut down when the turbocharger
    is activated is to create a sense of risk versus reward. The player must balance
    the desire to go faster with the potential consequence of overheating the engine.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a bike engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are going to see, the Facade pattern is straightforward, so we will keep
    the following code example simple and straight to the point. To start, we will
    write the classes for each of the core components that make up the bike''s engine,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the fuel pump; the purpose of this component is to simulate
    the consumption of fuel so that it knows the amount remaining and shuts down the
    engine when it runs out. Here''s the code you''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the cooling system, which is responsible for preventing the engine
    from overheating but gets deactivated if the turbocharger is activated. The code
    is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the turbocharger, when activated, increases the bike''s top speed,
    but for it to function, it needs to deactivate the cooling system temporarily.
    Here''s the code to accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the core components of our engine ready, we need to implement
    a class that will permit a client to interact with them seamlessly. So, we will
    implement a Facade class called `BikeEngine` that will offer an interface for
    a client to start and stop the engine and toggle the turbocharger. But because
    the following code example is so long, we will review it in two parts. Here''s
    the first part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of this class is initialization code and is self-explanatory,
    but the following segment is the important part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `EngineFacade` class exposes the available functionality
    that the bike engine offers but, at the same time, conceals the interaction between
    its components. If we want to start the engine, we just need to call the `StartEngine()`
    method. If we didn't have a Facade pattern such as the one we just implemented,
    we would have to initialize each engine component individually and know each of
    their parameters to set and the methods to call. The Facade pattern permits us
    to tuck all the complexity away behind a clean interface.
  prefs: []
  type: TYPE_NORMAL
- en: But suppose we wished to add another engine component, such as a nitro injector;
    in that case, we would only need to modify the `BikeFacade` class and expose a
    new public method to allow us to trigger the injector.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the engine facade
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can quickly test the code we just implemented by adding the following client
    script to a GameObject in an empty Unity scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the client class, we see that it's not aware of the engine's inner workings,
    and this is the effect we want to achieve when using the Facade pattern. The only
    thing the client class knows is that it can start and stop the engine and toggle
    on a turbocharged feature by calling the public methods made available by the `BikeEngine` class.
    To put it another way, just as in real life, we don't need to open the hood to
    start the engine; we turn the ignition key, and the components start working together
    without us knowing how they are interacting with each other.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review alternative solutions to consider before
    deciding on using the Facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In a potentially more advanced version of this code example, the engine would
    calculate the current **revolutions per minute** (**RPM**)—also known as the engine's
    speed—and we could connect it to a gear system regulated by a shifter input with
    which the player could control the bike's speed. Thus, we could easily enhance
    the level of realism at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several alternatives to keep in mind before considering the Facade
    pattern, depending on what you are actually trying to accomplish. These are listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract Factory pattern:** If you only want to conceal how subsystem objects
    are initialized from the client code, you should consider using the Abstract Factory
    pattern instead of the Facade pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adapter**: If you are intending to write a "wrapper" over existing classes
    with the intent to bridge two incompatible interfaces, then you should consider
    using the Adapter pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though the Facade pattern is sometimes used to hide messy code, when you
    use it as intended, it can enhance your code base's readability and usability
    by masking underlying complex interactions of subsystems behind a singular front-facing
    interface. Thus, it's a pattern that can be very beneficial for game programming,
    but one to use wisely and with good intent.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will explore a pattern named Service Locator, which
    we will use to manage global dependencies and expose core services.
  prefs: []
  type: TYPE_NORMAL
