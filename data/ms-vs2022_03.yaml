- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Advanced Code Analysis and Refactoring
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级代码分析和重构
- en: This chapter elevates our skills by focusing on advanced code analysis and refactoring
    techniques in Visual Studio 2022.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过专注于 Visual Studio 2022 中的高级代码分析和重构技术，提升了我们的技能。
- en: Understanding the fundamentals of code analysis, particularly through the lens
    of static code analysis powered by Roslyn, lays a robust foundation for identifying
    vulnerabilities and ensuring code correctness. Moreover, with built-in IntelliCode,
    which harnesses machine learning to optimize code bases, you’ll learn how to enhance
    maintainability and scalability effectively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Roslyn 驱动的静态代码分析来理解代码分析的基础，为识别漏洞和确保代码正确性奠定了坚实的基础。此外，借助内置的 IntelliCode，它利用机器学习来优化代码库，你将学习如何有效地提高可维护性和可扩展性。
- en: Beyond these foundational concepts, we’ll also delve into the importance of
    code metrics, providing invaluable insights into evaluating the maintainability
    and security postures of your projects. By using these metrics, you’ll gain the
    strategic foresight required to make informed decisions and enact targeted enhancements
    to your code base.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基础概念之外，我们还将深入探讨代码指标的重要性，为你提供评估项目可维护性和安全状态的有价值见解。通过使用这些指标，你将获得所需的战略远见，以便做出明智的决定并对代码库进行有针对性的改进。
- en: Throughout this chapter, I’ll illustrate these concepts with real-world code
    review refactoring case studies. By exploring the practical applications of Visual
    Studio tools, you’ll not only grasp theoretical concepts but also understand how
    to implement them effectively in your day-to-day development workflows.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将通过实际的代码审查重构案例研究来阐述这些概念。通过探索 Visual Studio 工具的实际应用，你不仅能够掌握理论概念，还能了解如何在日常开发工作中有效地实施它们。
- en: By the end of this chapter, you’ll emerge equipped with the knowledge and required
    tools to elevate the quality of your code, enhance security practices, and streamline
    maintenance efforts—all within the familiar and powerful environment of Visual
    Studio.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将掌握提升代码质量、增强安全实践和简化维护工作所需的知识和工具，所有这些都在熟悉的强大环境中完成，即 Visual Studio。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding code analysis in Visual Studio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Visual Studio 中的代码分析
- en: Utilizing static code analysis for quality assurance and security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用静态代码分析进行质量保证和安全
- en: Leveraging IntelliCode for code refactoring
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 IntelliCode 进行代码重构
- en: Using code metrics for maintainability and security
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码指标进行可维护性和安全性
- en: Refactoring case studies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构案例研究
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章时，我使用了以下版本的 Visual Studio：
- en: Visual Studio Enterprise 2022, version 17.12.0
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Enterprise 2022，版本 17.12.0
- en: Preview 1.0
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览 1.0
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch03](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch03)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch03](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch03)找到
- en: Understanding code analysis in Visual Studio
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Visual Studio 中的代码分析
- en: First, let’s discuss how Visual Studio and .NET work to analyze our code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论 Visual Studio 和 .NET 如何分析我们的代码。
- en: '**Code analysis** in Visual Studio 2022 is designed to help us improve the
    quality of our code. It provides several tools and metrics to analyze and enhance
    code maintainability, readability, and performance. By identifying potential issues
    and suggesting improvements, it aims to streamline the development process, reduce
    bugs, and improve overall code quality.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio 2022 中的代码分析**旨在帮助我们提高代码质量。它提供了一些工具和指标来分析和增强代码的可维护性、可读性和性能。通过识别潜在问题并提出改进建议，它旨在简化开发过程，减少错误，并提高整体代码质量。'
- en: 'Visual Studio 2022 can perform code analysis in two primary ways:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 可以通过两种主要方式执行代码分析：
- en: '**Legacy analysis (FxCop static analysis)** : This method analyzes compiled
    code to identify issues. It’s an old approach that only checks the code after
    it has been compiled.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遗留分析（FxCop 静态分析）**：这种方法分析编译后的代码以识别问题。这是一个过时的方法，它只在代码编译后进行检查。'
- en: '**.NET Compiler Platform-based code analyzers** : These are modern analyzers
    that analyze your code live as you type. They are dynamic and can provide real-time
    feedback, making it easier to catch and fix issues early in the development process.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于.NET编译器平台的代码分析器**：这些是现代分析器，在您键入时实时分析您的代码。它们是动态的，可以提供实时反馈，使在开发早期阶段捕捉和修复问题变得更容易。'
- en: Now, let’s delve into the .NET Compiler Platform, also known as **Roslyn** ,
    which revolutionizes code analysis capabilities in Visual Studio 2022. Roslyn
    is a platform that exposes the C# and Visual Basic compilers’ code analysis capabilities
    to developers. It provides a set of APIs that allow the creation of tools and
    applications focused on code analysis, refactoring, and transformation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解.NET编译器平台，也称为**Roslyn**，它彻底改变了Visual Studio 2022中的代码分析能力。Roslyn是一个平台，它将C#和Visual
    Basic编译器的代码分析能力暴露给开发者。它提供了一套API，允许创建专注于代码分析、重构和转换的工具和应用程序。
- en: 'Here’s some benefit of Roslyn:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Roslyn的一些好处：
- en: '**Rich language support** : Roslyn supports the C# and Visual Basic languages,
    providing comprehensive language features and syntax support for building custom
    developer tools and extensions.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丰富的语言支持**：Roslyn支持C#和Visual Basic语言，提供全面的语言特性和语法支持，用于构建自定义的开发者工具和扩展。'
- en: '**Programmatic code manipulation** : With Roslyn, we can programmatically analyze,
    refactor, and generate code using .NET APIs, empowering them to automate repetitive
    tasks and improve code quality and consistency.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序化代码操作**：使用Roslyn，我们可以通过.NET API程序化地分析、重构和生成代码，使它们能够自动化重复性任务，并提高代码质量和一致性。'
- en: '**IDE extensibility** : Roslyn enables the development of custom IDE extensions
    and tools that enhance the functionality of Visual Studio and other .NET IDEs,
    extending their capabilities to support specialized workflows and development
    scenarios.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDE可扩展性**：Roslyn允许开发自定义的IDE扩展和工具，增强Visual Studio和其他.NET IDE的功能，扩展其能力以支持专门的流程和开发场景。'
- en: '**Open source community** : Roslyn is an open source project hosted on GitHub
    that fosters collaboration and contributions from the developer community. Developers
    can contribute enhancements, bug fixes, and new features to the Roslyn code base,
    driving the innovation and evolution of the platform.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源社区**：Roslyn是一个托管在GitHub上的开源项目，它促进了开发社区的协作和贡献。开发者可以向Roslyn代码库贡献增强功能、错误修复和新功能，推动平台创新和进化。'
- en: Roslyn significantly reduces the difficulty of creating tools and applications
    focused on code, paving the way for innovation in various domains, including meta-programming,
    generating and transforming code, integrating interactive features into C# and
    Visual Basic languages, and embedding these languages into specialized domains.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn显著降低了创建专注于代码的工具和应用程序的难度，为包括元编程、生成和转换代码、将交互式功能集成到C#和Visual Basic语言中以及将这些语言嵌入到特定领域在内的各个领域的创新铺平了道路。
- en: How Roslyn works
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Roslyn的工作原理
- en: Roslyn revolutionizes the traditional compiler structure by decomposing it into
    distinct components. Moreover, it provides access to each phase of the compiler
    pipeline through APIs that mirror the compiler’s internal processes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn通过将其分解为不同的组件而彻底改变了传统的编译器结构。此外，它通过镜像编译器内部过程的API提供对编译器管道每个阶段的访问。
- en: 'Here’s an illustration of how this mirroring is organized:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何组织这种映射的说明：
- en: '![Figure 3.1 – Compiler API and Complier Pipeline](img/B22218_03_1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 编译器API和编译器管道](img/B22218_03_1.jpg)'
- en: Figure 3.1 – Compiler API and Complier Pipeline
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 编译器API和编译器管道
- en: 'The compiler API and compiler pipeline provide access to several key phases:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器API和编译器管道提供对几个关键阶段的访问：
- en: '**Parse Phase** : Source code undergoes tokenization and parsing, resulting
    in a syntax tree that adheres to the language’s grammar.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析阶段**：源代码经过标记化和解析，生成遵循语言语法的语法树。'
- en: '**Declaration Phase** : Declarations from both source code and imported metadata
    are analyzed to construct named symbols. These symbols are organized into a hierarchical
    symbol table.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明阶段**：从源代码和导入的元数据中分析声明以构建命名符号。这些符号组织成一个层次符号表。'
- en: '**Bind Phase** : Identifiers within the code are matched to symbols, generating
    a semantic model that reflects the compiler’s analysis.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定阶段**：代码中的标识符与符号匹配，生成反映编译器分析的语义模型。'
- en: '**Emit Phase** : The compiler accumulates all relevant information and emits
    it as an assembly. This assembly is represented through an API that produces **Intermediate
    Language** ( **IL** ) byte code.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Emit Phase**：编译器累积所有相关信息，并以汇编的形式输出。这个汇编通过一个API表示，该API生成**中间语言**（**IL**）字节码。'
- en: This modular approach grants comprehensive access to information at each stage
    of the compiler pipeline. It empowers developers with rich capabilities for code
    analysis and manipulation. The availability of three-phase compiler APIs (syntax
    trees, semantic model, and workspace level) is particularly instrumental in facilitating
    robust code analysis.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化方法允许全面访问编译器管道每个阶段的详细信息。它赋予开发者丰富的代码分析和操作能力。三个阶段的编译器 API（语法树、语义模型和工作区级别）在促进稳健的代码分析方面尤其重要。
- en: First, the **syntax trees** serve as a foundational representation of the structure
    of source code, encompassing both lexical and syntactic elements. They are pivotal
    in various stages of software development, including compilation, code analysis,
    binding, refactoring, and IDE functionalities. Offering a complete reflection
    of the source information, syntax trees maintain fidelity with the original text,
    ensuring immutability and thread safety. This facilitates the natural manipulation
    of source code without direct textual edits.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**语法树**作为源代码结构的基石表示，包括词汇和语法元素。它们在软件开发的各种阶段都至关重要，包括编译、代码分析、绑定、重构和 IDE 功能。语法树提供了对源信息的完整反映，与原始文本保持一致，确保不可变性和线程安全。这促进了源代码的自然操作，而无需直接进行文本编辑。
- en: Moving to semantics, the **semantic model** delves deeper into the meaning behind
    the code. It captures all semantic details within a single source file, shedding
    light on symbol references, expression types, diagnostics (errors and warnings),
    variable flow within source regions, and other nuanced aspects. By encapsulating
    language rules, this model enables clear distinctions between program elements
    in source code and those from precompiled libraries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 转向语义层面，**语义模型**深入挖掘代码背后的含义。它在一个源文件中捕获所有语义细节，揭示了符号引用、表达式类型、诊断（错误和警告）、源区域内的变量流以及其他细微方面。通过封装语言规则，该模型使得源代码中的程序元素与预编译库中的元素之间的区别更加清晰。
- en: At the workspace level, a central hub organizes information across entire solutions,
    streamlining code analysis and refactoring processes. This layer consolidates
    project data into a cohesive object model, offering seamless access to compiler
    layer object models without the need for file parsing, configuration adjustments,
    or inter-project dependency management. Crucially, it underpins the development
    of robust code analysis and refactoring tools within integrated development environments
    such as Visual Studio.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作区级别，一个中心枢纽组织整个解决方案的信息，简化了代码分析和重构过程。这一层将项目数据整合到一个统一的对象模型中，无需文件解析、配置调整或项目间依赖关系管理即可无缝访问编译层对象模型。关键的是，它为集成开发环境（如
    Visual Studio）中稳健的代码分析和重构工具的发展奠定了基础。
- en: How does Visual Studio 2022 use Roslyn?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio 2022 如何使用 Roslyn？
- en: Visual Studio 2022 uses the .NET Compiler Platform (Roslyn) to analyze and refactor
    C# or Visual Basic code in real time as developers write code. This process is
    integrated into the development environment, providing immediate feedback on code
    style, quality, maintainability, design, and other issues. In the subsequent sections,
    we’ll learn how Visual Studio 2022 utilizes Roslyn for analysis and refactoring.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 使用 .NET 编译器平台（Roslyn）在开发者编写代码时实时分析并重构 C# 或 Visual Basic 代码。此过程集成到开发环境中，提供对代码样式、质量、可维护性、设计和其他问题的即时反馈。在接下来的章节中，我们将学习
    Visual Studio 2022 如何利用 Roslyn 进行分析和重构。
- en: Analyzing with Roslyn analyzers
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Roslyn 分析器进行分析
- en: Visual Studio 2022 includes built-in code style analyzers (IDExxxx, e.g., IDE0001)
    and code quality analyzers (CAxxxx, e.g., CA1822) that inspect your code during
    design time in all open files. These analyzers are part of the .NET 5 SDK and
    are enabled by default.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 包含内置的代码样式分析器（IDExxxx，例如，IDE0001）和代码质量分析器（CAxxxx，例如，CA1822），它们在所有打开的文件的设计时检查你的代码。这些分析器是
    .NET 5 SDK 的一部分，默认启用。
- en: We can install external analyzers, such as **StyleCop** , **Roslynator** , **XUnit
    Analyzers** , and **SonarAnalyzer** , as NuGet packages or Visual Studio extensions.
    These analyzers extend the built-in capabilities, allowing more specialized checks
    and rules.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将外部分析器，如**StyleCop**、**Roslynator**、**XUnit Analyzers**和**SonarAnalyzer**，作为NuGet包或Visual
    Studio扩展安装。这些分析器扩展了内置功能，允许进行更专业的检查和规则。
- en: Furthermore, we create our own custom analyzer using the **Analyzer with Code
    Fix** template, which includes a VSIX extension and a separate project for the
    analyzer. This can be deployed via NuGet. That allows us to create our own custom
    analyzer. The analyzer can show a squiggly line below the matching code and an
    entry in the error list, with optional code fixes. This approach allows a more
    integrated development experience, with feedback and fixes available directly
    within the IDE.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用**带有代码修复的Analyzer**模板创建自己的自定义分析器，该模板包括一个VSIX扩展和一个用于分析器的独立项目。这可以通过NuGet进行部署。这允许我们创建自己的自定义分析器。分析器可以在匹配的代码下方显示波浪线并在错误列表中添加条目，可选的代码修复。这种方法允许更集成的开发体验，在IDE中直接提供反馈和修复。
- en: For scenarios where analysis does not require integration with Visual Studio,
    such as on a build server, we can use the **Standalone Code Analysis Tool** template.
    This tool opens a solution workspace and analyzes projects without requiring VSIX
    extensions or NuGet packages to be installed in the project or IDE.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不需要与Visual Studio集成的分析场景，例如在构建服务器上，我们可以使用**独立代码分析工具**模板。此工具打开解决方案工作区并分析项目，无需在项目中或IDE中安装VSIX扩展或NuGet包。
- en: Refactoring with Roslyn
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Roslyn进行重构
- en: Roslyn’s Syntax API parses C# code into a tree of nodes (class nodes, method
    nodes, etc.), enabling detailed manipulation of the code structure. This API is
    crucial for automating code refactoring, such as automating the migration of applications
    to . NET Core.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn的语法API将C#代码解析成节点树（类节点、方法节点等），使得对代码结构的详细操作成为可能。这个API对于自动化代码重构至关重要，例如自动化应用程序迁移到.NET
    Core。
- en: The **SyntaxEditor** class is used to apply changes to the code tree. It ensures
    that when a node is replaced or deleted, all its child nodes are updated accordingly,
    avoiding contention and exceptions. This is particularly useful for refactoring
    scripts that need to modify the code based on certain patterns or rules.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**SyntaxEditor**类用于对代码树应用更改。它确保当一个节点被替换或删除时，所有子节点都会相应地更新，避免冲突和异常。这对于需要根据某些模式或规则修改代码的脚本重构特别有用。'
- en: The **Code Refactoring** template in Visual Studio allows the creation of a
    VSIX extension that integrates with the **Quick Actions** menu in the IDE. This
    enables developers to apply quick code fixes directly from the editor without
    needing to define additional analyzer IDs or show entries in the error list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio中的**代码重构**模板允许创建一个与IDE中的**快速操作**菜单集成的VSIX扩展。这使得开发者可以直接从编辑器应用快速代码修复，而无需定义额外的分析器ID或在错误列表中显示条目。
- en: Now that we have learned how Visual Studio uses Roslyn to help us analyze and
    refactor our code, let’s dive deeper into the use of static code analysis for
    quality assurance and security.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Visual Studio如何使用Roslyn帮助我们分析和重构代码，让我们更深入地探讨如何使用静态代码分析进行质量保证和安全。
- en: Utilizing static code analysis for quality assurance and security
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用静态代码分析进行质量保证和安全
- en: The built-in **code quality analysis** feature is enabled by default in Visual
    Studio for projects that target .NET 5 or later. However, we can enable it for
    our older .NET project adding and setting to **true** the **EnabeNETAnalyzers**
    property in the **.** **csproj** file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标.NET 5或更高版本的Visual Studio项目，默认启用了内置的**代码质量分析**功能。但是，我们可以通过在**.csproj**文件中添加并设置为**true**的**EnabeNETAnalyzers**属性来为我们的旧.NET项目启用它。
- en: Static code analysis fosters a culture of continuous improvement and collaboration
    within development teams. By providing actionable insights and recommendations,
    these tools facilitate constructive code reviews, foster knowledge sharing, and
    ultimately elevate the skill and proficiency of developers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析促进了开发团队内部的持续改进和协作文化。通过提供可操作的建议和见解，这些工具促进了建设性的代码审查，促进了知识共享，并最终提高了开发者的技能和熟练度。
- en: Understanding how to use code analysis in Visual Studio
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解如何在Visual Studio中使用代码分析
- en: The code quality analysis will inspect our codebase for security, performance,
    design, and other potential areas for improvement. By default, the analysis runs
    automatically, so we can see errors, warnings, and information directly when we
    are typing through squiggles under our code or on the error list windows.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量分析将检查我们的代码库的安全性、性能、设计和其他潜在改进领域。默认情况下，分析会自动运行，因此我们可以在键入时通过代码下的波浪线或错误列表窗口直接看到错误、警告和信息。
- en: 'If we write code like the one shown in *Figure 3* *.2* , we will see squiggles
    appear:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写的代码像*图3.2*中所示的那样，我们将看到波浪线出现：
- en: '![Figure 3.2 – Information squiggles](img/B22218_03_2.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 信息波浪线](img/B22218_03_2.jpg)'
- en: Figure 3.2 – Information squiggles
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 信息波浪线
- en: In this example, the analyzer informs us that our **using** statement can be
    simplified according to the feature introduced by C# 8.0.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，分析器通知我们我们的**using**语句可以根据C# 8.0引入的功能进行简化。
- en: 'The analysis rules are organized into categories: Design, Documentation, Globalization,
    Portability and Interoperability, Maintainability, Naming, Performance, Reliability,
    Security, Style, and Usage. You can find detailed information about each rule
    category in the Microsoft documentation: [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/categories](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/categories)
    .'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 分析规则组织到以下类别：设计、文档、全球化、可移植性和互操作性、可维护性、命名、性能、可靠性、安全性、样式和用法。您可以在Microsoft文档中找到有关每个规则类别的详细信息：[https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/categories](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/categories)。
- en: 'Each rule has a severity level that determines its behavior:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则都有一个严重级别，用于确定其行为：
- en: '**Default** : This is the default severity level for rules that are enabled
    but do not have a specific severity set. It typically means that the rule is active
    and will report issues, but the exact behavior (e.g., whether it’s treated as
    a warning, error, or suggestion) depends on the rule’s configuration or the default
    behavior of the tool.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：这是已启用但未设置特定严重性的规则的默认严重级别。这通常意味着规则是激活的，并将报告问题，但确切的行为（例如，是否被视为警告、错误或建议）取决于规则的配置或工具的默认行为。'
- en: '**Error** : When a rule is set to the Error severity level, any violation of
    the rule will be reported as an error. This means that the code will not be compiled
    until the issue is resolved. Errors are typically used for critical issues that
    must be fixed before the code can be considered correct.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：当规则设置为错误严重级别时，任何违反规则的行为都将被报告为错误。这意味着代码将不会编译，直到问题得到解决。错误通常用于在代码被认为正确之前必须修复的关键问题。'
- en: '**Warning** : A rule set to Warning will report violations as warnings. Warnings
    do not prevent the code from compiling, but they are typically used to indicate
    potential issues that should be addressed to improve code quality or maintainability.
    Warnings can be configured to be treated as errors in certain build configurations,
    allowing developers to enforce stricter standards for production code.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**：设置为警告的规则将报告违规行为为警告。警告不会阻止代码编译，但通常用于指示应解决以改进代码质量或可维护性的潜在问题。警告可以配置为在特定构建配置中视为错误，允许开发者对生产代码强制执行更严格的标准。'
- en: '**Suggestion** : Rules with the Suggestion severity level report issues that
    are not critical but could improve the code. These rules are typically used for
    stylistic issues or practices that are not required but are recommended. Suggestions
    are often used in conjunction with code fixes that automatically apply the recommended
    changes, making it easier for developers to improve their code quality.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建议**：建议严重级别的规则报告的问题不是关键的，但可以改进代码。这些规则通常用于风格问题或不是必需但建议的做法。建议通常与自动应用推荐更改的代码修复结合使用，使开发者更容易提高代码质量。'
- en: '**Silent** : A rule set to Silent will not report any issues, effectively disabling
    the rule. This is useful for rules that are not relevant to your project or when
    you want to temporarily disable a rule without removing it from your configuration.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静默**：设置为静默的规则将不会报告任何问题，实际上禁用了该规则。这对于与你的项目无关的规则或当你想暂时禁用规则而不从配置中删除它时非常有用。'
- en: '**None** : This severity level is like Silent but is used to explicitly indicate
    that a rule should not be applied. It’s a way to make the intention clear that
    the rule is intentionally disabled.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：此严重性级别类似于静默，但用于明确表示规则不应应用。这是一种明确表示规则有意禁用的意图的方式。'
- en: Let’s see how we can use the level of severity to enhance the quality of our
    project.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用严重性级别来提高我们项目的质量。
- en: Adjusting the level of severity
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整严重性级别
- en: We can adjust the severity level of rules by right-clicking on the suggestion
    through the **Error List** and selecting **Set Severity** .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过通过**错误列表**右键单击建议并选择**设置严重性**来调整规则的严重性级别。
- en: This allows us to prioritize and customize how Visual Studio presents and addresses
    potential issues identified by the rules. Depending on the project’s requirements
    and development context, adjusting the severity levels can focus attention on
    critical issues while minimizing distractions from less impactful ones.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够优先考虑并自定义 Visual Studio 如何呈现和处理由规则识别的潜在问题。根据项目需求和开发环境，调整严重性级别可以集中关注关键问题，同时最大限度地减少对影响较小问题的干扰。
- en: '![Figure 3.3 – The Set severity option](img/B22218_03_3.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 设置严重性选项](img/B22218_03_3.jpg)'
- en: Figure 3.3 – The Set severity option
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 设置严重性选项
- en: This action generates an **.editorconfig** file in our solution’s root containing
    the overridden severity rule, which we can share with our team to ensure consistent
    coding practices.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将在我们的解决方案根目录中生成一个**.editorconfig**文件，其中包含覆盖的严重性规则，我们可以与我们的团队共享以确保一致的编码实践。
- en: '![Figure 3.4 – .editorconfig file generated](img/B22218_03_4.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 生成的 .editorconfig 文件](img/B22218_03_4.jpg)'
- en: Figure 3.4 – .editorconfig file generated
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 生成的 .editorconfig 文件
- en: An alternative method of adjusting the severity level is through the *light
    bulb* context menu, which also offers code fixes through Quick Actions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 调整严重性级别的另一种方法是通过**灯泡**上下文菜单，它还通过快速操作提供代码修复。
- en: '![Figure 3.5 – Setting the severity using the light bulb](img/B22218_03_5.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 使用灯泡图标设置严重性](img/B22218_03_5.jpg)'
- en: Figure 3.5 – Setting the severity using the light bulb
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 使用灯泡图标设置严重性
- en: During a code review, we might encounter practices that could be improved, as
    shown in *Figure 3* *.6* .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码审查期间，我们可能会遇到如图 3.6* 所示的可以改进的实践。
- en: '![Figure 3.6 – Pyramid code](img/B22218_03_6.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 金字塔代码](img/B22218_03_6.jpg)'
- en: Figure 3.6 – Pyramid code
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 金字塔代码
- en: For instance, a pyramid code structure might not trigger a squiggle, but the
    IDE might suggest simplifying an **if** statement ( **IDE0046** ). If you want
    to enforce a specific coding standard, you can set the severity level of this
    rule to **Error** .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个金字塔代码结构可能不会触发波浪线，但 IDE 可能会建议简化一个**if**语句（**IDE0046**）。如果您想强制执行特定的编码标准，可以将此规则的严重性级别设置为**错误**。
- en: '![Figure 3.7 – Change the severity level of IDE0046](img/B22218_03_7.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 更改 IDE0046 的严重性级别](img/B22218_03_7.jpg)'
- en: Figure 3.7 – Change the severity level of IDE0046
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 更改 IDE0046 的严重性级别
- en: 'Likewise, when we and our teammates encounter this rule, we are forced to refactor
    our code. We can notice that Visual Studio provides four code fixes for this Rule:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们和我们的团队成员遇到此规则时，我们被迫重构我们的代码。我们可以注意到 Visual Studio 为此规则提供了四种代码修复：
- en: '**Convert to a conditional expression** : This fix transforms an **if-else**
    statement into a conditional ( ternary) expression.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换为条件表达式**：此修复将**if-else**语句转换为条件（三元）表达式。'
- en: '**Invert if** : This fix inverts the condition of an if statement and swaps
    the code blocks.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反转 if**：此修复反转 if 语句的条件并交换代码块。'
- en: '**Convert to a switch statement** : This fix is applicable when you have multiple
    conditions based on the same variable or expression. It converts an if-else chain
    into a switch statement, which is more readable and maintainable for such case,
    like handling multiple conditions based on the same variable.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换为 switch 语句**：此修复适用于您有基于相同变量或表达式的多个条件时。它将**if-else**链转换为**switch**语句，这对于处理基于相同变量的多个条件来说更易读且易于维护。'
- en: '**Convert to a switch expression** : Like converting to a **switch** statement,
    this fix converts an **if-else** chain into a **switch** expression, which is
    a more concise and functional way to handle multiple conditions. It’s available
    in C# 8.0 and later.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换为 switch 表达式**：与转换为**switch**语句类似，此修复将**if-else**链转换为**switch**表达式，这是一种更简洁且功能更强大的处理多个条件的方法。它从
    C# 8.0 开始可用。'
- en: For better readability, I prefer to use Invert if in this example, but the IDE0046
    rule force is used to turn it into a conditional expression. Keep in mind that
    this is just an example, and we can adapt the level of severity of the analysis
    rules in our solution according to our needs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的可读性，我更喜欢在这个例子中使用Invert if，但IDE0046规则强制将其转换为条件表达式。请记住，这只是一个例子，我们可以根据我们的需求调整解决方案中分析规则的程度。
- en: As we have seen, adjusting the severity level generates a **.editorConfig**
    file containing our custom configurations. Let’s explore how we can generate such
    a file to easily share our Visual Studio settings with our team.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，调整严重程度级别会生成一个包含我们自定义配置的**.editorConfig**文件。让我们探索如何生成这样的文件，以便轻松地将我们的Visual
    Studio设置与团队共享。
- en: Generating a .editorconfig file
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 .editorconfig 文件
- en: What I recommend if you work in a team environment is to generate a **.editorconfig**
    file that you can tweak according to your needs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在团队环境中工作，我建议你生成一个可以根据你的需求进行调整的**.editorConfig**文件。
- en: To generate a **.editorconfig** file, we *right-click* on our solution, and
    in the contextual menu, select **Add** | **New** **Editor Config** .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个**.editorconfig**文件，我们在我们的解决方案上*右键单击*，然后在上下文菜单中选择**添加** | **新建** **Editor
    Config** 。
- en: '![Figure 3.8 – New EditorConfig](img/B22218_03_8.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 新的EditorConfig](img/B22218_03_8.jpg)'
- en: Figure 3.8 – New EditorConfig
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 新的EditorConfig
- en: This will generate a new file that will contain all configurations of our IDE.
    In this file, we will retrieve all the rules of the **Analyzer** .
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个新文件，其中将包含我们IDE的所有配置。在这个文件中，我们将检索**分析器**的所有规则。
- en: '![Figure 3.9 – EditorConfig Analyzer](img/B22218_03_9.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – EditorConfig 分析器](img/B22218_03_9.jpg)'
- en: Figure 3.9 – EditorConfig Analyzer
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – EditorConfig 分析器
- en: This allows us to list and set the severity level of each rule easily.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够轻松列出并设置每个规则的严重程度级别。
- en: Here, we can see that Visual Studio Analyzer provides 94 rules about security.
    These rules cover all the topics of the OWASP Top Ten and more. The OWASP Top
    10 serves as a widely recognized reference document for developers and web application
    security, highlighting the most significant security vulnerabilities faced by
    web applications based on a collective agreement within the industry.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Visual Studio分析器提供了关于安全的94条规则。这些规则涵盖了OWASP Top Ten的所有主题，以及更多。OWASP
    Top 10作为开发者和网络应用安全的一个广泛认可的参考文档，它基于行业内的集体协议，突出了网络应用面临的最重大的安全漏洞。
- en: Further reading
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'We can find all the security rules in Microsoft documentation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Microsoft文档中找到所有安全规则：
- en: '[https://learn.microsoft.com/en-us/visualstudio/code-quality/security-rules-rule-set-for-managed-code?view=vs-2019&viewFallbackFrom=vs-2022](https://learn.microsoft.com/en-us/visualstudio/code-quality/security-rules-rule-set-for-managed-code?view=vs-2019&viewFallbackFrom=vs-2022)
    .'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/visualstudio/code-quality/security-rules-rule-set-for-managed-code?view=vs-2019&viewFallbackFrom=vs-2022](https://learn.microsoft.com/en-us/visualstudio/code-quality/security-rules-rule-set-for-managed-code?view=vs-2019&viewFallbackFrom=vs-2022)
    .'
- en: Now that we have learned how we can use static code analysis, let’s dive into
    a new feature. Indeed, Visual Studio 2022 now integrates IntelliCode as a built-in
    feature, available to all subscriptions. Let’s explore how it works and how we
    can leverage its capabilities.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何使用静态代码分析，让我们深入了解一个新特性。确实，Visual Studio 2022现在将IntelliCode作为一个内置特性集成，对所有订阅者可用。让我们探索它是如何工作的，以及我们如何利用其功能。
- en: Leveraging IntelliCode for code refactoring
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用IntelliCode进行代码重构
- en: As developers, we need to constantly refactor our code to improve its structure,
    readability, or performance, especially when we are working with TDD, with respect
    to the flow explained in [*Chapter 1*](B22218_01.xhtml#_idTextAnchor015) .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们需要不断重构我们的代码来改善其结构、可读性或性能，尤其是在我们使用TDD（测试驱动开发）时，需要关注[第1章](B22218_01.xhtml#_idTextAnchor015)中解释的流程。
- en: One tool that has significantly enhanced our refactoring process is **IntelliCode**
    , which uses artificial intelligence and machine learning to offer intelligent
    suggestions and automate repetitive tasks. IntelliCode is now integrated into
    Visual Studio 2022 for C#. In this section, we’ll explore strategies for effective
    code refactoring using IntelliCode, drawing from our experience and insight.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著提高了我们重构过程的工具是**IntelliCode**，它使用人工智能和机器学习提供智能建议并自动化重复性任务。IntelliCode现在已集成到Visual
    Studio 2022的C#中。在本节中，我们将探讨使用IntelliCode进行有效代码重构的策略，借鉴我们的经验和洞察。
- en: First of all, we need to ensure that we have IntelliCode installed in our Visual
    Studio by going to the **Options** menu through the top bar menu, which is **Tools**
    | **Options** | **IntelliCode** .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保我们在 Visual Studio 中安装了 IntelliCode，通过顶部菜单栏的 **选项** 菜单进行，即 **工具** |
    **选项** | **IntelliCode** 。
- en: '![Figure 3.10 – IntelliCode Options](img/B22218_03_10.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.10 – IntelliCode Options](img/B22218_03_10.jpg)'
- en: Figure 3.10 – IntelliCode Options
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.10 – IntelliCode Options
- en: If you can't find IntelliCode in the **Options** menu, install it with your
    Visual Studio Installer by ticking the **IntelliCode** checkbox.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 **选项** 菜单中找不到 IntelliCode，请通过 Visual Studio 安装程序安装它，勾选 **IntelliCode**
    复选框。
- en: '![Figure 3.11 – Visual Studio Installer IntelliCode](img/B22218_03_11.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.11 – Visual Studio Installer IntelliCode](img/B22218_03_11.jpg)'
- en: Figure 3.11 – Visual Studio Installer IntelliCode
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.11 – Visual Studio Installer IntelliCode
- en: Now that we’ve ensured that IntelliCode is enabled in Visual Studio, let’s explore
    how it can enhance our coding experience.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经确保 IntelliCode 在 Visual Studio 中已启用，让我们探索它如何增强我们的编码体验。
- en: Predicting code with whole-line autocompletion
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用整行自动补全预测代码
- en: IntelliCode, introduced in Visual Studio 2022, provides whole-line autocompletion
    with suggestions. This feature is designed to streamline the development process,
    improve code quality, and increase productivity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliCode 是在 Visual Studio 2022 中引入的，提供带有建议的整行自动补全。此功能旨在简化开发过程，提高代码质量，并提高生产力。
- en: 'The following image shows whole-line autocompletion:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了整行自动补全：
- en: '![Figure 3.12 – Whole-line autocompletion from typing](img/B22218_03_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.12 – Whole-line autocompletion from typing](img/B22218_03_12.jpg)'
- en: Figure 3.12 – Whole-line autocompletion from typing
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.12 – Whole-line autocompletion from typing
- en: In *Figure 3* *.12* , we can see *gray text line prediction* generated according
    to the context. The prediction is based on a large amount of public, open source
    GitHub repositories. The IntelliCode suggestions are seamlessly integrated with
    those from in the IntelliSense. These IntelliCode recommendations are highlighted
    and easily indentifiable by the *black star* icon located on the left of the suggestion.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Figure 3* *.12* 中，我们可以看到根据上下文生成的 *灰色文本行预测*。该预测基于大量公共、开源的 GitHub 仓库。IntelliCode
    的建议与 IntelliSense 中的建议无缝集成。这些 IntelliCode 建议通过位于建议左侧的 *黑色星号* 图标突出显示，易于识别。
- en: If we select another suggestion than one provided by the whole-line autocompletion,
    IntelliCode generates a new prediction according to our choice.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择了一个不同于整行自动补全提供的建议，IntelliCode 将根据我们的选择生成一个新的预测。
- en: '![Figure 3.13 – Whole-line autocompletion from IntelliSense](img/B22218_03_13.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.13 – Whole-line autocompletion from IntelliSense](img/B22218_03_13.jpg)'
- en: Figure 3.13 – Whole-line autocompletion from IntelliSense
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.13 – Whole-line autocompletion from IntelliSense
- en: To accept the whole-line autocompletion, we just need to press *Tab* or click
    on the *arrow* that pops above the suggestion. We can press *Esc* or *Delete*
    to dismiss it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要接受整行自动补全，我们只需按 *Tab* 键或点击出现在建议上方的 *箭头*。我们可以按 *Esc* 或 *Delete* 键来取消它。
- en: IntelliCode runs locally on the machine, providing whole-line autocompletion,
    which enhances code security and consideration for properties, unlike ChatGPT
    and other AI predictions tools, which are generated inline.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliCode 在本地机器上运行，提供整行自动补全，这增强了代码安全性和对属性的考虑，与 ChatGPT 和其他在线 AI 预测工具不同，这些工具是在行内生成的。
- en: Now that we’ve seen how IntelliCode can help us generate code, let’s explore
    how it can assist us in understanding the code by providing direct access to documentation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到 IntelliCode 如何帮助我们生成代码，让我们探索它如何通过提供直接访问文档来帮助我们理解代码。
- en: Accessing GitHub documentation
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 GitHub 文档
- en: When using external libraries or nuggets, we can encounter methods that we don’t
    know how to use efficiently. IntelliCode provides a helpful feature called **API
    Usage Examples** , which provides practical examples of how to use these methods
    effectively.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用外部库或代码块时，我们可能会遇到不知道如何高效使用的函数。IntelliCode 提供了一个有用的功能，称为 **API 使用示例**，它提供了如何有效使用这些函数的实际示例。
- en: To activate this feature, go to the **Options** menu (see *Figure 3* *.10* )
    and tick **Enable API** **Usage Examples** .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活此功能，请转到 **选项** 菜单（见 *Figure 3* *.10* ）并勾选 **启用 API** **使用示例** 。
- en: 'Now, we can hover our cursor on the method we want to know more about, and
    we get a link labeled **GitHub Examples** **and Documentation** :'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将光标悬停在想要了解更多信息的函数上，我们会看到一个标记为 **GitHub 示例** **和文档** 的链接：
- en: '![Figure 3.14 – GitHub Examples and Documentation link](img/B22218_03_14.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – GitHub示例和文档链接](img/B22218_03_14.jpg)'
- en: Figure 3.14 – GitHub Examples and Documentation link
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – GitHub示例和文档链接
- en: 'Upon clicking on the link ( **GitHub Examples and Documentation** ), a side
    pin window opens with an example of the implementation of the method through several
    GitHub repositories:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接（**GitHub示例和文档**）后，会打开一个侧边固定窗口，展示通过几个GitHub仓库实现方法示例：
- en: '![Figure 3.15 – GitHub examples](img/B22218_03_15.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15 – GitHub示例](img/B22218_03_15.jpg)'
- en: Figure 3.15 – GitHub examples
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – GitHub示例
- en: This feature helps us to plan our refactoring according to the examples of implementation
    in other projects, using the experience of other developers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能帮助我们根据其他项目中实现的示例来规划重构，利用其他开发者的经验。
- en: In the next section, let’s dive into code metrics, which point to the areas
    of our project where we need to do some refactoring to improve maintainability
    and quality.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们深入了解代码度量，这些度量指向我们项目中需要重构以改善可维护性和质量的部分。
- en: Code metrics, maintainability, and security
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码度量、可维护性和安全性
- en: As developers, we rely on **code metrics** to evaluate the quality of a software
    system. These quantitative measures provide insights into various aspects of our
    code, such as complexity, maintainability, and security. By understanding these
    metrics, we can identify areas that may need improvement, ensuring that our code
    base remains manageable, secure, and efficient.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们依赖**代码度量**来评估软件系统的质量。这些定量措施为我们代码的各个方面提供洞察，如复杂度、可维护性和安全性。通过理解这些度量，我们可以识别可能需要改进的区域，确保我们的代码库保持可管理、安全且高效。
- en: Understanding the metrics
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解度量
- en: 'Visual Studio allows us to generate a report containing a list of metrics,
    such as the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio允许我们生成包含度量值列表的报告，如下所示：
- en: '**Maintainability Index** assesses how easy it is to maintain code, giving
    a score from 0 to 100, where higher scores indicate better maintainability. Ratings
    are color-coded: green (20-100) for *good* , yellow (10-19) for *moderate* , and
    red (0-9) for *low* .'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性指数**评估代码的可维护性，给出0到100的分数，分数越高表示可维护性越好。评分用颜色编码：绿色（20-100）表示*良好*，黄色（10-19）表示*中等*，红色（0-9）表示*低*。'
- en: '**Cyclomatic Complexity** measures a code’s structural complexity by counting
    its different flow paths. High complexity suggests more tests are needed for good
    coverage and lower maintainability.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环复杂度**通过计算代码的不同流程路径来衡量代码的结构复杂度。高复杂度表明需要更多的测试以实现良好的覆盖率并降低可维护性。'
- en: '**Depth of Inheritance** gauges how many classes inherit from one another,
    with lower values being better to prevent widespread changes.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承深度**衡量有多少个类相互继承，数值越低越好，以防止广泛的变化。'
- en: '**Class Coupling** measures how tightly classes are connected, with high coupling
    indicating poor design.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类耦合**衡量类之间的连接紧密程度，高耦合表示设计不佳。'
- en: '**Lines of Source Code** counts all lines in a source file, while **Lines of
    Executable Code** approximates the number of executable lines.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码行数**计算源文件中的所有行，而**可执行代码行数**近似可执行行的数量。'
- en: Now that we understand the metrics, let’s delve deeper into how to use them
    through Visual Studio.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了度量，让我们深入了解如何通过Visual Studio使用它们。
- en: Using code metrics in Visual Studio 2022
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中使用代码度量
- en: 'Visual Studio 2022 provides a powerful suite of tools for analyzing code metrics.
    Here are two ways to use them:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022提供了一套强大的工具用于分析代码度量。以下是两种使用它们的方法：
- en: In the top bar menu, select **Analyze** | **Calculate Code Metrics** and choose
    if you want to calculate the metrics on a specific project or on the solution
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部菜单栏中选择**分析** | **计算代码度量**，并选择您是否要在特定项目或解决方案上计算度量。
- en: '![Figure 3.16 – Calculate Code Metrics from the top menu](img/B22218_03_16.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16 – 从顶部菜单计算代码度量](img/B22218_03_16.jpg)'
- en: Figure 3.16 – Calculate Code Metrics from the top menu
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 从顶部菜单计算代码度量
- en: Alternatively, you can *right-click* directly on the solution or project you
    want to measure and, from the contextual menu, choose **Analyze and Code Cleanup**
    | **Calculate** **Code Metrics**
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以直接在想要测量的解决方案或项目上*右键单击*，然后从上下文菜单中选择**分析和代码清理** | **计算** **代码度量**
- en: '![Figure 3.17 – Calculate Code Metrics for a project](img/B22218_03_17.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17 – 为项目计算代码度量](img/B22218_03_17.jpg)'
- en: Figure 3.17 – Calculate Code Metrics for a project
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – 为项目计算代码度量
- en: 'After the analysis is complete, a window will open displaying the code metrics
    results:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 分析完成后，将打开一个窗口显示代码度量结果：
- en: '![Figure 3.18 – Code Metrics Results](img/B22218_03_18.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – 代码度量结果](img/B22218_03_18.jpg)'
- en: Figure 3.18 – Code Metrics Results
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – 代码度量结果
- en: Here, we can view metrics such as **Cyclomatic Complexity** , **Depth of Inheritance**
    , **Class Coupling** , **Lines of Source code** , and **Lines of Executable code**
    . We can apply a custom filter to clamp the result between the minimum and maximum
    values for a metric. Furthermore, for better manipulation of the data, we can
    export the code metric results to an Excel file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以查看诸如 **循环复杂度**、**继承深度**、**类耦合**、**源代码行数** 和 **可执行代码行数** 等度量。我们可以应用自定义过滤器，将度量结果限制在最小值和最大值之间。此外，为了更好地处理数据，我们可以将代码度量结果导出到
    Excel 文件中。
- en: Understanding and utilizing code metrics is essential for maintaining high-quality
    software. Visual Studio 2022 provides powerful tools for analyzing code metrics,
    helping developers identify and address issues relating to security and maintainability.
    By focusing on these aspects, developers can ensure that their code bases remain
    robust, secure, and easy to manage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和利用代码度量对于维护高质量的软件至关重要。Visual Studio 2022 提供了强大的工具来分析代码度量，帮助开发者识别和解决与安全和可维护性相关的问题。通过关注这些方面，开发者可以确保他们的代码库保持稳健、安全且易于管理。
- en: In this section, we’ve navigated through tools that identify parts of code that
    need improvement and used IntelliCode for refactoring. In the final section, let’s
    delve into a practical use case of refactoring.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已导航到识别需要改进的代码部分的工具，并使用 IntelliCode 进行重构。在最后一节中，让我们深入了解重构的实际用例。
- en: Refactoring case studies
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构案例研究
- en: '**Refactoring** entails restructuring code while preserving its initial functionality.
    The objective is to enhance the internal structure through incremental modifications
    without affecting the code’s external behavior. To check the integrity of our
    code, we use unit tests (see [*Chapter 1*](B22218_01.xhtml#_idTextAnchor015) of
    this book). Refactoring is the last step in the test-driven design process.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构**涉及在不影响代码初始功能的情况下重构代码。目标是通过对代码进行增量修改来增强内部结构，而不影响代码的外部行为。为了检查代码的完整性，我们使用单元测试（参见本书的[*第
    1 章*](B22218_01.xhtml#_idTextAnchor015)）。重构是测试驱动设计过程的最后一步。'
- en: This section showcases a small piece of code containing bad practices. We will
    see how to fix these issues efficiently with the help of Visual Studio. Remember
    that norms and practices must be discussed with all teams and can change from
    one team to another.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了一段包含不良实践的代码片段。我们将看到如何借助 Visual Studio 高效地修复这些问题。请记住，规范和实践必须与所有团队讨论，并且可能因团队而异。
- en: Handling common bad practice
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理常见的不良实践
- en: 'Here’s a code with bad naming and a condition check that can be easily simplified:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一段具有不良命名和可以轻松简化的条件检查的代码：
- en: '[PRE0]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will use the *light bulb* to fix the naming violation ( **IDE1006** ) provided
    by the live code analyzer:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 *灯泡* 来修复由实时代码分析器提供的命名违规（**IDE1006**）：
- en: '![Figure 3.19 – Fixing the name violation](img/B22218_03_19.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – 修复命名违规](img/B22218_03_19.jpg)'
- en: Figure 3.19 – Fixing the name violation
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 修复命名违规
- en: 'After that, we can simplify the age check with the *light bulb* :'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用 *灯泡* 简化年龄检查：
- en: '![Figure 3.20 – Simplifying the age check](img/B22218_03_20.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.20 – 简化年龄检查](img/B22218_03_20.jpg)'
- en: Figure 3.20 – Simplifying the age check
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 简化年龄检查
- en: We can see that the **Preview changes** window allows us to be more aggressive
    in fixing all occurrences in the different levels of our solution.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，**预览更改**窗口允许我们在解决方案的不同级别中更积极地修复所有出现的问题。
- en: 'Next, as our method contains only **return** , we can improve the readability
    by turning it into an **expression body** (a concise way to define the body of
    a method). We will use the *screwdriver* to do this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于我们的方法只包含 **return**，我们可以通过将其转换为 **表达式体**（定义方法体的简洁方式）来提高可读性。我们将使用 *螺丝刀*
    来完成这项工作：
- en: '![Figure 3.21 – Using an expression body](img/B22218_03_21.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.21 – 使用表达式体](img/B22218_03_21.jpg)'
- en: Figure 3.21 – Using an expression body
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 使用表达式体
- en: 'The last bad practice to handle is the usage of the magic number. A magic number
    refers to a numeric literal that appears directly in the source code without any
    explanation of its meaning or purpose. It can be challenging to change or understand
    without proper context. So, we will introduce a constant with a human-readable
    name to explain the purpose of this number. We will once again use the *light
    bulb* to do this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个需要处理的不良实践是使用魔法数字。魔法数字指的是在源代码中直接出现的没有解释其意义或目的的数值字面量。没有适当的上下文，它可能很难更改或理解。因此，我们将引入一个具有可读性名称的常量来解释这个数字的目的。我们还将再次使用
    *灯泡* 来完成这个任务：
- en: '![Figure 3.22 – Introducing a constant](img/B22218_03_22.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.22 – 引入一个常量](img/B22218_03_22.jpg)'
- en: Figure 3.22 – Introducing a constant
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – 引入一个常量
- en: Now we get a simple expression body, which is well named, and one that respects
    clean code practices.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了一个简单的表达式主体，名字起得很好，并且遵循了清洁代码实践。
- en: Generating an interface
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成一个接口
- en: For instance, imagine we get a **AirTraffic** class with a **RegisterAircraft**
    method. Now to add abstraction to our code we want to create an **IAirTraffic**
    interface. We’ll use the *screwdriver* to effortlessly extract the interface.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们得到一个 **AirTraffic** 类，它有一个 **RegisterAircraft** 方法。现在为了给我们的代码添加抽象，我们想要创建一个
    **IAirTraffic** 接口。我们将使用 *螺丝刀* 无缝地提取接口。
- en: '![Figure 3.23 – Extracting an interface](img/B22218_03_23.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.23 – 提取一个接口](img/B22218_03_23.jpg)'
- en: Figure 3.23 – Extracting an interface
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – 提取一个接口
- en: This will open a window with options to allow us to choose the configuration
    of our interface. We will keep the default choices to create the interface in
    a new file, named **IairTraffic.cs** .
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个窗口，其中包含选项，允许我们选择接口的配置。我们将保留默认选择，在新的文件中创建接口，命名为 **IairTraffic.cs**。
- en: 'Now, we are adding a new method, **SendMessage** , and we want it to belong
    to the interface as well. Again, we can use the *screwdriver* to pull the new
    method up to the interface:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在添加一个新的方法，**SendMessage**，我们希望它也属于接口。再次，我们可以使用 *螺丝刀* 将新方法提升到接口：
- en: '![Figure 3.24 – Pulling the method up to interface](img/B22218_03_24.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.24 – 将方法提升到接口](img/B22218_03_24.jpg)'
- en: Figure 3.24 – Pulling the method up to interface
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – 将方法提升到接口
- en: This refactoring ensures that all classes implementing **IAirTraffic** will
    have access to the **SendMessage** method, promoting a consistent interface and
    code reuse.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构确保了所有实现 **IAirTraffic** 的类都将能够访问 **SendMessage** 方法，促进了接口和代码的重用的一致性。
- en: File-scoping our namespace
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件作用域我们的命名空间
- en: The **file-scoped namespace** feature, introduced in C# 10, offers a more concise
    approach to declaring namespaces. It eliminates the need for curly braces to enclose
    the namespace body, streamlining the syntax and enhancing readability.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 10 中引入的 **文件作用域命名空间** 功能提供了一种更简洁的声明命名空间的方法。它消除了包围命名空间主体的花括号的需要，简化了语法并提高了可读性。
- en: By default, when we create classes in Visual Studio, it uses the older version
    of namespace, which wraps the entire content of the file using curly braces. We
    can add a semicolon at the end of the declaration of the namespace and Visual
    Studio will automatically understand that you want to turn it in file-scoped namespace.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们创建 Visual Studio 中的类时，它使用较旧的命名空间版本，该版本使用花括号包围整个文件的内容。我们可以在命名空间的声明末尾添加一个分号，Visual
    Studio 将自动理解你想要将其转换为文件作用域命名空间。
- en: 'To avoid this repetitive action, we can set file-scoped namespace as the default
    in Visual Studio by using the top menu bar: select **Tools** | **Options** | **Text
    Editor** | **C#** | **Code Style** | **General** and change the namespace declaration
    value to **File scoped** :'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种重复操作，我们可以通过使用顶部的菜单栏将文件作用域命名空间设置为 Visual Studio 的默认值：选择 **工具** | **选项**
    | **文本编辑器** | **C#** | **代码样式** | **常规** 并将命名空间声明值更改为 **文件作用域**：
- en: '![Figure 3.25 – Making namespace declarations file scoped](img/B22218_03_25.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.25 – 使命名空间声明为文件作用域](img/B22218_03_25.jpg)'
- en: Figure 3.25 – Making namespace declarations file scoped
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25 – 使命名空间声明为文件作用域
- en: If we work in teams, we can generate the **.editorconfig** file directly for
    the **Options** window by clicking on the **Generate .editor file from setting**
    option, as we can see in *Figure 3* *.25* .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在团队中工作，我们可以通过点击 **从设置生成 .editor 文件** 选项直接为 **选项** 窗口生成 **.editorconfig**
    文件，如图 *图 3* *.25* 所示。
- en: 'If we already have a **.editorconfig** file, (created manually or generated
    by changing the severity level, as seen in the *Utilizing static code analysis
    for quality assurance and security* section in this chapter), we can add the following
    line to set namespace declarations to **file_scoped** :'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们已经有了一个 **.editorconfig** 文件（可能是手动创建的，或者通过更改严重性级别生成的，如本章中 *利用静态代码分析进行质量保证和安全*
    部分所示），我们可以添加以下行来设置命名空间声明为 **file_scoped** :'
- en: '[PRE1]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we want Visual Studio to trigger compile-time errors when file-scoped namespaces
    are not used, the syntax would be as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望 Visual Studio 在未使用文件作用域命名空间时触发编译时错误，语法如下：
- en: '[PRE2]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This allows us to commit the configuration to our Git repository, ensuring it’s
    shared with our team.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们可以将配置提交到我们的 Git 仓库，确保它与我们的团队共享。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the inner workings of Roslyn within Visual Studio
    2022, empowering developers to use its capabilities fully. By mastering static
    code analysis, we can enhance quality assurance and security measures in our projects
    through nuanced control over severity levels and generating **.editorconfig**
    files and spreading them to our team.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Visual Studio 2022 中 Roslyn 的内部工作原理，使开发者能够充分利用其功能。通过掌握静态代码分析，我们可以通过精细控制严重性级别以及生成
    **.editorconfig** 文件并将其传播到我们的团队，来增强项目中的质量保证和安全措施。
- en: We saw how IntelliCode redefines productivity, offering predictive coding via
    whole-line autocompletion and seamless access to GitHub documentation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了 IntelliCode 如何重新定义生产力，通过整行自动完成和无缝访问 GitHub 文档提供预测性编码。
- en: We navigated code metrics of maintainability and security, which equip us with
    invaluable insights that allow us to evaluate and improve code bases. Armed with
    Visual Studio 2022’s built-in tools, projects can be optimized for long-term sustainability
    and robustness.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导航了代码的可维护性和安全性指标，这些指标为我们提供了宝贵的见解，使我们能够评估和改进代码库。凭借 Visual Studio 2022 的内置工具，项目可以优化以实现长期可持续性和健壮性。
- en: We concluded this chapter with practical refactoring case studies, addressing
    common pitfalls and demonstrating techniques such as interface generation and
    namespace refinement. By analyzing real-world scenarios, we gained hands-on experience
    in applying advanced refactoring principles.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以实际重构案例研究结束了本章，解决了一些常见陷阱，并展示了接口生成和命名空间细化等技术。通过分析现实场景，我们在应用高级重构原则方面获得了实践经验。
- en: In the following chapter, we explore strategies for identifying performance
    bottlenecks, optimizing code execution, and leveraging Visual Studio 2022’s profiling
    tools to ensure peak performance in our applications.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨识别性能瓶颈、优化代码执行以及利用 Visual Studio 2022 的分析工具以确保应用程序性能达到顶峰的策略。
