<html><head></head><body>
		<div id="_idContainer033">
			<h1 id="_idParaDest-328" class="chapter-number"><a id="_idTextAnchor426"/>10</h1>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor427"/>Pipelines and Composition</h1>
			<p>In this chapter, we will combine all knowledge from previous chapters and first discuss function composition, which allows us to combine simple functions to create more complex operations. Then, we will see how to construct pipelines using the <strong class="source-inline">Pipe</strong> method. We will also recall how to create monadic pipelines that gracefully handle errors. Furthermore, the fluent interface technique, which helps to write code that can be read almost like regular text, will <span class="No-Break">be presented.</span></p>
			<p>To sum it up, this chapter walks us through <span class="No-Break">these topics:</span></p>
			<ul>
				<li><span class="No-Break">Function composition</span></li>
				<li><span class="No-Break">Building pipelines</span></li>
				<li>The <span class="No-Break">fluent interface</span></li>
				<li>Advanced composition <span class="No-Break">with monads</span></li>
			</ul>
			<p>I could not betray our tradition and, for the last time, prepared three self-check tasks <span class="No-Break">for you.</span></p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor428"/>Task 1 – Enemy wave processing pipeline</h1>
			<p>Compose a series of functions into a pipeline that processes a list of enemy waves, applying <a id="_idIndexMarker562"/>increased difficulty (hard mode), validating the result, and transforming it into a formatted string using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
public class EnemyWave
{
   public int WaveNumber { get; set; }
   public int EnemyCount { get; set; }
   public string Description { get; set; }
}
Func&lt;EnemyWave, bool&gt; validateWave = wave =&gt; wave.EnemyCount &gt; 0;
Func&lt;EnemyWave, EnemyWave&gt; applyHardMode = wave =&gt;
{
   wave.EnemyCount = (int)(wave.EnemyCount * 1.2); // +20% enemies
   return wave;
};
Func&lt;EnemyWave, string&gt; formatWave = wave =&gt; $"Wave {wave.WaveNumber}: {wave.Description} - {wave.EnemyCount} enemies";</pre>			<h1 id="_idParaDest-331"><a id="_idTextAnchor429"/>Task 2 – Game data file processing</h1>
			<p>Using the following code, compose a series of monadic functions into a pipeline that processes <a id="_idIndexMarker563"/>a game data file, reads its content, processes it, and writes the result to <span class="No-Break">another file:</span></p>
			<pre class="source-code">
Func&lt;string, Result&lt;string&gt;&gt; readGameDataFile = path =&gt;
{
   try
   {
       var content = File.ReadAllText(path);
       return Result&lt;string&gt;.Success(content);
   }
   catch (Exception ex)
   {
       return Result&lt;string&gt;.Failure($"Failed to read file: {ex.Message}");
   }
};
Func&lt;string, Result&lt;string&gt;&gt; processGameData = content =&gt;
{
   // Simulate game data processing
   return Result&lt;string&gt;.Success(content.ToUpper());
};
Func&lt;string, Result&lt;bool&gt;&gt; writeGameDataFile = content =&gt;
{
   try
   {
       File.WriteAllText("processed_game_data.txt", content);
       return Result&lt;bool&gt;.Success(true);
   }
   catch (Exception ex)
   {
       return Result&lt;bool&gt;.Failure($"Failed to write file: {ex.Message}");
   }
};</pre>			<h1 id="_idParaDest-332"><a id="_idTextAnchor430"/>Task 3 – Dynamic SQL query generation using currying and partial application</h1>
			<p>Use currying <a id="_idIndexMarker564"/>to build a <a id="_idIndexMarker565"/>function for dynamic query generation for tower defense game data and partially applied functions for querying enemy types and levels. Use the following function to generate <span class="No-Break">query scripts:</span></p>
			<pre class="source-code">
Func&lt;string, string, string, string&gt; generateSqlQuery = (table, column, value) =&gt;
     $"SELECT * FROM {table} WHERE {column} = '{value}'";</pre>			<p>These tasks should be already familiar to you since they were discussed in previous chapters. However, you still might feel that there is room for improvement in your mastery of composition, currying, or partial application. If so, you are more than welcome to proceed with reading <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor431"/>Function composition</h1>
			<p>Steve looked <a id="_idIndexMarker566"/>at Julia with a mix of excitement <span class="No-Break">and nervousness.</span></p>
			<p>Steve: <em class="italic">So, we’re finally putting all the pieces together? I’m excited but a </em><span class="No-Break"><em class="italic">little overwhelmed.</em></span></p>
			<p>Julia: <em class="italic">Don’t worry, Steve. We’ll take it step by step. Remember, these concepts build on each other. You’ve already learned </em><span class="No-Break"><em class="italic">a lot!</em></span></p>
			<p>Steve: <em class="italic">You’re right. I’m ready to dive in. Where do </em><span class="No-Break"><em class="italic">we start?</em></span></p>
			<p>Julia: <em class="italic">Let’s begin with function composition. It’s a great way to combine everything we’ve learned </em><span class="No-Break"><em class="italic">so far...</em></span></p>
			<p>Function composition is the process of combining two or more functions to produce a new function. Let’s spice things up a notch and add higher-order functions to our <span class="No-Break">composition example.</span></p>
			<p>Consider a scenario where we need to transform a list of user data. We have the following <span class="No-Break">higher-order functions:</span></p>
			<p><strong class="bold">map</strong>: Applies a function to each element in <span class="No-Break">a list</span></p>
			<p><strong class="bold">filter</strong>: Filters elements in a list based on <span class="No-Break">a predicate</span></p>
			<p>We will <a id="_idIndexMarker567"/>define these functions in the <span class="No-Break">following way:</span></p>
			<pre class="source-code">
Func&lt;IEnumerable&lt;string&gt;, Func&lt;string, string&gt;, IEnumerable&lt;string&gt;&gt; map = (list, func) =&gt; list.Select(func);
Func&lt;IEnumerable&lt;string&gt;, Func&lt;string, bool&gt;, IEnumerable&lt;string&gt;&gt; filter = (list, predicate) =&gt; list.Where(predicate);</pre>			<p>Next, let’s define our transformation and <span class="No-Break">filtering functions:</span></p>
			<pre class="source-code">
Func&lt;string, string&gt; capitalize = input =&gt; char.ToUpper(input[0]) + input.Substring(1);
Func&lt;string, bool&gt; startsWithA = input =&gt; input.StartsWith("a");</pre>			<p>We can now compose <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> to create a function that will do all these actions <span class="No-Break">at once:</span></p>
			<pre class="source-code">
Func&lt;IEnumerable&lt;string&gt;, IEnumerable&lt;string&gt;&gt; processUsers = users =&gt; map(filter(users, startsWithA), capitalize);</pre>			<p>As a result, we have the <strong class="source-inline">processUsers</strong> function filter the list first to only include strings that start with “a” and then capitalize each remaining string. Of course, we could write all code using just one <strong class="source-inline">processUsers</strong> method, but the current solution allows us to reuse small functions in different places. The idea here is to start replacing big methods with compositions of smaller ones. Additional benefits are that small methods have much lower cognitive load and cyclomatic complexity, making them much easier to read <span class="No-Break">and maintain.</span></p>
			<p>As Julia finished explaining function composition, Steve <span class="No-Break">nodded thoughtfully.</span></p>
			<p>Steve: I think I’m starting to see how this all fits together. But how do we use this in <span class="No-Break">larger applications?</span></p>
			<p>Julia: Great <a id="_idIndexMarker568"/>question! That’s where pipelines come in. They allow us to chain these composed functions in a more structured way. Let me <span class="No-Break">show you...</span></p>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor432"/>Building pipelines</h1>
			<p>Before constructing pipelines, let’s briefly recap two key concepts from the previous chapter: currying and partial application. These techniques are fundamental to creating flexible, reusable function components that serve as excellent pipeline <span class="No-Break">building blocks.</span></p>
			<p>Currying, as we <a id="_idIndexMarker569"/>learned, transforms a function that takes multiple arguments into a sequence of functions, each accepting a single argument. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b;
Func&lt;int, Func&lt;int, int&gt;&gt; curriedAdd = a =&gt; b =&gt; a + b;</pre>			<p>Partial application, on the other hand, involves fixing a number of arguments to a function, producing another function with <span class="No-Break">fewer parameters:</span></p>
			<pre class="source-code">
Func&lt;int, int, int&gt; multiply = (a, b) =&gt; a * b;
Func&lt;int, int&gt; triple = x =&gt; multiply(3, x);</pre>			<p>These concepts naturally lead on to pipeline construction. By currying functions or partially applying them, we create specialized, single-purpose functions that can be easily composed into pipelines. This approach allows us to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Break down complex operations into simpler, more <span class="No-Break">manageable pieces</span></li>
				<li>Reuse these pieces across different pipelines <span class="No-Break">or contexts</span></li>
				<li>Create more expressive and readable code by chaining these <span class="No-Break">specialized functions</span></li>
			</ul>
			<p>For instance, consider a pipeline for processing <span class="No-Break">game data:</span></p>
			<pre class="source-code">
var processGameData =
     LoadData()
     .Then(ValidateData)
     .Then(TransformData)
     .Then(SaveData);</pre>			<p>Each step in this pipeline could be a curried or partially applied function, allowing for easy customization and reuse. As we explore pipeline construction further, remember how currying and partial application can be leveraged to create more flexible and <span class="No-Break">powerful pipelines.</span></p>
			<p>Now, let’s move on to <span class="No-Break">building pipelines.</span></p>
			<p>Pipelines process data through a sequence of processing steps, each represented by a function. This <a id="_idIndexMarker570"/>approach is particularly useful for tasks that require multiple transformations, validations, or computations. You most probably have already encountered pipelines while using LINQ to <span class="No-Break">manipulate collections.</span></p>
			<p>Let’s consider <a id="_idIndexMarker571"/>a real-world scenario: an <strong class="bold">Extract, Transform, Load</strong> (<strong class="bold">ETL</strong>) process for publishing manuscripts. This process involves <span class="No-Break">several steps:</span></p>
			<ol>
				<li>Extracting (querying) the manuscript from <span class="No-Break">a database</span></li>
				<li>Validating <span class="No-Break">its content</span></li>
				<li>Transforming it into the <span class="No-Break">required format</span></li>
				<li>Loading (submitting) it <span class="No-Break">for publication</span></li>
			</ol>
			<p>Each step can be represented as a function, and we can use a pipeline to streamline this process. To do this, let’s create a method that applies a sequence of functions to an initial value, passing the result of each function to the next, and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">Pipe</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public static T Pipe&lt;T&gt;(this T source, params Func&lt;T, T&gt;[] funcs)
{
     return funcs.Aggregate(source, (current, func) =&gt; func(current));
}</pre>			<p>Let’s consider book manuscript processing: querying the manuscript from a database, validating its content, transforming it into the required format, and finally submitting it <span class="No-Break">for publication:</span></p>
			<pre class="source-code">
public class Manuscript
{
     public string Content { get; set; }
     public bool IsValid { get; set; }
     public string FormattedContent { get; set; }
}
public Manuscript Query(Manuscript manuscript)
{
     // Simulate querying the manuscript from a database
     manuscript.Content = "Original manuscript content.";
     return manuscript;
}
public Manuscript Validate(Manuscript manuscript)
{
     // Simulate validating the manuscript
     manuscript.IsValid = !string.IsNullOrWhiteSpace(manuscript.Content);
     return manuscript;
}
public Manuscript Transform(Manuscript manuscript)
{
     // Simulate transforming the manuscript content
     if (manuscript.IsValid)
     {
         manuscript.FormattedContent = manuscript.Content.ToUpper();
     }
     return manuscript;
}
public Manuscript Submit(Manuscript manuscript)
{
     // Simulate submitting the manuscript for publication
     if (manuscript.IsValid)
     {
         Console.WriteLine($"Manuscript submitted: {manuscript.FormattedContent}");
     }
     else
     {
         Console.WriteLine("Manuscript validation failed. Submission aborted.");
     }
     return manuscript;
}</pre>			<p>Here’s how <a id="_idIndexMarker572"/>we might execute this flow without using the <span class="No-Break"><strong class="source-inline">Pipe</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
public void ExecutePublishingFlow(Manuscript manuscript)
{
     manuscript = Submit(
         Transform(
             Validate(
                 Query(
                     manuscript))));
}</pre>			<p>Now, using the <strong class="source-inline">Pipe</strong> method, our code becomes 10 <span class="No-Break">times better:</span></p>
			<pre class="source-code">
public void ExecutePublishingFlow(Manuscript manuscript)
{
     manuscript
         .Pipe(Query)
         .Pipe(Validate)
         .Pipe(Transform)
         .Pipe(Submit);
}</pre>			<p>Of course, it adds <a id="_idIndexMarker573"/>a bit of overhead, and the program might work noticeably more slowly, but it’s so much easier and faster <span class="No-Break">to read!</span></p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor433"/>Performance considerations</h1>
			<p>Talking about the overhead, while functional programming techniques such as composition <a id="_idIndexMarker574"/>and pipelines offer improved readability and maintainability, it’s important to understand their performance implications. When we compose functions, the compiler generates a series of nested method calls. This can lead to multiple stack frame allocations, impacting performance for deeply <span class="No-Break">nested compositions.</span></p>
			<p>To better understand the difference, let’s benchmark <span class="No-Break">different approaches:</span></p>
			<pre class="source-code">
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
[MemoryDiagnoser]
public class FunctionalPerformance
{
    private IEnumerable&lt;int&gt; _numbers;
    [GlobalSetup]
    public void Setup()
    {
         _numbers = Enumerable.Range(0, 1_000_000_000);
    }
    [Benchmark]
    public List&lt;int&gt; ImperativeApproach()
    {
         var result = new List&lt;int&gt;();
         foreach (var num in _numbers)
         {
              if ((num * 3) % 4 == 0)
                   result.Add(num * 3);
         }
         return result;
    }
    [Benchmark]
    public List&lt;int&gt; FunctionalApproach()
    {
         return _numbers
              .Select(x =&gt; x * 3)
              .Where(x =&gt; x % 4 == 0)
              .ToList();
    }
    [Benchmark]
    public List&lt;int&gt; FunctionalWithPipeline()
    {
         Func&lt;int, int&gt; triple = x =&gt; x * 3;
         Func&lt;int, bool&gt; isMultipleOfFour = x =&gt; x % 4 == 0;
         return _numbers
              .Pipe(list =&gt; list.Select(triple))
              .Pipe(list =&gt; list.Where(isMultipleOfFour))
              .ToList();
    }
}</pre>			<p>Running these <a id="_idIndexMarker575"/>benchmarks might yield results similar to <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B21069_10_001.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>As we can see, the imperative approach is almost twice as fast as the functional approach. However, the performance of a usual LINQ pipeline and our own is almost identical! While the imperative approach shows better performance, it’s important to note that functional approaches often provide benefits in code readability, maintainability, <span class="No-Break">and composability.</span></p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor434"/>The fluent interface</h1>
			<p>The fluent interface <a id="_idIndexMarker576"/>is the API pattern that allows us to chain method calls in a readable and intuitive manner. This term became widely known in 2005, but some people still think of it as just method chaining. However, the main idea is to make <a id="_idIndexMarker577"/>the code look like a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>). Let’s rework our previous example by introducing a fluent <span class="No-Break">interface technique.</span></p>
			<p>First, let’s define a class to encapsulate the pipeline steps for processing <span class="No-Break">a manuscript:</span></p>
			<pre class="source-code">
public class ManuscriptProcessor
{
     private Manuscript _manuscript;
     public ManuscriptProcessor(Manuscript manuscript)
     {
         _manuscript = manuscript;
     }
     public ManuscriptProcessor Query(Func&lt;Manuscript, Manuscript&gt; queryFunc)
     {
         // Simulate querying the manuscript from a database
         manuscript.Content = "Original manuscript content.";
         return this;
     }
     public ManuscriptProcessor Validate(Func&lt;Manuscript, Manuscript&gt; validateFunc)
     {
         _manuscript = validateFunc(_manuscript);
         return this;
     }
     public ManuscriptProcessor Transform(Func&lt;Manuscript, Manuscript&gt; transformFunc)
     {
         _manuscript = transformFunc(_manuscript);
         return this;
     }
     public Manuscript Submit()
     {
         // Simulate submitting the manuscript for publication
         if (manuscript.IsValid)
         {
            Console.WriteLine($"Manuscript submitted: {manuscript.FormattedContent}");
         }
         else
         {
            Console.WriteLine("Manuscript validation failed. Submission aborted.");
         }
         return _manuscript;
     }
}</pre>			<p>Using the <a id="_idIndexMarker578"/>fluent interface, we can rewrite the pipeline <span class="No-Break">more expressively:</span></p>
			<pre class="source-code">
var manuscript = new Manuscript();
var processedManuscript = new ManuscriptProcessor(manuscript)
     .Query()
     .Validate(Validate)
     .Transform(Transform)
     .Submit();</pre>			<p>As you can see, it looks almost identical to the example with the <strong class="source-inline">Pipe</strong> method, but the <strong class="source-inline">Query</strong> and <strong class="source-inline">Submit</strong> methods differ. It is because they do not depend on external validation or transformation rules that might change the logic but are rather straightforward. It’s a good idea to use a fluent interface when there is enough logic that will probably not change in the future. But if there isn’t any, we can use the <span class="No-Break"><strong class="source-inline">Pipe</strong></span><span class="No-Break"> method.</span></p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor435"/>Advanced composition with monads</h1>
			<p>Steve <a id="_idIndexMarker579"/>scratched <a id="_idIndexMarker580"/>his head, looking a <span class="No-Break">bit confused.</span></p>
			<p>Steve: <em class="italic">Julia, I thought we were done with monads. Why are we </em><span class="No-Break"><em class="italic">revisiting them?</em></span></p>
			<p>Julia: <em class="italic">Good observation, Steve. We’re circling back to monads because they’re incredibly powerful for composing complex operations, especially when dealing with error handling and asynchronous processes. Let me show you how they fit into </em><span class="No-Break"><em class="italic">our pipelines...</em></span></p>
			<p>Monads provide a mechanism for chaining operations as well. In previous chapters, you learned about the basic concept of monads and the <strong class="source-inline">Bind</strong> method. We will use the <strong class="source-inline">Bind</strong> method to chain operations in more complex contexts, such as error handling and <span class="No-Break">asynchronous processing.</span></p>
			<p>In our <a id="_idIndexMarker581"/>first scenario, we need to fetch and process <a id="_idIndexMarker582"/>user data from an external API. Each step in the process might fail, and we need to handle these <span class="No-Break">errors gracefully.</span></p>
			<p>First, let’s recall our <strong class="source-inline">Result</strong> <span class="No-Break">monad definition:</span></p>
			<pre class="source-code">
public class Result&lt;TValue, TError&gt;
{
    private TValue _value;
    private TError _error;
    public bool IsSuccess { get; private set; }
    private Result(TValue value, TError error, bool isSuccess)
    {
         _value = value;
         _error = error;
         IsSuccess = isSuccess;
    }
    public TValue Value
    {
         get
         {
              if (!IsSuccess) throw new InvalidOperationException("Cannot fetch Value from a failed result.");
              return _value;
         }
    }
    public TError Error
    {
         get
         {
              if (IsSuccess) throw new InvalidOperationException("Cannot fetch Error from a successful result.");
              return _error;
         }
    }
    public static Result&lt;TValue, TError&gt; Success(TValue value) =&gt; new Result&lt;TValue, TError&gt;(value, default, true);
    public static Result&lt;TValue, TError&gt; Failure(TError error) =&gt; new Result&lt;TValue, TError&gt;(default, error, false);
    public Result&lt;TResult, TError&gt; Bind&lt;TResult&gt;(Func&lt;TValue, Result&lt;TResult, TError&gt;&gt; func)
    {
         return IsSuccess ? func(_value!) : Result&lt;TResult, TError&gt;.Failure(_error!);
    }
}</pre>			<p>Next, rewrite <a id="_idIndexMarker583"/>our previous <a id="_idIndexMarker584"/>example to use the <span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
public class Manuscript
{
     public string Content { get; set; }
     public bool IsValid { get; set; }
     public string FormattedContent { get; set; }
}
Func&lt;int, Result&lt;Manuscript, string&gt;&gt; queryManuscript = manuscriptId =&gt;
{
     // Simulate querying the manuscript from a database
     if (manuscriptId &gt; 0)
     {
         var manuscript = new Manuscript { Content = "Original manuscript content." };
         return Result&lt;Manuscript, string&gt;.Success(manuscript);
     }
     else
     {
         return Result&lt;Manuscript, string&gt;.Failure("Invalid manuscript ID");
     }
};
Func&lt;Manuscript, Result&lt;Manuscript, string&gt;&gt; validateManuscript = manuscript =&gt;
{
     // Simulate validating the manuscript
     if (!string.IsNullOrWhiteSpace(manuscript.Content))
     {
         manuscript.IsValid = true;
         return Result&lt;Manuscript, string&gt;.Success(manuscript);
     }
     else
     {
         return Result&lt;Manuscript, string&gt;.Failure("Empty manuscript content");
     }
};
Func&lt;Manuscript, Result&lt;Manuscript, string&gt;&gt; transformManuscript = manuscript =&gt;
{
     // Simulate transforming the manuscript content
     if (manuscript.IsValid)
     {
         manuscript.FormattedContent = manuscript.Content.ToUpper();
         return Result&lt;Manuscript, string&gt;.Success(manuscript);
     }
     else
     {
         return Result&lt;Manuscript, string&gt;.Failure("Invalid manuscript for transformation");
     }
};
Func&lt;Manuscript, Result&lt;bool, string&gt;&gt; submitManuscript = manuscript =&gt;
{
     // Simulate submitting the manuscript for publication
     if (manuscript.IsValid)
     {
         Console.WriteLine($"Manuscript submitted: {manuscript.FormattedContent}");
         return Result&lt;bool, string&gt;.Success(true);
     }
     else
     {
         return Result&lt;bool, string&gt;.Failure("Manuscript validation failed. Submission aborted.");
     }
};</pre>			<p>We can <a id="_idIndexMarker585"/>now compose these functions using <strong class="source-inline">Bind</strong> to create <a id="_idIndexMarker586"/>a <span class="No-Break">monadic pipeline:</span></p>
			<pre class="source-code">
Func&lt;int, Result&lt;bool, string&gt;&gt; processManuscript = manuscriptId =&gt;
     queryManuscript(manuscriptId)
     .Bind(validateManuscript)
     .Bind(transformManuscript)
     .Bind(submitManuscript);</pre>			<p>Let’s use the pipeline to process <span class="No-Break">user data:</span></p>
			<pre class="source-code">
var result = processManuscript(129);
if (result.IsSuccess)
{
     Console.WriteLine("Manuscript processed and submitted successfully.");
}
else
{
     Console.WriteLine($"Error: {result.Error}");
}</pre>			<p>The expected console output is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Manuscript submitted: ORIGINAL MANUSCRIPT CONTENT.
Manuscript processed and submitted successfully.</pre>			<p>Again, the <strong class="source-inline">processManuscript</strong> method looks quite similar to the previous ones; however, this time, it includes graceful <span class="No-Break">error handling.</span></p>
			<p>Let’s now <a id="_idIndexMarker587"/>see how we can combine currying, partial <a id="_idIndexMarker588"/>application, and monadic operations to create a robust <span class="No-Break">error-handling pipeline:</span></p>
			<pre class="source-code">
// Curried function for Result monad
Func&lt;Func&lt;T, Result&lt;U&gt;&gt;, Func&lt;Result&lt;T&gt;, Result&lt;U&gt;&gt;&gt; curriedBind&lt;T, U&gt;() =&gt;
     f =&gt; result =&gt; result.Bind(f);
// Partially applied functions for specific operations
var parseInput = curriedBind&lt;string, int&gt;()
     (s =&gt; int.TryParse(s, out int n) ? Result&lt;int&gt;.Success(n) : Result&lt;int&gt;.Failure("Parse failed"));
var validatePositive = curriedBind&lt;int, int&gt;()
     (n =&gt; n &gt; 0 ? Result&lt;int&gt;.Success(n) : Result&lt;int&gt;.Failure("Number must be positive"));
var double = curriedBind&lt;int, int&gt;()
     (n =&gt; Result&lt;int&gt;.Success(n * 2));
// Composing a pipeline with monadic operations
Func&lt;string, Result&lt;int&gt;&gt; processInput =
     input =&gt; Result&lt;string&gt;.Success(input)
         .Pipe(parseInput)
         .Pipe(validatePositive)
         .Pipe(double);
var result = processInput("5");  // Success: 10
var error = processInput("-3");  // Failure: "Number must be positive"</pre>			<p>This example demonstrates the power of combining currying, partial application, and monadic composition. We’ve created a pipeline that parses input, validates it, and performs <a id="_idIndexMarker589"/>a transformation, all while handling potential errors in each step. The use of curried and partially applied functions makes our pipeline <a id="_idIndexMarker590"/>both flexible and easy <span class="No-Break">to extend.</span></p>
			<p>As they wrapped up their discussion, Steve looked both tired <span class="No-Break">and accomplished.</span></p>
			<p>Steve: <em class="italic">Wow, Julia. This has been quite a journey. I never thought I’d understand these concepts when </em><span class="No-Break"><em class="italic">we started</em></span><span class="No-Break">.</span></p>
			<p>Julia: <em class="italic">You’ve come a long way, Steve. How do you feel about functional </em><span class="No-Break"><em class="italic">programming now</em></span><span class="No-Break">?</span></p>
			<p>Steve: <em class="italic">I’m excited to start applying these concepts in our projects. It’s amazing how much clearer and more structured our code </em><span class="No-Break"><em class="italic">can be</em></span><span class="No-Break">.</span></p>
			<p>Julia smiled, proud of <span class="No-Break">Steve’s progress.</span></p>
			<p>Julia: <em class="italic">That’s great to hear, Steve. Remember, practice makes perfect. Keep experimenting and don’t be afraid to ask questions. Ready for some exercises to cement what </em><span class="No-Break"><em class="italic">we’ve learned?</em></span></p>
			<p>Steve: <em class="italic">Absolutely! Bring </em><span class="No-Break"><em class="italic">them on!</em></span></p>
			<h1 id="_idParaDest-338"><a id="_idTextAnchor436"/>Exercises</h1>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor437"/>Exercise 1</h2>
			<p>Compose a series of functions into a pipeline that processes a list of enemy waves, applying increased difficulty (hard mode), validating the result, and transforming it into a formatted string using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
public class EnemyWave
{
   public int WaveNumber { get; set; }
   public int EnemyCount { get; set; }
   public string Description { get; set; }
}
Func&lt;EnemyWave, bool&gt; validateWave = wave =&gt; wave.EnemyCount &gt; 0;
Func&lt;EnemyWave, EnemyWave&gt; applyHardMode = wave =&gt;
{
   wave.EnemyCount = (int)(wave.EnemyCount * 1.2); // +20% enemies
   return wave;
};
Func&lt;EnemyWave, string&gt; formatWave = wave =&gt; $"Wave {wave.WaveNumber}: {wave.Description} - {wave.EnemyCount} enemies";</pre>			<h2 id="_idParaDest-340"><a id="_idTextAnchor438"/>Exercise 2</h2>
			<p>Using the following code, compose a series of monadic functions into a pipeline that processes a game data file, reads its content, processes it, and writes the result to <span class="No-Break">another file:</span></p>
			<pre class="source-code">
Func&lt;string, Result&lt;string&gt;&gt; readGameDataFile = path =&gt;
{
   try
   {
       var content = File.ReadAllText(path);
       return Result&lt;string&gt;.Success(content);
   }
   catch (Exception ex)
   {
       return Result&lt;string&gt;.Failure($"Failed to read file: {ex.Message}");
   }
};
Func&lt;string, Result&lt;string&gt;&gt; processGameData = content =&gt;
{
   // Simulate game data processing
   return Result&lt;string&gt;.Success(content.ToUpper());
};
Func&lt;string, Result&lt;bool&gt;&gt; writeGameDataFile = content =&gt;
{
   try
   {
       File.WriteAllText("processed_game_data.txt", content);
       return Result&lt;bool&gt;.Success(true);
   }
   catch (Exception ex)
   {
       return Result&lt;bool&gt;.Failure($"Failed to write file: {ex.Message}");
   }
};</pre>			<h2 id="_idParaDest-341"><a id="_idTextAnchor439"/>Exercise 3</h2>
			<p>Use currying to build a function for dynamic query generation for tower defense game data and partially applied functions for querying enemy types and levels. Use the following function to generate <span class="No-Break">query scripts:</span></p>
			<pre class="source-code">
Func&lt;string, string, string, string&gt; generateSqlQuery = (table, column, value) =&gt;
     $"SELECT * FROM {table} WHERE {column} = '{value}'";</pre>			<h1 id="_idParaDest-342"><a id="_idTextAnchor440"/>Solutions</h1>
			<p>Here are the solutions to the exercises provided in the previous section. Use them to ensure your understanding and to correct any mistakes you might <span class="No-Break">have made.</span></p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor441"/>Solution 1</h2>
			<p>First, we compose these functions to create a transaction <span class="No-Break">processing pipeline:</span></p>
			<pre class="source-code">
Func&lt;IEnumerable&lt;EnemyWave&gt;, IEnumerable&lt;string&gt;&gt; processEnemyWaves = waves =&gt;
     waves
         .Where(validateWave)
         .Select(applyHardMode)
         .Select(formatWave);</pre>			<p>Then, we <span class="No-Break">test it:</span></p>
			<pre class="source-code">
var enemyWaves = new List&lt;EnemyWave&gt;
{
     new EnemyWave { WaveNumber = 1, EnemyCount = 50, Description = "Initial wave" },
     new EnemyWave { WaveNumber = 2, EnemyCount = 0, Description = "Empty wave" },
     new EnemyWave { WaveNumber = 3, EnemyCount = 100, Description = "Boss wave" }
};
var results = processEnemyWaves(enemyWaves);
foreach (var result in results)
{
     Console.WriteLine(result);
}</pre>			<p>Here’s the <span class="No-Break">expected result:</span></p>
			<pre class="source-code">
Wave 1: Initial wave - 60 enemies
Wave 3: Boss wave - 120 enemies</pre>			<h2 id="_idParaDest-344"><a id="_idTextAnchor442"/>Solution 2</h2>
			<p>We start by creating the monadic pipeline using the <span class="No-Break">given functions:</span></p>
			<pre class="source-code">
Func&lt;string, Result&lt;bool&gt;&gt; processGameDataFile = path =&gt;
     readGameDataFile(path)
         .Bind(processGameData)
         .Bind(writeGameDataFile);</pre>			<p>Let’s test <span class="No-Break">the pipeline:</span></p>
			<pre class="source-code">
var result = processGameDataFile("game.dat");
if (result.IsSuccess)
{
     Console.WriteLine("The data file was processed successfully.");
}
else
{
     Console.WriteLine($"Error: {result.Error}");
}</pre>			<p>Here’s the <span class="No-Break">expected result:</span></p>
			<pre class="source-code">
The data file was processed successfully.</pre>			<h2 id="_idParaDest-345"><a id="_idTextAnchor443"/>Solution 3</h2>
			<p>In this solution, we create a curried version of the <span class="No-Break">function first:</span></p>
			<pre class="source-code">
Func&lt;string, Func&lt;string, Func&lt;string, string&gt;&gt;&gt; curryGenerateSqlQuery = table =&gt; column =&gt; value =&gt; generateSqlQuery(table, column, value);</pre>			<p>Then, we use it to <span class="No-Break">generate queries:</span></p>
			<pre class="source-code">
Func&lt;string, string&gt; typeQuery = value =&gt; generateQuery("Enemies", "Type", value);
Func&lt;string, string&gt; levelQuery = value =&gt; generateQuery("Enemies", "Level", value);</pre>			<p>We write the code to <span class="No-Break">use them:</span></p>
			<pre class="source-code">
Console.WriteLine(typeQuery("Goblin"));
Console.WriteLine(levelQuery("5"));</pre>			<p>Here’s the <span class="No-Break">expected result:</span></p>
			<pre class="source-code">
SELECT * FROM Enemies WHERE Type = 'Goblin'
SELECT * FROM Enemies WHERE Level = '5'</pre>			<p>After finishing these exercises, you should have a better understanding of how to use pipelines, currying, and partial applications in <span class="No-Break">your code.</span></p>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor444"/>Summary</h1>
			<p>In this chapter, we integrated knowledge from previous chapters to revisit pipelines and composition. We started with function composition, showing how to combine simple functions into complex operations using higher-order functions for mapping and <span class="No-Break">filtering collections.</span></p>
			<p>We then introduced the <strong class="source-inline">Pipe</strong> method, which simplifies a pipeline’s function chaining. When applied to our book publishing system example, it enabled clear processing steps for querying, validating, transforming, and submitting <span class="No-Break">a manuscript.</span></p>
			<p>Then, we examined the fluent interface pattern, which allows quite intuitive method chaining. The <strong class="source-inline">ManuscriptProcessor</strong> class demonstrated how a fluent interface can make our code more expressive and user-friendly. We also covered advanced composition with monads using the <strong class="source-inline">Result</strong> type for graceful error handling in <span class="No-Break">monadic pipelines.</span></p>
			<p>The next chapter will be the last of our journey, and I truly hope you enjoy the process. So, finish the exercises if you haven’t yet done so, and see you in the <span class="No-Break">next chapter!</span></p>
		</div>
	

		<div id="_idContainer034" class="Content">
			<h1 id="_idParaDest-347" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor445"/>Part 4:Conclusion and Future Directions</h1>
			<p>In the final part, we reflect on the journey we’ve taken through functional programming in C#. We’ll summarize the key concepts learned, reinforcing your understanding of how these techniques can be applied to write cleaner, more maintainable code. We’ll also look ahead to what’s next in your functional programming journey, providing guidance on how to further advance your skills and stay up-to-date with evolving best practices in <span class="No-Break">the field.</span></p>
			<p>This part has the <span class="No-Break">following chapter:</span></p>
			<ul>
				<li><a href="B21069_11.xhtml#_idTextAnchor446"><em class="italic">Chapter 11</em></a><em class="italic">, Reflecting and Looking Ahead</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer035">
			</div>
		</div>
		<div>
			<div id="_idContainer036" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>