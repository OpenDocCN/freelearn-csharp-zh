["```cs\nusing System.IO.Pipes;\n\"Starting the server\".Dump(ConsoleColor.Cyan);\nawait using var server = new\n    NamedPipeServerStream(\"SystemsProgrammersPipe\");\n\"Waiting for connection\".Dump(ConsoleColor.Cyan);\nawait server.WaitForConnectionAsync();\nawait using var writer = new StreamWriter(server);\nwriter.AutoFlush = true;\nwriter.WriteLine(\"Hello from the server!\");\n```", "```cs\nusing System.IO.Pipes;\nawait using var client = new NamedPipeClientStream(\".\",     \"SystemsProgrammersPipe\");\n\"Connecting to the server\".Dump(ConsoleColor.Yellow);\nawait client.ConnectAsync();\nusing var reader = new StreamReader(client);\nstring? message = await reader.ReadLineAsync();\nmessage.Dump(ConsoleColor.Yellow);\n```", "```cs\nusing System.IO.Pipes;\nawait using var pipeServer = new     AnonymousPipeServerStream(PipeDirection.Out, HandleInheritability.    Inheritable);\n$\"The pipe handle is: {pipeServer.GetClientHandleAsString()}\".    Dump(ConsoleColor.Cyan);\npipeServer.DisposeLocalCopyOfClientHandle();\nawait using var sw = new StreamWriter(pipeServer);\nsw.AutoFlush = true;\nsw.WriteLine(\"From server\");\npipeServer.WaitForPipeDrain();\n```", "```cs\n\"Enter the pipeHandle\".Dump(ConsoleColor.Yellow);\nvar pipeHandle = Console.ReadLine();\nusing var pipeClient = new AnonymousPipeClientStream(PipeDirection.In, pipeHandle);\nusing var sr = new StreamReader(pipeClient);\nwhile (sr.ReadLine() is { } temp)\n    temp?.Dump(ConsoleColor.Yellow);\n```", "```cs\nProcess pipeClient = new Process();\npipeClient.StartInfo.FileName = @\"pipeClient.exe\";\n// Pass the client process a handle to the server.\npipeClient.StartInfo.Arguments =\n    pipeServer.GetClientHandleAsString();\npipeClient.StartInfo.UseShellExecute = false;\npipeClient.Start();\n```", "```cs\n01: using System.Net;\n02: using System.Net.Sockets;\n03: using System.Text;\n04:\n05: \"Server is starting up.\".Dump();\n06:\n07: var server = new TcpListener(IPAddress.Loopback, 8080);\n08: server.Start();\n09:\n10: \"Waiting for a connection.\".Dump();\n11:\n12: var client = await server.AcceptTcpClientAsync();\n13: \"Client connected\".Dump();\n14:\n15: var stream = client.GetStream();\n16: while (true)\n17: {\n18:     var buffer = new byte[1024];\n19:     var bytes = await stream.ReadAsync(buffer, 0, buffer.Length);\n20:     var message = Encoding.UTF8.GetString(buffer, 0, bytes);\n21:     $\"Received message: {message}\".Dump();\n22:\n23:     if (message.ToLower() == \"bye\")\n24:         break;\n25:\n26:     \"Say something back\".Dump();\n27:     var response = Console.ReadLine();\n28:     var responseBytes = Encoding.UTF8.GetBytes(response);\n29:     await stream.WriteAsync(responseBytes, 0, responseBytes.           Length);\n30:\n31:     if (response.ToLower() == \"bye\")\n32:         break;\n33: }\n34:\n35: client.Close();\n36: server.Stop();\n37: \"Connection closed.\".Dump();\n```", "```cs\n01: using System.Net.Sockets;\n02: using System.Text;\n03:\n04: \"Client is starting up.\".Dump(ConsoleColor.Yellow);\n05:\n06: var client = new TcpClient(\"127.0.0.1\", 8080);\n07: \"Connected to the server. Let's chat!\".Dump(ConsoleColor.Yellow);\n08: var stream = client.GetStream();\n09:\n10: while (true)\n11: {\n12:     \"Say something\".Dump(ConsoleColor.Yellow);\n13:     var message = Console.ReadLine();\n14:     var data = Encoding.UTF8.GetBytes(message);\n15:     await stream.WriteAsync(data, 0, data.Length);\n16:     if (message.ToLower() == \"bye\")\n17:         break;\n18:\n19:     var buffer = new byte[1024];\n20:     var bytesRead = await stream.ReadAsync(buffer, 0, buffer.            Length);\n21:     var response = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n22:     $\"Server says: {response}\".Dump(ConsoleColor.Yellow);\n23:     if (response.ToLower() == \"bye\")\n24:         break;\n25: }\n26:\n27: client.Close();\n28: \"Connection closed.\".Dump(ConsoleColor.Yellow);\n```", "```cs\nusing System.IO.MemoryMappedFiles;\n\"Ready to write data to share memory.\\nPress Enter to do     so.\".Dump(ConsoleColor.Cyan);\nConsole.ReadLine();\nusing var mmf = MemoryMappedFile.CreateNew(\"SharedData\", 1024);\n// Create a view accessor to write data\nusing MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();\nbyte[] data = System.Text.Encoding.UTF8.GetBytes(\"Hello from Process     1\");\naccessor.WriteArray(0, data, 0, data.Length);\n\"Data written to shared memory. Press any key to     exit.\".Dump(ConsoleColor.Cyan);\nConsole.ReadKey();\n```", "```cs\nusing System.IO.MemoryMappedFiles;\n\"Wait for the server to finish. \\nPress Enter to read the shared     data.\".Dump(ConsoleColor.Yellow);\nConsole.ReadLine();\nusing var mmf = MemoryMappedFile.OpenExisting(\"SharedData\");\n// Create a view accessor to read data\nusing MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();\nbyte[] data = new byte[1024];\naccessor.ReadArray(0, data, 0, data.Length);\n$\"Received message: {System.Text.Encoding.UTF8.GetString(data)}\".    Dump(ConsoleColor.Yellow);\n```", "```cs\n[Serializable]\ninternal class ShowDateCommand\n{\n    public bool IncludeTime { get; set; }\n}\n```", "```cs\ninternal class Server(CancellationToken cancellationToken)\n{\n    public async Task StartServer()\n    {\n        \"Starting the server\".Dump(ConsoleColor.Cyan);\n        await using var server = new             NamedPipeServerStream(\"CommandsPipe\");\n        \"Waiting for connection\".Dump(ConsoleColor.Cyan);\n        await server.WaitForConnectionAsync(cancellationToken);\n        using var reader = new StreamReader(server);\n        while (!cancellationToken.IsCancellationRequested)\n        {\n            var line = await reader.ReadLineAsync();\n            if (line == null) break;\n            $\"Received this command: {line}\".Dump(ConsoleColor.Cyan);\n            var command = JsonSerializer.                Deserialize<ShowDateCommand>(line);\n            if (command is { IncludeTime: true })\n                DateTime.Now.ToString(\"yyyy-MM-dd\n                    HH:mm:ss\").Dump(ConsoleColor.Cyan);\n            else\n                DateTime.Now.ToString(\"yyyy-MM-dd\").Dump(ConsoleColor.                    Cyan);\n        }\n    }\n}\n```", "```cs\ninternal class Client(CancellationToken cancellationToken)\n{\n    public async Task StartClient()\n    {\n        var newCommand = new ShowDateCommand\n        {\n            IncludeTime = true\n        };\n        var newCommandAsJson = JsonSerializer.Serialize(newCommand);\n        \"Starting the client\".Dump(ConsoleColor.Yellow);\n        await using var client = new             NamedPipeClientStream(\"CommandsPipe\");\n        await client.ConnectAsync(cancellationToken);\n        await using var writer = new StreamWriter(client);\n        $\"Sending this command: {newCommandAsJson}\".Dump(ConsoleColor.            Yellow);\n        await writer.WriteLineAsync(newCommandAsJson);\n        await writer.FlushAsync();\n    }\n}\n```", "```cs\nvar cancellationTokenSource = new CancellationTokenSource();\n\"Starting the server\".Dump(ConsoleColor.Green);\nvar server = new Server(cancellationTokenSource.Token);\nTask.Run(() => server.StartServer(), cancellationTokenSource.Token);\nvar client = new Client(cancellationTokenSource.Token);\n    Task.Run(() => client.StartClient(),\n    cancellationTokenSource.Token);\n\"Server and client are running, press a key to stop\".    Dump(ConsoleColor.Green);\nvar input = Console.ReadKey();\n\"Stopping all\".Dump(ConsoleColor.Green);\n```", "```cs\nsyntax = \"proto3\";\noption csharp_namespace = \"_02_GRPC_Server\";\nservice TimeDisplayer {\n    rpc DisplayTime (DisplayTimeRequest) returns (DisplayTimeReply);\n}\nmessage DisplayTimeRequest{\n    string name = 1;\n    bool wantsTime = 2;\n}\nmessage DisplayTimeReply{\n    string message = 1;\n}\n```", "```cs\n<ItemGroup>\n  <ProtoBuf Include=\"Protos\\displayer.proto\" GrpcServices=\"Server\" />\n</ItemGroup>\n```", "```cs\ninternal class TimeDisplayerService : TimeDisplayer.TimeDisplayerBase\n{\n    public override Task<DisplayTimeReply> DisplayTime(\n        DisplayTimeRequest request,\n        ServerCallContext context)\n    {\n        var result = request.WantsTime\n            ? DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\")\n            : DateTime.Now.ToString(\"yyyy-MM-dd\");\n        result.Dump();\n        return Task.FromResult(new DisplayTimeReply\n        {\n            Message = $\"I printed {result}\"\n        });\n    }\n}\n```", "```cs\n\"Starting gRPC server...\".Dump();\nvar port = 50051;\nvar server = new Server\n{\n    Services = {TimeDisplayer.BindService(new         TimeDisplayerService())},\n    Ports = {new ServerPort(\"localhost\", port, ServerCredentials.        Insecure)}\n};\nserver.Start();\nConsole.WriteLine(\"Greeter server listening on port \" + port);\nConsole.WriteLine(\"Press any key to stop the server...\");\nConsole.ReadKey();\nawait server.ShutdownAsync();\n```", "```cs\n\"Starting gRPC client... Press ENTER to connect.\".Dump(ConsoleColor.Yellow);\nConsole.ReadLine();\nvar channel = GrpcChannel.ForAddress(\"http://localhost:50051\");\nvar client = new\nTimeDisplayer.TimeDisplayerClient(channel);\nvar reply =\n    await client.DisplayTimeAsync(\n        new DisplayTimeRequest\n        {\n            Name = \"World\",\n            WantsTime = false\n        });\nConsole.WriteLine(\"From server: \" + reply.Message);\n```"]