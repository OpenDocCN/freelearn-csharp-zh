<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer123">
<h1 class="chapterNumber">7</h1>
<h1 class="chapterTitle" id="_idParaDest-146">Rigid Bodies and Physics Interaction</h1>
<p class="normal">In many game interactions, there needs to be physics. Whether you have items falling, bouncing, or just reacting to a collision in a procedural manner, you will most likely need to use Rigidbody components on your GameObjects. This component works with physics. We will first go through several use cases for the Rigidbody component. Once we’ve been through that, we will take some time to explain how we are using physics in our interactions for our project. Finally, we will show the scripting that is used to achieve these interactions in as much detail as possible. As always, the project files on GitHub will follow the structure in the <em class="italic">Readme</em> file. The topics in this chapter include:</p>
<ul>
<li class="bulletList">The Rigidbody component</li>
<li class="bulletList">Collision detection</li>
<li class="bulletList">Design and implementation </li>
<li class="bulletList">Telekinesis and physics</li>
</ul>
<h1 class="heading-1" id="_idParaDest-147">The Rigidbody component</h1>
<p class="normal">This powerful physics-focused<a id="_idIndexMarker414"/> component can be added to GameObjects to determine its position through physics. By default, just adding this component to a GameObject will put its motion under the influence of gravity. To understand how Unity uses physics, let’s take some time to look at the component.</p>
<p class="normal"><em class="italic">Figure 7.1</em> is a screenshot of the Rigidbody in Unity. There is a Rigidbody 2D component. Do not use this component for a 3D application. The primary problem with this is that the 2D and 3D versions of the physics steps do not interact with each other. It’s best to choose one and stick with it! We will go through<a id="_idIndexMarker415"/> all the pieces to the <strong class="screenText">Rigidbody</strong> component after the figure.</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" height="335" src="../Images/B17304_07_01.png" width="697"/></figure>
<p class="packt_figref">Figure 7.1: Rigidbody component</p>
<h2 class="heading-2" id="_idParaDest-148">Mass</h2>
<p class="normal">The <strong class="screenText">Mass</strong> property<a id="_idIndexMarker416"/> of the Rigidbody refers to that object’s relationship to other object’s masses. This will not make gravity affect it differently, but it will affect <a id="_idIndexMarker417"/>collisions with other objects. For example, if two GameObjects that are identical except for their mass on the Rigidbody collide, the item with the larger mass will act as though it’s heavier. Just as in the real world, mass doesn’t cause items to fall faster. This is due to the drag of the objects.</p>
<p class="normal">Drag</p>
<p class="normal">Objects with <strong class="screenText">Drag</strong> will decrease the rate<a id="_idIndexMarker418"/> at which it accelerates due to gravity. An example<a id="_idIndexMarker419"/> of this is a parachute. This object drastically decreases the acceleration of falling. For example, a skydiver has a very low drag, and when they open their parachute, the drag increases a lot. This is regardless of the rotation of the object.</p>
<h2 class="heading-2" id="_idParaDest-149">Angular Drag</h2>
<p class="normal"><strong class="screenText">Angular Drag</strong> is the same concept<a id="_idIndexMarker420"/> as drag; however, it’s specifically focused<a id="_idIndexMarker421"/> on rotation values. If you have a very small value for the angular drag, the object will rotate when bumped or collided with depending on the colliding object’s oncoming angle. If you raise the value, it will rotate less.</p>
<h2 class="heading-2" id="_idParaDest-150">Use Gravity boolean</h2>
<p class="normal">The <strong class="screenText">Use Gravity</strong> boolean simply allows<a id="_idIndexMarker422"/> gravity to affect the GameObject; the Rigidbody is a component<a id="_idIndexMarker423"/> of. As shown in <em class="italic">Figure 7.2</em>, in <strong class="screenText">Edit</strong> &gt; <strong class="screenText">Project Settings</strong> &gt; <strong class="screenText">Physics</strong>, gravity is defined as -<code class="inlineCode">9.81</code>, which is the same as Earth’s gravity. Adjusting the <strong class="screenText">Y</strong> axis gravity setting to -<code class="inlineCode">9.81</code> will be the most familiar to the players in emulating the likeness of Earth’s gravity. If you are working with a game with less gravity and it’s the same all the time, you can set it here. You can also set the gravity in code:</p>
<pre class="programlisting code"><code class="hljs-code">Physics.Gravity = Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,);
</code></pre>
<p class="normal">The 0s should be replaced with the values of gravity that are needed, generally in the <em class="italic">y</em> direction.</p>
<figure class="mediaobject"><img alt="Graphical user interface  Description automatically generated" height="268" src="../Images/B17304_07_02.png" width="705"/></figure>
<p class="packt_figref">Figure 7.2: Project Settings – Physics settings</p>
<h2 class="heading-2" id="_idParaDest-151">Is Kinematic boolean</h2>
<p class="normal">When designing the level, there may be items<a id="_idIndexMarker424"/> that move around that need to affect<a id="_idIndexMarker425"/> the physics of another Rigidbody during runtime. A very simple example you could imagine is a sphere with a Rigidbody above a large cube. When you press play, the sphere would fall and hit the cube as expected. If you had the <strong class="screenText">Is Kinematic</strong> boolean set to false and tried to rotate the cube, the sphere would stay put and clip through the cube. This is due to the cube not updating itself as a moving body after the sphere hit it and stopped. Setting this flag is helpful during an optimization pass, and it can be set for every known static item that still needs to have a Rigidbody component. Although, if you need to update the physics during runtime, set the ground to kinematic and when you rotate it, the sphere will react as expected and try to roll off the sloping downside of the cube.</p>
<p class="normal">This is a very common mistake when you start working with physics items. If during runtime your Rigidbody items aren’t moving in a way you’d expect, check to see if they should be kinematic.</p>
<h2 class="heading-2" id="_idParaDest-152">Interpolate</h2>
<p class="normal"><strong class="screenText">Interpolate</strong> means to place things<a id="_idIndexMarker426"/> in between other things. In our case, we need<a id="_idIndexMarker427"/> to know if interpolating is attempting to achieve one of three parameters in our physics update.</p>
<p class="normal">Those parameters are: </p>
<ul>
<li class="bulletList"><strong class="screenText">None</strong>: Do not interpolate or extrapolate</li>
<li class="bulletList"><strong class="screenText">Interpolate</strong>: Place the object in between the current frame and the next frame</li>
<li class="bulletList"><strong class="screenText">Extrapolate</strong>: Assume the next location from the previous frames and put it where you think it might go</li>
</ul>
<p class="normal">Figuring out the appropriate parameters to interpolate can be complicated to answer. The reason being is that there is more than one option when addressing interpolation, therefore, making the solution not as straightforward to resolve.</p>
<p class="normal">There are multiple variables to account for. These variables may contain these questions such as: How is the camera moving? Is the object moving quickly? Are you worried about the collision looking correct? Are you worried about the object moving incorrectly every time as the camera follows its motion? A simple answer is if your camera follows a character using a Rigidbody, then set it to <strong class="screenText">Interpolate</strong> and everything else to <strong class="screenText">None</strong>.</p>
<p class="normal">Diving into the physics system just a little bit, this system is calculated at a fixed interval, in contrast to graphics rendering. Graphics<a id="_idIndexMarker428"/> on a game can lag slightly and pop<a id="_idIndexMarker429"/> into place, where the physics will always calculate at a fixed interval. This can cause artifacts to visually occur, such as clipping into a wall. Clipping into a wall or other game objects within your scene would be seen if a fast-moving object is being followed closely by the camera and collides with the wall or surrounding GameObjects. The object would initially clip through the wall until the physics gets updated, and it would then update as though it bounced off the wall. </p>
<p class="normal">In this case, you would want to choose the <strong class="screenText">Interpolate</strong> option because the physics system would interpolate the in-between values as the graphics are being rendered. This doesn’t allow clipping while moving in a physics sense. It does cost some performance as it’s calculating values in different intervals than it would normally.</p>
<p class="normal"><strong class="screenText">Extrapolate</strong> does a good job of figuring out what the values will be in the future. This is helpful for simulating a flying object, but not good for collision detection as it will assume it’s past a wall or object and clip at a higher framerate and movement. Movement being followed closely could use <strong class="screenText">Interpolate</strong> or <strong class="screenText">Extrapolate</strong>. </p>
<p class="normal">It’s best to start with <strong class="screenText">Interpolate</strong> and see if it feels good for the movement of your experience. If it feels slow, try <strong class="screenText">Extrapolate</strong>. Weigh the pros and cons of each with a higher speed of movement in your action sequences to determine which interpolate method you need to use.</p>
<p class="normal">Understanding this will allow you to choose the best option for the physics values and the graphical representation of the items you are simulating with physics.</p>
<h2 class="heading-2" id="_idParaDest-153">Collision detection</h2>
<p class="normal">When using physics to determine the position of GameObject, there need to be collision checks to determine<a id="_idIndexMarker430"/> whether your object has collided with another object, regardless of if it’s staying still or moving in the scene. This is an interesting<a id="_idIndexMarker431"/> dilemma now that you’ve learned that physics are fixed, and rendering is not fixed. The physics system can’t assume what every object is using for collision types or interpolation. We need to have several options that would best suit each GameObject’s physics needs from within the experience. There are four different collision detection types to consider: <strong class="screenText">Discrete</strong>, <strong class="screenText">Continuous</strong>, <strong class="screenText">Continuous Dynamic</strong>, and <strong class="screenText">Continuous Speculative</strong>. If you have a GameObject that is moving quickly, it may clip through GameObjects, meaning that it will not know that it has hit a collider and will keep moving through it as the physics is updated. This can be prevented through collision detection modes. Each mode<a id="_idIndexMarker432"/> has different implications on performance; however, the general guideline is that fast objects are set to <strong class="screenText">Continuous Dynamic</strong> while the things they may collide with should be set to <strong class="screenText">Dynamic</strong>. Other options are explained in the breakdown of each choice below.</p>
<p class="normal">Discrete</p>
<p class="normal">This collision detection mode is the best mode for performance, and it’s aptly named <strong class="screenText">Discrete</strong> as it’s only checking<a id="_idIndexMarker433"/> the physics collision at fixed intervals, as mentioned previously. If you have a wall with a box collider and there is a ball moving quickly enough that its known location before the wall wasn’t colliding with it and the next fixed update was past the wall, there is no collision! This can be frustrating at first as it looks like it’s not working, or more frustratingly, it only happens intermittently as the ball may have collided with the wall when you ran the simulation a couple of times. It should be understood why this is happening so you can make different mode choices upon the needs of the physics simulation. The reason for this is that the physics update does not realize that the object was supposed to be affected by anything. The physics loop in <strong class="screenText">Discrete</strong> mode will only check if the object needs to change trajectory once it’s in the loop. If you have a fast-moving object, defined as an object moving more than its height or width in distance per frame, then there may be a point at which this object is past the other object and physics will not know to react to it.</p>
<p class="normal">If there are no fast-moving items, <strong class="screenText">Discrete</strong> is a fantastic choice. If you are planning on having fast-moving objects, then <strong class="screenText">Continuous</strong> is the answer, but please<a id="_idIndexMarker434"/> read about the rest of the options as they all don’t interact with each other intuitively.</p>
<h3 class="heading-3" id="_idParaDest-154">Continuous</h3>
<p class="normal">If you choose <strong class="screenText">Continuous</strong>, you may see that the object<a id="_idIndexMarker435"/> still clips through GameObjects you may not have expected it to. It is very important to understand that <strong class="screenText">Continuous</strong> collision detection only checks if your GameObject is colliding with static objects. This mode is heavy on resources and should be used with caution.</p>
<div class="note">
<p class="normal"><strong class="keyWord">Static objects</strong> are GameObjects that are in the scene<a id="_idIndexMarker436"/> with collider components on them but no Rigidbody component. They are not updated with physics. Upon describing collision detection there will be modes that will only work with static GameObjects.</p>
</div>
<p class="normal">An example of an object that would use <strong class="screenText">Continuous</strong> mode is fast moving GameObjects that need to collide with static items only. The simplest example of this is Pachinko. This is a game where a small metal ball gets dropped from the top of the screen and falls down, hitting static items, bouncing off them. All of the items on the field are static, so there will be no clipping.</p>
<p class="normal">Continuous Dynamic</p>
<p class="normal">This mode is very similar to the <strong class="screenText">Continuous</strong> mode; however, it will also work with GameObjects<a id="_idIndexMarker437"/> that use a Rigidbody component. This is a common usage within game mechanics. As you can imagine, adding the ability to work with the Rigidbody component increases the cost of resources within a game. This is more resource-heavy than the standard continuous mode. </p>
<p class="normal">An example of continuous dynamic is a game you might have played, Smash Hit. This game is a mobile title in which you are a player on rails moving forward. When you tap the screen, a metal ball shoots out towards the location you tapped. If it collides with glass, it shatters. The glass is dynamic and interacts where the ball hits. Those broken pieces are also dynamic and interact with the environment when falling. If it wasn’t dynamic, the ball would go right through the glass. This would make for a much less entertaining game!</p>
<h3 class="heading-3" id="_idParaDest-155">Continuous Speculative</h3>
<p class="normal">The word “speculative” suggests a sense of guessing. The system is speculating if the collision will happen. </p>
<p class="normal">This mode does what <strong class="screenText">Continuous Dynamic</strong> does, and objects with this setting can collide with both static<a id="_idIndexMarker438"/> and dynamic GameObjects; however, it’s cheaper. There is a bit of an accuracy cost, though. Two objects that are flying toward each other may end up bouncing away from each other without even touching if they both have <strong class="screenText">Continuous Speculative</strong> set. This would happen because both objects are speculating where they will be in the next frame, which makes them think they should’ve bounced off each other.</p>
<p class="normal">An example of this is a game called Beat Saber. This is a game<a id="_idIndexMarker439"/> where you’re in VR and you must hit blocks at certain angles to slice them properly. Having your saber’s detection set to <strong class="screenText">Continuous Speculative</strong> will allow you to know that you will hit the blocks that are moving at a high rate towards you.</p>
<p class="normal">Understanding all the modes for collision detection will help you create the right setup for physics-based work. Take time to play with these modes in your own project to get a good sense of how they all work together.</p>
<h2 class="heading-2" id="_idParaDest-156">Constraints</h2>
<p class="normal">Now that we’ve talked about some difficult questions, let’s bring it back to a simpler topic: <strong class="screenText">Constraints</strong>! This does exactly what<a id="_idIndexMarker440"/> you may think it does. If your item should<a id="_idIndexMarker441"/> not move or rotate on a specific axis, you may constrain it. An example of this is a platformer game that has moving platforms. You want them to move but maybe not along a specific axis. To ensure that the platform will not get nudged off course, you can constrain the GameObject in the <em class="italic">x</em>, <em class="italic">y</em>, or <em class="italic">z</em> direction so it will never update in that direction.</p>
<p class="normal">This was the last of the editable fields on the Rigidbody component. The last section is devoted to read-only fields for runtime debugging. Let’s take a look at what information you can gain from these fields.</p>
<h2 class="heading-2" id="_idParaDest-157">Info</h2>
<p class="normal">The <strong class="screenText">Info</strong> block of the Rigidbody component<a id="_idIndexMarker442"/> is essential for working with physics<a id="_idIndexMarker443"/> and debugging the strange behaviours that can come about. Every application may have unique problems that arise. Looking at the <strong class="screenText">Info</strong> object when in play, you can debug what is going on with ease. This section has many values: </p>
<ul>
<li class="bulletList"><strong class="screenText">Speed</strong>: Magnitude of the velocity</li>
<li class="bulletList"><strong class="screenText">Velocity</strong>:  Rate of change of Rigidbody position</li>
<li class="bulletList"><strong class="screenText">Angular Velocity</strong>: Angular velocity vector of the Rigidbody measured in radians per second</li>
<li class="bulletList"><strong class="screenText">Inertia Tensor</strong>: Diagonal matrix in a reference frame positioned at this body’s center of mass and rotated by <strong class="screenText">Inertia Tensor Rotation</strong></li>
<li class="bulletList"><strong class="screenText">Inertia Tensor Rotation</strong>: Rotation of the inertia tensor</li>
<li class="bulletList"><strong class="screenText">Local Center of Mass</strong>: Center of mass relative to the transform’s origin</li>
<li class="bulletList"><strong class="screenText">World Center of Mass</strong>: Center of mass of the Rigidbody in world space</li>
<li class="bulletList"><strong class="screenText">Sleep State</strong>: Optimization strategy to not always account for every object, with two settings:<ul>
<li class="bulletList"><strong class="screenText">Awake</strong>: Physics is considering this Rigidbody</li>
<li class="bulletList"><strong class="screenText">Asleep</strong>: Physics is not considering this Rigidbody</li>
</ul>
</li>
</ul>
<p class="normal">Each of these values above has its unique purposes depending on what you are trying to watch or debug during runtime. Working with the previously mentioned platformer, you may think that your platform should be in the alignment of your character, but something pushed it out of the way just enough<a id="_idIndexMarker444"/> to not allow the character to land on it. With the <strong class="screenText">Info</strong> block, you can watch<a id="_idIndexMarker445"/> the movement or velocity. If there should be no velocity in the <em class="italic">z</em> direction, then looking at that value will let you know if it is working as intended.</p>
<p class="normal">We have a strong idea of how the Rigidbody 3D component works now and can refer to these pages if there are some confusing movements when building physics-focused interactions.</p>
<p class="normal">Design and implementation considerations</p>
<p class="normal">It is very easy to try to add physics to each of your GameObjects to get movement in your interactions. Not every item<a id="_idIndexMarker446"/> specifically needs a Rigidbody to complete its movement in a manner that your interactions need to provide a fantastic experience. At the end of the day, it’s all about frames per second. Try to make any moving item without Rigidbody components, but if they’re needed, then add them.</p>
<h1 class="heading-1" id="_idParaDest-158">Telekinesis and physics interaction</h1>
<p class="normal">For our game’s first puzzle, we focused heavily on making the environment narrative the key interest point. From the moment you walk into the first room, your vision will be placed on the back door, which houses the puzzle’s solution. In the final puzzle, we need to force the player to use more brainpower on figuring out the puzzle instead of finding the answers around them. To do this, we decided<a id="_idIndexMarker447"/> to give the player the power of telekinesis<a id="_idIndexMarker448"/> that Myvari, our character, realizes she has had within her the whole time. We have three steps to get the player to this point of understanding.</p>
<h2 class="heading-2" id="_idParaDest-159">Rocks Falling</h2>
<p class="normal">Telekinesis hasn’t been seen in this game<a id="_idIndexMarker449"/> in any form yet. Some magic came from her necklace, but we need to provide some information to tell the player that she has something in her. A cinematic works well for this. We need to design the interaction.</p>
<h3 class="heading-3" id="_idParaDest-160">Design</h3>
<p class="normal">After finishing the first door puzzle, you encounter a large hallway with old statues of your past. This is a nice look<a id="_idIndexMarker450"/> into the culture of her race’s past. There is nothing to solve here; there’s just a nice walk. Behind the final statue is a tight space to walk through that leads to a cliff path. About halfway along the path, some rocks fall. This triggers a cinematic effect where Myvari defends herself from these falling rocks with her telekinesis. Looking confused, she needs to move forward to find out what is going on. Her adventurous side beckons her to push on.</p>
<h3 class="heading-3" id="_idParaDest-161">Implementation</h3>
<p class="normal">What needs to be implemented<a id="_idIndexMarker451"/> here is in two pieces. One large piece is the cinematic of the rocks and Myvari. Cinematics are when the user doesn’t have power over the interaction. This is helpful for gaining knowledge but shouldn’t be overused because the game can become like an interactive movie. Cinematics should be used with restraint. The second part is physics-based rocks as a secondary motion from the boulder falling.</p>
<p class="normal">The cinematic will be triggered in the same way as previously: we turn off the player’s ability to manipulate Myvari or the camera and transition to the cinematics’ animation while moving the camera to emphasize the object we want, in this case, the boulder. If you need a refresher for this, look at <em class="chapterRef">Chapter 6</em>, <em class="italic">Interactions and Mechanics</em>, during the implementation of the tight spaces.</p>
<p class="normal">The physics-based rocks, however, we can’t just animate. We want them to feel as though they fell on their own. It makes the larger boulder seem like it fell, which helps sell the immersion that this location might be real. </p>
<p class="normal">Even though this shows the telekinesis<a id="_idIndexMarker452"/> coming from Myvari, we need to have the player perform the interaction or else it’s just an ability they can’t use. We will go over the player’s interaction next.</p>
<h2 class="heading-2" id="_idParaDest-162">The Broken Pedestal</h2>
<p class="normal">This is the first time the player<a id="_idIndexMarker453"/> gets to use Myvari’s newfound power. We need to design this puzzle so it’s impossible to miss because the player isn’t used to using this power. This pedestal is a small version of the final puzzle. </p>
<p class="normal">In this micro-puzzle, you need to place the fallen piece onto the pedestal to fix it. We will need to be very careful with how we design this to ensure the player’s experience explains how this works before they touch the interaction button. Let’s run through the design together.</p>
<h3 class="heading-3" id="_idParaDest-163">Design</h3>
<p class="normal">After we make it along the cliff path<a id="_idIndexMarker454"/> and across a small crumbling bridge, the bridge then falls, and the way back is impassable. The only way to go is through a large door. When we walk up to it, it will start opening into a large open cavern, water pooled in the bottom, with ruins in the background and a fall to certain doom. Directly in front of Myvari is a pedestal that is broken, but the broken piece is on the ground close to it. Looking at it, we can see that it is outlined in the same color as the power that protected Myvari from the falling rocks. We will display a UI helper showing which button to press, which we will go over in <em class="chapterRef">Chapter 8</em>, <em class="italic">User Interface and Menus</em>. This will make interaction with her ability tied to a button to provide the player agency. When we press the button, Myvari lifts the broken piece off the ground and fits it onto the pedestal, where it affixes itself and lights up. Pressing the interaction button will then transition the open space into a night scene and some water rises up from below to reveal a pathway to the ruins.</p>
<h3 class="heading-3" id="_idParaDest-164">Implementation</h3>
<p class="normal">We know that the mechanic we want<a id="_idIndexMarker455"/> to include here is a subset of the final puzzle. To do this, we don’t want to write code just for this single item, so instead, we set it up to be a simple standalone using a public enum.</p>
<p class="normal">To keep this as easy to read as possible, we will ask you to take your time reading this section, which is about the final puzzle. We will be explaining some more advanced features and it all builds on itself up to the end. We are using some amazing Unity timing in this code, which will take some explanation, and breaking it up as we’ve done will help you to understand it. So, let’s move on to the final puzzle design, and then we will break down all of the pieces of this and the final puzzle’s implementation.</p>
<h2 class="heading-2" id="_idParaDest-165">The Final Puzzle</h2>
<p class="normal">We’ve made it to the big final puzzle. Luckily, we took<a id="_idIndexMarker456"/> the time to show the player what Myvari gained through stress from the boulder falling toward her. Then we learned how to use it to get here by fixing the broken pedestal. Now we have this puzzle slightly open, but allows the environment to teach the player what they need to do. Let’s dive in to see how we design this last puzzle.</p>
<h3 class="heading-3" id="_idParaDest-166">Design</h3>
<p class="normal">Now that you’ve made it to the ruins, there is some architecture in the background that lights up some<a id="_idIndexMarker457"/> runes on the pillars. This corresponds with some cables on the ground that connect to all the pillars. The puzzle consists of six pillars that connect the power to the main tree, which is in the center of the ruins and has wires connected to it. The wires are only properly connected from three of the pillars. Myvari needs to use her telekinesis to connect the correct pillars following the wires on the ground. Bringing power to the tree opens a small compartment in the tree, which houses a tiara. The tiara is revealed through a cinematic and will end the gameplay of this vertical slice. Now that we have the general idea of what we need to do, let’s move on to implementation.</p>
<h3 class="heading-3" id="_idParaDest-167">Implementation</h3>
<p class="normal">The implementation of this puzzle<a id="_idIndexMarker458"/> is the completion of the telekinesis mechanic. When we wrote this, we allowed ourselves to push into more advanced topics. To ensure this makes sense, we will go over all the topics here and break them down as much as possible. Ensure that you pay attention to the minutiae as there are bits of information here that will seem hidden or counter-intuitive at first.</p>
<p class="normal">Programming topics that we will be covering are:</p>
<ul>
<li class="bulletList">Execution order</li>
<li class="bulletList">Static methods</li>
<li class="bulletList"><code class="inlineCode">UnityAction</code> (delegate)</li>
<li class="bulletList">Coroutines</li>
</ul>
<p class="normal">Let’s first go over the execution<a id="_idIndexMarker459"/> order for Unity. We haven’t spent any time talking about the nitty-gritty of how it works under the hood.</p>
<h4 class="heading-4">Execution order</h4>
<p class="normal">There is an order to the execution<a id="_idIndexMarker460"/> of every frame when in runtime, or playing, inside the editor and opening a build. We would show you a screenshot of the flowchart, but it’s a bit too large. Instead, we will place a link here as well as a Google search term for you to search online to find the website and see this flowchart. I will cover the higher-level topics<a id="_idIndexMarker461"/> here and the reason why they matter within each portion that they affect. </p>
<p class="normal"><a href="https://docs.unity3d.com/Manual/ExecutionOrder.xhtml"><span class="url">https://docs.unity3d.com/Manual/ExecutionOrder.xhtml</span></a></p>
<p class="normal">Google search term: <code class="inlineCode">Unity Execution Order</code></p>
<p class="normal">The major concept here is that there has to be a hierarchy of execution of certain bits of information. We needed to have a strong think about this to have a baseline of what will be dealt with at each frame. The uncomfortable truth is that there is a lot to think about. Here is the list in chronological form with highest-level terminology for the execution order, with a small snippet of information on each of them:</p>
<ul>
<li class="bulletList"><strong class="screenText">Initialization</strong>: This is for <code class="inlineCode">Awake</code> and <code class="inlineCode">onEnable</code> only.</li>
<li class="bulletList"><strong class="screenText">Editor</strong>: Reset when scripts are added and not in play mode.</li>
<li class="bulletList"><strong class="screenText">Initialization</strong>: The second part of initialization is for the <code class="inlineCode">Monobehaviour</code> method <code class="inlineCode">Start</code> only.</li>
<li class="bulletList"><strong class="screenText">Physics</strong>: This is where all physics updates will happen. It can potentially be run more than once per frame if the fixed time step is set higher than the frame update time.</li>
<li class="bulletList"><strong class="screenText">Input Events</strong>: Any non-update focused input, such as <code class="inlineCode">OnMouseDown</code>.</li>
<li class="bulletList"><strong class="screenText">Game Logic</strong>: Update, coroutine logic and yielding, animation events, write properties, and <code class="inlineCode">LateUpdate</code> run in here. These will be more apparent during implementation of the game logic further in the chapter.</li>
<li class="bulletList"><strong class="screenText">Scene Rendering</strong>: Many scene-rendering functions run here in every frame to deal with culling objects from the camera, visible objects, and post rendering. We will not be breaking this down heavily, if you are curious, please read into the execution order manual for more information.</li>
<li class="bulletList"><strong class="screenText">Gizmo Rendering</strong>: Specifically, the <code class="inlineCode">OnDrawGizmo</code> method of the Unity Editor.</li>
<li class="bulletList"><strong class="screenText">GUI Rendering</strong>: The <code class="inlineCode">OnGui</code> method, which can run multiple times per frame.</li>
<li class="bulletList"><strong class="screenText">End of Frame</strong>: Allows coroutines to be paused or yielded at the end of the frame, waiting for all of the rest to finish before starting again at the top of game logic section.</li>
<li class="bulletList"><strong class="screenText">Pausing</strong>: When the application has been paused; before the application is paused, a single frame is run.</li>
<li class="bulletList"><strong class="screenText">Decommissioning</strong>: Cleans up memory with <code class="inlineCode">OnApplicationQuit</code>, <code class="inlineCode">OnDisable</code>, and <code class="inlineCode">OnDestroy</code> in that order.</li>
</ul>
<p class="normal">Before we move on to the next<a id="_idIndexMarker462"/> section, there is something you need to make sure you understand. You do not, by any means, need to understand all of the preceding list. There is a lot to learn there, and if you go to the execution order documentation you will see every method that is listed in more detail. We will be showing portions of the execution and explaining what is affecting our code during the rest of this chapter.</p>
<p class="normal">The key takeaway from the chronological list of higher-level sections being listed is that Unity has an order. That’s a relieving concept to wrap your head around as a developer. When you get confused about why something is happening the way it is, you can rely on this to see if it’s an execution order problem that you might be running into. </p>
<p class="normal">During the next sections, we will have images of the section of the execution order we had to pay attention to. This will allow you to see how it can be used for your future development work.</p>
<p class="normal">Now that we’ve looked at the execution order, we should get into the code. We are using three scripts to make this work with the telekinesis mechanics:</p>
<ul>
<li class="bulletList"><code class="inlineCode">PhysicsPuzzleTrigger.cs</code></li>
<li class="bulletList"><code class="inlineCode">PhysicsPuzzlePiece.cs</code></li>
<li class="bulletList"><code class="inlineCode">FinalPuzzle.cs</code></li>
</ul>
<p class="normal"><code class="inlineCode">PhysicsPuzzleTrigger.cs</code> has two pieces of code that are important to know about first: the <code class="inlineCode">PhysicsPuzzleTrigger</code> class and the <code class="inlineCode">PhysicsPuzzlePieceType</code> enum. We will tackle the <code class="inlineCode">PhysicsPuzzlePieceType</code> first as it’s much easier to get into than the trigger. We have an enum that allows us to choose<a id="_idIndexMarker463"/> which puzzle piece type it is on the GameObject. We define this as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> PhysicsPuzzlePieceType
{
    First = <span class="hljs-number">0</span>,
    Second,
    Third,
    Intro,
    Any
}
</code></pre>
<p class="normal">Then, in the <code class="inlineCode">PhysicsPuzzlePiece.cs</code> script, we implement it as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PhysicsPuzzlePiece</span> : <span class="hljs-title">MonoBehaviour</span>
{
    <span class="hljs-keyword">public</span> PhysicsPuzzlePieceType pieceType;
}
</code></pre>
<p class="normal">When we add the <code class="inlineCode">PhysicsPuzzlePiece.cs</code> script to any GameObject, we then get a dropdown to choose which type it is. This is very useful when you want explicit items to fit together. We’re using this to use the same mechanics but allow for different puzzle types. </p>
<p class="normal">We said in <em class="italic">The Broken Pedestal</em> section above that we would explain it within the implementation of the entire mechanic. What we do is allow the <code class="inlineCode">Intro</code> option to be aligned with this mechanic and be explicit for that action. Even though it’s impossible to get the final puzzle pieces in that location, this is a great practice to ensure data is consistent with your code.</p>
<p class="normal">Let’s get back into the <code class="inlineCode">PhysicsPuzzleTrigger.cs</code> code. We start off by declaring the fields we’re used to working with so far, but then on line 12, there is something unique that has two concepts we need to go over. This is the use of <code class="inlineCode">static</code> and <code class="inlineCode">UnityAction</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UnityAction&lt;PhysicsPuzzleTrigger, PhysicsPuzzlePiece&gt; OnPieceSlotted;
</code></pre>
<p class="normal">We’re going to break out of describing exactly what we’re doing with this line to explain the context of what both <code class="inlineCode">static</code> and <code class="inlineCode">UnityAction</code> are. After we do that, we will then proceed to how we are using them in this code for this mechanism.</p>
<h4 class="heading-4">Static methods</h4>
<p class="normal">A static method, field, property, or event is callable<a id="_idIndexMarker464"/> on any class that is within the namespace without needing the <code class="inlineCode">using</code> directive or inheritance. Let’s say you have one script that has a field as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StaticTest</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> StaticInt = <span class="hljs-number">10</span>;
}
</code></pre>
<p class="normal">You could then have another script in the same project that, without specifically calling for that script when using or inheriting it, could access it like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UseStaticTest</span>
{
    <span class="hljs-built_in">int</span> BaseNumber = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">int</span> NewNumber = BaseNumber + StaticTest.StaticInt;
}
</code></pre>
<p class="normal">This may not look very useful by itself, but the concept is the important part to take away at this time. <code class="inlineCode">Static</code> members of a class can be accessed by other classes by just using the class name before the required member.</p>
<p class="normal">An example of this being used commonly is keeping a count of something as the <code class="inlineCode">static</code> field has only one instance. We’re using it to store a <code class="inlineCode">UnityAction</code>. We need to go over that next before we get into how we are using these directly.</p>
<h4 class="heading-4">UnityActions</h4>
<p class="normal">A <code class="inlineCode">UnityAction</code> is a Unity-specific delegate. A delegate in C# is a sort of generic concept of a method that has a parameter<a id="_idIndexMarker465"/> list which also returns a specific type. Interestingly, a <code class="inlineCode">UnityAction</code> returns <code class="inlineCode">void</code> by default. A common way of explaining delegates is through the concept of the subscribe model. This means that the delegate is looking for methods to be attached to it and when something uses the delegate, it will try to run the methods attached as long as the methods are returning the same type. This is a bit abstract, so let’s look at an example. We will be using the <code class="inlineCode">UnityAction MathAction</code> to add to how many times a button is pressed and then see if that new number is even or odd:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> UnityEngine.UI;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnityActionTest</span> : <span class="hljs-title">MonoBehaviour</span>
{
    <span class="hljs-keyword">public</span> Button AddButton;
    <span class="hljs-keyword">private</span> UnityAction MathAction;
    <span class="hljs-built_in">float</span> TimesClicked;
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Start</span><span class="hljs-function">()</span>
    {
        AddButton = GetComponent&lt;Button&gt;();
        MathAction += AddOne;
        MathAction += CheckEven;
        AddButton.onClick.AddListener(MathAction);
    }
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">AddOne</span><span class="hljs-function">()</span>
    {
        TimesClicked++;
        Debug.Log(<span class="hljs-string">"Clicked count : "</span> + TimesClicked);
    }
    <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">CheckEven</span><span class="hljs-function">()</span>
    {
        <span class="hljs-keyword">if</span> (TimesClicked % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
        {
            Debug.Log(<span class="hljs-string">"This click was even!"</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            Debug.Log(<span class="hljs-string">"ThIs ClIcK WaS OdD."</span>);
        } 
    }
}
</code></pre>
<p class="normal">We’re using the <code class="inlineCode">Button</code> class, so ensure to import <code class="inlineCode">UnityEngine.UI</code> so we can use buttons from that class. Following the lines<a id="_idIndexMarker466"/> down, we made a new <code class="inlineCode">UnityAction</code> named <code class="inlineCode">MathAction</code>. On <code class="inlineCode">Start</code>, we grabbed the button so we could add logic to it. Then we attached the <code class="inlineCode">AddOne</code> and <code class="inlineCode">CheckEven</code> methods to <code class="inlineCode">UnityAction</code>. The <code class="inlineCode">+=</code> that you see is <code class="inlineCode">MathAction</code> attaching itself to those methods in order.</p>
<div class="note">
<p class="normal">Addition assignment operator – we’re using a special “syntactic sugar” to make the code a bit cleaner to read and less redundant. The addition assignment operator looks like this:</p>
</div>
<pre class="programlisting code"><code class="hljs-code">MathAction += AddOne
</code></pre>
<div class="note">
<p class="normal">Written another way is:</p>
</div>
<pre class="programlisting code"><code class="hljs-code">MathAction = MathAction + AddOne;
</code></pre>
<p class="normal">You then see that we assigned <code class="inlineCode">UnityAction</code> to the button’s listener. When you press the button, both of these functions<a id="_idIndexMarker467"/> will be running because <code class="inlineCode">UnityAction</code> is assigned to both of them.</p>
<p class="normal">Before we can go further into the code, we need to cover one more topic, coroutines. </p>
<p class="normal">Coroutines</p>
<p class="normal">A coroutine allows you to spread<a id="_idIndexMarker468"/> a task over multiple frames. This is not a form of multithreading. Every action is still being run on the main thread. The power of coroutines is that they allow directable pausing through a new term, <code class="inlineCode">yield</code>. Taking a look at the execution order in the figure below, you may remember seeing <strong class="screenText">yield null</strong> after <strong class="screenText">Update</strong> in the <strong class="screenText">Game Logic</strong> section. If you don’t have the execution order up on a browser tab, look at <em class="italic">Figure 7.3</em>. The small note on the left says it nicely. If a coroutine previously yielded or paused, and it’s due to resume, it will resume at that point in the execution order.</p>
<figure class="mediaobject"><img alt="Graphical user interface  Description automatically generated" height="189" src="../Images/B17304_07_03.png" width="717"/></figure>
<p class="packt_figref">Figure 7.3: Game logic of the execution order</p>
<p class="normal">That’s awesome, isn’t it? How does it know to resume, you ask? Good question, reader. It knows that it should resume<a id="_idIndexMarker469"/> because of the logic in the code. There is a fantastic example from the Unity Docs going over a basic fade from opaque to transparent using a coroutine. Let’s go through it quickly:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Update</span><span class="hljs-function">()</span>
{
    <span class="hljs-keyword">if</span> (Input.GetKeyDown(<span class="hljs-string">"f"</span>))
    {
        StartCoroutine(Fade());
    }
}
<span class="hljs-function">IEnumerator </span><span class="hljs-title">Fade</span><span class="hljs-function">()</span>
{
    Color c = renderer.material.color;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">float</span> alpha = <span class="hljs-number">1f</span>; alpha &gt;= <span class="hljs-number">0</span>; alpha -= <span class="hljs-number">0.1f</span>)
    {
        c.a = alpha;
        renderer.material.color = c;
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
}
</code></pre>
<p class="normal">I put in bold the three things that may be new to you. <code class="inlineCode">StartCoroutine(Fade())</code> is asking the application to start a coroutine with the <code class="inlineCode">Fade</code> method. You will start the coroutine during the start of the game logic <a id="_idIndexMarker470"/>at the bottom of the <code class="inlineCode">yield</code> statements; refer to <em class="italic">Figure 7.3</em> again for this.</p>
<p class="normal"><code class="inlineCode">IEnumerator</code> is stating that this method is iterable. Remember back to the last time you made a method. The keyword before the name is the type. We use <code class="inlineCode">void</code> if it returns nothing, but since this will be iterated on, it needs to know. We let the computer know this by adding <code class="inlineCode">IEnumerable</code> as the return type.</p>
<p class="normal">The last part is <code class="inlineCode">yield</code> <code class="inlineCode">return null</code>. This is tricky the first time looking over the <code class="inlineCode">for</code> loop. In most cases, a <code class="inlineCode">return</code> will take you out of a loop, but since we have a <code class="inlineCode">yield</code> there, Unity asks if we’ve finished with everything in the method. It pauses after subtracting 0.1f from the current alpha and waits for the game logic portion to start again to do it again until it satisfies the <code class="inlineCode">for</code> loop logic. Once that is completed, it no longer yields.</p>
<p class="normal">Summarizing this code, pressing <em class="keystroke">F</em> will fade the GameObject this script is on out from the scene. We think you have a good enough grasp of these concepts. Let’s get back to the code in our project to finish up our implementation.</p>
<h4 class="heading-4">Back to the code</h4>
<p class="normal">OK…we took a little aside to explain some<a id="_idIndexMarker471"/> key concepts, but we’re back now. Let’s open <code class="inlineCode">PhysicsPuzzleTrigger.cs</code> back up. The concept here is that you have telekinesis and when you move an item close to its trigger volume, it will then, on its own, move into place over a transitional period we define. We’ve seen <code class="inlineCode">OnTriggerEnter</code> previously, so that isn’t surprising with a volume trigger. We do want it to move on its own, so we need to disable a bunch of fields of the Rigidbody and disable the collider. This is done on lines 28-33 in <code class="inlineCode">PhysicsPuzzleTrigger.cs</code>.</p>
<p class="normal">Now, this is where we get to see new code. We need to set up the references to where the items need to transition from and to as this script is on several GameObjects, so we need to reference their relative positions.</p>
<p class="normal">Then we start the coroutine on line 40.</p>
<pre class="programlisting code"><code class="hljs-code">StartCoroutine(TransitionTween());
</code></pre>
<p class="normal">We have some code for changing the color of the trigger; this is temporary for debugging.</p>
<p class="normal">Then we have a <code class="inlineCode">tween</code> loop, which is an animation term for “between” which means the change in movement in our case. We have our <code class="inlineCode">while</code> loop running for as long as <code class="inlineCode">tweenDuration</code> is set to, normalized<a id="_idIndexMarker472"/> from how long it has been from the start. This is defined as <code class="inlineCode">delta</code>. We then Lerp the position and Slerp the rotation to the transform we want it to end with: </p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">while</span> (Time.time - tweenStart &lt; tweenDuration)
        {
            <span class="hljs-built_in">float</span> delta = (Time.time - tweenStart) / tweenDuration;
            tweenPiece.position = Vector3.Lerp(tweenStartPos, transform.position, delta);
            tweenPiece.eulerAngles = Vector3.Slerp(tweenStartRot, transform.eulerAngles, delta);
            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
</code></pre>
<p class="normal">Finally, we see the <code class="inlineCode">yield</code> <code class="inlineCode">return null</code>!</p>
<p class="normal">We’re now paused until the next game logic loop unless <code class="inlineCode">tweenDuration</code> is complete and we don’t enter the <code class="inlineCode">while</code> loop, which means we have completed the <code class="inlineCode">tween</code>. We set the position and angles on line 61 for the moving piece to ensure the transform is ready to be referenced in our <code class="inlineCode">UnityAction</code>. </p>
<pre class="programlisting code"><code class="hljs-code">tweenPiece.position = transform.position;
tweenPiece.eulerAngles = transform.eulerAngles;
OnPieceSlotted?.Invoke(<span class="hljs-keyword">this</span>,tweenPiece.GetComponent&lt;PhysicsPuzzlePiece&gt;());
</code></pre>
<p class="normal">Now, we move into our <code class="inlineCode">UnityAction</code>:</p>
<pre class="programlisting code"><code class="hljs-code">OnPieceSlotted?.Invoke(<span class="hljs-keyword">this</span>, tweenPiece.GetComponent&lt;PhysicsPuzzlePiece&gt;());
</code></pre>
<p class="normal">This looks interesting. Why is there a question mark there? There<a id="_idIndexMarker473"/> is a conditional operator called a “null condition operator”, which asks if <code class="inlineCode">OnPieceSlotted</code> is <code class="inlineCode">null</code> or not before performing the following method. This is another syntactical sugar. You could get the same result by making an <code class="inlineCode">if</code> statement checking if <code class="inlineCode">OnPieceSlotted</code> is <code class="inlineCode">null</code>.</p>
<p class="normal">In the case of <code class="inlineCode">UnityAction</code>, this is saying something very specific. It’s asking if anything has been attached to this action. </p>
<p class="normal">If there is a method assigned to this <code class="inlineCode">UnityAction</code>, then please call whatever function is assigned with the following arguments; the <code class="inlineCode">this</code> GameObject and the <code class="inlineCode">tweenPiece</code> as the <code class="inlineCode">PhysicsPuzzlePiece</code> type.</p>
<p class="normal">This is where some magic happens. Remember that we assigned <code class="inlineCode">OnPieceSlotted</code> to be a static member of the <code class="inlineCode">PhysicsPuzzleTrigger</code> class? Well, open up <code class="inlineCode">FinalPuzzle.cs </code>and let’s show the power of static members.</p>
<p class="normal">On <code class="inlineCode">Start</code>, we add a local function named <code class="inlineCode">OnPieceSlotted</code> to the static <code class="inlineCode">UnityAction</code> from <code class="inlineCode">PhysicsPuzzleTrigger.OnPieceSlotted</code>. We know that when our player puts an object into the right position, by the end <a id="_idIndexMarker474"/>of the coroutine it needs to update which object it was. Was it the final puzzle or the intro puzzle? We defined that through our enum on <code class="inlineCode">PuzzlePieceType</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnPieceSlotted</span><span class="hljs-function">(</span><span class="hljs-params">PhysicsPuzzleTrigger trigger, PhysicsPuzzlePiece piece</span><span class="hljs-function">)</span>
    {
        <span class="hljs-keyword">if</span> (piece.pieceType == PhysicsPuzzlePieceType.Intro)
        {
            Debug.Log(<span class="hljs-string">"FINAL PUZZLE INTRO SOLVED. Trigger environment transition here"</span>);
            tempBridge.SetActive(<span class="hljs-literal">true</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            numPiecesSlotted += <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (numPiecesSlotted &gt;= <span class="hljs-number">3</span>)
            {
                Debug.Log(<span class="hljs-string">"FINAL PUZZLE SOLVED! Trigger portal event"</span>);
            }
        }
    }
</code></pre>
<p class="normal">This local method being run from <code class="inlineCode">UnityAction</code> gives us the trigger and <code class="inlineCode">piece</code> tells us if we have finished the intro puzzle or if we have worked on the final puzzle. We can use any script later on in the game for this specific mechanic as it’s static and available to us. Static is not only fun with socks on the carpet shocking your siblings. It’s also magic in programming!</p>
<p class="normal">We just did some intermediate-level Unity programming. These tools are usable in so many situations, but they aren’t always easy to think about as the first option to the answer of your problem. Take your time and work through each section. Make some coroutines with GameObjects. See if you can make your own <code class="inlineCode">UnityAction</code> within one script, as we showed above. Test static methods and see how they work, and in time these tools will become<a id="_idIndexMarker475"/> natural to you when developing your games.</p>
<h1 class="heading-1" id="_idParaDest-168">Summary</h1>
<p class="normal">What a jam-packed chapter! We went over a lot, so I think we need a small summary here. The concept of physics is already a tough subject to tackle. We’re using it for simulation in games on a small scale. We went over the Rigidbody component in its entirety and then dove deep into some brand-new C# work. For C#, we went over:</p>
<ul>
<li class="bulletList">Execution order</li>
<li class="bulletList">Static methods</li>
<li class="bulletList"><code class="inlineCode">UnityAction</code> (delegate)</li>
<li class="bulletList">Coroutines</li>
</ul>
<p class="normal">All these new concepts are tools to use on your next project. Take as much time as needed to digest these concepts. You will see them used in almost every project that you work with.</p>
<p class="normal">In the next chapter, we need to add menu systems and a user interface so that the user can have more context for the gameplay.</p>
</div>
</div></body></html>