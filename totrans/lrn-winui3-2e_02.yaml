- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Configuring the Development Environment and Creating the Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置开发环境并创建项目
- en: To get started with WinUI and Windows App SDK development, it is important to
    install and configure Visual Studio for Windows desktop development. A WinUI developer
    must also understand the basics of applicationdevelopment with **Extensible Application
    Markup Language** (**XAML**) and C#, which we started learning in [*Chapter 1*](B20908_01.xhtml#_idTextAnchor015),
    *Introduction to WinUI*. However, the best way to understand the development concept
    is to get your hands on a real project. We will do that in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 WinUI 和 Windows App SDK 进行开发，安装和配置 Visual Studio 以进行 Windows 桌面开发非常重要。WinUI
    开发者还必须了解使用 **可扩展应用程序标记语言**（**XAML**）和 C# 进行应用程序开发的基础，这些内容我们在 [*第 1 章*](B20908_01.xhtml#_idTextAnchor015)
    *WinUI 简介* 中开始学习。然而，理解开发概念的最佳方式是亲自动手处理一个真实的项目。我们将在本章中这样做。
- en: After setting up your Visual Studio development environment, you will create
    the beginnings of a project that we will be building throughout the rest of the
    book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置您的 Visual Studio 开发环境后，您将创建本书其余部分将构建的项目的基础。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您将学习以下主题：
- en: How to set up a new Visual Studio installation for Windows desktop application
    development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为 Windows 桌面应用程序开发设置新的 Visual Studio 安装
- en: How to create a new WinUI project, add a few controls, and run the project for
    the first time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建新的 WinUI 项目，添加一些控件，并首次运行项目
- en: The anatomy of a new WinUI project and why each part is important
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 WinUI 项目的结构及其每个部分的重要性
- en: How XAML can be used to build flexible, performant **user** **interfaces** (**UIs**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 XAML 构建灵活、高效的 **用户界面**（**UI**）
- en: How WinUI fits with .NET and the role of each layer in the overall application
    architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinUI 如何与 .NET 结合以及每个层在整体应用程序架构中的作用
- en: How to work with WinUI controls and customize them through changes in the XAML
    markup or C# code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 WinUI 控件并通过更改 XAML 标记或 C# 代码来自定义它们
- en: How to handle some basic UI events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理一些基本的 UI 事件
- en: If you are new to WinUI and other XAML-based development platforms, by the end
    of this chapter, you should be starting to feel comfortable working with WinUI
    projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 WinUI 和其他基于 XAML 的开发平台的初学者，到本章结束时，您应该开始感到舒适地使用 WinUI 项目。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    required:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，需要以下软件：
- en: Windows 10, version 1809 (build 17763) or newer or Windows 11
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10 版本 1809（构建 17763）或更高版本或 Windows 11
- en: Visual Studio 2022 version 17.1 or later with the **.NET desktop development**
    workload and **Windows App SDK C# Templates** selected during installation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Visual Studio 2022 版本 17.1 或更高版本，并在安装过程中选择 **.NET 桌面开发** 工作负载和 **Windows
    App SDK C# 模板**
- en: 'The source code for this chapter is available on GitHub at this URL: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter02).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在 GitHub 上通过此 URL 获取：[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter02)。
- en: Installing Visual Studio and Windows desktop development workloads
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Visual Studio 和 Windows 桌面开发工作负载
- en: The first step to follow when starting with WinUI development is to install
    Microsoft’s Visual Studio **integrated development environment** (**IDE**). You
    can download the current version of Visual Studio 2022 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
    Visual Studio 2022 Community Edition is free for personal use and has all the
    features you will need to build WinUI applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开始 WinUI 开发时需要遵循的第一个步骤是安装微软的 Visual Studio **集成开发环境**（**IDE**）。您可以从 [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
    下载 Visual Studio 2022 的当前版本。Visual Studio 2022 社区版对个人用户免费，并包含您构建 WinUI 应用程序所需的所有功能。
- en: Tip
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to try new Visual Studio features before they are released, you
    can install the latest Visual Studio Preview version from [https://visualstudio.microsoft.com/vs/preview/](https://visualstudio.microsoft.com/vs/preview/).
    The Preview version is not recommended for the development of production applications
    as some features are unstable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在它们发布之前尝试新的 Visual Studio 功能，您可以从 [https://visualstudio.microsoft.com/vs/preview/](https://visualstudio.microsoft.com/vs/preview/)
    安装最新的 Visual Studio 预览版本。预览版本不建议用于生产应用程序的开发，因为一些功能可能不稳定。
- en: 'During installation, you can select workloads for any type of application that
    you want to create. For WinUI development, you must start by selecting the **.NET
    desktop development** workload. An overview of the **Workloads** section is shown
    in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，您可以选择创建任何类型应用程序的工作负载。对于WinUI开发，您必须首先选择**.NET桌面开发**工作负载。以下截图显示了**工作负载**部分的概述：
- en: '![Figure 2.1 – Visual Studio Installer workload selection](img/B20908_02_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – Visual Studio 安装程序工作负载选择](img/B20908_02_01.jpg)'
- en: Figure 2.1 – Visual Studio Installer workload selection
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Visual Studio 安装程序工作负载选择
- en: After the **.NET desktop development** workload has been selected, select the
    **Windows App SDK C# Templates** component from the **Installation details** pane.
    These templates, required for building WinUI apps, are not installed by default
    with the workload.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择**.NET桌面开发**工作负载后，从**安装详情**面板中选择**Windows App SDK C# 模板**组件。这些模板，用于构建WinUI应用程序，默认情况下不会与工作负载一起安装。
- en: '![Figure 2.2 – Selecting the Windows App SDK C# Templates component for installation](img/B20908_02_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 选择安装Windows App SDK C# 模板组件](img/B20908_02_02.jpg)'
- en: Figure 2.2 – Selecting the Windows App SDK C# Templates component for installation
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 选择安装Windows App SDK C# 模板组件
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are a C++ developer and would like to build WinUI apps with C++, you
    must select the **Desktop development with C++** workload and the optional **Windows
    App SDK C++ Templates** component within the **Desktop development with C++**
    workload. However, building WinUI applications with C++ is beyond the scope of
    this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是C++开发者并且想使用C++构建WinUI应用程序，您必须选择**使用C++进行桌面开发**工作负载，并在**使用C++进行桌面开发**工作负载内选择可选的**Windows
    App SDK C++ 模板**组件。然而，使用C++构建WinUI应用程序超出了本书的范围。
- en: When continuing to the next step, the Visual Studio Installer will download
    and install all selected workloads and components. When setup is complete, launch
    Visual Studio. The first time you run Visual Studio, you will be prompted to sign
    in with a Microsoft account. Linking Visual Studio to your account will enable
    Visual Studio to sync your settings, link any available licenses, and link your
    Microsoft Store account after it has been created. We will discuss more about
    the Microsoft Store and application distribution in [*Chapter 14*](B20908_14.xhtml#_idTextAnchor582),
    *Packaging and Deploying* *WinUI Applications*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到下一步时，Visual Studio 安装程序将下载并安装所有选定的工作负载和组件。设置完成后，启动Visual Studio。第一次运行Visual
    Studio时，您将被提示使用Microsoft账户登录。将Visual Studio链接到您的账户将使Visual Studio能够同步您的设置，链接任何可用的许可证，并在创建后链接您的Microsoft
    Store账户。我们将在[*第14章*](B20908_14.xhtml#_idTextAnchor582) *打包和部署* *WinUI应用程序* 中讨论更多关于Microsoft
    Store和应用程序分发的内容。
- en: Now, it’s time to start building our WinUI application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始构建我们的WinUI应用程序了。
- en: Introducing the application idea
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍应用程序想法
- en: The application we’re going to build is a tool called **My Media Collection**.
    It’s a simple utility that can catalog your entire media library. Because digital
    media is becoming more popular as time goes on, we can design the application
    to support the inclusion of both physical and digital media. The application will
    be able to catalog different types of media, including music, video, and books.
    We’ll add some features that will only light up for certain media types. Physical
    media (books, DVDs, and CDs) are often loaned to friends. This application will
    help you remember who borrowed your favorite book at a recent family party.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序是一个名为**我的媒体收藏**的工具。这是一个简单的实用程序，可以编目您的整个媒体库。由于随着时间的推移，数字媒体变得越来越受欢迎，我们可以设计应用程序以支持包含实体和数字媒体。应用程序将能够编目不同类型的媒体，包括音乐、视频和书籍。我们将添加一些仅对特定媒体类型生效的功能。实体媒体（书籍、DVD和CD）通常会被借给朋友。这个应用程序将帮助您记住在最近的家庭聚会上谁借走了您最喜欢的书。
- en: Reviewing the application features
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查应用程序功能
- en: 'Before we dive in and create the new project, let’s get organized. It helps
    to understand what you’re going to build so that you can track your progress while
    progressing through each chapter. If you’re tracking your development on GitHub,
    you could create an **Issue** for each feature. Let’s start with a high-level
    look at the application’s features, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入创建新项目之前，让我们先做好组织工作。了解您将要构建的内容，这样您可以在通过每一章进行时跟踪您的进度。如果您在GitHub上跟踪您的开发，您可以为每个功能创建一个**问题**。让我们从对应用程序功能的高级概述开始，如下所示：
- en: View all media
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看所有媒体
- en: 'Filter the media library by the following: **Media Type** (**Music**, **Video**,
    or **Book**), **Medium** (the available choices will vary by media type but will
    include **CD**, **Record**, **DVD**, **Blu-Ray**, **Hardcover**, **Paperback**,
    **Digital**), or **Location** (**In Collection** or **Loaned**)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据以下条件过滤媒体库：**媒体类型**（**音乐**、**视频**或**书籍**）、**介质**（根据媒体类型的不同，可用的选项将有所不同，但将包括**CD**、**唱片**、**DVD**、**蓝光**、**精装本**、**平装本**、**数字**）或**位置**（**在收藏中**或**已借出**）
- en: Add a new media item
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的媒体项目
- en: Edit a media item
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑媒体项目
- en: Mark an item as loaned or returned
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记项目为已借出或已归还
- en: Application sign-in
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序登录
- en: Back up (or restore) the collection data with OneDrive
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OneDrive 备份（或还原）集合数据
- en: 'The application will use features of the **Windows Community Toolkit**, which
    can simplify things such as Microsoft account authentication and file access on
    OneDrive. You can read more about the toolkit on Microsoft Learn: [https://learn.microsoft.com/dotnet/communitytoolkit/windows/](https://learn.microsoft.com/dotnet/communitytoolkit/windows/).
    The application’s data will be stored in a local **SQLite** database, allowing
    for online or offline access to the media collection. You’ll even be able to send
    email reminders if one of your friends is taking a little too long in returning
    one of the items in your collection.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用**Windows Community Toolkit**的功能，这些功能可以简化诸如 Microsoft 帐户身份验证和 OneDrive
    上的文件访问等问题。您可以在 Microsoft Learn 上了解更多关于工具包的信息：[https://learn.microsoft.com/dotnet/communitytoolkit/windows/](https://learn.microsoft.com/dotnet/communitytoolkit/windows/)。应用程序的数据将存储在本地**SQLite**数据库中，允许在线或离线访问媒体集合。您甚至可以发送电子邮件提醒，如果您的朋友在归还您收藏品中的某件物品时花费了太多时间。
- en: WinUI in Desktop projects
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桌面 WinUI 项目
- en: In this chapter, we will be building a Windows App SDK application with the
    **WinUI in Desktop** project template. A **WinUI in Desktop** project targets
    the .NET runtime while using the same XAML schema as a UWP project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**桌面 WinUI**项目模板构建一个 Windows App SDK 应用程序。一个**桌面 WinUI**项目针对 .NET
    运行时，同时使用与 UWP 项目相同的 XAML 架构。
- en: A **WinUI in Desktop** project also includes a **Windows Application Packaging**
    project in the newly created solution. We will learn more about packaging WinUI
    applications in [*Chapter 14*](B20908_14.xhtml#_idTextAnchor582), *Packaging and
    Deploying WinUI Applications*. Now, let’s get started with our first project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**桌面 WinUI**项目还包括一个在新建解决方案中的**Windows 应用程序打包**项目。我们将在[*第 14 章*](B20908_14.xhtml#_idTextAnchor582)“打包和部署
    WinUI 应用程序”中了解更多关于打包 WinUI 应用程序的内容。现在，让我们开始我们的第一个项目。'
- en: Creating your first WinUI project
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个 WinUI 项目
- en: 'It’s time to start building the project. To do so, proceed as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始构建项目了。为此，请按照以下步骤操作：
- en: 'Launch Visual Studio, and from the opening screen, select **Create a new project**,
    as illustrated in the following screenshot:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio，然后从打开屏幕中选择**创建新项目**，如图所示：
- en: '![Figure 2.3 – The initial Visual Studio dialog](img/B20908_02_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 初始 Visual Studio 对话框](img/B20908_02_03.jpg)'
- en: Figure 2.3 – The initial Visual Studio dialog
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 初始 Visual Studio 对话框
- en: 'On the `winui` in the **Search for templates** field, select the **Blank App,
    Packaged (WinUI 3 in Desktop)** C# template, and click **Next**, as illustrated
    in the following screenshot:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**搜索模板**字段中的`winui`，选择**空白应用，打包（桌面 WinUI 3）**C#模板，然后点击**下一步**，如图所示：
- en: '![Figure 2.4 – Selecting the project template](img/B20908_02_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 选择项目模板](img/B20908_02_04.jpg)'
- en: Figure 2.4 – Selecting the project template
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 选择项目模板
- en: Tip
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Be sure to select the **C#** project template and not **C++**. You can filter
    the project types to show only C# projects by changing the **Language** filter
    from **All languages** to **C#**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保选择**C#**项目模板，而不是**C++**。您可以通过将**语言**过滤器从**所有语言**更改为**C#**来过滤项目类型，以仅显示 C#
    项目。
- en: Name the project `MyMediaCollection`, leave the rest of the fields set to their
    default values, and click **Create**. You may be prompted to select the Windows
    versions to target with your app. You can leave these set to their default values
    for this project.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`MyMediaCollection`，其余字段保留默认值，然后点击**创建**。您可能需要选择要针对您的应用程序的 Windows 版本。对于此项目，您可以保留这些设置为默认值。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is up to you whether you want to change these versions for your app, but
    you will be limiting the versions of Windows that can install your app. If you
    are using a control or feature that you know is only available in specific versions
    of Windows, you must select that version as the **Minimum version**. The **Target
    version** must be equal to or greater than the **Minimum version**. If you are
    unsure of what to choose, you should stick with the default values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 是否要更改这些版本以适应您的应用程序由您决定，但您将限制可以安装您应用程序的 Windows 版本。如果您使用的是仅在特定 Windows 版本中可用的控件或功能，您必须选择该版本作为**最低版本**。**目标版本**必须等于或高于**最低版本**。如果您不确定选择什么，您应该坚持使用默认值。
- en: Now, the project has been created and Visual Studio has loaded, it’s always
    a best practice to build and run the project. Run the application and see what
    the template has provided for `MainWindow`. You should see an empty window hosting
    a few controls. Next, we will see what Visual Studio has created to get us started.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，项目已创建且 Visual Studio 已加载，始终是一个最佳实践来构建和运行项目。运行应用程序并查看模板为 `MainWindow` 提供了什么。您应该看到一个空窗口托管了一些控件。接下来，我们将看到
    Visual Studio 为我们创建的以帮助我们开始的内容。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To run and debug WinUI apps on Windows, you must update your Windows settings
    to enable **Developer Mode**. To do this, follow these steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上运行和调试 WinUI 应用程序，您必须更新您的 Windows 设置以启用**开发者模式**。为此，请按照以下步骤操作：
- en: 1\. Open **Settings** from the **Start** menu.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 从**开始**菜单打开**设置**。
- en: 2\. Type `Developer` in the search bar and select the **For Developers** settings
    from the search results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在搜索栏中输入 `Developer` 并从搜索结果中选择**开发者**设置。
- en: '3\. On the **For developers** page that appears, switch the **Developer Mode**
    toggle switch on, if it is not already turned on. Enabling this allows developers
    to sideload, run, and debug unsigned apps, and enables some other developer-focused
    Windows settings. You can get more information here: [https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development](https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 在出现的**开发者**页面，如果尚未开启，切换**开发者模式**开关。启用此功能允许开发者侧载、运行和调试未签名的应用程序，并启用一些其他面向开发者的
    Windows 设置。您可以在以下链接中获取更多信息：[https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development](https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development)。
- en: Anatomy of a WinUI in Desktop project
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桌面项目中 WinUI 的结构
- en: 'Now that we have a new empty WinUI project loaded in Visual Studio, let’s examine
    the different components. In `App.xaml` and `MainWindow.xaml`. We will start by
    discussing the purpose of each of these. Both files can be seen in the following
    screenshot of **Solution Explorer**:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将一个新的空 WinUI 项目加载到 Visual Studio 中，让我们检查不同的组件。在 `App.xaml` 和 `MainWindow.xaml`
    中。我们将首先讨论每个文件的用途。这两个文件可以在以下 **Solution Explorer** 的屏幕截图中看到：
- en: '![Figure 2.5 – The new WinUI solution in Solution Explorer](img/B20908_02_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – Solution Explorer 中的新 WinUI 解决方案](img/B20908_02_05.jpg)'
- en: Figure 2.5 – The new WinUI solution in Solution Explorer
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – Solution Explorer 中的新 WinUI 解决方案
- en: Reviewing App.xaml
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 App.xaml
- en: The `App.xaml` file, as its name implies, stores resources available across
    the entire application. If you have any templates or styles that will need to
    be used across multiple windows, they should be added at the `Application` level.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`App.xaml` 文件存储了整个应用程序可用的资源。如果您有任何需要在多个窗口中使用的模板或样式，它们应该添加到 `Application`
    级别。
- en: 'The new project’s `App.xaml` file will contain some initial markup, as illustrated
    in the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目的 `App.xaml` 文件将包含一些初始标记，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will cover some XAML basics in the next section. For now, you should know
    that the `Application.Resources` section will contain all the resources to be
    shared across an application. Within this section, the `ResourceDictionary.MergedDictionaries`
    section contains references to other XAML files whose resources will be shared
    with the entire application. This allows developers to organize shared content
    into multiple resource files, leading to better-organized and more maintainable
    XAML. This also enables the sharing of third-party resources across the application.
    For example, this file merges `XamlControlsResources` from the `Microsoft.UI.Xaml.Controls`
    namespace. These are the resources for the WinUI controls that we will be using
    to build our app.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些 XAML 基础知识。目前，你应该知道 `Application.Resources` 部分将包含跨应用程序共享的所有资源。在这个部分中，`ResourceDictionary.MergedDictionaries`
    部分包含了对其他 XAML 文件的引用，这些文件中的资源将与整个应用程序共享。这允许开发者将共享内容组织到多个资源文件中，从而使得 XAML 更有组织性和易于维护。这也使得应用程序可以共享第三方资源。例如，此文件合并了来自
    `Microsoft.UI.Xaml.Controls` 命名空间的 `XamlControlsResources`。这些是我们将用于构建应用程序的 WinUI
    控件的资源。
- en: Reviewing App.xaml.cs
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 App.xaml.cs 文件
- en: 'In `App.xaml` file’s node, and you will see there is another file named `App.xaml.cs`
    nested underneath. This is referred to as a `Application` class. If you open the
    C# file, you will see that it already contains some code. This is where you will
    handle any application-wide events. This is the event handler added by default:
    `OnLaunched`. If you need to execute any specific logic when your app is first
    launched, it should be added here. This is also where any application arguments
    passed to the app can be handled.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.xaml` 文件的节点中，你会看到还有一个名为 `App.xaml.cs` 的文件嵌套在其中。这被称为 `Application` 类。如果你打开
    C# 文件，你会看到它已经包含了一些代码。这就是你处理任何应用程序级事件的地方。这是默认添加的事件处理程序：`OnLaunched`。如果你需要在应用程序首次启动时执行任何特定逻辑，它应该在这里添加。这也是处理传递给应用程序的任何应用程序参数的地方。
- en: Reviewing MainWindow.xaml
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查 MainWindow.xaml
- en: 'The `MainWindow.xaml` file contains the `MainWindow` WinUI window that will
    be displayed when the application launches. You can see this in the `OnLaunched`
    event handler in `App.xaml.cs`, as illustrated in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow.xaml` 文件包含将在应用程序启动时显示的 `MainWindow` WinUI 窗口。你可以在 `App.xaml.cs`
    中的 `OnLaunched` 事件处理程序中看到这一点，如下面的代码片段所示：'
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In a new blank WinUI app, `Window` will contain an empty `StackPanel` layout
    control. Try replacing `StackPanel`’s child controls with `TextBlock` with a `Text`
    property of `Media` and replace `StackPanel` with `Grid`. The result should look
    like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的空白 WinUI 应用程序中，`Window` 将包含一个空的 `StackPanel` 布局控件。尝试用具有 `Text` 属性为 `Media`
    的 `TextBlock` 替换 `StackPanel` 的子控件，并用 `Grid` 替换 `StackPanel`。结果应该看起来像这样：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To prevent exceptions at runtime, remove the event handler for the `Button.Click`
    event in `MainWindow.xaml.cs`. Now run the app with the **Debug** | **Start Debugging**
    menu item or the **Start Debugging** button on the Visual Studio toolbar, and
    you should see something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止运行时出现异常，请从 `MainWindow.xaml.cs` 中移除 `Button.Click` 事件处理程序。现在使用 **调试** |
    **开始调试** 菜单项或 Visual Studio 工具栏上的 **开始调试** 按钮运行应用程序，你应该会看到如下内容：
- en: '![Figure 2.6 – MainWindow with TextBlock added](img/B20908_02_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 添加了 TextBlock 的 MainWindow](img/B20908_02_06.jpg)'
- en: Figure 2.6 – MainWindow with TextBlock added
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 添加了 TextBlock 的 MainWindow
- en: We’ll make this window a bit more functional later in the chapter. For now,
    let’s finish our review of the project structure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将使这个窗口功能更强大。现在，让我们完成对项目结构的审查。
- en: Reviewing MainWindow.xaml.cs
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查 MainWindow.xaml.cs
- en: The code-behind file for the `MainWindow.xaml.cs` window now contains only a
    call to `InitializeComponent()` in the constructor because we removed the event
    handler for the original `Button` control. Later, we will add some code here to
    populate some sample data and handle events on the page. In a well-designed MVVM
    app, the code-behind files for your pages will have very little code. Most of
    the code will reside in the `ViewModel` classes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow.xaml.cs` 窗口的代码后文件现在在构造函数中只包含对 `InitializeComponent()` 的调用，因为我们移除了原始
    `Button` 控件的事件处理程序。稍后，我们将在这里添加一些代码来填充一些示例数据并处理页面上的事件。在一个设计良好的 MVVM 应用程序中，你的页面代码后文件将包含非常少的代码。大部分代码将位于
    `ViewModel` 类中。'
- en: Reviewing the project references
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查项目引用
- en: 'All your project’s references to `Packages` folder under **Dependencies** in
    **Solution Explorer**. Your WinUI project will reference the following NuGet packages:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 的 **依赖项** 下的 **Packages** 文件夹中，你项目的所有引用。你的 WinUI 项目将引用以下 NuGet
    包：
- en: '`Microsoft.WindowsAppSDK`: The Windows App SDK components, which include WinUI'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.WindowsAppSDK`：包括 WinUI 的 Windows App SDK 组件'
- en: '`Microsoft.Windows.SDK.BuildTools`: The Windows SDK components required to
    build a WinUI solution'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Windows.SDK.BuildTools`：构建 WinUI 解决方案所需的 Windows SDK 组件'
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not modify or remove any of these references.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要修改或删除这些引用。
- en: Reviewing the project properties
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看项目属性
- en: 'If you right-click the project in **Solution Explorer** and select **Properties**
    from the context menu, you can view and modify the project properties. You won’t
    often need to make any changes here. These are a couple of properties you might
    need to modify from time to time:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你右键单击 **解决方案资源管理器** 中的项目并从上下文菜单中选择 **属性**，你可以查看和修改项目属性。你不会经常需要在此处进行任何更改。以下是一些你可能需要不时修改的属性：
- en: '**Assembly Name**: You can change the name of the output assembly that is compiled
    by the project'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序集名称**：你可以更改由项目编译的输出程序集的名称'
- en: '**Min Version** and **Target Version**: The Windows versions that were selected
    when creating the project can be modified here'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小版本** 和 **目标版本**：创建项目时选择的 Windows 版本可以在此修改'
- en: The primary difference between a new UWP project and a new WinUI 3 project is
    the controls and other objects that are referenced in the `Windows.UI.Xaml.*`
    namespaces are now referenced in the Windows App SDK’s `Microsoft.UI.Xaml.*` namespaces.
    One other difference is that in the `App.xaml` file of the UWP project, it’s not
    necessary to import the controls’ resources. The remaining differences are mostly
    hidden from app developers in the project file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 UWP 项目和新的 WinUI 3 项目的区别主要在于在 `Windows.UI.Xaml.*` 命名空间中引用的控件和其他对象现在引用了 Windows
    App SDK 的 `Microsoft.UI.Xaml.*` 命名空间中的控件。另一个区别是，在 UWP 项目的 `App.xaml` 文件中，不需要导入控件的资源。其余的区别主要在项目文件中对应用程序开发者隐藏。
- en: Now that you’ve become familiar with the WinUI project, let’s start building
    the UI for `MainWindow`. We will start with some of the more common XAML controls
    and concepts.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 WinUI 项目，让我们开始构建 `MainWindow` 的 UI。我们将从一些常见的 XAML 控件和概念开始。
- en: XAML basics
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XAML 基础
- en: 'It’s time to start building the main screen of the **My Media Collection**
    application. The focal point of the application will be the media items in the
    collection. To display that list, we are going to need a few things, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始构建 **My Media Collection** 应用程序的主屏幕了。应用程序的焦点将是集合中的媒体项目。为了显示这个列表，我们需要一些东西，如下所示：
- en: A `Model` class that defines an item in the collection
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个定义集合中项目的 `Model` 类
- en: Some code to bind the collection of items to the UI
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些代码用于将项目集合绑定到 UI
- en: A XAML control to display the items
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示项目的 XAML 控件
- en: Building the model
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模型
- en: We will start by building the model for the **My Media Collection** application.
    A **model** defines an entity and its attributes. Earlier in the chapter, we discussed
    some of the items’ attributes we want to display in the UI. To display and (eventually)
    persist this information, we must create the model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为 **My Media Collection** 应用程序构建模型。一个 **模型** 定义了一个实体及其属性。在本章的早期部分，我们讨论了一些我们希望在
    UI 中显示的项目属性。为了显示（最终）持久化这些信息，我们必须创建模型。
- en: 'The initial version of our model will consist of two enumerations (`ItemType`
    and `LocationType`) in an `Enums` folder, and two classes (`Medium` and `MediaItem`)
    in a `Model` folder, as illustrated in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型的初始版本将包括一个 `Enums` 文件夹中的两个枚举（`ItemType` 和 `LocationType`），以及一个 `Model` 文件夹中的两个类（`Medium`
    和 `MediaItem`），如下面的截图所示：
- en: '![Figure 2.7 – Solution Explorer displays the new Model and Enum files](img/B20908_02_07.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 解决方案资源管理器显示新的模型和枚举文件](img/B20908_02_07.jpg)'
- en: Figure 2.7 – Solution Explorer displays the new Model and Enum files
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 解决方案资源管理器显示新的模型和枚举文件
- en: To add a new folder to the project, right-click on the `Enums` as the folder
    name and hit *Enter*. Repeat this process to add a `Model` folder.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向项目中添加新文件夹，右键单击 `Enums` 作为文件夹名称，然后按 *Enter*。重复此过程以添加 `Model` 文件夹。
- en: 'Next, right-click the project file and select `ItemType`, and click the **Add**
    button, as illustrated in the following screenshot:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击项目文件并选择 `ItemType`，然后点击下面的 **添加** 按钮，如下面的截图所示：
- en: '![Figure 2.8 – The Add New Item dialog](img/B20908_02_08.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 添加新项对话框](img/B20908_02_08.jpg)'
- en: Figure 2.8 – The Add New Item dialog
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 添加新项对话框
- en: 'The code for `ItemType` is created and displayed. Change the `class` definition
    to `enum` and change the `internal` keyword to `public`. The `ItemType` enum contains
    three possible values named `Music`, `Video`, and `Book`. When you’re finished,
    the definition of the `ItemType` enum will look like this:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ItemType`的代码已创建并显示。将`class`定义更改为`enum`，并将`internal`关键字更改为`public`。`ItemType`枚举包含三个可能值，分别命名为`Music`、`Video`和`Book`。当您完成时，`ItemType`枚举的定义将如下所示：'
- en: '[PRE3]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Repeat the steps to create a `LocationType` enum, defined as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤创建一个`LocationType`枚举，定义如下：
- en: '[PRE4]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using what you have learned, create two classes named `Medium` and `MediaItem`
    in the `Model` folder. The `Medium` class represents a specific medium such as
    *hardcover* or *paperback*, while the `MediaType` property assigns an `ItemType`
    to which the `Medium` class belongs. For these, the valid `ItemType` would be
    `Book`. When you are finished, the two new classes will look like this:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您所学到的知识，在`Model`文件夹中创建两个名为`Medium`和`MediaItem`的类。`Medium`类表示特定的媒体，如*精装本*或*平装本*，而`MediaType`属性将`ItemType`分配给`Medium`类所属的类型。对于这些，有效的`ItemType`将是`Book`。当您完成时，这两个新类将如下所示：
- en: '[PRE5]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To reference the enum types in the `Enums` folder from the two classes, a `using`
    declaration will need to be added at the top of each new class, like this: `using
    MyMediaCollection.Enums;`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要从两个类中引用`Enums`文件夹中的枚举类型，需要在每个新类的顶部添加一个`using`声明，如下所示：`using MyMediaCollection.Enums;`。
- en: In addition to the properties discussed earlier in the chapter, an `Id` property
    has been added to the `MediaItem` class to uniquely identify each item in the
    collection. This will be useful later when we start persisting data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章前面讨论的属性外，`MediaItem`类中已添加一个`Id`属性，用于唯一标识集合中的每个项。这将在我们开始持久化数据时非常有用。
- en: Creating sample data
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建示例数据
- en: With the model classes in place, we’re ready to add some code that will create
    three media items to display in the UI. This will help us visualize things as
    we start creating our list of items on the main screen. When this step is complete
    and we’re ready to move on to enabling the ability to add items through the app,
    this code will be removed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型类就绪后，我们准备添加一些代码来创建三个用于在UI中显示的媒体项。这将帮助我们在我们开始创建主屏幕上的项目列表时可视化事物。当这一步完成，我们准备继续启用通过应用程序添加项的功能时，此代码将被移除。
- en: 'For now, we are going to add this code in the `MainWindow.xaml.cs` code-behind
    file. Later, in [*Chapter 3*](B20908_03.xhtml#_idTextAnchor073), *MVVM for Maintainability
    and Testability*, this type of code will be added in a `ViewModel` file. The `MainWindow`
    will contain only presentation logic and will not be responsible for creating
    or fetching the data that populates the UI:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在此`MainWindow.xaml.cs`代码隐藏文件中添加此代码。稍后，在[*第3章*](B20908_03.xhtml#_idTextAnchor073)
    *可维护性和可测试性的MVVM* 中，此类代码将添加到`ViewModel`文件中。`MainWindow`将只包含表示逻辑，不会负责创建或获取填充UI的数据：
- en: 'First, open `MainWindow.xaml.cs` and create a method named `PopulateData`.
    This method will contain the code that creates three `MediaItem` objects (a CD,
    a book, and a Blu-ray) and adds them to a private `List` named `_items`, as illustrated
    in the following code snippet:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`MainWindow.xaml.cs`并创建一个名为`PopulateData`的方法。此方法将包含创建三个`MediaItem`对象（一张CD、一本书和一张蓝光光盘）并将它们添加到名为`_items`的私有`List`中的代码，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You will need to add the `using` statements to `MainWindow` for the `MyMediaCollection.Model`
    and `MyMediaCollection.Enums` namespaces.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要将`using`语句添加到`MainWindow`的`MyMediaCollection.Model`和`MyMediaCollection.Enums`命名空间中。
- en: 'Define `_items` `IList` and `isLoaded` `bool` as private class members. We
    will later change the collection of items to an `ObservableCollection`. `ObservableCollection`
    is a special collection that notifies data-bound items on the UI when items have
    been added or removed from the collection. For now, an `IList` will suit our needs.
    The code can be seen in the following snippet:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`_items`定义为`IList`和`isLoaded`定义为`bool`作为私有类成员。我们稍后将更改项目集合为`ObservableCollection`。`ObservableCollection`是一个特殊的集合，当集合中的项目被添加或删除时，它会通知UI中的数据绑定项。现在，`IList`将满足我们的需求。代码可以在以下代码片段中看到：
- en: '[PRE7]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, add a line of code to the `MainWindow` constructor, after the call to
    `Initialize``     Component`, to call the new `PopulateData` method. Any code added to a `Window`
    or `UserControl` constructor must be added after this initialization code. This
    is where all the XAML code in `MainWindow.xaml` is initialized. If you attempt
    to reference any of those elements before the call to `InitializeComponent`, it
    will result in an error. The constructor should now look like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `MainWindow` 构造函数中，在调用 `InitializeComponent` 之后添加一行代码，以调用新的 `PopulateData`
    方法。添加到 `Window` 或 `UserControl` 构造函数中的任何代码都必须在此初始化代码之后添加。这是 `MainWindow.xaml`
    中所有 XAML 代码初始化的地方。如果在调用 `InitializeComponent` 之前尝试引用这些元素，将导致错误。构造函数现在应如下所示：
- en: '[PRE8]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will return to this file to add some data-binding logic after creating some
    UI components in the XAML file. Let’s go and do that now.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XAML 文件中创建一些 UI 组件之后，我们将返回此文件以添加一些数据绑定逻辑。让我们现在就去完成这个任务。
- en: Building the initial UI
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建初始用户界面
- en: Earlier in the chapter, we added a single `TextBlock` to the `MainWindow.xaml`
    file with the `Text` property set to `Media`. We are going to add a `ListView`
    control beneath the existing `TextBlock`. A `ListView` control is a powerful and
    flexible control to display a list of items in a vertical list. It is like the
    `ListBox` control in basic list functionality (item selection, multi-selection,
    and automatic scroll bars), but each list item can be templated to display in
    just about any way imaginable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们在 `MainWindow.xaml` 文件中添加了一个 `TextBlock`，其 `Text` 属性设置为 `Media`。我们将在现有的
    `TextBlock` 下方添加一个 `ListView` 控件。`ListView` 控件是一个强大且灵活的控件，用于在垂直列表中显示项目列表。它类似于基本列表功能（项目选择、多选和自动滚动条）中的
    `ListBox` 控件，但每个列表项都可以进行模板化，以几乎任何可想象的方式显示。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the `ListView` class, documentation with sample
    code and markup is available on Microsoft Learn: [https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.listview](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.listview).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `ListView` 类的更多信息，包括示例代码和标记的文档，可在 Microsoft Learn 上找到：[https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.listview](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.listview)。
- en: 'First, add some markup to create two rows inside the top-level `Grid` control.
    `RowDefinitions` should be added before the existing `TextBlock` element. `TextBlock`
    will remain in the first row, and we’ll add the `ListView` control to the second
    row. Create `RowDefinitions` as illustrated in the following code snippet:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在顶级 `Grid` 控件内添加一些标记以创建两行。应在现有的 `TextBlock` 元素之前添加 `RowDefinitions`。`TextBlock`
    将保留在第一行，我们将在第二行添加 `ListView` 控件。按照以下代码片段创建 `RowDefinitions`：
- en: '[PRE9]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we’re automatically sizing the first `RowDefinition` to the
    size of the `TextBlock` and allocating the remaining space inside the `Grid` to
    the `ListView` control’s `RowDefinition` by using `"*"`. If you assign more than
    one row with `"*"`, those rows will split the remaining available space equally.
    This is the default value for the `Height` attribute. It would be sized the same
    if `"*"` were omitted, but most XAML developers explicitly include it for completeness
    and improved readability.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们自动将第一 `RowDefinition` 的大小设置为 `TextBlock` 的大小，并通过使用 `"*"` 将 `Grid` 内剩余的空间分配给
    `ListView` 控件的 `RowDefinition`。如果您为多个行分配 `"*"`，则这些行将平均分配剩余的可用空间。这是 `Height` 属性的默认值。如果省略
    `"*"`，大小将相同，但大多数 XAML 开发者明确包含它以实现完整性和提高可读性。
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about row sizing, see the following Microsoft Learn documentation:
    [https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.rowdefinition.height](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.rowdefinition.height).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于行大小的更多信息，请参阅以下 Microsoft Learn 文档：[https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.rowdefinition.height](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.rowdefinition.height)。
- en: 'Next, add a `ListView` control to the `Grid`, setting `Grid.Row` equal to `1`
    (row numbering is 0-based, meaning the first row is row `0`), and name it `ItemList`.
    It is not necessary to name your XAML elements. This is only required if you either
    want to reference them by `ElementName` in XAML data binding or as a variable
    in the code-behind file. Naming a control causes a variable to be created in the
    `InitializeComponent` call, and to optimize performance, you should only name
    your controls if you need to reference them elsewhere. The markup can be seen
    in the following snippet:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `ListView` 控件添加到 `Grid` 中，设置 `Grid.Row` 等于 `1`（行编号从 0 开始，即第一行是行 `0`），并将其命名为
    `ItemList`。命名您的 XAML 元素不是必需的。这仅在您想要通过 `ElementName` 在 XAML 数据绑定中引用它们或作为代码背后的文件中的变量时才是必需的。命名一个控件会在
    `InitializeComponent` 调用中创建一个变量，为了优化性能，您应该只在需要在其他地方引用控件时命名控件。以下代码片段显示了标记：
- en: '[PRE10]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By setting the background color to `LightGoldenrodYellow`, we can see the `ListView`
    in the application’s main window before we populate any data. Depending on whether
    you are using a *Light* or *Dark* Windows theme, you can choose a color that works
    best for you. Run the app, and it should look something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将背景颜色设置为 `LightGoldenrodYellow`，在填充任何数据之前，我们可以看到应用程序主窗口中的 `ListView`。根据您是否使用
    *Light* 或 *Dark* Windows 主题，您可以选择最适合您的颜色。运行应用程序，它应该看起来像这样：
- en: '![Figure 2.9 – A ListView added to the UI](img/B20908_02_09.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 已添加到 UI 的 ListView](img/B20908_02_09.jpg)'
- en: Figure 2.9 – A ListView added to the UI
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 已添加到 UI 的 ListView
- en: Let’s return to the code-behind file to start wiring up the data binding.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到代码背后文件，开始设置数据绑定。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are new to data binding concepts in XAML programming, Microsoft Learn
    has a great overview of data binding for Windows App SDK developers at the following
    web page: [https://learn.microsoft.com/windows/apps/develop/data-binding/](https://learn.microsoft.com/windows/apps/develop/data-binding/).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对 XAML 编程中的数据绑定概念不熟悉，Microsoft Learn 在以下网页上为 Windows App SDK 开发者提供了一个关于数据绑定的优秀概述：[https://learn.microsoft.com/windows/apps/develop/data-binding/](https://learn.microsoft.com/windows/apps/develop/data-binding/)。
- en: Completing the data-binding initialization
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成数据绑定初始化
- en: 'Return to the `MainWindow.xaml.cs` file and add a line of code before the `PopulateData()`
    method call, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `MainWindow.xaml.cs` 文件，在调用 `PopulateData()` 方法之前添加一行代码，如下所示：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After typing `+=`, Visual Studio `ItemList_Loaded` event handler, as illustrated
    in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在键入 `+=` 后，Visual Studio `ItemList_Loaded` 事件处理器，如下面的截图所示：
- en: '![Figure 2.10 – Inserting the ItemList_Loaded event handler](img/B20908_02_010.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 插入 ItemList_Loaded 事件处理器](img/B20908_02_010.jpg)'
- en: Figure 2.10 – Inserting the ItemList_Loaded event handler
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 插入 ItemList_Loaded 事件处理器
- en: Alternatively, if you type the entire line and press *Ctrl* +, you’ll be prompted
    to create the new method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您输入整行并按 *Ctrl* +，系统会提示您创建新方法。
- en: 'To keep the `MainWindow` constructor simple and keep our data-loading code
    together, move the `PopulateData` call to the `ItemList_Loaded` method. Then,
    add the two other lines of code to the new event handler, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `MainWindow` 构造函数简单，并将我们的数据加载代码放在一起，将 `PopulateData` 调用移动到 `ItemList_Loaded`
    方法。然后，将其他两行代码添加到新的事件处理器中，如下所示：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code is called after the `ItemsList` control has completed loading in
    the UI. We’re getting the instance of the control from the `sender` parameter
    and setting the `ItemsSource` of the list to the `_items` collection that was
    loaded in `PopulateData()`. Now, we have data in the list, but things don’t look
    quite right, as can be seen from the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在 `ItemsList` 控件在 UI 中完成加载后调用。我们从 `sender` 参数获取控件的实例，并将列表的 `ItemsSource`
    设置为在 `PopulateData()` 中加载的 `_items` 集合。现在，列表中有数据，但看起来并不完全正确，如下面的截图所示：
- en: '![Figure 2.11 – A ListView with three rows of data](img/B20908_02_011.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 包含三行数据的 ListView](img/B20908_02_011.jpg)'
- en: Figure 2.11 – A ListView with three rows of data
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 包含三行数据的 ListView
- en: The `ListView` is displaying three rows for our three sample data items, but
    it’s displaying the data type for each item instead of the data. That’s because
    we haven’t told the `ListView` which properties it should display for the items
    in the collection. By default, the list will display whatever is returned by an
    object’s `ToString()` method. If `ToString()` is not overridden, the data type
    name of the class is returned.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 正在显示三个行，对应于我们的三个示例数据项，但它显示的是每个项的数据类型而不是数据。这是因为我们没有告诉 `ListView`
    它应该显示集合中每个项的哪些属性。默认情况下，列表将显示对象 `ToString()` 方法返回的内容。如果 `ToString()` 没有重写，则返回类的数据类型名称。'
- en: Creating the DataTemplate and binding the UI
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 DataTemplate 并绑定 UI
- en: Let’s return to `MainWindow.xaml` and tell the `ListView` which data we want
    to display for each item in the list. Try making this change with the application
    still running. Thanks to Visual Studio’s **XAML Hot Reload** feature, you should
    see the UI reload without having to restart the debugging session.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `MainWindow.xaml` 并告诉 `ListView` 我们想要为列表中的每个项目显示哪些数据。尝试在应用程序仍在运行时进行此更改。多亏了
    Visual Studio 的 **XAML 热重载** 功能，你应该会看到 UI 重新加载，而无需重新启动调试会话。
- en: 'Customizing the appearance of each `ListView` item is accomplished by defining
    a `DataTemplate` inside `ListView.ItemTemplate`. A `DataTemplate` can contain
    any WinUI controls we need to define the layout of each list item. Let’s keep
    it simple and add a `Grid` containing two columns. Each column will contain a
    `TextBlock`. The `ListView` should now look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `ListView.ItemTemplate` 内定义 `DataTemplate` 来自定义每个 `ListView` 项的外观。`DataTemplate`
    可以包含我们需要的任何 WinUI 控件来定义每个列表项的布局。让我们保持简单，并添加一个包含两列的 `Grid`。每一列将包含一个 `TextBlock`。现在
    `ListView` 应该看起来像这样：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are beginning to create some more complex XAML and need to keep formatting
    in mind to optimize its readability.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始创建一些更复杂的 XAML，并需要考虑格式化以优化其可读性。
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To quickly reformat your XAML, you can use the *Ctrl* + *K | D* keyboard shortcut.
    There is also an extension on the **Visual Studio Marketplace** called **XAML
    Styler**. You can search for it in Visual Studio’s **Manage Extensions** dialog
    or get more information on the Marketplace here: [https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022](https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速重新格式化 XAML，可以使用 *Ctrl* + *K | D* 快捷键。还有一个名为 **XAML Styler** 的扩展程序在 **Visual
    Studio Marketplace** 上。您可以在 Visual Studio 的 **管理扩展** 对话框中搜索它，或在此处获取更多信息：[https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022](https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022)。
- en: 'To enable each `TextBlock` to bind to the properties of `MediaItem`, we must
    set an `x:DataType` property on the `DataTemplate`. To resolve `MediaItem`, a
    namespace declaration needs to be added to the `Window` definition, like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使每个 `TextBlock` 能够绑定到 `MediaItem` 的属性，我们必须在 `DataTemplate` 上设置一个 `x:DataType`
    属性。为了解析 `MediaItem`，需要在 `Window` 定义中添加一个命名空间声明，如下所示：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A shortcut to add this `using` statement is to place your cursor in `x:DataType`
    and press *Ctrl* +. Visual Studio will suggest adding the missing namespace to
    the file. We now have access to objects in the `MyMediaCollection.Model` namespace
    by using the `model` prefix, and `x:DataType="model:MediaItem"` will resolve `MediaItem`
    when we build and run the app.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此 `using` 语句的快捷方式是将光标放在 `x:DataType` 上并按 *Ctrl* +. Visual Studio 将建议向文件中添加缺失的命名空间。现在我们可以通过使用
    `model` 前缀来访问 `MyMediaCollection.Model` 命名空间中的对象，并且 `x:DataType="model:MediaItem"`
    在构建和运行应用程序时将解析 `MediaItem`。
- en: Each `TextBlock` has its `Text` property bound to a property of `MediaItem`,
    using the `x:Bind` **markup extension**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `TextBlock` 的 `Text` 属性都绑定到 `MediaItem` 的一个属性，使用的是 `x:Bind` **标记扩展**。
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Using `x:Bind` instead of the `Binding` markup extension to bind data to the
    UI has the benefit of compile-time validation and increased performance. The previously
    noted data-binding overview on Microsoft Learn covers the differences in depth.
    I prefer to use `x:Bind` where possible. One important difference between `Binding`
    and `x:Bind` you should note is that while `Binding` defaults to `OneWay` mode,
    `x:Bind` defaults to `OneTime`. This change to the default binding behavior was
    made for performance considerations. `OneWay` binding requires more code behind
    the scenes to wire up the change detection needed for monitoring changes to the
    source value. You can still explicitly update your `x:Bind` usages to be `OneWay`
    or `TwoWay`. For more information about `x:Bind`, see this Microsoft Learn article:
    [https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension](https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`x:Bind`而不是`Binding`标记扩展来将数据绑定到UI的好处是编译时验证和性能提升。之前在Microsoft Learn上提到的数据绑定概述深入探讨了这些差异。我更喜欢尽可能使用`x:Bind`。你应该注意`Binding`和`x:Bind`之间的重要区别是，虽然`Binding`默认为`OneWay`模式，但`x:Bind`默认为`OneTime`。这种对默认绑定行为的更改是为了性能考虑。`OneWay`绑定需要在幕后编写更多代码来设置更改检测，以监控源值的更改。你仍然可以显式地将你的`x:Bind`使用更新为`OneWay`或`TwoWay`。有关`x:Bind`的更多信息，请参阅这篇Microsoft
    Learn文章：[https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension](https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension)。
- en: 'For more information on markup extensions in XAML, you can read this .NET article:
    [https://learn.microsoft.com/dotnet/desktop/xaml-services/markup-extensions-overview](https://learn.microsoft.com/dotnet/desktop/xaml-services/markup-extensions-overview).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有关XAML中标记扩展的更多信息，你可以阅读这篇.NET文章：[https://learn.microsoft.com/dotnet/desktop/xaml-services/markup-extensions-overview](https://learn.microsoft.com/dotnet/desktop/xaml-services/markup-extensions-overview)。
- en: 'Now, when you run the application, you can see the `MediumType` name and the
    item name for each item in the `ListView`, as illustrated in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序时，你可以在`ListView`中看到每个项目的`MediumType`名称和项目名称，如下面的截图所示：
- en: '![Figure 2.12 – The ListView with two columns of sample data](img/B20908_02_012.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 带有两列示例数据的ListView](img/B20908_02_012.jpg)'
- en: Figure 2.12 – The ListView with two columns of sample data
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 带有两列示例数据的ListView
- en: That’s some pretty good progress! Before we expand on the functionality, let’s
    talk a little about how WinUI, the Windows App SDK, and .NET fit together in terms
    of the app development process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经取得了相当不错的进展！在我们扩展功能之前，让我们简要谈谈WinUI、Windows App SDK和.NET在应用开发过程中的结合方式。
- en: Understanding WinUI and Windows App SDK
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解WinUI和Windows App SDK
- en: Let’s review the WinUI controls available to use in our project and see how
    they can help us build the `Microsoft.WindowsAppSDK` package we saw in **Solution
    Explorer** earlier in the chapter contains these controls and much more.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们项目中可用的WinUI控件，看看它们如何帮助我们构建在**解决方案资源管理器**中看到的`Microsoft.WindowsAppSDK`包。
- en: 'To view the contents of this package, open the **Object Browser** window from
    Visual Studio’s **View** menu. The controls will be listed here under several
    namespaces inside the **Microsoft.WinUI** tree node, as illustrated in the following
    screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此包的内容，请从Visual Studio的**视图**菜单中打开**对象浏览器**窗口。控件将在此处列出，位于**Microsoft.WinUI**树节点下的几个命名空间中，如下面的截图所示：
- en: '![Figure 2.13 – WinUI controls in Object Browser](img/B20908_02_013.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 对象浏览器中的WinUI控件](img/B20908_02_013.jpg)'
- en: Figure 2.13 – WinUI controls in Object Browser
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 对象浏览器中的WinUI控件
- en: The majority of WinUI controls we will be using can be found inside the **Microsoft.UI.Xaml.Controls**
    namespace under **Microsoft.WinUI**, along with other related classes and interfaces.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的WinUI控件的大部分都可以在**Microsoft.WinUI**下的**Microsoft.UI.Xaml.Controls**命名空间中找到，以及其他相关类和接口。
- en: So far, we have used in our application the `Grid`, `TextBlock`, and `ListView`
    controls. Open the `ListView` class, expand `ListViewBase` class. This base class
    contains the methods, properties, and events available to the `ListView`. The
    members of `ListViewBase` will display in the right pane. Take some time to review
    these members and see whether you recognize any of them from your use of the control
    so far.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在应用程序中使用了`Grid`、`TextBlock`和`ListView`控件。打开`ListView`类，展开`ListViewBase`类。这个基类包含了`ListView`可用的方法、属性和事件。`ListViewBase`的成员将在右侧窗格中显示。花些时间审查这些成员，看看你是否能从迄今为止对控件的使用中认出它们。
- en: 'Clear `ListView` from your search, scroll down in the left pane of `TextBlock`
    control. Select it and, in the right pane, find and select the **Text** property.
    The bottom-right pane displays details of the property, as illustrated in the
    following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 清除您的搜索 `ListView`，在 `TextBlock` 控件的左侧面板中向下滚动。选择它，在右侧面板中找到并选择 **Text** 属性。右下角的面板显示了属性的详细信息，如图下截图所示：
- en: '![Figure 2.14 – Details of the TextBlock.Text property in Object Browser](img/B20908_02_014.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 对象浏览器中 TextBlock.Text 属性的详细信息](img/B20908_02_014.jpg)'
- en: Figure 2.14 – Details of the TextBlock.Text property in Object Browser
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 对象浏览器中 TextBlock.Text 属性的详细信息
- en: The **Object Browser** window can be a valuable resource when familiarizing
    yourself with a new library or project. All referenced projects, NuGet packages,
    and other references will appear here.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象浏览器**窗口在熟悉新库或项目时可以成为一个宝贵的资源。所有引用的项目、NuGet 包和其他引用都将在此处显示。'
- en: The controls and other components you have reviewed here make up the UI layer
    of Windows App SDK applications. The underlying application framework for the
    Windows App SDK is .NET.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此处审查的控件和其他组件构成了 Windows App SDK 应用程序的 UI 层。Windows App SDK 的底层应用程序框架是 .NET。
- en: Understanding the .NET app model
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 .NET 应用程序模型
- en: You may have heard that the underlying app model for WinUI apps can be Win32
    for C++ apps or .NET for desktop apps. So, what exactly is the **.NET** **app
    model**?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能听说过 WinUI 应用的底层应用程序模型可以是 C++ 应用的 Win32 或桌面应用的 .NET。那么，.NET **应用程序模型**究竟是什么呢？
- en: 'The .NET app model in WinUI apps describes how applications are packaged and
    deployed. It also defines the following behaviors and capabilities:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 应用程序中的 .NET 应用程序模型描述了应用程序的打包和部署方式。它还定义了以下行为和能力：
- en: Data storage
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储
- en: State management
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态管理
- en: Lifecycle events (**Startup** and **Shutdown**)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期事件（**启动**和**关闭**）
- en: Multitasking
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多任务处理
- en: Resource management
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理
- en: Inter-app communication
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用间通信
- en: WinUI 3 is one component of the Windows App SDK, the UI layer. Although the
    WinUI controls are decoupled from the Windows SDK, the underlying .NET app platform
    is still dependent on it when using the Windows App SDK. Selecting a target and
    minimum Windows version is one of the side effects of this dependency.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: WinUI 3 是 Windows App SDK 的一个组件，是 UI 层。尽管 WinUI 控件与 Windows SDK 解耦，但在使用 Windows
    App SDK 时，底层 .NET 应用程序平台仍然依赖于它。选择目标操作系统和最低版本是这种依赖关系的一个副作用。
- en: Now that you have a better understanding of WinUI controls and how they relate
    to the Windows App SDK and the .NET app platform, let’s use a few more of them
    in our application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经更好地理解了 WinUI 控件以及它们与 Windows App SDK 和 .NET 应用程序平台的关系，让我们在我们的应用程序中使用更多的一些控件。
- en: Working with WinUI controls, properties, and events
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 WinUI 控件、属性和事件一起工作
- en: 'It’s time to enhance the UI of the application. Currently, the main page only
    consists of a `Media` label over a `ListView`, with columns for the media type
    and the name of the media item. The following are the enhancements we will add
    in this section:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候增强应用程序的 UI 了。目前，主页只包含一个位于 `ListView` 上的 `Media` 标签，有媒体类型和媒体项目名称的列。以下是我们将在本节中添加的增强功能：
- en: A header row for the `ListView`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView` 的标题行'
- en: A `ComboBox` to filter the rows based on the media type
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `ComboBox` 用于根据媒体类型过滤行
- en: A `Button` to add a new item to the collection
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于向集合添加新项目的 `Button`
- en: We will start by enhancing the `ListView` for our media collection.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先增强我们的媒体集合的 `ListView`。
- en: Adding a ListView header
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 ListView 标题
- en: Before we create the header, let’s change the background color of the `ListView`.
    The `Aqua` color worked well to highlight the control, but it would be distracting
    when the application is used by our customers. We will discuss WinUI theme brushes
    and look at `Background="Aqua"` from the `ListView` definition in the `MainWindow.xaml`
    file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建标题之前，让我们改变 `ListView` 的背景颜色。`Aqua` 颜色很好地突出了控件，但当应用程序被我们的客户使用时可能会分散注意力。我们将讨论
    WinUI 主题画笔，并查看 `MainWindow.xaml` 文件中 `ListView` 定义中的 `Background="Aqua"`。
- en: Creating the header row for the media collection is relatively simple. To define
    the rows for each item, we created a `ListView.ItemTemplate` block containing
    a `DataTemplate`. To create the header, we do the same inside a `ListView.HeaderTemplate`
    block.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建媒体集合的标题行相对简单。为了定义每个项目的行，我们创建了一个包含 `DataTemplate` 的 `ListView.ItemTemplate`
    块。为了创建标题，我们在 `ListView.HeaderTemplate` 块内做同样的事情。
- en: 'Just as with the item rows, the header row will consist of a `Grid` with two
    columns, with the same `Width` definitions. We again want to use two `TextBlock`
    controls inside the `Grid`, but to add some separation between the header and
    the items, we will add `Border` controls. Let’s look at the markup for the header
    and then discuss the differences in more detail. Take some time to review the
    following markup:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如与项目行一样，表头行将包含一个具有两个列的 `Grid`，具有相同的 `Width` 定义。我们再次想在 `Grid` 中使用两个 `TextBlock`
    控件，但为了在表头和项目之间添加一些间隔，我们将添加 `Border` 控件。让我们看一下表头的标记，然后更详细地讨论差异。花点时间审查以下标记：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, each `TextBlock` is nested inside a `Border` element. This
    will wrap the text in a border with a `BlueViolet` color. However, by setting
    `BorderThickness="0,0,0,1"`, the border color will only appear on the bottom of
    the header row items. Here is how that appears in the application:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个 `TextBlock` 都嵌套在一个 `Border` 元素中。这将用 `BlueViolet` 颜色的边框包裹文本。然而，通过设置 `BorderThickness="0,0,0,1"`，边框颜色将只出现在表头行项的底部。这是它在应用程序中的样子：
- en: '![Figure 2.15 – The ListView with a header row added](img/B20908_02_015.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 添加了表头行的 ListView](img/B20908_02_015.jpg)'
- en: Figure 2.15 – The ListView with a header row added
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 添加了表头行的 ListView
- en: Note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The same bottom border could be achieved by nesting the entire `Grid` inside
    a `Border` instead of putting one around each header item. However, by doing it
    this way, we have more control over the appearance of each column’s border style.
    When we implement sorting later, the border’s color can be modified to highlight
    the column on which sorting has been applied.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将整个 `Grid` 嵌套在一个 `Border` 中而不是围绕每个表头项放置一个 `Border`，可以实现相同的底部边框。然而，通过这种方式操作，我们对每个列的边框样式的外观有更多的控制。当我们稍后实现排序时，可以修改边框的颜色以突出显示已应用排序的列。
- en: You probably also noticed that the header row text stands out from the rows
    in the grid. The `FontWeight="Bold"` property set inside each `TextBlock` in the
    `HeaderTemplate` helps to highlight the header row.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了，表头行的文本与网格中的行不同。`HeaderTemplate` 中每个 `TextBlock` 内设置的 `FontWeight="Bold"`
    属性有助于突出显示表头行。
- en: Creating the ComboBox filter
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 ComboBox 过滤器
- en: 'One of the requirements for the application is to allow users to filter several
    of the collection items’ properties. Let’s start simple, by adding a filter only
    on the medium (**Book**, **Music**, or **Movie**). The list also needs an **All**
    option, which will be the default selection when users open the application:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的一个要求是允许用户过滤集合项的多个属性。让我们从简单开始，只添加对媒体（**Book**、**Music** 或 **Movie**）的过滤。列表还需要一个
    **All** 选项，当用户打开应用程序时，它将是默认选择：
- en: 'First, add some XAML to `MainWindow` to add a filter to the right of the `Media`
    label. Replace `Media` `TextBlock` with the following markup:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向 `MainWindow` 添加一些 XAML 代码，以便在 `Media` 标签的右侧添加一个过滤器。将 `Media` `TextBlock`
    替换为以下标记：
- en: '[PRE16]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The single `TextBlock` label has been replaced with a two-column `Grid`. The
    first column contains the `TextBlock`, with a few modifications. First, the `Text`
    property has been updated to `"Media Collection"`. `FontWeight` has been changed
    to `"Bold"` and some margin has been added. Finally, the element is vertically
    centered.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单一的 `TextBlock` 标签已被替换为两列的 `Grid`。第一列包含 `TextBlock`，进行了一些修改。首先，`Text` 属性已更新为
    `"Media Collection"`。`FontWeight` 已更改为 `"Bold"`，并添加了一些边距。最后，该元素垂直居中。
- en: The second column contains a new `StackPanel` (a container control that stacks
    its contents horizontally or vertically). The default orientation is `Vertical`.
    In our case, we want a horizontal stack, which is why the `Orientation` property
    has been set.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二列包含一个新的 `StackPanel`（一个水平或垂直堆叠其内容的容器控件）。默认方向是 `Vertical`。在我们的情况下，我们想要一个水平堆叠，这就是为什么将
    `Orientation` 属性设置为 `Horizontal` 的原因。
- en: '`StackPanel` contains a `TextBlock` label and a `ComboBox` for the filter selection.
    The `ComboBox` filter has been given an `x:Name` so we can reference it from the
    C# code-behind file when initializing its contents. We have also configured a
    `MinWidth` value of `120`. If the contents of the `ComboBox` filter require more
    than 120 **pixels** (**px**), it can grow larger, but its width cannot be less
    than the value set here.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackPanel` 包含一个 `TextBlock` 标签和一个用于过滤选择的 `ComboBox`。`ComboBox` 过滤器已被赋予一个
    `x:Name`，这样我们就可以从 C# 后台代码文件中引用它以初始化其内容。我们还配置了一个 `MinWidth` 值为 `120`。如果 `ComboBox`
    过滤器的内容需要超过 120 **像素**（**px**），它可以变得更大，但它的宽度不能小于此处设置的值。'
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The pixels being referenced in XAML are effective pixels. To read more about
    responsive layouts and sizing with XAML, see this Microsoft Learn article: [https://learn.microsoft.com/windows/apps/design/layout/layouts-with-xaml](https://learn.microsoft.com/windows/apps/design/layout/layouts-with-xaml).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XAML 中引用的像素是有效像素。要了解更多关于使用 XAML 的响应式布局和尺寸信息，请参阅这篇 Microsoft Learn 文章：[https://learn.microsoft.com/windows/apps/design/layout/layouts-with-xaml](https://learn.microsoft.com/windows/apps/design/layout/layouts-with-xaml)。
- en: 'In the `MainWindow.xaml.cs` file, add a new variable to hold the list of mediums,
    as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml.cs` 文件中，添加一个新的变量来保存媒体列表，如下所示：
- en: '[PRE17]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This collection can be an `IList` rather than `ObservableCollection` because
    we don’t expect its contents to change while the application is running.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个集合可以是一个 `IList` 而不是 `ObservableCollection`，因为我们不期望在应用程序运行期间其内容发生变化。
- en: 'Inside the `PopulateData()` method, add some code at the end of the method
    to populate the `_mediums` list, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PopulateData()` 方法内部，在方法末尾添加一些代码来填充 `_mediums` 列表，如下所示：
- en: '[PRE18]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’re adding an item to the collection for each of the possible values in our
    `ItemType` enum, plus the default `"``All"` value.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为 `ItemType` 枚举中的每个可能值以及默认的 `"All"` 值添加一个项到集合中。
- en: 'The `ComboBox` filter will be bound to the collection after it has loaded,
    so add a `Loaded` event handler in the `MainWindow` constructor, as we did for
    the `ItemList` earlier, like this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ComboBox` 过滤器将在加载后绑定到集合，因此请在 `MainWindow` 构造函数中添加一个 `Loaded` 事件处理器，就像我们之前为
    `ItemList` 所做的那样，如下所示：'
- en: '[PRE19]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `ItemFilter_Loaded` event handler will look much like the `ItemList_Loaded`
    handler. Use the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ItemFilter_Loaded` 事件处理器将与 `ItemList_Loaded` 处理器非常相似。使用以下代码：'
- en: '[PRE20]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code casts the sender to the `ComboBox` data type and sets its `ItemSource`
    to the list we populated in the previous step. Finally, an additional step is
    needed to default the `ComboBox` filter to default to the `"All"` item. This is
    accomplished by setting `SelectedIndex` equal to `0`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将发送者转换为 `ComboBox` 数据类型，并将其 `ItemSource` 设置为我们上一步填充的列表。最后，还需要一个额外的步骤来将 `ComboBox`
    过滤器默认设置为 `"All"` 项。这是通过将 `SelectedIndex` 设置为 `0` 来实现的。
- en: 'Let’s run the application and see how it looks now. You can see the result
    in the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行应用程序并看看现在看起来如何。您可以在以下屏幕截图中看到结果：
- en: '![Figure 2.16 – Media Collection with the Media Type filter added](img/B20908_02_016.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 添加了媒体类型过滤器的媒体集合](img/B20908_02_016.jpg)'
- en: Figure 2.16 – Media Collection with the Media Type filter added
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 添加了媒体类型过滤器的媒体集合
- en: 'Pretty sharp! If you click the **Media Type** filter, you can see the four
    values available for selection, as illustrated here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 非常锐利！如果您点击 **媒体类型** 过滤器，您可以看到可用的四个选择值，如图所示：
- en: '![Figure 2.17 – Media Type values](img/B20908_02_017.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 媒体类型值](img/B20908_02_017.jpg)'
- en: Figure 2.17 – Media Type values
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 媒体类型值
- en: 'Notice how the dropdown of `ComboBox` has picked up the Windows style with
    some transparency without having to add any additional code or markup. Select
    one of the other values in the list and see what happens. Nothing! That’s because
    we haven’t added any code to do the filtering when the selection changes on the
    filter. We can add a little bit of extra code to fix that, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `ComboBox` 的下拉菜单已经采用了带有一定透明度的 Windows 风格，而无需添加任何额外的代码或标记。选择列表中的其他值并查看会发生什么。什么都没有！这是因为我们没有在过滤器选择变化时添加任何代码来进行过滤。我们可以添加一些额外的代码来修复这个问题，如下所示：
- en: 'First, create a new `_allItems` collection to store a list of all available
    media items, regardless of the current filter, like this:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 `_allItems` 集合来存储所有可用的媒体项列表，无论当前过滤器如何，如下所示：
- en: '[PRE21]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, in the `PopulateData()` method, after populating the `_items` collection,
    add the same items to `_allItems`, like this:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `PopulateData()` 方法中，在填充 `_items` 集合之后，添加相同的项到 `_allItems`，如下所示：
- en: '[PRE22]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we need to do some filtering when the filter selection changes. We want
    to handle the `SelectionChanged` event on the `ComboBox` control, but we don’t
    want to hook it up until after the entire page has loaded. This will prevent the
    event from being handled while the `ComboBox` filter is initially being populated.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当过滤器选择变化时，我们需要进行一些过滤。我们想要处理 `ComboBox` 控件上的 `SelectionChanged` 事件，但我们不希望在页面完全加载之前将其连接起来。这将防止在
    `ComboBox` 过滤器最初被填充时处理该事件。
- en: 'At the end of the implementation of `ItemFilter_Loaded`, add an event handler
    for the `SelectionChanged` event on the `ComboBox` control:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ItemFilter_Loaded` 的实现结束时，为 `ComboBox` 控件上的 `SelectionChanged` 事件添加一个事件处理器：
- en: '[PRE23]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the new `ItemFilter_SelectionChanged` event handler, we will iterate through
    the `_allItems` list and determine which of the items to include in the filtered
    list, based on their `MediaType` property, as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 `ItemFilter_SelectionChanged` 事件处理器中，我们将遍历 `_allItems` 列表，并根据它们的 `MediaType`
    属性确定要包含在过滤列表中的项目，如下所示：
- en: '[PRE24]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If the filter value is empty or `MediaType`. Otherwise, we check whether the
    `MediaType` matches the selection in `ItemFilter` `ComboBox`. When there is a
    match, we add it to the `updatedItems` list. Then, we set `updatedItems` as `ItemsSource`
    on the `ListView`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过滤器值为空或 `MediaType`。否则，我们检查 `MediaType` 是否与 `ItemFilter` `ComboBox` 中的选择匹配。当有匹配时，我们将其添加到
    `updatedItems` 列表中。然后，我们将 `updatedItems` 设置为 `ListView` 的 `ItemsSource`。
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A filter should never be empty unless there is an error while initializing the
    data. This condition is only a safeguard for unforeseen scenarios.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器永远不应该为空，除非在初始化数据时出现错误。这个条件只是为了防范不可预见的情况。
- en: 'Now, run the app again and select **Book** in the filter, as illustrated in
    the following screenshot:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行应用程序，并在过滤器中选择 **Book**，如图所示：
- en: '![Figure 2.18 – Media Collection filtered to display only books](img/B20908_02_018.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 仅显示书籍的媒体集合](img/B20908_02_018.jpg)'
- en: Figure 2.18 – Media Collection filtered to display only books
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 仅显示书籍的媒体集合
- en: That takes care of the filter implementation for the time being. Let’s finish
    up this part of the UI design with a `Button`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就暂时处理了过滤实现。让我们用 `Button` 完成这部分 UI 设计。
- en: Adding a new item button
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新项目按钮
- en: We are not quite ready to start working with multiple windows or navigation
    yet. You should have some understanding of the `Button` to the current page and
    add some code to ensure everything is hooked up correctly.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有准备好开始使用多个窗口或导航。你应该对当前页面的 `Button` 有一些了解，并添加一些代码以确保一切连接正确。
- en: 'Open the `MainWindow.xaml` file and add a third `RowDefinition` to the top-level
    `Grid` on the `Window`, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件，并在 `Window` 的顶级 `Grid` 上添加第三个 `RowDefinition`，如下所示：
- en: '[PRE25]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The new row will have a height of `Auto` so that it sizes itself to fit the
    `Button`. We still want the `ListView` to take up most of the screen.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 新行将具有 `Auto` 高度，以便它根据 `Button` 的大小自动调整。我们仍然希望 `ListView` 占据屏幕的大部分空间。
- en: 'Now, after the closing tag of the `ListView` control, add the new `Button`,
    as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `ListView` 控件的关闭标签之后，添加新的 `Button`，如下所示：
- en: '[PRE26]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As discussed in the previous chapter, the `Button` control does not have a `Text`
    property. Instead, if you only want a `Button` control to contain text, you assign
    it to the `Content` property. We are also assigning the `Button` control to the
    third row of the `Grid`, setting the margin, and aligning it to the right side
    of the `Grid`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，`Button` 控件没有 `Text` 属性。相反，如果你想只让 `Button` 控件包含文本，你可以将其分配给 `Content`
    属性。我们还将 `Button` 控件分配到 `Grid` 的第三行，设置边距，并将其对齐到 `Grid` 的右侧。
- en: 'Let’s see how the app looks now, as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在应用程序看起来如何，如下所示：
- en: '![Figure 2.19 – My Media Collection with an Add Item button](img/B20908_02_019.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 带有添加项目按钮的我的媒体集合](img/B20908_02_019.jpg)'
- en: Figure 2.19 – My Media Collection with an Add Item button
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 带有添加项目按钮的我的媒体集合
- en: The button doesn’t do anything yet. Because we’re not yet ready to add an additional
    window to the application to add items, let’s open a message popup to inform the
    user that this function is not available.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮目前还没有做任何事情。因为我们还没有准备好向应用程序添加一个额外的窗口来添加项目，让我们打开一个消息弹出窗口来通知用户此功能不可用。
- en: 'In `MainWindow.xaml`, wire up a new event handler inside `AddButton`. You can
    also remove the `x:Name` attribute. We’re able to remove the name because we do
    not need to reference it in the code-behind file. The code is shown in the following
    snippet:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml` 中，在 `AddButton` 内部连接一个新的事件处理器。你也可以移除 `x:Name` 属性。我们能够移除这个名称，因为我们不需要在代码-behind
    文件中引用它。代码如下所示：
- en: '[PRE27]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can create the event handler by placing the cursor on the name of the handler,
    `AddButton_Click`, and pressing *F12*. This will create the handler and navigate
    to it in the `MainWindow.xaml.cs` file. Inside the `AddButton_Click` event handler,
    we will create a new `ContentDialog` with the message we want to display to the
    user.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将光标放在处理器名称 `AddButton_Click` 上并按 *F12* 来创建事件处理器，这将创建处理器并导航到 `MainWindow.xaml.cs`
    文件。在 `AddButton_Click` 事件处理器内部，我们将创建一个新的 `ContentDialog`，并显示我们想要向用户显示的消息。
- en: Note
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The call to `dialog.ShowAsync()` must be awaited, so remember to add the `async`
    directive to the event handler, as shown next.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `dialog.ShowAsync()` 必须等待，所以请记住在事件处理器中添加 `async` 指令，如下所示。
- en: 'The `async` directive is highlighted in the following code snippet for the
    new event handler:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`async` 指令被突出显示，用于新的事件处理器：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, run the application again and click the **Add Item** button, as illustrated
    in the following screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行应用程序并单击如图所示的 **添加项目** 按钮：
- en: '![Figure 2.20 – Displaying a ContentDialog popup](img/B20908_02_020.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 显示 ContentDialog 弹出窗口](img/B20908_02_020.jpg)'
- en: Figure 2.20 – Displaying a ContentDialog popup
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 显示 ContentDialog 弹出窗口
- en: That’s all there is to adding a functional `Button` to a WinUI page. As we have
    discussed, some of this code will change and be moved to a `ViewModel` in the
    next chapter, but you should now have a good idea of how to work with some basic
    `Button` properties and events.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是向 WinUI 页面添加功能 `Button` 的全部内容。正如我们讨论的那样，其中一些代码将在下一章中更改并移动到 `ViewModel` 中，但你现在应该已经很好地了解了如何使用一些基本的
    `Button` 属性和事件。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have made some great initial progress on the **My Media Collection** application
    in this chapter. Along the way, you have learned how to use several common WinUI
    controls. You have also learned how to change the appearance, layout, and behavior
    of WinUI controls by using different layout controls and updating control properties
    in XAML. Finally, you saw how to leverage data binding and events to add and update
    data displayed to the user.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在 **我的媒体收藏** 应用程序上取得了很大的初步进展。在这个过程中，你学习了如何使用几个常见的 WinUI 控件。你还学习了如何通过使用不同的布局控件和更新
    XAML 中的控件属性来更改 WinUI 控件的外观、布局和行为。最后，你看到了如何利用数据绑定和事件来添加和更新显示给用户的数据。
- en: Next, we will learn how to decouple some of the logic we have been writing in
    the code-behind files to build testable and maintainable applications.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将我们在代码隐藏文件中编写的部分逻辑解耦，以构建可测试和可维护的应用程序。
- en: Questions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you add or remove features to or from Visual Studio?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何向 Visual Studio 添加或删除功能？
- en: What is the lowest minimum version of Windows that must be targeted when creating
    a new WinUI 3 project?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的 WinUI 3 项目时，必须针对哪个最低 Windows 版本？
- en: Where can you add XAML resources that can be shared by components in a whole
    application?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在哪里添加可以被整个应用程序中的组件共享的 XAML 资源？
- en: What is the default name of the first window loaded in a new WinUI app?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 WinUI 应用程序中，第一个加载的窗口的默认名称是什么？
- en: Which XAML container control allows you to define rows and columns to lay out
    its contents?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 XAML 容器控件允许你定义行和列来布局其内容？
- en: Which XAML container control stacks its contents horizontally or vertically?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 XAML 容器控件水平或垂直堆叠其内容？
- en: What is the name of the message box that WinUI apps can use to display simple
    messages to users?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WinUI 应用程序可以使用哪个消息框来向用户显示简单的消息？
- en: 'Challenge: What type of layout panel in WinUI allows its contents to be positioned
    absolutely?'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：WinUI 中哪种布局面板允许其内容绝对定位？
