- en: '*Chapter 7*: Unity API – Making Choices and Story Progression'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter begins with reviewing how to add a `script` component to a game
    object in Unity. By creating a `script` component associated with a C# file, code
    can be written to load the compiled JSON files created by the ink-Unity Integration
    plugin from ink source files as part of the Unity scene. Next, we will examine
    how to load an ink story and start to progress through it. We will see how to
    programmatically make selections of options presented by ink and then how to continue
    story progression as a result. We will end with an example of a common approach
    of presenting multiple user interface elements to a player in Unity. A user will
    be able to click buttons in Unity and guide story progression in a running ink
    story.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a compiled ink story
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting options programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dynamic user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples used in this chapter, in `*.ink` files, can be found online on
    GitHub: [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7).'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a compiled ink story
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092), *Adding and
    Working with the ink-Unity Integration Plugin*, we saw how to add new ink files
    to a Unity project. After importing the plugin, new files can be created using
    the **Create** menu from the **Project** window. When an ink source was added,
    the plugin automatically created a compiled JSON file. As we now move into working
    with the ink API provided by the plugin, we will use the created JSON files for
    working with a story.
  prefs: []
  type: TYPE_NORMAL
- en: The first step for working with code in Unity is to create a `GameObject`. This
    is a basic container in Unity. Each `GameObject` holds at least one component.
    The different systems in Unity, such as the rendering system (for drawing things
    on a screen), physics (for detecting whether two things overlap on a screen),
    and input (for detecting whether a user presses a button) all communicate with
    these components. When Unity runs a project, it sends data to components matching
    the system associated with it. For example, to work with data from the input system,
    an input component is needed.
  prefs: []
  type: TYPE_NORMAL
- en: To work with code in Unity, a `script` component is needed. All code added to
    a Unity project works through being a part of different systems. A `script` component
    allows a developer to write code for working with a game object and the different
    components it contains. Unlike most other components that primarily receive data
    from different systems, a `script` component can *script* other objects and values.
    Through code, it can instruct other components to change their values when different
    events, such as a user clicking on a button, happen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a script component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any game object can have a `script` component. However, for better organization,
    it is often useful to create a new `GameObject` for each type of data, behavior,
    or task related to a project. This separates each new action or possible event
    with a `GameObject` and makes working on the different parts of a larger project
    much easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new or existing Unity project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not already added, be sure to install the ink-Unity Integration plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are always multiple ways to do things in Unity, and this is also true
    of creating a new game object. One of the easiest ways to create a new game object
    is by using the **GameObject** menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **GameObject** and then click on **Create Empty**.![Figure 7.1 – GameObject
    menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.1 – GameObject menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A new `GameObject` will be created and added to the `GameObject` will show its
    current components in the `GameObject` is merely a container. Its components do
    all the work involved with running the project. Even the name of the `GameObject`
    is a value contained as part of its components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To change the name of the created `GameObject`, click on it in the `GameObject`
    (the default value) to `Ink` `Story`.![Figure 7.3 – Ink Story name change in Unity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.3 – Ink Story name change in Unity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The newly named `Ink` `Story` will be a container for other components related
    to running an ink story. Changing the name of the game object to `Ink` `Story`
    makes it easier to find it among potentially many other objects in the project
    and explains its role in the project as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the components of `Ink` `Story` shown in the **Inspector** view, click
    on **Add Component**.![Figure 7.4 – Component listing in the Add Component menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.4 – Component listing in the Add Component menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the listing, click on **New script**.![Figure 7.5 – New script component
    creation](img/Figure_7.5_B17597.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.5 – New script component creation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Name this new script file `inkLoader.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking on the `script` component name does not always allow access to rename
    the file in Unity. Pressing the down arrow twice on the keyboard will move the
    selection from the search to the title of the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Script renamed InkLoader](img/Figure_7.6_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7.6 – Script renamed InkLoader
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After renaming the file, click the **Create and Add** button. A new C# file
    will be added to the **Project** window.![Figure 7.7 – Assets in Unity with the
    new InkLoader.cs file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.7_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.7 – Assets in Unity with the new InkLoader.cs file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Double-click on this file to open it in Visual Studio for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This first section has included a step-by-step process of preparing a Unity
    project for working with the ink Story API. We have seen how to create a `GameObject`
    and add a `script` component. In the next section, we will build on this project
    to begin to work with the Story API added to Unity as part of the ink-Unity Integration
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ink Story API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing the ink-Unity Integration plugin adds an additional `Ink`. It contains,
    in turn, three other namespaces named `Parsed`, `Runtime`, and `UnityIntegration`,
    each of which contains classes related to their names. To work with compiled ink
    JSON files, the `Ink``.Runtime` namespace is needed. This tells Unity that it
    should start with the `ink` namespace and then find the namespace within it named
    `Runtime`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file opened in the *Creating a script component* section, add a new
    `using` line after those already there in the created file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a public field called `inkJSONAsset` and change the `Start()`
    method to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the `InkLoader.cs` file in Visual Studio and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a moment, Unity will refresh and reload the changed C# file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to associate an ink JSON file with the created C# file. In
    the `InkStory` game object. In the `script` component, as shown in the following
    screenshot:![Figure 7.8 – New Ink JSON Asset property in the Inspector view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.8_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.8 – New Ink JSON Asset property in the Inspector view
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The property shows the value `None (Text Asset)`. This means no files are associated
    with this property. To change this, a compiled JSON file needs to be added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An ink JSON file will be needed for the next steps. If one is not created, add
    a new one by creating an ink file and letting the **Automatic compile** option
    create one, or click on an existing ink source file and then click on **Compile**
    in the **Inspector** view to create a new JSON file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **TextAsset** selection circle next to the value to open a **Select
    TextAsset** window.![Figure 7.9 – Select TextAsset window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.9_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.9 – Select TextAsset window
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select an ink-compiled JSON file.![Figure 7.10 – Updated Ink JSON Asset property
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.10 – Updated Ink JSON Asset property
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the value of the **Ink JSON Asset** property updates, close the **Select
    TextAsset** window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Play** button in the middle of the Unity editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Play button in Unity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Play button in Unity
  prefs: []
  type: TYPE_NORMAL
- en: Unity will run the current scene, and nothing will appear to happen. If no errors
    appear in the **Console** window, everything has run correctly. Internally, Unity
    has loaded the compiled ink JSON file and is ready to run the ink story.
  prefs: []
  type: TYPE_NORMAL
- en: Stop the running scene by clicking on the **Play** button a second time.
  prefs: []
  type: TYPE_NORMAL
- en: Running an ink JSON file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ink stories are run using the `Story` class and methods. Loading an ink JSON
    file is only the first step. The `Story` class must be told to load one or more
    *lines* of the story at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Inky was used to run the ink source file previously, it displayed one
    line at a time with an empty line between them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When run in Inky, *Example 1* creates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Example 1 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – Example 1 output
  prefs: []
  type: TYPE_NORMAL
- en: 'In Inky, the extra lines it created are a result of its own use of the Story
    API. To replicate this output, we will need to add a new method: `Continue()`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the same file used as part of the *Adding the ink Story API* section, open
    the file in Inky for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the content of the new ink source file to *Example 1* and then save the
    file in Inky. Do not close Inky after saving the file. Now return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon detecting the change in the ink source file, the ink-Unity Integration
    plugin will automatically re-compile the ink JSON file. Because it was associated
    with the Ink JSON Asset property as part of the *Adding the ink Story API* section,
    the ink JSON file will also always be loaded correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `InkLoader.cs` file is not already open in Visual Studio, double-click
    on it in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line to the `Start()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the changed `inkLoader.cs` file and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Play** button to run the current scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, the **Console** window will show a message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Console window in Unity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.13_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – Console window in Unity
  prefs: []
  type: TYPE_NORMAL
- en: The `Debug.Log()` method used what was returned by the `Continue()` method as
    part of the `Story` class to display a message in the **Console** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time the `Continue()` method is called, it loads the next line in an ink
    story and returns a string representing it. However, the method has an issue:
    it cannot detect the end of a story. For that, a different property is required.'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the running scene by clicking on the **Play** button again.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a story can continue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Continue()` method loads the next line of a story if it is available. In
    the code from *Example 1*, there are two lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to Visual Studio and edit the `Ink``Loader.cs` file. Change the `Story()`
    method to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the `InkLoader.cs` file after adding the new line of code. Return to Unity
    and click on the **Play** button to play the current scene and updated file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Continue()` method and then passed to the `Debug.Log()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Play** button again in Unity to stop the current scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return to Visual Studio and edit the `InkLoader.cs` file. Add the following
    code to the `Start()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the updated `InkLoader.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to Unity and play the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the third use of the `Continue()` method, an error will happen and be displayed
    in the **Console** window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Continue() error in the Unity console'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.15_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.15 – Continue() error in the Unity console
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the `Continue()` method does not check whether there is another line
    to load. When there is no more content, it throws an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fix this issue, a property mentioned in the error is needed. The `Story`
    class provides the `canContinue` property for checking whether there is more story
    content to load. It contains a Boolean value. If there is more content, `canContinue`
    will be `true`. Otherwise, it will be `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Return to Visual Studio and edit the `InkLoader.cs` file. Update the `Start()`
    method in the `InkLoader.cs` file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the edited `InkLoader.cs` file in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to Unity and play the scene again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the use of a `while` loop, the story will be loaded line by line until
    there is no content left. Once this happens, the `canContinue` property is changed
    to `false` and the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Console window using an updated while loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.16_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.16 – Console window using an updated while loop
  prefs: []
  type: TYPE_NORMAL
- en: The combination of the `canContinue` property with the `Continue()` method is
    a common pattern when using the Story API. More advanced usage patterns may not
    use a `while` loop, but the property and method will often appear together.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting options programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying only the text of an ink story has limited usefulness. Most advanced
    ink stories use weaves to present different options. Along with the `Continue()`
    method and the `canContinue` property, the Story API also has another property
    called `currentChoices` that contains a list of the options generated by the most
    recent weave.
  prefs: []
  type: TYPE_NORMAL
- en: As was demonstrated in the *Checking whether a story can continue* section,
    the `canContinue` property is affected by the `Continue()` method. After each
    line is loaded and returned as a string, the `Story` class will update the `canContinue`
    property if there is more story to load. This is also true of the `currentChoice`
    property. When the `Continue()` method is used, it will load the next line *and*
    any weaves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Any previously used game objects or C# files created as part of this chapter
    can safely be deleted. This section will create a new game object and script component,
    and use different code for working with weaves and options.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting ink choices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step to act on a weave is to detect that its choices have been loaded
    by the `currentChoices` property. This means both the `canContinue` property and
    `Continue()` method are also needed. The first prevents any issues of trying to
    load content that may not exist and the second loads the current line and any
    weaves along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: In a new or existing Unity project with no other game objects using the Story
    API, create a new, empty `GameObject`. Name it `Ink` `Choices`.![Figure 7.17 –
    ink Choices GameObject
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.17_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.17 – ink Choices GameObject
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As was shown in the *Creating a script component* section, create a new `script`
    component on the `Ink` `Choices` game object. Name this new file `LoadingChoices.cs`.![Figure
    7.18 – LoadingChoices.cs file in the Assets window](img/Figure_7.18_B17597.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.18 – LoadingChoices.cs file in the Assets window
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Double-click on the `LoadingChoices.cs` file in the **Assets** window to open
    it for editing in Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file in Visual Studio and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new ink file and name (or rename) the file to `Example3.ink`.![Figure
    7.19 – Example3.ink file in the Assets window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.19_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.19 – Example3.ink file in the Assets window
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Following the instructions in the *Running an ink JSON file* section, associate
    the automatically generated ink JSON file with the `Ink` `Choices` game object
    property.![Figure 7.20 – Example3.json file associated with the ink JSON Asset
    property](img/Figure_7.20_B17597.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.20 – Example3.json file associated with the ink JSON Asset property
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `Example3.ink` file for editing in Inky. Change it to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the changed `Example3.ink` file. Return to Unity and run the scene. The
    **Console** window in Unity will now show the text content of each option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Example 3 options in the Console window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.21_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.21 – Example 3 options in the Console window
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the `Continue()` method loaded not only the first line of *Example
    3* but also the first weave appearing within the code. The `currentChoices` property
    contains a `List<Choice>` of objects per choice that exists within the weave.
    Each element of `List<Choice>` is a `Choice` object, a special class containing
    two important properties: `index` and `text`.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the `foreach` loop, the `text` property of each `Choice` object is retrieved.
    This is then passed to the `Debug.Log()` method. When run, the ink story is loaded.
    Next, the first line and weave are loaded. Inside the loop, the `currentChoices`
    property is used to retrieve the value of each `text` property. Each is then shown
    in the `Debug.Log()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Making choices using the Unity API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Options are selected by players to continue a story. Within the ink source code,
    a choice is created using either the asterisk (`*`) or the plus symbol (`+`).
    When run, the ink runtime code as part of the `Story` class creates *options*
    from these source code choices. However, to progress in an ink story, a choice
    must be *made*. It must exist in the code and then be presented as an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Story` class provides a method named `ChooseChoiceIndex()`. This accepts
    an *index* (`int`) within the range of the current total number of elements in
    the `currentChoices` property. Each `Choice` object within the list of `currentChoices`
    has `index` and `text` properties. In the *Detecting ink choices* section, the
    `text` property was used to display the generated option from the ink source file.
    To *make* a choice, its `index` property is used:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `LoadingChoices.cs` file from the *Detecting ink choices*
    section to open it for editing if it is not already open in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file in Visual Studio, return to Unity, and run the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `0`) position element within the `currentChoices` property.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Option chosen from Example 3 in the Console window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.22_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.22 – Option chosen from Example 3 in the Console window
  prefs: []
  type: TYPE_NORMAL
- en: The `ChooseChoiceIndex()` method selects the first choice within the weave based
    on the `index` property of `exampleChoice`. This is then displayed in the Unity
    `Continue()` method.
  prefs: []
  type: TYPE_NORMAL
- en: To *make* choices when using ink and Unity, a combination of things needs to
    happen in sequence. First, a story must be loaded. Second, at least one line needs
    to be loaded that also contains a weave. Next, the `currentChoices` property of
    the `Story` class must be used to retrieve the created options for the player.
    The `ChooseChoiceIndex()` method then needs to be used with the `index` property
    of one of the `Choice` objects retrieved from the `currentChoices` property. Finally,
    the next part of the story needs to be loaded. This additional loading will include
    the text of the option (if selective output is not used) chosen using the `ChooseChoiceIndex()`
    method. The rest of the story can then proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Loading all text until the next weave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While useful for loading story content, the `Continue()` method must be used
    multiple times to load each line at a time. As with the code in the *Making choices
    using the Unity API* section, this means it would need to appear across multiple
    lines of code. Anticipating this problem, the Story API also includes a method
    named `ContinueMaximally()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of loading a line at a time, the `ContinueMaximally()` method loads
    all content until it encounters a weave. For many projects, this is a preferred
    method to use when there might be multiple lines of text between weaves or generated
    by ink internally as a part of the weave itself:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new ink source file in Unity. Name (or rename) the file to `Example4.ink`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Example4.ink` for editing in Inky and update it to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the `Example4.ink` file with the content from *Example 4*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Example3.json` to `Example4.json`.![Figure 7.23 – Updated Example4.json
    value in the Inspector view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.23_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.23 – Updated Example4.json value in the Inspector view
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Double-click on `LoadingChoices.cs` to open it for editing in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the changes in Visual Studio, return to Unity, and run the scene.![Figure
    7.24 – Loaded lines and choice text from Example 4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.24_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.24 – Loaded lines and choice text from Example 4
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Stop the running scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first usage of the `ContinueMaximally()` method loaded the first two lines
    and the weave. Next, the `ChooseChoiceIndex()` method chose the first option.
    The second `ContinueMaximally()` method usage, when paired with the internal divert,
    then loaded the next line and the weave again.
  prefs: []
  type: TYPE_NORMAL
- en: When working with looping structures, the `ContinueMaximally()` method is often
    better than using the `Continue()` method. Use of the `ContinueMaximally()` method
    will always load all the new text until it encounters the next weave. For loops
    where text might appear between weaves, a single use of the `ContinueMaximally()`
    method would achieve the same effect as multiple calls to the `Continue()` method
    to load the same content.
  prefs: []
  type: TYPE_NORMAL
- en: This topic started with detecting choices in a running ink story with the `currentChoices`
    property. We then moved into making choices, both creating them in the ink code
    and then using the `ChooseChoiceIndex()` method to pick them. Finally, we saw
    how the `ContinueMaximally()` method can be combined with both the `currentChoices`
    property and the `ChooseChoiceIndex()` method. In the next topic, we will expand
    on these concepts. To create a dynamic interface, we can use our knowledge of
    the Story API to associate the `GameObjects` user interface and create a connection
    between clicking a button on the screen and progressing an ink story.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Story` class provides multiple methods for loading and progressing a story.
    However, without a user interface, a player is not able to select between options
    and see the result. To fix this problem, additional game objects are needed to
    show text and provide an interface for a user to click on different things.
  prefs: []
  type: TYPE_NORMAL
- en: To start, a new project is needed. Instead of example code, this will use different
    user interface objects for working with a user. The project will also need to
    create a `GameObject` can become *prefabricated* by moving it from the `GameObject`
    during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The current lines as returned by the `ContinueMaximally()` method and choices
    in the `currentChoices` property can potentially be dynamic while an ink story
    runs. Combined with a Prefab, C# code can recreate an interface dynamically because
    of a player clicking on buttons to make choices in a story.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will move through the steps of creating a dynamic interface
    by starting with a new Unity project and creating the necessary game objects.
    Next, we will associate a Prefab with our code. Finally, we will end with a section
    on putting everything together and running the combined project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project and game objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us now start with creating a new project and game objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Unity. Name this project `The Body` and use a 2D template.![Figure
    7.25 – Unity Hub project creation with the name of The Body](img/Figure_7.25_B17597.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.25 – Unity Hub project creation with the name of The Body
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before doing anything else, install the ink-Unity Integration plugin in the
    new project using the instructions as part of [*Chapter 6*](B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092),
    *Adding and Working with the ink-Unity Integration Plugin*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the project has been created by Unity, add a `Canvas` game object to the
    `Canvas` game object can be accessed by selecting `Canvas` game object, Unity
    will automatically add an `EventSystem` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Canvas` game object. In the **Inspector** view, click on the **Add
    Component** button. Select **Layout** and then **Vertical Layout Group**.![Figure
    7.27 – Vertical Layout Group component selection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.27_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.27 – Vertical Layout Group component selection
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A vertical layout group will automatically align all other UI game objects within
    itself in a *vertical* pattern.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the vertical layout group, click on the **Child Alignment** dropdown and
    select **Middle Center**.![Figure 7.28 – Vertical Layout Group with Middle Center
    selected
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.28_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.28 – Vertical Layout Group with Middle Center selected
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the `Canvas` game object selected in the `Text` game object. `Text` game
    objects can be found under `Text` will be added as a child of the `Canvas` game
    object.![Figure 7.29 – Added Text game object in the Hierarchy view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.29_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.29 – Added Text game object in the Hierarchy view
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the `Canvas` game object selected in the `Button` game object. `Button`
    can be found under `Button` game object will be added as a child of the `Canvas`
    game object.![Figure 7.30 – Added Button game object in the Hierarchy view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.30_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.30 – Added Button game object in the Hierarchy view
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the newly added `Button` game object, and then click and drag it from
    the `Button` in the **Project** window.![Figure 7.31 – Prefab created in the Project
    window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.31_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.31 – Prefab created in the Project window
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the `Button` game object icon changes in the `Button` game object in the
    `Button` game object is now a Prefab, it exists as an asset and does not need
    to exist in the current **Hierarchy** view. (It will later be instantiated by
    code.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the project and game objects created, the next item is a `script` component.
    This will create the necessary properties for other files to be associated with
    running the story.
  prefs: []
  type: TYPE_NORMAL
- en: Associating Prefab and ink JSON files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating the game objects in the last section, we will now create a `script`
    component, create the necessary properties, and then associate assets with the
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Canvas` game object in the **Hierarchy** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `script` component using the instructions in the *Creating a script component*
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name (or rename following creation) this new file `InkStory.cs`.![Figure 7.32
    – Created InkStory.cs file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.32_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.32 – Created InkStory.cs file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Double-click on the `InkStory.cs` file for editing in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the code to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are three new additions to the default code provided by Unity. The first
    is the inclusion of the `Ink.Runtime` namespace. This will allow us to work with
    ink while a story runs. The second two additions are the properties we will be
    using in the `public` keyword in C# to create a property we can adjust in the
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new ink file named (or renamed following creation) `TheBody.ink`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `TheBody.ink` file in Inky for editing and copy the contents from the
    file from GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code for this example, `TheBody.ink`, can be found on GitHub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the ink source file and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The use of the `public` keyword in `InkStory.cs` added two new properties to
    the `Canvas` game object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.33 – Properties added in the Inspector view'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.33_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.33 – Properties added in the Inspector view
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the file selection next to the `Ink` `JSON Asset` property to open
    the **Select TextAsset** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Associate the ink JSON file created by the ink-Unity Integration plugin with
    the **Ink JSON Asset** property and then close the **Select TextAsset** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the file selection next to the `Button` Prefab to open the **Select
    GameObject** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Assets** tab in the **Select GameObject** window if it is not open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Button** Prefab and then close the **Select GameObject** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of associating the ink JSON file with the `Button` Prefab will be
    that the code has access to those assets during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34 – Updated Ink Story component with the ink JSON file and button
    Prefab values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.34_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.34 – Updated Ink Story component with the ink JSON file and button
    Prefab values
  prefs: []
  type: TYPE_NORMAL
- en: With the file associated with properties of the `script` component, additional
    code can now be written. Changing the ink source file, `TheBody.ink`, and saving
    the change will automatically update the `TheBody.json` file. The same is also
    true of the `Button` Prefab. It can also be adjusted, and its settings changed.
    As long as neither asset is renamed, Unity will maintain the association and allow
    developers to customize their settings independent of the code using them when
    the scene runs.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, we will have created a Unity project, its game objects,
    and associated assets with properties. Before we can run the project, we will
    need to write more code to dynamically create a user interface based on the content
    of a running ink story. In the next section, we will write the code to use the
    Prefab and create a dynamic interface based on the text output of the `ContinueMaximally()`
    method and the `currentChoices` property.
  prefs: []
  type: TYPE_NORMAL
- en: Making a dynamic user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final series of steps needed before the Unity project can be run is to add
    more code. We need to incorporate the concepts explained in this chapter covering
    the use of the `ContinueMaximally()` method and the `currentChoices` property.
    We also need to add an overall loop within the code using the `canContinue` property
    to check whether there is more content before progressing the story.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by adding the properties we will need within the class that will not
    be used by the Unity editor. We mark these using the `private` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `InkStory.cs` for editing in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To work with user interface game objects, another instance of the `using` keyword
    is needed. This adds access to classes such as `Text` and `Button` used in this
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `Story` class and the `Text` game object `currentLinesText` will be used
    across methods in this code. To make sure they can be used in this way, they must
    be properties of the `InkStory` class and not variables within any method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that must happen is the loading of the ink JSON file. Next,
    a reference to the `Text` component is needed. The text will be shown to the user
    each time they make a choice. This means the `text` property of the `Text` game
    object will need to be updated. However, as it is a child of `Canvas`, the `GetComponentInChildren()`
    method is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of loading the text content and current choices will be used multiple
    times. This means all the code used as part of the process should be its own method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the new `LoadTextAndWeave()` method, new text content will be loaded if the
    `canContinue` property is true. Using the `foreach` keyword, new buttons will
    be added by using the `Instantiate()` method in Unity. This *instantiates* a Prefab
    as a GameObject during runtime, creating it through code and adding it to the
    running scene.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `AddListener()` method is used with the `OnClick` property of a
    button in Unity. This adds to a collection of which functions should be notified
    that a click has happened. The `delegate` keyword allows a developer to pass a
    method as an argument to another method. In this case, a short method is created
    within the same scope as the `foreach` loop. The `index` property can thus be
    used inside this created method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time the button is clicked, the `Story` class method `ChooseChoiceIndex()`
    will be called with the correct index, and the `LoadTextAndWeave()` method will
    be called again, refreshing the value of the `currentLinesText` method and updating
    the current buttons shown on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the current code, one more change is needed. The `LoadTextAndWeave()`
    method needs to be called inside the `Start()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the current code in Visual Studio. Return to Unity and run the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immediately, two problems will become evident. First, the default black text
    on a dark background makes the text impossible to read. Second, only the first
    few words will be shown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.35 – The Body project running in Unity](img/Figure_7.35_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7.35 – The Body project running in Unity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **(Continue.)** button to see two more problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.36 – Dynamically created buttons in The Body](img/Figure_7.36_B17597.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.36 – Dynamically created buttons in The Body
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that instead of replacing the first button, Unity added
    two more. This is caused by the second call to the `LoadTextAndWeave()`method
    internally. First, the text content and button were loaded. Next, when the **(Continue.)**
    button was clicked, it was called again, adding more buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also observe that the buttons are small and hard to read. By default,
    Unity will assume some values for a `Button` game object. While adjusting our
    code, we will also need to change the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the running scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To start to fix the issue with the text, first, select the `Text` game object
    in the `160` and `30`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through either clicking and dragging using the `800` and height of `300`.![Figure
    7.37 – The Inspector view in Unity with updated width and height values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.37_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.37 – The Inspector view in Unity with updated width and height values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the `14` to `24`. This will make the starting size larger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `default` to `white` and then close the **Color** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The updated values will now display more text and, with the white on a darker
    background, increase its readability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.38 – Updated Text GameObject component values'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.38_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.38 – Updated Text GameObject component values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the `Button` Prefab in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like the `Text` game object, its default width is `160` and its height is `30`.
    Change the width to `250` and the height to `100`.![Figure 7.39 – Updated button
    Prefab values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.39_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.39 – Updated button Prefab values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Return to editing `InkStory.cs` in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The fix to the code is a small but important one. Each time the button is clicked,
    the code will need to destroy the current buttons and then create new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new method is needed for the specific task of destroying `Button` children:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: cloneButtonButton.onClick.AddListener(delegate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inkStory.ChooseChoiceIndex(c.index);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DestoryButtonChildren();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LoadTextAndWeave();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the updated file in Visual Studio and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DestroyButtonChildren()` method looks for a specific `tag` value. This
    needs to be added to the `Button` Prefab.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the `Button` Prefab in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** view, click on the **Tag** drop-down menu and then the
    **Add Tag…** option.![Figure 7.40 – Tag drop-down menu in the Unity Inspector
    view](img/Figure_7.40_B17597.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.40 – Tag drop-down menu in the Unity Inspector view
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **+** icon to add a new tag to the list. In the prompt, use the
    name *ButtonChoice*.![Figure 7.41 – New tag name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.41_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.41 – New tag name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **Save** to create a new tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Button` Prefab in the `ButtonChoice` tag has been added, it must
    be selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Tag** dropdown, select **ButtonChoice**.![Figure 7.42 – Added ButtonChoice
    option to the Tag drop-down menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.42_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.42 – Added ButtonChoice option to the Tag drop-down menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the scene. Play through the story by clicking on buttons to make choices
    and see the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the running scene when done playing the story.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The changes to the `Text` game object and code will load the new text and correctly
    update the choices as the player clicks on the buttons. While consisting of multiple
    steps, this same approach can be used with most ink JSON files to present text
    and dynamic buttons for a player to make different choices and then see the result
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked through the process of adding a `script` component,
    associating an ink JSON file with a property, and using methods and properties
    as part of the `Story` class to progress a running ink story. We saw how the `Continue()`
    method loads one line at a time and the `ContinueMaximally()` method loads all
    text until it encounters a weave. When combined with the `canContinue` property,
    these methods allow for text content to be loaded from an ink JSON file and prevent
    any errors when the content runs out. With the `currentChoices` property, we examined
    how to use loops, such as those using the `foreach` keyword. When we used the
    `ChooseChoiceIndex()` method, we picked which option among the weave we wanted
    and progressed through a story using the `Continue()` or `ContinueMaximally()`
    methods again.
  prefs: []
  type: TYPE_NORMAL
- en: By setting up user interface game objects in Unity, we built a dynamic process
    to load ink story content, destroy buttons, and then create new ones. Needing
    to create a `Button` Prefab, we saw how these could be instantiated by the code
    while it was running. Adjusting the values of `Text` and `Button` game objects,
    we completed an interface for running an ink JSON file and built a system usable
    by many other projects working with the same game objects and organization.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we continue to use the `Story` class and its methods. We
    will examine how to retrieve and update the values of variables in an ink story
    using C# code. We will also see ways of accessing functions in ink and how to
    pass data in and out of them. Combined with user interface game objects, we will
    build an example of how to communicate between the ink runtime and Unity code
    by using content from ink to create multiple dynamic interfaces in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between the `Continue()` and `ContinueMaximally()` methods
    in the `Story` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of data does the `ChooseChoiceIndex()` method in the `Story` class
    expect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the `canContinue` property used with the `Continue()` and `ContinueMaximally()`
    methods in the `Story` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Prefab in Unity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of object is found in the `currentChoices` list property of the `Story`
    class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
