- en: '*Chapter 12*: Responsive User Interfaces'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 12 章*：响应式用户界面'
- en: In this chapter, you will learn to write responsive user interfaces. You will
    write responsive **Windows Forms** (**WinForms**), **Windows Presentation Foundation**
    (**WPF**), ASP.NET, .NET MAUI, and WinUI applications. Using background worker
    threads, you will see how you can update and work with the **User Interface**
    (**UI**) in real time by running long-running tasks in the background.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何编写响应式用户界面。你将编写响应式的 **Windows Forms**（**WinForms**）、**Windows Presentation
    Foundation**（**WPF**）、ASP.NET、.NET MAUI 和 WinUI 应用程序。通过使用后台工作线程，你将了解如何在后台运行长时间运行的任务，从而实时更新和与
    **用户界面**（**UI**）交互。
- en: 'In this chapter, we will be working through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: '**Building a responsive UI with WinForms**: In this section, you will write
    a simple WinForms application that remains responsive to user interaction while
    performing multiple tasks.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 WinForms 构建响应式 UI**：在本节中，你将编写一个简单的 WinForms 应用程序，该应用程序在执行多项任务的同时保持对用户交互的响应性。'
- en: '**Building a responsive UI with WPF**: In this section, you will be writing
    a simple WPF application that remains responsive to user interaction while performing
    multiple tasks.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 WPF 构建响应式 UI**：在本节中，你将编写一个简单的 WPF 应用程序，该应用程序在执行多项任务的同时保持对用户交互的响应性。'
- en: '**Building a responsive UI with ASP.NET**: In this section, you will be writing
    a simple ASP.NET application that remains responsive to user interaction while
    performing multiple tasks.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 ASP.NET 构建响应式 UI**：在本节中，你将编写一个简单的 ASP.NET 应用程序，该应用程序在执行多项任务的同时保持对用户交互的响应性。'
- en: '**Building a responsive UI with .NET MAUI**: In this section, you will be writing
    a simple Xamarin.Forms application that remains responsive to user interaction
    while performing multiple tasks. You will then migrate the projects from Xamarin.Forms
    to .NET MAUI by updating the library references.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 .NET MAUI 构建响应式 UI**：在本节中，你将编写一个简单的 Xamarin.Forms 应用程序，该应用程序在执行多项任务的同时保持对用户交互的响应性。然后，你将通过更新库引用将项目从
    Xamarin.Forms 迁移到 .NET MAUI。'
- en: '**Building a responsive UI with WinUI**: In this section, you will be writing
    a simple WinUI application that remains responsive to user interaction while performing
    multiple tasks.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 WinUI 构建响应式 UI**：在本节中，你将编写一个简单的 WinUI 应用程序，该应用程序在执行多项任务的同时保持对用户交互的响应性。'
- en: 'By working through this chapter, you will gain the skills to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习本章，你将获得以下技能：
- en: Use background worker threads to keep UIs responsive
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用后台工作线程保持 UI 响应
- en: Use wait screens to provide updates when users are required to wait
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用等待屏幕在用户需要等待时提供更新
- en: Use AJAX, WebSockets, SignalR, and gRPC/gRPC-Web to send and receive data and
    transfer assets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AJAX、WebSockets、SignalR 和 gRPC/gRPC-Web 发送和接收数据以及传输资产
- en: Write responsive desktop, web, and mobile UIs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写响应式桌面、Web 和移动 UI
- en: Note
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For clarification, when speaking about responsive UIs in this chapter, we are
    not talking about the layout of the UI adapting to the device size or screen real
    estate. Instead, we are focused on making busy UIs responsive to user input instead
    of blocking the user from working during task execution.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了澄清，当在本章中讨论响应式 UI 时，我们不是在谈论 UI 布局适应设备大小或屏幕可用空间。相反，我们专注于使忙碌的 UI 对用户输入做出响应，而不是在任务执行期间阻止用户工作。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Visual Studio 2022 or later.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 或更高版本。
- en: This chapter source code is available at [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH12](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH12).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章源代码可在 [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH12](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH12)
    获取。
- en: Building a responsive UI with WinForms
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WinForms 构建响应式 UI
- en: In this section, we will be building a very simple WinForms application that
    is **Dots Per Inch** (**DPI**)-aware and enables the user to continue working
    during long-running operations. The application has a splash screen with a progress
    bar and an updated label that provides visual feedback to the user that the application
    is busy loading. Once the loading progress has been completed, the splash screen
    closes, and the main window is displayed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个非常简单的 WinForms 应用程序，该应用程序对 **每英寸点数**（**DPI**）敏感，并允许用户在长时间运行的操作期间继续工作。应用程序具有带有进度条和更新标签的启动画面，为用户提供视觉反馈，表明应用程序正在忙于加载。一旦加载进度完成，启动画面关闭，主窗口显示。
- en: On the main window, there is a label that gets updated every time you click
    on the increment count button, a paged table that you can navigate through using
    the buttons provided, and a progress indicator for a long-running task that also
    has a cancel button.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在主窗口中，有一个标签，每次点击增加计数按钮时都会更新，一个可以通过提供的按钮进行导航的分页表格，以及一个用于长时间运行任务的进度指示器，它还有一个取消按钮。
- en: While the long-running task is executing, you can move the window around, increment
    the label by clicking the increment count button, and you can page through the
    data. If you choose to, you can also cancel the long-running task.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在长时间运行的任务执行期间，您可以移动窗口，通过点击增加计数按钮来增加标签，并且您可以浏览数据。如果您选择的话，您还可以取消长时间运行的任务。
- en: When the long-running task is completed, canceled, or encounters an error, the
    task progress panel is hidden.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当长时间运行的任务完成、取消或遇到错误时，任务进度面板将被隐藏。
- en: Enabling DPI awareness and long file path awareness
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用DPI感知和长文件路径感知
- en: 'In this section, we will configure a WinForms application so that it looks
    good on high-DPI screens and normal-DPI large screens. We also configure it to
    be aware of long file paths. Follow these steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将配置一个WinForms应用程序，使其在高DPI屏幕和普通DPI大屏幕上看起来很好。我们还将其配置为能够识别长文件路径。请按照以下步骤操作：
- en: Start a new .NET 6 WinForms application and call it `CH12_ResponsiveWinForms`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的.NET 6 WinForms应用程序，并将其命名为`CH12_ResponsiveWinForms`。
- en: Add a new *application manifest* file.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的*应用程序清单*文件。
- en: 'Open the `app.manifest` file and update the `compatibility` section as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.manifest`文件并更新`compatibility`部分如下：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This XML code enables DPI awareness in WinForms applications from Windows Vista
    upward.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此XML代码使Windows Vista及更高版本的WinForms应用程序具有DPI感知能力。
- en: 'Uncomment the following `application` section:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消以下`application`部分的注释：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code informs the compiler that the application is aware of long paths and
    DPI settings. With these settings in place, the application will now scale for
    different screen DPI settings and will be able to handle long paths that are 256
    characters long.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通知编译器应用程序具有对长路径和DPI设置的感知能力。有了这些设置，应用程序现在将根据不同的屏幕DPI设置进行缩放，并且能够处理长达256个字符的长路径。
- en: In the next section, we will add a splash screen with loading progress feedback.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加一个带有加载进度反馈的启动画面。
- en: Adding a splash screen that updates with loading progress
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个随着加载进度更新的启动画面
- en: Applications can load very quickly, or they can load quite slowly. When they
    are loading, the user is unaware of what the application is doing. You may choose
    to display a splash screen as part of your application branding. If your application
    loads fast, then you may need to add a delay for a short period such as 3 seconds
    to enable the user to see the splash screen. Otherwise, all the user may see is
    a quick screen flicker.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以非常快速地加载，或者加载相当缓慢。当它们正在加载时，用户并不知道应用程序正在做什么。您可以选择显示启动画面作为您应用程序品牌的一部分。如果您的应用程序加载速度快，那么您可能需要添加一个短暂的延迟，例如3秒，以便用户能够看到启动画面。否则，用户可能看到的只是屏幕快速闪烁。
- en: If the application has some heavy loading operations that take time to process,
    the user can think there is an issue and that the program has crashed. So, it
    is good practice to provide a splash screen that provides visual feedback to the
    user. This way, the user knows that the application is busy processing and has
    not crashed. When users see such feedback, they are more patient and will wait
    until the application has loaded.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序有一些需要花费时间处理的繁重加载操作，用户可能会认为有问题，程序已崩溃。因此，提供提供视觉反馈的启动画面是一种良好的做法。这样，用户就知道应用程序正在忙于处理，并没有崩溃。当用户看到这样的反馈时，他们会更有耐心，并等待应用程序加载完成。
- en: 'In this section, we add a splash screen with visual feedback. The main window
    simulates several loading operations with a delay to the UI. Then, the splash
    screen is closed and the main window is displayed. We will now start adding the
    necessary code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们添加了一个带有视觉反馈的启动画面。主窗口通过延迟模拟几个加载操作。然后，关闭启动画面并显示主窗口。现在，我们将开始添加必要的代码：
- en: Add a new form called `SplashScreenForm`, and change its **FormBorderStyle**
    property to **None** and its **StartPosition** property to **CentreScreen**. Change
    the **BackColor** property to **ActiveCaptionText**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`SplashScreenForm`的新表单，并将其**FormBorderStyle**属性更改为**None**，**StartPosition**属性更改为**CentreScreen**。将**BackColor**属性更改为**ActiveCaptionText**。
- en: Add a `LoadingProgressBar` to the form and dock it to the bottom of the form.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单中添加一个`LoadingProgressBar`并将其停靠到表单底部。
- en: Add a label to `LoadingProgressLabel` and dock it to the bottom of the form
    so that it appears just above the progress bar. Set the **Text** property to **Loading.
    Please wait…** and **Font** | **Size** to **12**. Change the **ForeColor** property
    to **HighlightWhite**. Set **Margin** | **All** and **Padding** | **All** to **8**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `LoadingProgressLabel` 添加一个标签并将其停靠到表单底部，使其出现在进度条上方。将 **Text** 属性设置为 **Loading.
    Please wait…**，并将 **Font** | **Size** 设置为 **12**。将 **ForeColor** 属性更改为 **HighlightWhite**。将
    **Margin** | **All** 和 **Padding** | **All** 设置为 **8**。
- en: Add another label to `TitleLabel` with the **Text** property set to **Responsive
    WinForms Example**, **ForeColor** set to **HighlightText**, **Font** | **Size**
    set to **32**, and **Location** set to **29, 126**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `TitleLabel` 添加另一个标签，其 **Text** 属性设置为 **Responsive WinForms Example**，**ForeColor**
    设置为 **HighlightText**，**Font** | **Size** 设置为 **32**，并将 **Location** 设置为 **29,
    126**。
- en: Rename `MainForm` and open the form. Double-click on WindowsForm. This will
    open the code window.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名 `MainForm` 并打开表单。双击 WindowsForm。这将打开代码窗口。
- en: 'Add the following `using` statements to the `MainForm` class:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `MainForm` 类添加以下 `using` 语句：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These `using` statements provide all that we need for our splash screen’s code
    to function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `using` 语句为我们启动画面的代码提供了所需的所有功能。
- en: 'Add the following member variables to the `MainForm` class:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `MainForm` 类添加以下成员变量：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These member variables will be referenced by the various methods in our `MainForm`
    class to provide paging, in-memory data storage, and store the click count and
    operation number of the operation being processed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员变量将在我们的 `MainForm` 类的各个方法中被引用，以提供分页、内存数据存储以及存储正在处理操作的点击计数和操作编号。
- en: 'Update the `MainForm_Load` method as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新 `MainForm_Load` 方法：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code creates our splash screen and then iterates 100 times, simulating
    many loading operations. Each iteration causes the UI thread to sleep for half
    a second, updates the splash screen progress, and releases the thread so that
    other threads can do their work by calling `Application.DoEvents()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建我们的启动画面，然后迭代 100 次，模拟许多加载操作。每次迭代都会使 UI 线程休眠半秒，更新启动画面进度，并通过调用 `Application.DoEvents()`
    释放线程，以便其他线程可以通过调用 `Application.DoEvents()` 来执行它们的工作。
- en: 'Open **SplashScreenForm** and view its code. Add the following method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **SplashScreenForm** 并查看其代码。添加以下方法：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code takes input from the `MainForm` class and updates the splash screen’s
    label and progress bar, providing feedback to the user that the application is
    loading and making progress.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从 `MainForm` 类获取输入，并更新启动画面的标签和进度条，向用户提供应用程序正在加载和进度的反馈。
- en: 'We have now completed the progress bar. If you run the code, you will see the
    following splash screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了进度条。如果您运行代码，您将看到以下启动画面：
- en: '![Figure 12.1 – The WinForms splash screen'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – WinForms 启动画面'
- en: '](img/Figure_12.01_B16617.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.01_B16617.jpg)'
- en: Figure 12.1 – The WinForms splash screen
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – WinForms 启动画面
- en: Now that our splash screen is working, let’s add our label and button that displays
    an incremental count of button clicks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的启动画面已经工作，让我们添加显示按钮点击增量计数的标签和按钮。
- en: Adding the increment count button and label
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加增量计数按钮和标签
- en: 'To demonstrate non-blocking of the UI when a long operation is executing, we
    will have a label that is updated with text every time a user clicks a button.
    We will need to perform the following tasks in our code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示在执行长时间操作时 UI 不会被阻塞，我们将有一个标签，每次用户点击按钮时都会更新其文本。在我们的代码中，我们需要执行以下任务：
- en: Add a label called `ClickCounterLabel` to `MainForm` and dock it to the top.
    Set its text to an empty string and its text properties to **Segoe UI** and **36pt**,
    with **TextAlign** set to **MiddleCenter**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `MainForm` 添加一个名为 `ClickCounterLabel` 的标签并将其停靠到顶部。将其文本设置为空字符串，文本属性设置为 **Segoe
    UI** 和 **36pt**，并将 **TextAlign** 设置为 **MiddleCenter**。
- en: Add a button called `IncrementCountButton` to the form and dock it to the top
    of the form. Set its text to **&Increment Text**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向表单添加一个名为 `IncrementCountButton` 的按钮并将其停靠到表单顶部。将其文本设置为 **&Increment Text**。
- en: '*Double-click* on the button to generate its click event. Update the code of
    the click event with the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击* 按钮，生成其点击事件。更新点击事件的代码如下：'
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each time the user clicks the button, the _`clickCounter` variable is incremented
    by one. The `ClickCounterLabel` text is then updated, informing the user of how
    many times they have clicked the button.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户点击按钮，`_clickCounter` 变量就会增加一。然后更新 `ClickCounterLabel` 文本，通知用户他们点击按钮的次数。
- en: The next thing we will be doing is adding a table with paged navigation. We
    shall be doing that in the following section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个带有分页导航的表格。我们将在下一节中完成这项工作。
- en: Adding a table with paged data
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加具有分页数据的表格
- en: 'In this section, we will be adding a table with paged navigation. This will
    demonstrate that the user can still interact with the page through data in a WinForms
    application, even when long operations are running in the background. Let’s begin:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个带有分页导航的表格。这将演示，即使在后台运行长时间操作时，用户仍然可以通过 WinForms 应用程序中的数据与页面进行交互。让我们开始：
- en: Add `DataTable`, and set its **Dock** property to **Fill**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `DataTable`，并设置其 **Dock** 属性为 **Fill**。
- en: Add `DataPagingPanel`, with its **Dock** property set to **Bottom**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `DataPagingPanel`，将其 **Dock** 属性设置为 **Bottom**。
- en: Add a button to `FirstButton`, with the text set to **|<<**. *Double-click*
    the button to generate the click event. Then, return to the design window.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FirstButton` 上添加一个按钮，文本设置为 **|<<**。*双击* 按钮以生成点击事件。然后，返回到设计窗口。
- en: Add a button to `PreviousButton` with the text set to **<<**. *Double-click*
    the button to generate the click event. Then, return to the design window.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PreviousButton` 上添加一个按钮，文本设置为 **<<**。*双击* 按钮以生成点击事件。然后，返回到设计窗口。
- en: Add a textbox called `PageTextBox` to **FlowLayoutPanel**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **FlowLayoutPanel** 中添加一个名为 `PageTextBox` 的文本框。
- en: Add a button called `NextButton` to **FlowLayoutPanel**, with the text set to
    **>>**. *Double-click* the button to generate its click event. Then, return to
    the design window.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **FlowLayoutPanel** 中添加一个名为 `NextButton` 的按钮，文本设置为 **>>**。*双击* 按钮以生成其点击事件。然后，返回到设计窗口。
- en: Add a button called `LastButton` to **FlowLayoutPanel**, with the text set to
    **>>|**. *Double-click* the button to generate its click event. This time, stay
    in the code view, as we have completed what we need to do on the UI for this section.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **FlowLayoutPanel** 中添加一个名为 `LastButton` 的按钮，文本设置为 **>>|**。*双击* 按钮以生成其点击事件。这次，保持代码视图，因为我们已经完成了本节
    UI 需要完成的工作。
- en: 'Add the `BuildCollection` method:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `BuildCollection` 方法：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method builds a collection of `100` products.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法构建一个包含 `100` 个产品的集合。
- en: Add the call to the `BuildCollection` method to the `MainForm_Load` method before
    the `SplashScreenForm` instantiation line.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SplashScreenForm` 实例化行之前，将 `BuildCollection` 方法的调用添加到 `MainForm_Load` 方法中。
- en: 'After the line that closes the splash screen, add the following two lines of
    code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关闭启动屏幕的行之后，添加以下两行代码：
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code sets the data source for our `PagedProducts` method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码设置 `PagedProducts` 方法的数据源。
- en: 'Add the `PagedProducts` method:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `PagedProducts` 方法：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method returns a range from the `_products` collection. The `_offset` variable
    stores the index value that forms the starting point of the returned collection,
    and the `_pageSize` variable stores the number of records to be returned for a
    page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从 `_products` 集合返回一个范围。`_offset` 变量存储构成返回集合起始点的索引值，`_pageSize` 变量存储每页要返回的记录数。
- en: 'Add the `PageCount` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `PageCount` 方法：
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method obtains the number of products contained within the `_products`
    collection, divides that number by the `_pageSize` variable, and then returns
    the result. The result is the number of data pages that we can navigate through.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法获取 `_products` 集合中包含的产品数量，将该数量除以 `_pageSize` 变量，然后返回结果。结果是我们可以导航的数据页数。
- en: 'Update the `FirstButton_Click` method as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式更新 `FirstButton_Click` 方法：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code moves to the first page in the dataset and updates the UI accordingly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将数据集的第一页移动到当前页，并相应地更新 UI。
- en: 'Update the `PreviousButton_Click` method with the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `PreviousButton_Click` 方法：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code moves to the previous page in the dataset and updates the UI accordingly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将数据集的前一页移动到当前页，并相应地更新 UI。
- en: 'Add the `NextButton_Click` method code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `NextButton_Click` 方法代码：
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code moves to the next page of the dataset and updates the UI accordingly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将数据集的下一页移动到当前页，并相应地更新 UI。
- en: 'Add the `LastButton_Click` method code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `LastButton_Click` 方法代码：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method moves to the last page of the dataset and updates the UI accordingly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将数据集的最后页移动到当前页，并相应地更新 UI。
- en: 'Finally, add the `Product` class:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加 `Product` 类：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class is the `Product` class that our `MainForm` uses to build its list
    of products within its `BuildCollection` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此类是 `Product` 类，我们的 `MainForm` 在其 `BuildCollection` 方法中使用它来构建其产品列表。
- en: We have now built our paged data table, and we have our increment button and
    label in place. The final thing to do with our form is to add our long-running
    task, to show that user interactions are still possible without being blocked
    by long-running tasks. This will be the topic of our next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了我们的分页数据表，并且我们的增量按钮和标签已经就位。我们表单的最后一件事是添加我们的长时间运行的任务，以表明用户交互仍然可能，而不会因为长时间运行的任务而被阻塞。这将是下一节的主题。
- en: Running long-running tasks in the background
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在后台运行长时间运行的任务
- en: 'In this section, we are going to upgrade our UI to show the progress of a long-running
    task that is running in the background. The user will be able to cancel the long-running
    task at any time. When the task is completed, whatever state it is in, the long-running
    task update progress controls will be hidden from the user. Let’s start adding
    the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将升级我们的 UI 以显示在后台运行的长运行任务的进度。用户可以在任何时候取消长时间运行的任务。当任务完成时，无论其状态如何，长时间运行的任务更新进度控件将从用户隐藏。让我们开始添加代码：
- en: Add a `LongRunningOperationCancelButton` and set its text to `&Cancel long running
    operation`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `LongRunningOperationCancelButton` 并将其文本设置为 `&取消长时间运行操作`。
- en: Add a `StatusBar`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `StatusBar`。
- en: Add a `TaskProgressBar`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `TaskProgressBar`。
- en: Add a `StatusLabel` and make sure its text property is empty.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `StatusLabel` 并确保其文本属性为空。
- en: Add a `CollectionBuilderBackgroundWorker`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `CollectionBuilderBackgroundWorker`。
- en: Add a `LongRunningProcessBackgroundWorker`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `LongRunningProcessBackgroundWorker`。
- en: 'In the `MainForm` class, add the following three lines to the constructor:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainForm` 类的构造函数中，添加以下三行：
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code adds the handlers for our `BackgroundWorker`, which will be responsible
    for executing the long-running task.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码为我们的 `BackgroundWorker` 添加了处理程序，该处理程序将负责执行长时间运行的任务。
- en: 'Add the following method call to the last line of the `MainForm_Load` method
    before the closing brace: `LongRunningProcess();`.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainForm_Load` 方法的最后行（在闭合括号之前）添加以下方法调用：`LongRunningProcess();`。
- en: 'Add the following `LongRunningProcess` method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `LongRunningProcess` 方法：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If `LongRunningProcessBackgroundWorker` is not busy, then the `RunWorkerAsync`
    method called `LongRunningProcessBackground Worker_DoWork` is run.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `LongRunningProcessBackgroundWorker` 没有忙碌，则调用 `RunWorkerAsync` 方法的 `LongRunningProcessBackground
    Worker_DoWork` 将被执行。
- en: 'Add `LongRunningProcessBackgroundWorker_DoWork` to the `MainForm` class:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LongRunningProcessBackgroundWorker_DoWork` 添加到 `MainForm` 类：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are casting the sender as `BackgroundWorker` and assigning it to our local
    worker variable. Then, we iterate 100 times. Each time we iterate, we set the
    `_operationNumber` variable to the loop count variable value, sleep for 100 milliseconds,
    and then call the `ReportProgress` method of the worker passing in the percentage
    of work done.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发送者强制转换为 `BackgroundWorker` 并将其分配给我们的本地工作变量。然后，我们迭代 100 次。每次迭代时，我们将 `_operationNumber`
    变量设置为循环计数变量的值，休眠 100 毫秒，然后调用工作者的 `ReportProgress` 方法，传入已完成的工作百分比。
- en: 'Add the `LongRunningProcessBackgroundWorker_ProgressChanged` method to the
    `MainForm` class:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LongRunningProcessBackgroundWorker_ProgressChanged` 方法添加到 `MainForm` 类：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code updates the UI with the progress of the long-running task. If all
    the operations have been completed, the task cancel button and status bar are
    hidden from the user.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用长运行任务的进度更新 UI。如果所有操作都已完成，则隐藏任务取消按钮和状态栏。
- en: 'Add the `LongRunningProcessBackgroundWorker_RunWorkerCompleted` method to the
    `MainForm` class:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LongRunningProcessBackgroundWorker_RunWorkerCompleted` 方法添加到 `MainForm` 类：
- en: '[PRE20]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the long-running task is completed, this method executes `StatusLabel.Text`
    to the outcome of the method, with the outcomes being either `Cancelled`, `Error`,
    or `Done`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当长时间运行的任务完成时，此方法将 `StatusLabel.Text` 执行到方法的输出，输出结果为 `Cancelled`、`Error` 或 `Done`。
- en: 'Our final piece of code to write before we complete and run our WinForms application
    is to add code to the `LongRunningOperationButton_Click` method to `MainClass`,
    as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成并运行我们的 WinForms 应用程序之前，我们需要编写的最后一部分代码是向 `MainClass` 的 `LongRunningOperationButton_Click`
    方法添加代码，如下所示：
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code checks to see whether the task supports cancellation. If it does,
    then the task is canceled, and the cancel button and status bar are hidden from
    the user.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查任务是否支持取消。如果支持，则取消任务，并将取消按钮和状态栏从用户隐藏。
- en: 'Run the code. You should see the splash screen shown in *Figure 12.1*. Then,
    you should see the main window resembling what is shown in *Figure 12.2*. Move
    the window about and click on the increment count button. Also, click the paging
    buttons to move between data pages of the dataset, and cancel the task. You should
    see that the window is completely responsive to your input, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。您应该看到*图12.1*中显示的启动画面。然后，您应该看到类似于*图12.2*所示的主窗口。移动窗口并点击递增计数按钮。此外，点击翻页按钮在数据集的不同数据页之间移动，并取消任务。您应该看到窗口完全响应您的输入，如下所示：
- en: '![Figure 12.2 – The Windows Forms main application window'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – Windows Forms主应用程序窗口'
- en: '](img/Figure_12.02_B16617.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.02_B16617.jpg)'
- en: Figure 12.2 – The Windows Forms main application window
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – Windows Forms主应用程序窗口
- en: As you can see, we have written a WinForms application that has a lot going
    on. We have a splash screen that provides visual feedback to the user so that
    they do not think that the application has crashed in any way, and we have a UI
    that remains responsive to user input during a long-running task.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们编写了一个功能丰富的WinForms应用程序。我们有一个启动画面，它向用户提供视觉反馈，这样他们就不会认为应用程序以任何方式崩溃，并且我们有一个在长时间运行的任务期间对用户输入保持响应的UI。
- en: Now that we have a working WinForms application, let’s turn our attention to
    WPF. In the next section, we will apply what we have learned with our WinForms
    application to a WPF application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个工作的WinForms应用程序，让我们将注意力转向WPF。在下一节中，我们将把我们在WinForms应用程序中学到的知识应用到WPF应用程序中。
- en: Building a responsive UI with WPF
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WPF构建响应式UI
- en: 'In this section, we are going to build the same kind of interface as we did
    for the WinForms application, but this time, it will be using WPF. We will now
    start writing our code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建与WinForms应用程序相同的界面，但这次将使用WPF。我们现在将开始编写我们的代码：
- en: Create a new WPF application called `CH12_ResponsiveWPF` and make sure to select
    **.NET 6.0** as the target framework.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CH12_ResponsiveWPF`的新WPF应用程序，并确保选择**.NET 6.0**作为目标框架。
- en: Add the `Product` class to the project. It is the same code that we used in
    our WinForms application.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Product`类添加到项目中。它与我们在WinForms应用程序中使用的代码相同。
- en: Add a new Window called `SplashWindow`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`SplashWindow`的新窗口。
- en: 'Modify the **SplashWindow** XAML as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式修改**SplashWindow** XAML：
- en: '[PRE22]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The XAML we have just updated declares a stack panel with two labels and a progress
    bar. The first label displays the title, and the second label displays loading
    progress along with the progress bar.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚更新的XAML声明了一个包含两个标签和进度条的堆叠面板。第一个标签显示标题，第二个标签显示与进度条一起的加载进度。
- en: 'Add the following method to the `SplashWindow` class:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到`SplashWindow`类中：
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code will be called by the `MainWindow` class and is responsible for updating
    the progress indicators on **SplashWindow**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将由`MainWindow`类调用，并负责更新**SplashWindow**上的进度指示器。
- en: 'Open the `MainWindow.xaml` file and replace the existing XAML with the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`文件，并用以下内容替换现有的XAML：
- en: '[PRE24]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This XAML provides a status panel that will show the progress of any background
    tasks, an increment label and an increment button, a data grid, and a navigation
    panel for paging through different pages of data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此XAML提供了一个状态面板，将显示任何后台任务的进度，一个递增标签和一个递增按钮，一个数据网格，以及用于翻页不同数据页面的导航面板。
- en: 'Add the following `using` statements to the `MainWindow.xaml.cs` file:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`语句添加到`MainWindow.xaml.cs`文件中：
- en: '[PRE25]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These `using` statements are needed for our WPF window to function without error.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`using`语句对于我们的WPF窗口正常工作是必需的。
- en: 'Add the following member variables to the `MainWindow` class:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下成员变量添加到`MainWindow`类中：
- en: '[PRE26]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we have the same variables that we had with our WinForms application,
    except we also declare a background worker.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有与WinForms应用程序相同的变量，除了我们声明了一个后台工作线程。
- en: 'Update the `MainWindow` constructor with the following code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`MainWindow`构造函数：
- en: '[PRE27]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code is pretty much the same as our WinForms load method. The only real
    difference is that all our initialization code is in the constructor.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上与我们的WinForms加载方法相同。唯一的真正区别是我们所有的初始化代码都在构造函数中。
- en: 'Add the `Worker_DoWork` method:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Worker_DoWork`方法：
- en: '[PRE28]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code simulates the work of 100 operations with a small delay for each operation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码模拟了100个操作的工作，每个操作之间有短暂的延迟。
- en: 'Add the `Worker_ProgressChanged` method code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Worker_ProgressChanged`方法代码：
- en: '[PRE29]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code updates the progress indicators for the long-running task.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更新了长时间运行任务的进度指示器。
- en: 'Add the `Worker_RunWorkerCompleted` method:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Worker_RunWorkerCompleted` 方法：
- en: '[PRE30]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method reports the result of the long-running task and then hides the status
    panel from the end user.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法报告长时间运行任务的结果，然后从最终用户那里隐藏状态面板。
- en: 'Add the `PagedData` method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `PagedData` 方法：
- en: '[PRE31]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method returns a page of data whose index starts at `_offset`, with the
    number of returned rows defined by `_pageSize`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个数据页，其索引从 `_offset` 开始，返回的行数由 `_pageSize` 定义。
- en: 'Add the `DoEvents` method:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `DoEvents` 方法：
- en: '[PRE32]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code performs like the WinForms `Application.DoEvents()` code. You can
    place your non-UI blocking code here, and update the UI.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的行为类似于 WinForms 的 `Application.DoEvents()` 代码。您可以将非 UI 阻塞代码放在这里，并更新 UI。
- en: 'Add the `BuildCollection` method:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `BuildCollection` 方法：
- en: '[PRE33]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `BuildCollection` method builds our dataset of 100 products.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildCollection` 方法构建我们的 100 个产品数据集。'
- en: 'Add the `PageCount` method:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `PageCount` 方法：
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `PageCount` method works out how many pages of data there are based on the
    dataset size, divided by the page size, and then returns the result.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageCount` 方法根据数据集大小和页面大小计算数据页数，然后返回结果。'
- en: 'Add the `FirstButton_Click` method:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `FirstButton_Click` 方法：
- en: '[PRE35]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When executed, this method navigates to the first record in our dataset and
    upgrades the UI accordingly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，此方法将导航到我们数据集的第一条记录，并相应地升级 UI。
- en: 'Add the `PreviousButton_Click` method:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `PreviousButton_Click` 方法：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This method will move to the previous page of the dataset and update the UI
    accordingly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将移动到数据集的前一页，并相应地更新 UI。
- en: 'Add the `NextButton_Click` code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `NextButton_Click` 代码：
- en: '[PRE37]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This method moves to the next page of the dataset and updates the UI accordingly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法移动到数据集的下一页，并相应地更新 UI。
- en: 'Add the `LastButton_Click` method:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `LastButton_Click` 方法：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method moves to the last dataset page and updates the UI accordingly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法移动到最后一个数据集页面，并相应地更新 UI。
- en: 'Add the `IncrementCounterButton_Click` method:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `IncrementCounterButton_Click` 方法：
- en: '[PRE39]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Each time you click `IncrementCounterButton`, this method will increment the
    `_clickCounter` variable and report on the screen how many times you have clicked
    the button.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您点击 `IncrementCounterButton`，此方法将增加 `_clickCounter` 变量，并在屏幕上报告您点击按钮的次数。
- en: 'Add the final WPF method called `CancelTaskButton_Click`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加最终名为 `CancelTaskButton_Click` 的 WPF 方法：
- en: '[PRE40]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method cancels the long-running task if it supports cancellation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果支持取消，此方法将取消长时间运行的任务。
- en: 'Run the WPF application. You will find that you are presented with the splash
    screen showing the loading progress, as displayed here:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 WPF 应用程序。您将看到显示加载进度的启动屏幕，如下所示：
- en: '![Figure 12.3 – The WPF application’s splash screen'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.3 – WPF 应用程序的启动屏幕'
- en: '](img/Figure_12.03_B16617.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.03_B16617.jpg]'
- en: Figure 12.3 – The WPF application’s splash screen
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – WPF 应用程序的启动屏幕
- en: When the loading completes, the splash screen closes and you are presented with
    the main window. While a long-running task is in progress, you can move the window
    about, click on the increment counter button, navigate through the paged data,
    and cancel the long-running task.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 加载完成后，启动屏幕关闭，您将看到主窗口。在长时间运行的任务进行时，您可以移动窗口，点击增加计数器按钮，浏览分页数据，并取消长时间运行的任务。
- en: 'As you can see from the following screenshot, we have everything in place that
    provides visual feedback of progress to end users and a UI that remains responsive
    to user input during a long-running task:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，我们已准备好一切，为最终用户提供进度视觉反馈，并在长时间运行的任务期间保持对用户输入的响应性 UI：
- en: '![Figure 12.4 – The WPF application’s main window'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.4 – WPF 应用程序的主窗口'
- en: '](img/Figure_12.04_B16617.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.04_B16617.jpg]'
- en: Figure 12.4 – The WPF application’s main window
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – WPF 应用程序的主窗口
- en: In the next section, we will look at how to keep ASP.NET UI responsive to user
    input.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何保持 ASP.NET UI 对用户输入的响应性。
- en: Building a responsive UI with ASP.NET
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ASP.NET 构建响应式 UI
- en: In this section, we will be looking at ways to assist ASP.NET applications in
    being quick and responsive. We will start by looking at memory and distributed
    caching. Then, we will look at how you can update a section of a page using AJAX.
    Next, we will move on to write a real-time chat application with SignalR. We will
    then take a look at using WebSockets in our ASP.NET applications.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何帮助 ASP.NET 应用程序快速响应。我们将首先查看内存和分布式缓存。然后，我们将探讨如何使用 AJAX 更新页面的一部分。接下来，我们将编写一个实时聊天应用程序，使用
    SignalR。然后，我们将探讨在 ASP.NET 应用程序中使用 WebSockets。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will not be covering gRPC-Web in this chapter, as we have already covered
    that topic with example code in [*Chapter 9*](B16617_09_Final_SB_Epub.xhtml#_idTextAnchor168),
    *Enhancing the Performance of Networked Applications*, in which we looked at gRPC
    for non-web applications and gRPC-Web for web applications. In this chapter, we
    also implemented a simple Blazor web application using gRPC-Web, so you can refer
    to this chapter for gRPC/gRPC-Web.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不会介绍 gRPC-Web，因为我们已经在 [*第 9 章*](B16617_09_Final_SB_Epub.xhtml#_idTextAnchor168)
    中通过示例代码介绍了该主题，即 *增强网络应用程序的性能*，其中我们探讨了 gRPC 用于非 Web 应用程序和 gRPC-Web 用于 Web 应用程序。在本章中，我们还使用
    gRPC-Web 实现了一个简单的 Blazor Web 应用程序，因此你可以参考本章以了解 gRPC/gRPC-Web。
- en: Let’s begin looking at a responsive ASP.NET application by focusing on caching.
    There are two kinds of caching we will be looking at. These are **memory caching**
    and **distributed caching**. In the next section, we will implement memory caching.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过关注缓存来开始查看一个响应式 ASP.NET 应用程序。我们将查看两种类型的缓存。这些是 **内存缓存** 和 **分布式缓存**。在下一节中，我们将实现内存缓存。
- en: Implementing memory caching
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现内存缓存
- en: Web applications load resources over the network we all know as the internet.
    Accessing, downloading, and rendering resources from the internet takes varying
    degrees of time. Time can vary due to network traffic, the quality of the network,
    and computer system resources. Is there a way in which we can speed this process
    up? Well, yes. We can implement caching. But what exactly is caching?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序通过网络（我们所有人都知道的网络）加载资源。从互联网访问、下载和渲染资源需要不同程度的时间。时间可能会因网络流量、网络质量以及计算机系统资源而变化。我们有没有办法加快这个过程？嗯，是的。我们可以实现缓存。但缓存究竟是什么呢？
- en: '**Caching** is the local storage of frequently accessed resources for faster
    access and processing.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**是将频繁访问的资源本地存储以提高访问和处理速度的一种方式。'
- en: 'In this section, you will see how we can easily implement in-memory caching
    in ASP.NET. To implement in-memory caching, follow these steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到我们如何在 ASP.NET 中轻松实现内存缓存。要实现内存缓存，请按照以下步骤操作：
- en: Start a new ASP.NET Core web app (`Model-View-Controller`) project and call
    it `CH12_ResponsiveASPNET`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的 ASP.NET Core Web 应用程序（模型-视图-控制器）项目，并将其命名为 `CH12_ResponsiveASPNET`。
- en: 'Add the `Microsoft.Extensions.Caching.Memory` NuGet package. If Visual Studio
    cannot install it, run the following command in the Package Manager:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Microsoft.Extensions.Caching.Memory` NuGet 包。如果 Visual Studio 无法安装它，请在包管理器中运行以下命令：
- en: '[PRE41]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the `HomeController` class, add the statement `using Microsoft.Extensions.Caching.Memory`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HomeController` 类中，添加语句 `using Microsoft.Extensions.Caching.Memory`。
- en: 'Add the following member variables:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下成员变量：
- en: '[PRE42]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code declares the variables that will store our logger and memory cache
    objects.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码声明了将存储我们的日志记录器和内存缓存对象的变量。
- en: 'Update the `HomeController` constructor, as shown next:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下更新 `HomeController` 构造函数：
- en: '[PRE43]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this code, the logger and memory cache objects that we will be using are
    injected into our class, and we pass in variables to set our member variables.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将注入我们将要使用的日志记录器和内存缓存对象，并传递变量以设置我们的成员变量。
- en: 'Add the `GetMemoryCacheTime` method:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GetMemoryCacheTime` 方法：
- en: '[PRE44]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we are checking whether our `CachedTime` variable exists in the memory
    cache. If it does exist, then the out variable called `currentTime` is set and
    the cached time is returned. Otherwise, we get the current time and store it in
    the memory cache with a sliding expiration value, and then we return the cached
    time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查我们的 `CachedTime` 变量是否存在于内存缓存中。如果它存在，则将 `currentTime` 变量设置并返回缓存的时长。否则，我们获取当前时间并将其存储在内存缓存中，并带有滑动过期值，然后返回缓存的时长。
- en: 'Update the `Index` method with this code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `Index` 方法：
- en: '[PRE45]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `Index` controller method returns a string. This string that is returned
    is the cached time.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index` 控制器方法返回一个字符串。返回的字符串是缓存的时长。'
- en: 'Run the project and navigate to `https://localhost:5001/Home`. You should see
    something like the following output:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目并导航到 `https://localhost:5001/Home`。你应该会看到以下类似的输出：
- en: '**Current Time: 12/07/221 20:18:25**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前时间：2021年12月7日 20:18:25**'
- en: '**Memory Cache Time: 12/07/2021 20:18:25**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存缓存时间：2021年12月7日 20:18:25**'
- en: As you can see, the time did not exist in the cache, and so was added to the
    cache before it was returned.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，时间不存在于缓存中，因此在返回之前被添加到缓存中。
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The setting of port numbers is dependent on the availability of ports. Whatever
    port you choose, it will not work if it is in use by another program.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号的设置取决于端口的可用性。无论你选择哪个端口，如果它已被其他程序占用，则将无法工作。
- en: 'Now, refresh the page, and you should see different values for the current
    time and the memory cache time:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，刷新页面，你应该会看到当前时间和内存缓存时间的不同值：
- en: '**Current Time: 12/07/2021 20:21:21**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前时间：12/07/2021 20:21:21**'
- en: '**Memory Cache Time: 12/07/2021 20:18:25**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存缓存时间：12/07/2021 20:18:25**'
- en: You can clearly see that the memory cache time is older than the current time.
    This shows that we have stored the time in the in-memory cache and retrieved it
    successfully.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到内存缓存时间早于当前时间。这表明我们已经将时间存储在内存缓存中并成功检索。
- en: Implementing in-memory caching is really easy in ASP.NET, and you can enhance
    the page load and render time by storing and retrieving data from the in-memory
    cache. Now that we have looked at the in-memory cache, we will turn our attention
    to distributed cache.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET 中实现内存缓存非常简单，你可以通过存储和检索内存缓存中的数据来提高页面加载和渲染时间。现在我们已经了解了内存缓存，我们将转向分布式缓存。
- en: Implementing distributed caching
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现分布式缓存
- en: 'In this section, we will be using the same ASP.NET web project and controller
    to implement distributed caching. What do we mean by distributed caching? Distributed
    caching extends the concept of local caching to include caching over several computers.
    Such caching enables the scaling of transactional data. You would mainly use distributed
    caching to store application data that resides in a database, and data related
    to web sessions. In this section, we use Redis for our caching. Redis is an in-memory
    data structure store, used as a distributed, in-memory key-value database, cache,
    and message broker, with optional durability. To implement distributed caching,
    perform the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用相同的 ASP.NET Web 项目和控制器来实现分布式缓存。我们所说的分布式缓存是什么意思？分布式缓存扩展了本地缓存的概念，包括跨多台计算机的缓存。这种缓存使得事务数据的扩展成为可能。你主要会使用分布式缓存来存储位于数据库中的应用程序数据，以及与
    Web 会话相关的数据。在本节中，我们使用 Redis 进行缓存。Redis 是一个内存数据结构存储，用作分布式、内存中的键值数据库、缓存和消息代理，具有可选的持久性。要实现分布式缓存，执行以下操作：
- en: 'Add the `Microsoft.Extensions.Caching.Redis` NuGet package to the web package.
    You can use the following command:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Microsoft.Extensions.Caching.Redis` NuGet 包添加到 Web 包中。你可以使用以下命令：
- en: '[PRE46]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the `HomeController` class, add the `using Microsoft.Extensions.Caching.Distributed`
    statement.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HomeController` 类中，添加 `using Microsoft.Extensions.Caching.Distributed` 语句。
- en: 'Add the following member variable:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下成员变量：
- en: '[PRE47]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This variable will hold our distributed cache object that gets injected via
    the constructor.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将保存我们的分布式缓存对象，该对象通过构造函数注入。
- en: 'Now, update the constructor code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新构造函数代码：
- en: '[PRE48]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We are injecting the distributed cache object and setting our member variable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在注入分布式缓存对象并设置我们的成员变量。
- en: 'To use our distributed cache, we will need to encode and decode Base64 strings.
    Add the following two methods:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用我们的分布式缓存，我们需要对 Base64 字符串进行编码和解码。添加以下两个方法：
- en: '[PRE49]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In these two methods, we are encoding a string as a Base64 encoded string, and
    we are also decoding strings from Base64 to UTF8.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个方法中，我们将字符串编码为 Base64 编码的字符串，同时也将字符串从 Base64 解码为 UTF8。
- en: 'Add the `GetDistriutedCacheString` method:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GetDistriutedCacheString` 方法：
- en: '[PRE50]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this code, we obtain string data from the cache. If it exists, then we return
    it. If it does not exist, then we save the Base64 encoded version of the string
    to the cache with an absolute expiry being set and then return the Base64 decoded
    version of the string as a UTF encoded string.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们从缓存中获取字符串数据。如果存在，则返回它。如果不存在，则将字符串的 Base64 编码版本保存到缓存中，并设置绝对过期时间，然后以 UTF
    编码的字符串形式返回字符串的 Base64 解码版本。
- en: 'Update the `HomeController.Index` method, as shown here:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `HomeController.Index` 方法，如下所示：
- en: '[PRE51]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This code obtains in-memory cache and distributed cache stored data and outputs
    it to the user, showing the current time, the in-memory cached time, and the data
    stored in the distributed cache.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码获取内存缓存和分布式缓存存储的数据，并将其输出给用户，显示当前时间、内存缓存时间和分布式缓存中的数据。
- en: 'Run the program and navigate to `https://localhost:5001`. You should see the
    following output:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并导航到 `https://localhost:5001`。你应该会看到以下输出：
- en: '[PRE52]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can see that the memory cached time and distributed cache string have both
    just been added to the cache because they are the same as the current time. Now,
    refresh your browser. You should see that both cached values are older than the
    current time as shown:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，内存缓存时间和分布式缓存字符串都刚刚被添加到缓存中，因为它们与当前时间相同。现在，刷新你的浏览器。你应该会看到这两个缓存值都早于当前时间，如下所示：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this and the previous section, you have seen how easy it is to add in-memory
    and distributed caching to our application. Both forms of caching can be really
    useful in improving the performance of your ASP.NET web applications. In the next
    section, we will look at how to update a small section of the currently displayed
    page using AJAX.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和上一节中，您已经看到如何轻松地将内存和分布式缓存添加到我们的应用程序中。这两种缓存形式都可以在提高您的ASP.NET Web应用程序性能方面非常有用。在下一节中，我们将探讨如何使用AJAX更新当前显示页面的一个小部分。
- en: Using AJAX to update part of the currently displayed page
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AJAX更新当前显示页面的部分
- en: 'In this section, we will use AJAX to update a part of a page that is currently
    being displayed. This saves us from having to load the whole page. Let’s start
    writing our AJAX example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用AJAX来更新当前正在显示的页面的一部分。这样我们就不必加载整个页面。让我们开始编写我们的AJAX示例：
- en: Right-click on the `Controllers` folder. From the context menu, select **Add**
    | **Controller…**. Then, select **MVC Controller – Empty**.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Controllers` 文件夹。从上下文菜单中选择 **添加** | **控制器…**。然后，选择 **MVC 控制器 – 空的**。
- en: Call the new controller `AjaxController` and open the class.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用新的控制器`AjaxController`并打开类。
- en: 'Update the controller by adding the following method:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下方法来更新控制器：
- en: '[PRE54]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method when called will return a JSON result, which in our case is a simple
    string.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此方法时，将返回一个JSON结果，在我们的例子中是一个简单的字符串。
- en: '*Right-click* on the `Index` method and select `index.cshtml`.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击* `Index` 方法并选择 `index.cshtml`。'
- en: 'Update the `Views/Ajax/index.cshtml` file with the following HTML and JavaScript
    code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下HTML和JavaScript代码更新 `Views/Ajax/index.cshtml` 文件：
- en: '[PRE55]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We have an HTML form. That form has a button that, when pressed, will execute
    JavaScript that will retrieve AJAX data by executing our `AjaxDemo` action method.
    This will result in our JSON string being displayed on the page.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个HTML表单。该表单有一个按钮，当按下时，将执行JavaScript，通过执行我们的`AjaxDemo`操作方法来检索AJAX数据。这将导致我们的JSON字符串在页面上显示。
- en: 'Run the project and navigate to `http://localhost:5001/Ajax`. You should see
    the following:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目并导航到 `http://localhost:5001/Ajax`。您应该看到以下内容：
- en: '![Figure 12.5 – The AJAX demo before AJAX is retrieved'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.5 – 在AJAX检索之前AJAX演示](img/Figure_12.05_B16617.jpg)'
- en: '](img/Figure_12.05_B16617.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.05_B16617.jpg](img/Figure_12.05_B16617.jpg)'
- en: Figure 12.5 – The AJAX demo before AJAX is retrieved
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.5 – 在AJAX检索之前AJAX演示](img/Figure_12.05_B16617.jpg)'
- en: 'As you can see, our page is loaded without our JSON string. Now, click the
    **Ajax Demonstration** button. You now see the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的页面在没有我们的JSON字符串的情况下加载。现在，点击 **Ajax 演示** 按钮。您现在看到以下内容：
- en: '![Figure 12.6 – The AJAX demo displaying the JSON string retrieved using AJAX'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.6 – 使用AJAX检索并显示的JSON字符串](img/Figure_12.06_B16617.jpg)'
- en: '](img/Figure_12.06_B16617.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.06_B16617.jpg](img/Figure_12.06_B16617.jpg)'
- en: Figure 12.6 – The AJAX demo displaying the JSON string retrieved using AJAX
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.6 – 使用AJAX检索并显示的JSON字符串](img/Figure_12.06_B16617.jpg)'
- en: After clicking the button, we can see that the AJAX action retrieved our JSON
    string and displayed it on the page without a complete page load.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，我们可以看到AJAX操作检索了我们的JSON字符串，并在不进行完整页面加载的情况下将其显示在页面上。
- en: We have seen how to update a portion of a page using AJAX, and before that,
    we saw how to implement in-memory and distributed caching. In the next section,
    we will look at how to implement WebSockets.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用AJAX更新页面的一部分，在此之前，我们看到了如何实现内存和分布式缓存。在下一节中，我们将探讨如何实现WebSockets。
- en: Implementing WebSockets
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现WebSockets
- en: In this section, we will be implementing **WebSockets**. You may have heard
    of WebSockets, but what are they? A WebSocket is a full-duplex communication protocol
    for communication over a single TCP connection. To find out more about the WebSocket
    specification, you can look up the IETF RFC 6455 from 2011 ([https://www.rfc-editor.org/rfc/rfc6455.txt](https://www.rfc-editor.org/rfc/rfc6455.txt)).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现 **WebSockets**。您可能已经听说过WebSockets，但它们是什么？WebSocket是一个全双工通信协议，用于通过单个TCP连接进行通信。要了解更多关于WebSocket规范的信息，您可以查阅2011年的IETF
    RFC 6455（[https://www.rfc-editor.org/rfc/rfc6455.txt](https://www.rfc-editor.org/rfc/rfc6455.txt)）。
- en: What do we use WebSockets for? Well, we can use them to open a single two-way
    interactive session between browsers and servers. That way, we can negate server
    polling, send messages to a server, and receive responses via events. Thus, making
    our applications event-driven.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要使用WebSockets？嗯，我们可以使用它们在浏览器和服务器之间打开一个单一的双向交互会话。这样，我们可以取消服务器轮询，向服务器发送消息，并通过事件接收响应。从而使我们的应用程序成为事件驱动的。
- en: 'In our WebSockets demonstration, we will click a button. It will open a WebSocket,
    send a message, receive a response, and then close the connection. The communication
    between our browser and the server will be output to our web page. So, let’s get
    started with writing our WebSocket example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的WebSocket演示中，我们将点击一个按钮。它将打开一个WebSocket，发送消息，接收响应，然后关闭连接。我们浏览器和服务器之间的通信将输出到我们的网页上。因此，让我们开始编写我们的WebSocket示例：
- en: Add a new controller called `WebSocketsController`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`WebSocketsController`的新控制器。
- en: Right-click the `Index` method and select **Add View**.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Index`方法并从上下文菜单中选择**添加视图**。
- en: 'Update the `Views/WebSockets/Index.cshtml` file as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新`Views/WebSockets/Index.cshtml`文件：
- en: '[PRE56]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When a WebSocket is opened via the button click, the `messages` paragraph is
    updated with messages, and then a message is sent to the server. When the server
    responds, the messages paragraph is then updated to inform the user that the server
    has responded. If an error occurs, then a message is displayed to the user. The
    WebSocket is then closed and a message is displayed on the page.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过按钮点击打开WebSocket时，`messages`段落会更新消息，然后向服务器发送一条消息。当服务器响应时，`messages`段落随后更新以通知用户服务器已响应。如果发生错误，则向用户显示一条消息。然后关闭WebSocket并在页面上显示一条消息。
- en: 'Run the code and navigate to `http://localhost:5001/WebSockets`. Click on the
    button, and you should end up with the following:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并导航到`http://localhost:5001/WebSockets`。点击按钮，你应该会得到以下结果：
- en: '![Figure 12.7 – The end result of clicking on the button and executing our
    WebSocket example'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 点击按钮并执行我们的WebSocket示例的最终结果]'
- en: '](img/Figure_12.07_B16617.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.07_B16617.jpg](img/Figure_12.07_B16617.jpg)'
- en: Figure 12.7 – The end result of clicking on the button and executing our WebSocket
    example
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 点击按钮并执行我们的WebSocket示例的最终结果
- en: There is not that much code to WebSockets. In this example, we have sent a simple
    message and received a response. All our code to do this exists in the `CSHTML`
    file of our view. In the next section, we will look at writing a real-time chat
    program using SignalR.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket的代码并不多。在这个示例中，我们发送了一条简单的消息并收到了响应。我们用于执行此操作的所有代码都存在于视图的`CSHTML`文件中。在下一节中，我们将探讨如何使用SignalR编写实时聊天程序。
- en: Implementing a real-time chat application using SignalR
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SignalR实现实时聊天应用程序
- en: 'In this section, we will learn how to write real-time functionality in an ASP.NET
    web application using SignalR. We will demonstrate SignalR in action by writing
    a simple chat application. We will now begin writing the application:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用SignalR在ASP.NET web应用程序中编写实时功能。我们将通过编写一个简单的聊天应用程序来演示SignalR的实际应用。现在，我们将开始编写应用程序：
- en: '*Right-click* the project and select **Add** | **Client-Side Library** from
    the context menu, and fill in the details as shown in *Figure 12.8*. Then, click
    the **Install** button:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目，并从上下文菜单中选择**添加** | **客户端库**，然后填写如图12.8所示的详细信息。然后，点击**安装**按钮：
- en: '![Figure 12.8 – The Add Client-Side Library configured to install SignalR'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 – 添加客户端库以配置安装SignalR]'
- en: '](img/Figure_12.08_B16617.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.08_B16617.jpg](img/Figure_12.08_B16617.jpg)'
- en: Figure 12.8 – The Add Client-Side Library configured to install SignalR
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 添加客户端库以配置安装SignalR
- en: Copy the `wwwroot/lib/microsoft/signalr` library and paste it into the `wwwroot/js`
    folder.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`wwwroot/lib/microsoft/signalr`库复制并粘贴到`wwwroot/js`文件夹中。
- en: Add a new controller called `SignalRController`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`SignalRController`的新控制器。
- en: Add a folder called `Hubs` under the main project root.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主项目根目录下添加一个名为`Hubs`的文件夹。
- en: 'Add a class to the `Hubs` folder called `ChatHub`. Then, update the `ChatHub`
    class, as shown here:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Hubs`文件夹中添加一个名为`ChatHub`的类。然后，更新`ChatHub`类，如下所示：
- en: '[PRE57]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We have our SignalR hub class in place, and our `SendMessage` method sends a
    message to the specified user asynchronously.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了SignalR hub类，并且`SendMessage`方法异步地向指定用户发送消息。
- en: '*Right-click* on the `Index` method in the `SignalRController` class and select
    **Add View** from the context menu.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SignalRController`类的`Index`方法上右键单击，并从上下文菜单中选择**添加视图**。
- en: 'In the `Views/SignalR/Index.cshtml` file, replace the existing contents with
    the following code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Views/SignalR/Index.cshtml`文件中，将现有内容替换为以下代码：
- en: '[PRE58]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We have put together a chat UI. The script uses SignalR. All we need to do now
    is add our JavaScript that makes our UI interactive.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个聊天UI。脚本使用SignalR。我们现在需要添加使我们的UI交互的JavaScript。
- en: 'In the `wwwroot/js` folder, add a file called `chat.js` with the following
    code:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`wwwroot/js`文件夹中，添加一个名为`chat.js`的文件，包含以下代码：
- en: '[PRE59]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have added JavaScript that makes our UI interactive. This code manages the
    sending of chat messages between users.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了使我们的 UI 交互式的 JavaScript。此代码管理用户之间的聊天消息发送。
- en: 'In the `Program` class, add the following services:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类中，添加以下服务：
- en: '[PRE60]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This code adds SignalR to our available services so that we can pass SignalR
    requests to SignalR.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将 SignalR 添加到我们的可用服务中，以便我们可以将 SignalR 请求传递给 SignalR。
- en: Note
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: If using the new minimal template, the code is `builder.Services.AddRazorPages();
    builder.Services.AddSignalR();`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用新的最小模板，代码是 `builder.Services.AddRazorPages(); builder.Services.AddSignalR();`。
- en: 'Update the `Program` class to include the mapped route to our `ChatHub`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Program` 类以包含映射到我们的 `ChatHub` 的路由：
- en: '[PRE61]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We have included the route to our `ChatHub` so that our chat application knows
    how to handle incoming requests.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了到我们的 `ChatHub` 的路由，这样我们的聊天应用程序就知道如何处理传入的请求。
- en: 'Run the code and navigate to `https://localhost:5001/SignalR`. You will need
    two browser instances side by side. Enter usernames and messages in each browser
    and click on the **Send Message** button. Each time you enter text, it will appear
    on the receiver’s chat page, as you can see here:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并导航到 `https://localhost:5001/SignalR`。你需要两个并排的浏览器实例。在每个浏览器中输入用户名和消息，然后点击**发送消息**按钮。每次输入文本时，它都会出现在接收者的聊天页面上，就像这里所示：
- en: '![Figure 12.9 – Our SignalR application in action'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.9 – Our SignalR application in action]'
- en: '](img/Figure_12.09_B16617.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.09_B16617.jpg]'
- en: Figure 12.9 – Our SignalR application in action
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.9 – Our SignalR application in action]'
- en: It was fairly straightforward setting up and running our SignalR. As you can
    see, SignalR is an excellent choice for real-time communication, and I am sure
    you will be able to take this knowledge further in the web applications you write.
    That concludes our work on ASP.NET in this chapter. So, let’s now move on to look
    at .NET MAUI in the next section.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和运行我们的 SignalR 比较直接。正如你所见，SignalR 是实时通信的一个优秀选择，我相信你将能够在你编写的网络应用程序中进一步运用这些知识。这就结束了本章关于
    ASP.NET 的内容。现在，让我们继续下一节，看看 .NET MAUI。
- en: Building responsive UIs with .NET MAUI
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET MAUI 构建响应式 UI
- en: Microsoft .NET MAUI is the new version of Xamarin.Forms. There have been some
    significant changes between Xamarin.Forms version 5.0 and .NET MAUI (Xamarin.Forms
    version 6.0). The biggest change in MAUI has been to combine the Android, iOS,
    and macOS projects into a main project. While the code specific to Windows still
    resides in its own project, Microsoft is working to include the Windows code in
    the main project. This will lead to us having one single project for writing cross-platform
    applications using C# and XAML. Let’s have a look at some of the other improvements
    to building cross-platform applications using .NET MAUI.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft .NET MAUI 是 Xamarin.Forms 的新版本。在 Xamarin.Forms 5.0 版本和 .NET MAUI（Xamarin.Forms
    6.0 版本）之间有一些重大变化。MAUI 最大的变化是将 Android、iOS 和 macOS 项目合并为一个主项目。虽然针对 Windows 的特定代码仍然位于其自己的项目中，但
    Microsoft 正在努力将 Windows 代码包含到主项目中。这将使我们能够使用 C# 和 XAML 编写跨平台应用程序时拥有一个单一的项目。让我们看看使用
    .NET MAUI 构建跨平台应用程序的其他一些改进。
- en: Note
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: If you are using an early version of MAUI, to run the Windows project, you will
    need to set the Windows project as the startup project and deploy the project.
    Once the project is deployed, you can run the application from the Windows start
    menu.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 MAUI 的早期版本，要运行 Windows 项目，你需要将 Windows 项目设置为启动项目并部署项目。一旦项目部署完成，你就可以从
    Windows 启动菜单中运行应用程序。
- en: Layouts
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: Another significant change made in .NET MAUI is that the original layouts used
    by Xamarin.Forms projects have been moved to `Microsoft.Maui.Controls.Compatibility`
    namespace. By default, MAUI will use new layouts. These layouts are based on a
    new `LayoutManager` that has been written for performance, consistency, and maintainability.
    The new layouts are `Grid`, `FlexLayout`, and `StackLayout` (`HorizontalStackLayout`
    and `VerticalStackLayout`). Microsoft encourages you to select the stack layout
    that best suits your needs. You are also encouraged to replace legacy layouts
    with new layouts.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中做出的另一个重大更改是，Xamarin.Forms 项目原本使用的布局已被移动到 `Microsoft.Maui.Controls.Compatibility`
    命名空间。默认情况下，MAUI 将使用新的布局。这些布局基于一个新编写的 `LayoutManager`，它针对性能、一致性和可维护性进行了优化。新的布局包括
    `Grid`、`FlexLayout` 和 `StackLayout`（`HorizontalStackLayout` 和 `VerticalStackLayout`）。Microsoft
    鼓励你选择最适合你需求的堆叠布局。同时，也鼓励你用新的布局替换旧布局。
- en: 'The default spacing values for the new layouts have been standardized to the
    value of 0\. Having these values as 0 sets the expectation that you will set your
    own preferred values to meet your design requirements. It is best to set these
    values in your global styles as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 新布局的默认间距值已标准化为0。将这些值设置为0设定了您将设置自己的首选值以满足设计要求的预期。最好在全局样式设置这些值，如下所示：
- en: '[PRE62]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Let’s move on to look at accessibility improvements.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看可访问性的改进。
- en: Accessibility
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可访问性
- en: Microsoft regularly meets with developers who are heavily invested in making
    applications that meet the highest accessibility rating. This led Microsoft to
    remove the `TabIndex` and `IsTabStop` properties, as they ended up being confusing
    and not meeting accessibility needs. For better accessibility, you can improve
    a screen reader’s ability to know the order of reading a UI by implementing a
    thoughtful design. If you need to take control over the order of UI components,
    Microsoft recommends that you use the `SemanticOrderView` component.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 微软定期与那些致力于开发最高可访问性评级应用程序的开发者会面。这促使微软移除了`TabIndex`和`IsTabStop`属性，因为它们最终变得令人困惑，并且没有满足可访问性需求。为了提高可访问性，您可以通过实施深思熟虑的设计来提高屏幕阅读器识别UI阅读顺序的能力。如果您需要控制UI组件的顺序，微软建议您使用`SemanticOrderView`组件。
- en: SetSemanticFocus and Announce
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SetSemanticFocus和Announce
- en: Screen readers are an essential part of an application that is accessible and
    friendly. To aid these applications’ performance in being able to read the correct
    components, there is a new `SemanticExtensions` class. As part of this class,
    there is a new method called `SetSematicFocus`. This method enables the setting
    of a screen reader’s focus to a specific element.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕阅读器是可访问且友好的应用程序的重要组成部分。为了帮助这些应用程序在读取正确组件方面的性能，有一个新的`SemanticExtensions`类。作为此类的一部分，有一个名为`SetSematicFocus`的新方法。此方法允许将屏幕阅读器的焦点设置到特定元素。
- en: Note
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, `SetSemanticFocus` and `Announce` are only available
    for iOS, Android, and Mac Catalyst.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`SetSemanticFocus`和`Announce`仅适用于iOS、Android和Mac Catalyst。
- en: 'Here is a XAML example of setting semantic focus:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个设置语义焦点的XAML示例：
- en: '[PRE71]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In this XAML, we have an instruction label and a button for the user to press.
    When the button is pressed, the click event will set the semantic focus to `semanticFocusLabel`.
    Here is the click event code:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个XAML中，我们有一个指令标签和一个用户可以按下的按钮。当按钮被按下时，点击事件会将语义焦点设置到`semanticFocusLabel`。以下是点击事件代码：
- en: '[PRE88]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following code enables the screen reader to make an announcement:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使屏幕阅读器能够发出公告：
- en: '[PRE93]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Another accessibility addition is automatic font scaling.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可访问性新增功能是自动字体缩放。
- en: Font scaling
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字体缩放
- en: 'By default, all components now have automatic font scaling, and it is enabled
    by default. That means that when your users change their text scaling on the various
    platforms, your application’s text will scale to their chosen settings automatically.
    You can turn automatic font scaling off for control with the following markup:
    `FontAutoScalingEnabled=”False”`. Changing the attribute to `True` or removing
    it will turn font auto-scaling back on.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有组件现在都具有自动字体缩放，并且默认启用。这意味着当您的用户在各个平台上更改文本缩放时，您的应用程序的文本将自动缩放到他们选择的设置。您可以使用以下标记关闭自动字体缩放：`FontAutoScalingEnabled="False"`。将属性更改为`True`或删除它将重新启用字体自动缩放。
- en: BlazorWebView
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BlazorWebView
- en: 'Using BlazorWebView, you can host Blazor websites in your Microsoft MAUI applications.
    This enables your Blazor website to make use of native platform functionality
    and various user controls. You can add `BlazorWebView` to a XAML page and point
    it to the root of your Blazor application:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BlazorWebView，您可以在Microsoft MAUI应用程序中托管Blazor网站。这使得您的Blazor网站能够利用原生平台功能和各种用户控件。您可以将`BlazorWebView`添加到XAML页面，并将其指向Blazor应用程序的根：
- en: '[PRE96]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As you can see from the XAML, the root of our Blazor application is `wwwroot/index.html`.
    In the next section, we will take a look at WinUI 3.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从XAML中看到的，我们Blazor应用程序的根是`wwwroot/index.html`。在下一节中，我们将探讨WinUI 3。
- en: Note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As of June 20, 2022, MAUI is generally available, but to develop MAUI applications,
    you will need to install a .NET 2022 preview.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年6月20日，MAUI已普遍可用，但为了开发MAUI应用程序，您需要安装.NET 2022预览版。
- en: Building a responsive UI with MAUI
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MAUI构建响应式UI
- en: 'In this section, we will build a simple responsive UI using MAUI. Until MAUI
    is included with Visual Studio 2022, you will need to ensure you use Visual Studio
    2022 Preview:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用MAUI构建一个简单的响应式UI。在MAUI包含在Visual Studio 2022之前，您需要确保您使用Visual Studio
    2022预览版：
- en: Start a new .NET MAUI app and call it `CH12_ResponsiveMAUI`.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的.NET MAUI应用程序，命名为`CH12_ResponsiveMAUI`。
- en: Add a new folder called `Api`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Api`的新文件夹。
- en: 'In the `Api` folder, add a class called `PropertyChangedNotifier` and replace
    its contents with the following code:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Api`文件夹中，添加一个名为`PropertyChangedNotifier`的类，并用以下代码替换其内容：
- en: '[PRE103]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This code is a base class that implements the `INotifyPropertyChanged` interface.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码是一个实现`INotifyPropertyChanged`接口的基类。
- en: Add a new folder called `Data`.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Data`的新文件夹。
- en: 'Add a new class to the `Data` folder called `BaseEntity` with the following
    properties:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Data`文件夹中添加一个名为`BaseEntity`的新类，并具有以下属性：
- en: '[PRE104]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: These are base properties for our entities that will inherit this class.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们实体的基本属性，将继承此类。
- en: 'Add a new interface to the `Data` folder called `IRepository` and replace the
    class with the following code:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Data`文件夹中添加一个名为`IRepository`的新接口，并用以下代码替换类：
- en: '[PRE105]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This interface will be implemented by all our repositories.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口将由所有我们的存储库实现。
- en: 'Add a class called `BaseRepository` to the `Data` folder and update the class
    with the following code:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Data`文件夹中添加一个名为`BaseRepository`的类，并用以下代码更新类：
- en: '[PRE106]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This class is a generic base repository that implements the `IRepository` interface.
    The context for storing data is of type `ICollection`, and we set `Context` to
    the collection passed in as a parameter.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 此类是一个通用的基本存储库，实现了`IRepository`接口。存储数据上下文为`ICollection`类型，我们将`Context`设置为作为参数传入的集合。
- en: 'Add the `Add` method:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Add`方法：
- en: '[PRE107]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This code adds an entity to our collection.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将一个实体添加到我们的集合中。
- en: 'Add the `Count` method:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Count`方法：
- en: '[PRE108]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This code returns the count of all the entities in our collection.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码返回我们集合中所有实体的数量。
- en: 'Add the `Filter` method:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Filter`方法：
- en: '[PRE109]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This code takes a query and returns a filtered list of items.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码接收一个查询并返回一个过滤后的项目列表。
- en: 'Add the `FilteredCount` method:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`FilteredCount`方法：
- en: '[PRE110]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This code returns the items in our filtered list.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码返回我们过滤列表中的项目。
- en: 'Add the `FirstOrDefault` method:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`FirstOrDefault`方法：
- en: '[PRE111]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This method returns the first record to match our query. If there is no match,
    then the default value is returned instead.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回与我们的查询匹配的第一条记录。如果没有匹配项，则返回默认值。
- en: 'Add the `GetAll` method:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GetAll`方法：
- en: '[PRE112]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The method returns all the items in our list.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回我们列表中的所有项。
- en: 'Add the `GetById` method:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GetById`方法：
- en: '[PRE113]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This method gets an item from the list, as identified by its ID number.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法根据其ID号从列表中获取一个项。
- en: 'Add the `Remove` method:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Remove`方法：
- en: '[PRE114]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This method removes an entity from the collection.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从集合中删除一个实体。
- en: 'Add the `Update` method:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Update`方法：
- en: '[PRE115]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This method updates an entity in the collection.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法更新集合中的一个实体。
- en: 'Add a new class to the `Data` folder and call it `PeopleRepository`. Then,
    update the class definition as follows:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Data`文件夹中添加一个名为`PeopleRepository`的新类，并按以下方式更新类定义：
- en: '[PRE116]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This class creates a new repository of type `Person`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 此类创建了一个新的`Person`类型存储库。
- en: 'Add a new folder with a class called `Person`. Then, update the class as follows:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Data`文件夹中添加一个名为`Person`的新类。然后，按以下方式更新类：
- en: '[PRE117]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This class inherits our `BaseEntity` class and adds the properties `FirstName`
    and `LastName`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 此类继承我们的`BaseEntity`类并添加了`FirstName`和`LastName`属性。
- en: 'Add a new folder called `ViewModels` and a new class called `ViewModelBase`.
    Update the class definition as shown:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ViewModels`的新文件夹和一个名为`ViewModelBase`的新类。按以下所示更新类定义：
- en: '[PRE118]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This class is the base view model class for all our view models. It can be cast
    to any type, and it implements `PropertyChangeNotifer`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 此类是所有视图模型的基本视图模型类。它可以被转换为任何类型，并实现了`PropertyChangeNotifer`。
- en: 'Add `PeopleViewModel`:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`PeopleViewModel`：
- en: '[PRE119]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This code seeds our collection with people.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码用人员填充我们的集合。
- en: 'Add a new page to the root of the project called `SplashPage`:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录中添加一个名为`SplashPage`的新页面：
- en: '[PRE120]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Our `SplashPage` is a loading page that will display progress to the user in
    the form of a progress bar and label. The class inherits from the `Content` page
    and implements the `INotifyPropertyChanged` event. We have a timer whose callback
    is a method for reporting loading progress.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SplashPage`是一个加载页面，将以进度条和标签的形式向用户显示进度。该类继承自`Content`页面并实现了`INotifyPropertyChanged`事件。我们有一个计时器，其回调是一个报告加载进度的方法。
- en: 'Add the `ReportProgress` method:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ReportProgress`方法：
- en: '[PRE121]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This method stops the timer and runs the code to update the application loading
    progress status. It uses a safe invoke method that will update the splash screen.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法停止计时器并运行代码以更新应用程序加载进度状态。它使用一个安全调用方法来更新启动屏幕。
- en: 'Add the `LoadMainPage` method:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`LoadMainPage`方法：
- en: '[PRE122]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This method sets the application’s `MainPage` to `AppShell` and passes in a
    parameter of type `BaseEntity`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将应用程序的`MainPage`设置为`AppShell`，并传递一个类型为`BaseEntity`的参数。
- en: 'Add the `SaveInvokeInMaInThread` method:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`SaveInvokeInMaInThread`方法：
- en: '[PRE123]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This code performs a safe invocation on the main thread to update the UI. The
    method checks the device the application is running on before calling the correct
    method for the device.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在主线程上执行安全调用以更新UI。该方法在调用设备对应的方法之前会检查应用程序正在运行的设备。
- en: 'Add the `UpdateProgress` method:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`UpdateProgress`方法：
- en: '[PRE124]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This method updates the progress bar and the label.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法更新进度条和标签。
- en: 'Update the `SplashPage` XAML, as shown here:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`SplashPage` XAML，如下所示：
- en: '[PRE125]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This markup contains our UI definition that will be updated by the code when
    it runs.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 此标记包含我们的UI定义，当它运行时将由代码更新。
- en: 'Update `MainPage` by replacing the current XAML with the following XAML:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过替换以下XAML来更新`MainPage`：
- en: '[PRE126]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This code updates the original source by adding a table of people.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过添加人员表来更新原始源代码。
- en: 'Add a `PeopleRepository` class variable and update the constructor of the `MainPage`
    class, as shown here:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`PeopleRepository`类变量，并更新`MainPage`类的构造函数，如下所示：
- en: '[PRE127]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This code modifies our `MainPage` by setting its `BindingContext` to `PeopleViewModel`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过将`MainPage`的`BindingContext`设置为`PeopleViewModel`来修改我们的`MainPage`。
- en: 'Run the code, and you should see the following screen:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，你应该会看到以下屏幕：
- en: '![Figure 12.10 – The splash page'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.10 – 启动页面'
- en: '](img/Figure_12.10_B16617.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.10 – B16617.jpg](img/Figure_12.10_B16617.jpg)'
- en: Figure 12.10 – The splash page
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 12.10 – 启动页面
- en: 'The following screen is what you’ll see next:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕是你将看到的：
- en: '![Figure 12.11 – The main form with a table in a scroll view with a button
    that responds to clicks'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.11 – 带有滚动视图中的表格和响应点击按钮的主表单'
- en: '](img/Figure_12.11_B16617.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.11 – B16617.jpg](img/Figure_12.11_B16617.jpg)'
- en: Figure 12.11 – The main form with a table in a scroll view with a button that
    responds to clicks
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 12.11 – 带有滚动视图中的表格和响应点击按钮的主表单
- en: We have managed to build a responsive splash screen that also populates a table
    and responds to button clicks. That concludes our look at MAUI. We will now move
    on to WinUI 3.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功构建了一个响应式启动屏幕，它还会填充表格并响应用户点击按钮。这标志着我们对MAUI的探讨结束。现在我们将转向WinUI 3。
- en: Building a responsive UI with WinUI 3
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WinUI 3构建响应式UI
- en: 'In this section, we will look at how to provide user feedback using the `ProgressRing`
    component while performing a long-running operation in WinUI 3 applications. When
    your users trigger a long-running operation that holds up the UI, it is a good
    idea to provide user feedback until the operation completes. Let’s write a simple
    application that simulates a long-running operation using the following steps:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何在WinUI 3应用程序中执行长时间运行的操作时使用`ProgressRing`组件来提供用户反馈。当用户触发一个长时间运行的操作并阻止UI时，在操作完成之前提供用户反馈是一个好主意。让我们编写一个简单的应用程序，使用以下步骤来模拟长时间运行的操作：
- en: Start a new WinUI3 application and call it `CH12_ResponsiveWinUI3`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的WinUI3应用程序，并将其命名为`CH12_ResponsiveWinUI3`。
- en: 'Open `MainWindow.xaml` and replace the existing XAML between the Window tags
    with the following XAML:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml`并替换窗口标签之间的现有XAML，如下所示：
- en: '[PRE128]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: We have used `OneWay` binding to bind our the `ProgressRing` class' `IsActive`
    and `Visibility` properties to the `IsWorking` property.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`OneWay`绑定将`ProgressRing`类的`IsActive`和`Visibility`属性绑定到`IsWorking`属性。
- en: In the code behind the class, implement the `INotifyPropertyChanged` interface.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的代码后面实现`INotifyPropertyChanged`接口。
- en: 'Add the following members to the class:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下成员添加到类中：
- en: '[PRE129]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`_dispatcherTimer` will be used to simulate a long-running operation. The `PropertyChanged`
    event will be used to notify `ProgressRing` that the `IsWorking` property has
    changed, and the `_isWorking` variable will be updated to let `ProgressRing` know
    to either show or hide itself.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`_dispatcherTimer`将被用来模拟长时间运行的操作。`PropertyChanged`事件将被用来通知`ProgressRing`，`IsWorking`属性已更改，`_isWorking`变量将被更新，让`ProgressRing`知道是显示还是隐藏自己。'
- en: 'Add a method to raise the `PropertyChanged` event if it is not `null`:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`PropertyChanged`事件不是`null`，则添加一个方法来引发该事件：
- en: '[PRE130]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: When we set the `IsWorking` property, we call this method so that the `PropertyChanged`
    event is raised.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置 `IsWorking` 属性时，我们调用此方法以引发 `PropertyChanged` 事件。
- en: 'Add the following three lines to the constructor:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加以下三行代码：
- en: '[PRE131]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: These three lines instantiate our `DispatcherTimer`, set its interval to `10`
    seconds, and add the `Tick` event handler.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行代码实例化了我们的 `DispatcherTimer`，将其间隔设置为 `10` 秒，并添加了 `Tick` 事件处理程序。
- en: 'We will now add the `DispatcherTimer_Tick` event handler:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加 `DispatcherTimer_Tick` 事件处理程序：
- en: '[PRE132]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We stop the timer and remove the event handler to stop it from firing again
    and being held in memory. Then, we set the `IsWorking` property to `false`, which
    results in `ProgressRing` being hidden and made inactive. Then, we add a message
    to `MessageTextBlock`.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们停止计时器并移除事件处理程序，以防止它再次触发并被保留在内存中。然后，我们将 `IsWorking` 属性设置为 `false`，这将导致 `ProgressRing`
    被隐藏并变为不活动状态。然后，我们向 `MessageTextBlock` 添加一条消息。
- en: 'Now, add the `IsWorking` property:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `IsWorking` 属性：
- en: '[PRE133]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: When setting our property, we call the `NotifyPropertyChanged` method that raises
    the `PropertyChanged` event to let `ProgressRing` know that the property has changed.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当设置我们的属性时，我们调用 `NotifyPropertyChanged` 方法来引发 `PropertyChanged` 事件，让 `ProgressRing`
    知道属性已更改。
- en: 'Now, add the code for the button click:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加按钮点击的代码：
- en: '[PRE134]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We collapse our button, as it is no longer needed. Set the `IsWorking` property
    to `true`, and start our `DispatcherTimer`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们折叠我们的按钮，因为它不再需要。将 `IsWorking` 属性设置为 `true`，并启动我们的 `DispatcherTimer`。
- en: Run the code. You should see a single button that says `ProgressRing` for 10
    seconds. Then, `ProgressRing` should disappear and be replaced with the text **Work
    completed**.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。你应该看到一个显示 `ProgressRing` 的单个按钮，持续 10 秒。然后，`ProgressRing` 应该消失，并被文本 **工作完成**
    替换。
- en: Now that we have concluded our look at responsive UIs, let’s summarize what
    we have learned.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经结束了对响应式 UI 的探讨，让我们总结一下我们学到了什么。
- en: Summary
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to work with various UI frameworks to make
    UIs responsive. First, we looked at WinForms. With WinForms, we enabled DPI and
    long file path awareness. We also ensured that despite running long background
    tasks, we could page through data in a table and perform other UI operations,
    and we also added a splash screen that updates with the loading progress.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用各种 UI 框架来使 UI 响应。首先，我们看了 WinForms。使用 WinForms，我们启用了 DPI 和长文件路径感知。我们还确保即使在运行长时间的后台任务时，我们也能在表格中翻页并执行其他
    UI 操作，我们还添加了一个更新加载进度的启动画面。
- en: With WPF, we managed to produce a window that has a long-running task that can
    be canceled with progress indication. It also has a paged data table and button
    that, when clicked, updates the click count label.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WPF，我们成功地创建了一个具有长时间运行任务（可以取消并显示进度指示）的窗口。它还有一个分页的数据表和按钮，当点击时，会更新点击计数标签。
- en: Then, we looked at memory caching and distributed caching in ASP.NET. We also
    used AJAX to update part of the currently displayed page and looked at WebSockets
    and SignalR. We implemented a real-time ASP.NET chat application using SignalR.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看了 ASP.NET 中的内存缓存和分布式缓存。我们还使用了 AJAX 来更新当前显示页面的部分，并研究了 WebSockets 和 SignalR。我们使用
    SignalR 实现了一个实时 ASP.NET 聊天应用程序。
- en: We then went on to look at MAUI. In particular, we looked at layouts, accessibility,
    and `BlazorWebView`. Finally, we looked at WinUI 3 and how to provide user feedback
    when a long-running process is taking place.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续研究 MAUI。特别是，我们研究了布局、可访问性和 `BlazorWebView`。最后，我们研究了 WinUI 3 以及如何在长时间运行的过程中提供用户反馈。
- en: In the next chapter, we will be looking at distributed systems. But first, try
    answering the questions in the next section, and then do some further reading
    to enhance your knowledge of responsive UIs.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨分布式系统。但首先，尝试回答下一节中的问题，然后进行一些进一步阅读，以增强你对响应式 UI 的了解。
- en: Questions
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can you make a WinForms application scale properly on high-DPI screens or
    normal-DPI large screens?
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使 WinForms 应用程序在高清屏幕或普通 DPI 的大屏幕上正确缩放？
- en: How do you cope with long file paths on Windows?
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Windows 上处理长文件路径？
- en: How can you keep users engaged when your application takes a long time to start?
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的应用程序启动时间较长时，你如何保持用户的参与度？
- en: How can you keep an application responsive to user input when you have a long-running
    process in operation?
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你有一个长时间运行的过程正在运行时，你如何保持应用程序对用户输入的响应性？
- en: What caching methods can you use to speed up access to resources?
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用哪些缓存方法来加速对资源的访问？
- en: How can you load only part of a web page?
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何只加载网页的一部分？
- en: Name two frameworks for performing network data transfer and real-time networked
    communication?
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两个用于执行网络数据传输和实时网络通信的框架？
- en: Name three accessibility methods available in MAUI.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出MAUI中可用的三种无障碍方法。
- en: How do you include an existing Blazor web application in an MAUI project?
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将现有的Blazor Web应用包含在MAUI项目中？
- en: When your application is already loaded, and a user kicks off a long-running
    operation, what controls can you use to provide user feedback so that users don’t
    think your WinUI 3 application has crashed?
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的应用程序已经加载，并且用户启动一个长时间运行的操作时，您可以使用哪些控件来提供用户反馈，以便用户不会认为您的WinUI 3应用程序已崩溃？
- en: Further reading
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Which is best? WebSockets or SignalR*: [https://dotnetplaybook.com/which-is-best-websockets-or-signalr/](https://dotnetplaybook.com/which-is-best-websockets-or-signalr/
    )'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哪个更好？WebSockets还是SignalR*: [https://dotnetplaybook.com/which-is-best-websockets-or-signalr/](https://dotnetplaybook.com/which-is-best-websockets-or-signalr/
    )'
- en: '*Why is SignalR/messagepack 2 times faster than gRPC/protobuf?*: [https://github.com/grpc/grpc-dotnet/issues/812](https://github.com/grpc/grpc-dotnet/issues/812
    )'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么SignalR/messagepack比gRPC/protobuf快两倍？*: [https://github.com/grpc/grpc-dotnet/issues/812](https://github.com/grpc/grpc-dotnet/issues/812
    )'
- en: '*Tutorial: Get started with ASP.NET Core SignalR*: [https://docs.microsoft.com/aspnet/core/tutorials/signalr?view=aspnetcore-5.0&tabs=visual-studio](https://docs.microsoft.com/aspnet/core/tutorials/signalr?view=aspnetcore-5.0&tabs=visual-studio
    )'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*教程：开始使用ASP.NET Core SignalR*: [https://docs.microsoft.com/aspnet/core/tutorials/signalr?view=aspnetcore-5.0&tabs=visual-studio](https://docs.microsoft.com/aspnet/core/tutorials/signalr?view=aspnetcore-5.0&tabs=visual-studio
    )'
- en: '*WebSocket*: [https://javascript.info/websocket](https://javascript.info/websocket)'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WebSocket*: [https://javascript.info/websocket](https://javascript.info/websocket)'
- en: '*Migrate your app from Xamarin.Forms*: https://docs.microsoft.com/dotnet/maui/get-started/migrate'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将您的应用从Xamarin.Forms迁移*: https://docs.microsoft.com/dotnet/maui/get-started/migrate'
- en: '*Xamarin.Forms Made Easy*: [https://winstongubantes.blogspot.com/2018/09/backgrounding-with-xamarinforms-easy-way.html](https://winstongubantes.blogspot.com/2018/09/backgrounding-with-xamarinforms-easy-way.html)'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Xamarin.Forms Made Easy*: [https://winstongubantes.blogspot.com/2018/09/backgrounding-with-xamarinforms-easy-way.html](https://winstongubantes.blogspot.com/2018/09/backgrounding-with-xamarinforms-easy-way.html)'
- en: '*Xamarin – Working with threads*: [https://lukealderton.com/blog/posts/2016/october/xamarin-forms-working-with-threads/](https://lukealderton.com/blog/posts/2016/october/xamarin-forms-working-with-threads/
    )'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Xamarin – 与线程一起工作*: [https://lukealderton.com/blog/posts/2016/october/xamarin-forms-working-with-threads/](https://lukealderton.com/blog/posts/2016/october/xamarin-forms-working-with-threads/
    )'
- en: 'Creating Android emulators on Windows: [https://docs.microsoft.com/xamarin/android/get-started/installation/android-emulator/device-manager?tabs=windows&pivots=windows](https://docs.microsoft.com/xamarin/android/get-started/installation/android-emulator/device-manager?tabs=windows&pivots=windows)'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在Windows上创建Android模拟器: [https://docs.microsoft.com/xamarin/android/get-started/installation/android-emulator/device-manager?tabs=windows&pivots=windows](https://docs.microsoft.com/xamarin/android/get-started/installation/android-emulator/device-manager?tabs=windows&pivots=windows)'
- en: 'Installing the Microsoft OpenJDK: [https://docs.microsoft.com/xamarin/android/get-started/installation/openjdk](https://docs.microsoft.com/xamarin/android/get-started/installation/openjdk
    )'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '安装Microsoft OpenJDK: [https://docs.microsoft.com/xamarin/android/get-started/installation/openjdk](https://docs.microsoft.com/xamarin/android/get-started/installation/openjdk
    )'
- en: '*Single-project MSIX Packaging Tools for VS 2022*: https://marketplace.visualstudio.com/items?itemName=ProjectReunion.MicrosoftSingleProjectMSIXPackagingToolsDev17'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为VS 2022的单项目MSIX打包工具*: https://marketplace.visualstudio.com/items?itemName=ProjectReunion.MicrosoftSingleProjectMSIXPackagingToolsDev17'
- en: '*Improving rendering performance with Blazor component virtualization*: [https://www.daveabrock.com/2020/10/20/blazor-component-virtualization/#:~:text=Improve%20rendering%20performance%20with%20Blazor%20component%20virtualization%20Use,the%20entire%20HTML%20tree%20loads%20from%20the%20server](https://www.daveabrock.com/2020/10/20/blazor-component-virtualization/#:~:text=Improve%20rendering%20performance%20with%20Blazor%20component%20virtualization%20Use,the%20entire%20HTML%20tree%20loads%20from%20the%20server).'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Blazor组件虚拟化提高渲染性能*: [https://www.daveabrock.com/2020/10/20/blazor-component-virtualization/#:~:text=Improve%20rendering%20performance%20with%20Blazor%20component%20virtualization%20Use,the%20entire%20HTML%20tree%20loads%20from%20the%20server](https://www.daveabrock.com/2020/10/20/blazor-component-virtualization/#:~:text=Improve%20rendering%20performance%20with%20Blazor%20component%20virtualization%20Use,the%20entire%20HTML%20tree%20loads%20from%20the%20server).'
- en: '*How to Reuse Xamarin.Forms Custom Renderers in .NET MAUI*: [https://www.syncfusion.com/blogs/post/how-to-reuse-xamarin-forms-custom-renderers-in-net-maui.aspx](https://www.syncfusion.com/blogs/post/how-to-reuse-xamarin-forms-custom-renderers-in-net-maui.aspx)'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何在 .NET MAUI 中重用 Xamarin.Forms 自定义渲染器*: [https://www.syncfusion.com/blogs/post/how-to-reuse-xamarin-forms-custom-renderers-in-net-maui.aspx](https://www.syncfusion.com/blogs/post/how-to-reuse-xamarin-forms-custom-renderers-in-net-maui.aspx)'
- en: '*Announcing .NET MAUI Preview 7*: [https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-7/](https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-7/)'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*宣布 .NET MAUI 预览版 7*: [https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-7/](https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-7/)'
- en: '*.NET Multi-platform App UI*: [https://dotnet.microsoft.com/en-us/apps/maui](https://dotnet.microsoft.com/en-us/apps/maui)'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET 多平台应用程序用户界面*: [https://dotnet.microsoft.com/en-us/apps/maui](https://dotnet.microsoft.com/en-us/apps/maui)'
