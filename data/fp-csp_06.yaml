- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Higher-Order Functions and Delegates
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数与代表
- en: In this chapter, we’ll dive into higher-order functions and delegates in C#.
    These concepts are crucial in functional programming and will help you write more
    flexible and maintainable code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究C#中的高阶函数和代表。这些概念在函数式编程中至关重要，并将帮助你编写更灵活、更易于维护的代码。
- en: Higher-order functions are simply functions that can take other functions as
    arguments or return a function. This might sound complex, but don’t worry; we’ll
    break it down with clear examples and explanations. Higher-order functions are
    a key part of functional programming, allowing you to write code that’s both more
    concise and more expressive.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数仅仅是能够接受其他函数作为参数或返回一个函数的函数。这听起来可能很复杂，但别担心；我们将通过清晰的示例和解释来分解它。高阶函数是函数式编程的关键部分，允许你编写更简洁、更具有表现力的代码。
- en: 'Delegates in C# are closely related to higher-order functions. They are like
    variables for methods, allowing you to pass methods as arguments or store them
    as values. This chapter will help you understand how to use delegates to implement
    higher-order functions in the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，代表（Delegates）与高阶函数（Higher-order functions）密切相关。它们类似于方法变量，允许你将方法作为参数传递或将它们作为值存储。本章将帮助你理解如何在以下部分使用代表来实现高阶函数：
- en: Understanding higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解高阶函数
- en: Delegates, actions, funcs, and predicates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表、动作、Func和谓词
- en: Callbacks, events, and anonymous methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调、事件和匿名方法
- en: Harnessing LINQ methods as higher-order functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用LINQ方法作为高阶函数
- en: Case study – putting it all together
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究 – 将所有内容整合在一起
- en: Best practices and common pitfalls
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践和常见陷阱
- en: In keeping with the tradition of our previous chapters, we’ll start this one
    with a brief self-evaluation. Below are three tasks designed to test your understanding
    of the concepts that will be discussed in this chapter. If you hesitate or struggle
    with these tasks, I recommend that you pay close attention to this chapter. However,
    if you find them easy, it might be a good opportunity to focus on areas where
    your knowledge isn’t as strong. So, let’s look at the tasks now.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们前几章的传统，我们将从一次简短的自我评估开始这一章。下面有三个任务，旨在测试你对本章将要讨论的概念的理解。如果你对这些任务犹豫不决或感到困难，我建议你仔细阅读这一章。然而，如果你觉得它们很容易，这可能是一个专注于你知识不那么强的领域的良好机会。现在，让我们来看看这些任务。
- en: Task 1 – Sorting function
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务1 – 排序函数
- en: Write a program that uses a higher-order function to sort a list of towers in
    Steve’s game based on their damage output. The sorting function should be passed
    as a delegate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，使用高阶函数根据史蒂夫游戏中的塔的输出伤害对塔列表进行排序。排序函数应作为代表传递。
- en: Task 2 – Customized calculations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务2 – 定制计算
- en: Create a method that takes an `Action` and a list of enemies. The `Action` should
    perform a calculation on each enemy’s health and print the result. Test your method
    using several different `Action`s, such as calculating damage taken from different
    tower types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个方法，该方法接受一个`Action`和一个敌人列表。`Action`应对每个敌人的健康进行计算并打印结果。使用几个不同的`Action`测试你的方法，例如计算来自不同塔类型的伤害。
- en: Task 3 – Comparison
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务3 – 比较
- en: Implement a method that uses a `Func` delegate to compare two towers based on
    their range. The method should return the tower with the longer range.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个使用`Func`代表来比较两个塔基于其射程的方法。该方法应返回射程较长的塔。
- en: Understanding higher-order functions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解高阶函数
- en: 'In functional programming, a higher-order function is simply a function that
    does at least one of the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，高阶函数简单地说是一个至少执行以下操作之一的函数：
- en: Takes one or more functions as parameters
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个或多个函数作为参数
- en: Returns a function as a result
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数作为结果
- en: Yes, you heard it right! Higher-order functions treat functions as data, to
    be passed around like any other value. This leads to an unprecedented level of
    abstraction and code reuse.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你没有听错！高阶函数将函数视为数据，像任何其他值一样传递。这导致前所未有的抽象水平和代码重用。
- en: 'Consider a video management system in a YouTube-like platform, where efficiently
    handling a large collection of videos is crucial. Instead of writing separate
    functions for each type of video filtering, we can utilize higher-order functions
    for a more elegant and reusable solution. A higher-order function can abstract
    the filtering logic, making the code more modular and maintainable. Here’s a simplified
    example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个类似于YouTube的视频管理系统，在这个系统中，高效处理大量视频至关重要。而不是为每种类型的视频过滤编写单独的函数，我们可以利用高阶函数来获得更优雅和可重用的解决方案。高阶函数可以抽象过滤逻辑，使代码更模块化和易于维护。以下是一个简化的示例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this system, we have a collection of `Video` objects. We want to filter these
    videos based on different criteria such as visibility, length, or genre. To achieve
    this, we create a higher-order function called `FilterVideos`. This function takes
    a collection of videos and returns another function. The returned function is
    capable of filtering the videos based on a provided predicate – a function that
    defines the filtering criteria. This design allows us to easily create various
    filters without duplicating the filtering logic, thereby enhancing code reuse
    and readability.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统中，我们有一个 `Video` 对象的集合。我们希望根据不同的标准如可见性、长度或类型来过滤这些视频。为了实现这一点，我们创建了一个名为 `FilterVideos`
    的高阶函数。这个函数接受一个视频集合，并返回另一个函数。返回的函数能够根据提供的谓词（定义过滤标准的函数）来过滤视频。这种设计使我们能够轻松地创建各种过滤器，而不必重复过滤逻辑，从而增强代码的重用和可读性。
- en: The power of higher-order functions in functional programming
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数在函数式编程中的力量
- en: Higher-order functions are a cornerstone of functional programming, offering
    robustness and flexibility. Their ability to treat functions as data, and the
    resulting abstraction and versatility, can be seen in various facets of programming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是函数式编程的基石，提供了稳健性和灵活性。它们将函数作为数据的能力，以及由此产生的抽象和通用性，可以在编程的各个方面看到。
- en: 'The ability of higher-order functions to abstract and encapsulate behaviors
    is unparalleled, leading to significant code reuse. For instance, consider a scenario
    in a mobile tower defense game where we need various types of unit transformations.
    Instead of repeating transformation logic, we can abstract this through a higher-order
    function. Here’s an illustrative example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数抽象和封装行为的能力是无与伦比的，这导致了显著的代码重用。例如，考虑一个在移动塔防游戏中的场景，我们需要各种类型的单位转换。而不是重复转换逻辑，我们可以通过高阶函数来抽象这一点。以下是一个说明性的示例：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, `CreateTransformation` is a higher-order function that returns
    a new function, encapsulating the transformation behavior. It promotes code reuse
    and abstraction by providing a flexible way to apply different transformations
    to game units.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`CreateTransformation` 是一个高阶函数，它返回一个新的函数，封装了转换行为。它通过提供一种灵活的方式来应用不同的转换到游戏单位，从而促进了代码的重用和抽象。
- en: Creating versatile code with fewer errors
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用更少的错误创建通用代码
- en: Higher-order functions also contribute to writing generic and versatile code,
    leading to fewer errors. By encapsulating a generic behavior, these functions
    reduce the amount of code written, which is then more frequently tested and less
    prone to bugs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数也有助于编写通用和灵活的代码，导致错误更少。通过封装通用行为，这些函数减少了编写的代码量，这使得代码更频繁地被测试，并且更不容易出错。
- en: 'Consider a function for applying effects to units in a tower defense game.
    Using a higher-order function, we can pass different effects as parameters:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个在塔防游戏中对单位应用效果的函数。使用高阶函数，我们可以将不同的效果作为参数传递：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `ApplyEffect` allows for various effects to be applied to game units,
    simplifying the code base and reducing potential errors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ApplyEffect` 允许对游戏单位应用各种效果，简化了代码库并减少了潜在的错误。
- en: Supporting a more declarative coding style
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持更声明式的编码风格
- en: Higher-order functions foster a declarative style of coding. You describe what
    you want to achieve rather than how to achieve it, making code more readable and
    maintainable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数促进了声明式编码风格。你描述你想要实现的目标，而不是如何实现它，这使得代码更易于阅读和维护。
- en: In the game effect example, we declaratively specify that we want to apply an
    effect to a unit. The specifics of how the effect is applied are abstracted within
    the `ApplyEffect` function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏效果示例中，我们声明性地指定我们想要对一个单位应用一个效果。效果如何应用的具体细节被封装在 `ApplyEffect` 函数中。
- en: In conclusion, higher-order functions in functional programming are invaluable.
    They enable code reuse, reduce errors, and support a declarative coding style,
    making them a powerful tool in any programmer’s toolkit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，函数式编程中的高阶函数非常有价值。它们使代码重用，减少错误，并支持声明式编码风格，使它们成为任何程序员工具箱中的强大工具。
- en: Delegates, actions, funcs, and predicates
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托、动作、funcs 和谓词
- en: Delegates are essentially type-safe function pointers, holding references to
    functions. This type of safety is crucial as it ensures that the function’s signature
    aligns with the delegate’s defined signature. Delegates enable methods to be passed
    as parameters, returned from functions, and stored in data structures, making
    them indispensable for event handling and other dynamic functionalities.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 委托本质上是一种类型安全的函数指针，持有函数的引用。这种安全性至关重要，因为它确保函数的签名与委托定义的签名相匹配。委托使方法可以作为参数传递、从函数返回并存储在数据结构中，对于事件处理和其他动态功能来说必不可少。
- en: Delegates
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Delegates
- en: Let’s apply the concept of delegates to a book publishing system. Imagine we
    need to notify different departments when a new book is published.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将委托的概念应用到图书出版系统中。想象一下，当一本新书出版时，我们需要通知不同的部门。
- en: 'First, define a delegate matching the notification function’s signature:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个与通知函数签名匹配的委托：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, create a class to manage book publishing that accepts a delegate in its
    method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个用于管理图书出版的类，其方法接受一个委托：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, any function that matches the delegate’s signature can be passed into
    `PublishBook` and will be called when a new book is published:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何与委托签名匹配的函数都可以传递到 `PublishBook` 中，并在新书出版时被调用：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, any function that matches the `BookPublishedNotification` delegate’s
    signature can be passed to `PublishBook` and will be invoked when a book is published.
    This demonstrates the flexibility and dynamism of delegates in a practical scenario.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，任何与 `BookPublishedNotification` 委托签名匹配的函数都可以传递给 `PublishBook`，并在书籍出版时被调用。这展示了委托在实际场景中的灵活性和动态性。
- en: Actions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Actions
- en: In functional programming, `Actions` are a type of delegate that does not return
    a value. They are ideal for executing methods that perform actions but do not
    need to return a result. This simplicity makes `Actions` a versatile tool in various
    programming scenarios.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，`Actions` 是一种不返回值的委托类型。它们非常适合执行执行动作但不需要返回结果的方法。这种简单性使 `Actions` 成为各种编程场景中的多功能工具。
- en: 'Consider a mobile tower defense game where certain events, such as spawning
    enemies and triggering effects, do not require a return value. We can use an `Action`
    delegate to handle these scenarios:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个移动塔防游戏，其中某些事件，如生成敌人和触发效果，不需要返回值。我们可以使用 `Action` 委托来处理这些场景：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, `OnEnemySpawned` is an `Action` delegate used to notify when
    an enemy is spawned. The simplicity of `Action` delegates allows for clean and
    clear event handling in the game’s logic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`OnEnemySpawned` 是一个用于在生成敌人时通知的 `Action` 委托。`Action` 委托的简单性允许在游戏逻辑中实现清晰的事件处理。
- en: Funcs
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Funcs
- en: '`Funcs`, another kind of built-in delegate, are used when a return value is
    needed. They can have between 0 and 16 input parameters, with the last parameter
    type always being the return type.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Funcs` 是另一种内置委托，当需要返回值时使用。它们可以有 0 到 16 个输入参数，最后一个参数的类型总是返回类型。'
- en: 'In the context of the same tower defense game, imagine we need a function to
    calculate the score based on various game parameters. This is where `Funcs` become
    useful:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一塔防游戏的上下文中，想象我们需要一个基于各种游戏参数计算分数的函数。这就是 `Funcs` 发挥作用的地方：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `CalculateScore` is a `Func` delegate, allowing for a flexible and customizable
    way to calculate the game’s score based on dynamic gameplay factors. `Funcs` provide
    a powerful way to define operations with return values, enhancing the flexibility
    and reusability of the code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CalculateScore` 是一个 `Func` 委托，允许根据动态游戏因素灵活和自定义地计算游戏的分数。`Funcs` 提供了一种强大的方式来定义具有返回值的操作，增强了代码的灵活性和可重用性。
- en: Predicates
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谓词
- en: '`Predicate<T>` is a delegate that represents a method containing a set of criteria
    and checks whether the passed parameter meets those criteria. A predicate delegate
    method must take one input parameter and return a `bool` value.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate<T>` 是一个代表包含一组标准并检查传递的参数是否满足这些标准的方法的委托。谓词委托方法必须接受一个输入参数并返回一个 `bool`
    值。'
- en: 'In a YouTube-like video management system, we might use `Predicate<Video>`
    to filter videos based on certain criteria:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类似YouTube的视频管理系统里，我们可能会使用`Predicate<Video>`来根据某些标准过滤视频：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, `GetVideosMatching` takes a `Predicate<Video>` delegate to
    filter videos. The method iterates through the list of videos and adds those meeting
    the criteria defined by the predicate to the result list. It could be written
    as a one-liner using `Where`, but using `yield return` makes it more expressive.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`GetVideosMatching`方法接受一个`Predicate<Video>`委托来过滤视频。该方法遍历视频列表，并将满足谓词定义的标准的视频添加到结果列表中。它可以用`Where`写成一个单行代码，但使用`yield
    return`使其更具表达性。
- en: 'So, summarizing all we’ve learned about delegates, actions, funcs, and predicates,
    we can see the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结我们关于委托、动作、函数和谓词所学的所有内容，我们可以看到以下：
- en: '**Delegates**: The foundational elements, allowing methods to be referenced
    and passed around, vital to creating higher-order functions'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：基础元素，允许方法被引用和传递，对于创建高阶函数至关重要'
- en: '**Actions**: Specialized delegates for methods that perform actions but don’t
    return values, simplifying task encapsulation'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：专门用于执行动作但不返回值的委托，简化了任务封装'
- en: '**Funcs**: Delegates that return a result, useful for computations and transformations'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：返回结果的委托，适用于计算和转换'
- en: '**Predicates**: A form of func always returning a Boolean, standardizing condition
    checks'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谓词**：一种总是返回布尔值的函数形式，标准化了条件检查'
- en: These constructs collectively can enhance our programming, enabling code reuse,
    higher abstraction, and a flexible, functional style.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构共同可以增强我们的编程，实现代码复用、更高的抽象层次以及灵活的函数式风格。
- en: Let’s continue with even more exciting constructs next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨更多令人兴奋的结构。
- en: Callbacks, events, and anonymous methods
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调、事件和匿名方法
- en: Callbacks are a pivotal concept in asynchronous and event-driven programming.
    They are essentially delegates that point to a method, allowing it to be called
    at a later time. This facilitates non-blocking code execution, crucial for responsive
    applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是异步和事件驱动编程中的一个关键概念。它们本质上是指向方法的委托，允许它在稍后时间被调用。这促进了非阻塞代码执行，对于响应式应用至关重要。
- en: 'Imagine a book publishing system where we need to perform actions such as sending
    notifications after a book is published. Here, a callback can notify other parts
    of the system once the publishing process is completed:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个图书出版系统，我们需要在图书出版后执行诸如发送通知等动作。在这里，回调可以在发布过程完成后通知系统的其他部分：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this scenario, the callback is invoked after a book is published, providing
    a flexible and decoupled way of handling post-publishing processes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，回调在图书出版后执行，提供了一种灵活且解耦的处理出版后流程的方式。
- en: The role of delegates in events
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托在事件中的作用
- en: Events, built on the publisher-subscriber model, are another powerful application
    of delegates. They allow objects to notify others about occurrences of interest.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 基于发布者-订阅者模型的事件，是委托的另一个强大应用。它们允许对象通知其他对象关于感兴趣事件的发生。
- en: 'The book publishing system can be further enhanced by using events, providing
    a more robust and flexible mechanism for notifications:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用事件，可以进一步增强图书出版系统，提供更健壮和灵活的通知机制：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this version, `OnBookPublished` is an event that subscribers can listen to.
    When a book is published, the event is raised, and all subscribed methods are
    invoked. This model enhances modularity and reduces coupling between the publishing
    logic and its subsequent actions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，`OnBookPublished`是一个订阅者可以监听的事件。当一本书出版时，事件被触发，所有订阅的方法都会被调用。这种模型增强了模块化，并减少了发布逻辑与其后续动作之间的耦合。
- en: Delegates and anonymous methods
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托和匿名方法
- en: Anonymous methods are methods that are not bound to a specific name. They are
    defined using the `delegate` keyword and can be used to create instances of a
    delegate. Anonymous methods provide a way to define methods in place where they
    are called, making your code more concise and readable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法是未绑定到特定名称的方法。它们使用`delegate`关键字定义，可以用来创建委托的实例。匿名方法提供了一种在方法被调用的地方定义方法的方式，使代码更加简洁易读。
- en: 'Let’s create a simple anonymous method that filters a list of video objects
    based on a specific criterion, such as videos that are longer than a certain duration.
    We’ll use an anonymous method with the `FindAll` method to accomplish this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的匿名方法，根据特定标准过滤视频对象列表，例如过滤出持续时间超过一定长度的视频。我们将使用匿名方法和`FindAll`方法来完成这个任务：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, `delegate(Video video) {...}` is an anonymous method used to
    define the criteria for the `FindAll` method, filtering videos based on their
    duration. This demonstrates how anonymous methods can be employed in practical
    scenarios such as filtering data in a video management system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`delegate(Video video) {...}`是一个匿名方法，用于定义`FindAll`方法的条件，根据视频的持续时间过滤视频。这展示了匿名方法如何在实际场景中应用，例如在视频管理系统中的数据过滤。
- en: By leveraging delegates to create callbacks, handle events, and define anonymous
    methods, we gain a powerful set of tools that allow us to write more flexible
    and maintainable code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用委托创建回调、处理事件和定义匿名方法，我们获得了一组强大的工具，使我们能够编写更灵活、可维护的代码。
- en: Harnessing LINQ methods as higher-order functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用LINQ方法作为高阶函数
- en: '**Language Integrated Query** (**LINQ**) in C# integrates query capabilities
    into the language, functioning primarily through extension methods. These methods,
    adhering to functional programming principles, allow for concise and expressive
    data manipulation. We’ll explore how LINQ can be effectively used in different
    systems for data filtering, transformation, and aggregation.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言集成查询**（**LINQ**）在C#中将查询功能集成到语言中，主要通过扩展方法来实现。这些方法遵循函数式编程原则，允许进行简洁且富有表现力的数据操作。我们将探讨LINQ如何在不同系统中有效地用于数据过滤、转换和聚合。'
- en: Filtering
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤
- en: 'In a video management system, we might need to filter videos based on their
    view count. Using the `Where` method, we can easily achieve this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频管理系统中，我们可能需要根据视频的观看次数进行过滤。使用`Where`方法可以轻松实现这一点：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Data transformation
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据转换
- en: 'In a publishing system, converting book titles to uppercase for a uniform catalog
    display can be done using the `Select` method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个发布系统中，为了实现统一目录显示，可以将书名转换为大写，可以使用`Select`方法来完成：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data aggregation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据聚合
- en: 'For a mobile tower defense game, calculating the average damage of all towers
    can be efficiently done using the `Average` method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动塔防游戏，使用`Average`方法可以有效地计算所有塔楼的平均伤害：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These examples showcase the power of LINQ as higher-order functions, demonstrating
    how they can be used to handle complex data operations in various real-world applications,
    making code more readable, maintainable, and enjoyable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了LINQ作为高阶函数的力量，展示了它们如何在各种实际应用中处理复杂的数据操作，使代码更易读、可维护和有趣。
- en: Case study – putting it all together
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究——综合运用所有技术
- en: 'Here, we’ll bring together all the elements we’ve discussed so far: higher-order
    functions, delegates, actions, funcs, predicates, and LINQ methods. We’ll provide
    a comprehensive, real-world example and analyze the code, step by step.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将汇集到目前为止所讨论的所有元素：高阶函数、委托、操作、funcs、断言和LINQ方法。我们将提供一个全面、真实的示例，并逐步分析代码。
- en: Imagine we are developing a mobile tower defense game. This game involves managing
    towers, handling enemy waves, and upgrading tower capabilities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在开发一个移动塔防游戏。这个游戏涉及管理塔楼、处理敌军波次以及升级塔楼的能力。
- en: 'Here’s an outline of the classes we’ll use:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要使用的类的一个概述：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Tower` class here represents the basic building block of the game – the
    towers. Each tower has a type, a damage level, and a status indicating whether
    it has been upgraded. This class is a cornerstone for the game’s mechanics, as
    different towers might have various effects and strategies associated with them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Tower`类代表了游戏的基本构建块——塔楼。每个塔楼都有一个类型、一个伤害等级和一个状态，表示它是否已被升级。这个类是游戏机制的基础，因为不同的塔楼可能会有各种效果和与之相关的策略。
- en: 'The `Game` class acts as a central hub for managing the game’s logic. It contains
    a list of all towers in the game. The class demonstrates advanced functional programming
    techniques:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`类作为管理游戏逻辑的中心枢纽。它包含游戏中所有塔楼的列表。该类展示了高级函数式编程技术：'
- en: The `FilterTowers` method is a quintessential example of using higher-order
    functions in a real-world application. By accepting a `Func<Tower, bool>` as a
    predicate, it provides a flexible way to filter towers based on dynamic criteria,
    such as damage level, range, or upgrade status. This method makes use of LINQ,
    showcasing its power in simplifying data manipulation tasks.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FilterTowers` 方法是使用高阶函数在实际应用中的典范示例。通过接受一个 `Func<Tower, bool>` 作为谓词，它提供了一种灵活的方式来根据动态标准（如伤害等级、射程或升级状态）过滤塔。此方法利用了
    LINQ，展示了它在简化数据操作任务方面的强大功能。'
- en: The `TowerUpgraded` event, coupled with the `UpgradeTower` method, demonstrates
    the use of actions and delegates. This event-driven approach allows for reactive
    programming, where different parts of the game can respond to changes in tower
    states, such as triggering animations, sounds, or game logic updates when a tower
    is upgraded.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TowerUpgraded` 事件与 `UpgradeTower` 方法的结合展示了动作和委托的使用。这种事件驱动的方法允许进行响应式编程，其中游戏的不同部分可以响应塔状态的变化，例如在塔升级时触发动画、声音或游戏逻辑更新。'
- en: Step-by-step walk-through and analysis of the code
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码的逐步分析和分析
- en: 'Now, let’s add some logic to our methods and write the code that uses them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给我们的方法添加一些逻辑，并编写使用它们的代码：
- en: '`FilterTowers` method uses a predicate (a `Func` that returns a `bool`) to
    select towers based on specific criteria, illustrating higher-order functions
    and LINQ:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FilterTowers` 方法使用谓词（返回 `bool` 的 `Func`）根据特定标准选择塔，展示了高阶函数和 LINQ：'
- en: '[PRE16]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach allows for dynamic tower filtering, adapting to various game scenarios
    and player strategies.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法允许进行动态塔过滤，适应各种游戏场景和玩家策略。
- en: '`TowerUpgraded` event demonstrates how delegates facilitate event handling
    in the game:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TowerUpgraded` 事件展示了委托如何促进游戏中的事件处理：'
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This mechanism is crucial for notifying different parts of the game about tower
    upgrades and maintaining game state consistency.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此机制对于通知游戏的不同部分关于塔升级并保持游戏状态一致性至关重要。
- en: '**Interacting with the game**: Finally, let’s see how a user might interact
    with the library:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与游戏交互**：最后，让我们看看用户如何与库交互：'
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this snippet, we see the practical application of the game’s functional programming
    features. From filtering towers based on damage to handling tower upgrades, the
    code is concise, expressive, and effective.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个片段中，我们可以看到游戏函数式编程特性的实际应用。从根据伤害过滤塔到处理塔升级，代码简洁、易于表达且有效。
- en: This case study demonstrates the use of predicates, events, delegates, and higher-order
    functions in a practical scenario. It showcases how functional programming principles
    can enhance the development and operation of a complex mobile game, leading to
    more efficient, expressive, and powerful programming. The integration of these
    concepts provides a solid foundation for building engaging and robust game mechanics.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本案例研究展示了在实际情况中使用谓词、事件、委托和高阶函数。它展示了函数式编程原则如何增强复杂移动游戏的开发和运营，从而实现更高效、更易于表达和更强大的编程。这些概念的集成为构建引人入胜且稳健的游戏机制提供了坚实的基础。
- en: Best practices and common pitfalls
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践和常见陷阱
- en: This section takes a closer look at best practices when working with higher-order
    functions, delegates, actions, funcs, predicates, and LINQ. We’ll also discuss
    common mistakes that developers make and offer solutions on how to avoid these
    pitfalls.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将深入探讨使用高阶函数、委托、动作、funcs、谓词和 LINQ 的最佳实践。我们还将讨论开发者常犯的错误，并提供避免这些陷阱的解决方案。
- en: 'Here are some best practices to use while working with higher-order functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用高阶函数工作时，以下是一些最佳实践：
- en: '**Aim for stateless functions**: For consistency and predictability, strive
    to ensure that the functions you pass as arguments are stateless, meaning they
    don’t rely on or change the state of anything outside themselves. This makes them
    more predictable and less prone to side effects.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追求无状态函数**：为了保持一致性和可预测性，努力确保您作为参数传递的函数是无状态的，这意味着它们不依赖于或改变自身之外的状态。这使得它们更具可预测性，并减少了副作用的可能性。'
- en: '**Embrace immutability**: One of the core principles of functional programming
    is immutability. When passing objects to your higher-order functions, consider
    whether they can be made immutable to ensure that the function doesn’t alter their
    state.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥抱不可变性**：函数式编程的核心原则之一是不可变性。在将对象传递给高阶函数时，考虑它们是否可以变为不可变，以确保函数不会改变它们的状态。'
- en: '**Use descriptive names**: As you are passing around functions, it’s easy to
    lose track of what each one does. Therefore, use descriptive names for your functions
    and parameters to improve readability.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用描述性名称**：在传递函数时，很容易失去对每个函数所做事情的跟踪。因此，为你的函数和参数使用描述性名称以提高可读性。'
- en: 'Some of the common pitfalls are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的陷阱如下：
- en: '`OrderBy`, `Reverse`, and `Count`, may be costly. Always measure the performance
    of your queries and consider alternative approaches if necessary.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderBy`、`Reverse` 和 `Count` 可能会耗费较多资源。始终测量查询的性能，并在必要时考虑替代方法。'
- en: '**Ignoring type safety with delegates**: While delegates are powerful, they
    can also bypass type safety if not used with care. Always ensure the delegate
    signature matches the method it points to avoid runtime errors.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略委托的类型安全**：虽然委托功能强大，但如果不小心使用，它们也可能绕过类型安全。始终确保委托签名与方法指向的方法相匹配，以避免运行时错误。'
- en: '`NullReferenceException`:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullReferenceException`：'
- en: '[PRE19]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Misuse of anonymous functions**: Anonymous functions can lead to cleaner
    code, but they can also hide complexity and make code harder to test. If an anonymous
    function is more than a few lines long, or if it’s complex enough to require testing
    on its own, it should probably be a named function instead.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名函数的误用**：匿名函数可以使代码更简洁，但它们也可能隐藏复杂性并使代码更难测试。如果一个匿名函数超过几行长，或者足够复杂以至于需要单独测试，那么它可能应该是一个命名函数。'
- en: By following these best practices and avoiding common mistakes, you can write
    clean, efficient, and maintainable code, harnessing the power of functional programming
    constructs to the fullest.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践并避免常见错误，你可以编写干净、高效且易于维护的代码，充分利用函数式编程构造的强大功能。
- en: Exercises
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The theory and concepts are only half the learning journey. Now, it’s time to
    get your hands dirty with some practical exercises. This chapter provides a series
    of challenging problems to test your understanding of the concepts learned and
    to reinforce them. Following each problem, you’ll find a proposed solution with
    detailed explanations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 理论和概念只是学习旅程的一半。现在，是时候通过一些实际练习来亲自动手了。本章提供了一系列具有挑战性的问题，以测试你对所学概念的理解，并加强它们。在每个问题之后，你将找到一个建议的解决方案，以及详细的解释。
- en: Exercise 1
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: Write a program that uses a higher-order function to sort a list of towers in
    Steve’s game based on their damage output. The sorting function should be passed
    as a delegate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，使用高阶函数根据 Steve 游戏中塔的伤害输出对塔列表进行排序。排序函数应作为委托传递。
- en: Exercise 2
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: Create a method that takes an `Action` and a list of enemies. The `Action` should
    perform a calculation on each enemy’s health and print the result. Test your method
    using several different `Action`s, such as calculating damage taken from different
    tower types.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个方法，该方法接受一个 `Action` 和一个敌人列表。`Action` 应对每个敌人的生命值执行计算并打印结果。使用几个不同的 `Action`
    测试你的方法，例如计算来自不同塔类型的伤害。
- en: Exercise 3
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: Implement a method that uses a `Func` delegate to compare two towers based on
    their range. The method should return the tower with the longer range.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个使用 `Func` 委托根据射程比较两个塔的方法。该方法应返回射程更长的塔。
- en: Solutions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解答
- en: Exercise 1
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Steve implemented a sorting function for towers using a delegate:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Steve 使用委托实现了对塔的排序函数：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This solution creates a `CompareTowers` delegate that takes two `Tower` objects
    and returns an `int`. The `SortTowers` method then uses this delegate to sort
    the list of towers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案创建了一个 `CompareTowers` 委托，它接受两个 `Tower` 对象并返回一个 `int`。然后 `SortTowers` 方法使用此委托对塔列表进行排序。
- en: Exercise 2
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'For enemy health calculations, Steve created this method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于敌人生命值的计算，Steve 创建了以下方法：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This solution iterates over a list of enemies and applies the passed action
    to each.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此解答遍历敌人列表，并对每个敌人应用传入的操作。
- en: Exercise 3
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'Here’s a solution to the third problem:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第三个问题的解决方案：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This solution uses a `Func` delegate to compare the ranges of two towers and
    returns the longer-range one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此解答使用一个 `Func` 委托来比较两个塔的射程，并返回射程更长的那个。
- en: Remember, while these solutions work, there may be other equally valid approaches.
    These exercises are about reinforcing the concepts learned and exploring different
    ways to apply them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虽然这些解决方案有效，但可能还有其他同样有效的方案。这些练习的目的是加强所学概念，并探索不同的应用方式。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'As we conclude this chapter on higher-order functions and delegates in the
    context of functional programming in C#, let’s pause to reflect on the key concepts
    we’ve delved into and anticipate what’s next on our journey:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结本章关于 C# 函数式编程中的高阶函数和委托时，让我们停下来反思我们深入探讨的关键概念，并预测我们旅程的下一步：
- en: '**Higher-order functions**: These functions, capable of receiving other functions
    as parameters or returning them, are foundational in promoting code reusability,
    abstraction, and a more declarative coding style. Their versatility enhances the
    expressiveness of our code, allowing us to write more with less.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高阶函数**：这些函数能够接收其他函数作为参数或返回它们，是促进代码重用、抽象和更声明式编程风格的基础。它们的通用性增强了代码的表达力，使我们能够用更少的代码完成更多的工作。'
- en: '**Delegates, actions, funcs, and predicates**: Our exploration of these pivotal
    functional programming constructs revealed their unique roles and differences.
    We saw how they contribute to crafting versatile and reliable code, each playing
    a specific part in the broader functional paradigm.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托、动作、funcs 和谓词**：我们对这些关键函数式编程结构的探索揭示了它们的独特角色和区别。我们看到了它们如何有助于构建灵活且可靠的代码，每个都在更广泛的函数式范式扮演着特定的角色。'
- en: '**Delegates for callbacks, events, and anonymous methods**: Delegates are the
    backbone of creating callbacks, managing events, and defining anonymous methods.
    They enable flexible, event-driven programming structures, crucial for responsive
    and interactive applications.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托用于回调、事件和匿名方法**：委托是创建回调、管理事件和定义匿名方法的基础。它们使灵活的事件驱动编程结构成为可能，这对于响应性和交互式应用程序至关重要。'
- en: '**LINQ as higher-order functions**: We uncovered the immense power of the LINQ
    library in processing data collections. The emphasis was on how LINQ methods exemplify
    higher-order functions, offering elegant solutions for complex data manipulation
    and querying.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ 作为高阶函数**：我们发现了 LINQ 库在处理数据集合方面的巨大力量。重点在于 LINQ 方法如何体现高阶函数，为复杂的数据操作和查询提供优雅的解决方案。'
- en: '**Best practices and pitfalls**: We rounded off with vital best practices for
    employing these concepts effectively and avoiding common mistakes. These insights
    are crucial for writing clean, efficient, and maintainable code.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践和陷阱**：我们以这些概念的有效应用和避免常见错误的关键最佳实践作为总结。这些见解对于编写干净、高效和可维护的代码至关重要。'
- en: In essence, this chapter has illuminated how the principles of functional programming
    can be effectively harnessed in C#. We’ve seen that by embracing these concepts,
    developers can achieve greater readability, maintainability, and robustness in
    their code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这一章阐明了函数式编程的原则如何在 C# 中有效利用。我们看到，通过拥抱这些概念，开发者可以在他们的代码中实现更高的可读性、可维护性和健壮性。
- en: As we turn the page to the next chapter, our journey into the depths of functional
    programming continues. We will delve into the intriguing world of functors and
    monads. These advanced concepts will unlock new levels of abstraction and composability
    for you. Stay tuned; it will be interesting!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们翻到下一章时，我们探索函数式编程深度的旅程仍在继续。我们将深入探究函数式和单子的迷人世界。这些高级概念将为您解锁新的抽象和组合层次。敬请期待；这将非常有趣！
