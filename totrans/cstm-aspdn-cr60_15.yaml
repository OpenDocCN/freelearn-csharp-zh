- en: '*Chapter 15*: Working with Caches'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：使用缓存'
- en: In this chapter we will have a look into cache techniques. ASP.NET Core provides
    multiple ways to cache and we will learn to use and to customize them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨缓存技术。ASP.NET Core提供了多种缓存方式，我们将学习如何使用和自定义它们。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The need for caching
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存的必要性
- en: HTTP-based caching
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于HTTP的缓存
- en: Caching using ResponseCachingMiddleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ResponseCachingMiddleware进行缓存
- en: Predefining caching strategies using cache profiles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存配置文件预定义缓存策略
- en: Caching specific areas using CacheTagHelper
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CacheTagHelper缓存特定区域
- en: Caching Manually
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动缓存
- en: 'The topics in this chapter refer to the MVC layer of the ASP.NET Core architecture:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的主题涉及ASP.NET Core架构的MVC层：
- en: '![Figure 15.1 – ASP.NET Core architecture](img/Figure_15.1_B17996.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – ASP.NET Core架构](img/Figure_15.1_B17996.jpg)'
- en: Figure 15.1 – ASP.NET Core architecture
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – ASP.NET Core架构
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the descriptions in this chapter, you will need to create an ASP.NET
    Core MVC application. Open your console, shell, or Bash terminal, and change to
    your working directory. Use the following command to create a new MVC application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的描述，你需要创建一个ASP.NET Core MVC应用程序。打开你的控制台、shell或Bash终端，切换到你的工作目录。使用以下命令创建一个新的MVC应用程序：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, open the project in Visual Studio by double-clicking the project file
    or, in VS Code, by typing the following command in the already open console:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过双击项目文件或在VS Code中输入以下命令来在Visual Studio中打开项目：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All of the code samples in this chapter can be found in the GitHub repository
    for this book at [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter15).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的GitHub仓库[https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter15)中找到。
- en: Why do we need caching?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要缓存？
- en: Caching speeds up performance, by storing the results in memory or in a distributed
    cache like a fast Redis database, you can also store cached data in files if it
    makes sense.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存通过在内存或像快速Redis数据库这样的分布式缓存中存储结果来加速性能，如果合理的话，你还可以将缓存数据存储在文件中。
- en: A distributed cache is needed in case you run multiple instances of an application
    to scale for availability of your application. The instances will run on multiple
    Docker containers, in a Kubernetes cluster or just on more than one Azure App
    Services. In that case, the instances should share a cache.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行多个应用程序实例以扩展应用程序的可用性时，需要分布式缓存。这些实例将在多个Docker容器、Kubernetes集群或多个Azure App Services上运行。在这种情况下，实例应该共享缓存。
- en: Most application caches are in-memory caches that store data for a short period
    of time. This is good for most scenarios.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序缓存都是内存缓存，存储数据的时间较短。这对于大多数场景来说都是好的。
- en: Also, browser do cache the websites or the web applications output. The browsers
    usually store the entire result in files. As an ASP.NET developer you can control
    the browsers cache by adding HTTP headers that specify whether the browser should
    cache or not and that specify how long the cached item should be valid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，浏览器也会缓存网站或Web应用程序的输出。浏览器通常将整个结果存储在文件中。作为一名ASP.NET开发者，你可以通过添加指定浏览器是否应该缓存以及缓存项应该有效多长时间的HTTP头来自定义浏览器缓存。
- en: A browser cache reduces the number of requests to the server. A cache handling
    in your code might reduce the number of database access or reduce the access to
    another time-consuming action.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器缓存可以减少对服务器的请求次数。在你的代码中处理缓存可以减少数据库访问次数或减少对其他耗时操作的访问。
- en: Both client-side caches and server side caches are useful to increase the performance
    of your application. Let's have a detailed look at the client side cache.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端缓存和服务器端缓存都对提高应用程序性能很有用。让我们详细了解一下客户端缓存。
- en: HTTP-based caching
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于HTTP的缓存
- en: 'To control the browsers cache you can set a `Cache-Control` HTTP header. Usually,
    the `StaticFileMiddleware` doesn''t set a Cache-Control header. This means the
    clients are free to cache how they prefer. If you like to limit the cache time
    to just one day, you can do this by passing `StaticFileOptions` to the middleware:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制浏览器缓存，你可以设置一个`Cache-Control` HTTP头。通常，`StaticFileMiddleware`不会设置Cache-Control头。这意味着客户端可以自由地按照他们喜欢的任何方式缓存。如果你希望将缓存时间限制为仅一天，你可以通过将`StaticFileOptions`传递给中间件来实现这一点：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sets the `Cache-Control` header to every static file that is requested
    before it gets sent to the client. The `Cache-Control` is set to public, which
    means it can be publicly cached on every client. The maximum age of the cache
    items should not be older than 86,400 seconds, which is one day.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `Cache-Control` 头部设置为在发送到客户端之前请求的每个静态文件。`Cache-Control` 被设置为公共，这意味着它可以在每个客户端上公开缓存。缓存项的最大年龄不应超过
    86,400 秒，即一天。
- en: Setting the headers to the static file is just an example. You can set the header
    to every response that needs cache control. You can also disable the cache by
    setting the Cache-Control header to no-cache.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将头部设置为静态文件只是一个示例。您可以将头部设置为需要缓存控制的每个响应。您还可以通过将 `Cache-Control` 头部设置为 no-cache
    来禁用缓存。
- en: 'To learn more about the `Cache-Control` header, see the following URL: https://datatracker.ietf.org/doc/html/rfc7234#section-5.2'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `Cache-Control` 头部的信息，请参阅以下 URL：https://datatracker.ietf.org/doc/html/rfc7234#section-5.2
- en: Also, the `Expires` header might be useful, to specify when the responded content
    get invalid and should get renewed from the server. See https://datatracker.ietf.org/doc/html/rfc7234#section-5.3
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Expires` 头部可能也很有用，用于指定响应内容何时失效并应从服务器刷新。请参阅 https://datatracker.ietf.org/doc/html/rfc7234#section-5.3
- en: The `Vary` header specifies a criteria that tells the clients about cache variations.
    It checks for specific headers to be available. See https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.4
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vary` 头部指定了一个标准，告诉客户端关于缓存变化的信息。它检查特定头部是否存在。请参阅 https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.4'
- en: This controls the clients directly via the response object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过响应对象直接控制客户端。
- en: Caching using ResponseCachingMiddleware
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `ResponseCachingMiddleware` 进行缓存
- en: The `ResponseCachingMiddleware` caches the responses on the server side and
    creates responses based on the cached responses. The middleware respects the `Cache-Control`
    header in the same way as clients do. That means you are able to control the middleware
    by setting the specific headers as described in the previews section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseCachingMiddleware` 在服务器端缓存响应并基于缓存的响应创建响应。该中间件像客户端一样尊重 `Cache-Control`
    头部。这意味着您可以通过设置预览部分中描述的特定头部来控制中间件。'
- en: 'To get it working you need to add the `ResponseCachingMiddleware` to the Dependency
    Injection container:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其工作，您需要将 `ResponseCachingMiddleware` 添加到依赖注入容器中：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And you should use that middleware to the pipeline after the static files and
    routing got added:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 并且您应该在静态文件和路由添加之后使用该中间件：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you added a CORS configuration, the `UseCors` method should be called before,
    as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您添加了 CORS 配置，则应先调用 `UseCors` 方法。
- en: The `ResponseCachingMiddleware` gets affected by specific HTTP headers. For
    example, if the `Authentication` header is set the response doesn't get cached,
    same with the `Set-Cookie` header. It also only caches responses that result in
    a 200 OK result. Error pages and other status codes don't get cached.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseCachingMiddleware` 受特定 HTTP 头部的影响。例如，如果设置了 `Authentication` 头部，则响应不会缓存，与
    `Set-Cookie` 头部相同。它也仅缓存导致 200 OK 结果的响应。错误页面和其他状态代码不会缓存。'
- en: 'You can find the full list of criteria at this URL: https://docs.microsoft.com/en-us/aspnet/core/performance/caching/middleware?view=aspnetcore-6.0#http-headers-used-by-response-caching-middleware.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下 URL 中找到完整的标准列表：https://docs.microsoft.com/en-us/aspnet/core/performance/caching/middleware?view=aspnetcore-6.0#http-headers-used-by-response-caching-middleware。
- en: 'Using the `ResponseCacheAttribute` on controller level, actions level or pages
    level you can set the right headers to control the `ResponseCachingMiddleware`
    by using `ResponseCacheAttribute`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器级别、操作级别或页面级别使用 `ResponseCacheAttribute`，您可以通过使用 `ResponseCacheAttribute`
    设置正确的头部来控制 `ResponseCachingMiddleware`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This snippet sets the `Cache-Control` to public with max-age to one day, like
    the sample in the previews section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将 `Cache-Control` 设置为公共，最大年龄为一天，就像预览部分中的示例一样。
- en: This attribute is pretty powerful, you can also set Vary headers in different
    ways, as well as the indicator to not cache the output at all. Even a `CacheProfileName`
    can be set. We are going to have a look at cache profiles in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性非常强大，您还可以以不同的方式设置 `Vary` 头部，以及指示完全不缓存输出的指示器。甚至可以设置 `CacheProfileName`。我们将在下一节中查看缓存配置文件。
- en: 'These are properties you can set:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可以设置的属性：
- en: '`Duration`: Time range in seconds'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duration`：秒数时间范围'
- en: '`Location`: The location where to store the cache: Client, Any, or none'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Location`：存储缓存的地点：客户端、任何或无'
- en: '`NoStore`: Disables the cache if it is set to true'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoStore`：如果设置为 true，则禁用缓存'
- en: '`VaryByHeader`: A header value that varies the cache'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VaryByHeader`：一个改变缓存的头值'
- en: '`VaryByQueryKeys`: An array of query key names that varies the cache'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VaryByQueryKeys`：一个查询键名称数组，它改变了缓存'
- en: Predefining caching strategies using cache profiles
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存配置文件预定义缓存策略
- en: You can predefine caching strategies in a so-called cache profile to reuse them
    wherever you need. The `CacheProfile` type has the same properties as the `ResponseCache`
    attribute. To define cache profiles, you need to set options to the MVC services.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在所谓的缓存配置文件中预定义缓存策略，以便在需要的地方重复使用。`CacheProfile` 类型具有与 `ResponseCache` 属性相同的属性。要定义缓存配置文件，你需要将选项设置到
    MVC 服务中。
- en: 'In `Program.cs`, the `AddControllersWithViews method` has an overload to configure
    the `MvcOptions`. Here, you can also add cache profiles:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，`AddControllersWithViews` 方法有一个重载，可以配置 `MvcOptions`。在这里，你还可以添加缓存配置文件：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You might need to add a `using` statement to `Microsoft.AspNetCore.Mvc`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要添加一个 `using` 语句到 `Microsoft.AspNetCore.Mvc`。
- en: This snippet adds two different cache profiles, the first one with a 30 second
    cache and the second one with a 60 second cache. Both profiles tell the cache
    to vary by the `"User-Agent"` header.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段添加了两个不同的缓存配置文件，第一个配置文件有 30 秒的缓存时间，第二个配置文件有 60 秒的缓存时间。这两个配置文件都告诉缓存根据 `"User-Agent"`
    头来变化。
- en: 'To use a profile, you can use the profile name in the response caching attribute:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用配置文件，你可以在响应缓存属性中使用配置文件名称：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instead of setting all the properties of `ResponseCacheAttribute`, you can just
    set `CacheProfileName`. Let's see how to use caches the declarative way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必设置 `ResponseCacheAttribute` 的所有属性，只需设置 `CacheProfileName`。让我们看看如何使用声明性方式使用缓存。
- en: Caching specific areas using CacheTagHelper
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CacheTagHelper 缓存特定区域
- en: You can also cache specific areas of the view. In a scenario where you are not
    able to cache an entire view, you would be able to just cache a specific area
    by surrounding it with the `CacheTagHelper`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以缓存视图的特定区域。在一个无法缓存整个视图的场景中，你可以通过使用 `CacheTagHelper` 来只缓存特定的区域。
- en: 'To test that, add the following snippet to the `index.cshtml`, that you can
    find in the `/Views/Home/` folder:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，将以下片段添加到 `index.cshtml` 文件中，该文件位于 `/Views/Home/` 文件夹中：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This snippet contains two identical p-tags that write out the current time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段包含两个相同的 p 标签，用于输出当前时间。
- en: The second one is wrapped in a `CacheTagHelper` that has a sliding expiration
    of 7 seconds defined.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个被包裹在一个具有 7 秒滑动过期时间的 `CacheTagHelper` 中。
- en: Start the application and see what happens. Navigate to the `Index` page and
    refresh the browser several times. You will see that only the first time will
    change while refreshing the page. The second one is cached and stays the same
    for 7 seconds.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并查看发生了什么。导航到 `Index` 页面并多次刷新浏览器。你将看到只有第一次刷新时内容会改变，第二个是缓存的，在 7 秒内保持不变。
- en: '![Figure 15.2 - Cached and uncached values ](img/Figure_15.2_B17996.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.2 - 缓存和未缓存值](img/Figure_15.2_B17996.jpg)'
- en: Figure 15.2 - Cached and uncached values
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 - 缓存和未缓存值
- en: Let's look at what we should do if we need to cache more specifically
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们需要更具体地缓存应该做什么
- en: Caching Manually
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动缓存
- en: Sometimes it makes sense to cache specifically inside the C# code. For example,
    if you need to fetch data from an external source or database, it would save time
    and traffic if you cache the results and don't access the result every time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在 C# 代码内部进行特定缓存是有意义的。例如，如果你需要从外部源或数据库获取数据，缓存结果并每次不访问结果可以节省时间和流量。
- en: 'Let''s try it out by using two different ways to use create and access cache
    items:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用两种不同的方式来创建和访问缓存项来试一试：
- en: 'To try it out we will extend the `HomeController` a little bit. Start by injecting
    an instance of the `IMemoryCache` to the controller and store it in a field:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了试一试，我们将稍微扩展一下 `HomeController`。首先，将 `IMemoryCache` 的一个实例注入到控制器中，并将其存储在一个字段中：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `Models` folder, create a file called `Person.cs` and place the following
    lines in it:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中，创建一个名为 `Person.cs` 的文件，并在其中放置以下行：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we need to add two super complex methods that do some magic for us. Actually,
    these methods just create fake data and aren''t really complex:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加两个非常复杂的方法，这些方法为我们做一些神奇的事情。实际上，这些方法只是创建一些假数据，并不真正复杂：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first method uses `GenFu` that is also used in previous chapters to create
    a list of `Person` and fill them with random but valid data. The second method
    creates a `Dictionary` of 10 items that also contains random data. The random
    data make sense to show that the data are actually cached. If the data don't change
    on the user interface, the data came out of the cache.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一种方法使用`GenFu`，这在之前的章节中也已使用，用于创建`Person`列表并填充随机但有效的数据。第二种方法创建了一个包含随机数据的10项`Dictionary`。随机数据有助于展示数据实际上已被缓存。如果用户界面上的数据没有变化，那么数据是从缓存中获取的。
- en: 'Type the following command in the project folder to install `GenFu`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中输入以下命令以安装`GenFu`：
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following lines at the beginning of the index action to store the data
    of the first method in the cache or to load the data out of the cache:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在索引操作的开始处添加以下行，将第一种方法的数据存储在缓存中或从缓存中加载数据：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will at first try to load the data out of the cache by using the `ExternalSource`
    cache key. If the cached data doesn't exist, you need to load them from the original
    source and store them in the cache using the `Set` method.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将首先尝试使用`ExternalSource`缓存键从缓存中加载数据。如果缓存中的数据不存在，你需要从原始源加载数据，并使用`Set`方法将它们存储在缓存中。
- en: 'The other way to create and load cached data is to use the `GetOrCreate` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和加载数据的另一种方式是使用`GetOrCreate`方法：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It works the same way but is pretty much simpler to use. The value that needs
    to be cached will be returned in the lambda expression directly while the lambda
    retrieves the cache entry that can be configured.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式相同，但使用起来相当简单。需要缓存的值将直接在lambda表达式中返回，同时lambda表达式检索可以配置的缓存条目。
- en: 'Once the data are there you can return them to the view:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据存在，你就可以将它们返回到视图中：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The model that gets returned looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的模型看起来像这样：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the next snippet to `Index.cshtml` right after `CacheTagHelper` to visualize
    the data:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下片段添加到`Index.cshtml`文件中，紧接在`CacheTagHelper`之后，以可视化数据：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This creates two lists in two side-by-side columns. Now run the application,
    call it in the browser, and try to refresh the page. The displayed data shouldn''t
    change even though the data are completely random. Without the cache, the data
    would change on every reload:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这在两个并排的列中创建了两个列表。现在运行应用程序，在浏览器中调用它，并尝试刷新页面。即使数据完全随机，显示的数据也不应该改变。如果没有缓存，每次重新加载时数据都会改变：
- en: '![Figure 5.3 - Changing data'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - 数据变化'
- en: '](img/Figure_15.3_B17996.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.3_B17996.jpg)'
- en: Figure 5.3 - Changing data
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 数据变化
- en: That's it. The cache expires every 30 seconds as configured.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。缓存每30秒过期，如配置所示。
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Caches help us to create high performance applications by reducing the calls
    to resources that are less performant, such as databases, external APIs, or complex
    calculations. In this chapter, you learned to use the response cache using the
    `ResponseCachingMiddleware` and the `ResponseCacheAttribute`, and the in-memory
    cache by using the `CacheTagHelper` as well as by using the `IMemoryCache` manually
    in the C# code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存帮助我们通过减少对性能较差的资源（如数据库、外部API或复杂计算）的调用，来创建高性能的应用程序。在本章中，你学习了如何使用`ResponseCachingMiddleware`和`ResponseCacheAttribute`来使用响应缓存，以及如何使用`CacheTagHelper`和手动在C#代码中使用`IMemoryCache`来使用内存缓存。
- en: In the next chapter, you will learn how to create custom `TagHelper`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何创建自定义`TagHelper`。
- en: Further reading
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'More about caching in the ASP.NET Core docs: [https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-6.0).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于ASP.NET Core文档中的缓存信息：[https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-6.0)。
