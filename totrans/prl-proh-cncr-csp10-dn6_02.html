<html><head></head><body>
<div><div><h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Managed Threading Concepts</h1>
<p><code>async</code> and <code>await</code> keywords in C#. This book will cover all of these concepts in the chapters ahead.</p>
<p>In this chapter, we will start with the basics of how to work with <strong class="bold">managed threading</strong> in .NET. You will learn how to create and destroy threads, handle exceptions, synchronize data, and utilize the objects provided by .NET to handle background operations. Additionally, you will gain a basic understanding of how threads can be managed in a .NET application. The practical examples in this chapter will illustrate how to leverage managed threading in C# projects.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>.NET threading basics</li>
<li>Creating and destroying threads</li>
<li>Handling threading exceptions</li>
<li>Synchronizing data across threads</li>
<li>Scheduling and canceling work</li>
</ul>
<p>By starting with the core concepts of threading in .NET, you will gain a solid foundation as you move forward with your learning throughout this book. It is important to understand the basics to prevent common mistakes from being made while introducing threading and asynchrony to .NET applications. It is all too easy to exhaust resources or put the application’s data in an invalid state. Let’s get started with managed threading with C#.</p>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later</li>
<li>.NET 6</li>
</ul>
<p>While these are recommended, as long as you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter01</a>. </p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>.NET threading basics</h1>
<p>It’s time to <a id="_idIndexMarker000"/>get started by learning about the basics of threading in C# and .NET. We will be covering the managed threading concepts that are available in .NET 6, but many of these features have been part of .NET since the beginning. The <code>System.Threading</code> namespace has been available since .NET Framework 1.0. In the subsequent 20 years, there have been many useful features added for developers.</p>
<p>In order to responsibly use threading in your applications, you should understand exactly what a <strong class="bold">thread</strong> is and how threads are used by your application’s <strong class="bold">processes</strong>.</p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Threads and processes</h2>
<p>We<a id="_idIndexMarker001"/> will <a id="_idIndexMarker002"/>start<a id="_idIndexMarker003"/> our journey <a id="_idIndexMarker004"/>with the basic units of application processing, threads, and processes. A process encapsulates all the execution of an application. This is true for all platforms and frameworks. In .NET, you can think of a process as your <code>.exe</code> or hosted service.</p>
<p class="callout-heading">Note</p>
<p class="callout">In .NET Framework, the concept <a id="_idIndexMarker005"/>of <strong class="bold">application domains</strong> (or app domains), which create isolation units within a process, was introduced. These app domains provide security and reliability by isolating the execution of code loaded into a new app domain. App domains still exist but are not available for developers to create or unload in .NET Core and modern versions of .NET. To read more about app domains, check out this Microsoft Docs article at <a href="">https://docs.microsoft.com/dotnet/framework/app-domains/application-domains</a>.</p>
<p>A <strong class="bold">thread</strong> represents a single unit of execution within a process. By default, a .NET application will execute all its logic on a single thread (that is, the primary or main thread). Developers can leverage managed threads and other .NET constructs to move from a single-threaded<a id="_idIndexMarker006"/> to a multithreaded world, but how do you know <a id="_idIndexMarker007"/>when<a id="_idIndexMarker008"/> to <a id="_idIndexMarker009"/>take this step?</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>When should we use multithreading in .NET?</h2>
<p>There are <a id="_idIndexMarker010"/>multiple factors to consider when deciding whether to introduce threading to an application. These factors are both internal and external to the application. The external factors include the hardware in terms of where the application will be deployed, how powerful the processors are where the application will be running, and what other types of processes will be running on these systems? </p>
<p>If your application will be competing for limited resources, it is best to be judicious with the use of multiple threads. If users get the impression that your application is impacting the performance of their systems, you will need to scale back on the number of threads being consumed by your process. Another factor that comes into play is how critical your application is in relation to others on the system. Mission-critical applications will have more resources allocated to remain responsive when needed.</p>
<p>Other common reasons for introducing threading relate to the application itself. Desktop and mobile applications need to <a id="_idIndexMarker011"/>keep the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) responsive to user input. If the application needs to process a large amount of data or load it from a database, file, or network resource, executing on the main thread can cause the UI to freeze or lag. Also, executing long-running tasks in parallel on multiple threads can reduce the overall execution time of the task.</p>
<p>These operations can be<a id="_idIndexMarker012"/> offloaded to <strong class="bold">background threads</strong> if the execution of the tasks is not critical to the application state. Let’s look at the difference between foreground threads and background threads in .NET.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Background threads</h2>
<p>The difference <a id="_idIndexMarker013"/>between<a id="_idIndexMarker014"/> foreground threads and background threads might not be what you think. A managed thread created as a foreground thread is not the UI thread or the main thread. Foreground threads are threads that will prevent the managed process from terminating if they are running. If an application is terminated, any running background threads will be stopped so that the process can shut down.</p>
<p>By default, newly created threads are foreground threads. To create a new background thread, set the <code>Thread.IsBackground</code> property to <code>true</code> before starting the thread. Additionally, you can use the <code>IsBackground</code> property to determine the background status of an existing thread. Let’s look at an example where you might want to use a background thread in your application.</p>
<p>In this example, we will create a console application in Visual Studio that will continuously check the status of a network connection on a background thread. Create a new .NET 6 console app project, name it <code>BackgroundPingConsoleApp</code>, and in <code>Program.cs</code>, enter the following code:</p>
<pre class="source-code">Console.WriteLine("Hello, World!");</pre>
<pre class="source-code">var bgThread = new Thread(() =&gt;</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    while (true)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        bool isNetworkUp = System.Net.NetworkInformation</pre>
<pre class="source-code">            .NetworkInterface.GetIsNetworkAvailable();</pre>
<pre class="source-code">        Console.WriteLine($"Is network available? Answer: </pre>
<pre class="source-code">            {isNetworkUp}");</pre>
<pre class="source-code">        Thread.Sleep(100);</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">});</pre>
<pre class="source-code">bgThread.IsBackground = true;</pre>
<pre class="source-code">bgThread.Start();</pre>
<pre class="source-code">for (int i = 0; i &lt; 10; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine("Main thread working...");</pre>
<pre class="source-code">    Task.Delay(500);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">Console.WriteLine("Done");</pre>
<pre class="source-code">Console.ReadKey();</pre>
<p>Let’s discuss each part of the preceding code before we run it and examine the output:</p>
<ol>
<li>The first <code>Console.WriteLine</code> statement was created by the project template. We’ll <a id="_idIndexMarker015"/>keep this here to help illustrate the order <a id="_idIndexMarker016"/>output in the console.</li>
<li>Next, we’re creating a new <code>Thread</code> type named <code>bgThread</code>. Inside the body of the thread, there is a <code>while</code> loop that will execute continuously until the thread is terminated. Inside the loop, we’re calling the <code>GetIsNetworkAvailable</code> method and outputting the result of that call to the console. Before starting over again, we’re using <code>Thread.Sleep</code> to inject a 100-millisecond delay.</li>
<li>The next line after creating the thread is the key part of this lesson:<pre>bgThread.IsBackground = true;</pre></li>
</ol>
<p>Setting the <code>IsBackground</code> property to <code>true</code> is what makes our new thread a background thread. This tells our application that the code executing inside the thread is not critical to the application, and the process can terminate without needing to wait for the thread to complete its work. That is a good thing here because the <code>while</code> loop we created will never be complete.</p>
<ol>
<li value="4">On the next line, we start the thread with the <code>Start</code> method.</li>
<li>Next, the application kicks off some work inside the application’s primary thread. A <code>for</code> loop will execute 10 times and output <code>"Main thread working..."</code> to the console. At the end of each iteration of the loop, <code>Task.Delay</code> is used to wait 500 milliseconds, hopefully providing some time for the background thread to perform some work.</li>
<li>After the <code>for</code> loop, the application will output <code>"Done"</code> to the console and wait for the user input to terminate the application with the <code>Console.ReadKey</code> method.</li>
</ol>
<p>Now, run the application and examine the console output. You can press any key to stop the <a id="_idIndexMarker017"/>application<a id="_idIndexMarker018"/> when you feel you have let it run for long enough:</p>
<div><div><img alt="Figure 1.1 – Viewing the threaded console application output " height="680" src="img/Figure_1.1_B18552.jpg" width="1085"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Viewing the threaded console application output</p>
<p>The result might not be what you expected. You can see that the program executed all the logic on the primary thread before starting any of the background thread work. Later, we’ll see how to change the priority of the threads to manipulate which work will be processed first.</p>
<p>What is important to understand, in this example, is that we were able to stop the console application by pressing a key to execute the <code>Console.ReadKey</code> command. Even though the background thread is still running, the process does not consider the thread to be critical to the application. If you comment out the following line, the application will no longer terminate by pressing a key:</p>
<pre class="source-code">bgThread.IsBackground = true;</pre>
<p>The application will have to be stopped by closing the command window or using the <strong class="bold">Debug</strong> | <strong class="bold">Stop Debugging</strong> menu item in Visual Studio. Later, in the <em class="italic">Scheduling and canceling work</em> section, we will learn how to cancel work in a managed thread.</p>
<p>Before we<a id="_idIndexMarker019"/> look<a id="_idIndexMarker020"/> at any more examples of using managed threads, we will take some time to learn exactly what they are.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>What is managed threading?</h2>
<p>In .NET, <code>System.Threading.Thread</code> class that we used in the previous example. The managed execution environment for the current process monitors all the threads that have been run as part of the process. <code>PInvoke</code>) calls from .NET code. If this thread is entering the managed environment for the first time, .NET will create a new <code>Thread</code> object to be managed by the execution environment.</p>
<p>A managed thread can be uniquely identified using the <code>ManagedThreadId</code> property of the <code>Thread</code> object. This property is an integer that is guaranteed to be unique across all threads and will not change over time.</p>
<p>The <code>ThreadState</code> property is a read-only property that provides the current execution state of the <code>Thread</code> object. In the example in the <em class="italic">.NET threading basics</em> section, if we had checked the <code>ThreadState</code> property before calling <code>bgThread.Start()</code>, it would have been <code>Unstarted</code>. After calling <code>Start</code>, the state will change to <code>Background</code>. If it were not a background thread, calling <code>Start</code> would change the <code>ThreadState</code> property to <code>Running</code>. </p>
<p>Here is a full list of the <code>ThreadState</code> enum values:</p>
<ul>
<li><code>Aborted</code>: The thread has been aborted.</li>
<li><code>AbortRequested</code>: An abort has been requested but has not yet been completed.</li>
<li><code>Background</code>: The thread is running in the background (<code>IsBackground</code> has been set to true).</li>
<li><code>Running</code>: The thread is currently running.</li>
<li><code>Stopped</code>: The thread has been stopped.</li>
<li><code>StopRequested</code>: A stop has been requested but has not yet been completed.</li>
<li><code>Suspended</code>: The thread has been suspended.</li>
<li><code>SuspendRequested</code>: Thread suspension has been requested but has not yet been completed.</li>
<li><code>Unstarted</code>: The thread has been created but not yet started.</li>
<li><code>WaitSleepJoin</code>: The thread is currently blocked.</li>
</ul>
<p>The <code>Thread.IsAlive</code> property is a less specific property that can tell you whether a thread is currently running. It is a <code>boolean</code> property that will return <code>true</code> if the thread has started and has not been stopped or aborted in some way.</p>
<p>Threads also have a <code>Name</code> property that defaults to <code>null</code> if they have never been set. Once a <code>Name</code> property is set on a thread, it cannot be changed. If you attempt to set the <code>Name</code> property of a thread that is not null, it will throw <code>InvalidOperationException</code>.</p>
<p>We will<a id="_idIndexMarker025"/> cover <a id="_idIndexMarker026"/>additional aspects of managed threads in the remainder of this chapter. In the next section, we will dive deeper into the available methods and options for creating and destroying threads in .NET.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Creating and destroying threads</h1>
<p><code>Thread</code> class that should be discussed first. Also, we will look at a few methods of pausing or interrupting thread execution. Finally, we will cover some ways to destroy or terminate a thread’s execution. </p>
<p>Let’s get started by going into more detail regarding creating and starting threads.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Creating managed threads</h2>
<p>Creating <code>Thread</code> object. The <code>Thread</code> class has four constructor overloads:</p>
<ul>
<li><code>Thread(ParameterizedThreadStart)</code>: This creates a new <code>Thread</code> object. It does this by passing a delegate with a constructor that takes an object as its parameter that can be passed when calling <code>Thread.Start()</code>.</li>
<li><code>Thread(ThreadStart)</code>: This creates a new <code>Thread</code> object that will execute the method to be invoked, which is provided as the <code>ThreadStart</code> property.</li>
<li><code>Thread(ParameterizedThreadStart, Int32):</code> This adds a <code>maxStackSize</code> parameter. Avoid using this overload because it is best to allow .NET to manage the stack size.</li>
<li><code>Thread(ThreadStart, Int32):</code> This adds a <code>maxStackSize</code> parameter. Avoid using this overload because it is best to allow .NET to manage the stack size.</li>
</ul>
<p>Our first example used the <code>Thread(ThreadStart)</code> constructor. Let’s look at a version of that code that uses <code>ParameterizedThreadStart</code> to pass a value by limiting the number of iterations of the <code>while</code> loop:</p>
<pre class="source-code">Console.WriteLine("Hello, World!");</pre>
<pre class="source-code">var bgThread = new Thread((<strong class="bold">object? data</strong>) =&gt;</pre>
<pre class="source-code">{</pre>
<pre class="source-code"><strong class="bold">    if (data is null) return;</strong></pre>
<pre class="source-code"><strong class="bold">    int counter = 0;</strong></pre>
<pre class="source-code"><strong class="bold">    var result = int.TryParse(data.ToString(), </strong></pre>
<pre class="source-code"><strong class="bold">        out int maxCount);</strong></pre>
<pre class="source-code"><strong class="bold">    if (!result) return;</strong></pre>
<pre class="source-code">    while (<strong class="bold">counter &lt; maxCount</strong>)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        bool isNetworkUp = System.Net.NetworkInformation</pre>
<pre class="source-code">            .NetworkInterface.GetIsNetworkAvailable();</pre>
<pre class="source-code">        Console.WriteLine($"Is network available? Answer: </pre>
<pre class="source-code">            {isNetworkUp}");</pre>
<pre class="source-code">        Thread.Sleep(100);</pre>
<pre class="source-code"><strong class="bold">        counter++;</strong></pre>
<pre class="source-code">    }</pre>
<pre class="source-code">});</pre>
<pre class="source-code">bgThread.IsBackground = true;</pre>
<pre class="source-code"><strong class="bold">bgThread.Start(12);</strong></pre>
<pre class="source-code">for (int i = 0; i &lt; 10; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine("Main thread working...");</pre>
<pre class="source-code">    Task.Delay(500);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">Console.WriteLine("Done");</pre>
<pre class="source-code">Console.ReadKey();</pre>
<p>If you run the application, it will run just like the last example, but the background thread should only output 12 lines to the console. You can try passing different integer values into the <code>Start</code> method to see how that impacts the console output.</p>
<p>If you want to get a reference to the thread that is executing the current code, you can use the <code>Thread.CurrentThread</code> static property:</p>
<pre class="source-code">var currentThread = System.Threading.Thread.CurrentThread;</pre>
<p>This can be useful <a id="_idIndexMarker029"/>if your code needs to check the current thread’s <code>ManagedThreadId</code>, <code>Priority</code>, or whether it is running in the background.</p>
<p>Next, let’s look at how we can pause or interrupt the execution of a thread.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Pausing thread execution</h2>
<p>Sometimes, it is <a id="_idIndexMarker030"/>necessary to pause the execution of a thread. A common real-life example of this is a retry mechanism on a background thread. If you have a method that sends log data to a network resource, but the network is unavailable, you can call <code>Thread.Sleep</code> to wait for a specific interval before trying again. <code>Thread.Sleep</code> is a static method that will block the current thread for the number of milliseconds specified. It is not possible to call <code>Thread.Sleep</code> on a thread other than the current one.</p>
<p>We have already used <code>Thread.Sleep</code> in the examples in this chapter, but let’s change the code slightly to see how it can impact the order of events. Change the <code>Thread.Sleep</code> interval inside the thread to <code>10</code>, remove the code that makes it a background thread, and change the <code>Task.Delay()</code> call to <code>Thread.Sleep(100)</code>:</p>
<pre class="source-code">Console.WriteLine("Hello, World!");</pre>
<pre class="source-code">var bgThread = new Thread((object? data) =&gt;</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    if (data is null) return;</pre>
<pre class="source-code">    int counter = 0;</pre>
<pre class="source-code">    var result = int.TryParse(data.ToString(), out int </pre>
<pre class="source-code">        maxCount);</pre>
<pre class="source-code">    if (!result) return;</pre>
<pre class="source-code">    while (counter &lt; maxCount)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        bool isNetworkUp = System.Net.NetworkInformation.</pre>
<pre class="source-code">            NetworkInterface.GetIsNetworkAvailable();</pre>
<pre class="source-code">        Console.WriteLine($"Is network available? Answer: </pre>
<pre class="source-code">             {isNetworkUp}");</pre>
<pre class="source-code">        <strong class="bold">Thread.Sleep(10);</strong></pre>
<pre class="source-code">        counter++;</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">});</pre>
<pre class="source-code">bgThread.Start(12);</pre>
<pre class="source-code">for (int i = 0; i &lt; 12; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine("Main thread working...");</pre>
<pre class="source-code">    <strong class="bold">Thread.Sleep(100);</strong></pre>
<pre class="source-code">}</pre>
<pre class="source-code">Console.WriteLine("Done");</pre>
<pre class="source-code">Console.ReadKey();</pre>
<p>When running<a id="_idIndexMarker031"/> the application again, you can see that putting a greater delay on the primary thread allows the process inside <code>bgThread</code> to begin executing before the primary thread completes its work:</p>
<div><div><img alt="Figure 1.2 – Using Thread.Sleep to change the order of events " height="640" src="img/Figure_1.2_B18552.jpg" width="1037"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Using Thread.Sleep to change the order of events</p>
<p>The two <code>Thread.Sleep</code> intervals <a id="_idIndexMarker032"/>can be adjusted to see how they impact the console output. Give it a try!</p>
<p>Additionally, it is possible to pass <code>Timeout.Infinite</code> to <code>Thread.Sleep</code>. This will cause the thread to pause until it is interrupted or aborted by another thread or the managed environment. Interrupting a blocked or paused thread is accomplished by calling <code>Thread.Interrupt</code>. When a thread is interrupted, it will receive a <code>ThreadInterruptedException</code> exception. </p>
<p>The exception handler should allow the thread to continue working or clean up any remaining work. If the exception is unhandled, the runtime will catch the exception and stop the thread. Calling <code>Thread.Interrupt</code> on a running thread will have no effect until that thread has been blocked.</p>
<p>Now that you understand how to create an interrupt thread, let’s wrap up this section by learning how to destroy a thread.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Destroying managed threads</h2>
<p>Generally, <code>Thread.Abort</code> method. In .NET Framework, calling <code>Thread.Abort</code> on a thread would raise a <code>ThreadAbortedException</code> exception and stop the thread from running. Aborting threads was not made available in .NET Core or any of the newer versions of .NET. If some code needs to be forcibly stopped, it is recommended that you run it in a separate process from your other code and use <code>Process.Kill</code> to terminate the other process.</p>
<p>Any other thread termination should be handled cooperatively using cancelation. We will see how to<a id="_idIndexMarker034"/> do this in the <em class="italic">Scheduling and canceling work</em> section. Next, let’s discuss some of the exceptions to handle when working with managed threads.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Handling threading exceptions</h1>
<p>There are a couple of <a id="_idIndexMarker035"/>exception types that are specific to managed threading, including the <code>ThreadInterruptedException</code> exception that we covered in the previous section. Another exception type that is specific to threading is <code>ThreadAbortException</code>. However, as we discussed in the previous section, <code>Thread.Abort</code> is not supported in .NET 6, so, although this exception type exists in .NET 6, it is not necessary to handle it, as this type of exception is only possible in .NET Framework applications.</p>
<p>Two other exceptions are the <code>ThreadStartException</code> exception and the <code>ThreadStateException</code> exception. The <code>ThreadStartException</code> exception is thrown if there is a problem starting the managed thread before any user code in the thread can be executed. The <code>ThreadStateException</code> exception is thrown when a method on the thread is called that is not available when the thread is in its current <code>ThreadState</code> property. For example, calling <code>Thread.Start</code> on a thread that has already started is invalid and will cause a <code>ThreadStateException</code> exception. These types of exceptions can usually be avoided by checking the <code>ThreadState</code> property before acting on the thread.</p>
<p>It is important to implement comprehensive exception handling in multithreaded applications. If code in managed threads begins to fail silently without any logging or causing the process to terminate, the application can fall into an invalid state. This can also result in degrading performance and unresponsiveness. While this kind of degradation might be noticed quickly for many applications, some services, and other non-GUI-based applications, could continue for some time without any issues being noticed. Adding logging to the exception handlers along with a process to alert users when logs are reporting failures will help to prevent problems with undetected failing threads.</p>
<p>In the next <a id="_idIndexMarker036"/>section, we’ll discuss another challenge with multithreaded code: keeping data in-sync across multiple threads.</p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Synchronizing data across threads</h1>
<p>In this <a id="_idIndexMarker037"/>section, we will look at some of the methods that are available in .NET for synchronizing data across multiple threads. Shared data across threads can be one of the primary pain points of multithreaded development if not handled properly. Classes in .NET that have protections in place for threading are <a id="_idIndexMarker038"/>said to be <strong class="bold">thread-safe</strong>.</p>
<p>Data in multithreaded applications can be synchronized in several different ways:</p>
<ul>
<li><code>Monitor</code> class or with some help from the .NET compiler. </li>
<li><strong class="bold">Manual synchronization</strong>: There are several <strong class="bold">synchronization primitives</strong> in .NET that can be used to manually synchronize data.</li>
<li><strong class="bold">Synchronized context</strong>: This is only available in .NET Framework and Xamarin applications.</li>
<li><strong class="bold">System.Collections.Concurrent classes</strong>: There are specialized .NET collections to handle concurrency. We will examine these in <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>.</li>
</ul>
<p>In this section, we’ll look at the first two methods. Let’s start by discussing how to synchronize code regions in your application.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Synchronizing code regions</h2>
<p>There are <a id="_idIndexMarker039"/>several techniques you can use to<a id="_idIndexMarker040"/> synchronize regions of your code. The first one we will discuss is the <code>Monitor</code> class. You can surround a block of code that can be accessed by multiple threads with calls to <code>Monitor.Enter</code> and <code>Monitor.Exit</code>:</p>
<pre class="source-code">...</pre>
<pre class="source-code">Monitor.Enter(order);</pre>
<pre class="source-code">order.AddDetails(orderDetail);</pre>
<pre class="source-code">Monitor.Exit(order);</pre>
<pre class="source-code">...</pre>
<p>In this example, imagine you have an <code>order</code> object that is being updated by multiple threads in parallel. The <code>Monitor</code> class will lock access from other threads while the current thread adds an <code>orderDetail</code> item to the <code>order</code> object. The key to minimizing the chance of introducing wait time to other threads is by only locking the lines of<a id="_idIndexMarker041"/> code<a id="_idIndexMarker042"/> that need to be synchronized.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>Interlocked</code> class, as discussed in this section, performs atomic operations in user mode rather than kernel mode. If you want to read more about this distinction, I recommend checking out this blog post by Nguyen Thai Duong: <a href="">https://duongnt.com/interlocked-synchronization/</a>. </p>
<p>The <code>Interlocked</code> class provides several methods for performing atomic operations on objects shared across multiple threads. The following list of methods is part of the <code>Interlocked</code> class:</p>
<ul>
<li><code>Add</code>: This adds two integers, replacing the first one with the sum of the two</li>
<li><code>And</code>: This is a bitwise <code>and</code> operation for two integers</li>
<li><code>CompareExchange</code>: This compares two objects for equality and replaces the first if they are equal</li>
<li><code>Decrement</code>: This decrements an integer</li>
<li><code>Exchange</code>: This sets a variable to a new value</li>
<li><code>Increment</code>: This increments an integer</li>
<li><code>Or</code>: This is a bitwise <code>or</code> operation for two integers</li>
</ul>
<p>These <code>Interlocked</code> operations will lock access to the target object only for the duration of that operation.</p>
<p>Additionally, the <code>lock</code> statement in C# can be used to lock access to a block of code to only a single thread. The <code>lock</code> statement is a language construct implemented using the .NET <code>Monitor.Enter</code> and <code>Monitor.Exit</code> operations.</p>
<p>There is some built-in compiler support for the <code>lock</code> and <code>Monitor</code> blocks. If an exception is thrown inside one of these blocks, the lock is automatically released. The C# compiler generates a <code>try/finally</code> block around the synchronized code and makes a call to <code>Monitor.Exit</code> in the <code>finally</code> block.</p>
<p>Let’s finish up<a id="_idIndexMarker043"/> this section on synchronization <a id="_idIndexMarker044"/>by looking at some other .NET classes that provide support for manual data synchronization.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Manual synchronization</h2>
<p>The use of <strong class="bold">manual synchronization</strong> is<a id="_idIndexMarker045"/> common <a id="_idIndexMarker046"/>when synchronizing data across multiple threads. Some types of data cannot be protected in other ways, such as these:</p>
<ul>
<li><strong class="bold">Global fields</strong>: These are variables that can be accessed globally across the application.</li>
<li><strong class="bold">Static fields</strong>: These are static variables in a class.</li>
<li><strong class="bold">Instance fields</strong>: These are instance variables in a class.</li>
</ul>
<p>These fields do not have method bodies, so there is no way to put a synchronized code region around them. With manual synchronization, you can protect all the areas where these objects are used. These regions can be protected with <code>lock</code> statements in C#, but some other synchronization primitives provide access to shared data and can coordinate the interactions between threads on a more granular level. The first construct we will examine is the <code>System.Threading.Mutex</code> class.</p>
<p>The <code>Mutex</code> class is similar to the <code>Monitor</code> class in that it blocks access to a region of code, but it can also provide the ability to grant access to other processes. When using the <code>Mutex</code> class, use the <code>WaitOne()</code> and <code>ReleaseMutex()</code> methods to acquire and release the lock. Let’s look at the same order/order details example. This time, we’ll use a <code>Mutex</code> class declared at the class level:</p>
<pre class="source-code">private static Mutex orderMutex = new Mutex();</pre>
<pre class="source-code">...</pre>
<pre class="source-code">orderMutex.WaitOne();</pre>
<pre class="source-code">order.AddDetails(orderDetail);</pre>
<pre class="source-code">orderMutex.ReleaseMutex();</pre>
<pre class="source-code">...</pre>
<p>If you want to enforce a timeout period on the <code>Mutex</code> class, you can call the <code>WaitOne</code> overload with a timeout value:</p>
<pre class="source-code">orderMutex.WaitOne(500);</pre>
<p>It is important to note that <code>Mutex</code> is a <code>Dispose()</code> on the <a id="_idIndexMarker047"/>object when you are finished using it. Additionally, you can also enclose a disposable type within a <code>using</code> block to have it disposed of indirectly.</p>
<p>In this <a id="_idIndexMarker048"/>section, the<a id="_idIndexMarker049"/> last .NET manual locking construct we are going to examine is the <code>ReaderWriterLockSlim</code> class. You can use this type if you have an object that is used across multiple threads, but most of the code is reading data from the object. You don’t want to lock access to the object in the blocks of code that are reading data, but you do want to prevent reading while the object is being updated or simultaneously written. This is referred to as "multiple readers, single writer."</p>
<p>This <code>ContactListManager</code> class contains a list of contacts that can be added to or retrieved by a phone number. The class assumes that these operations can be called from multiple threads and uses the <code>ReaderWriterLockSlim</code> class to apply a read lock in the <code>GetContactByPhoneNumber</code> method and a write lock in the <code>AddContact</code> method. The locks are released in a <code>finally</code> block to ensure they are always released, even when exceptions are encountered:</p>
<pre class="source-code">public class ContactListManager</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    private readonly List&lt;Contact&gt; contacts;</pre>
<pre class="source-code">    private readonly ReaderWriterLockSlim contactLock = </pre>
<pre class="source-code">        new ReaderWriterLockSlim();</pre>
<pre class="source-code">    public ContactListManager(</pre>
<pre class="source-code">        List&lt;Contact&gt; initialContacts)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        contacts = initialContacts;</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    public void AddContact(Contact newContact)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        try</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            contactLock.EnterWriteLock();</pre>
<pre class="source-code">            contacts.Add(newContact);</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">        finally</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            contactLock.ExitWriteLock();</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    public Contact GetContactByPhoneNumber(string </pre>
<pre class="source-code">        phoneNumber)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        try</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            contactLock.EnterReadLock();</pre>
<pre class="source-code">            return contacts.FirstOrDefault(x =&gt; </pre>
<pre class="source-code">                x.PhoneNumber == phoneNumber);</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">        finally</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            contactLock.ExitReadLock();</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>If you were to add a <code>DeleteContact</code> method to the <code>ContactListManager</code> class, you would leverage the same <code>EnterWriteLock</code> method to prevent any conflicts with the other operations in the class. If a lock is forgotten in one usage of <code>contacts</code>, it can cause any of the other operations to fail. Additionally, it is possible to apply a timeout to the <code>ReaderWriterLockSlim</code> locks:</p>
<pre class="source-code">contacts.EnterWriteLock(1000);</pre>
<p>There are several other synchronization primitives that we have not covered in this section, but we have discussed some of the most common types that you will use. To read more about the available types for manual synchronization, you can visit Microsoft Docs at <a href="">https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives</a>.</p>
<p>Now that<a id="_idIndexMarker050"/> we<a id="_idIndexMarker051"/> have examined different ways of synchronizing data when working with managed threads, let’s cover two more important topics before wrapping up this first chapter. We are going to discuss techniques to schedule work on threads and how to cancel managed threads cooperatively.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Scheduling and canceling work</h1>
<p>When<a id="_idIndexMarker052"/> orchestrating <a id="_idIndexMarker053"/>multithreaded processing in an application, it is important to understand how to schedule and cancel work on managed threads. </p>
<p>Let’s start by looking at how scheduling works with managed threads in .NET.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Scheduling managed threads</h2>
<p>When it comes to <a id="_idIndexMarker054"/>managed threads, scheduling is not as explicit as it might sound. There is no mechanism to tell the operating system to kick off work at specific times or to execute within certain intervals. While you could write this kind of logic, it is probably not necessary. The process of scheduling managed threads is simply managed by setting priorities on the threads. To do this, set the <code>Thread.Priority</code> property to one of the available <code>ThreadPriority</code> values: <code>Highest</code>, <code>AboveNormal</code>, <code>Normal</code> (default), <code>BelowNormal</code>, or <code>Lowest</code>.</p>
<p>Generally, higher priority threads will execute before those of lower priority. Usually, a thread of <code>Lowest</code> priority will not execute until all the higher priority threads have been completed. If the <code>Lowest</code> priority thread has started and a <code>Normal</code> thread kicks off, the <code>Lowest</code> priority thread will be suspended so that the <code>Normal</code> thread can be run. These rules are not absolute, but you can use them as a guide. Most of the time, you will leave the default of <code>Normal</code> for your threads.</p>
<p>When there are multiple threads of the same priority, the operating system will cycle through them, giving each thread up to a maximum allotment of time before suspending work and moving on to the next thread of the same priority. The logic will vary by the operating system, and the prioritization of a process can change based on whether the application is in the foreground of the UI. </p>
<p>Let’s use our network checking code to test thread priorities:</p>
<ol>
<li value="1">Start by creating a new console application in Visual Studio</li>
<li>Add a new class to the project, named <code>NetworkingWork</code>, and add a method named <code>CheckNetworkStatus</code> with the following implementation:<pre>public void CheckNetworkStatus(object data)
{
    for (int i = 0; i &lt; 12; i++)
    {
        bool isNetworkUp = System.Net.
            NetworkInformation.NetworkInterface
                .GetIsNetworkAvailable();
        Console.WriteLine($"Thread priority 
            {(string)data}; Is network available? 
                Answer: {isNetworkUp}");
        i++;
    }
}</pre></li>
</ol>
<p>The calling code will be passing a parameter with the priority of the thread that is currently executing the message. That will be added as part of the console output inside the <code>for</code> loop, so users can see which priority threads are running first.</p>
<ol>
<li value="3">Next, replace <a id="_idIndexMarker055"/>the contents of <code>Program.cs</code> with the following code:<pre>using BackgroundPingConsoleApp_sched;
Console.WriteLine("Hello, World!");
var networkingWork = new NetworkingWork();
var bgThread1 = new 
    Thread(networkingWork.CheckNetworkStatus);
var bgThread2 = new 
    Thread(networkingWork.CheckNetworkStatus);
var bgThread3 = new 
    Thread(networkingWork.CheckNetworkStatus);
var bgThread4 = new 
    Thread(networkingWork.CheckNetworkStatus);
var bgThread5 = new 
    Thread(networkingWork.CheckNetworkStatus);
bgThread1.Priority = ThreadPriority.Lowest;
bgThread2.Priority = ThreadPriority.BelowNormal;
bgThread3.Priority = ThreadPriority.Normal;
bgThread4.Priority = ThreadPriority.AboveNormal;
bgThread5.Priority = ThreadPriority.Highest;
bgThread1.Start("Lowest");
bgThread2.Start("BelowNormal");
bgThread3.Start("Normal");
bgThread4.Start("AboveNormal");
bgThread5.Start("Highest");
for (int i = 0; i &lt; 10; i++)
{
    Console.WriteLine("Main thread working...");
}
Console.WriteLine("Done");
Console.ReadKey();</pre></li>
</ol>
<p>The code<a id="_idIndexMarker056"/> creates five <code>Thread</code> objects, each with a different <code>Thread.Priority</code> value. To make things a little more interesting, the threads are being started in reverse order of their priorities. You can try changing this on your own to see how the order of execution is impacted.</p>
<ol>
<li value="4">Now run the application and examine the output:</li>
</ol>
<div><div><img alt="Figure 1.3 – Console output from five different threads " height="680" src="img/Figure_1.3_B18552.jpg" width="1129"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Console output from five different threads</p>
<p>You can see that the operating system, which, in my case, is Windows 11, sometimes executes lower priority threads before all the higher priority threads have completed their work. The algorithm for selecting the next thread to run is a bit of a mystery. You should also <a id="_idIndexMarker057"/>remember that this is multithreading. Multiple threads are running at once. The exact number of threads that can run simultaneously will vary by the processor or virtual machine configuration.</p>
<p>Let’s wrap things up by learning how to cancel a running thread.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Canceling managed threads</h2>
<p><strong class="bold">Canceling managed threads</strong> is one <a id="_idIndexMarker058"/>of the more important concepts to understand about managed threading. If you have long-running operations running on foreground threads, they should support cancelation. There are times when you might want to allow users to cancel the processes through your application’s UI, or the cancelation might be part of a cleanup process while the application is closing.</p>
<p>To cancel an operation in a managed thread, you will use a <code>CancellationToken</code> parameter. The <code>Thread</code> object itself does not have built-in support for cancellation tokens like some of the modern threading constructs .NET. So, we will have to pass the token to the method running in the newly created thread. In the next exercise, we will modify the previous example to support cancelation:</p>
<ol>
<li value="1">Start by updating <code>NetworkingWork.cs</code> so that the parameter passed to <code>CheckNetworkStatus</code> is a <code>CancellationToken</code> parameter:<pre>public void CheckNetworkStatus(object data)
{
    var cancelToken = (CancellationToken)data;
    while (!cancelToken.IsCancellationRequested)
    {
        bool isNetworkUp = System.Net
            .NetworkInformation.NetworkInterface
                .GetIsNetworkAvailable();
        Console.WriteLine($"Is network available? 
            Answer: {isNetworkUp}");
    }
}</pre></li>
</ol>
<p>The code will keep<a id="_idIndexMarker059"/> checking the network status inside a while loop until <code>IsCancellationRequested</code> becomes <code>true</code>.</p>
<ol>
<li value="2">In <code>Program.cs</code>, we’re going to return to working with only one <code>Thread</code> object. Remove or comment out all of the previous background threads. To pass the <code>CancellationToken</code> parameter to the <code>Thread.Start</code> method, create a new <code>CancellationTokenSource</code> object, and name it <code>ctSource</code>. The cancellation token is available in the <code>Token</code> property:<pre>var pingThread = new 
    Thread(networkingWork.CheckNetworkStatus);
var ctSource = new CancellationTokenSource();
pingThread.Start(ctSource.Token);
...</pre></li>
<li>Next, inside the <code>for</code> loop, add a <code>Thread.Sleep(100)</code> statement to allow <code>pingThread</code> to execute while the main thread is suspended:<pre>for (int i = 0; i &lt; 10; i++)
{
    Console.WriteLine("Main thread working...");
    <strong class="bold">Thread.Sleep(100);</strong>
}</pre></li>
<li>After the <code>for</code> loop<a id="_idIndexMarker060"/> is complete, invoke the <code>Cancel()</code> method, join the thread back to the main thread, and dispose of the <code>ctSource</code> object. The <code>Join</code> method will block the current thread and wait for <code>pingThread</code> to complete using this thread:<pre>...
ctSource.Cancel();
pingThread.Join();
ctSource.Dispose();</pre></li>
<li>Now, when you run the application, you will see the network checking stops shortly after the final <code>Thread.Sleep</code> statement on the main thread has been executed:</li>
</ol>
<div><div><img alt="Figure 1.4 – Canceling a thread in the console application " height="644" src="img/Figure_1.4_B18552.jpg" width="1049"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Canceling a thread in the console application</p>
<p>Now the network checker application is gracefully canceling the threaded work before listening for a keystroke to close the application.</p>
<p>When you have <a id="_idIndexMarker061"/>a long-running process on a managed thread, you should check for cancellation as the code iterates through loops, begins a new step in a process, and at other logical checkpoints in the process. If the operation uses a timer to periodically perform work, the token should be checked each time the timer executes.</p>
<p>Another way to listen for cancellation is by registering a <code>Token.Register</code> method inside the managed thread to receive a cancellation callback. The following <code>CheckNetworkStatus2</code> method will work exactly like the previous example:</p>
<pre class="source-code">public void CheckNetworkStatus2(object data)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    bool finish = false;</pre>
<pre class="source-code">    var cancelToken = (CancellationToken)data;</pre>
<pre class="source-code"><strong class="bold">    cancelToken.Register(() =&gt; {</strong></pre>
<pre class="source-code"><strong class="bold">        // Clean up and end pending work</strong></pre>
<pre class="source-code"><strong class="bold">        finish = true;</strong></pre>
<pre class="source-code"><strong class="bold">    });</strong></pre>
<pre class="source-code">    while (!finish)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        bool isNetworkUp = System.Net.NetworkInformation</pre>
<pre class="source-code">            .NetworkInterface.GetIsNetworkAvailable();</pre>
<pre class="source-code">        Console.WriteLine($"Is network available? Answer: </pre>
<pre class="source-code">            {isNetworkUp}");</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>Using a delegate<a id="_idIndexMarker062"/> like this is more useful if you have multiple parts of your code that need to listen for a cancellation request. A <strong class="bold">callback</strong> method can call several cleanup methods or set another flag that is monitored throughout the thread. It encapsulates the cleanup operation nicely.</p>
<p>We will revisit cancellation in <a href="B18552_11_ePub.xhtml#_idTextAnchor173"><em class="italic">Chapter 11</em></a>, as we introduce new parallelism and concurrency concepts. However, this section should provide a solid foundation for understanding what comes next.</p>
<p>That concludes the final section on managed threads. Let’s wrap things up and review what we have learned.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Summary</h1>
<p>In this chapter, we covered the basics of managed threading and the <code>System.Threading.Thread</code> class. You should now have a good understanding of how to create and schedule a thread in .NET. You learned about some of the techniques for passing data to threads and how to use background threads for non-critical operations, so they don’t prevent your application from terminating. Finally, we used two different techniques for canceling threads in .NET.</p>
<p>In the next chapter, <a href="B18552_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, we will learn how .NET has simplified and improved parallel programming and concurrency for developers over the last 20 years. Significant improvements were added in .NET 4.5 in the form of the <code>async</code> and <code>await</code> keywords, and .NET Core removed some of the legacy threading constructs of .NET Framework.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Questions</h1>
<ol>
<li value="1">What is a managed thread?</li>
<li>How do you make a background thread?</li>
<li>What happens if you try to set the <code>IsBackground</code> property of a running thread?</li>
<li>How does .NET handle scheduling managed threads?</li>
<li>What is the highest thread priority?</li>
<li>What happens to a thread when you call <code>Thread.Abort()</code> in .NET 6?</li>
<li>How can you pass data to a method in a new thread?</li>
<li>How do you register a callback to be invoked when a cancellation is requested on a thread?</li>
</ol>
</div>
</div>
</body></html>