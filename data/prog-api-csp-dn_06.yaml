- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Azure Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Functions
- en: 'Determining the execution environment of your APIs can have a large impact
    on how they run, how they scale, how much they cost, and what features come out
    of the box. Azure Functions provides a different hosting option that complements
    existing Azure services with a focus on event-driven execution. While Functions
    provides many ways to react to different things in a system, we’ll focus on a
    specific event: the HTTP request.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 确定您的API的执行环境可能会对它们的运行方式、扩展方式、成本以及默认功能产生重大影响。Azure Functions提供了一种不同的托管选项，它通过关注事件驱动的执行来补充现有的Azure服务。虽然Functions提供了许多方式来响应系统中的不同事物，但我们将专注于一个特定的事件：HTTP请求。
- en: In this chapter, we’ll cover some technical aspects related to hosting and billing
    and finish with a walkthrough that includes cloud deployment and configuration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍与托管和计费相关的某些技术方面，并以包括云部署和配置的演练结束。
- en: 'By the end of this chapter, you’ll have a good base to continue your API journey
    by knowing about the following aspects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解以下方面，从而为继续您的API之旅打下良好的基础：
- en: Hosting considerations that affect certain runtime options and limitations based
    on the needs of your application.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响某些运行时选项和限制的托管考虑因素，这些选项和限制基于您应用程序的需求。
- en: How certain aspects of your application can affect billing.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应用程序的某些方面如何影响计费。
- en: The structure, general familiarity, and possibilities of code design related
    specifically to HTTP APIs.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与特定于HTTP API的代码设计相关的结构、一般熟悉度和可能性。
- en: Deploying to Azure from Visual Studio. Automated builds, continuous integration,
    and continuous delivery will be covered later in this book.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Visual Studio部署到Azure。本书后面将介绍自动构建、持续集成和持续交付。
- en: Making runtime configuration changes without redeployment.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不重新部署的情况下进行运行时配置更改。
- en: How to adjust scaling settings to reduce the potential cost of a public endpoint,
    colloquially known as a Denial-of-Wallet attack.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何调整扩展设置以降低公共端点（俗称钱包拒绝攻击）的潜在成本。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To build Azure Functions in Visual Studio, you’ll need the Azure development
    workload available in Visual Studio Installer. The source code for this chapter
    is available at https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter06
    .
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Visual Studio中构建Azure Functions，您需要Visual Studio安装器中可用的Azure开发工作负载。本章的源代码可在https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter06处获取。
- en: Understanding Functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Functions
- en: Azure Functions fills a large role in execution environments while focusing
    on event-based data processing. Traditionally, those environments have a lot of
    overhead in terms of hardware or **virtual machines** ( **VMs** ) and boilerplate
    code. Functions is Microsoft’s execution environment to allow ease of development,
    deployment, and scaling. While a few types of underlying execution environments
    are available, it defaults to consumption, which brings a set of defaults that
    are well suited to a large variety of different data processing scenarios and
    are billed per event execution. If you need more CPU cores or memory, other environments
    are available; these will be covered later in this chapter. While all execution
    environments in Functions are considered serverless in the sense that you don’t
    have to manage individual instances, other non-consumption environments are not
    pay-per-use and instead are charged based on the amount of CPU cores and memory
    allocated to each instance. C# is the predominant language that’s used, although
    a variety of languages and bindings are supported.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions在执行环境中扮演着重要角色，同时专注于基于事件的数据处理。传统上，这些环境在硬件或**虚拟机**（**VMs**）以及样板代码方面有大量的开销。Functions是Microsoft的执行环境，旨在允许轻松的开发、部署和扩展。虽然有一些底层执行环境可供选择，但它默认为消费模式，这带来了一组适用于大量不同数据处理场景的默认设置，并且按事件执行计费。如果您需要更多的CPU核心或内存，其他环境可供选择；这些将在本章后面介绍。虽然Functions中的所有执行环境在无服务器意义上都被认为是无需管理单个实例的，但其他非消费环境不是按使用付费，而是根据分配给每个实例的CPU核心和内存数量计费。C#是使用的主要语言，尽管支持多种语言和绑定。
- en: The main entry points for the execution of these applications are triggers.
    A variety of these triggers exist to react to external events. From queue polling
    to ServiceBus pushing, reacting to blob, or database record changes, many ready-to-go
    bindings allow you to mix and match your solution. For APIs, the triggers we care
    most about are HTTP triggers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序执行的主要入口点是触发器。存在各种触发器来响应外部事件。从队列轮询到 ServiceBus 推送，响应 blob 或数据库记录更改，许多现成的绑定允许您混合匹配您的解决方案。对于
    API，我们最关心的触发器是 HTTP 触发器。
- en: 'HTTP triggers are exactly what they sound like: a request-response to a normal
    API request. These requests can come from all the usual suspects: browsers, webhooks,
    service-to-service calls, and so on. They can be routed to individual functions
    using the built-in routing template support. Incoming data from these routes can
    be automatically matched to the specified data types, deserialized, and bound.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 触发器正如其名：对正常 API 请求的请求-响应。这些请求可以来自所有常见的来源：浏览器、webhooks、服务间调用等等。它们可以使用内置的路由模板支持路由到单个函数。来自这些路由的传入数据可以自动匹配到指定的数据类型，反序列化，并绑定。
- en: 'Built-in authorization is either none or API key-based, with the latter available
    in two flavors: function-specific or a single global application key. Other standard
    authorization can be implemented with Entra ID, manually in code, or both.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的授权要么是无授权，要么是基于 API 密钥的，后者有两种风味：特定于函数的或单个全局应用程序密钥。其他标准授权可以使用 Entra ID、手动在代码中实现，或者两者结合。
- en: Hosting should also be considered since your application will need to run somewhere
    – likely, though not necessarily, in the cloud. Various hosting and packaging
    options are provided, allowing you to tailor deployment to accommodate your application’s
    needs. ZIP files, Docker, plain file copy (xcopy), and on-premises are all available.
    AMD64 Windows and Linux are supported on Azure, while ARM64 is supported in other
    scenarios.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该考虑主机，因为您的应用程序需要在某处运行——可能是，但不一定是云中。提供了各种主机和打包选项，允许您根据应用程序的需求定制部署。ZIP 文件、Docker、普通文件复制（xcopy）和本地部署都是可用的。Azure
    支持AMD64 Windows 和 Linux，而 ARM64 在其他场景中得到支持。
- en: At this point, you should have a good understanding of the environment in which
    Azure Functions operates and what’s available to you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对 Azure Functions 运行的环境以及您可用的资源有很好的理解。
- en: Hosting
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机
- en: There are a variety of hosting options available to suit practically any need.
    Each has its pros and cons. **Consumption** is the default and will be used in
    this chapter. **Flex Consumption** (in preview at the time of writing), **Premium**
    , **Application Service Environment** ( **ASE** ), and **Kubernetes** are additional
    supported offerings that won’t be discussed in this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种主机选项可供选择，以满足几乎任何需求。每个选项都有其优缺点。"消费"是默认选项，将在本章中使用。"灵活消费"（在撰写本文时处于预览阶段）、"高级"（Premium）、"应用程序服务环境"（**ASE**）和**Kubernetes**是额外的支持服务，本书将不会讨论。
- en: Although powerful, Consumption comes with several limitations. First, the instance
    memory is limited to 1.5 GB, which can put a hard limit on the types of applications
    that can be run directly inside this Functions option. The second is that the
    instance only has a single core. The third is timeout. Azure only allows a timeout
    limit of 5 to 10 minutes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然功能强大，但消费模式也带来了一些限制。首先，实例内存限制为 1.5 GB，这可能会对可以直接在此函数选项内部运行的应用程序类型设置硬限制。第二是实例只有一个核心。第三是超时。Azure
    只允许 5 到 10 分钟的超时限制。
- en: However, many workloads do fit well within these constraints. From standard
    **Software-as-a-Service** ( **SaaS** ), APIs, and periodic updates to CRUD and
    Durable Functions-related calls (explained in the next chapter), the potential
    is there for the vast majority of these to fit well within the limits.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多工作负载都很好地适应了这些限制。从标准的**软件即服务**（**SaaS**）、API 和定期更新到 CRUD 和持久函数相关的调用（下一章中解释），大多数这些工作负载都有潜力很好地适应这些限制。
- en: Needing more compute resources can be common in artificial intelligence workloads,
    for example. While Consumption is conceptually easy to think about, Premium is
    the next step up. You’re billed for individual CPU vCores and GBs of memory allocated
    together in classic VM form. Managing these VMs is completely delegated to Azure.
    You set the maximum (and/or minimum) of the number of instances that the application
    can scale out to, and Azure handles the rest. The current limitations are 4 vCores
    and 14 GB of memory per host. Windows allows up to 100 hosts, and Linux between
    20 and 100 hosts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能工作负载中，需要更多的计算资源可能是常见的，例如。虽然消费模式在概念上容易理解，但高级模式是下一步。你将根据经典虚拟机形式中分配的每个CPU
    vCore和GB内存的数量进行计费。这些虚拟机的管理完全委托给Azure。你可以设置应用程序可以扩展到的实例数量的最大值（和/或最小值），Azure处理其余部分。当前的限制是每个主机4个vCore和14GB内存。Windows支持最多100个主机，而Linux则在20到100个主机之间。
- en: Application packaging
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序打包
- en: There are a few application packaging and deployment options available as well,
    depending on what size of resource you require. Docker is supported on Premium
    and App Service, allowing you to control the runtime environment with precision.
    ZIP files (published archives containing your entire application) are supported
    for all runtimes and required with Consumption.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所需的资源大小，还有一些应用程序打包和部署选项可用。在高级和App Service上支持Docker，允许你精确控制运行时环境。所有运行时都支持ZIP文件（包含你整个应用程序的发布存档），在消费模式下是必需的。
- en: History
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 历史
- en: Note that most of the runtime hosting modes, while they may still be available,
    are now considered deprecated. Originally, compiled functions were loaded inside
    the same physical operating system process that the function host was running
    in. This “in-proc” model allowed direct function calling between the host and
    custom functions but introduced potential issues with library dependencies and
    language updates. Hard dependencies on specific library versions couldn’t be changed,
    and new C# language versions couldn’t be used if they were incompatible with the
    existing runtime. Assembly loading quirks were also common, with varying success
    in workarounds.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管大多数运行时托管模式可能仍然可用，但现在它们被认为是过时的。最初，编译的函数是在与函数宿主运行在同一个物理操作系统进程中加载的。这种“进程内”模型允许宿主和自定义函数之间直接调用函数，但引入了与库依赖和语言更新相关的潜在问题。对特定库版本的硬依赖无法更改，如果新的C#语言版本与现有运行时不兼容，则无法使用。组件加载的怪癖也很常见，解决方法的效果各不相同。
- en: Azure Functions initially launched with an Azure-based browser editor, and although
    it was serverless, the model had room for improvement. Later, a new version allowed
    standard .NET assemblies to be compiled so that the function host, starting the
    physical operating system process, would load. This introduced dependency resolution
    conflicts and required pinning functions to the same runtime version as the host,
    highlighting the need for further solutions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions最初以基于Azure的浏览器编辑器启动，尽管它是无服务器的，但该模型仍有改进的空间。后来，一个新版本允许编译标准.NET组件，以便函数宿主启动物理操作系统进程时可以加载。这引入了依赖项解析冲突，并需要将函数固定到与宿主相同的运行时版本，突显了需要进一步解决方案的需求。
- en: Today, with out-of-process hosting, the majority of the aforementioned problems
    go away. Your function application runs in its own operating system process, managing
    its own startup, dependency injection, language, and .NET version. Communication
    is handled through an internal channel between the host application and your function
    application. This is the recommended way forward for .NET 6 and .NET 8 functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，使用进程外托管，上述大多数问题都消失了。你的函数应用程序在自己的操作系统进程中运行，管理自己的启动、依赖注入、语言和.NET版本。通信通过宿主应用程序和你的函数应用程序之间的内部通道处理。这是.NET
    6和.NET 8函数推荐的向前发展方式。
- en: Though historical context is worth knowing for completeness, the defaults guide
    you through the recommended experience out of the box. So, how does the Consumption
    plan measure the usage of your API? Let’s take a look.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解历史背景对于完整性很重要，但默认设置会引导你直接进入推荐体验。那么，消费计划是如何衡量你的API使用的呢？让我们看看。
- en: Billing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计费
- en: 'The billing model for Consumption is a new metric that you may not be familiar
    with unless you’ve dealt with cloud cost estimation before. **Gigabytes per second**
    ( **GB/s** ) is the measure that’s used in Consumption to accurately bill for
    applications and is the first part of the billing process. Whether they’re quick
    and fast responses or memory-hungry multi-second responses, this style of metric
    allows it to be reported as a single numeric value. For example, a single request
    that takes 1 second to respond, using 1 GB of memory, would result in **1*1s*1GB=1GB/s**
    for billing. As for the inverse, four requests taking 250 milliseconds using the
    same 1 GB of memory would also equal 1 GB/s: **4*250ms*1GB=1GB/s** . At the time
    of writing, Azure’s free tier grants 400,000 GB/s of free usage per month. With
    each request potentially taking an average of 100ms and using 256 MB of memory,
    that works out to be 16 million requests. The second part of billing is more straightforward:
    the number of requests. Azure grants 1 million requests for free per month, and
    it’s $0.20 per million requests after that.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗型计费模型是一个新的度量标准，除非您之前处理过云成本估算，否则您可能不熟悉。**每秒千兆字节**（**GB/s**）是消耗型中用于准确计费应用的度量标准，是计费过程的第一个部分。无论是快速响应还是内存密集型多秒响应，这种度量标准允许将其报告为单个数值。例如，一个响应时间为
    1 秒的单个请求，使用 1 GB 的内存，将导致计费为 **1*1s*1GB=1GB/s**。至于相反的情况，四个使用相同 1 GB 内存且响应时间为 250
    毫秒的请求也等于 1 GB/s：**4*250ms*1GB=1GB/s**。截至编写本文时，Azure 的免费层每月提供 400,000 GB/s 的免费使用量。如果每个请求平均需要
    100ms 并使用 256 MB 的内存，那么这将相当于 1600 万个请求。计费的第二个部分更为直接：请求的数量。Azure 每月免费提供 100 万个请求，之后每百万个请求的费用为
    0.20 美元。
- en: Project walkthrough
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this section, we’ll begin creating a new Functions project, adding an additional
    HTTP trigger with an API route, and setting up some configuration that practically
    all applications will require.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始创建一个新的函数项目，添加一个额外的 HTTP 触发器以及 API 路由，并设置一些几乎所有应用程序都将需要的配置。
- en: Starting up
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动
- en: 'Creating a new Functions project is just like creating any other project. There
    are templates available in Visual Studio’s new project wizard to aid you with
    this. Follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的函数项目就像创建任何其他项目一样。Visual Studio 的新项目向导中提供了模板，可以帮助您完成此操作。请按照以下步骤操作：
- en: 'Select **Azure Functions** or search for it using the **functions** keyword
    and click **Next** :'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Azure Functions**或使用**functions**关键字搜索，然后点击**下一步**：
- en: '![Figure 6.1 – New project wizard](img/B21988_06_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 新项目向导](img/B21988_06_01.jpg)'
- en: Figure 6.1 – New project wizard
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 新项目向导
- en: 'Name your project and click **Next** :'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的项目命名并点击**下一步**：
- en: '![Figure 6.2 – Project configuration](img/B21988_06_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 项目配置](img/B21988_06_02.jpg)'
- en: Figure 6.2 – Project configuration
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 项目配置
- en: 'Select the runtime and hosting configuration options. Usually, the latest **Long
    Term Support** option is a safe bet:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择运行时和托管配置选项。通常，最新的**长期支持**选项是一个安全的选择：
- en: '![Figure 6.3 – Functions worker configuration](img/B21988_06_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 函数工作器配置](img/B21988_06_03.jpg)'
- en: Figure 6.3 – Functions worker configuration
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 函数工作器配置
- en: Select the **Http trigger** option, choose **Anonymous** under **Authorization
    level** , and click **Create** .
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Http 触发器**选项，在**授权级别**下选择**匿名**，然后点击**创建**。
- en: 'We’ll cover authentication and authorization later in this book. As mentioned
    earlier, Docker containers are supported, but leave this option unchecked for
    now. Ensure the **Azurite** option is selected. This supports backend state management
    for various things and is also the “Durable” in Durable Functions, something that
    will be covered in the next chapter. Other triggers can be added later:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分介绍身份验证和授权。如前所述，Docker 容器受到支持，但暂时不要勾选此选项。确保选择**Azurite**选项。这支持各种后端状态管理，也是
    Durable Functions 中的“Durable”，这些内容将在下一章中介绍。其他触发器可以在以后添加：
- en: '![Figure 6.4 – Additional Functions authorization options](img/B21988_06_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 额外的函数授权选项](img/B21988_06_04.jpg)'
- en: Figure 6.4 – Additional Functions authorization options
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 额外的函数授权选项
- en: 'Many different triggers are available, and you can mix and match as needed.
    Right-click on the project in the **Solution Explorer** area and select **Add**
    | **New** **Azure Function** :'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可用的触发器种类繁多，您可以根据需要混合搭配。在**解决方案资源管理器**区域中右键单击项目，然后选择**添加** | **新建** **Azure 函数**：
- en: '![Figure 6.5 – Adding a new Azure Function](img/B21988_06_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 添加新的 Azure 函数](img/B21988_06_05.jpg)'
- en: Figure 6.5 – Adding a new Azure Function
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 添加新的 Azure 函数
- en: 'You may need to search for **Function** in the list, then click **Add** :'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能需要在列表中搜索 **Function**，然后点击 **Add**：
- en: '![Figure 6.6 – New item dialog](img/B21988_06_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 新项目对话框](img/B21988_06_06.jpg)'
- en: Figure 6.6 – New item dialog
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 新项目对话框
- en: 'A list of triggers should appear. Select **Http trigger** , choose **Anonymous**
    for **Authorization level** , and click **Add** :'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该会显示一个触发器列表。选择 **Http trigger**，对于 **Authorization level** 选择 **Anonymous**，然后点击
    **Add**：
- en: '![Figure 6.7 – The New Azure Function dialog](img/B21988_06_07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 新 Azure 函数对话框](img/B21988_06_07.jpg)'
- en: Figure 6.7 – The New Azure Function dialog
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 新 Azure 函数对话框
- en: Note that templates are revised over time, and this new one may look different
    compared to the original Function. It also may add some interesting new objects
    that may look familiar to you, including **IActionResult** and **OkObjectResult**
    . These come from ASP.NET Core libraries. Install the latest **Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore**
    NuGet package if it wasn’t referenced by default.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模板会随着时间的推移而更新，这个新模板可能与原始函数看起来不同。它还可能添加一些您可能熟悉的新对象，包括 **IActionResult** 和
    **OkObjectResult**。这些来自 ASP.NET Core 库。如果默认情况下没有引用，请安装最新的 **Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore**
    NuGet 包。
- en: With that, you’ve created two HTTP endpoints that should compile.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您已经创建了两个应该可以编译的 HTTP 端点。
- en: Options
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项
- en: Most applications will need options or configuration in some form. .NET provides
    built-in support for passing options in many forms, including custom ones, to
    your application when it starts up. These different instances, such as environment
    variables, JSON ( **appsettings.json** ) and XML files, and command-line arguments,
    are all layered on top of one another so that individual settings can be overridden
    as needed. Note that this is different from settings that are altered while the
    application is running, which are more advanced and circumstantial when creating
    APIs, and thus won’t be covered in this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都需要以某种形式提供选项或配置。.NET 提供了内置支持，在应用程序启动时以多种形式（包括自定义形式）传递选项到您的应用程序。这些不同的实例，如环境变量、JSON（**appsettings.json**）和
    XML 文件，以及命令行参数，都是相互叠加的，以便可以根据需要覆盖单个设置。请注意，这与在应用程序运行时更改的设置不同，这些设置在创建 API 时更为高级和具体，因此本书不会涉及。
- en: 'To add support for these options, follow these steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加对这些选项的支持，请按照以下步骤操作：
- en: Add a new class called **MyOptions** , make it **public** , and add a standard
    **string** property called **MyReturnValue** . We’ll use this to control the return
    value of the Function.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 **MyOptions** 的新类，将其设置为 **public**，并添加一个名为 **MyReturnValue** 的标准 **string**
    属性。我们将使用它来控制函数的返回值。
- en: Go ahead and default the property value in the **MyOptions** class to anything
    you like. We’ll override it in the **appsettings.json** file in a moment, and
    change it at startup time during deployment later in this chapter.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **MyOptions** 类中，将属性值默认设置为任何您喜欢的。我们将在稍后的 **appsettings.json** 文件中覆盖它，并在本章后面的部署期间更改它。
- en: Add a new property to the **appsettings.json** file named **MyReturnValue**
    , and a different value than you originally defaulted to in the code.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **appsettings.json** 文件中添加一个名为 **MyReturnValue** 的新属性，并设置一个与代码中默认值不同的值。
- en: Now, we must configure the application so that it can use the configuration
    framework at startup.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们必须配置应用程序，使其能够在启动时使用配置框架。
- en: Modify **.ConfigureServices** in **Program.cs** to add an additional argument
    to the **context** Lambda. Add calls to **.AddOptions<MyOptions>** to the services
    variable, or chain them onto the end of **.ConfigureFunctionsApplicationInsights**
    . Chain a call after **.AddOptions** to **.BindConfiguration** , taking an empty
    string. This binds values in the root configuration path to matching property
    names in the **MyOptions** class.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Program.cs** 中的 **.ConfigureServices** 中修改，向 **context** Lambda 添加一个额外的参数。将调用
    **.AddOptions<MyOptions>** 添加到服务变量中，或者将其链接到 **.ConfigureFunctionsApplicationInsights**
    的末尾。在 **.AddOptions** 后链接着调用 **.BindConfiguration**，并传入一个空字符串。这将绑定根配置路径中的值到 **MyOptions**
    类中匹配的属性名称。
- en: 'The **Program.cs** file should look this:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Program.cs** 文件应该看起来像这样：'
- en: '[PRE0]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The **MyOptions.cs** file should look like this:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**MyOptions.cs** 文件应该看起来像这样：'
- en: '[PRE1]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Modify **Function1.cs** so that it includes **IOptions<MyOptions>** in the constructor,
    then save a reference to that as a class member. Have **OkObjectResult** return
    **_options.Value.MyReturnProperty** so that we can see values changing.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改**Function1.cs**文件，使其构造函数中包含**IOptions<MyOptions>**，然后将其作为类成员保存引用。让**OkObjectResult**返回**_options.Value.MyReturnProperty**，这样我们就能看到值的变化。
- en: 'The **Function1.cs** file should look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Function1.cs**文件应如下所示：'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Test this out by running it. You should see the standard output console window
    with some informational Function messages including the visible routes. Hold *Ctrl*
    and click (on Windows) to run them in your browser, or use any standard HTTP software.
    You should see your hard-coded string as output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行它来测试。你应该会看到标准输出控制台窗口，其中包含一些包含可见路由的信息性函数消息。在Windows上，按住*Ctrl*键并点击（在浏览器中运行），或者使用任何标准的HTTP软件。你应该会看到作为输出的硬编码字符串：
- en: '![Figure 6.8 – Expected output in the browser](img/B21988_06_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 浏览器中的预期输出](img/B21988_06_08.jpg)'
- en: Figure 6.8 – Expected output in the browser
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 浏览器中的预期输出
- en: Congratulations! Not only is your Function running, but it’s been set up so
    that its values can be altered at deployment time. Now, let’s learn how to route
    incoming requests to different sections of code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你的函数不仅正在运行，而且已经设置好，可以在部署时更改其值。现在，让我们学习如何将传入的请求路由到不同的代码部分。
- en: Routing
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: You’ll almost certainly need multiple routes in your Function API, including
    routing parameters, query parameters, and so on. This forms part of the “shape”
    or public contract of your API. Routing supports this concept. If you’re familiar
    with ASP.NET Core routes, then you’ll be right at home as they’re also supported,
    including constraints.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎肯定需要在你的函数API中使用多个路由，包括路由参数、查询参数等。这构成了你API的“形状”或公共契约的一部分。路由支持这个概念。如果你熟悉ASP.NET
    Core路由，那么你会感到非常自在，因为它们也得到了支持，包括约束。
- en: 'How do different requests know where to enter into your application? How should
    you describe what types of data should be allowed to be processed? Let’s start
    with a classic storefront products endpoint:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的请求如何知道进入你的应用程序的入口点？你应该如何描述允许处理的数据类型？让我们从一个经典的店面产品端点开始：
- en: Duplicate **Function1.cs** and rename it **Products.cs** , ensuring that you
    include all the references to **Function1** in it.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**Function1.cs**并将其重命名为**Products.cs**，确保在其中包含所有对**Function1**的引用。
- en: Add **string category** and an **int id** parameter to the **Run** method.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Run**方法中添加**string category**和**int id**参数。
- en: Instead of returning a string in **OkObjectResult** , return an anonymous object
    containing **category** and **id** so that we can see the values that are passed
    in from the route.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**OkObjectResult**中返回字符串而不是返回匿名对象，该对象包含**category**和**id**，这样我们就能看到从路由传递过来的值。
- en: 'The **Product.cs** file should look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Product.cs**文件应如下所示：'
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note the new **Route** property in the **HttpTrigger** attribute, **"products/{category:alpha}/{id:int?}"**
    . This allows us to customize, restrict, and parse out the arguments from the
    desired endpoint. Since these route designs will likely be part of a larger web
    API for third-party consumers to use, you’ll want to take care in creating them.
    You know that the product ID must be numeric, but you may want to restrict the
    category so that it only contains letters. When implemented as a route template,
    it would look like the one we mentioned previously: **"products/{category:alpha}/{id:int?}"**
    . This will only match incoming requests that have your desired URI segments in
    the specified format. The question mark ( **?** ) denotes that the specified parameter
    is optional, and can be defaulted in the method parameters.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**HttpTrigger**属性中的新**Route**属性，**"products/{category:alpha}/{id:int?}"**。这允许我们自定义、限制并解析出所需端点的参数。由于这些路由设计可能将成为一个更大的第三方消费者使用的Web
    API的一部分，因此你想要在创建它们时格外小心。你知道产品ID必须是数字，但你可能想要限制类别，使其只包含字母。当作为路由模板实现时，它将看起来像我们之前提到的：**"products/{category:alpha}/{id:int?}"**。这将只匹配具有指定格式的URI段的传入请求。问号（**?**）表示指定的参数是可选的，可以在方法参数中默认设置。
- en: 'Did you notice that *Figure 6* *.8* had the **api** URL segment prefixed to
    it when it wasn’t specified in the route? Where does this prefix come from? By
    default, **api** is the default prefix for Functions. This can be changed in the
    **host.json** file under the **extensions** > http > **routePrefix** setting:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到图 6.8 在没有指定路由时，其 **api** URL 段被添加了吗？这个前缀从哪里来？默认情况下，**api** 是函数的默认前缀。这可以在
    **host.json** 文件中的 **extensions** > http > **routePrefix** 设置中更改：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: More details on overriding settings after deployment can be found in the *Post-deployment*
    *reconfiguration* section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于部署后覆盖设置的更多详细信息，请参阅 *Post-deployment* *reconfiguration* 部分。
- en: Now, let’s create the necessary Azure cloud resources and environment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建必要的 Azure 云资源和环境。
- en: Deploying
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: First, we need to create some resources before we can view them in Visual Studio.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一些资源，然后我们才能在 Visual Studio 中查看它们。
- en: Azure resource creation
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 资源创建
- en: 'Let’s deploy your Function to production! To do so, create a new **Consumption
    Linux Function** and follow these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们部署你的函数到生产环境！为此，创建一个新的 **消费 Linux 函数** 并按照以下步骤操作：
- en: 'Go to [https://portal.azure.com](https://portal.azure.com) and create a new
    resource group if you don’t have one already:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://portal.azure.com](https://portal.azure.com) 并创建一个新的资源组，如果你还没有的话：
- en: '![Figure 6.9 – Creating a new resource group](img/B21988_06_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 创建新的资源组](img/B21988_06_09.jpg)'
- en: Figure 6.9 – Creating a new resource group
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 创建新的资源组
- en: 'Place it in an Azure region geographically close to you. We’ll use this same
    region when we create other resources to minimize lag and potential bandwidth.
    Click on the **Review + create** tab, then **Create** :'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将其放置在你地理位置附近的一个 Azure 区域。当我们创建其他资源时，我们将使用相同的区域以最小化延迟和潜在带宽。点击 **审查 + 创建** 选项卡，然后点击
    **创建**：
- en: '![Figure 6.10 – Successfully creating a new resource group](img/B21988_06_10.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 成功创建新的资源组](img/B21988_06_10.jpg)'
- en: Figure 6.10 – Successfully creating a new resource group
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 成功创建新的资源组
- en: 'Inside this resource group, create a new Function app:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此资源组内创建一个新的函数应用：
- en: '![Figure 6.11 – Creating a new resource inside the resource group](img/B21988_06_11.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 在资源组内创建新的资源](img/B21988_06_11.jpg)'
- en: Figure 6.11 – Creating a new resource inside the resource group
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 在资源组内创建新的资源
- en: 'Search for **function** if you don’t see it in the default selection. Select
    **Create** | **Function App** to continue:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有在默认选择中看到 **函数**，请搜索它。选择 **创建** | **函数应用** 以继续：
- en: '![Figure 6.12 – Selecting Function App as the resource to create](img/B21988_06_12.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 选择函数应用作为要创建的资源](img/B21988_06_12.jpg)'
- en: Figure 6.12 – Selecting Function App as the resource to create
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 选择函数应用作为要创建的资源
- en: 'Next, select **Consumption** as your hosting option:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择 **消费** 作为你的托管选项：
- en: '![Figure 6.13 – Function hosting configuration](img/B21988_06_13.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 函数托管配置](img/B21988_06_13.jpg)'
- en: Figure 6.13 – Function hosting configuration
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 函数托管配置
- en: 'Select **.NET** for **Runtime stack** , **8 (LTS), isolated worker model**
    for **Version** , and **Linux** for **Operating system** . Select the region that
    you selected when you created the resource group and click **Next** :'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **.NET** 作为 **运行时堆栈**，**8 (LTS)，隔离工作模型** 作为 **版本**，以及 **Linux** 作为 **操作系统**。选择你创建资源组时选择的区域，然后点击
    **下一步**：
- en: '![Figure 6.14 – Function details](img/B21988_06_14.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 函数详细信息](img/B21988_06_14.jpg)'
- en: Figure 6.14 – Function details
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 函数详细信息
- en: 'A **storage account** resource will also need to be created to hold various
    things for the Function runtime, including logs, your deployment package, and
    optionally the Durable state, something we’ll discuss in the next chapter. Disable
    **Blob service diagnostic settings** for now:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要创建一个 **存储账户** 资源来存储函数运行时所需的各种东西，包括日志、你的部署包，以及可选的 Durable 状态，我们将在下一章中讨论。现在，禁用
    **Blob 服务诊断设置**：
- en: '![Figure 6.15 – Storage configuration](img/B21988_06_15.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 存储配置](img/B21988_06_15.jpg)'
- en: Figure 6.15 – Storage configuration
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 存储配置
- en: 'Enable **public access** . Then, choose **No** for **Enable** **Application
    Insights** :'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 **公共访问**。然后，选择 **否** 对于 **启用** **应用程序洞察**：
- en: '![Figure 6.16 – Application Insights creation](img/B21988_06_16.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 创建应用程序洞察](img/B21988_06_16.jpg)'
- en: Figure 6.16 – Application Insights creation
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 创建应用程序洞察
- en: Disable **continuous deployment** , an aspect that will also be covered in [*Chapter
    10*](B21998_10.xhtml#_idTextAnchor136) . We can use **Tags** to filter or group
    resources, and so on. Add tags if desired, or leave this section empty and click
    **Review + create** . Review your settings; if everything looks good, click **Create**
    .
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用**持续部署**，这也是第[*第10章*](B21998_10.xhtml#_idTextAnchor136)中将要讨论的内容。我们可以使用**标签**来过滤或分组资源等。如有需要，请添加标签，或者保持此部分为空并点击**审查
    + 创建**。审查您的设置；如果一切看起来都很好，请点击**创建**。
- en: At this point, the deployment process will continue. Click **Go to resource**
    ; you’ll be taken to your brand new Function!
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，部署过程将继续。点击**转到资源**；您将被带到您全新的函数！
- en: '![Figure 6.17 – Portal overview blade for your Azure Function](img/B21988_06_17.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17 – Azure函数的门户概览选项卡](img/B21988_06_17.jpg)'
- en: Figure 6.17 – Portal overview blade for your Azure Function
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – Azure函数的门户概览选项卡
- en: 'Click on the URL listed on the right-hand side. You’ll be taken to a default
    page indicating that your Function is running:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右侧列出的URL。您将被带到默认页面，表明您的函数正在运行：
- en: "![Figure 6.18 – Default Azure Functions landing page\uFEFF](img/B21988_06_18.jpg)"
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18 – 默认Azure函数登录页面](img/B21988_06_18.jpg)'
- en: Figure 6.18 – Default Azure Functions landing page
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 默认Azure函数登录页面
- en: Tip
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: While these steps and screenshots are accurate at the time of writing, Azure
    often changes and upgrades its design, features, flow, and so on. It’s recommended
    that you check out the official documentation for updated guidance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些步骤和截图在写作时是准确的，但Azure经常更改和升级其设计、功能、流程等。建议您查看官方文档以获取最新指南。
- en: Now that the Function resource is running with a default template, let’s deploy
    from Visual Studio.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数资源正在使用默认模板运行，让我们从Visual Studio进行部署。
- en: Publishing from Visual Studio
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Visual Studio发布
- en: 'Let’s walk through deploying manually from Visual Studio. Automated deployments,
    also known as continuous delivery, will be covered in [*Chapter 10*](B21998_10.xhtml#_idTextAnchor136)
    :'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们手动从Visual Studio进行部署。自动化部署，也称为持续交付，将在[*第10章*](B21998_10.xhtml#_idTextAnchor136)中讨论：
- en: 'Back in **Visual Studio** , right-click on the **FunctionsChapter6** project
    and select **Publish…** :'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Visual Studio**中，右键单击**FunctionsChapter6**项目并选择**发布…**：
- en: '![Figure 6.19 – Publishing our project](img/B21988_06_19.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图6.19 – 发布我们的项目](img/B21988_06_19.jpg)'
- en: Figure 6.19 – Publishing our project
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – 发布我们的项目
- en: 'Then, select **Azure** and click **Next** :'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**Azure**并点击**下一步**：
- en: '![Figure 6.20 – Types of publishing](img/B21988_06_20.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图6.20 – 发布类型](img/B21988_06_20.jpg)'
- en: Figure 6.20 – Types of publishing
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 – 发布类型
- en: 'Select **Azure Function App (Linux)** and click **Next** :'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Azure Function App (Linux**)并点击**下一步**：
- en: '![Figure 6.21 – Azure publishing targets](img/B21988_06_21.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图6.21 – Azure发布目标](img/B21988_06_21.jpg)'
- en: Figure 6.21 – Azure publishing targets
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 – Azure发布目标
- en: 'Select the **Microsoft account** and **subscription** you created the Function
    resource under. Search or locate your Function by name, select it, and click **Finish**
    :'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建函数资源时使用的**Microsoft帐户**和**订阅**。通过名称搜索或定位您的函数，选择它，然后点击**完成**：
- en: '![Figure 6.22 – Selecting the account, subscription, and resource to publish
    to](img/B21988_06_22.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图6.22 – 选择要发布的帐户、订阅和资源](img/B21988_06_22.jpg)'
- en: Figure 6.22 – Selecting the account, subscription, and resource to publish to
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 – 选择要发布的帐户、订阅和资源
- en: 'Click **Finish** , then **Close** when you’re done. Details about your published
    profile will appear, including its **Configuration** and **Target Runtime** ,
    as well as any dependencies that it needs:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**，完成后点击**关闭**。您的发布配置文件详情将出现，包括其**配置**和**目标运行时**，以及它需要的任何依赖项：
- en: '![Figure 6.23 – Function publish profile](img/B21988_06_23.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图6.23 – 函数发布配置文件](img/B21988_06_23.jpg)'
- en: Figure 6.23 – Function publish profile
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23 – 函数发布配置文件
- en: When you’re ready, click **Publish** . Once that succeeds, you can view your
    new API route at https://<my resource name>.azurewebsites.net/api/products/electronics/471337.
    Note that you can see the default data if you go to https://<my resource name>.azurewebsites.net/api/Function
    .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好时，点击**发布**。一旦成功，您可以在 https://<我的资源名称>.azurewebsites.net/api/products/electronics/471337
    查看您的新API路由。请注意，如果您访问 https://<我的资源名称>.azurewebsites.net/api/Function，您可以看到默认数据。
- en: As mentioned previously in this chapter, we’ll now look at changing a configuration
    value without recompiling the Function, and without redeploying it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章先前所述，我们现在将探讨在不重新编译函数和不重新部署的情况下更改配置值。
- en: Post-deployment reconfiguration
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署后重新配置
- en: 'Now, let’s change the configuration to a different value:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将配置更改为不同的值：
- en: 'In the **Environment variables** blade, under the **Settings** section of the
    Function resource in the Azure portal, create a new key to override the setting
    we hard-coded earlier. Use **MyReturnProperty** as the key since we’re reading
    the configuration variables from the root namespace:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Azure门户中函数资源的**设置**部分下的**环境变量**标签页中，创建一个新的键来覆盖我们之前硬编码的设置。使用**MyReturnProperty**作为键，因为我们是从根命名空间读取配置变量：
- en: '![Figure 6.24 - Adding a new environment variable to override a setting](img/B21988_06_24.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图6.24 - 添加新的环境变量以覆盖设置](img/B21988_06_24.jpg)'
- en: Figure 6.24 - Adding a new environment variable to override a setting
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24 - 添加新的环境变量以覆盖设置
- en: '**Apply** this addition, **Apply** the changes, and **Confirm** the save; your
    Function application will be restarted. Navigate to https://<my resource name>.azurewebsites.net/api/Function1
    so that you can see the new configuration value:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用**这个添加，**应用**更改，并**确认**保存；你的函数应用将被重新启动。导航到 https://<我的资源名称>.azurewebsites.net/api/Function1，以便您可以看到新的配置值：'
- en: '![Figure 6.25 – Overridden configuration value](img/B21988_06_25.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图6.25 – 覆盖的配置值](img/B21988_06_25.jpg)'
- en: Figure 6.25 – Overridden configuration value
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 – 覆盖的配置值
- en: This can be nested arbitrarily deep. For example, if your **MyOptions** class’s
    **MyReturnValue** was a complex type with its own **MyOtherReturnValue** property,
    the path for the key in Azure would be **MyReturnValue__MyOtherReturnValue** .
    Note that there are two underscores between the property names.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以任意深度嵌套。例如，如果您的**MyOptions**类的**MyReturnValue**是一个具有自己的**MyOtherReturnValue**属性的复杂类型，Azure中的键路径将是**MyReturnValue__MyOtherReturnValue**。请注意，属性名之间有两个下划线。
- en: Since this is publicly accessible, it has the potential to cost you money if
    a rogue process becomes aware of your new endpoint. Securing this new site with
    what’s colloquially known as **Easy Auth** will be discussed later in this book.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是公开可访问的，如果恶意进程意识到您的新端点，这可能会让您付出金钱。在本书的后面部分将讨论如何使用俗称的**简易认证**来保护这个新网站。
- en: But in the meantime, you can adjust some hosting options to limit the potential
    cost.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但与此同时，您可以调整一些托管选项来限制潜在成本。
- en: 'Navigate to **Settings** | **Scale out** and change **Maximum Scale Out Limit**
    to **1** . Then, click **Save** :'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**设置** | **扩展**，并将**最大扩展限制**更改为**1**。然后，点击**保存**：
- en: '![Figure 6.26 – Limiting scale out](img/B21988_06_26.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图6.26 – 限制扩展](img/B21988_06_26.jpg)'
- en: Figure 6.26 – Limiting scale out
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26 – 限制扩展
- en: 'Then, navigate to **Settings** | **Configuration** , change **Daily Usage Quota**
    to **1** , and click **Save** , then **Continue** :'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到**设置** | **配置**，将**每日使用配额**更改为**1**，然后点击**保存**，接着**继续**：
- en: '![Figure 6.27 – Adding a daily quota](img/B21988_06_27.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图6.27 – 添加每日配额](img/B21988_06_27.jpg)'
- en: Figure 6.27 – Adding a daily quota
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27 – 添加每日配额
- en: At this point, while you haven’t secured your site against bots or malicious
    actors, you have at least taken a few steps to mitigate any potential damage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，虽然您还没有保护您的网站免受机器人或恶意行为者的攻击，但您至少已经采取了一些措施来减轻任何潜在损害。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked through creating multiple HTTP endpoints inside a
    single Azure Function, adding a route template to assist with managing differing
    URI segments at runtime. Then, we added configuration options to our project,
    deployed it to Azure, and adjusted the configuration options after deployment.
    To limit the potential cost of a deployed, live HTTP endpoint, we adjusted two
    settings until authorization was in place.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在单个Azure函数内创建多个HTTP端点，添加路由模板以帮助在运行时管理不同的URI段。然后，我们将配置选项添加到我们的项目中，将其部署到Azure，并在部署后调整配置选项。为了限制已部署的实时HTTP端点的潜在成本，我们调整了两个设置，直到授权就绪。
- en: Now that you understand how HTTP triggers work in Azure Functions, in the next
    chapter, we’ll explore other types of triggers we can use to build reliable, stateful,
    and scalable workflows.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Azure函数中HTTP触发器的工作原理，在下一章中，我们将探讨我们可以使用的其他类型的触发器，以构建可靠、有状态和可扩展的工作流程。
- en: You try it
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你试试看
- en: Write an API using Azure Functions, create a Function resource in Azure, and
    then deploy your Function to it with Visual Studio.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure Functions编写API，在Azure中创建一个函数资源，然后使用Visual Studio将其部署到该资源。
