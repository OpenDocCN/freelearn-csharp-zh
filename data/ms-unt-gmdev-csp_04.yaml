- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Writing Clean and Modular C# Code for Unity Game Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Unity游戏开发编写干净和模块化的C#代码
- en: Welcome to [*Chapter 2*](B22017_02.xhtml#_idTextAnchor028), where we focus on
    the importance of clean and modular C# code for Unity game development. In the
    next pages, you’ll learn practical skills to write clear and efficient code. We’ll
    cover clean code principles, stress the significance of readability, and introduce
    industry best practices. You’ll also explore conventions and code structuring
    for smoother collaboration. Additionally, we’ll delve into refactoring and optimization
    techniques to enhance your C# code’s performance and scalability. By the end of
    this chapter, you’ll have the expertise to write, document, refactor, and optimize
    C# code effectively, laying a solid foundation for successful Unity game development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第二章*](B22017_02.xhtml#_idTextAnchor028)，我们将重点介绍为Unity游戏开发编写干净和模块化C#代码的重要性。在接下来的页面中，您将学习编写清晰和高效代码的实用技能。我们将涵盖干净代码原则，强调可读性的重要性，并介绍行业最佳实践。您还将探索协作的约定和代码结构。此外，我们将深入研究重构和优化技术，以增强您的C#代码的性能和可扩展性。到本章结束时，您将具备有效地编写、文档化、重构和优化C#代码的专业知识，为成功的Unity游戏开发打下坚实的基础。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to writing clean code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写干净代码的介绍
- en: C# code conventions and readability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#代码约定和可读性
- en: C# code refactoring and optimization techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#代码重构和优化技术
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following to follow along with me in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随我在本章中的学习，您需要以下内容：
- en: '**Unity version 2022.3.13**: Download and install Unity version 2022.3.13 or
    any other version. It is recommended to install the 2022 version.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity版本2022.3.13**: 下载并安装Unity版本2022.3.13或任何其他版本。建议安装2022版本。'
- en: '**Primary IDE – Visual Studio 2022**: Ensure Visual Studio 2022 is installed
    for optimal learning.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要IDE – Visual Studio 2022**: 确保已安装Visual Studio 2022以获得最佳学习体验。'
- en: '**GitHub repository for code samples**: Access the code samples and project
    files of this chapter from our GitHub repository: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002).
    Clone or download the repository to have easy access to the code demonstrated
    in this chapter.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码样本的GitHub仓库**: 您可以从我们的GitHub仓库访问本章的代码样本和项目文件：[https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2002)。克隆或下载仓库，以便轻松访问本章中展示的代码。'
- en: Introduction to writing clean code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写干净代码的介绍
- en: Clean code refers to well-organized, readable, and easy-to-understand code.
    It’s like writing a clear story that anyone can follow without getting lost in
    confusing jargon or messy paragraphs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 干净代码指的是组织良好、易于阅读和理解的代码。它就像写一个清晰的故事，任何人都可以跟随而不会迷失在令人困惑的术语或混乱的段落中。
- en: 'In software development, clean code matters a lot. First, it makes the code
    easier for everyone in the team to grasp, helping them work together smoothly.
    Second, it saves time because clean code is simpler to fix when something goes
    wrong. Lastly, it’s like having a clean room – it just feels better and is easier
    to manage in the long run. In this list, we highlight the significance of employing
    clean code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，干净代码非常重要。首先，它使团队中的每个人都更容易理解代码，帮助他们顺利合作。其次，它节省了时间，因为当出现问题需要修复时，干净代码更简单。最后，它就像有一个干净的房间——它感觉更好，并且从长远来看更容易管理。在这个列表中，我们强调了采用干净代码的重要性：
- en: '**Building AAA games**: Have you come across “the power of clean code” on your
    coding journey? Well, it’s like the secret sauce for cooking up high-quality code,
    especially when you’re aiming to create top-notch AAA games. Clean code is the
    key ingredient for building games that stand out in the industry.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建AAA游戏**: 在您的编码之旅中是否遇到过“干净代码的力量”？好吧，它就像是烹饪高质量代码的秘密酱料，尤其是在您致力于创建顶级AAA游戏时。干净代码是构建在行业中脱颖而出的游戏的关键成分。'
- en: '**Working with others**: In the world of coding, we’re never alone. Whether
    you’re part of a company with high standards or collaborating on a project, the
    clean code mentality is your silent companion. You might not realize you’re using
    it, but with a bit of knowledge, you can rock the industry by making your code
    clear and understandable for everyone on the team.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与他人合作**：在编码的世界里，我们永远不会孤单。无论你是公司中高标准的一部分，还是在项目上进行合作，清晰的代码心态是你的无声伴侣。你可能没有意识到你正在使用它，但只要有一点知识，你就可以通过使你的代码对团队中的每个人来说都清晰易懂，来在行业中脱颖而出。'
- en: '**Flexibility in applying clean code**: The goal of this chapter isn’t to force
    you to use all these clean code principles every single time. Sometimes you need
    to dive into coding first and then tidy up later. These aren’t strict rules; they’re
    more like tools you can pull out when needed. If a feature is familiar, and you
    know how to implement it with principles such as SOLID, go for it. But if you’re
    unsure, start with the basics and refine your code so you gain a clearer picture
    of what’s needed.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在应用清晰代码时的灵活性**：本章的目标不是强迫你在每次都使用所有这些清晰的代码原则。有时你需要先进行编码，然后再进行整理。这些不是严格的规则；它们更像是在需要时可以取出的工具。如果一个功能很熟悉，你知道如何使用SOLID等原则来实现它，那就去做吧。但如果你不确定，从基础开始，完善你的代码，以便你能够更清楚地了解需要什么。'
- en: '**Every coder’s struggle**: Picture this: you’re tired of the endless coding
    and updates, facing issues as you go. Changing a feature becomes a headache, especially
    when the code turns into a messy puzzle. Dealing with testers feels like a never-ending
    loop of modifications. If this sounds familiar, you’re not alone. This chapter
    is your guide to overcoming the struggles of code maintenance and updates.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个程序员的挣扎**：想象一下：你厌倦了无休止的编码和更新，在编码过程中遇到问题。更改一个功能变成了一场头痛，尤其是当代码变成一个混乱的拼图时。与测试人员打交道就像是一个永无止境的修改循环。如果这听起来很熟悉，你并不孤单。本章将指导你克服代码维护和更新的挑战。'
- en: '**Code that tells a story**: Ever written a piece of code and then completely
    forgotten what it was for? It happens to the best of us. This chapter is here
    to teach you how to write code that tells a story – a story that’s clear and easy
    to follow and won’t leave you scratching your head later.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**讲述故事的代码**：有没有编写过一段代码，然后完全忘记了它的用途？这种情况发生在我们所有人身上。本章旨在教你如何编写讲述故事的代码——一个清晰易懂、易于跟随的故事，不会让你在以后挠头。'
- en: '**Modularity and efficiency tips**: Get ready for some tips and tricks on how
    to make your code modular and efficient. I’ll walk you through general principles
    and show you how to apply them in real-world scenarios. Plus, we’ll dive into
    examples – messy code versus clean code – for each clean code principle, giving
    you a practical understanding of how to implement these ideas in your own projects.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化和效率技巧**：准备好一些关于如何使你的代码模块化和高效的技巧和窍门。我将带你了解一些基本原则，并展示如何在现实场景中应用它们。此外，我们将深入研究示例——混乱的代码与清晰的代码——对于每个清晰的代码原则，给你一个在实际项目中实施这些想法的实际理解。'
- en: Clean code is essential for building better software. By understanding its importance,
    you’ll be better equipped to write code that’s clear, understandable, and effective.
    In the next section, we will understand the principles of writing clean code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰的代码对于构建更好的软件至关重要。通过理解其重要性，你将更好地装备自己，以编写清晰、易懂和有效的代码。在下一节中，我们将了解编写清晰代码的原则。
- en: Principles of writing clean code
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写清晰代码的原则
- en: 'In the world of **object-oriented programming** (**OOP**), clean code thrives
    on a foundation of five key principles known as **SOLID**. These principles act
    as guiding lights, helping us write code that’s not just functional but also the
    following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（**OOP**）的世界里，清晰的代码建立在五个关键原则的基础上，被称为**SOLID**。这些原则作为指导灯，帮助我们编写不仅功能性强，而且以下方面的代码：
- en: '**Easy to read and understand**: Anyone who picks up your code should be able
    to grasp its purpose and logic without too much effort'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于阅读和理解**：任何拿起你的代码的人都应该能够不费太多力气就理解其目的和逻辑。'
- en: '**Maintainable**: Modifications and updates should be a breeze, even for someone
    unfamiliar with the code’s history'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：修改和更新应该变得轻而易举，即使是对代码历史不熟悉的人也是如此。'
- en: '**Extendable and reusable**: Building on existing code should be straightforward,
    promoting code reuse and reducing redundancy'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和可重用性**：在现有代码的基础上构建应该是直截了当的，促进代码重用，减少冗余。'
- en: Let me tell you a story. Before I discovered SOLID principles, I often found
    myself struggling to figure out how to build features. Reaching the finish line
    felt like a messy, chaotic journey. Then, SOLID came along and changed everything.
    It was like a map, helping me organize my thoughts and code into a clear, structured
    path.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你讲一个故事。在我发现SOLID原则之前，我经常发现自己很难想出如何构建功能。到达终点就像一场混乱、杂乱无章的旅程。然后，SOLID原则出现了，一切都变了。它就像一张地图，帮助我把思想和代码组织成清晰、结构化的路径。
- en: But SOLID wasn’t just a clean code tool; it empowered me to become a better
    problem solver. It shifted my mindset from a “try hard” approach to a “create
    solutions” approach. I went from someone who wrestled with code to someone who
    crafted elegant solutions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但SOLID不仅仅是一个编写干净代码的工具；它赋予了我成为一个更好的问题解决者的能力。它将我的思维方式从“努力尝试”转变为“创造解决方案”。我从与代码搏斗的人变成了创造优雅解决方案的人。
- en: As software developers, our job is to solve problems. SOLID becomes your secret
    weapon in this battle. It provides the framework to tackle most challenges you’ll
    encounter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发者，我们的工作是解决问题。SOLID成为你在这一战斗中的秘密武器。它为你提供了应对大多数挑战的框架。
- en: However, simply reading about SOLID isn’t enough. True learning comes from applying
    it yourself. Grab your existing code and dive in! Experiment with incorporating
    SOLID principles and see how they transform your work. Trust me, the hands-on
    experience will solidify your understanding and unlock a whole new level of development
    mastery.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅阅读关于SOLID的内容是不够的。真正的学习来自于自己应用它。拿起你现有的代码，深入其中！尝试将SOLID原则融入其中，看看它们如何改变你的工作。相信我，实践的经验将巩固你的理解，并解锁全新的开发技能层次。
- en: Single Responsibility Principle (SRP)
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: Let’s discuss the **Single Responsibility Principle** (**SRP**) in the context
    of game development. The SRP suggests that a class should have only one reason
    to change, meaning it should only have one responsibility. In the gaming world,
    this translates to ensuring that each component or class is responsible for a
    single aspect of the game, making the code base more modular and maintainable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下在游戏开发背景下**单一职责原则**（**SRP**）。SRP建议一个类应该只有一个改变的理由，这意味着它应该只有一个责任。在游戏世界中，这转化为确保每个组件或类只负责游戏的一个方面，使代码库更加模块化和易于维护。
- en: When we begin coding, it’s common to stuff all the logic into one massive class
    that takes on many jobs. It gets tricky trying to fix one issue without messing
    up other things in that class or introducing new logic that ends up making other
    sections act strangely.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编码时，通常会将所有逻辑都塞进一个承担许多工作的巨大类中。试图修复一个问题而不会弄乱该类中的其他事物或引入最终导致其他部分行为异常的新逻辑，这变得很棘手。
- en: Let’s start with an example of a player controller script that combines various
    responsibilities and then refactor it to adhere to the SRP.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从玩家控制器脚本的一个例子开始，它结合了各种责任，然后重构它以符合SRP。
- en: 'In the following code block, we can see the old `PlayerController` class, which
    has many responsibilities:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到旧的`PlayerController`类，它承担了许多责任：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s break down the big class into smaller classes, each with its own set of
    actions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个大类拆分成更小的类，每个类都有自己的动作集。
- en: 'In the following code block, we can see the `PlayerAnimation` class, which
    is responsible for handling player animations:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到负责处理玩家动画的`PlayerAnimation`类：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the following code block, we can see the `PlayerMovement` class, which is
    responsible for handling player movement, and the `PlayerInput` class, which is
    responsible for handling player input:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`PlayerMovement`类，它负责处理玩家移动，以及`PlayerInput`类，它负责处理玩家输入：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the following code block, we can see the `PlayerController` class acting
    as the orchestrator, delegating responsibilities:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`PlayerController`类作为协调者，委托责任：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this simplified version of the `PlayerController` class, we have separate
    classes for movement, input handling, and animations, making `PlayerController`
    more focused and adhering to the SRP. Each class handles its specific responsibility,
    enhancing code organization and clarity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayerController`类的这个简化版本中，我们为移动、输入处理和动画分别创建了类，使`PlayerController`更加专注，并符合SRP。每个类处理其特定的责任，增强了代码的组织性和清晰度。
- en: Open-Closed Principle (OCP)
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放-封闭原则（OCP）
- en: Let’s explore the **Open-Closed Principle** (**OCP**) in the context of game
    development. The OCP promotes the idea that a class should be open for extension
    while remaining closed for modification. In the context of game development, this
    implies the ability to introduce new features or functionalities without making
    changes to the existing code. This principle plays a crucial role in enhancing
    code flexibility and maintainability, allowing for the seamless addition of new
    elements to the game without disrupting the established framework.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨在游戏开发背景下**开放封闭原则**（**OCP**）。OCP提倡一个类应该对扩展开放，同时对修改封闭。在游戏开发的背景下，这意味着能够在不修改现有代码的情况下引入新的功能或功能。这个原则在增强代码灵活性和可维护性方面发挥着关键作用，允许无缝地添加新元素到游戏中，而不会破坏现有的框架。
- en: An example of the *power-up dilemma* is as follows.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**增强功能困境**的一个例子如下。'
- en: Imagine you have a basic power-up system in your game that grants bonus points.
    Using the OCP, you can create a base `PowerUp` class with common functionalities
    such as activation and duration. Then, you can create subclasses for different
    specific power-ups, such as double jump or temporary invincibility.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在你的游戏中有一个基本的增强功能系统，可以增加分数。使用OCP，你可以创建一个具有常见功能的基础`PowerUp`类，例如激活和持续时间。然后，你可以为不同的特定增强功能创建子类，例如双跳或临时无敌。
- en: This way, adding a new power-up involves creating a new subclass without modifying
    the existing code. You’re not stuck with a rigid system – the possibilities are
    endless!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，添加一个新的功能增强需要创建一个新的子类，而不需要修改现有的代码。你不会陷入一个僵化的系统——可能性是无限的！
- en: OCP allows you to build games that are flexible, adaptable, and maintainable.
    It’s like having a well-designed construction set, letting you create and expand
    your game world without limits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: OCP允许你构建灵活、适应性强、易于维护的游戏。这就像拥有一个设计精良的构建套件，让你可以无限制地创建和扩展你的游戏世界。
- en: 'In the following code block, we can see the base `PowerUp` class with common
    functionalities:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到具有常见功能的基础`PowerUp`类：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the following code block, we can see the subclass for `DoubleJumpPowerUp`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`DoubleJumpPowerUp`的子类：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following code block, we can see the subclass for `TemporaryInvincibilityPowerUp`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`TemporaryInvincibilityPowerUp`的子类：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the following code block, we can see the `PowerUpManager` class utilizing
    the power-ups:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`PowerUpManager`类正在使用增强功能：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this Unity example, the `PowerUp` class is extended with specific power-ups,
    such as `DoubleJumpPowerUp` and `TemporaryInvincibilityPowerUp`. The `PowerUp`
    **Manager** class demonstrates how to add and remove power-ups, and each power-up
    logs a message upon activation and deactivation. This structure allows for the
    addition of new power-ups without modifying the existing code, following the OCP.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Unity示例中，`PowerUp`类被扩展为特定的增强功能，如`DoubleJumpPowerUp`和`TemporaryInvincibilityPowerUp`。`PowerUp`
    **管理器**类展示了如何添加和移除增强功能，每个增强功能在激活和去激活时都会记录一条消息。这种结构允许在不修改现有代码的情况下添加新的增强功能，遵循OCP。
- en: Now, the fun part begins! We can use this system to connect each power-up subclass
    to its own prefab. When the player grabs a power-up, only the specific power-up
    associated with that prefab activates. This means adding new power-ups is a breeze
    – just create a new subclass and its prefab and voilà! You’ve expanded your game’s
    possibilities without touching the core logic. This principle isn’t just for power-ups,
    though. You can use it for enemies, items, abilities – the sky’s the limit! So,
    go forth and build your awesome game with the power of the OCP!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有趣的部分开始了！我们可以使用这个系统将每个增强功能子类连接到它自己的预制件。当玩家抓取一个增强功能时，只有与该预制件关联的特定增强功能会被激活。这意味着添加新的增强功能变得轻而易举——只需创建一个新的子类和它的预制件，然后就是了！你扩展了游戏的可能性，而没有触及核心逻辑。虽然这个原则不仅仅适用于增强功能，你还可以用它来处理敌人、物品、能力——天空才是极限！所以，勇敢地前进，用OCP的力量构建你的精彩游戏！
- en: Liskov Substitution Principle (LSP)
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Liskov替换原则（LSP）
- en: Let’s explore the **Liskov Substitution Principle** (**LSP**) within the realm
    of game development. The LSP maintains that substituting objects of a superclass
    with objects of a subclass should not disrupt the program’s correctness. In the
    context of game development, this implies that using derived classes (subclasses)
    should seamlessly integrate without compromising the expected functionality of
    the base class. This principle ensures the smooth interchangeability of classes,
    allowing for flexibility and ease of use in game development scenarios.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨游戏开发领域内的**里氏替换原则**（**LSP**）。LSP主张用子类对象替换超类对象不应破坏程序的正确性。在游戏开发的背景下，这意味着使用派生类（子类）应无缝集成，而不损害基类的预期功能。这个原则确保了类之间的平滑可替换性，在游戏开发场景中提供了灵活性和易用性。
- en: An example of the *sneaky enemy dilemma* is as follows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*潜行敌人困境*的一个例子如下。'
- en: 'Imagine you have a base class called `Enemy` with basic movement and attack
    behaviors. You then create two subclasses: `GroundEnemy` and `FlyingEnemy`. The
    LSP ensures that both subclasses behave as expected enemies, moving and attacking
    in ways that comply with the `Enemy` base class’s definition. This means that
    any code designed to work with enemies, such as collision detection or damage
    calculation, will work seamlessly with both `GroundEnemy` and `FlyingEnemy` instances.
    This consistency simplifies development and allows you to focus on creating unique
    behaviors for each subclass without worrying about breaking core functionalities.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`Enemy`的基类，它具有基本的移动和攻击行为。然后你创建了两个子类：`GroundEnemy`和`FlyingEnemy`。LSP确保这两个子类都表现出预期的敌人行为，以符合`Enemy`基类的定义进行移动和攻击。这意味着任何设计用于处理敌人的代码，如碰撞检测或伤害计算，都将无缝地与`GroundEnemy`和`FlyingEnemy`实例一起工作。这种一致性简化了开发，并允许你专注于为每个子类创建独特的行为，而无需担心破坏核心功能。
- en: 'In the following code block, we can see the base class for `Enemy`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`Enemy`类的基类：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the following code block, we can see the subclass for `GroundEnemy`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`GroundEnemy`的子类：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the following code block, we can see the subclass for `FlyingEnemy`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`FlyingEnemy`的子类：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the following code block, we can see the `EnemyManager` class demonstrating
    the LSP:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到演示LSP的`EnemyManager`类：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this Unity example, the `Enemy` class acts as the base class with basic movement
    and attack methods. The `GroundEnemy` and `FlyingEnemy` subclasses extend the
    base class and provide specific implementations for movement and attack. The `EnemyManager`
    class demonstrates the LSP by treating instances of both subclasses as instances
    of the base class, ensuring that code written to work with enemies functions seamlessly
    with both `GroundEnemy` and `FlyingEnemy` instances.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Unity示例中，`Enemy`类作为基类，具有基本的移动和攻击方法。`GroundEnemy`和`FlyingEnemy`子类扩展了基类，并为移动和攻击提供了特定的实现。`EnemyManager`类通过将两个子类的实例都视为基类的实例来演示LSP，确保编写用于处理敌人的代码可以无缝地与`GroundEnemy`和`FlyingEnemy`实例一起工作。
- en: What is the difference between the LSP and OCP?
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LSP（里氏替换原则）和OCP（开闭原则）之间的区别是什么？
- en: In game development, the key difference between the LSP and OCP lies in their
    focus and application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，LSP和OCP之间的关键区别在于它们的关注点和应用。
- en: The LSP ensures that derived classes can be seamlessly substituted for their
    base class without affecting program behavior. In a game, this means different
    types of enemies (e.g., ground and flying enemies) should be interchangeable without
    breaking the expected functionality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: LSP确保派生类可以无缝地替换其基类而不影响程序行为。在游戏中，这意味着不同类型的敌人（例如，地面和飞行敌人）应该是可互换的，而不会破坏预期的功能。
- en: The OCP encourages designing classes that are open for extension but closed
    for modification. In game development, this allows adding new features (e.g.,
    new types of weapons) without altering existing code, promoting flexibility and
    maintainability.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: OCP鼓励设计那些对扩展开放但对修改关闭的类。在游戏开发中，这允许在不更改现有代码的情况下添加新功能（例如，新类型的武器），从而促进灵活性和可维护性。
- en: To better illustrate their difference, here’s an example. In a game system,
    consider a base class for weapons. Adhering to the LSP allows substituting specific
    weapon types without disrupting expected behaviors, while following the OCP enables
    extending the system to add new weapons without modifying existing code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明它们的区别，这里有一个例子。在一个游戏系统中，考虑一个武器的基础类。遵循LSP允许在不破坏预期行为的情况下替换特定的武器类型，而遵循OCP则允许在不修改现有代码的情况下扩展系统以添加新的武器。
- en: Interface Segregation Principle (ISP)
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则 (ISP)
- en: Now, let’s talk about the **Interface Segregation Principle** (**ISP**) in the
    gaming world. The ISP suggests that a class shouldn’t be required to do things
    it doesn’t need to. Simply put, it encourages creating small, task-specific interfaces
    instead of big, general ones. In the context of game development, this means designing
    interfaces that suit each class’s specific needs. This helps keep things clear,
    makes the code more focused, and allows for easier upkeep and changes in game
    development.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈游戏世界中的**接口隔离原则**（**ISP**）。ISP建议一个类不应该被要求去做它不需要做的事情。简单来说，它鼓励创建小型的、任务特定的接口，而不是大型的、通用的接口。在游戏开发的情况下，这意味着设计适合每个类特定需求的接口。这有助于保持事情清晰，使代码更加专注，并允许在游戏开发中更容易地进行维护和更改。
- en: Let’s see an example of the NPC interfaces dilemma.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看NPC接口困境的一个例子。
- en: Imagine you have NPCs in your game, each with various functionalities, such
    as wandering, talking, and trading. Applying the ISP ensures that each NPC only
    needs to implement interfaces relevant to its specific behaviors, avoiding unnecessary
    methods.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在你的游戏中，每个NPC都有各种功能，比如漫步、交谈和交易。应用ISP确保每个NPC只需要实现与其特定行为相关的接口，避免不必要的函数。
- en: '*Without the ISP*, in the following code block, we can see the `INPC` interface,
    which has general methods for all NPCs, with the `FriendlyNPC` and `AggressiveNPC`
    classes, which implement `INPC`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有ISP*，在下面的代码块中，我们可以看到`INPC`接口，它为所有NPC提供了通用方法，以及`FriendlyNPC`和`AggressiveNPC`类，它们实现了`INPC`：'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*With the ISP*, in the following code block, we will separate interfaces based
    on functionality, with the `FriendlyNPC` and `AggressiveNPC` classes, which implement
    relevant interfaces:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用ISP*，在下面的代码块中，我们将根据功能分离接口，`FriendlyNPC`和`AggressiveNPC`类将实现相关的接口：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this adapted example, applying the ISP leads to separate interfaces for distinct
    NPC functionalities. Each NPC type (friendly or aggressive) can now implement
    only the interfaces relevant to its behavior, avoiding the implementation of unnecessary
    methods. This makes the system more modular and adaptable as different NPC types
    can adhere to their specific interfaces without being burdened by irrelevant methods.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改后的例子中，应用ISP导致为不同的NPC功能创建了单独的接口。现在，每种NPC类型（友好或攻击性）现在只能实现与其行为相关的接口，避免了实现不必要的函数。这使得系统更加模块化和适应性强，因为不同的NPC类型可以遵循它们特定的接口，而不会受到无关方法的负担。
- en: Dependency Inversion Principle (DIP)
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则 (DIP)
- en: Let’s discuss the **Dependency Inversion Principle** (**DIP**) in the context
    of game development. The DIP suggests that high-level modules (e.g., game logic)
    should not depend on low-level modules (e.g., specific implementations), but both
    should depend on abstractions (e.g., interfaces or abstract classes). Additionally,
    it promotes that details should depend on abstractions, not the other way around.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下在游戏开发中的**依赖倒置原则**（**DIP**）。DIP建议高层模块（例如，游戏逻辑）不应该依赖于低层模块（例如，特定实现），而两者都应该依赖于抽象（例如，接口或抽象类）。此外，它还促进细节应该依赖于抽象，而不是相反。
- en: Let us see an example of the weapon manager dilemma.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个武器管理困境的例子。
- en: Consider a game where the `WeaponManager` is responsible for handling different
    types of weapons wielded by the player. Without adhering to the DIP, the `WeaponManager`
    might directly instantiate and manage specific weapon classes, such as pistols
    and rifles. However, applying the DIP transforms the scenario. Now, the `WeaponManager`
    relies on an abstraction, say `IWeapon`, representing the common functionalities
    of all weapons.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个游戏，其中`WeaponManager`负责处理玩家使用的不同类型的武器。如果不遵循DIP，`WeaponManager`可能会直接实例化和管理特定的武器类，例如手枪和步枪。然而，应用DIP会改变这一情况。现在，`WeaponManager`依赖于一个抽象，比如说`IWeapon`，它代表了所有武器的共同功能。
- en: 'In the following code block, we can see the high-level module and also the
    low-level modules *without* *the DIP*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到高级模块以及没有使用DIP的低级模块：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*With the DIP*, in the following code block, we can see the high-level module
    and low-level modules implementing the abstraction:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用DIP（依赖倒置原则）*，在下面的代码块中，我们可以看到高级模块和低级模块实现了抽象：'
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, applying the DIP allows `WeaponManager` to depend on the abstraction
    (`IWeapon`), enabling easy extension with new weapon types without modifying the
    high-level module. This flexibility is crucial in game development, where new
    features and components may be added over time without disrupting existing code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，应用DIP允许`WeaponManager`依赖于抽象（`IWeapon`），使得在不修改高级模块的情况下，可以轻松地扩展新的武器类型。这种灵活性在游戏开发中至关重要，因为随着时间的推移，可能会添加新的功能和组件，而不会破坏现有代码。
- en: Implementing the SOLID principles in Unity is instrumental in achieving modular
    C# code, a crucial aspect of effective software design. Modularity, which involves
    breaking down a system into self-contained components, is facilitated by the SOLID
    principles, making the code not only easy to understand, maintain, and test but
    also adherent to the LSP.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中实现SOLID原则对于实现模块化的C#代码至关重要，这是有效软件设计的关键方面。SOLID原则通过将系统分解为自包含的组件来促进模块化，使得代码不仅易于理解、维护和测试，而且符合LSP（里氏替换原则）。
- en: Modularity’s significance lies in its ability to enhance code organization.
    Applying the SRP ensures that each module has a single responsibility, fostering
    a focused and modular code base. The OCP supports extending code without changing
    existing modules, allowing the seamless addition of new features. The LSP ensures
    that derived classes can substitute their base classes without affecting program
    behavior, promoting consistency and predictability in Unity code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的重要性在于其增强代码组织的能力。应用SRP（单一职责原则）确保每个模块只有一个职责，促进专注和模块化的代码库。OCP（开闭原则）支持在不更改现有模块的情况下扩展代码，允许无缝添加新功能。LSP（里氏替换原则）确保派生类可以在不影响程序行为的情况下替换其基类，促进了Unity代码的一致性和可预测性。
- en: In Unity development, effective code organization involves using namespaces
    and classes thoughtfully. The ISP tailors interfaces to specific functionalities,
    promoting a concise and modular design. **Dependency Injection** (**DI**), advocated
    by the DIP, creates loosely coupled modules, enhancing adaptability. In summary,
    the SOLID principles, including the LSP, guide the creation of modular and flexible
    C# code in Unity, ensuring a robust, maintainable, and consistent code base. In
    the following section, we’ll explore design patterns in game development and learn
    how to implement them effectively in our code base.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity开发中，有效的代码组织涉及深思熟虑地使用命名空间和类。ISP（接口隔离原则）将接口定制为特定功能，促进简洁和模块化的设计。**依赖注入**（**DI**），由DIP倡导，创建了松散耦合的模块，增强了适应性。总之，SOLID原则，包括LSP，指导了Unity中模块化和灵活的C#代码的创建，确保了健壮、可维护和一致的代码库。在下一节中，我们将探讨游戏开发中的设计模式，并学习如何在我们的代码库中有效地实现它们。
- en: Understanding design patterns in game development
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解游戏开发中的设计模式
- en: Design patterns are proven solutions to common problems encountered in software
    development. In game development, they provide valuable tools for building robust,
    maintainable, and efficient games. The following section has an overview of design
    patterns and their types.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是解决软件开发中常见问题的既定解决方案。在游戏开发中，它们为构建健壮、可维护和高效的游戏提供了宝贵的工具。下一节将概述设计模式及其类型。
- en: There are many design patterns, each applicable to specific situations. Here
    are some common types encountered in game development.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多设计模式，每种都适用于特定的情况。以下是游戏开发中常见的一些类型。
- en: Creational patterns
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建型模式
- en: 'Creational patterns are design patterns that provide structured approaches
    to object creation, ensuring flexibility and reusability while maintaining a clear
    separation between object creation and usage code. Here are some of these patterns:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式是一组设计模式，它们提供了结构化的对象创建方法，确保了灵活性和可重用性，同时保持了对象创建和使用代码之间的清晰分离。以下是一些这些模式：
- en: '**Singleton**: Ensures only one instance of a class exists throughout the game.
    Useful for global objects such as game managers or audio players.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例模式**：确保在整个游戏过程中只存在一个类的实例。对于全局对象，如游戏管理器或音频播放器，非常有用。'
- en: '**Factory Method**: Creates objects without specifying the exact class, promoting
    flexibility and code reuse.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法模式**：创建对象而不指定确切的类，促进灵活性和代码重用。'
- en: '**Object Pool**: Pre-allocates and reuses objects to improve performance, especially
    for frequently created objects such as projectiles or enemies.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象池**：预先分配和重用对象以提高性能，特别是对于经常创建的对象，如炮弹或敌人。'
- en: Structural patterns
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构模式
- en: 'Structural patterns focus on organizing classes and objects to form larger
    structures, enabling better composition and flexibility in managing complex relationships
    between entities within a system. Here are some of these patterns:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式关注于组织类和对象以形成更大的结构，从而在管理系统内实体之间的复杂关系时提供更好的组合和灵活性。以下是一些这些模式：
- en: '**Flyweight**: Makes incompatible interfaces work together by translating calls
    between them. Useful for integrating external libraries or custom code.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**享元模式**：通过在它们之间转换调用，使不兼容的接口协同工作。对于集成外部库或自定义代码非常有用。'
- en: '**Decorator**: Adds functionality to an object dynamically without subclassing
    it, promoting flexible object behavior.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**：动态地向对象添加功能，而不需要通过子类化它，从而促进灵活的对象行为。'
- en: Behavioral patterns
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为模式
- en: 'Behavioral patterns address communication and interaction between objects in
    a system, focusing on how objects collaborate and distribute responsibilities
    to achieve desired behaviors and functionalities. These patterns help manage algorithms,
    relationships, and responsibilities among objects to promote flexibility and extensibility
    in software design. Here are some of these patterns:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式关注于系统内对象之间的通信和交互，侧重于对象如何协作和分配责任以实现期望的行为和功能。这些模式有助于管理算法、关系和责任，以促进软件设计中的灵活性和可扩展性。以下是一些这些模式：
- en: '**Observer**: Allows objects to subscribe to and be notified about changes
    in other objects, facilitating communication and event handling.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：允许对象订阅并通知其他对象的变化，促进通信和事件处理。'
- en: '**Strategy**: Defines a family of algorithms and encapsulates them to allow
    switching between them at runtime. Useful for handling different player actions
    or enemy behaviors.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略模式**：定义了一组算法，并将它们封装起来，以便在运行时进行切换。对于处理不同的玩家动作或敌人行为非常有用。'
- en: '**State**: Encapsulates the behavior of an object based on its internal state,
    allowing for state-dependent behavior changes. Useful for handling character states
    such as walking, jumping, or attacking.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：封装了基于对象内部状态的行为，允许根据状态进行行为变化。对于处理角色状态，如行走、跳跃或攻击，非常有用。'
- en: In the next few sections, we are going to talk about one design pattern from
    each type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论每种类型的一个设计模式。
- en: Singleton design pattern
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例设计模式
- en: 'The Singleton pattern ensures that a class has only one instance and provides
    a global point of access to that instance throughout the application. *Figure
    2**.1* illustrates the Singleton structure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式确保一个类只有一个实例，并在整个应用程序中提供一个全局访问点到该实例。*图2**.1*展示了单例结构：
- en: '![Figure 2.1 – Singleton design pattern structure](img/B22017_02_1.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 单例设计模式结构](img/B22017_02_1.jpg)'
- en: Figure 2.1 – Singleton design pattern structure
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 单例设计模式结构
- en: 'In the following code block, you can see an implementation example of Singleton
    in Unity:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，你可以看到Unity中Singleton实现的示例：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the following code block, we can see a usage example for the Singleton pattern:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到单例模式的使用示例：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, `GameManager` is a Singleton responsible for managing the game
    state. The `PlayerController` class accesses the single instance to start the
    game. While Singletons offers global access and lazy initialization benefits,
    developers should carefully consider the potential drawbacks, especially in larger
    projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`GameManager`是一个单例，负责管理游戏状态。`PlayerController`类访问单个实例以启动游戏。虽然单例提供了全局访问和延迟初始化的好处，但开发人员应仔细考虑潜在的缺点，尤其是在大型项目中。
- en: 'The following are some of the pros of using the Singleton pattern:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用单例模式的优点：
- en: '**Global access**: Provides a single, globally accessible point to manage and
    control a specific aspect of the game, such as game state or settings'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局访问**：提供一个单一的全局访问点来管理和控制游戏中的特定方面，例如游戏状态或设置'
- en: '**Lazy initialization**: The instance is created only when it is first needed,
    saving resources until it’s required'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟初始化**：实例仅在首次需要时创建，直到需要时才节省资源'
- en: '**Easy to implement**: The Singleton pattern is straightforward to implement
    and widely recognized, making it easy for developers to understand and use'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于实现**：Singleton模式易于实现且广为人知，这使得开发者容易理解和使用'
- en: 'The following are some of the cons of using the Singleton pattern:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Singleton模式的一些缺点如下：
- en: '**Global state**: Singletons introduce a global state, and excessive use can
    lead to tight coupling and a global state that is challenging to manage'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局状态**：Singletons引入了全局状态，过度使用可能导致紧密耦合和难以管理的全局状态'
- en: '**Potential for misuse**: Developers might overuse Singletons, leading to a
    proliferation of global instances, diminishing the benefits of encapsulation'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滥用可能性**：开发者可能会过度使用Singletons，导致全局实例的激增，从而减少封装的好处'
- en: '**Difficult to test**: Testing code that depends on Singletons can be challenging,
    as the global state may impact the results of unit tests'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难以测试**：依赖于Singletons的代码测试可能具有挑战性，因为全局状态可能会影响单元测试的结果'
- en: There is a principle, though, that exists to solve the singleton problem, and
    it’s called dependency injection.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个原则来解决Singleton问题，它被称为依赖注入。
- en: DI is a design pattern that addresses the concerns associated with tight coupling
    and global state by providing objects with their dependencies rather than letting
    them create those dependencies. In Unity, this is often achieved through constructor
    injection or property injection.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: DI是一种设计模式，通过提供对象依赖项而不是让它们创建依赖项来解决与紧密耦合和全局状态相关的担忧。在Unity中，这通常通过构造函数注入或属性注入来实现。
- en: 'The following are the benefits of DI:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些依赖注入（DI）的好处：
- en: '**Reduced coupling**: By injecting dependencies, classes become less dependent
    on specific implementations, reducing tight coupling'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少耦合**：通过注入依赖项，类对特定实现的依赖性降低，减少了紧密耦合'
- en: '**Testability**: Classes with injected dependencies are often easier to test
    because you can provide mock or test implementations for those dependencies'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：具有注入依赖项的类通常更容易测试，因为你可以为这些依赖项提供模拟或特定于测试的实现'
- en: '**Flexibility**: Different implementations of a dependency can be injected,
    enabling easy swapping of components without modifying existing code'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：可以注入依赖项的不同实现，从而在不修改现有代码的情况下轻松交换组件'
- en: 'DI can help mitigate some of the issues associated with the Singleton pattern
    in the following ways:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: DI可以通过以下方式帮助缓解与Singleton模式相关的一些问题：
- en: '**Reduced global state**: By injecting dependencies, you can avoid creating
    global singletons, reducing the overall global state in your application'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少全局状态**：通过注入依赖项，你可以避免创建全局Singletons，从而减少应用程序中的整体全局状态'
- en: '**Easier testing**: Code relying on injected dependencies is generally easier
    to test because you can replace real implementations with mock objects or test-specific
    instances'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于测试**：依赖于注入依赖项的代码通常更容易测试，因为你可以用模拟对象或特定于测试的实例替换真实实现'
- en: '**Improved modularity**: DI encourages a modular design where components are
    loosely coupled, making it easier to understand and maintain the code base'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高模块化**：依赖注入鼓励模块化设计，其中组件松耦合，这使得理解和维护代码库更容易'
- en: The Singleton design pattern provides a single, globally accessible instance
    of a class, offering convenience but potentially leading to issues such as tight
    coupling and difficulty in testing. DI addresses these concerns by allowing objects
    to be provided with their dependencies externally, reducing reliance on a global
    state. This promotes loose coupling, enhances testability, and improves code maintainability
    by decoupling components and facilitating the easier management of object life
    cycles.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton设计模式提供了一个类全局可访问的唯一实例，提供了便利，但可能导致紧密耦合和测试困难等问题。依赖注入（DI）通过允许对象从外部获得其依赖项来解决这些担忧，减少了对外部状态的依赖。这促进了松耦合，增强了可测试性，并通过解耦组件和简化对象生命周期的管理来提高代码的可维护性。
- en: Flyweight design pattern
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flyweight设计模式
- en: 'The Flyweight pattern in Unity offers a solution for optimizing memory usage
    by sharing common data across multiple objects. It allows you to efficiently manage
    resources by storing shared data externally and referencing it when needed. *Figure
    2**.2* illustrates Flyweight’s structure:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的Flyweight模式提供了一种通过在多个对象间共享公共数据来优化内存使用的解决方案。它允许你通过外部存储共享数据并在需要时引用它来高效地管理资源。*图2.2*展示了Flyweight的结构：
- en: '![Figure 2.2 – Flyweight design pattern structure](img/B22017_02_2.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – Flyweight设计模式结构](img/B22017_02_2.jpg)'
- en: Figure 2.2 – Flyweight design pattern structure
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Flyweight 设计模式结构
- en: In the following code blocks, you’ll see an example scenario where the Flyweight
    pattern can be applied.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，您将看到一个可以应用 Flyweight 模式的示例场景。
- en: 'The `IWeapon` interface represents the shared properties and behaviors of weapons:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`IWeapon` 接口代表了武器的共享属性和行为：'
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Weapon` class implements the `IWeapon` interface and acts as a concrete
    Flyweight class representing individual weapons:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Weapon` 类实现了 `IWeapon` 接口，并作为一个具体的 Flyweight 类，代表单个武器：'
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `WeaponFactory` class acts as a Flyweight factory, managing and reusing
    flyweight objects based on specific keys (e.g., weapon types):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeaponFactory` 类作为 Flyweight 工厂，根据特定的键（例如，武器类型）管理和重用 flyweight 对象：'
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `GameClient` class demonstrates how to use the flyweight objects retrieved
    from the factory, showcasing the reusability and memory efficiency of the Flyweight
    pattern:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameClient` 类展示了如何使用从工厂检索的 flyweight 对象，展示了 Flyweight 模式的可重用性和内存效率：'
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This example simulates a game scenario where different types of weapons are
    represented as flyweight objects, and the factory efficiently manages these shared
    objects to optimize memory usage and improve performance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例模拟了一个游戏场景，其中不同类型的武器被表示为 flyweight 对象，工厂有效地管理这些共享对象以优化内存使用并提高性能。
- en: 'The following are the pros of using the Flyweight pattern:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下使用 Flyweight 模式的优点：
- en: '**Memory optimization**: By sharing common data, the pattern reduces memory
    consumption, especially for large numbers of similar objects'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存优化**：通过共享常见数据，该模式减少了内存消耗，特别是对于大量类似对象。'
- en: '**Improved performance**: Sharing reduces the overhead of creating and managing
    redundant data, leading to better performance'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高性能**：共享减少了创建和管理冗余数据的开销，从而提高了性能'
- en: '**Simplified code**: Separating shared and unique data promotes cleaner and
    more maintainable code'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化代码**：分离共享和独特数据，促进更干净、更易于维护的代码'
- en: 'The following are the cons of using the Flyweight pattern:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下使用 Flyweight 模式的缺点：
- en: '**Complexity**: Implementing the Flyweight pattern introduces additional complexity,
    especially when managing shared and unique states'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：实现 Flyweight 模式引入了额外的复杂性，尤其是在管理共享和独特状态时'
- en: '**Potential overhead**: While the pattern improves memory and performance,
    it may introduce overhead due to managing shared resources'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在开销**：虽然该模式提高了内存和性能，但它可能由于管理共享资源而引入开销'
- en: Despite these considerations, the Flyweight pattern remains a valuable tool
    for efficient resource management in Unity projects, particularly in scenarios
    with many similar objects requiring memory optimization.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些考虑，Flyweight 模式仍然是 Unity 项目中有效资源管理的宝贵工具，尤其是在需要内存优化的类似对象场景中。
- en: Observer design pattern
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Observer 设计模式
- en: The Observer pattern in Unity promotes loose coupling between objects by allowing
    them to subscribe to events and receive notifications when those events occur.
    This way, objects can react to changes without needing to know the specific details
    of the object raising the event.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的 Observer 模式通过允许对象订阅事件并在事件发生时接收通知，促进了对象之间的松耦合。这样，对象可以响应变化，而无需了解引发事件的特定对象细节。
- en: '*Figure 2**.3* illustrates Observer’s structure.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2**.3* 展示了 Observer 的结构。'
- en: '![Figure 2.3 – Observer design pattern structure](img/B22017_02_3.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – Observer 设计模式结构](img/B22017_02_3.jpg)'
- en: Figure 2.3 – Observer design pattern structure
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – Observer 设计模式结构
- en: Let’s create a simple example in Unity to demonstrate the implementation of
    a health system using the Observer pattern.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Unity 中创建一个简单的示例，以演示使用 Observer 模式实现健康系统的实现。
- en: 'In the following code block, we can see the `IHealthObserver` Observer interface
    and the `IHealthSubject` subject interface:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到 `IHealthObserver` Observer 接口和 `IHealthSubject` 主题接口：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the following code block, we can see the `HealthManager` class implementing
    `IHealthSubject`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到 `HealthManager` 类实现了 `IHealthSubject`：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following code block, we can see the `UIObserver` class implementing
    `IHealthObserver`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到 `UIObserver` 类实现了 `IHealthObserver`：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the following code block, we can see the `GameplayObserver` class implementing
    `IHealthObserver`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到 `GameplayObserver` 类实现了 `IHealthObserver`：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the following code block, we can see a usage example for the Observer pattern
    in Unity:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到在 Unity 中 Observer 模式的使用示例：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the `HealthManager` class represents the subject, and the `UIObserver`
    and `GameplayObserver` classes represent observers. When the character takes damage,
    `HealthManager` triggers the `OnHealthChanged` event, notifying all registered
    observers. Each observer then updates its state based on the received health value,
    demonstrating the Observer pattern in action.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`HealthManager`类代表主题，而`UIObserver`和`GameplayObserver`类代表观察者。当角色受到伤害时，`HealthManager`触发`OnHealthChanged`事件，通知所有已注册的观察者。每个观察者随后根据接收到的健康值更新其状态，展示了观察者模式的应用。
- en: 'The following are the pros of using the Observer pattern:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式的优点如下：
- en: '**Improved decoupling**: Objects are not dependent on each other’s implementation
    details, promoting loose coupling and modularity'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高解耦性**：对象不依赖于彼此的实现细节，促进松散耦合和模块化'
- en: '**Enhanced maintainability**: Code becomes easier to understand and modify
    because event handling is centralized and observers are decoupled'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强可维护性**：由于事件处理是集中的，并且观察者是解耦的，因此代码更容易理解和修改'
- en: '**Increased flexibility**: Allows for the dynamic addition and removal of observers,
    making the system more adaptable to changing requirements'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加灵活性**：允许动态地添加和删除观察者，使系统更能适应不断变化的需求'
- en: 'The following are the cons of using the Observer pattern:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式的缺点如下：
- en: '**Increased complexity**: Introduces additional abstraction layers compared
    to direct communication, which can slightly increase code complexity'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加复杂性**：与直接通信相比，引入了额外的抽象层，这可能会略微增加代码复杂性'
- en: '**Performance overhead**: Event handling involves method calls and potentially
    data transfer, which can lead to some performance overhead'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能开销**：事件处理涉及方法调用和可能的数据传输，这可能导致一些性能开销'
- en: Overall, the Observer pattern is a powerful tool for facilitating communication
    between objects and managing dynamic changes in Unity. The benefits of loose coupling
    and flexibility outweigh the drawbacks in most situations involving event-driven
    behavior.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，观察者模式是Unity中促进对象间通信和管理动态变化的有力工具。在涉及事件驱动行为的多数情况下，松散耦合和灵活性的好处超过了缺点。
- en: 'Additionally, here are some other applications of the Observer pattern in Unity:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里还有一些Unity中观察者模式的其它应用：
- en: Implementing state machines for characters and enemies
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为角色和敌人实现状态机
- en: Updating UI elements based on changes in game state (e.g., score, level, and
    inventory)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据游戏状态的变化（例如，得分、等级和库存）更新UI元素
- en: Triggering animations or sound effects based on specific events in the game
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据游戏中的特定事件触发动画或音效
- en: Remember, you can find all the examples on GitHub for reference.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您可以在GitHub上找到所有示例以供参考。
- en: It’s not mandatory to use these patterns in all your code. They serve as solutions
    to common problems, but sometimes, implementing patterns might complicate things
    unnecessarily. The key is to focus on solving the problem at hand first and then
    look for the best solution. In the following section, we will delve into coding
    conventions and explore best practices for writing clear code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 并非在所有代码中都必须使用这些模式。它们是解决常见问题的解决方案，但有时，实现模式可能会无谓地使事情复杂化。关键在于首先关注解决当前的问题，然后再寻找最佳解决方案。在下一节中，我们将深入探讨编码约定并探讨编写清晰代码的最佳实践。
- en: Coding conventions and best practices
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码约定和最佳实践
- en: 'Maintaining consistent and clear code is essential for effective development
    and collaboration. Adhering to recognized conventions and best practices enhances
    code clarity, maintainability, and readability. Here’s a breakdown of key aspects
    of C# coding:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 保持代码的一致性和清晰性对于有效的开发和协作至关重要。遵循公认的约定和最佳实践可以增强代码的清晰度、可维护性和可读性。以下是C#编码的关键方面概述：
- en: '**C# naming conventions**: Understanding and implementing C# naming conventions
    is pivotal for maintaining code consistency and clarity. Let’s delve into best
    practices for naming variables, methods, classes, and namespaces to ensure our
    code is both readable and expressive:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#命名约定**：理解和实现C#命名约定对于保持代码一致性和清晰性至关重要。让我们深入了解命名变量、方法、类和命名空间的最佳实践，以确保我们的代码既易于阅读又具有表现力：'
- en: '**Variables**: Adopt **camelCase** (e.g., **playerScore**, **enemyHealth**)
    and opt for descriptive names conveying the variable’s purpose (e.g., **currentLevel**,
    **isGameOver**). Avoid abbreviations unless widely understood (e.g., fps for frames
    per second).'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**: 采用 **camelCase** (例如，**playerScore**, **enemyHealth**) 并选择描述性名称，传达变量的目的（例如，**currentLevel**,
    **isGameOver**）。除非广泛理解，否则避免缩写（例如，fps代表每秒帧数）。'
- en: '**Methods**: Utilize **PascalCase** (e.g., **StartGame**, **MovePlayer**) and
    ensure the method name precisely reflects its functionality. Use verbs for action-oriented
    methods (e.g., **CalculateDamage**, **LoadLevel**).'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**: 使用 **PascalCase** (例如，**StartGame**, **MovePlayer**) 并确保方法名称精确反映其功能。对于面向动作的方法使用动词（例如，**CalculateDamage**,
    **LoadLevel**）。'
- en: '**Classes**: Employ PascalCase for class names (e.g., **Player**, **EnemyController**)
    and avoid generic names such as **MyClass** or **NewClass**. Choose descriptive
    names representing the class’s purpose.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**: 使用 PascalCase 为类命名（例如，**Player**, **EnemyController**) 并避免使用通用名称，如 **MyClass**
    或 **NewClass**。选择描述性名称，代表类的目的。'
- en: '**Namespaces**: Apply PascalCase for namespaces (e.g., **MyGame.Characters**,
    **Utility.Math**) and organize code into meaningful hierarchical namespaces.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**: 使用 PascalCase 为命名空间命名（例如，**MyGame.Characters**, **Utility.Math**)
    并将代码组织成有意义的分层命名空间。'
- en: '**Meaningful and descriptive names**: Crafting meaningful and descriptive names
    is fundamental to writing clear and understandable code. Let’s explore guidelines
    for selecting names that accurately convey the purpose and type of variables,
    avoiding ambiguity and enhancing code readability:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有意义的和描述性的名称**: 构建有意义的和描述性的名称是编写清晰易懂代码的基本要素。让我们探讨选择名称的指南，这些名称能够准确传达变量目的和类型，避免歧义并提高代码可读性：'
- en: Choose names that accurately reflect the represented entity.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择准确反映所表示实体的名称。
- en: Avoid ambiguous names such as **temp** or **data**.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用模糊的名称，如 **temp** 或 **data**。
- en: Use prefixes and suffixes to clarify variable types (e.g., **isJumping**, **playerPosition**).
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前缀和后缀来澄清变量类型（例如，**isJumping**, **playerPosition**）。
- en: '**Code formatting**: Mastering code formatting is a fundamental aspect of writing
    clean and organized code. Let’s explore key elements such as indentation, spacing,
    and comments to enhance readability and structure in your programming endeavors:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码格式化**: 掌握代码格式化是编写干净和有组织代码的基本方面。让我们探讨关键元素，如缩进、间距和注释，以增强编程工作中的可读性和结构：'
- en: '**Indentation**: Employ consistent indentation for enhanced readability and
    structure'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩进**: 使用一致的缩进来提高可读性和结构。'
- en: '**Spacing**: Introduce appropriate spacing around operators, keywords, and
    parentheses'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间距**: 在运算符、关键字和括号周围引入适当的间距。'
- en: '**Comments**: Include comments to elucidate complex logic, clarify algorithms,
    and document code functionality'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注释**: 包含注释以阐明复杂逻辑、澄清算法和记录代码功能。'
- en: '**Error handling and exception management**: Error handling and exception management
    are critical aspects of software development, ensuring robustness and reliability
    in handling unexpected scenarios. Let’s delve into effective strategies, such
    as using **try-catch** blocks and providing meaningful feedback, to manage errors
    gracefully and enhance user experience:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理和异常管理**: 错误处理和异常管理是软件开发的关键方面，确保在处理意外情况时具有鲁棒性和可靠性。让我们深入了解有效的策略，例如使用 **try-catch**
    块和提供有意义的反馈，以优雅地管理错误并提高用户体验：'
- en: Implement robust error handling for graceful management of unexpected situations
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施健壮的错误处理，以优雅地管理意外情况。
- en: Use **try-catch** blocks to capture exceptions and provide meaningful user feedback
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **try-catch** 块来捕获异常并提供有意义的用户反馈。
- en: Avoid ignoring errors to prevent unpredictable behavior
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免忽略错误以防止不可预测的行为。
- en: '**Method and class length**: When it comes to method and class length, maintaining
    a balance between conciseness and clarity is paramount to fostering maintainable
    code bases. Let’s explore strategies for keeping methods and classes concise while
    ensuring they remain focused and easy to understand, promoting code readability
    and maintainability:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法和类长度**: 当涉及到方法和类长度时，在简洁性和清晰性之间保持平衡对于培养可维护的代码库至关重要。让我们探讨保持方法和类简洁的同时确保它们保持专注和易于理解，从而提高代码的可读性和可维护性的策略：'
- en: Strive for concise and focused methods and classes
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 努力使方法和类简洁且专注。
- en: Steer clear of “monolithic classes” handling everything, making them challenging
    to understand and maintain
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免创建处理所有内容的“单体类”，这会使它们难以理解和维护。
- en: Extract complex functionality into separate methods for clarity and reusability
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复杂的功能提取到单独的方法中，以提高清晰度和可重用性
- en: '**Additional best practices**: In pursuit of robust and maintainable code,
    embracing additional best practices beyond the fundamentals is essential. Let’s
    delve into strategies:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外最佳实践**：为了追求健壮和可维护的代码，除了基本准则之外，还需要接受额外的最佳实践。让我们深入了解策略：'
- en: Employ meaningful constants instead of magic numbers
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有意义的常量而不是魔法数字
- en: Minimize the use of global variables
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化全局变量的使用
- en: Avoid deeply nested code and excessive indentation
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免深层嵌套的代码和过多的缩进
- en: Embarking on a journey through essential coding conventions and best practices,
    we explored fundamental aspects such as C# naming conventions, where clarity and
    consistency reign supreme. We discussed the nuances of meaningful and descriptive
    names, mastering the art of code formatting, navigating error handling and exception
    management, and optimizing method and class length, as well as discovered additional
    best practices to refine your code base for robustness and clarity.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索基本的编码约定和最佳实践的过程中，我们探讨了基本方面，如C#命名约定，其中清晰和一致性是至高无上的。我们讨论了有意义的和描述性的名称的细微差别，掌握了代码格式的艺术，导航错误处理和异常管理，以及优化方法和类长度，同时发现了额外的最佳实践来改进代码库的健壮性和清晰度。
- en: Let’s explore some refactoring techniques with examples.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过示例探索一些重构技术。
- en: Refactoring techniques
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构技术
- en: Refactoring techniques involve breaking down long and complex methods into smaller,
    focused functions and eliminating duplicated code to adhere to principles such
    as **Don’t Repeat Yourself** (**DRY**) and **Keep It Simple, Stupid** (**KISS**),
    ultimately resulting in cleaner and more maintainable Unity projects.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 重构技术包括将长且复杂的方法分解成更小、更专注的函数，并消除重复代码，以遵循如**不要重复自己**（DRY）和**保持简单，傻瓜**（KISS）的原则，最终使Unity项目更加整洁和易于维护。
- en: Let’s look at a couple of examples of code smells in Unity projects that may
    indicate a need for refactoring.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Unity项目中可能表明需要重构的代码异味的一些例子。
- en: 'Example 1: Long and complex method'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1：长且复杂的方法
- en: 'In the following code block, we can see that the `PlayerController` class has
    a long method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`PlayerController`类有一个长方法：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code smell here is the `HandlePlayerInput` method is lengthy and handles
    multiple tasks, making it hard to maintain. Refactor it into smaller, dedicated
    functions for specific player actions, such as movement, shooting, and jumping.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码异味是`HandlePlayerInput`方法过长，处理了多个任务，这使得维护变得困难。将其重构为针对特定玩家动作的较小、专用函数，例如移动、射击和跳跃。
- en: '*After refactoring*, in the following code block, we can see the `PlayerController`
    class has methods for each piece of logic instead of a large method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*重构后*，在下面的代码块中，我们可以看到`PlayerController`类为每块逻辑都有方法，而不是一个大方法：'
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Example 2: Duplicated code'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：重复代码
- en: 'In the following code block, we can see the `EnemyAI` class has duplicated
    logic:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到`EnemyAI`类有重复的逻辑：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code smell here is that duplicated code for attacking the player, ally,
    and boss poses maintenance hurdles. Refactor by crafting a single method for attacking
    and invoking it with distinct parameters to eliminate redundancy.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码异味是攻击玩家、盟友和Boss的重复代码给维护带来了障碍。通过创建一个用于攻击的方法，并用不同的参数调用它来消除冗余。
- en: '*After refactoring*, in the following code block, we can see `EnemyAI` has
    common code for attacking:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*重构后*，在下面的代码块中，我们可以看到`EnemyAI`有用于攻击的通用代码：'
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These refactoring examples adhere to the DRY and KISS principles, resulting
    in cleaner and more maintainable Unity code. In the next couple of bullet points,
    we will take a look at the definitions of DRY and KISS:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重构示例遵循DRY和KISS原则，从而使得Unity代码更加整洁和易于维护。在接下来的几个要点中，我们将探讨DRY和KISS的定义：
- en: '**DRY principle**: The DRY principle is a software development concept advocating
    for the avoidance of code duplication. It emphasizes that each piece of knowledge
    or logic within a system should have a single, unambiguous representation to reduce
    redundancy. By following DRY, developers aim to enhance maintainability, reduce
    the chance of errors, and improve code readability.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DRY原则**：DRY原则是一个软件开发概念，主张避免代码重复。它强调系统中的每一块知识或逻辑都应该有一个单一、明确的表示，以减少冗余。通过遵循DRY，开发者旨在提高可维护性，减少错误发生的可能性，并提高代码的可读性。'
- en: '**KISS principle**: The KISS principle suggests that simplicity should be a
    key goal in design and decision-making. It encourages developers to favor straightforward,
    uncomplicated solutions over complex ones. KISS asserts that simplicity often
    leads to better understandability, maintainability, and reduced chances of errors.
    The principle is a reminder to avoid unnecessary complexity when solving problems.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KISS原则**：KISS原则建议在设计决策中，简单性应是一个关键目标。它鼓励开发者优先选择简单、直接的解决方案，而不是复杂的解决方案。KISS断言，简单性通常会导致更好的可理解性、可维护性，并降低出错的可能性。这个原则是对避免在解决问题时引入不必要的复杂性的提醒。'
- en: By identifying and addressing code smells in Unity projects, we ensure cleaner,
    more maintainable code. Through examples such as breaking down long methods and
    eliminating duplicated code, we adhere to principles such as DRY and KISS, resulting
    in improved code quality and readability.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过识别和解决Unity项目中的代码异味，我们确保代码更干净、更易于维护。通过例如分解长方法和消除重复代码的示例，我们遵循DRY和KISS原则，从而提高代码质量和可读性。
- en: Time to demonstrate your knowledge! Give these questions and challenges a try.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候展示你的知识了！尝试这些问题和挑战。
- en: Questions
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the primary goal of writing clean code?
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写干净代码的主要目标是什么？
- en: Implement a singleton pattern for managing game settings such as sound volume,
    music volume, and screen resolution. Ensure that there is only one instance of
    the settings manager throughout the game.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个单例模式来管理游戏设置，如音量、音乐音量和屏幕分辨率。确保在整个游戏中只有一个设置管理器实例。
- en: Create a singleton score manager that tracks the player’s score across multiple
    game levels or scenes. Ensure that the score manager instance persists between
    scene changes.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单例得分管理器，用于跟踪玩家在多个游戏关卡或场景中的得分。确保得分管理器实例在场景变化之间保持持久。
- en: Implement a flyweight pattern using object pooling for bullets in a shooting
    game. The flyweight should efficiently manage the creation and reuse of bullet
    objects to minimize memory overhead during gameplay.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在射击游戏中使用对象池实现轻量级模式，用于子弹。轻量级模式应有效地管理子弹对象的创建和重用，以最小化游戏过程中的内存开销。
- en: Design a flyweight pattern for rendering a tile-based map in a 2D game. Optimize
    the rendering process by reusing flyweight tile objects for similar tile types,
    such as grass, water, and rocks.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个轻量级模式，用于在2D游戏中渲染基于瓦片的地图。通过重用类似瓦片类型的轻量级瓦片对象（如草地、水域和岩石）来优化渲染过程。
- en: Develop an observer pattern-based event system for handling in-game events such
    as player deaths, power-up pickups, and level completions. Implement observers
    for different event types and ensure efficient event broadcasting.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个基于观察者模式的系统，用于处理游戏中的事件，如玩家死亡、增益物品拾取和关卡完成。实现不同类型事件的观察者，并确保高效的事件广播。
- en: Create an observer pattern implementation to update UI elements dynamically
    based on game events. For example, update health bars, score displays, and inventory
    icons using observers for player health changes, score increments, and item pickups.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个观察者模式实现，根据游戏事件动态更新UI元素。例如，使用玩家健康变化、得分增加和物品拾取的观察者来更新生命值条、得分显示和库存图标。
- en: Combine singleton, flyweight, and observer patterns to design a player character
    system. Use the singleton pattern for player input handling, flyweight for managing
    player animations efficiently, and observers for handling player state changes
    (e.g., health, inventory).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合单例、轻量级和观察者模式来设计玩家角色系统。使用单例模式处理玩家输入，使用轻量级模式高效管理玩家动画，使用观察者处理玩家状态变化（例如，健康、库存）。
- en: Design a game system (e.g., inventory management, quest tracking) and choose
    the most suitable design patterns (singleton, flyweight, observer, etc.) to implement
    various aspects of the system. Justify your design decisions based on SOLID principles
    and scalability.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个游戏系统（例如，库存管理、任务追踪）并选择最合适的设计模式（单例、轻量级、观察者等）来实现系统的各个方面。根据SOLID原则和可扩展性来论证你的设计决策。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To wrap up this chapter, remember that writing neat and well-organized C# code
    is key for successful Unity game development. The skills you’ve gained, such as
    naming things sensibly and arranging code logically, will make your game creation
    journey smoother. Keeping things simple and avoiding repeated code make your work
    easier to grasp and maintain. Applying these ideas will lead to games with code
    that just makes sense, making you a more efficient and effective game developer.
    It’s important to note that the journey toward clean code and best practices is
    ongoing. You don’t have to apply all the principles in every project, but consistently
    incorporating them into your coding mindset will enhance your skills over time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章内容，请记住，编写整洁且组织良好的C#代码对于成功的Unity游戏开发至关重要。你获得的一些技能，如合理命名事物和逻辑地排列代码，将使你的游戏创作之旅更加顺畅。保持简单并避免重复代码可以使你的工作更容易理解和维护。应用这些想法将导致代码清晰易懂的游戏，使你成为一个更高效和有效的游戏开发者。重要的是要注意，向干净代码和最佳实践迈进是一个持续的过程。你不必在每一个项目中应用所有原则，但持续地将它们融入你的编码思维中将随着时间的推移提高你的技能。
- en: Now, gear up for the next chapter, where you’ll explore Unity plugins. You will
    discover how to identify and evaluate various types of plugins, seamlessly integrating
    them into your projects. This knowledge will empower you to enhance game features,
    save development time, and implement new mechanics using C#. So, get ready for
    [*Chapter 3*](B22017_03.xhtml#_idTextAnchor049), where you’ll broaden your Unity
    toolkit and elevate your game development skills.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，准备好进入下一章，你将探索Unity插件。你将了解如何识别和评估各种类型的插件，并将它们无缝集成到你的项目中。这些知识将使你能够增强游戏功能，节省开发时间，并使用C#实现新的机制。因此，准备好进入[*第3章*](B22017_03.xhtml#_idTextAnchor049)，在那里你将扩展你的Unity工具集并提升你的游戏开发技能。
