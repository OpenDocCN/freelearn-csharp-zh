<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer032">
<h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor051"/>3</h1>
<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>Data Binding Building Blocks in .NET MAUI</h1>
<p>In the previous chapters, we familiarized ourselves with the core concepts of the MVVM pattern and explored the fundamentals of .NET MAUI. With the knowledge of MVVM principles and .NET MAUI’s capabilities, we can now start looking at how to apply MVVM to .<span class="No-Break">NET MAUI.</span></p>
<p>Data binding, a crucial component in .NET MAUI, is the key enabler of the MVVM pattern. In this chapter, we <a id="_idIndexMarker182"/>will focus on the fundamental concepts, components, and techniques that facilitate data binding in .NET MAUI. These critical elements link the View and ViewModel layers of your application, enabling efficient communication and ensuring a clean separation <span class="No-Break">of concerns.</span></p>
<p>In the course of this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Key components for <span class="No-Break">data binding</span></li>
<li>Binding modes and the <span class="No-Break"><strong class="bold">INotifyPropertyChanged</strong></span><span class="No-Break"> interface</span></li>
<li>Handling interactions with the <span class="No-Break"><strong class="bold">ICommand</strong></span><span class="No-Break"> interface</span></li>
</ul>
<p>By the end of this chapter, you will have a solid understanding of the essential data-binding building blocks that come with .NET MAUI. This will help you understand the inner workings of data binding in .NET MAUI and what role each component plays. With this foundation in place, you will be well equipped to explore more advanced topics and techniques in the <span class="No-Break">following chapters.</span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/>Technical requirements</h1>
<p>Throughout this chapter, we will add functionality to the <strong class="bold">Recipes!</strong> app. All required assets needed to follow along, including all the code used in this chapter, can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/>Key components for data binding</h1>
<p>Let’s first turn our attention to the core components that enable data binding in .NET MAUI: <strong class="source-inline">BindableObject</strong>, <strong class="source-inline">BindableProperty</strong>, and <strong class="source-inline">BindingContext</strong>. These components work in harmony <a id="_idIndexMarker183"/>to establish and manage the connections between your Views and ViewModels. Understanding the role and functionality of these elements is crucial, as they form the backbone of data binding in .<span class="No-Break">NET MAUI.</span></p>
<p>Let’s quickly discuss the elements that play a role in <span class="No-Break">data binding.</span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Elements of data binding</h2>
<p>Before we dive into the key components, let’s go through the elements that we need to understand to effectively <a id="_idIndexMarker184"/>work with data binding in .NET MAUI applications. These elements play a vital role in facilitating communication between the View and ViewModel layers, enabling seamless synchronization of data and <span class="No-Break">user interactions:</span></p>
<ul>
<li><strong class="bold">Binding source</strong>: The binding source refers to the data being bound, typically originating from the ViewModel. It is often a property of an instance of a class that implements the <strong class="source-inline">INotifyPropertyChanged</strong> interface. This interface <a id="_idIndexMarker185"/>ensures that the View is notified whenever the data in the ViewModel changes, allowing the UI to update accordingly. It’s essential to understand that implementing the <strong class="source-inline">INotifyPropertyChanged</strong> interface is not strictly required for a property to act as a binding source. In fact, any property, regardless of its enclosing class implementing <strong class="source-inline">INotifyPropertyChanged</strong> or not, can serve as a <span class="No-Break">binding source.</span></li>
<li><strong class="bold">Binding target</strong>: The binding target is the <strong class="source-inline">BindableProperty</strong> on a UI element – or another <strong class="source-inline">BindableObject</strong> – that you may want to connect to the binding <a id="_idIndexMarker186"/>source. In .NET MAUI, most UI elements, such as labels, text boxes, and buttons, derive from the <strong class="source-inline">Microsoft.Maui.Controls.BindableObject</strong> class, which enables them to serve as a binding target. As opposed to the binding source, not every property can be <a id="_idIndexMarker187"/>a binding target, only properties of type <strong class="source-inline">BindableProperty</strong> on a class that inherits from <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">BindableObject</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Binding context</strong>: The binding context establishes the relationship between the ViewModel and the View. It serves as a reference point for the data binding engine, providing a <a id="_idIndexMarker188"/>connection to the ViewModel instance. The binding context is usually set at the page level or on individual UI elements. By default, child elements inherit the context from <span class="No-Break">their parent.</span></li>
<li><strong class="bold">Binding path</strong>: The binding path is an expression that specifies the property of the <a id="_idIndexMarker189"/>binding source that need to be bound to the binding target. In the simplest case, the binding path refers to a single property name in the ViewModel, but it can also include more complex expressions, such as property chains or indexers. The combination of the binding path and the binding context form the <span class="No-Break">binding source.</span></li>
<li><strong class="bold">Binding mode</strong>: The binding mode determines the direction of data flow between the binding <a id="_idIndexMarker190"/>source and target, as we saw earlier in <a href="B20941_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">What Is the MVVM </em><span class="No-Break"><em class="italic">Design Pattern?</em></span></li>
<li><strong class="bold">ValueConverter</strong>: A value converter modifies the data between the ViewModel and the View <a id="_idIndexMarker191"/>and vice versa. It allows us to convert the data value that is being bound and is particularly useful when the ViewModel’s data type does not match the data type expected by the UI element in <span class="No-Break">the View.</span></li>
</ul>
<p>Throughout this and <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Data Binding in .NET MAUI</em>, all aspects of data binding will be <span class="No-Break">thoroughly discussed.</span></p>
<p>Let’s first take a look at the core component that makes data binding possible in .<span class="No-Break">NET MAUI.</span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>BindableObject</h2>
<p>In .NET MAUI, the <strong class="source-inline">Microsoft.Maui.Controls.BindableObject</strong> class is the base class for <a id="_idIndexMarker192"/>objects that leverage data binding. It provides <a id="_idIndexMarker193"/>the foundation to enable data binding with UI elements and other objects by implementing essential properties, methods, and events related to the binding process. It is, in fact, the cornerstone of data-binding functionality in .NET MAUI, which is a crucial component of applying the MVVM pattern. It allows us to connect the View and the ViewModel, allowing them to communicate and stay in sync with each other without <span class="No-Break">direct coupling.</span></p>
<p>Most UI elements <a id="_idIndexMarker194"/>in .NET MAUI, such as labels, buttons, and <a id="_idIndexMarker195"/>text boxes, are derived from the <strong class="source-inline">BindableObject</strong> class. This inheritance enables these elements to participate in <span class="No-Break">data binding.</span></p>
<p>In essence, the <strong class="source-inline">BindableObject</strong> stores instances of <strong class="source-inline">Microsoft.Maui.Controls.BindableProperty</strong> and manages the <strong class="source-inline">BindingContext</strong>. These are crucial aspects to enable effective data binding, which in turn fosters seamless communication between the View and ViewModel, <span class="No-Break">facilitating MVVM.</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>BindableProperty</h2>
<p><strong class="source-inline">BindableProperty</strong> is a special kind of property that can act as a binding target. It basically is an advanced <a id="_idIndexMarker196"/>CLR property, a property on steroids, if you will. Ultimately, a <a id="_idIndexMarker197"/>bindable property serves as a container for storing data related to the property, such as its default value and validation logic. It also provides a mechanism to enable data binding and property change notifications. It is associated with a public instance property, which serves as the interface for getting and setting the value of the bindable property. Many properties of UI elements in .NET MAUI are bindable properties, which allows us to set their values through data binding or <span class="No-Break">using styles.</span></p>
<p>As an example, let’s look at the <strong class="source-inline">Text</strong> property <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Label</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
public partial class Label : View ...
{
    ....
    public static readonly BindableProperty TextProperty =
        BindableProperty.Create(nameof(Text),
            typeof(string), typeof(Label), default(string),
            propertyChanged: OnTextPropertyChanged);
    ...
    public string Text
    {
        get { return (string)GetValue(TextProperty); }
        set { SetValue(TextProperty, value); }
    }
    static void OnTextPropertyChanged(
        BindableObject bindable,
        object oldvalue, object newvalue)
    {
        ...
    }
    ...
}</pre> <p>Let’s start by <a id="_idIndexMarker198"/>looking at the <strong class="source-inline">Text</strong> property. This is just a CLR property, but <a id="_idIndexMarker199"/>instead of storing and retrieving the value from a backing field, it does <span class="No-Break">the following:</span></p>
<ul>
<li>The getter retrieves the value by calling the <strong class="source-inline">GetValue</strong> method, passing in <strong class="source-inline">TextProperty</strong>. This <strong class="source-inline">GetValue</strong> method is a method on the <strong class="source-inline">BindableObject</strong> base class that <strong class="source-inline">Label</strong> <span class="No-Break">inherits from.</span></li>
<li>The setter calls the <strong class="source-inline">SetValue</strong> method of <strong class="source-inline">BindableObject</strong>, passing in <strong class="source-inline">TextProperty</strong> and the <span class="No-Break">given value.</span></li>
</ul>
<p>The <strong class="source-inline">TextProperty</strong> used in the <strong class="source-inline">GetValue</strong> and <strong class="source-inline">SetValue</strong> methods is a <strong class="source-inline">BindableProperty</strong>. It’s static and belongs to the <strong class="source-inline">Label</strong> class. As mentioned earlier, <strong class="source-inline">BindableProperty</strong> is a sort of “container” that holds various bits of information about the property, including <span class="No-Break">its value.</span></p>
<p>Let’s break <a id="_idIndexMarker200"/>down this <strong class="source-inline">TextProperty</strong>. This property is defined as a public <a id="_idIndexMarker201"/>static field of type <strong class="source-inline">BindableProperty</strong>. It is instantiated by calling the <strong class="source-inline">BindableProperty.Create</strong> method, passing in the <span class="No-Break">following values:</span></p>
<ul>
<li><strong class="bold">nameof(Text)</strong>: The first parameter is the name of the public instance property associated with the <a id="_idIndexMarker202"/>static <strong class="source-inline">BindableProperty</strong> field. In this particular case, <strong class="source-inline">nameof(Text)</strong> is used to refer to the <strong class="source-inline">Text</strong> property of the <span class="No-Break"><strong class="source-inline">Label</strong></span><span class="No-Break"> class.</span></li>
<li><strong class="bold">typeof(string)</strong>: The second parameter is of type <strong class="source-inline">Type</strong> and defines the data type of the property that the bindable property is referring to. As the <strong class="source-inline">Text</strong> property is of type <strong class="source-inline">string</strong>, <strong class="source-inline">typeof(string)</strong> is passed in as <span class="No-Break">a value.</span></li>
<li><strong class="bold">typeof(Label)</strong>: The third and final mandatory parameter is also of type <strong class="source-inline">Type</strong>. It refers to the owner type of the property, which is the class that the property belongs to. In this particular example, the <strong class="source-inline">Text</strong> property is defined in the <strong class="source-inline">Label</strong> class, so this type is passed as <span class="No-Break">a value.</span></li>
<li><strong class="bold">default(string)</strong>: The next parameter in this example is the <strong class="source-inline">defaultValue</strong> parameter, which is of type <strong class="source-inline">object</strong>. This parameter is optional and allows us to provide a default value to the bindable property. In this case, <strong class="source-inline">default(string)</strong> is passed, which means <strong class="source-inline">NULL</strong> will be the <span class="No-Break">default value.</span></li>
<li><strong class="bold">OnTextpropertyChanged</strong>: Optionally, we can provide a delegate that needs to be called when the value of the <span class="No-Break">property changes.</span></li>
</ul>
<p>The <strong class="source-inline">BindableProperty.Create</strong> method has a lot more optional parameters that you can provide <span class="No-Break">if needed.</span></p>
<p class="callout-heading">More about bindable properties</p>
<p class="callout">In <a href="B20941_11.xhtml#_idTextAnchor182"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Creating MVVM-Friendly Controls</em>, we will look at building our own controls. Understanding the concept of a <strong class="source-inline">BindableProperty</strong> is essential when it comes to creating MVVM-friendly controls. So, you can expect to dive deeper into this in <span class="No-Break">that chapter.</span></p>
<p>The concept of a <strong class="source-inline">BindableProperty</strong> can be a little overwhelming or hard to understand to start <a id="_idIndexMarker203"/>with. For now, just remember that all of the UI elements inherit <a id="_idIndexMarker204"/>from <strong class="source-inline">BindableObject</strong> and that many of their properties are bindable properties, allowing us to use them as a <span class="No-Break">binding target.</span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>BindingContext</h2>
<p>A <strong class="source-inline">BindableObject</strong> has a <strong class="source-inline">BindingContext</strong> property of type <strong class="source-inline">object</strong>, which acts as the glue between the <a id="_idIndexMarker205"/>binding source and the binding <a id="_idIndexMarker206"/>target. It points the data binding engine to an instance of a class that serves as the binding source. When you set the <strong class="source-inline">BindingContext</strong> property on a <strong class="source-inline">BindableObject</strong>, such as a .NET MAUI page or a UI element, you are specifying the source object for data binding expressions within that object’s scope. Child elements within that scope will inherit the <strong class="source-inline">BindingContext</strong> by default unless a different <strong class="source-inline">BindingContext</strong> is explicitly set <span class="No-Break">for them.</span></p>
<p>When the <strong class="source-inline">BindingContext</strong> is set on a <strong class="source-inline">BindableObject</strong>, the data-binding engine will resolve all bindings having their <strong class="source-inline">Source</strong> set to the <strong class="source-inline">BindingContext</strong>. Also, when the value of the <strong class="source-inline">BindingContext</strong> property changes, these bindings are reevaluated using the <span class="No-Break">updated </span><span class="No-Break"><strong class="source-inline">BindingContext</strong></span><span class="No-Break">.</span></p>
<p>Now that we’ve discussed all the core components that allow us to do data binding in .NET MAUI, let’s see how to define and <span class="No-Break">use them.</span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>Data binding in practice</h2>
<p>Before we can start <a id="_idIndexMarker207"/>writing our data binding, we first need to add our ViewModels to our solution. In order to fully embrace the separation of concerns, let’s put them into a <span class="No-Break">separate project:</span></p>
<ol>
<li>In the <strong class="bold">Solution Explorer</strong>, right-click on your solution and select <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">New Project…</strong></span><span class="No-Break">.</span></li>
<li>Select <strong class="bold">Class Library</strong> from the list of project templates and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></li>
<li>Enter <strong class="source-inline">Recipes.Client.Core</strong> under <strong class="bold">Project name</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></li>
<li>Select <strong class="source-inline">.NET 8.0</strong> as <strong class="bold">Framework</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Create</strong></span><span class="No-Break">.</span></li>
</ol>
<p>Once the project <a id="_idIndexMarker208"/>is created, let’s delete <strong class="source-inline">Class1.cs</strong>, which was created by default. Next, we want to add our ViewModels to this project. In order to keep everything nice and organized, let’s first create a <strong class="source-inline">ViewModels</strong> folder to put all of our <span class="No-Break">ViewModels in:</span></p>
<ol>
<li>Right-click <a id="_idIndexMarker209"/>on the <strong class="source-inline">Recipes.Client.Core</strong> project in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add</strong> | <strong class="bold">New Folder</strong> and enter the folder <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">ViewModels</strong></span><span class="No-Break">.</span></li>
<li>Right-click on the newly added folder and select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>, enter the name <strong class="source-inline">RecipeDetailViewModel</strong>, and add the <span class="No-Break">following code:</span><pre class="source-code">
namespace Recipes.Client.Core.ViewModels;
public class RecipeDetailViewModel
{
    public string Title { get; set; } = "Classic Caesar Salad";
}</pre><p class="list-inset"><strong class="source-inline">RecipeDetailViewModel</strong> represents the details of a recipe. For now, it only contains a <strong class="source-inline">Title</strong> property, which we now give a hardcoded value of <strong class="source-inline">"Classic </strong><span class="No-Break"><strong class="source-inline">Caesar Salad"</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>Next, we need to add a reference to this <strong class="source-inline">Recipes.Client.Core</strong> project from the <strong class="source-inline">Recipes.Mobile</strong> project. To do this, simply right-click on the <strong class="source-inline">Recipes.Mobile</strong> project, select <strong class="bold">Add</strong> | <strong class="bold">Project Reference…</strong>, and pick the <span class="No-Break"><strong class="source-inline">Recipes.Client.Core</strong></span><span class="No-Break"> project.</span></p>
<p>As a very last step, before <a id="_idIndexMarker210"/>we dive into data binding, we need to add a new page to our <span class="No-Break"><strong class="source-inline">Recipes.Mobile</strong></span><span class="No-Break"> project:</span></p>
<ol>
<li>Right-click the project name and select <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">New Item…</strong></span><span class="No-Break">.</span></li>
<li>Select <strong class="bold">.NET MAUI ContentPage (XAML)</strong> and type in the name of the new <span class="No-Break">page: </span><span class="No-Break"><strong class="source-inline">RecipeDetailPage.xaml</strong></span><span class="No-Break">.</span></li>
<li>Open <strong class="source-inline">App.xaml.cs</strong> and, in the constructor, assign an instance of <strong class="source-inline">RecipeDetailPage</strong> to the <span class="No-Break"><strong class="source-inline">MainPage</strong></span><span class="No-Break"> property:</span><pre class="source-code">
public App()
{
    InitializeComponent();
    <strong class="bold">MainPage = new RecipeDetailPage();</strong>
}</pre><p class="list-inset">This ensures that on startup, the mobile app will show our newly <span class="No-Break">created </span><span class="No-Break"><strong class="source-inline">RecipeDetailPage</strong></span><span class="No-Break">.</span></p></li> <li>Finally, in the code-behind of <strong class="source-inline">RecipeDetailPage</strong>, we need to assign its <strong class="source-inline">BindingContext</strong> property to <a id="_idIndexMarker211"/>an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
using Recipes.Client.Core.ViewModels;
namespace Recipes.Mobile;
public partial class RecipeDetailPage : ContentPage
{
    public RecipeDetailPage()
    {
        InitializeComponent();
        <strong class="bold">BindingContext = new RecipeDetailViewModel();</strong>
    }
}</pre></li> </ol>
<p>Now, we can focus on <strong class="source-inline">RecipeDetailPage</strong> and start implementing some data bindings. Data bindings can be defined in code using C# and in XAML. Both have their cons and their pros, but essentially it comes down to preference. You can even mix and match both approaches if you want, although I wouldn’t recommend doing that. Most commonly, data bindings are defined in XAML, minimizing the amount of code in the code-behind. Nevertheless, let’s first see how we can define data bindings <span class="No-Break">in C#.</span></p>
<h3>Data binding in C#</h3>
<p>Let’s go to <a id="_idIndexMarker212"/>our new <strong class="source-inline">RecipeDetailPage.xaml</strong> file and start updating <span class="No-Break">some </span><span class="No-Break"><a id="_idIndexMarker213"/></span><span class="No-Break">XAML:</span></p>
<ol>
<li>Remove any default XAML elements inside the <span class="No-Break"><strong class="source-inline">ContentPage</strong></span><span class="No-Break"> tag.</span></li>
<li>Add the following elements <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">ContentPage</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;ScrollView&gt;
    &lt;VerticalStackLayout Padding="10"&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ScrollView&gt;</pre><p class="list-inset">We are keeping the UI very simple and straightforward for now. That’s why we are going to put everything in a <strong class="source-inline">VerticalStackLayout</strong>, which organizes child elements in a vertical stack. We’re surrounding the <strong class="source-inline">VerticalStackLayout</strong> with a <strong class="source-inline">ScrollView</strong> in order to make sure we get scrollbars when not everything fits on <span class="No-Break">the screen.</span></p></li> <li>Add a <strong class="source-inline">Label</strong> to the <strong class="source-inline">VerticalStackLayout</strong> with the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">lblTitle</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;Label <strong class="bold">x:Name="lblTitle"</strong>
    FontAttributes="Bold" FontSize="22" /&gt;</pre><p class="list-inset">This label will be showing the <span class="No-Break">recipe’s title.</span></p></li> <li>In the code-behind, within the constructor of <strong class="source-inline">RecipeDetailPage</strong>, we can now add data-binding code so that the value of the <strong class="source-inline">Title</strong> property of the <strong class="source-inline">RecipeDetailViewModel</strong> is shown in the <span class="No-Break"><strong class="source-inline">lblTitle</strong></span><span class="No-Break"> label:</span><pre class="source-code">
lblTitle.SetBinding(
    Label.TextProperty,
    nameof(RecipeDetailViewModel.Title),
    BindingMode.OneWay);</pre><p class="list-inset">Because we <a id="_idIndexMarker214"/>have given the <strong class="source-inline">Label</strong> the name <strong class="source-inline">lblTitle</strong>, a <a id="_idIndexMarker215"/>field with this name is generated, which allows us to access this label from the code-behind. By calling the <strong class="source-inline">SetBinding</strong> method, we can define and apply <span class="No-Break">a binding.</span></p></li> <li>Run the app and you should see the <strong class="source-inline">Title</strong> of <strong class="source-inline">RecipeDetailViewModel</strong>, which is currently hardcoded as <strong class="source-inline">"Classic Caesar Salad"</strong> on <span class="No-Break">the screen.</span></li>
</ol>
<p>By looking at the first data binding we’ve just implemented, you should be able to identify most of the data binding elements we’ve <span class="No-Break">discussed earlier:</span></p>
<ul>
<li><strong class="bold">Binding target</strong>: The <strong class="source-inline">SetBinding</strong> method is a method on the <strong class="source-inline">BindableObject</strong> class. The first parameter the <strong class="source-inline">SetBinding</strong> method needs is a <strong class="source-inline">BindableProperty</strong>. In this case, we are passing in the static <strong class="source-inline">Label.TextProperty</strong>, which corresponds to the <strong class="source-inline">Text</strong> instance property of a <strong class="source-inline">Label</strong>. The instance of the <strong class="source-inline">BindableObject</strong> we are calling the <strong class="source-inline">SetBinding</strong> method on, together with the <strong class="source-inline">BindableProperty</strong> we’re specifying as the first parameter, form the <span class="No-Break">binding target.</span></li>
<li><strong class="bold">Binding source</strong>: The second parameter the <strong class="source-inline">SetBinding</strong> method expects is the property path to bind to. This, together with the <strong class="source-inline">BindingContext</strong>, forms the binding source – but what is the <strong class="source-inline">BindingContext</strong> in this case? As we don’t explicitly specify the <strong class="source-inline">BindingContext</strong> on the <strong class="source-inline">Label</strong>, the <strong class="source-inline">BindingContext</strong> is inherited from <strong class="source-inline">lblTitle</strong>’s parent, which is <strong class="source-inline">RecipeDetailPage</strong>. Therefore, the <strong class="source-inline">BindingContext</strong> of the label is also the instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Binding mode</strong>: <strong class="source-inline">BindingMode</strong> is the third parameter in this example. This one, however, is optional. In this case, we are setting the <strong class="source-inline">BindingMode</strong> to <strong class="source-inline">OneTime</strong>. In <a href="B20941_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">What Is the MVVM Design Pattern?</em>, we briefly discussed different binding modes, and we will discuss binding modes in a bit more depth later on in <span class="No-Break">this chapter.</span></li>
</ul>
<p>Defining data binding in code is quite easy and straightforward. However, most of the time, data bindings <a id="_idIndexMarker216"/>are defined in XAML. Personally, I think defining them in XAML <a id="_idIndexMarker217"/>feels more natural and requires less context switching when creating your UI with XAML. So, let’s have <span class="No-Break">a look!</span></p>
<h3>Data binding in XAML</h3>
<p>As we are going to write <a id="_idIndexMarker218"/>our data binding in XAML, we can delete or comment out the binding code <a id="_idIndexMarker219"/>that we added to the constructor of <strong class="source-inline">RecipeDetailPage</strong> in <em class="italic">step 4</em> of the <span class="No-Break">previous section.</span></p>
<p>We can now switch to <strong class="source-inline">RecipeDetailPage.xaml</strong> and update the label by removing the <strong class="source-inline">x:Name</strong> property <a id="_idIndexMarker220"/>and adding the <strong class="source-inline">Text</strong> property, which contains a <strong class="bold">Binding </strong><span class="No-Break"><strong class="bold">markup extension</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;Label
    FontAttributes="Bold"
    FontSize="22"
    <strong class="bold">Text="{Binding Path=Title, Mode=OneTime}"</strong> /&gt;</pre> <p>Because we are defining our data binding in XAML, we won’t need a reference to the label in the code-behind. This is why we remove the <strong class="source-inline">x:Name</strong> property. Of course, if you need a reference to the label for any other reason (for example, you have some animation logic in the code-behind that animates the label), you need to keep the <span class="No-Break"><strong class="source-inline">x:Name</strong></span><span class="No-Break"> property.</span></p>
<p>But more importantly, let’s take a look at the <strong class="source-inline">Binding</strong> markup extension that we’ve set to the <strong class="source-inline">Text</strong> property of <span class="No-Break">the label.</span></p>
<p class="callout-heading">XAML markup extensions</p>
<p class="callout">XAML markup extensions are a feature of XAML that allows you to provide values for properties during the <a id="_idIndexMarker221"/><a id="_idIndexMarker222"/>parsing of the XAML markup more dynamically and flexibly. Markup extensions use curly braces (<strong class="source-inline">{}</strong>) to enclose their syntax and enable you to add more complex logic or functionality to the <span class="No-Break">XAML itself.</span></p>
<p class="callout">Markup extensions can be used to reference resources, create bindings, or even instantiate objects, among other things. They allow you to extend the capabilities of the <span class="No-Break">XAML language.</span></p>
<p class="callout">A lot more <a id="_idIndexMarker223"/>about markup extensions can be found in the <span class="No-Break">docs: </span><a href="https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions</span></a><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">Binding</strong> markup extension is used to create a data binding between the <strong class="source-inline">Text</strong> property of the label and the <strong class="source-inline">Title</strong> property of the binding source. The binding source, in this case, is an instance of <strong class="source-inline">RecipeDetailViewModel</strong>, which is set as the <strong class="source-inline">BindingContext</strong> of the control’s <span class="No-Break">parent, </span><span class="No-Break"><strong class="source-inline">RecipeDetailPage</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">Path=Title</strong> part <a id="_idIndexMarker224"/>of the binding expression specifies that the <strong class="source-inline">Title</strong> property <a id="_idIndexMarker225"/>from the binding source should be used as the source of the binding. In this scenario, you can omit <strong class="source-inline">Path=</strong> and simply use <strong class="source-inline">Title</strong>, as the binding expression is smart enough to recognize it as a property path. So, the binding expression can be written <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;Label
    FontAttributes="Bold"
    FontSize="22"
    <strong class="bold">Text="{Binding Title, Mode=OneTime}"</strong> /&gt;</pre> <p>With <strong class="source-inline">Mode=</strong>, we can indicate the binding mode, just like we did in the previous example; we’re setting it to <strong class="source-inline">OneTime</strong> in <span class="No-Break">this example.</span></p>
<p>Apart from <strong class="source-inline">Path</strong> and <strong class="source-inline">Mode</strong>, there are more properties to the binding markup extension, such as <strong class="source-inline">Source</strong>, which allows us to point to another binding source, <strong class="source-inline">Converter</strong>, <strong class="source-inline">TargetNullValue</strong>, and others. <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Data Binding in .NET MAUI</em>, will cover all of this in much <span class="No-Break">more detail.</span></p>
<p>Now, let’s take a look at the different binding modes in more detail and how to reflect changes from the binding source automatically in the <span class="No-Break">binding target.</span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Binding modes and the INotifyPropertyChanged interface</h1>
<p>In <a href="B20941_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">What Is the MVVM Design Pattern</em>, we already discussed how data <span class="No-Break">can flow:</span></p>
<ul>
<li><strong class="bold">One-way</strong>: From ViewModel <span class="No-Break">to View</span></li>
<li><strong class="bold">One-way-to-source</strong>: From View <span class="No-Break">to ViewModel</span></li>
<li><strong class="bold">One-time</strong>: Only once from ViewModel <span class="No-Break">to View</span></li>
<li><strong class="bold">Two-way</strong>: From ViewModel to View and from View <span class="No-Break">to ViewModel</span></li>
</ul>
<p>Now, let’s take a look at how this is handled in .<span class="No-Break">NET MAUI.</span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/>Binding modes in .NET MAUI</h2>
<p>.NET MAUI supports <a id="_idIndexMarker226"/>all of these data flows, represented <a id="_idIndexMarker227"/>through the <strong class="source-inline">Microsoft.Maui.Controls.BindingMode</strong> enum: <strong class="source-inline">OneWay</strong>, <strong class="source-inline">OneWayToSource</strong>, <strong class="source-inline">OneTime</strong> and <strong class="source-inline">TwoWay</strong>. There is in fact a fifth value as well: <strong class="source-inline">Default</strong>. Remember when we talked about bindable properties earlier in this chapter? When creating a bindable property, there are some optional values we can set. One of those optional parameters is <strong class="source-inline">defaultBindingMode</strong>. This allows us to set a default binding mode on a bindable property. On <strong class="source-inline">Entry</strong>, for example, it makes sense to have the default binding mode on the <strong class="source-inline">Text</strong> property set to <strong class="source-inline">TwoWay</strong>, as it shows the value of the binding source, and the user is able to update the value as well. The <strong class="source-inline">Text</strong> property on a <strong class="source-inline">Label</strong>, on the other hand, is read-only, so the default binding mode there is <strong class="source-inline">OneWay</strong>. Now, going back to the <strong class="source-inline">BindingMode</strong> enum and more specifically, the <strong class="source-inline">Default</strong> value, when we don’t specify a binding mode or use <strong class="source-inline">Default</strong>, the data-binding engine will use the binding mode that is specified as the default one on the bindable property of the <span class="No-Break">binding target.</span></p>
<p>In the context of data binding and the various binding modes in .NET MAUI, it’s crucial to have an efficient way <a id="_idIndexMarker228"/>to inform the UI about changes to the ViewModel’s <a id="_idIndexMarker229"/>properties. The <strong class="source-inline">INotifyPropertyChanged</strong> interface addresses this need by providing a mechanism for your ViewModel to notify the UI when a property value has <span class="No-Break">been updated.</span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/>INofityPropertyChanged</h2>
<p>The <strong class="source-inline">INotifyPropertyChanged</strong> interface, part of the <strong class="source-inline">System.ComponentModel</strong> namespace, allows your binding source to communicate property<a id="_idIndexMarker230"/> changes to the binding target. This interface isn’t specific to .NET MAUI; it’s part of the .NET <strong class="bold">Base Class Library</strong> (<strong class="bold">BCL</strong>) and is used in other .NET UI frameworks <a id="_idIndexMarker231"/>such as WPF. When your ViewModel implements this interface, you can allow the data-binding engine to refresh the UI whenever the value of a data-bound property changes. This is simply done by the XAML engine, which automatically subscribes to the <strong class="source-inline">PropertyChanged</strong> event when the object that is being bound to implements the <strong class="source-inline">INotifyPropertyChanged</strong> interface. When the event is triggered, the engine will update the <span class="No-Break">UI accordingly.</span></p>
<p>To implement the <strong class="source-inline">INotifyPropertyChanged</strong> interface, your ViewModel must include a <strong class="source-inline">PropertyChanged</strong> event, which can be triggered whenever a property’s value changes. Furthermore, you typically create a method, usually called <strong class="source-inline">OnPropertyChanged</strong>, that triggers this event while providing the name of the altered property as a parameter. This method should be called within the property setter, immediately after the property value <span class="No-Break">is updated:</span></p>
<pre class="source-code">
public class SampleViewModel : <strong class="bold">INotifyPropertyChanged</strong>
{
    private string _title = string.Emtpty;
    public string Title
    {
        get =&gt; _title;
        set
        {
            if(_title != value)
            {
                _title = value;
                <strong class="bold">OnPropertyChanged(nameof(Title));</strong>
            }
        }
    }
    public void <strong class="bold">OnPropertyChanged</strong>(string propertyName)
        =&gt;<strong class="bold"> PropertyChanged?.Invoke(this,</strong>
<strong class="bold">            new PropertyChangedEventArgs(propertyName));</strong>
    public event PropertyChangedEventHandler? <strong class="bold">PropertyChanged</strong>;
}</pre> <p>As you can see in the preceding sample, this <strong class="source-inline">SampleViewModel</strong> implements the <strong class="source-inline">INotifyPropertyChanged</strong> interface, which requires us to implement the <strong class="source-inline">PropertyChanged</strong> event of the <strong class="source-inline">PropertyChangedEventHandler</strong> type. The <strong class="source-inline">PropertyChanged</strong> event can easily be invoked by calling the <strong class="source-inline">OnPropertyChanged</strong> method and passing in the name of the property that has been changed. When looking at the <a id="_idIndexMarker232"/>code, in the setter of the <strong class="source-inline">Title</strong> property, the <strong class="source-inline">OnPropertyChanged</strong> method is called when a new value is assigned to the property’s backing field, passing in the name of the property. When calling the <strong class="source-inline">PropertyChanged</strong> event, the current instance of the <strong class="source-inline">SampleViewModel</strong> is passed-in as the sender through the <strong class="source-inline">this</strong> keyword, followed by an instance of <strong class="source-inline">PropertyChangedEventArgs</strong>, which requires the name of the updated property. Through this event, the data-binding engine gets notified about the updated property and can, depending on the data-binding mode, update the binding <span class="No-Break">target automatically.</span></p>
<p><strong class="source-inline">CallerMemberNameAttribute</strong> is something that is very commonly used as an attribute on the <strong class="source-inline">propertyName</strong> parameter of the <strong class="source-inline">OnPropertyChanged</strong> method. This attribute automatically obtains the name of the method or property that calls the attributed <a id="_idIndexMarker233"/>method. This facilitates calling the <strong class="source-inline">PropertyChanged</strong> event from the property’s setter even more, as the name of the property doesn’t need to be explicitly passed as <span class="No-Break">a parameter:</span></p>
<pre class="source-code">
public class SampleViewModel : INotifyPropertyChanged
{
    ...
    public string Title
    {
        get =&gt; _title;
        set
        {
            if(_title != value)
            {
                _title = value;
                <strong class="bold">OnPropertyChanged();</strong>
            }
        }
    }
    public void OnPropertyChanged<strong class="bold">([CallerMemberName]string? propertyName = null)</strong>
        =&gt; PropertyChanged?.Invoke(this,
            new PropertyChangedEventArgs(propertyName));
...
}</pre> <p>As the <strong class="source-inline">Title</strong> property calls the <strong class="source-inline">OnPropertyChanged</strong> method, without providing an explicit value as a <a id="_idIndexMarker234"/>parameter, the name of the caller  – <strong class="source-inline">Title</strong> in this case – will be passed in as a value. In <a href="B20941_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Community Toolkits</em>, we’ll see how we can eliminate a lot of the ceremony here when triggering the <span class="No-Break"><strong class="source-inline">PropertyChanged</strong></span><span class="No-Break"> event.</span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>Different binding modes in action</h2>
<p>In the example earlier in this chapter, we bound the <strong class="source-inline">Title</strong> property of our <strong class="source-inline">RecipeDetailViewModel</strong> one time to the <strong class="source-inline">Text</strong> property of a <strong class="source-inline">Label</strong>. This means that the binding source is set only when the <strong class="source-inline">BindingContext</strong> of the binding target is set or when the <strong class="source-inline">BindingContext</strong> is assigned a new instance. In the context of our current setup, <strong class="bold">one-time</strong> data binding may not be the best choice because typically the data in the ViewModel is loaded asynchronously. This means that when we assign the ViewModel as the <strong class="source-inline">BindingContext</strong>, the initial value of the <strong class="source-inline">Title</strong> property is bound right away. However, any subsequent changes made to the <strong class="source-inline">Title</strong> property (such as updating it after the ViewModel loads data) won’t be reflected in the UI due to the nature of one-time data binding. This won’t be a problem for us right now since we’re working with <a id="_idIndexMarker235"/>static data for demonstration purposes, but it’s something to be aware of in a real-world application. As we progress through this book, we will revise this binding mode to handle such situations <span class="No-Break">more effectively.</span></p>
<p>Let’s add some more code and discuss the other binding modes. First, let’s add an additional <strong class="source-inline">IngredientsListViewModel</strong> and extend our <strong class="source-inline">RecipeDetailViewModel</strong> with a property of <span class="No-Break">that type:</span></p>
<ol>
<li>In the <strong class="bold">Solution Explorer</strong>, right-click on the <strong class="source-inline">ViewModels</strong> folder in the <strong class="source-inline">Recipes.Client.Core</strong> project and select <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">Class…</strong></span><span class="No-Break">.</span></li>
<li>Enter <strong class="source-inline">IngredientsListViewModel.cs</strong> as name and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break">.</span></li>
<li>Let the class implement the <strong class="source-inline">INotifyPropertyChanged</strong> interface and add the <strong class="source-inline">OnPropertyChanged</strong> method. Add the following code to the newly <span class="No-Break">created class:</span><pre class="source-code">
public class IngredientsListViewModel : INotifyPropertyChanged
{
    public void OnPropertyChanged([CallerMemberName]string?  propertyName = null)
        =&gt; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    public event PropertyChangedEventHandler? PropertyChanged;}</pre><p class="list-inset">This is a typical implementation of the <strong class="source-inline">INotifyPropertyChanged</strong> interface with the <strong class="source-inline">PropertyChangedEvent</strong> and an <strong class="source-inline">OnPropertyChanged</strong> method that triggers the implemented <span class="No-Break"><strong class="source-inline">PropertyChhanged</strong></span><span class="No-Break"> event.</span></p></li> <li>Next, we can <a id="_idIndexMarker236"/>add the <strong class="source-inline">NumberOfServings</strong> property, as shown in the following snippet. For brevity, the implementation of the <strong class="source-inline">INotifyPropertyChanged</strong> interface is <span class="No-Break">left out:</span><pre class="source-code">
public class IngredientsListViewModel : INotifyPropertyChanged
{
    private int _numberOfServings = 4;
    public int NumberOfServings
    {
        get =&gt; _numberOfServings;
        set
        {
            if(_numberOfServings != value)
            {
                _numberOfServings = value;
                OnPropertyChanged();
            }
        }
    }
...
    //ToDo: add list of Ingredients
}</pre><p class="list-inset"><strong class="source-inline">IngredientsListViewModel</strong> contains a list of all ingredients and the quantities of them that are needed for a particular recipe. It also contains a <strong class="source-inline">NumberOfServings</strong> property, which indicates the number of servings for which the listed ingredients and their quantities are intended. The user should be able to adjust <a id="_idIndexMarker237"/>the number of servings in the UI and see how the quantity of the ingredients is being updated according to the selected amount. We will add the list of <span class="No-Break">ingredients later.</span></p></li> <li>Move over to <strong class="source-inline">RecipeDetailViewModel</strong> and add an <strong class="source-inline">IngredientsList</strong> property of type <strong class="source-inline">IngredientsListViewModel</strong> and assign it a new instance <span class="No-Break">by default:</span><pre class="source-code">
public IngredientsListViewModel
        IngredientsList { get; set; } = new ();</pre><p class="list-inset">With this updated code in place, we can now go to <strong class="source-inline">RecipeDetailPage</strong> and focus on the XAML again. We want to update the UI to allow users to choose the desired number of servings. For this use case, we will create a <strong class="source-inline">OneWay</strong> and a <strong class="source-inline">TwoWay</strong> <span class="No-Break">data binding.</span></p><p class="list-inset">Go to <strong class="source-inline">RecipeDetail</strong> and add the following XAML below the <strong class="source-inline">Label</strong> that shows the <span class="No-Break">recipe’s title:</span></p><pre class="source-code">&lt;HorizontalStackLayout Padding="10"&gt;
    &lt;Label Text="Number of servings:"
        VerticalOptions="Center" /&gt;
    &lt;Label
        Margin="10,0" FontAttributes="Bold"
        <strong class="bold">Text="{Binding IngredientsList.NumberOfServings, Mode=OneWay}"</strong>
        VerticalOptions="Center" /&gt;
    &lt;Stepper
        BackgroundColor="{OnPlatform WinUI={StaticResource Primary}}"
        Maximum="8" Minimum="1"
        <strong class="bold">Value="{Binding IngredientsList.NumberOfServings, Mode=TwoWay}"</strong> /&gt;
&lt;/HorizontalStackLayout&gt;</pre></li> </ol>
<p>Let’s have a look <a id="_idIndexMarker238"/>at the binding statements that we’ve added through <span class="No-Break">this code:</span></p>
<ul>
<li>The <strong class="source-inline">Text</strong> property of the label is bound to the <strong class="source-inline">NumberOfServings</strong> property using the following binding statement: <strong class="source-inline">{Binding IngredientsList.NumberOfServings, Mode=OneWay}</strong>. The label displays the currently selected number of servings. The <strong class="source-inline">NumberOfServings</strong> property is part of the <strong class="source-inline">IngredientsList</strong> property on <strong class="source-inline">RecipeDetailViewModel</strong>, which is why the binding path is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">IngredientsList.NumberOfServings</strong></span><span class="No-Break">.</span><p class="list-inset">Since the user can change the number of servings, we use the <strong class="source-inline">OneWay</strong> binding mode. This ensures that when the value of <strong class="source-inline">NumberOfServings</strong> is updated, the UI reflects the <span class="No-Break">change accordingly.</span></p></li>
<li>The <strong class="source-inline">Value</strong> property of the <strong class="source-inline">Stepper</strong> control is bound to the <strong class="source-inline">NumberOfServings</strong> property using the following binding statement: <strong class="source-inline">{Binding IngredientsList.NumberOfServings, Mode=TwoWay}</strong>. <strong class="source-inline">Stepper</strong> allows the user to adjust the currently selected number <span class="No-Break">of servings.</span><p class="list-inset">Since the user can change the number of servings and the ViewModel should update accordingly, we use the <strong class="source-inline">TwoWay</strong> binding mode. This ensures that not only the UI reflects the <strong class="source-inline">NumberOfServings</strong> property’s value but also that the ViewModel is updated when the user modifies the number of servings via the <span class="No-Break"><strong class="source-inline">Stepper</strong></span><span class="No-Break"> control.</span></p><p class="list-inset">Increments or decrements to the <strong class="source-inline">NumberOfServings</strong> property made using <strong class="source-inline">Stepper</strong> will be reflected in the previously discussed label due to <strong class="source-inline">OneWay</strong> binding, and the property triggers the <span class="No-Break"><strong class="source-inline">PropertyChanged</strong></span><span class="No-Break"> event.</span></p></li>
</ul>
<p>In the XAML code, both bindings target properties within the <strong class="source-inline">IngredientsList</strong> property. In this <a id="_idIndexMarker239"/>example, all child elements of <strong class="source-inline">HorizontalStackLayout</strong> are bound to properties of the <strong class="source-inline">IngredientsList</strong> property in <strong class="source-inline">RecipeDetailViewModel</strong>. Since child elements inherit the binding context from their parent, it’s possible to move the binding to the <strong class="source-inline">IngredientsList</strong> property one level up, <span class="No-Break">if desired:</span></p>
<pre class="source-code">
&lt;HorizontalStackLayout Padding="10" <strong class="bold">BindingContext="{Binding IngredientsList}"</strong>&gt;
    &lt;Label Text="Number of servings:"
        VerticalOptions="Center" /&gt;
    &lt;Label
        Margin="10,0" FontAttributes="Bold"
        <strong class="bold">Text="{Binding NumberOfServings, Mode=OneWay}"</strong>
        VerticalOptions="Center" /&gt;
    &lt;Stepper
        BackgroundColor="{OnPlatform WinUI={StaticResource Primary}}"
        Maximum="8" Minimum="1"
        <strong class="bold">Value="{Binding NumberOfServings, Mode=TwoWay}"</strong>/&gt;
&lt;/HorizontalStackLayout&gt;</pre> <p>In the preceding example, we are binding the <strong class="source-inline">BindingContext</strong> of <strong class="source-inline">HorizontalStackLayout</strong> to the <strong class="source-inline">IngredientsList</strong> property of <strong class="source-inline">RecipeDetailViewModel</strong>. This allows us to simplify the binding statements on the child elements. Of course, you can only do this when all the child elements have the same <span class="No-Break">binding source.</span></p>
<p>As a final example, let’s implement a <strong class="source-inline">OneWayToSource</strong> data binding in our <strong class="bold">Recipes!</strong> app. Here our aim is to <a id="_idIndexMarker240"/>show the allergen information for each recipe. As not everyone is interested in viewing this information, we will not show it by default. However, we want to allow the user to tick a box to get <span class="No-Break">this information:</span></p>
<ol>
<li>Go to <strong class="source-inline">RecipesDetailViewModel</strong> and let it <span class="No-Break">implement </span><span class="No-Break"><strong class="source-inline">INotifyPropertyChanged</strong></span><span class="No-Break">:</span><pre class="source-code">
public class RecipeDetailViewModel : INotifyPropertyChanged
{
    ...
    public event PropertyChangedEventHandler? PropertyChanged;
}</pre></li> <li>Create an <strong class="source-inline">OnPropertyChanged</strong> method that accepts <strong class="source-inline">propertyName</strong> as a parameter and calls the <strong class="source-inline">PropertyChanged</strong> event, just like we did <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">IngredientsListViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
public void OnPropertyChanged([CallerMemberName] string? propertyName = null)
            =&gt; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));</pre></li> <li>Now, let’s add a <strong class="source-inline">ShowAllergenInformation</strong> property of type <strong class="source-inline">bool</strong>. This property will be <a id="_idIndexMarker241"/>responsible for the visibility of the allergen information <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">RecipeDetailPage</strong></span><span class="No-Break">:</span><pre class="source-code">
private bool _showAllergenInformation;
public bool ShowAllergenInformation
{
    get =&gt; _showAllergenInformation;
    set
    {
        if (_showAllergenInformation!= value)
        {
            _showAllergenInformation = value;
            OnPropertyChanged();
        }
    }
}</pre></li> <li>This property triggers the <strong class="source-inline">PropertyChanged</strong> event when its value changes. This allows us to bind it to the <strong class="source-inline">IsVisible</strong> property of a <strong class="source-inline">VisualElement</strong> so that whenever the value on the ViewModel changes, the UI element’s visibility is <span class="No-Break">updated automatically.</span></li>
<li>Finally, we can go to <strong class="source-inline">RecipeDetailPage</strong> and add the following XAML between the label that shows the recipe’s title and the <strong class="source-inline">HorizontalStackLayout</strong> that is bound <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">IngredientsList</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;VerticalStackLayout Padding="10"&gt;
    &lt;HorizontalStackLayout&gt;
        &lt;Label
            FontAttributes="Italic"
            Text="Show Allergen information"
            VerticalOptions="Center" /&gt;
        &lt;CheckBox <strong class="bold">IsChecked="{Binding ShowAllergenInformation, Mode=OneWayToSource}"</strong> /&gt;
    &lt;/HorizontalStackLayout&gt;
    &lt;Label <strong class="bold">IsVisible="{Binding ShowAllergenInformation, Mode=OneWay}"</strong>
        Text="ToDo: add allergen information" /&gt;
&lt;/VerticalStackLayout&gt;</pre><p class="list-inset">This XAML code <a id="_idIndexMarker242"/>snippet displays a label, <strong class="source-inline">"Show Allergen Information"</strong>, followed by a checkbox that the user can toggle if they want to view the recipe’s allergen information. The <strong class="source-inline">IsChecked</strong> property is bound using the <strong class="source-inline">OneWayToSource</strong> mode to the <strong class="source-inline">ShowAllergenInformation</strong> property in the ViewModel. This means that when the user checks the box, the property will <span class="No-Break">update accordingly.</span></p><p class="list-inset">Additionally, we bind the same <strong class="source-inline">ShowAllergenInformation</strong> property using the <strong class="source-inline">OneWay</strong> mode to the <strong class="source-inline">IsVisible</strong> property of a label. This label will eventually display the allergen information. As a result, when the user toggles the checkbox, it updates the <strong class="source-inline">ShowAllergenInformation</strong> property in the ViewModel, which in turn triggers <strong class="source-inline">PropertyChangedEvent</strong>. This event will be picked up by the binding engine, which will update the <strong class="source-inline">IsVisible</strong> property of <a id="_idIndexMarker243"/>the label, allowing the allergen information to be displayed or hidden based on the <span class="No-Break">user’s preference.</span></p></li> </ol>
<p class="callout-heading">INotifyPropertyChanged is not a requirement for the binding source</p>
<p class="callout">It is important to note that a binding target should always be a <strong class="source-inline">BindableProperty</strong> on a class that inherits from the <strong class="source-inline">BindableObject</strong>. The binding source, on the other hand, can be any property of any class. Most of the time, the binding source’s class implements the <strong class="source-inline">INotifyPropertyChanged</strong> interface, but that’s not a requirement. Only when using <strong class="source-inline">OneWay</strong> and <strong class="source-inline">TwoWay</strong> binding modes in scenarios where the values on the binding source can update and need to be reflected in the UI does the <strong class="source-inline">INotifyPropertyChanged</strong> interface need to be implemented. Alternatively, setting the <strong class="source-inline">BindingContext</strong> again would also update all the values, but that means everything needs to be reevaluated, which might not be a <span class="No-Break">good idea.</span></p>
<p>Now that we’ve seen how .NET MAUI supports data binding and different binding modes, let’s see how we can handle <span class="No-Break">user interactions.</span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Handling interactions with the ICommand interface</h1>
<p>In most applications, user interaction plays a vital role. Common interactions include clicking buttons, selecting items from a list, toggling switches, and more. To handle these interactions <a id="_idIndexMarker244"/>effectively while <a id="_idIndexMarker245"/>adhering to the MVVM pattern, it’s essential to utilize a robust mechanism that encapsulates the necessary logic within the ViewModel. The <strong class="source-inline">ICommand</strong> interface is designed specifically for this purpose, enabling you to manage user interactions in a clean and maintainable way while ensuring a clear separation of concerns between the View and the ViewModel. In this section, we’ll explore how to implement and use <strong class="source-inline">ICommand</strong> to handle user interactions in your .NET <span class="No-Break">MAUI application.</span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>The ICommand interface</h2>
<p>The <strong class="source-inline">ICommand</strong> interface plays a crucial role in handling user interactions within the context of the MVVM pattern in .NET MAUI applications. <strong class="source-inline">ICommand</strong> is part of the <strong class="source-inline">System.Windows.Input</strong> namespace <a id="_idIndexMarker246"/>and allows you to encapsulate the logic for executing a specific action and determining whether that action can be executed in a ViewModel. Again, this interface isn’t specific to .NET MAUI; it’s an integral part of the .<span class="No-Break">NET BCL.</span></p>
<p><strong class="source-inline">ICommand</strong> has two main members: <strong class="source-inline">Execute</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">CanExecute</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="bold">Execute (object parameter)</strong>: This method is what gets executed when the command <a id="_idIndexMarker247"/>is invoked. Through an optional parameter, additional data can be passed in <span class="No-Break">if needed.</span></li>
<li><strong class="bold">CanExecute (object parameter)</strong>: This method indicates whether the command <a id="_idIndexMarker248"/>can be executed in its current state or not. Optionally, a parameter can be passed in <span class="No-Break">if needed.</span></li>
</ul>
<p><strong class="source-inline">ICommand</strong> also exposes an event called <strong class="bold">CanExecuteChanged</strong>. This event is raised when the result of the <strong class="source-inline">CanExecute</strong> method changes, signaling the UI to re-evaluate whether the command can be executed. This enables automatic enabling/disabling of UI elements (such as buttons) based on the current state of <span class="No-Break">the application.</span></p>
<p>To use <strong class="source-inline">ICommand</strong> in your ViewModel, you can create a custom command class that implements the <strong class="source-inline">ICommand</strong> interface or use a built-in command class such as <strong class="source-inline">Microsoft.Maui.Controls.Command</strong>. There are also third-party implementations available such as <strong class="source-inline">CommunityToolkit.Mvvm.Input.RelayCommand</strong> from the MVVM Toolkit, which we will dive into in more detail in <a href="B20941_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Community Toolkits</em>. Typically, these implementations contain a method called <strong class="source-inline">ChangeCanExecute</strong> or <strong class="source-inline">NotifyCanExecuteChanged</strong>, which is called the <span class="No-Break"><strong class="source-inline">CanExecuteChanged</strong></span><span class="No-Break"> event.</span></p>
<p>Now that you’re familiar with the <strong class="source-inline">ICommand</strong> interface and its role in a ViewModel, it’s time to see it <span class="No-Break">in action.</span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Putting it into action</h2>
<p>As a simple <a id="_idIndexMarker249"/>demonstration, we want to allow users to add or remove a recipe as a favorite. For this, let’s add two buttons to <strong class="source-inline">RecipeDetailPage</strong>, right below the <strong class="source-inline">VerticalStackLayout</strong> that contains the <strong class="source-inline">CheckBox</strong> element to display the <span class="No-Break">allergen information:</span></p>
<pre class="source-code">
&lt;VerticalStackLayout&gt;
    &lt;Button <strong class="bold">Command="{Binding AddAsFavoriteCommand}"</strong> Text="Add as favorite" /&gt;
    &lt;Button <strong class="bold">Command="{Binding RemoveAsFavoriteCommand}"</strong> Text="Remove as favorite" /&gt;
&lt;/VerticalStackLayout&gt;</pre> <p>The first button’s <strong class="source-inline">Command</strong> property binds to the <strong class="source-inline">AddAsFavoriteCommand</strong> property on our binding source, <strong class="source-inline">RecipeDetailViewModel</strong>. This button should allow a user to mark a recipe as a favorite when the recipe is not yet favorited. The second button does the exact opposite: it should allow a user to remove a recipe as a favorite. Let’s take a look at the implementation of <span class="No-Break">both commands:</span></p>
<ol>
<li>In <strong class="source-inline">RecipeDetailViewModel</strong>, we can add an <span class="No-Break"><strong class="source-inline">IsFavorite</strong></span><span class="No-Break"> property:</span><pre class="source-code">
private bool _isFavorite = false;
public bool IsFavorite
{
    get =&gt; _isFavorite;
    private set
    {
        if (_isFavorite != value)
        {
            _isFavorite = value;
            OnPropertyChanged();
        }
    }
}</pre><p class="list-inset">This property holds a <strong class="source-inline">bool</strong> value to indicate whether the user has marked this recipe as a favorite <span class="No-Break">or not.</span></p></li> <li>Next, we need to add the two commands, <strong class="source-inline">AddAsFavoriteCommand</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">RemoveAsFavoriteCommand</strong></span><span class="No-Break">:</span><pre class="source-code">
public ICommand AddAsFavoriteCommand
{
    get;
}
public ICommand RemoveAsFavoriteCommand
{
    get;
}</pre><p class="list-inset">These are the two properties of type <strong class="source-inline">ICommand</strong> that the <strong class="source-inline">Command</strong> properties of the buttons <span class="No-Break">bind to.</span></p></li> <li>Now, we need to instantiate both commands. Whilst .NET contains an <strong class="source-inline">ICommand</strong> interface, it <a id="_idIndexMarker250"/>doesn’t contain a concrete implementation. .NET MAUI, on the other hand, does have one! In order to access this implementation from the <strong class="source-inline">Recipes.Client.Core</strong> project, we need to configure the project to use the .NET <span class="No-Break">MAUI framework.</span><p class="list-inset">In the <strong class="bold">Solution Explorer</strong>, select the <strong class="source-inline">Recipes.Client.Core</strong> project. This should open up the associated <strong class="source-inline">csproj</strong> file, wherein you need to <span class="No-Break">add </span><span class="No-Break"><strong class="source-inline">&lt;UseMaui&gt;true&lt;/UseMaui&gt;</strong></span><span class="No-Break">:</span></p><pre class="source-code">
&lt;PropertyGroup&gt;
  &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
  &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
<strong class="bold">  &lt;UseMaui&gt;true&lt;/UseMaui&gt;</strong>
  &lt;Nullable&gt;enable&lt;/Nullable&gt;
&lt;/PropertyGroup&gt;</pre><p class="list-inset">This allows us to access .NET MAUI-specific libraries from our <strong class="source-inline">Core</strong> project, such as <strong class="source-inline">Microsoft.Maui.Controls.Command</strong>, which <span class="No-Break">implements </span><span class="No-Break"><strong class="source-inline">ICommand</strong></span><span class="No-Break">.</span></p></li> <li>In the <a id="_idIndexMarker251"/>constructor of <strong class="source-inline">RecipeDetailViewModel</strong>, we can now instantiate <strong class="source-inline">AddAsFavoriteCommand</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">RemoveAsFavoriteCommand</strong></span><span class="No-Break">:</span><pre class="source-code">
private void AddAsFavorite() =&gt; IsFavorite = true;
private void RemoveAsFavorite() =&gt; IsFavorite = false;
private bool CanAddAsFavorite()
    =&gt; !IsFavorite;
private bool CanRemoveAsFavorite()
    =&gt; IsFavorite;
public RecipeDetailViewModel()
{
<strong class="bold">    AddAsFavoriteCommand =</strong>
<strong class="bold">        new Command(AddAsFavorite, CanAddAsFavorite);</strong>
<strong class="bold">    RemoveAsFavoriteCommand =</strong>
<strong class="bold">        new Command(RemoveAsFavorite, CanRemoveAsFavorite);</strong>
}</pre><p class="list-inset">In this example, we have two commands on the ViewModel: <strong class="source-inline">AddAsFavoriteCommand</strong> and <strong class="source-inline">RemoveAsFavoriteCommand</strong>. Each command is created with an associated <strong class="source-inline">Action</strong> and a <strong class="source-inline">Func&lt;bool&gt;</strong> to determine <span class="No-Break">its executability.</span></p><p class="list-inset"><strong class="source-inline">AddAsFavoriteCommand</strong> has an <strong class="source-inline">AddAsFavorite</strong> method as its action, which simply sets the <strong class="source-inline">IsFavorite</strong> property to <strong class="source-inline">true</strong>. Its <strong class="source-inline">CanExecute</strong> method is determined by the <strong class="source-inline">CanAddAsFavorite</strong> method, which returns <strong class="source-inline">true</strong> when the <strong class="source-inline">IsFavorite</strong> property has a value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p><p class="list-inset">On the other<a id="_idIndexMarker252"/> hand, <strong class="source-inline">RemoveAsFavoriteCommand</strong> has a <strong class="source-inline">RemoveAsFavorite</strong> method as its action, which sets the <strong class="source-inline">IsFavorite</strong> property to <strong class="source-inline">false</strong>. The <strong class="source-inline">CanRemoveAsFavorite</strong> method is provided as the <strong class="source-inline">CanExecute</strong> check for this command, and it returns <strong class="source-inline">true</strong> when the <strong class="source-inline">IsFavorite</strong> property has a value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">It’s important to note that it is up to the control to check and adhere to the <strong class="source-inline">CanExecute</strong> method. It should not be a thing to blindly rely on, as it might not be implemented or work the way you expect. Make sure to read the control’s documentation and test <span class="No-Break">it thoroughly.</span></p>
<p class="list-inset">In summary, when the <strong class="source-inline">IsFavorite</strong> property is <strong class="source-inline">true</strong>, only <strong class="source-inline">RemoveAsFavoriteCommand</strong> can be executed, while  <strong class="source-inline">AddAsFavoriteCommand</strong> cannot be. Conversely, when the <strong class="source-inline">IsFavorite</strong> property is <strong class="source-inline">false</strong>, <strong class="source-inline">AddAsFavoriteCommand</strong> can be executed, and <strong class="source-inline">RemoveAsFavoriteCommand</strong> cannot be. This ensures that the appropriate command is available for execution based on the current state of the <span class="No-Break"><strong class="source-inline">IsFavorite</strong></span><span class="No-Break"> property.</span></p>
<ol>
<li value="5">There is just one piece of the puzzle missing: whenever the <strong class="source-inline">IsFavorite</strong> property’s value changes, the <strong class="source-inline">CanExecute</strong> method of both commands needs to be re-evaluated. In order to do that, we need to update the setter of the <span class="No-Break"><strong class="source-inline">IsFavorite</strong></span><span class="No-Break"> property:</span><pre class="source-code">
if (_isFavorite != value)
{
    _isFavorite = value;
    OnPropertyChanged();
    <strong class="bold">((Command)AddAsFavoriteCommand).ChangeCanExecute();</strong>
    <strong class="bold">((Command)RemoveAsFavoriteCommand).ChangeCanExecute();</strong>
}</pre></li> </ol>
<p>With all this code in place, we can run the app again. By default, only the first button (bound to <strong class="source-inline">AddAsFavoriteCommand</strong>) is enabled when the recipe is not a user favorite. Upon clicking this button, the <strong class="source-inline">IsFavorite</strong> property is updated, and the <strong class="source-inline">ChangeCanExecute</strong> method is called for both commands. As a result, the first button becomes disabled, while the second button (bound to <strong class="source-inline">RemoveAsFavoriteCommand</strong>) is automatically enabled. This ensures that the correct button is <a id="_idIndexMarker253"/>enabled or disabled based on the <span class="No-Break"><strong class="source-inline">IsFavorite</strong></span><span class="No-Break"> property.</span></p>
<p>Alternatively, we could also use a single command and use a <strong class="source-inline">CommandParameter</strong> to handle the toggling of the <span class="No-Break"><strong class="source-inline">IsFavorite</strong></span><span class="No-Break"> property:</span></p>
<ol>
<li>For that, let’s add a new <strong class="source-inline">SetFavoriteCommand</strong> property of type <strong class="source-inline">ICommand</strong> and initialize it in the constructor <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
public RecipeDetailViewModel()
{
    ...
    SetFavoriteCommand =
        new Command&lt;bool&gt;(SetFavorite, CanSetFavorite);
}
private bool CanSetFavorite(bool isFavorite)
    =&gt; IsFavorite != isFavorite;
private void SetFavorite(bool isFavorite)
    =&gt; IsFavorite = isFavorite;</pre><p class="list-inset">By assigning the command to an instance of <strong class="source-inline">Command&lt;bool&gt;</strong>, we are specifying that we expect a parameter of type bool in both the <strong class="source-inline">Execute</strong> and <span class="No-Break"><strong class="source-inline">CanExecute</strong></span><span class="No-Break"> methods.</span></p></li> <li>In the setter of the <strong class="source-inline">IsFavorite</strong> property, we now need to call the <strong class="source-inline">CanExecuteChanged</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">SetFavoriteCommand</strong></span><span class="No-Break">.</span></li>
<li>Finally, we can update <a id="_idIndexMarker254"/>the binding statements on <span class="No-Break">both buttons:</span><pre class="source-code">
&lt;Button
    <strong class="bold">Command="{Binding SetFavoriteCommand}"</strong>
    <strong class="bold">CommandParameter="{x:Boolean true}"</strong>
    Text="Add as favorite" /&gt;
&lt;Button
    <strong class="bold">Command="{Binding SetFavoriteCommand}"</strong>
    <strong class="bold">CommandParameter="{x:Boolean false}"</strong>
    Text="Remove as favorite" /&gt;</pre><p class="list-inset">Both buttons call the same command, but they each pass in a different parameter, which gets passed to both the <strong class="source-inline">Execute</strong> and <span class="No-Break"><strong class="source-inline">CanExecute</strong></span><span class="No-Break"> methods.</span></p></li> </ol>
<p class="callout-heading">UseMaui and MVVM best practices</p>
<p class="callout">In this chapter, we introduced the <strong class="source-inline">UseMaui</strong> property in our <strong class="source-inline">Core</strong> project, which may seem to contradict our previous statements about ViewModels being framework-agnostic. While adhering to the MVVM pattern, it is recommended to keep the ViewModels free from any framework-specific dependencies. However, in this specific case, we have opted for a more practical approach to demonstrate an implementation of <strong class="source-inline">ICommand</strong> through the <strong class="source-inline">Microsoft.Maui.Controls.Command</strong> class. In a strictly MVVM-compliant scenario, you would want to avoid such dependencies in your ViewModels to ensure maximum flexibility <span class="No-Break">and maintainability.</span></p>
<p class="callout">In <a href="B20941_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Community Toolkits</em>, we will take a look at the possibility of how to improve this code so that it follows these best practices <span class="No-Break">more closely.</span></p>
<p>As a little extra, we also might want to display an icon indicating whether a recipe is a favorite or not. The visibility of this icon can be bound to the <strong class="source-inline">IsFavorite</strong> property. When toggling this <a id="_idIndexMarker255"/>property through the buttons and commands we’ve just created, the icon’s visibility will be updated <span class="No-Break">as well:</span></p>
<ol>
<li>First, let’s add the <span class="No-Break"><strong class="source-inline">Chapter 03</strong></span><strong class="source-inline">/Assets/favorite.png</strong> file to the <strong class="source-inline">Resources/Images</strong> folder in the <strong class="bold">Recipes.Mobile</strong> project. Right-click on this folder in the <strong class="bold">Solution Explorer</strong>, select <strong class="bold">Add</strong> | <strong class="bold">Existing Item…</strong>, and select the <strong class="source-inline">favorite.png</strong> file. You might need to adjust the file type filter in the file picker popup to include <strong class="bold">All Files (*.*)</strong> in order to be able to see the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">png</strong></span><span class="No-Break"> file.</span></li>
<li>In <strong class="source-inline">RecipeDetailPage.xaml</strong>, add the following XAML directly below the <strong class="source-inline">Label</strong> displaying the <span class="No-Break">recipe’s title:</span><pre class="source-code">
&lt;Image
    Margin="5" HeightRequest="35"
    IsVisible="{Binding IsFavorite}"
    Source="favorite.png" WidthRequest="35" /&gt;</pre><p class="list-inset">Now when we tap the <strong class="bold">Add as favorite</strong> or <strong class="bold">Remove as favorite</strong> button, you should see the favorite icon appearing <span class="No-Break">or disappearing.</span></p></li> </ol>
<p>The <strong class="source-inline">ICommand</strong> interface plays a vital role in implementing the MVVM. By encapsulating user interactions within commands, it promotes a clean separation of concerns between the View and ViewModel. This allows for more maintainable, testable, and modular code. As demonstrated, <strong class="source-inline">ICommand</strong>, along with its <strong class="source-inline">CanExecute</strong> functionality, ensures that the appropriate actions are available to users based on the application’s state, further enhancing the user experience. By leveraging <strong class="source-inline">ICommand</strong>, developers can effectively implement the <span class="No-Break">MVVM pattern.</span></p>
<p>As we’ve explored the <strong class="source-inline">ICommand</strong> interface, you may be interested to know that there are additional tools <a id="_idIndexMarker256"/>and resources available for implementing MVVM in .NET MAUI. Thanks to the fantastic .NET and .NET MAUI community, various Community Toolkits provide even more support for the MVVM pattern in <span class="No-Break">your projects.</span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/>Summary</h1>
<p>In this chapter, we delved into the core components that enable the MVVM pattern in .NET MAUI. We discussed the essential building blocks, including <strong class="source-inline">BindableObject</strong>, <strong class="source-inline">BindableProperty</strong>, and <strong class="source-inline">BindingContext</strong>, and how they facilitate seamless communication between the View and ViewModel. Furthermore, we examined the importance of the <strong class="source-inline">INotifyPropertyChanged</strong> interface in notifying the UI of changes in ViewModel properties and demonstrated how the <strong class="source-inline">ICommand</strong> interface helps handle user interactions in a decoupled manner. By understanding these fundamental concepts, it becomes evident why .NET MAUI and the MVVM pattern are such a <span class="No-Break">harmonious match.</span></p>
<p>As we move on to <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Data Binding in .NET MAUI</em>, we will take a closer look at data binding, diving deeper into topics such as value converters, fallback values, element and relative binding, multi-bindings, and compiled bindings. This will enable you to leverage the full power of data binding. Let’s continue <span class="No-Break">our journey!</span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li>Bindable <span class="No-Break">properties: </span><a href="https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties</span></a></li>
<li>The <strong class="source-inline">BindableObject</strong> <span class="No-Break">class: </span><a href="https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject"><span class="No-Break">https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject</span></a></li>
<li>The <strong class="source-inline">INotifyPropertyChanged</strong> <span class="No-Break">interface: </span><a href="https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged"><span class="No-Break">https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged</span></a></li>
</ul>
</div>
</div></body></html>