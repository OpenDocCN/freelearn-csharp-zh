["```cs\nvoid PerformETL() \n{ \n    ExtractData(); \n    TransformData(); \n    LoadData(); \n} \n\n```", "```cs\nlet performETL params : unit = \n    let inputCollection = extractData params \n    let outputCollection = transformData inputCollection \n    loadData outputCollection \n\n```", "```cs\nlet performETL params : unit = \n  params  \n   |> extractData \n   |> transformData \n   |> loadData \n\n```", "```cs\npartition: predicate:('T -> bool) -> source:'T collection \n           -> ('T collection * 'T collection) \n\n```", "```cs\nlet rec qsort : int list -> _ = function \n   | [] -> [] \n   | x::xs -> \n       let less, greater = List.partition ((>) x) xs \n       qsort less @ x :: qsort greater \n\n```", "```cs\nList.partition: predicate:('T -> bool) -> list:'T list \n           -> ('T list * 'T list) \nArray.partition : predicate:('T -> bool) -> array:'T[] \n           -> 'T[] * 'T[] \n\n```", "```cs\nname: <zero or more input parameters> -> collection<'T> \n\n```", "```cs\nlet el = List.empty<string> \n// val el : string list = [] \nlet ea = Array.empty<float> \n// val ea : float [] = [||] \nlet es = Seq.empty<int -> string> \n// val es : seq<(int -> string)> \n// es;; \n// val it : seq<(int -> string)> = seq [] \n\n```", "```cs\nlet ell: string list = [] \n// val ell : string list = [] \nlet eal: float[] = [||] \n// val eal : float [] = [||] \nlet esl: seq<int -> string> = seq [] \n// val esl : seq<(int -> string)> = [] \n// esl;; \n// val it : seq<(int -> string)> = [] \n\n```", "```cs\nlet sl = List.singleton \"I'm alone\" \n// val sl : string list = [\"I'm alone\"] \nlet sa = Array.singleton 42.0 \n// val sa : float [] = [|42.0|] \nlet ss = Seq.singleton (fun (x:int) -> x.ToString()) \n// val ss : seq<(int -> string)> \n// ss;; \n// val it : seq<(int -> string)> = seq [<fun:ss@24>] \n\n```", "```cs\nlet sll = [\"I'm alone\"] \n// val sll : string list = [\"I'm alone\"] \nlet sal = [| 42.0 |] \n// val sal : float [] = [|42.0|] \nlet ssl = seq [fun (x:int) -> x.ToString()] \n// val ssl : seq<(int -> string)> = [<fun:ssl@24>] \n\n```", "```cs\nList.replicate: count:int -> initial:'T -> 'T list \nArray.replicate: count:int -> initial:'T -> 'T[] \nSeq.replicate: count:int -> initial:'T -> seq<'T> \n\n```", "```cs\nlet fl = List.replicate 3 \"blah\" \n// val fl : string list = [\"blah\"; \"blah\"; \"blah\"] \nlet fa = Array.replicate 3 42 \n// val fa : int [] = [|42; 42; 42|] \nlet fs = Seq.replicate 3 42.0 \n// val fs : seq<float> \n// fs;; \n// val it : seq<float> = seq [42.0; 42.0; 42.0] \n\n```", "```cs\nlet fll = [\"blah\";\"blah\";\"blah\"] \n// val fll : string list = [\"blah\"; \"blah\"; \"blah\"] \nlet fal = [| for i in 1..3 -> 42 |] \n// val fal : int [] = [|42; 42; 42|] \nlet fsl = seq { for i in 1..3 do yield 42.0 } \n// val fsl : seq<float> \n// fsl;; \n// val it : seq<float> = seq [42.0; 42.0; 42.0] \n\n```", "```cs\nArray.create: count:int -> value:'T -> 'T[] \nArray.zeroCreate: count:int -> 'T[] \nlet fac = Array.create 3 \"blah\" \n// val fac : string [] = [|\"blah\"; \"blah\"; \"blah\"|] \nlet fazc: string[] = Array.zeroCreate 3 \n// val fazc : string [] = [|null; null; null|] \nlet fazci = Array.zeroCreate<int> 3 \n// val fazci : int [] = [|0; 0; 0|] \n\n```", "```cs\nList.init: length:int -> initializer:(int -> 'T) -> 'T list \nArray.init : count:int -> initializer:(int -> 'T) -> 'T[] \nSeq. init: count:int -> initializer:(int -> 'T) -> seq<'T> \n\n```", "```cs\nlet vl = List.init 4 ((*) 2) \n// val vl : int list = [0; 2; 4; 6]  \nlet va = let src = \"closure\" in Array.init src.Length (fun i -> src.[i]) \n\n// val va : char [] = [|'c'; 'l'; 'o'; 's'; 'u'; 'r'; 'e'|] \nlet vs = Seq.init 3 id  \n// val vs : seq<int> \n// vs;; \n// val it : seq<int> = seq [0; 1; 2] \n\n```", "```cs\nlet vll = [0; 2; 4; 6] \n// val vll : int list = [0; 2; 4; 6] \nlet vlc = [ for i in 0..3 -> i * 2 ] \n// val vlc : int list = [0; 2; 4; 6] \nlet vlcy = [ for i in 0..3 do yield i * 2 ] \n// val vlcy : int list = [0; 2; 4; 6] \nlet ``val`` = \n    let src = \"closure\" in \n    [| src.[0]; src.[1]; src.[2]; src.[3]; src.[4]; src.[5]; src.[6] |] \n// val val : char [] = [|'c'; 'l'; 'o'; 's'; 'u'; 'r'; 'e'|] \nlet vac = \n    let src = \"closure\" in \n    [| for i in 1..src.Length -> src.[i - 1] |] \n// val vac : char [] = [|'c'; 'l'; 'o'; 's'; 'u'; 'r'; 'e'|] \nlet vacy = \n    let src = \"closure\" in \n    [| for i in 1..src.Length do \n       yield src.[i - 1] |> System.Char.ToUpper |] \n// val vacy : char [] = [|'C'; 'L'; 'O'; 'S'; 'U'; 'R'; 'E'|] \nlet vsc = seq { for i in 0..2..6 -> i} \n// vsc;; \n// val it : seq<int> = seq [0; 2; 4; 6] \nlet vscy = seq { for i in 0..2..6 do yield 6 - i } \n// vscy;; \n// val it : seq<int> = seq [6; 4; 2; 0] \n\n```", "```cs\nlet randoms lo hi len = \n    let r = System.Random() \n    let max = hi + 1 \n    let rec generate n = [ \n        if n < len then \n            yield r.Next(lo, max) \n            yield! generate (n + 1) \n    ] \n    generate 0 \n\n```", "```cs\nList.unfold<'T,'State> : generator:('State -> ('T * 'State) option) -> state:'State -> 'T list \nArray.unfold<'T,'State> : generator:('State -> ('T * 'State) option) -> state:'State -> 'T[] \nSeq.unfold   : generator:('State -> ('T * 'State) option) -> state:'State -> seq<'T> \n\n```", "```cs\nlet collatzLib n = \n    Seq.unfold (fun n -> match n with \n                            | 0L -> None \n                            | 1L -> Some(1L, 0L) \n                            | n when n % 2L = 0L -> Some(n, n/2L) \n                            | n -> Some(n, 3L * n + 1L)) n \n\n```", "```cs\nlet rec collatzCustom num =  \n    seq { \n        yield num \n        match num with \n        | 1L -> () \n        | x when x % 2L = 0L ->yield! collatzCustom (x/2L) \n        | x ->yield! collatzCustom ((x * 3L) + 1L) \n        } \n\n```", "```cs\n[2L..1000000L] |> Seq.map (collatzLib >> Seq.length) |> Seq.max \n\n```", "```cs\n[2L..1000000L] |> Seq.map (collatzCustom >> Seq.length) |> Seq.max \n\n```", "```cs\nSeq.initInfinite: initializer:(int -> 'T) -> seq<'T> \n\n```", "```cs\nList.reduce: reduction:('T -> 'T -> 'T) -> list:'T list -> 'T \nList.reduceBack: reduction:('T -> 'T -> 'T) -> list:'T list -> 'T \nArray.reduce: reduction:('T -> 'T -> 'T) -> array:'T[] -> 'T \nArray.reduceBack: reduction:('T -> 'T -> 'T) -> array:'T[] -> 'T \nSeq.reduce: reduction:('T -> 'T -> 'T) -> source:seq<'T> -> 'T \n\n```", "```cs\n...r (r (r c.[0] c.[1]) c.[2]) c.[3]... \n\n```", "```cs\n... (r c.[n - 3] (r c.[n - 2] (r c.[n - 1] c.[n])) ... \n\n```", "```cs\n// associative operation min \nList.reduce min [1;2;3;4;5] \n// val it : int = 1 \nList.reduceBack min [1;2;3;4;5] \n// val it : int = 1 \n\n// non-associative operation (-) \nList.reduce (-) [1;2;3;4;5] \n// val it : int = -13 \nList.reduceBack (-) [1;2;3;4;5] \n// val it : int = 3 \n\n```", "```cs\nList.average : list:^T list -> ^T     \n    when ^T : (static member ( + ) : ^T * ^T -> ^T)  \n    and  ^T : (static member DivideByInt : ^T*int -> ^T)  \n    and  ^T : (static member Zero : ^T) \nArray.average : array:^T[] -> ^T     \n    when ^T : (static member ( + ) : ^T * ^T -> ^T)  \n    and  ^T : (static member DivideByInt : ^T*int -> ^T)  \n    and  ^T : (static member Zero : ^T) \nSeq.average : source:seq<(^T)> -> ^T     \n    when ^T : (static member ( + ) : ^T * ^T -> ^T)  \n    and  ^T : (static member DivideByInt : ^T*int -> ^T)  \n    and  ^T : (static member Zero : ^T) \nList.max : list:'T list -> 'T when 'T : comparison \nArray.max : array:'T[] -> 'T  when 'T : comparison \nSeq.max : source:seq<'T> -> 'T when 'T : comparison \nList.min : list:'T list -> 'T when 'T : comparison \nArray.min : array:'T[] -> 'T  when 'T : comparison \nSeq.min : source:seq<'T> -> 'T when 'T : comparison \nList.sum : list:^T list -> ^T  \n    when ^T : (static member ( + ) : ^T * ^T -> ^T)  \n    and  ^T : (static member Zero : ^T) \nArray.sum : array: ^T[] -> ^T  \n    when ^T : (static member ( + ) : ^T * ^T -> ^T)  \n    and  ^T : (static member Zero : ^T) \nSeq.sum : source:seq<(^T)> -> ^T  \n    when ^T : (static member ( + ) : ^T * ^T -> ^T)  \n    and  ^T : (static member Zero : ^T) \n\n```", "```cs\nList.averageBy : projection:('T -> ^U) -> list:'T list  -> ^U     \n    when ^U : (static member ( + ) : ^U * ^U -> ^U)  \n    and  ^U : (static member DivideByInt : ^U*int -> ^U)  \n    and  ^U : (static member Zero : ^U) \nArray.averageBy : projection:('T -> ^U) -> array:'T[] -> ^U     \n    when ^U : (static member ( + ) : ^U * ^U -> ^U)  \n    and  ^U : (static member DivideByInt : ^U*int -> ^U)  \n    and  ^U : (static member Zero : ^U) \nSeq.averageBy : projection:('T -> ^U) -> source:seq<'T>  -> ^U     \n    when ^U : (static member ( + ) : ^U * ^U -> ^U)  \n    and  ^U : (static member DivideByInt : ^U*int -> ^U)  \n    and  ^U : (static member Zero : ^U) \nList.maxBy : projection:('T -> 'U) -> list:'T list -> 'T \n    when 'U : comparison \nArray.maxBy  : projection:('T -> 'U) -> array:'T[] -> 'T \n    when 'U : comparison \nSeq.maxBy : projection:('T -> 'U) -> source:seq<'T> -> 'T \n    when 'U : comparison \nList.minBy : projection:('T -> 'U) -> list:'T list -> 'T \n    when 'U : comparison \nArray.minBy : projection:('T -> 'U) -> array:'T[] -> 'T \n    when 'U : comparison \nSeq.minBy : projection:('T -> 'U) -> source:seq<'T> -> 'T \n    when 'U : comparison \nList.sumBy : projection:('T -> ^U) -> list:'T list -> ^U  \n    when ^U : (static member ( + ) : ^U * ^U -> ^U)  \n    and  ^U : (static member Zero : ^U) \nArray.sumBy : projection:('T -> ^U) -> array:'T[] -> ^U  \n    when ^U : (static member ( + ) : ^U * ^U -> ^U)  \n    and  ^U : (static member Zero : ^U) \nSeq.sumBy : projection:('T -> ^U) -> source:seq<'T>  -> ^U  \n    when ^U : (static member ( + ) : ^U * ^U -> ^U)  \n    and  ^U : (static member Zero : ^U) \n\n```", "```cs\nList.sumBy (fun x -> -x) [1;2;3] \n// val it : int = -6 \nList.minBy (fun x -> -x) [1;2;3] \n// val it : int = 3 \n\n```", "```cs\nList.length: list:'T list -> int \nArray.length: array:'T[] -> int \nSeq.length: source:seq<'T> -> int \n\n```", "```cs\nList.countBy projection:('T -> 'Key) -> list:'T list \n    -> ('Key * int) list \n    when 'Key : equality \nArray.countBy : projection:('T -> 'Key) -> array:'T[] \n    -> ('Key * int)[] \n    when 'Key : equality \nSeq.countBy projection:('T -> 'Key) -> source:seq<'T> \n    -> seq<'Key * int> \n    when 'Key : equality \n\n```", "```cs\nrandoms 1 6 10000000 \n|> Seq.countBy id \n|> Seq.toList \n|> printfn \"%A\" \n\n```", "```cs\nSeq.cache: source:seq<'T> -> seq<'T> \nSeq.delay: generator:(unit -> seq<'T>) -> seq<'T> \nSeq.readonly : source:seq<'T> -> seq<'T> \n\n```", "```cs\nlet eagerList = [ \n    printfn \"Evaluating eagerList\" \n    yield \"I\" \n    yield \"am\" \n    yield \"an\" \n    yield \"eager\" \n    yield \"list\" \n] \n// Evaluating eagerList \n// val eagerList : string list = [\"I\"; \"am\"; \"an\"; \"eager\"; \"list\"] \nlet delayedEagerList = Seq.delay(fun () -> ([ printfn \"Evaluating \n                                              eagerList\" \n                                            yield \"I\" \n                                            yield \"am\" \n                                            yield \"an\" \n                                            yield \"eager\" \n                                            yield \"list\" \n                                        ] |> Seq.ofList)) \n// val delayedEagerList : seq<string> \n\ndelayedEagerList |> Seq.toList \n// Evaluating eagerList \n// val it : string list = [\"I\"; \"am\"; \"an\"; \"eager\"; \"list\"] \n\n```", "```cs\nlet src = [|1;2;3|] \nlet srcAsSeq = src :> seq<_> \nlet backdoor = srcAsSeq :?> int array \nbackdoor.[0] <- 10 \nprintfn \"%A\" src \n// [|10; 2; 3|] \n\n```", "```cs\nlet srcAsROSeq = src |> Seq.readonly \nlet tryBackDoor = srcAsROSeq :?> int array \n// System.InvalidCastException: Unable to cast object of type 'mkSeq@541[System.Int32]' to type 'System.Int32[]'. \n\n```", "```cs\nList.toSeq list:'T list -> seq<'T> \nList.ofSeq: source:seq<'T> -> 'T list \nList.toArray: list:'T list -> 'T[] \nList.ofArray : array:'T[] -> 'T list \nArray.toSeq: array:'T[] -> seq<'T> \nArray.ofSeq: source:seq<'T> -> 'T[] \nArray.toList: array:'T[] -> 'T list \nArray.ofList: list:'T list -> 'T[] \nSeq.toList: source:seq<'T> -> 'T list \nSeq.ofList: source:'T list -> seq<'T> \nSeq.toArray: source:seq<'T> -> 'T[] \nSeq.ofArray: source:'T[] -> seq<'T> \n\n```", "```cs\nSeq.cast: source:IEnumerable -> seq<'T> \n\n```", "```cs\nlet s = System.Collections.Stack() \ns.Push(1) \ns.Push('2') \ns.Push(\"xyzzy\") \ns |> Seq.cast<_> |> printfn \"%A\" \n// seq [\"xyzzy\"; '2'; 1] \n\n```", "```cs\nList.head: list:'T list -> 'T \nArray.head: array:'T[] -> 'T \nSeq.head: source:seq<'T> -> 'T \n\nList.tryHead: list:'T list -> 'T option \nArray.tryHead: array:'T[] -> 'T option  \nSeq.tryHead: source:seq<'T> -> 'T option \n\nList.last: list:'T list -> 'T \nArray.last: list:'T list -> 'T \nSeq.last: source:seq<'T> -> 'T \n\nList.tryLast: list:'T list -> 'T option \nArray.tryLast: list:'T list -> 'T option \nSeq.tryLast: source:seq<'T> -> 'T option \n\nList.item: index:int -> list:'T list -> 'T \nArray.item: index:int -> array:'T[] -> 'T \nArray.get: array:'T[] -> index:int -> 'T \nSeq.item: index:int -> source:seq<'T> -> 'T \n\nList.tryItem: index:int -> list:'T list -> 'T option \nArray.tryItem: index:int -> array:'T[] -> 'T option \nSeq.tryItem: index:int -> source:seq<'T> -> 'T option \n\nList.nth: list:'T list -> index:int -> 'T // obsolete \nSeq.nth: index:int -> source:seq<'T> -> 'T // obsolete \n\nList.exactlyOne: list:'T list -> 'T \nArray.exactlyOne: array:'T[] -> 'T \nSeq.exactlyOne: source:seq<'T> -> 'T \n\n```", "```cs\nList.head<int> [] \n// System.ArgumentException: The input list was empty. \nList.tryHead<int> [] \n// val it : int option = None \n\n```", "```cs\nlet ll = [1;2;3;4] \nList.head ll = ll.[0] \n//val it : bool = true \n\n```", "```cs\nList.take: count:int -> list:'T list -> 'T list \nArray.take: count:int -> array:'T[] -> 'T[] \nSeq.take: count:int -> source:seq<'T> -> seq<'T> \n\nList.takeWhile: predicate:('T -> bool) -> list:'T list -> 'T list \nArray.takeWhile: predicate:('T -> bool) -> array:'T[] -> 'T[] \nSeq.takeWhile: predicate:('T -> bool) -> source:seq<'T> -> seq<'T> \n\nList.truncate: count:int -> list:'T list -> 'T list \nArray.truncate: count:int -> array:'T[] -> 'T[] \nSeq.truncate: count:int -> source:seq<'T> -> seq<'T> \n\nList.skip: count:int -> list: 'T list -> 'T list \nArray.skip: count:int -> array:'T[] -> 'T[] \nSeq.skip: count:int -> source:seq<'T> -> seq<'T> \n\nList.skipWhile: predicate:('T -> bool) -> list:'T list -> 'T list \nArray.skipWhile: predicate:('T -> bool) -> array:'T[] -> 'T[] \nSeq.skipWhile: predicate:('T -> bool) -> source:seq<'T> -> seq<'T> \n\nList.tail: list:'T list -> 'T list \nArray.tail: array:'T[] -> 'T[] \nSeq.tail: source:seq<'T> -> seq<'T> \n\nList.filter: predicate:('T -> bool) -> list:'T list -> 'T list \nArray.filter: predicate:('T -> bool) -> array:'T[] -> 'T[] \nSeq.filter: predicate:('T -> bool) -> source:seq<'T> -> seq<'T> \n\nList.except: itemsToExclude:seq<'T> -> list:'T list -> 'T list when 'T : equality \nArray.except: itemsToExclude:seq<'T> -> array:'T[] -> 'T[] when 'T : equality \nSeq.except: itemsToExclude:seq<'T> -> source:seq<'T> -> seq<'T> when 'T : equality \n\nList.choose: chooser:('T -> 'U option) -> list:'T list -> 'U list \nArray.choose: chooser:('T -> 'U option) -> array:'T[] -> 'U[] \nSeq.choose: chooser:('T -> 'U option) -> source:seq<'T> -> seq<'U> \n\nList.where: predicate:('T -> bool) -> list:'T list -> 'T list \nArray.where: predicate:('T -> bool) -> array:'T[] -> 'T[] \nSeq.where: predicate:('T -> bool) -> source:seq<'T> -> seq<'T> \n\nArray.sub: array:'T[] -> startIndex:int -> count:int -> 'T[] \n\nList.distinct: list:'T list -> 'T list when 'T : equality \nArray.distinct: array:'T[] -> 'T[] when 'T : equality \nSeq.distinct: source:seq<'T> -> seq<'T> when 'T : equality \n\nList.distinctBy: projection:('T -> 'Key) -> list:'T list -> 'T list when 'Key : equality \nArray.distinctBy: projection:('T -> 'Key) -> array:'T[] -> 'T[] when 'Key : equality \nSeq.distinctBy: projection:('T -> 'Key) -> source:seq<'T> -> seq<'T> when 'Key : equality \n\n```", "```cs\n[|10;20;30;40;50;60|].[2..4] \n// val it : int [] = [|30; 40; 50|] \n\n```", "```cs\nlet numbers = [1;2;3;4;5;6;7;8] \nList.filter (fun x -> (%) x 2 = 0) numbers = List.where (fun x -> (%) x 2 = 0) numbers \n// val it : bool = true \n\n```", "```cs\nList.find: predicate:('T -> bool) -> list:'T list -> 'T \nArray.find: predicate:('T -> bool) -> array:'T[] -> 'T \nSeq.find: predicate:('T -> bool) -> source:seq<'T> -> 'T \n\nList.tryFind: predicate:('T -> bool) -> list:'T list -> 'T option \nArray.tryFind: predicate:('T -> bool) -> array:'T[] -> 'T option \nSeq.tryFind: predicate:('T -> bool) -> source:seq<'T> -> 'T option \n\nList.findIndex: predicate:('T -> bool) -> list:'T list -> int \nArray.findIndex: predicate:('T -> bool) -> array:'T[] -> int \nSeq.findIndex: predicate:('T -> bool) -> source:seq<'T> -> int \n\nList.tryFindIndex: predicate:('T -> bool) -> list:'T list -> int option \nList.tryFindIndexBack: predicate:('T -> bool) -> list:'T list -> int option \n\nList.findBack: predicate:('T -> bool) -> list:'T list -> 'T \nArray.findBack: predicate:('T -> bool) -> array:'T[] -> 'T \nSeq.findBack: predicate:('T -> bool) -> source:seq<'T> -> 'T \n\nList.tryFindBack: predicate:('T -> bool) -> list:'T list -> 'T option \nArray.tryFindBack: predicate:('T -> bool) -> array:'T[] -> 'T option \nSeq.tryFindBack: predicate:('T -> bool) -> source:seq<'T> -> 'T option \n\nList.findIndexBack: predicate:('T -> bool) -> list:'T list -> int \nArray.findIndexBack: predicate:('T -> bool) -> array:'T[] -> int \nSeq.findIndexBack: predicate:('T -> bool) -> source:seq<'T> -> int \n\nList.pick: chooser:('T -> 'U option) -> list:'T list -> 'U \nArray.pick: chooser:('T -> 'U option) -> array:'T[] -> 'U  \nSeq.pick: chooser:('T -> 'U option) -> source:seq<'T> -> 'U \n\nList.tryPick: chooser:('T -> 'U option) -> list:'T list -> 'U option \nArray.tryPick: chooser:('T -> 'U option) -> array:'T[] -> 'U option \nSeq.tryPick: chooser:('T -> 'U option) -> source:seq<'T> -> 'U option \n\n```", "```cs\nList.find (fun x -> (%) x 2 = 0) <| [1;3;5] \n// System.Collections.Generic.KeyNotFoundException: \n// Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown. \nList.tryFind (fun x -> (%) x 2 = 0) <| [1;3;5] \n// val it : int option = None \nList.find (fun x -> (%) x 2 <> 0) <| [1;3;5] \n// val it : int = 1 \nList.tryFind (fun x -> (%) x 2 <> 0) <| [1;3;5] \n// val it : int option = Some 1 \nList.findIndex (fun x -> (%) x 2 <> 0) <| [1;3;5] \n// val it : int = 0 \nList.tryFindIndex (fun x -> (%) x 2 <> 0) <| [1;3;5] \n// val it : int option = Some 0 \nList.findBack (fun x -> (%) x 2 <> 0) <| [1;3;5] \n// val it : int = 5 \nList.tryFindBack (fun x -> (%) x 2 <> 0) <| [1;3;5] \n// val it : int option = Some 5 \nList.findIndexBack (fun x -> (%) x 2 <> 0) <| [1;3;5] \n// val it : int = 2 \nList.tryFindIndexBack (fun x -> (%) x 2 <> 0) <| [1;3;5] \n// val it : int option = Some 2 \n\n```", "```cs\n[(9,\"Nine\");(42,\"FortyTwo\");(0,\"Zero\")] \n|> List.pick (fun (x,y) -> if x = 42 then Some y else None) \n// val it : string = \"FortyTwo\" \n[(9,\"Nine\");(42,\"FortyTwo\");(0,\"Zero\")] \n|> List.tryPick (fun (x,y) -> if x = 42 then Some y else None) \n// val it : string option = Some \"FortyTwo\" \n[(9,\"Nine\");(42,\"FortyTwo\");(0,\"Zero\")] \n|> List.pick (fun (x,y) -> if x = 14 then Some y else None) \n// System.Collections.Generic.KeyNotFoundException: \n// Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown. \n[(9,\"Nine\");(42,\"FortyTwo\");(0,\"Zero\")] \n|> List.tryPick (fun (x,y) -> if x = 14 then Some y else None) \n// val it : string option = None \n\n```", "```cs\nList.chunkBySize: chunkSize:int -> list:'T list -> 'T list list \nArray.chunkBySize: chunkSize:int -> array:'T[] -> 'T[][] \nSeq.chunkBySize: chunkSize:int -> source:seq<'T> -> seq<'T[]> \n\nList.groupBy : projection:('T -> 'Key) -> list:'T list -> ('Key * 'T list) list when 'Key : equality \nArray.groupBy: projection:('T -> 'Key) -> array:'T[] -> ('Key * 'T[])[]  when 'Key : equality \nSeq.groupBy : projection:('T -> 'Key) -> source:seq<'T> -> seq<'Key * seq<'T>> when 'Key : equality \n\nList.pairwise: list:'T list -> ('T * 'T) list \nArray.pairwise: array:'T[] -> ('T * 'T)[] \nSeq.pairwise: source:seq<'T> -> seq<'T * 'T> \n\nList.partition: predicate:('T -> bool) -> list:'T list -> ('T list * 'T list) \nArray.partition: predicate:('T -> bool) -> array:'T[] -> 'T[] * 'T[] \n\nList.splitAt: index:int -> list:'T list -> ('T list * 'T list) \nArray.splitAt: index:int -> array:'T[] -> ('T[] * 'T[]) \n\nList.splitInto: count:int -> list:'T list -> 'T list list \nArray.splitInto: count:int -> array:'T[] -> 'T[][] \nSeq.splitInto: count:int -> source:seq<'T> -> seq<'T[]> \n\nList.windowed: windowSize:int -> list:'T list -> 'T list list \nArray.windowed: windowSize:int -> array:'T[] -> 'T[][] \nSeq.windowed: windowSize:int -> source:seq<'T> -> seq<'T[]> \n\n```", "```cs\nList.chunkBySize 2 ['a'..'g'] \n// val it : char list list = [['a'; 'b']; ['c'; 'd']; ['e'; 'f']; ['g']] \n\nList.groupBy (fun n -> n / 3) [1..7] \n// val it : (int * int list) list = [(0, [1; 2]); (1, [3; 4; 5]); (2, [6; 7])] \n\nList.pairwise [1..2..10] \n// val it : (int * int) list = [(1, 3); (3, 5); (5, 7); (7, 9)] \n\n[\"angle\";\"delta\";\"cheese\";\"America\"] \n|> List.partition (fun (x:string) -> (System.Char.ToUpper x.[0]) = 'A') \n// val it : string list * string list = \n//  ([\"angle\"; \"America\"], [\"delta\"; \"cheese\"]) \n\n[\"angle\";\"delta\";\"cheese\";\"America\"] \n|> List.splitAt 2 \n// val it : string list * string list = \n//  ([\"angle\"; \"delta\"], [\"cheese\"; \"America\"]) \n\n[\"angle\";\"delta\";\"cheese\";\"America\"] \n|> List.splitInto 3 \n// val it : string list list = \n//   [[\"angle\"; \"delta\"]; [\"cheese\"]; [\"America\"]] \n\n[\"angle\";\"delta\";\"cheese\";\"America\"] \n|> List.windowed 2 \n// val it : string list list = \n//   [[\"angle\"; \"delta\"]; [\"delta\"; \"cheese\"]; [\"cheese\"; \"America\"]] \n\n```", "```cs\nList.rev: list:'T list -> 'T list \nArray.rev: array:'T[] -> 'T[] \nSeq.rev: source:seq<'T> -> seq<'T> \n\nList.sort: list:'T list -> 'T list when 'T : comparison \nArray.sort: array:'T[] -> 'T[] when 'T : comparison \nSeq.sort: source:seq<'T> -> seq<'T> when 'T : comparison \n\nList.sortDescending: list:'T list -> 'T list when 'T : comparison \nArray.sortDescending: array:'T[] -> 'T[] when 'T : comparison \n\nList.sortBy: projection:('T -> 'Key) -> list:'T list -> 'T list when 'Key : comparison \nArray.sortBy: projection:('T -> 'Key) -> array:'T[] -> 'T[] when 'Key : comparison \nSeq.sortBy: projection:('T -> 'Key) -> source:seq<'T> -> seq<'T> when 'Key : comparison \n\nList.sortByDescending: projection:('T -> 'Key) -> list:'T list -> 'T list when 'Key : comparison \nArray.sortByDescending: projection:('T -> 'Key) -> array:'T[] -> 'T[] when 'Key : comparison \nSeq.sortByDescending : projection:('T -> 'Key) -> source:seq<'T> -> seq<'T> when 'Key : comparison \n\nList.sortWith: comparer:('T -> 'T -> int) -> list:'T list -> 'T list \nArray.sortWith: comparer:('T -> 'T -> int) -> array:'T[] -> 'T[] \nSeq.sortWith : comparer:('T -> 'T -> int) -> source:seq<'T> -> seq<'T> \n\nList.permute : indexMap:(int -> int) -> list:'T list -> 'T list \nArray.permute : indexMap:(int -> int) -> array:'T[] -> 'T[] \nSeq.permute: indexMap:(int -> int) -> source:seq<'T> -> seq<'T> \n\nArray.sortInPlace: array:'T[] -> unit when 'T : comparison \nArray.sortInPlaceBy: projection:('T -> 'Key) -> array:'T[] -> unit when 'Key : comparison \nArray.sortInPlaceWith: comparer:('T -> 'T -> int) -> array:'T[] -> unit \n\n```", "```cs\nList.sort [1;8;3;6;4;-2] \n// val it : int list = [-2; 1; 3; 4; 6; 8] \nList.sortDescending [1;8;3;6;4;-2] \n// val it : int list = [8; 6; 4; 3; 1; -2] \nList.sortBy (fun x -> x.GetHashCode()) [\"Fourteen\";\"Zero\";\"Forty Two\"] \n// val it : string list = [\"Zero\"; \"Forty Two\"; \"Fourteen\"] \n\n```", "```cs\nList.contains: value:'T -> source:'T list -> bool when 'T : equality \nArray.contains: value:'T -> array:'T[] -> bool when 'T : equality \nSeq.contains: value:'T -> source:seq<'T> -> bool when 'T : equality \n\nList.exists: predicate:('T -> bool) -> list:'T list -> bool \nArray.exists: predicate:('T -> bool) -> array:'T[] -> bool \nSeq.exists: predicate:('T -> bool) -> source:seq<'T> -> bool \n\nList.exists2: predicate:('T1 -> 'T2 -> bool) -> list1:'T1 list -> list2:'T2 list -> bool \nArray.exists2: predicate:('T1 -> 'T2 -> bool) -> array1:'T1[] -> array2:'T2[] -> bool \nSeq.exists2: predicate:('T1 -> 'T2 -> bool) -> source1:seq<'T1> -> <'T2> -> bool \n\nList.forall: predicate:('T -> bool) -> list:'T list -> bool \nArray.forall: predicate:('T -> bool) -> array:'T[] -> bool \nSeq.forall: predicate:('T -> bool) -> source:seq<'T> -> bool \n\nList.forall2: predicate:('T1 -> 'T2 -> bool) -> list1:'T1 list -> list2:'T2 list -> bool \nArray.forall2: predicate:('T1 -> 'T2 -> bool) -> array1:'T1[] -> array2:'T2[] -> bool \nSeq.forall2: predicate:('T1 -> 'T2 -> bool) -> source1:seq<'T1> -> source2:seq<'T2> -> bool \n\nList.isEmpty: list:'T list -> bool \nArray.isEmpty: array:'T[] -> bool \nSeq.isEmpty: source:seq<'T> -> bool \n\nList.compareWith: comparer:('T -> 'T -> int) -> list1:'T list -> list2:'T list -> int \nArray.compareWith: comparer:('T -> 'T -> int) -> array1:'T[] -> array2:'T[] -> int \nSeq.compareWith: comparer:('T -> 'T -> int) -> source1:seq<'T> -> source2:seq<'T> -> int \n\n```", "```cs\nList.iter: action:('T -> unit) -> list:'T list -> unit \nArray.iter: action:('T -> unit) -> array:'T[] -> unit \nSeq.iter: action:('T -> unit) -> source:seq<'T> -> unit \n\nList.iter2: action:('T1 -> 'T2 -> unit) -> list1:'T1 list -> list2:'T2 list -> unit \nArray.iter2: action:('T1 -> 'T2 -> unit) -> array1:'T1[] -> array2:'T2[] -> unit \nSeq.iter2: action:('T1 -> 'T2 -> unit) -> source1:seq<'T1> -> source2:seq<'T2> -> unit \n\nList.iteri: action:(int -> 'T -> unit) -> list:'T list -> unit \nArray.iteri: action:(int -> 'T -> unit) -> array:'T[] -> unit \nSeq.iteri: action:(int -> 'T -> unit) -> source:seq<'T> -> unit \n\nList.iteri2: action:(int -> 'T1 -> 'T2 -> unit) -> list1:'T1 list -> list2:'T2 list -> unit \nArray.iteri2: action:(int -> 'T1 -> 'T2 -> unit) -> array1:'T1[] -> array2:'T2[] -> unit \nSeq.iteri2: action:(int -> 'T1 -> 'T2 -> unit) -> source1:seq<'T1> -> source2:seq<'T2> -> unit \n\n```", "```cs\nList.map: mapping:('T -> 'U) -> list:'T list -> 'U list \nArray.map: mapping:('T -> 'U) -> array:'T[] -> 'U[] \nSeq.map: mapping:('T -> 'U) -> sequence:seq<'T> -> seq<'U> \n\nList.map2: mapping:('T1 -> 'T2 -> 'U) -> list1:'T1 list -> list2:'T2 list -> 'U list \nArray.map2: mapping:('T1 -> 'T2 -> 'U) -> array1:'T1[] -> array2:'T2[] -> 'U[] \nSeq.map2: mapping:('T1 -> 'T2 -> 'U) -> source1:seq<'T1> -> source2:seq<'T2> -> seq<'U> \n\nList.mapi: mapping:(int -> 'T -> 'U) -> list:'T list -> 'U list \nArray.mapi: mapping:(int -> 'T -> 'U) -> array:'T[] -> 'U[] \nSeq.mapi: mapping:(int -> 'T -> 'U) -> source:seq<'T> -> seq<'U> \n\nList.mapi2: mapping:(int -> 'T1 -> 'T2 -> 'U) -> list1:'T1 list -> list2:'T2 list -> 'U list \nArray.mapi2: mapping:(int -> 'T1 -> 'T2 -> 'U) -> array1:'T1[] -> array2:'T2[] -> 'U[] \nSeq.mapi2: mapping:(int -> 'T1 -> 'T2 -> 'U) -> source1:seq<'T1> -> source2:seq<'T2> -> seq<'U> \n\nList.map3: mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> list1:'T1 list -> list2:'T2 list -> list3:'T3 list -> 'U list \nArray.map3: mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> array1:'T1[] -> array2:'T2[] -> array3:'T3[] -> 'U[] \nSeq.map3: mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> source1:seq<'T1> -> source2:seq<'T2> -> source3:seq<'T3> -> seq<'U> \n\nList.collect: mapping:('T -> 'U list) -> list:'T list -> 'U list \nArray.collect: mapping:('T -> 'U[]) -> array:'T[] -> 'U[] \nSeq.collect: mapping:('T -> 'Collection) -> source:seq<'T> -> seq<'U>  when 'Collection :> seq<'U> \n\nList.indexed: list:'T list -> (int * 'T) list \nArray.indexed: array:'T[] -> (int * 'T)[] \nSeq.indexed: source:seq<'T> -> seq<int * 'T> \n\n```", "```cs\n\"Je ne regrette rien\".Split([|' '|]) \n|> Seq.collect (fun x -> x.ToCharArray()) \n|> Seq.toList \n// val it : char list = \n//  ['J'; 'e'; 'n'; 'e'; 'r'; 'e'; 'g'; \n//   'r'; 'e'; 't'; 't'; 'e'; 'r'; 'i'; 'e'; 'n'] \n\n```", "```cs\n\"Je ne regrette rien\".Split([|' '|]) \n|> Seq.indexed \n// val it : seq<int * string> = \n//  seq [(0, \"Je\"); (1, \"ne\"); (2, \"regrette\"); (3, \"rien\")] \n\n```", "```cs\nList.fold<'T,'State> : folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State \nArray.fold<'T,'State> : folder:('State -> 'T -> 'State) -> state:'State -> array: 'T[] -> 'State \nSeq.fold<'T,'State> : folder:('State -> 'T -> 'State) -> state:'State -> source:seq<'T> -> 'State \nList.fold2<'T1,'T2,'State> : folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> list1:'T1 list -> list2:'T2 list -> 'State \nArray.fold2<'T1,'T2,'State>  : folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> array1:'T1[] -> array2:'T2[] -> 'State \nSeq.fold2<'T1,'T2,'State> : folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> source1:seq<'T1> -> source2:seq<'T2> -> 'State \nList.mapFold<'T,'State,'Result> : mapping:('State -> 'T -> 'Result * 'State) -> state:'State -> list:'T list -> 'Result list * 'State \nArray.mapFold<'T,'State,'Result> : mapping:('State -> 'T -> 'Result * 'State) -> state:'State -> array:'T[] -> 'Result[] * 'State \nSeq.mapFold<'T,'State,'Result> : mapping:('State -> 'T -> 'Result * 'State) -> state:'State -> source:seq<'T> -> seq<'Result> * 'State \n\nList.foldBack<'T,'State> : folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State \nArray.foldBack<'T,'State> : folder:('T -> 'State -> 'State) -> array:'T[] -> state:'State -> 'State \nSeq.foldBack<'T,'State> : folder:('T -> 'State -> 'State) -> source:seq<'T> -> state:'State -> 'State \n\nList.foldBack2<'T1,'T2,'State> : folder:('T1 -> 'T2 -> 'State -> 'State) -> list1:'T1 list -> list2:'T2 list -> state:'State -> 'State \nArray.foldBack2<'T1,'T2,'State> : folder:('T1 -> 'T2 -> 'State -> 'State) -> array1:'T1[] -> array2:'T2[] -> state:'State -> 'State \nSeq.foldBack2<'T1,'T2,'State> : folder:('T1 -> 'T2 -> 'State -> 'State) -> source1:seq<'T1> -> source2:seq<'T2> -> state:'State -> 'State \n\nList.mapFoldBack<'T,'State,'Result> : mapping:('T -> 'State -> 'Result * 'State) -> list:'T list -> state:'State -> 'Result list * 'State \nArray.mapFoldBack<'T,'State,'Result> : mapping:('T -> 'State -> 'Result * 'State) -> array:'T[] -> state:'State -> 'Result[] * 'State \nSeq.mapFoldBack<'T,'State,'Result> : mapping:('T -> 'State -> 'Result * 'State) -> source:seq<'T> -> state:'State -> seq<'Result> * 'State \n\nList.scan<'T,'State>  : folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State list \nArray.scan<'T,'State> : folder:('State -> 'T -> 'State) -> state:'State -> array:'T[] -> 'State[] \nSeq.scan<'T,'State> : folder:('State -> 'T -> 'State) -> state:'State -> source:seq<'T> -> seq<'State> \n\nList.scanBack<'T,'State> : folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State list \nArray.scanBack<'T,'State> : folder:('T -> 'State -> 'State) -> array:'T[] -> state:'State -> 'State[] \nSeq.scanBack<'T,'State> : folder:('T -> 'State -> 'State) -> source:seq<'T> -> state:'State -> seq<'State> \n\n```", "```cs\nList.append: list1:'T list -> list2:'T list -> 'T list \nArray.append: array1:'T[] -> array2:'T[] -> 'T[] \nSeq.append: source1:seq<'T>  -> source2:seq<'T> -> seq<'T> \n\nList.concat: lists:seq<'T list> -> 'T list \nArray.concat: arrays:seq<'T[]> -> 'T[] \nSeq.concat: sources:seq<'Collection> -> seq<'T> when 'Collection :> seq<'T> \n\nList.zip: list1:'T1 list -> list2:'T2 list -> ('T1 * 'T2) list \nArray.zip: array1:'T1[] -> array2:'T2[] -> ('T1 * 'T2)[] \nSeq.zip: source1:seq<'T1> -> source2:seq<'T2> -> seq<'T1 * 'T2> \n\nList.zip3: list1:'T1 list -> list2:'T2 list -> list3:'T3 list -> ('T1 * 'T2 * 'T3) list \nArray.zip3: array1:'T1[] -> array2:'T2[] -> array3:'T3[] -> ('T1 * 'T2 * 'T3)[] \nSeq.zip3: source1:seq<'T1> -> source2:seq<'T2> -> source3:seq<'T3> -> seq<'T1 * 'T2 * 'T3> \n\nList.unzip: list:('T1 * 'T2) list -> ('T1 list * 'T2 list) \nArray.unzip: array:('T1 * 'T2)[] -> ('T1[] * 'T2[]) \n\nList.unzip3 list:('T1 * 'T2 * 'T3) list -> ('T1 list * 'T2 list * 'T3 list) \nArray.unzip3 array:('T1 * 'T2 * 'T3)[] -> ('T1[] * 'T2[] * 'T3[]) \n\n```"]