<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-133">
    <a id="_idTextAnchor133">
    </a>
    
     4
    
   </h1>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor134">
    </a>
    
     Enhancing Data Display with Grids
    
   </h1>
   <p>
    
     In this chapter, we’ll dive into data presentation within Blazor applications through the implementation of advanced grid functionalities.
    
    
     Starting with the essential task of refactoring traditional tables into more dynamic grid components, we’ll explore the significance of attaching interactive actions to various parts of a grid, such as buttons or links within cells, enhancing user engagement and
    
    
     
      operational efficiency.
     
    
   </p>
   <p>
    
     We’ll also cover pagination techniques to manage large datasets effectively and explore infinite scrolling as a modern alternative to traditional pagination.
    
    
     Additionally, we’ll walk through creating a customizable grid, offering flexibility in adapting the grid to specific application needs.
    
    
     Lastly, we will discuss
    
    <strong class="bold">
     
      QuickGrid
     
    </strong>
    
     – a ready-to-use Blazor grid component with a predefined feature set and the quickest and simplest data-grid option you
    
    
     
      can leverage.
     
    
   </p>
   <p>
    
     By the end of this chapter, you will be equipped with the knowledge to enhance data display in your Blazor applications, improving the aesthetics and functionality of data presentation through the effective use
    
    
     
      of grids.
     
    
   </p>
   <p>
    
     Here are the recipes we will follow in
    
    
     
      this chapter:
     
    
   </p>
   <ul>
    <li>
     
      Refactoring a table to a
     
     
      
       grid component
      
     
    </li>
    <li>
     
      Attaching actions to parts of
     
     
      
       a grid
      
     
    </li>
    <li>
     
      
       Implementing pagination
      
     
    </li>
    <li>
     
      
       Implementing sorting
      
     
    </li>
    <li>
     
      Implementing
     
     
      
       infinite scrolling
      
     
    </li>
    <li>
     
      
       Utilizing QuickGrid
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-135">
    <a id="_idTextAnchor135">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     We will maintain simplicity across all examples to facilitate understanding and learning.
    
    
     We will use the same dataset for all recipes, so you can see the impact of different technical aspects of working with grid components.
    
    
     No external tools will be required but the
    
    
     
      following basics:
     
    
   </p>
   <ul>
    <li>
     
      A modern IDE (that supports
     
     
      
       Blazor development)
      
     
    </li>
    <li>
     
      .NET 9 installed on your
     
     
      
       development machine
      
     
    </li>
    <li>
     
      A modern web browser (that
     
     
      
       supports WebAssembly)
      
     
    </li>
    <li>
     
      A Blazor project (where you’ll write code as you
     
     
      
       go along)
      
     
    </li>
   </ul>
   <p>
    
     All the code examples (and data samples) that you’ll see can be found in a dedicated GitHub repository at:
    
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter04">
     
      https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter04
     
    </a>
    
     .
    
    
     In each recipe that needs any samples, I will also point you to the directory where you can
    
    
     
      find them.
     
    
   </p>
   <h1 id="_idParaDest-136">
    <a id="_idTextAnchor136">
    </a>
    
     Refactoring a table to a grid component
    
   </h1>
   <p>
    
     In this recipe, we’ll explore the fundamentals of developing a reusable grid component.
    
    
     Grids are a cornerstone in
    
    <a id="_idIndexMarker171">
    </a>
    
     designing intuitive and organized user interfaces, enabling structured data display.
    
    
     Transitioning from using basic tables to implementing
    
    <a id="_idIndexMarker172">
    </a>
    
     a reusable grid component is a strategic move toward achieving modular, maintainable, and scalable frontend architecture.
    
    
     Such a component can be adapted across different parts of an application, ensuring consistency and reducing redundancy
    
    
     
      in code.
     
    
   </p>
   <p>
    
     Let’s start from the basics and refactor an existing, standard HTML table to a
    
    
     
      componentized grid.
     
    
   </p>
   <h2 id="_idParaDest-137">
    <a id="_idTextAnchor137">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we dive into exploring grid and refactoring markup, let’s get the
    
    
     
      stage ready:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       HtmlGrid
      
     </strong>
     
      files from the
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-138">
    <a id="_idTextAnchor138">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to rebuild the standard HTML markup into a modular
    
    
     
      grid component:
     
    
   </p>
   <ol>
    <li>
     
      Locate the
     
     <strong class="source-inline">
      
       HtmlGrid
      
     </strong>
     
      component.
     
     
      Rename
     
     <strong class="source-inline">
      
       HtmlGrid
      
     </strong>
     
      to
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      and convert it to a generic version by
     
     <a id="_idIndexMarker173">
     </a>
     
      adding the
     
     <strong class="source-inline">
      
       @typeparam
      
     </strong>
     
      attribute at the top of
     
     
      
       the file:
      
     
     <pre class="source-code">
@typeparam T</pre>
    </li>
    <li>
     
      Add a
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      section
     
     <a id="_idIndexMarker174">
     </a>
     
      within the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component.
     
     
      Declare three critical parameters:
     
     <strong class="source-inline">
      
       Header
      
     </strong>
     
      and the generic
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Row
      
     </strong>
     
      , allowing for dynamic
     
     
      
       content rendering:
      
     
     <pre class="source-code">
@code {
    [Parameter, EditorRequired]
    public List&lt;T&gt; Data { get; set; }
    [Parameter, EditorRequired]
    public RenderFragment Header { get; set; }
    [Parameter, EditorRequired]
    public RenderFragment&lt;T&gt; Row { get; set; }
}</pre>
    </li>
    <li>
     
      Modify the table header cell markup to utilize the
     
     <strong class="source-inline">
      
       Header
      
     </strong>
     
      parameter, representing a
     
     
      
       flexible template:
      
     
     <pre class="source-code">
&lt;thead&gt;
    @Header
&lt;/thead&gt;</pre>
    </li>
    <li>
     
      Revise the loop responsible for rendering the table body.
     
     
      Instead of a fixed dataset, iterate over the
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      collection provided through the parameter.
     
     
      Similarly, replace static row cells with the
     
     <strong class="source-inline">
      
       Row
      
     </strong>
     
      
       template parameter:
      
     
     <pre class="source-code">
&lt;tbody&gt;
    @foreach (var element in Data)
    {
        @Row(element)
    }
&lt;/tbody&gt;</pre>
    </li>
    <li>
     
      Create a new routable
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component and embed the newly modularized
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component in the
     
     <a id="_idIndexMarker175">
     </a>
     
      markup area.
     
     
      Leverage the provided
     
     <strong class="source-inline">
      
       Tickets.All
      
     </strong>
     
      sample
     
     <a id="_idIndexMarker176">
     </a>
     
      data for the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      
       data source:
      
     
     <pre class="source-code">
@page "/ch04r01"
&lt;Grid Data="@Tickets.All"&gt;
    @* we will construct the grid body next @*
&lt;/Grid&gt;</pre>
    </li>
    <li>
     
      Declare the
     
     <strong class="source-inline">
      
       Header
      
     </strong>
     
      markup for the embedded grid by extracting the header area from the original
     
     
      
       raw table:
      
     
     <pre class="source-code">
&lt;Header&gt;
    &lt;tr&gt;
        &lt;td&gt;Tariff&lt;/td&gt;
        &lt;td&gt;Price&lt;/td&gt;
    &lt;/tr&gt;
&lt;/Header&gt;</pre>
    </li>
    <li>
     
      Construct the
     
     <strong class="source-inline">
      
       Row
      
     </strong>
     
      markup for the embedded grid by extracting the row markup from the original
     
     
      
       raw table:
      
     
     <pre class="source-code">
&lt;Row&gt;
    &lt;tr&gt;
        &lt;td&gt;@context.Tariff&lt;/td&gt;
        &lt;td&gt;@context.Price&lt;/td&gt;
    &lt;/tr&gt;
&lt;/Row&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-139">
    <a id="_idTextAnchor139">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we begin implementing a modular grid by renaming
    
    <strong class="source-inline">
     
      HtmlGrid
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     .
    
    
     Then, we convert the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component into a generic component by adding the
    
    <strong class="source-inline">
     
      @typeparam T
     
    </strong>
    
     attribute at the top.
    
    
     If you haven’t seen generic components before, we already explored that topic in
    
    <a href="B22020_01.xhtml#_idTextAnchor020">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     , in the
    
    <em class="italic">
     
      Making components generic
     
    </em>
    
     recipe.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we declare three required parameters.
    
    
     With a generic
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     collection and a generic
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     template, we
    
    <a id="_idIndexMarker177">
    </a>
    
     enable the dynamic rendering of any objects as table rows.
    
    
     With
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     , we can
    
    <a id="_idIndexMarker178">
    </a>
    
     dynamically provide a table header setup without depending on any fixed layout.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we utilize the
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     parameter to modularize the table’s
    
    <strong class="source-inline">
     
      thead
     
    </strong>
    
     content, effectively making the table header fully customizable.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we configure table body rendering.
    
    
     We iterate over the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     collection and leverage the type-aware
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     template to render table rows dynamically with the
    
    
     
      provided template.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we add a new routable
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component.
    
    
     We showcase the new modularized
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component, thereby embedding it into the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup area.
    
    
     We utilize the
    
    <strong class="source-inline">
     
      Tickets.All
     
    </strong>
    
     dataset sample as the data source for the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     instance.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we construct the
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     markup by repurposing the original table header.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we do the same for the
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     markup.
    
    
     However, with
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     , there’s no need to implement a loop here – the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component already iterates over the
    
    
     
      provided dataset.
     
    
   </p>
   <p>
    
     Such a modularized approach not only simplifies the implementation but also ensures that the grid remains highly customizable and adaptable to various data types.
    
    
     We’ve effectively only simplified the loop mechanism to render grid rows, but it was important to showcase the thought process behind breaking the HTML table into modular pieces.
    
    
     Understanding that allows us to take the grid concept further in the
    
    
     
      following recipes.
     
    
   </p>
   <h2 id="_idParaDest-140">
    <a id="_idTextAnchor140">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     While modularizing grids in Blazor applications enhances flexibility and reusability, you must consider the potential rendering overhead this introduces, especially with interactive grids.
    
    
     Every user interaction could activate the diffing algorithm (we touched upon diffing in
    
    <a href="B22020_03.xhtml#_idTextAnchor095">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     ) and trigger re-rendering, which, depending on the complexity of your logic, might significantly affect performance.
    
    
     It’s essential that you find a balance in componentizing your grid – implement enough modularity to maintain flexibility without
    
    <a id="_idIndexMarker179">
    </a>
    
     overcomplicating your components.
    
    
     Strategic API call placement and the judicious use of static
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     instances can help manage
    
    
     
      performance impacts.
     
    
   </p>
   <p>
    
     An effective strategy to
    
    <a id="_idIndexMarker180">
    </a>
    
     improve grid performance is leveraging the
    
    <strong class="source-inline">
     
      @key
     
    </strong>
    
     Blazor attribute.
    
    
     This attribute helps Blazor’s diffing algorithm to identify elements more efficiently, reducing unnecessary DOM updates by associating each grid row or component with a unique identifier.
    
    
     If we were to assume that we expect only row-level changes in our grid, then we could leverage the
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     property of the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     object and attach
    
    <strong class="source-inline">
     
      @key
     
    </strong>
    
     in the
    
    
     
      following way:
     
    
   </p>
   <pre class="source-code">
&lt;Grid Tickets="@Tickets.All"&gt;
    @* ... *@
    &lt;Row&gt;
        &lt;tr @key="context.Id"&gt;
            &lt;td&gt;@context.Tariff&lt;/td&gt;
            &lt;td&gt;@context.Price&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/Row&gt;
&lt;/Grid&gt;</pre>
   <p>
    
     When Blazor can correlate DOM elements with backing data objects, it can smartly decide when re-rendering is actually necessary and when it can skip updating certain parts of the DOM.
    
    
     By using the
    
    <strong class="source-inline">
     
      @key
     
    </strong>
    
     attribute, you not only enhance the rendering performance of your grids but also ensure a smoother user experience, particularly in data-intensive scenarios where the grid’s contents
    
    
     
      change frequently.
     
    
   </p>
   <h1 id="_idParaDest-141">
    <a id="_idTextAnchor141">
    </a>
    
     Attaching actions to parts of a grid
    
   </h1>
   <p>
    
     Interactive grids play a pivotal role in enhancing the user experience within frontend applications, allowing users to interact with and manipulate data in intuitive and efficient ways.
    
    
     By attaching
    
    <a id="_idIndexMarker181">
    </a>
    
     actions to parts of a grid, you can significantly improve the grid’s functionality, paving the way for advanced features such as sorting, filtering, and dynamic data management.
    
    
     We explored how actions and events correlate in Blazor in
    
    <a href="B22020_03.xhtml#_idTextAnchor095">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     .
    
    
     In this recipe, you’ll learn about the techniques and best practices for integrating actionable elements within your grid components.
    
    
     Attaching actions effectively to grid parts not only enriches the user interface but also provides a seamless experience for users as they interact with
    
    
     
      your application.
     
    
   </p>
   <p>
    
     Let’s implement a table that allows you to attach an action to its columns that Blazor will execute when the user clicks on them and refactor the grid so it’s
    
    
     
      more flexible.
     
    
   </p>
   <h2 id="_idParaDest-142">
    <a id="_idTextAnchor142">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before you dive into making columns and rows interactive, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Refactoring a table to a grid component
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      from the
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-143">
    <a id="_idTextAnchor143">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To implement interactive table columns and rows, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new, generic
     
     <strong class="source-inline">
      
       ColumnViewModel
      
     </strong>
     
      class with
     
     <strong class="source-inline">
      
       Label
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Template
      
     </strong>
     
      , and
     
     
      <strong class="source-inline">
       
        OnSort
       
      </strong>
     
     
      
       properties:
      
     
     <pre class="source-code">
public class ColumnViewModel&lt;T&gt;
{
    public string Label { get; init; }
    public RenderFragment&lt;T&gt; Template { get; init; }
    public EventCallback OnSort { get; init; }
}</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component and, below the
     
     <strong class="source-inline">
      
       @typeparam
      
     </strong>
     
      directive, add an attribute indicating
     
     <a id="_idIndexMarker182">
     </a>
     
      that the generic type of the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component should cascade to
     
     
      
       descendant components:
      
     
     <pre class="source-code">
@typeparam T
@attribute [CascadingTypeParameter(nameof(T))]</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component, remove the
     
     <strong class="source-inline">
      
       Row
      
     </strong>
     
      parameter and rename the
     
     <strong class="source-inline">
      
       Header
      
     </strong>
     
      parameter to
     
     <strong class="source-inline">
      
       ChildContent
      
     </strong>
     
      .
     
     
      You already have the
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      collection that you will
     
     
      
       also need:
      
     
     <pre class="source-code">
@code {
    [Parameter, EditorRequired]
    public List&lt;T&gt; Data { get; set; }
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; }
}</pre>
    </li>
   </ol>
   <ol>
    <li value="4">
     
      Below the parameters, initialize a
     
     <strong class="source-inline">
      
       Columns
      
     </strong>
     
      collection, with objects of type
     
     <strong class="source-inline">
      
       ColumnViewModel
      
     </strong>
     
      , and implement an
     
     <strong class="source-inline">
      
       AddColumn()
      
     </strong>
     
      method, allowing you to add a new column to the
     
     
      
       internal collection:
      
     
     <pre class="source-code">
protected List&lt;ColumnViewModel&lt;T&gt;&gt; Columns = [];
public void AddColumn(ColumnViewModel&lt;T&gt; column)
    =&gt; Columns.Add(column);</pre>
    </li>
    <li>
     
      Lastly, at the end of the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, override the
     
     <strong class="source-inline">
      
       OnAfterRender()
      
     </strong>
     
      lifecycle method to ensure Blazor re-renders
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      when the rendering of all the nested
     
     
      
       components completes:
      
     
     <pre class="source-code">
protected override void OnAfterRender(
    bool firstRender)
{
    if (firstRender) StateHasChanged();
}</pre>
    </li>
    <li>
     
      Move to the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      markup and replace the existing table header with a loop constructing column
     
     <a id="_idIndexMarker183">
     </a>
     
      headers based on the objects in the
     
     
      <strong class="source-inline">
       
        Columns
       
      </strong>
     
     
      
       collection:
      
     
     <pre class="source-code">
&lt;thead&gt;
    &lt;tr&gt;
        @foreach (var column in Columns)
        {
            &lt;th @onclick="@column.OnSort"&gt;
                @column.Label
            &lt;/th&gt;
        }
    &lt;/tr&gt;
&lt;/thead&gt;</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      markup, in the table body area, nest another
     
     <strong class="source-inline">
      
       foreach
      
     </strong>
     
      loop where you render each column template for all elements in the
     
     
      <strong class="source-inline">
       
        Data
       
      </strong>
     
     
      
       collection:
      
     
     <pre class="source-code">
&lt;tbody&gt;
    @foreach (var element in Data)
    {
        &lt;tr&gt;
            @foreach (var column in Columns)
            {
                &lt;td&gt;@column.Template(element)&lt;/td&gt;
            }
        &lt;/tr&gt;
    }
&lt;/tbody&gt;</pre>
    </li>
    <li>
     
      To complete the markup, add a
     
     <strong class="source-inline">
      
       CascadingValue
      
     </strong>
     
      markup to share the current
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      instance
     
     <a id="_idIndexMarker184">
     </a>
     
      with all the nested components it
     
     
      
       might contain:
      
     
     <pre class="source-code">
&lt;CascadingValue Value="this"&gt;
    @ChildContent
&lt;/CascadingValue&gt;</pre>
    </li>
    <li>
     
      Create a new, generic
     
     <strong class="source-inline">
      
       Column
      
     </strong>
     
      component, with a
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block where you intercept a cascading reference to the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      instance and allow passing
     
     <strong class="source-inline">
      
       Label
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       ChildContent
      
     </strong>
     
      , and
     
     
      <strong class="source-inline">
       
        OnSort
       
      </strong>
     
     
      
       parameters:
      
     
     <pre class="source-code">
@typeparam T
@code {
    [CascadingParameter]
    public Grid&lt;T&gt; Grid { get; set; }
    [Parameter, EditorRequired]
    public string Label { get; set; }
    [Parameter, EditorRequired]
    public RenderFragment&lt;T&gt; ChildContent { get; set; }
    [Parameter]
    public EventCallback OnSort { get; set; }
}</pre>
    </li>
    <li>
     
      Still in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       Column
      
     </strong>
     
      component, override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      lifecycle
     
     <a id="_idIndexMarker185">
     </a>
     
      method to convert
     
     <strong class="source-inline">
      
       Column
      
     </strong>
     
      parameters to
     
     <strong class="source-inline">
      
       ColumnViewModel
      
     </strong>
     
      and pass the
     
     <strong class="source-inline">
      
       model
      
     </strong>
     
      instance to the parent
     
     
      <strong class="source-inline">
       
        Grid
       
      </strong>
     
     
      
       component:
      
     
     <pre class="source-code">
protected override void OnInitialized()
{
    var model = new ColumnViewModel&lt;T&gt;
    {
        Label = Label,
        Template = ChildContent,
        OnSort = OnSort
    };
    Grid.AddColumn(model);
}</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component and initialize an
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block to implement a
     
     <strong class="source-inline">
      
       Sort()
      
     </strong>
     
      placeholder method, where you just log
     
     
      
       the intention:
      
     
     <pre class="source-code">
@code {
    private void Sort(string prop)
        =&gt; Console.WriteLine($"Sorted by {prop}!");
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup, replace the no longer compatible
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      content with columns rendered with the help of the
     
     
      <strong class="source-inline">
       
        Column
       
      </strong>
     
     
      
       component:
      
     
     <pre class="source-code">
&lt;Column OnSort="@(() =&gt; Sort(nameof(Ticket.Tariff)))"
        Label="Tariff"&gt;
    @context.Tariff
&lt;/Column&gt;
&lt;Column OnSort="@(() =&gt; Sort(nameof(Ticket.Price)))"
        Label="Price"&gt;
    @context.Price
&lt;/Column&gt;</pre>
    </li>
    <li>
     
      Lastly, enhance
     
     <a id="_idIndexMarker186">
     </a>
     
      the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component to render in
     
     
      <strong class="source-inline">
       
        InteractiveWebAssembly
       
      </strong>
     
     
      
       mode:
      
     
     <pre class="source-code">
@rendermode InteractiveWebAssembly</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-144">
    <a id="_idTextAnchor144">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a generic
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     class.
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     contains three properties:
    
    <strong class="source-inline">
     
      Label
     
    </strong>
    
     , representing the title of the column;
    
    <strong class="source-inline">
     
      Template
     
    </strong>
    
     , representing the markup to be rendered for each data point in the column; and
    
    <strong class="source-inline">
     
      OnSort
     
    </strong>
    
     , a callback to trigger sorting when a user clicks on the column header.
    
    
     Using
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     , you can simplify the definition of a column in the grid without passing all the column
    
    
     
      properties explicitly.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component and perform some refactoring to make its construction more dynamic.
    
    
     While the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component is already generic, we will work with cascading values next and want Blazor to automatically propagate these values type down the component tree.
    
    
     To achieve this descendant sharing, we leverage the
    
    <strong class="source-inline">
     
      CascadingTypeParameter
     
    </strong>
    
     attribute.
    
    <strong class="source-inline">
     
      CascadingTypeParameter
     
    </strong>
    
     allows a generic type to be shared across the component tree.
    
    
     Instead of passing the generic type
    
    <strong class="source-inline">
     
      "T"
     
    </strong>
    
     as a string, we use the
    
    <strong class="source-inline">
     
      nameof()
     
    </strong>
    
     method, achieving the same result while maintaining
    
    
     
      compile-time validation.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we change the
    
    <a id="_idIndexMarker187">
    </a>
    
     parameters required by
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     .
    
    
     We remove the
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     parameter, as we will move the data point template into
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     .
    
    
     With the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component now requiring only one
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     parameter, we rename
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     to simplify the grid’s
    
    
     
      construction later.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we add a
    
    <strong class="source-inline">
     
      Columns
     
    </strong>
    
     collection that will serve as a container for the grid columns we will render.
    
    
     To populate that collection, we expose an
    
    <strong class="source-inline">
     
      AddColumn()
     
    </strong>
    
     method, which accepts a
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     object and adds it
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       Columns
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnAfterRender()
     
    </strong>
    
     lifecycle method of the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component.
    
    
     This instructs Blazor to re-render the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component immediately after the initial render completes.
    
    
     This might seem counter-intuitive now, but it will make more sense when we implement the
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     
      component later.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we adjust the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     markup to comply with the changes in the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block.
    
    
     As we’ve removed the
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     parameter, we rebuild the table header area.
    
    
     We reconstruct the
    
    <strong class="source-inline">
     
      thead
     
    </strong>
    
     content by explicitly embedding
    
    <strong class="source-inline">
     
      tr
     
    </strong>
    
     tags and rendering the
    
    <strong class="source-inline">
     
      Label
     
    </strong>
    
     properties of columns from the
    
    <strong class="source-inline">
     
      Columns
     
    </strong>
    
     collection.
    
    
     We also attach the declared sorting action of each column to the
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     event of each
    
    <strong class="source-inline">
     
      th
     
    </strong>
    
     element.
    
    
     You attach actions to grid elements the same as any other
    
    
     
      HTML element.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we reconstruct the table body.
    
    
     We replace the
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     reference (which we’ve removed) with explicit
    
    <strong class="source-inline">
     
      tr
     
    </strong>
    
     tags inside the loop iterating over the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     collection.
    
    
     Inside each
    
    <strong class="source-inline">
     
      tr
     
    </strong>
    
     , we nest another loop, instructing Blazor to render each
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     element using the template from the
    
    <strong class="source-inline">
     
      Template
     
    </strong>
    
     property of the
    
    
     
      current column.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we complete the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     markup by constructing a
    
    <strong class="source-inline">
     
      CascadingValue
     
    </strong>
    
     area, where we share the current grid instance with nested components.
    
    
     We will also need the
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     component to understand this part, so we will implement
    
    
     
      it next.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we create a generic
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     component, which will be the primary construction element for the grid.
    
    
     The
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     component intercepts the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     instance where it is rendered and requires
    
    <strong class="source-inline">
     
      Label
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     parameters.
    
    
     The
    
    <strong class="source-inline">
     
      Label
     
    </strong>
    
     parameter defines the column title, while
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     represents a template for the data point belonging to that column.
    
    
     This markup will be rendered for each element of the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     collection in the grid.
    
    
     We also declare one optional parameter,
    
    <strong class="source-inline">
     
      OnSort
     
    </strong>
    
     , allowing the attachment of sorting behavior triggered by clicking the
    
    
     
      column header.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we complete the
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     implementation by overriding the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     lifecycle method, where we convert the incoming parameters into a
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     object that we then register in the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component using the previously implemented
    
    <strong class="source-inline">
     
      AddColumn()
     
    </strong>
    
     method.
    
    
     The
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     component is markupless by design – it doesn’t render any markup explicitly.
    
    
     Instead, it registers the row template and column definition directly in the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     instance, which knows how to construct the table markup from
    
    
     
      those details.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component.
    
    
     First, we initialize a
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block where we implement a
    
    <strong class="source-inline">
     
      Sort()
     
    </strong>
    
     method – a behavior placeholder that only logs an operation intention (we will implement the sorting in a
    
    
     
      separate step).
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 12
     
    </em>
    
     , we reconstruct the grid content, leveraging the
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     component.
    
    
     As all grid elements are
    
    <a id="_idIndexMarker188">
    </a>
    
     generic and the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component cascades the generic parameter type downwards, we can access the
    
    <strong class="source-inline">
     
      Ticket
     
    </strong>
    
     properties with a
    
    <strong class="source-inline">
     
      context
     
    </strong>
    
     reference.
    
    
     Knowing this, we build the first column with a
    
    <strong class="source-inline">
     
      Tariff
     
    </strong>
    
     title and declare that for each data point, we want to render the value of the
    
    <strong class="source-inline">
     
      Tariff
     
    </strong>
    
     property of the current element.
    
    
     We also declare that the
    
    <strong class="source-inline">
     
      OnSort
     
    </strong>
    
     callback exposed by
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     will trigger the
    
    <strong class="source-inline">
     
      Sort()
     
    </strong>
    
     method on the
    
    <strong class="source-inline">
     
      Tariff
     
    </strong>
    
     property.
    
    
     For the second column, we duplicate these steps for the
    
    
     <strong class="source-inline">
      
       Price
      
     </strong>
    
    
     
      property.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 13
     
    </em>
    
     , since we expect the grid to be interactive, we declare that the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component will render in
    
    
     <strong class="source-inline">
      
       InteractiveWebAssembly
      
     </strong>
    
    
     
      mode.
     
    
   </p>
   <p>
    
     Now, with the entire implementation in place, it will be easier to understand the rendering of the enhanced
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component.
    
    
     As you can see, the
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     component we use to construct the grid doesn’t carry any markup, so it will be fully transparent in the DOM.
    
    
     However,
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     still requires cascading access to the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     instance, which is why we put all the customizable
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     content in the
    
    <strong class="source-inline">
     
      CascadingValue
     
    </strong>
    
     tags in
    
    <em class="italic">
     
      step 8
     
    </em>
    
     .
    
    
     With that, each
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     instance can register the render template it carries directly within the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     instance, so it is rendered together with the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     markup.
    
    
     This is also why we’ve overridden the
    
    <strong class="source-inline">
     
      OnAfterRender()
     
    </strong>
    
     lifecycle method of the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component in
    
    <em class="italic">
     
      step 5
     
    </em>
    
     .
    
    
     We must re-render the table markup after the initial render of the grid and after all the
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     instances register their payload within the
    
    
     <strong class="source-inline">
      
       Grid
      
     </strong>
    
    
     
      instance.
     
    
   </p>
   <h2 id="_idParaDest-145">
    <a id="_idTextAnchor145">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In some scenarios, you might need to attach actions to entire grid rows and specific grid cells.
    
    
     When a row overlaps a cell, you
    
    <a id="_idIndexMarker189">
    </a>
    
     will face
    
    <strong class="bold">
     
      event bubbling
     
    </strong>
    
     .
    
    
     When an event, such as a mouse click or key press, occurs in the browser, it propagates (or bubbles) from the target element through its
    
    <a id="_idIndexMarker190">
    </a>
    
     ancestors, resulting in unwanted behavior in parent elements listening for the same event.
    
    
     With Blazor’s
    
    <strong class="source-inline">
     
      @onEvent:stopPropagation
     
    </strong>
    
     attribute, you can prevent this propagation, ensuring that only the intended event
    
    
     
      handler executes:
     
    
   </p>
   <pre class="source-code">
&lt;tr @onclick="@ShowTicketDetails"&gt;
    &lt;td&gt;@ticket.Tariff&lt;/td&gt;
    &lt;td @onclick="@AddToCart"
        @onclick:stopPropagation&gt;
        @ticket.Price
    &lt;/td&gt;
&lt;/tr&gt;</pre>
   <p>
    
     In this code snippet, we allow users to display ticket details when they click on a table row and add a ticket to the cart when they click on the cell with the price.
    
    
     We’ve attached the desired event handlers to the
    
    <strong class="source-inline">
     
      tr
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      td
     
    </strong>
    
     elements.
    
    
     Additionally, we’ve attached the
    
    <strong class="source-inline">
     
      @onclick:stopPropagation
     
    </strong>
    
     attribute to
    
    <strong class="source-inline">
     
      td
     
    </strong>
    
     with a price.
    
    
     Now, we prevent the click event from propagating to the parent row.
    
    
     As a result, when the user clicks the cell, Blazor executes only the
    
    <strong class="source-inline">
     
      AddToCart()
     
    </strong>
    
     handler and omits the
    
    <strong class="source-inline">
     
      ShowTicketDetails()
     
    </strong>
    
     handler.
    
    
     With
    
    <strong class="source-inline">
     
      @onclick:stopPropagation
     
    </strong>
    
     , we ensure that the click event is handled solely by the cell and does not affect the surrounding
    
    
     
      row element.
     
    
   </p>
   <h1 id="_idParaDest-146">
    <a id="_idTextAnchor146">
    </a>
    
     Implementing pagination
    
   </h1>
   <p>
    
     Pagination refers to dividing
    
    <a id="_idIndexMarker191">
    </a>
    
     content into separate pages, which is particularly crucial for tables and grids displaying large datasets.
    
    
     This approach improves the readability and navigability of data and significantly enhances performance by reducing the volume of data loaded and rendered at any given time.
    
    
     Pagination is often required in tables and grids to manage large amounts of data efficiently, preventing overwhelming users with too much information at once and ensuring that the application
    
    
     
      remains responsive.
     
    
   </p>
   <p>
    
     Let’s add a simple pagination to
    
    
     
      the grid.
     
    
   </p>
   <h2 id="_idParaDest-147">
    <a id="_idTextAnchor147">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we dive in, ensure that you do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Column
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       ColumnViewModel
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Attaching actions to parts of a grid
      
     </em>
     
      recipe or the
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory in the
     
     <a id="_idIndexMarker192">
     </a>
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      from the
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-148">
    <a id="_idTextAnchor148">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To add pagination to your
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       PaginateEventArgs
      
     </strong>
     
      record with
     
     <strong class="source-inline">
      
       Page
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        Size
       
      </strong>
     
     
      
       properties:
      
     
     <pre class="source-code">
public record PaginateEventArgs(int Page, int Size);</pre>
    </li>
    <li>
     
      Add a new
     
     <strong class="source-inline">
      
       Paginator
      
     </strong>
     
      component and initialize a
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block with two required parameters: a
     
     <strong class="source-inline">
      
       Paginate
      
     </strong>
     
      callback with
     
     <strong class="source-inline">
      
       PaginateEventArgs
      
     </strong>
     
      
       and
      
     
     
      <strong class="source-inline">
       
        DataSize
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
[Parameter, EditorRequired]
public EventCallback&lt;PaginateEventArgs&gt;
    Paginate { get; set; }
[Parameter, EditorRequired]
public int DataSize { get; set; }</pre>
    </li>
    <li>
     
      Below the parameters, initialize variables defining the pagination state:
     
     <strong class="source-inline">
      
       TotalPages
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       CurrentPage
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       PageSize
      
     </strong>
     
      with default
     
     
      
       initial values:
      
     
     <pre class="source-code">
protected int TotalPages,
    CurrentPage = 1, PageSize = 5;</pre>
    </li>
    <li>
     
      Next to the state
     
     <a id="_idIndexMarker193">
     </a>
     
      variables, override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      lifecycle method and calculate the
     
     
      <strong class="source-inline">
       
        TotalPages
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
protected override void OnInitialized()
    =&gt; TotalPages =
        (DataSize + PageSize - 1)
        / PageSize;</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       LoadAsync()
      
     </strong>
     
      method, invoking the
     
     <strong class="source-inline">
      
       Paginate
      
     </strong>
     
      callback with the current
     
     
      
       pagination state:
      
     
     <pre class="source-code">
private Task LoadAsync()
{
    var state = new PaginateEventArgs(
        CurrentPage,
        PageSize
    );
    return Paginate.InvokeAsync(state);
}</pre>
    </li>
    <li>
     
      Below the loading method, define a
     
     <strong class="source-inline">
      
       NextAsync()
      
     </strong>
     
      method to enable the forward navigation of
     
     
      
       data pages:
      
     
     <pre class="source-code">
private async Task NextAsync()
{
    if (CurrentPage == TotalPages) return;
    CurrentPage++;
    await LoadAsync();
}</pre>
    </li>
    <li>
     
      Similarly, next to the forward navigation, implement a
     
     <strong class="source-inline">
      
       PreviousAsync()
      
     </strong>
     
      method to handle backward navigation of
     
     
      
       data pages:
      
     
     <pre class="source-code">
private async Task PreviousAsync()
{
    if (CurrentPage == 1) return;
    CurrentPage--;
    await LoadAsync();
}</pre>
    </li>
    <li>
     
      Complete the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block by overriding the
     
     <strong class="source-inline">
      
       OnAfterRenderAsync()
      
     </strong>
     
      lifecycle method and
     
     <a id="_idIndexMarker194">
     </a>
     
      load the initial data page, after the
     
     
      
       first render:
      
     
     <pre class="source-code">
protected override async Task
    OnAfterRenderAsync(bool firstRender)
{
    if (firstRender) await LoadAsync();
}</pre>
    </li>
    <li>
     
      Move to the
     
     <strong class="source-inline">
      
       Paginator
      
     </strong>
     
      markup area and construct a container with two
     
     <strong class="source-inline">
      
       button
      
     </strong>
     
      elements for page navigation and an
     
     <strong class="source-inline">
      
       input
      
     </strong>
     
      field to display the
     
     
      <strong class="source-inline">
       
        CurrentPage
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
&lt;div class="d-flex"&gt;
    &lt;button @onclick="@PreviousAsync"&gt;
        Previous
    &lt;/button&gt;
    &lt;input disabled
           class="text-center"
           value="@CurrentPage" /&gt;
    &lt;button @onclick="@NextAsync"&gt;
        Next
    &lt;/button&gt;
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component and, within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, initialize a generic
     
     <strong class="source-inline">
      
       Set
      
     </strong>
     
      collection to
     
     <a id="_idIndexMarker195">
     </a>
     
      persist currently
     
     
      
       displayed data:
      
     
     <pre class="source-code">
protected IEnumerable&lt;T&gt; Set = [];</pre>
    </li>
    <li>
     
      Next to the
     
     <strong class="source-inline">
      
       Set
      
     </strong>
     
      initialization, implement a
     
     <strong class="source-inline">
      
       LoadAsync()
      
     </strong>
     
      method, accepting a
     
     <strong class="source-inline">
      
       PaginationEventArgs
      
     </strong>
     
      parameter, that takes a slice of data from the
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      collection based on the incoming pagination
     
     
      
       state details:
      
     
     <pre class="source-code">
public Task LoadAsync(PaginateEventArgs args)
{
    Set = Data
        .Skip((args.Page - 1) * args.Size)
        .Take(args.Size);
    return Task.CompletedTask;
}</pre>
    </li>
    <li>
     
      Jump to the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component markup and update the loop generating table rows to iterate over the
     
     
      <strong class="source-inline">
       
        Set
       
      </strong>
     
     
      
       collection:
      
     
     <pre class="source-code">
&lt;tbody&gt;
    @foreach (var element in Set)
    {
        @* nested loop through Columns *@
    }
&lt;/tbody&gt;</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      markup, under the table, embed the
     
     <strong class="source-inline">
      
       Paginator
      
     </strong>
     
      component, attaching
     
     <a id="_idIndexMarker196">
     </a>
     
      the
     
     <strong class="source-inline">
      
       LoadAsync()
      
     </strong>
     
      method to its
     
     <strong class="source-inline">
      
       Paginate
      
     </strong>
     
      callback and passing the size of the
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      collection as the
     
     
      <strong class="source-inline">
       
        DataSize
       
      </strong>
     
     
      
       parameter:
      
     
     <pre class="source-code">
&lt;hr /&gt;
&lt;Paginator Paginate="@LoadAsync"
           DataSize="@Data.Count"/&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-149">
    <a id="_idTextAnchor149">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a
    
    <strong class="source-inline">
     
      PaginateEventArgs
     
    </strong>
    
     record with
    
    <strong class="source-inline">
     
      Page
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Size
     
    </strong>
    
     properties representing the currently visible page and the size of each page a user is viewing.
    
    
     Having these details allows us to fetch data in expected batches effectively.
    
    
     As we expect
    
    <strong class="source-inline">
     
      PaginateEventArgs
     
    </strong>
    
     to represent a pagination event, it makes sense to make the object immutable, so we declare it as a
    
    <strong class="source-inline">
     
      record
     
    </strong>
    
     object.
    
    
     To simplify the
    
    <strong class="source-inline">
     
      PaginateEventArgs
     
    </strong>
    
     initialization, we also leverage the primary constructor rather than the legacy one and explicit
    
    
     
      property declaration.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we introduce a
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     component to encapsulate the grid pagination logic.
    
    
     First, we initialize a
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block within
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     .
    
    
     We declare a
    
    <strong class="source-inline">
     
      Paginate
     
    </strong>
    
     callback that returns
    
    <strong class="source-inline">
     
      PaginateEventArgs
     
    </strong>
    
     to communicate page navigation changes.
    
    
     We also declare a
    
    <strong class="source-inline">
     
      DataSize
     
    </strong>
    
     parameter.
    
    
     Knowing the amount of data to paginate allows us to improve the pagination experience by setting the maximum page a user
    
    
     
      can reach.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we initialize three state properties:
    
    <strong class="source-inline">
     
      TotalPages
     
    </strong>
    
     , indicating where the pagination navigator should stop;
    
    <strong class="source-inline">
     
      CurrentPage
     
    </strong>
    
     , indicating the current page a user is viewing; and
    
    <strong class="source-inline">
     
      PageSize
     
    </strong>
    
     , defining how many elements we allow to load per page.
    
    
     For
    
    <strong class="source-inline">
     
      CurrentPage
     
    </strong>
    
     , we set the initial value to
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     since we naturally start from the first page.
    
    
     We also fix
    
    <strong class="source-inline">
     
      PageSize
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      5
     
    </strong>
    
     , allowing us to focus on the
    
    
     
      pagination behavior.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     lifecycle method of
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     to calculate the
    
    <strong class="source-inline">
     
      TotalPages
     
    </strong>
    
     value based on the incoming
    
    <strong class="source-inline">
     
      DataSize
     
    </strong>
    
     parameter and the
    
    <strong class="source-inline">
     
      PageSize
     
    </strong>
    
     variable.
    
    
     We implement the simplest arithmetic calculation that always rounds up to the next whole number, whenever the division of
    
    <strong class="source-inline">
     
      DataSize
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      PageSize
     
    </strong>
    
     is an odd number, indicating that the last page is
    
    
     
      not full.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     method, which is central to the pagination request communication.
    
    
     Every time
    
    <a id="_idIndexMarker197">
    </a>
    
     Blazor invokes
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     , we create a
    
    <strong class="source-inline">
     
      PaginationEventArgs
     
    </strong>
    
     instance from the current value of
    
    <strong class="source-inline">
     
      CurrentPage
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      PageSize
     
    </strong>
    
     variables and asynchronously pass it to the
    
    <strong class="source-inline">
     
      Paginate
     
    </strong>
    
     callback for the callback consumer
    
    
     
      to interpret.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we construct the first part of the
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     navigation capabilities by implementing a
    
    <strong class="source-inline">
     
      NextAsync()
     
    </strong>
    
     method.
    
    <strong class="source-inline">
     
      NextAsync()
     
    </strong>
    
     allows the user to fetch the next page of data – we check whether the user is already on the last available page to prevent further navigation; if not, we increment
    
    <strong class="source-inline">
     
      CurrentPage
     
    </strong>
    
     and invoke the
    
    
     <strong class="source-inline">
      
       LoadAsync()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we construct the
    
    <strong class="source-inline">
     
      NextAsync()
     
    </strong>
    
     counterpart,
    
    <strong class="source-inline">
     
      PreviousAsync()
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      PreviousAsync()
     
    </strong>
    
     method allows the user to navigate backward and fetch the previous dataset.
    
    
     To prevent the user from navigating too far back, we check whether
    
    <strong class="source-inline">
     
      CurrentPage
     
    </strong>
    
     is already the first available page.
    
    
     If not, we decrease
    
    <strong class="source-inline">
     
      CurrentPage
     
    </strong>
    
     and
    
    
     
      invoke
     
    
    
     <strong class="source-inline">
      
       LoadAsync()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The last thing we must cover is the initial loading of data.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnAfterRenderAsync()
     
    </strong>
    
     lifecycle method of
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     .
    
    
     After the first render, we invoke
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     to instruct Blazor to load the defined initial page with the specified number
    
    
     
      of elements.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we build the
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     markup.
    
    
     We construct a primitive bar with two buttons allowing navigation back and forth using
    
    <strong class="source-inline">
     
      PreviousAsync()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      NextAsync()
     
    </strong>
    
     respectively.
    
    
     We also add a disabled input field displaying the current page based on the
    
    
     <strong class="source-inline">
      
       CurrentPage
      
     </strong>
    
    
     
      variable.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we move to the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component and enhance it to comply with
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     and pagination.
    
    
     First, we focus on the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block and declare a generic
    
    <strong class="source-inline">
     
      Set
     
    </strong>
    
     collection to store the currently
    
    
     
      fetched dataset.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     method that consumes
    
    <strong class="source-inline">
     
      PaginateEventArgs
     
    </strong>
    
     and reacts to the
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     callback.
    
    
     Inside
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     , we use
    
    <strong class="bold">
     
      LINQ methods
     
    </strong>
    
     to load only the required elements from
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     .
    
    
     We use the
    
    <strong class="source-inline">
     
      Skip()
     
    </strong>
    
     method to skip
    
    <a id="_idIndexMarker198">
    </a>
    
     elements the user has already seen.
    
    
     Since the
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     component starts the page count from
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     while collection indexing starts from
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     , we reduce the
    
    <strong class="source-inline">
     
      args.Page
     
    </strong>
    
     value by
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     and then multiply it by
    
    <strong class="source-inline">
     
      args.Size
     
    </strong>
    
     to get the number of elements to omit from the start of the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     collection.
    
    
     Then, we use a
    
    <strong class="source-inline">
     
      Take()
     
    </strong>
    
     method to fetch the desired amount
    
    
     
      of elements.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 12
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     markup, locate the loop where we iterate over
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     elements, and update the loop to work
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       Set
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Lastly, in
    
    <em class="italic">
     
      step 13
     
    </em>
    
     , we embed the
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     component into the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     markup.
    
    
     We attach the
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      Paginate
     
    </strong>
    
     callback and count the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     elements to provide the
    
    <a id="_idIndexMarker199">
    </a>
    
     required
    
    
     <strong class="source-inline">
      
       DataSize
      
     </strong>
    
    
     
      parameter.
     
    
   </p>
   <p>
    
     With very little code, we have arrived at a fully functional and generic
    
    
     
      pagination feature.
     
    
   </p>
   <div><div><img alt="Figure 4.1: Grid loading with a functional pagination bar" src="img/B22020_04_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.1: Grid loading with a functional pagination bar
    
   </p>
   <h2 id="_idParaDest-150">
    <a id="_idTextAnchor150">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In the pagination implementation, we have some methods returning
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     that we didn’t declare as
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     but rather returned the
    
    <strong class="source-inline">
     
      Task.CompletedTask
     
    </strong>
    
     object.
    
    
     This approach is beneficial when we don’t perform asynchronous operations inside the method but must adhere to an asynchronous method signature.
    
    
     Returning
    
    <strong class="source-inline">
     
      Task.CompletedTask
     
    </strong>
    
     is more efficient in such scenarios because we avoid the overhead of the async state
    
    <a id="_idIndexMarker200">
    </a>
    
     machine that the compiler generates for
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     methods.
    
    
     By not awaiting
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     and simply returning
    
    <strong class="source-inline">
     
      Task.CompletedTask
     
    </strong>
    
     , we minimize unnecessary performance costs associated with task scheduling and
    
    
     
      context switching.
     
    
   </p>
   <h2 id="_idParaDest-151">
    <a id="_idTextAnchor151">
    </a>
    
     See also
    
   </h2>
   <p>
    
     In this recipe, we also saw the LINQ methods in action.
    
    
     LINQ methods could fill a book on their own, so if you’d like to explore that topic, head over
    
    
     
      to
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/">
     
      
       https://learn.microsoft.com/en-us/dotnet/csharp/linq/
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-152">
    <a id="_idTextAnchor152">
    </a>
    
     Implementing sorting
    
   </h1>
   <p>
    
     In this recipe, we dive into organizing data within grids by arranging rows based on column values.
    
    
     Sorting allows users to easily navigate and analyze data by prioritizing it according to relevant criteria, such
    
    <a id="_idIndexMarker201">
    </a>
    
     as alphabetical order, numerical values, dates, or custom parameters.
    
    
     This capability becomes increasingly important in applications dealing with extensive datasets, where locating specific information or understanding data trends can become cumbersome without effective sorting mechanisms.
    
    
     By introducing sorting functionalities, developers can significantly improve the user experience, offering intuitive interactions and insights into the
    
    
     
      data presented.
     
    
   </p>
   <p>
    
     Let’s enhance the grid with sorting functionality that users can trigger by clicking on the grid
    
    
     
      column headers.
     
    
   </p>
   <h2 id="_idParaDest-153">
    <a id="_idTextAnchor153">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we explore sorting in a grid, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Column
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       ColumnViewModel
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       PaginateEventArgs
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Paginator
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Implementing pagination
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      from the
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-154">
    <a id="_idTextAnchor154">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to add sorting to
    
    
     
      a grid:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       ColumnViewModel
      
     </strong>
     
      class and replace the
     
     <strong class="source-inline">
      
       OnSort
      
     </strong>
     
      callback with a
     
     <strong class="source-inline">
      
       Property
      
     </strong>
     
      delegate, encapsulating
     
     <a id="_idIndexMarker202">
     </a>
     
      the logic to select a property from a
     
     
      
       generic model:
      
     
     <pre class="source-code">
public Func&lt;T, object&gt; Property { get; init; }</pre>
    </li>
    <li>
     
      Go to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       Column
      
     </strong>
     
      component and replace the
     
     <strong class="source-inline">
      
       OnSort
      
     </strong>
     
      parameter with a
     
     <strong class="source-inline">
      
       Property
      
     </strong>
     
      delegate parameter, allowing you to pass a property selector from a
     
     
      
       generic model:
      
     
     <pre class="source-code">
[Parameter]
public Func&lt;T, object&gt; Property { get; set; }</pre>
    </li>
    <li>
     
      Still in the
     
     <strong class="source-inline">
      
       Column
      
     </strong>
     
      component, fix the implementation of the overridden
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      method by updating the
     
     <strong class="source-inline">
      
       ColumnViewModel
      
     </strong>
     
      construction to utilize the
     
     
      <strong class="source-inline">
       
        Property
       
      </strong>
     
     
      
       parameter:
      
     
     <pre class="source-code">
var model = new ColumnViewModel&lt;T&gt;
{
    Label = Label,
    Template = ChildContent,
    Property = Property
};</pre>
    </li>
    <li>
     
      Move to the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component.
     
     
      At the end of the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, declare variables to persist the current sorting column
     
     
      
       and order:
      
     
     <pre class="source-code">
private string _currentSortColumn;
private bool _isAsc;</pre>
    </li>
    <li>
     
      Below the sorting state variables, add a
     
     <strong class="source-inline">
      
       PaginatorRef
      
     </strong>
     
      variable to allow referencing the
     
     <strong class="source-inline">
      
       Paginator
      
     </strong>
     
      component from within the
     
     
      <strong class="source-inline">
       
        Grid
       
      </strong>
     
     
      
       code:
      
     
     <pre class="source-code">
protected Paginator PaginatorRef;</pre>
    </li>
    <li>
     
      Complete the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component, by implementing a
     
     <strong class="source-inline">
      
       SortAsync()
      
     </strong>
     
      method, allowing
     
     <a id="_idIndexMarker203">
     </a>
     
      you to dynamically sort the
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      collection based on the
     
     <strong class="source-inline">
      
       Property
      
     </strong>
     
      selector set for each
     
     <strong class="source-inline">
      
       ColumnViewModel
      
     </strong>
     
      
       column object:
      
     
     <pre class="source-code">
public Task SortAsync(ColumnViewModel&lt;T&gt; column)
{
    if (_currentSortColumn == column.Label)
        _isAsc = !isAsc;
    else
        _isAsc = true;
    Comparison&lt;T&gt; comparer = (left, right) =&gt;
    {
        var result = Comparer&lt;object&gt;.Default
            .Compare(column.Property(left),
                column.Property(right));
        return _isAsc ? result : -result;
    };
    Data.Sort(comparer);
    _currentSortColumn = column.Label;
    return PaginatorRef.LoadAsync();
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      markup, replace the delegate attached to the table column headers with the newly
     
     
      
       implemented
      
     
     
      <strong class="source-inline">
       
        SortAsync()
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
&lt;th @onclick="@(() =&gt; SortAsync(column))"&gt;
    @column.Label
&lt;/th&gt;</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      markup, locate
     
     <a id="_idIndexMarker204">
     </a>
     
      the
     
     <strong class="source-inline">
      
       Paginator
      
     </strong>
     
      instance and attach its reference to the
     
     
      <strong class="source-inline">
       
        PaginatorRef
       
      </strong>
     
     
      
       variable:
      
     
     <pre class="source-code">
&lt;Paginator @ref="@PaginatorRef"
           Paginate="@LoadAsync"
           DataSize="@Data.Count" /&gt;</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component and fix the
     
     <strong class="source-inline">
      
       Column
      
     </strong>
     
      instances by passing in the
     
     <strong class="source-inline">
      
       Property
      
     </strong>
     
      selector and defining the
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      properties to
     
     
      
       sort on:
      
     
     <pre class="source-code">
&lt;Column Property="@(it =&gt; it.Tariff)"
        Label="Tariff"&gt;
    @context.Tariff
&lt;/Column&gt;
&lt;Column Property="@(it =&gt; it.Price)"
        Label="Price"&gt;
    @context.Price
&lt;/Column&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-155">
    <a id="_idTextAnchor155">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we update the
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     class and replace the
    
    <strong class="source-inline">
     
      OnSort
     
    </strong>
    
     callback with a generic
    
    <strong class="source-inline">
     
      Func&lt;T, object&gt;
     
    </strong>
    
     .
    
    <strong class="source-inline">
     
      Func&lt;T, object&gt;
     
    </strong>
    
     is a delegate that represents a method returning an object from a given type,
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     .
    
    
     We use
    
    <strong class="source-inline">
     
      Func&lt;T, object&gt;
     
    </strong>
    
     as a selector for
    
    <a id="_idIndexMarker205">
    </a>
    
     the property to sort by and name it
    
    
     <strong class="source-inline">
      
       Property
      
     </strong>
    
    
     
      intuitively.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     component to update the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     building block with the same logic as we did for
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     .
    
    
     Inside the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     , we replace the
    
    <strong class="source-inline">
     
      OnSort
     
    </strong>
    
     callback with the
    
    <strong class="source-inline">
     
      Func&lt;T, object&gt;
     
    </strong>
    
     parameter.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we fix the mapping in the overridden
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     method to pass the sorting property selector into the
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     constructor and consequently into the
    
    
     <strong class="source-inline">
      
       Grid
      
     </strong>
    
    
     
      instance.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component and implement the backing logic for the sorting feature.
    
    
     First, we declare two variables representing the current state of the sorting:
    
    <strong class="source-inline">
     
      _currentSortColumn
     
    </strong>
    
     , indicating which sorting property is currently selected, and an
    
    <strong class="source-inline">
     
      _isAsc
     
    </strong>
    
     flag, implying whether the sorting order is ascending
    
    
     
      or descending.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we introduce a
    
    <strong class="source-inline">
     
      PaginatorRef
     
    </strong>
    
     variable of type
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     .
    
    
     It might look a bit confusing at first glance.
    
    
     Using a component as a variable in your C# code in Blazor allows you to interact with the component’s public API.
    
    
     Furthermore, with the
    
    <strong class="source-inline">
     
      @ref
     
    </strong>
    
     attribute, you can capture a reference to the rendered component and leverage its methods and properties.
    
    
     But
    
    <strong class="source-inline">
     
      @ref
     
    </strong>
    
     has one major limitation – the reference is only populated after the component rendering completes.
    
    
     Since Blazor’s rendering process is asynchronous, any attempt to use the reference immediately after component initialization may fail because the reference might not yet be available.
    
    
     Therefore, you must ensure that you access the
    
    <strong class="source-inline">
     
      @ref
     
    </strong>
    
     bound reference only after the component render
    
    
     
      cycle completes.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      SortAsync()
     
    </strong>
    
     method, the center of our sorting logic.
    
    
     The
    
    <strong class="source-inline">
     
      SortAsync()
     
    </strong>
    
     method requires a
    
    <strong class="source-inline">
     
      ColumnViewModel
     
    </strong>
    
     object to define the sorting to perform.
    
    
     First, we determine the sorting order by checking whether the current sorting column label matches the one selected by the user.
    
    
     If they match, it indicates the user is trying to invert the sorting order, so we flip the current value of
    
    <strong class="source-inline">
     
      _isAsc
     
    </strong>
    
     .
    
    
     Otherwise, we set it to ascending order, as expected for the initial behavior.
    
    
     Next, we leverage a generic
    
    <strong class="source-inline">
     
      Comparison
     
    </strong>
    
     C# object.
    
    
     The
    
    <strong class="source-inline">
     
      Comparison&lt;T&gt;
     
    </strong>
    
     delegate represents a comparison method that compares two objects of the same type.
    
    
     We build the
    
    <strong class="source-inline">
     
      comparer
     
    </strong>
    
     delegate using a lambda expression that compares the
    
    <strong class="source-inline">
     
      left
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      right
     
    </strong>
    
     objects in the collection using the default
    
    <strong class="source-inline">
     
      Comparer
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      Comparer&lt;T&gt;
     
    </strong>
    
     class provides a way to compare two objects and returns an integer indicating their relative order.
    
    
     By checking
    
    <strong class="source-inline">
     
      _isAsc
     
    </strong>
    
     , we can negate the comparison result to arrive easily at a descending order.
    
    
     With the
    
    <strong class="source-inline">
     
      comparer
     
    </strong>
    
     instance in place, we use the
    
    <strong class="source-inline">
     
      Sort()
     
    </strong>
    
     LINQ extension method on the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     collection to reshuffle the elements according to our logic.
    
    
     Finally, we update the current sorting column reference
    
    <a id="_idIndexMarker206">
    </a>
    
     with the latest
    
    <strong class="source-inline">
     
      column.Label
     
    </strong>
    
     value and invoke the
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     method exposed by the
    
    <strong class="source-inline">
     
      PaginatorRef
     
    </strong>
    
     object to reload the dataset with the
    
    
     
      new sorting.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     markup, locate the table header area where we render each table column header, and attach the
    
    <strong class="source-inline">
     
      SortAsync()
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      @onclick
     
    </strong>
    
     event handler with the current
    
    <strong class="source-inline">
     
      column
     
    </strong>
    
     reference.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we scroll down to where we constructed the
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     instance and, with the help of the
    
    <strong class="source-inline">
     
      @ref
     
    </strong>
    
     attribute, attach the
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     instance to the
    
    <strong class="source-inline">
     
      PaginatorRef
     
    </strong>
    
     variable we have in the code part of
    
    
     
      the component.
     
    
   </p>
   <p>
    
     After all the sorting enhancements, the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component is no longer compatible.
    
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we move to the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup and update the
    
    <strong class="source-inline">
     
      Column
     
    </strong>
    
     instances by declaring the
    
    <strong class="source-inline">
     
      Property
     
    </strong>
    
     delegate with a lambda expression for each column
    
    
     
      we render.
     
    
   </p>
   <h1 id="_idParaDest-156">
    <a id="_idTextAnchor156">
    </a>
    
     Implementing infinite scrolling
    
   </h1>
   <p>
    
     In user experience trends, there’s
    
    <a id="_idIndexMarker207">
    </a>
    
     a shift from traditional pagination to a more dynamic and seamless infinite scrolling approach.
    
    <strong class="source-inline">
     
      Virtualize
     
    </strong>
    
     , integrated into the Blazor framework, was designed to enhance the user interface by loading content on-demand as users scroll through the page.
    
    
     It smartly manages resources by only rendering items in the viewport and fetching additional content as needed, significantly improving performance and user experience, especially in applications dealing with large datasets.
    
    
     By implementing infinite scrolling with the
    
    <strong class="source-inline">
     
      Virtualize
     
    </strong>
    
     component, you can offer a smoother, more engaging interaction pattern, eliminating the need for manual page navigation and making content
    
    
     
      exploration effortless.
     
    
   </p>
   <p>
    
     Let’s construct a simple grid
    
    <a id="_idIndexMarker208">
    </a>
    
     and implement infinite scrolling, leveraging the
    
    
     <strong class="source-inline">
      
       Virtualize
      
     </strong>
    
    
     
      component.
     
    
   </p>
   <h2 id="_idParaDest-157">
    <a id="_idTextAnchor157">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To simplify the grid itself and focus on the infinite scrolling implementation, we will not leverage any grid markup built in prior recipes but rather start from scratch.
    
    
     But before you dive in, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      from the
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      file of your application and register the
     
     <strong class="source-inline">
      
       TicketsApi
      
     </strong>
     
      service, from
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      , in the application dependency
     
     
      
       injection container:
      
     
     <pre class="source-code">
builder.Services.AddScoped&lt;TicketsApi&gt;();</pre>
    </li>
   </ul>
   <h2 id="_idParaDest-158">
    <a id="_idTextAnchor158">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to add infinite scrolling to
    
    
     
      a grid:
     
    
   </p>
   <ol>
    <li>
     
      Create a generic
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component using the
     
     
      <strong class="source-inline">
       
        typeparam
       
      </strong>
     
     
      
       attribute:
      
     
     <pre class="source-code">
@typeparam T</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component, declare three
     
     
      
       required parameters:
      
     
     <pre class="source-code">
[Parameter, EditorRequired]
public Func&lt;int, int, CancellationToken,
    Task&lt;(int, List&lt;T&gt;)&gt;&gt; Provider { get; set; }
[Parameter, EditorRequired]
public RenderFragment Header { get; set; }
[Parameter, EditorRequired]
public RenderFragment&lt;T&gt; Row { get; set; }</pre>
     <p class="list-inset">
      
       The three
      
      
       
        parameters are:
       
      
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        
         Provider
        
       </strong>
       
        – delegate that encapsulates
       
       
        
         data fetching
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         Header
        
       </strong>
       
        –
       
       <strong class="source-inline">
        
         RenderFragment
        
       </strong>
       
        for the table
       
       
        
         header template
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         Row
        
       </strong>
       
        – generic
       
       <strong class="source-inline">
        
         RenderFragment
        
       </strong>
       
        for the table
       
       
        
         row template
        
       
      </li>
     </ul>
    </li>
    <li>
     
      Below the parameters, implement
     
     <a id="_idIndexMarker209">
     </a>
     
      a
     
     <strong class="source-inline">
      
       LoadAsync()
      
     </strong>
     
      method to handle dynamic data loading; accepting
     
     <strong class="source-inline">
      
       ItemsProviderRequest
      
     </strong>
     
      as input and returning a generic
     
     
      <strong class="source-inline">
       
        ItemsProviderResult
       
      </strong>
     
     
      
       object:
      
     
     <pre class="source-code">
private async ValueTask&lt;ItemsProviderResult&lt;T&gt;&gt;
    LoadAsync(ItemsProviderRequest request)
{
    (var total, var data) = await Provider
        .Invoke(request.StartIndex, request.Count,
                request.CancellationToken);
    return new(data, total);
}</pre>
    </li>
    <li>
     
      Move to the
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component’s markup area and construct a table: embed the
     
     <strong class="source-inline">
      
       Header
      
     </strong>
     
      template within the
     
     <strong class="source-inline">
      
       &lt;thead&gt;
      
     </strong>
     
      tags and for the
     
     <strong class="source-inline">
      
       &lt;tbody&gt;
      
     </strong>
     
      section, utilize the
     
     <strong class="source-inline">
      
       Virtualize
      
     </strong>
     
      component, linking it to the
     
     <strong class="source-inline">
      
       LoadAsync()
      
     </strong>
     
      method via its
     
     <strong class="source-inline">
      
       ItemsProvider
      
     </strong>
     
      parameter, and pass the
     
     <strong class="source-inline">
      
       Row
      
     </strong>
     
      template as its
     
     
      <strong class="source-inline">
       
        ChildContent
       
      </strong>
     
     
      
       parameter:
      
     
     <pre class="source-code">
&lt;table class="table table-bordered"&gt;
    &lt;thead&gt;
        @Header
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;Virtualize ItemsProvider="@LoadAsync"&gt;
            @Row(context)
        &lt;/Virtualize&gt;
    &lt;/tbody&gt;
&lt;/table&gt;</pre>
    </li>
    <li>
     
      Create a routable
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component.
     
     
      Set
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      to render in
     
     <strong class="source-inline">
      
       InteractiveWebAssembly
      
     </strong>
     
      mode and
     
     
      
       inject
      
     
     
      <strong class="source-inline">
       
        TicketsApi
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
@page "/ch04r05"
@rendermode InteractiveWebAssembly
@inject TicketsApi Tickets</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup, incorporate the newly created
     
     <strong class="source-inline">
      
       Grid
      
     </strong>
     
      component.
     
     
      Attach the
     
     <strong class="source-inline">
      
       Tickets.GetAsync()
      
     </strong>
     
      method to the
     
     <strong class="source-inline">
      
       Provider
      
     </strong>
     
      parameter and
     
     <a id="_idIndexMarker210">
     </a>
     
      define the
     
     <strong class="source-inline">
      
       Header
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Row
      
     </strong>
     
      templates for rendering
     
     <strong class="source-inline">
      
       Ticket
      
     </strong>
     
      properties within
     
     
      
       the grid:
      
     
     <pre class="source-code">
&lt;Grid Provider="@Service.GetAsync"&gt;
    &lt;Header&gt;
        &lt;tr&gt;
            &lt;td&gt;Id&lt;/td&gt;
            &lt;td&gt;Tariff&lt;/td&gt;
            &lt;td&gt;Price&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/Header&gt;
    &lt;Row&gt;
        &lt;tr&gt;
            &lt;td&gt;@context.Id&lt;/td&gt;
            &lt;td&gt;@context.Tariff&lt;/td&gt;
            &lt;td&gt;@context.Price&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/Row&gt;
&lt;/Grid&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-159">
    <a id="_idTextAnchor159">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a generic
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component that serves as the foundation for dynamically displaying
    
    <a id="_idIndexMarker211">
    </a>
    
     data in a tabular format with infinite
    
    
     
      scrolling capabilities.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we declare a few required parameters within the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component.
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     , of type
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     , enable the customization of the table’s header and facilitate the dynamic rendering of table rows.
    
    
     Additionally, we specify a
    
    <strong class="source-inline">
     
      Provider
     
    </strong>
    
     delegate to encapsulate the logic for fetching data.
    
    
     We intentionally designed
    
    <strong class="source-inline">
     
      Provider
     
    </strong>
    
     to match the
    
    <strong class="source-inline">
     
      ItemsProvider
     
    </strong>
    
     signature required by the
    
    <strong class="source-inline">
     
      Virtualize
     
    </strong>
    
     component, ensuring compatibility and
    
    
     
      seamless integration.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     method that plays a pivotal role in fetching data in response to the user’s scroll actions.
    
    
     It accepts an
    
    <strong class="source-inline">
     
      ItemsProviderRequest
     
    </strong>
    
     parameter and returns an
    
    <strong class="source-inline">
     
      ItemsProviderResult&lt;T&gt;
     
    </strong>
    
     object to enable the
    
    <strong class="source-inline">
     
      Virtualize
     
    </strong>
    
     component continuous population of the grid as users scroll through the content.
    
    <strong class="source-inline">
     
      ItemsProviderRequest
     
    </strong>
    
     provides the current state of scrolling, exposing
    
    <strong class="source-inline">
     
      StartIndex
     
    </strong>
    
     , which defines from which index the next data batch should start.
    
    
     To construct the
    
    <strong class="source-inline">
     
      ItemsProviderResult&lt;T&gt;
     
    </strong>
    
     response, we need a subset of new objects to render and a total number of objects in the collection.
    
    
     The
    
    <strong class="source-inline">
     
      Virtualize
     
    </strong>
    
     component uses that total to safely stop data fetching and avoid throwing an
    
    
     
      indexing exception.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we set up the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     markup.
    
    
     We add a
    
    <strong class="source-inline">
     
      &lt;table&gt;
     
    </strong>
    
     structure where we place the
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     template within
    
    <strong class="source-inline">
     
      &lt;thead&gt;
     
    </strong>
    
     tags and utilize the
    
    <strong class="source-inline">
     
      Virtualize
     
    </strong>
    
     component within the
    
    <strong class="source-inline">
     
      &lt;tbody&gt;
     
    </strong>
    
     tags.
    
    
     By attaching the
    
    <strong class="source-inline">
     
      LoadAsync()
     
    </strong>
    
     method as the
    
    <strong class="source-inline">
     
      ItemsProvider
     
    </strong>
    
     parameter and
    
    <a id="_idIndexMarker212">
    </a>
    
     including the
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     template as the
    
    <strong class="source-inline">
     
      Virtualize
     
    </strong>
    
     component
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     , the grid dynamically renders additional rows of data, creating an infinite
    
    
     
      scrolling effect.
     
    
   </p>
   <p>
    
     To demonstrate the usage of the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component, in
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we introduce a routable
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component.
    
    
     We set
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     to render in
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode and inject
    
    <strong class="source-inline">
     
      TicketsApi
     
    </strong>
    
     as we will need it as the data source.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we integrate the
    
    <strong class="source-inline">
     
      Grid
     
    </strong>
    
     component into the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup, with
    
    <strong class="source-inline">
     
      Tickets.GetAsync
     
    </strong>
    
     serving as the data provider and
    
    <strong class="source-inline">
     
      Header
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Row
     
    </strong>
    
     templates specified to display the properties of the
    
    
     <strong class="source-inline">
      
       Ticket
      
     </strong>
    
    
     
      objects.
     
    
   </p>
   <h2 id="_idParaDest-160">
    <a id="_idTextAnchor160">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Utilizing the
    
    <strong class="source-inline">
     
      Virtualize
     
    </strong>
    
     component in your Blazor applications brings forth a multitude of benefits that enhance both performance and
    
    
     
      user experience:
     
    
   </p>
   <ul>
    <li>
     
      Firstly,
     
     <strong class="source-inline">
      
       Virtualize
      
     </strong>
     
      dramatically improves performance and reduces memory usage when dealing with large datasets.
     
     
      This efficiency gain comes from its rendering approach, where only a visible subset of items is rendered at any given time, reducing the overall load on
     
     
      
       the browser.
      
     
    </li>
    <li>
     
      Secondly, the simplicity offered by
     
     <strong class="source-inline">
      
       Virtualize
      
     </strong>
     
      cannot be overstated.
     
     
      You can implement sophisticated infinite scrolling functionalities with minimal code, as the component abstracts the complexities of item virtualization and automatic
     
     
      
       event handling.
      
     
    </li>
    <li>
     
      Lastly,
     
     <strong class="source-inline">
      
       Virtualize
      
     </strong>
     
      provides remarkable flexibility, enabling seamless integration with a wide array of data sources.
     
     
      This flexibility is especially beneficial for applications requiring real-time data fetching, as you can tailor the
     
     <strong class="source-inline">
      
       ItemsProvider
      
     </strong>
     
      delegate
     
     <a id="_idIndexMarker213">
     </a>
     
      to suit specific data fetching logic, ensuring that applications remain responsive and up to date with the
     
     
      
       latest information.
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-161">
    <a id="_idTextAnchor161">
    </a>
    
     Utilizing QuickGrid
    
   </h1>
   <p>
    
     In this recipe, we’ll explore a powerful component now embedded directly into the Blazor framework –
    
    <strong class="bold">
     
      QuickGrid
     
    </strong>
    
     .
    
    
     QuickGrid simplifies the creation and management of dynamic, data-driven grids in Blazor
    
    <a id="_idIndexMarker214">
    </a>
    
     applications, offering out-of-the-box functionalities such as sorting, pagination, and filtering.
    
    
     This component stands out for its ease of implementation and high performance in presenting and manipulating large datasets thanks to the baked-in virtualization.
    
    
     QuickGrid eliminates the need for additional NuGet packages, streamlining development processes and reducing
    
    
     
      project complexity.
     
    
   </p>
   <p>
    
     Let’s walk through the essentials of QuickGrid and showcase how simple it is
    
    
     
      to implement.
     
    
   </p>
   <h2 id="_idParaDest-162">
    <a id="_idTextAnchor162">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we explore the QuickGrid implementation, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      from the
     
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      file of your application and register the
     
     <strong class="source-inline">
      
       TicketsApi
      
     </strong>
     
      service, from
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      , in the application dependency
     
     
      
       injection container:
      
     
     <pre class="source-code">
builder.Services.AddScoped&lt;TicketsApi&gt;();</pre>
    </li>
   </ul>
   <h2 id="_idParaDest-163">
    <a id="_idTextAnchor163">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To render a grid utilizing QuickGrid, follow
    
    <a id="_idIndexMarker215">
    </a>
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       .csproj
      
     </strong>
     
      configuration file of your project and add the
     
     <strong class="source-inline">
      
       Microsoft.AspNetCore.Components.QuickGrid
      
     </strong>
     
      package to
     
     
      
       your project:
      
     
     <pre class="source-code">
&lt;ItemGroup&gt;
  &lt;PackageReference
      Include=
          "Microsoft.AspNetCore.Components.QuickGrid"
      Version="8.0.2" /&gt;
&lt;/ItemGroup&gt;</pre>
    </li>
    <li>
     
      Create a new routable
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component, with a reference to the
     
     <strong class="source-inline">
      
       QuickGrid
      
     </strong>
     
      package, that renders in
     
     <strong class="source-inline">
      
       InteractiveWebAssembly
      
     </strong>
     
      mode, and inject the
     
     
      <strong class="source-inline">
       
        TicketApi
       
      </strong>
     
     
      
       service:
      
     
     <pre class="source-code">
@page "/ch04r06"
@using Microsoft.AspNetCore.Components.QuickGrid
@rendermode InteractiveWebAssembly
@inject TicketsApi Tickets</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      component, introduce a
     
     <strong class="source-inline">
      
       Pagination
      
     </strong>
     
      variable of type
     
     <strong class="source-inline">
      
       PaginationState
      
     </strong>
     
      to configure data pagination of the
     
     
      <strong class="source-inline">
       
        QuickGrid
       
      </strong>
     
     
      
       instance:
      
     
     <pre class="source-code">
@code {
    protected PaginationState Pagination = new()
    {
        ItemsPerPage = 5
    };
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       TicketManager
      
     </strong>
     
      markup, construct the
     
     <strong class="source-inline">
      
       QuickGrid
      
     </strong>
     
      component with nested
     
     <strong class="source-inline">
      
       PropertyColumn
      
     </strong>
     
      components to
     
     <a id="_idIndexMarker216">
     </a>
     
      define the data columns and integrate a
     
     <strong class="source-inline">
      
       Paginator
      
     </strong>
     
      component to manage
     
     
      
       data pagination:
      
     
     <pre class="source-code">
&lt;QuickGrid Class="w-100 table table-bordered"
           Items="@Tickets.Get()"
           Pagination="@Pagination"&gt;
    &lt;PropertyColumn Property="@(x =&gt; x.Tariff)"
                    Sortable="true" /&gt;
    &lt;PropertyColumn Property="@(x =&gt; x.Price)"
                    Sortable="true" Format="0.00" /&gt;
&lt;/QuickGrid&gt;
&lt;Paginator State="@Pagination" /&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-164">
    <a id="_idTextAnchor164">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the configuration file of the project (the one with a
    
    <strong class="source-inline">
     
      .csproj
     
    </strong>
    
     extension) and add the
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.Components.QuickGrid
     
    </strong>
    
     package into the project.
    
    
     QuickGrid is officially a part of the Blazor ecosystem but isn’t included in the Blazor project
    
    
     
      by default.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we create a new routable
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component, where we will put
    
    <strong class="source-inline">
     
      QuickGrid
     
    </strong>
    
     to the test.
    
    
     As the grid will be interactive, we declare
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     to render in
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode.
    
    
     We also include a
    
    <strong class="source-inline">
     
      using
     
    </strong>
    
     directive, referencing the
    
    <strong class="source-inline">
     
      QuickGrid
     
    </strong>
    
     namespace.
    
    
     And lastly, we inject the
    
    <strong class="source-inline">
     
      TicketsApi
     
    </strong>
    
     service to have a data source for
    
    
     
      the grid.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we initialize the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     component where we construct an instance of a
    
    <strong class="source-inline">
     
      Pagination
     
    </strong>
    
     variable and set its
    
    <strong class="source-inline">
     
      ItemsPerPage
     
    </strong>
    
     property.
    
    <strong class="source-inline">
     
      QuickGrid
     
    </strong>
    
     requires a
    
    <strong class="source-inline">
     
      PaginationState
     
    </strong>
    
     object to enable
    
    
     
      the pagination.
     
    
   </p>
   <p>
    
     Finally, in
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we embed
    
    <strong class="source-inline">
     
      QuickGrid
     
    </strong>
    
     in the
    
    <strong class="source-inline">
     
      TicketManager
     
    </strong>
    
     markup.
    
    
     We attach the
    
    <strong class="source-inline">
     
      Tickets.Get()
     
    </strong>
    
     method and the
    
    <strong class="source-inline">
     
      Pagination
     
    </strong>
    
     object to
    
    <strong class="source-inline">
     
      QuickGrid
     
    </strong>
    
     ’s
    
    <strong class="source-inline">
     
      Items
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Pagination
     
    </strong>
    
     parameters respectively.
    
    
     Next, we construct grid columns using
    
    <strong class="source-inline">
     
      PropertyColumn
     
    </strong>
    
     components.
    
    
     We specify properties to render with a delegate and enable sorting by setting the
    
    <strong class="source-inline">
     
      Sortable
     
    </strong>
    
     parameter accordingly.
    
    
     For the
    
    <strong class="source-inline">
     
      Price
     
    </strong>
    
     column, we additionally set the
    
    <strong class="source-inline">
     
      Format
     
    </strong>
    
     parameter.
    
    
     The
    
    <strong class="source-inline">
     
      QuickGrid
     
    </strong>
    
     component will automatically apply this formatting to
    
    <a id="_idIndexMarker217">
    </a>
    
     all prices in that column.
    
    
     Lastly, we incorporate a
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     component that we link to the same
    
    <strong class="source-inline">
     
      Pagination
     
    </strong>
    
     variable as the
    
    <strong class="source-inline">
     
      QuickGrid
     
    </strong>
    
     Instance.
    
    <strong class="source-inline">
     
      Paginator
     
    </strong>
    
     exposes the pagination UI to the user and executes navigation requests directly
    
    
     
      on
     
    
    
     <strong class="source-inline">
      
       QuickGrid
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     At the end, we get a fully functional, optimized, and
    
    
     
      feature-rich grid:
     
    
   </p>
   <div><div><img alt="Figure 4.2: Grid with sortable columns and pagination rendered with QuickGrid" src="img/B22020_04_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.2: Grid with sortable columns and pagination rendered with QuickGrid
    
   </p>
  </div>
 </body></html>