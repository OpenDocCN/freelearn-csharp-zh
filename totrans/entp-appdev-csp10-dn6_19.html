<html><head></head><body>
		<div id="_idContainer223">
			<h1 id="_idParaDest-262"><em class="italic"><a id="_idTextAnchor1674"/>Chapter 14</em>: Health and Diagnostics</h1>
			<p>Modern software applications have evolved to be complex and dynamic and are distributed in nature. There is a high demand for these applications to be able to work round the clock, anywhere, on any device. To achieve this, it is important to know that our application is available and responds to requests at all times. Customer experiences will play a big role in the future of service and the revenue of an organization.</p>
			<p>Once the application is live, it is critical to monitor the application's health. Regular application health monitoring will help us to proactively detect any failures and address them before they cause more damage. Application monitoring has now become a part of day-to-day operations. To diagnose any failure on a live application, we need to have the right telemetry and diagnostic tools. The telemetry that we capture will also help us identify those problems not directly seen or reported by users.</p>
			<p>Let's learn about application health monitoring and what is on offer in .NET 6.</p>
			<p>In this chapter, we will learn about the following topics:</p>
			<ul>
				<li>Introducing health checks</li>
				<li>The health check API in ASP.NET Core 6</li>
				<li>Monitoring the application with Application Insights</li>
				<li>Performing remote debugging</li>
			</ul>
			<p>By the end of this chapter, you'll have a good grasp of building the health check API for .NET 6 apps and Azure Application Insights for capturing telemetry and diagnosing problems.</p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor1675"/><a id="_idTextAnchor1676"/>Technical requirements</h1>
			<p>You will need the following software to work through the tasks in this chapter:</p>
			<ul>
				<li>Visual Studio 2022 Community Edition with the Azure development workload installed (certain sections require Enterprise Edition)</li>
				<li>An Azure subscription</li>
			</ul>
			<p>A basic understanding of Microsoft .NET and how to create resources in Azure is expected.</p>
			<p>The code used in this chapter can be found at <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application</a>.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor1677"/><a id="_idTextAnchor1678"/>Introducing health checks</h1>
			<p>A health check is<a id="_idIndexMarker1263"/> a<a id="_idTextAnchor1679"/> comprehensive review of an application that helps us to understand the current state of the application and use visible indicators to take corrective measures. Health checks are exposed as HTTP endpoints by applications. The health check endpoints are used as health probes for certain orchestrators and load balancers to route traffic away from a failing node. Health checks are used to monitor application dependencies, such as databases, external services, and cache services.</p>
			<p>In the next section, we will learn about the support for building the health check API in ASP.NET Core 6.<a id="_idTextAnchor1680"/><a id="_idTextAnchor1681"/></p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor1682"/>The health check API in ASP.NET Core 6</h1>
			<p>ASP.NET<a id="_idTextAnchor1683"/> Core 6 has <a id="_idIndexMarker1264"/>a built-in middleware (available via the <strong class="source-inline">Microsoft.Extensions.Diagnostics.HealthChecks</strong> NuGet package) t<a id="_idTextAnchor1684"/>o report the health status of the application components exposed as an HTTP endpoint. This<a id="_idIndexMarker1265"/> middleware makes it so easy to integrate health checks for databases, external systems, and other dependencies. It is also extensible, so we can create our own custom health checks.</p>
			<p>In the next section, we will add a health check endpoint to our <strong class="source-inline">Ecommerce</strong> porta<a id="_idTextAnchor1685"/><a id="_idTextAnchor1686"/>l.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor1687"/>Adding a health check endpoint</h2>
			<p>In this section, <a id="_idTextAnchor1688"/>we <a id="_idIndexMarker1266"/>will add a health check endpoint to our <strong class="source-inline">Packt.Ecommerce.Web</strong> application:</p>
			<ol>
				<li>In order to add a health check endpoint, we need to first add the <strong class="source-inline">Microsoft.Extensions.Diagnostics.HealthChecks</strong> NuGet package reference to the <strong class="source-inline">Packt.Ecommerce.Web</strong> project, as shown in the following screensho<a id="_idTextAnchor1689"/>t:</li>
			</ol>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/Figure_14.1_B18507.jpg" alt="Figure 14.1 – NuGet reference, Microsoft.Extensions.Diagnostics.HealthChecks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 – NuGet reference, Microsoft.Extensions.Diagnostics.HealthChecks</p>
			<p>Now, we need to<a id="_idIndexMarker1267"/> register <strong class="source-inline">HealthCheckService</strong> with the dependency container. The <strong class="source-inline">Microsoft.Extensions.Diagnostics.HealthChecks</strong> package has the <strong class="source-inline">AddHealthChecks</strong> extension method defined to add <strong class="source-inline">HealthCheckService</strong> to the container. We can call the <strong class="source-inline">AddHealthChecks</strong> method from the <strong class="source-inline">Program.cs</strong> file to add the <strong class="source-inline">DefaultHealthCheckService</strong> module:</p>
			<p class="source-code">// Removed code for brevity.</p>
			<p class="source-code">// Add health check services to the container.</p>
			<p class="source-code"><strong class="bold">builder.Services.AddHealthChecks();</strong></p>
			<ol>
				<li value="2">Let's<a id="_idTextAnchor1690"/> go ahead and configure the health check endpoint to our web application. Map the health endpoint using the <strong class="source-inline">MapHealthChecks</strong> method, as shown in the following code, in the <strong class="source-inline">Program.cs</strong> file. This will add the health check endpoint route to the application. This will internally configure the <strong class="source-inline">HealthCheckResponseWriters.WriteMinimalPlainText</strong> framework method to emit the response. <strong class="source-inline">WriteMinimalPlainText</strong> will just emit the overall status of the health check services:<p class="source-code">// Removed code for brevity.</p><p class="source-code">app.UseEndpoints(endpoints =&gt;</p><p class="source-code">{</p><p class="source-code">    endpoints.MapControllerRoute(</p><p class="source-code">         name: "default",</p><p class="source-code">         pattern: </p><p class="source-code">        "{controller=Products}/{action=Index}/{id?}");</p><p class="source-code">    <strong class="bold">endpoints.MapHealthChecks("/health");</strong></p><p class="source-code">});</p></li>
				<li>Run <a id="_idTextAnchor1691"/>the <a id="_idIndexMarker1268"/>application and browse to the <strong class="source-inline">&lt;&lt;Application URL&gt;&gt;/health</strong> URL. You will see following the outp<a id="_idTextAnchor1692"/>ut:</li>
			</ol>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/Figure_14.2_B18507.jpg" alt="Figure 14.2 – Health check endpoint response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2 – Health check endpoint response</p>
			<p>The health endpoint we added provides basic information on service availability. In the next section, we will see how we can monitor the status of dependent se<a id="_idTextAnchor1693"/>rvic<a id="_idTextAnchor1694"/><a id="_idTextAnchor1695"/>es.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor1696"/>Monitoring dependent URIs</h2>
			<p>An enterprise<a id="_idIndexMarker1269"/> application depends on multiple other components, such as databases and Azure components including <strong class="source-inline">KeyVault</strong>, and o<a id="_idTextAnchor1697"/>ther microservices (such as our <strong class="source-inline">Ecommerce</strong> website) depend on the Order service, Product service, and so on. These services can be owned by other teams within the same organization or, in some cases, they might be external services. It is often a good idea to monitor dependent services. We can leverage the <strong class="source-inline">AspNetCore.HealthChecks.Uris</strong> NuGet package to monitor the availability of dependent services.</p>
			<p>Let's go ahead and enhance our health endpoint to monitor the Product and Order services:</p>
			<ol>
				<li value="1">Add the NuGet package reference to <strong class="source-inline">AspNetCore.HealthChecks.Uris</strong>. Now, modify the health check registration to register the Product and Order services, as shown in the following code snippet:<p class="source-code">// Add health check services to the container.</p><p class="source-code">services.AddHealthChecks()</p><p class="source-code"><strong class="bold">.AddUrlGroup(new Uri(this.Configuration.GetValue&lt;string&gt;("ApplicationSettings:ProductsApiEndpoint ")), name: "Product Service")</strong></p><p class="source-code"><strong class="bold">.AddUrlGroup(new Uri(this.Configuration.GetValue&lt;string&gt;("ApplicationSettings:OrdersApiEndpoint ")), name: "Order Service");</strong></p></li>
			</ol>
			<p>The health check middleware<a id="_idIndexMarker1270"/> also provides details about the status of individual health checks.</p>
			<ol>
				<li value="2">Let's now modify our health check middlewa<a id="_idTextAnchor1698"/>re to emit the details as shown in the following code:<p class="source-code">// Removed code for brevity.</p><p class="source-code">app.UseEndpoints(endpoints =&gt;</p><p class="source-code">{</p><p class="source-code">   endpoints.MapControllerRoute(</p><p class="source-code">        name: "default",</p><p class="source-code">        pattern: "{controller=Products}/{action=Index}/{id?}");</p><p class="source-code"><strong class="bold">        endpoints.MapHealthChecks("/health", new </strong></p><p class="source-code"><strong class="bold">          HealthCheckOptions</strong></p><p class="source-code"><strong class="bold">        {</strong></p><p class="source-code"><strong class="bold">          ResponseWriter = async (context, report) =&gt;</strong></p><p class="source-code"><strong class="bold">          {</strong></p><p class="source-code"><strong class="bold">             context.Response.ContentType = </strong></p><p class="source-code"><strong class="bold">               "application/json";</strong></p><p class="source-code"><strong class="bold">             var response = new</strong></p><p class="source-code"><strong class="bold">      {</strong></p><p class="source-code"><strong class="bold">         Status = report.Status.ToString(),</strong></p><p class="source-code"><strong class="bold">         HealthChecks = report.Entries.Select(x =&gt; new</strong></p><p class="source-code"><strong class="bold">         {</strong></p><p class="source-code"><strong class="bold">            Component = x.Key,</strong></p><p class="source-code"><strong class="bold">            Status = x.Value.Status.ToString(),</strong></p><p class="source-code"><strong class="bold">            Description = x.Value.Description,</strong></p><p class="source-code"><strong class="bold">          }),</strong></p><p class="source-code"><strong class="bold">          HealthCheckDuration = report.TotalDuration,</strong></p><p class="source-code"><strong class="bold">      };</strong></p><p class="source-code"><strong class="bold">      await context.Response.WriteAsync(</strong></p><p class="source-code"><strong class="bold">        JsonConvert.SerializeObject(response))</strong></p><p class="source-code"><strong class="bold">        .ConfigureAwait(false);</strong></p><p class="source-code"><strong class="bold">    },</strong></p><p class="source-code"><strong class="bold">   });</strong></p><p class="source-code">});</p></li>
			</ol>
			<p>In this code<a id="_idTextAnchor1699"/>, the<a id="_idIndexMarker1271"/> health check middleware is overwritten to write the details of the status, health check duration, component name, and a description as its response by providing <strong class="source-inline">HealthCheckOptions</strong> with <strong class="source-inline">ResponseWriter</strong>.</p>
			<ol>
				<li value="3">Now, if we run the project and navigate to the health check API, we should see the following ou<a id="_idTextAnchor1700"/>tput:</li>
			</ol>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/Figure_14.3_B18507.jpg" alt="Figure 14.3 – Health check endpoint response with status&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3 – Health check endpoint response with status</p>
			<p>We have<a id="_idIndexMarker1272"/> learned how to customi<a id="_idTextAnchor1701"/>ze the response of the health check endpoint and how to leverage a third-party library to monitor the status of dependent URIs. If you wish to integrate the check for a database used via Entity Framework Core, you can leverage the <strong class="source-inline">Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore</strong> library. More information about using this library can be found at <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0#entity-framework-core-dbcontext-probe">https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0#entity-framework-core-dbcontext-probe</a>.</p>
			<p>A wider collection of health check packages for different services can be found at <a href="https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks">https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks</a>. In the next section, we will learn how to build a custom health <a id="_idTextAnchor1702"/><a id="_idTextAnchor1703"/>check.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor1704"/>Building a custom health check</h2>
			<p>The <a id="_idIndexMarker1273"/>healt<a id="_idTextAnchor1705"/>h check middleware in ASP.NET Core 6 is extensible, meaning that it allows us to extend and create a custom health check. We<a id="_idIndexMarker1274"/> will learn how to build and use custom health checks by building a process monitor. In some scenarios, there might be a need to monitor a specific process running on the machine. If the process (for example, an anti-malware service) is not running, or if the license of a third-party SaaS offering is expiring/expired, we might flag them as health issues.</p>
			<p>Let's start creating the <strong class="source-inline">ProcessMonitor</strong> health check in the <strong class="source-inline">Packt.Ecommerce.Common</strong> project:</p>
			<ol>
				<li value="1">Add a<a id="_idIndexMarker1275"/> project folder named <strong class="source-inline">HealthCheck</strong> to <strong class="source-inline">Packt.Ecommerce.Common</strong> and add two classes, <strong class="source-inline">ProcessMonitor</strong> and <strong class="source-inline">ProcessMonitorHealthCheckBuilderExtensions</strong>, as shown in the <a id="_idTextAnchor1706"/>following <a id="_idIndexMarker1276"/>sc<a id="_idTextAnchor1707"/>reenshot:</li>
			</ol>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/Figure_14.4_B18507.jpg" alt="Figure 14.4 – Project structure after adding a custom health check&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4 – Project structure after adding a custom health check</p>
			<p>The custom <strong class="source-inline">HealthCheck</strong> middleware requires the NuGet reference to be <strong class="source-inline">Microsoft.Extensions.Diagnostics.HealthChecks</strong>.</p>
			<ol>
				<li value="2">The custom health check in ASP.NET Core 6 should implement the <strong class="source-inline">IHealthCheck</strong> interface. This interface defines the <strong class="source-inline">CheckHealthAsync</strong> method that will get called when the request comes to the health endpoint API.</li>
				<li><a id="_idTextAnchor1708"/>Implement<a id="_idIndexMarker1277"/> the <strong class="source-inline">ProcessMonitorHealthCheck</strong> class as shown in the following <a id="_idIndexMarker1278"/>code:<p class="source-code">public class ProcessMonitorHealthCheck : IHealthCheck</p><p class="source-code">{</p><p class="source-code">   private readonly string processName;</p><p class="source-code">   public ProcessMonitorHealthCheck(string </p><p class="source-code">     processName) =&gt; this.processName = processName;</p><p class="source-code">   public Task&lt;HealthCheckResult&gt; </p><p class="source-code">     CheckHealthAsync(HealthCheckContext context, </p><p class="source-code">     CancellationToken cancellationToken = default)</p><p class="source-code">    {</p><p class="source-code">        Process[] pname = </p><p class="source-code">         Process.GetProcessesByName(this.processName);</p><p class="source-code">        if (pname.Length == 0)</p><p class="source-code">        {</p><p class="source-code">            return Task.FromResult(new </p><p class="source-code">              HealthCheckResult(context.Registration</p><p class="source-code">             .FailureStatus, description: $"Process </p><p class="source-code">              with the name {this.processName} is not </p><p class="source-code">              running."));</p><p class="source-code">        }</p><p class="source-code">        else</p><p class="source-code">        {</p><p class="source-code">            return Task.FromResult(</p><p class="source-code">              HealthCheckResult.Healthy());</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In the <strong class="source-inline">CheckHealthAsync</strong> method, fetch the list of processes with the name specified in <strong class="source-inline">processName</strong>. If there is no such process, then return as health check failed, otherwise, return the state as failed.</p>
			<ol>
				<li value="4">Now<a id="_idIndexMarker1279"/> that we have the custom <a id="_idIndexMarker1280"/>health check middleware, let's add an extension method to register. Modify the <strong class="source-inline">ProcessMonitorHealthCheckBuilderExtens<a id="_idTextAnchor1709"/>ions</strong> class as shown in the following code snippet:<p class="source-code">public static class ProcessMonitorHealthCheckBuilderExtensions</p><p class="source-code">    {</p><p class="source-code">        public static IHealthChecksBuilder </p><p class="source-code">          AddProcessMonitorHealthCheck(</p><p class="source-code">            this IHealthChecksBuilder builder,</p><p class="source-code">            string processName = default,</p><p class="source-code">            string name = default,</p><p class="source-code">            HealthStatus? failureStatus = default,</p><p class="source-code">            IEnumerable&lt;string&gt; tags = default)</p><p class="source-code">        {</p><p class="source-code">            return builder.Add(new </p><p class="source-code">              HealthCheckRegistration(</p><p class="source-code">               name ?? "ProcessMonitor",</p><p class="source-code">               sp =&gt; new </p><p class="source-code">               ProcessMonitorHealthCheck(processName),</p><p class="source-code">               failureStatus,</p><p class="source-code">               tags));</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
			</ol>
			<p>This is an extension method to <strong class="source-inline">IHealthCheckBuilder</strong>. We can see that adding <strong class="source-inline">ProcessMonitorHealthCheck</strong> in the code snippet registers it with the container.</p>
			<ol>
				<li value="5">Let's now <a id="_idIndexMarker1281"/>make use of the <a id="_idIndexMarker1282"/>custom health check that we have built. I<a id="_idTextAnchor1710"/>n the following code, we registered the <strong class="source-inline">ProcessMonitorHealthCheck</strong> health check for <strong class="source-inline">notepad</strong>:<p class="source-code">// Add health check services to the container.</p><p class="source-code">Builder.Services.AddHealthChecks()</p><p class="source-code">.AddUrlGroup(new Uri(this.Configuration.GetValue&lt;string&gt;("ApplicationSettings :ProductsApiEndpoint")), name: "Product Service")</p><p class="source-code">.AddUrlGroup(new Uri(this.Configuration.GetValue&lt;string&gt;("ApplicationSettings :OrdersApiEndpoint")), name: "Order Service")</p><p class="source-code">.AddProcessMonitorHealthCheck("notepad", name: "Notepad monitor");</p></li>
				<li>Now, when you run the application and navigate to the health check API, you will see the output shown in <em class="italic">Figure 14.5</em> if <strong class="source-inline">notepad.exe</strong> is running on<a id="_idTextAnchor1711"/> your machine:</li>
			</ol>
			<p class="figure-caption"><img src="image/Figure_14.5_B18507.png" alt="Figure 14.5 – Response from health check endpoint "/></p>
			<p class="figure-caption">Figure 14.5 – Response from the health che<a id="_idTextAnchor1712"/>ck endpoint</p>
			<p>We can<a id="_idIndexMarker1283"/> enable <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>), aut<a id="_idTextAnchor1713"/>horization, and <a id="_idIndexMarker1284"/>host restriction <a id="_idIndexMarker1285"/>on our health check endpoints. For details, please refer to <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0</a>.</p>
			<p>In some scenarios, the health check APIs are split into two types based on the state of the application that they probe. They are the following:</p>
			<ul>
				<li><strong class="bold">Readiness probe<a id="_idTextAnchor1714"/>s</strong>: These<a id="_idIndexMarker1286"/> indicate that the application is running normally but is not ready to take requests.</li>
				<li><strong class="bold">Liveliness prob<a id="_idTextAnchor1715"/>es</strong>: These <a id="_idIndexMarker1287"/>indicate whether the application has crashed and must be restarted.</li>
			</ul>
			<p>Both readiness and liveliness probes are used to control the health of the application. A failing readiness probe will stop the application from serving traffic, whereas a failing liveliness probe will restart the node. We use readiness and liveliness probes in hosting environments, such as Kubernet<a id="_idTextAnchor1716"/>es.</p>
			<p>We have learned about how to add the health check API to an ASP.NET Core 6 application. In the next section, we will learn about Azure Application Insights and how it helps to moni<a id="_idTextAnchor1717"/><a id="_idTextAnchor1718"/>tor an application.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor1719"/>Monitoring the application with Application Insights</h1>
			<p>Monitoring the <a id="_idIndexMarker1288"/>application is key to providing end users with a top-class experience. Appli<a id="_idTextAnchor1720"/>cation monitoring is needed to drive business return on investment and retain a competitive advantage in the current era of super-fast digital markets. The parameters we should be focusing on are page/API performance, most-used pages/APIs, application errors, and system health, among others. There should be alerts set up for when there is an anomaly in the system so that we can correct it and minimize the impact on our users.</p>
			<p>You were already introduced to integrating Application Insights into an application and its key features in <a href="B18507_07_Epub.xhtml#_idTextAnchor596"><em class="italic">Chapter 7</em></a>, <em class="italic">Logging in .NET 6</em>. Let's open Application Insights in the Azure portal and understand its different offerings. On the overview dashboard, along with the Azure subscription, location, and instrumentation key, we see key <a id="_idTextAnchor1721"/>metrics as follows:</p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/Figure_14.6_B18507.jpg" alt="Figure 14.6 – Application Insights dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.6 – Application Insights dashboard</p>
			<p>The <strong class="bold">Failed requests</strong> graph shows the number of requests that failed in the selected duration. This is the key metric we should pay attention to; many failures represent instability in the system. <strong class="bold">Server response time</strong> represents the average response time of the server for the calls. If the response time is too high, more users will see a lag in the application responsiveness, which might lead to frustration and we could lose our users as a result.</p>
			<p>The <strong class="bold">Server requests</strong> graph represents the total number of calls to the application; th<a id="_idTextAnchor1722"/>is will give us the patterns of the usage in the system. The <strong class="bold">Availability</strong> graph represents the uptime of the application. The availability tests that we will configure later in this chapter will show the <strong class="bold">Availability</strong> graph. By clicking on each graph, we can get more details pertaining to the respective metric, including requests and exception details. We can change the duration to view the graphs for the chosen interval.</p>
			<p>The graphs<a id="_idIndexMarker1289"/> on the overview dashboard show recent metrics. This can be useful in a situation where we wish to know the working of the system for a particular time in the past.</p>
			<p>In the next section, we will learn about some of the most important offerings from Application Insights, looking at Live Metrics, telemetry events, and remote<a id="_idTextAnchor1723"/><a id="_idTextAnchor1724"/> debugging features.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor1725"/>Live Metrics</h2>
			<p>Live Metrics <a id="_idIndexMarker1290"/>is enabled<a id="_idIndexMarker1291"/> by default. Live metrics are captured with a latency of 1 second<a id="_idTextAnchor1726"/>, unlike the analytics metrics, which are aggregated over time. The data for Live Metrics is streamed only when the Live Metrics pane is open. The collected data only persists while it is on the chart. During Live Metrics monitoring, all the events are transmitted from the server and they won't be sampled. We can also filter the events by the server if the application is deployed in a web farm.</p>
			<p>Live Metrics shows various charts, such as the incoming and outgoing requests, along with the overall health of the memory and CPU utilization. On the right-hand pane, we can see the captured telemetry, which will list the requests, dependency calls, and exceptions. Live Metrics is leveraged where we want to evaluate a fix that is released to production by watching the failure rates and performance. We will also monitor these while running a load test to see the effects of the load on the system.</p>
			<p>For applications such as our <strong class="source-inline">Ecommerce</strong> app, it is important to know how users are using the application, the most-used features, and how users are traversing through the application. In the next section, we will learn about usage analysis in<a id="_idTextAnchor1727"/><a id="_idTextAnchor1728"/> Application Insights.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor1729"/>Usage analysis with Application Insights</h2>
			<p>In <a href="B18507_11_Epub.xhtml#_idTextAnchor1228"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web Application</em>, you learned how to<a id="_idTextAnchor1730"/> integrate <a id="_idIndexMarker1292"/>Application Insights with views. When Application<a id="_idTextAnchor1731"/> Insights is integrated with views, Application Insights<a id="_idIndexMarker1293"/> helps us with powerful insights into how people are using an application. The <strong class="bold">Users</strong> blade under the <strong class="bold">Usage</strong> section of Application Insights provides details about the number of users using the application. The user is identified by using anonymous IDs stored in browser cookies. Please note that a single person using different browsers and machines is counted as more than one user. The <strong class="bold">Sessions</strong> and <strong class="bold">Events</strong> blades represent the sessions of user activity and how often certain pages or features are used respectively. You can also generate reports on users, sessions, and events based on custom events, which you learned about in <a href="B18507_07_Epub.xhtml#_idTextAnchor596"><em class="italic">Chapter 7</em></a>, <em class="italic">Logging in .NET 6</em>.</p>
			<p>Another interesting tool available under usage analysis is <strong class="bold">User Flows</strong>. The <strong class="bold">User Flows</strong> tool visualizes how users navigate through different pages and features of an application. User flows provide the events that happened before and after the given event during the user session. <em class="italic">Figure 14.7</em> shows the user flows at a given time. This tells us that from the home page, users are mainly navigating to the <strong class="bold">Product Details</strong> page or th<a id="_idTextAnchor1732"/>e <strong class="bold">Account Sign In</strong> page:</p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/Figure_14.7_B18507.jpg" alt="Figure 14.7 – User flow in our Ecommerce application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.7 – User flow in our Ecommerce application</p>
			<p>Let's add a couple of custom events and see what the user flow is like against those custom events. Add one custom event, as shown in the following code snippet, in the <strong class="source-inline">Create</strong> action method of <strong class="source-inline">OrderController</strong> in the <strong class="source-inline">Packt.Ecommerce.Web</strong> application. This will track a custom event when the user clicks on the <strong class="bold">Place Order</strong> button on the <strong class="bold">Cart</strong> page:</p>
			<pre class="source-code">this.telemetry.TrackEvent("Create Or<a id="_idTextAnchor1733"/>der");</pre>
			<p>Similarly, let's add a custom event<a id="_idTextAnchor1734"/> tracking when the user clicks on the <strong class="bold">Add to Cart</strong> button on the <strong class="bold">Product Details</strong> page. To do this, add the following code snippet:</p>
			<pre class="source-code">this.telemetry.TrackEvent("Add Item To Cart");</pre>
			<p>After <a id="_idIndexMarker1294"/>adding the custom events, the user flow will show the different activities of the application with respect to these<a id="_idIndexMarker1295"/> events. User Flows is a handy tool to know how many users are navigating away from a page and what they click on a page. Please refer to the Azure Application Insights documentation provided in the <em class="italic">Further reading</em> section at the end of the chapter to learn more about the other interesting offerings for usage analysis, including cohorts, funnels, and retention.</p>
			<p>When there are enough telemetry events, you can use an Application Insights feature called <strong class="bold">Smart Detection</strong>, which automatically detects anomalies in the system and alerts us to them. In the next section, we will lea<a id="_idTextAnchor1735"/><a id="_idTextAnchor1736"/>rn about Smart Detection.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor1737"/>Smart Detection</h2>
			<p>Smar<a id="_idTextAnchor1738"/>t Detection<a id="_idIndexMarker1296"/> does not need<a id="_idIndexMarker1297"/> any configuration or code changes. It works on the telemetry data captured from the system. Alerts will be displayed under the <strong class="bold">Smart Detection</strong> blade in the system and these alerts will go to users with the <strong class="bold">Monitoring Reader</strong> and <strong class="bold">Monitoring Contributor</strong> roles. We can configure additional recipients for these alerts under the <strong class="bold">Settings</strong> option. Some of the Smart Detection rules include <strong class="bold">Slow page load time</strong>, <strong class="bold">Slow server response time</strong>, <strong class="bold">Abnormal raise in daily data volume</strong>, and <strong class="bold">Degradation in dependency volume</strong>.</p>
			<p>One of the important aspects we need to monitor for an application is availability. In the next section, we will learn how to leverage Application Insights to monito<a id="_idTextAnchor1739"/><a id="_idTextAnchor1740"/>r application availability.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor1741"/>Application availability</h2>
			<p>In <a id="_idIndexMarker1298"/><a id="_idTextAnchor1742"/>Application Insights, we <a id="_idIndexMarker1299"/>can set up availability tests for any <strong class="source-inline">http</strong> or <strong class="source-inline">https</strong> endpoints accessible from the internet. This does not require any changes to our application code. We can configure the health check endpoint at <strong class="source-inline">(&lt;App Root URL&gt;/health)</strong> for an availability test.</p>
			<p>To configure <a id="_idIndexMarker1300"/>an <a id="_idIndexMarker1301"/>availability test, go to the Application Insights resource in the Azure portal and perform the following steps:</p>
			<ol>
				<li value="1">Select <strong class="bold">Availability</strong> under the <strong class="bold">In<a id="_idTextAnchor1743"/>vestigate</strong> menu, as shown here:</li>
			</ol>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/Figure_14.8_B18507.jpg" alt="Figure 14.8 – Application Insights' Availability section&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.8 – Application Insigh<a id="_idTextAnchor1744"/>ts' Availability section</p>
			<ol>
				<li value="2">Click on <strong class="bold">Add test</strong> to add an availability test, as highlighted in the preceding screenshot.</li>
				<li>In the <strong class="bold">Create Test</strong> dialog, specify the name for the test (say, <strong class="source-inline">Commerce availability test</strong>), select <strong class="bold">URL Ping Test</strong> for <strong class="bold">Test Type</strong>, and in the <strong class="bold">URL</strong> field, enter the health check URL as <strong class="source-inline">&lt;&lt;App root url&gt;&gt;/health</strong>. Leave the other options at their default values and click on <strong class="bold">Create</strong>.</li>
				<li>Once the test is configured, Application Insights will call the configured URL every 5 minutes from all the configured regions. We can see the availabi<a id="_idTextAnchor1745"/>lity test results as follows:</li>
			</ol>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/Figure_14.9_B18507.jpg" alt="Figure 14.9 – Availability test results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.9 – Availabi<a id="_idTextAnchor1746"/>lity test results</p>
			<ol>
				<li value="5">The<a id="_idIndexMarker1302"/> default<a id="_idIndexMarker1303"/> regions selected while creating the tests were <strong class="bold">Brazil South</strong>, <strong class="bold">East Asia</strong>, <strong class="bold">Japan East</strong>, <strong class="bold">Southeast Asia</strong>, and <strong class="bold">UK South</strong>. We can add or remove any of the regions on which the availability test will be run. It is recommended to configure at least five regions.</li>
				<li>If we want to add a new region at a later point in time, we can edit the availability test and select the new region (for example, <strong class="bold">West Europe</strong>) as shown in the following scre<a id="_idTextAnchor1747"/>enshot and then click on <strong class="bold">Save</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/Figure_14.10_B18507.jpg" alt="Figure 14.10 – Editing availability test regions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.10 – Editing availability test<a id="_idTextAnchor1748"/> regions</p>
			<p>We can also <a id="_idIndexMarker1304"/>configure<a id="_idIndexMarker1305"/> a multi-step web test as an availability test in Application Insights.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can use the<a id="_idIndexMarker1306"/> following documentation to help you configure a multi-step web test: <a href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/availability-multistep">https://docs.microsoft.com/en-us/azure/azure-monitor/app/availability-multistep</a>.</p>
			<p>Application Insights provides a very good tool to query the telemetry events captured. In the next section, we will learn about the <strong class="bold">Search<a id="_idTextAnchor1749"/><a id="_idTextAnchor1750"/></strong> feature in Application Insights.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor1751"/>Search</h2>
			<p><a id="_idTextAnchor1752"/>The <strong class="bold">Search</strong> feature in <a id="_idIndexMarker1307"/>Application Insights <a id="_idIndexMarker1308"/>helps to explore telemetry events such as requests, page views, and exceptions. We can also query the traces that we have coded in the <a id="_idIndexMarker1309"/>application. <strong class="bold">Search</strong> can be opened from the <strong class="bold">Overview</strong> tab or from the <strong class="bold">Se<a id="_idTextAnchor1753"/>arch</strong> option of the <strong class="bold">Investigate</strong> tab:</p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/Figure_14.11_B18507.jpg" alt="Figure 14.11 – Search results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.11 – Search results</p>
			<p>With the <strong class="bold">Transaction Search</strong> feature, we can filter the telemetry events displayed based on time and <strong class="bold">Event Type</strong>.</p>
			<p>We can also filter<a id="_idIndexMarker1310"/> on their properties. By clicking on a specific event, we can view all the properties of the event along with the telemetry of the event. To view the requests with status code <strong class="bold">500</strong>, filter the events bas<a id="_idTextAnchor1754"/>ed on the response code as follows:</p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/Figure_14.12_B18507.jpg" alt="Figure 14.12 – Filtering search results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.12 – Filtering search results</p>
			<p>Once we apply the filter, in the search results, we will only see requ<a id="_idTextAnchor1755"/>ests with the response code 500, as <a id="_idTextAnchor1756"/>shown in the following screenshot:</p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/Figure_14.13_B18507.jpg" alt="Figure 14.13 – Filtered search results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.13 – Filtered search results</p>
			<p>To know <a id="_idIndexMarker1311"/>more about what caused<a id="_idIndexMarker1312"/> the failure, click on the event. Clicking on the event will show the details of the related telemetry, as<a id="_idTextAnchor1757"/> shown in the following screenshot:</p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/Figure_14.14_B18507.jpg" alt="Figure 14.14 – End-to-end transaction details&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.14 – End-to-end transac<a id="_idTextAnchor1758"/>tion details</p>
			<p>We can even drill down more by clicking on the exception. This will show details such as the method name and the stack trace, which will help us identify the cause of the failure.</p>
			<p>With Application Insights, we can write custom queries on the telemetry data that was captured to get more meaningful insights. In the next section, w<a id="_idTextAnchor1759"/><a id="_idTextAnchor1760"/>e will learn about writing qu<a id="_idTextAnchor1761"/>eries.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor1762"/>Logs</h2>
			<p>To write<a id="_idIndexMarker1313"/> queries on the telemetry data that is captured, let's navigate to it as follows:</p>
			<ol>
				<li value="1">Go to <strong class="bold">Application Insights</strong> | <strong class="bold">Monitoring</strong> | <strong class="bold">Logs</strong>. This will show the <strong class="bold">Logs</strong> page w<a id="_idTextAnchor1763"/>ith sample queries that we can run:</li>
			</ol>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/Figure_14.15_B18507.jpg" alt="Figure 14.15 – Application Insights logs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.15 – Application Insights logs</p>
			<ol>
				<li value="2">Select <strong class="bold">Request count trend</strong> in the suggested sample queries. This will generate <a id="_idIndexMarker1314"/>a quer<a id="_idTextAnchor1764"/>y for us and run it. Once the run is complete, we will see the results and the chart populated, as<a id="_idTextAnchor1765"/> shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/Figure_14.16_B18507.jpg" alt="Figure 14.16 – Log search results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.16 – Log search results</p>
			<p>The telemetry that is captured in Application Insights goes into different tables covering requests, exceptions, dependencies, traces, and page views. The query generated here summarizes the telemetry data from the request table and renders a time chart where the time axis is split by 3<a id="_idTextAnchor1766"/>0 minutes.</p>
			<p>We select<a id="_idIndexMarker1315"/> the time range as per our requirements. We can even specify the time range in the query rather than selecting from the menu options. These queries created here can be saved and rerun at a later time. There is also an option to configure alerts here, which we learned about in <a href="B18507_07_Epub.xhtml#_idTextAnchor596"><em class="italic">Chapter 7</em></a>, <em class="italic">Logging in .NET 6</em>. The language used here to write the queries is Kusto.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><a id="_idTextAnchor1767"/>Refer to the following documentation<a id="_idIndexMarker1316"/> to learn about Kusto Query Language: <a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/concepts/">https://docs.microsoft.com/en-us/azure/data-explorer/kusto/concepts/</a>.</p>
			<p>Kusto is based <a id="_idIndexMarker1317"/>on relational database constructs. With Kusto Query Language, we can write complex analytical queries. Kusto supports group-by aggregation, computed columns, and join functions.</p>
			<p>Let's take another example, where we want to identify the 95th percentile service response time for each client city. The query for this will be written as follows:</p>
			<pre class="source-code">requests</pre>
			<pre class="source-code">| summarize 95percentile=percentile(duration, 0.95) by client_City</pre>
			<pre class="source-code">| render barchart</pre>
			<p>In the preceding query, we are using the <strong class="source-inline">percentile</strong> functi<a id="_idTextAnchor1768"/>on to identify the 95th percentile and summarize it per region. The results are rendered as a bar chart.</p>
			<p>For the precedi<a id="_idTextAnchor1769"/>ng query, we see the following graph:</p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/Figure_14.17_B18507.jpg" alt="Figure 14.17 – Kusto percentile summary results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.17 – Kusto percentile summary results</p>
			<p>From the rendered graph, we can infer that the response time for a request coming from <strong class="bold">Chennai</strong> is faster than for requests from <strong class="bold">Secunderabad</strong>.</p>
			<p>Now, let's find <a id="_idIndexMarker1318"/>any exceptions that caused a request failure and summarize them by request and exception type. To get the result for this, we will join the <strong class="source-inline">requests</strong> table with <strong class="source-inline">exceptions</strong> and summarize them based on request name and exception type, as shown in the following query:</p>
			<pre class="source-code">requests</pre>
			<pre class="source-code">| join kind= inner (</pre>
			<pre class="source-code">exceptions</pre>
			<pre class="source-code">) on operation_Id</pre>
			<pre class="source-code">| project requestName = name, exceptionType = type</pre>
			<pre class="source-code">| summarize count=sum(1)  by requestName, exceptionType</pre>
			<p>If we run the query, we get the results summarized by the name of the request and the type of the exception, <a id="_idTextAnchor1770"/>as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/Figure_14.18_B18507.jpg" alt="Figure 14.18 – Kusto failing request exception&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.18 – Kusto failing request exception</p>
			<p>Search is a powerful feature of Application Insights to diagnose and fix failures in a production site. It is recommended to click through the different features of Application Insights and explore them.</p>
			<p>When you create<a id="_idIndexMarker1319"/> an Application Insights resource, a <strong class="bold">Log Analytics workspace</strong> will be created that persists the telemetry captured through Application Insights. Using <strong class="bold">Log Analytics</strong> workspaces along with application metrics, we can also query and monitor the key metrics related to Azure resources such as RU/s consumed in Cosmos DB. All the queries we ran in this section were executed on the <strong class="bold">Log Analytics</strong> workspace. We can create a dashboard in the Azure portal and pin all the charts related to the key metrics we wanted to track for the application. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to the Azure documentation to learn more about Log Analytics: <a href="https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-overview">https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-overview</a>. </p>
			<p>In this section, we learned how to monitor the application deployed in Azure using Azure Monitor. To analyze and troubleshoot any production failures better, we might want to know the state of an application when a specific error occurred. In the next section, we will learn how the <strong class="bold">Snapshot Debugger</strong> feature of Applicatio<a id="_idTextAnchor1771"/><a id="_idTextAnchor1772"/>n Insights enables us to achieve this.</p>
			<h1 id="_idParaDest-276">Configuring the Snapshot D<a id="_idTextAnchor1773"/>ebugger</h1>
			<p>The Snapshot Debugger <a id="_idIndexMarker1320"/>monitors the exception telemetry of our application. It automatically collects snapshots of the top exceptions that occurred in the application with the current state of the source code and variables.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Snapshot Debugger feature is only available in the Enterprise version of Visual Studio.</p>
			<p>Let's now go ahead <a id="_idIndexMarker1321"/>and configure the Snapshot Debugger for our <strong class="source-inline">Ecommerce</strong> application:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">Microsoft.ApplicationInsights.SnapshotCollector</strong> NuGet package to the <strong class="source-inline">Packt.Ecommerce.Web</strong> project.</li>
				<li>Add the following <strong class="source-inline">using</strong> statement to <strong class="source-inline">Startup.cs</strong>:<p class="source-code">using Microsoft.ApplicationInsights.SnapshotCollector;</p></li>
				<li>Add a Snapshot Collector to your services by adding the following line to the <strong class="source-inline">ConfigureServices</strong> method:<p class="source-code">services.AddApplicationInsightsTelemetry(this.Configuration["ApplicationInsights:InstrumentationKey"]);</p><p class="source-code"><strong class="bold">builder.Services.AddSnapshotCollector((configuration) =&gt; this.Configuration.Bind(nameof(SnapshotCollectorConfig<a id="_idTextAnchor1774"/>uration), configuration));</strong></p></li>
				<li>To simulate a failure, add the following code to the <strong class="source-inline">GetProductsAsync</strong> method of the <strong class="source-inline">EcommerceService</strong> class. This code will throw an error if there are any products available:<p class="source-code">public async Task&lt;IEnumerable&lt;ProductListViewModel&gt;&gt; GetProductsAsync(string filterCriteria = null)</p><p class="source-code">{        </p><p class="source-code">            // Code removed for brevity</p><p class="source-code"><strong class="bold">            if (products.Any())</strong></p><p class="source-code"><strong class="bold">            {</strong></p><p class="source-code"><strong class="bold">                throw new InvalidOperationException();</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code"><strong class="bold">            return products;</strong></p><p class="source-code">}</p></li>
				<li>Now, let's go ahead and run the application. We see an error on the home page. Refresh the page again, as the debugging snapshot is fo<a id="_idTextAnchor1775"/>r errors that occur at least twice.</li>
				<li>Now, open<a id="_idIndexMarker1322"/> the <strong class="bold">Search</strong> tab in Application Insigh<a id="_idTextAnchor1776"/>ts. Filter by the <strong class="bold">Exception</strong> event types:</li>
			</ol>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/Figure_14.19_B18507.jpg" alt="Figure 14.19 – Exceptions telemetry&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.19 – Exceptions telemetry</p>
			<ol>
				<li value="7">Click on the exception to go to the details page. On the details page, we see that the debug snapshot has been created for the exception, as h<a id="_idTextAnchor1777"/>ighlighted in the following screenshot<a id="_idTextAnchor1778"/>:</li>
			</ol>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="image/Figure_14.20_B18507.jpg" alt="Figure 14.20 – Debug snapshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.20 – Debug snapshot</p>
			<ol>
				<li value="8">Click on<a id="_idIndexMarker1323"/> the <strong class="bold">Debug Snapshot</strong> icon. This w<a id="_idTextAnchor1779"/>ill take us to the <strong class="bold">Debug Snapshot</strong> page:</li>
			</ol>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/Figure_14.21_B18507.jpg" alt="Figure 14.21 – Debug Snapshot window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.21 – Debug Snapshot window</p>
			<ol>
				<li value="9">To view the debug snapshots, the <strong class="bold">Application Insights Snapshot Debugger Role</strong> is required. As the debug state might have sensitive information, this role is not added by default. Click on the <strong class="bold">Add Application Insights Snapshot Debugger Role</strong> button. This will add the role to the currently logged-in user.</li>
				<li>Once the <a id="_idIndexMarker1324"/>role addition is complete, we can then <a id="_idTextAnchor1780"/>see the debug snapshot details populated on the page, along <a id="_idTextAnchor1781"/>with a button to download the snapshot:</li>
			</ol>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/Figure_14.22_B18507.jpg" alt="Figure 14.22 – Download debug snapshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.22 – Download debug snapshot</p>
			<ol>
				<li value="11">Click on the <strong class="bold">Download Snapshot</strong> button. The extension of the downloaded debug snapshot file is <strong class="source-inline">diagsession</strong>. Open the downloa<a id="_idTextAnchor1782"/>ded <strong class="source-inline">diagsession</strong> file in Visual Studio:</li>
			</ol>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/Figure_14.23_B18507.jpg" alt="Figure 14.23 – Debug snapshot view in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.23 – Debug snapshot view in Visual Studio</p>
			<ol>
				<li value="12">Now, click on <strong class="bold">Debug with Managed Only</strong> to start the debug session. Once<a id="_idTextAnchor1783"/> the debug <a id="_idIndexMarker1325"/>session is open, we see the exception is broken at the line whe<a id="_idTextAnchor1784"/>re we throw <strong class="source-inline">InvalidOperationException</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/Figure_14.24_B18507.jpg" alt="Figure 14.24 – Debugging snapshot in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.24 – Debugging snapshot in Visual Studio</p>
			<p>In this debug session, we may add a watch to the local variables and class variables to understand the state they are in, which will aid in debugging.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to the following documentation to under<a id="_idTextAnchor1785"/>stand more about the Snapshot Debugger <a id="_idIndexMarker1326"/>configurations: <a href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm">https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm</a>.</p>
			<p>As the application <a id="_idIndexMarker1327"/>grows and is integrated with multiple other services, it will be challenging to troubleshoot and debug those issues that occur in production environments. In some cases, it is not possible to reproduce them in the pre-production environment. With the telemetry that we capture and the tools avai<a id="_idTextAnchor1786"/>lable with Application Insights, we will be able to analyze the problem and address the issue. The Snapshot Debugger is a powerful tool to troubleshoot critical issues. Application Insights collects telemetry data and sends it in batches via a background process. The impact of using Application Insights on our application is small.</p>
			<p>There might be instances where we want to debug a live application. With Visual Studio, we are able to attach a debugger to a remotely running application to debug it. In the next sec<a id="_idTextAnchor1787"/><a id="_idTextAnchor1788"/>tion, we will learn how to achieve this.</p>
			<h1 id="_idParaDest-277">Performing remote <a id="_idTextAnchor1789"/>debugging</h1>
			<p>In this section, we<a id="_idIndexMarker1328"/> will learn how to attach a debugger to our deployed application in Azure App Service. Debugging a remote application is easy with the tooling provided by Visual Studio. Deploying an application in Azure App Service is covered in <a href="B18507_16_Epub.xhtml#_idTextAnchor1932"><em class="italic">Chapter 16</em></a>, <em class="italic">Deploying the Application in Azure</em>. We can attach a debugger to an already-deployed service by performing the following:</p>
			<ol>
				<li value="1">Launch the <strong class="bold">Publish</strong> window by right-clicking on the <strong class="bold">Packt.Ecommerce.Web</strong> project and select <strong class="bold">Publish</strong> from the context menu. You can also launch the <strong class="bold">Publish</strong> window by setting the <strong class="bold">Build</strong> | Publish <strong class="bold">Packt.Ecommerce.Web</strong> menu item.</li>
				<li>Create a <strong class="bold">Publish</strong> profile to <strong class="bold">Packt.Ecommerce.Web</strong> by selecting the Azure App Service resource in the Publish Wizard.</li>
				<li>Once the <strong class="bold">Publish</strong> profile is created, you can attach the debugger to the application instance running in Azure App Service by selecting <strong class="bold">Attach Debugger</strong> from the <strong class="bold">Hosting</strong> option<a id="_idTextAnchor1790"/>s, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/Figure_14.25_B18507.jpg" alt="Figure 14.25 – Visual Studio's Publish window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.25 – Visual Studio's Publish window</p>
			<ol>
				<li value="4">Once the<a id="_idIndexMarker1329"/> debugger is attached, the application will be opened in the browser from Azure App Service. We can add breakpoints in Visual Studio and debug the application as we would in a local development environment. To debug effectively, we need the debug version of the application deployed to Azure App Service.</li>
			</ol>
			<p>Though this is a powerful <a id="_idIndexMarker1330"/>feature for debugging remotely deployed appl<a id="_idTextAnchor1791"/>ications, we should be extra cautious when attaching the debugger to the production instance, as we will be seeing live customer data. We can attach the debugger to the staging slot of Azure App Service to debug and fix the issue, and from there, swap the staging slot to promote the fix to production. There are many more important features in Application Insights and Azure Monitor that are not covered in this chapter. It is strongly recommended to explor<a id="_idTextAnchor1792"/><a id="_idTextAnchor1793"/>e them further in the Azure documentation.</p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor1794"/>Summary</h1>
			<p>This chapter introduced you to the concepts of health checks and diagnosing problems with applications using Application Insights. We have learned how to build a health check API and add a health check module to our <strong class="source-inline">Ecommerce</strong> application, which will help us monitor the health of an application. This chapter also covered some of the key features of Azure Application Insights, which is a powerful tool to capture telemetry and diagnose problems.</p>
			<p>We have learned how Application Insights detects anomalies and alerts with the Smart Detection feature. We have also learned about snapshots and remote debugging, which help to troubleshoot problems in live applications running in production environments.</p>
			<p>In the next chapter, we are going to learn about different testing methodologies to ensure the quality of an appl<a id="_idTextAnchor1795"/><a id="_idTextAnchor1796"/>ication before deploying it to production.</p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor1797"/>Questions</h1>
			<p>After reading this chapter, we should be able to answer the following questions:</p>
			<ol>
				<li value="1">Periodic monitoring of the application is not that important for an application once it is deployed to production. True or false?</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="2">What is the interface that a custom health check module should implement?</li>
			</ol>
			<p>a. <strong class="source-inline">IHealth</strong></p>
			<p>b. <strong class="source-inline">IApplicationBuilder</strong></p>
			<p>c.<strong class="source-inline">IHealthCheck</strong></p>
			<p>d. <strong class="source-inline">IWebHostEnvironment</strong></p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="3">What is the latency in displaying Live Metrics data in Application Insights?</li>
			</ol>
			<p>a. 1 minute</p>
			<p>b. 1 second</p>
			<p>c. 10 seconds</p>
			<p>d. 5 seconds</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="4">What is the query language used to write queries in Application Insights logs?</li>
			</ol>
			<p>a. S<a id="_idTextAnchor1798"/><a id="_idTextAnchor1799"/>QL</p>
			<p>b. C#</p>
			<p>c. JavaScript</p>
			<p>d. Kusto</p>
			<p><strong class="bold">Answer: d</strong></p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor1800"/>Further reading</h1>
			<ul>
				<li>Azure Application Insights documentation: <a href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview">https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview</a></li>
			</ul>
		</div>
	</body></html>