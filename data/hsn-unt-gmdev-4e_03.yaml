- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Crafting Scenes and Game Elements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作场景和游戏元素
- en: In this chapter, we will develop some base knowledge of Unity in order to edit
    a project, and we will learn how to use several Unity Editor windows to manipulate
    our first scene and its objects. We will also learn how an object, or GameObject,
    is created and composed and how to manage complex scenes with multiple objects,
    using Hierarchies and Prefabs. Finally, we will review how we can properly save
    all our work to continue working on it later.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一些Unity的基础知识，以便编辑项目，我们将学习如何使用几个Unity编辑器窗口来操作我们的第一个场景及其对象。我们还将学习如何创建和组成对象或GameObject，以及如何使用层次结构和预制件来管理复杂场景。最后，我们将回顾如何正确保存所有工作以便稍后继续工作。
- en: 'Specifically, we will examine the following concepts in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将考察以下概念：
- en: Manipulating scenes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作场景
- en: GameObjects and components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameObjects和组件
- en: Understanding object Hierarchies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象层次结构
- en: Managing GameObjects using Prefabs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预制件管理GameObject
- en: Saving scenes and projects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存场景和项目
- en: Manipulating scenes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作场景
- en: 'A **scene** is one of the several types of files (also known as **assets**)
    in our project. Other types of files include scripts for code, audio files, 3D
    models, and textures, among others. A “scene” can be used for different things
    according to the type of project, but the most common use case is to separate
    your game into whole sections, with the most common ones being the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**是我们项目中几种类型的文件之一（也称为**资产**）。其他类型的文件包括代码脚本、音频文件、3D模型和纹理等。根据项目类型，“场景”可以用于不同的事情，但最常见的用例是将你的游戏分成整个部分，最常见的包括以下内容：'
- en: The main menu
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主菜单
- en: Level 1, Level 2, Level 3, etc.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1关，第2关，第3关等等。
- en: A victory screen and a lose screen
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜利屏幕和失败屏幕
- en: A splash screen and a loading screen
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动屏幕和加载屏幕
- en: 'In this section, we will cover the following concepts related to scenes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与场景相关的以下概念：
- en: The purpose of a scene
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景的目的
- en: The **Scene** view
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**视图'
- en: Adding our first GameObject to a scene
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的第一个GameObject添加到场景中
- en: Navigating the Scene view
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航场景视图
- en: Manipulating GameObjects
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作GameObject
- en: So, let’s take a look at each of these concepts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看这些概念中的每一个。
- en: The purpose of a scene
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景的目的
- en: The idea of separating your game into scenes is so that Unity can process and
    load just the data needed for the scene. Let’s say you are in the main menu; in
    such a case, you will have only the textures, music, and objects that the main
    menu needs to be loaded in **random-access memory** (**RAM**), the device’s main
    memory. In that case, there’s no need for your game to have loaded the Level 10
    boss if you don’t need it right now. That’s why loading screens exist, just to
    fill the time between unloading the assets needed in one scene and loading the
    assets needed in another. Maybe you are thinking that open-world games such as
    *Grand Theft Auto* don’t have loading screens while you roam around in the world,
    but they are actually loading and unloading chunks of the world in the background
    as you move, and those chunks are different scenes that are designed to be connected
    to each other.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的游戏分成场景的想法是让Unity只处理和加载场景所需的数据。比如说你在主菜单；在这种情况下，你将只有主菜单需要的纹理、音乐和对象被加载到**随机存取存储器**（**RAM**），即设备的主要内存。在这种情况下，如果你的游戏不需要加载第10关的Boss，就没有必要加载它。这就是为什么有加载屏幕，只是为了填补在卸载一个场景所需的资产和加载另一个场景所需的资产之间的时间。也许你正在想，像*侠盗猎车手*这样的开放世界游戏在你四处游荡时没有加载屏幕，但实际上它们在移动时会在后台加载和卸载世界的一部分，这些部分是设计成可以相互连接的不同场景。
- en: The difference between the main menu and a regular level scene is the objects
    (also known as **GameObjects** in Unity lingo) they have. In a menu, you will
    find objects such as backgrounds, music, buttons, and logos, and in a level, you
    will have the player, enemies, platforms, health boxes, and so on. So, the meaning
    of your scene depends on what GameObjects are put into it. But how can we create
    a scene? Let’s start with the Scene view.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单和常规关卡场景之间的区别在于它们拥有的对象（在Unity术语中也称为**GameObject**）。在菜单中，你会找到背景、音乐、按钮和标志等对象，而在关卡中，你将拥有玩家、敌人、平台、生命值盒子等等。因此，你的场景意义取决于放入其中的GameObject。但我们是怎样创建场景的呢？让我们从场景视图开始。
- en: The Scene view
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景视图
- en: 'When you open a Unity project, you will see the Unity Editor. It will be composed
    of several **windows** or **panels**, each one helping you to change different
    aspects of your game. In this chapter, we will look at the windows that help you
    create scenes. The Unity Editor is shown in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开Unity项目时，你会看到Unity编辑器。它将由几个**窗口**或**面板**组成，每个面板都帮助你改变游戏的不同方面。在本章中，我们将查看帮助你创建场景的窗口。以下截图展示了Unity编辑器：
- en: '![](img/B21361_02_01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_01.png)'
- en: 'Figure 2.1: The Unity Editor'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：Unity编辑器
- en: 'If you have ever programmed any kind of application before, you are probably
    used to having a starting function such as `Main`, where you start writing code
    to create several objects needed for your app. If you were developing a game,
    you would probably create all the objects for the scene there. The problem with
    this approach is that in order to ensure all objects are created properly, you
    will need to run the program to see the results, and if something is misplaced,
    you will need to manually change the coordinates of the object, which is a slow
    and painful process. Luckily, in Unity, we have the Scene view, an example of
    which is shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前曾经编程过任何类型的应用程序，你可能已经习惯了有一个起始函数，比如`Main`，在那里你开始编写代码来创建应用程序所需的几个对象。如果你在开发一个游戏，你可能会在那里创建场景中所有的对象。这种方法的缺点是，为了确保所有对象都正确创建，你需要运行程序来查看结果，如果某个地方放错了，你需要手动更改对象的坐标，这是一个缓慢且痛苦的过程。幸运的是，在Unity中，我们有场景视图，以下截图展示了其一个示例：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_02_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 自动生成描述](img/B21361_02_02.png)'
- en: 'Figure 2.2: The Scene view'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：场景视图
- en: This window is an implementation of the classic **WYSIWYG** (**What You See
    Is What You Get**) concept. Here, you can create objects and place them all over
    the scene, all through a scene previsualization where you can see how the scene
    will look when players play the game. However, before learning how to use this
    scene, we need to have an object in the scene, so let’s create our first object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口是经典**WYSIWYG**（**所见即所得**）概念的实现。在这里，你可以创建对象并将它们放置在场景的任何地方，所有这些都是在场景预览中完成的，你可以看到玩家玩游戏时场景将如何看起来。然而，在我们学习如何使用这个场景之前，我们需要场景中有一个对象，所以让我们创建我们的第一个对象。
- en: Adding our first GameObject to the scene
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的第一个GameObject添加到场景中
- en: 'The project template we choose when creating the project comes with a blank
    scene ready to work with, but let’s create our own empty scene to see how to do
    it ourselves. To do that, you can simply use the **File | New Scene** menu to
    create an empty new scene, as illustrated in the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目时选择的模板项目包含一个空白场景，可以开始工作，但让我们创建我们自己的空场景来看看如何自己完成。为此，你可以简单地使用**文件 | 新场景**菜单来创建一个空的新场景，以下截图展示了这一点：
- en: '![](img/B21361_02_03.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_03.png)'
- en: 'Figure 2.3: Creating a new scene'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：创建新场景
- en: 'After clicking **New Scene**, you will see a window to pick a scene template;
    here, select the **Basic (URP)** template. A template defines which objects the
    new scene will have, and in this case, our template will come with a basic light
    and a camera, which will be useful for the scene we want to create. Once selected,
    just click the **Create** button:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**新场景**后，你会看到一个选择场景模板的窗口；在这里，选择**基本（URP）**模板。模板定义了新场景将包含哪些对象，在这种情况下，我们的模板将包含一个基本光源和一个摄像机，这对我们想要创建的场景将很有用。一旦选择，只需点击**创建**按钮：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_02_04.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 自动生成描述](img/B21361_02_04.png)'
- en: 'Figure 2.4: Selecting the scene template'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：选择场景模板
- en: 'Now that we have our empty scene, let’s add GameObjects to it. We will learn
    several ways of creating GameObjects throughout the book, but for now, let’s start
    using some basic templates Unity provides for us. In order to create them, we
    will need to open the **GameObject** menu at the top of the Unity window, and
    it will show us several template categories, such as **3D Object**, **2D Object**,
    **Effects**, and so on, as illustrated in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个空场景了，让我们向其中添加GameObject。我们将在整本书中学习创建GameObject的几种方法，但就现在，让我们先使用Unity为我们提供的几个基本模板。为了创建它们，我们需要打开Unity窗口顶部的**GameObject**菜单，它将显示几个模板类别，如**3D
    Object**、**2D Object**、**Effects**等，以下截图展示了这一点：
- en: '![](img/B21361_02_05.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_05.png)'
- en: 'Figure 2.5: Creating a cube'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：创建一个立方体
- en: Under the **3D Object** category, we will see several 3D primitives such as
    **Cube**, **Sphere**, **Cylinder**, and so on, and while using them is not as
    exciting as using beautiful, downloaded 3D models, remember that we are only prototyping
    our level at the moment. This is called **gray-boxing**, which means that we will
    use lots of prototyping primitive shapes to model our level so that we can quickly
    test it, seeing if our idea is good enough to start the complex work of converting
    it to a final version.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在**3D对象**类别下，我们将看到几个3D基本形状，如**立方体**、**球体**、**圆柱体**等，虽然使用它们不如使用漂亮的下载3D模型那么令人兴奋，但请记住，我们目前只是在原型化我们的关卡。这被称为**灰盒建模**，意味着我们将使用大量的原型基本形状来建模我们的关卡，以便我们可以快速测试它，看看我们的想法是否足够好，可以开始将其转换为最终版本的工作。
- en: I recommend you pick the **Cube** object to start because it is a versatile
    shape that can represent lots of objects. So, now that we have a scene with an
    object to edit, the first thing we need to learn to do with the Scene view is
    to navigate through the scene.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您选择**立方体**对象开始，因为它是一个多功能的形状，可以代表许多对象。所以，现在我们有一个可以编辑的场景和对象，我们需要学习使用场景视图做的第一件事就是导航场景。
- en: Navigating the Scene view
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航场景视图
- en: 'In order to manipulate a scene, we need to learn how to move through it to
    view the results from different perspectives. There are several ways to navigate
    the scene, so let’s start with the most common one, the first-person view. This
    view allows you to move through a scene using first-person-shooter-like navigation,
    using the mouse and the *WASD* keys. To navigate like this, you will need to press
    and hold the right mouse button, and while doing so, you can:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作场景，我们需要学习如何移动以从不同角度查看结果。有几种导航场景的方法，所以让我们从最常见的一种开始，即第一人称视角。这种视角允许你使用类似第一人称射击游戏的导航方式在场景中移动，使用鼠标和*WASD*键。要这样导航，你需要按住并保持右鼠标按钮，同时进行以下操作：
- en: Move the mouse to rotate the camera around its current position
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标移动到旋转相机围绕其当前位置
- en: Press the *WASD* keys to move the position of the camera, always holding the
    right click
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下*WASD*键来移动相机的位置，始终按住右键
- en: You can also press *Shift* to move faster
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您也可以按*Shift*键来加快移动速度
- en: Press the *Q* and *E* keys to move up and down
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下*Q*和*E*键来上下移动
- en: Another common way of moving is to click an object to select it (the selected
    object will have an orange outline), and then press the *F* key to focus on it,
    making the Scene view camera immediately move to a position where we can look
    at that object more closely.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的移动方式是点击一个对象来选择它（选中的对象将有一个橙色的轮廓），然后按*F*键来聚焦于它，使场景视图相机立即移动到一个可以更近距离观察该对象的位置。
- en: 'After that, we can press and hold the left *Alt* key on Windows, or *Option*
    on a Mac, along with the left mouse click, to finally start moving the mouse and
    “orbit” around the object. This will allow you to see the focused object from
    different angles to check if every part of it is properly placed, as demonstrated
    in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以在Windows上按住并保持左*Alt*键，或在Mac上按*Option*键，同时点击左鼠标，最终开始移动鼠标并在对象周围“环绕”。这将允许您从不同的角度查看焦点对象，以检查其每个部分是否都放置得当，如下面的截图所示：
- en: '![A picture containing screenshot, design  Description automatically generated](img/B21361_02_06.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图和设计的图片  描述由低置信度自动生成](img/B21361_02_06.png)'
- en: 'Figure 2.6: Selecting an object'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：选择一个对象
- en: Now that we can move freely through the scene, we can start using the Scene
    view to manipulate GameObjects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在场景中自由移动，我们可以开始使用场景视图来操作游戏对象。
- en: Manipulating GameObjects
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作游戏对象
- en: 'Another use of the Scene view is to manipulate the locations of the objects.
    In order to do so, we first need to select an object, and then press the **Transform**tool
    in the top-left corner of the Scene view. You can also press the *Y* key on the
    keyboard once an object is selected to activate the same Transform tool:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 场景视图的另一个用途是操作对象的定位。为了做到这一点，我们首先需要选择一个对象，然后按场景视图左上角的**变换**工具。一旦选择了对象，您也可以按键盘上的*Y*键来激活相同的变换工具：
- en: '![A close-up of a sign  Description automatically generated with low confidence](img/B21361_02_07.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![一个标志的特写  描述由低置信度自动生成](img/B21361_02_07.png)'
- en: 'Figure 2.7: The transformation tool'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：变换工具
- en: 'This will show what is called the **Transform**Gizmo over the selected object.
    A **gizmo** is a visual tool overlaid on top of the selected object, used to modify
    different aspects of it. In the case of the **Transform Gizmo**, it allows us
    to change the position, rotation, and scale of the object, as illustrated in *Figure
    2.8*. Don’t worry if you don’t see the cube-shaped arrows outside the sphere—we
    will enable them in a moment:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所选对象上所谓的**变换工具**。**工具**是一种叠加在所选对象之上的视觉工具，用于修改其不同方面。在**变换工具**的情况下，它允许我们改变对象的位置、旋转和缩放，如图*图2.8*所示。如果你没有看到球体外的立方形箭头，请不要担心——我们很快就会启用它们：
- en: '![A picture containing screenshot, circle, art  Description automatically generated](img/B21361_02_08.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、圆形、艺术描述自动生成的图片](img/B21361_02_08.png)'
- en: 'Figure 2.8: The Transform Gizmo'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：变换工具
- en: 'Let’s start translating the object, which is accomplished by dragging the red,
    green, and blue arrows inside the gizmo’s sphere. While you do this, the object
    will move along the selected axis. An interesting concept to explore here is the
    meaning of the colors of these arrows. If you pay attention to the top-right area
    of the Scene view, you will see an axis Gizmo that serves as a reminder of those
    colors’ meaning, as illustrated in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始移动对象，这是通过在工具的球体内拖动红色、绿色和蓝色箭头来实现的。当你这样做的时候，对象将沿着所选轴移动。这里一个有趣的概念是探索这些箭头颜色的含义。如果你注意观察场景视图的右上角，你会看到一个轴工具，它作为这些颜色含义的提醒，如图下所示：
- en: '![A picture containing screenshot, design  Description automatically generated](img/B21361_02_09.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、设计描述自动生成的图片](img/B21361_02_09.png)'
- en: 'Figure 2.9: The axis Gizmo'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：轴工具
- en: Computer graphics use the classic 3D **Cartesian coordinate system** to represent
    objects’ locations. The red color is associated with the *x* axis of the object,
    green with the *y* axis, and blue with the *z* axis.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机图形学使用经典的3D**笛卡尔坐标系**来表示对象的定位。红色与对象的*x*轴相关联，绿色与*y*轴相关联，蓝色与*z*轴相关联。
- en: But what does each axis mean? If you are used to another 3D authoring program
    like Maya, Blender, or 3DS Max, this can be different, but in Unity, the *z* axis
    represents the **forward vector**, which means that the arrow points along the
    front of the object; the *x* axis is the **right vector**, and the *y* axis represents
    the **up vector**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但每个轴代表什么？如果你习惯于使用像Maya、Blender或3DS Max这样的其他3D制作程序，这可能会不同，但在Unity中，*z*轴代表**前向向量**，这意味着箭头指向对象的前面；*x*轴是**右向向量**，而*y*轴代表**向上向量**。
- en: These directions are known as **local** coordinates, and that’s because every
    object can be rotated differently, meaning each object can point its forward,
    up, and right vectors elsewhere according to its orientation. The local coordinates
    will make more sense when used later in the *Understanding object hierarchies*
    section of the chapter, so bear with me on that, but it’s worth discussing **global**coordinates
    now. The idea is to have a single origin point (the zero point) with a single
    set of forward, right, and up axes that are common across the scene. This way,
    when we say an object has a global position of `5`,`0`,`0`, we know that we are
    referring to a position 5 meters along the global *x*-axis, starting from the
    global zero position. The global axes are the ones you see in the top-right axis
    gizmos previously mentioned.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方向被称为**局部**坐标，这是因为每个对象都可以以不同的方式旋转，这意味着每个对象都可以根据其方向将其前向、向上和向右的向量指向其他地方。当在章节的*理解对象层次结构*部分稍后使用时，局部坐标将更有意义，所以请耐心等待，但现在讨论**全局**坐标是值得的。想法是有一个单一的起点（零点）和一组共同的向前、向右和向上轴，这些轴在场景中是通用的。这样，当我们说一个对象的全局位置是`5`,`0`,`0`时，我们知道我们指的是从全局零位置开始沿全局*x*轴延伸5米的坐标。全局轴是你在之前提到的右上角轴工具中看到的那些。
- en: We just mentioned that a position (`5`,`0`,`0`) would mean 5 meters along the
    *x*-axis, which implies that the Unity unit system is the meter. While several
    Unity systems like Physics and Audio follow this assumption (1 unit = 1 meter),
    it is not necessarily the mandatory unit system. There are several ways to change
    this and scale the world for convenience, but given that it is only necessary
    in specific scenarios, in this book, we will stick to the meter measuring system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才提到，位置(`5`,`0`,`0`)意味着*x*轴上5米，这暗示Unity单位系统是米。虽然Unity的几个系统如物理和音频遵循这个假设（1单位=1米），但这并不是强制性的单位系统。有几种方法可以改变它，为了方便缩放世界，但在本书中，我们将坚持米测量系统。
- en: 'In order to be sure that we work with local coordinates, meaning we will move
    the object along its local axes, make sure the **Local** mode is activated in
    the Scene view, as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们使用局部坐标，即我们将沿着对象的局部轴移动对象，请确保在场景视图中激活了**局部**模式，如下面的屏幕截图所示：
- en: '![A screenshot of a phone  Description automatically generated with medium
    confidence](img/B21361_02_10.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕截图  描述由中等置信度自动生成](img/B21361_02_10.png)'
- en: 'Figure 2.10: Switching pivot and local coordinates'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：切换轴心和局部坐标
- en: If the right button says **Global** instead of **Local**, just click it and
    select **Local** from the drop-down options. By the way, try to keep the left
    button as **Pivot**. If it says **Center**, click and select **Pivot**. The pivot
    of the object is not necessarily its center, and that depends entirely on the
    3D model we use, and where the author of it specifies the object rotation center
    is located. For example, a car could have its pivot in the middle of its back
    wheels, so when we rotate, it will respect the real car’s rotation center. Editing
    based on the object’s pivot will simplify our understanding of how rotating via
    C# scripts will work later in *Chapter 6*. Also, now that we have enabled **Local**
    coordinates, you should see the cube-shaped arrows seen in *Figure 2.8*; we will
    use them in a moment to scale the cube.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果右键按钮显示的是**全局**而不是**局部**，只需点击它，然后从下拉选项中选择**局部**。顺便说一句，尽量保持左键按钮为**轴心**。如果它显示的是**中心**，点击并选择**轴心**。对象的轴心不一定是它的中心，这完全取决于我们使用的3D模型，以及作者指定对象旋转中心的位置。例如，一辆汽车可能有它的轴心在它的后轮中间，所以当我们旋转时，它将尊重真实汽车的旋转中心。基于对象的轴心进行编辑将简化我们对如何在第6章中通过C#脚本旋转对象的理解。现在，我们已经启用了**局部**坐标，你应该看到*图2.8*中看到的立方形箭头；我们将在稍后使用它们来缩放立方体。
- en: I know—we are editing a cube, so there is no clear front or right side, but
    when you work with real 3D models such as cars and characters, they will certainly
    have those sides, and they must be properly aligned with those axes. If, by any
    chance in the future, you import a car into Unity and the front of the car points
    along the *x-*axis, you will need to align that model along the *z* axis because
    the code we will create to move our object will rely on that convention.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道——我们正在编辑一个立方体，所以没有明确的前面或右面，但当你处理真实的3D模型，如汽车和角色时，它们肯定会有这些面，并且它们必须与这些轴正确对齐。如果将来你意外地将一辆汽车导入Unity，并且汽车的前面沿着*x*轴，你需要将模型沿*z*轴对齐，因为我们将要创建的用于移动对象的代码将依赖于这个约定。
- en: 'Now, let’s use this **Transform**Gizmo to rotate the object, using the three
    colored circles around it. If you click and drag, for example, the red circle,
    you will rotate the object along the *x-*axis. If you want to rotate the object
    horizontally, based on the color coding we previously discussed, you will probably
    pick the *x-*axis—the one that is used to move horizontally—but, sadly, that’s
    wrong. A good way to look at the rotation is like the accelerator of a motorcycle:
    you need to take it and roll it. If you rotate the *x-*axis like this, you will
    rotate the object up and down. So, in order to rotate horizontally, you would
    need to use the green circle or the *y* axis. The process is illustrated in the
    following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个**变换**工具来旋转对象，使用围绕它的三个彩色圆圈。例如，如果你点击并拖动红色圆圈，你将沿着*x*轴旋转对象。如果你想水平旋转对象，根据我们之前讨论的颜色编码，你可能选择*x*轴——用于水平移动的那个轴——但是，很遗憾，这是错误的。看待旋转的一个好方法是像摩托车加速器：你需要拿起它并滚动它。如果你这样旋转*x*轴，你将使对象上下旋转。所以，为了水平旋转，你需要使用绿色圆圈或*y*轴。这个过程在下面的屏幕截图中有说明：
- en: '![A picture containing screenshot, design, art  Description automatically generated](img/B21361_02_11.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、设计、艺术描述自动生成的图片](img/B21361_02_11.png)'
- en: 'Figure 2.11: Rotating an object'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：旋转对象
- en: Finally, we have scaling, and we have two ways to accomplish that, one of them
    being through the gray cube at the center of the **Transform** Gizmo shown in
    *Figure 2.8*. This allows us to change the size of the object by clicking and
    dragging that cube. Now, as we want to prototype a simple level, sometimes we
    want to stretch the cube to create, for example, a column or a flat floor, and
    here’s where the second way comes in.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有缩放，我们有两种方法可以实现这一点，其中一种是通过*图2.8*中显示的**变换**工具中心的灰色立方体。这允许我们通过点击并拖动该立方体来改变对象的大小。现在，由于我们想要原型化一个简单的关卡，有时我们想要拉伸立方体来创建，例如，一列或一个平坦的地板，这就是第二种方法出现的地方。
- en: If you click and drag the colored cubes in front of the translation arrows instead
    of the gray one in the center, you will see how our cube stretches over those
    axes, allowing you to change the shape of the object. If you don’t see those cube-shaped
    arrows, remember to enable **Local** coordinates, as stated earlier in this section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击并拖动翻译箭头前面的彩色立方体而不是中心灰色的立方体，你会看到我们的立方体如何沿着这些轴拉伸，从而允许你改变对象的形状。如果你看不到那些立方体形状的箭头，记得要启用前面在本节中提到的**局部**坐标。
- en: 'The process of stretching is illustrated in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 拉伸的过程在下面的屏幕截图中有说明：
- en: '![A picture containing screenshot, design  Description automatically generated](img/B21361_02_12.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、设计描述自动生成的图片](img/B21361_02_12.png)'
- en: 'Figure 2.12: Scaling an object'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：缩放对象
- en: Remember that you can also use the the same gray cube we had in the **Transform**
    Gizmo in the middle to scale all axes at the same time if desired. This is known
    as **uniform scaling**
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你希望的话，也可以使用中间的**变换**工具中的相同灰色立方体来同时缩放所有轴。这被称为**均匀缩放**。
- en: Finally, something to consider here is that several objects can have the same
    scale values but different sizes, given how they were originally designed. **Scale**
    is a multiplier we can apply to the original size of an object, so a building
    and a car both with scale `1` make perfect sense; the relative size of one against
    the other seems correct. The main takeaway here is that scale is not size but
    a way to multiply it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里需要考虑的是，由于它们最初的设计方式，几个对象可以具有相同的缩放值但不同的尺寸。**缩放**是我们可以应用于对象原始尺寸的一个乘数，因此一个比例`1`的建筑和一辆车都是完全合理的；它们相对于彼此的相对大小看起来是正确的。这里的主要启示是，缩放不是尺寸，而是一种乘以它的方式。
- en: Consider that scaling objects is usually a bad practice in many cases. In the
    final versions of your scene, you will use models with the proper size and scale,
    and they will be designed in a modular way so that you can plug them into each
    other. If you scale them, several bad things can happen, such as textures being
    stretched and becoming pixelated, and modules that no longer plug properly. There
    are some exceptions to this rule, such as placing lots of instances of the same
    tree in a forest and changing its scale slightly to simulate variation. Also,
    in the case of gray-boxing, it is perfectly fine to take cubes and change the
    scale to create floors, walls, ceilings, columns, and so on because, ultimately,
    those cubes will be replaced with real 3D models.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在许多情况下缩放对象通常是不良的做法。在你的场景最终版本中，你将使用适当大小和比例的模型，并且它们将以模块化的方式设计，以便你可以将它们相互连接。如果你缩放它们，可能会发生一些不好的事情，比如纹理被拉伸并变得像素化，以及不再正确连接的模块。这个规则有一些例外，比如在森林中放置许多相同树木的实例，并稍微改变其比例以模拟变化。此外，在灰色框的情况下，将立方体改变比例以创建地板、墙壁、天花板、柱子等是完全可行的，因为最终，这些立方体将被真实的3D模型所取代。
- en: 'Here’s a challenge! Create a room composed of a floor, three regular walls,
    and the fourth wall with a hole for a door (three cubes), and no need for a roof.
    In the next image, you can see how it should look:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个挑战！创建一个由地板、三面普通墙壁和带有门洞的第四面墙壁（三个立方体）组成的房间，不需要屋顶。在下一张图片中，你可以看到它应该是什么样子：
- en: '![A picture containing screenshot, design, water basin  Description automatically
    generated](img/B21361_02_13.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、设计、水盆描述自动生成的图片](img/B21361_02_13.png)'
- en: 'Figure 2.13: Room task finished'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：房间任务完成
- en: '**Memory**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**记忆**'
- en: I remember when I started making games, I did most of my scenes with just boxes.
    While we will certainly do better in this book, there are still incredibly clever
    ways to use just that simple shape. Take, for example, the game *Thomas Was Alone*,
    which uses just boxes with clever lighting effects and looks beautiful.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得当我刚开始制作游戏时，我大多数场景都是用盒子做的。虽然我们在这本书中肯定会做得更好，但仍然有非常巧妙的方法只使用这个简单的形状。以游戏*托马斯独自一人*为例，它只使用了盒子，通过巧妙的光照效果看起来很漂亮。
- en: Now that we can edit an object’s location, let’s see how we can edit all its
    other aspects.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以编辑对象的位置了，让我们看看如何编辑其所有其他方面。
- en: GameObjects and components
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameObjects和组件
- en: We talked about our project being composed of `assets` (the project’s files)
    and that a scene (which is a specific type of asset) is composed of GameObjects;
    so, how can we create an object? Through a composition of **components**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到我们的项目由`assets`（项目文件）组成，一个场景（它是一种特定的资产）由GameObject组成；那么，我们如何创建一个对象呢？通过**组件**的组合。
- en: 'In this section, we will cover the following concepts related to components:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与组件相关的以下概念：
- en: Understanding components
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解组件
- en: Manipulating components
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作组件
- en: Let’s start by discussing what a component is.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论一下组件是什么。
- en: Understanding components
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解组件
- en: A **component** is one of several pieces that make up a GameObject; each one
    is in charge of different features of the object. There are several components
    that Unity already includes that solve different tasks, such as playing a sound,
    rendering a mesh, applying physics, and so on; however, even though Unity has
    a large number of components, we will eventually need to create custom components
    sooner or later.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是构成GameObject的几个部分之一；每个组件负责对象的不同功能。Unity已经包含了一些组件，可以解决不同的任务，例如播放声音、渲染网格、应用物理效果等；然而，尽管Unity有大量的组件，我们迟早需要创建自定义组件。'
- en: 'In the next image, you can see what Unity shows us when we select a GameObject:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图片中，你可以看到当我们选择一个GameObject时Unity向我们展示的内容：
- en: '![](img/B21361_02_14.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_02_14.png)'
- en: 'Figure 2.14: The Inspector panel'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：检查器面板
- en: If we needed to guess what the **Inspector** panel in the preceding screenshot
    does right now, we could say it shows all the properties of objects selected,
    either via the **Hierarchy**, the menu where you can see all the objects that
    have already been placed within the current scene, or the Scene view, and allows
    us to configure those options to change the behavior of the object (i.e., the
    position and rotation, whether it will project shadows or not, and so on).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要猜测前面截图中的**检查器**面板现在做什么，我们可以说它显示了通过**层次结构**、你可以看到所有已经放置在当前场景中的对象的菜单，或者通过**场景视图**选择的选定对象的全部属性，并允许我们配置这些选项以改变对象的行为（即位置和旋转，是否投射阴影等）。
- en: 'That is true, but we are missing a key element: those properties don’t belong
    to the object; they belong to the components of the object. We can see some titles
    in bold before a group of properties, such as **Transform** and **Box Collider**,
    and so on. Those are the components of the object.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真的，但我们遗漏了一个关键元素：这些属性不属于对象；它们属于对象的组件。我们可以在一组属性之前看到一些加粗的标题，例如**变换**和**盒子碰撞器**等。这些都是对象的组件。
- en: In this case, our object has a **Transform**, a **Mesh Filter**, a **Mesh Renderer**,
    and a **Box Collider** component, so let’s review each one of those.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的对象有一个**变换**、一个**网格过滤器**、一个**网格渲染器**和一个**盒子碰撞器**组件，所以让我们回顾每一个。
- en: '**Transform** just holds the position, rotation, and scale of the object, and
    by itself it does nothing—it’s just a point in our game—but as we add components
    to the object, that position starts to have more meaning. That’s because some
    components will interact with **Transform** and other components, each one affecting
    the other.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换**只包含对象的位置、旋转和缩放，它本身并不做任何事情——它只是我们游戏中的一个点——但是当我们向对象添加组件时，这个位置开始具有更多的意义。这是因为一些组件将与**变换**和其他组件交互，每个组件都会影响另一个。'
- en: An example of these different components interacting with each other would be
    the case of **Mesh Filter** and **Mesh Renderer**, both of those being in charge
    of rendering a 3D model. **Mesh Renderer** will render the 3D model, also known
    as mesh, specified by the **Mesh Filter** in the position specified in the **Transform**
    component, so **Mesh Renderer** needs to get data from those other components
    and can’t work without them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同组件之间相互作用的例子可以是**网格过滤器**和**网格渲染器**的情况，这两个组件都负责渲染3D模型。**网格渲染器**将渲染由**网格过滤器**在**变换**组件中指定的位置指定的3D模型，也称为网格，因此**网格渲染器**需要从其他组件获取数据，没有它们无法工作。
- en: Another example would be the **Box Collider**. This represents the physics shape
    of the object, so when the physics calculates collisions between objects, it checks
    if that shape collides with other shapes, based on the position specified in the
    **Transform** component.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是**盒子碰撞器**。这代表对象的物理形状，因此当物理计算对象之间的碰撞时，它会检查该形状是否与指定在**变换**组件中的其他形状发生碰撞。
- en: We will explore rendering and physics later in the book, but the takeaway from
    this section is that a GameObject is a collection of components, each component
    adding a specific behavior to our object, and each one interacting with the others
    to accomplish the desired task. To further reinforce this, let’s see how we can
    convert a cube into a sphere that will fall, due to gravity applied via physics.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分探讨渲染和物理，但本节的要点是GameObject是一个组件集合，每个组件都为我们的对象添加特定的行为，并且每个组件都与其他组件交互以完成所需任务。为了进一步强化这一点，让我们看看我们如何将一个立方体转换为球体，该球体将由于物理施加的重力而落下。
- en: Manipulating components
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作组件
- en: The tool to edit an object’s components is the **Inspector**. It not only allows
    us to change the properties of our components but also lets us add and remove
    components. In this case, we want to convert a cube to a sphere, so we need to
    change several aspects of those components.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑对象组件的工具是**检查器**。它不仅允许我们更改组件的属性，还让我们可以添加和删除组件。在这种情况下，我们想要将一个立方体转换为球体，因此需要更改这些组件的几个方面。
- en: 'We can start by changing the visual shape of the object, so we need to change
    the rendered model or **mesh**. The component that specifies the mesh to be rendered
    is the **Mesh Filter** component. If we look at it in the following figure, we
    can see a **Mesh** property that says **Cube**, with a little circle and a dot
    on its right:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先从改变对象的视觉形状开始，因此我们需要更改渲染模型或**网格**。指定要渲染的网格的组件是**网格过滤器**组件。如果我们查看以下图示，我们可以看到一个名为**网格**的属性，其右侧有一个小圆圈和一个小点：
- en: '![](img/B21361_02_15.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21361_02_15.png](img/B21361_02_15.png)'
- en: 'Figure 2.15: The Mesh Filter component'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：网格过滤器组件
- en: If you don’t see a particular property, such as the **Mesh** we just mentioned,
    try to click the triangle at the left of the component’s name. Doing this will
    expand and collapse all the component’s properties.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到特定的属性，例如我们刚才提到的**网格**，请尝试点击组件名称左侧的三角形。这样做将展开和折叠所有组件属性。
- en: If we click the button with a circle and a dot inside, the one at the right
    of the **Mesh** property, the **Select Mesh** window will pop up, allowing us
    to pick several **mesh** options. In this case, select the **Sphere** mesh. In
    the future, we will add more 3D models to our project so that the window will
    have more options.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击位于**网格**属性右侧、带有圆圈和点的按钮，将弹出**选择网格**窗口，允许我们选择几个**网格**选项。在这种情况下，选择**球体**网格。在未来，我们将向我们的项目中添加更多3D模型，因此窗口将具有更多选项。
- en: 'The mesh selector is shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 网格选择器在以下屏幕截图中显示：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_02_16.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成描述](img/B21361_02_16.png)'
- en: 'Figure 2.16: The mesh selector'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：网格选择器
- en: 'Okay—the object now looks like a sphere, but will it behave like a sphere?
    Let’s find out. In order to do so, we can add a component named **Rigidbody**
    to our sphere, which will add physics to it. We will talk more about Rigidbody
    and physics later in *Chapter 7*, *Collisions and Health: Detecting Collisions
    Accurately*, but for now, let’s stick to the basics.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——现在对象看起来像一个球体，但它会像球体一样表现吗？让我们来看看。为了做到这一点，我们可以在我们的球体上添加一个名为**刚体**的组件，这将给它添加物理属性。我们将在*第7章*，*碰撞与健康：精确检测碰撞*中更多地讨论刚体和物理，但现在让我们专注于基础知识。
- en: 'To add Rigidbody to our sphere, we need to click the **Add Component** button
    at the bottom of the Inspector. It will show a **Component Selector** window with
    lots of categories; in this case, we need to click on the **Physics** category.
    The window will show all the **Physics** components, and there we can find **Rigidbody**.
    Another option would be to type `Rigidbody` in the search box at the top of the
    window. The following screenshot illustrates how to add a component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要将刚体添加到我们的球体上，我们需要在检查器的底部点击**添加组件**按钮。它将显示一个**组件选择器**窗口，其中包含许多类别；在这种情况下，我们需要点击**物理**类别。窗口将显示所有**物理**组件，在那里我们可以找到**刚体**。另一个选项是在窗口顶部的搜索框中输入`Rigidbody`。以下截图说明了如何添加组件：
- en: '![](img/B21361_02_17.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_17.png)'
- en: 'Figure 2.17: Adding components'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：添加组件
- en: 'If you hit the **Play** button in the top-middle part of the editor, you can
    test your sphere physics using the **Game** panel. That panel will be automatically
    focused when you hit **Play** and will show you how the player will see the game.
    The playback controls are shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在编辑器的顶部中间部分点击**播放**按钮，您可以使用**游戏**面板测试您的大球物理效果。当您点击**播放**时，该面板将自动聚焦，并显示玩家将如何看到游戏。播放控制按钮如图下截图所示：
- en: '![](img/B21361_02_18.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_18.png)'
- en: 'Figure 2.18: Playback controls'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：播放控制
- en: 'Here, you can just use the **Transform** Gizmo to rotate and position your
    camera in such a way that it looks at our sphere. This is important, as one problem
    that can happen is that you might not see anything during **Play** mode, which
    can happen if the game camera does not point to where our sphere is located. While
    you are moving, you can check the little preview in the bottom-right part of the
    **Scene** window to check out the new camera perspective. That is the expected
    behavior if you have selected a camera. Another alternative would be to select
    the camera in the **Hierarchy** and use the shortcut *Ctrl* + *Shift* + *F* (or
    *Command* + *Shift* + *F* on a Mac). The camera preview is shown in the following
    screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您只需使用**变换**工具来旋转和定位您的相机，使其朝向我们的大球。这很重要，因为可能会出现的一个问题是，在**播放**模式下您可能什么也看不到，这可能是因为游戏相机没有指向我们大球所在的位置。当您移动时，您可以在**场景**窗口的右下角查看小预览，以检查新的相机视角。如果您已经选择了相机，这就是预期的行为。另一个选择是在**层次结构**中选择相机，并使用快捷键*Ctrl*
    + *Shift* + *F*（或在Mac上为*Command* + *Shift* + *F*）。相机预览如图下截图所示：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_02_19.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成描述，中等置信度](img/B21361_02_19.png)'
- en: 'Figure 2.19: The camera preview'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：相机预览
- en: 'Now, to test if physics collisions are executing properly, let’s create a cube,
    scale it until it has the shape of a ramp, and put that ramp below our sphere,
    as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试物理碰撞是否执行正确，让我们创建一个立方体，将其缩放成斜坡的形状，并将这个斜坡放在我们的大球下方，如图所示：
- en: '![A picture containing screenshot, moon, sphere  Description automatically
    generated](img/B21361_02_20.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、月亮和大球的图片，自动生成描述](img/B21361_02_20.png)'
- en: 'Figure 2.20: Ball and ramp objects'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：球和斜坡对象
- en: 'If you hit **Play** now, you will see the sphere colliding with our ramp, but
    in a strange way. It looks like it’s bouncing, but that’s not the case. If you
    expand the **Box Collider** component of our sphere, you will see that even if
    our object looks like a sphere, the green box gizmo shows us that our sphere is
    actually a box in the physics world, as illustrated in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在您点击**播放**，您将看到球体以奇怪的方式与我们的斜坡碰撞。它看起来像是在弹跳，但实际上并非如此。如果您展开球体的**盒子碰撞器**组件，您将看到即使我们的物体看起来像是一个球体，绿色的盒子工具显示我们的球体在物理世界中实际上是一个盒子，如图下截图所示：
- en: '![](img/B21361_02_21.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_21.png)'
- en: 'Figure 2.21: Object with a sphere graphic and box collider'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：具有球形图形和盒子碰撞器的对象
- en: Nowadays, video cards (GPUs) can handle rendering highly detailed models (models
    with a high polygon count), but the physics system is executed in the **central
    processing unit** (**CPU**), and it needs to do complex calculations in order
    to detect collisions. To get a decent performance in our game, it needs to run
    at least 30 **frames per second** (**FPS**), the minimum accepted by the industry
    to provide a smooth experience. The physics system considers that and, hence,
    works using simplified collision shapes that may differ from the actual shape
    a player sees on the screen.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，视频卡（GPU）可以处理渲染高度详细的三维模型（具有高多边形计数的模型），但物理系统是在**中央处理单元**（**CPU**）中执行的，并且它需要进行复杂的计算以检测碰撞。为了在我们的游戏中获得良好的性能，它至少需要达到每秒30帧（**FPS**），这是行业接受的最低标准，以提供平滑的体验。物理系统考虑到了这一点，因此使用简化的碰撞形状，这些形状可能与玩家在屏幕上看到的实际形状不同。
- en: That’s why we have **Mesh Filter** and the different types of **Collider** components
    separated—one handles the visual shape and the other the physics shape.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为我们有**Mesh Filter**和不同类型的**Collider**组件分开——一个处理视觉形状，另一个处理物理形状。
- en: 'Again, the idea of this section is not to deep-dive into those Unity systems,
    so let’s just move on for now. How can we solve the issue of our sphere appearing
    as a box? Simple: by modifying our components! In this case, the **Box Collider**
    component already present in our cube GameObject can just represent a box physics
    shape, unlike **Mesh Filter**, which supports any rendering shape. So, first,
    we need to remove it by right-clicking the component’s title and selecting the
    **Remove Component** option, as illustrated in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，本节的目的不是深入探讨那些Unity系统，所以我们现在就继续前进。我们如何解决我们的球体看起来像盒子的问题呢？简单：通过修改我们的组件！在这种情况下，已经存在于我们的立方体GameObject中的**Box
    Collider**组件可以仅仅代表一个物理形状的盒子，与支持任何渲染形状的**Mesh Filter**不同。因此，首先，我们需要通过右键单击组件的标题并选择**移除组件**选项来移除它，如下面的截图所示：
- en: '![](img/B21361_02_22.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/B21361_02_22.png)'
- en: 'Figure 2.22: Removing components'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：移除组件
- en: Now, we can again use the **Add Component** menu to select a **Physics** component,
    this time selecting the **Sphere Collider** component. If you look at the **Physics**
    components, you will see other types of colliders that can be used to represent
    other shapes, but we will look at them later in *Chapter 7*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次可以使用**添加组件**菜单来选择一个**物理**组件，这次选择**Sphere Collider**组件。如果你查看**物理**组件，你会看到其他类型的碰撞器，可以用来表示其他形状，但我们将在第7章中稍后讨论它们。
- en: 'The **Sphere Collider** component can be seen in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sphere Collider**组件可以在以下截图中看到：'
- en: '![](img/B21361_02_23.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/B21361_02_23.png)'
- en: 'Figure 2.23: Adding a Sphere Collider component'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：添加球体Collider组件
- en: 'So, if you hit **Play** now, you will see that our sphere not only looks like
    a sphere but also behaves like one. Remember: the main idea of this section of
    the book is understanding that, in Unity, you can create whatever object you want
    just by adding, removing, and modifying components, and we will be doing a lot
    of this throughout the book.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你现在点击**播放**，你会看到我们的球体不仅看起来像一个球体，而且表现得像一个球体。记住：本书本节的主要思想是理解在Unity中，你可以通过添加、移除和修改组件来创建任何你想要的对象，而且我们将在整本书中做很多这样的事情。
- en: Now, components are not the only thing needed in order to create objects. Complex
    objects may be composed of several sub-objects, so let’s see how that works.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，组件不是创建对象所需的唯一东西。复杂对象可能由几个子对象组成，所以让我们看看这是如何工作的。
- en: Understanding object Hierarchies
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象层次结构
- en: Some complex objects may need to be separated into sub-objects, each one with
    its own components. Those sub-objects need to be somehow attached to the main
    object and work together to create the necessary object behavior.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一些复杂对象可能需要被分解成子对象，每个子对象都有自己的组件。这些子对象需要以某种方式附加到主对象上，并协同工作以创建必要的对象行为。
- en: 'In this section, we will cover the following concepts related to objects:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与对象相关的以下概念：
- en: Parenting of objects
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的父子关系
- en: Possible uses
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的用途
- en: Let’s start by discovering how to create a parent-child relationship between
    objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解如何创建对象之间的父子关系。
- en: Parenting of objects
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象的父子关系
- en: '**Parenting** consists of making an object the child of another, meaning that
    those objects will be related to each other. One type of relationship that happens
    is a **Transform relationship**, meaning that a child object will be affected
    by the parent’s **Transform**. In simple terms, the child object will follow the
    parent, as if it is attached to it. For example, imagine a player with a hat on
    their head. The hat can be a child of the player’s head, making the hat follow
    the head while they are attached.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**父对象**是指将一个对象设置为另一个对象的子对象，这意味着这些对象将相互关联。发生的一种关系是**Transform关系**，这意味着子对象将受到父对象的**Transform**影响。简单来说，子对象将跟随父对象，就像它被附着在上面一样。例如，想象一个头上戴着帽子的玩家。帽子可以是玩家头部的子对象，使帽子在它们附着时跟随头部。'
- en: 'In order to try this, let’s create a capsule that represents an enemy and a
    cube that represents the weapon of the enemy. Remember that in order to do so,
    you can use the **GameObject** | **3D Object** | **Capsule** and **Cube** options
    and then use the **Transform** tool to modify them. An example of a capsule and
    a cube can be seen in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个功能，让我们创建一个代表敌人的胶囊体和一个代表敌人武器的立方体。记住，为了做到这一点，你可以使用**GameObject** | **3D
    Object** | **Capsule**和**Cube**选项，然后使用**Transform**工具来修改它们。以下截图展示了胶囊体和立方体的示例：
- en: '![A picture containing screenshot  Description automatically generated](img/B21361_02_24.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图的图片，自动生成描述](img/B21361_02_24.png)'
- en: 'Figure 2.24: A capsule and a cube representing an enemy and a weapon'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24：代表敌人和武器的胶囊体和立方体
- en: 'If you move the enemy object (the capsule), the weapon (the cube) will keep
    its position, not following our enemy. So, to prevent that, we can simply drag
    the weapon to the enemy object in the **Hierarchy** window, as illustrated in
    the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移动敌人对象（胶囊体），武器（立方体）将保持其位置，不会跟随我们的敌人。因此，为了防止这种情况，我们可以在**Hierarchy**窗口中简单地拖动武器到敌人对象上，如下截图所示：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_02_25.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，自动生成描述，置信度中等](img/B21361_02_25.png)'
- en: 'Figure 2.25: Parenting the cube weapon to the capsule character'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25：将立方体武器设置为胶囊角色的父对象
- en: Now, if you move the enemy, you will see the gun moving, rotating, and being
    scaled along with it. So, basically, the gun **Transform** also has the effects
    of the enemy Transform component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你移动敌人，你会看到枪支随着敌人移动、旋转和缩放。所以，基本上，枪支的**Transform**也具有敌人Transform组件的效果。
- en: Now that we have done some basic parenting, let’s explore other possible uses.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进行了一些基本的父对象设置，让我们探索其他可能的用途。
- en: Possible uses
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的用途
- en: There are some other uses of parenting aside from creating complex objects.
    Another common usage for it is to organize the project Hierarchy. Right now, our
    scene is simple, but in time it will grow, so keeping track of all the objects
    will become difficult. To prevent this, we can create empty GameObjects (in **GameObject**
    | **Create Empty**) that only have the Transform component to act as containers,
    with objects put into them just to organize our scene. Try to use this with caution
    because this has a performance cost if you abuse it. Generally, having one or
    two levels of parenting when organizing a scene is fine, but more than that can
    have a performance hit. Consider that you can—and will—have deeper parenting for
    the creation of complex objects; the proposed limit is just for scene organization.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建复杂对象之外，还有其他一些父对象的使用方法。它的另一个常见用途是组织项目层次结构。目前，我们的场景很简单，但随着时间的推移，它将逐渐增长，因此跟踪所有对象将变得困难。为了防止这种情况，我们可以创建空的GameObject（在**GameObject**
    | **Create Empty**），它们仅具有Transform组件，充当容器，将对象放入其中以组织场景。请谨慎使用，因为过度使用会导致性能成本。通常，在组织场景时，有一到两个父对象级别是合适的，但超过这个级别可能会影响性能。请考虑，你可以——并且将会——为创建复杂对象进行更深层次的父对象设置；所提出的限制仅适用于场景组织。
- en: 'To keep improving on our previous example, duplicate the enemy a couple of
    times all around the scene, create an empty GameObject, name it `Enemies`, and
    drag all the enemies into it so that it will act as a container. This is illustrated
    in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们之前的示例，将敌人复制几次散布在场景周围，创建一个空的GameObject，命名为`Enemies`，并将所有敌人拖入其中，使其充当容器。以下截图展示了这一过程：
- en: '![A picture containing text, screenshot  Description automatically generated](img/B21361_02_26.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本和截图的图片，自动生成描述](img/B21361_02_26.png)'
- en: 'Figure 2.26: Grouping enemies in a parent object'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26：将敌人分组到父对象中
- en: Another common usage of parenting is to change the **pivot** (or center) of
    an object. Right now, if we try to rotate our gun with the **Transform** Gizmo,
    it will rotate around its center because the creator of that cube decided to put
    the center there. Normally, that’s okay, but let’s consider a case where we need
    to make the weapon aim at the point where our enemy is looking. In this case,
    we need to rotate the weapon around the weapon handle; so, in the case of this
    cube weapon, it would be the part of the handle that is closest to the enemy.
    The problem here is that we cannot change the center of an object, so one solution
    would be to create another “weapon” 3D model or mesh with another center, which
    will lead to lots of duplicated versions of the weapon if we consider other possible
    gameplay requirements such as a rotating weapon pickup. We can fix this easily
    using parenting.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 父对象（Parenting）的另一种常见用途是改变物体的**支点**（或中心）。目前，如果我们尝试使用**变换**（Transform）工具旋转我们的枪，它将围绕其中心旋转，因为创建该立方体的开发者决定将中心放在那里。通常情况下，这是可以的，但让我们考虑一个需要使武器瞄准敌人视线方向的案例。在这种情况下，我们需要围绕武器手柄旋转武器；因此，对于这个立方体武器来说，就是手柄最靠近敌人的部分。问题在于我们无法改变物体的中心，所以一个解决方案是创建另一个具有不同中心的“武器”3D模型或网格，如果我们考虑其他可能的游戏玩法要求，如旋转武器拾取，这将导致大量武器的重复版本。我们可以通过父对象（Parenting）轻松解决这个问题。
- en: The idea is to create an empty GameObject and place it where we want the new
    pivot of our object to be. After that, we can simply drag our weapon inside this
    empty GameObject, and, from now on, consider the empty object as the actual weapon.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是创建一个空的GameObject，并将其放置在我们想要物体新支点所在的位置。之后，我们可以简单地拖动我们的武器到这个空GameObject中，从现在起，将这个空对象视为实际的武器。
- en: 'If you rotate or scale this weapon container, you will see that the weapon
    mesh will apply those transformations around this container, so we can say the
    pivot of the weapon has changed (actually, it hasn’t, but our container simulates
    the change). The process is illustrated in the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你旋转或缩放这个武器容器，你会看到武器网格将应用这些变换到这个容器上，所以我们可以说武器的支点已经改变（实际上并没有，但我们的容器模拟了这种变化）。这个过程在下面的屏幕截图中展示：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_02_27.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成，置信度中等](img/B21361_02_27.png)'
- en: 'Figure 2.27: Changing the Weapon pivot'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27：更改武器支点
- en: Now, let’s continue seeing different ways of managing GameObjects, using Prefabs
    this time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探讨使用预制件管理GameObject的不同方法。
- en: Managing GameObjects using Prefabs
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预制件管理GameObject
- en: In the previous example, we created lots of copies of our enemy around the scene,
    but in doing so, we created a new problem. Let’s imagine we need to change our
    enemy and add a **Rigidbody** component to it, but because we have several copies
    of the same object, we need to take them one by one and add the same component
    to all of them. Maybe later, we will need to change the mass of each enemy, so
    again, we need to go over each one of the enemies and make the change, and here
    we can start to see a pattern. One solution could be to select all the enemies
    using the *Ctrl* key (*Command* on a Mac) and modify all of them at once, but
    that solution won’t be of any use if we have enemy copies in other scenes. So,
    here is where Prefabs come in.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们在场景周围创建了敌人的许多副本，但这样做也带来了新的问题。让我们想象我们需要更改敌人并为其添加一个**刚体**（Rigidbody）组件，但由于我们有多个相同对象的副本，我们需要逐个选择它们并将相同的组件添加到所有副本上。也许以后我们还需要更改每个敌人的质量，所以同样，我们需要逐一检查每个敌人并做出更改，这时我们可以开始看到一种模式。一个解决方案可能是使用*Ctrl*键（在Mac上为*Command*键）选择所有敌人并一次性修改它们，但如果我们在其他场景中有敌人的副本，这个解决方案将毫无用处。所以，这就是预制件发挥作用的地方。
- en: 'In this section, we will cover the following concepts related to Prefabs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与预制件相关的以下概念：
- en: Creating Prefabs
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建预制件
- en: Prefab-instance relationship
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制件实例关系
- en: Prefab variants
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制件变体
- en: Let’s start by discussing how to create and use Prefabs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论如何创建和使用预制件开始。
- en: Creating Prefabs
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建预制件
- en: '**Prefabs** are a Unity tool that allows us to convert custom-made objects,
    such as our enemy, into an asset that defines how they can be created. We can
    use them to create new copies of our custom object easily, without needing to
    create its components and sub-objects all over again.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**预制件**（Prefab）是Unity的一个工具，允许我们将自定义对象，如我们的敌人，转换成一个定义它们如何创建的资产。我们可以使用它们轻松地创建自定义对象的新副本，而无需再次创建其组件和子对象。'
- en: In order to create a Prefab, you can simply drag your custom object from the
    **Hierarchy** window to the projectwindow, and after doing that, you will see
    a new asset in your project files. The project window is where you can navigate
    and explore all your project files; so, in this case, your Prefab is the first
    asset you ever created.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个 Prefab，您只需将自定义对象从 **Hierarchy** 窗口拖动到项目窗口，然后完成此操作后，您将在项目文件中看到一个新资产。项目窗口是您可以导航和探索所有项目文件的地方；因此，在这种情况下，您的
    Prefab 是您创建的第一个资产。
- en: 'Now, you can simply drag the Prefab from the project window into the scene
    to easily create new Prefab copies, as illustrated in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需将 Prefab 从项目窗口拖动到场景中，就可以轻松创建新的 Prefab 副本，如下图所示：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_02_28.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成，置信度中等](img/B21361_02_28.png)'
- en: 'Figure 2.28: Creating a Prefab'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28：创建 Prefab
- en: 'Now, we have a little problem here. If you pay attention to the **Hierarchy**
    window, you will see the original Prefab objects and all the new copies with their
    names in the color blue, while the enemies created before the Prefab will have
    their names in black. The blue color in a name means that the object is an **instance**
    of a Prefab, meaning that the object was created based on a Prefab. We can select
    those blue-named objects and click the **Select** button in the **Inspector**,
    selecting the original Prefab that created that object. This is illustrated in
    the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们这里有个小问题。如果您注意 **Hierarchy** 窗口，您将看到原始 Prefab 对象以及所有带有蓝色名称的新副本，而创建 Prefab
    之前的敌人将带有黑色名称。名称中的蓝色表示该对象是 Prefab 的 **实例**，意味着该对象是基于 Prefab 创建的。我们可以选择那些带有蓝色名称的对象，并在
    **Inspector** 中的 **Select** 按钮上点击，选择创建该对象的原始 Prefab。这在下图中得到了说明：
- en: '![](img/B21361_02_29.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_02_29.png)'
- en: 'Figure 2.29: Detecting Prefabs in the Hierarchy'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29：在 Hierarchy 中检测 Prefab
- en: The problem here is that the non-blue copies of the enemy are not instances
    of the Prefab we just created. We can fix this by selecting all enemies, by clicking
    them in the Hierarchy window while pressing the *Ctrl* key (*Command* on a Mac),
    and then right-clicking on them to select the **Prefab** | **Replace...** option.
    Finally, select the `Enemy` Prefab in the **Select GameObject** window that appeared
    to convert them to Prefab instances. This is a new feature available in the latest
    Unity versions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，非蓝色的敌人副本不是我们刚刚创建的 Prefab 的实例。我们可以通过在 Hierarchy 窗口中按住 *Ctrl* 键（Mac 上的
    *Command* 键）点击所有敌人，然后右键单击它们以选择 **Prefab** | **Replace...** 选项来修复这个问题。最后，在出现的 **Select
    GameObject** 窗口中选择 `Enemy` Prefab，将它们转换为 Prefab 实例。这是最新 Unity 版本中的一项新功能。
- en: '![](img/B21361_02_30.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_02_30.png)'
- en: 'Figure 2.30: Converting regular GameObjects to Prefab instances'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30：将常规 GameObject 转换为 Prefab 实例
- en: 'You can also replace the original Prefab used by its instances with a different
    Prefab and convert a Prefab instance back to a regular GameObject. For more details,
    see the video at [https://youtu.be/WOJzHz4sRyU](https://youtu.be/WOJzHz4sRyU)
    and the Unity documentation: [https://docs.unity3d.com/Manual/UnpackingPrefabInstances.html](https://docs.unity3d.com/Manual/UnpackingPrefabInstances.html).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以用不同的 Prefab 替换原始 Prefab 的实例，并将 Prefab 实例转换回常规 GameObject。更多详情，请参阅视频 [https://youtu.be/WOJzHz4sRyU](https://youtu.be/WOJzHz4sRyU)
    和 Unity 文档：[https://docs.unity3d.com/Manual/UnpackingPrefabInstances.html](https://docs.unity3d.com/Manual/UnpackingPrefabInstances.html)。
- en: Not having all enemy copies as Prefab instances didn’t seem to be a problem,
    but we will see why it was an issue in the next section of this chapter, where
    we will explore the relationship between the Prefabs and their instances.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有敌人副本不是 Prefab 实例似乎没有问题，但我们将看到为什么在下一节中这是一个问题，我们将探讨 Prefab 和它们的实例之间的关系。
- en: Prefab-instance relationship
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prefab 实例关系
- en: An instance of a Prefab, the GameObject that was created when dragging the Prefab
    to the scene, has a binding to it that helps to revert and apply changes easily
    between the Prefab and the instance. If you take a Prefab and make some modifications
    to it, those changes will be automatically applied to all instances across all
    the scenes in the project, so we can easily create a first version of the Prefab,
    use it all around the project, and then experiment with changes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 预制体实例，即当将预制体拖动到场景中创建的GameObject，与它有一个绑定，这有助于在预制体和实例之间轻松地回滚和应用更改。如果你对一个预制体进行一些修改，这些更改将自动应用到项目中所有场景的所有实例上，因此我们可以轻松地创建预制体的第一个版本，在项目的各个部分使用它，然后进行实验性更改。
- en: To practice this, let’s say we want to add a **Rigidbody** component to the
    enemies so that they can fall. In order to do so, we can simply double-click the
    Prefab file in the **Project** panel and enter the **Prefab Edit Mode**, where
    we can edit the Prefab isolated from the rest of the scene.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习这个功能，假设我们想要给敌人添加一个**刚体**组件，以便它们可以下落。为了做到这一点，我们可以在**项目**面板中双击预制体文件，进入**预制体编辑模式**，在那里我们可以独立于场景编辑预制体。
- en: 'Here, we can simply take the Prefab root object (**Enemy**, in our case) and
    add the **Rigidbody** component to it. After that, we can simply click on the
    **Scenes** button in the top-left part of the **Scene** window to get back to
    the scene we were editing, and now, we can see that all the Prefab instances of
    the enemy have a **Rigidbody** component, as illustrated in the following screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以简单地选择预制体根对象（在我们的例子中是**敌人**）并为其添加**刚体**组件。之后，我们只需点击**场景**窗口左上角的**场景**按钮，就可以回到我们正在编辑的场景，现在，我们可以看到所有敌人的预制体实例都有一个**刚体**组件，如下面的截图所示：
- en: '![](img/B21361_02_31.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_31.png)'
- en: 'Figure 2.31: Prefab Edit Mode'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.31：预制体编辑模式
- en: 'Now, what happens if we change a Prefab instance (the one in the scene) instead?
    Let’s say we want one specific enemy to fly, so they won’t suffer the effect of
    gravity. We can do that by simply selecting the specific Prefab and unchecking
    the **Use Gravity** checkbox in the **Rigidbody** component. After doing that,
    if we play the game, we will see that only that specific instance will float.
    That’s because changes to an instance of a Prefab become an **override**, a set
    of differences the instance has compared to the original Prefab. We can see how
    the **Use** **Gravity** property is bold in the Inspector, and also has a blue
    bar displayed to its left, meaning it’s an override of the original Prefab value.
    Let’s take another object and change its **Scale** property to make it bigger.
    Again, we will see how the **Scale** property becomes bold, and a blue bar will
    appear to its left. The **Use Gravity** checkbox can be seen in the following
    screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们改变一个预制体实例（场景中的那个）会发生什么？假设我们想让一个特定的敌人飞行，这样它们就不会受到重力的影响。我们可以通过简单地选择特定的预制体，并在**刚体**组件中取消勾选**使用重力**复选框来实现这一点。完成之后，如果我们玩游戏，我们会看到只有那个特定的实例会漂浮。这是因为预制体实例的变化会成为一个**覆盖**，即与原始预制体相比实例的差异集合。我们可以在检查器中看到**使用重力**属性被加粗，并且在其左侧显示一个蓝色条，表示它是原始预制体值的覆盖。让我们再取另一个对象，将其**缩放**属性更改为使其变大。同样，我们也会看到**缩放**属性被加粗，并且在其左侧出现一个蓝色条。以下截图显示了**使用重力**复选框：
- en: '![](img/B21361_02_32.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_32.png)'
- en: 'Figure 2.32: Use Gravity being highlighted as an override'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.32：突出显示使用重力作为覆盖
- en: 'The overrides have precedence over the Prefab, so if we change the scale of
    the original Prefab, the one that has a scale override won’t change, keeping its
    own version of the scale, as illustrated in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖优先于预制体，所以如果我们更改原始预制体的缩放，具有缩放覆盖的那个不会改变，保持它自己的缩放版本，如下面的截图所示：
- en: '![A picture containing screenshot  Description automatically generated](img/B21361_02_33.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图的图片 描述自动生成](img/B21361_02_33.png)'
- en: 'Figure 2.33: One Prefab instance with a scale override'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.33：具有缩放覆盖的预制体实例
- en: 'We can easily locate all overrides of an instance using the **Overrides** dropdown
    in the Inspector after selecting the Prefab instance (the one in the scene, outside
    **Prefab Edit Mode**) in the Hierarchy, locating all the changes our object has.
    It not only allows us to see all the overrides but also reverts any override we
    don’t want, applying the ones we do want. Let’s say we regretted the lack of gravity
    of that specific Prefab—no problem! We can just locate the override and revert
    it using the **Revert All** button after clicking on the component with the override.
    The process is illustrated in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在层次结构中选择预制件实例（场景中的，位于**预制件编辑模式**之外）后，在检查器中使用**覆盖**下拉菜单轻松定位实例的所有覆盖，定位我们的对象所做的所有更改。它不仅允许我们查看所有覆盖，还可以撤销我们不需要的任何覆盖，应用我们需要的覆盖。假设我们后悔了那个特定预制件缺乏重力的缺点——没问题！我们只需定位覆盖，并在点击具有覆盖的组件后使用**撤销全部**按钮将其撤销。该过程在以下截图中进行说明：
- en: '![](img/B21361_02_34.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_34.png)'
- en: 'Figure 2.34: Reverting a single override'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.34：撤销单个覆盖
- en: 'Also, let’s imagine that we really liked the new scale of that instance, so
    we want all instances to have that scale—great! We can simply select the specific
    override, hit the **Apply** button, and then the **Apply All** option; now, all
    instances will have that scale (except the ones with an override), as illustrated
    in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们假设我们真的很喜欢该实例的新缩放比例，因此我们希望所有实例都具有该缩放比例——太好了！我们可以简单地选择特定的覆盖选项，点击**应用**按钮，然后选择**应用全部**选项；现在，所有实例都将具有该缩放比例（除了具有覆盖选项的实例），如以下截图所示：
- en: '![](img/B21361_02_35.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_35.png)'
- en: 'Figure 2.35: The Apply button'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.35：应用按钮
- en: Also, we have the **Revert All** and **Apply All** buttons, but use them with
    caution, because you can easily revert and apply changes that you are not aware
    of.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有**撤销全部**和**应用全部**按钮，但请谨慎使用，因为您很容易撤销和应用您未意识到的更改。
- en: So, as you can see, Prefabs are a really useful Unity tool to keep track of
    all similar objects and apply changes to all of them, and they also have specific
    instances with few variations. Talking about variations, there are other cases
    where you will want to have several instances of a Prefab with the same set of
    variations—for example, flying enemies and grounded enemies—but if you think about
    that, we will have the same problem we had when we didn’t use Prefabs, so we need
    to manually update those varied versions one by one.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如您所看到的，预制件是Unity中一个非常有用的工具，可以跟踪所有类似对象并对其全部应用更改，它们也有少量变体的特定实例。谈到变体，还有其他情况下您可能希望有具有相同变体集的多个预制件实例——例如，飞行敌人和地面敌人，但如果您考虑一下，我们就会遇到我们未使用预制件时遇到的问题，因此我们需要手动逐个更新这些变体版本。
- en: 'Here, we have two options: one is to create a brand new Prefab just to have
    another version with that variation. This leads to the problem that if we want
    all types of enemies to undergo changes, we need to manually apply the changes
    to each possible Prefab. The second option is to create a Prefab variant. Let’s
    review the latter.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两种选择：一种是为具有该变体的另一个版本创建一个新的预制件。这会导致问题，如果我们想让所有类型的敌人都经历变化，我们需要手动将更改应用到每个可能的预制件上。第二种选择是创建一个预制件变体。让我们回顾一下后者。
- en: Prefab variants
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预制件变体
- en: A **Prefab variant** is a new Prefab that is created based on an existing one,
    so the new one **inherits** the features of the base Prefab. This means that our
    new Prefab can have differences from the base one, but the features that they
    have in common are still connected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**预制件变体**是基于现有预制件创建的新预制件，因此新预制件**继承**了基础预制件的功能。这意味着我们的新预制件可以与基础预制件有所不同，但它们共有的功能仍然相连。'
- en: 'To illustrate this, let’s create a variation of the enemy Prefab that can fly:
    the flying enemy Prefab. In order to do that, we can select an existing `enemy`
    Prefab instance in the **Hierarchy** window, name it `Flying Enemy`, and drag
    it again to the project window, and this time we will see a prompt, asking which
    kind of Prefab we want to create. This time, we need to choose **Prefab variant**,
    as illustrated in the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们创建一个可以飞行的敌人预制件变体：飞行敌人预制件。为了做到这一点，我们可以在**层次结构**窗口中选择现有的`enemy`预制件实例，将其命名为`Flying
    Enemy`，并将其再次拖动到项目窗口中，这次我们将看到一个提示，询问我们想要创建哪种类型的预制件。这次，我们需要选择**预制件变体**，如以下截图所示：
- en: '![](img/B21361_02_36.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_02_36.png)'
- en: 'Figure 2.36: Creating Prefab variants'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.36：创建预制件变体
- en: 'Now, we can enter the **Prefab Edit Mode** of the variant by double-clicking
    the new Prefab file created in the project panel. Then, add a cube as the jetpack
    of our enemy, and also uncheck the **Use Gravity** property for the enemy. If
    we return to the scene, we will see that the variant instance has changed, and
    the base enemies haven’t changed. You can see this in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过双击项目面板中创建的新预制件文件进入变体的**预制件编辑模式**。然后，添加一个立方体作为敌人的喷气背包，并取消勾选敌人的**使用重力**属性。如果我们返回到场景，我们将看到变体实例已更改，而基础敌人没有变化。你可以在下面的屏幕截图中看到这一点：
- en: '![A picture containing design, art  Description automatically generated with
    medium confidence](img/B21361_02_37.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![包含设计、艺术的图片，描述自动生成，中等置信度](img/B21361_02_37.png)'
- en: 'Figure 2.37: A Prefab variant instance'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.37：预制件变体实例
- en: 'Now, imagine you want to add a hat to all our types of enemies. We can simply
    enter the **Prefab Edit Mode** of the base enemy Prefab by double-clicking it
    and adding a cube as a hat. Now, we will see that change applied to all the enemies,
    because remember: the **Flying Enemy** Prefab is a variant of the base enemy Prefab,
    meaning that it will inherit all the changes of that one.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想要给所有类型的敌人添加一顶帽子。我们可以通过双击基础敌人预制件进入**预制件编辑模式**，然后添加一个立方体作为帽子。现在，我们将看到这个变化应用到所有敌人身上，因为记住：**飞行敌人**预制件是基础敌人预制件的一个变体，这意味着它将继承所有这些变化。
- en: 'There’s also the concept of Nested Prefabs, which allows you to use prefabs
    inside prefabs to cleverly reuse prefabs’ pieces. For more info, see the Unity
    documentation here: [https://docs.unity3d.com/Manual/NestedPrefabs.html](https://docs.unity3d.com/Manual/NestedPrefabs.html)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有嵌套预制件的概念，它允许你在预制件内部使用预制件，从而巧妙地重复使用预制件的部件。更多信息，请参阅此处 Unity 文档：[https://docs.unity3d.com/Manual/NestedPrefabs.html](https://docs.unity3d.com/Manual/NestedPrefabs.html)
- en: We have created lots of content so far, but if our PC turns off for some reason,
    we will certainly lose it all, so let’s see how we can save our progress.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了很多内容，但如果我们的电脑因某种原因关闭，我们肯定会丢失所有内容，所以让我们看看我们如何保存我们的进度。
- en: Saving scenes and projects
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存场景和项目
- en: As in any other program, we need to save our progress. The difference here is
    that we don’t have just one giant file with all the project assets but also several
    files for each asset.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他程序一样，我们需要保存我们的进度。这里的区别在于，我们不仅仅有一个包含所有项目资产的巨大文件，而且每个资产都有几个文件。
- en: 'Let’s start saving our progress by saving the scene, which is pretty straightforward.
    We can simply go to **File** | **Save** or press *Ctrl* + *S* (*Command* + *S*
    on a Mac). The first time we save our scene, a window will ask us where we want
    to save our file, and you can save it wherever you want inside the `Assets` folder
    of our project, but never outside that folder; otherwise, Unity will not be capable
    of finding it as an asset in the project. That will generate a new asset in the
    project window: a scene file.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始保存我们的进度，先保存场景，这很简单。我们可以直接去**文件** | **保存**或按*Ctrl* + *S*（在 Mac 上为*Command*
    + *S*）。第一次保存场景时，会弹出一个窗口询问我们想要将文件保存到何处，你可以在项目`Assets`文件夹内的任何位置保存它，但永远不要在文件夹外保存；否则，Unity
    将无法将其作为项目中的资产找到。这将在项目窗口中生成一个新的资产：场景文件。
- en: 'In the following screenshot, you can see how I saved the scene, naming it `test`,
    and now it shows up in the **Project** panel:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，你可以看到我是如何保存场景的，将其命名为`test`，现在它显示在**项目**面板中：
- en: '![](img/B21361_02_38.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_02_38.png)'
- en: 'Figure 2.38: Scene files'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.38：场景文件
- en: We can create a folder to save our scene in the **Save** dialog, or, if you
    already saved the scene, you can create a folder using the **plus** (**+**) icon
    in the **Project** window, and then click the **Folder** option. Finally, drag
    the created scene to that folder. Now, if you create another scene with the **File**
    | **New Scene** menu option, you can get back to the previous scene just by double-clicking
    the scene asset in the project window. Try it!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**保存**对话框中创建一个文件夹来保存我们的场景，或者，如果你已经保存了场景，你可以在**项目**窗口中使用**加号**（**+**）图标创建一个文件夹，然后点击**文件夹**选项。最后，将创建的场景拖到该文件夹中。现在，如果你使用**文件**
    | **新建场景**菜单选项创建另一个场景，只需双击项目窗口中的场景资产即可返回上一个场景。试试看！
- en: This only saved the scene, but any change in Prefabs and other kinds of assets
    are not saved with that option. Instead, if you want to save every change of the
    assets except scenes, you can use the **File** | **Save Project** option. It can
    be a little confusing, but if you want to save all your changes, you need to both
    save the scenes and the project, as saving just the project won’t save the changes
    to the scenes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这只保存了场景，但 Prefabs 和其他类型的资产的变化并没有使用该选项保存。相反，如果你想保存除了场景之外的所有资产更改，你可以使用 **文件**
    | **保存项目** 选项。这可能会有些令人困惑，但如果你想保存所有更改，你需要同时保存场景和项目，因为只保存项目不会保存场景中的更改。
- en: Sometimes, the best way to be sure everything is saved is just by closing Unity,
    which is recommended when you try to move your project between computers or folders.
    This will show you a prompt to save the changes in the scene, and it will automatically
    save any change made to other assets, like Prefabs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，确保一切保存的最佳方式就是关闭 Unity，当你尝试在不同计算机或文件夹之间移动项目时，这是推荐的。这会显示一个提示，让你保存场景中的更改，并且会自动保存对其他资产（如
    Prefabs）所做的任何更改。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a quick introduction to essential Unity concepts. We
    reviewed the basic Unity windows and how we can use all of them to edit a full
    scene, from navigating it and creating premade objects (Prefabs) to manipulating
    them to create our own types of objects, using GameObjects and components. We
    also discussed how to use the **Hierarchy** window to parent GameObjects to create
    complex object Hierarchies, as well as how to create Prefabs to reutilize and
    manipulate large amounts of the same type of objects. Finally, we discussed how
    we can save our progress.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速介绍了必要的 Unity 概念。我们回顾了基本的 Unity 窗口，以及我们如何使用它们来编辑一个完整的场景，从导航它和创建预制对象（Prefabs）到操纵它们以创建我们自己的对象类型，使用
    GameObjects 和组件。我们还讨论了如何使用 **层次结构** 窗口将 GameObjects 设置为父对象以创建复杂对象层次结构，以及如何创建 Prefabs
    以重复利用和操作大量相同类型的对象。最后，我们讨论了如何保存我们的进度。
- en: In the next chapter, we will learn about different tools like the Terrain system
    and ProBuilder to create the first prototype of our game’s level. This prototype
    will serve as a preview of where our scene will head, testing some ideas before
    going into full production.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于不同工具的知识，如地形系统和 ProBuilder，以创建我们游戏级别的第一个原型。这个原型将作为我们场景将走向的预览，在进入全面生产之前测试一些想法。
- en: Learn more on Discord
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity 游戏开发专家以及作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过 Ask Me Anything 会话与作者聊天，等等。扫描二维码或访问链接以加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1498477041053909218.png)'
