<html><head></head><body>
  <div id="_idContainer023">
   <h1 class="chapter-number" id="_idParaDest-165">
    <a id="_idTextAnchor165">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     5
    </span>
   </h1>
   <h1 id="_idParaDest-166">
    <a id="_idTextAnchor166">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Managing Application State
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In this chapter, we will explore the crucial aspect of maintaining and manipulating the state of a Blazor application.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     An
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.4.1">
      application state
     </span>
    </strong>
    <span class="koboSpan" id="kobo.5.1">
     is the
    </span>
    <a id="_idIndexMarker218">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     runtime data that dictates the behavior and appearance of an application, reflecting user interactions
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.7.1">
      and decisions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.8.1">
     We will walk through various strategies for state management, from encoding state in the URL for bookmarkable states and easy sharing to implementing in-memory state containers for rapid access.
    </span>
    <span class="koboSpan" id="kobo.8.2">
     You’ll learn how to inject application state as a service, allowing centralized state management across different components, and how to persist state to ensure data continuity across sessions.
    </span>
    <span class="koboSpan" id="kobo.8.3">
     Furthermore, we will explore techniques to resolve persisted state upon application load, invoking state changes from anywhere within an application, and monitoring these changes with dedicated listening components.
    </span>
    <span class="koboSpan" id="kobo.8.4">
     We will pay special attention to sharing state across different render
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.9.1">
      mode boundaries.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.10.1">
     By the end of this chapter, you’ll have a solid foundation in state management practices that will help you build dynamic, responsive, and stateful
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      Blazor applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.12.1">
     Here are the recipes that will take
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.13.1">
      us there:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.14.1">
      Having a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       bookmarkable state
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      Implementing an in-memory
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       state container
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      Injecting application state as
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       a service
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      Invoking state changes
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       from anywhere
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       Persisting state
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.23.1">
      Resolving
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       persisted state
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.25.1">
      Sharing state across interactive render
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.26.1">
       mode boundaries
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-167">
    <a id="_idTextAnchor167">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     The barrier of entry to that chapter is not high.
    </span>
    <span class="koboSpan" id="kobo.28.2">
     You’ll need the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      following tools:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.30.1">
      A modern IDE (that supports
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.31.1">
       Blazor development)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.32.1">
      .NET 9 installed on your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.33.1">
       development machine
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.34.1">
      A modern web browser (one that supports Web Assembly and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.35.1">
       has DevTools)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.36.1">
      A bare-bone Blazor project (where you’ll write
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.37.1">
       your code)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     You can find all the examples and data samples referenced in the following recipes in a dedicated GitHub repository at:
    </span>
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05">
     <span class="koboSpan" id="kobo.39.1">
      https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05
     </span>
    </a>
    <span class="koboSpan" id="kobo.40.1">
     .
    </span>
    <span class="koboSpan" id="kobo.40.2">
     In each recipe that needs any samples, I will also point you to the directory where you can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.41.1">
      find them.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-168">
    <a id="_idTextAnchor168">
    </a>
    <span class="koboSpan" id="kobo.42.1">
     Having bookmarkable state
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     In this recipe, we
    </span>
    <a id="_idIndexMarker219">
    </a>
    <span class="koboSpan" id="kobo.44.1">
     will introduce the simplest yet powerful pattern of leveraging a URL to maintain and share application state.
    </span>
    <span class="koboSpan" id="kobo.44.2">
     Unlike more complex state management strategies, embedding state flags directly in the URL doesn’t require in-memory persistence.
    </span>
    <span class="koboSpan" id="kobo.44.3">
     A static URL allows users to bookmark a specific application state and facilitates the easy sharing of that state with others.
    </span>
    <span class="koboSpan" id="kobo.44.4">
     We will follow the well-known
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.45.1">
      restful routing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.46.1">
     pattern
    </span>
    <a id="_idIndexMarker220">
    </a>
    <span class="koboSpan" id="kobo.47.1">
     and elegantly map application states to readable and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      shareable URLs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.49.1">
     Let’s create a component that allows us to bookmark and view an entire event list or specific
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      event information.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-169">
    <a id="_idTextAnchor169">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     Before we start implementing a component with bookmarkable state, we need to do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.54.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.55.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.56.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.57.1">
       Recipe01
      </span>
     </strong>
     <span class="koboSpan" id="kobo.58.1">
      directory – this will be our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.59.1">
       working directory
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.60.1">
      Copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.61.1">
       Api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.62.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.63.1">
       Event
      </span>
     </strong>
     <span class="koboSpan" id="kobo.64.1">
      files from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.65.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.66.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.67.1">
       Data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.68.1">
      directory in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.69.1">
       GitHub repository
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-170">
    <a id="_idTextAnchor170">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.71.1">
     Follow these steps to implement stateful URLs in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      your application:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.73.1">
      Navigate to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.74.1">
       Program
      </span>
     </strong>
     <span class="koboSpan" id="kobo.75.1">
      file of your application and register the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.76.1">
       Api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.77.1">
      service, as scoped in the application’s dependency
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.78.1">
       injection container:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.79.1">
builder.Services.AddScoped&lt;Api&gt;();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.80.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.81.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.82.1">
      component with two navigable routes to facilitate user access to different application states through
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.83.1">
       the URL:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.84.1">
@page "/ch05r01/events"
@page "/ch05r01/events/{eventId:guid}"</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.85.1">
      Inside the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.86.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.87.1">
      block of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.88.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.89.1">
      component, inject the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.90.1">
       Api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.91.1">
      service and declare an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.92.1">
       EventId
      </span>
     </strong>
     <span class="koboSpan" id="kobo.93.1">
      parameter
     </span>
     <a id="_idIndexMarker221">
     </a>
     <span class="koboSpan" id="kobo.94.1">
      that we will use to fetch specific
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.95.1">
       event details:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.96.1">
[Inject] private Api Api { get; init; }
[Parameter] public Guid EventId { get; set; }</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.97.1">
      Still within the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.98.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.99.1">
      block, initialize the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.100.1">
       Collection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.101.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.102.1">
       Event
      </span>
     </strong>
     <span class="koboSpan" id="kobo.103.1">
      variables that will hold the fetched data, based on the application’s
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.104.1">
       current state:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.105.1">
protected IList&lt;Event&gt; Collection = [];
protected Event Event;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.106.1">
      Override the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.107.1">
       OnParametersSetAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.108.1">
      life cycle method and implement the logic to update the component’s state, based on the parameters passed in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.109.1">
       the URL:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.110.1">
protected override async Task OnParametersSetAsync()
{
    if (EventId != Guid.Empty)
    {
        Event = await Api
            .GetEventAsync(EventId, default);
        return;
    }
    Collection = await Api.GetEventsAsync(default);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.111.1">
      In the markup of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.112.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.113.1">
      component, add a section to render
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.114.1">
       Event
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.115.1">
       details conditionally:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.116.1">
@if (Event is not null)
{
    &lt;p&gt;Viewing: @Event.Id&lt;/p&gt;
    return;
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.117.1">
      Add another
     </span>
     <a id="_idIndexMarker222">
     </a>
     <span class="koboSpan" id="kobo.118.1">
      section to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.119.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.120.1">
      markup to render the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.121.1">
        Collection
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.122.1">
       elements:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.123.1">
@foreach (var item in Collection)
{
    &lt;div class="w-100"&gt;
        &lt;a href="/ch05r01/events/@item.Id"&gt;
            @item.Id
        &lt;/a&gt;
    &lt;/div&gt;
}</span></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-171">
    <a id="_idTextAnchor171">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.125.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.126.1">
      step 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.127.1">
     , we navigate to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.128.1">
      Program
     </span>
    </strong>
    <span class="koboSpan" id="kobo.129.1">
     of the application and register the API service in the application’s dependency injection container, so we can inject it later
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.130.1">
      when required.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.131.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.132.1">
      step 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.133.1">
     , we create a routable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.134.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.135.1">
     component a slightly enhanced routing.
    </span>
    <span class="koboSpan" id="kobo.135.2">
     We declare two routable paths –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.136.1">
      /ch05r01/events
     </span>
    </strong>
    <span class="koboSpan" id="kobo.137.1">
     for rendering all available events and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.138.1">
      /ch05r01/events/{eventId:guid}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.139.1">
     for specific event details.
    </span>
    <span class="koboSpan" id="kobo.139.2">
     By leveraging path parametrization and path constraints, we specify the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.140.1">
      EventId
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     parameter within the curly braces, setting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.142.1">
      Guid
     </span>
    </strong>
    <span class="koboSpan" id="kobo.143.1">
     as its expected
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.144.1">
      value type.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.145.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.146.1">
      step 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.147.1">
     , we initialize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      @code
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     block, where we declare the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      EventId
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     parameter expected by the route.
    </span>
    <span class="koboSpan" id="kobo.151.2">
     Blazor automatically intercepts and assigns path parameter values based on the name matching.
    </span>
    <span class="koboSpan" id="kobo.151.3">
     We also inject the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      Api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     service from the provided sample data, allowing us to fetch event information seamlessly.
    </span>
    <span class="koboSpan" id="kobo.153.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.154.1">
      step 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.155.1">
     , we initialize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.156.1">
      Collection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     variables.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     These are essential in supporting the dual states of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.160.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     component – one for showcasing a list of available events and another for presenting details of a specific, selected event.
    </span>
    <span class="koboSpan" id="kobo.161.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.162.1">
      step 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.163.1">
     , we fine-tune the rendering logic by overriding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.164.1">
      OnParametersSetAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.165.1">
     life cycle method.
    </span>
    <span class="koboSpan" id="kobo.165.2">
     We determine whether the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      EventId
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     was correctly resolved and fetch the details of that specific event, using the injected
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      Api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     service.
    </span>
    <span class="koboSpan" id="kobo.169.2">
     Otherwise, we retrieve the entire collection of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.170.1">
      available events.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.171.1">
     From
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.172.1">
      step 6
     </span>
    </em>
    <span class="koboSpan" id="kobo.173.1">
     , we implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     markup that supports two distinct states.
    </span>
    <span class="koboSpan" id="kobo.175.2">
     To accommodate this, we include two conditional markup sections.
    </span>
    <span class="koboSpan" id="kobo.175.3">
     If
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.176.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.177.1">
     was fetched, indicating that a specific event’s details are ready for display, we render its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.178.1">
      Id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.179.1">
     and quickly return to skip
    </span>
    <a id="_idIndexMarker223">
    </a>
    <span class="koboSpan" id="kobo.180.1">
     any further logic.
    </span>
    <span class="koboSpan" id="kobo.180.2">
     We cover the component’s alternative state in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.181.1">
      step 7
     </span>
    </em>
    <span class="koboSpan" id="kobo.182.1">
     by iterating over
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.183.1">
      Collection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.184.1">
     .
    </span>
    <span class="koboSpan" id="kobo.184.2">
     We render links to each event’s details, utilizing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.185.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     component’s parametrized path and providing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      item.Id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     where the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      eventId
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      parameter goes.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-172">
    <a id="_idTextAnchor172">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.192.1">
     You will find parameterized paths most useful in
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.193.1">
      CRUD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.194.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.195.1">
      Create, Read, Update, Delete
     </span>
    </strong>
    <span class="koboSpan" id="kobo.196.1">
     ) scenarios.
    </span>
    <span class="koboSpan" id="kobo.196.2">
     Assuming
    </span>
    <a id="_idIndexMarker224">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     we would implement a form within the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.198.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.199.1">
     component designed to attach to an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     object, we could ingeniously treat a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      Guid.Empty
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     value as a trigger to initiate the creation process and initialize a new, empty
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.204.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     model.
    </span>
    <span class="koboSpan" id="kobo.205.2">
     Conversely, if a valid
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      Guid
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     is provided, we would fetch the existing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.208.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.209.1">
     from the API.
    </span>
    <span class="koboSpan" id="kobo.209.2">
     We’ve effectively covered two scenarios with the same form and avoided
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.210.1">
      code duplication.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.211.1">
     Specifying the type for a value in a path isn’t a strict requirement.
    </span>
    <span class="koboSpan" id="kobo.211.2">
     By default, Blazor will map parameters as strings, giving you the flexibility to parse them into the required type at a later stage.
    </span>
    <span class="koboSpan" id="kobo.211.3">
     However, the real power lies in utilizing route constraints effectively.
    </span>
    <span class="koboSpan" id="kobo.211.4">
     While parsing parameters later provides flexibility, I strongly recommend leveraging route constraints wherever possible.
    </span>
    <span class="koboSpan" id="kobo.211.5">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.212.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.213.1">
     component example, by specifying a parameter type as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.214.1">
      Guid
     </span>
    </strong>
    <span class="koboSpan" id="kobo.215.1">
     , if the route does not match due to the route constraint, Blazor shows a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.216.1">
      NotFound
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     content – filtering out invalid inputs preemptively and enhancing the robustness and security of your application.
    </span>
    <span class="koboSpan" id="kobo.217.2">
     We will explore routing and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.218.1">
      NotFound
     </span>
    </strong>
    <span class="koboSpan" id="kobo.219.1">
     content
    </span>
    <a id="_idIndexMarker225">
    </a>
    <span class="koboSpan" id="kobo.220.1">
     in
    </span>
    <a href="B22020_09.xhtml#_idTextAnchor308">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.221.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.222.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-173">
    <a id="_idTextAnchor173">
    </a>
    <span class="koboSpan" id="kobo.223.1">
     Implementing an in-memory state container
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.224.1">
     Efficiently managing
    </span>
    <a id="_idIndexMarker226">
    </a>
    <span class="koboSpan" id="kobo.225.1">
     interactions with external APIs is absolutely crucial in modern web development.
    </span>
    <span class="koboSpan" id="kobo.225.2">
     An
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.226.1">
      in-memory state container
     </span>
    </strong>
    <span class="koboSpan" id="kobo.227.1">
     allows you to persist specific objects for an application lifetime unless configured otherwise.
    </span>
    <span class="koboSpan" id="kobo.227.2">
     When you receive a comprehensive data object from the API upon the initial call, rather than fetching this data anew for every page transition, an in-memory state container facilitates the smooth transfer of the entire object throughout the various stages and pages of the application.
    </span>
    <span class="koboSpan" id="kobo.227.3">
     Furthermore, an in-memory state container proves invaluable during multi-stage setup processes, allowing the current state of a complex setup object to be persistently carried forward without loss or repeated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.228.1">
      external calls.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.229.1">
     Let’s implement a container where we will persist event information and display it after redirecting a user to an event
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      details page.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-174">
    <a id="_idTextAnchor174">
    </a>
    <span class="koboSpan" id="kobo.231.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.232.1">
     Before diving into the implementation of an in-memory container, we need to do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.233.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.234.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.235.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.236.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.237.1">
       Recipe02
      </span>
     </strong>
     <span class="koboSpan" id="kobo.238.1">
      directory – this will be your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.239.1">
       working directory
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.240.1">
      Copy
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.241.1">
       Api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.242.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.243.1">
       Event
      </span>
     </strong>
     <span class="koboSpan" id="kobo.244.1">
      files from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.245.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.246.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.247.1">
       Data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.248.1">
      directory in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.249.1">
       GitHub repository
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.250.1">
      Register the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.251.1">
       Api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.252.1">
      service as scoped in the application’s dependency injection container (you can check the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.253.1">
       Having a bookmarkable state
      </span>
     </em>
     <span class="koboSpan" id="kobo.254.1">
      recipe to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.255.1">
       see how)
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-175">
    <a id="_idTextAnchor175">
    </a>
    <span class="koboSpan" id="kobo.256.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     Implement the in-memory state container with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.258.1">
      following steps:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.259.1">
      Create a generic
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.260.1">
       StateContainer&lt;T&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.261.1">
      class to hold any type of object
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.262.1">
       in memory:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.263.1">
public class StateContainer&lt;T&gt; { }</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.264.1">
      Within
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.265.1">
       StateContainer&lt;T&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.266.1">
      , initialize a backing
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.267.1">
       _container
      </span>
     </strong>
     <span class="koboSpan" id="kobo.268.1">
      as a generic
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.269.1">
       Dictionary
      </span>
     </strong>
     <span class="koboSpan" id="kobo.270.1">
      where you will persist
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.271.1">
       state objects:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.272.1">
private readonly Dictionary&lt;Guid, T&gt; _container = [];</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.273.1">
      Add the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.274.1">
       Persist()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.275.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.276.1">
       Resolve()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.277.1">
      methods to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.278.1">
       StateContainer&lt;T&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.279.1">
      that either store
     </span>
     <a id="_idIndexMarker227">
     </a>
     <span class="koboSpan" id="kobo.280.1">
      or retrieve objects from
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.281.1">
       _container
      </span>
     </strong>
     <span class="koboSpan" id="kobo.282.1">
      , using a
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.283.1">
        Guid
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.284.1">
       key:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.285.1">
public void Persist(Guid key, T value)
    =&gt; _container.TryAdd(key, value);
public T Resolve(Guid key) =&gt; _container[key];</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.286.1">
      Navigate to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.287.1">
       Program
      </span>
     </strong>
     <span class="koboSpan" id="kobo.288.1">
      application root and register the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.289.1">
       StateContainer&lt;Event&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.290.1">
      in the dependency
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.291.1">
       injection container:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.292.1">
builder.Services.AddScoped&lt;StateContainer&lt;Event&gt;&gt;();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.293.1">
      Add a static
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.294.1">
       Config
      </span>
     </strong>
     <span class="koboSpan" id="kobo.295.1">
      class and define a customized
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.296.1">
       PrerenderDisabled
      </span>
     </strong>
     <span class="koboSpan" id="kobo.297.1">
      render mode, based on
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.298.1">
       InteractiveWebAssembly
      </span>
     </strong>
     <span class="koboSpan" id="kobo.299.1">
      but with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.300.1">
       disabled pre-rendering:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.301.1">
internal static class Config
{
    public static readonly IComponentRenderMode
        PrerenderDisabled = new
            InteractiveWebAssemblyRenderMode(
                prerender: false);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.302.1">
      Create a routable
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.303.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.304.1">
      component that renders in
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.305.1">
        PrerenderDisabled
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.306.1">
       mode:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.307.1">
@page "/ch05r02"
@rendermode Config.PrerenderDisabled</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.308.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.309.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.310.1">
      section of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.311.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.312.1">
      , inject
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.313.1">
       StateContainer&lt;Event&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.314.1">
      to persist
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.315.1">
       Event
      </span>
     </strong>
     <span class="koboSpan" id="kobo.316.1">
      objects,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.317.1">
       NavigationManager
      </span>
     </strong>
     <span class="koboSpan" id="kobo.318.1">
      to facilitate navigation, and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.319.1">
       Api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.320.1">
      to seed data
     </span>
     <a id="_idIndexMarker228">
     </a>
     <span class="koboSpan" id="kobo.321.1">
      from an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.322.1">
       external source:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.323.1">
[Inject]
private StateContainer&lt;Event&gt; Container { get; init; }
[Inject]
private NavigationManager Navigation { get; init; }
[Inject]
private Api Api { get; init; }</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.324.1">
      Still inside the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.325.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.326.1">
      block, initialize a backing
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.327.1">
       Data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.328.1">
      collection and override the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.329.1">
       OnInitializedAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.330.1">
      life cycle method to fetch
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.331.1">
       Data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.332.1">
      objects
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.333.1">
       from
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.334.1">
        Api
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.335.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.336.1">
protected IList&lt;Event&gt; Data = [];
protected override async Task OnInitializedAsync()
    =&gt; Data = await Api.GetEventsAsync(default);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.337.1">
      Lastly, in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.338.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.339.1">
      block, implement a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.340.1">
       ShowDetails()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.341.1">
      method that stores a requested
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.342.1">
       Event
      </span>
     </strong>
     <span class="koboSpan" id="kobo.343.1">
      in the in-memory
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.344.1">
       StateContainer&lt;Event&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.345.1">
      and redirects to a page displaying the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.346.1">
       event details:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.347.1">
public void ShowDetails(Event @event)
{
    Container.Persist(@event.Id, @event);
    Navigation.NavigateTo(
        $"/ch05r02/events/{@event.Id}"
    );
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.348.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.349.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.350.1">
      markup, construct a loop where you render navigation buttons to all elements
     </span>
     <a id="_idIndexMarker229">
     </a>
     <span class="koboSpan" id="kobo.351.1">
      from the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.352.1">
        Data
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.353.1">
       collection:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.354.1">
@foreach (var item in Data)
{
    &lt;div class="row w-50 m-1"&gt;
        &lt;button @onclick="@(() =&gt; ShowDetails(item))"&gt;
            @item.Id
        &lt;/button&gt;
    &lt;/div&gt;
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.355.1">
      Create an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.356.1">
       EventDetails
      </span>
     </strong>
     <span class="koboSpan" id="kobo.357.1">
      component with a route matching the one specified in the previous step and rendering in
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.358.1">
        PrerenderDisabled
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.359.1">
       mode:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.360.1">
@page "/ch05r02/events/{eventId:guid}"
@rendermode Config.PrerenderDisabled</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.361.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.362.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.363.1">
      section of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.364.1">
       EventDetails
      </span>
     </strong>
     <span class="koboSpan" id="kobo.365.1">
      , inject
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.366.1">
       StateContainer&lt;Event&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.367.1">
      and declare an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.368.1">
       EventId
      </span>
     </strong>
     <span class="koboSpan" id="kobo.369.1">
      parameter to capture an event identifier from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.370.1">
       the URL:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.371.1">
[Inject]
private StateContainer&lt;Event&gt; Container { get; init; }
[Parameter]
public Guid EventId { get; set; }</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.372.1">
      Still within the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.373.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.374.1">
      block, declare a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.375.1">
       Model
      </span>
     </strong>
     <span class="koboSpan" id="kobo.376.1">
      variable to maintain the current component state and override the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.377.1">
       OnParametersSet()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.378.1">
      life cycle method to resolve
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.379.1">
       Model
      </span>
     </strong>
     <span class="koboSpan" id="kobo.380.1">
      from the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.381.1">
       injected
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.382.1">
        Container
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.383.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.384.1">
protected Event Model;
protected override void OnParametersSet()
    =&gt; Model = Container.Resolve(EventId);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.385.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.386.1">
       EventDetails
      </span>
     </strong>
     <span class="koboSpan" id="kobo.387.1">
      markup, introduce a nullability check for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.388.1">
       Model
      </span>
     </strong>
     <span class="koboSpan" id="kobo.389.1">
      , and render the
     </span>
     <a id="_idIndexMarker230">
     </a>
     <span class="koboSpan" id="kobo.390.1">
      current capacity of the underlying event if
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.391.1">
       Model
      </span>
     </strong>
     <span class="koboSpan" id="kobo.392.1">
      is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.393.1">
       successfully resolved:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.394.1">
@if (Model is null) return;
It has @Model.Capacity spots left!</span></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-176">
    <a id="_idTextAnchor176">
    </a>
    <span class="koboSpan" id="kobo.395.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.396.1">
     We start the implementation by laying the foundation of in-memory state persistence.
    </span>
    <span class="koboSpan" id="kobo.396.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.397.1">
      step 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.398.1">
     , we add a generic class,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.399.1">
      StateContainer&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.400.1">
     .
    </span>
    <span class="koboSpan" id="kobo.400.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.401.1">
      step 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.402.1">
     , we initialize a backing collection within
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.403.1">
      StateContainer&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     to persist state objects.
    </span>
    <span class="koboSpan" id="kobo.404.2">
     We opt for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.405.1">
      Dictionary&lt;Guid, T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.406.1">
     , as we will exploit its straightforward key-value API, but any alternative collection type would also work.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.407.1">
      step 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.408.1">
     , we implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.409.1">
      Persist()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.410.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.411.1">
      Resolve()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.412.1">
     methods.
    </span>
    <span class="koboSpan" id="kobo.412.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.413.1">
      Persist()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.414.1">
     method, accepting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.415.1">
      key
     </span>
    </strong>
    <span class="koboSpan" id="kobo.416.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.417.1">
      value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.418.1">
     , allows us to add objects to our in-memory container.
    </span>
    <span class="koboSpan" id="kobo.418.2">
     Concurrently, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.419.1">
      Resolve()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.420.1">
     method allows to retrieve these objects using their keys.
    </span>
    <span class="koboSpan" id="kobo.420.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.421.1">
      step 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.422.1">
     , we add our in-memory state container to the application’s dependency injection container.
    </span>
    <span class="koboSpan" id="kobo.422.2">
     As we will be working with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.423.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.424.1">
     objects, we register
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.425.1">
      StateContainer&lt;Event&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.426.1">
     .
    </span>
    <span class="koboSpan" id="kobo.426.2">
     We give it a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.427.1">
      Scoped
     </span>
    </strong>
    <span class="koboSpan" id="kobo.428.1">
     lifetime to ensure that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.429.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.430.1">
     objects are available throughout the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.431.1">
      user session.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.432.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.433.1">
      step 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.434.1">
     , we introduce a custom render mode –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.435.1">
      PrerenderDisabled
     </span>
    </strong>
    <span class="koboSpan" id="kobo.436.1">
     .
    </span>
    <span class="koboSpan" id="kobo.436.2">
     We place
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.437.1">
      PrerenderDisabled
     </span>
    </strong>
    <span class="koboSpan" id="kobo.438.1">
     in a new, static
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.439.1">
      Config
     </span>
    </strong>
    <span class="koboSpan" id="kobo.440.1">
     class so that it’s easily reusable.
    </span>
    <span class="koboSpan" id="kobo.440.2">
     Why do we need a custom render mode?
    </span>
    <span class="koboSpan" id="kobo.440.3">
     When you declare interactivity mode per component, Blazor serves pre-rendered content by default and hydrates the component state subsequently.
    </span>
    <span class="koboSpan" id="kobo.440.4">
     In our case, this would raise exceptions, as the in-memory state container remains inaccessible during the initial component render.
    </span>
    <span class="koboSpan" id="kobo.440.5">
     Our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.441.1">
      PrerenderDisabled
     </span>
    </strong>
    <span class="koboSpan" id="kobo.442.1">
     mode, based on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.443.1">
      InteractiveWebAssembly
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     , solves
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.445.1">
      that challenge.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.446.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.447.1">
      step 6
     </span>
    </em>
    <span class="koboSpan" id="kobo.448.1">
     , we create a routable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.449.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.450.1">
     component, referencing the sample data assembly, and we leverage
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.451.1">
      PrerenderDisabled
     </span>
    </strong>
    <span class="koboSpan" id="kobo.452.1">
     mode, defined in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.453.1">
      Config
     </span>
    </strong>
    <span class="koboSpan" id="kobo.454.1">
     .
    </span>
    <span class="koboSpan" id="kobo.454.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.455.1">
      step 7
     </span>
    </em>
    <span class="koboSpan" id="kobo.456.1">
     , we inject the required services –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.457.1">
      StateContainer&lt;Event&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.458.1">
     for object state persistence,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.459.1">
      Navigation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.460.1">
     for user-directed navigation, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.461.1">
      Api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.462.1">
     for fetching events from an external data source.
    </span>
    <span class="koboSpan" id="kobo.462.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.463.1">
      step 8
     </span>
    </em>
    <span class="koboSpan" id="kobo.464.1">
     , we initialize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.465.1">
      Data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.466.1">
     collection within the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.467.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     component and populate it by invoking
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      Api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      OnInitializedAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     life cycle method.
    </span>
    <span class="koboSpan" id="kobo.472.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.473.1">
      step 9
     </span>
    </em>
    <span class="koboSpan" id="kobo.474.1">
     , we define a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.475.1">
      ShowDetails()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.476.1">
     method that adds the selected
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.477.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.478.1">
     object to the in-memory state container and redirects the user to an event details page.
    </span>
    <span class="koboSpan" id="kobo.478.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.479.1">
      step 10
     </span>
    </em>
    <span class="koboSpan" id="kobo.480.1">
     , we jump to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.481.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.482.1">
     markup and render buttons, allowing us to navigate to the details of any element from the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.483.1">
       Data
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.484.1">
      collection.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.485.1">
     Now, we also need to
    </span>
    <a id="_idIndexMarker231">
    </a>
    <span class="koboSpan" id="kobo.486.1">
     add the event details page.
    </span>
    <span class="koboSpan" id="kobo.486.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.487.1">
      step 11
     </span>
    </em>
    <span class="koboSpan" id="kobo.488.1">
     , we create an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.489.1">
      EventDetails
     </span>
    </strong>
    <span class="koboSpan" id="kobo.490.1">
     component with a route matching the one chosen in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.491.1">
      step 9
     </span>
    </em>
    <span class="koboSpan" id="kobo.492.1">
     .
    </span>
    <span class="koboSpan" id="kobo.492.2">
     We also declare its render mode to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.493.1">
      PrerenderDisabled
     </span>
    </strong>
    <span class="koboSpan" id="kobo.494.1">
     - in line with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.495.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.496.1">
     component.
    </span>
    <span class="koboSpan" id="kobo.496.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.497.1">
      step 12
     </span>
    </em>
    <span class="koboSpan" id="kobo.498.1">
     , we inject the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.499.1">
      StateContainer&lt;Event&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.500.1">
     and declare
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.501.1">
      EventId
     </span>
    </strong>
    <span class="koboSpan" id="kobo.502.1">
     , allowing Blazor to intercept the event identifier directly from the page URL.
    </span>
    <span class="koboSpan" id="kobo.502.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.503.1">
      step 13
     </span>
    </em>
    <span class="koboSpan" id="kobo.504.1">
     , we declare
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.505.1">
      Model
     </span>
    </strong>
    <span class="koboSpan" id="kobo.506.1">
     for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.507.1">
      EventDetails
     </span>
    </strong>
    <span class="koboSpan" id="kobo.508.1">
     component and override the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.509.1">
      OnParametersSet()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.510.1">
     life cycle method, where we resolve the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.511.1">
      Model
     </span>
    </strong>
    <span class="koboSpan" id="kobo.512.1">
     value using the intercepted
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.513.1">
      EventId
     </span>
    </strong>
    <span class="koboSpan" id="kobo.514.1">
     .
    </span>
    <span class="koboSpan" id="kobo.514.2">
     Note that we leverage our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.515.1">
      StateContainer&lt;Event&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.516.1">
     to fetch the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.517.1">
      Model
     </span>
    </strong>
    <span class="koboSpan" id="kobo.518.1">
     details and avoid additional fetching from external sources.
    </span>
    <span class="koboSpan" id="kobo.518.2">
     As we wrap up the implementation, in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.519.1">
      step 14
     </span>
    </em>
    <span class="koboSpan" id="kobo.520.1">
     , we complete the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.521.1">
      EventDetails
     </span>
    </strong>
    <span class="koboSpan" id="kobo.522.1">
     component with a markup that checks for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.523.1">
      Model
     </span>
    </strong>
    <span class="koboSpan" id="kobo.524.1">
     state and displays information about the event’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.525.1">
      current capacity.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-177">
    <a id="_idTextAnchor177">
    </a>
    <span class="koboSpan" id="kobo.526.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.527.1">
     Interestingly, the in-memory state container isn’t just for holding onto data.
    </span>
    <span class="koboSpan" id="kobo.527.2">
     It’s also handy when managing multi-step forms or complex configuration processes, as you can save and retrieve the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.528.1">
      progress efficiently.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.529.1">
     A critical aspect we’ve deliberately omitted is the mechanism for cleaning up the state container.
    </span>
    <span class="koboSpan" id="kobo.529.2">
     Depending on your application’s requirements, you may need to persist state for different durations.
    </span>
    <span class="koboSpan" id="kobo.529.3">
     By following our implementation above, simply registering
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.530.1">
      StateContainer&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.532.1">
      Scoped
     </span>
    </strong>
    <span class="koboSpan" id="kobo.533.1">
     ensures that the state lives as long as the user session.
    </span>
    <span class="koboSpan" id="kobo.533.2">
     However, you might face scenarios where you need more control over the life cycle of state objects.
    </span>
    <span class="koboSpan" id="kobo.533.3">
     Should you need to clear the state when the user navigates away from a specific component or completes a set of steps, implementing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.534.1">
      IDisposable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.535.1">
     or utilizing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.536.1">
      OwningComponentBase
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     for scoped disposal are more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.538.1">
      effective strategies.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.539.1">
     A word of caution before we end this recipe – you must strategically assess the feasibility of in-memory state
    </span>
    <a id="_idIndexMarker232">
    </a>
    <span class="koboSpan" id="kobo.540.1">
     containers in your scenarios.
    </span>
    <span class="koboSpan" id="kobo.540.2">
     The complexity of the persisted objects and the duration of their persistence might put an unnecessary strain on application memory and lead to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.541.1">
      performance issues.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-178">
    <a id="_idTextAnchor178">
    </a>
    <span class="koboSpan" id="kobo.542.1">
     Injecting application state as a service
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.543.1">
     In this recipe, we
    </span>
    <a id="_idIndexMarker233">
    </a>
    <span class="koboSpan" id="kobo.544.1">
     will showcase a design
    </span>
    <a id="_idIndexMarker234">
    </a>
    <span class="koboSpan" id="kobo.545.1">
     pattern to streamline state management across your application by introducing an application state service and leveraging dependency injection.
    </span>
    <span class="koboSpan" id="kobo.545.2">
     This method simplifies how components interact with each other, enabling them to seamlessly listen to or communicate changes in the application’s state.
    </span>
    <span class="koboSpan" id="kobo.545.3">
     Leveraging dependency injection, you enhance the responsiveness of your application and maintain a clean architecture by avoiding tight coupling between components.
    </span>
    <span class="koboSpan" id="kobo.545.4">
     With an application state service, your application remains agile, maintainable, and scalable, adapting to the evolving needs of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.546.1">
      web development.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.547.1">
     Let’s implement an injectable state service that allows us to post and receive success and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.548.1">
      failure messages.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-179">
    <a id="_idTextAnchor179">
    </a>
    <span class="koboSpan" id="kobo.549.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.550.1">
     Before you dive into an injectable state service, do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.552.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.553.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.554.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.555.1">
       Recipe03
      </span>
     </strong>
     <span class="koboSpan" id="kobo.556.1">
      directory – this will be your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.557.1">
       working directory
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.558.1">
      Copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.559.1">
       Config
      </span>
     </strong>
     <span class="koboSpan" id="kobo.560.1">
      class with customized
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.561.1">
       PrerenderDisabled
      </span>
     </strong>
     <span class="koboSpan" id="kobo.562.1">
      render mode from the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.563.1">
       Implementing an in-memory state container
      </span>
     </em>
     <span class="koboSpan" id="kobo.564.1">
      recipe or the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.565.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.566.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.567.1">
       Recipe03
      </span>
     </strong>
     <span class="koboSpan" id="kobo.568.1">
      directory in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.569.1">
       GitHub repository
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-180">
    <a id="_idTextAnchor180">
    </a>
    <span class="koboSpan" id="kobo.570.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.571.1">
     Follow this guide
    </span>
    <a id="_idIndexMarker235">
    </a>
    <span class="koboSpan" id="kobo.572.1">
     to implement
    </span>
    <a id="_idIndexMarker236">
    </a>
    <span class="koboSpan" id="kobo.573.1">
     an injectable state service in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.574.1">
      your application:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.575.1">
      Add a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.576.1">
       StateArgs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.577.1">
      base record and define the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.578.1">
       SuccessArgs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.579.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.580.1">
       FailureArgs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.581.1">
      state arguments deriving from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.582.1">
       that base:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.583.1">
public abstract record StateArgs;
public record SuccessArgs : StateArgs;
public record FailureArgs : StateArgs;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.584.1">
      Introduce a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.585.1">
       StoreState
      </span>
     </strong>
     <span class="koboSpan" id="kobo.586.1">
      class with an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.587.1">
       event
      </span>
     </strong>
     <span class="koboSpan" id="kobo.588.1">
      delegate that can be subscribed to and a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.589.1">
       Notify()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.590.1">
      method that accepts
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.591.1">
       StateArgs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.592.1">
      and triggers the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.593.1">
        OnChanged
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.594.1">
       event:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.595.1">
public sealed class StoreState
{
    public event Func&lt;StateArgs, Task&gt; OnChanged;
    public Task Notify(StateArgs args)
        =&gt; OnChanged?.Invoke(args);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.596.1">
      Navigate to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.597.1">
       Program
      </span>
     </strong>
     <span class="koboSpan" id="kobo.598.1">
      class and register
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.599.1">
       StoreState
      </span>
     </strong>
     <span class="koboSpan" id="kobo.600.1">
      in the dependency
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.601.1">
       injection container:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.602.1">
builder.Services.AddScoped&lt;StoreState&gt;();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.603.1">
      Create a routable
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.604.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.605.1">
      component that leverages
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.606.1">
       PrerenderDisabled
      </span>
     </strong>
     <span class="koboSpan" id="kobo.607.1">
      render mode and implements the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.608.1">
        IDisposable
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.609.1">
       interface:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.610.1">
@page "/ch05r03"
@rendermode Config.PrerenderDisabled
@implements IDisposable</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.611.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.612.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.613.1">
      component
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.614.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.615.1">
      block, inject
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.616.1">
       StoreState
      </span>
     </strong>
     <span class="koboSpan" id="kobo.617.1">
      and initialize a
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.618.1">
        Message
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.619.1">
       variable:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.620.1">
[Inject] private StoreState State { get; init; }
protected string Message = string.Empty;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.621.1">
      Still in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.622.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.623.1">
      block, implement a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.624.1">
       ReactAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.625.1">
      method to convert
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.626.1">
       StateArgs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.627.1">
      into
     </span>
     <a id="_idIndexMarker237">
     </a>
     <span class="koboSpan" id="kobo.628.1">
      user-friendly
     </span>
     <a id="_idIndexMarker238">
     </a>
     <span class="koboSpan" id="kobo.629.1">
      messages and apply
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.630.1">
       UI changes:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.631.1">
private Task ReactAsync(StateArgs args)
{
    Message = args is SuccessArgs
        ? </span><span class="koboSpan" id="kobo.631.2">"Success"
        : "Failure";
    return InvokeAsync(StateHasChanged);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.632.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.633.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.634.1">
      block, override the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.635.1">
       OnInitialized()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.636.1">
      life cycle method to subscribe the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.637.1">
       ReactAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.638.1">
      method to the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.639.1">
        StoreState
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.640.1">
       event:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.641.1">
protected override void OnInitialized()
    =&gt; State.OnChanged += ReactAsync;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.642.1">
      Lastly, within the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.643.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.644.1">
      block, implement the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.645.1">
       Dispose()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.646.1">
      method as required by
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.647.1">
       IDisposable
      </span>
     </strong>
     <span class="koboSpan" id="kobo.648.1">
      and unsubscribe
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.649.1">
       ReactAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.650.1">
      from the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.651.1">
        StoreState
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.652.1">
       event:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.653.1">
public void Dispose()
    =&gt; State.OnChanged -= ReactAsync;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.654.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.655.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.656.1">
      component’s markup, add two buttons that, upon being clicked, call the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.657.1">
       Notify()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.658.1">
      method with either
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.659.1">
       SuccessArgs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.660.1">
      or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.661.1">
       FailureArgs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.662.1">
      .
     </span>
     <span class="koboSpan" id="kobo.662.2">
      Include a paragraph
     </span>
     <a id="_idIndexMarker239">
     </a>
     <span class="koboSpan" id="kobo.663.1">
      to
     </span>
     <a id="_idIndexMarker240">
     </a>
     <span class="koboSpan" id="kobo.664.1">
      display the current value of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.665.1">
       Message
      </span>
     </strong>
     <span class="koboSpan" id="kobo.666.1">
      variable
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.667.1">
       as well:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.668.1">
&lt;button @onclick="@(() =&gt;
        State.Notify(new SuccessArgs()))"&gt;
    Buy!
</span><span class="koboSpan" id="kobo.668.2">&lt;/button&gt;
&lt;button @onclick="@(() =&gt;
        State.Notify(new FailureArgs()))"&gt;
    Buy!
</span><span class="koboSpan" id="kobo.668.3">&lt;/button&gt;
&lt;p&gt;@Message&lt;/p&gt;</span></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-181">
    <a id="_idTextAnchor181">
    </a>
    <span class="koboSpan" id="kobo.669.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.670.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.671.1">
      step 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.672.1">
     , we define three object types –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.673.1">
      StateArgs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.674.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.675.1">
      SuccessArgs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.676.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.677.1">
      FailureArgs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.678.1">
     – to represent states within our application.
    </span>
    <span class="koboSpan" id="kobo.678.2">
     Leveraging inheritance and having
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.679.1">
      SuccessArgs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.680.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.681.1">
      FailureArgs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.682.1">
     inherit from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.683.1">
      StateArgs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.684.1">
     allows us to maintain simplicity in our state-handling logic.
    </span>
    <span class="koboSpan" id="kobo.684.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.685.1">
      step 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.686.1">
     , we implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.687.1">
      StoreState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.688.1">
     class, which acts as an application state service.
    </span>
    <span class="koboSpan" id="kobo.688.2">
     We expose an event – encapsulating an invocation of an asynchronous method with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.689.1">
      StateArgs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.690.1">
     parameter and a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.691.1">
      Notify()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.692.1">
     method – allowing any component to communicate state changes.
    </span>
    <span class="koboSpan" id="kobo.692.2">
     We’ve effectively encapsulated the complexities of state transitions behind a simple, intuitive interface.
    </span>
    <span class="koboSpan" id="kobo.692.3">
     With
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.693.1">
      StoreState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.694.1">
     ready to go, in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.695.1">
      step 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.696.1">
     , we integrate it into our application’s dependency injection container within the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.697.1">
       Program
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.698.1">
      class.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.699.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.700.1">
      step 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.701.1">
     , we create a routable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.702.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.703.1">
     component to demonstrate the practical use of our application state service.
    </span>
    <span class="koboSpan" id="kobo.703.2">
     We opt for custom
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.704.1">
      PrerenderDisabled
     </span>
    </strong>
    <span class="koboSpan" id="kobo.705.1">
     render mode to avoid potential rendering pitfalls; you learned about that in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.706.1">
      Implementing an in-memory state container
     </span>
    </em>
    <span class="koboSpan" id="kobo.707.1">
     recipe.
    </span>
    <span class="koboSpan" id="kobo.707.2">
     We also declare
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.708.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.709.1">
     to implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.710.1">
      IDisposable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.711.1">
     interface, indicating that there will be a custom cleanup logic to execute.
    </span>
    <span class="koboSpan" id="kobo.711.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.712.1">
      step 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.713.1">
     , we inject
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.714.1">
      StoreState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.715.1">
     as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.716.1">
      State
     </span>
    </strong>
    <span class="koboSpan" id="kobo.717.1">
     and initialize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.718.1">
      Message
     </span>
    </strong>
    <span class="koboSpan" id="kobo.719.1">
     variable, where we will capture user-friendly snapshots of the application’s state for display.
    </span>
    <span class="koboSpan" id="kobo.719.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.720.1">
      step 6
     </span>
    </em>
    <span class="koboSpan" id="kobo.721.1">
     , we implement a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.722.1">
      ReactAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.723.1">
     method that acts as a dynamic resolver of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.724.1">
      StateArgs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.725.1">
     .
    </span>
    <span class="koboSpan" id="kobo.725.2">
     We update the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.726.1">
      Message
     </span>
    </strong>
    <span class="koboSpan" id="kobo.727.1">
     variable based on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.728.1">
      args
     </span>
    </strong>
    <span class="koboSpan" id="kobo.729.1">
     type, pivoting between success and failure states.
    </span>
    <span class="koboSpan" id="kobo.729.2">
     Afterward, we invoke
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.730.1">
      StateHasChanged()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.731.1">
     to notify that the UI state has changed, but we wrap it inside the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.732.1">
      InvokeAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.733.1">
     method to ensure that our UI remains responsive
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.734.1">
      and thread-safe.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.735.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.736.1">
      step 7
     </span>
    </em>
    <span class="koboSpan" id="kobo.737.1">
     , we enable the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.738.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.739.1">
     component to listen to state changes broadcasted by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.740.1">
      StoreState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.741.1">
     .
    </span>
    <span class="koboSpan" id="kobo.741.2">
     We override the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.742.1">
      OnInitialized()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.743.1">
     method and subscribe our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.744.1">
      ReactAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.745.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.746.1">
      State.OnChanged
     </span>
    </strong>
    <span class="koboSpan" id="kobo.747.1">
     .
    </span>
    <span class="koboSpan" id="kobo.747.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.748.1">
      step 8
     </span>
    </em>
    <span class="koboSpan" id="kobo.749.1">
     , we implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.750.1">
      Dispose()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.751.1">
     method, enforced by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.752.1">
      IDisposable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.753.1">
     interface.
    </span>
    <span class="koboSpan" id="kobo.753.2">
     Here, we unsubscribe
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.754.1">
      ReactAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.755.1">
     from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.756.1">
      State.OnChanged
     </span>
    </strong>
    <span class="koboSpan" id="kobo.757.1">
     to prevent memory leaks and guarantee graceful
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.758.1">
      component disposal.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.759.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.760.1">
      step 9
     </span>
    </em>
    <span class="koboSpan" id="kobo.761.1">
     , we put
    </span>
    <a id="_idIndexMarker241">
    </a>
    <span class="koboSpan" id="kobo.762.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.763.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.764.1">
     markup
    </span>
    <a id="_idIndexMarker242">
    </a>
    <span class="koboSpan" id="kobo.765.1">
     in place.
    </span>
    <span class="koboSpan" id="kobo.765.2">
     We add two buttons – one signals success while the other signals failure.
    </span>
    <span class="koboSpan" id="kobo.765.3">
     Both utilize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.766.1">
      State.Notify()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.767.1">
     method to orchestrate state changes.
    </span>
    <span class="koboSpan" id="kobo.767.2">
     Below these buttons, we add paragraph tags and render
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.768.1">
      Message
     </span>
    </strong>
    <span class="koboSpan" id="kobo.769.1">
     to visualize the impact of our button’s interactions.
    </span>
    <span class="koboSpan" id="kobo.769.2">
     To keep the example simple, we’re triggering state changes with buttons within the same component that listens to those state changes.
    </span>
    <span class="koboSpan" id="kobo.769.3">
     However, you could place these buttons in any component across the application, and our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.770.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.771.1">
     will still accurately receive and react to the state notifications.
    </span>
    <span class="koboSpan" id="kobo.771.2">
     That’s the true strength and agility of having an injectable application
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.772.1">
      state service.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-182">
    <a id="_idTextAnchor182">
    </a>
    <span class="koboSpan" id="kobo.773.1">
     See also
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.774.1">
     In this recipe, we’ve
    </span>
    <a id="_idIndexMarker243">
    </a>
    <span class="koboSpan" id="kobo.775.1">
     touched on the topic of
    </span>
    <a id="_idIndexMarker244">
    </a>
    <span class="koboSpan" id="kobo.776.1">
     events in .NET.
    </span>
    <span class="koboSpan" id="kobo.776.2">
     We won’t dive deep into the .NET fundamentals in that book, but if you’re curious to learn more, check out the official Microsoft Learn
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.777.1">
      resources:
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.778.1">
       https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.779.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-183">
    <a id="_idTextAnchor183">
    </a>
    <span class="koboSpan" id="kobo.780.1">
     Invoking state changes from anywhere
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.781.1">
     In this recipe, we’re
    </span>
    <a id="_idIndexMarker245">
    </a>
    <span class="koboSpan" id="kobo.782.1">
     exploring injecting state service globally in your Blazor application.
    </span>
    <span class="koboSpan" id="kobo.782.2">
     State service can cover anything from a user’s app personalization to user session details or processing indicators.
    </span>
    <span class="koboSpan" id="kobo.782.3">
     In our example, we’re implementing an overlay covering our interface during a long-running task.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.783.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.784.1">
     serves as
    </span>
    <a id="_idIndexMarker246">
    </a>
    <span class="koboSpan" id="kobo.785.1">
     a visual cue to users, signaling that their request is being executed and preventing any user interactions that could disrupt the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.786.1">
      ongoing process.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-184">
    <a id="_idTextAnchor184">
    </a>
    <span class="koboSpan" id="kobo.787.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.788.1">
     Before we explore the strategy to globally inject state service and trigger an overlay, do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.789.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.790.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.791.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.792.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.793.1">
       Recipe04
      </span>
     </strong>
     <span class="koboSpan" id="kobo.794.1">
      directory – this will be your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.795.1">
       working directory
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.796.1">
      Copy
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.797.1">
       Api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.798.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.799.1">
       Event
      </span>
     </strong>
     <span class="koboSpan" id="kobo.800.1">
      files from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.801.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.802.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.803.1">
       Data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.804.1">
      directory in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.805.1">
       GitHub repository
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.806.1">
      Copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.807.1">
       Overlay.css
      </span>
     </strong>
     <span class="koboSpan" id="kobo.808.1">
      file from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.809.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.810.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.811.1">
       Data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.812.1">
      directory in the GitHub repository and rename it
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.813.1">
       Overlay.razor.css
      </span>
     </strong>
     <span class="koboSpan" id="kobo.814.1">
      ; after renaming, your IDE might display a compilation error – we will explain that behavior and fix the error by the end of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.815.1">
       this recipe
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.816.1">
      Register the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.817.1">
       Api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.818.1">
      service as scoped in the application’s dependency injection container (check out the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.819.1">
       Having a bookmarkable state
      </span>
     </em>
     <span class="koboSpan" id="kobo.820.1">
      recipe to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.821.1">
       see how)
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-185">
    <a id="_idTextAnchor185">
    </a>
    <span class="koboSpan" id="kobo.822.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.823.1">
     Follow these instructions to add a globally injected overlay
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.824.1">
      state handler:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.825.1">
      Create an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.826.1">
       OverlayState
      </span>
     </strong>
     <span class="koboSpan" id="kobo.827.1">
      class with an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.828.1">
       OnChanged
      </span>
     </strong>
     <span class="koboSpan" id="kobo.829.1">
      event for subscribers to listen to and an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.830.1">
       ExecuteAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.831.1">
      method that triggers
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.832.1">
       OnChanged
      </span>
     </strong>
     <span class="koboSpan" id="kobo.833.1">
      , both before and after executing any job passed
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.834.1">
       to it:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.835.1">
public class OverlayState
{
    public event Func&lt;bool, Task&gt; OnChanged;
    public async Task ExecuteAsync(Func&lt;Task&gt; job)
    {
        await OnChanged.Invoke(true);
        await job.Invoke();
        await OnChanged.Invoke(false);
    }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.836.1">
      Navigate to
     </span>
     <a id="_idIndexMarker247">
     </a>
     <span class="koboSpan" id="kobo.837.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.838.1">
       Program
      </span>
     </strong>
     <span class="koboSpan" id="kobo.839.1">
      class and register
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.840.1">
       OverlayState
      </span>
     </strong>
     <span class="koboSpan" id="kobo.841.1">
      in the dependency
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.842.1">
       injection container.
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.843.1">
builder.Services.AddScoped&lt;OverlayState&gt;();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.844.1">
      Navigate to the main
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.845.1">
       _Imports.razor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.846.1">
      file at the project level and inject the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.847.1">
       OverlayState
      </span>
     </strong>
     <span class="koboSpan" id="kobo.848.1">
      , making it available across all components.
     </span>
     <span class="koboSpan" id="kobo.848.2">
      You might need to reference the missing assembly
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.849.1">
       as well:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.850.1">
@inject
    BlazorCookbook.App.Client.Chapters.Chapter05
    .Recipe04.OverlayState OverlayState</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.851.1">
      Create an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.852.1">
       Overlay
      </span>
     </strong>
     <span class="koboSpan" id="kobo.853.1">
      component that implements the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.854.1">
        IDisposable
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.855.1">
       interface:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.856.1">
@implements IDisposable</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.857.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.858.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.859.1">
      block of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.860.1">
       Overlay
      </span>
     </strong>
     <span class="koboSpan" id="kobo.861.1">
      , initialize an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.862.1">
       IsVisible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.863.1">
      variable and define a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.864.1">
       ReactAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.865.1">
      method to update
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.866.1">
       IsVisible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.867.1">
      , based on
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.868.1">
       state changes:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.869.1">
protected bool IsVisible;
public Task ReactAsync(bool isVisible)
{
    IsVisible = isVisible;
    return InvokeAsync(StateHasChanged);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.870.1">
      Override the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.871.1">
       OnInitialized()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.872.1">
      life cycle method in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.873.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.874.1">
      block of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.875.1">
       Overlay
      </span>
     </strong>
     <span class="koboSpan" id="kobo.876.1">
      , and
     </span>
     <a id="_idIndexMarker248">
     </a>
     <span class="koboSpan" id="kobo.877.1">
      subscribe the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.878.1">
       ReactAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.879.1">
      method to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.880.1">
       OverlayState.OnChanged
      </span>
     </strong>
     <span class="koboSpan" id="kobo.881.1">
      event for state
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.882.1">
       change notifications:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.883.1">
protected override void OnInitialized()
    =&gt; OverlayState.OnChanged += ReactAsync;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.884.1">
      Still within the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.885.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.886.1">
      block, implement a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.887.1">
       Dispose()
      </span>
     </strong>
     <strong class="bold">
      <span class="koboSpan" id="kobo.888.1">
       method to unsubscribe
      </span>
     </strong>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.889.1">
       ReactAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.890.1">
      from the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.891.1">
        OverlayState.OnChanged
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.892.1">
       event:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.893.1">
public void Dispose()
    =&gt; OverlayState.OnChanged -= ReactAsync;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.894.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.895.1">
       Overlay
      </span>
     </strong>
     <span class="koboSpan" id="kobo.896.1">
      markup, include an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.897.1">
       &lt;overlay&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.898.1">
      section that visually represents the overlay, and use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.899.1">
       IsVisible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.900.1">
      variable to toggle the visibility of this
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.901.1">
       section with:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.902.1">
&lt;overlay class="@(IsVisible ? </span><span class="koboSpan" id="kobo.902.2">"visible" : "")"&gt;
    Loading...
</span><span class="koboSpan" id="kobo.902.3">&lt;/overlay&gt;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.903.1">
      Create a routable
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.904.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.905.1">
      component that renders in
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.906.1">
        InteractiveWebAssembly
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.907.1">
       mode:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.908.1">
@page "/ch05r04"
@rendermode InteractiveWebAssembly</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.909.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.910.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.911.1">
      component’s
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.912.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.913.1">
      block, inject the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.914.1">
       Api
      </span>
     </strong>
     <span class="koboSpan" id="kobo.915.1">
      service, and implement a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.916.1">
       SyncAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.917.1">
      method to engage the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.918.1">
       OverlayState
      </span>
     </strong>
     <span class="koboSpan" id="kobo.919.1">
      for managing overlay visibility while executing the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.920.1">
       Api
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.921.1">
       service request:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.922.1">
[Inject] private Api Api { get; init; }
private Task SyncAsync()
    =&gt; OverlayState.ExecuteAsync(()
        =&gt; Api.SynchronizeAsync(default));</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.923.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.924.1">
       Store
      </span>
     </strong>
     <span class="koboSpan" id="kobo.925.1">
      markup, embed the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.926.1">
       Overlay
      </span>
     </strong>
     <span class="koboSpan" id="kobo.927.1">
      component, and include a button to trigger
     </span>
     <a id="_idIndexMarker249">
     </a>
     <span class="koboSpan" id="kobo.928.1">
      the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.929.1">
        SyncAsync()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.930.1">
       method:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.931.1">
&lt;Overlay /&gt;
&lt;button @onclick="@SyncAsync"&gt;
    Synchronize data
&lt;/button&gt;</span></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-186">
    <a id="_idTextAnchor186">
    </a>
    <span class="koboSpan" id="kobo.932.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.933.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.934.1">
      step 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.935.1">
     , we create an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.936.1">
      OverlayState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.937.1">
     service.
    </span>
    <span class="koboSpan" id="kobo.937.2">
     As we expect our overlay to have a binary nature – visible or hidden – we build a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.938.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.939.1">
     -based logic.
    </span>
    <span class="koboSpan" id="kobo.939.2">
     We add a subscribable event of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.940.1">
      Func&lt;bool, Task&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.941.1">
     and implement an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.942.1">
      ExecuteAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.943.1">
     method, which accepts an
    </span>
    <a id="_idIndexMarker250">
    </a>
    <span class="koboSpan" id="kobo.944.1">
     asynchronous
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.945.1">
      job
     </span>
    </strong>
    <span class="koboSpan" id="kobo.946.1">
     as a parameter.
    </span>
    <span class="koboSpan" id="kobo.946.2">
     Within
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.947.1">
      ExecuteAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.948.1">
     , we toggle the overlay’s visibility by invoking the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.949.1">
      OnChanged
     </span>
    </strong>
    <span class="koboSpan" id="kobo.950.1">
     event before and after the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.951.1">
      job
     </span>
    </strong>
    <span class="koboSpan" id="kobo.952.1">
     execution, effectively showing the overlay during processing and hiding it upon completion.
    </span>
    <span class="koboSpan" id="kobo.952.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.953.1">
      step 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.954.1">
     , we integrate
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.955.1">
      OverlayState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.956.1">
     into the dependency injection container, and in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.957.1">
      step 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.958.1">
     , we achieve
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.959.1">
      OverlayState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.960.1">
     global accessibility by injecting it into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.961.1">
      _Imports.razor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.962.1">
     file.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.963.1">
      _Imports.razor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.964.1">
     files in a Blazor application act as encapsulators of adding namespaces and directives, enabling them to be accessible across sibling or nested Razor components without declaring them explicitly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.965.1">
      in each.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.966.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.967.1">
      step 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.968.1">
     , we create an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.969.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.970.1">
     component, interacting with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.971.1">
      OverlayState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.972.1">
     .
    </span>
    <span class="koboSpan" id="kobo.972.2">
     As we will implement event-driven logic in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.973.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.974.1">
     , we declare it to implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.975.1">
      IDisposable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.976.1">
     interface.
    </span>
    <span class="koboSpan" id="kobo.976.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.977.1">
      step 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.978.1">
     , we initiate an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.979.1">
      IsVisible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.980.1">
     variable to track the overlay’s visibility state and a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.981.1">
      ReactAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.982.1">
     method to respond to those state changes.
    </span>
    <span class="koboSpan" id="kobo.982.2">
     Now, we can leverage the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.983.1">
      ReactAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.984.1">
     method to listen to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.985.1">
      OverlayState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.986.1">
     event.
    </span>
    <span class="koboSpan" id="kobo.986.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.987.1">
      step 6
     </span>
    </em>
    <span class="koboSpan" id="kobo.988.1">
     , we override the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.989.1">
      OnInitialized()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.990.1">
     life cycle method to subscribe to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.991.1">
      OverlayState.OnChanged
     </span>
    </strong>
    <span class="koboSpan" id="kobo.992.1">
     event with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.993.1">
      ReactAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.994.1">
     .
    </span>
    <span class="koboSpan" id="kobo.994.2">
     Now, Blazor will communicate any changes in the overlay state to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.995.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.996.1">
     UI.
    </span>
    <span class="koboSpan" id="kobo.996.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.997.1">
      step 7
     </span>
    </em>
    <span class="koboSpan" id="kobo.998.1">
     , we address potential memory leaks and unsubscribe from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.999.1">
      OnChanged
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1000.1">
     event within the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1001.1">
      Dispose()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1002.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.1002.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1003.1">
      step 8
     </span>
    </em>
    <span class="koboSpan" id="kobo.1004.1">
     , we implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1005.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1006.1">
     markup.
    </span>
    <span class="koboSpan" id="kobo.1006.2">
     We introduce a custom
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1007.1">
      &lt;overlay&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1008.1">
     tag to avoid conflicts with other, standard DOM elements.
    </span>
    <span class="koboSpan" id="kobo.1008.2">
     We use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1009.1">
      IsVisible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1010.1">
     flag to toggle the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1011.1">
      visible
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1012.1">
     class, deciding whether an overlay is currently visible.
    </span>
    <span class="koboSpan" id="kobo.1012.2">
     Blazor will automatically associate the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1013.1">
      Overlay.razor.css
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1014.1">
     collocated styles (which you’ve copied from the sample directory) and scope that styling to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1015.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1016.1">
     component we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1017.1">
      just implemented.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1018.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1019.1">
      step 9
     </span>
    </em>
    <span class="koboSpan" id="kobo.1020.1">
     , we shift to showcasing the practical application of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1021.1">
      OverlayState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1022.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1023.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1024.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1024.2">
     We create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1025.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1026.1">
     component and set it to render in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1027.1">
      InteractiveWebAssembly
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1028.1">
     mode.
    </span>
    <span class="koboSpan" id="kobo.1028.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1029.1">
      step 10
     </span>
    </em>
    <span class="koboSpan" id="kobo.1030.1">
     , we inject the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1031.1">
      Api
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1032.1">
     service and implement a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1033.1">
      SyncAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1034.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.1034.2">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1035.1">
      SyncAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1036.1">
     method, we leverage
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1037.1">
      OverlayState.ExecuteAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1038.1">
     to encapsulate the execution of potentially time-consuming operations and display a visual cue in the form of an overlay, ensuring that the user is aware that their request is processing.
    </span>
    <span class="koboSpan" id="kobo.1038.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1039.1">
      step 11
     </span>
    </em>
    <span class="koboSpan" id="kobo.1040.1">
     , we introduce the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1041.1">
      Store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1042.1">
     markup by
    </span>
    <a id="_idIndexMarker251">
    </a>
    <span class="koboSpan" id="kobo.1043.1">
     adding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1044.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1045.1">
     component and a trigger button for the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1046.1">
       SyncAsync()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1047.1">
      method.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-187">
    <a id="_idTextAnchor187">
    </a>
    <span class="koboSpan" id="kobo.1048.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1049.1">
     As we’ve injected the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1050.1">
      OverlayState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1051.1">
     globally across all components, we can decouple the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1052.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1053.1">
     presence from any component state.
    </span>
    <span class="koboSpan" id="kobo.1053.2">
     We can achieve that by incorporating the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1054.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1055.1">
     tag within the application’s layout file.
    </span>
    <span class="koboSpan" id="kobo.1055.2">
     With that, the overlay functionality is omnipresent – you can leverage the overlay from any application area with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1056.1">
      minimal fuss.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1057.1">
     Here’s what the layout could
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1058.1">
      look like:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1059.1">
@inherits LayoutComponentBase
&lt;Overlay /&gt;
&lt;main&gt;
    @Body
&lt;/main&gt;</span></pre>
   <h1 id="_idParaDest-188">
    <a id="_idTextAnchor188">
    </a>
    <span class="koboSpan" id="kobo.1060.1">
     Persisting state
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1061.1">
     In modern web
    </span>
    <a id="_idIndexMarker252">
    </a>
    <span class="koboSpan" id="kobo.1062.1">
     development, the ability to persist application and session states is no longer a luxury but a necessity.
    </span>
    <span class="koboSpan" id="kobo.1062.2">
     Whether it’s to enhance user experience, safeguard user progress, or maintain preferences across sessions, state persistence plays a pivotal role in creating seamless and engaging digital experiences.
    </span>
    <span class="koboSpan" id="kobo.1062.3">
     Consider the convenience of saving local application configurations on the client side, such as a user’s preference for dark mode or their choice to receive push notifications.
    </span>
    <span class="koboSpan" id="kobo.1062.4">
     Similarly, persisting parts of the session state can be crucial for ensuring that users don’t lose valuable progress due to unexpected disruptions – imagine the frustration it would cause.
    </span>
    <span class="koboSpan" id="kobo.1062.5">
     These small touches can significantly boost the usability and personalization of any application.
    </span>
    <span class="koboSpan" id="kobo.1062.6">
     Let’s see how to persist state in your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1063.1">
      Blazor app.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1064.1">
     Let’s implement an option to switch between light and dark modes and persist a proper setting flag in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1065.1">
      user’s browser.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-189">
    <a id="_idTextAnchor189">
    </a>
    <span class="koboSpan" id="kobo.1066.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1067.1">
     Before implementing state persistence, do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1068.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1069.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1070.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1071.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1072.1">
       Recipe05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1073.1">
      directory – this will be your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1074.1">
       working directory
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-190">
    <a id="_idTextAnchor190">
    </a>
    <span class="koboSpan" id="kobo.1075.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1076.1">
     Follow these steps to implement
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1077.1">
      state persistence:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1078.1">
      Add an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1079.1">
       {ASSEMBLY_NAME}.lib.module.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1080.1">
      file within the wwwroot directory of your client application, and define a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1081.1">
       browserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1082.1">
      object with a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1083.1">
       set
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1084.1">
      function that is capable of storing a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1085.1">
       key
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1086.1">
      -
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1087.1">
       value
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1088.1">
      pair in either session storage or local storage, based on a
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1089.1">
        type
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1090.1">
       parameter:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1091.1">
window.browserStorage = {
    set: function (type, key, value) {
        if (type === 'sessionStorage') {
            sessionStorage.setItem(key, value);
        }
        if (type == 'localStorage') {
            localStorage.setItem(key, value);
        }
    }
};</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1092.1">
      Create a generic, abstract
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1093.1">
       StorageValue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1094.1">
      class with the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1095.1">
       Key
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1096.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1097.1">
       Value
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1098.1">
      properties, aligning
     </span>
     <a id="_idIndexMarker253">
     </a>
     <span class="koboSpan" id="kobo.1099.1">
      with the parameters expected by the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1100.1">
        browserStorage.set
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1101.1">
       function:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1102.1">
public abstract record StorageValue&lt;T&gt;
{
    public string Key { get; init; }
    public T Value { get; init; }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1103.1">
      Create
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1104.1">
       LocalStorageValue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1105.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1106.1">
       SessionStorageValue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1107.1">
      records – specific implementations of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1108.1">
       StorageValue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1109.1">
      for different browser
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1110.1">
       storage types:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1111.1">
public record LocalStorageValue&lt;T&gt; : StorageValue&lt;T&gt;;
public record SessionStorageValue&lt;T&gt; :
    StorageValue&lt;T&gt;;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1112.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1113.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1114.1">
      class within your application, and inject the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1115.1">
       IJSRuntime
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1116.1">
      service available in Blazor
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1117.1">
       by default:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1118.1">
public class BrowserStorage
{
    private readonly IJSRuntime _js;
    public BrowserStorage(IJSRuntime js)
    {
        _js = js;
    }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1119.1">
      Inside the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1120.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1121.1">
      , define
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1122.1">
       const
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1123.1">
      values to ensure the consistency of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1124.1">
       the logic:
      </span>
     </span>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.1125.1">
         _setFunc
        </span>
       </strong>
       <span class="koboSpan" id="kobo.1126.1">
        to store the JavaScript
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.1127.1">
         function name
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.1128.1">
         _local
        </span>
       </strong>
       <span class="koboSpan" id="kobo.1129.1">
        and
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.1130.1">
         _session
        </span>
       </strong>
       <span class="koboSpan" id="kobo.1131.1">
        to reference the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.1132.1">
         storage types:
        </span>
       </span>
       <pre class="source-code"><span class="koboSpan" id="kobo.1133.1">
private const string
    _setFunc = "browserStorage.set",
    _local = "localStorage",
    _session = "sessionStorage";</span></pre>
      </li>
     </ul>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1134.1">
      Still inside
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1135.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1136.1">
      , implement a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1137.1">
       PersistAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1138.1">
      method, accepting a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1139.1">
       StorageValue&lt;T&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1140.1">
      parameter.
     </span>
     <span class="koboSpan" id="kobo.1140.2">
      Utilize
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1141.1">
       JsonSerializer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1142.1">
      to convert the
     </span>
     <a id="_idIndexMarker254">
     </a>
     <span class="koboSpan" id="kobo.1143.1">
      value to JSON and determine the appropriate storage location, before invoking the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1144.1">
       browserStorage.set
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1145.1">
       function:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1146.1">
public ValueTask PersistAsync&lt;T&gt;(
    StorageValue&lt;T&gt; @object)
{
    var json = JsonSerializer
        .Serialize(@object.Value);
    var storage = @object is LocalStorageValue&lt;T&gt;
        ? </span><span class="koboSpan" id="kobo.1146.2">_local : _session;
    return _js.InvokeVoidAsync(_setFunc,
        storage, @object.Key, json);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1147.1">
      Navigate to the application’s
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1148.1">
       Program
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1149.1">
      class and register the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1150.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1151.1">
      service in the dependency
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1152.1">
       injection container:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1153.1">
builder.Services.AddTransient&lt;BrowserStorage&gt;();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1154.1">
      Create a routable
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1155.1">
       Settings
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1156.1">
      component that renders in
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1157.1">
        InteractiveWebAssembly
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1158.1">
       mode:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1159.1">
@page "/ch05r05"
@rendermode InteractiveWebAssembly</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1160.1">
      Within the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1161.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1162.1">
      block of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1163.1">
       Settings
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1164.1">
      , inject
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1165.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1166.1">
      and declare constant
     </span>
     <a id="_idIndexMarker255">
     </a>
     <span class="koboSpan" id="kobo.1167.1">
      keys dedicated to managing view
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1168.1">
       mode persistence:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1169.1">
[Inject] private BrowserStorage Storage { get; init; }
private const string _key = "viewMode",
                     _light = "lightMode",
                     _dark = "darkMode";</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1170.1">
      Still in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1171.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1172.1">
      block, implement a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1173.1">
       SetViewModeAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1174.1">
      method that takes a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1175.1">
       mode
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1176.1">
      parameter, encapsulates it within a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1177.1">
       LocalStorageValue&lt;string&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1178.1">
      object, and persists it using the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1179.1">
        BrowserStorage.PersistAsync()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1180.1">
       method:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1181.1">
public async Task SetViewModeAsync(string mode)
{
    var value = new LocalStorageValue&lt;string&gt;
    {
        Key = _key,
        Value = mode
    };
    await Storage.PersistAsync(value);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1182.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1183.1">
       Settings
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1184.1">
      component’s markup, introduce two buttons that utilize the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1185.1">
       SetViewModeAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1186.1">
      method to adjust the application’s view mode – one to set light mode and the other for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1187.1">
       dark mode:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1188.1">
&lt;button @onclick="@(() =&gt; SetViewModeAsync(_light))"&gt;
    Turn the light on!
</span><span class="koboSpan" id="kobo.1188.2">&lt;/button&gt;
&lt;button @onclick="@(() =&gt; SetViewModeAsync(_dark))"&gt;
    Turn the light off!
</span><span class="koboSpan" id="kobo.1188.3">&lt;/button&gt;</span></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-191">
    <a id="_idTextAnchor191">
    </a>
    <span class="koboSpan" id="kobo.1189.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1190.1">
     In this recipe, we
    </span>
    <a id="_idIndexMarker256">
    </a>
    <span class="koboSpan" id="kobo.1191.1">
     will require a piece of custom
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1192.1">
      JavaScript
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1193.1">
     to lay
    </span>
    <a id="_idIndexMarker257">
    </a>
    <span class="koboSpan" id="kobo.1194.1">
     the foundation of our process.
    </span>
    <span class="koboSpan" id="kobo.1194.2">
     We utilize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1195.1">
      {ASSEMBLY_NAME}.lib.module.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1196.1">
     file, which resides in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1197.1">
      wwwroot
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1198.1">
     folder of our client-side project; if you don’t have it yet, create one.
    </span>
    <span class="koboSpan" id="kobo.1198.2">
     Blazor will automatically embed it, so explicit registration is not required.
    </span>
    <span class="koboSpan" id="kobo.1198.3">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1199.1">
      step 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.1200.1">
     , we navigate to that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1201.1">
      .js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1202.1">
     file and define a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1203.1">
      browserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1204.1">
     API.
    </span>
    <span class="koboSpan" id="kobo.1204.2">
     For now, we implement just a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1205.1">
      set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1206.1">
     function that accepts the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1207.1">
      type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1208.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1209.1">
      key
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1210.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1211.1">
      value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1212.1">
     parameters, and depending on the specified
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1213.1">
      type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1214.1">
     , it invokes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1215.1">
      setItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1216.1">
     function of either the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1217.1">
      sessionStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1218.1">
     or
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1219.1">
       localStorage
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1220.1">
      instance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1221.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1222.1">
      step 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.1223.1">
     , we create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1224.1">
      StorageValue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1225.1">
     generic record with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1226.1">
      Key
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1227.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1228.1">
      Value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1229.1">
     properties.
    </span>
    <span class="koboSpan" id="kobo.1229.2">
     By marking this record as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1230.1">
      abstract
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1231.1">
     , we signal our intention to use it as a foundation for more specific storage values.
    </span>
    <span class="koboSpan" id="kobo.1231.2">
     And we implement just that in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1232.1">
      step 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.1233.1">
     , where we add
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1234.1">
      LocalStorageValue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1235.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1236.1">
      SessionStorageValue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1237.1">
     , both inheriting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1238.1">
      from
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1239.1">
       StorageValue
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1240.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1241.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1242.1">
      step 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.1243.1">
     , we initiate the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1244.1">
      BrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1245.1">
     service.
    </span>
    <span class="koboSpan" id="kobo.1245.2">
     As we need to call a JavaScript function from our C# code, we inject Blazor’s baked-in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1246.1">
      IJSRuntime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1247.1">
     into our service.
    </span>
    <span class="koboSpan" id="kobo.1247.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1248.1">
      step 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.1249.1">
     , we introduce a few
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1250.1">
      const
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1251.1">
     values to anchor our persistence logic.
    </span>
    <span class="koboSpan" id="kobo.1251.2">
     With
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1252.1">
      _setFunc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1253.1">
     , we encapsulate the naming of the JavaScript function we want to call, while
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1254.1">
      _local
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1255.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1256.1">
      _session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1257.1">
     identify the two available browser storage types.
    </span>
    <span class="koboSpan" id="kobo.1257.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1258.1">
      step 6
     </span>
    </em>
    <span class="koboSpan" id="kobo.1259.1">
     , we finalize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1260.1">
      BrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1261.1">
     implementation with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1262.1">
      PersistAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1263.1">
     generic method.
    </span>
    <span class="koboSpan" id="kobo.1263.2">
     However, browser storage allows us to store
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1264.1">
      string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1265.1">
     types only.
    </span>
    <span class="koboSpan" id="kobo.1265.2">
     We address that constraint by leveraging the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1266.1">
      JsonSerializer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1267.1">
     to transform our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1268.1">
      value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1269.1">
     object into
    </span>
    <a id="_idIndexMarker258">
    </a>
    <span class="koboSpan" id="kobo.1270.1">
     a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1271.1">
      JSON
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1272.1">
     format.
    </span>
    <span class="koboSpan" id="kobo.1272.2">
     Then, using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1273.1">
      is
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1274.1">
     operator and our constant values, we resolve the appropriate browser storage type.
    </span>
    <span class="koboSpan" id="kobo.1274.2">
     Having all the required payload, we end the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1275.1">
      PersistAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1276.1">
     logic by delegating work to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1277.1">
      browserStorage.set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1278.1">
     function, with the help of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1279.1">
      IJSRuntime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1280.1">
     reference and its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1281.1">
      InvokeVoidAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1282.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.1282.2">
     Now, we need to make our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1283.1">
      BrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1284.1">
     available for components.
    </span>
    <span class="koboSpan" id="kobo.1284.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1285.1">
      step 7
     </span>
    </em>
    <span class="koboSpan" id="kobo.1286.1">
     , we navigate to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1287.1">
      Program
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1288.1">
     class and register
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1289.1">
      BrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1290.1">
     within the dependency injection container.
    </span>
    <span class="koboSpan" id="kobo.1290.2">
     Given the stateless nature of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1291.1">
      BrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1292.1">
     , we opt for a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1293.1">
      Transient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1294.1">
     lifetime to avoid unnecessary
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1295.1">
      memory use.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1296.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1297.1">
      step 8
     </span>
    </em>
    <span class="koboSpan" id="kobo.1298.1">
     , we create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1299.1">
      Settings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1300.1">
     component
    </span>
    <a id="_idIndexMarker259">
    </a>
    <span class="koboSpan" id="kobo.1301.1">
     and set it to render in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1302.1">
      InteractiveWebAssembly
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1303.1">
     mode, ensuring the component’s interactivity.
    </span>
    <span class="koboSpan" id="kobo.1303.2">
     Then, in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1304.1">
      step 9
     </span>
    </em>
    <span class="koboSpan" id="kobo.1305.1">
     , we inject
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1306.1">
      BrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1307.1">
     into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1308.1">
      Settings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1309.1">
     and declare a few constant variables –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1310.1">
      _key
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1311.1">
     , which holds the storage value key, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1312.1">
      _light
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1313.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1314.1">
      _dark
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1315.1">
     , which outline the available view modes.
    </span>
    <span class="koboSpan" id="kobo.1315.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1316.1">
      step 10
     </span>
    </em>
    <span class="koboSpan" id="kobo.1317.1">
     , we implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1318.1">
      SetViewModeAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1319.1">
     method, where we initialize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1320.1">
      LocalStorageValue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1321.1">
     variable with our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1322.1">
      _key
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1323.1">
     and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1324.1">
      mode
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1325.1">
     parameter and invoke the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1326.1">
      PersistAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1327.1">
     method of the injected
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1328.1">
      BrowserStore
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1329.1">
     service.
    </span>
    <span class="koboSpan" id="kobo.1329.2">
     To wrap it up, in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1330.1">
      step 11
     </span>
    </em>
    <span class="koboSpan" id="kobo.1331.1">
     , we add two buttons to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1332.1">
      Settings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1333.1">
     component markup.
    </span>
    <span class="koboSpan" id="kobo.1333.2">
     With these buttons, users can invoke the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1334.1">
      SetViewModeAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1335.1">
     method and set the selected view mode in the browser’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1336.1">
      local storage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1337.1">
     Steps may vary a little between browsers, but here’s how you can peak the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1338.1">
      viewMode
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1339.1">
     key value with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1340.1">
      Chrome DevTools:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer022">
     <span class="koboSpan" id="kobo.1341.1">
      <img alt="Figure 5.1: Peaking the value persisted in a browser’s local storage with Chrome DevTools" src="image/Figure_5.1_B22020.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1342.1">
     Figure 5.1: Peaking the value persisted in a browser’s local storage with Chrome DevTools
    </span>
   </p>
   <h2 id="_idParaDest-192">
    <a id="_idTextAnchor192">
    </a>
    <span class="koboSpan" id="kobo.1343.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1344.1">
     We’ve developed a
    </span>
    <a id="_idIndexMarker260">
    </a>
    <span class="koboSpan" id="kobo.1345.1">
     custom JavaScript function to enable access
    </span>
    <a id="_idIndexMarker261">
    </a>
    <span class="koboSpan" id="kobo.1346.1">
     to a browser’s storage, as this implementation remains functional across both server and client-side scenarios, offering broad compatibility and flexibility.
    </span>
    <span class="koboSpan" id="kobo.1346.2">
     When integrating JavaScript into Blazor applications, you must remember that services depending on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1347.1">
      IJSRuntime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1348.1">
     cannot be registered as singletons.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1349.1">
      IJSRuntime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1350.1">
     requires access to each user’s browser session, which makes it architecturally incompatible with the singleton initialization pattern and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1351.1">
      lifetime model.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1352.1">
     However, for projects strictly confined to server-side Blazor, you should consider leveraging the built-in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1353.1">
      ProtectedBrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1354.1">
     API.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1355.1">
      ProtectedBrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1356.1">
     is a Blazor-native mechanism that enables browser storage access with a data encryption layer that doesn’t require custom JavaScript
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1357.1">
      at all.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-193">
    <a id="_idTextAnchor193">
    </a>
    <span class="koboSpan" id="kobo.1358.1">
     Resolving persisted state
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1359.1">
     In the previous
    </span>
    <a id="_idIndexMarker262">
    </a>
    <span class="koboSpan" id="kobo.1360.1">
     recipe, you explored persisting application state within a browser’s storage.
    </span>
    <span class="koboSpan" id="kobo.1360.2">
     Building upon this foundation, in this recipe, we’ll focus on an equally crucial aspect – restoring that persisted state.
    </span>
    <span class="koboSpan" id="kobo.1360.3">
     That functionality is invaluable when dealing with user-specific local application personalization, such as the preference between dark or light mode or the consent to receive push notifications.
    </span>
    <span class="koboSpan" id="kobo.1360.4">
     With state persistence and resolution, you offer users the convenience of rejoining their sessions exactly where they left them.
    </span>
    <span class="koboSpan" id="kobo.1360.5">
     This continuity is fundamental in crafting a user-centric application and offering a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1361.1">
      personalized experience.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1362.1">
     With the light or dark mode persisted in the last recipe, let’s implement an option to resolve a persisted view mode value when a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1363.1">
      component renders.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-194">
    <a id="_idTextAnchor194">
    </a>
    <span class="koboSpan" id="kobo.1364.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1365.1">
     Before you start resolving persisted state, do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1366.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1367.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1368.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1369.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1370.1">
       Recipe06
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1371.1">
      directory – this will be your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1372.1">
       working directory
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1373.1">
      Copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1374.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1375.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1376.1">
       Settings
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1377.1">
      , and all
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1378.1">
       StorageValue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1379.1">
      records from the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1380.1">
       Persisting state
      </span>
     </em>
     <span class="koboSpan" id="kobo.1381.1">
      recipe or the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1382.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1383.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1384.1">
       Recipe05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1385.1">
      directory of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1386.1">
       GitHub repository
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1387.1">
      If you’re not following along the entire chapter but starting with this recipe, copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1388.1">
       BlazorCookbook.App.Client.lib.module.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1389.1">
      file from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1390.1">
       wwwroot
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1391.1">
      directory of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1392.1">
       BlazorCookbook.App.Client
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1393.1">
      in the GitHub repository to
     </span>
     <a id="_idIndexMarker263">
     </a>
     <span class="koboSpan" id="kobo.1394.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1395.1">
       wwwroot
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1396.1">
      of your project, and rename it to match your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1397.1">
       project assembly
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1398.1">
      Register the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1399.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1400.1">
      as transient in your application’s
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1401.1">
       Program
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1402.1">
      class (check out the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1403.1">
       Persisting state
      </span>
     </em>
     <span class="koboSpan" id="kobo.1404.1">
      recipe to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1405.1">
       see how)
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-195">
    <a id="_idTextAnchor195">
    </a>
    <span class="koboSpan" id="kobo.1406.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1407.1">
     Follow these instructions to implement the resolution of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1408.1">
      persisted state:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1409.1">
      Open the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1410.1">
       {ASSEMBLY_NAME}.lib.module.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1411.1">
      script file, and enhance
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1412.1">
       browserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1413.1">
      by adding a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1414.1">
       get
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1415.1">
      function that retrieves the persisted value from storage, specified by the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1416.1">
        type
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1417.1">
       parameter:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1418.1">
get: function (type, key) {
    if (type === 'sessionStorage') {
        return sessionStorage.getItem(key);
    }
    if (type === 'localStorage') {
        return localStorage.getItem(key);
    }
    return '';
},</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1419.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1420.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1421.1">
      class, introduce a new
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1422.1">
       _getFunc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1423.1">
      variable to hold the name of the newly created
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1424.1">
       browserStorage.get
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1425.1">
       JavaScript function:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1426.1">
private const string _getFunc = "browserStorage.get";</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1427.1">
      Within the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1428.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1429.1">
      , implement a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1430.1">
       ResolveAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1431.1">
      generic method, accepting a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1432.1">
       StorageValue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1433.1">
      parameter that fetches the persisted value from the appropriate browser storage.
     </span>
     <span class="koboSpan" id="kobo.1433.2">
      Utilize
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1434.1">
       JsonSerializer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1435.1">
      to transform the
     </span>
     <a id="_idIndexMarker264">
     </a>
     <span class="koboSpan" id="kobo.1436.1">
      retrieved string into the expected
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1437.1">
       object type:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1438.1">
public async ValueTask&lt;T&gt; ResolveAsync&lt;T&gt;(
    StorageValue&lt;T&gt; @object)
{
    var storage = @object is LocalStorageValue&lt;T&gt;
        ? </span><span class="koboSpan" id="kobo.1438.2">_local : _session;
    var value = await _js.InvokeAsync&lt;string&gt;(
        _getFunc, storage, @object.Key);
    return JsonSerializer.Deserialize&lt;T&gt;(value);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1439.1">
      Move to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1440.1">
       Settings
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1441.1">
      component.
     </span>
     <span class="koboSpan" id="kobo.1441.2">
      Extend the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1442.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1443.1">
      section with a new
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1444.1">
       ViewMode
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1445.1">
      variable, and override the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1446.1">
       OnAfterRenderAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1447.1">
      life cycle method with logic to resolve the persisted
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1448.1">
       viewMode
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1449.1">
      value
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1450.1">
       in
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1451.1">
        ViewMode
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1452.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1453.1">
protected string ViewMode = string.Empty;
protected override async Task
    OnAfterRenderAsync(bool firstRender)
{
    if (!firstRender) return;
    var value = new LocalStorageValue&lt;string&gt;
    {
        Key = _key
    };
    ViewMode = await Storage.ResolveAsync(value);
    StateHasChanged();
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1454.1">
      Enhance
     </span>
     <a id="_idIndexMarker265">
     </a>
     <span class="koboSpan" id="kobo.1455.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1456.1">
       Settings
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1457.1">
      component’s markup by adding a paragraph below the buttons to display the current
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1458.1">
        ViewMode
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1459.1">
       value:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1460.1">
&lt;p&gt;@ViewMode&lt;/p&gt;</span></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-196">
    <a id="_idTextAnchor196">
    </a>
    <span class="koboSpan" id="kobo.1461.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1462.1">
     We start by enhancing our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1463.1">
      browserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1464.1">
     API.
    </span>
    <span class="koboSpan" id="kobo.1464.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1465.1">
      step 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.1466.1">
     , we navigate to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1467.1">
      {ASSEMBLY_NAME}.lib.module.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1468.1">
     script file and expand the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1469.1">
      browserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1470.1">
     functionality with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1471.1">
      get
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1472.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1472.2">
     We mirror the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1473.1">
      set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1474.1">
     function’s implementation, utilizing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1475.1">
      type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1476.1">
     parameter to select the appropriate storage type and fetching the value associated with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1477.1">
      specified
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1478.1">
       key
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1479.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1480.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1481.1">
      step 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.1482.1">
     , we refine our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1483.1">
      BrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1484.1">
     service implementation by introducing a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1485.1">
      _getFunc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1486.1">
     variable to store the name of our newly created
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1487.1">
      browserStorage.get
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1488.1">
     function, safeguarding against potential typo errors in future references.
    </span>
    <span class="koboSpan" id="kobo.1488.2">
     Following this, in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1489.1">
      step 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.1490.1">
     , we implement a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1491.1">
      ResolveAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1492.1">
     generic method that mirrors the logic of the existing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1493.1">
      PersistAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1494.1">
     method.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1495.1">
      ResolveAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1496.1">
     takes a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1497.1">
      StorageValue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1498.1">
     parameter, identifies the correct storage using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1499.1">
      is
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1500.1">
     operator, and calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1501.1">
      InvokeAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1502.1">
     generic method provided by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1503.1">
      IJSRuntime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1504.1">
     to pull the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1505.1">
      value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1506.1">
     from browser storage.
    </span>
    <span class="koboSpan" id="kobo.1506.2">
     Since this value returns as a JSON string, we utilize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1507.1">
      JsonSerializer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1508.1">
     API to convert this string back into the desired
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1509.1">
      data type.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1510.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1511.1">
      step 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.1512.1">
     , we shift to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1513.1">
      Settings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1514.1">
     component, where we initialize a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1515.1">
      ViewMode
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1516.1">
     variable to hold the resolved value of the user’s persisted view mode choice.
    </span>
    <span class="koboSpan" id="kobo.1516.2">
     We then override the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1517.1">
      OnAfterRenderAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1518.1">
     life cycle method, where we use the injected
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1519.1">
      Storage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1520.1">
     service and the newly introduced
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1521.1">
      ResolveAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1522.1">
     method to resolve the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1523.1">
      ViewMode
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1524.1">
     value when the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1525.1">
      Settings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1526.1">
     component initially renders.
    </span>
    <span class="koboSpan" id="kobo.1526.2">
     Leveraging the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1527.1">
      fast-return pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1528.1">
     , we
    </span>
    <a id="_idIndexMarker266">
    </a>
    <span class="koboSpan" id="kobo.1529.1">
     ensure that the method exits immediately
    </span>
    <a id="_idIndexMarker267">
    </a>
    <span class="koboSpan" id="kobo.1530.1">
     during subsequent component state changes.
    </span>
    <span class="koboSpan" id="kobo.1530.2">
     Since Blazor executes our resolving logic post-render, we must invoke the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1531.1">
      StateHasChanged()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1532.1">
     method to refresh the UI with the updated values.
    </span>
    <span class="koboSpan" id="kobo.1532.2">
     Finally, in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1533.1">
      step 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.1534.1">
     , for the sake of simplicity, we add a paragraph below the action buttons within the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1535.1">
      Settings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1536.1">
     markup to display the current
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1537.1">
      ViewMode
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1538.1">
     value.
    </span>
    <span class="koboSpan" id="kobo.1538.2">
     Alternatively, you can apply CSS classes for light and dark modes to the DOM elements, should you have the supporting CSS
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1539.1">
      in place.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-197">
    <a id="_idTextAnchor197">
    </a>
    <span class="koboSpan" id="kobo.1540.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1541.1">
     We used the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1542.1">
      OnAfterRenderAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1543.1">
     method to resolve the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1544.1">
      ViewMode
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1545.1">
     value for an
    </span>
    <a id="_idIndexMarker268">
    </a>
    <span class="koboSpan" id="kobo.1546.1">
     architectural reason.
    </span>
    <span class="koboSpan" id="kobo.1546.2">
     Blazor blocks all
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1547.1">
      IJSRuntime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1548.1">
     interactions in the initial phases of component initialization.
    </span>
    <span class="koboSpan" id="kobo.1548.2">
     Before the DOM is created, the component is essentially in a setup phase, initializing and fetching required data.
    </span>
    <span class="koboSpan" id="kobo.1548.3">
     Once rendering completes and the DOM structure is in place, Blazor allows us to invoke the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1549.1">
      IJSRuntime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1550.1">
     API and interact with loaded
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1551.1">
      JavaScript functions.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-198">
    <a id="_idTextAnchor198">
    </a>
    <span class="koboSpan" id="kobo.1552.1">
     Sharing state across interactive render mode boundaries
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1553.1">
     Navigating state
    </span>
    <a id="_idIndexMarker269">
    </a>
    <span class="koboSpan" id="kobo.1554.1">
     management in Blazor apps becomes complicated when you switch from running solely in one render mode to mixing render modes, or using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1555.1">
      InteractiveAuto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1556.1">
     mode.
    </span>
    <span class="koboSpan" id="kobo.1556.2">
     The challenge arises from the recreation of a scoped state with every render mode change, due to the lack of automatic state sharing between server and client environments.
    </span>
    <span class="koboSpan" id="kobo.1556.3">
     You can tackle this fragmentation by designating a single, consistent source for state persistence.
    </span>
    <span class="koboSpan" id="kobo.1556.4">
     In this recipe, we will dive into a strategy where the client is the source of truth, and we will restore state from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1557.1">
      browser storage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1558.1">
     Let’s implement a generic component base that allows us to share state across interactive render
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1559.1">
      mode boundaries.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-199">
    <a id="_idTextAnchor199">
    </a>
    <span class="koboSpan" id="kobo.1560.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1561.1">
     Before you dive into state sharing, do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1562.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1563.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1564.1">
       Chapter05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1565.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1566.1">
       Recipe07
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1567.1">
      directory – this will be your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1568.1">
       working directory
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1569.1">
      Copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1570.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1571.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1572.1">
       StorageValue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1573.1">
      objects from the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1574.1">
       Resolving persisted state
      </span>
     </em>
     <span class="koboSpan" id="kobo.1575.1">
      recipe or from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1576.1">
       Chapters05
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1577.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1578.1">
       Recipe06
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1579.1">
      directory of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1580.1">
       GitHub repository
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1581.1">
      If you’re not following along the entire chapter but starting with this recipe, copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1582.1">
       BlazorCookbook.App.Client.lib.module.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1583.1">
      file from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1584.1">
       wwwroot
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1585.1">
      directory of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1586.1">
       BlazorCookbook.App.Client
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1587.1">
      in the GitHub repository to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1588.1">
       wwwroot
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1589.1">
      of your project, and rename it to match your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1590.1">
       project assembly
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1591.1">
      Register the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1592.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1593.1">
      as transient in your application’s
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1594.1">
       Program
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1595.1">
      class (check out the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1596.1">
       Persisting state
      </span>
     </em>
     <span class="koboSpan" id="kobo.1597.1">
      recipe to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1598.1">
       see how)
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-200">
    <a id="_idTextAnchor200">
    </a>
    <span class="koboSpan" id="kobo.1599.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1600.1">
     Follow these steps to implement sharing state across interactive render
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1601.1">
      mode boundaries:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1602.1">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1603.1">
       CartState
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1604.1">
      class, with an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1605.1">
       UpdateTime
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1606.1">
      property and an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1607.1">
       Add()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1608.1">
      method that mimics adding to the cart and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1609.1">
       refreshes
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1610.1">
        UpdateTime
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1611.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1612.1">
public sealed class CartState
{
    public DateTime UpdateTime { get; set; }
    public void Add() =&gt; UpdateTime = DateTime.UtcNow;
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1613.1">
      Navigate
     </span>
     <a id="_idIndexMarker270">
     </a>
     <span class="koboSpan" id="kobo.1614.1">
      to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1615.1">
       Program
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1616.1">
      class and register a global
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1617.1">
       CascadingValue
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1618.1">
       for
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1619.1">
        CartState
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1620.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1621.1">
builder.Services
    .AddCascadingValue(it =&gt; new CartState());</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1622.1">
      Create a generic
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1623.1">
       CrossingInteractiveBoundary
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1624.1">
      component that implements the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1625.1">
        IAsyncDisposable
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1626.1">
       interface:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1627.1">
@implements IAsyncDisposable
@typeparam T</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1628.1">
      Within the component’s
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1629.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1630.1">
      section of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1631.1">
       CrossingInteractiveBoundary
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1632.1">
      , define a unique state identifier,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1633.1">
       _key
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1634.1">
      , inject
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1635.1">
       BrowserStorage
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1636.1">
      , and use
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1637.1">
       CascadingParameter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1638.1">
      to intercept the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1639.1">
       generic
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1640.1">
        State
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1641.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1642.1">
private const string _key = "state";
[Inject] private BrowserStorage Storage { get; init; }
[CascadingParameter] public T State { get; set; }</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1643.1">
      Still within the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1644.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1645.1">
      block, override the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1646.1">
       OnAfterRenderAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1647.1">
      life cycle method to hydrate
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1648.1">
       State
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1649.1">
      by fetching the persisted value with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1650.1">
       SessionStorageValue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1651.1">
      , via the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1652.1">
       ResolveAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1653.1">
      method
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1654.1">
       of
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1655.1">
        Storage
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1656.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1657.1">
protected override async Task
    OnAfterRenderAsync(bool firstRender)
{
    if (!firstRender) return;
    var value = new SessionStorageValue&lt;T&gt;
    {
        Key = $"{_key}_{State.GetType()}"
    };
    try
    {
        State = await Storage.ResolveAsync(value);
        StateHasChanged();
    }
    catch { }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1658.1">
      Lastly, in
     </span>
     <a id="_idIndexMarker271">
     </a>
     <span class="koboSpan" id="kobo.1659.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1660.1">
       @code
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1661.1">
      block, to preserve state upon disposal, implement a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1662.1">
       DisposeAsync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1663.1">
      method, as mandated by the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1664.1">
       IAsyncDisposable
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1665.1">
      contract, and send the updated
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1666.1">
       State
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1667.1">
      back to the browser storage through the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1668.1">
        PersistAsync()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1669.1">
       method:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1670.1">
public ValueTask DisposeAsync()
{
    var value = new SessionStorageValue&lt;T&gt;
    {
        Key = $"{_key}_{State.GetType()}", 
        Value = State
    };
    return Storage.PersistAsync(value);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1671.1">
      Create a routable
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1672.1">
       Cart
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1673.1">
      component that operates in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1674.1">
       InteractiveAuto
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1675.1">
      render mode and inherits from the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1676.1">
        CrossingInteractiveBoundary&lt;CartState&gt;
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1677.1">
       type:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1678.1">
@page "/ch05r07"
@rendermode InteractiveAuto
@inherits CrossingInteractiveBoundary&lt;CartState&gt;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1679.1">
      In the layout of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1680.1">
       Cart
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1681.1">
      component, add a button that triggers the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1682.1">
       Add()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1683.1">
      method of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1684.1">
       State
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1685.1">
      and a paragraph to display the current value of the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1686.1">
        UpdateTime
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1687.1">
       property:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1688.1">
&lt;button @onclick="@(() =&gt; State.Add())"&gt;
    Add to cart
&lt;/button&gt;
&lt;p&gt;Last cart change: @State.UpdateTime&lt;/p&gt;</span></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-201">
    <a id="_idTextAnchor201">
    </a>
    <span class="koboSpan" id="kobo.1689.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1690.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1691.1">
      step 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.1692.1">
     , we
    </span>
    <a id="_idIndexMarker272">
    </a>
    <span class="koboSpan" id="kobo.1693.1">
     create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1694.1">
      CartState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1695.1">
     state class with an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1696.1">
      UpdateTime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1697.1">
     property and an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1698.1">
      Add()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1699.1">
     method that refreshes
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1700.1">
      UpdateTime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1701.1">
     with the current UTC, demonstrating the dynamic state interactions.
    </span>
    <span class="koboSpan" id="kobo.1701.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1702.1">
      step 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.1703.1">
     , we navigate to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1704.1">
      Program
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1705.1">
     class, and by leveraging Blazor’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1706.1">
      AddCascadingValue()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1707.1">
     extension method, we declare
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1708.1">
      CartState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1709.1">
     as a globally accessible
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1710.1">
      CascadingValue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1711.1">
     , ensuring that the state object is available throughout the application.
    </span>
    <span class="koboSpan" id="kobo.1711.2">
     We declare that the initial state of the cart is represented by a new instance of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1712.1">
       CartState
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1713.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1714.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1715.1">
      step 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.1716.1">
     , we introduce the cornerstone of our state-sharing mechanism – the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1717.1">
      CrossingInteractiveBoundary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1718.1">
     component.
    </span>
    <span class="koboSpan" id="kobo.1718.2">
     By implementing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1719.1">
      IAsyncDisposable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1720.1">
     interface, we prepare
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1721.1">
      CrossingInteractiveBoundary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1722.1">
     to have an asynchronous disposal logic.
    </span>
    <span class="koboSpan" id="kobo.1722.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1723.1">
      step 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.1724.1">
     , we define a unique
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1725.1">
      _key
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1726.1">
     storage identifier and inject
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1727.1">
      BrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1728.1">
     to persist state beyond traditional life cycle boundaries.
    </span>
    <span class="koboSpan" id="kobo.1728.2">
     With the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1729.1">
      CascadingParameter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1730.1">
     attribute, we dynamically capture the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1731.1">
      State
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1732.1">
     value, regardless of the currently expected type.
    </span>
    <span class="koboSpan" id="kobo.1732.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1733.1">
      step 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.1734.1">
     , we override the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1735.1">
      OnAfterRenderAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1736.1">
     life cycle method of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1737.1">
      CrossingInteractiveBoundary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1738.1">
     to rehydrate
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1739.1">
      State
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1740.1">
     with previously persisted values from the browser’s session storage.
    </span>
    <span class="koboSpan" id="kobo.1740.2">
     We utilize the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1741.1">
      try
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1742.1">
     -
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1743.1">
      catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1744.1">
     structure to gracefully handle scenarios where the user initializes state for the first time, so there’s no value to restore.
    </span>
    <span class="koboSpan" id="kobo.1744.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1745.1">
      step 6
     </span>
    </em>
    <span class="koboSpan" id="kobo.1746.1">
     , we complete the implementation with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1747.1">
      DisposeAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1748.1">
     method, but instead of releasing resources, we add logic to persist the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1749.1">
      State
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1750.1">
     value with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1751.1">
      PersistAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1752.1">
     method of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1753.1">
      Storage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1754.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1754.2">
     This way, we ensure that the state remains updated and recoverable, regardless of navigation actions or rendering
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1755.1">
      mode transitions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1756.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1757.1">
      step 7
     </span>
    </em>
    <span class="koboSpan" id="kobo.1758.1">
     , we introduce the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1759.1">
      Cart
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1760.1">
     component that renders in dynamic
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1761.1">
      InteractiveAuto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1762.1">
     mode and inherits from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1763.1">
      CrossingInteractiveBoundary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1764.1">
     , with state represented by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1765.1">
      CartState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1766.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.1766.2">
     Blazor will seamlessly alternate between server-side and client-side rendering, which makes it a perfect environment to showcase the
    </span>
    <a id="_idIndexMarker273">
    </a>
    <span class="koboSpan" id="kobo.1767.1">
     adaptive state-sharing logic of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1768.1">
      CrossingInteractiveBoundary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1769.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1769.2">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1770.1">
      step 8
     </span>
    </em>
    <span class="koboSpan" id="kobo.1771.1">
     , we add the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1772.1">
      Cart
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1773.1">
     markup – a button that invokes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1774.1">
      Add()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1775.1">
     method of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1776.1">
      CartState
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1777.1">
     and a paragraph displaying the current
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1778.1">
       UpdateTime
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1779.1">
      value.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-202">
    <a id="_idTextAnchor202">
    </a>
    <span class="koboSpan" id="kobo.1780.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1781.1">
     The strategy we’ve explored in this recipe is not limited to cascading parameters.
    </span>
    <span class="koboSpan" id="kobo.1781.2">
     You can also leverage
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1782.1">
      BrowserStorage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1783.1">
     to hydrate and persist the state of the state injected as a service (you learned how to implement injectable state in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1784.1">
      Injecting application state as a service
     </span>
    </em>
    <span class="koboSpan" id="kobo.1785.1">
     recipe).
    </span>
    <span class="koboSpan" id="kobo.1785.2">
     Depending on your architectural requirements, you can leverage a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1786.1">
      REST API
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1787.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1788.1">
      gRPC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1789.1">
     service and persist state on the server as well.
    </span>
    <span class="koboSpan" id="kobo.1789.2">
     Moreover, as the
    </span>
    <a id="_idIndexMarker274">
    </a>
    <span class="koboSpan" id="kobo.1790.1">
     complexity
    </span>
    <a id="_idIndexMarker275">
    </a>
    <span class="koboSpan" id="kobo.1791.1">
     and size of the state object grows, you’ll see that state hydration can cause a visible delay before the UI refreshes with the correct data.
    </span>
    <span class="koboSpan" id="kobo.1791.2">
     That’s where the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1792.1">
      Overlay
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1793.1">
     component, which we implemented in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1794.1">
      Invoking state changes from anywhere
     </span>
    </em>
    <span class="koboSpan" id="kobo.1795.1">
     recipe, comes in handy.
    </span>
    <span class="koboSpan" id="kobo.1795.2">
     By temporarily obscuring the UI until state resolution
    </span>
    <a id="_idIndexMarker276">
    </a>
    <span class="koboSpan" id="kobo.1796.1">
     completes, we ensure that users experience a seamless and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1797.1">
      cohesive interface.
     </span>
    </span>
   </p>
  </div>
 </body></html>