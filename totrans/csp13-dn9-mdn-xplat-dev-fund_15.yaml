- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Building and Consuming Web Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和消费Web服务
- en: This chapter is about learning how to build web services (aka HTTP or **Representational
    State Transfer** (**REST**) services) using ASP.NET Core Minimal APIs. You will
    then learn how to consume web services using HTTP clients, which could be any
    other type of .NET app, including a website or a mobile or desktop app. We will
    create a Blazor WebAssembly client.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于学习如何使用ASP.NET Core Minimal APIs构建Web服务（也称为HTTP或**表示状态转移**（**REST**）服务）。然后，你将学习如何使用HTTP客户端消费Web服务，这可以是任何其他类型的.NET应用程序，包括网站或移动或桌面应用程序。我们将创建一个Blazor
    WebAssembly客户端。
- en: This chapter requires the knowledge and skills that you gained in *Chapter 10*,
    *Working with Data Using Entity Framework Core*, and *Chapters 12* to *14*, about
    building websites using ASP.NET Core and Blazor.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要你在*第10章*，*使用Entity Framework Core处理数据*，以及*第12章*到*第14章*中获得的关于使用ASP.NET Core和Blazor构建网站的知识和技能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building web services using ASP.NET Core
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core构建Web服务
- en: Creating a web service for the Northwind database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Northwind数据库创建Web服务
- en: Documenting and trying out web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和尝试Web服务
- en: Consuming web services using HTTP clients
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP客户端消费Web服务
- en: Building web services using ASP.NET Core
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core构建Web服务
- en: Before we build a modern web service, we need to cover some background to set
    the context for this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建现代Web服务之前，我们需要了解一些背景知识，为本章的内容奠定基础。
- en: Understanding web service acronyms
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Web服务缩写
- en: Although HTTP was originally designed to request and respond with HTML and other
    resources for humans to look at, it is also good for building services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP最初是为了请求和响应HTML和其他资源供人类查看而设计的，但它也适合构建服务。
- en: 'Roy Fielding stated in his doctoral dissertation, describing the **REST** architectural
    style, that the HTTP standard would be good for building services because it defines
    the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding在他的博士论文中，描述了**REST**架构风格，指出HTTP标准对于构建服务来说很好，因为它定义了以下内容：
- en: URIs to uniquely identify resources, like `https://localhost:5151/products/23`.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用URI（统一资源标识符）来唯一标识资源，例如`https://localhost:5151/products/23`。
- en: Methods for performing common tasks on those resources, like `GET`, `POST`,
    `PUT`, and `DELETE`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些资源上执行常见任务的方法，如`GET`、`POST`、`PUT`和`DELETE`。
- en: 'The ability to negotiate the media type of content exchanged in requests and
    responses, such as XML and JSON. Content negotiation happens when the client specifies
    a request header like `Accept: application/xml,*/*;q=0.8`. The default response
    format used by the ASP.NET Core web services is JSON, which means one of the response
    headers would be `Content-Type: application/json; charset=utf-8`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '能够协商请求和响应中交换的内容的媒体类型，例如XML和JSON。当客户端指定一个请求头，如`Accept: application/xml,*/*;q=0.8`时，就会发生内容协商。ASP.NET
    Core Web服务使用的默认响应格式是JSON，这意味着其中一个响应头会是`Content-Type: application/json; charset=utf-8`。'
- en: '**Web services** use the HTTP communication standard, so they are sometimes
    called **HTTP services** or **RESTful services**.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web服务**使用HTTP通信标准，因此有时被称为**HTTP服务**或**RESTful服务**。'
- en: Understanding HTTP requests and responses
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解HTTP请求和响应
- en: HTTP defines standard types of requests and standard codes to indicate a type
    of response. Most of them can be used to implement web services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP定义了标准类型的请求和标准代码来指示响应类型。其中大部分可以用来实现Web服务。
- en: 'The most common type of request is `GET`, to retrieve a resource identified
    by a unique path, with additional options like what media type is acceptable to
    set as a request header, like `Accept`, as shown in the following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的请求类型是`GET`，用于检索由唯一路径标识的资源，还可以设置额外的选项，如请求头中可接受的媒体类型，例如`Accept`，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Common responses include success and multiple types of failure, as shown in
    *Table 15.1*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的响应包括成功和多种类型的失败，如*表15.1*所示：
- en: '| **Status code** | **Description** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **描述** |'
- en: '| `101 Switching Protocols` | The requester has asked the server to switch
    protocols and the server has agreed to do so. For example, it is common to switch
    from HTTP to **WebSockets** (**WS**) for more efficient communication. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `101 Switching Protocols` | 请求者已要求服务器切换协议，并且服务器已同意这样做。例如，从HTTP切换到**WebSockets**（**WS**）进行更有效的通信是常见的。|'
- en: '| `103 Early Hints` | Used to convey hints that help a client make preparations
    to process the final response. For example, the server might send the following
    response before then sending a normal `200 OK` response for a web page that uses
    a stylesheet and JavaScript file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '| `103 Early Hints` | 用于传达帮助客户端准备处理最终响应的提示。例如，服务器可能会在发送一个使用样式表和 JavaScript
    文件的网页的正常 `200 OK` 响应之前发送以下响应：|'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `200 OK` | The path was correctly formed and the resource was successfully
    found, serialized into an acceptable media type, and then returned in the response
    body. The response headers specify the `Content-Type`, `Content-Length`, and `Content-Encoding`,
    for example, `GZIP`. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `200 OK` | 路径正确形成，资源成功找到，序列化为可接受的媒体类型，然后返回在响应体中。响应头指定了 `Content-Type`、`Content-Length`
    和 `Content-Encoding`，例如，`GZIP`。|'
- en: '| `301 Moved Permanently` | Over time, a web service may change its resource
    model, including the path used to identify an existing resource. The web service
    can indicate the new path by returning this status code and a response header
    named `Location` that has the new path. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `301 Moved Permanently` | 随着时间的推移，网络服务可能会更改其资源模型，包括用于标识现有资源的路径。网络服务可以通过返回此状态码和一个名为
    `Location` 的响应头，其中包含新路径，来指示新路径。|'
- en: '| `302 Found` | This is the same as `301`. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `302 Found` | 这与 `301` 相同。|'
- en: '| `304 Not Modified` | If the request includes the `If-Modified-Since` header,
    then the web service can respond with this status code. The response body is empty
    because the client should use its cached copy of the resource. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `304 Not Modified` | 如果请求包含 `If-Modified-Since` 头部，则网络服务可以响应此状态码。响应体为空，因为客户端应使用其缓存的资源副本。|'
- en: '| `307 Temporary Redirect` | The requested resource has been temporarily moved
    to the URL in the `Location` header. The browser should make a new request using
    that URL. For example, this is what happens if you enable `UseHttpsRedirection`
    and a client makes an HTTP request. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `307 Temporary Redirect` | 请求的资源已临时移动到 `Location` 头部中的 URL。浏览器应使用该 URL 发起新的请求。例如，如果你启用了
    `UseHttpsRedirection` 并客户端发起了一个 HTTP 请求，就会发生这种情况。|'
- en: '| `400 Bad Request` | The request was invalid, for example, it used a path
    for a product using an integer ID where the ID value is missing. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `400 Bad Request` | 请求无效，例如，它使用了一个整数 ID 的产品路径，但缺少 ID 值。|'
- en: '| `401 Unauthorized` | The request was valid and the resource was found, but
    the client did not supply credentials or is not authorized to access that resource.
    Re-authenticating may enable access, for example, by adding or changing the `Authorization`
    request header. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `401 Unauthorized` | 请求有效且资源已找到，但客户端未提供凭据或无权访问该资源。重新认证可能允许访问，例如，通过添加或更改 `Authorization`
    请求头部。|'
- en: '| `403 Forbidden` | The request was valid and the resource was found, but the
    client is not authorized to access that resource. Re-authenticating will not fix
    the issue. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `403 Forbidden` | 请求有效且资源已找到，但客户端无权访问该资源。重新认证不会解决问题。|'
- en: '| `404 Not Found` | The request was valid, but the resource was not found.
    The resource may be found if the request is repeated later. To indicate that a
    resource will never be found, return `410 Gone`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `404 Not Found` | 请求有效，但资源未找到。资源可能在稍后重复请求时找到。要指示资源永远不会找到，返回 `410 Gone`。|'
- en: '| `406 Not Acceptable` | If the request has an `Accept` header that only lists
    media types that the web service does not support. For example, if the client
    requests JSON but the web service can only return XML. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `406 Not Acceptable` | 如果请求有一个 `Accept` 头部，只列出了网络服务不支持媒体类型。例如，如果客户端请求 JSON，但网络服务只能返回
    XML。|'
- en: '| `451 Unavailable for Legal Reasons` | A website hosted in the USA might return
    this for requests coming from Europe to avoid having to comply with the **General
    Data Protection Regulation** (**GDPR**). The number was chosen as a reference
    to the novel Fahrenheit 451, in which books are banned and burned. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `451 Unavailable for Legal Reasons` | 美国托管的一个网站可能会对来自欧洲的请求返回此状态，以避免必须遵守**通用数据保护条例**（**GDPR**）。这个数字是作为对小说《
    Fahrenheit 451》的参考，在那本书中，书籍被禁止并焚毁。|'
- en: '| `500 Server Error` | The request was valid, but something went wrong on the
    server side while processing the request. Retrying again later might work. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `500 Server Error` | 请求有效，但在服务器端处理请求时出了问题。稍后再试可能有效。|'
- en: '| `503 Service Unavailable` | The web service is busy and cannot handle the
    request. Trying again later might work. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `503 Service Unavailable` | 网络服务正忙，无法处理请求。稍后再试可能有效。|'
- en: 'Table 15.1: Common HTTP status code responses to the GET method'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1：对GET方法的常见HTTP状态码响应
- en: Other common types of HTTP requests include `POST`, `PUT`, `PATCH`, or `DELETE`,
    which create, modify, or delete resources.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见的HTTP请求类型包括`POST`、`PUT`、`PATCH`或`DELETE`，它们用于创建、修改或删除资源。
- en: 'To create a new resource, you might make a `POST` request with a body that
    contains the new resource, as shown in the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新资源，你可能需要发送一个包含新资源的`POST`请求，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create a new resource or update an existing resource, you might make a `PUT`
    request with a body that contains a whole new version of the existing resource,
    and if the resource does not exist, it is created, or if it does exist, it is
    replaced (sometimes called an **upsert** operation), as shown in the following
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新资源或更新现有资源，你可能需要发送一个包含现有资源全新版本的`PUT`请求，如果资源不存在，则创建它；如果它已存在，则替换它（有时称为**upsert**操作），如下面的代码所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To update an existing resource more efficiently, you might make a `PATCH` request
    with a body that contains an object with only the properties that need changing,
    as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有效地更新现有资源，你可能需要发送一个包含仅包含需要更改的属性的对象的`PATCH`请求，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To delete an existing resource, you might make a `DELETE` request, as shown
    in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除现有资源，你可能需要发送一个`DELETE`请求，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As well as the responses shown in the table above for a `GET` request, all
    the types of requests that create, modify, or delete a resource have additional
    possible common responses, as shown in *Table 15.2*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上表中针对`GET`请求的响应外，所有创建、修改或删除资源的请求类型都有额外的可能常见响应，如下所示*表15.2*：
- en: '| **Status code** | **Description** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **描述** |'
- en: '| `201 Created` | The new resource was created successfully, the response header
    named `Location` contains its path, and the response body contains the newly created
    resource. Immediately `GET`-ing the resource should return `200`. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `201 已创建` | 新资源已成功创建，响应头中名为`Location`的头部包含其路径，响应体包含新创建的资源。立即`GET`该资源应返回`200`。|'
- en: '| `202 Accepted` | The new resource cannot be created immediately, so the request
    is queued for later processing, and immediately `GET`-ing the resource might return
    `404`. The body can contain a resource that points to some form of status checker
    or an estimate of when the resource will become available. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `202 已接受` | 新资源不能立即创建，因此请求被排队等待后续处理，立即`GET`该资源可能会返回`404`。响应体可以包含指向某种状态检查器或资源何时可用的估计的资源。|'
- en: '| `204 No Content` | Commonly used in response to a `DELETE` request since
    returning the resource in the body after deleting it does not usually make sense!
    Sometimes used in response to `POST`, `PUT`, or `PATCH` requests if the client
    does not need to confirm that the request was processed correctly. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `204 无内容` | 通常用于对`DELETE`请求的响应，因为删除后返回资源在请求体中通常没有意义！有时用于对`POST`、`PUT`或`PATCH`请求的响应，如果客户端不需要确认请求是否正确处理。|'
- en: '| `405 Method Not Allowed` | Returned when the request used a method that is
    not supported. For example, a web service designed to be read-only may explicitly
    disallow `PUT`, `DELETE`, and so on. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `405 方法不允许` | 当请求使用了不支持的方法时返回。例如，一个设计为只读的Web服务可能会明确禁止`PUT`、`DELETE`等操作。|'
- en: '| `415 Unsupported Media Type` | Returned when the resource in the request
    body uses a media type that the web service cannot handle. For example, if the
    body contains a resource in XML format but the web service can only process JSON.
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `415 不支持的媒体类型` | 返回时，请求体中的资源使用的是该网络服务无法处理的媒体类型。例如，如果请求体包含XML格式的资源，但该网络服务只能处理JSON。|'
- en: 'Table 15.2: Common HTTP status code responses to other methods like POST and
    PUT'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.2：对其他方法如POST和PUT的常见HTTP状态码响应
- en: ASP.NET Core Minimal APIs projects
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core最小API项目
- en: We will build a web service that provides a way to work with data in the Northwind
    database using ASP.NET Core so that the data can be used by any client application
    on any platform that can make HTTP requests and receive HTTP responses.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个Web服务，该服务使用ASP.NET Core提供一种方式来处理Northwind数据库中的数据，以便任何可以发送HTTP请求并接收HTTP响应的平台上的客户端应用程序都可以使用这些数据。
- en: Traditionally, you use the **ASP.NET Core Web API** / `dotnet new webapi` project
    template. This allows the creation of a web service implemented using either controllers
    or the newer Minimal APIs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，你使用 **ASP.NET Core Web API** / `dotnet new webapi` 项目模板。这允许创建使用控制器或较新的最小化
    API 实现的 Web 服务。
- en: '**Warning!** With .NET 6 and .NET 7, the `dotnet new webapi` command creates
    a service implemented using controllers. With .NET 6 and .NET 7, to implement
    the service using Minimal APIs, you need to add the `--use-minimal-apis` switch
    to the command. Using .NET 8 or later, the `dotnet new webapi` command creates
    a service implemented using Minimal APIs. To implement the service using controllers,
    you need to add the `--use-controllers` switch.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 在 .NET 6 和 .NET 7 中，`dotnet new webapi` 命令创建的是使用控制器实现的服务。在 .NET 6 和
    .NET 7 中，要使用最小化 API 实现服务，需要将 `--use-minimal-apis` 开关添加到命令中。使用 .NET 8 或更高版本，`dotnet
    new webapi` 命令创建的是使用最小化 API 实现的服务。要使用控制器实现服务，需要添加 `--use-controllers` 开关。'
- en: Minimal APIs web service and native AOT compilation
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小化 API 网络服务和原生 AOT 编译
- en: '.NET 8 introduced the **ASP.NET Core Web API (native AOT)** / `dotnet new webapiaot`
    project template, which only uses Minimal APIs and supports native AOT publishing.
    More components of .NET will support AOT over time, as you can read in the following
    quote:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 引入了 **ASP.NET Core Web API (native AOT)** / `dotnet new webapiaot` 项目模板，它仅使用最小化
    API 并支持原生 AOT 发布。随着时间的推移，.NET 的更多组件将支持 AOT，正如你可以在以下引语中读到的那样：
- en: “We expect to make progress investigating Native AOT support for MVC & Blazor
    in the .NET 9 timeframe, but we don’t expect to deliver production ready Native
    AOT support for .NET 9 given the large amount of work involved.” – Dan Roth
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我们预计将在 .NET 9 时间范围内取得调查原生 AOT 支持对于 MVC 和 Blazor 的进展，但我们不期望在 .NET 9 中提供生产就绪的原生
    AOT 支持，因为涉及的工作量很大。” – 丹·罗斯
- en: '[https://github.com/dotnet/aspnetcore/issues/51834#issuecomment-1913300365](https://github.com/dotnet/aspnetcore/issues/51834#issuecomment-1913300365)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/dotnet/aspnetcore/issues/51834#issuecomment-1913300365](https://github.com/dotnet/aspnetcore/issues/51834#issuecomment-1913300365)'
- en: '**Good Practice**: Minimal APIs work especially well with **Vertical Slice
    Architecture (VSA)**. A major benefit of Minimal APIs over a controller-based
    Web API is that each Minimal API endpoint only needs to instantiate the **dependency
    injection** (**DI**) services that it needs. With controllers, to execute any
    action method within that controller, all DI services used in any of the action
    methods must be instantiated for every call. This is a waste of time and resources!'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：最小化 API 与垂直切片架构（VSA）配合得非常好。与基于控制器的 Web API 相比，最小化 API 的一个主要优点是每个最小化
    API 端点只需要实例化它需要的依赖注入（DI）服务。在使用控制器的情况下，为了执行控制器中的任何操作方法，必须在每次调用中实例化任何操作方法中使用的所有
    DI 服务。这是时间和资源的浪费！'
- en: Creating an ASP.NET Core Minimal API project
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 ASP.NET Core 最小化 API 项目
- en: 'Let’s go:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Use your preferred code editor to open the `ModernWeb` solution and then add
    a new project, as defined in the following list:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器打开 `ModernWeb` 解决方案，然后添加一个新项目，如下所示：
- en: 'Project template: **ASP.NET Core Web API** / `webapi`'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**ASP.NET Core Web API** / `webapi`
- en: 'Solution file and folder: `ModernWeb`'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`ModernWeb`
- en: 'Project file and folder: `Northwind.WebApi`'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.WebApi`
- en: 'If you are using Visual Studio, then confirm the following defaults have been
    chosen:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Visual Studio，那么请确认以下默认值已被选择：
- en: '**Authentication type**: None'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证类型**：无'
- en: '**Configure for HTTPS**: Selected'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置 HTTPS**：已选择'
- en: '**Enable container support**: Cleared'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用容器支持**：已清除'
- en: '**Enable OpenAPI support**: Selected'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用 OpenAPI 支持**：已选择'
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶级语句**：已清除'
- en: '**Use controllers**: Cleared'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用控制器**：已清除'
- en: Make sure to clear the **Use controllers** check box, or your code will look
    very different to what you will see in this book!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 确保清除 **使用控制器** 复选框，否则你的代码将与你在这本书中看到的非常不同！
- en: 'If you are using VS Code or Rider, then in the `ModernWeb` directory, at the
    command prompt or terminal, enter the following:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用 VS Code 或 Rider，那么在 `ModernWeb` 目录中，在命令提示符或终端中输入以下命令：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Build the `Northwind.WebApi` project.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `Northwind.WebApi` 项目。
- en: 'In the project file, remove the version number for the package that implements
    OpenAPI web service documentation because we are using CPM, as shown in the following
    markup:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，删除实现 OpenAPI 网络服务文档的包的版本号，因为我们正在使用 CPM，如下所示：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `Program.cs`, review the code, as shown in the following code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，查看以下代码：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While reviewing the preceding code, note the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查前面的代码时，请注意以下内容：
- en: The program starts with a similar configuration to any other ASP.NET Core project,
    with a call to `WebApplication.CreateBuilder`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序以与其他任何 ASP.NET Core 项目类似的配置开始，通过调用 `WebApplication.CreateBuilder`。
- en: 'The services collection has an OpenAPI service added. This is used to document
    a web service. In .NET 8 and earlier, the third-party Swashbuckle package was
    used to do this, but with .NET 9 and later, Microsoft has written their own implementation.
    You can read more about this at the following link: [https://github.com/dotnet/aspnetcore/issues/54599](https://github.com/dotnet/aspnetcore/issues/54599).
    By default, OpenAPI document generation creates a document that is compliant with
    v3.0 of the OpenAPI specification: [https://spec.openapis.org/oas/v3.0.0](https://spec.openapis.org/oas/v3.0.0).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务集合中添加了一个 OpenAPI 服务。这用于记录网络服务。在 .NET 8 及更早版本中，使用了第三方 Swashbuckle 包来完成此操作，但自
    .NET 9 及以后版本，Microsoft 已经编写了自己的实现。您可以在以下链接中了解更多信息：[https://github.com/dotnet/aspnetcore/issues/54599](https://github.com/dotnet/aspnetcore/issues/54599)。默认情况下，OpenAPI
    文档生成创建一个符合 OpenAPI 规范 v3.0 的文档：[https://spec.openapis.org/oas/v3.0.0](https://spec.openapis.org/oas/v3.0.0)。
- en: During development, the OpenAPI documentation is mapped as endpoints so that
    other developers can use it to create clients easily. By default, the OpenAPI
    endpoint registered via a call to MapOpenApi exposes the document at the [/openapi/{documentName}.json](https://openapi/%7BdocumentName%7D.json)
    endpoint. By default, the `documentName` is `v1`. In the production environment,
    these endpoints are not mapped because they are no longer necessary.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发期间，OpenAPI 文档被映射为端点，以便其他开发者可以使用它轻松地创建客户端。默认情况下，通过调用 MapOpenApi 注册的 OpenAPI
    端点将文档暴露在 [/openapi/{documentName}.json](https://openapi/%7BdocumentName%7D.json)
    端点。默认情况下，`documentName` 是 `v1`。在生产环境中，这些端点不会被映射，因为它们不再必要。
- en: The `MapGet` call registers a relative path of `/weatherforecast` to respond
    to HTTP `GET` requests, and its implementation uses the shared `Random` object
    to return an array of `WeatherForecast` objects with random temperatures and summaries
    like `Bracing` or `Balmy` for the next five days of weather.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapGet` 调用注册了一个相对路径 `/weatherforecast` 以响应 HTTP `GET` 请求，并且其实现使用共享的 `Random`
    对象返回一个包含随机温度和总结（如 `Bracing` 或 `Balmy`）的 `WeatherForecast` 对象数组，这些总结对应于未来五天的天气。'
- en: 'Now let’s allow the HTTP request to specify how many days ahead the forecast
    should be. At the same time, we will implement good practices by putting the weather
    endpoint implementation in its own code file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们允许 HTTP 请求指定预报应提前多少天。同时，我们将通过将天气端点实现放入其自己的代码文件中，来实施良好的实践：
- en: Add a new class file named `Program.Weather.cs`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Program.Weather.cs` 的新类文件。
- en: 'In `Program.Weather.cs`, add statements to extend the automatically generated
    `partial` `Program` class by moving (cut and paste the statements) the weather-related
    statements from `Program.cs` and making small adjustments like defining a `GetWeather`
    method with a `days` parameter to control how many weather forecasts to generate,
    as shown in the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Weather.cs` 中，添加语句以通过移动（剪切和粘贴语句）从 `Program.cs` 中的天气相关语句来扩展自动生成的 `partial`
    `Program` 类，并进行一些小的调整，例如定义一个带有 `days` 参数的 `GetWeather` 方法来控制要生成的天气预报数量，如下所示，代码如下：
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `Program.cs`, modify the `MapGet` call, as shown highlighted in the following
    code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，修改 `MapGet` 调用，如下所示，高亮显示的代码：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `MapGet` call, note the route template pattern `{days:int?}` constrains
    the `days` parameter to `int` values. The `?` makes the `days` parameter optional,
    and if missing it will default to `5`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MapGet` 调用中，请注意路由模板模式 `{days:int?}` 将 `days` 参数限制为 `int` 值。`?` 使得 `days`
    参数是可选的，如果缺失，则默认为 `5`。
- en: Reviewing the web service’s functionality
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查网络服务的功能
- en: 'Now, we will test the web service’s functionality:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测试网络服务的功能：
- en: 'In the `Properties` folder, in `launchSettings.json`, note that by default,
    if you are using Visual Studio, the `https` profile will launch the browser and
    navigate to the `/weatherforecast` relative URL path, as shown highlighted in
    the following markup:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Properties` 文件夹中，在 `launchSettings.json` 中，请注意，默认情况下，如果您使用 Visual Studio，则
    `https` 配置文件将启动浏览器并导航到 `/weatherforecast` 相对 URL 路径，如下所示，高亮显示的标记：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the `https` profile, for its `applicationUrl`, change the random port number
    for HTTPS to `5151` and for HTTP to `5150`, as shown highlighted in the following
    markup:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `https` 配置文件，对于其 `applicationUrl`，将 HTTPS 的随机端口号更改为 `5151`，对于 HTTP 更改为 `5150`，如下所示，高亮显示的标记：
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save changes to all modified files.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有修改文件的更改。
- en: Start the `Northwind.WebApi` web service project using the `https` launch profile.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `https` 启动配置文件启动 `Northwind.WebApi` 网络服务项目。
- en: On Windows, if you see a **Windows Security Alert** dialog box saying **Windows
    Defender Firewall has blocked some features of this app**, then click the **Allow
    access** button.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 上，如果你看到一个 **Windows 安全警报** 对话框，显示 **Windows Defender 防火墙已阻止此应用的一些功能**，那么请点击
    **允许访问** 按钮。
- en: Start Chrome, navigate to `https://localhost:5151/`, and note you will get a
    `404` status code response because we have not enabled static files and there
    is not an `index.html`. Remember that this project is not designed for a human
    to view and interact with, so this is expected behavior for a web service.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Chrome，导航到 `https://localhost:5151/`，并注意你会得到一个 `404` 状态码响应，因为我们尚未启用静态文件，且没有
    `index.html`。记住，这个项目不是为人类查看和交互而设计的，所以这是网络服务的预期行为。
- en: In Chrome, show **Developer Tools**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Chrome 中，显示 **开发者工具**。
- en: 'Navigate to `https://localhost:5151/weatherforecast` and note the web service
    should return a JSON document with five random weather forecast objects in an
    array, as shown in *Figure 15.1*:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `https://localhost:5151/weatherforecast` 并注意网络服务应该返回一个包含五个随机天气预报对象的 JSON
    文档数组，如图 *图 15.1* 所示：
- en: '![](img/B22322_15_01.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_15_01.png)'
- en: 'Figure 15.1: A request and response from a weather forecast web service'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1：来自天气预报网络服务的一个请求和响应
- en: Close **Developer Tools**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 **开发者工具**。
- en: Navigate to `https://localhost:5151/weatherforecast/14` and note that the response
    when requesting a two-week weather forecast contains 14 forecasts.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `https://localhost:5151/weatherforecast/14` 并注意请求两周天气预报时，响应包含 14 个预报。
- en: Select the **Pretty print** checkbox, as shown in *Figure 15.1*, and note that
    recent versions of Chrome can now format JSON responses better for humans to read.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 *美化打印* 复选框，如图 *图 15.1* 所示，并注意 Chrome 的最新版本现在可以更好地格式化 JSON 响应，以便人类阅读。
- en: Close Chrome and shut down the web server.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 Chrome 并关闭网络服务器。
- en: Route constraints
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由约束
- en: 'To register the `/weatherforecast` route endpoint, we used a route constraint
    to limit acceptable values for the `days` parameter to integers, as shown highlighted
    in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册 `/weatherforecast` 路由端点，我们使用路由约束来限制 `days` 参数的可接受值为整数，如下代码中突出显示所示：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Route constraints allow us to control matches based on data types and other
    validation. They are summarized in *Table 15.3*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 路由约束允许我们根据数据类型和其他验证来控制匹配。它们总结在 *表 15.3* 中：
- en: '| **Constraint** | **Example** | **Description** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **约束** | **示例** | **描述** |'
- en: '| `required` | `{id:required}` | The parameter has been provided. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `required` | `{id:required}` | 参数已被提供。|'
- en: '| `int` and `long` | `{id:int}` | Any integer of the correct size. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `int` 和 `long` | `{id:int}` | 任何正确大小的整数。|'
- en: '| `decimal`, `double`, and `float` | `{unitprice:decimal}` | Any real number
    of the correct size. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `decimal`、`double` 和 `float` | `{unitprice:decimal}` | 任何正确大小的实数。|'
- en: '| `bool` | `{discontinued:bool}` | Case-insensitive match on `true` or `false`.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `{discontinued:bool}` | 在 `true` 或 `false` 上的不区分大小写的匹配。|'
- en: '| `datetime` | `{hired:datetime}` | An invariant culture date/time. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `datetime` | `{hired:datetime}` | 不变文化的日期/时间。|'
- en: '| `guid` | `{id:guid}` | A GUID value. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `guid` | `{id:guid}` | 一个 GUID 值。|'
- en: '| `minlength(n)`, `maxlength(n)`, `length(n)`, and `length(n, m)` | `{title:minlength(5)}`,
    `{title:length(5, 25)}` | The text must have the defined minimum and/or maximum
    length. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `minlength(n)`、`maxlength(n)`、`length(n)` 和 `length(n, m)` | `{title:minlength(5)}`、`{title:length(5,
    25)}` | 文本必须具有定义的最小和/或最大长度。|'
- en: '| `min(n)`, `max(n)`, and `range(n, m)` | `{age:range(18, 65)}` | The integer
    must be within the defined minimum and/or maximum range. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `min(n)`、`max(n)` 和 `range(n, m)` | `{age:range(18, 65)}` | 整数必须在定义的最小和/或最大范围内。|'
- en: '| `alpha`, `regex` | `{firstname:alpha}`, `{id:regex(^[A-Z]{{5}}$)}` | The
    parameter must match one or more alphabetic characters or the regular expression.
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `alpha`、`regex` | `{firstname:alpha}`、`{id:regex(^[A-Z]{{5}}$)}` | 参数必须匹配一个或多个字母字符或正则表达式。|'
- en: 'Table 15.3: Route constraints with examples and descriptions'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.3：带有示例和描述的路由约束
- en: 'Use colons to separate multiple constraints, as shown in the following example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用冒号分隔多个约束，如下例所示：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For regular expressions, `RegexOptions.IgnoreCase | RegexOptions.Compiled |
    RegexOptions.CultureInvariant` is added automatically. Regular expression tokens
    must be escaped (replace `\` with `\\`, `{` with `{{`, and `}` with `}}`) or use
    verbatim string literals.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正则表达式，自动添加了 `RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant`。正则表达式标记必须转义（将
    `\` 替换为 `\\`，将 `{` 替换为 `{{`，将 `}` 替换为 `}}`）或使用文本字符串字面量。
- en: '**More Information**: You can create custom route constraints by defining a
    class that implements `IRouteConstraint`. This is beyond the scope of this book,
    but you can read about it at the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing#custom-route-constraints](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing#custom-route-constraints).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以通过定义一个实现 `IRouteConstraint` 的类来创建自定义路由约束。这超出了本书的范围，但您可以在以下链接中了解相关信息：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing#custom-route-constraints](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing#custom-route-constraints)。'
- en: Short-circuit routes
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短路路由
- en: When routing matches a request to an endpoint, it lets the rest of the middleware
    pipeline run before invoking the endpoint logic. That takes time, so in ASP.NET
    Core 8 and later, you can invoke the endpoint immediately and return the response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由匹配到端点请求时，它允许中间件管道的其他部分在调用端点逻辑之前运行。这需要时间，因此在 ASP.NET Core 8 及以后版本中，您可以立即调用端点并返回响应。
- en: 'You do this by calling the `ShortCircuit` method on a mapped endpoint route,
    as shown in the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在映射的端点路由上调用 `ShortCircuit` 方法来完成此操作，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, you can call the `MapShortCircuit` method to respond with a
    `404 Missing Resource` or other status code for resources that don’t need further
    processing, as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过调用 `MapShortCircuit` 方法来响应 `404 资源未找到` 或其他状态码，对于不需要进一步处理的资源，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Improved route tooling in ASP.NET Core 8 and later
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core 8 及以后版本的改进路由工具
- en: 'Microsoft has improved the tooling for working with routes for all ASP.NET
    Core 8 and later technologies including Web APIs and Blazor. The features include
    the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已经改进了用于处理所有 ASP.NET Core 8 及以后技术（包括 Web API 和 Blazor）的路由工具。这些功能包括以下内容：
- en: '**Route syntax highlighting**: Different parts of routes are now highlighted
    in your code editor.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由语法高亮**：现在在您的代码编辑器中突出显示路由的不同部分。'
- en: '**Autocompletion**: Parameter and route names and route constraints are autocompleted.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动完成**：参数和路由名称以及路由约束将自动完成。'
- en: '**Route analyzers and fixers**: These address common problems that developers
    have when implementing their routes.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由分析器和修复工具**：这些工具解决了开发者在实现路由时遇到的常见问题。'
- en: 'You can read about them in the blog article *ASP.NET Core Route Tooling Enhancements
    in .NET 8*, found at the following link: [https://devblogs.microsoft.com/dotnet/aspnet-core-route-tooling-dotnet-8/](https://devblogs.microsoft.com/dotnet/aspnet-core-route-tooling-dotnet-8/).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到的博客文章 *ASP.NET Core 在 .NET 8 中的路由工具增强功能* 中了解它们：[https://devblogs.microsoft.com/dotnet/aspnet-core-route-tooling-dotnet-8/](https://devblogs.microsoft.com/dotnet/aspnet-core-route-tooling-dotnet-8/)。
- en: Understanding endpoint route handler return types
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解端点路由处理程序返回类型
- en: An endpoint lambda expression can return .NET types like a single `string` value;
    complex objects defined by a `class`, `record`, or `struct`; or collections of
    complex objects. ASP.NET Core Minimal APIs will serialize them into JSON or plain
    text.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 端点 lambda 表达式可以返回 .NET 类型，如单个 `string` 值；由 `class`、`record` 或 `struct` 定义的复杂对象；或复杂对象的集合。ASP.NET
    Core 最小 API 将它们序列化为 JSON 或纯文本。
- en: 'Consider the following endpoint route handler, which returns a `string` value,
    as shown in the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下端点路由处理程序，它返回一个 `string` 值，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'ASP.NET Core Minimal APIs will return a `200` status code with a `Content-Type:
    text/plain; charset=utf-8` header and the following content in the body: `Hello
    World`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'ASP.NET Core 最小 API 将返回带有 `Content-Type: text/plain; charset=utf-8` 头的 `200`
    状态码，并在正文中包含以下内容：`Hello World`。'
- en: 'Now consider the following endpoint route handler, which returns an anonymous
    type, as shown in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下端点路由处理程序，它返回一个匿名类型，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'ASP.NET Core Minimal APIs will return a `200` status code with a `Content-Type:
    application/json; charset=utf-8` header and the following content in the body:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'ASP.NET Core 最小 API 将返回带有 `Content-Type: application/json; charset=utf-8` 头的
    `200` 状态码，并在正文中包含以下内容：'
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For more control over the response, there are helper methods that return an
    `IResult`, which defines a contract that represents the result of an HTTP endpoint.
    The static `Results` and `TypedResults` classes can be used to create various
    `IResult` objects that represent different types of responses.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地控制响应，存在返回 `IResult` 的辅助方法，它定义了一个表示 HTTP 端点结果的合同。静态 `Results` 和 `TypedResults`
    类可以用来创建代表不同类型响应的各种 `IResult` 对象。
- en: 'Returning `TypedResults` rather than `Results` has the following advantages:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于返回 `Results`，返回 `TypedResults` 具有以下优点：
- en: '`TypedResults` helpers return strongly typed objects, which can improve code
    readability and unit testing and reduce the chance of runtime errors.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypedResults` 辅助函数返回强类型对象，这可以提高代码可读性和单元测试，并减少运行时错误的可能性。'
- en: The implementation type automatically provides the response type metadata for
    OpenAPI to describe the endpoint.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现类型自动为 OpenAPI 提供响应类型元数据，以描述端点。
- en: The `TypedResults` class has a property named `Empty` that produces an empty
    result response, which when executed will do nothing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypedResults` 类有一个名为 `Empty` 的属性，它产生一个空的结果响应，当执行时将不会做任何事情。'
- en: 'The `TypedResults` class has methods to make it easy to return different responses,
    as shown in *Table 15.4*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypedResults` 类有方法使其能够轻松返回不同的响应，如 *表 15.4* 所示：'
- en: '| **Method** | **Description** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Bytes` | Returns a `200` status code and writes byte-array content to the
    response. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `Bytes` | 返回 `200` 状态码并将字节数组内容写入响应。|'
- en: '| `Content` | Returns a `200` status code and writes the content string to
    the HTTP response. Has an optional parameter to specify the media type header.
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `Content` | 返回 `200` 状态码并将内容字符串写入 HTTP 响应。有一个可选参数可以指定媒体类型头。|'
- en: '| `File` | Returns a `200` status code and writes the specified `Stream` to
    the response. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `File` | 返回 `200` 状态码并将指定的 `Stream` 写入响应。|'
- en: '| `Json` | Returns a `200` status code and serializes the specified data object
    in JSON format to the response. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `Json` | 返回 `200` 状态码并将指定的数据对象序列化为 JSON 格式发送到响应。|'
- en: '| `Ok` | Returns a `200` status code and a resource converted into the client’s
    preferred format, like JSON or XML. Commonly used in response to a `GET` request.
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `Ok` | 返回 `200` 状态码并将资源转换为客户端首选的格式，如 JSON 或 XML。通常用于响应 `GET` 请求。|'
- en: '| `Created`, `CreatedAtRoute` | Returns a `201` status code and the path to
    the new resource. Commonly used in response to a `POST` request to create a resource
    that can be created quickly. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `Created`, `CreatedAtRoute` | 返回 `201` 状态码和新的资源路径。通常用于响应创建资源快速创建的 `POST`
    请求。|'
- en: '| `Accepted`, `AcceptedAtRoute` | Returns a `202` status code to indicate the
    request is being processed but has not been completed. Commonly used in response
    to a `POST`, `PUT`, `PATCH`, or `DELETE` request that triggers a background process
    that takes a long time to complete. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `Accepted`, `AcceptedAtRoute` | 返回 `202` 状态码以指示请求正在处理但尚未完成。通常用于响应 `POST`、`PUT`、`PATCH`
    或 `DELETE` 请求，这些请求触发一个需要很长时间才能完成的后台进程。|'
- en: '| `Redirect`, `RedirectToRoute` | Returns a `301`, `307`, or `308` status code
    depending on a temporary or permanent redirect `bool` parameter, with the `url`
    to redirect to. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `Redirect`, `RedirectToRoute` | 根据临时或永久重定向的 `bool` 参数返回 `301`、`307` 或 `308`
    状态码，并带有要重定向到的 `url`。|'
- en: '| `Problem` | Produces a `ProblemDetails` response. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `Problem` | 生成 `ProblemDetails` 响应。|'
- en: '| `NoContent` | Returns a `204` status code and an empty response body. Commonly
    used in response to a `PUT`, `PATCH`, or `DELETE` request when the response does
    not need to contain the affected resource. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `NoContent` | 返回 `204` 状态码和空响应体。通常用于响应不需要包含受影响资源的 `PUT`、`PATCH` 或 `DELETE`
    请求。|'
- en: '| `BadRequest` | Returns a `400` status code and an optional message string
    with more details. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `BadRequest` | 返回 `400` 状态码和包含更多详细信息的可选消息字符串。|'
- en: '| `NotFound` | Returns a `404` status code and automatically populates the
    `ProblemDetails` body (requires a compatibility version of 2.2 or later). |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `NotFound` | 返回 `404` 状态码并自动填充 `ProblemDetails` 主体（需要 2.2 或更高版本的兼容性版本）。|'
- en: 'Table 15.4: TypedResults helper methods that return a response'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.4：返回响应的 `TypedResults` 辅助方法
- en: '**More Information**: You can learn more about how to create responses in a
    Minimal APIs web service at the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses?view=aspnetcore-9.0).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于如何在 Minimal APIs 网络服务中创建响应的信息：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses?view=aspnetcore-9.0)。'
- en: Creating a web service for the Northwind database
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Northwind 数据库创建网络服务
- en: 'We will reference the Entity Framework Core entity data model for the Northwind
    database that you created in *Chapter 12*, *Introducing Modern Web Development
    Using .NET*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引用您在 *第 12 章*，*使用 .NET 引入现代网络开发* 中创建的 Northwind 数据库的 Entity Framework Core
    实体数据模型：
- en: 'In the `Northwind.WebApi` project, globally and statically import the `System.Console`
    class, and add a project reference to the Northwind data context class library
    for either SQLite or SQL Server, as shown in the following markup:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi` 项目中，全局和静态导入 `System.Console` 类，并为 SQLite 或 SQL Server 添加对
    Northwind 数据上下文类库的项目引用，如下所示：
- en: '[PRE20]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Build the `Northwind.WebApi` project and fix any compile errors in your code.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `Northwind.WebApi` 项目并修复代码中的任何编译错误。
- en: 'In `Program.cs`, import namespaces for working with the Northwind entity model,
    as shown in the following code:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，导入用于处理 Northwind 实体模型的命名空间，如下所示：
- en: '[PRE21]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In `Program.cs`, add a statement before the call to `Build` to register the
    `Northwind` database context class (it will use either SQLite or SQL Server depending
    on which database provider you referenced in the project file), as shown in the
    following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在调用 `Build` 之前添加一个语句来注册 `Northwind` 数据库上下文类（它将使用 SQLite 或 SQL
    Server，具体取决于在项目文件中引用的数据库提供程序），如下所示：
- en: '[PRE22]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Registering dependency services
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册依赖服务
- en: 'You can register dependency services with different lifetimes, as shown in
    the following list:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用不同的生命周期注册依赖服务，如下列所示：
- en: '**Transient**: These services are created each time they’re requested. Transient
    services should be lightweight and stateless.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态**：每次请求时都会创建这些服务。瞬态服务应该是轻量级和无状态的。'
- en: '**Scoped**: These services are created once per client request and are disposed
    of. Then, the response is returned to the client.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域内**：这些服务在每个客户端请求时创建一次，然后被销毁。然后，将响应返回给客户端。'
- en: '**Singleton**: These services are usually created the first time they are requested
    and then are shared, although you can provide an instance at the time of registration
    too.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：这些服务通常在第一次请求时创建，然后被共享，尽管您也可以在注册时提供实例。'
- en: Introduced in .NET 8 is the ability to set a key for a dependency service. This
    allows multiple services to be registered with different keys and then retrieved
    later using that key.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 中引入了为依赖服务设置键的能力。这允许使用不同的键注册多个服务，然后使用该键稍后检索。
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this book, you will use all three types of lifetimes, but we will not need
    to use keyed services.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，您将使用所有三种生命周期，但我们不需要使用带键的服务。
- en: In-memory, distributed, and hybrid caches
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存、分布式和混合缓存
- en: Now let’s see an overview of in-memory, distributed, and hybrid caching.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来概述一下内存、分布式和混合缓存。
- en: In-memory caching
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存缓存
- en: In-memory caching stores data in the memory of the web server where the application
    is running. This is useful for small to medium-sized applications where the caching
    needs are not too extensive and can be handled by a single server’s memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 内存缓存将数据存储在运行应用程序的 Web 服务器内存中。这对于需要不太广泛的缓存需求的小型到中型应用程序很有用，并且可以由单个服务器的内存处理。
- en: 'The key points about in-memory caching are shown in the following list:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 内存缓存的要点如下所示：
- en: '**Performance**: Fast retrieval since the data is stored locally in RAM.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：由于数据存储在本地 RAM 中，因此检索速度快。'
- en: '**Simplicity**: Easy to implement and configure within the application.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：易于在应用程序中实现和配置。'
- en: '**Volatility**: Data is lost if the application restarts or the server goes
    down.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易变性**：如果应用程序重新启动或服务器关闭，数据将丢失。'
- en: '**Scalability**: Limited to a single server’s memory; not suitable for large-scale
    applications needing distributed caching.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：限于单个服务器的内存；不适合需要分布式缓存的大规模应用程序。'
- en: 'To implement in-memory caching, add the memory cache service to the services
    collection in `Program.cs`, as shown in the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现内存缓存，请在 `Program.cs` 中的服务集合中添加内存缓存服务，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Retrieve the service in an endpoint, as shown in the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在端点中检索服务，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set data in the cache, as shown in the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存中设置数据，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Get data from the cache, as shown in the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从缓存中获取数据，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now let’s compare in-memory caching to distributed caching.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来比较内存缓存和分布式缓存。
- en: Distributed caching
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: Distributed caching allows caching data across multiple servers, making it suitable
    for large-scale, distributed applications. This ensures data availability and
    consistency across different nodes in a web farm.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式缓存允许跨多个服务器缓存数据，这使得它适用于大规模、分布式应用程序。这确保了在 Web 农场中不同节点之间的数据可用性和一致性。
- en: 'The key points about in-memory caching are shown in the following list:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 内存缓存的关键点如下所示：
- en: '**Scalability**: Can handle large datasets and provide caching across multiple
    servers.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：可以处理大量数据集，并在多个服务器之间提供缓存。'
- en: '**Persistence**: Depending on the provider, data can be persisted beyond application
    restarts.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：根据提供者，数据可以在应用程序重启后持久化。'
- en: '**Latency**: May have higher latency compared to in-memory caching due to network
    calls.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：与内存缓存相比，可能具有更高的延迟，因为需要网络调用。'
- en: '**Providers**: Common providers include Redis, SQL Server, and NCache.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供者**：常见的提供者包括 Redis、SQL Server 和 NCache。'
- en: 'To implement in-memory caching, add it to the services collection in `Program.cs`,
    as shown in the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现内存缓存，请在 `Program.cs` 中的服务集合中添加它，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Retrieve the service in an endpoint, as shown in the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在端点中检索服务，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set data in the cache, as shown in the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存中设置数据，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Get data from the cache, as shown in the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从缓存中获取数据，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So, in-memory caching is fast and simple but limited to the server’s memory
    and loses data on restart. Distributed caching is scalable and persistent, ideal
    for large applications, with various providers like Redis and SQL Server.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内存缓存快速简单，但仅限于服务器的内存，并在重启时丢失数据。分布式缓存可扩展且持久，适用于大型应用程序，有各种提供者，如 Redis 和 SQL
    Server。
- en: Both approaches help improve application performance by reducing the need to
    repeatedly fetch or compute data. The choice between them depends on the application’s
    scale, performance needs, and architecture.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有助于通过减少重复获取或计算数据的需求来提高应用程序性能。选择它们取决于应用程序的规模、性能需求和架构。
- en: But what if we could get the best of both worlds?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们能够兼得两者之长呢？
- en: Let’s see a new option called hybrid caching.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个新的选项，称为混合缓存。
- en: Hybrid caching
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合缓存
- en: The HybridCache API introduced with ASP.NET Core 9 addresses some limitations
    found in the `IDistributedCache` and `IMemoryCache` APIs. As an abstract class
    with a default implementation, `HybridCache` efficiently manages most tasks related
    to storing and retrieving data from the cache.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 中引入的 HybridCache API 解决了在 `IDistributedCache` 和 `IMemoryCache`
    API 中发现的一些限制。作为一个具有默认实现的抽象类，`HybridCache` 高效地管理了与从缓存中存储和检索数据相关的多数任务。
- en: 'The key points about hybrid caching are shown in the following list:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 混合缓存的关键点如下所示：
- en: '**Unified API**: Provides a single interface for both in-process and out-of-process
    caching. `HybridCache` can seamlessly replace any existing `IDistributedCache`
    and `IMemoryCache` usage. It always uses the in-memory cache initially, and when
    an `IDistributedCache` implementation is available, `HybridCache` leverages it
    for secondary caching. This dual-level caching approach combines the speed of
    in-memory caching with the durability of distributed or persistent caching.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一 API**：为进程内和进程外缓存提供单个接口。`HybridCache` 可以无缝替换任何现有的 `IDistributedCache` 和
    `IMemoryCache` 使用。它最初始终使用内存缓存，当有 `IDistributedCache` 实现可用时，`HybridCache` 会利用它进行二级缓存。这种双级缓存方法结合了内存缓存的快速性和分布式或持久缓存的持久性。'
- en: '**Stampede Protection**: `HybridCache` prevents cache stampedes, which occur
    when a frequently used cache entry is invalidated, causing multiple requests to
    try to repopulate it simultaneously. `HybridCache` merges concurrent operations,
    ensuring all requests for the same response wait for the first request to be completed.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥挤保护**：`HybridCache` 防止缓存拥挤，这发生在频繁使用的缓存条目被失效时，导致多个请求同时尝试重新填充它。`HybridCache`
    合并并发操作，确保所有相同响应的请求都等待第一个请求完成。'
- en: '**Configurable Serialization**: `HybridCache` allows for configurable serialization
    during service registration, supporting both type-specific and generalized serializers
    via the `WithSerializer` and `WithSerializerFactory` methods, which are chained
    from the `AddHybridCache` call. By default, it manages `string` and `byte[]` internally
    and utilizes `System.Text.Json` for other types. It can be configured to use other
    serializers, such as Protobuf or XML.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置序列化**：`HybridCache` 允许在服务注册期间进行可配置的序列化，通过 `WithSerializer` 和 `WithSerializerFactory`
    方法支持类型特定的和通用的序列化器，这些方法是从 `AddHybridCache` 调用链式调用的。默认情况下，它内部管理 `string` 和 `byte[]`，并使用
    `System.Text.Json` 处理其他类型。它可以配置为使用其他序列化器，例如 Protobuf 或 XML。'
- en: Although HybridCache was introduced with .NET 9, its package targets .NET Standard
    2.0, so it can be used with older versions of .NET, even .NET Framework 4.6.2
    or later.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然混合缓存是在 .NET 9 中引入的，但其包针对 .NET Standard 2.0，因此它可以与较老的 .NET 版本一起使用，甚至包括 .NET
    Framework 4.6.2 或更高版本。
- en: Now that you’ve learned the concepts and basic implementation options for caching,
    let’s create a data repository for our web service that caches entities to improve
    performance and scalability.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了缓存的原理和基本实现选项，让我们为我们的 Web 服务创建一个数据仓库，该仓库缓存实体以提高性能和可伸缩性。
- en: Creating data repositories with caching for entities
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建具有缓存实体的数据仓库
- en: Defining and implementing a data repository to provide CRUD operations is good
    practice. We will create a data repository for the `Customers` table in Northwind.
    There are only 91 customers in this table, so we will cache a copy of the whole
    table in memory to improve scalability and performance when reading customer records.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 定义和实现数据仓库以提供 CRUD 操作是良好的实践。我们将为 Northwind 中的 `Customers` 表创建一个数据仓库。这个表中只有 91
    个客户，因此我们将整个表的副本缓存在内存中，以提高读取客户记录时的可伸缩性和性能。
- en: '**Good Practice**: In a real web service, you should use a distributed cache
    like Redis, an open-source data structure store that can be used as a high-performance,
    high-availability database, cache, or message broker. You can learn about this
    at the following link: [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在实际的 Web 服务中，你应该使用分布式缓存，如 Redis，这是一个开源的数据结构存储，可以用作高性能、高可用数据库、缓存或消息代理。你可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed)。'
- en: In .NET 9, `HybridCache` was introduced, which automatically switches between
    in-memory and distributed cache types.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 9 中，引入了 `HybridCache`，它可以在内存和分布式缓存类型之间自动切换。
- en: '**More Information**: You can learn more about `HybridCache` at the following
    link: [https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接中了解更多关于 `HybridCache` 的信息：[https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid?view=aspnetcore-9.0)。'
- en: 'We will follow a modern good practice and make the repository API asynchronous.
    It will be instantiated by an endpoint using parameter injection, so a new instance
    is created to handle every HTTP request. It will use a singleton instance of `HybridCache`.
    Let’s go:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循现代的良好实践，使仓库 API 异步。它将通过使用参数注入的端点实例化，因此为每个 HTTP 请求创建一个新的实例。它将使用 `HybridCache`
    的单例实例。让我们开始吧：
- en: 'In the `Northwind.WebApi.csproj` project file, add a package reference for
    hybrid caching, as shown in the following markup:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.csproj` 项目文件中，添加对混合缓存的包引用，如下所示：
- en: '[PRE32]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `Program.cs`, import the namespace for working with a hybrid cache, as shown
    in the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，导入用于处理混合缓存的命名空间，如下所示：
- en: '[PRE33]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `Program.cs`, before the call to `Build`, in the section for configuring
    services, register the hybrid cache service with a default cache entry duration
    of 60 seconds overall, and 30 seconds for local in-memory caching, as shown in
    the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在调用`Build`之前，在配置服务的部分，使用默认的缓存条目持续时间为60秒以及本地内存缓存为30秒，注册混合缓存服务，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the `Northwind.WebApi` project, create a folder named `Repositories`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.WebApi`项目中，创建一个名为`Repositories`的文件夹。
- en: Add a new interface file and a class file to the `Repositories` folder, named
    `ICustomerRepository.cs` and `CustomerRepository.cs`, respectively.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新接口文件和一个类文件添加到`Repositories`文件夹中，分别命名为`ICustomerRepository.cs`和`CustomerRepository.cs`。
- en: 'In `ICustomerRepository.cs`, define an interface with five CRUD methods, as
    shown in the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ICustomerRepository.cs`中，定义一个具有五个CRUD方法（创建、读取、更新、删除）的接口，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In `CustomerRepository.cs`, define a class that will implement the interface
    and uses the hybrid cache (its methods will be implemented over the next few steps,
    so, for now, ignore the errors you will be shown), as shown in the following code:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomerRepository.cs`中，定义一个将实现该接口并使用混合缓存（其方法将在接下来的几个步骤中实现，所以现在忽略你将看到的错误），如下面的代码所示：
- en: '[PRE36]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement the method that retrieves all customers to always read the latest
    customers from the database, as shown in the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个检索所有客户的方法，始终从数据库中读取最新的客户，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement the `Retrieve` method to get the customer from the cache if possible,
    or from the data model, and set it in the cache for next time, as shown in the
    following code:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于检索的`Retrieve`方法，如果可能的话，从缓存中获取客户，或从数据模型中获取，并将其设置在缓存中以便下次使用，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the `Create` method, as shown in the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于创建的`Create`方法，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Implement the `Update` method to update the database, and if successful, update
    the cached customer as well, as shown in the following code:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于更新数据库的`Update`方法，如果成功，同时更新缓存的客户，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implement the `Delete` method to delete the customer from the database, and
    if successful, remove the cached customer as well, as shown in the following code:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于删除的`Delete`方法，从数据库中删除客户，如果成功，同时删除缓存的客户，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Configuring the customer repository
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置客户仓库
- en: Now that you’ve learned the theory, you will put it into practice to configure
    the repository so that it can be called from within a Minimal API endpoint.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学到了理论，你将把它应用到实践中，以配置仓库，使其可以从Minimal API端点内部调用。
- en: You will register a scoped dependency service implementation for the repository
    when the web service starts up, and then use constructor parameter injection to
    get it inside the definition of a new Minimal API endpoint for working with customers.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络服务启动时，你将为仓库注册一个作用域依赖项服务实现，然后在定义新的用于处理客户的Minimal API端点时使用构造函数参数注入来获取它。
- en: 'It will have five action methods to perform CRUD operations on customers—two
    `GET` methods (for all customers or one customer), `POST` (create), `PUT` (update),
    and `DELETE`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 它将包含五个操作方法来对客户执行CRUD操作——两个`GET`方法（用于所有客户或单个客户）、`POST`（创建）、`PUT`（更新）和`DELETE`：
- en: 'In `Program.cs`, import the namespace for working with our customer repository,
    as shown in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入用于处理我们的客户仓库的命名空间，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `Program.cs`, add a statement before the call to the `Build` method, which
    will register the `CustomerRepository` for use at runtime as a scoped dependency,
    as shown in the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在调用`Build`方法之前添加一个语句，该语句将注册`CustomerRepository`以在运行时作为作用域依赖项使用，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Good Practice**: Our repository uses a database context that is registered
    as a scoped dependency. You can only use scoped dependencies inside other scoped
    dependencies, so we cannot register the repository as a singleton. You can read
    more about this at the following link: [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：我们的仓库使用一个注册为作用域依赖项的数据库上下文。你只能在其他作用域依赖项内部使用作用域依赖项，因此我们不能将仓库注册为单例。你可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped)。'
- en: In the `Northwind.WebApi` project, add a new class named `Program.Customers.cs`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.WebApi`项目中，添加一个名为`Program.Customers.cs`的新类。
- en: 'In `Program.Customers.cs`, add statements to define two Minimal API endpoint
    route handlers that respond to HTTP `GET` requests for all customers or customers
    within a specified country, as shown in the following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Customers.cs` 中添加语句以定义两个响应 HTTP `GET` 请求的所有客户或指定国家内客户的最低 API 端点路由处理程序，如下所示：
- en: '[PRE44]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In `Program.Customers.cs`, in the `MapCustomers` method, add statements to
    map an endpoint route handler that responds to HTTP `GET` requests for an individual
    customer, as shown in the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Customers.cs` 中，在 `MapCustomers` 方法中添加语句以映射响应单个客户 HTTP `GET` 请求的端点路由处理程序，如下所示：
- en: '[PRE45]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In `Program.Customers.cs`, add statements to map an endpoint route handler
    that responds to HTTP `POST` requests to insert a new customer entity, as shown
    in the following code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Customers.cs` 中添加语句以映射响应 HTTP `POST` 请求以插入新的客户实体，如下所示：
- en: '[PRE46]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In `Program.Customers.cs`, add statements to map an endpoint route handler
    that responds to HTTP `PUT` requests, as shown in the following code:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Customers.cs` 中添加语句以映射响应 HTTP `PUT` 请求的端点路由处理程序，如下所示：
- en: '[PRE47]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `Program.Customers.cs`, add statements to map an endpoint route handler
    that responds to HTTP `DELETE` requests, as shown in the following code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Customers.cs` 中添加语句以映射响应 HTTP `DELETE` 请求的端点路由处理程序，如下所示：
- en: '[PRE48]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In `Program.cs`, before the call to `Run`, call the extension method to map
    all the customer endpoint route handlers, as shown highlighted in the following
    code:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在调用 `Run` 之前，调用扩展方法以映射所有客户端点路由处理程序，如下所示：
- en: '[PRE49]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Save all the changes.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有更改。
- en: When an HTTP request is received by the service, it will create an instance
    of the `Controller` class, call the appropriate action method, return the response
    in the format preferred by the client, and release the resources used by the controller,
    including the repository and its data context.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务接收到 HTTP 请求时，它将创建 `Controller` 类的实例，调用适当的行为方法，以客户端偏好的格式返回响应，并释放控制器使用的资源，包括存储库及其数据上下文。
- en: Specifying problem details
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定问题详情
- en: A feature added in ASP.NET Core 2.1 and later is an implementation of a web
    standard for specifying problem details. If you want to take control, then you
    can create a `ProblemDetails` instance yourself and include additional information.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 2.1 及更高版本中添加的一个功能是实现一个用于指定问题详情的 web 标准。如果您想掌握控制权，则可以自己创建一个 `ProblemDetails`
    实例并包含附加信息。
- en: Let’s simulate a bad request that needs custom data to be returned to the client.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟一个需要返回自定义数据的错误请求。
- en: 'At the top of the implementation of the `Delete` endpoint route handler, add
    statements to check if the `id` matches the literal string value `"bad"`, and
    if so, return a custom `ProblemDetails` object, as shown in the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Delete` 端点路由处理程序的实现顶部，添加语句以检查 `id` 是否与字面字符串值 `"bad"` 匹配，如果是，则返回一个自定义的 `ProblemDetails`
    对象，如下所示：
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You will try out this functionality later.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在稍后尝试此功能。
- en: Documenting and trying out web services
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和尝试 web 服务
- en: You can easily try out a web service by making HTTP `GET` requests using a browser.
    To try out other HTTP methods, we need a more advanced tool.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在浏览器中使用 HTTP `GET` 请求轻松尝试 web 服务。要尝试其他 HTTP 方法，我们需要一个更高级的工具。
- en: Trying out GET requests using a browser
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浏览器尝试 GET 请求
- en: 'You will use Chrome to try out the three implementations of a `GET` request—for
    all customers, for customers in a specified country, and for a single customer
    using their unique customer ID:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用 Chrome 尝试三种 `GET` 请求的实现——对所有客户、对指定国家的客户以及使用其唯一的客户 ID 对单个客户的请求：
- en: Start the `Northwind.WebApi` web service project using the `https` launch profile.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `https` 启动配置启动 `Northwind.WebApi` web 服务项目。
- en: 'Start Chrome, navigate to `https://localhost:5151/customers`, and note the
    JSON document returned, containing all 91 customers in the Northwind database
    (unsorted), as shown in *Figure 15.2*:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Chrome，导航到 `https://localhost:5151/customers` 并注意返回的 JSON 文档，其中包含 Northwind
    数据库中的所有 91 个客户（未排序），如图 15.2 所示：
- en: '![](img/B22322_15_02.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![img/B22322_15_02.png]'
- en: 'Figure 15.2: Customers from the Northwind database as a JSON document'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2：Northwind 数据库中的客户作为 JSON 文档
- en: Navigate to `https://localhost:5151/customers/in/Germany` and note the JSON
    document returned, containing only the customers in Germany.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `https://localhost:5151/customers/in/Germany` 并注意返回的 JSON 文档，其中只包含德国的客户。
- en: If you get an empty array `[]` returned, then make sure you have entered the
    country name using the correct casing, because the database query is case-sensitive.
    For example, compare the results of `uk` and `UK`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您返回的是一个空数组`[]`，那么请确保您已使用正确的大小写输入国家名称，因为数据库查询是区分大小写的。例如，比较`uk`和`UK`的结果。
- en: Navigate to `https://localhost:5151/customers/alfki` and note the JSON document
    returned containing only the customer named **Alfreds Futterkiste**.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `https://localhost:5151/customers/alfki` 并注意返回的仅包含名为**Alfreds Futterkiste**的客户的JSON文档。
- en: Unlike country names, we do not need to worry about casing for the customer
    `id` value because, in the customer repository implementation, we normalized the
    `string` value as uppercase.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 与国家名称不同，我们不需要担心客户`id`值的大小写问题，因为在客户存储库实现中，我们将`string`值规范化为 uppercase。
- en: But how can we try out the other HTTP methods, such as `POST`, `PUT`, and `DELETE`?
    And how can we document our web service so it’s easy for anyone to understand
    how to interact with it?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何尝试其他HTTP方法，例如`POST`、`PUT`和`DELETE`？以及我们如何记录我们的网络服务，使其易于任何人理解如何与之交互？
- en: 'There are many tools for testing web services, for example, **Postman**. Although
    Postman is popular, I prefer tools like **HTTP Editor** in Visual Studio or **REST
    Client** in VS Code because they do not hide what is happening. I feel Postman
    is too GUI-y. But I encourage you to explore different tools and find the ones
    that fit your style. You can learn more about Postman at the following link: [https://www.postman.com/](https://www.postman.com/).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于测试网络服务的工具，例如**Postman**。尽管Postman很受欢迎，但我更喜欢Visual Studio中的**HTTP编辑器**或VS
    Code中的**REST客户端**这样的工具，因为它们不会隐藏正在发生的事情。我觉得Postman太图形化了。但我鼓励您探索不同的工具，找到适合您风格的工具。您可以在以下链接了解更多关于Postman的信息：[https://www.postman.com/](https://www.postman.com/)。
- en: To solve the first problem, we can use the **HTTP Editor** tool built into Visual
    Studio and install a VS Code extension named **REST Client**. Rider has its own
    equivalent. These are tools that allow you to send any type of HTTP request and
    view the response in your code editor.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，我们可以使用Visual Studio中内置的**HTTP编辑器**工具，并安装一个名为**REST客户端**的VS Code扩展。Rider有自己的等效工具。这些工具允许您发送任何类型的HTTP请求并在代码编辑器中查看响应。
- en: To solve the second problem, we can use **OpenAPI**, aka **Swagger**, the world’s
    most popular technology for documenting HTTP APIs. But first, let’s see what is
    possible with the code editor HTTP/REST tools.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第二个问题，我们可以使用**OpenAPI**，也称为**Swagger**，这是世界上用于记录HTTP API的最流行技术。但首先，让我们看看代码编辑器HTTP/REST工具能做什么。
- en: Making GET requests using HTTP/REST tools
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTP/REST工具发送GET请求
- en: 'We will start by creating a file for making `GET` requests:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个用于发送`GET`请求的文件：
- en: If you have not already installed **REST Client** by Huachao Mao (`humao.rest-client`),
    then install it for VS Code now.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未安装Huachao Mao的**REST客户端**（`humao.rest-client`），那么现在就为VS Code安装它。
- en: In your preferred code editor, open the `ModernWeb` solution and then start
    the `Northwind.WebApi` project web service.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的代码编辑器中打开`ModernWeb`解决方案，然后启动`Northwind.WebApi`项目网络服务。
- en: In **File Explorer**, **Finder**, or your favorite Linux file tool, in the `ModernWeb`
    folder, create an `HttpRequests` folder.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文件资源管理器**、**Finder**或您喜欢的Linux文件工具中，在`ModernWeb`文件夹中创建一个`HttpRequests`文件夹。
- en: In the `HttpRequests` folder, create a file named `get-customers.http`, and
    open it in your preferred code editor.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HttpRequests`文件夹中，创建一个名为`get-customers.http`的文件，并在您喜欢的代码编辑器中打开它。
- en: 'In `get-customers.http`, modify its contents to contain an HTTP `GET` request
    to retrieve all customers, as shown in the following code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`get-customers.http`中，修改其内容以包含一个用于检索所有客户的HTTP `GET`请求，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Above the HTTP `GET` request, click **Send request**, as shown in *Figure 15.3*.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTTP `GET`请求上方，点击**发送请求**，如图*15.3*所示。
- en: Note the response is shown in a new tabbed window.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意响应在新的选项卡窗口中显示。
- en: 'If you are using Visual Studio, then click the **Raw** tab, and note the JSON
    that was returned, as shown in *Figure 15.3*:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是Visual Studio，请点击**原始**选项卡，并注意返回的JSON，如图*15.3*所示：
- en: '![](img/B22322_15_03.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_15_03.png)'
- en: 'Figure 15.3: Sending an HTTP GET request using Visual Studio'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：使用Visual Studio发送HTTP GET请求
- en: 'HTTP Editor in Visual Studio version 17.8 and later is a feature designed to
    add REST client-like capabilities, and its user interface is likely to evolve
    rapidly as it catches up. You can read its official documentation at the following
    link: [https://learn.microsoft.com/en-us/aspnet/core/test/http-files](https://learn.microsoft.com/en-us/aspnet/core/test/http-files).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio版本17.8及以后的HTTP编辑器是一个旨在添加类似REST客户端功能的功能，其用户界面可能会迅速发展，以跟上进度。您可以在以下链接中阅读其官方文档：[https://learn.microsoft.com/en-us/aspnet/core/test/http-files](https://learn.microsoft.com/en-us/aspnet/core/test/http-files)。
- en: 'In `get-customers.http`, add more `GET` requests, each separated by three hash
    symbols, to test getting customers in various countries and getting a single customer
    using their ID, as shown in the following code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`get-customers.http`中添加更多的`GET`请求，每个请求之间用三个井号分隔，以测试获取不同国家的客户以及使用ID获取单个客户，如下所示：
- en: '[PRE52]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Click the **Send Request** link above each request to send it, and confirm you
    get the expected response, like a 404 for a non-existent customer.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击每个请求上方的**发送请求**链接来发送请求，并确认您获得了预期的响应，例如对于不存在的客户返回404。
- en: Making other requests using HTTP/REST tools
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTP/REST工具制作其他请求
- en: 'Next, we will create a file for making other requests like `POST`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个用于制作其他请求（如`POST`）的文件：
- en: 'In the `HttpRequests` folder, create a file named `create-customer.http` and
    modify its contents to define a `POST` request to create a new customer, as shown
    in the following code:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HttpRequests`文件夹中，创建一个名为`create-customer.http`的文件，并修改其内容以定义创建新客户的`POST`请求，如下所示：
- en: '[PRE53]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Send the request and note the response is `201 Created`. Also note in the **Headers**
    section that the **Location** (that is, the URL) of the newly created customer
    is `/customers/ABCXY`, as shown in *Figure 15.4*, and the response included the
    newly created customer in the response body (not shown in the screenshot but you
    can see it in the **Formatted** and **Raw** sections):'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求并注意响应为`201 Created`。同时注意在**头部**部分，新创建客户的**位置**（即URL）为`/customers/ABCXY`，如图*15.4*所示，并且响应体中包含了新创建的客户（截图未显示，但您可以在**格式化**和**原始**部分中看到）：
- en: '![](img/B22322_15_04.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_15_04.png)'
- en: 'Figure 15.4: Adding a new customer by POSTing to the web service'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：通过向Web服务POST添加新客户
- en: 'I will leave you an optional challenge to create `.http` files that try updating
    a customer (using `PUT`) and deleting a customer (using `DELETE`). Try them on
    customers that do exist as well as customers that do not. Solutions are in the
    GitHub repository for this book at the following link:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我将给您一个可选的挑战，创建`.http`文件尝试更新客户（使用`PUT`）和删除客户（使用`DELETE`）。尝试在确实存在的客户以及不存在的客户上操作。解决方案可以在本书的GitHub仓库中的以下链接找到：
- en: '[https://github.com/markjprice/cs13net9/tree/main/code/ModernWeb/HttpRequests](https://github.com/markjprice/cs13net9/tree/main/code/ModernWeb/HttpRequests)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/tree/main/code/ModernWeb/HttpRequests](https://github.com/markjprice/cs13net9/tree/main/code/ModernWeb/HttpRequests)'
- en: Passing environment variables
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递环境变量
- en: 'To get an environment variable in a `.http` script, use `$processenv`, as shown
    in the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`.http`脚本中获取环境变量，使用`$processenv`，如下所示：
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For example, if you have set an environment variable to store a secret value
    like a password to connect to a SQL Server database that must be kept out of any
    files committed to a GitHub repository, you can use the following command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您已设置环境变量来存储密码等秘密值以连接到必须从提交到GitHub仓库的任何文件中排除的SQL Server数据库，您可以使用以下命令：
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**More Information**: You can learn more about using environment variables
    with the REST client at the following link: [https://marketplace.visualstudio.com/items?itemName=humao.rest-client#environments](https://marketplace.visualstudio.com/items?itemName=humao.rest-client#environments).
    You can learn more about using environment variables and Secret Manager with HTTP
    Editor at the following link: [https://devblogs.microsoft.com/visualstudio/safely-use-secrets-in-http-requests-in-visual-studio-2022/](https://devblogs.microsoft.com/visualstudio/safely-use-secrets-in-http-requests-in-visual-studio-2022/).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于使用REST客户端环境变量的信息：[https://marketplace.visualstudio.com/items?itemName=humao.rest-client#environments](https://marketplace.visualstudio.com/items?itemName=humao.rest-client#environments)。您可以在以下链接中了解更多关于使用环境变量和Secret
    Manager与HTTP编辑器的信息：[https://devblogs.microsoft.com/visualstudio/safely-use-secrets-in-http-requests-in-visual-studio-2022/](https://devblogs.microsoft.com/visualstudio/safely-use-secrets-in-http-requests-in-visual-studio-2022/).'
- en: Now that we’ve seen a quick and easy way to test our service, which also happens
    to be a great way to learn HTTP, what about external developers? We want it to
    be as easy as possible for them to learn about and then call our service. For
    that purpose, we will use Swagger.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了测试我们的服务的一种快速简单的方法，这同时也是学习 HTTP 的好方法，那么对于外部开发者来说呢？我们希望他们学习并调用我们的服务尽可能简单。为此，我们将使用
    Swagger。
- en: Understanding the OpenAPI Specification
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 OpenAPI 规范
- en: The **OpenAPI Specification** defines a REST-style contract for your API, detailing
    all its resources and operations in a human- and machine-readable format for easy
    development, discovery, and integration.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenAPI 规范**定义了您的 API 的 REST 风格合约，详细说明了所有资源及其操作，以人类和机器可读的格式，便于开发、发现和集成。'
- en: Developers can use the OpenAPI Specification for a web service to automatically
    generate strongly typed client-side code in their preferred language or library.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用网络服务的 OpenAPI 规范来自动生成他们首选语言或库中的强类型客户端代码。
- en: 'Let’s review how OpenAPI is enabled for our web service:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何为我们的网络服务启用 OpenAPI：
- en: If the web service is running, shut down the web server.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果网络服务正在运行，请关闭网络服务器。
- en: 'In `Northwind.WebApi.csproj`, note the package reference for Microsoft’s package
    that implements documentation for OpenAPI that was added by the project template,
    as shown in the following markup:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.csproj` 中，注意项目模板添加的用于实现 OpenAPI 文档的 Microsoft 包引用，如下面的标记所示：
- en: '[PRE56]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In `Program.cs`, in the section for adding services to the container, note
    the service registered by the project template to use OpenAPI, as shown in the
    following code:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在添加服务到容器的部分，注意项目模板注册的用于使用 OpenAPI 的服务，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'By default, the document name is `v1`. Set the document name parameter to `v2`,
    as shown in the following code:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，文档名称是 `v1`。将文档名称参数设置为 `v2`，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the section that configures the HTTP request pipeline, note the statements
    for using OpenAPI when in development mode, as shown highlighted in the following
    code:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置 HTTP 请求管道的章节中，注意使用 OpenAPI 在开发模式下的语句，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Start the `Northwind.WebApi` web service project using the `https` launch profile.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `https` 启动配置启动 `Northwind.WebApi` 网络服务项目。
- en: 'Start Chrome, navigate to `https://localhost:5151/openapi/v2.json`, and note
    the JSON document returned, as shown in *Figure 15.5*:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Chrome，导航到 `https://localhost:5151/openapi/v2.json`，并注意返回的 JSON 文档，如图 15.5
    所示：
- en: '![](img/B22322_15_05.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_15_05.png)'
- en: 'Figure 15.5: OpenAPI JSON documentation for the Northwind web service'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5：Northwind 网络服务的 OpenAPI JSON 文档
- en: 'Note the following about the OpenAPI JSON document:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 OpenAPI JSON 文档的以下注意事项：
- en: It specifies all the relative paths for the service, like `/weatherforecast/{days}`.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它指定了服务的所有相对路径，例如：`/weatherforecast/{days}`。
- en: For parameters like `days`, it specifies their type and default value, like
    `"parameters":[{"name":"days","in":"path","required":true,"schema":{"type":"integer","format":"int32","default":5}}]`.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于像 `days` 这样的参数，它指定了它们的类型和默认值，例如：`"parameters":[{"name":"days","in":"path","required":true,"schema":{"type":"integer","format":"int32","default":5}}]`。
- en: 'There are two techniques that you can use to add extra information to the generated
    documentation, `WithSummary` and `WithDescription`. These are available as either
    calling extension methods after mapping the endpoint or by decorating the lambda
    expression with attributes, as shown in the following code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两种技术来向生成的文档添加额外信息，`WithSummary` 和 `WithDescription`。这些技术可以通过在映射端点后调用扩展方法或通过用属性装饰lambda表达式来实现，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**More Information**: You can learn more at the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/openapi?view=aspnetcore-9.0#describe-endpoints](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/openapi?view=aspnetcore-9.0#describe-endpoints).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/openapi?view=aspnetcore-9.0#describe-endpoints](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/openapi?view=aspnetcore-9.0#describe-endpoints)。'
- en: Enabling HTTP logging
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 HTTP 记录
- en: 'HTTP logging is an optional middleware component that is useful when testing
    a web service. It logs information about HTTP requests and HTTP responses, including
    the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 记录是一个可选的中间件组件，在测试网络服务时非常有用。它记录有关 HTTP 请求和 HTTP 响应的信息，包括以下内容：
- en: Information about the HTTP request
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 HTTP 请求的信息
- en: Headers
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部
- en: Body
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体
- en: Information about the HTTP response
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 HTTP 响应的信息
- en: This is valuable in web services for auditing and debugging scenarios but beware
    because it can negatively impact performance. You might also log **Personally
    Identifiable Information** (**PII**), which can cause compliance issues in some
    jurisdictions.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Web 服务的审计和调试场景中非常有用，但请注意，它可能会对性能产生负面影响。你也可能会记录 **个人身份信息**（**PII**），这可能会在某些司法管辖区引起合规性问题。
- en: 'Log levels can be set to the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 日志级别可以设置为以下：
- en: '`Error`: Only `Error` level logs'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`错误`: 只有 `错误` 级别的日志'
- en: '`Warning`: `Error` and `Warning` level logs'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`警告`: `错误` 和 `警告` 级别的日志'
- en: '`Information`: `Error`, `Warning`, and `Information` level logs'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`信息`: `错误`, `警告`, 和 `信息` 级别的日志'
- en: '`Verbose`: All level logs'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`详细`: 所有级别的日志'
- en: 'Log levels can be set for the namespace in which the functionality is defined.
    Nested namespaces allow us to control which functionality has logging enabled:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为定义功能性的命名空间设置日志级别。嵌套的命名空间允许我们控制哪些功能启用了日志记录：
- en: '`Microsoft`: Include all log types in the `Microsoft` namespace'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft`: 在 `Microsoft` 命名空间中包含所有日志类型'
- en: '`Microsoft.AspNetCore`: Include all log types in the `Microsoft.AspNetCore`
    namespace'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore`: 在 `Microsoft.AspNetCore` 命名空间中包含所有日志类型'
- en: '`Microsoft.AspNetCore.HttpLogging`: Include all log types in the `Microsoft.AspNetCore.HttpLogging`
    namespace'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.HttpLogging`: 在 `Microsoft.AspNetCore.HttpLogging` 命名空间中包含所有日志类型'
- en: 'Let’s see HTTP logging in action:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 HTTP 日志的实际应用：
- en: 'In the `Northwind.WebApi` project, `appsettings.Development.json`, add an entry
    to set the HTTP logging middleware to the `Information` level, as shown highlighted
    in the following code:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi` 项目中，`appsettings.Development.json` 文件中添加一个条目来设置 HTTP 日志中间件为
    `信息` 级别，如下面高亮显示的代码所示：
- en: '[PRE61]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Although the `Default` log level might be set to `Information`, more specific
    configurations take priority. For example, any logging systems in the `Microsoft.AspNetCore`
    namespace will use the `Warning` level. By making the change we did, any logging
    systems in the `Microsoft.AspNetCore.` `HttpLogging.HttpLoggingMiddleware` namespace
    will now use `Information`.
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管默认的日志级别可能被设置为 `信息`，但更具体的配置具有优先级。例如，`Microsoft.AspNetCore` 命名空间中的任何日志系统都将使用
    `警告` 级别。通过我们所做的更改，`Microsoft.AspNetCore.` `HttpLogging.HttpLoggingMiddleware`
    命名空间中的任何日志系统现在将使用 `信息` 级别。
- en: 'In `Program.cs`, import the namespace for working with HTTP logging, as shown
    in the following code:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，导入用于处理 HTTP 日志的命名空间，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the services configuration section, before the call to `Build`, add a statement
    to configure HTTP logging, as shown in the following code:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务配置部分，在调用 `Build` 之前，添加一个语句来配置 HTTP 日志，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the HTTP pipeline configuration section, before the call to `app.UseHttpsRedirection`,
    add a statement to add HTTP logging, as shown in the following code:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HTTP 管道配置部分，在调用 `app.UseHttpsRedirection` 之前，添加一个语句来添加 HTTP 日志，如下面的代码所示：
- en: '[PRE64]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Start the `Northwind.WebApi` web service using the `https` launch profile.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `https` 启动配置启动 `Northwind.WebApi` 网络服务。
- en: Start Chrome and navigate to `https://localhost:5151/customers`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Chrome 并导航到 `https://localhost:5151/customers`。
- en: 'In the command prompt or terminal that shows the output from the web service
    host, note the request and response have been logged, as shown in the following
    partial output:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示来自网络服务主机输出的命令提示符或终端中，注意请求和响应已经被记录，如下面的部分输出所示：
- en: '[PRE65]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Close Chrome and shut down the web server.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 Chrome 并关闭网络服务器。
- en: Logging to the Windows-only Event Log
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅记录 Windows 的事件日志
- en: 'When configuring logging, you might want to enable logging to the Windows Event
    Log, as shown in the following code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置日志时，你可能想要启用将日志记录到 Windows 事件日志，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You will see a code analyzer warning, `CA1416`, because enabling Event Log only
    works on Windows. If you run this code on any other OS, then a runtime exception
    would be thrown. To avoid the warning (and runtime error), you should wrap the
    call to `AddEventLog` with an OS check.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个代码分析器警告，`CA1416`，因为仅启用事件日志在 Windows 上有效。如果你在其他操作系统上运行此代码，则会抛出运行时异常。为了避免警告（以及运行时错误），你应该使用
    OS 检查来包裹对 `AddEventLog` 的调用。
- en: 'First, import a namespace, as shown in the following code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入一个命名空间，如下面的代码所示：
- en: '[PRE67]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, wrap any calls to `AddEventLog`, as shown in the following code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将任何对 `AddEventLog` 的调用包裹起来，如下面的代码所示：
- en: '[PRE68]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Support for logging additional request headers in W3CLogger
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: W3CLogger 支持记录额外的请求头
- en: 'W3CLogger is a middleware that writes logs in the W3C standard format. You
    can:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: W3CLogger 是一个中间件，它以 W3C 标准格式写入日志。你可以：
- en: Record details of HTTP requests and responses.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录 HTTP 请求和响应的详细信息。
- en: Filter which headers and parts of the request and response messages are logged.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤记录哪些头信息和请求/响应消息的部分。
- en: '**Warning!** W3CLogger can reduce the performance of an app.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** W3CLogger 可能会降低应用程序的性能。'
- en: 'W3CLogger is like HTTP logging, so I will not cover details of how to use it
    in this book. You can learn more about W3CLogger at the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/w3c-logger/](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/w3c-logger/).'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: W3CLogger 类似于 HTTP 日志记录，因此在这本书中我不会详细说明如何使用它。您可以在以下链接中了解更多关于 W3CLogger 的信息：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/w3c-logger/](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/w3c-logger/).
- en: 'In ASP.NET Core 7 or later, you can specify that you want to log additional
    request headers when using W3CLogger. Call the `AdditionalRequestHeaders` method
    and pass the name of the header you want to log, as shown in the following code:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 7 或更高版本中，您可以在使用 W3CLogger 时指定要记录额外的请求头。调用 `AdditionalRequestHeaders`
    方法并传递您想要记录的头名称，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You are now ready to build applications that consume your web service.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以构建并运行使用您的 Web 服务的应用程序。
- en: Consuming web services using HTTP clients
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP 客户端消费 Web 服务
- en: Now that we have built and tested our Northwind service, we will learn how to
    call it from any .NET app using the `HttpClient` class and its factory.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建并测试了我们的 Northwind 服务，我们将学习如何使用 `HttpClient` 类及其工厂从任何 .NET 应用程序中调用它。
- en: Understanding HttpClient
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 HttpClient
- en: The easiest way to consume a web service is to use the `HttpClient` class. However,
    many people use it wrongly because it implements `IDisposable`, and Microsoft’s
    own documentation shows poor usage of it. See the book links in the GitHub repository
    for articles with more discussion of this.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 消费 Web 服务最简单的方法是使用 `HttpClient` 类。然而，许多人错误地使用它，因为它实现了 `IDisposable` 接口，并且微软自己的文档显示了其不良的使用方式。请参阅
    GitHub 仓库中的书籍链接，以获取更多关于此问题的讨论文章。
- en: Usually, when a type implements `IDisposable`, you should create it inside a
    `using` statement to ensure that it is disposed of as soon as possible. `HttpClient`
    is different because it is shared, reentrant, and partially thread-safe.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个类型实现了 `IDisposable` 接口时，您应该在其内部创建它，以确保它能够尽快被销毁。`HttpClient` 是不同的，因为它是可以共享的、可重入的，并且部分线程安全。
- en: The problem has to do with how the underlying network sockets must be managed.
    The bottom line is that you should use a single instance of it for each HTTP endpoint
    that you consume during the life of your application. This will allow each `HttpClient`
    instance to have defaults set that are appropriate for the endpoint it works with
    while managing the underlying network sockets efficiently.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 问题与如何管理底层网络套接字有关。底线是，您应该在应用程序的生命周期内为每个您消费的 HTTP 端点使用单个实例。这将允许每个 `HttpClient`
    实例具有适合其工作的默认设置，同时有效地管理底层网络套接字。
- en: Configuring HTTP clients
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 HTTP 客户端
- en: Microsoft is aware of the issue of .NET developers misusing `HttpClient`, and
    in ASP.NET Core 2.1, it introduced `HttpClientFactory` to encourage best practices;
    that is the technique we will use.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已经意识到 .NET 开发者误用 `HttpClient` 的问题，并在 ASP.NET Core 2.1 中引入了 `HttpClientFactory`
    以鼓励最佳实践；这正是我们将要使用的技术。
- en: 'In the following example, we will create a Northwind Blazor WebAssembly standalone
    project as a client for the Northwind Web API service. Let’s configure an HTTP
    client:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建一个 Northwind Blazor WebAssembly 独立项目作为 Northwind Web API 服务的客户端。让我们配置一个
    HTTP 客户端：
- en: 'Use your preferred code editor to open the `ModernWeb` solution and then add
    a new project, as defined in the following list:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器打开 `ModernWeb` 解决方案，然后添加一个新项目，如下所示：
- en: 'Project template: **Blazor WebAssembly Standalone App**/ `blazorwasm`'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**Blazor WebAssembly 独立应用程序**/ `blazorwasm`
- en: 'Solution file and folder: `ModernWeb`'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`ModernWeb`
- en: 'Project file and folder: `Northwind.WebApi.WasmClient`'
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.WebApi.WasmClient`
- en: '**Authentication type**: None'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证类型**：无'
- en: '**Configure for HTTPS**: Selected'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置为 HTTPS**：已选择'
- en: '**Progressive Web Application**: Cleared'
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渐进式 Web应用程序**：已清除'
- en: '**Include sample pages**: Selected'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含示例页面**：已选择'
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不使用顶层语句**：已清除'
- en: In the `Northwind.WebApi.WasmClient.csproj` project file, in the package references,
    remove version attributes.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.WasmClient.csproj` 项目文件中，在包引用中删除版本属性。
- en: 'In the `Properties` folder, in `launchSettings.json`, for the `https` profile,
    for its `applicationUrl`, change the random port number for HTTPS to `5152` and
    for HTTP to `5153`, as shown highlighted in the following markup:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Properties` 文件夹中，在 `launchSettings.json` 文件中，对于 `https` 配置文件，对于其 `applicationUrl`，将
    HTTPS 的随机端口号更改为 `5152`，对于 HTTP 更改为 `5153`，如下所示（高亮显示）：
- en: '[PRE70]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Save changes to all modified files.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有修改过的文件。
- en: 'In `Program.cs`, in the call to the `AddScoped` method, add a statement to
    enable `HttpClientFactory` with a named client to make calls to the Northwind
    Web API service using HTTPS on port `5151` and request JSON as the default response
    format, as shown in the following code:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，在调用 `AddScoped` 方法的地方，添加一条语句以启用 `HttpClientFactory` 的命名客户端，通过
    HTTPS 在端口 `5151` 上调用 Northwind Web API 服务，并将 JSON 作为默认的响应格式，如下所示：
- en: '[PRE71]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the `Northwind.WebApi` project, in `Program.cs`, at the top of the file
    after the namespace imports, declare a string constant for the name of a CORS
    policy, as shown in the following code:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi` 项目中，在 `Program.cs` 文件中，在命名空间导入之后，声明一个字符串常量用于 CORS 策略的名称，如下所示：
- en: '[PRE72]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In `Program.cs`, before the call to `Build`, add CORS and configure a policy
    to allow HTTP calls from clients with different port numbers from the web service
    itself, as shown in the following code:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，在调用 `Build` 之前，添加 CORS 并配置策略以允许来自与 Web 服务自身不同端口号的客户端的 HTTP
    调用，如下所示：
- en: '[PRE73]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In `Program.cs`, after the call to `UseHttpsRedirection`, enable CORS with
    the named policy, as shown in the following code:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，在调用 `UseHttpsRedirection` 之后，使用命名策略启用 CORS，如下所示：
- en: '[PRE74]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Getting customers as JSON in a Blazor component
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Blazor 组件中以 JSON 格式获取客户
- en: 'We can now create a client page that:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个客户端页面：
- en: Makes a `GET` request for customers.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对客户进行 `GET` 请求。
- en: Deserializes the JSON response using convenient extension methods introduced
    with .NET 5 in the `System.Net.Http.Json` assembly and namespace.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .NET 5 中引入的方便的扩展方法，在 `System.Net.Http.Json` 程序集和命名空间中反序列化 JSON 响应。
- en: 'Let’s go:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'In the `Northwind.WebApi.WasmClient.csproj` project file, add a reference to
    the entity models project, as shown in the following markup:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.WasmClient.csproj` 项目文件中，添加对实体模型项目的引用，如下所示：
- en: '[PRE75]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the `Northwind.WebApi.WasmClient` project, in `_Imports.razor`, import the
    namespace for working with entity models, as shown in the following code:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.WasmClient` 项目中，在 `_Imports.razor` 文件中，导入用于处理实体模型的命名空间，如下所示：
- en: '[PRE76]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the `Northwind.WebApi.WasmClient` project, in the `Pages` folder, add a new
    file named `Customers.razor`.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.WebApi.WasmClient` 项目中，在 `Pages` 文件夹中，添加一个名为 `Customers.razor`
    的新文件。
- en: 'In `Customers.razor`, inject the HTTP client service, and use it to call the
    Northwind Web API service, fetching all customers, and passing them to a table,
    as shown in the following markup:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Customers.razor` 文件中，注入 HTTP 客户端服务，并使用它调用 Northwind Web API 服务，获取所有客户，并将它们传递到一个表格中，如下所示：
- en: '[PRE77]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the `Layout` folder, in `NavMenu.razor`, change the **Weather** menu item
    to show customers instead, as shown in the following markup:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Layout` 文件夹中，在 `NavMenu.razor` 文件中，将 **天气** 菜单项更改为显示客户，如下所示：
- en: '[PRE78]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Starting multiple projects
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动多个项目
- en: Up to this point, we have only started one project at a time. Now we have two
    projects that need to be started, a web service and a Blazor client website. In
    the step-by-step instructions, I will only tell you to start individual projects
    one at a time, but you should use whatever technique you prefer to start them.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一次只启动了一个项目。现在我们有两个项目需要启动，一个是 Web 服务，另一个是 Blazor 客户端网站。在逐步说明中，我将只告诉您逐个启动单个项目，但您应该使用您喜欢的任何技术来启动它们。
- en: If you are using Visual Studio
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果您正在使用 Visual Studio
- en: 'Visual Studio can start multiple projects manually one by one if the debugger
    is not attached, as described in the following steps:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 可以在不附加调试器的情况下手动逐个启动多个项目，具体步骤如下：
- en: In **Solution Explorer**, right-click on the solution or any project and then
    select **Configure Startup Projects…**, or select the solution and navigate to
    **Project** | **Configure Startup Projects…**.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中，右键单击解决方案或任何项目，然后选择 **配置启动项目…**，或者选择解决方案并导航到 **项目** | **配置启动项目…**。
- en: In the **Solution ‘<name>’ Property Pages** dialog box, select **Current selection**.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案属性页** 对话框中，选择 **当前选择**。
- en: Click **OK**.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **确定**。
- en: Select a project in **Solution Explorer** so that its name becomes bold.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中选择一个项目，使其名称变为粗体。
- en: Navigate to **Debug** | **Start Without Debugging** or press *Ctrl* + *F5*.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**调试** | **启动而不调试**或按 *Ctrl* + *F5*。
- en: Repeat *steps 2* and *3* for as many projects as you need.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复**步骤 2**和**步骤 3**，直到你需要的项目数量。
- en: If you need to debug the projects, then you must start multiple instances of
    Visual Studio. Each instance can start a single project with debugging.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要调试项目，那么你必须启动多个 Visual Studio 实例。每个实例可以启动一个带调试的单个项目。
- en: 'You can also configure multiple projects to start up at the same time using
    the following steps:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以按照以下步骤配置多个项目同时启动：
- en: In **Solution Explorer**, right-click the solution or any project and then select
    **Configure Startup Projects…**, or select the solution and navigate to **Project**
    | **Configure Startup Projects…**.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，右键单击解决方案或任何项目，然后选择**配置启动项目…**，或者选择解决方案并导航到**项目** | **配置启动项目…**。
- en: 'In the **Solution ‘<name>’ Property Pages** dialog box, select **Multiple startup
    projects**, and for any projects that you want to start, select either **Start**
    or **Start without debugging**, as shown in *Figure 15.6*:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**“解决方案 '<name>' 属性页”**对话框中，选择**多个启动项目**，对于你想要启动的任何项目，选择**启动**或**启动而不调试**，如图*15.6*所示：
- en: '![](img/B22322_15_06.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_15_06.png)'
- en: 'Figure 15.6: Selecting multiple projects to start up in Visual Studio'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：在 Visual Studio 中选择要启动的多个项目
- en: Click **OK**.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。
- en: Navigate to **Debug** | **Start Debugging** or **Debug** | **Start Without Debugging**
    or click the equivalent buttons in the toolbar to start all the projects that
    you selected.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**调试** | **开始调试**或**调试** | **启动而不调试**，或者在工具栏中点击等效按钮以启动你选择的所有项目。
- en: 'You can learn more about multi-project startup using Visual Studio at the following
    link: [https://learn.microsoft.com/en-us/visualstudio/ide/how-to-set-multiple-startup-projects](https://learn.microsoft.com/en-us/visualstudio/ide/how-to-set-multiple-startup-projects).'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于使用 Visual Studio 进行多项目启动的信息：[https://learn.microsoft.com/en-us/visualstudio/ide/how-to-set-multiple-startup-projects](https://learn.microsoft.com/en-us/visualstudio/ide/how-to-set-multiple-startup-projects).
- en: If you are using VS Code
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果你正在使用 VS Code
- en: If you need to start multiple projects at the command line with `dotnet`, then
    write a script or batch file to execute multiple `dotnet run` commands, or open
    multiple command prompt or terminal windows.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用 `dotnet` 在命令行中启动多个项目，那么请编写一个脚本来执行多个 `dotnet run` 命令，或者打开多个命令提示符或终端窗口。
- en: If you need to debug multiple projects using VS Code, then after you’ve started
    the first debug session, you can just launch another session. Once the second
    session is running, the user interface switches to multi-target mode. For example,
    in the **CALL STACK**, you will see both named projects with their own threads,
    and then the debug toolbar shows a drop-down list of sessions with the active
    one selected. Alternatively, you can define compound launch configurations in
    the `launch.json`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用 VS Code 调试多个项目，那么在你启动第一个调试会话后，你可以启动另一个会话。一旦第二个会话开始运行，用户界面将切换到多目标模式。例如，在**调用栈**中，你会看到带有自己线程的命名项目，然后调试工具栏显示一个包含活动会话的下拉列表。或者，你可以在
    `launch.json` 中定义复合启动配置。
- en: 'You can learn more about multi-target debugging using VS Code at the following
    link: [https://code.visualstudio.com/Docs/editor/debugging#_multitarget-debugging](https://code.visualstudio.com/Docs/editor/debugging#_multitarget-debugging).'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于使用 VS Code 进行多目标调试的信息：[https://code.visualstudio.com/Docs/editor/debugging#_multitarget-debugging](https://code.visualstudio.com/Docs/editor/debugging#_multitarget-debugging).
- en: Starting the web service and Blazor client projects
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 Web 服务和 Blazor 客户端项目
- en: 'Now we can try out the web service with the Blazor client calling it:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试使用 Blazor 客户端调用 Web 服务：
- en: 'Start the `Northwind.WebApi` project and confirm that the web service is listening
    on ports `5151` and `5150`, as shown in the following output:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `Northwind.WebApi` 项目，并确认 Web 服务正在监听端口 `5151` 和 `5150`，如下所示输出：
- en: '[PRE79]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Start the `Northwind.WebApi.WasmClient` project and confirm that the website
    is listening on ports `5152` and `5153`, as shown in the following output:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `Northwind.WebApi.WasmClient` 项目，并确认网站正在监听端口 `5152` 和 `5153`，如下所示输出：
- en: '[PRE80]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Start Chrome and navigate to `https://localhost:5152/`.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Chrome 并导航到 `https://localhost:5152/`。
- en: 'On the home page, in the left navigation menu, click **Customers**, and note
    the list of customers, as shown in *Figure 15.7*:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主页上，在左侧导航菜单中，点击**客户**，并注意客户列表，如图*15.7*所示：
- en: '![](img/B22322_15_07.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_15_07.png)'
- en: 'Figure 15.7: Customers worldwide fetched from a web service'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7：从 Web 服务获取的全球客户
- en: 'In the command prompt or terminal for the web service, note that HTTP logging
    shows that a successful request was made for customers, as shown in the following
    output:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Web 服务的命令提示符或终端中，注意 HTTP 日志显示已成功请求客户，如下所示：
- en: '[PRE81]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the address bar, change the path to specify a country like `Germany`, `UK`,
    or `USA`, for example: `customers/UK`. Press *Enter* and note the table updates
    to only show UK customers.'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地址栏中，将路径更改为指定国家，例如 `Germany`、`UK` 或 `USA`，例如：`customers/UK`。按 *Enter* 并注意表格更新，只显示
    UK 客户。
- en: Close Chrome and shut down the two web servers.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 Chrome 并关闭两个 Web 服务器。
- en: Practicing and exploring
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些动手实践以及更深入地研究本章的主题来测试你的知识和理解。
- en: Exercise 15.1 – Online material
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.1 – 在线材料
- en: Online material could be created by Microsoft or third-parties, or extra content
    for this book.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 网络材料可以由微软或第三方创建，或为本书提供额外内容。
- en: Implementing advanced features for web services
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Web 服务的高级功能
- en: 'If you would like to learn about web service health checks, OpenAPI analyzers,
    adding security HTTP headers, and enabling HTTP/3 support for `HttpClient`, then
    you can read the optional online-only section at the following link:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解有关 Web 服务健康检查、OpenAPI 分析器、添加安全 HTTP 标头以及为 `HttpClient` 启用 HTTP/3 支持的信息，那么你可以阅读以下链接中的可选在线部分：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch15-advanced.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch15-advanced.md)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch15-advanced.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch15-advanced.md)'
- en: Minimal APIs parameter binding
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minimal APIs 参数绑定
- en: 'You can learn more about how to convert HTTP request data into strongly typed
    parameters for Minimal APIs endpoints at the following link:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于如何将 HTTP 请求数据转换为用于 Minimal APIs 端点的强类型参数的信息：
- en: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/parameter-binding](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/parameter-binding)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/parameter-binding](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/parameter-binding)'
- en: Refit client
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Refit 客户端
- en: Refit is an automatic type-safe REST library for .NET. It was inspired by Square’s
    Retrofit library, and it turns your REST service into a live interface.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: Refit 是一个自动的、类型安全的 .NET REST 库。它受到了 Square 的 Retrofit 库的启发，并将你的 REST 服务转换为一个实时接口。
- en: '[https://github.com/reactiveui/refit](https://github.com/reactiveui/refit)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/reactiveui/refit](https://github.com/reactiveui/refit)'
- en: Web service security using Microsoft Identity
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Microsoft Identity 的 Web 服务安全
- en: 'You can learn what’s new with Microsoft Identity for authentication and authorization
    at the following link:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解有关 Microsoft Identity 用于身份验证和授权的新功能：
- en: '[https://devblogs.microsoft.com/dotnet/whats-new-with-identity-in-dotnet-8/](https://devblogs.microsoft.com/dotnet/whats-new-with-identity-in-dotnet-8/)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/whats-new-with-identity-in-dotnet-8/](https://devblogs.microsoft.com/dotnet/whats-new-with-identity-in-dotnet-8/)'
- en: Exercise 15.2 – Practice exercises
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.2 – 实践练习
- en: Practice exercises go deeper into the topics for this chapter.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 实践练习深入探讨了本章的主题。
- en: Creating and deleting customers with HttpClient
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 HttpClient 创建和删除客户
- en: Extend the `Northwind.WebApi.ClientWasm` project to have pages where a visitor
    can fill in a form to create a new customer, or search for a customer and then
    delete them. The Blazor components should make calls to the Northwind Web API
    web service to create and delete customers.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Northwind.WebApi.ClientWasm` 项目扩展，使其包含访客可以填写表单以创建新客户或搜索客户然后删除他们的页面。Blazor
    组件应调用 Northwind Web API Web 服务以创建和删除客户。
- en: Exercise 15.3 – Test your knowledge
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.3 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: ASP.NET Core has multiple project templates for building web services. What
    are they and how do you create them using the CLI?
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了多个项目模板用于构建 Web 服务。它们是什么，以及如何使用 CLI 创建它们？
- en: When configuring an HTTP client, how do you specify the format of data that
    you prefer in the response from the web service?
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当配置 HTTP 客户端时，你如何指定你希望从 Web 服务响应中获取的数据格式？
- en: Why did the ASP.NET Core team replace the Swashbuckle package with their own
    implementation of OpenAPI support?
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 ASP.NET Core 团队用他们自己的 OpenAPI 支持实现替换了 Swashbuckle 包？
- en: What must you do to specify what responses should be expected when calling a
    `MapGet` or similar method?
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`MapGet`或类似方法时，你应该如何指定期望得到的响应？
- en: List three methods that can be called to return responses with different status
    codes.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三种可以调用以返回不同状态码的响应的方法。
- en: List four ways that you can test a web service.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出四种你可以测试Web服务的方法。
- en: Why should you not wrap your use of `HttpClient` in a `using` statement to dispose
    of it when you are finished even though it implements the `IDisposable` interface,
    and what should you use instead?
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管`HttpClient`实现了`IDisposable`接口，但你为什么不应该在完成使用后用`using`语句来释放它，而应该使用什么代替？
- en: What are the benefits of HTTP/2 and HTTP/3 compared to HTTP/1.1?
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与HTTP/1.1相比，HTTP/2和HTTP/3有哪些好处？
- en: How can you enable clients to detect if your web service is healthy with ASP.NET
    Core 2.2 and later?
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用ASP.NET Core 2.2及更高版本使客户端能够检测你的Web服务是否健康？
- en: What are the main types of object caching and why is the `HybridCache` introduced
    with .NET 9 the best?
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象缓存的主要类型有哪些，为什么.NET 9中引入的`HybridCache`是最好的？
- en: Exercise 15.4 – Explore topics
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.4 – 探索主题
- en: 'Use the links in the following GitHub repository to learn more details about
    the topics covered in this chapter:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下GitHub仓库中的链接了解更多关于本章涵盖主题的详细信息：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-15---building-and-consuming-web-services](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-15---building-and-consuming-web-services)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-15---building-and-consuming-web-services](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-15---building-and-consuming-web-services)'
- en: Summary
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了：
- en: How to build an ASP.NET Core web service using Minimal APIs that can be called
    by any app on any platform that can make an HTTP request and process an HTTP response
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Minimal APIs构建ASP.NET Core Web服务，这样任何可以发起HTTP请求并处理HTTP响应的平台上的应用程序都可以调用它
- en: How to document web service APIs with OpenAPI
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用OpenAPI记录Web服务API
- en: How to test web services using a browser, HTTP editor, or REST client
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用浏览器、HTTP编辑器或REST客户端测试Web服务？
- en: How to consume services efficiently
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何高效地消费服务
- en: In the *Epilogue*, I will make some suggestions for books to take you deeper
    into C# and .NET.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在**结语**中，我将提出一些建议，帮助你更深入地了解C#和.NET。
