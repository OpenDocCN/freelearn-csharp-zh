# 前言

第一原理，克拉丽斯：简单。阅读马库斯·奥勒留斯，

“对每一件特定的事情，问：它本身是什么？它的本质是什么？”

~汉尼拔·莱克特

这句话来自我最喜欢的电影之一，总结了我的学习方法。在游戏行业工作十多年后，我发现掌握复杂系统的唯一有效方法是将其分解为其最基本的组成部分。换句话说，我试图在掌握最终形式之前理解核心成分。

你会看到，在这本书中，我在呈现每个模式的方式上采取了一种非常简单的方法。目标不是堆砌主题内容，而是通过隔离每个设计模式背后的核心概念来学习，这样我们就可以观察它们并学习它们的复杂性。我在游戏行业作为设计师和程序员工作时学到了这种方法。我们经常在被称为“体育馆”的独立级别中为我们的游戏构建组件和系统。我们会花费数周时间迭代、测试和调整我们游戏中的每个成分，直到我们理解了如何使它们作为一个整体工作。

我以我处理游戏开发的方式写了这本书，这样你作为读者就可以沉浸在主题中，同时培养一些有助于你职业生涯的好习惯。

即使每个章节中包含的代码不是我们所说的*生产就绪*，它仍然为构建你游戏中的强大系统提供了一个良好的起点。因此，重要的是要记住，本书中的代码不是教条，而是旨在由你，即读者，改进的学习材料。我希望你这样做！

# 本书面向对象

本书是为初学者和有经验的 Unity 开发者所写。但它也被设计成其他开发环境转向 Unity 的开发者的参考，他们希望了解如何在使用 Unity 的 API 核心功能的同时应用设计模式。

# 本书涵盖内容

第一章，*Unity 引擎架构*，解释了 Unity 游戏引擎的核心架构支柱。

第二章，*游戏循环和更新方法*，回顾了每个游戏程序员都需要理解的两个核心设计模式，即`game`循环和`update`方法。

第三章，*原型*，使用原型模式作为其基础实现了一个生成系统。

第四章，*工厂方法*，涵盖了工厂模式，它是抽象工厂的近亲。我们将用它来设计一个生成系统以生成非玩家角色。

第五章，*抽象工厂*，在构建高级生成系统时，涵盖了抽象工厂和工厂方法之间的核心差异。

第六章，*单例*，回顾了臭名昭著的单例模式，这可能是 Unity 中最广泛使用的模式。

第七章，*策略*，涵盖了策略模式的基本原理以及如何使用它来实现导弹系统的目标寻找行为集合。

第八章，*命令*，回顾了命令模式以及如何使用它来构建一个通用控制系统以控制远程设备。

第九章，*观察者*，解释了观察者模式是什么以及如何在 Unity 中使用 C#正确地使用它。

第十章，*状态*，涵盖了状态模式的基本原理以及如何使用它来实现围绕太空船的游戏的有限状态。

第十一章，*访问者*，涵盖了访问者模式的基本原理以及如何使用它来实现一个单臂工厂机器人的模拟。

第十二章，*外观*，使用外观模式来原型化一个系统，该系统允许玩家在游戏中的进度被保存。

第十三章，*适配器*，涵盖了适配器模式的基本原理以及如何使用它来调整在线用户管理系统而不修改其代码。

第十四章，*装饰者*，回顾了装饰者模式的基本原理以及如何使用它来原型化武器定制系统。

第十五章，*事件总线*，涵盖了事件总线模式的基本原理以及如何使用它来实现一个全局事件驱动消息系统。

第十六章，*服务定位器*，回顾了服务定位器模式的基本原理以及如何使用它来实现一个在运行时允许注册和定位特定服务的系统。

第十七章，*依赖注入*，研究了 IoC 容器背后的核心概念以及它们与 DI 的关系。然后我们将看到一个由允许定制赛车游戏超级摩托车初始配置的功能实现引发的依赖问题示例。

第十八章，*对象池*，回顾了对象池模式的基本原理以及如何使用它来优化僵尸游戏的生成系统。

第十九章，*空间分区*，回顾了空间分区模式的基本原理以及如何使用它来原型化一个捕食者在环境中猎捕猎物的迷你游戏。

第二十章，*反模式*，回顾了一系列常见反模式以及如何避免它们。

# 为了充分利用本书

为了充分利用本书，需要具备 Unity 和 C#的基本功能知识。

# 下载示例代码文件

您可以从[www.packt.com](http://www.packt.com)的账户下载此书的示例代码文件。如果您在其他地方购买了此书，您可以访问[www.packt.com/support](http://www.packt.com/support)并注册，以便将文件直接通过电子邮件发送给您。

您可以通过以下步骤下载代码文件：

1.  在[www.packt.com](http://www.packt.com)登录或注册

1.  选择“支持”标签页。

1.  点击“代码下载与勘误”。

1.  在搜索框中输入书籍名称，并按照屏幕上的说明操作。

文件下载完成后，请确保使用最新版本的以下软件解压或提取文件夹：

+   Windows 系统使用 WinRAR/7-Zip

+   Mac 系统使用 Zipeg/iZip/UnRarX

+   Linux 系统使用 7-Zip/PeaZip

本书代码包也托管在 GitHub 上，地址为[`github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018`](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)。如果代码有更新，它将在现有的 GitHub 仓库中更新。

我们还有其他来自我们丰富图书和视频目录的代码包可供使用，地址为**[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**。查看它们！

# 下载彩色图像

我们还提供了一份包含本书中使用的截图/图表彩色图像的 PDF 文件。您可以从这里下载：[`www.packtpub.com/sites/default/files/downloads/9781789349337_ColorImages.pdf`](https://www.packtpub.com/sites/default/files/downloads/9781789349337_ColorImages.pdf)。

# 代码实战

访问以下链接查看代码运行的视频：

[`bit.ly/2Wty3SJ`](http://bit.ly/2Wty3SJ)

# 使用的约定

本书使用了多种文本约定。

`CodeInText`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。以下是一个示例：“您可以通过以下代码示例看到实现 GameObject 组件引用并调用其`public`方法的简便性。”

代码块设置如下：

```cs
public class Tomahawk : Missile
{
    void Awake()
    {
        this.seekBehavior = new SeekWithGPS();
    }
}
```

**粗体**：表示新术语、重要单词或屏幕上出现的单词。例如，菜单或对话框中的单词在文本中显示如下。以下是一个示例：“使用 Drone 或 Sniper 脚本附加到组件上的方式创建两个 GameObject。”

警告或重要注意事项看起来像这样。

小贴士和技巧看起来像这样。

# 联系我们

我们始终欢迎读者的反馈。

**一般反馈**：如果您对本书的任何方面有疑问，请在邮件主题中提及书名，并将邮件发送至`customercare@packtpub.com`。

**勘误表**：尽管我们已经尽一切努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，我们将不胜感激，如果您能向我们报告这一点。请访问 [www.packt.com/submit-errata](http://www.packt.com/submit-errata)，选择您的书籍，点击勘误表提交表单链接，并输入详细信息。

**盗版**：如果您在互联网上发现我们作品的任何形式的非法副本，如果您能提供位置地址或网站名称，我们将不胜感激。请通过 `copyright@packt.com` 联系我们，并附上材料的链接。

**如果您有兴趣成为作者**：如果您在某个领域有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问 [authors.packtpub.com](http://authors.packtpub.com/).

# **评论**

请留下评论。一旦您阅读并使用过这本书，为何不在您购买它的网站上留下评论呢？潜在读者可以查看并使用您的客观意见来做出购买决定，我们 Packt 可以了解您对我们产品的看法，我们的作者也可以看到他们对书籍的反馈。谢谢！

如需更多关于 Packt 的信息，请访问 [packt.com](http://www.packt.com/).
