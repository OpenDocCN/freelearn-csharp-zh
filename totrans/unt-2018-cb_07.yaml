- en: Using Cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the basic scene for this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a picture-in-picture effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between multiple cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making textures from screen content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zooming a telescopic camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a minimap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an in-game surveillance camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Unity's multi-purpose camera rig
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cinemachine ClearShot to switch cameras to keep the player in shot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting the player switch to a Cinemachine FreeLook camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we should never forget to pay attention to **Cameras**. After
    all, they are the windows through which our players see our games. In this chapter,
    we will take a look at interesting ways of using **Cameras** that enhance the
    player's experience.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Scene** can contain multiple **Cameras**. Often, we have one Main Camera
    (we're given one by default with a new Scene). For **First-Person** viewpoint
    games, we control the position and rotation of the **Camera** directly, since
    it acts as our eyes. In **Third-Personal** viewpoint games, our main **Camera**
    follows an animated 3D character (usually from above/behind/over the shoulder),
    and may slowly and smoothly change its position and rotation as if a person were
    holding the **Camera** and moving to keep us in view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perspective **Cameras** have a triangular pyramid-shaped volume of space in
    front of them, called a **frustrum.** Objects inside this space are projected
    onto a plane, which determines what we see from the **Camera.** We can control
    this volume of space by specifying the clipping planes and the field of view.
    The clipping planes define the minimum and maximum distance objects have to be
    between to be considered viewable. The field of view is decided by how wide or
    narrow the pyramid shape is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/544a4efb-3a80-4b82-bf37-888035c50bbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Cameras can be customized in many ways:'
  prefs: []
  type: TYPE_NORMAL
- en: They can exclude objects on specific layers from rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be set to render in Orthographic mode (that is, without perspective)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can have their **Field of View** (**FOV**) manipulated to simulate a wide-
    or narrow-angle lenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be rendered on top of other cameras or within specific areas of the
    screen (viewports)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be rendered into Textures files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The list goes on. The following screenshot illustrates several of these Camera
    features. The same Scene has a perspective Camera, outputting to a viewport taking
    up the entire Game screen (from 0,0 to 1,1). On top of this is a second viewport
    for an Orthographic Camera, showing a 2D top-down view of the same Scene''s contents.
    This viewport is just the top-left quarter of the screen `(0, 0.5)` to `(0.5,
    1.0)`. The "ghost" character is on a layer that is ignored (culled) by the second
    **Orthographic** Camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4994613-9dc7-41e5-b6ea-45a88357a702.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Cameras** have a depth property. This is used by Unity to determine in what
    sequence **Cameras** are rendered. Unity renders **Cameras** starting with the
    lowest depth number, and working up to the highest. This is needed to ensure that
    **Cameras** that are not rendered to fill the whole screen are rendered after
    **Cameras** that are. You''ll see this illustrated in several recipes, including
    the picture-in-picture recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Cinemachine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developed by Adam Myhill, and now available free as a Unity Package, **Cinemachine**
    is a powerful automated system for camera control. It offers much to Unity developers,
    both for **Run-Time** in-game camera control and also cinematic creation for cut
    scenes or complete animated films. We end this chapter with examples of how to
    add some **Run-Time** camera controls to your games using **Cinemachine.**
  prefs: []
  type: TYPE_NORMAL
- en: At the core of Cinemachine is the concept of a set of Virtual Cameras in a Scene and
    a Cinemachine Brain component, which decides which virtual camera's properties
    should be used to control the Scene's **Main Camera**.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about the history and development of Cinemachine at [http://www.cinemachineimagery.com/](http://www.cinemachineimagery.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the basic scene for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the recipes in this chapter start off with the same basic scene, featuring
    a 3D maze, some objects, and a keyboard-controllable 3D character. In this recipe,
    you'll create a project with such a scene, which can be duplicated and adapted
    for each recipe that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8611645-76d7-4231-8804-b8b3bd0d5a96.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared a Unity package named `CamerasChapter.unity`,
    containing all the resources needed for this chapter. The package can be found
    in the `06_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the basic scene for this chapter, just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the CamerasChapter package into your Unity Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, you'll find three Prefabs in the `Prefabs` folder (`maze-floor-walls`,
    `maze-objects`, `character-MsLazer`). Create GameObjects for each of these three
    Prefabs by dragging the Prefabs from the Project panel into the Hierarchy or Scene
    panels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now have a maze with a floor, some walls, some **Sphere** objects,
    a green respawn point, and the keyboard-controllable character-MsLazer 3D character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's attach the Scene's **Main Camera** to the character, so that you'll see
    this Third Person Controller character all the time as you move it around the
    maze. Child the Main Camera to `character-MsLazer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector, set the Main Camera Position to (0, 3, -5), and Rotation to
    (5, 0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, as you use the arrow keys to move the character around the maze, the **Main
    Camera** should move and rotate automatically with the character, and you should
    be able to see the back of the character at all times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the Scene. As you move the character, the **Main Camera** should
    move around with the character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By cloning Prefabs, you have added a maze and some objects to an empty Scene.
    You have also added a keyboard-controller character to the Scene.
  prefs: []
  type: TYPE_NORMAL
- en: By childing the **Main Camera** to the character GameObject, the **Main Camera**
    maintains the same position and rotation relative to the character at all times.
    Therefore, as the character moves so does the **Main Camera****,** giving a simple,
    over-the-shoulder type viewpoint for the game action.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a picture-in-picture effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having more than one viewport displayed can be useful in many situations. For
    example, you may want to show simultaneous events going on in different locations,
    or you may want to have a separate window for hot-seat multiplayer games:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecea56b2-9da5-463d-bd88-73ca4c01cbd6.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a picture-in-picture display, just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new Camera to the scene named `Camera-pic-in-pic`. Choose menu: Create
    | Camera.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector, for the `Camera` component, set the Depth property to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck or remove the camera's Audio Listener component, since there should
    only be one active Audio Listener in a Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script-class named `PictureInPicture`, and add an instance-object
    as a component to the Camera-pic-in-pic GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Inspector, change some of the Picture In Picture (Script) parameters:
    choose top and right for vertical and horizontal alignment. Choose 0.25 for vertical
    and horizontal percentage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your Scene. In the Game panel, your picture-in-picture Camera's viewport
    should be visible in the top-left corner of the screen, taking up a quarter (25%)
    of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, you added a second **Camera** in order to display the scene
    from a different point of view.
  prefs: []
  type: TYPE_NORMAL
- en: The default Main Camera has the default `depth` of `0`. You set the depth for
    our Camera-pic-in-pic to `1`, so the **Main Camera** is rendered first, covering
    the whole Game window, and then our second Camera (picture-in-picture) is rendered
    last, on top of the Main Camera rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The Picture In Picture script changes the camera's Normalized Viewport Rect,
    thus resizing and positioning the viewport according to the user's preferences.
    The four values of Vertical and Horizontal Alignment, plus `width` and `height`
    percentage, are used to create a rectangle in the (0,0) - (1.0, 1.0) **normalized**
    coordinates of the the Game panel. The `rect` property of the **Camera** is set
    to the new rectangle calculated.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are some aspects of your picture-in-picture that you could change.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the size and location of the picture-in-picture viewport on the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can change the **size** of the picture-in-picture rectangle by setting the
    horizontal and vertical percentage values.
  prefs: []
  type: TYPE_NORMAL
- en: The Vertical Alignment and Horizontal Alignment options can be used to change
    the viewport's vertical and horizontal alignment. Use them to place it where you
    wish, such as top-left, bottom-right, center-center, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Adding further contols for depth-of-field and aspect-ratio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can add additional public variables to the code, and corresponding **Camera**
    adjustments, for **field-of-view**, **aspect ratio**, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The camera field-of-view is how much of the world the camera captures; often,
    we think of this as how wide or narrow our view is. Learn more at [https://en.wikipedia.org/wiki/Field_of_view](https://en.wikipedia.org/wiki/Field_of_view)
    and  [https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html](https://docs.unity3d.com/ScriptReference/Camera-fieldOfView.html).
  prefs: []
  type: TYPE_NORMAL
- en: Camera aspect ratio is the relationship of the width to the height of the rectangle.
    It is calculated as the width divided by the height. Learn more at [https://docs.unity3d.com/ScriptReference/Camera-aspect.html](https://docs.unity3d.com/ScriptReference/Camera-aspect.html)
    and [https://en.wikipedia.org/wiki/Aspect_ratio_(image)](https://en.wikipedia.org/wiki/Aspect_ratio_(image)).
  prefs: []
  type: TYPE_NORMAL
- en: Manually changing Camera viewport properties in the Inspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you are happy working with the normalized viewport coordinate system of
    (0,0) to (1.0, 1.0), you can manually edit **Camera Viewport** settings for the Camera component
    directly in the Inspector, without having to use any C# script-classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82251c09-f35d-442d-af9e-18ef299d4c9b.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Displaying a minimap* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between multiple cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Choosing from a variety of cameras is a common feature in many genres: racing,
    sports, tycoon/strategy, and many others. In this recipe, you will learn how to
    give players the ability to choose from many cameras by using their keyboards.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement switchable cameras, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Camera in the Scene named Camera-1 (Create | Camera). Set its position
    to (`0,0,0`). Set the Tag for this Camera to be **MainCamera**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate Camera-1, naming the copy Camera-2\. Set its Position to (`0, 0, -15`),
    and its Rotation to (`20, 0, 0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the Camera and AudioListener components for both Camera-1 and Camera-2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty GameObject named switchboard (Create | Create Empty).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script-class named `CameraSwitch` containing the following,
    and add an object-instance as a component to the switchboard GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure the switchboard GameObject is selected in the Hierarchy. In the Inspector
    for the Camera Switch (Script) component, set the size of the **Cameras** array
    to `3`. Then, drag and populate the **Camera** slots with the cameras from the
    scene, including the **Main Camera **and the child of the MsLazer character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a7fc2a89-2722-487d-a9b0-95da84fe2dcc.png)'
  prefs: []
  type: TYPE_IMG
- en: Save and Play the scene. Pressing keys *0*, *1*, and *2* should switch between
    each of the three **Cameras.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each frame, a test is made for each of the three shortcut key presses (0, 1,
    or 2). If one of those keys has been pressed, then the corresponding **Camera**
    is enabled, and the other two **Cameras** are disabled.
  prefs: []
  type: TYPE_NORMAL
- en: If the public Boolean property `changeAudioListener` has been checked, then
    the `AudioListener` inside the selected Camera is enabled and the `AudioListeners`
    in the other two Cameras are disabled.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some ideas about how you could try adapting this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using a single-enabled camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A different approach to the problem would be keeping all secondary cameras disabled
    and assigning their position and rotation to the **Main Camera** via a script-class
    (you would need to make a copy of the **Main Camera** and add it to the list,
    in case you wanted to save its Transform settings). This is similar to the virtual
    **Camera** properties applied to the **Main Camera** approach that the `Cinemachine`
    package implements (see the last two recipes in this chapter to learn more about
    `Cinemachine`).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Creating an in-game surveillance camera recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Making textures from screen content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want your game or player to take in-game snapshots and apply them as
    textures, this recipe will show you how. This can be very useful if you plan to
    implement an in-game photo gallery or display a snapshot of a key moment at the
    end of a level (racing games and stunt simulations use this feature a lot). For
    this particular example, we will take a snapshot of a framed region of the screen
    and print it in the top-right corner of the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fefcf742-7a2f-4b0c-a22e-40be43be685f.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create textures from screen content, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Hierarchy, create a new **UI Image** named **Image-frame** by choosing
    the following from the **Hierarchy** panel menu: Create | UI | Image. Since this
    is the first UI GameObject to be created in this Scene, new Canvas and `EventSystem`
    GameObjects should be created automatically, and the Image-frame UI should be
    a child of the Canvas GameObject.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Inspector panel, find the Image (Script) component of the frame GameObject
    and set `InputFieldBackground` as its **Source Image**. Also, uncheck the **Fill
    Center** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sprite `InputFieldBackground` comes bundled with Unity, and it's already sliced
    for resizing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Set the Anchors for Image-frame to: Min (`0.25`), (`0.25`); Max (`0.75`), (`0.750`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Zero the Position (Left: `0`, Top: `0`, Pos Z: `0`) and Size (Width: `0`, Height:
    `0`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Image-frame** GameObject should appear in the center of the screen, taking
    up half the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e7e24165-9431-4a03-8774-031a77737a57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Hierarchy, create a new **UI Raw Image** named **RawImage-Photo** by
    choosing the following from the **Hierarchy** panel menu: **Create** | **UI**
    | **RawImage****.** Ensure its **Texture** is **None** for its **Raw Image (Script)**
    component.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector,** now disable the entire **RawImage-Photo** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Width** and **Height** to `1`. Set the Anchors for **RawImage-Photo**
    to: **Min** (`0`), (`1`); **Max** (`0`), (`1`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Pivot** to `(0, 1)`. And zero the Position by setting **Left** to `0`,
    **Top** to `0`, and **Z** to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C# script-class named `TextureFromCamera,` and add an instance-object
    as a component to the **Main Camera** GameObject (child of `MsLazer):`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the **Inspector,** find the **Screen Texture** component and populate the Raw
    Image Photo field with **GameObject****RawImage-Photo;** and the **Image Frame** field with
    the **Image-frame** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the **Scene**. Each time you click the mouse, you'll take a snapshot of
    the screen within the rectangular frame, and the snapshop should be displayed
    in the top-left of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we created a UI frame from which to take a snapshot, and a UI Raw Image
    at the top-left of the screen, onto which to apply the snapshot textures.
  prefs: []
  type: TYPE_NORMAL
- en: Each frame, the `LateUpdate()` method of C# script-class `TextureFromCamera`
    is executed. Each time this happens a test is made to see whether the mouse button
    has been clicked. If it has, then the UI Raw Image is disabled (so previous snapshots
    don't appear in new snapshots) and the `CaptureScreen()` coroutine method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: We use `LateUpdate()` here to ensure all rendering has been completed before
    we capture the image.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutine `CaptureScreen()` calculates a `Rect` area, copies screen pixels from
    that area, and applies them to a texture to be displayed by the **UI Raw Image**
    element, which is also resized to fit the texture.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the `Rect` is calculated from the screen's dimensions and the frame's
    Rect Transform settings, particularly its Pivot, Anchors, Width, and Height. The
    screen pixels are then captured by the `ReadPixels()` command and applied to the
    texture, which is then applied to the Raw Image photo, which is itself resized
    to fit the desired ratio between the photo size and the original pixels.
  prefs: []
  type: TYPE_NORMAL
- en: The `CaptureScreen()` method is a coroutine, which allows it to wait until the
    end of a frame (`yield return new WaitForEndOfFrame()`), before attempting to
    capture a copy of the image from the **Camera.**
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from displaying the texture as a UI element, you can use it in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: Applying your texture to a material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can apply your texture to an existing object's material by adding a line
    similar to `GameObject.Find("MyObject").renderer.material.mainTexture`= texture to
    the end of the `CaptureScreen` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using your texture as a screenshot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can encode your texture as a PNG image file and save it. This is explored
    in the Unity documentation pages about encoding PNG images: [https://docs.unity3d.com/ScriptReference/ImageConversion.EncodeToPNG.html](https://docs.unity3d.com/ScriptReference/ImageConversion.EncodeToPNG.html).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Saving screenshots from the game recipe in Chapter 10, *Working with External
    Resource Files and Devices*, Saving and Loading Data Files.
  prefs: []
  type: TYPE_NORMAL
- en: Zooming a telescopic camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a telescopic camera that zooms in whenever the
    left mouse button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a telescopic camera, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script-class named `TelescopicView`, and add an instance-object
    as a component to the **Main Camera** (child of `MsLazer`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Play the level. You should see an animated zooming effect when you click and
    hold the right mouse button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The zooming effect is actually caused by changes to the value of the camera's
    **Field Of View** (**FOV**) property; small values result in closer views of a
    smaller area, while larger values enlarge the FOV.
  prefs: []
  type: TYPE_NORMAL
- en: The `TelescopicView` script-class changes the camera's field of view by reducing
    it whenever the left mouse button is pressed. It also adds to the FOV value when
    the right mouse button is not being held, until it reaches its original value.
  prefs: []
  type: TYPE_NORMAL
- en: The zoom limit of the FOV can be deduced from the `minFov = initFov / zoom` code.
    This means that the minimum value of the FOV is equal to its original value divided
    by the zoom amount. For instance, if our **Camera** originally features an FOV
    of 60, and we set the **Telescopic View Zoom** amount to `2.0`, the minimum FOV
    allowed will be 60/2 = 30.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a vignette effect when you zoom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often in games, a visual vignette effect is applied at the same time as camera
    zooming. Vignetting is when the edges of an image are made less bright or more
    blurred (often in an oval or circular shape). It used to be an unintended (and
    often unwanted) effect of older cameras and lenses, but can be purposely applied
    in games to help the player focus on the content at the center of the screen,
    and to add a more intense atmosphere at a certain point in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fbf8906-51a5-4ae8-a2ca-382bb363e4b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add a vignette effect, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Asset Store panel, then download and import the free Post-Processing
    Stack assets published by Unity Technologies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector, select the Main Camera GameObject (child of **MsLazer**).
    Then, add a Post-Processing Behaviour component. Go to Add Component | Effects
    | Post-Processing Behaviour.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new Post-Processing Profile file named my-vignette by
    choosing the following from the Project panel menu: Create | Post-Processing Profile.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `my-vignette` file selected in the Project panel, in the Inspector,
    check the my-vignette effect and click it once to reveal its properties. Set its
    properties as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Center: (X: 0.5, Y: 0.5)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Intensity: 0.75'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Smoothness: 0.5'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Roundness: 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With the **Main Camera** selected in the **Inspector,** drag the `my-vignette` file from
    the **Project** panel into the **Inspector** to populate the **Profile** property
    of the **Post-Processing Behaviour** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see the dark, fuzzy vignetting circular effect around the edges
    of the **Game** panel camera view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector,** select the **Main Camera** and disable its **Post-Processing
    Behaviour** component (uncheck the box for this component in the **Inspector).**
    We'll be enabling this effect in the script only when the zoom effect is switched
    on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new using statement at the top of the `TelescopicView` script-class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new private variable to the `TelescopicView` script-class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a statement to get and store a reference to the **Post-Processing Behaviour**
    component at the end of the `Start()` method in the `TelescopicView` script-class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add statements in the `Update()` method of script-class `TelescopicView,` to
    enable the Post-Processing Behaviour when the mouse key is pressed and disable
    it when not pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Play the Scene. You should see an animated vignette effect, in addition to the
    zooming, when the mouse button is clicked and held.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Learn more about the Vignette effect and the Post-processing Stack in the Unity
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/PostProcessing-Vignette.html](https://docs.unity3d.com/Manual/PostProcessing-Vignette.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/PostProcessing-Stack.html](https://docs.unity3d.com/Manual/PostProcessing-Stack.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going further with version 2 of the Unity Post Processing Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of printing, Unity have published an experimental version 2 of their
    Post Processing Stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a vignette effect, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Main Camera** in the **Inspector** (child of `MsLazer`). In the
    **Inspector,** create a new **Layer** named `PostProcessing,` and set the **Layer**
    of the **Main Camera** to **PostProcessing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the ZIP from the Unity GitHub account at [https://github.com/Unity-Technologies/PostProcessing](https://github.com/Unity-Technologies/PostProcessing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, unzip the folder into your project's Assets folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Post-Process Layer component to the **Main Camera**. Do this in the **Inspector**
    by clicking **Add Component** | **Rendering** | **Post Process Layer**. Set the
    **Layer** property of this component to **Post Processing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add a **Post-process Volume Component** by clicking **Add Component** |
    **Rendering** | **Post Process Volume**. Check the Is Global property. Create
    a New profile (click the New button). Then, click the Add Effect... button and
    choose Vignette from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a using statement at the top of the `TelescopicView` script-class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two more properties to the `TelescopicView` script-class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following statements to the end of the `Start()` method of script-class
    `TelescopicView`, in order to get a reference to the Vignette effect in the Post-Processing
    Volume component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following statements to the end of the `Update()` method of script-class
    `TelescopicView,` in order to update the vignette settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Play the Scene. You should see an animated vignette effect, in addition to the
    zooming, when the mouse button is clicked and held.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Learn more about this new version at the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The project Wiki: [https://github.com/Unity-Technologies/PostProcessing/wiki](https://github.com/Unity-Technologies/PostProcessing/wiki)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity GitHub account from which to download it: [https://github.com/Unity-Technologies/PostProcessing](https://github.com/Unity-Technologies/PostProcessing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This article about scripting with the Post Processing Stack v2 by Juan Sebastian
    Munoz Arango: [http://www.pencilsquaregames.com/changing-parameters-through-scripting-on-unitys-post-processing-stack-v2/](http://www.pencilsquaregames.com/changing-parameters-through-scripting-on-unitys-post-processing-stack-v2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a minimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many games, a broader view of the scene can be invaluable for navigation
    and information. Minimaps are great for giving players that extra perspective
    that they may need when in first- or third-person mode. In this recipe, we''ll
    first create a simple square minimap that appears at the top-right of the screen;
    then, you''ll learn how to make it circular and add a rotating compass effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efbb987f-89dc-4ca1-9e59-f7877904b412.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a minimap, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Hierarchy** panel, create a new UI Panel object (Create | UI | Panel)
    named `Panel-miniMap`. Since this is the first UI GameObject to be created in
    this Scene, new Canvas and `EventSystem` GameObjects should be created automatically,
    and the UI Panel should be a child of the Canvas GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `Panel-miniMap` GameObject selected in the **Inspector,** do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Rect Transform, set the alignment to top-right (click the top-right box
    while holding down the Shift and Alt keys)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Rect Transform, set Width to `128` and Height to `128`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll create a Render Texture file to which our minimap Camera will copy its
    view. In the **Project** panel, create a new Render Texture and name it `RenderTextureMap.`
    In the **Inspector,** ensure its Size is set to 256 x 256.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector,** select GameObject Panel-minimap and add a new child UI
    Raw Image named `RawImage-TextureMap` (Create | UI | Raw Image).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the UI `RawImage-TextureMap` GameObject, populate the Source Image field
    with the `RenderTextureMap` image. This means when our minimap Camera updates
    its view to the Render Texture, what the **Camera** sees will be automatically
    displayed in this UI Raw Image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After ensuring UI Raw `Image-RenderTextureMap` is a child of `Panel-minimap,`
    make it fill the whole panel by choosing **Stretch** for both the vertical and
    horizontal axes in the Rect Transform (while holding down the Shift and Alt keys):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73bd3b55-b8a7-4901-8055-446295cddd11.png)'
  prefs: []
  type: TYPE_IMG
- en: From the **Hierarchy** panel, create a new Camera **(****Create** | **Camera****)**
    and rename it `Camera-minimap.` Uncheck (or remove) the camera's **Audio Listener**
    component, since there should only be one active **Audio Listener** in a **Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Hierarchy child `Camera-minimap` to the `character-MsLazer` character. 
    Then, in the **Inspector,** set its properties as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Position: `(0, 10, 0)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rotation: `(90, 0, 0)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clear Flags: Depth Only'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Projection: Orthographic'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Camera: Size: 5 (default)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Depth: 1 (or higher)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Target Texture: RenderTextureMap'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Play the Scene. You should be able to see the square-shaped minimap functioning
    in the top-right corner of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc403a8d-3ef3-4efa-b825-fd5a1ea589bb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main element of the minimap is a UI Raw Image element `(RawImage-TextureMap),`
    displaying the contents of the Render Texture file named `RenderTextureMap.`
  prefs: []
  type: TYPE_NORMAL
- en: You created a second Camera in the Scene `(Camera-minimap),` and set its Target
    Texture to the `RenderTextureMap` file; this means that the view seen by the Camera
    updates the contents of `RenderTextureMap` each frame, which in turn is then displayed
    to the user in UI `RawImage-TextureMap.`
  prefs: []
  type: TYPE_NORMAL
- en: '`Camera-minimap` is an orthographic camera that follows the player''s character
    from a top-down viewpoint. You removed/disabled the `AudioListener` component
    in this new Camera, since there should only be one active `AudioListener` in a
    **Scene,** and there is already one in the default **Main Camera** GameObject.'
  prefs: []
  type: TYPE_NORMAL
- en: You childed this new Camera to `character-MsLazer,` so it moves with the character.
    You positioned it 10 units above the character (Y = 10), and you made it point
    downwards towards the character (X-rotation of 90 degrees).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to experiment more with your minimap, read on.
  prefs: []
  type: TYPE_NORMAL
- en: Using a UI Mask to make the minimap circular in shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way to make the minimap stand out in the UI is to make it circular. We
    can do this easily by adding a UI Mask based on a circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab73d37f-e236-40c4-a636-a15489db6f22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A good way to make the minimap stand out in the UI is to present it as a circular
    shape, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Project** panel, select the circleMask file in the `Textures` folder,
    and in the **Inspector** ensure the Texture Type is **Sprite** **(2D and UI)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To change a Texture type to **Sprite (2D and UI)**, select the file in the **Project**
    panel, then in the **Inspector** change its **Texture Type** to **Sprite (2D and
    UI)** and click on **Apply** to confirm the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure the `Panel-miniMap` GameObject is selected in the **Hierarchy.** In
    the **Inspector** for the **Image (Script)** component, populate the Source Image
    field with the circleMask texture, click the Color property, and set the Alpha
    value to `255`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df09b696-695c-4870-92e4-01128de5b044.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, add a Mask component to `Panel-miniMap` in the **Inspector,** by choosing
    menu: Add Component | UI | Mask. Uncheck the Show Mask Graphic property (it will
    become invisible).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The circle image serves as a mask for the minimap, so that only images inside
    the `circleMask` area will be displayed, resulting in a circular minimap.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding player character image at center of minimap and showing triangle marker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With most minimaps, the center of the minimap is the location of the player''s
    character, so we don''t need to show the player''s character in the minimap. Let''s
    create a Layer named `Player` and place `character-MsLazer` onto that **Layer.**
    We can then improve efficiency and reduce visual clutter by creating a **Culling
    Mask** that ignores the **Player**** Layer**. We can display a simple **2D Sprite**
    in the center of our minimap, pointing upwards, to indicate that our player is
    always facing upwards relative to what is displayed in the minimap:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new User Layer named `Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `character-MsLaser` GameObject (the player's character) in the Hierarchy,
    and set the **Layer** property to **Player** (click Yes in the **Change Children**
    popup dialog).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `Camera-minimap` selected in the **Hierarchy,** in the **Inspector** for
    the **Culling Mask** property of the **Camera,** deselect **Layer Player**. This
    property should now say **Mixed...,** which means that GameObjects on the **Player Layer** will
    be ignored by our our `Camera-minimap.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's add a triangle marker 2D image at the center of the **Panel.** Create
    a new UI Image as a child of `Panel-minimap;` rename this `Image-marker.` In the
    **Inspector,** set the Source Image property to Texture asset file `triangleMarker`.
    Click the Set Native Size button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the Scene. Rather than the top-down view of the player''s character, you
    should now see a triangle at the center of the minimap (always pointing upwards):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/326756ab-832b-42b4-a3e7-b3e1bfc1acf9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Rather than just having a triangle image in the center representing the player,
    you can create, for example, colored 3D objects that in Orthographic projection
    look like circles, squares, and so on by using **Layers** further. This involves
    having a **Layer** for objects to be displayed in the minimap, and another **Layer**
    (such as **Player)** that will be ignored by the minimap Camera. The Knights Of
    Unity have published a short tutorial that explains just how to do this kind of
    thing: [http://blog.theknightsofunity.com/implementing-minimap-unity/](http://blog.theknightsofunity.com/implementing-minimap-unity/).'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating a compass-style image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we want a compass-style image around our minimaps, so we can see any
    differences between the current bearing (forward direction) of our player's character
    and the direction we were originally facing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a rotating compass-style image around our minimap, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a compass-style circular image at the center of the Panel (with the
    letter N pointing upwards). To do this, create a new UI Image as a child of **Panel-minimap;**
    rename this **Image-compass.** In the **Inspector,** set the **Source Image**
    property to Texture compass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure both **Image-compass** and **Image-marker** appear below **RawImage-TextureMap**
    in the **Hierarchy** of the children of the `Panel-minimap` GameObject; this ensures
    the triangle marker and compass circle images are drawn after the Camera texture
    (that is, on top of the Camera''s view image):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e955c146-8a5e-4163-a5d4-28231ad98d8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a C# script-class MiniMap, and add an `instance-object` as a component
    to `Camera-minimap:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Play the Scene. You should be able to see the minimap functioning in the top-right
    corner of the screen. As you rotate the player character's orientation, you'll
    see the "N" north indicator in the circle around the minimap rotate too (but in
    the opposite direction).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every frame, the compass UI Image is rotated to match the rotation of the player's
    3D character in the Scene.
  prefs: []
  type: TYPE_NORMAL
- en: Making the range of the map larger or smaller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our Camera-minimap is Orthographic, changing the height of the **Camera**
    above the character will make no difference (since distance doesn't change how
    objects are projected onto an Orthographic camera). However, changing the Size
    property of the **Camera** component in the **Inspector** will control how large
    or small an area of the world is projected to the **Camera.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Try increasing the size to 20, and your minimap will show much more of the
    surrounding maze around your character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97c67c73-4b99-466a-be13-68afb82cb79b.png)'
  prefs: []
  type: TYPE_IMG
- en: When increasing the range of the minimap, you may wish to make the triangle
    marker Image in the center of the minimap smaller. You can do this easily by centering
    its Rect Transform, then setting a smaller Width and Height (such as 16 x 16).
  prefs: []
  type: TYPE_NORMAL
- en: Adapting your minimap to other styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can easily modify this recipe to make a top-down or isometric view of a
    racing game circuit map. In the **Inspector,** unchild the `Camera-minimap` GameObject; this
    will prevent it from following any of the **Scene** characters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an in-game surveillance Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we rendered the output from our minimap **Camera**
    to a **Render Texture**, and displayed the contents of that image in a **UI Raw
    Image**. Another example of when we may wish to capture and output the view of
    a **Camera** at runtime is to simulate an in-game surveillance **Camera,** such
    as a **Closed-Circuit Television** (**CCTV**) system. In this recipe, we will
    make use of a **Render Texture** to create an in-game surveillance camera that
    transmits its video to a 3D monitor elsewhere in the **Scene**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c449ebd-34e9-48a5-b2e3-4ea3db5c8582.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have also prepared two 3D models (FBX files) needed for
    the monitor and `cctv-camera` objects. These 3D model files can be found in the
    `06_07` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an in-game surveillance **Camera,** just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the monitor and `cctv-camera` models into your Unity Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create clones of the monitor and `cctv-camera` models by dragging them from
    the **Project** panel into the Hierarchy panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector,** set the following properties for the monitor GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Position: (`-3, 0, 6`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rotation: (`0, 180, 0`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scale: (`1,1,1`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the **Inspector,** set the following properties for the `cctv-camera` GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Position: (`-6, 0, 1`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rotation: (`0, 90, 0`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From the **Project** panel, create a new **Render Texture** file and rename
    it `screenRenderTexture.` In the **Inspector,** change its **Size** to **512 x
    512**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new **Camera** to the scene (menu: Create | Camera) named `Camera-surveillance.`
    Child this new GameObject to `cctv-camera.` Uncheck (or remove) the camera''s
    **Audio Listener** component, since there should only be one active **Audio Listener**
    in a Scene.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector,** set the following properties for the `Camera-surveillance`
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Position: (`0, 2, 0`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rotation: (`0, 0, 0`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clipping Planes: Near: `0.6`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Target Texture: `screenRenderTexture`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new **Material** named `m_renderTexture,` and set its **Albedo Texture**
    to `screenRenderTexture.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy,** find the screen child of the monitor GameObject and set
    its **Mesh Renderer Material** to `m_renderTexture.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play your Scene. You should be able to see your actions in front of the `cctc-camera`
    displayed in real time on the monitor''s screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ddf90bc-c267-41a4-ab7c-90fc03fb9d0f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We achieved the final result by using the surveillance camera as a source for
    the **Render Texture** applied to the screen. The camera was made a child of the
    camera's 3D model for easier relocation. Also, its **Near Clipping** plane was
    readjusted in order to avoid displaying parts of the camera's 3D model geometry,
    and its **Audio Source** component was disabled so that it wouldn't clash with
    the main camera's component.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our **Render Texture** was applied to the material of the monitor GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to experiment more with your minimap, read on.
  prefs: []
  type: TYPE_NORMAL
- en: Using Post-Processing to add a grainy, grayscale effect to the CCTV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A great effect to add for in-game TV systems is grainy (visual noise) grayscale
    **Post-Processing.** This adds the feel of cheap, old-style CCTV systems, such
    as might be used for a security system, and to add some kind of menacing film
    noir effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33ad43ad-f915-4cd8-b998-413dded2a69e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add a vignette effect, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Asset Store** panel, then download and import the free **Post-Processing
    Stack** assets published by Unity Technologies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** panel, create a new **Post-Processing** Profile file by going
    to Create | Post-Processing Profile. Name this new profile `film-noir.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy,** select the `Camera-surveillance` child of the `cctv-camera` GameObject.
    Add a **Post-Processing Behaviour** component to this **Camera,** by chosing menu:
    **Add Component** | **Effects** | **Post-Processing** Behaviour.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `film-noir` file from the **Project** panel into the **Inspector** to
    populate the **Profile** property of the **Post-Processing Behaviour** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector,** set the following properties for the **Post-Processing
    Profile** `film-noir` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the **Color Grading** option, and set Basic: Saturation to zero'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the **Grain** option, uncheck **Colored,** and set the maximum values
    for **Intensity (1), Luminescence Contribution (1)**, and **Size (3)**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By processing the image generated from the **Camera,** the image in the monitor
    should now be an old-style grainy, grayscale video feed from `cctv-camera.` The
    image is made grayscale, since color saturation is zero, and a grainy effect has
    also been applied.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Unity's multi-purpose camera rig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity provides some **Camera** rigs, which can make setting up scenes much
    faster and help to test out ideas. In this recipe, you''ll use a 3rd Person Character
    and the multi-purpose camera rig from the default Unity asset packages to quickly
    create a scene with a camera that automatically follows a character as it moves,
    smoothing rotating behind the character as the character changes direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e08f6a53-935c-481e-a1f7-bc370bf474ad.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with Unity''s multi-purpose camera rig, just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 3D scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the **Characters** and **Cameras Asset Packages**: use menu: **Assets**
    | **Import Package ...** | **Cameras & Characters**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now have a `Standard Assets` folder in your **Project** panel, containing
    the `Cameras` and `Characters` folders (and possibly some others, such as `CrossPlatformInput`, `Editor`,
    and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 3D Plane in your **Scene.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a clone of the `ThirdPersonController Prefab` to your Scene. Do this by
    dragging the `ThirdPersonController Prefab` from the `Standard Assets` | `Characters`
    | `ThirdPersonController` | `Prefabs` folder into the **Scene.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With GameObject `ThirdPersonController` selected in the **Hierarchy,** in the
    **Inspector** tag this GameObject with the **Player** tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a clone of the `MultipurposeCameraRig Prefab` to your Scene. Do this by
    dragging the `MultipurposeCameraRig` Prefab from the `Standard Assets` | `Cameras`
    | `Prefabs` folder into the Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the **Main** Camera GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the **Scene.** As you move the character around the **Scene,** the **Camera**
    should smoothly follow behind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You added a `ThirdPersonController` to the Scene and tagged it **Player.** You
    added a `MultipurposeCameraRig` to the **Scene.** The code attached to the camera
    rig automatically looks for a target GameObject tagged Player, and positions itself
    to follow from above and behind this GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: You can adjust the speed at which the camera follows and turns by changing the
    public properties for the `MultipurposeCameraRig` in its **Inspector** component
    **Auto Cam (Script)**.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cinemachine ClearShot to switch cameras to keep the player in shot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new feature of Unity is the `Cinemachine` set of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc0390fe-7d99-4d56-bde8-db64840934c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the scene created in the first recipe of this chapter, so
    make a copy of that project folder and do your work for this recipe with that
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use **Cinemachine ClearShot** to switch cameras to keep the player in shot,
    just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the scene provided, containing a 3D maze and `character-MsLazer.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Un-child the **Main Camera** from `character-MsLazer,` since we need this camera
    free for `Cinemachine` to take control of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Cinemachine` package using the Unity Package Manager (to get the
    most up-to-date version).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Cinemachine ClearShot** camera GameObject to the scene (menu: **Cinemachine**
    | **Ceate ClearShot Camera****).** You should see a new GameObject in the Hierarchy
    named CM Clearshot 1\. Set the position of this new GameObject to (0,0,0).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CM Clearshot 1 should have a child GameObject, Cinemachine Virtual Camera CM
    vcam 1\. Set the position of this virtual camera, CM vcam 1, to (10, 4, -10).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will also see that a Cinemachine Brain component has been added to the
    **Main Camera,** and in the **Hierarchy** you''ll see the Cinemacine Brain icon
    next to the **Main Camera** name (half gray cog, half red camera):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3287b4cb-90a2-4cbe-a49b-bc22ab98081d.png)'
  prefs: []
  type: TYPE_IMG
- en: Locate the `mixamorig:neck` GameObject in the Hierarchy inside character-MsLazer.
    We'll use this part of `character-MsLazer` to be the part that our `Cinemachine`
    cameras will use to orient towards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **CM Clearshot 1**, and in the **Inspector** populate the **Look At**
    property of the **Cinemachine ClearShot** component with a reference to the `mixamorig:neck` GameObject (drag
    the GameObject from Hierarchy into the property in the **Inspector):**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/045f5ca2-2cdc-4f42-848a-13417bc3fb16.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the **Scene.** As you move `character-MsLazer` around the scene, the Main
    Camera (controlled by the `Cinemachein` Brain) should rotate to always look at
    the character. However, sometimes a wall obscures the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second child Virtual Camera by selecting CM Clearshot 1 in the Hierarchy,
    and then in the Inspector, click the + button for the **Virtual Camera Children**
    property of the `Cinemachine` Clear Shot component. You should see a new virtual
    camera child named CM vcam 2 has been created. Set the **Position** of CM vcam
    2 to (27, 4, -18).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the **Scene**. Initially, CM vcam 1 has the best shot, and so this camera's
    position will be used to direct the **Main Camera**. However, if you move `character-MsLazer`
    along the corridor towards CM vcam 2, `Cinemachine` will then switch control to
    CM vcam 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Cinemachine Brain component was added to the **Scene.** This takes control
    of the **Main Camera** and uses properties of one or more **Virtual Cinemachine
    Camera** to decide what properties to apply to the **Main Camera**. You added
    a **Cinemachine ClearShot** GameObject, whose purpose is to tell the **Cinemachine
    Brain** which of its **Virtual Camera** children has the best shot.
  prefs: []
  type: TYPE_NORMAL
- en: You set the **Look At** property of the `ClearShot` component to the neck component
    of `character-MsLazer;` the position of this GameObject is used by the `ClearShot`
    component to rank each **Virtual Camera's** quality of shot.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've only just touched the surface of what **Cinemachine** has to offer. Here
    are some suggestions for how to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Cinemachine tutorials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the learn section of the Unity website, you''ll find many video tutorials
    introducing the different animation features of Unity. There is a special category
    for **Cinemachine** tutorials, which provide a great overview of the features
    and uses of Cinemachine: [https://unity3d.com/learn/tutorials/s/animation](https://unity3d.com/learn/tutorials/s/animation).'
  prefs: []
  type: TYPE_NORMAL
- en: Will Goldstone's ClearShot turtorial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe was inspired by Will Goldstone''s ClearShot tutorial, available
    on YouTube: [https://www.youtube.com/watch?v=kLcdrDljakA](https://www.youtube.com/watch?v=kLcdrDljakA).'
  prefs: []
  type: TYPE_NORMAL
- en: Adam Myhill's Cinemachine blog posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adam Myhill''s blog posts (he is the creator of **Cinemachine)** have lots
    of information and video links about many different Cinemachine features: [https://blogs.unity3d.com/2017/08/25/community-stories-cinemachine-and-timeline/](https://blogs.unity3d.com/2017/08/25/community-stories-cinemachine-and-timeline/).'
  prefs: []
  type: TYPE_NORMAL
- en: Read the installed Cinemachine documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Later versions of **Cinemachine (2.1+)** have documentation installed with
    the package. Display the **Cinemachine** About panel **(Menu:** **Cinemachine**
    | **About****),** then click the **Documentation** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/545c2654-1926-4021-aa19-c5c37017cb56.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also find the documentation online at [https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/manual/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Letting the player switch to a Cinemachine FreeLook camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's always good to give players choices and control in their game experience.
    In this recipe, we'll set up a mouse-controllable **Cinemachine FreeLook** camera
    and let the player switch to it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To explore Cinemachine, just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the **Default Blend** property of the **Cinemachine Brain** component
    in the **Main Camera** is set to Ease In Out. This means we'll have a smooth transition
    when switching between cameras.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Cinemachine FreeLook** camera GameObject to the scene (menu: **Cinemachine**
    | **Ceate FreeLook Camera****).** You should see a new GameObject in the **Hierarchy**
    named `CM FreeLook 1`. Set the **Priority** property of the **Cinemachine** **Free
    Look (Script)** component to zero.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `mixamorig:neck` GameObject in the **Hierarchy** inside **MsLazer.**
    We'll use this part of the **MsLazer** character to be the part that our **Cinemachine**
    cameras will use to orient towards and follow at a steady distance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **CM FreeLook 1**, and in the **Inspector** populate the **Look At**
    and **Follow** properties of the **Cinemachine** **Free Look (Script)** component
    with a reference to the `mixamorig:neck` GameObject (drag the GameObject from
    Hierarchy into the properties in the **Inspector).**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `FreeLookSwitcher` C# Script-class containing the following code,
    and add an instance-object as a component to the **CM FreeLook 1** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the **Scene.** When moving around the maze, initially the **Cinemachine
    ClearShot** cameras will be chosen by the **Cinemachine** Brain. But, pressing
    the *1* key will make it switch to the **FreeLook** camera following the player's
    character. Pressing *2* will switch back to the **ClearShot** cameras.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You added a **FreeLook Cinemachine** GameObject, but with a priority of zero,
    so it will be ignored initially. When the *1* key is pressed, the script increases
    the **Priority** to `99` (much higher than the default 10 of the **ClearShot**
    cameras), so then the **Cinemachine** Brain will make the **FreeLook** virtual
    camera control the **Main Camera**. Pressing the *2* key reduces the **FreeLook**
    component's **Priority** back to **zero,** so the **ClearShot** cameras will be
    used again.
  prefs: []
  type: TYPE_NORMAL
- en: There should be a smooth transition from **FreeLook** to **ClearShot** and back
    again, since you set the **Default Blend** property of the **Cinemachine Brain**
    component in the **Main Camera** to **Ease In Out**.
  prefs: []
  type: TYPE_NORMAL
