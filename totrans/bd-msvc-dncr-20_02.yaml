- en: Implementing Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed the problems of a layered monolith architecture.
    In this chapter, we will discuss how we can refactor them from the existing system
    and build separate microservices for products and orders. In this chapter, we
    will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to C# 7.0, Entity Framework Core, Visual Studio 2017, and Microsoft
    SQLServer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What makes a good service?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-driven design (DDD) and its importance for microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of Seam
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting the Flix One case study
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed with the concepts to implement microservices, it is worth
    mentioning the core concepts, languages, and tools that we're using to implement
    these microservices. In this chapter, we will get an overview of these topics.
  prefs: []
  type: TYPE_NORMAL
- en: C# 7.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is a programming language developed by Microsoft. The current release at
    the time of writing this book is C# 7.0\. The language appeared in 2002\. This
    language is an object-oriented language and component-oriented. The current version
    has various new features such as ValueTuple, Deconstructors, pattern matching,
    the switch statement local function, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going into details of these features as it's beyond the scope of
    this book. Refer to [https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Entity Framework Core** (**EF Core**) is a cross-platform version of Microsoft
    Entity Framework that is one of the most popular **object-relational mappers**
    (**ORMs**).'
  prefs: []
  type: TYPE_NORMAL
- en: ORM is a technique that helps you to query and manipulate data as per required
    business output. Refer to the discussion at [https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it](https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core supports various databases. A complete list of databases is available
    here: [https://docs.microsoft.com/en-us/ef/core/providers/index](https://docs.microsoft.com/en-us/ef/core/providers/index).
    The current version of EF Core is 2.0\. To get familiar with EF Core, I suggest
    you read this: [https://docs.microsoft.com/en-us/ef/core/get-started/index](https://docs.microsoft.com/en-us/ef/core/get-started/index)
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio is one of the best **Integrated Development Environments** (**IDE**)
    created by Microsoft. It enables developers to work in various ways using famous
    languages(for example, C#, VB.NET F#, and so on). The current release of Visual
    Studio 2017 is update 3 (VS15.3).
  prefs: []
  type: TYPE_NORMAL
- en: An IDE is a software application that provides a facility for programmers to
    write programs using programming languages. For more information, visit [https://en.wikipedia.org/wiki/Integrated_development_environment.](https://en.wikipedia.org/wiki/Integrated_development_environment)
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft also released Visual Studio for macOS, and the new avatar of Visual
    Studio has many tremendous features. For more information please refer to [https://www.visualstudio.com/vs/whatsnew/](https://www.visualstudio.com/vs/whatsnew/).
    In this book, all examples are written using Visual Studio 2017 update 3\. You
    can also download a community edition that is free: [https://www.visualstudio.com/.](https://www.visualstudio.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft SQLServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microsoft SQLServer** (**MSSQL**) is a software application that is a relational
    database management system. It''s mainly used as  database software to store and
    retrieve data. This is built on top of SQL, that is, Structured Query Language: [http://searchsqlserver.techtarget.com/definition/SQL](http://searchsqlserver.techtarget.com/definition/SQL).'
  prefs: []
  type: TYPE_NORMAL
- en: The current release, that is, SQL Server 2017, is more robust and can be used
    on Windows and Linux. You can get SQL Server 2017 from here: [https://www.microsoft.com/en-IN/sql-server/sql-server-2017](https://www.microsoft.com/en-IN/sql-server/sql-server-2017).
    Please note that we will use SQL Server 2008 R2 or later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Size of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start building our microservices, we should be clear about a few of
    their basic aspects, such as what factors to consider while sizing our microservices
    and how to ensure their isolation from the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, microservices should be micro. A question arises: what
    is micro? Microservices are all about size and granularity. To understand this
    better, let''s consider the application discussed in [Chapter 1](274437a4-3708-4913-96b3-539e376c71fb.xhtml),
    *An Introduction to Microservices*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We wanted the teams working on this project to stay synchronized at all times
    with respect to their code. Staying synchronized is even more important when we
    release the complete project. We needed to first decompose our application/specific
    parts into smaller functionalities/segments of the main service. Let''s discuss
    the factors that need to be considered for the high-level isolation of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Risks due to requirement changes: Changes in the requirements of one microservice
    should be independent of other microservices. In such a case, we will isolate/split
    our software into smaller services in such a way that if there are any requirement
    changes in one service, they will be independent of another microservice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functionality changes: We will isolate the functionalities that are rarely
    changed from the dependent functionalities that can be frequently modified. For
    example, in our application, the customer module notification functionality will
    rarely change. But its related modules, such as `Order`, are more likely to have
    frequent business changes as part of their life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Team changes: We should also consider isolating modules in such a way that
    one team can work independently of all the other teams. If the process of making
    a new developer productive—regarding the tasks in such modules—is not dependent
    on people outside the team, it means we are well placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Technology changes: Technology use needs to be isolated vertically within each
    module. A module should not be dependent on a technology or component from another
    module. We should strictly isolate the modules developed in different technologies
    or stacks, or look at moving them to a common platform as a last resort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our primary goal should not be to make services as small as possible; instead,
    our goal should be to isolate the identified bounded context and keep it small.
  prefs: []
  type: TYPE_NORMAL
- en: What makes a good service?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before microservices were conceptualized, whenever we thought of enterprise
    application integration, middleware looked like the most feasible option. Software
    vendors offered **Enterprise Service Bus** (**ESB**), and it was one of the best options for
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Besides considering these solutions, our main priority should be inclined toward
    the architectural features. When microservices arrived, middleware was no longer
    a consideration. Rather, the focus shifted to contemplation of business problems
    and how to tackle those problems with the help of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make a service that can be used and maintained easily by developers
    and users, the service must have the following features (we can also consider
    these as characteristics of good services):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard data formats: Good services should follow standardized data formats
    while exchanging services or systems with other components. The most popular data
    formats used in the .NET stack are XML and JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Standard communication protocol: Good services should obey standard communication
    formats, such as SOAP and REST.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loose coupling: One of the most important characteristics of a good service
    is that it follows loose coupling. When services are loosely coupled, we don''t
    have to worry about changes. Changes in one service will not impact other services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DDD and its importance for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Domain-Driven Design** (**DDD**) is a methodology and a process of designing
    complex systems. In these sections, we will briefly discuss DDD and how it is
    important in the context of microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: Domain model design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main objective of domain design is to understand the exact domain problems
    and then draft a model that can be written in any language or set of technologies.
    For example, in our Flix One bookstore application, we need to understand *Order
    Management* and *Stock Management*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few characteristics of the domain-driven model:'
  prefs: []
  type: TYPE_NORMAL
- en: A domain model should focus on a specific business model and not multiple business
    models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be reusable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be designed so that it can be called in a loosely coupled way, unlike
    the rest of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be designed independently of persistence implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be pulled out from a project to another location, so it should not
    be based on any infrastructure framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importance for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DDD is the blueprint and can be implemented by microservices. In other words,
    once DDD is done, we can implement it using microservices. This is just like how,
    in our application, we can easily implement *Order services*, *Inventory services*,
    *Tracking services*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have dealt with the transition process to your satisfaction, a simple
    exercise should be performed. This will help you verify that the size of the microservice
    is small enough. Every system is unique and has its own complexity level. Considering
    these levels of your domain, you need to have a baseline for the maximum number
    of domain objects that can talk to each other. If any service fails this evaluation
    criterion, then you have a possible candidate to evaluate your transition once
    again. However, don't get into this exercise with a specific number in mind; you
    can always go easy. As long as you have followed all the steps correctly, the
    system should be fine for you.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel that this baseline process is difficult for you to achieve, you
    can take another route. Go through all the interfaces and classes in each microservice.
    Considering all the steps we have followed, and the industry standard coding guidelines,
    anybody new to the system should be able to make sense of its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: You can also perform another simple test to check whether the correct vertical
    isolation of the services was achieved. You can deploy each one of them and make
    them live with the rest of the services, which are still unavailable. If your
    service goes live and continues listening for incoming requests, you can pat yourself
    on the back.
  prefs: []
  type: TYPE_NORMAL
- en: There are many benefits that you can derive from the isolated deployment capability.
    The capability to just deploy them independently allows the host in them to enter
    its own independent processes. It allows you to harness the power of the cloud
    and other hybrid models of hosting that you can think of. You are free to independently
    pick different technologies for each one of them as well.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of seam
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the very core of microservices lies the capability to work on a specific
    functionality in isolation from the rest of the system. This translates into all
    the advantages discussed earlier, such as reduced module dependency, code reusability,
    easier code maintenance, and better deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the same attributes that were attained with the implementation
    of microservices should be maintained during the process of implementation. Why
    should the whole process of moving monoliths to microservices be painful and not
    be as rewarding as using the microservices themselves? Just remember that the
    transition can't be done overnight and will need meticulous planning. Many capable
    solution architects have differed in their approaches while presenting their highly
    capable teams. The answer lies not just in the points already mentioned, but in
    the risk to the business itself.
  prefs: []
  type: TYPE_NORMAL
- en: This is very well attainable. However, we must identify our method correctly
    in order to achieve it. Otherwise, there is a possibility that the whole process
    of transitioning a monolithic application to microservices could be a dreadful
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Module interdependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This should always be the starting point when trying to transition a monolithic
    application to microservice-style architecture. Identify and pick up those parts
    of the application that are least dependent on other modules and have the least
    dependency on them, as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand that by identifying such parts of the application,
    you are not just trying to pick up the least challenging parts to deal with. However,
    at the same time, you have identified seams, which are the most easily visible
    ones. These are parts of the application where we will perform the necessary changes
    first. This allows us to completely isolate this part of the code from the rest
    of the system. It should be ready to become a part of the microservice or deployed
    in the final stage of this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Even though such seams have been identified, the capability to achieve microservice-style
    development is still a little further away. This is a good start, though.
  prefs: []
  type: TYPE_NORMAL
- en: Technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A two-pronged approach is required here. First, you must identify what different
    features of the application's base framework are being utilized. The differentiation
    could be, for example, implemented on the basis of heavy dependency on certain
    data structures, interprocess communication being performed, or the activity of
    report generation. This is the easier part.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the second step, I recommend that you become more confident and
    pick up pieces that use a type of technology that is different from what is being
    used currently. For example, there could be a piece of code relying on simple
    data structures or XML-based persistence. Identify such baggage in the system
    and mark it for a transition. A lot of prudence is required in this twin-pronged
    approach. Making a selection that is too ambitious could set you on a path similar
    to what we have been trying to avoid altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these parts might not look like very promising candidates for the final
    microservice-style architecture application. They should still be dealt with now.
    In the end, they will allow you to easily perform the transition.
  prefs: []
  type: TYPE_NORMAL
- en: Team structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With every iteration of this identification process being executed, this factor
    becomes more and more important. There could be teams that are differentiated
    on various grounds, such as their technical skill set, geographical location,
    or security requirements (employees versus outsourced).
  prefs: []
  type: TYPE_NORMAL
- en: If there is a part of the functionality that requires a specific skill set,
    then you could be looking at another probable Seam candidate. Teams can be composed
    of varying degrees of these differentiation factors. As part of the transition
    to microservices, the clear differentiation that could enable them to work independently
    could further optimize their productivity.
  prefs: []
  type: TYPE_NORMAL
- en: This can also provide a benefit in the form of safeguarding the intellectual
    property of the company—outsourcing to consultants for specific parts of the application
    is not uncommon. The capability to allow consultants or partners to help you only
    on a specific module makes the process simpler and more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart and soul of any enterprise system is its database. It is the biggest
    asset of the system on any given day. It is also the most vulnerable part of the
    whole system in such an exercise. No wonder database architects can sound mean
    and intruding whenever you ask them to make even the smallest change. Their domain
    is defined by database tables and stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: The health of their domain is judged by the referential integrity and the time
    it takes to perform various transactions. I don't hold them guilty for overdoing
    it anymore. They have a reason for this—their past experiences. It's time to change
    that. Let me tell you, this won't be easy, as we will have to utilize a completely
    different approach to handle data integrity once we embark on this path.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that the easiest approach is to divide the whole database in
    one go, but this is not the case. It can lead us to the situation we have been
    trying to avoid all along. Let's look at how to go about doing this in a more
    efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: As you move along, picking up pieces after the module dependency analysis, identify
    the database structures that are being used to interact with the database. There
    are two steps that you need to perform here. First, check whether you can isolate
    the database structures in your code to be broken down, and align this with the
    newly defined vertical boundaries. Second, identify what it would take to break
    down the underlying database structure as well.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry yet if breaking down the underlying data structure seems difficult.
    If it appears that it is involving other modules that you haven't started to move
    to microservices, it is a good sign. Don't let the database changes define the
    modules that you would pick and migrate to microservice-style architecture. Keep
    it the other way round. This ensures that when a database change is picked up,
    the code that depends on the change is already ready to absorb the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'This ensures that you don''t pick up the battle of data integrity while you
    are already occupied with modifying the code that would rely on this part of the
    database. Nevertheless, such database structures should draw your attention so
    that the modules that depend on them are picked next. This will allow you to easily
    complete the move to microservices for all the associated modules in one go. Refer
    to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/041baa4c-439d-4fd5-97ec-6d6b82f20456.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have not broken the database yet. Instead, we have simply separated
    our database access part into layers as part of the first step.
  prefs: []
  type: TYPE_NORMAL
- en: What we have simply done is map the code data structure the database, and they
    no longer depend on each other. Let's see how this step would work out when we
    remove foreign key relationships.
  prefs: []
  type: TYPE_NORMAL
- en: If we can transition the code structures being used to access the database along
    with the database structure, we will save time. This approach might differ from
    system to system and can be affected by our personal bias. If your database structure
    changes seem to be impacting modules that are yet to be marked for transition,
    move on for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important point to understand here is what kind of changes are acceptable
    when you break down this database table or merge it with another partial structure?
    The most important thing is not to shy away from breaking those foreign key relationships
    apart. This might sound like a big difference from our traditional approach to
    maintaining data integrity. However, removing your foreign key relationships is
    the most fundamental challenge when restructuring your database to suit the microservice
    architecture. Remember that a microservice is meant to be independent of other
    services. If there are foreign key relationships with other parts of the system,
    it makes it dependent on the services owning that part of the database. Refer
    to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d192da44-e0e3-4344-b40a-29bb63c009b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As part of step two, we have kept the foreign key fields in the database tables
    but have removed the foreign key constraint. So the **ORDER** table is still holding
    information about **ProductID**, but the foreign key relation is broken now. Refer
    to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfefb0b7-e7e8-439e-87e1-34f2f8a05e41.png)'
  prefs: []
  type: TYPE_IMG
- en: This is what our microservice-style architecture would finally look like. The
    central database would be moved away in favor of each service having their own
    database. So, separating the data structures in the code and removing foreign
    key relationships is our preparation to finally make the change. The connected
    boundaries of microservices in the preceding figure signify the interservice communication.
  prefs: []
  type: TYPE_NORMAL
- en: With the two steps performed, your code is now ready to split **ORDER** and
    **PRODUCT** into separate services, with each having their own database.
  prefs: []
  type: TYPE_NORMAL
- en: If all of the discussion here has left you bewildered about all those transactions
    that have been safely performed up to now, you are not alone. This outcome of
    the challenge with the transactions is not a small one by any means, and deserves
    focused attention. We'll talk about this in detail a bit later. Before that, there
    is another part that becomes a no man's land in the database. It is master data
    or static data, as some may call it.
  prefs: []
  type: TYPE_NORMAL
- en: Master data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling master data is more about your personal choice and system-specific
    requirements. If you see that the master data is not going to change for ages
    and occupies an insignificant amount of records, you are better off with the configuration
    files or even code enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: This requires someone to push out the configuration files once in a while when
    the changes do happen. However, this still leaves a gap for the future. As the
    rest of the system would depend on this one module, it will be responsible for
    these updates. If this module does not behave correctly, other parts of the system
    relying on it could also be impacted negatively.
  prefs: []
  type: TYPE_NORMAL
- en: Another option could be to wrap up the master data in a separate service altogether.
    Having the master data delivered through a service would provide the advantage
    of the services knowing the change instantly and understanding the capability
    to consume it as well.
  prefs: []
  type: TYPE_NORMAL
- en: The process of requesting this service might not be much different from the
    process of reading configuration files when required. It might be slower, but
    then it is to be done only as many times as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you could also support different sets of master data. It would be
    fairly easy to maintain product sets that differ every year. With the microservice
    architecture style, it is always a good idea to be independent of any kind of
    outside reliance in future.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our foreign keys gone and the database split into smaller parts, we need
    to devise our own mechanisms for handling data integrity. Here, we need to factor
    in the possibility that not all services would successfully go through a transaction
    in the scope of their respective data stores.
  prefs: []
  type: TYPE_NORMAL
- en: A good example is a user ordering a specific product. At the time the order
    is being accepted, there is a sufficient quantity available to be ordered. However,
    by the time the order is logged, the Product service cannot log the orders for
    some reason. We don't know yet whether is was due to insufficient quantity or
    some other communication fault within the system. There are two possible options
    here. Let's discuss them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The first option is to try again and perform the remaining part of the transaction
    sometime later. This would require us to orchestrate the whole transaction in
    a way that tracks individual transactions across services. So every transaction
    that leads to transactions being performed for more than one service must be tracked.
    In case one of them does not go through, it deserves a retry. This might work
    for long-lived operations.
  prefs: []
  type: TYPE_NORMAL
- en: However, for other operations, this could cause a real problem. If the operation
    is not long-lived and you still decide to retry, the outcome will result in either
    locking out other transactions or making the transaction wait—meaning it is impossible
    to complete it.
  prefs: []
  type: TYPE_NORMAL
- en: Another option that we can contemplate here is to cancel the entire set of transactions
    spread across various services. This means that a single failure at any stage
    of the entire set of transactions would result in the reversal of all the previous
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: This is one area where maximum prudence would be required, and it would be time
    well invested. A stable outcome is only guaranteed when the transactions are planned
    out well in any microservice-style architecture application.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we separated our *Order module* into **Order services** and
    discussed how we can break down the foreign key relationship between **ORDER**
    and **PRODUCT** tables.
  prefs: []
  type: TYPE_NORMAL
- en: In a monolithic application, we have a single repository that queries the database
    to fetch the records from both **ORDER** and **PRODUCT** tables. However, in our
    upcoming microservice application, we will segregate repositories between **Order
    service** and **Product service**. With each service having its respective database,
    each one would access its own database only. **Order service** would only be able
    to access order **Database**, whereas **Product service** would be able to access
    product **Database** only. **Order service** should not be allowed to access product **Database**
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss communication between microservices in Chapter 3, *Integration
    Techniques and Microservices*, in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/357146ab-c997-4a2c-8a36-26bae14d8155.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, we can see that our UI is interacting with **Order
    Service** and **Product service** via **API gateway**. Both the services are physically
    separated from each other and there is no direct interaction between these services.
    Communication performed in this manner is also referred to as communication that
    is based on the *API Gateway Pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway is nothing but a middle tier via which the UI can interact with
    the microservices. It also provides a simpler interface and makes the process
    of consuming these services simpler. It provides a different level of granularity
    to different clients as required (browser and desktop).
  prefs: []
  type: TYPE_NORMAL
- en: We can say that it provides coarse-grained APIs to mobile clients and fine-grained
    APIs to desktop clients, and it can use a high-performance network underneath
    its hood to provide some serious throughput.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of granularity from Wikipedia is as follows ([https://en.wikipedia.org/wiki/Granularity](https://en.wikipedia.org/wiki/Granularity)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"**Granularity** is the extent to which a system is broken down into small
    parts, either the system itself or its description or observation. It is the extent
    to which a larger entity is subdivided. For example, a yard broken into inches
    has a finer granularity than a yard broken into feet.'
  prefs: []
  type: TYPE_NORMAL
- en: Coarse-grained systems consist of fewer, larger components than fine-grained
    systems; a coarse-grained description of a system regards large subcomponents
    while a fine-grained description regards smaller components of which the larger
    ones are composed."
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of the API gateway for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no doubt that the API gateway is beneficial for microservices. With
    its use, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Invoke services through the API gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce round trips between the client and the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client has the ability to access different APIs in one place, as segregated
    by the gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides flexibility to clients in such a manner that they are able to interact
    with different services as and when they need to. This way, there is no need to
    expose complete/all services at all. API gateway is a component of complete API
    management. In our solution, we will use Azure API management, and we will explain
    it further in Chapter 3, *Integration Techniques and Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: API gateway versus API management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we discussed how the API gateway hides the actual
    APIs from its client and then simply redirects the calls to the actual API from
    these clients. The API management solution provides a complete management system
    to manage all the APIs of its external consumers. All API management solutions,
    such as Azure API management ([https://docs.microsoft.com/en-us/azure/api-management/](https://docs.microsoft.com/en-us/azure/api-management/)),
    provide various capabilities and functionalities, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monetization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting the Flix One case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding chapter, we looked at an example of an imaginary company,
    Flix One Inc., operating in the e-commerce domain and having its own .NET monolithic
    application: the Flix One bookstore. We have already discussed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to segregate the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to segregate the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to denormalize the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to begin transitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The available refactoring approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next sections, we will start writing/transitioning .NET monolith to a microservice
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the following tools and technologies while transitioning our monolithic
    application to microservice-style architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 update 3 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# 7.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core MVC/Web API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity Framework Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server 2008R2 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning to our product service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already have our product module in place. We are going to pull back this
    module now and start with a new ASP.NET Core MVC project. To do this, follow all
    the steps we discussed in the preceding sections and in [Chapter 1](6126f4b5-7098-4bb4-891d-02065b4b5930.xhtml), *An
    Introduction to Microservices*, Let''s examine the technology and database we
    will use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Technology stack: We have already selected this for our product service; we
    will go with ASP.NET Core, C#, **Entity framework **(**EF**), and so on. Microservices
    can be written using different technology stacks and can be consumed by clients
    created by different technologies. For our product service, we will go with ASP.NET
    Core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database: We have already discussed this in [Chapter 1](6126f4b5-7098-4bb4-891d-02065b4b5930.xhtml),
    *An Introduction to Microservices*, when talking about a monolithic application
    and segregating its database. Here, we will go with SQL Server, and the database
    schema will be `Product` instead of `dbo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our product database is segregated. We will use this database in our product
    service, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b8f6813-6396-4dec-989e-9aeeaeffd95b.png)'
  prefs: []
  type: TYPE_IMG
- en: We have created a separated product database for our product service. We did
    not migrate the entire data. In the following sections, we will discuss product
    database migration as well. Migration is important as we have numerous existing
    records of FlixOne bookstore customers. We can't ignore these records, and they
    need to be migrated to our modified structure. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we separated our product database to ensure that it
    would only be used by our product service. We also selected a technology stack
    of our choice to build our microservice (product service). In this section, we
    will discuss how we can migrate both our existing code and database to ensure
    that they fit right in with our new architectural style.
  prefs: []
  type: TYPE_NORMAL
- en: Code migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code migration does not involve just pulling out a few layers of code from
    the existing monolithic application and then bundling it with our newly created
    **Product service**. In order to achieve this, you''ll need to implement all that
    you have learned up until now. In the existing monolithic application, we have
    a single repository, which is common to all modules, whereas, for microservices,
    we will create repositories for each module separately and keep them isolated
    from each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e671df5-24e4-49e7-8c3b-70ae5507352d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, **Product service** has a **Product repository**, which
    further interacts with its designated data store, named **Product database**.
    We will now discuss microcomponents a bit more. They are nothing but isolated parts
    of the application (microservice), namely common classes and business functionalities.
    It is worthwhile to note here that the **Product repository** itself is a microcomponent
    in the world of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our final product service, which is to be done in ASP.NET Core 2.0, we will
    work with a model and controller to create our REST API. Let''s talk about both
    of these briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Model: This is an object that represents the data in the product service. In
    our case, the identified models are stacked into product and category fields.
    In our code, models are nothing but a set of simple C# classes. When we talk in
    terms of EF Core, they are commonly referred to as **plain old CLR objects** (**POCOs**).
    POCOs are nothing but simple entities without any data access functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller: This is a simple C# class that inherits an abstract class controller
    of the `Microsoft.AspNetCore.Mvc `namespace. It handles HTTP requests and is responsible
    for the creation of the HTTP response to be sent back. In our **Product** service,
    we have a product controller that handles everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's follow a step-by-step approach to create our product service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As already decided in the previous sections, we will create our `ProductService`
    in ASP.NET Core 2.0 or C# 7.0, using Visual Studio. Let''s look at what steps
    are required to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new project by navigating to File | New | Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the template options available, select ASP.NET Core Web Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the project name as `FlixOne.BookStore.ProductService`, and click on ok.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the template screen, select Web Application (Model-View-Controller) and
    make sure you have selected .NET Core and ASP.NET Core 2.0 from the options, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02d9049b-d80a-4141-8e6c-f6924ca39bac.png)'
  prefs: []
  type: TYPE_IMG
- en: 6\. Leave rest options as the default and click on ok.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new solution should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffc4e6f9-bc82-4013-a5a3-1d1ff156a5cd.png)'
  prefs: []
  type: TYPE_IMG
- en: From the solution explorer, right-click (or press *Alt* + *Enter*) on the project
    and click on Properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Properties window, click on Build and click on Advance. The Language
    version should be C#7.0, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa3860db-5a10-4058-9e42-ce6490740072.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our monolithic application, we do not have any model classes yet. So let's
    go ahead and add a new model as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the new model, add a new folder and name it `Models`. In the Solution
    Explorer, right-click on the project and then click on options from Add | New
    Folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/062c2d4c-7372-4fbb-ad95-7d72e74618e2.png)'
  prefs: []
  type: TYPE_IMG
- en: There is no hard and fast rule for putting all the model classes in a folder
    named `Models`. As a matter of fact, we can put our model classes anywhere in
    the project in our application. We follow this practice as it becomes self-explanatory
    from folder names. At the same time, it easily identifies that this folder is
    for the model classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add new Product and Category classes (these classes will represent our POCOs),
    do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Models` folder and chose Option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add New Item|Class. We will name them `Product` and `Category`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add the properties that depict our product database column name to the tables `Product`
    and `Category`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no restriction regarding having the property name match the table column
    name. It is just general practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet depicts what our `Product.cs` model class will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows what our `Category.cs` model class will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Adding a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our monolithic application, we have a common repository throughout the project.
    In `ProductService`, by virtue of following all the principals learned up until
    now, we will create microcomponents, which means separate repositories encapsulating
    the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: A repository is nothing but a simple C# class that contains the logic to retrieve
    data from the database and maps it to the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a repository is as simple as following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and name it `Persistence`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `IProductRepository` interface and a `ProductRepository` class that
    will implement the `IProductRepository` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, we name the folder `Persistence` in an effort to follow the general principal
    for easy identification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet provides an overview of the `IProductRepository`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet provides an overview of the `ProductRepository` class
    (it is still without any implementation and it does not have any interaction with
    the database yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Registering the repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For `ProductService`, we will use built-in dependency injection support with
    ASP.NET Core. To do so, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Startup.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the repository to the `ConfigureServices` method. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Adding a product controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we have reached the stage where we can proceed to add our controller
    class. This controller will actually be responsible for responding to the incoming
    HTTP requests with the applicable HTTP response. In case you are wondering what
    is to be done with that, you can see the `HomeController` class, as it is a default
    class provided by the ASP.NET core template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `controllers` folder, chose the Add | New Item option, and
    select Web API Controller Class. Name it `ProductController`. Here we are going
    to utilize whatever code/functionality we can from the monolithic application.
    Go back to the legacy code and look at the operations you''re performing there;
    they can be borrowed for our `ProductController` class. Refer to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13d111e8-9d32-4c0e-8c50-7305312f1990.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After we have made the required modifications to `ProductController`, it should
    look something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The ProductService API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our monolithic application, for the `Product` module, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new `Product` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating an existing `Product` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an existing `Product` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving a `Product` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will create `ProductService`; we require the following APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API Resource** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`Product` | Gets a list of products |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`Product{id}` | Gets a product |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` /`api`/`Product{id}` | Updates an existing product |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` /`api`/`Product{id}` | Deletes an existing product |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` /`api`/`Product` | Adds a new product |'
  prefs: []
  type: TYPE_TB
- en: Adding EF core support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going further, we need to add EF so that our service can interact with
    the actual product database. Until now, we did not add any method to our repository
    that could interact with the database.
  prefs: []
  type: TYPE_NORMAL
- en: To add EF core support, we need to add EF's core `sqlserver` package (we are
    adding the `sqlserver` package because we are using SQL Server as our DB server).
    Open the NuGet Package Manager (Tools | NuGet Package Manager | Manage NuGet Package).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the NuGet Package and search for `Microsoft.EntityFrameworkCore.SqlServer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9de49b9-e010-4ae5-b66d-2035e6473095.png)'
  prefs: []
  type: TYPE_IMG
- en: EF Core DbContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we added the EF Core 2.0 package for SQL Server support;
    now we need to create a context so our models can interact with our product database.
    We have the Product and Category models, refer to this list:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new folder and name it `Contexts`—it is not compulsory to add a new folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `context` folder, add a new C# class and name it `ProductContext`. We
    are creating `DbContext` for `ProductDatabase`, so to make it similar here, we
    are creating `ProductContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the `ProductContext` class inherits the `DbContext` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the changes, and our `ProductContext` class will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have created our context, but this context is independent of the product
    database. We need to add a provider and connection string so that `ProductContext` can
    talk with our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, open the `Startup.cs` file and add the `SQL Server db` provider
    for our EF Core support, under the `ConfigureServcies` method. Once you add the
    provider''s `ConfigureServcies` method, our `Startup.cs` file will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `appsettings.json` file and add the required database connection string.
    In our provider, we have already set the connection key as `ProductsConnection.`
    So now, add the following line to set the connection string with the same key
    (change Data Source to your data source):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: EF Core migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we have already created our product database, it is not time to underestimate
    the power of EF Core migrations. EF Core migrations will be helpful for us to
    perform any future modifications to the database. This modification could be in
    the form of a simple field addition or any other update to the database structure.
    We can simply rely on these EF Core migration commands every time to do the necessary
    changes for us. In order to utilize this capability, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Tools | NuGet Package Manager | Package Manager Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following commands from Package Manager Console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To initiate the migration, run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that this is to be done only the first time (when we
    do not yet have a database created by this command).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, whenever there are any changes in your model, simply execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Database migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we are done with our `ProductDatabase` creation. Now it's time
    to migrate our existing database. There are many different ways to do this. Our
    monolithic application, which presently has a huge database, contains a large
    number of records as well. It is not possible to migrate them by simply using
    a database SQL script.
  prefs: []
  type: TYPE_NORMAL
- en: We need to explicitly create a script to migrate the database with all of its
    data. Another option is to go ahead and create a DB package as required. Depending
    on the complexity of your data and the records, you might need to create more
    than one data package to ensure that the data is migrated correctly to our newly
    created database, `ProductDB`.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting repositories and the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to facilitate interaction between our model and database via our
    newly created repositories. After making the appropriate changes to `ProductRepository`,
    it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Introducing ViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new class to the `models` folder and name it `ProductViewModel`. We do
    this because, in our monolithic application, whenever we search for a product,
    it should be displayed in its product category. In order to support this, we need
    to incorporate the necessary fields into our view model. Our `ProductViewModel` class
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Revisiting the product controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we are ready to create a REST API for `ProductService`. After the
    changes are made, here is what `ProductController` will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have completed our all the tasks that are required for web API creation.
    Now, we need to tweaks few things so that client can get information about our
    web APIs. So, in the upcoming sections, we will add Swagger to our web API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Swagger support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are using Swagger in our API documentation. We will not dive into the details
    of Swagger here (for more information, refer to [https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)).
  prefs: []
  type: TYPE_NORMAL
- en: Swagger is an open source and famous library that provides documentation for
    Web APIs. Refer to the official link, [https://swagger.io/](https://swagger.io/),
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very easy to add documentation using Swagger. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open NuGet Package Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the `Swashbuckle.AspNetCore` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the package and then install the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f71fad12-faa2-4147-833b-53ac1361df19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will install the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swashbuckle.AspNetCore
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Swashbuckle.AspNetCore.Swagger
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Swashbuckle.AspNetCore.SwaggerGen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Swashbuckle.AspNetCore.SwaggerUI
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20ceaa41-dd98-46f8-ace6-39f8a46fc3c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `Startup.cs` file, move to the ConfigureServices method, and add the
    following lines to register the Swagger generator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the Configure method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Press *F5* and run the application; you'll get a default page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Swagger documentation by adding swagger in the URL. So, the URL would
    be `http://localhost:43552/swagger/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64e5272f-fc8a-4a65-be37-8a765d25ae75.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image shows the Product API resources, and you can try these APIs
    from within the Swagger documentation page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have completed the transition of our monolith .NET application
    to microservices and discussed the step-by-step transition of `ProductService`.
    There are more steps to come for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How microservices communicate: This will be discussed in *Chapter 3, Integration
    Techniques and Microservices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to test a microservice: This will be discussed in **Chapter 4, Testing
    Microservices**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploying microservices: This will be discussed in *[Chapter 5](6843b0a1-0287-4d15-9e72-fdf228e52604.xhtml),
    Deploying Microservices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How can we make sure our microservices are secure, and monitoring our microservices:
    This will be discussed in *Chapter 6, Securing Microservices*, and *Chapter 7,
    Monitoring Microservices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How microservices are scaled: This will be discussed in *Chapter 8, Scaling
    Microservices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the different factors that can be used to identify
    and isolate microservices at a high level. We also discussed the various characteristics
    of a good service. When talking about DDD, we learned its importance in the context
    of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we analyzed how we can correctly achieve the vertical isolation
    of microservices through various parameters in detail. We tried to draw on our
    previous understanding of the challenges posed by a monolithic application and
    its solution in microservices, and we learned that we can use factors such as
    module interdependency, technology utilization, and team structure to identify
    seams and perform the transition from a monolithic architecture to microservices
    in an organized manner.
  prefs: []
  type: TYPE_NORMAL
- en: It became apparent that the database can pose a clear challenge in this process.
    However, we identified how we can still perform the process using a simple strategy
    and the possible approaches to do this. We then established that, with the foreign
    keys reduced/removed, the transactions can be handled in a completely different
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on from a monolith to bounded contexts, we further applied our knowledge
    to transition the FlixOne application to a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
