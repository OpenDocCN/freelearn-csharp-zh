- en: Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: State-driven behavior DIY states
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由状态驱动的行为 DIY状态
- en: State-driven behavior State Design Pattern classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由状态驱动的行为 状态设计模式类
- en: State-driven behavior with Unity Scriptable Objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity可脚本化对象的状态驱动行为
- en: Publisher-Subscriber pattern C# delegates and events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布-订阅模式 C#委托和事件
- en: Model-View-Controller (MVC) pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）模式
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In computer programming in general, some types of features and requirements
    occur commonly. For computer game programming, there are often features for new
    games that have things in common with existing games. Software **Design Patterns**
    are reusable, computer-language-independent templates for how to solve common
    problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程的一般情况下，某些类型的功能和需求经常出现。对于计算机游戏编程，新游戏通常具有与现有游戏共同的特征。软件**设计模式**是解决常见问题的可重用、计算机语言无关的模板。
- en: Not all design patterns are needed for all languages (for example, some computer
    languages may have features that already provide an easy way to solve a common
    problem). In this chapter, we'll explore several common design patterns in the
    context of Unity game programming in the C# programming language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有设计模式对所有语言都是必需的（例如，某些计算机语言可能已经提供了解决常见问题的简单方法）。在本章中，我们将探讨在C#编程语言背景下Unity游戏编程中的几个常见设计模式。
- en: The big picture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体情况
- en: There is no need to reinvent the wheel, and there are many advantages for game
    programmers to adopt tried-and-tested approaches to solving common features for
    game projects. Design patterns have been designed by experience, and refined to
    encourage good programming practice and well-designed architectural software solutions.
    A common theme in design patterns is the independence of code components, and
    clearly-defined interfaces for when components do need to know about each other
    and the protocols for their interactions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要重新发明轮子，并且对于游戏程序员来说，采用经过验证的方法来解决游戏项目中常见的功能有许多优势。设计模式是通过经验设计的，并经过提炼，以鼓励良好的编程实践和精心设计的软件架构解决方案。设计模式中的常见主题是代码组件的独立性，以及当组件需要相互了解时，明确定义的接口及其交互协议。
- en: 'In this chapter, the recipes focus on three main design patterns, all of which
    are well known and found not only in game software designs but in the design of
    many interactive software systems, such as web applications and mobile phone programming.
    The design patterns explored in this chapter are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，食谱主要关注三个主要设计模式，这些模式不仅众所周知，而且不仅存在于游戏软件设计中，还存在于许多交互式软件系统的设计中，如Web应用和手机编程。本章探讨的设计模式包括：
- en: '**The State pattern**: States and their transitions'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态模式**：状态及其转换'
- en: '**The Publisher-Subscriber pattern**: Observers subscribing to event-publishing
    objects'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布-订阅模式**：观察者订阅事件发布对象'
- en: '**The Model-View-Controller (MCV) pattern**: Separating internal workings from
    UI components and display representations'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器（MVC）模式**：将内部工作与UI组件和显示表示分离'
- en: In this chapter, examples are presented in generic object-oriented designs,
    also there are C#-specific features (such as **delegates** and **events**), and
    some Unity-specific features (such as **scriptable objects**). While generic approaches
    have the advantage that programmers from other languages or domains will be instantly
    familiar with their Unity game implementations, the most significant game memory-speed
    improvements are found through exploiting language- and engine-specific features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，示例以通用面向对象设计的形式呈现，同时也有C#特定的功能（例如**委托**和**事件**），以及一些Unity特定的功能（例如**可脚本化对象**）。虽然通用方法具有优势，即来自其他语言或领域的程序员会立即熟悉他们的Unity游戏实现，但通过利用语言和引擎特定的功能，可以找到最显著的内存速度提升。
- en: 'C# **Delegate** variables are like a container for a function (or collection
    of functions) that can be passed around and invoked. They have values assigned
    to them and can be changed at runtime. **Delegates** can multicast through the
    use of the `+=` operator, multiple methods can be assigned a single delegate,
    and all will be invoked when the delegate is invoked. C# **events** are a special,
    more secure kind of delegate. By defining public static event variables, we restrict
    other script classes to only be allowed to:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的 **Delegate** 变量就像一个用于函数（或函数集合）的容器，这些函数可以被传递和调用。它们被分配了值，并且可以在运行时更改。**Delegates**
    可以通过使用 `+=` 操作符进行多播，多个方法可以被分配给单个委托，并且当委托被调用时，所有方法都会被调用。C# 的 **events** 是一种特殊且更安全的委托类型。通过定义公共静态事件变量，我们限制其他脚本类只能允许：
- en: Subscribe one of their methods
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅其中一个方法
- en: Unsubscribe one of their methods
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消其中一个方法的订阅
- en: Events ensure a good separation of our code logic, and mean that the script
    class publishing events does not need to know anything about, or how many, other
    script classes are subscribing to published events.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 事件确保了我们的代码逻辑的良好分离，并且意味着发布事件的脚本类不需要了解或关心有多少其他脚本类正在订阅发布的事件。
- en: 'Here are some sources where you can learn more about **Design Patterns** and
    Unity:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以学习更多关于 **设计模式** 和 Unity 的资源：
- en: 'The Unity tutorial about **Scriptable Objects** for enemy state-driven AI:
    [https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern](https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于由敌人状态驱动的 AI 的 Unity 教程：[https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern](https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern)
- en: 'The Unity tutorial about **delegates** and **events**:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 **delegates** 和 **events** 的 Unity 教程：
- en: '[https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117](https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117](https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117)'
- en: '[https://unity3d.com/learn/tutorials/topics/scripting/events](https://unity3d.com/learn/tutorials/topics/scripting/events)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unity3d.com/learn/tutorials/topics/scripting/events](https://unity3d.com/learn/tutorials/topics/scripting/events)'
- en: 'Prime[31]''s video about Unity delegates and events (from 2011, but still a
    nice introduction): [http://www.youtube.com/watch?v=N2zdwKIsXJs](http://www.youtube.com/watch?v=N2zdwKIsXJs)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prime[31] 关于 Unity 委托和事件的视频（2011 年发布，但仍然是一个很好的介绍）：[http://www.youtube.com/watch?v=N2zdwKIsXJs](http://www.youtube.com/watch?v=N2zdwKIsXJs)
- en: 'Eric Nordeus'' tutorial on Unity and **Design Patterns**: [http://www.habrador.com/tutorials/programming-patterns/](http://www.habrador.com/tutorials/programming-patterns/)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eric Nordeus 的 Unity 和 **设计模式** 教程：[http://www.habrador.com/tutorials/programming-patterns/](http://www.habrador.com/tutorials/programming-patterns/)
- en: 'Unity **Model-View-Controller** tutorials:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity **模型-视图-控制器** 教程：
- en: 'Gameasutra: [https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php](https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Gameasutra: [https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php](https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php)'
- en: 'Eduardo Dias Da Costa: [https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development](https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eduardo Dias Da Costa：[https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development](https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development)
- en: 'Jackson Dunstan: [https://jacksondunstan.com/articles/3092](https://jacksondunstan.com/articles/3092)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jackson Dunstan：[https://jacksondunstan.com/articles/3092](https://jacksondunstan.com/articles/3092)
- en: State-driven behavior DIY states
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动行为的状态 DIY 状态
- en: 'Games as a whole, and individual objects or characters, can often be thought
    of (or modeled as) passing through different states or modes. Modeling states
    and changes of state (due to events or game conditions) is a very common way to
    manage the complexity of games and game components. In this recipe, we create
    a simple three-state game (game playing/game won/game lost) using a `GameManager`
    class. Buttons and a timer are provided to simulate the events that would allow
    a player to win or lose the game:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，游戏以及单个对象或角色，常常可以被视为（或建模为）通过不同的状态或模式。建模状态和状态变化（由于事件或游戏条件）是管理游戏和游戏组件复杂性的非常常见方式。在本食谱中，我们使用
    `GameManager` 类创建了一个简单的三状态游戏（游戏进行中/游戏胜利/游戏失败）。提供了按钮和计时器来模拟允许玩家赢得或输掉游戏的事件：
- en: '![](img/db3d658f-f2bb-45a7-b80a-21f607df37ec.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db3d658f-f2bb-45a7-b80a-21f607df37ec.png)'
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To use states to manage object behavior, follow these steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用状态来管理对象行为，请按照以下步骤操作：
- en: Create two UI Buttons at the top-middle of the screen. Name one `Button-win`
    and edit its text to read `Win Game`. Name the second `Button-lose` and edit its
    text to read `Lose Game`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部中间创建两个UI按钮。将一个命名为`Button-win`，并编辑其文本为“Win Game”。将第二个命名为`Button-lose`，并编辑其文本为“Lose
    Game”。
- en: Create a UI Text object at the top left of the screen. Name this `Text-state-messages`,
    and set its Rect Transform height property to `300` and its Text (Script) Paragraph
    Vertical Overflow property to `Overflow`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕左上角创建一个UI Text对象。将其命名为`Text-state-messages`，并将其Rect Transform高度属性设置为`300`，其Text（脚本）Paragraph
    Vertical Overflow属性设置为`Overflow`。
- en: 'Create a new C# script class,&nbsp;`GameStates.cs`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类，`GameStates.cs`：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the&nbsp;`MyGameManager.cs`&nbsp;C# script class, and add an instance
    object as a component to the Main Camera:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MyGameManager.cs`C#脚本类，并将实例对象作为组件添加到主摄像机：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the&nbsp;`ButtonActions.cs`&nbsp;C# script class, and add an instance
    object as a component to the Main Camera:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ButtonActions.cs`C#脚本类，并将实例对象作为组件添加到主摄像机：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the Hierarchy, select the Button-win button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the ButtonsActions component in the Main Camera GameObject.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择“Button-win”按钮，并为它的按钮（脚本）组件添加一个OnClick动作，以从主摄像机GameObject中的ButtonsActions组件调用`BUTTON_CLICK_ACTION_WIN_GAME()`方法。
- en: In the Hierarchy, select the Button-lose button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the ButtonActions component in the Main Camera GameObject.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择“Button-lose”按钮，并为它的按钮（脚本）组件添加一个OnClick动作，以从主摄像机GameObject中的ButtonActions组件调用`BUTTON_CLICK_ACTION_LOSE_GAME()`方法。
- en: In the Hierarchy, select the Main Camera GameObject. Drag this GameObject into
    the Inspector to ensure that all three GameManager (Script) public variables (Text
    State Messages, Button Win Game, and Button Lose Game)&nbsp;have the corresponding
    Canvas GameObjects dragged into them (the two buttons and the UI Text GameObject).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择主摄像机GameObject。将此GameObject拖入检查器以确保所有三个GameManager（脚本）公共变量（Text State
    Messages、Button Win Game和Button Lose Game）都有相应的Canvas GameObject拖入其中（两个按钮和UI Text
    GameObject）。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As can be seen in the following state chart figure, this recipe models a simple
    game, which starts in the `GamePlaying` state; then, depending on the button clicked
    by the user, the game moves either into the `GameWon` state or the `GameLost`
    state. Also, if the user waits too long (five seconds) to click on a button, the
    game moves into the `GameLost` state.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下状态图所示，这个配方模拟了一个简单的游戏，它从`GamePlaying`状态开始；然后，根据用户点击的按钮，游戏将移动到`GameWon`状态或`GameLost`状态。另外，如果用户等待太长时间（五秒）才点击按钮，游戏将移动到`GameLost`状态。
- en: 'The possible states of the system are defined using the enumerated&nbsp;`GameStateType`&nbsp;type
    in the&nbsp;`GameStates` class, and the current state of the system at any point
    in time is stored in the&nbsp;`currentState` variable of GameManager:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的可能状态是通过在`GameStates`类中使用枚举的`GameStateType`类型来定义的，并且系统在任何时间点的当前状态都存储在`GameManager`的`currentState`变量中：
- en: '![](img/618d0afd-9a1a-42b7-878d-22f91b072349.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/618d0afd-9a1a-42b7-878d-22f91b072349.png)'
- en: The initial state,&nbsp;`GamePlaying`, is set in the `Start()` method of `MyGameManager`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态`GamePlaying`是在`MyGameManager`的`Start()`方法中设置的。
- en: '`GameManager` seems to now be a special asset name in Unity, for that reason,
    we have named our game manager script classes `MyGameManager` to avoid any issues.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager`在Unity中似乎是一个特殊的资产名称，因此，我们已将我们的游戏管理脚本类命名为`MyGameManager`，以避免任何问题。'
- en: When the `MyGameManager` object receives messages (for example, every frame
    for `Update()`), its behavior must be appropriate for the current state. So, we
    see a `Switch` statement in the&nbsp;`Update()` method&nbsp;that calls state-specific
    methods. For example, if the current state is `GamePlaying`, when an `Update()`
    message is received, the `UpdateStateGamePlaying()` method will be called.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MyGameManager`对象接收到消息（例如，对于`Update()`，每帧一次）时，其行为必须适合当前状态。因此，我们在`Update()`方法中看到了一个`Switch`语句，它调用特定状态的方法。例如，如果当前状态是`GamePlaying`，当接收到`Update()`消息时，将调用`UpdateStateGamePlaying()`方法。
- en: 'The `NewGameState(...)` method first calls the `OnMyStateExit(...)` method
    with the current state, since there may be actions to be performed when a particular
    state is exited; for example, when the `GamePlaying` state is exited, it destroys
    the two buttons. Next, the `NewGameState(...)` method sets the `currentState`
    variable to be assigned the new state. Next, the `OnMyStateEnter(...)` method
    is called, since there may be actions to be performed immediately when a new state
    is entered. Finally, a message divider is posted     to the UI Text box, with a call to the `PostMessageDivider()` method.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewGameState(...)`方法首先调用带有当前状态的`OnMyStateExit(...)`方法，因为当退出特定状态时可能需要执行某些操作；例如，当退出`GamePlaying`状态时，它会销毁两个按钮。接下来，`NewGameState(...)`方法将`currentState`变量设置为分配新状态。然后，调用`OnMyStateEnter(...)`方法，因为当进入新状态时可能需要立即执行某些操作。最后，通过调用`PostMessageDivider()`方法，在UI文本框中发布一个消息分隔符。'
- en: The `BUTTON_CLICK_ACTION_WIN_GAME()` and `BUTTON_CLICK_ACTION_LOSE_GAME()` methods
    are executed if their corresponding buttons have been clicked. They move the game
    into the corresponding `GameWon` or `GameLost` state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当对应的按钮被点击时，会执行`BUTTON_CLICK_ACTION_WIN_GAME()`和`BUTTON_CLICK_ACTION_LOSE_GAME()`方法。它们将游戏移动到相应的`GameWon`或`GameLost`状态。
- en: Logic has been written in the `UpdateStateGamePlaying()` method, so once&nbsp;`MyGameManager`
    has been in the `GamePlaying` state for more than a certain time (defined in the&nbsp;`timeToPressAButton`
    variable), the game will automatically change into the `GameLost` state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑已经编写在`UpdateStateGamePlaying()`方法中，因此一旦`MyGameManager`处于`GamePlaying`状态超过一定时间（由`timeToPressAButton`变量定义），游戏将自动变为`GameLost`状态。
- en: So, for each state, we may need to write methods for state exit, state entry,
    and update events, and also a main method for each event with a Switch statement
    to determine which state method should be called (or not). As can be imagined,
    the size of our methods and the number of methods in our `MyGameManager` class
    will grow significantly as more states and a more complex game logic are needed
    for non-trivial games.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个状态，我们可能需要编写状态退出、状态进入和更新事件的相应方法，以及每个事件的主方法，其中包含一个Switch语句来确定应该调用哪个状态方法（或不应调用）。正如可以想象的那样，随着更多状态和更复杂的游戏逻辑的需求增加，我们的方法和`MyGameManager`类中的方法数量将显著增加。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe takes a more sophisticated approach to state-driven games, where
    each state has its own class. The next recipe in this chapter illustrates how
    to manage the complexity of states with class inheritance and the State Design
    Pattern.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个菜谱采用了一种更复杂的状态驱动游戏方法，其中每个状态都有自己的类。本章节的下一个菜谱展示了如何通过类继承和状态设计模式来管理状态的复杂性。
- en: State-driven behavior using the State Design Pattern
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态设计模式实现状态驱动行为
- en: The previous pattern illustrated not only the usefulness of modeling game states,
    but also how a game manager class can grow in size and become unmanageable. To
    manage the complexity of many states and complex behaviors of states, the State
    pattern has been proposed in the software-development community. Design patterns
    are general-purpose software component architectures that have been tried and
    tested and found to be good solutions to commonly-occurring software-system features.
    The key features of the State pattern are that each state is modeled by its own
    class and that all states inherit (are subclassed) from a single parent state
    class. The states need to know about each other in order to tell the game manager
    to change the current state. This is a small price to pay for the division of
    the complexity of the overall game behavior into separate state classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的模式不仅说明了建模游戏状态的有用性，而且还说明了游戏管理类如何增长并变得难以管理。为了管理许多状态和状态的复杂行为，软件开发社区提出了状态模式。设计模式是一般用途的软件组件架构，经过尝试和测试，被证明是解决常见软件系统特征的优秀解决方案。状态模式的关键特性是每个状态都由其自己的类来建模，并且所有状态都继承（子类化）自单个父状态类。状态需要相互了解，以便告诉游戏管理器更改当前状态。这是为了将整体游戏行为的复杂性分解为单独的状态类而付出的微小代价。
- en: 'Note: Many thanks to the contribution from Bryan Griffiths, which has helped
    improve this recipe.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：非常感谢Bryan Griffiths的贡献，这有助于改进这个菜谱。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the previous recipe. So, make a copy of that project,
    open it, and then follow the steps for this recipe.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱基于之前的菜谱。因此，请复制那个项目，打开它，然后按照这个菜谱的步骤进行操作。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To manage an object''s behavior using the State pattern architecture, perform
    the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用状态模式架构管理对象的行为，请执行以下步骤：
- en: 'Create a new C# script class called `GameState`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的C#脚本类，名为`GameState`:'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a new C# script class called `StateGamePlaying`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的C#脚本类，名为`StateGamePlaying`:'
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new C# script class called `StateGameWon`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的C#脚本类，名为`StateGameWon`:'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a new C# script class called `StateGameLost`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的C#脚本类，名为`StateGameLost`:'
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace the contents of the&nbsp;`MyGameManager`&nbsp;C# script class with
    the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换`MyGameManager`C#脚本类的现有内容：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the Hierarchy, select the Button-win button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the GameManager component in the Main Camera GameObject.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，选择“Button-win”按钮，为其“Button (Script)”组件添加一个OnClick动作，以调用主摄像机GameObject中GameManager组件的`BUTTON_CLICK_ACTION_WIN_GAME()`方法。
- en: In the Hierarchy, select the Button-lose button, and for its Button (Script)
    component, add an OnClick action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the GameManager component in the Main Camera GameObject.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，选择“Button-lose”按钮，为其“Button (Script)”组件添加一个OnClick动作，以调用主摄像机GameObject中GameManager组件的`BUTTON_CLICK_ACTION_LOSE_GAME()`方法。
- en: In the Hierarchy, select the Main Camera GameObject. Drag&nbsp;it into the Inspector
    to ensure that all three GameManager (Script) public variables (Text State Messages,
    Button Win Game, and Button Lose Game)&nbsp;have the corresponding Canvas GameObjects
    dragged into them (the two buttons and the **UI Text** GameObject).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，选择主摄像机GameObject。将其拖动到检查器中，以确保所有三个GameManager (Script)公共变量（文本状态消息、按钮赢游戏和按钮输游戏）都有相应的Canvas
    GameObject拖动到它们中（两个按钮和**UI Text**GameObject）。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The scene is very straightforward for this recipe. There is the single Main
    Camera GameObject that has the `MyGameManager` script object component attached
    to it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，场景非常简单。有一个单独的主摄像机GameObject，它附有`MyGameManager`脚本对象组件。
- en: "A C# scripted class is defined for each state that the game needs to manage—for\
    \ this example,&nbsp;`StateGamePlaying`, `StateGameWon`, and `StateGameLost`.\
    \ Each of these state classes is a subclass of `GameState`. `GameState` defines\
    \ properties \Land methods that all subclass states will possess:"
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为游戏需要管理的每个状态定义一个C#脚本类——对于这个例子，`StateGamePlaying`、`StateGameWon`和`StateGameLost`。这些状态类都是`GameState`的子类。`GameState`定义了所有子类状态将拥有的属性和方法：
- en: 'An enumerated type `EventType`, which defines the two possible button click
    events that the game might generate: `ButtonWinGame` and `ButtonLoseGame`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个枚举类型`EventType`，它定义了游戏可能生成的两种可能的按钮点击事件：`ButtonWinGame`和`ButtonLoseGame`。
- en: The `gameManager` variable so that each state object has a link to the game
    manager.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gameManager`变量，以便每个状态对象都有一个指向游戏管理器的链接。'
- en: The constructor method that accepts a reference to `MyGameManager`, which&nbsp;automatically
    makes the `gameManager` variable refer to the passed-in `MyGameManager` object.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受对`MyGameManager`引用的构造函数方法，这会自动使`gameManager`变量指向传入的`MyGameManager`对象。
- en: 'The four methods with empty bodies: `OnMyStateEntered()`, `OnMyStateExit()`,
    `OnEventRecieved(...)`, and `StateUpdate()`. Note that these methods are declared
    virtual so that they can be overridden by subclasses if necessary, but if not
    overridden then will do nothing.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个具有空体的方法：`OnMyStateEntered()`、`OnMyStateExit()`、`OnEventRecieved(...)`和`StateUpdate()`。请注意，这些方法被声明为虚拟的，以便在必要时可以被子类覆盖，如果没有覆盖，则不会执行任何操作。
- en: 'When the `MyGameManager` class''s&nbsp;`Awake()` method is executed, three
    state objects are created, one for each of the playing/win/lose classes. These
    state objects are stored in their corresponding variables: `stateGamePlaying`,
    `stateGameWon`, and `stateGameLost`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MyGameManager`类的`Awake()`方法执行时，将创建三个状态对象，每个对象对应于一个玩/赢/输类。这些状态对象存储在其相应的变量中：`stateGamePlaying`、`stateGameWon`和`stateGameLost`。
- en: The `MyGameManager` class has a variable called `currentState`, which is a reference
    to the current state object at any time while the game runs (initially, it will
    be null). Since it is of the `GameState` class (the parent of all state classes),
    it can refer to any of the different state objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyGameManager`类中有一个名为`currentState`的变量，它在游戏运行期间始终指向当前状态对象（最初，它将是null）。由于它是`GameState`类（所有状态类的父类）的引用，它可以指向任何不同的状态对象。'
- en: After `Awake()`, `GameManager` will receive a `Start()` message. This method
    initializes&nbsp;`currentState` to be the `stateGamePlaying` object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Awake()` 之后，`GameManager` 将接收一个 `Start()` 消息。此方法将 `currentState` 初始化为 `stateGamePlaying`
    对象。
- en: 'For each frame,&nbsp;`GameManager` will receive `Update()` messages. Upon receiving
    these messages, `GameManager` sends a `StateUpdate()` messages to&nbsp;`currentState     &nbsp;`&nbsp;object. So, for each frame, the object for the current state of the
    game will execute those methods. For example, when&nbsp;`currentState` is set
    to game playing, for each frame, the `gamePlayingObject` will calls its (in this
    case, empty) `StateUpdate()` method.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一帧，`GameManager` 将接收 `Update()` 消息。在接收到这些消息后，`GameManager` 会向 `currentState`
    对象发送 `StateUpdate()` 消息。因此，对于每一帧，当前游戏状态的对象将执行这些方法。例如，当 `currentState` 设置为游戏进行时，对于每一帧，`gamePlayingObject`
    将调用其（在这种情况下，为空的）`StateUpdate()` 方法。
- en: The `StateGamePlaying` class implements statements in its `OnEventReceived()`
    method so that when the user clicks on a button, the `gamePlayingObject` will
    call the `GameManager` instance's `NewState(...)` method, passing it the object
    corresponding to the new state. So for example, if the user clicks on Button-win,
    the `NewState(...)` method is passed to `gameManager.stateGameWon`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateGamePlaying` 类在其 `OnEventReceived()` 方法中实现了语句，以便当用户点击按钮时，`gamePlayingObject`
    将调用 `GameManager` 实例的 `NewState(...)` 方法，并传递对应新状态的对象。例如，如果用户点击按钮-win，则 `NewState(...)`
    方法传递给 `gameManager.stateGameWon`。'
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节你不希望错过。
- en: Adding the Timer event to lose the game after five seconds
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏开始后五秒添加计时器事件
- en: 'The state pattern solution makes it much simpler, and cleaner to add new features.
    For example, to add the five-second-timer feature to this recipe, do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式解决方案使得添加新功能变得更加简单和清晰。例如，要将五秒计时器功能添加到这个配方中，请执行以下操作：
- en: 'Create a new C# script class called `SimpleTimer`, and add an instance object
    as a component to the Main Camera GameObject:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类名为 `SimpleTimer`，并将实例对象作为组件添加到主摄像机 GameObject：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a new event type of `TimerFinished` to the `GameState` script class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameState` 脚本类中添加一个新的 `TimerFinished` 事件类型：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a new case to the switch statement in `StateGamePlaying`, so that this
    `TimerFinished` event also causes the game to go into the `GameLost` state:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StateGamePlaying` 中的 switch 语句中添加一个新的情况，以便这个 `TimerFinished` 事件也能使游戏进入 `GameLost`
    状态：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See also
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In this recipe, some of the complexity of different types of events causing
    the `MyGameManager` to change its current state was implemented by other scripted
    objects (`ButtonActions` and `SimpleTimer` as scripted object components inside
    Main Camera) invoking the&nbsp;`PublishEventToCurrentState(...)` public method.
    A better was to implement events in games is provided later in this chapter in
    the&nbsp;*Publisher-Subscriber pattern C# delegates and events* recipe.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个配方中，通过其他脚本对象（如主摄像机内部的脚本对象组件 `ButtonActions` 和 `SimpleTimer`）调用 `PublishEventToCurrentState(...)`
    公共方法实现了导致 `MyGameManager` 改变其当前状态的复杂事件类型的一些实现。在本章后面的 *发布-订阅模式 C# 委托和事件* 配方中提供了更好的实现游戏事件的方法。
- en: State-driven behavior with Unity Scriptable Objects
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity Scriptable Objects 的状态驱动行为
- en: Unity has a feature called Scriptable Objects. Scriptable Objects are asset
    files stored in the `Assets` folder, like any other asset (such as Materials or
    Textures). In some ways,&nbsp;Scriptable Objects are like Monobehaviours, but
    they are not attached to GameObjects. Both logic (code) and data can be stored
    as asset files in the form of&nbsp;Scriptable Objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 有一个名为 Scriptable Objects 的功能。Scriptable Objects 是存储在 `Assets` 文件夹中的资产文件，就像其他任何资产（如材质或纹理）一样。在某种程度上，Scriptable
    Objects 类似于 Monobehaviours，但它们不附加到 GameObjects 上。逻辑（代码）和数据都可以以 Scriptable Objects
    的形式作为资产文件存储。
- en: In this recipe, we implement a state-based game where the game starts in a game-playing
    state, and goes to a game-lost state when a timer runs out. If two stars are collected
    before the timer runs out, the game goes into the game-won state. A **UI Button**
    is offered to the user, which collects a star each time it is clicked.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们实现了一个基于状态的游戏，游戏从游戏进行状态开始，当计时器耗尽时进入游戏失败状态。如果在计时器耗尽之前收集到两个星星，游戏将进入游戏胜利状态。提供了一个
    **UI 按钮** 给用户，每次点击都会收集一个星星。
- en: As you'll see, Scriptable Object asset files are used to represent which decisions
    cause which state changes to take place.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，Scriptable Object 资产文件用于表示哪些决策会导致哪些状态变化发生。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To manage a game''s state-driven behavior with Unity Scriptable Objects, perform
    the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Unity 可脚本对象管理游戏的状态驱动行为，请执行以下步骤：
- en: Create a **UI Button** in the middle of the screen. Name it `Button-collect-star`
    and edit its text to read `Collect a star`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕中间创建一个 **UI Button**。将其命名为 `Button-collect-star` 并编辑其文本，使其显示为 `Collect a
    star`。
- en: Create a **UI Text** object at the top-right of the screen. Name this `Text-current-state`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕的右上角创建一个 **UI Text** 对象。将其命名为 `Text-current-state`。
- en: Create a **UI Text** object at the top-left of the screen. Name this `Text-stars-collected`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕的右上角创建一个 **UI Text** 对象。将其命名为 `Text-stars-collected`。
- en: Create a second UI Text object at the top-left of the screen, positioned below
    `Text-stars-collected`. Name this `Text-seconds-left`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕的左上角创建第二个 UI Text 对象，位于 `Text-stars-collected` 下方。将其命名为 `Text-seconds-left`。
- en: 'Create a new C# script class called `Decision`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类，命名为 `Decision`：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new C# script class called `Transition`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类，命名为 `Transition`：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a new C# script class called `State`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类，命名为 `State`：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new C# script class called `StateController`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类，命名为 `StateController`：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a new C# script class called `GameWonDecision`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类，命名为 `GameWonDecision`：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a new C# script class called `GameLostDecision`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类，命名为 `GameLostDecision`：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new C# script class called `MyGameManager`, and add an instance object
    as a component of the Main Camera:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类，命名为 `MyGameManager`，并将其实例对象作为主摄像机的组件添加：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the Hierarchy, select the Button-collect-star button, and for its Button
    (Script) component, add an OnClick action to call the `BUTTON_ACTION_PickupOneStar()`
    method from the `MyGameManager` component in the Main Camera GameObject.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，选择 `Button-collect-star` 按钮，并为它的按钮（脚本）组件添加一个 OnClick 动作，调用主摄像机 GameObject
    中的 `MyGameManager` 组件的 `BUTTON_ACTION_PickupOneStar()` 方法。
- en: In the Project panel, create two new folders, named `_Decisions` and `_States`.
    These folders will contain the Scriptable Object asset files for this project.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建两个新的文件夹，分别命名为 `_Decisions` 和 `_States`。这些文件夹将包含此项目的可脚本对象资产文件。
- en: 'In the&nbsp;`_Decisions` folder, create two new Decision Scriptable Objects
    named `GameWonDecision` and `GameLostDecision`. Do this by choosing menu: Assets
    | Create | MyGame | Decisions.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_Decisions` 文件夹中，创建两个新的决策可脚本对象，分别命名为 `GameWonDecision` 和 `GameLostDecision`。通过选择菜单：资产
    | 创建 | MyGame | 决策来完成此操作。
- en: 'In the&nbsp;`_States` folder, create three new State Scriptable Objects named
    `StateGamePlaying`, `StateGameWon`, and `StateGameLost`. Do this by choosing menu:
    Assets | Create | MyGame | State.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_States` 文件夹中，创建三个新的状态可脚本对象，分别命名为 `StateGamePlaying`、`StateGameWon` 和 `StateGameLost`。通过选择菜单：资产
    | 创建 | MyGame | 状态来完成此操作。
- en: In the&nbsp;Project panel folder `_States`, select the&nbsp;`StateGamePlaying`
    Scriptable Object, and in the Inspector, set the size of its Transitions property
    to `2`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板文件夹 `_States` 中，选择 `StateGamePlaying` 可脚本对象，并在检查器中将其转换属性的大小设置为 `2`。
- en: For Element 0, set the Decision to GameWonDecision and the True&nbsp;state to
    StateGameWon
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于元素 0，将决策设置为 GameWonDecision，并将真实状态设置为 StateGameWon
- en: 'For Element 1, set the Decision to GameLostDecision and the True&nbsp;state
    to StateGameLost:'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于元素 1，将决策设置为 GameLostDecision，并将真实状态设置为 StateGameLost：
- en: '![](img/36fe5ff2-2a96-4d8a-babb-f9622131b3bf.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36fe5ff2-2a96-4d8a-babb-f9622131b3bf.png)'
- en: In the Hierarchy, select the Main Camera GameObject. Drag it into the Inspector
    to ensure that all three GameManager (Script) public variables (Text Current State,
    Text Stars Collected, and Text Seconds Left)&nbsp;have the corresponding Canvas
    **UI Text** GameObjects dragged into them.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，选择主摄像机 GameObject。将其拖动到检查器中，以确保所有三个 GameManager（脚本）公共变量（当前状态文本、收集的星星文本和剩余秒数文本）都有相应的
    Canvas **UI Text** GameObject 拖动到它们中。
- en: Run the game. The game should start in `StateGamePlaying`. If the user does
    nothing, when the timer gets to zero, the game should go into `StateGameLost`.
    If the user clicks the button twice (simulating collecting two stars) before the
    timer hits zero, the game should go into `StateGameWon`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。游戏应从 `StateGamePlaying` 状态开始。如果用户不采取任何操作，当计时器到达零时，游戏应进入 `StateGameLost`
    状态。如果用户在计时器到达零之前点击按钮两次（模拟收集两个星星），游戏应进入 `StateGameWon` 状态。
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'GameManager knows nothing about the state-based decisions going on in this
    game. It has a public method giving the number of seconds left in the timer: `GetTimeRemaining()`.
    It also has a public method that returns a Boolean (true/false) about whether
    or not all stars have been collected: `HasCollectedAllStars()`. It also has references
    to the three&nbsp;**UI Text** GameObjects, so it can keep the display updated
    with the time left and stars collected. A public&nbsp;`DispayCurrentState(...)`&nbsp;method
    also updates the name of current game state (that is, whatever was passed to this
    method).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager` 对游戏中基于状态的决策一无所知。它有一个公共方法提供计时器剩余的秒数：`GetTimeRemaining()`。它还有一个公共方法返回一个布尔值（true/false），表示是否所有星星都已收集：`HasCollectedAllStars()`。它还引用了三个**UI
    Text** GameObject，因此它可以保持显示更新，显示剩余时间和收集的星星。还有一个公共的 `DispayCurrentState(...)` 方法也更新当前游戏状态的名称（即传递给此方法的任何内容）。'
- en: The core game behavior is driven by the `StateController` script class. This
    maintains the current state, and has a reference to the instance object of the
    `MyGameManager` class that is its sibling component in the Main Camera. Its `Awake()`
    method gets the reference to the `MyGameManager` object. Its `Update()`&nbsp;method
    invokes the current state's `UpdateState(...)` method. It passes a reference to
    itself to the current state. It also has a third public method, `TransitionToState(...)`,
    which allows a state to instruct the controller to change the current state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 核心游戏行为由 `StateController` 脚本类驱动。它维护当前状态，并引用 `MyGameManager` 类的实例对象，这是它在主相机中的同级组件。它的
    `Awake()` 方法获取 `MyGameManager` 对象的引用。它的 `Update()` 方法调用当前状态的 `UpdateState(...)`
    方法。它将自己传递给当前状态。它还有一个第三个公共方法，`TransitionToState(...)`，允许状态指示控制器更改当前状态。
- en: 'The `Transition` class has no methods, it simply stores references to two objects:
    a decision and the state that the system will to change to if the decision is
    true.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transition` 类没有方法，它仅仅存储两个对象的引用：一个决策和系统在决策为真时将改变到的状态。'
- en: The `Decision` class is abstract, which means there will never be any objects
    created from this class, but subclasses may be defined. It declares that any subclasses
    must implement a method named `Decide(...)`, which&nbsp;returns a Boolean (true/false)
    value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decision` 类是抽象的，这意味着从这个类中永远不会创建任何对象，但可以定义子类。它声明任何子类都必须实现一个名为 `Decide(...)`
    的方法，该方法返回一个布尔值（true/false）。'
- en: The `State` class has an array of `Transition` objects, and its `UpdateState()`
    method simple invokes its `CheckTransitions(...)` method.&nbsp;`CheckTransitions(...)`
    loops through each transition, testing its `Decision`. If the decision is true,
    it tells&nbsp;`StateController` to make the current state the true state of the
    transition.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`State` 类有一个 `Transition` 对象数组，并且它的 `UpdateState()` 方法简单地调用其 `CheckTransitions(...)`
    方法。`CheckTransitions(...)` 遍历每个转换，测试其 `Decision`。如果决策为真，它告诉 `StateController`
    将当前状态设置为转换的真正状态。'
- en: 'In this project, we have declared two subclasses of the `Decision` class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们声明了 `Decision` 类的两个子类：
- en: '`GameWonDecision`: This class'' `Decide(...)` method returns the value of its&nbsp;`GameWonActionDetected(...)`
    method.&nbsp;`GameWonActionDetected(...)` returns the value of the game manager''s
    `HasCollectedAllStars()` method, that is, the game-won decision is true when the
    game manager says that all stars have been collected.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameWonDecision`: 这个类的 `Decide(...)` 方法返回其 `GameWonActionDetected(...)` 方法的值。`GameWonActionDetected(...)`
    返回游戏管理器的 `HasCollectedAllStars()` 方法的值，即当游戏管理器表示所有星星都已收集时，游戏胜利的决策为真。'
- en: '`GameWonDecision`: This class''s&nbsp;`Decide(...)` method returns the value
    of its&nbsp;`GameLostActionDetected(...)` method.&nbsp;`GameLostActionDetected(...)`
    returns true if the game manager''s timer is zero or less (time has run out).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameWonDecision`: 这个类的 `Decide(...)` 方法返回其 `GameLostActionDetected(...)` 方法的值。`GameLostActionDetected(...)`
    返回真，如果游戏管理器的计时器为零或更少（时间已用完）。'
- en: 'We have created five scriptable object assets:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了五个可脚本化对象资源：
- en: '**Three states**: `StateGamePlaying`, `StateGameWon`, `StateGameLost`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三个状态**：`StateGamePlaying`、`StateGameWon`、`StateGameLost`'
- en: '**Two decisions**: `GameWonDecision` and `GameLostDecision`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个决策**：`GameWonDecision` 和 `GameLostDecision`'
- en: 'We were able to create these Scriptable Object assets via the Create menu through
    the statements immediately before the script-class declarations for `Decision`
    and `State` that declared that there should be a new sub-menu in the Create Asset
    menu named MyGame:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够通过创建菜单，通过在`Decision`和`State`脚本类声明之前的语句中声明应该有一个名为MyGame的新子菜单来创建这些可脚本化对象资产：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only one of these Scriptable Objects that needed any customizing was `StateGamePlaying`.
    Two transitions were defined in this object:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些可脚本化对象中，唯一需要定制的是`StateGamePlaying`。在这个对象中定义了两个转换：
- en: If `GameWonDecision` becomes true, the State Controller should set the current
    state to `StateGameWon`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`GameWonDecision`变为true，状态控制器应将当前状态设置为`StateGameWon`
- en: If `GameLostDecision` becomes true, the State Controller should set the current
    state to `StateGameLost`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`GameLostDecision`变为true，状态控制器应将当前状态设置为`StateGameLost`
- en: While it may seem like there was a lot of work for this simple game, what this
    recipe illustrates is how some generic state-machine classes can be created (`State`,
    `Decision`, `Transition`, `StateController`), and that the actual game behavior
    is modelled through a set of Scriptable Object assets, and two classes to implement
    the decision-making for special game events (`GameWonDecision` and `GameLostDecision`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个简单的游戏可能需要做很多工作，但这个配方展示的是如何创建一些通用的状态机类（`State`、`Decision`、`Transition`、`StateController`），并且实际的游戏行为是通过一系列可脚本化对象资产以及两个类来实现的，这两个类用于实现特殊游戏事件的决策（`GameWonDecision`和`GameLostDecision`）。
- en: Since Scriptable Object are asset files, there are only one of them. At times,
    we may want the same Scriptable Object to be used by different GameObjects when
    the game is running—for example, the state transitions for the AI of lots of different
    enemy characters may share the use of the same Scriptable Object. For this reason,
    a reference to a `StateController` object instance is passed when methods are
    invoked on `State` and `Decision` Scriptable Objects,&nbsp;so the logic in the
    methods of the Scriptable Object can work on whatever run-time controller object
    is provided with. This is an example of another design pattern known as the **Delegate**
    design pattern (not to be confused with a C# delegate!).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可脚本化对象是资产文件，因此只有一个。有时，当游戏运行时，我们可能希望不同的GameObject使用相同的可脚本化对象——例如，许多不同敌人角色的AI状态转换可能共享使用同一个可脚本化对象。因此，当在`State`和`Decision`可脚本化对象上调用方法时，会传递一个`StateController`对象实例的引用，这样可脚本化对象的方法中的逻辑就可以在提供的任何运行时控制器对象上工作。这是一个被称为**委托**设计模式（不要与C#的委托混淆）的另一个设计模式的例子。
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节你不希望错过。
- en: Extending the game to model Player health
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将游戏扩展到模拟玩家健康
- en: 'To further understand the power of this data-centric approach to state-based
    games, let''s add the following behavior to the game:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解这种基于状态的游戏数据驱动方法的力量，让我们向游戏中添加以下行为：
- en: The player has a health value, starting at 100% (a float value of 1.0)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家有一个健康值，起始值为100%（浮点值为1.0）
- en: In each frame, a random amount of health is added or subtracted
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每一帧，都会随机增加或减少一定量的健康值
- en: The game is lost if the health of the player goes down to zero
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家的健康值下降到零，则游戏失败
- en: 'To implement this feature, all we need to do is:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，我们只需要做以下事情：
- en: 'Add a test to the&nbsp;`GameLostDecision`&nbsp;script class to return true
    if time or health are zero:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameLostDecision`脚本类中添加一个测试，如果时间或健康值为零则返回true：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the `health` feature to the&nbsp;`GameManager` script class:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`health`功能添加到`GameManager`脚本类中：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We could also add another **UI Text** on screen to see the current value of
    health. If the public `healthPlusMaximum` variable is set smaller than the minus
    maximum (for example,&nbsp;`0.02`), the health will go downwards since the random
    average will be less than zero.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在屏幕上添加另一个**UI Text**来查看当前的健康值。如果公共`healthPlusMaximum`变量设置小于减去最大值（例如，`0.02`），则健康值将下降，因为随机平均值将小于零。
- en: 'To add another state, such as&nbsp;`StatePauseGame`, all that is needed are
    the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加另一个状态，例如`StatePauseGame`，所需的步骤如下：
- en: Create new&nbsp;`GamePausedDecision` script class, with the logic to detect
    whether the game is paused (for example, the game manager could have an&nbsp;`isPaused`&nbsp;boolean
    variable that gets set to true when the user presses the *P* key)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`GamePausedDecision`脚本类，包含检测游戏是否暂停的逻辑（例如，游戏管理器可以有一个`isPaused`布尔变量，当用户按下*P*键时设置为true）
- en: Create a new&nbsp;`StateGamePaused` Scriptable Object State
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`StateGamePaused`脚本对象状态
- en: Create a new&nbsp;`GamePausedDecision` Scriptable Object State
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`GamePausedDecision`脚本对象状态
- en: Add a third transition to the&nbsp;`StateGamePlaying`&nbsp;Scriptable Object
    State (element 2), with `GamePausedDecision` and the true state of `StateGamePaused`
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StateGamePlaying`脚本对象状态（元素2）中添加第三个过渡，使用`GamePausedDecision`和`StateGamePaused`的真实状态
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To see this approach to state-driven games using Scriptable Objects taken much
    further, including adding the feature for actions to be performed during each
    state, follow the online video Unity tutorial about Scriptable Objects for enemy
    state-driven AI:&nbsp;[https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern](https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要进一步了解使用脚本对象驱动状态的这种方法，包括在每个状态下执行动作的功能，请观看关于脚本对象用于敌人状态驱动AI的在线Unity教程：[https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern](https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern)。
- en: Publisher-Subscriber pattern C# delegates and events
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者-订阅者模式C#委托和事件
- en: When events can be based on visibility, distance, or collisions, we can use
    such events as `OnTriggerExit` and `OnBecomeInvisible`. When events can be based
    on time periods, we can use coroutines. However, some events are unique to each
    game situation, and C# offers several methods of broadcasting user-defined event
    messages to scripted objects. One approach is the `SendMessage(...)` method, which,
    when sent to a GameObject, will check every Monobehaviour scripted component and
    execute the named method if its parameters match. However, this involves an inefficient
    technique known as reflection. C# offers another event message approach known
    as delegates and events, which we describe and implement in this recipe.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件可以根据可见性、距离或碰撞来触发时，我们可以使用像`OnTriggerExit`和`OnBecomeInvisible`这样的事件。当事件可以根据时间段来触发时，我们可以使用协程。然而，某些事件是每个游戏情况独有的，C#提供了几种方法来向脚本对象广播用户定义的事件消息。一种方法是`SendMessage(...)`方法，当发送到GameObject时，将检查每个Monobehaviour脚本组件，如果其参数匹配，则执行命名方法。然而，这涉及到一种称为反射的低效技术。C#提供了另一种事件消息方法，称为委托和事件，我们在本食谱中描述并实现它。
- en: Delegates and events work in a similar way to `SendMessage(...)`, but are much
    more efficient since Unity maintains a defined list of which objects are listening
    to the broadcast events. `SendMessage(...)` should be avoided if performance is
    important, since it means that Unity has to analyze each scripted object (reflect
    over the object) to see whether there is a public method corresponding to the
    message that has been sent; this is much slower than using delegates and events.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 委托和事件的工作方式与`SendMessage(...)`类似，但更高效，因为Unity维护一个定义了哪些对象正在监听广播事件的列表。如果性能很重要，应避免使用`SendMessage(...)`，因为这意味着Unity必须分析每个脚本对象（对对象进行反射）以查看是否有与发送的消息相对应的公共方法；这比使用委托和事件慢得多。
- en: Delegates separate the code declaring the delegate from any of the codes (classes)
    that use the delegate. The script-class that declares the public delegate does
    not need to know anything about the object or objects that make use of its delegated
    functionality.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 委托将声明委托的代码与使用委托的任何代码（类）分开。声明公共委托的脚本类不需要了解任何使用其委托功能的对象或对象。
- en: Delegates and events implement the **Publisher-Subscriber design pattern** (**pubsub**).
    This is also known as the **Observer** design pattern. Objects can subscribe one
    of their methods to receive a particular type of event message from a particular
    publisher. In this recipe, we'll have a manager class that will publish new events
    when **UI Buttons** are clicked. We'll create some **UI objects**, some of which
    subscribe to the color-change events. Each time a color-change event is published,
    subscribed **UI objects** receive the event message and change their color accordingly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 委托和事件实现了 **发布者-订阅者设计模式**（**pubsub**）。这也被称为 **观察者** 设计模式。对象可以将它们的方法之一订阅，以从特定的发布者接收特定类型的事件消息。在这个菜谱中，我们将有一个管理类，当
    **UI 按钮** 被点击时，它会发布新的事件。我们将创建一些 **UI 对象**，其中一些对象订阅了颜色更改事件。每次发布颜色更改事件时，订阅的 **UI
    对象**都会接收到事件消息并相应地更改它们的颜色。
- en: We will also add a console event logger, to listen for and log messages about
    color-change events.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个控制台事件记录器，以监听并记录有关颜色更改事件的日志。
- en: 'C# publisher objects don''t have to worry about how many objects subscribe
    to them at any point in time (it could be none or 1,000!). This is known as **loose
    coupling**, since it allows different code components to be written (and maintained)
    independently and is a desirable feature of object-oriented code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C# 发布者对象不必担心在任何时刻有多少对象订阅它们（可能是没有或1,000个！）这被称为**松耦合**，因为它允许不同的代码组件独立编写（和维护），并且是面向对象代码的一个理想特性：
- en: '![](img/2154430f-5063-4aa5-a1ab-610c558782c8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2154430f-5063-4aa5-a1ab-610c558782c8.png)'
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, a Unity Package has been provided (`colorChangeScene.unitypackage`)
    in the `17_04` folder. This package contains a scene with **UI Buttons** and other
    objects for the recipe.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，在 `17_04` 文件夹中提供了一个 Unity 包（`colorChangeScene.unitypackage`）。这个包包含一个场景，其中包含
    **UI 按钮** 和其他用于菜谱的对象。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To implement the Publisher-Subscriber pattern using C# delegates and events,
    follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 C# 委托和事件实现发布者-订阅者模式，请按照以下步骤操作：
- en: Create a new Unity project, and delete the default&nbsp;`Scenes` folder.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 项目，并删除默认的 `Scenes` 文件夹。
- en: Import the provided Unity package (`colorChangeScene.unitypackage`).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的 Unity 包（`colorChangeScene.unitypackage`）。
- en: 'Add the following `ColorManager` C# script class to the Main Camera:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `ColorManager` C# 脚本类添加到主摄像机：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the&nbsp;`ColorChangeListenerImage`&nbsp;C# script class, and add an
    instance object as a component to the&nbsp;`Image-listening` and `Slider-listening`
    GameObjects (both children of&nbsp;Canvas | listening-game-objects):'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `ColorChangeListenerImage` C# 脚本类，并将实例对象作为组件添加到 `Image-listening` 和 `Slider-listening`
    GameObject（都是 Canvas | listening-game-objects 的子对象）：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the&nbsp;`ColorChangeListenerText`&nbsp;C# script class, and add an
    instance object as a component to the&nbsp;`Text-listening` GameObject&nbsp;(a
    child of&nbsp;Canvas | listening-game-objects):'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `ColorChangeListenerText` C# 脚本类，并将实例对象作为组件添加到 `Text-listening` GameObject（Canvas
    | listening-game-objects 的子对象）：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the `ColorChangeListenerConsole` C# script class:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `ColorChangeListenerConsole` C# 脚本类：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the `ColorModel` C# script class:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `ColorModel` C# 脚本类：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With button-GREEN selected in the Hierarchy, add a new OnClick() event for this
    button, dragging the Main Camera as the target GameObject and selecting the&nbsp;BUTTON_ACTION_make_green()
    public function. Do the same for the button-BLUE and button-RED buttons with the&nbsp;BUTTON_ACTION_make_blue()
    and BUTTON_ACTION_make_red() functions, respectively.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 中选择按钮-GREEN，为该按钮添加一个新的 OnClick() 事件，将主摄像机作为目标 GameObject，并选择 BUTTON_ACTION_make_green()
    公共函数。对按钮-BLUE 和按钮-RED 按钮分别执行相同的操作，使用 BUTTON_ACTION_make_blue() 和 BUTTON_ACTION_make_red()
    函数。
- en: Run the game. When you click a change-color button, the three **UI objects**
    on the right of the screen show all changes to the corresponding color, while
    the two **UI objects** at the bottom-left of the screen remain in the default
    white color. You should also see `Debug.Log` messages in the Console panel, showing
    the RBG color corresponding to the button that was clicked.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。当你点击更改颜色按钮时，屏幕右侧的三个 **UI 对象**会显示所有对应的颜色更改，而屏幕左下角的两个 **UI 对象**将保持默认的白色。你还应该在控制台面板中看到
    `Debug.Log` 消息，显示被点击按钮对应的 RBG 颜色。
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have added an instance object of `ColorManager` to the Main Camera. This
    class does three main things:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `ColorManager` 的实例对象添加到主摄像机。这个类主要做三件事：
- en: Creates an instance object of the&nbsp;`ColorChangeListenerConsole` script class
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`ColorChangeListenerConsole`脚本类的实例对象
- en: Creates an instance object of the&nbsp;`ColorModel` script class
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`ColorModel`脚本类的实例对象
- en: Offers three public methods that can be invoked by clicking the red/green/blue
    UI Buttons
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了三个可以通过点击红色/绿色/蓝色UI按钮调用的公共方法
- en: Each time a button is clicked, the `colorModel` object is told to `SetColor(...)`
    to the corresponding color.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击按钮时，都会告诉`colorModel`对象将颜色设置为相应的颜色。
- en: The `ColorModel`&nbsp;script class has a private variable of the current color.
    This value can be changed by invoking its `SetColor(...)` method (from the `ColorManager`
    when a button is clicked). As well as changing the value of color, the&nbsp;`SetColor(...)`&nbsp;method
    also invokes the&nbsp;`PublishColorEvent()` method. The&nbsp;`PublishColorEvent()`&nbsp;method
    publishes the&nbsp;`OnChangeColor(this.color)` event,&nbsp;so that all registered
    listeners to this event will be invoked with the new color value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorModel`脚本类有一个表示当前颜色的私有变量。这个值可以通过调用其`SetColor(...)`方法（在点击按钮时从`ColorManager`调用）来改变。除了改变颜色值之外，`SetColor(...)`方法还会调用`PublishColorEvent()`方法。`PublishColorEvent()`方法发布`OnChangeColor(this.color)`事件，这样所有注册监听此事件的监听器都会被调用，并使用新的颜色值。'
- en: 'On the right-hand side of the screen, we have three GameObjects: Image-listening,
    Slider-listening, and Text-listening. Each of these objects has a scripted component
    of either `ColorChangeListenerImage` or `ColorChangeListenerText`. These components
    register their respective `OnChangeColor(...)` methods to listen for `OnChangeColor(this.color)`
    events. The `ColorChangeListenerImage` and `ColorChangeListenerText` script classes
    both register their `ChangeColor(...)` methods to the `OnChangeColor(...)` event
    of the `ColorModel` script class.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的右侧，我们有三个GameObject：Image-listening、Slider-listening和Text-listening。这些对象各自都有一个`ColorChangeListenerImage`或`ColorChangeListenerText`的脚本组件。这些组件将它们各自的`OnChangeColor(...)`方法注册为监听`OnChangeColor(this.color)`事件。`ColorChangeListenerImage`和`ColorChangeListenerText`脚本类都将它们的`ChangeColor(...)`方法注册到`ColorModel`脚本类的`OnChangeColor(...)`事件。
- en: The&nbsp;`ColorChangeListenerConsole`&nbsp;script class also registers its `ChangeColor(...)`
    methods to the `OnChangeColor(...)` event of the&nbsp;`ColorModel` script class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorChangeListenerConsole`脚本类也将它的`ChangeColor(...)`方法注册到`ColorModel`脚本类的`OnChangeColor(...)`事件。'
- en: Since our scripted objects may be disabled and enabled at different times, each
    time a scripted `ColorChangeListener` object is enabled (such as when its GameObject
    parent is instantiated), its `OnChangeColor()` method is added (`+=`) to the list
    of those subscribed to listen for color-change events, likewise, each time `ColorChangeListenerImage`
    or `Text` objects are disabled, those methods are removed (`-=`) from the list
    of event subscribers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的脚本对象可能在不同的时间被启用和禁用，每次脚本`ColorChangeListener`对象被启用（例如，当其GameObject父对象被实例化时），其`OnChangeColor()`方法将被添加到订阅颜色更改事件的列表中（`+=`），同样，每次`ColorChangeListenerImage`或`Text`对象被禁用，那些方法将从事件订阅者列表中移除（`-=`）。
- en: It is very important that methods are removed from the list of subscribers to
    an event when they are no longer required. Failure to do this can lead to significant
    problems, such as memory leaks.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要时，从事件的订阅者列表中删除方法非常重要。未能这样做可能会导致重大问题，例如内存泄漏。
- en: When `ColorChangeListenerImage` or a `Text` object receives a color-change message,
    its subscribed `OnChangeColor()` method is executed and the color of the appropriate
    component is changed to the received color value (green/red/blue).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ColorChangeListenerImage`或`Text`对象接收到颜色更改消息时，其订阅的`OnChangeColor()`方法将被执行，并且适当的组件颜色将更改为接收到的颜色值（绿色/红色/蓝色）。
- en: The `ColorManager` class declares a **Delegate** named `ColorChangeHandler`.
    Delegates define the return type (in this case, `void`) and argument signature
    of methods that can be delegated (subscribed) to an event. In this case, methods
    must have the argument signature of a single parameter of the&nbsp;`Color` type.
    Our `OnChangeColor()` method in the&nbsp;`ColorChangeListenerImage`, `Text`, and
    `Console`&nbsp;classes matches this argument signature and so is permitted to
    subscribe to&nbsp;`changeColorEvent` in the `ColorManager` class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorManager` 类声明了一个名为 `ColorChangeHandler` 的 **委托**。委托定义了可以委托（订阅）到事件的方法的返回类型（在这种情况下，`void`）和参数签名。在这种情况下，方法必须具有单个
    `Color` 类型参数的参数签名。我们的 `OnChangeColor()` 方法在 `ColorChangeListenerImage`、`Text`
    和 `Console` 类中与这个参数签名相匹配，因此可以订阅 `ColorManager` 类中的 `changeColorEvent`。'
- en: You may notice that&nbsp;`ColorChangeListenerConsole` does not have `OnEnable`
    or `OnDisable` methods. This is because it is not a MonoBehaviour, and so does
    not receive Unity runtime events such as `Awake()`, `Update()`, or `OnEnable()`.
    However, being a simple class, it can have a constructor method invoked when a
    new object instance is created with the new keyword, and a destructor method invoked
    when the object is no longer referenced. So it is in those methods that these
    objects register and deregister to listen to `ColorModel.OnChangeColor` events.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 `ColorChangeListenerConsole` 没有 `OnEnable` 或 `OnDisable` 方法。这是因为它不是一个
    MonoBehaviour，所以不会接收到 Unity 运行时事件，如 `Awake()`、`Update()` 或 `OnEnable()`。然而，作为一个简单的类，它可以在使用
    new 关键字创建新的对象实例时调用构造方法，并在对象不再被引用时调用析构方法。因此，在这些方法中，这些对象注册和注销以监听 `ColorModel.OnChangeColor`
    事件。
- en: Model-View-Controller (MVC) pattern
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器 (MVC) 模式
- en: The **Model-View-Controller** (**MVC**) pattern is a software architecture that
    tries to separate the data (Model) from the displays (Views) and actions that
    change that data (Controller).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器** (**MVC**) 模式是一种软件架构，试图将数据（模型）与显示（视图）以及改变数据的操作（控制器）分离。'
- en: 'In this recipe, we use the MVC pattern to implement a feature of many games—a
    visual health bar representing the Player''s numeric health value (in this case,
    a float number from 0.0 - 1.0). As the user presses the Up/Down arrow keys (simulating
    healing and damage), the value of the player''s heath changes. With the health-change
    events, the visual display and a **Console** log are updated to present the new
    health values to the user:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 MVC 模式来实现许多游戏的一个功能——一个表示玩家数值生命值的视觉生命条（在这种情况下，一个从 0.0 - 1.0 的浮点数）。当用户按下上/下箭头键（模拟治疗和伤害）时，玩家的生命值会发生变化。随着生命值变化事件的发生，视觉显示和
    **控制台** 日志都会更新，以向用户展示新的生命值：
- en: '![](img/2f1a83c1-3d1a-4ecd-8b51-b8ba25b99953.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f1a83c1-3d1a-4ecd-8b51-b8ba25b99953.png)'
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, two images been provided in the `17_05` folder:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，`17_05` 文件夹中提供了两个图像：
- en: '`health_bar_outline.png`: A red heart image and outline for the health filler'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`health_bar_outline.png`：一个红色心形图像和填充轮廓'
- en: '`health_bar_fill_blue_to_green.png`: A graduated (blue left to green right)
    filler image, indicating how much health is left'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`health_bar_fill_blue_to_green.png`：一个渐变（从左边的蓝色到右边的绿色）填充图像，表示剩余的健康量'
- en: 'Thanks to Pixel Art Maker for the health bar image:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 Pixel Art Maker 提供的生命条图像：
- en: '[http://pixelartmaker.com/art/49e2498a414f221](http://pixelartmaker.com/art/49e2498a414f221)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://pixelartmaker.com/art/49e2498a414f221](http://pixelartmaker.com/art/49e2498a414f221)'
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To implement the MVC pattern in Unity, follow these steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中实现 MVC 模式，请按照以下步骤操作：
- en: Import the two provided images.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的两个图像。
- en: Create a **UI Image** named `Image-health-bar-outline`, and populate it with
    the `health_bar_outline` image asset.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Image-health-bar-outline` 的 **UI Image**，并用 `health_bar_outline` 图像资源填充它。
- en: Create a **UI Image** named `Image-health-bar-filler`, and populate it with
    the `health_bar_fill_blue_to_green` image asset. In the Inspector for the Image
    (Script) component, set the Image Type to Filled, and the Fill Type to Horizontal.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Image-health-bar-filler` 的 **UI Image**，并用 `health_bar_fill_blue_to_green`
    图像资源填充它。在 Image (Script) 组件的检查器中，将图像类型设置为 Filled，并将填充类型设置为水平。
- en: Arrange your **Canvas** so that Image-health-bar-filler is before Image-health-bar
    in the Hierarchy (the filler appears behind the outline).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的 **画布** 安排得使 Image-health-bar-filler 在层次结构中位于 Image-health-bar 之前（填充物位于轮廓之后）。
- en: 'Create a new C# script class,&nbsp;`Player`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类，`Player`：
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a new C# script class,&nbsp;`PlayerController`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类，`PlayerController`：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a new C# script class,&nbsp;`HealthBarDisplay`, and add an instance
    object as a component to `Image-health-bar-filler`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类，`HealthBarDisplay`，并将实例对象作为组件添加到`Image-health-bar-filler`：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new C# script class,&nbsp;`HealthChangeLogger`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类，`HealthChangeLogger`：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following `PlayerManager` C# script class&nbsp;to the Main Camera:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`PlayerManager` C#脚本类添加到主相机：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the game. Pressing the Up/Down arrow keys should raise/lower the player's
    health, which should be confimed by the meter fill image, and in the `Debug.Log()`
    messages in the **Console**.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。按下上箭头键和下箭头键应该提高/降低玩家的健康值，这应该通过填充图像和**控制台**中的`Debug.Log()`消息得到确认。
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You were provided with two&nbsp;**UI Images**:&nbsp;one is a health bar outline
    (red heart and a black outline), the second is the filler image—to show dark blue
    to light blue to green, for weak to strong health values.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您提供了两个&nbsp;**UI Images**：一个是健康条轮廓（红色心形和黑色轮廓），另一个是填充图像——用于显示从深蓝到浅蓝再到绿色，表示从弱到强的健康值。
- en: You set the Image Type of Image-health-bar-filler to be Filled, and that it
    is to be filled Horizontally (left to right). Therefore, the fillAmount property
    of a UI Image determines how much of this filler image is displayed to the user
    (from `0.0` to `1.0`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您将Image-health-bar-filler的图像类型设置为填充，并设置为水平填充（从左到右）。因此，UI Image的fillAmount属性决定了向用户显示的填充图像的量（从`0.0`到`1.0`）。
- en: The `PlayerManager`&nbsp;script class is a manager script that initializes the&nbsp;`PlayerController`
    and `HealthChangeLogger` objects, and also allows the user to change the health
    of the Player by pressing the Up and Down arrow keys (simulating healing/damage
    during a game). Via the `Update()` method, each Up/Down arrow key press invokes
    the `PlayerController` methods:&nbsp;`AddToHealth()` and `ReducedHealth()`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerManager`&nbsp;脚本类是一个管理脚本，它初始化`PlayerController`和`HealthChangeLogger`对象，并允许用户通过按上箭头键和下箭头键来改变玩家的健康值（在游戏中模拟治疗/伤害）。通过`Update()`方法，每次按下上箭头键或下箭头键都会调用`PlayerController`的方法：`AddToHealth()`和`ReducedHealth()`。'
- en: The `PlayerController`&nbsp;script class creates a `PlayerModel` object in its
    constructor. It has two other methods, `AddToHealth()` and `ReducedHealth()`,
    that add to/reduce the health of the `PlayerModel` object by `+0.5` and `-0.1`,
    respectively.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerController`&nbsp;脚本类在其构造函数中创建一个`PlayerModel`对象。它还有两个其他方法，`AddToHealth()`和`ReducedHealth()`，分别通过`+0.5`和`-0.1`来增加/减少`PlayerModel`对象的健康值。'
- en: The `PlayerModel`&nbsp;script class manages values for `Player` health, and
    uses delegates and events to publish health changes to any listening **View**
    classes. When a new object is created, the health property is initialized, and
    a health-change event is published to all listening objects. Likewise, when the
    `AddHealth(...)` and `ReduceHealth(...)` methods are invoked with a value, the
    value of the health is changed, and the health-change event is published to all
    listening objects. The&nbsp;`OnHealthChange`&nbsp;event is visible to other objects
    as a static public event. The&nbsp;`PublishHealthChangeEvent()`&nbsp;method publishes
    the new value of health by invoking all listening `OnHealthChange(...)` methods.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerModel`&nbsp;脚本类管理玩家的健康值，并使用代理和事件将健康变化发布给任何监听**视图**类。当创建一个新的对象时，健康属性被初始化，并将健康变化事件发布给所有监听对象。同样，当调用`AddHealth(...)`和`ReduceHealth(...)`方法并传入一个值时，健康值会改变，并将健康变化事件发布给所有监听对象。`OnHealthChange`&nbsp;事件作为一个静态公共事件对其他对象可见。`PublishHealthChangeEvent()`&nbsp;方法通过调用所有监听的`OnHealthChange(...)`方法来发布健康的新值。'
- en: 'There are two View classes that register to listen for `Player.OnHealthChange(...)`
    events:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个视图类注册监听`Player.OnHealthChange(...)`事件：
- en: '`HealthBarDisplay`: Updates&nbsp;`fillAmount` for a UI Image for each new health
    value received'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HealthBarDisplay`：为每个接收到的新的健康值更新UI Image的`fillAmount`'
- en: '`HealthChangeLogger`: Prints messages about the new `Player health` value received
    to the Debug.Log file'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HealthChangeLogger`：将接收到的新的`Player health`值的消息打印到Debug.Log文件'
- en: As can be seen, each of the Model/View/Controller classes is quite small and
    simple, and each has their own, well-defined responsibilities. It would be easy
    to add another kind of health-change event listener, perhaps to play a sound,
    without having to change any code in any of these existing classes. Likewise,
    it would be straightforward to add a new property to our `PlayerModel` (perhaps
    a score or inventory value of stars collected, and then add another public static
    event for score/inventory changes to be published to subscribed listening views).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，每个Model/View/Controller类都相当小且简单，并且每个都有自己的、定义良好的职责。很容易添加另一种健康变化事件监听器，比如播放一个声音，而不需要更改这些现有类中的任何代码。同样，添加一个新的属性到我们的`PlayerModel`（可能是一个得分或收集到的星星的库存值）也很简单，然后添加另一个公共静态事件，以便将得分/库存更改发布给订阅的监听视图。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Only&nbsp;`PlayerManager` is a MonoBehaviour. One of the advantages of this
    MVC&nbsp;architecture is that each of these components becomes much easier to
    unit-test in isolation. A version of this recipe is used as an example in the&nbsp;*State
    Design Pattern* *PlayMode and Unit Testing a health bar with events, logging,
    and exceptions*&nbsp;recipe in Chapter 19, *Automated Testing*&nbsp;.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有`PlayerManager`是一个MonoBehaviour。这种MVC架构的一个优点是，这些组件中的每一个都变得更容易在隔离状态下进行单元测试。这个食谱的版本在第19章“自动化测试”中的*状态设计模式*
    *PlayMode和单元测试带有事件、日志和异常的健康条*食谱中被用作示例。
