<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Gameplay and Screen Effects</h1>
                
            
            
                
<p class="calibre3">When it comes to creating believable and immersive games, the material design is not the only aspect that we need to take into account. The overall feeling can be altered using screen effects. This is very common in movies, for instance, when colors are corrected in the post-production phase. You can implement these techniques in your games too, using the knowledge from <a href="part0227.html#6OFFM0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 9</a>, <em class="calibre14">Screen Effects with Unity Render Texture</em>. Two interesting effects are presented in this chapter; you can, however, adapt them to fit your needs and create your very own screen effect.</p>
<p class="calibre3">In this chapter, you will learn the following:</p>
<ul class="calibre11">
<li class="calibre12">Creating an old movie screen effect</li>
<li class="calibre12">Creating a night vision screen effect</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            
                
<p class="calibre3">If you are reading this book, you are most likely a person who has played a game or two in your time. One of the aspects of real-time games is the effect of immersing a player into a world to make it feel as if they were actually playing in the real world. More modern games make heavy use of screen effects to achieve this immersion.</p>
<p class="calibre3">With screen effects, we can turn the mood of a certain environment from calm to scary, just by changing the look of the screen. Imagine walking into a room that is contained within a level, then the game takes over and goes into a cinematic moment. Many modern games will turn on different screen effects to change the mood of the current moment. Understanding how to create effects triggered by gameplay is next in our journey about shader writing.</p>
<p class="calibre3">In this chapter, we are going to take a look at some of the more common gameplay screen effects. You are going to learn how to change the look of the game from normal to an old movie effect, and we are going to take a look at how many first-person shooter games apply their night vision effects to the screen. With each of these recipes, we are going to look at how to hook these up to game events so that they are turned on and off as the game's current presentation require.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating an old movie screen effect</h1>
                
            
            
                
<p class="calibre3">Many games are set in different times. Some take place in fantasy worlds or future sci-fi worlds, and some even take place in the Old West, where film cameras were just being developed and the movies that people watched were black and white or sometimes tinted with what is called a <strong class="calibre5">sepia effect</strong>. The look is very distinct, and we are going to replicate this look using a screen effect in Unity.</p>
<p class="calibre3">There are a few steps to achieving this look; just to make the whole screen black and white or grayscale, we need to break down this effect into its component parts. If we analyze some reference footage of an old movie, we can begin to do this. Let's take a look at the following image and break down the elements that make up the old movie look:</p>
<div><img src="img/00202.jpeg" class="calibre25"/></div>
<p class="calibre3">We constructed this image using a few reference images found online. It is always a good idea to try and utilize Photoshop to construct images like this to aid you in creating a plan for your new screen effect. Performing this process not only tells us the elements we will have to code in, but it also gives us a quick way to see which blending modes work and how we will construct the layers of our screen effect. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">Now that we know what we have to make, let's take a look at how each of the layers is combined to create the final effect and gather some resources for our shader and screen effect script:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Sepia tone</strong>: This is a relatively simple effect to achieve, as we just need to bring all the pixel colors of the original render texture to a single color range. This is easily achieved using the luminance of the original image and adding a constant color. Our first layer will look like the following screenshot:</li>
</ul>
<div><img src="img/00203.jpeg" class="calibre25"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Vignette effect</strong>: We can always see some sort of soft border around old films when they are being projected using an old movie projector. This is caused because the bulb that is used for the movie projector has more brightness in the middle than it does at the edges of the film. This effect is generally called the vignette effect and is the second layer in our screen effect. We can achieve this with an overlaid texture over the whole screen. The following screenshot demonstrates what this layer looks like, isolated as a texture:</li>
</ul>
<div><div><img src="img/00204.jpeg" class="calibre25"/></div>
</div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Dust and scratches</strong>: The third and final layer in our old movie screen effect is dust and scratches. This layer will utilize two different tiled textures, one for scratches and one for dust. The reason is that we will want to animate these two textures over time at different tiling rates. This will give the effect that the film is moving along and there are small scratches and dust on each frame of the old film. The following screenshot demonstrates this effect isolated to its own texture:</li>
</ul>
<div><img src="img/00205.jpeg" class="calibre142"/></div>
<p class="calibre3">Let's get our screen effect system ready with the preceding textures. Perform the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Gather up a vignette texture and a dust and scratches texture, like the ones we just saw.</li>
</ol>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">We will also need a scene for which we want to emulate the effect we're trying to build. I have created a sample scene that you can use in the <kbd class="calibre13">Chapter 10</kbd> folder of the example code, called <kbd class="calibre13">10.1 Starter Scene</kbd>:</li>
</ol>
<div><img src="img/00206.jpeg" class="calibre25"/></div>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Create a new shader by duplicating the <kbd class="calibre13">ScreenGrayscale</kbd> code; select it from the Project tab under the <kbd class="calibre13">Chapter 9 </kbd>| <kbd class="calibre13">Shaders</kbd> folder and press <em class="calibre2">Ctrl</em> + <em class="calibre2">D</em>. Once duplicated, rename the script to <kbd class="calibre13">ScreenOldFilm</kbd>. Then, drag and drop the script into the <kbd class="calibre13">Chapter 10 </kbd>| <kbd class="calibre13">Shaders</kbd> folder, creating it if needed.</li>
<li value="4" class="calibre12">Next, go to the <kbd class="calibre13">Chapter 9 </kbd>| <kbd class="calibre13">Scripts</kbd> folder and duplicate the <kbd class="calibre13">TestRenderImage</kbd> script. Rename the new file to <kbd class="calibre13">RenderOldFilm</kbd> and then drag and drop it into the <kbd class="calibre13">Chapter 10 </kbd>| <kbd class="calibre13">Scripts</kbd> folder, creating it if needed.</li>
</ol>
<p class="calibre3">Finally, with our screen effect system up and running and our textures gathered, we can begin the process of recreating this old film effect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">Our individual layers for our old film screen effect are quite simple, but when combined, we get some very visually stunning effects. Let's run through how to construct the code for our script and shader, then we can step through each line of code and learn why things are working the way they are. At this point, you should have the screen effects system up and running, as we will not be covering how to set this up in this recipe.</p>
<ol class="calibre15">
<li value="1" class="calibre12">We will begin by entering the code in our script. Our first step in modifying our script is to rename the class to match our filename, <kbd class="calibre13">RenderOldFilm</kbd>:</li>
</ol>
<pre class="calibre62">[ExecuteInEditMode]<br class="title-page-name"/>public class <strong class="calibre1">RenderOldFilm</strong> : MonoBehaviour {</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">The first block of code that we will enter will define the variable that we want to expose to Inspector, in order to let the user of this effect adjust it as they see fit. We can also use our mocked-up Photoshop file as a reference when deciding what we will need to expose to the Inspector of this effect. Enter the following code in your effect script:</li>
</ol>
<pre class="calibre62">#region Variables <br class="title-page-name"/>public Shader curShader; // old film shader<br class="title-page-name"/><br class="title-page-name"/>public float OldFilmEffectAmount = 1.0f;<br class="title-page-name"/><br class="title-page-name"/>public Color sepiaColor = Color.white;<br class="title-page-name"/>public Texture2D vignetteTexture;<br class="title-page-name"/>public float vignetteAmount = 1.0f;<br class="title-page-name"/><br class="title-page-name"/>public Texture2D scratchesTexture;<br class="title-page-name"/>public float scratchesYSpeed = 10.0f;<br class="title-page-name"/>public float scratchesXSpeed = 10.0f;<br class="title-page-name"/><br class="title-page-name"/>public Texture2D dustTexture;<br class="title-page-name"/>public float dustYSpeed = 10.0f;<br class="title-page-name"/>public float dustXSpeed = 10.0f;<br class="title-page-name"/><br class="title-page-name"/>private Material screenMat;<br class="title-page-name"/>private float randomValue;<br class="title-page-name"/>#endregion</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Next, we need to fill in the contents of our <kbd class="calibre13">OnRenderImage()</kbd> function. Here, we will be passing the data from our variables to our shader so that the shader can then use this data in the processing of the render texture:</li>
</ol>
<pre class="calibre62">void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)<br class="title-page-name"/>{<br class="title-page-name"/>    if (curShader != null)<br class="title-page-name"/>    {<br class="title-page-name"/>        ScreenMat.SetColor("_SepiaColor", sepiaColor);<br class="title-page-name"/>        ScreenMat.SetFloat("_VignetteAmount", vignetteAmount);<br class="title-page-name"/>        ScreenMat.SetFloat("_EffectAmount", OldFilmEffectAmount);<br class="title-page-name"/><br class="title-page-name"/>        if (vignetteTexture)<br class="title-page-name"/>        {<br class="title-page-name"/>            ScreenMat.SetTexture("_VignetteTex", vignetteTexture);<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        if (scratchesTexture)<br class="title-page-name"/>        {<br class="title-page-name"/>            ScreenMat.SetTexture("_ScratchesTex", scratchesTexture);<br class="title-page-name"/>            ScreenMat.SetFloat("_ScratchesYSpeed", scratchesYSpeed);<br class="title-page-name"/>            ScreenMat.SetFloat("_ScratchesXSpeed", scratchesXSpeed);<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        if (dustTexture)<br class="title-page-name"/>        {<br class="title-page-name"/>            ScreenMat.SetTexture("_DustTex", dustTexture);<br class="title-page-name"/>            ScreenMat.SetFloat("_dustYSpeed", dustYSpeed);<br class="title-page-name"/>            ScreenMat.SetFloat("_dustXSpeed", dustXSpeed);<br class="title-page-name"/>            ScreenMat.SetFloat("_RandomValue", randomValue);<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture, ScreenMat);<br class="title-page-name"/>    }<br class="title-page-name"/>    else<br class="title-page-name"/>    {<br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">To complete the script portion of this effect, we simply need to make sure that we clamp the values of the variables that need to have a clamped range instead of being any value:</li>
</ol>
<pre class="calibre62">void Update()<br class="title-page-name"/>{<br class="title-page-name"/>    vignetteAmount = Mathf.Clamp01(vignetteAmount);<br class="title-page-name"/>    OldFilmEffectAmount = Mathf.Clamp(OldFilmEffectAmount, 0f, 1.5f);<br class="title-page-name"/>    randomValue = Random.Range(-1f, 1f);<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">With our script complete, let's turn our attention to our shader file. We need to create the corresponding variables, which we created in our script in our shader. This will allow the script and shader to communicate with one another. Enter the following code in the <kbd class="calibre13">Properties</kbd> block of the shader:</li>
</ol>
<pre class="calibre62">Properties <br class="title-page-name"/>{ <br class="title-page-name"/>    _MainTex ("Base (RGB)", 2D) = "white" {} <br class="title-page-name"/>    _VignetteTex ("Vignette Texture", 2D) = "white"{} <br class="title-page-name"/>    _ScratchesTex ("Scratches Texture", 2D) = "white"{} <br class="title-page-name"/>    _DustTex ("Dust Texture", 2D) = "white"{} <br class="title-page-name"/>    _SepiaColor ("Sepia Color", Color) = (1,1,1,1) <br class="title-page-name"/>    _EffectAmount ("Old Film Effect Amount", Range(0,1)) = 1.0 <br class="title-page-name"/>    _VignetteAmount ("Vignette Opacity", Range(0,1)) = 1.0 <br class="title-page-name"/>    _ScratchesYSpeed ("Scratches Y Speed", Float) = 10.0 <br class="title-page-name"/>    _ScratchesXSpeed ("Scratches X Speed", Float) = 10.0 <br class="title-page-name"/>    _dustXSpeed ("Dust X Speed", Float) = 10.0 <br class="title-page-name"/>    _dustYSpeed ("Dust Y Speed", Float) = 10.0 <br class="title-page-name"/>    _RandomValue ("Random Value", Float) = 1.0 <br class="title-page-name"/>    _Contrast ("Contrast", Float) = 3.0 <br class="title-page-name"/>} </pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Then, as usual, we need to add these same variable names to our <kbd class="calibre13">CGPROGRAM</kbd> block so that the <kbd class="calibre13">Properties</kbd> block can communicate with the <kbd class="calibre13">CGPROGRAM</kbd> block:</li>
</ol>
<pre class="calibre62">Pass<br class="title-page-name"/>{<br class="title-page-name"/>  CGPROGRAM <br class="title-page-name"/>  #pragma vertex vert_img <br class="title-page-name"/>  #pragma fragment frag <br class="title-page-name"/>  #pragma fragmentoption ARB_precision_hint_fastest <br class="title-page-name"/>  #include "UnityCG.cginc" <br class="title-page-name"/>             <br class="title-page-name"/>  uniform sampler2D _MainTex; <br class="title-page-name"/>  uniform sampler2D _VignetteTex; <br class="title-page-name"/>  uniform sampler2D _ScratchesTex; <br class="title-page-name"/>  uniform sampler2D _DustTex; <br class="title-page-name"/>  fixed4 _SepiaColor; <br class="title-page-name"/>  fixed _VignetteAmount; <br class="title-page-name"/>  fixed _ScratchesYSpeed; <br class="title-page-name"/>  fixed _ScratchesXSpeed; <br class="title-page-name"/>  fixed _dustXSpeed; <br class="title-page-name"/>  fixed _dustYSpeed; <br class="title-page-name"/>  fixed _EffectAmount; <br class="title-page-name"/>  fixed _RandomValue; <br class="title-page-name"/>  fixed _Contrast; </pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Now, we simply fill in the guts of our <kbd class="calibre13">frag()</kbd> function so that we can process the pixels for our screen effect. To start with, let's get the render texture and vignette texture passed to us by the script:</li>
</ol>
<pre class="calibre62">fixed4 frag(v2f_img i) : COLOR 
{ 
    //Get the colors from the RenderTexture and the uv's 
    //from the v2f_img struct 
    fixed4 renderTex = tex2D(_MainTex, i.uv); 
                 
    //Get the pixels from the Vignette Texture 
    fixed4 vignetteTex = tex2D(_VignetteTex, i.uv); </pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">We then need to add the process for the dust and scratches by entering the following code:</li>
</ol>
<pre class="calibre62">//Process the Scratches UV and pixels 
half2 scratchesUV = half2(i.uv.x + (_RandomValue * _SinTime.z * _ScratchesXSpeed), i.uv.y + (_Time.x * _ScratchesYSpeed)); 
fixed4 scratchesTex = tex2D(_ScratchesTex, scratchesUV); 
         
//Process the Dust UV and pixels 
half2 dustUV = half2(i.uv.x + (_RandomValue * (_SinTime.z * _dustXSpeed)), i.uv.y + (_RandomValue * (_SinTime.z * _dustYSpeed))); 
fixed4 dustTex = tex2D(_DustTex, dustUV); </pre>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">The sepia tone process is next on our list:</li>
</ol>
<pre class="calibre62">// get the luminosity values from the render texture using the YIQ values. 
fixed lum = dot (fixed3(0.299, 0.587, 0.114), renderTex.rgb); 
                 
//Add the constant color to the lum values 
fixed4 finalColor = lum + lerp(_SepiaColor, _SepiaColor + 
 fixed4(0.1f,0.1f,0.1f,1.0f), _RandomValue); 
finalColor = pow(finalColor, _Contrast); </pre>
<ol start="10" class="calibre15">
<li value="10" class="calibre12">Finally, we combine all of our layers and colors and return the final screen effect texture:</li>
</ol>
<pre class="calibre62">  //Create a constant white color we can use to adjust opacity of effects <br class="title-page-name"/>  fixed3 constantWhite = fixed3(1,1,1); <br class="title-page-name"/>                 <br class="title-page-name"/>  //Composite together the different layers to create finsl Screen Effect <br class="title-page-name"/>  finalColor = lerp(finalColor, finalColor * vignetteTex, _VignetteAmount); <br class="title-page-name"/>  finalColor.rgb *= lerp(scratchesTex, constantWhite, (_RandomValue)); <br class="title-page-name"/>  finalColor.rgb *= lerp(dustTex.rgb, constantWhite, (_RandomValue * _SinTime.z)); <br class="title-page-name"/>  finalColor = lerp(renderTex, finalColor, _EffectAmount); <br class="title-page-name"/>                 <br class="title-page-name"/>  return finalColor; <br class="title-page-name"/>}</pre>
<ol start="11" class="calibre15">
<li value="11" class="calibre12">With all of our code entered and no errors, return to the Unity editor and add the <kbd class="calibre13">RenderOldFilm</kbd> component to the <kbd class="calibre13">MainCamera</kbd> in our example scene. From there, drag and drop our shader into the Cur Shader property. Afterward, under Sepia Color,  assign a brown color like the following:</li>
</ol>
<div><img src="img/00207.jpeg" class="calibre143"/></div>
<ol start="12" class="calibre15">
<li value="12" class="calibre12">Afterward, assign each of the textures given to the appropriate property. You should then notice something similar to the following on the screen:</li>
</ol>
<div><img src="img/00208.jpeg" class="calibre25"/></div>
<ol start="13" class="calibre15">
<li value="13" class="calibre12">Also, make sure to hit Play in the Unity Editor to see the full extent of the effects of the dust and scratches and the slight image shift that we gave the screen effect.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">Now, let's walk through each of the layers in this screen effect, break down why each of the lines of code is working the way it is, and get more insight about how we can add more to this screen effect.</p>
<p class="calibre3">Now that our old film screen effect is working, let's step through the lines of code in our <kbd class="calibre13">frag()</kbd> function, as all the other code should be pretty self-explanatory at this point in the book.</p>
<p class="calibre3">Just like our Photoshop layers, our shader is processing each layer and then compositing them together, so while we go through each layer, try to imagine how the layers in Photoshop work. Keeping this concept in mind always helps when developing new screen effects.</p>
<p class="calibre3">Here, we have the first set of lines of code in our <kbd class="calibre13">frag()</kbd> function:</p>
<pre class="calibre62">fixed4 frag(v2f_img i) : COLOR 
{ 
    //Get the colors from the RenderTexture and the uv's 
    //from the v2f_img struct 
    fixed4 renderTex = tex2D(_MainTex, i.uv); 
                 
    //Get the pixels from the Vignette Texture 
    fixed4 vignetteTex = tex2D(_VignetteTex, i.uv); </pre>
<p class="calibre3">The first line of code, just after the <kbd class="calibre13">frag()</kbd> function declaration, is the definition of how the UVs should work for our main render texture or the actual rendered frame of our game. As we are looking to fake the effect of an old film style, we want to adjust the UVs of our render texture in every frame, such that they flicker. This flickering simulates how the winding of the film's projector is just a bit off. This tells us that we need to animate the UVs and this is what this first line of code is doing.</p>
<p class="calibre3">We used the built-in <kbd class="calibre13">_SinTime</kbd> variable, which Unity provides, to get a value between <kbd class="calibre13">-1</kbd> and <kbd class="calibre13">1</kbd>. We then multiply this by a very small number, in this case, <kbd class="calibre13">0.005</kbd>, to reduce the intensity of the effect. The final value is then multiplied again by the <kbd class="calibre13">_RandomValue</kbd> variable, which we generated in the effect script. This value bounces back and forth between <kbd class="calibre13">-1</kbd> and <kbd class="calibre13">1</kbd> to basically flip the direction of the motion back and forth.</p>
<p class="calibre3">Once our UVs are built and stored in the <kbd class="calibre13">renderTexUV</kbd> variable, we can sample the render texture using a <kbd class="calibre13">tex2D()</kbd> function. This operation then gives us our final render texture, which we can use to process further in the rest of the shader.</p>
<p class="calibre3">Moving on to the last line in the previous image, we simply do a straight sample of the vignette texture using the <kbd class="calibre13">tex2D()</kbd> function. We don't need to use the animated UVs we already created, as the vignette texture will be tied to the motion of the camera itself and not to the flickering of the camera film.</p>
<pre>frag()</kbd> function:</pre>
<pre class="calibre19">//Process the Scratches UV and pixels 
half2 scratchesUV = half2(i.uv.x + (_RandomValue * _SinTime.z * _ScratchesXSpeed), 
        i.uv.y + (_Time.x * _ScratchesYSpeed)); 
fixed4 scratchesTex = tex2D(_ScratchesTex, scratchesUV); 
                 
//Process the Dust UV and pixels 
half2 dustUV = half2(i.uv.x + (_RandomValue * (_SinTime.z * _dustXSpeed)),  
        i.uv.y + (_RandomValue * (_SinTime.z * _dustYSpeed))); 
fixed4 dustTex = tex2D(_DustTex, dustUV); </pre>
<p class="calibre3">These lines of code are almost exactly like the previous lines of code, in which we need to generate unique animated UV values to modify the position of our screen effect layers. We simply use the built-in <kbd class="calibre13">_SinTime</kbd> value to get a value between <kbd class="calibre13">-1</kbd> and <kbd class="calibre13">1</kbd>, multiply it by our random value, and then by another multiplier to adjust the overall speed of the animation. Once these UV values are generated, we can then sample our dust and scratches texture using these new animated values.</p>
<p class="calibre3">Our next set of code handles the creation of the colorizing effect for our old film screen effect. The following code snippet demonstrates these lines:</p>
<pre class="calibre19">// get the luminosity values from the render texture using the YIQ values 
fixed lum = dot (fixed3(0.299, 0.587, 0.114), renderTex.rgb); 
                 
//Add the constant color to the lum values 
fixed4 finalColor = lum + lerp(_SepiaColor, _SepiaColor +<br class="title-page-name"/>     fixed4(0.1f,0.1f,0.1f,1.0f), _RandomValue);</pre>
<p class="calibre3">With this set of code, we are creating the actual color tinting of the entire render texture. To accomplish this, we first need to turn the render texture into the grayscale version of itself. To do this, we can use the luminosity values given to us by the <kbd class="calibre13">YIQ</kbd> values. <kbd class="calibre13">YIQ</kbd> values are the color space used by the NTSC color TV system. Each letter in <kbd class="calibre13">YIQ</kbd> actually stores color constants that are used by TVs to adjust the color for readability.</p>
<p class="calibre3">While it is not necessary to actually know the reasons for this color scale, it should be known that the <kbd class="calibre13">Y</kbd> value in <kbd class="calibre13">YIQ</kbd> is the constant luminance value for any image. So, we can generate a grayscale image of our render texture by taking each pixel of the render texture and dotting it with our luminance values. This is what the first line in this set is doing.</p>
<p class="calibre3">Once we have the luminance values, we can simply add the color we want to tint the image with. This color is passed from our script to our shader, then to our <kbd class="calibre13">CGPROGRAM</kbd> block, where we can add it to our grayscale render to texture. Once completed, we will have a perfectly tinted image.</p>
<p class="calibre3">Finally, we create the blending between each of our layers in our screen effect. The following code snippet shows the set of code we are looking at:</p>
<pre class="calibre19">//Create a constant white color we can use to adjust opacity of effects 
fixed3 constantWhite = fixed3(1,1,1); 
                 
//Composite together the different layers to create finsl Screen Effect 
finalColor = lerp(finalColor, finalColor * vignetteTex, _VignetteAmount); 
finalColor.rgb *= lerp(scratchesTex, constantWhite, (_RandomValue)); 
finalColor.rgb *= lerp(dustTex.rgb, constantWhite, (_RandomValue * _SinTime.z)); 
finalColor = lerp(renderTex, finalColor, _EffectAmount); 
                 
return finalColor </pre>
<p class="calibre3">Our last set of code is relatively simple and doesn't really need a ton of explanation. In short, it is simply multiplying all the layers together to reach our final result. Just like we multiplied our layers together in Photoshop, we multiply them together in our shader. Each layer is processed through a <kbd class="calibre13">lerp()</kbd> function so that we can adjust the opacity of each layer, which gives more artistic control over the final effect. The more tweaks one can offer, the better when it comes to screen effects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            
                
<p class="calibre3">For more information on the <kbd class="calibre13">YIQ</kbd> values, refer to the following links:</p>
<ul class="calibre11">
<li class="calibre12"><a href="http://en.wikipedia.org/wiki/YIQ" class="calibre10">http://en.wikipedia.org/wiki/YIQ</a><br class="title-page-name"/></li>
<li class="calibre12"><a href="http://www.blackice.com/colorspaceYIQ.htm" class="calibre10">http://www.blackice.com/colorspaceYIQ.htm</a><br class="title-page-name"/></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a night vision screen effect</h1>
                
            
            
                
<p class="calibre3">Our next screen effect is definitely a more popular one. The night vision screen effect is seen in <em class="calibre14">Call of Duty: Modern Warfare</em>, <em class="calibre14">Halo</em>, and just about any first-person shooter out in the market today. It is the effect of brightening the whole image using that very distinct lime-green color.</p>
<p class="calibre3">In order to achieve our night vision effect, we need to break down our effect using Photoshop. It is a simple process of finding some reference images online and composing a layered image to see what kind of blending modes you will need or in which order we will need to combine our layers. The following screenshot shows the result of performing just this process in Photoshop:</p>
<div><img src="img/00209.jpeg" class="calibre144"/></div>
<p class="calibre3">Let's begin to break down our rough Photoshop composite image into its component parts so that we can better understand the assets we will have to gather. In the next recipe, we will cover the process of doing this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">Let's begin this screen effect by again breaking down our effect into its component layers. Using Photoshop, we can construct a layered image to better illustrate how we can go about capturing the effect of night vision:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Tinted green</strong>: Our first layer in our screen effect is the iconic green color, found in just about every night vision image. This will give our effect that signature night vision look, as shown in the following screenshot:</li>
</ul>
<div><img src="img/00210.jpeg" class="calibre145"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Scan lines</strong>: To increase the effect of this being a new type of display for the player, we include scan lines over the top of our tinted layer. For this, we will use a texture created in Photoshop and let the user tile it so that the scan lines can be bigger or smaller.</li>
<li class="calibre12"><strong class="calibre1">Noise</strong>: Our next layer is a simple noise texture that we tile over the tinted image and scan lines to break up the image and add even more detail to our effect. This layer simply emphasizes that digital read-out look:</li>
</ul>
<div><img src="img/00211.jpeg" class="calibre146"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Vignette</strong>: The last layer in our night vision effect is the vignette. If you look at the night vision effect in <em class="calibre2">Call of Duty: Modern Warfare</em>, you will notice that it uses a vignette that fakes the effect of looking down a scope. We will do that for this screen effect:</li>
</ul>
<div><img src="img/00212.jpeg" class="calibre25"/></div>
<p class="calibre3">Let's create a screen effect system by gathering our textures. Perform the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Gather up a vignette texture, noise texture, and scan line texture, like the ones we just saw. Like before, I have these textures available in the book's example code under the <kbd class="calibre13">Chapter 10</kbd> | <kbd class="calibre13">Textures</kbd> folder.</li>
<li value="2" class="calibre12">Find a sample scene to make it easy to see the effect of the shader. I will be using the same scene as in the previous recipe, so feel free to use the <kbd class="calibre13">10.1 Sample Scene</kbd> again.</li>
<li value="3" class="calibre12">Create a new shader by duplicating the <kbd class="calibre13">ScreenGrayscale</kbd> code; select it from the Project tab under the <kbd class="calibre13">Chapter 9</kbd> | <kbd class="calibre13">Shaders</kbd> folder and press <em class="calibre2">Ctrl </em>+ <em class="calibre2">D</em>. Once duplicated, rename the script to  <kbd class="calibre13">ScreenNightVision</kbd>. Then drag and drop the script into the <kbd class="calibre13">Chapter 10 </kbd>| <kbd class="calibre13">Shaders</kbd> folder, creating it if needed.</li>
<li value="4" class="calibre12">Next, go the <kbd class="calibre13">Chapter 9 </kbd>| <kbd class="calibre13">Scripts</kbd> folder and duplicate the <kbd class="calibre13">TestRenderImage</kbd> script. Rename the new file to <kbd class="calibre13">RenderNightVision</kbd> and then drag and drop it into the <kbd class="calibre13">Chapter 10 </kbd>| <kbd class="calibre13">Scripts</kbd> folder, creating it if needed.</li>
</ol>
<p class="calibre3">Finally, with our screen effect system up and running and our textures gathered, we can begin the process of recreating this night vision effect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">With all of our assets gathered and the screen effect system running smoothly, let's begin to add the code necessary to both the script and shader. We will begin our coding with the <kbd class="calibre13">RenderNightVision.cs</kbd> script, so double-click on this file now to open it in your code editor of choice:</p>
<ol class="calibre15">
<li value="1" class="calibre12">We will begin by entering the code in our script. Our first step in modifying our script is to rename the class to match our filename, <kbd class="calibre13">RenderNightVision</kbd>:</li>
</ol>
<pre class="calibre62">[ExecuteInEditMode]<br class="title-page-name"/>public class <strong class="calibre1">RenderNightVision </strong>: MonoBehaviour {</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">We need to create a few variables that will allow the user of this effect to adjust it in the script's Inspector. Enter the following code in the <kbd class="calibre13">NightVisionEffect.cs</kbd> script:</li>
</ol>
<pre class="calibre62">#region Variables 
    public Shader curShader; 
     
    public float contrast = 3.0f; 
    public float brightness = 0.1f; 
    public Color nightVisionColor = Color.green; 
     
    public Texture2D vignetteTexture; 
     
    public Texture2D scanLineTexture; 
    public float scanLineTileAmount = 4.0f; 
     
    public Texture2D nightVisionNoise; 
    public float noiseXSpeed = 100.0f; 
    public float noiseYSpeed = 100.0f; 
     
    public float distortion = 0.2f; 
    public float scale = 0.8f; 
     
    private float randomValue = 0.0f; 
    private Material screenMat; 
    #endregion </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Next, we need to complete our <kbd class="calibre13">OnRenderImage()</kbd> function so that we are passing the right data to the shader in order for the shader to process the screen effect properly. Complete the <kbd class="calibre13">OnRenderImage()</kbd> function with the following code:</li>
</ol>
<pre class="calibre62">void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)<br class="title-page-name"/>{<br class="title-page-name"/>    if (curShader != null)<br class="title-page-name"/>    {<br class="title-page-name"/>        ScreenMat.SetFloat("_Contrast", contrast);<br class="title-page-name"/>        ScreenMat.SetFloat("_Brightness", brightness);<br class="title-page-name"/>        ScreenMat.SetColor("_NightVisionColor", nightVisionColor);<br class="title-page-name"/>        ScreenMat.SetFloat("_RandomValue", randomValue);<br class="title-page-name"/>        ScreenMat.SetFloat("_distortion", distortion);<br class="title-page-name"/>        ScreenMat.SetFloat("_scale", scale);<br class="title-page-name"/><br class="title-page-name"/>        if (vignetteTexture)<br class="title-page-name"/>        {<br class="title-page-name"/>            ScreenMat.SetTexture("_VignetteTex", vignetteTexture);<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        if (scanLineTexture)<br class="title-page-name"/>        {<br class="title-page-name"/>            ScreenMat.SetTexture("_ScanLineTex", scanLineTexture);<br class="title-page-name"/>            ScreenMat.SetFloat("_ScanLineTileAmount", scanLineTileAmount);<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        if (nightVisionNoise)<br class="title-page-name"/>        {<br class="title-page-name"/>            ScreenMat.SetTexture("_NoiseTex", nightVisionNoise);<br class="title-page-name"/>            ScreenMat.SetFloat("_NoiseXSpeed", noiseXSpeed);<br class="title-page-name"/>            ScreenMat.SetFloat("_NoiseYSpeed", noiseYSpeed);<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture, ScreenMat);<br class="title-page-name"/>    }<br class="title-page-name"/>    else<br class="title-page-name"/>    {<br class="title-page-name"/>        Graphics.Blit(sourceTexture, destTexture);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">To complete the <kbd class="calibre13">NightVisionEffect.cs</kbd> script, we simply need to make sure that we clamp certain variables so that they stay within a range. These ranges are arbitrary and can be changed at a later time. These are just values that worked well:</li>
</ol>
<pre class="calibre62">void Update()<br class="title-page-name"/>{<br class="title-page-name"/>    contrast = Mathf.Clamp(contrast, 0f, 4f);<br class="title-page-name"/>    brightness = Mathf.Clamp(brightness, 0f, 2f);<br class="title-page-name"/>    randomValue = Random.Range(-1f, 1f);<br class="title-page-name"/>    distortion = Mathf.Clamp(distortion, -1f, 1f);<br class="title-page-name"/>    scale = Mathf.Clamp(scale, 0f, 3f);<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">We can now turn our attention over to the shader portion of this screen effect. Open the shader, if you haven't already, and begin by entering the following properties in the <kbd class="calibre13">Properties</kbd> block:</li>
</ol>
<pre class="calibre62">Properties <br class="title-page-name"/>{ <br class="title-page-name"/>    _MainTex ("Base (RGB)", 2D) = "white" {} <br class="title-page-name"/>    _VignetteTex ("Vignette Texture", 2D) = "white"{} <br class="title-page-name"/>    _ScanLineTex ("Scan Line Texture", 2D) = "white"{} <br class="title-page-name"/>    _NoiseTex ("Noise Texture", 2D) = "white"{} <br class="title-page-name"/>    _NoiseXSpeed ("Noise X Speed", Float) = 100.0 <br class="title-page-name"/>    _NoiseYSpeed ("Noise Y Speed", Float) = 100.0 <br class="title-page-name"/>    _ScanLineTileAmount ("Scan Line Tile Amount", Float) = 4.0 <br class="title-page-name"/>    _NightVisionColor ("Night Vision Color", Color) = (1,1,1,1) <br class="title-page-name"/>    _Contrast ("Contrast", Range(0,4)) = 2 <br class="title-page-name"/>    _Brightness ("Brightness", Range(0,2)) = 1 <br class="title-page-name"/>    _RandomValue ("Random Value", Float) = 0 <br class="title-page-name"/>    _distortion ("Distortion", Float) = 0.2 <br class="title-page-name"/>    _scale ("Scale (Zoom)", Float) = 0.8 <br class="title-page-name"/>} </pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">To make sure that we are passing the data from our <kbd class="calibre13">Properties</kbd> block to our <kbd class="calibre13">CGPROGRAM</kbd> block, we need to make sure to declare them with the same name in the <kbd class="calibre13">CGPROGRAM</kbd> block:</li>
</ol>
<pre class="calibre62">Pass<br class="title-page-name"/>{<br class="title-page-name"/>  CGPROGRAM <br class="title-page-name"/>  #pragma vertex vert_img <br class="title-page-name"/>  #pragma fragment frag <br class="title-page-name"/>  #pragma fragmentoption ARB_precision_hint_fastest <br class="title-page-name"/>  #include "UnityCG.cginc" <br class="title-page-name"/>             <br class="title-page-name"/>  uniform sampler2D _MainTex; <br class="title-page-name"/>  uniform sampler2D _VignetteTex; <br class="title-page-name"/>  uniform sampler2D _ScanLineTex; <br class="title-page-name"/>  uniform sampler2D _NoiseTex; <br class="title-page-name"/>  fixed4 _NightVisionColor; <br class="title-page-name"/>  fixed _Contrast; <br class="title-page-name"/>  fixed _ScanLineTileAmount; <br class="title-page-name"/>  fixed _Brightness; <br class="title-page-name"/>  fixed _RandomValue; <br class="title-page-name"/>  fixed _NoiseXSpeed; <br class="title-page-name"/>  fixed _NoiseYSpeed; <br class="title-page-name"/>  fixed _distortion; <br class="title-page-name"/>  fixed _scale; </pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Our effect is also going to include a lens distortion to further convey the effect that we are looking through a lens and the edges of the image are being distorted by the angle of the lens. Enter the following function just after the variable declarations in the <kbd class="calibre13">CGPROGRAM</kbd> block:</li>
</ol>
<pre class="calibre62">    float2 barrelDistortion(float2 coord)  
    { 
        // lens distortion algorithm 
        // See http://www.ssontech.com/content/lensalg.htm 
 
        float2 h = coord.xy - float2(0.5, 0.5); 
        float r2 = h.x * h.x + h.y * h.y; 
        float f = 1.0 + r2 * (_distortion * sqrt(r2)); 
 
        return f * _scale * h + 0.5; 
    } </pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">We can now concentrate on the meat of our <kbd class="calibre13">NightVisionEffect</kbd> shader. Let's start this by entering the code that is necessary to get the render texture and vignette texture. Enter the following code in the <kbd class="calibre13">frag()</kbd> function of our shader:</li>
</ol>
<pre class="calibre62">    fixed4 frag(v2f_img i) : COLOR 
    { 
        //Get the colors from the RenderTexture and the uv's 
        //from the v2f_img struct 
        half2 distortedUV = barrelDistortion(i.uv); 
        fixed4 renderTex = tex2D(_MainTex, distortedUV); 
        fixed4 vignetteTex = tex2D(_VignetteTex, i.uv); </pre>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">The next step in our <kbd class="calibre13">frag()</kbd> function is to process the scan lines and <kbd class="calibre13">Noise</kbd> textures and apply the proper animated UVs to them:</li>
</ol>
<pre class="calibre62">//Process scan lines and noise <br class="title-page-name"/>half2 scanLinesUV = half2(i.uv.x * _ScanLineTileAmount, i.uv.y * _ScanLineTileAmount); <br class="title-page-name"/>fixed4 scanLineTex = tex2D(_ScanLineTex, scanLinesUV); <br class="title-page-name"/>                 <br class="title-page-name"/>half2 noiseUV = half2(i.uv.x + (_RandomValue * _SinTime.z * _NoiseXSpeed), <br class="title-page-name"/>                  i.uv.y + (_Time.x * _NoiseYSpeed)); <br class="title-page-name"/>fixed4 noiseTex = tex2D(_NoiseTex, noiseUV); </pre>
<ol start="10" class="calibre15">
<li value="10" class="calibre12">To complete all of our layers in the screen effect, we simply need to process the luminance value of our render texture, and then apply the night vision color to it to achieve that iconic night vision look:</li>
</ol>
<pre class="calibre62">// get the luminosity values from the render texture using the     //YIQ values. 
        fixed lum = dot (fixed3(0.299, 0.587, 0.114), renderTex.rgb); 
        lum += _Brightness; 
        fixed4 finalColor = (lum *2) + _NightVisionColor; </pre>
<ol start="11" class="calibre15">
<li value="11" class="calibre12">Lastly, we will combine all the layers together and return the final color of our night vision effect:</li>
</ol>
<pre class="calibre62">  //Final output <br class="title-page-name"/>  finalColor = pow(finalColor, _Contrast); <br class="title-page-name"/>  finalColor *= vignetteTex; <br class="title-page-name"/>  finalColor *= scanLineTex * noiseTex; <br class="title-page-name"/>                 <br class="title-page-name"/>  return finalColor; <br class="title-page-name"/>}</pre>
<ol start="12" class="calibre15">
<li value="12" class="calibre12">When you have finished entering the code, return to the Unity editor to let the script and shader compile. If there are no errors, select the <kbd class="calibre13">MainCamera</kbd> in your scene. Remove the Render Old Film component, if it is there already, and add the <kbd class="calibre13">RenderNightVision</kbd> component. Once there, drag and drop the <kbd class="calibre13">ScreenNightVision</kbd> shader into the Cur Shader property of the component and then assign the Night Vision Color property to a green color like the following: </li>
</ol>
<div><img src="img/00213.jpeg" class="calibre147"/></div>
<ol start="13" class="calibre15">
<li value="13" class="calibre12">Afterward, assign the textures to their proper spot:</li>
</ol>
<div><img src="img/00214.jpeg" class="calibre25"/></div>
<ol start="14" class="calibre15">
<li value="14" class="calibre12">Afterward, make sure to play in the editor to see the full, final version of the effect:</li>
</ol>
<div><img src="img/00215.jpeg" class="calibre25"/></div>
<p>The final result of our night-vision screen effect</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">The night vision effect is actually very similar to the old film screen effect, which shows us just how modular we can make these components. Just by simply swapping the textures that we are using for overlays and changing the speed at which our tiling rates are being calculated, we can achieve very different results using the same code.</p>
<p class="calibre3">The only difference with this effect is the fact that we are including a lens distortion to our screen effect. So let's break this down so that we can get a better understanding of how it works.</p>
<pre>SynthEyes</em>, and the code is freely available to use in your own effects:</pre>
<pre class="calibre19">float2 barrelDistortion(float2 coord)  
{ 
    // lens distortion algorithm 
    // See http://www.ssontech.com/content/lensalg.htm 
    float2 h = coord.xy - float2(0.5, 0.5); 
    float r2 = h.x * h.x + h.y * h.y; 
    float f = 1.0 + r2 * (_distortion * sqrt(r2)); 
 
    return f * _scale * h + 0.5; 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            
                
<p class="calibre3">It is not uncommon in video games to have the need to highlight certain objects. For instance, a thermal visor should only apply a post-processing effect to people and other sources of heat. Doing this is already possible with the knowledge gathered so far in this book; you can, in fact, change the shader or material of an object by code. However, this is often laborious and has to be replicated on every the object.</p>
<p class="calibre3">A more effective way to use replaced shaders. Each shader has a tag called <kbd class="calibre13">RenderType</kbd> that has never been used so far. This property can be used to force a camera to apply a shader only to certain objects. You can do this by attaching the following script to the camera:</p>
<pre class="calibre19">using UnityEngine; 
 
public class ReplacedShader : MonoBehaviour { 
 
    public Shader shader; 
    void Start () { 
        GetComponent&lt;Camera&gt;().SetReplacementShader(shader, "Heat"); 
    } 
} </pre>
<p class="calibre3">After entering the play mode, the camera will query all the objects that it has to render. If they don't have a shader decorated with <kbd class="calibre13">RenderType = "Heat"</kbd>, they will not be rendered. Objects with such a tag will be rendered with the shader attached to the script.</p>


            

            
        
    </body></html>