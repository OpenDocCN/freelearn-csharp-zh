<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-179"><a id="_idTextAnchor379"/>10</h1>
<h1 id="_idParaDest-180"><a id="_idTextAnchor380"/>Conclusion</h1>
<p>As you saw while reading the book, there are many data structures with many configuration variants. Thus, <strong class="bold">choosing a proper data structure is not an easy task</strong>, which could have a significant impact on the performance of the developed solution. Even the topics mentioned in this book form quite a long list of described data structures. For this reason, it is a good idea to classify them in some way.</p>
<p>Within this chapter, the described data structures are grouped into linear and non-linear categories. Each element in a <strong class="bold">linear data structure</strong> can be logically adjacent to the following or the previous element. In the case of a <strong class="bold">nonlinear data structure</strong>, a single element can be logically adjacent to numerous others, not necessarily only one or two.</p>
<p>As it is the last chapter of the book, we will also summarize all of the gathered knowledge. Each data structure will be presented with a brief description, and some of them will be also shown with illustrations to help you remember this information.</p>
<p>In this chapter, the following topics will be covered:</p>
<ul>
<li>Classification</li>
<li>Arrays</li>
<li>Lists</li>
<li>Stacks</li>
<li>Queues</li>
<li>Dictionaries</li>
<li>Sets</li>
<li>Trees</li>
<li>Graphs</li>
<li>The last word</li>
</ul>
<h1 id="_idParaDest-181"><a id="_idTextAnchor381"/>Classification</h1>
<p>I will start with a classification <a id="_idIndexMarker899"/>of the data structures shown already in the book. The classification divides all structures into linear and non-linear ones.</p>
<p>A <strong class="bold">linear data structure</strong> means<a id="_idIndexMarker900"/> that <strong class="bold">each element can be logically adjacent to the following or the previous element</strong>. There are several data structures that follow this rule, such as arrays, lists, stacks, and queues. Of course, you should also take care of various subtypes of the mentioned <a id="_idIndexMarker901"/>data structures, such as four variants of a linked list, which is a subtype of a list.</p>
<p>A <strong class="bold">non-linear data structure</strong> indicates that <strong class="bold">a single element can be logically adjacent to numerous others, not necessarily only one or two</strong>. They can be freely distributed<a id="_idIndexMarker902"/> throughout the memory. Of course, graph-based data structures, including<a id="_idIndexMarker903"/> trees, are included in this group. Trees include binary trees, tries, and heaps, while a binary search tree is a subtype of a binary tree. In a similar way, you can describe the relationships of other data structures presented and explained in this book.</p>
<p>The mentioned classification is presented in the following diagram:</p>
<div><div><img alt="Figure 10.1 – Classification of data structures into linear and non-linear ones" src="img/B18069_10_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Classification of data structures into linear and non-linear ones</p>
<p>Do you remember all of the data structures shown in the book? Due to the high number of described topics, it is a good idea to take a look at the following data structures once again. The associated<a id="_idIndexMarker904"/> algorithms will be mentioned, as well. The remaining part of this chapter is a brief summary with information about some real-world applicat<a id="_idTextAnchor382"/>i<a id="_idTextAnchor383"/>ons.</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor384"/>Arrays</h1>
<p>Let’s start with an <code>int</code>, <code>string</code>, or a user-defined <a id="_idIndexMarker905"/>class. The important assumption is that the number of elements in an array cannot be changed after initialization. Moreover, arrays belong to <strong class="bold">random access data structures</strong>. This means that you can use indices to get access to the first, the middle, the <em class="italic">n</em>-th, or the last element from the array.</p>
<p>You can benefit from a few variants of <a id="_idIndexMarker906"/>arrays – namely, <strong class="bold">single-dimensional</strong>, <strong class="bold">multi-dimensional</strong>, and <strong class="bold">jagged arrays</strong>, also referred to as an <strong class="bold">array of arrays</strong>. All of these variants are shown in the following illustration:</p>
<div><div><img alt="Figure 10.2 – Variants of arrays" src="img/B18069_10_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Variants of arrays</p>
<p>There are a lot of applications for arrays and, as a developer, you have probably already used this data structure many times. In this book, you saw how you can use it to store various data, such as the <strong class="bold">names of months</strong>, the <strong class="bold">multiplication table</strong>, or even a <strong class="bold">map of a game</strong>. In the last case, you created a two-dimensional array with the same size as a map, where each element specified a certain type of terrain, such as grass.</p>
<p>There are many algorithms that perform operations on arrays. However, one of the most common tasks is sorting an array to arrange its elements in the correct order, either ascending or descending. This book focuses on seven algorithms, namely <strong class="bold">selection sort</strong>, <strong class="bold">insertion sort</strong>, <strong class="bold">bubble sort</strong>, <strong class="bold">merge sort</strong>, <strong class="bold">Shell sort</strong>, <strong class="bold">quicksort</strong>, and <strong class="bold">heap sort</strong>. Each of them <a id="_idIndexMarker907"/>was described and presented in the illustration, as well as written in the C# code, together with a detailed explan<a id="_idTextAnchor385"/>ation.</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor386"/>Lists</h1>
<p>The next group of data structures are <code>ArrayList</code>), as well as its generic (<code>List</code>) and sorted (<code>SortedList</code>) variants. The latter can be understood as a collection of key-value pairs, always sorted by keys.</p>
<p>There are a few other variants of lists, including a <code>LinkedList</code>). You can quite easily extend it to behave as any circular linked list, either as a circular singly or circular doubly linked list.</p>
<p>Various variants of lists are shown in the following illustration:</p>
<div><div><img alt="Figure 10.3 – Variants of lists" src="img/B18069_10_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Variants of lists</p>
<p>There are a lot of applications for the lists to solve diverse problems in various kinds of applications. In this book, you saw how to utilize the list to store some floating-point values and calculate the average value, how to use this data structure to create a simple <strong class="bold">database of people</strong>, and <a id="_idIndexMarker909"/>how to develop an automatically sorted <strong class="bold">address book</strong>. Moreover, you prepared an exemplary application that allows a user to <strong class="bold">read the book</strong> by changing the pages, as well as a game, in which the user <strong class="bold">spins the wheel</strong> with random power. The wheel rotates slower and slower until it stops. Then, the user can spin it again, from the previous stop position, which illustrates a circular link<a id="_idTextAnchor387"/>e<a id="_idTextAnchor388"/>d list.</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor389"/>Stacks</h1>
<p><a href="B18069_05.xhtml#_idTextAnchor165"><em class="italic">Chapter 5</em></a>, <em class="italic">Stacks and Queues</em>, focused on stacks and queues. Now, let’s recap a <code>Stack</code> class is available, as well.</p>
<p>The illustration of a stack is shown as follows:</p>
<div><div><img alt="Figure 10.4 – Illustration of a stack" src="img/B18069_10_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Illustration of a stack</p>
<p>A stack has many real-world applications. One of the mentioned examples is related to a <strong class="bold">pile of many plates</strong>, each placed on top of the other. You can only add a new plate at the top of the pile, and you can only get a plate from the top of the pile. You cannot remove the seventh plate without taking the previous six from the top, and you cannot add a plate to the middle of the pile. You also saw how to use a stack to <strong class="bold">reverse a word</strong> and how to apply it to solve the mathematical game <strong class="bold">Tower o<a id="_idTextAnchor390"/>f Hanoi</strong>. That’s not all, because applications of stacks are much broader, such as for calculating mathematical expressions provided in the <strong class="bold">reverse </strong><strong class="bold">Polish no<a id="_idTextAnchor391"/>tation</strong>.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor392"/>Queues</h1>
<p>Another leading subject of <a href="B18069_05.xhtml#_idTextAnchor165"><em class="italic">Chapter 5</em></a>, <em class="italic">Stacks and Queues</em>, was a <code>Queue</code> class is available for you, as well.</p>
<p>The illustration of a queue is shown as follows:</p>
<div><div><img alt="Figure 10.5 – Illustration of a queue" src="img/B18069_10_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Illustration of a queue</p>
<p>It is also possible to use a <strong class="bold">priority queue</strong>, which extends the concept of a queue by setting the priority for each element. Thus, the dequeue operation returns the element with the highest priority, which was added earliest to the queue. When all elements with the highest priority are dequeued, the priority queue handles elements with the next highest priority and dequeues such elements from those added earliest.</p>
<p>Another variant of a<a id="_idIndexMarker912"/> queue is a <strong class="bold">circular queue</strong>, also called a <strong class="bold">ring buffer</strong>, which was also presented and explained in the book. Here, a queue forms a circle, internally uses an array, and the maximum number of elements that can be placed inside the queue is limited. You specify indices for front and rear elements in this case.</p>
<p>There are many real-world applications of a queue. For example, a queue can be used to represent a <strong class="bold">line of people</strong> waiting in a shop at a checkout. New people stand at the end of the line, and the next person is taken to the checkout from the beginning of the line. You are not allowed to<a id="_idIndexMarker913"/> choose a person from the middle and serve them. Moreover, you saw a few examples of the solution of a <strong class="bold">call center</strong>, where there are many clients and one consultant, many clients and many consultants, or many clients (with different plans, either standard or priority support) and only one consultant, who answers the wait<a id="_idTextAnchor393"/>ing calls. Another group of queue applications was shown while presenting <strong class="bold">graph-based algorithms</strong>. A queue was used in the <strong class="bold">breadth-first search</strong> algorithm for traversing a graph or for searching for a given value in a graph. A priority queue was applied in <strong class="bold">Dijkstra’s algorithm</strong> for searching the shortest path in<a id="_idTextAnchor394"/> a graph.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor395"/>Dictionaries</h1>
<p>The topic of <a href="B18069_06.xhtml#_idTextAnchor195"><em class="italic">Chapter 6</em></a>, <em class="italic">Dictionaries and Sets</em>, was related to dictionaries and sets. First, let’s recap a <strong class="bold">dictionary</strong>, which allows <strong class="bold">mapping keys to values and performing fast lookups</strong>. A dictionary uses a hash function and can be understood as a collection of pairs, each consisting <a id="_idIndexMarker914"/>of a key and a value.</p>
<p>There are two built-in versions of a dictionary – non-generic (<code>Hashtable</code>) and generic (<code>Dictionary</code>). The sorted variant of a dictionary (<code>SortedDictionary</code>) is available, as well. All of them were described in detail.</p>
<p>The mechanism of a hash table is presented in the following illustration:</p>
<div><div><img alt="Figure 10.6 – Illustration of mapping keys to particular values" src="img/B18069_10_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Illustration of mapping keys to particular values</p>
<p>Due to the great performance of the hash table, such a data structure is frequently used in many real-world applications, such as for <strong class="bold">associative arrays</strong>, <strong class="bold">database indices</strong>, or <strong class="bold">cache systems</strong>. Within this book, you saw how to create a <strong class="bold">phone book</strong> to store entries where a person’s name is a key and a phone number is a value. Among other examples, you developed an application that helps employees of shops <strong class="bold">find the location</strong> of where a <a id="_idIndexMarker915"/>product should be placed, and you applied the sorted dictionary to create a simple <strong class="bold">encyclopedia</strong>, where a user can <a id="_idTextAnchor396"/>ad<a id="_idTextAnchor397"/>d entries.</p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor398"/>Sets</h1>
<p>Another data structure from <a href="B18069_06.xhtml#_idTextAnchor195"><em class="italic">Chapter 6</em></a>, <em class="italic">Dictionaries and Sets</em>, is a <strong class="bold">set</strong>, which is a <strong class="bold">collection of distinct objects without duplicated elements and without any particular order</strong>. Therefore, you can only get to know whether a given element is in the set or not. The sets are strictly connected with <a id="_idIndexMarker916"/>mathematical models and operations, such as <strong class="bold">union</strong>, <strong class="bold">intersection</strong>, <strong class="bold">subtraction</strong>, and <strong class="bold">symmetric difference</strong>.</p>
<p>The exemplary sets, storing data of various types, are shown as follows:</p>
<div><div><img alt="Figure 10.7 – Illustration of sets with integer and string values" src="img/B18069_10_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Illustration of sets with integer and string values</p>
<p>While developing applications in the C# language, you can benefit from high-performance set-related operations provided by the <code>HashSet</code> class. As an example, you saw how to create a system that handles <strong class="bold">one-time promotional coupons</strong> and allows you to check whether the scanned one was already used. Another example was the <strong class="bold">reporting service</strong> for <a id="_idIndexMarker917"/>the system of a SPA center with four swimming pools. By using sets, you calculated statistics, such as the number of visitors to a pool, the most popular pool, and the number of people who visited at lea<a id="_idTextAnchor399"/>s<a id="_idTextAnchor400"/>t one pool.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor401"/>Trees</h1>
<p>The next topic is about <strong class="bold">trees</strong>, which were <a id="_idIndexMarker918"/>the subject of <a href="B18069_07.xhtml#_idTextAnchor233"><em class="italic">Chapter 7</em></a>, <em class="italic">Variants of Trees</em>. A tree consists of <strong class="bold">nodes</strong> with one <strong class="bold">root</strong>. The root contains no <strong class="bold">parent</strong> node, while all other nodes do. Moreover, each node can have any number of <strong class="bold">child nodes</strong>. The child <a id="_idIndexMarker919"/>nodes of the same parent can be called <strong class="bold">siblings</strong>, while a node without children is called a <strong class="bold">leaf</strong>. </p>
<p>An exemplary tree is shown here:</p>
<div><div><img alt="Figure 10.8 – Illustration of a tree" src="img/B18069_10_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Illustration of a tree</p>
<p>A tree is a data structure that is great for the representation of various data, such as the <strong class="bold">structure of a company</strong>, divided into a few departments, where each has its own structure. You also saw an example where a tree was used to arrange a <strong class="bold">simple quiz</strong> consisting of a few questions and answers, which are shown depending on the previously ta<a id="_idTextAnchor402"/>ken decisions.</p>
<p>Generally speaking, each node<a id="_idIndexMarker920"/> in a tree can contain any number of children. However, in the case of <strong class="bold">binary trees</strong>, a node cannot contain more than two children – that is, it can contain no child nodes, or only one or two. However, there are no rules about relationships between the nodes. The exemplary binary trees are shown here:</p>
<div><div><img alt="Figure 10.9 – Illustration of a binary tree and a binary search tree" src="img/B18069_10_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Illustration of a binary tree and a binary search tree</p>
<p>If you want to use a <strong class="bold">binary search tree</strong> (<strong class="bold">BST</strong>), the next<a id="_idIndexMarker921"/> rule is introduced. It states that, for any node, the values of all nodes in its left subtree must be smaller than its value, and that the values <a id="_idIndexMarker922"/>of all nodes in its right subtree must be greater than its value. The exemplary BST is presented on the right-hand side of the preceding illustration.</p>
<p>Another group of trees is called <strong class="bold">self-balancing trees</strong>, which <a id="_idIndexMarker923"/>keep a tree balanced all the time while adding and removing nodes. Their application is very important because it allows you to form the correctly arranged tree, which has a positive impact on performance. There are several variants of self-balancing trees, but <strong class="bold">AVL trees</strong> and <strong class="bold">red-black trees</strong> (<strong class="bold">RBTs</strong>) are some of the most popular.</p>
<p>One of the tree applications is related to processing strings, such as for <code>a</code> to <code>z</code>). When you go from the root to each node, you receive a string, which is either a saved word or its substring, as presented in the following illustration:</p>
<div><div><img alt="Figure 10.10 – Illustration of a trie" src="img/B18069_10_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Illustration of a trie</p>
<p>A <strong class="bold">heap</strong> is another subtype of a tree and exists in many variants, including a <strong class="bold">binary heap</strong>. It contains two versions – namely, <strong class="bold">min-heap</strong> and <strong class="bold">max-heap</strong>. For each of them, the additional property must be satisfied. For the min-heap, the value of each node must be greater than or equal to the value of its parent node. Thus, the root node contains the smallest <a id="_idIndexMarker924"/>value. For the max-heap, the value of each node must be less than or equal to the value of its parent node. Therefore, the root node always contains the largest value. The exemplary binary heaps are shown as follows:</p>
<div><div><img alt="Figure 10.11 – Illustration of a min-heap and max-heap" src="img/B18069_10_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Illustration of a min-heap and max-heap</p>
<p>A heap is a convenient data structure for implementing a <strong class="bold">priority queue</strong>. Another interesting application is <a id="_idIndexMarker925"/>the sorting algorithm<a id="_idTextAnchor403"/>, named <strong class="bold">heap sort</strong>, which was presented and explained in the chapter regarding arra<a id="_idTextAnchor404"/>ys and sorting.</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor405"/>Graphs</h1>
<p><a href="B18069_08.xhtml#_idTextAnchor296"><em class="italic">Chapter 8</em></a>, <em class="italic">Exploring Graphs</em>, was related to <strong class="bold">graphs</strong> – a very popular data structure with a broad range of applications. As a reminder, a graph is a data structure that consists of <strong class="bold">nodes</strong> and <strong class="bold">edges</strong>. Each edge connects two nodes. There are a few variants of edges in a graph, such as<a id="_idIndexMarker926"/> undirected and directed, as well as unweighted and weighted. A graph can be represented as an adjacency list or as an adjacency matrix.</p>
<p>All of these topics were described in the book, together with the problem of graph<strong class="bold"> traversal</strong> with breadth-first search and depth-first search algorithms, finding the <strong class="bold">minimum spanning tree</strong> with Kruskal’s and Prim’s algorithms, <strong class="bold">node coloring</strong>, and <strong class="bold">finding the shortest path</strong> in a graph with Dijkstra’s algorithm.</p>
<p>The exemplary graphs are shown in the following illustration:</p>
<div><div><img alt="Figure 10.12 – Illustration of graphs" src="img/B18069_10_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Illustration of graphs</p>
<p>A graph data structure is commonly used in various applications. It is also a great way to represent diverse data, such as the <strong class="bold">structure of friends</strong> available on a social media site. Here, the nodes can represent contacts, while edges represent relationships between people. Thus, you<a id="_idIndexMarker927"/> can easily check whether two contacts know each other or how many people should be involved to arrange a meeting between two particular people.</p>
<p>Another common application of graphs involves the problem of <strong class="bold">finding a path</strong>. As an example, you can use a graph to find a path between two points in the city, taking into account the distance or time necessary for driving. You can use a graph to represent a map of a city, where nodes are intersections and edges represent roads. You can assign weights to edges to indicate the necessary distance or time for driving a given road.</p>
<p>There are many other applications related to graphs. For instance, the minimum spanning tree can be used to create a <strong class="bold">plan of connections between buildings</strong> to supply all of them with a telecommunication cable at the smallest cost. The node coloring problem was used in the book for <strong class="bold">coloring voivodeships</strong> on a map of Poland according to the rule that two voivodeships that have common borders cannot have the same color. Another shown example involves Dijkstra’s algorithm for finding <strong class="bold">the shortest path in a game map</strong>, taking into account <a id="_idTextAnchor406"/>v<a id="_idTextAnchor407"/>arious obstacles.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor408"/>The last word</h1>
<p>You just reached the end of the last chapter of the book. First, the classification of data structures was presented, taking into account linear and non-linear data structures. In the first group, you can find arrays, lists, stacks, and queues, while the second group involves graphs and their subtypes, including trees and heaps. In the following part of this chapter, the diversity of applications of various data structures was taken into account. You saw a short summary of each described data structure, as well as information about some problems that can be solved with the use of a particular data structure, such as a queue or a graph. To make the content easier to understand, as well as to remind you of the various topics from the previous chapters, the summary was equipped with brief descriptions and illustrations of data structures.</p>
<p>In the introduction to this book, I invited you to start your adventure with data structures and algorithms. While reading the following chapters, writing hundreds of lines of code, and debugging, you had a chance to familiarize yourself with various data structures, starting with arrays and lists, through stacks, queues, dictionaries, and sets, and ending with trees and graphs. I hope that this book is only the first step in your long, challenging, and successful adventure with data structures and algorithms.</p>
<p>I would like to thank you for reading this book. If you have any questions or problems regarding the described content, please do not hesitate to contact me directly using the contact information shown at <a href="https://marcin.com">https://marcin.com</a>. While visiting my website, you can also find answers to many questions that you can ask during your development career. Please also tell me what topics are missing from this book that you want to learn about for the next edition of this book or from another of my books. I really hope that you will benefit from the presented content. I would like to wish you all the best in your career as a software developer, and I hope that you have many successful projects! I will be very happy if you let me know about your great projects, especially if they are inspired by the content of this book. Good luck and keep in touch!</p>
</div>
</body></html>