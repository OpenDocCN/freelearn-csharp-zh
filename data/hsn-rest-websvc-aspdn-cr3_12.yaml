- en: Implementing the Domain Logic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现领域逻辑
- en: This chapter focuses on the logic layer of the catalog web service. As previously
    discussed, the logic will be encapsulated in the `Catalog.Domain` project. The
    chapter shows how to implement the application logic using the service classes
    approach. The aim of these classes is to perform the mapping logic between the
    requests and the effective entities used on the data source layer and to provide
    all the additional logic needed by our application. Moreover, we will also see
    how to test the implemented code in order to verify the behaviors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍目录 Web 服务的逻辑层。如前所述，逻辑将被封装在 `Catalog.Domain` 项目中。本章展示了如何使用服务类方法实现应用程序逻辑。这些类的目的是在请求和数据源层实际使用的实体之间执行映射逻辑，并提供我们应用程序所需的所有附加逻辑。此外，我们还将看到如何测试实现代码以验证行为。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to implement the service classes for our application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现我们应用程序的服务类
- en: How to implement request DTOs and the related validation system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现请求 DTO 和相关的验证系统
- en: How to apply tests to verify the implemented logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何应用测试来验证实现的逻辑
- en: 'The code in the following chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节中的代码可在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3)。
- en: Implementing service classes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务类
- en: Let's proceed with the concrete part of the chapter by implementing the service
    classes. This layer of abstraction will define the methods that query the data
    layer, including the `IItemRepository` interface, and map the resulting data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现服务类来继续本章的具体部分。这一层抽象将定义查询数据层的各种方法，包括 `IItemRepository` 接口，并将结果数据映射。
- en: 'As mentioned previously, our service implementation will use DTO classes in
    order to pass the data through the stack. First of all, let''s define the request
    classes needed by our service. To do that, we can start by creating a new `Requests/Item`
    folder structure in the `Catalog.Domain` project, and by adding a new `AddItemRequest.cs`
    file in the folder:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的服务实现将使用 DTO 类来通过堆栈传递数据。首先，让我们在 `Catalog.Domain` 项目中创建一个新的 `Requests/Item`
    文件夹结构，并在文件夹中添加一个新的 `AddItemRequest.cs` 文件：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code defines the add item request. The class is very similar to
    the `Item` entity class, except that the `Id` field, the `Artist` field, and the
    `Genre` field are not present. Furthermore, the `Id` field will be generated by
    the EF Core implementation, and the `Artist` and `Genre` fields are handled by
    the ORM in order to represent the relationship between the entities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了添加项目请求。该类与 `Item` 实体类非常相似，除了 `Id` 字段、`Artist` 字段和 `Genre` 字段不存在。此外，`Id`
    字段将由 EF Core 实现，`Artist` 和 `Genre` 字段由 ORM 处理，以表示实体之间的关系。
- en: 'In the same way, we can proceed by defining the `EditItemRequest` class in
    the same folder:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在同一文件夹中定义 `EditItemRequest` 类：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also in the preceding snippet, the class contains the same fields used by the
    `Item` entity, except for the `Artist` and `Genre` fields, for the same reason
    described earlier. As you can understand from the class name, it represents the
    update item operation. The same approach can be taken for the get item operation
    shown as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，该类包含与 `Item` 实体相同的字段，除了 `Artist` 和 `Genre` 字段，原因与前面描述的相同。正如您可以从类名中理解的那样，它代表更新项目操作。同样的方法也可以用于以下所示获取项目操作：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It may seem a little bit redundant, defining a request class for a single field.
    Despite that, we should consider that the HTTP requests received by our service
    may vary over time. Therefore, this approach guarantees us being able to evolve
    our requests without adding tons of parameters to the methods of the service class.
    On top of that, representing our incoming requests as classes provides an easy
    way to version the different request types evolving over time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来有点冗余，为单个字段定义一个请求类。尽管如此，我们应该考虑我们的服务收到的 HTTP 请求可能会随时间变化。因此，这种方法确保我们能够在不向服务类的各种方法添加大量参数的情况下，使我们的请求能够进化。此外，将我们的传入请求表示为类提供了一个轻松的方式来版本化随时间演变的不同的请求类型。
- en: 'Let''s continue by also defining the response classes used by our service classes.
    Also, in the case of the response classes, it is essential to understand that
    this approach guarantees us a way to avoid exposing all the fields to the client
    of our web service. As a first step, we need to define a new `Responses` folder
    in the `Catalog.Domain` project, and create the following classes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续定义我们的服务类所使用的响应类。此外，在响应类的案例中，理解这一点至关重要：这种方法确保我们有一种避免向我们的网络服务客户端暴露所有字段的方法。作为第一步，我们需要在`Catalog.Domain`项目中定义一个新的`Responses`文件夹，并创建以下类：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For brevity, I''ve defined the implementation of the `PriceResponse`, `GenreResponse`,
    and `ArtistResponse` classes in a unique snippet of code. Those classes define
    the field used by the same entity classes we use on the database side. On top
    of that, we will also define an `ItemReposonse` class, which represents the response
    of our service:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我已将`PriceResponse`、`GenreResponse`和`ArtistResponse`类的实现定义在一个代码片段中。这些类定义了在数据库端使用的相同实体类所使用的字段。除此之外，我们还将定义一个`ItemReposonse`类，它代表我们的服务响应：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ItemResponse` class refers to the other response classes in order to avoid
    a mismatch between the response data contained in the related entities. Furthermore,
    the `IItemRepository` implementation will load all the data of the related entities
    using the `Include` extension method we looked at in the previous chapter, and,
    as we will see later, the data will be mapped into the response types.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemResponse`类引用其他响应类，以避免相关实体中包含的响应数据不匹配。此外，`IItemRepository`实现将使用我们在上一章中查看的`Include`扩展方法加载相关实体的所有数据，并且，正如我们稍后将看到的，数据将被映射到响应类型中。'
- en: The service class interface
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务类接口
- en: 'Since we have defined all the requests and response types needed by our service,
    we are now able to proceed by defining the `IItemService` interface and its implementation.
    As a first step, we can create a new `Services` folder in the `Catalog.Domain`
    project and proceed by defining the following `IItemService` interface:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经定义了我们的服务所需的所有请求和响应类型，我们现在可以通过定义`IItemService`接口及其实现来继续前进。作为第一步，我们可以在`Catalog.Domain`项目中创建一个新的`Services`文件夹，并定义以下`IItemService`接口：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding definition exposes the methods needed by our application. First
    of all, we should notice that all the functions return a `Task<T>` generic type.
    We can also see that all the methods end with the `Async` prefix, which suggests
    that the implementation will be asynchronous.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义暴露了我们的应用程序所需的方法。首先，我们应该注意到所有函数都返回一个`Task<T>`泛型类型。我们还可以看到所有方法都以`Async`前缀结尾，这表明实现将是异步的。
- en: Implementing the mapping layer
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现映射层
- en: 'This subsection and the following one describe the implementation of two mapping
    approaches we can use in our application: the *manual approach* and the *reflection
    approach*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节和下一小节描述了我们可以在我们应用程序中使用的两种映射方法的实现：*手动方法*和*反射方法*。
- en: 'The *manual approach* involves the definition and implementation of our own
    mapper classes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*手动方法*涉及定义和实现我们自己的映射类：'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code defines an `IItemMapper` interface, which provides two methods
    to map `AddItemRequest` and `EditItemRequest` in the `Item` type. In addition,
    it also defines the mapping method signature to convert an `Item` type into an
    `ItemResponse` instance. This strategy can be implemented with the following `ItemMapper`
    class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个`IItemMapper`接口，它提供了两个方法来映射`Item`类型中的`AddItemRequest`和`EditItemRequest`。此外，它还定义了将`Item`类型转换为`ItemResponse`实例的映射方法签名。这种策略可以通过以下`ItemMapper`类实现：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Please notice that, for brevity, I''ve omitted all the fields of the entity
    defined in the mapping, you can find the full mapper class file in the following
    repository [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3/tree/master/Chapter09/Catalog](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3/tree/master/Chapter09/Catalog).
    Both the `IItemMapper` interface and the `ItemMapper` class are located in a `Mappers`
    folder in the `Catalog.Domain` project. The `ItemMapper` implementation requires
    a bit of overhead in terms of development, but it performs exactly what you need
    without any runtime costs, such as reflection. On top of that, the logic is encapsulated
    in separate classes. The same approach can be applied to the `ItemResponse` mapping
    – in this case, we will also need to create some isolated mappers for the `Artist`
    and the `Genre` entities:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了简洁，我已经省略了映射中定义的实体所有字段，你可以在以下存储库中找到完整的映射类文件[https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3/tree/master/Chapter09/Catalog](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3/tree/master/Chapter09/Catalog)。`IItemMapper`接口和`ItemMapper`类都位于`Catalog.Domain`项目的`Mappers`文件夹中。`ItemMapper`实现需要在开发方面投入一些开销，但它可以精确地完成你所需要的功能，而不产生任何运行时成本，例如反射。除此之外，逻辑被封装在单独的类中。同样的方法也可以应用于`ItemResponse`映射——在这种情况下，我们还需要为`Artist`和`Genre`实体创建一些隔离的映射器：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For brevity reasons, I''ve included the interface and the concrete implementation
    in a unique snippet of code. `IArtistMapper` exposes a method called `Map`, which
    initializes a new `ArtistResponse` given an `Artist` entity class. This approach
    will be the same for the `Genre` entity:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我将接口和具体实现包含在一个独特的代码片段中。`IArtistMapper`公开了一个名为`Map`的方法，它根据`Artist`实体类初始化一个新的`ArtistResponse`。对于`Genre`实体，这种方法将是相同的：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, in this case, we define `Genre` as `GenreResponse` mapping. Both these
    mapping classes can be used independently or referred by other mappers. Once we
    have implemented the `Artist` and `Genre` mapping logic, we can refer them into
    `IItemMapper` in order to define the implementation of the `ItemReponse Map(Item
    item)` mapping method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这种情况下，我们将`Genre`定义为`GenreResponse`映射。这两个映射类都可以独立使用或被其他映射器引用。一旦我们实现了`Artist`和`Genre`的映射逻辑，我们就可以将它们引用到`IItemMapper`中，以便定义`ItemReponse
    Map(Item item)`映射方法的实现：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have changed the `ItemMapper` implementation class and we have combined the
    dependencies with the `IArtistMapper` and `IGenreMapper` interfaces. Furthermore,
    we can use the `Map` method we've just defined to create `ItemResponse` instances
    based on the `Item` entities. You may have noticed that I haven't implemented
    the mapping class for `PriceResponse`. This is because an entity such as `Price`
    is unlikely to change. Another crucial part to notice is that we are missing the
    initialization of the dependency injection between the mapper interfaces and their
    implementation; this part will be covered later in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了`ItemMapper`实现类，并将依赖项与`IArtistMapper`和`IGenreMapper`接口相结合。此外，我们可以使用我们刚刚定义的`Map`方法来根据`Item`实体创建`ItemResponse`实例。你可能已经注意到，我没有为`PriceResponse`实现映射类。这是因为像`Price`这样的实体不太可能发生变化。另一个需要注意的关键部分是，我们在映射接口及其实现之间缺少依赖注入的初始化；这部分将在本章后面进行介绍。
- en: 'Finally, I want to specify that this is not the only way to implement the mapping
    layer in our application. In fact, there are also other patterns, for example,
    using extension methods. Let''s take as an example, `Artist` to `ArtistResponse`
    mapping:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想明确指出，这并不是实现映射层在我们应用程序中的唯一方法。实际上，还有其他模式，例如使用扩展方法。让我们以`Artist`到`ArtistResponse`的映射为例：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code defines a new `MappingExtensions` static class, which can
    be used as a container for all the extension methods we need for the mapping logic.
    Furthermore, it is possible to define a `MapToResponse` extension method that
    can be applied to the `Artist` entity in the following way:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个新的`MappingExtensions`静态类，它可以作为所有我们需要用于映射逻辑的扩展方法的容器。此外，我们还可以定义一个`MapToResponse`扩展方法，可以应用于以下方式中的`Artist`实体：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The extension methods approach can be applied to all the entities of the domain
    model. Although it seems a lot more immediate, it doesn't highlight the dependency
    between the services classes and the mapping logic. Therefore, I prefer implementing
    mapping through the use of separate classes because it provides a better way to
    understand the dependency flow of the application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法方法可以应用于领域模型的所有实体。尽管这种方法看起来更加直接，但它没有突出显示服务类与映射逻辑之间的依赖关系。因此，我更喜欢通过使用单独的类来实现映射，因为它提供了更好地理解应用程序依赖流的方式。
- en: Mapping logic using Automapper
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Automapper 的映射逻辑
- en: 'An alternative way is to implement the mapping using the `Automapper` NuGet
    package. As mentioned in [Chapter 5](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml),
    *Web Service Stack in ASP.NET Core*, this approach uses the reflection system
    provided by .NET in order to match and to map the fields of our classes. It is
    possible to add the `Automapper` package to the `Catalog.Domain` project using
    the following CLI instruction:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `Automapper` NuGet 包来实现映射。如[第5章](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml)中所述，“ASP.NET
    Core中的Web服务堆栈”，这种方法利用.NET提供的反射系统来匹配和映射我们类中的字段。可以使用以下CLI指令将 `Automapper` 包添加到 `Catalog.Domain`
    项目中：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Automapper uses a profile-based structure in order to define the mapping behaviors
    of our classes. Let''s proceed by defining a new `CatalogProfile` class in the
    `Mappers` folder:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Automapper 使用基于配置的结构来定义我们类的映射行为。让我们继续在 `Mappers` 文件夹中定义一个新的 `CatalogProfile`
    类：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding profile will be used by the dependency injection engine to define
    the lists of mapping behaviors. The `CreateMap` method provided by the `Profile`
    base class matches two generic types: `TSource` and `TDestination`. It will be
    possible to also perform the reverse process by chaining the `ReverseMap()` extension
    method. This can be applied for every request and response type we define in the
    application. In order to use the mapping logic in our methods, it is necessary
    to inject the `IMapper` type into the target class and execute the `Map` method
    in the following way:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将由依赖注入引擎用于定义映射行为的列表。`Profile` 基类提供的 `CreateMap` 方法匹配两个泛型类型：`TSource` 和 `TDestination`。通过链式调用
    `ReverseMap()` 扩展方法，也可以执行反向过程。这可以应用于我们在应用程序中定义的每个请求和响应类型。为了在我们的方法中使用映射逻辑，必须将 `IMapper`
    类型注入到目标类中，并按以下方式执行 `Map` 方法：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is important to notice that the `Map` method will throw a runtime exception
    in the following cases:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在以下情况下，`Map` 方法将抛出运行时异常：
- en: The type of the source and the destination of the mapping don't correspond
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射的源和目标类型不对应
- en: The corresponding source and destination mapping is not explicitly defined in
    a profile
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应的源和目标映射在配置中未显式定义
- en: There are some unmapped members in the entities (this prevents accidental `null`
    fields in the destination of the mapping)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体中存在一些未映射的成员（这防止了映射目标中的意外 `null` 字段）
- en: Finally, Automapper also requires initialization using the dependency injection
    of .NET Core. We will see how to add `Automapper` in the DI engine later in this
    chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Automapper 还需要使用 .NET Core 的依赖注入进行初始化。我们将在本章后面看到如何将 `Automapper` 添加到 DI 引擎中。
- en: The service class implementation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务类实现
- en: 'Once the mapper layer is completed, we can proceed by implementing the service
    layer. Let''s start by defining the `ItemService.cs` file in the `Services` folder
    of the `Catalog.Domain` project. The following code describes the implementation
    of the constructor method and the reading operations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成映射层，我们就可以继续实现服务层。让我们首先在 `Catalog.Domain` 项目的 `Services` 文件夹中定义 `ItemService.cs`
    文件。以下代码描述了构造函数方法和读取操作：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First of all, we can see that the class refers to both the `IItemRepository`
    and the `IItemMapper` interfaces, which are injected using the constructor injection
    technique. The snippet also describes the implementation of the `GetItemsAsync`
    and `GetItemAsync` functions. Both methods use the `IItemRepository` interface
    to retrieve data from the data source, and the `IItemMapper` interface to perform
    the mapping between the `Item` entity and `ItemResponse`. The same approach can
    be taken by the writing operations, which are implemented with the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以看到该类同时引用了 `IItemRepository` 和 `IItemMapper` 接口，这些接口是通过构造函数注入技术注入的。这个小节还描述了
    `GetItemsAsync` 和 `GetItemAsync` 函数的实现。这两个方法都使用 `IItemRepository` 接口从数据源检索数据，并使用
    `IItemMapper` 接口在 `Item` 实体和 `ItemResponse` 之间进行映射。编写操作也可以采用相同的方法，具体实现如下：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Also, in the case of the writing operations, they use the `IItemMapper` instance
    to map the request's type with the `Item` entity type and to retrieve the `ItemResponse`
    type. In addition, they perform the operations by calling the `IItemRepository`
    instance, and subsequently, they call the `SaveChangesAsync` method to apply those
    changes to the database. Once we have implemented the service layer, we can proceed
    by testing the class and verifying the implementation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在写入操作的情况下，它们使用 `IItemMapper` 实例将请求的类型与 `Item` 实体类型进行映射，并检索 `ItemResponse`
    类型。此外，它们通过调用 `IItemRepository` 实例执行操作，随后调用 `SaveChangesAsync` 方法将那些更改应用到数据库中。一旦我们实现了服务层，我们就可以继续测试该类并验证实现。
- en: Testing the service layer
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务层
- en: This section covers the testing of the service layer part implemented previously.
    As we did in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building
    the Data Access Layer*, we need to set up a mock catalog context that provides
    the data necessary for testing the service classes. The `Catalog.Infrastructure`
    project already has its own implementation of the `TestCatalogContext` class and
    the `ModelBuilderExtensions` class. Furthermore, we can use the same two classes
    to implement the tests for the service layer. What we need is just a bit of refactoring
    and optimization on the `Catalog.Infrastructure` project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了之前实现的服务层部分的测试。正如我们在[第8章](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml)，“构建数据访问层”中所做的那样，我们需要设置一个模拟的目录上下文，为测试服务类提供必要的数据。`Catalog.Infrastructure`
    项目已经实现了自己的 `TestCatalogContext` 类和 `ModelBuilderExtensions` 类。此外，我们可以使用这两个相同的类来实现服务层的测试。我们需要的只是对
    `Catalog.Infrastructure` 项目进行一点重构和优化。
- en: Refactoring testing classes
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构测试类
- en: 'After implementing the `ItemsRepositoryTests` type, in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    *Building the Data Access Layer*, you might notice that we are using a recurring
    pattern in the `ItemRepositoryTests` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了 `ItemsRepositoryTests` 类型后，在[第8章](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml)，“构建数据访问层”中，你可能会注意到我们在
    `ItemRepositoryTests` 类中使用了重复的模式：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding snippet has been replicated in every test method written up to
    now. It is possible to improve our test code by extracting the implementation
    in a different type. The `xunit` framework provides a way to share test contexts
    between test methods of the same test class by providing an interface called `IClassFixture`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的小节内容已经复制到迄今为止编写的每一个测试方法中。我们可以通过将实现提取到不同的类型来改进我们的测试代码。`xunit` 框架通过提供一个名为 `IClassFixture`
    的接口，提供了一种在同一个测试类的方法之间共享测试上下文的方法。
- en: '`IClassFixture` is a generic type that constitutes a single test context and
    shares it among all the test methods in the class. Hence, the `xunit` framework
    cleans up the fixture after all the tests in the class have completed. The `IClassFixture`
    interface we are going to implement will be used by both the `Catalog.Infrastructure.Tests`
    project and the `Catalog.Domain.Tests` project. Therefore, we can commonize the
    implementation in a unique `Catalog.Fixtures` project.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`IClassFixture` 是一个泛型类型，它构成一个单独的测试上下文，并在类中的所有测试方法之间共享。因此，`xunit` 框架在类中的所有测试完成后清理固定装置。我们将要实现的
    `IClassFixture` 接口将被 `Catalog.Infrastructure.Tests` 项目和 `Catalog.Domain.Tests`
    项目使用。因此，我们可以在一个独特的 `Catalog.Fixtures` 项目中通用化实现。'
- en: 'Let''s proceed by creating the new project in the `tests` folder:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `tests` 文件夹中创建新的项目开始：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding instructions create a new `Catalog.Fixtures` project and add
    it to the solution. After that, we can proceed by adding the dependencies:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令创建了一个新的 `Catalog.Fixtures` 项目并将其添加到解决方案中。之后，我们可以继续添加依赖项：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we can move all the classes previously implemented in the `Catalog.Infrastructure.Tests`
    project into the new `Catalog.Fixtures` project just created: `TestCatalogContext.cs`,
    `Extensions/ModelBuilderExtensions.cs`, and all `.json` files.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将之前在 `Catalog.Infrastructure.Tests` 项目中实现的全部类移动到刚刚创建的 `Catalog.Fixtures`
    项目中：`TestCatalogContext.cs`、`Extensions/ModelBuilderExtensions.cs` 以及所有 `.json`
    文件。
- en: 'Let''s continue by creating a new `CatalogContextFactory` class, which will
    be referred by the `IClassFixture` interface:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的 `CatalogContextFactory` 类，该类将被 `IClassFixture` 接口引用：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `CatalogContextFactory` class defines a new instance of `TestCatalogContext`
    using the previously assigned `contextOptions` object. It is necessary to notice
    that we are building `ContextOptions` using `Guid.NewGuid().ToString()` property
    as a database name in order to provide a new, clean in-memory instance for each
    test class. In addition, the class also initializes the three attributes of type
    `IGenreMapper`, `IArtistMapper`, and `IItemMapper` which will be used by the service
    layer tests in order to perform the mapping of the fields.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`CatalogContextFactory` 类使用先前分配的 `contextOptions` 对象定义了一个新的 `TestCatalogContext`
    实例。需要注意的是，我们正在使用 `Guid.NewGuid().ToString()` 属性作为数据库名来构建 `ContextOptions`，以便为每个测试类提供一个新的、干净的内存实例。此外，该类还初始化了三个类型为
    `IGenreMapper`、`IArtistMapper` 和 `IItemMapper` 的属性，这些属性将被服务层测试用于执行字段的映射。'
- en: 'It is, therefore, possible to access the instance of the factory class in our
    tests by using the following constructor injection approach:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在测试中使用以下构造函数注入方法来访问工厂类的实例：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `IClassFixture` interface contains the reference to the factory class just
    created. The dependency will be resolved at runtime through the constructor of
    the test class. Note that the entire instance is shared between each unique test
    class. Therefore, each test method in the test class will share the same database
    snapshot with the other method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`IClassFixture` 接口包含对刚刚创建的工厂类的引用。依赖关系将在测试类的构造函数中运行时解析。请注意，整个实例在各个唯一的测试类之间是共享的。因此，测试类中的每个测试方法都将与其他方法共享相同的数据库快照。'
- en: 'Finally, we can refactor the `ItemRepositoryTests` class in order to use the
    new `CatalogContextFactory` implementation. For example, if we take as reference
    the `should_add_new_item` test method, we can proceed in the following way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以重构 `ItemRepositoryTests` 类以使用新的 `CatalogContextFactory` 实现。例如，如果我们以 `should_add_new_item`
    测试方法为参考，我们可以按以下方式进行：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `_sut` class attribute is used to perform the actual operation we want to
    test. For example, in the test case above, we are verifying the `Add` method exposed
    by the `ItemRepository` class. The `_context` attribute is used to verify the
    result. This approach guarantees the reusability of our test code between the
    different test classes by providing the tests with better maintainability. All
    the data is provided by the `CatalogContextFactory` type, which uses the in-memory
    database technique provided by ASP.NET Core to store data in memory and simulates
    the data operation on a real database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`_sut` 类属性用于执行我们想要测试的实际操作。例如，在上面的测试用例中，我们正在验证 `ItemRepository` 类公开的 `Add` 方法。`_context`
    属性用于验证结果。这种方法通过为测试提供更好的可维护性，确保了我们的测试代码在不同测试类之间的可重用性。所有数据都由 `CatalogContextFactory`
    类型提供，该类型使用 ASP.NET Core 提供的内存数据库技术将数据存储在内存中，并模拟对真实数据库的数据操作。'
- en: As we did for the `ItemRepositoryTests` class, we will also see how to use the
    `CatalogContextFactory` class in the service layer tests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 `ItemRepositoryTests` 类中所做的那样，我们还将看到如何在服务层测试中使用 `CatalogContextFactory`
    类。
- en: 'The code in this section is available in the following GitHub repository: [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码可在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3)。
- en: Implementing the ItemService tests
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 ItemService 测试
- en: 'Let''s continue by implementing the `ItemService` test part. As a first step,
    we should proceed by creating a new `Catalog.Domain.Tests` project in the `tests`
    folder using the following CLI instruction:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过实现 `ItemService` 测试部分来继续。首先，我们应该通过在 `tests` 文件夹中使用以下 CLI 指令创建一个新的 `Catalog.Domain.Tests`
    项目来开始：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding command creates a new `Catalog.Domain.Tests` project in the `tests`
    folder. Therefore, we can proceed by adding the new project to the solution using
    the following instruction:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在`tests`文件夹中创建了一个新的`Catalog.Domain.Tests`项目。因此，我们可以通过以下指令将新项目添加到解决方案中：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Additionally, the test project has some dependencies. Furthermore, we can proceed
    by adding the reference using the following command to the `Catalog.Domain.Tests`
    folder:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，测试项目还有一些依赖项。此外，我们可以通过以下命令将引用添加到`Catalog.Domain.Tests`文件夹中：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After that, we create a new `ItemServiceTests.cs` file with the following implementation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建一个新的`ItemServiceTests.cs`文件，其实现如下：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code tests the implementation of the reading operations of the
    `ItemService` class. The `ItemServiceTests` class uses the `CatalogContextFactory`
    type to initialize and get the base data used by the service. Each test method
    uses the `_itemRepository` class property and the `_mapper` instance to initialize
    a new `ItemService` and verify the `GetItemAsync` and the `GetItemsAsync` methods
    provided by the service class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码测试了`ItemService`类读取操作的实现。`ItemServiceTests`类使用`CatalogContextFactory`类型来初始化并获取服务所使用的基本数据。每个测试方法都使用`_itemRepository`类属性和`_mapper`实例来初始化一个新的`ItemService`并验证由服务类提供的`GetItemAsync`和`GetItemsAsync`方法。
- en: 'In the same way, we can use the same technique to implement the writing operation
    tests:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用相同的技巧来实现写入操作的测试：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `additem_should_add_the_entity` and `edititem_should_edit_the_entity` methods
    are verifying both the `IItemMapper` logic implementation and also the `IItemService`
    implementation. This approach can be used to test the logic of the service classes
    layer. In this case, the mapping logic is not so complex. Besides, I suggest also
    implementing separate tests in the case of a more complex mapping logic.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`additem_should_add_the_entity`和`edititem_should_edit_the_entity`方法正在验证`IItemMapper`逻辑实现以及`IItemService`实现。这种方法可以用来测试服务类层的逻辑。在这种情况下，映射逻辑并不复杂。此外，我还建议在映射逻辑更复杂的情况下实现单独的测试。'
- en: 'Finally, we can run the test cases we''ve just implemented by executing the
    `dotnet test` CLI instruction in the solution folder, or by using our preferred
    IDE test runner. The CLI result should be similar to this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在解决方案文件夹中通过执行`dotnet test` CLI指令或在首选的IDE测试运行器中运行我们刚刚实现的测试用例。CLI结果应该类似于以下内容：
- en: '![](img/43a9d778-e29d-47e7-92c4-d90d8836bdde.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43a9d778-e29d-47e7-92c4-d90d8836bdde.png)'
- en: The preceding report lists all the tests executed by the `dotnet test` command,
    and it provides an overview of the successful and failed tests. Furthermore, it
    is also possible to specify the verbosity of the test by appending the `-v` option
    next to the `dotnet test -v <q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]>`
    command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述报告列出了由`dotnet test`命令执行的测试，并提供了成功和失败测试的概述。此外，还可以通过在`dotnet test -v <q[uiet],
    m[inimal], n[ormal], d[etailed], and diag[nostic]>`命令旁边附加`-v`选项来指定测试的详细程度。
- en: Implementing request model validation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现请求模型验证
- en: The `Catalog.Domain` project also owns the validation logic of our request models*.*
    In this section, we will see how to implement the request validation logic part,
    which will be also used by our controllers in order to validate the incoming data.
    Here, I usually rely on the `FluentValidation` package, which provides a really
    readable way to perform validation checks on every type of object and data structure.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Catalog.Domain`项目也拥有我们请求模型的验证逻辑。在本节中，我们将看到如何实现请求验证逻辑部分，这部分也将被我们的控制器用来验证传入的数据。在这里，我通常依赖于`FluentValidation`包，它提供了一种非常易于阅读的方式来对每种类型的对象和数据结构执行验证检查。'
- en: 'In order to add the `FluentValidation` package to our `Catalog.Domain` project,
    we can execute the following commands in the project folder:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`FluentValidation`包添加到我们的`Catalog.Domain`项目中，我们可以在项目文件夹中执行以下命令：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `FluentValidation` package exposes the `AbstractValidation` class, which
    can be extended to implement our custom validation criteria for a request model
    class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`FluentValidation`包公开了`AbstractValidation`类，它可以被扩展以实现针对请求模型类的自定义验证标准：'
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These validator classes are located in the `Requests/Item/Validators` path.
    Let''s proceed by analyzing some of the validation criteria implemented in the
    `AddItemRequestValidator` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些验证类位于`Requests/Item/Validators`路径。让我们通过分析`AddItemRequestValidator`类中实现的一些验证标准来继续：
- en: The `GenreId` and `ArtistId` fields are required because a vinyl always has
    this kind of information.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenreId`和`ArtistId`字段是必需的，因为黑胶唱片总是有这类信息。'
- en: The class uses the same `NotEmpty` method on the `Name`, `ReleaseDate`, and
    `Price` fields.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类在`Name`、`ReleaseDate`和`Price`字段上使用相同的`NotEmpty`方法。
- en: The `Amount` field of the `Price` class should always be greater than 0\. The
    validator class uses the `Must` method to apply this rule.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Price`类的`Amount`字段始终应该大于0。验证器类使用`Must`方法应用此规则。'
- en: 'The same approach is taken for the `EditItemRequestValidator` class, except
    for the `Id` field, which is defined as required for the updated process of an
    entity. The fluent way of working is really useful for different reasons: it is
    ready to read, easy to maintain, and really helpful when we want to test logic.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`EditItemRequestValidator`类，采用相同的方法，除了`Id`字段，它在实体的更新过程中被定义为必需的。流畅的工作方式确实非常有用，原因有很多：它易于阅读，易于维护，并且在我们想要测试逻辑时非常有帮助。
- en: Testing request model validation
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试请求模型验证
- en: As mentioned, the `FluentValidation` package provides an excellent way to test
    our validation criteria.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`FluentValidation`包提供了一种出色的方式来测试我们的验证标准。
- en: The `AddItemRequestValidator` and `EditItemRequestValidator` classes implement
    elementary checks. Furthermore, it may be useful to cover them with some tests
    to document the logic implemented in these classes. `FluentValidation` provides
    a `TestHelper` class that provides the assertion conditions necessary to verify
    the behavior of our validation logic.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddItemRequestValidator`和`EditItemRequestValidator`类实现了基本检查。此外，可能有用的是用一些测试来覆盖它们，以记录这些类中实现的逻辑。`FluentValidation`提供了一个`TestHelper`类，它提供了验证我们验证逻辑行为的必要断言条件。'
- en: 'Let''s see how to do some unit tests for the `AddItemRequestValidator` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为`AddItemRequestValidator`类进行一些单元测试：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The test class defined in the preceding code verifies that `AddItemRequestValidator`
    triggers a validation error if the `GenreId` or `ArtistId` fields are null. It
    uses the `ShouldHaveValidationErrorFor` extension method exposed by the `TestHelper`
    class to verify the behavior. The `ShouldHaveValidationErrorFor` method also exposes
    an `IEnumerable` of `ValidationError`, which can be used to check the details
    of each message of type `ValidationError`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码中定义的测试类验证了如果`GenreId`或`ArtistId`字段为空，则`AddItemRequestValidator`会触发验证错误。它使用`TestHelper`类公开的`ShouldHaveValidationErrorFor`扩展方法来验证行为。`ShouldHaveValidationErrorFor`方法还公开了一个`IEnumerable`的`ValidationError`，可以用来检查类型为`ValidationError`的每个消息的详细信息。
- en: Dependencies registration
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项注册
- en: 'In this chapter, we have seen how to implement mapper classes, validators,
    and service classes. All these types work together using the dependency injection
    of .NET Core. Dependency registration usually happens through the use of extension
    methods that group the registered classes by following some criteria. In this
    case, I will group the registered classes in the following way:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何实现映射类、验证器和服务类。所有这些类型都通过.NET Core的依赖注入一起工作。依赖项注册通常通过使用按某些标准分组注册类的扩展方法来完成。在这种情况下，我将按以下方式分组注册的类：
- en: Services refer to all the service interfaces and classes defined in the `Catalog.Domain`
    project
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务指的是在`Catalog.Domain`项目中定义的所有服务接口和类。
- en: Mappers refer to all the mapper classes defined in the `Catalog.Domain` project
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mappers指的是在`Catalog.Domain`项目中定义的所有映射类。
- en: Validations refer to all the fluent validation requirements and dependencies
    used by the application
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证指的是应用程序使用的所有流畅验证要求和依赖项。
- en: 'Now that we have defined the logic behind the separation of dependency registration,
    we can proceed by defining a new `DependencyRegistration` static class in the
    `Extensions` folder in the `Catalog.Domain` project:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了依赖项分离背后的逻辑，我们可以在`Catalog.Domain`项目的`Extensions`文件夹中定义一个新的`DependencyRegistration`静态类来继续：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code defines three extension methods, one for each group: `AddMappers`,
    `AddServices`, and `AddValidation`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了三个扩展方法，每个组一个：`AddMappers`、`AddServices`和`AddValidation`。
- en: The `AddMappers` extension method registers the mapper instances using a *singleton*
    life cycle, therefore, the mappers do not have any kind of dependency and they
    don't perform any request-related operation. On the other side, the `AddServices`
    extension method uses a scoped life cycle because the service classes depend on
    the repositories that perform I/O operations on the database. Finally, the `AddValidation`
    extension method is chained with `IMvcBuilder` and is strictly dependent on the
    MVC stack.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddMappers` 扩展方法使用 *单例* 生命周期来注册映射实例，因此，映射器没有任何依赖，也不执行任何与请求相关的操作。另一方面，`AddServices`
    扩展方法使用作用域生命周期，因为服务类依赖于在数据库上执行 I/O 操作的仓储。最后，`AddValidation` 扩展方法与 `IMvcBuilder`
    链接，并且严格依赖于 MVC 堆栈。'
- en: Furthermore, it uses the `AddFluentValidation` method provided by the `FluentValidation`
    package in order to register all the validation classes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它使用 `FluentValidation` 包提供的 `AddFluentValidation` 方法来注册所有验证类。
- en: 'In conclusion, we can register the dependencies of our application in the following
    way:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以以下方式注册应用程序的依赖项：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Lastly, we can now verify the implementations written during this chapter by
    again running a `dotnet test` command in the solution folder, or by executing
    the test runner of our preferred IDE.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过在解决方案文件夹中再次运行 `dotnet test` 命令，或者执行我们首选 IDE 的测试运行器来验证本章编写的实现。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The `Catalog.Domain` project now contains the core logic of the entire application.
    Although the logic implemented in the `Domain` project is still quite simple,
    later on in this book, it will become more complex.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Catalog.Domain` 项目现在包含整个应用程序的核心逻辑。尽管在 `Domain` 项目中实现的逻辑仍然相当简单，但在这本书的后续部分，它将变得更加复杂。'
- en: 'The topics covered in this chapter included some of the concepts related to
    the domain logic implementation of a web service: how to implement the service
    and the mapping classes, how to implement the request validation process using
    a fluent approach, and finally, how to test our code using some unit testing techniques.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括一些与 Web 服务领域逻辑实现相关的概念：如何实现服务和映射类，如何使用流畅的方法实现请求验证过程，以及最后如何使用一些单元测试技术来测试我们的代码。
- en: The next chapter will look into all the HTTP parts of the application. Furthermore,
    we will focus on the `Catalog.API` project, and how to put together the data access,
    the service, and the API layers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨应用程序的所有 HTTP 部分。此外，我们将关注 `Catalog.API` 项目，以及如何组合数据访问、服务和 API 层。
