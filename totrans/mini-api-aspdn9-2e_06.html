<html><head></head><body>
  <div id="_idContainer044">
   <h1 class="chapter-number" id="_idParaDest-77">
    <a id="_idTextAnchor105">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     6
    </span>
   </h1>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor106">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Parameter Binding
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Context is a critical aspect of any API.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     The client has their own understanding of how data is structured, as does the server.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     For example, as the client, you will view API documentation that tells you to format a request payload in JSON format.
    </span>
    <span class="koboSpan" id="kobo.3.4">
     You therefore create the JSON payload as per the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      API requirements.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     When the API receives your payload, it is not guaranteed that the object you transmitted will remain as JSON (especially in an ASP.NET API), and a mechanism will often be in place to bind the JSON object to a strongly typed .NET object that the API can manipulate more easily within its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      own context.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     Let us take another example.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     You (still as the client) make a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.8.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.9.1">
     request for all logs corresponding to a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.10.1">
      job
     </span>
    </em>
    <span class="koboSpan" id="kobo.11.1">
     with a particular ID.
    </span>
    <span class="koboSpan" id="kobo.11.2">
     However, you want to restrict the number of logs returned to 100, which the API allows you to do.
    </span>
    <span class="koboSpan" id="kobo.11.3">
     According to the API documentation, you can do this by including the job ID in the route, and an option in the query string specifying how many logs you wish
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      to return.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.13.1">
     When receiving this request from you as the client, the API will need to know where to look to retrieve these parameters, so that they can be used in the context of the request handler.
    </span>
    <span class="koboSpan" id="kobo.13.2">
     This type of transformation of data between client and server during requests is known as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.14.1">
      parameter binding
     </span>
    </strong>
    <span class="koboSpan" id="kobo.15.1">
     , and we
    </span>
    <a id="_idIndexMarker178">
    </a>
    <span class="koboSpan" id="kobo.16.1">
     are going to explore it in detail in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.17.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.18.1">
     In this chapter, we will explore
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.19.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      Parameter
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       binding sources
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       Binding precedence
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.23.1">
      Creating custom
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       parameter bindings
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-79">
    <a id="_idTextAnchor107">
    </a>
    <span class="koboSpan" id="kobo.25.1">
     Parameter binding sources
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     Out of the box, ASP.NET supports
    </span>
    <a id="_idIndexMarker179">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     several different parameter binding types.
    </span>
    <span class="koboSpan" id="kobo.27.2">
     Each binding type has a source from which it can bind.
    </span>
    <span class="koboSpan" id="kobo.27.3">
     Additionally, each binding source is situated in a different location within the request, with various ways in which they can be bound to data structures in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      the API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     Let’s start with one of the most common binding sources, the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      route value.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor108">
    </a>
    <span class="koboSpan" id="kobo.31.1">
     Route values
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.32.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.33.1">
      route value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.34.1">
     is
    </span>
    <a id="_idIndexMarker180">
    </a>
    <span class="koboSpan" id="kobo.35.1">
     simply a
    </span>
    <a id="_idIndexMarker181">
    </a>
    <span class="koboSpan" id="kobo.36.1">
     section of an API route.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     Look at a typical route and imagine it is split into sections delimited by each occurrence of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.37.1">
      /
     </span>
    </strong>
    <span class="koboSpan" id="kobo.38.1">
     character.
    </span>
    <span class="koboSpan" id="kobo.38.2">
     Each of these resulting sections is a value within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      the route.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     Take this example:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.41.1">
      /todoitems/2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.42.1">
     .
    </span>
    <span class="koboSpan" id="kobo.42.2">
     It would be split into two route value sections:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.43.1">
      todoitems
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.45.1">
       2
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     In this context,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.48.1">
      2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.49.1">
     is the route value we are interested in, because it is the ID of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.50.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.51.1">
     entity.
    </span>
    <span class="koboSpan" id="kobo.51.2">
     So, how can we access this within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      an endpoint?
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.53.1">
app.MapGet("/todoitems/{id}", (int id) =&gt;
{
    TodoItem item = GetById(id);
    if(item != null)
    {
        return Results.Ok(item);
    }
    return Results.NotFound();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     In this code, we can see that the incoming route has been modified to add a value surrounded by curly braces.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     This
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.55.1">
      id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.56.1">
     value is a placeholder for an integer value that will be passed in its place from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      client’s perspective.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     In the parameter of the lambda expression that follows the route, we declare that we are passing in an integer parameter, called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.59.1">
      id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.60.1">
     .
    </span>
    <span class="koboSpan" id="kobo.60.2">
     We can do this thanks to ASP.NET’s routing module, which detects the route value placeholder and parses out the actual value, converting it to the data type needed for the lambda expression, which in this case is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      an integer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.62.1">
     On the client’s side, the requested route might look like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      this:
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.64.1">
       https://myTodoAPI/todoitems/2
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     It is important to remember that in this example, if an item with an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.66.1">
      id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.67.1">
     value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     does not exist, the binding will not match, and the endpoint won’t hit at all, instead returning
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.70.1">
      404
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.71.1">
       NOT FOUND
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.73.1">
     By declaring a route parameter in the endpoint, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.74.1">
      id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.76.1">
      2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     found at the end of this route will be automatically detected and bound to the integer parameter declared in the lambda expression, allowing it to be used within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      the request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     Route values do not have to be automatically bound to the lambda expression parameters.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     They can be manually accessed within the request by passing an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.80.1">
      HttpRequest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.81.1">
     object as the parameter instead.
    </span>
    <span class="koboSpan" id="kobo.81.2">
     On
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.82.1">
      HttpRequest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     , there is a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.84.1">
      RouteValues
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     collection that will be populated with the values you need
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.86.1">
      for binding.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.87.1">
     This is useful if you have multiple types of parameter bindings and you want to make the request more readable.
    </span>
    <span class="koboSpan" id="kobo.87.2">
     Here’s an example that passes in an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.88.1">
      HttpRequest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.89.1">
     parameter.
    </span>
    <span class="koboSpan" id="kobo.89.2">
     This does not require any change on the client side, as it is already present.
    </span>
    <span class="koboSpan" id="kobo.89.3">
     By adding it as a
    </span>
    <a id="_idIndexMarker182">
    </a>
    <span class="koboSpan" id="kobo.90.1">
     parameter, we
    </span>
    <a id="_idIndexMarker183">
    </a>
    <span class="koboSpan" id="kobo.91.1">
     are allowing the endpoint to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.92.1">
      access it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.93.1">
app.MapGet(
    "/todoitems/{id}",
    (HttpRequest request) =&gt;
{
    if(int.TryParse(
        request.RouteValues["id"].ToString(),
        out var id) == false)
    {
        return Results.BadRequest(
            "Could not convert id to integer");
    }
    TodoItem item = GetById(id);
    return Results.Ok(item);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.94.1">
     When
    </span>
    <a id="_idIndexMarker184">
    </a>
    <span class="koboSpan" id="kobo.95.1">
     making requests to an API, there are times when you need to be more granular
    </span>
    <a id="_idIndexMarker185">
    </a>
    <span class="koboSpan" id="kobo.96.1">
     about the state or the conditions of a query you’re making.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     In these
    </span>
    <a id="_idIndexMarker186">
    </a>
    <span class="koboSpan" id="kobo.97.1">
     situations, query strings can be added to the endpoint URL.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     This allows you to pass more specific parameters to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      the API.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor109">
    </a>
    <span class="koboSpan" id="kobo.99.1">
     Query strings
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.100.1">
     In the case of route values, they
    </span>
    <a id="_idIndexMarker187">
    </a>
    <span class="koboSpan" id="kobo.101.1">
     are often a direct route to data.
    </span>
    <span class="koboSpan" id="kobo.101.2">
     Requesting something by an ID using a route value, on its own, produced a predictable result.
    </span>
    <span class="koboSpan" id="kobo.101.3">
     However, data comes in many different forms, meaning that we often need to specify specific conditions that will transform the data we are retrieving in the required shape.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.102.1">
      Query strings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.103.1">
     allow us
    </span>
    <a id="_idIndexMarker188">
    </a>
    <span class="koboSpan" id="kobo.104.1">
     to achieve this.
    </span>
    <span class="koboSpan" id="kobo.104.2">
     They sit at the end of a route, and they have their own notation that defines them, starting with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.105.1">
      ?
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.106.1">
      character.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.107.1">
     Checking for the presence of query string parameters
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.108.1">
     The benefit of checking for the query strings before using them only if they exist is that we can make query string parameters optional (more on that in the next section).
    </span>
    <span class="koboSpan" id="kobo.108.2">
     Otherwise, our code would assume that the client is always going to send query string values, therefore making them mandatory parameters for the endpoint.
    </span>
    <span class="koboSpan" id="kobo.108.3">
     This is fine when intended, but in the examples shown in this chapter, the aim is to ensure that the client has the choice to either filter the data or not, using query
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.109.1">
      string values.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.110.1">
     As we can see in this route,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.111.1">
      https://myTodoAPI/todoitems?pastDue=true&amp;priority=1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     , the query string starts at the end of the route values with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     character.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     After this, a collection of key-value pairs
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      is specified.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.116.1">
     The purpose
    </span>
    <a id="_idIndexMarker189">
    </a>
    <span class="koboSpan" id="kobo.117.1">
     of the query string in the route is to pass a series
    </span>
    <a id="_idIndexMarker190">
    </a>
    <span class="koboSpan" id="kobo.118.1">
     of variables into the API, which can be used to filter the data that will be returned.
    </span>
    <span class="koboSpan" id="kobo.118.2">
     In this case, the client is requesting any
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.119.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.120.1">
     that is past its due date, but also has a priority with a value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.121.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.122.1">
       1
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-82">
    <a id="_idTextAnchor110">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     Optional query string parameters
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.125.1">
     You can make it so that a
    </span>
    <a id="_idIndexMarker191">
    </a>
    <span class="koboSpan" id="kobo.126.1">
     parameter passed in is
    </span>
    <a id="_idIndexMarker192">
    </a>
    <span class="koboSpan" id="kobo.127.1">
     optional.
    </span>
    <span class="koboSpan" id="kobo.127.2">
     It’s very simple; you just make the query string parameter you added to the endpoint nullable by affixing a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.128.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.129.1">
     character to it.
    </span>
    <span class="koboSpan" id="kobo.129.2">
     Then, in the body of your endpoint, you can check for the existence of an optional value.
    </span>
    <span class="koboSpan" id="kobo.129.3">
     If the optional value is not null, you can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.130.1">
      use it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.131.1">
     Here’s an example of an optional parameter used on an endpoint that fetches a todo item by ID.
    </span>
    <span class="koboSpan" id="kobo.131.2">
     It allows the client to specify that the assignee must be a certain value.
    </span>
    <span class="koboSpan" id="kobo.131.3">
     If the assignee value is not null and does not match the assignee value on the item, you can send a different response, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.132.1">
      404
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.133.1">
       NOT FOUND
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.135.1">
  app.MapGet(
      "/todoitems/{id}",
      (int id, string? </span><span class="koboSpan" id="kobo.135.2">assignee) =&gt;
  {
      var index = TodoItems.FindIndex(x =&gt; x.Id == id);
      if (index == -1)
      {
          return Results.NotFound();
      }
      var todoItem = TodoItems[index];
      if (assignee != null)
      {
          if(todoItem.Assignee != assignee)
          {
              return Results.NotFound();
          }
      }
      return Results.Ok(ToDoItems[index]);
  });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     On the server side, the query
    </span>
    <a id="_idIndexMarker193">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     string parameters are
    </span>
    <a id="_idIndexMarker194">
    </a>
    <span class="koboSpan" id="kobo.138.1">
     bound as per the following example.
    </span>
    <span class="koboSpan" id="kobo.138.2">
     In this example, we are also checking for the existence of certain query string key-value pairs and building the relevant query for the data based on the specified query string values,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.139.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.140.1">
       IQueryable
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.142.1">
app.MapGet("/todoItems", (HttpRequest request) =&gt;
{
    bool pastDue = false;
    int priority = 0;
    var todoItemsQuery = ToDoItems.AsQueryable();
    if (request.Query.ContainsKey("pastDue"))
    {
        var parsedDueDate = bool.TryParse(
            request.Query["pastDue"],
            out pastDue
        );
        if (parsedDueDate) {
            todoItemsQuery = todoItemsQuery.Where(
                x =&gt; x.DueDate &lt;= DateTime.Now
            );
        }
    }
    if (request.Query.ContainsKey("priority"))
    {
        var parsedPriority = int.TryParse(
            request.Query["priority"],
            out priority
        );
        if (parsedPriority) {
            todoItemsQuery = todoItemsQuery.Where(
                x =&gt; x.Priority == priority
            );
        }
    }
    var result = todoItemsQuery.ToList();
    return Results.Ok(result);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.143.1">
     We’ve spent most
    </span>
    <a id="_idIndexMarker195">
    </a>
    <span class="koboSpan" id="kobo.144.1">
     of our time so far passing
    </span>
    <a id="_idIndexMarker196">
    </a>
    <span class="koboSpan" id="kobo.145.1">
     parameters within the URLs of our requests.
    </span>
    <span class="koboSpan" id="kobo.145.2">
     Let us explore parameters that exist outside of this, starting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.146.1">
      with headers.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor111">
    </a>
    <span class="koboSpan" id="kobo.147.1">
     Headers
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.148.1">
      Headers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     are a classic
    </span>
    <a id="_idIndexMarker197">
    </a>
    <span class="koboSpan" id="kobo.150.1">
     component of general API architecture, providing important metadata about the
    </span>
    <a id="_idIndexMarker198">
    </a>
    <span class="koboSpan" id="kobo.151.1">
     request.
    </span>
    <span class="koboSpan" id="kobo.151.2">
     They are like query strings in the sense that they are defined by a key-value structure, but the syntax used when applying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      them differs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.153.1">
     Like query strings and route values, they can also be accessed from an
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.154.1">
       HttpRequest
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.155.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.156.1">
app.MapGet("/todoItems", (HttpRequest request) =&gt;
{
    var customHeader = request.Headers["SomeCustomHeader"];
    var result = todoItemsQuery.ToList();
    return Results.Ok(result);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.157.1">
     Another critical parameter type that exists outside of the URL is the request body, sometimes referred to as the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.158.1">
      payload.
     </span>
    </em>
    <span class="koboSpan" id="kobo.159.1">
     ASP.NET has a clever feature that allows the payload’s contents to be automatically converted into a strongly typed object defined in the project.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     The feature is known
    </span>
    <a id="_idIndexMarker199">
    </a>
    <span class="koboSpan" id="kobo.160.1">
     as
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.161.1">
       object binding
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.162.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor112">
    </a>
    <span class="koboSpan" id="kobo.163.1">
     Strongly typed object binding
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.164.1">
     When representing objects
    </span>
    <a id="_idIndexMarker200">
    </a>
    <span class="koboSpan" id="kobo.165.1">
     in a request payload, it is extremely common for that object to be
    </span>
    <a id="_idIndexMarker201">
    </a>
    <span class="koboSpan" id="kobo.166.1">
     structured as JSON when the
    </span>
    <a id="_idIndexMarker202">
    </a>
    <span class="koboSpan" id="kobo.167.1">
     client creates the request.
    </span>
    <span class="koboSpan" id="kobo.167.2">
     ASP.NET provides a convenient way of automatically binding incoming JSON parameters to a strongly typed object so that it can be easily used when handling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.168.1">
      the request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.169.1">
     We have seen examples of this already in previous chapters, where we send a JSON payload representing a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.170.1">
       TodoItem
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.171.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.172.1">
     If the JSON object can be parsed, ASP.NET allows you to implicitly declare that the request parameter is an object of type
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.173.1">
      x
     </span>
    </em>
    <span class="koboSpan" id="kobo.174.1">
     –
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.175.1">
      x
     </span>
    </em>
    <span class="koboSpan" id="kobo.176.1">
     in our example being a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.177.1">
       TodoItem
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.178.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     To use implicit binding in this manner, simply declare a parameter of the type you wish to receive as a parameter in your endpoint, as shown in the following example, where we receive a new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.180.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.181.1">
     to be created via a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.182.1">
       POST
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.183.1">
      method:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.184.1">
app.MapPost("/todoitems", (TodoItem item) =&gt;
{
    var validationContext = new ValidationContext(item);
    var validationResults = new List&lt;ValidationResult&gt;();
    var isValid = Validator.TryValidateObject(
        item, validationContext, validationResults, true);
    if (isValid)
    {
        TodoItems.Add(item);
        return Results.Created();
    }
    return Results.BadRequest(validationResults);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.185.1">
     Object binding is
    </span>
    <a id="_idIndexMarker203">
    </a>
    <span class="koboSpan" id="kobo.186.1">
     initiated thanks to the client sending a data structure represented by a string, within the body of the request.
    </span>
    <span class="koboSpan" id="kobo.186.2">
     This is often the result of a developer formatting the payload after the data was gathered, before
    </span>
    <a id="_idIndexMarker204">
    </a>
    <span class="koboSpan" id="kobo.187.1">
     sending it to the API.
    </span>
    <span class="koboSpan" id="kobo.187.2">
     However, if the data was gathered
    </span>
    <a id="_idIndexMarker205">
    </a>
    <span class="koboSpan" id="kobo.188.1">
     by a user, who could be entering the data in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.189.1">
      Graphical User Interface
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.191.1">
      GUI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.192.1">
     ) via a form, the process can be streamlined further, thanks to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.193.1">
      form values.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-85">
    <a id="_idTextAnchor113">
    </a>
    <span class="koboSpan" id="kobo.194.1">
     Form values
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.195.1">
     API endpoints take in data and
    </span>
    <a id="_idIndexMarker206">
    </a>
    <span class="koboSpan" id="kobo.196.1">
     do something with it.
    </span>
    <span class="koboSpan" id="kobo.196.2">
     What better use case can there be for data submission than a form?
    </span>
    <span class="koboSpan" id="kobo.196.3">
     Minimal APIs support the receipt
    </span>
    <a id="_idIndexMarker207">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.198.1">
      form values
     </span>
    </strong>
    <span class="koboSpan" id="kobo.199.1">
     , making them a suitable option for handling submissions from forms within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.200.1">
      a GUI.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.201.1">
     Like the previous parameter examples, form values can be retrieved from their own dedicated member within an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      HttpRequest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     object, where they also exist in a key-value structure within an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.204.1">
      IFormCollection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     collection.
    </span>
    <span class="koboSpan" id="kobo.205.2">
     The following code shows the retrieval of form values
    </span>
    <a id="_idIndexMarker208">
    </a>
    <span class="koboSpan" id="kobo.206.1">
     within a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.207.1">
       PATCH
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.208.1">
      request:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.209.1">
app.MapPatch(
    "/updateTodoItemDueDate",
    async (HttpRequest request) =&gt;
{
    var formData = await request.ReadFormAsync();
    var id = int.Parse(formData["Id"]);
    var newDueDate =
        DateTime.Parse(formData["newDueDate"]);
    var index = TodoItems.FindIndex(x =&gt; x.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    TodoItems[index].DueDate = newDueDate;
    return Results.NoContent();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.210.1">
     So far, we’ve made
    </span>
    <a id="_idIndexMarker209">
    </a>
    <span class="koboSpan" id="kobo.211.1">
     some good progress exploring the various types of parameters that can be bound to API endpoints.
    </span>
    <span class="koboSpan" id="kobo.211.2">
     In each of the previous examples, a lot is assumed about how these parameters should be bound.
    </span>
    <span class="koboSpan" id="kobo.211.3">
     The location of the parameters, whether they be in the URL as query strings or in the request body, is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.212.1">
      implicit
     </span>
    </em>
    <span class="koboSpan" id="kobo.213.1">
     ; it does not require definition, instead occurring automatically.
    </span>
    <span class="koboSpan" id="kobo.213.2">
     Inversely, there will be times when we will need to be
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.214.1">
      explicit
     </span>
    </em>
    <span class="koboSpan" id="kobo.215.1">
     about how parameters are bound.
    </span>
    <span class="koboSpan" id="kobo.215.2">
     This explicit binding can be achieved
    </span>
    <a id="_idIndexMarker210">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.216.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.217.1">
       attributes
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.218.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-86">
    <a id="_idTextAnchor114">
    </a>
    <span class="koboSpan" id="kobo.219.1">
     Explicit binding with attributes
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.220.1">
     All the previous
    </span>
    <a id="_idIndexMarker211">
    </a>
    <span class="koboSpan" id="kobo.221.1">
     examples have something in common – they are
    </span>
    <a id="_idIndexMarker212">
    </a>
    <span class="koboSpan" id="kobo.222.1">
     accessible using keys from collections that exist within an
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.223.1">
       HttpRequest
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.224.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.225.1">
     There is another way of binding these parameter types without needing to inject
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.226.1">
      HttpRequest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.227.1">
     or its parent,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     –
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      attributes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.231.1">
     The benefit of this is that we can make the code more readable and arguably improve the structure of the request, because the parameters can be bound from within the parentheses of the endpoint’s lambda expression, leaving the expression body dedicated exclusively to handling the request.
    </span>
    <span class="koboSpan" id="kobo.231.2">
     As shown in the previous examples, we are using the parentheses to receive parameters but then performing explicit binding in the body, as well as executing handling logic, which can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.232.1">
      somewhat messy.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.233.1">
     Parameter binding with attributes is simpler because you are explicitly stating that you have a parameter that should be bound from a specific location in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.234.1">
      the request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.235.1">
     Let us take query strings as an example.
    </span>
    <span class="koboSpan" id="kobo.235.2">
     In the code block in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.236.1">
      Query strings
     </span>
    </em>
    <span class="koboSpan" id="kobo.237.1">
     section, we were accessing query strings from within the endpoint body by index on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.238.1">
      IQueryCollection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.239.1">
     within the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.240.1">
       HttpRequest
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.241.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.242.1">
     The following code block demonstrates how this endpoint can be refactored to obtain query string values using attributes, reducing the amount of code and making it easier
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.243.1">
      to read:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.244.1">
app.MapGet(
    "/todoItems",
    ([FromQuery(Name = "pastDue")] bool pastDue,
     [FromQuery(Name = "priority")] int priority  ) =&gt;
{
    var todoItemsQuery = ToDoItems.AsQueryable();
    if (pastDue)
    {
        todoItemsQuery = todoItemsQuery.Where(
            x =&gt; x.DueDate &lt;= DateTime.Now
        );
    }
    if (priority &gt; 0)
    {
        todoItemsQuery = todoItemsQuery.Where(
            x =&gt; x.Priority == priority
        );
    }
    var result = todoItemsQuery.ToList();
    return Results.Ok(result);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.245.1">
     If you were to change the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.246.1">
      [FromQuery]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.247.1">
     attributes in this code slightly by removing the argument, for example, to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.248.1">
      Name = "priority"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     , the API would still match the query values, assuming that the name was specified in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.250.1">
      query string.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.251.1">
     All the parameter binding
    </span>
    <a id="_idIndexMarker213">
    </a>
    <span class="koboSpan" id="kobo.252.1">
     methods demonstrated previously in this
    </span>
    <a id="_idIndexMarker214">
    </a>
    <span class="koboSpan" id="kobo.253.1">
     chapter can be extracted in this way – by specifying in an attribute where the parameter should be bound from and then providing an object with the appropriate data type in which it can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      be bound.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.255.1">
     Let us update another of our previous
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.256.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.257.1">
     examples by checking the headers in this manner.
    </span>
    <span class="koboSpan" id="kobo.257.2">
     For the purposes of demonstration, let us assume that when a client posts a new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.258.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.259.1">
     , they can indicate whether another process should be triggered in the background by using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      custom header.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     The header can be explicitly bound using an attribute, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.262.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.263.1">
app.MapPost(
    "/todoitems",
    (TodoItem item,
      [FromHeader(Name ="TriggerBackgroundTask")]
      bool triggerBackgroundTaskHeader ) =&gt;
{
    if ( triggerBackgroundTaskHeader)
    {
        // do something else in the background
    }
    ToDoItems.Add(item);
    return Results.Created();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.264.1">
     We’re ready to step into more advanced territory now, in which we can explore parameters that have been
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.265.1">
      injected
     </span>
    </em>
    <span class="koboSpan" id="kobo.266.1">
     from a catalog of previously
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      registered
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.268.1">
       services
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.269.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-87">
    <a id="_idTextAnchor115">
    </a>
    <span class="koboSpan" id="kobo.270.1">
     Binding parameters through dependency injection
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.271.1">
     Parameters can be bound to an endpoint that
    </span>
    <a id="_idIndexMarker215">
    </a>
    <span class="koboSpan" id="kobo.272.1">
     was not necessarily sent by the client.
    </span>
    <span class="koboSpan" id="kobo.272.2">
     One example of this is dependencies.
    </span>
    <span class="koboSpan" id="kobo.272.3">
     Where an API has dependencies registered for injection, they can be explicitly bound as parameters.
    </span>
    <span class="koboSpan" id="kobo.272.4">
     Let us explore an example of this by rewriting the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.273.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     request example from the first code block in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.275.1">
      Explicit binding with
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.276.1">
       attributes
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.277.1">
      section.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.278.1">
     First, as you can see in the code on GitHub, we’ve created a service
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.279.1">
      called
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.280.1">
       TodoItemService
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.281.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.282.1">
public class TodoItemService
{
    List&lt;TodoItem&gt; todoItems = new List&lt;TodoItem&gt;();
    public TodoItem GetById(int id)
    {
        return todoItems.FirstOrDefault(x =&gt; x.Id == id);
    }
    public List&lt;TodoItem&gt; GetTodoItems(
        bool pastDue, int priority)
    {
        var todoItemsQuery = todoItems.AsQueryable();
        if (pastDue)
        {
            todoItemsQuery = todoItemsQuery.Where(
                x =&gt; x.DueDate &lt;= DateTime.Now
            );
        }
        if (priority &gt; 0)
        {
            todoItemsQuery = todoItemsQuery.Where(
                x =&gt; x.Priority == priority);
        }
        return todoItemsQuery.ToList();
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     This service has been
    </span>
    <a id="_idIndexMarker216">
    </a>
    <span class="koboSpan" id="kobo.284.1">
     registered for dependency injection as a singleton service
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.285.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.286.1">
       Program.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.288.1">
builder.Services.AddSingleton&lt;TodoItemService&gt;();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.289.1">
     This means that we can
    </span>
    <a id="_idIndexMarker217">
    </a>
    <span class="koboSpan" id="kobo.290.1">
     now access this service from within an endpoint using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.291.1">
      [
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.292.1">
       FromServices]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.293.1">
      attribute:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.294.1">
app.MapGet(
    "/todoItems",
    ([FromQuery(Name = "pastDue")] bool pastDue,
     [FromQuery(Name = "priority")] int priority,
     [FromServices] TodoService todoItemService) =&gt;
{
    var todoItemsQuery =
        todoItemService.TodoItems.AsQueryable();
    if (pastDue)
    {
        todoItemsQuery = todoItemsQuery.Where(
            x =&gt; x.DueDate &lt;= DateTime.Now
        );
    }
    if (priority &gt; 0)
    {
        todoItemsQuery = todoItemsQuery.Where(
            x =&gt; x.Priority == priority
        );
    }
    var result =
        todoItemService.GetTodoItems(todoItemsQuery);
    return Results.Ok(result);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     In this code, binding a service registered for dependency injection is demonstrated using a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.296.1">
      [FromService]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.297.1">
     attribute.
    </span>
    <span class="koboSpan" id="kobo.297.2">
     This
    </span>
    <a id="_idIndexMarker218">
    </a>
    <span class="koboSpan" id="kobo.298.1">
     allows API endpoints to leverage reusable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.299.1">
      components easily.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.300.1">
     So far, we have looked at examples of various parameter types and how they are bound to API endpoints.
    </span>
    <span class="koboSpan" id="kobo.300.2">
     Hopefully, it is clear that ASP.NET is taking care of the heavy lifting when it comes to resolving these parameters before binding.
    </span>
    <span class="koboSpan" id="kobo.300.3">
     It is also important to understand the order in which this resolution of parameters happens.
    </span>
    <span class="koboSpan" id="kobo.300.4">
     This is known as
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.301.1">
       binding precedence
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.302.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-88">
    <a id="_idTextAnchor116">
    </a>
    <span class="koboSpan" id="kobo.303.1">
     Binding precedence
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.304.1">
     ASP.NET has its own defined
    </span>
    <a id="_idIndexMarker219">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     order in which it will bind parameters, known as its
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.306.1">
      order of precedence
     </span>
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     .
    </span>
    <span class="koboSpan" id="kobo.307.2">
     Using this
    </span>
    <a id="_idIndexMarker220">
    </a>
    <span class="koboSpan" id="kobo.308.1">
     order keeps resolution consistent and ensures that ASP.NET is resolving in a predictable way, starting with the most specific parameters to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.309.1">
      the least.
     </span>
    </span>
   </p>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.310.1">
       Figure 6
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.311.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.312.1">
     outlines the official order ASP.NET uses, which is useful to know as a developer, as it can help you anticipate any potential binding issues depending on the parameters
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      in use.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer043">
     <span class="koboSpan" id="kobo.314.1">
      <img alt="Figure 6.1: ASP.NET order of precedence for parameter binding" src="image/B20968_06_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.315.1">
     Figure 6.1: ASP.NET order of precedence for parameter binding
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.316.1">
     Let us look
    </span>
    <a id="_idIndexMarker221">
    </a>
    <span class="koboSpan" id="kobo.317.1">
     at a working example of how we can create custom binding logic, giving us more control over the way binding is executed on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.318.1">
      incoming parameters.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-89">
    <a id="_idTextAnchor117">
    </a>
    <span class="koboSpan" id="kobo.319.1">
     Creating custom binding logic
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.320.1">
     In this example, we are going
    </span>
    <a id="_idIndexMarker222">
    </a>
    <span class="koboSpan" id="kobo.321.1">
     to change the way we bind an incoming
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.322.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.323.1">
     , adding
    </span>
    <a id="_idIndexMarker223">
    </a>
    <span class="koboSpan" id="kobo.324.1">
     validation logic that will occur at the point
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.325.1">
      of binding.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.326.1">
     To implement this kind of custom binding, we need to implement a function within
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     .
    </span>
    <span class="koboSpan" id="kobo.328.2">
     This function is static and is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      called
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.330.1">
       BindAsync()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.331.1">
      .
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.332.1">
      BindAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.333.1">
     allows us to interrupt the binding process for an object and apply our own logic.
    </span>
    <span class="koboSpan" id="kobo.333.2">
     Let us start by adding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      BindAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.336.1">
       TodoItem
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.337.1">
      class.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.338.1">
     In
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.339.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.340.1">
     , add the following static function below the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.341.1">
      property definitions:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.342.1">
public static async ValueTask&lt;TodoItem&gt; BindAsync(
    HttpContext context, ParameterInfo parameter)
{
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.343.1">
     Next, we need to add a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.344.1">
      try/catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.345.1">
     block so that we can perform JSON validation logic, catching any errors in the process.
    </span>
    <span class="koboSpan" id="kobo.345.2">
     We are expecting to see exceptions of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.346.1">
      JsonException
     </span>
    </strong>
    <span class="koboSpan" id="kobo.347.1">
     if the validation fails, so we will explicitly catch this exception type in our
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.348.1">
       try/catch
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.349.1">
      block:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.350.1">
public static async ValueTask&lt;TodoItem&gt; BindAsync(
    HttpContext context, ParameterInfo parameter)
{
    try
    {
    }
    catch (JsonException)
    {
}
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     Now, we can start by accessing the body of the request and deserializing the raw JSON to a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.352.1">
      TodoItem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.353.1">
     instance.
    </span>
    <span class="koboSpan" id="kobo.353.2">
     We will add options to ensure case is not factored into validation, and then check to see whether deserialization was successful.
    </span>
    <span class="koboSpan" id="kobo.353.3">
     If it was not, the incoming parameter
    </span>
    <a id="_idIndexMarker224">
    </a>
    <span class="koboSpan" id="kobo.354.1">
     cannot be bound and the request is invalid, so we will return a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.355.1">
      400 Bad Request
     </span>
    </strong>
    <span class="koboSpan" id="kobo.356.1">
     response.
    </span>
    <span class="koboSpan" id="kobo.356.2">
     Update the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.357.1">
      try
     </span>
    </strong>
    <span class="koboSpan" id="kobo.358.1">
     block with this code,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.359.1">
      shown
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker225">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.360.1">
      here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.361.1">
var requestBody = await new StreamReader(
    context.Request.Body
).ReadToEndAsync();
var todoItem = JsonSerializer.Deserialize&lt;TodoItem&gt;(
    requestBody,
    new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    }
);
if (todoItem == null)
{
    context.Response.StatusCode = 400;
    await context.Response.WriteAsync("Invalid JSON");
    return new TodoItem();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.362.1">
     At this point, we have now checked the validity of the JSON to be bound.
    </span>
    <span class="koboSpan" id="kobo.362.2">
     In
    </span>
    <a href="B20968_05.xhtml#_idTextAnchor094">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.363.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.364.1">
     , we explored an example of validation middleware for verifying that objects were created according to specific rules.
    </span>
    <span class="koboSpan" id="kobo.364.2">
     We used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.365.1">
      ValidationContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.366.1">
     along with the static type,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.367.1">
      Validator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.368.1">
     , to return a list of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.369.1">
      ValidationResult
     </span>
    </strong>
    <span class="koboSpan" id="kobo.370.1">
     , which would determine the validity of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.371.1">
      the model.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.372.1">
     We can use this
    </span>
    <a id="_idIndexMarker226">
    </a>
    <span class="koboSpan" id="kobo.373.1">
     same logic in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.374.1">
      BindAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.375.1">
     to implement validation of the object as part of the parameter
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.376.1">
      binding process.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     Add this logic to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      try
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     block to
    </span>
    <a id="_idIndexMarker227">
    </a>
    <span class="koboSpan" id="kobo.380.1">
     complete the custom
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.381.1">
      binding logic:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.382.1">
var validationResults = new List&lt;ValidationResult&gt;();
var validationContext = new ValidationContext(
    todoItem,
    serviceProvider: null,
    items: null
);
if (!Validator.TryValidateObject(
    todoItem,
    validationContext,
    validationResults,
    validateAllProperties: true
))
{
    context.Response.StatusCode = 400;
    var errorMessages = string.Join(
        "; ",
        validationResults.Select(x =&gt; x.ErrorMessage)
    );
    await context.Response.WriteAsync(errorMessages);
    return new TodoItem();
}
return todoItem;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.383.1">
     Finally, we
    </span>
    <a id="_idIndexMarker228">
    </a>
    <span class="koboSpan" id="kobo.384.1">
     need to add the following basic logic to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.385.1">
      catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.386.1">
     block to handle any exceptions
    </span>
    <a id="_idIndexMarker229">
    </a>
    <span class="koboSpan" id="kobo.387.1">
     of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.388.1">
      JsonException
     </span>
    </strong>
    <span class="koboSpan" id="kobo.389.1">
     that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.390.1">
      are caught:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.391.1">
  context.Response.StatusCode = 400;
  await context.Response.WriteAsync("Invalid JSON");
  return new TodoItem();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.392.1">
     Refer to this chapter’s code in the accompanying GitHub repository to see the finished
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.393.1">
      class:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.394.1">
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.395.1">
     Custom parameter binding is a good example of ASP.NET’s flexible feature set.
    </span>
    <span class="koboSpan" id="kobo.395.2">
     Minimal APIs may be labeled as such but that doesn’t mean they restrict custom configurations.
    </span>
    <span class="koboSpan" id="kobo.395.3">
     Let us review what we have covered in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.396.1">
      this chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-90">
    <a id="_idTextAnchor118">
    </a>
    <span class="koboSpan" id="kobo.397.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     The binding of parameters is a fairly broad subject, and we have certainly covered the bulk of it in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.399.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.400.1">
     We started by looking at how the different parameter types are bound, from route values and query strings right up to headers and the automatic binding provided for strongly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.401.1">
      typed objects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.402.1">
     We then explored some alternative binding methods for these parameter types in the form of explicit attribute binding and the order of binding precedence, before looking at how dependency injection can be leveraged within requests to add parameters that may not have been received from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      the client.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.404.1">
     Finally, we worked through an example of custom parameter binding, adding custom validation to the binding logic of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.405.1">
       TodoItem
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.406.1">
      model.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     This chapter is not the last we have seen of dependency injection in minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.407.2">
     In the next chapter, we will explore the topic in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.408.1">
      more detail.
     </span>
    </span>
   </p>
  </div>
 </body></html>