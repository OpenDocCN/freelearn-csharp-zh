["```cs\nobject Convert(object value, Type targetType, object\n  parameter, CultureInfo culture);\nobject ConvertBack(object value, Type targetType, object\n  parameter, CultureInfo culture);\n```", "```cs\n    public class RecipeRatingsSummaryViewModel\n    {\n        public double MaxRating { get; } = 4d;\n        public double? AverageRating { get; set; } = 3.5d;\n    }\n    ```", "```cs\n    public RecipeRatingsSummaryViewModel RatingDetail {\n      get; set; } = new ();\n    ```", "```cs\n    .ConfigureFonts(fonts =>\n    {\n        ...\n        fonts.AddFont(\"MaterialIcons-Regular.ttf\",\n          \"MaterialIconsRegular\");\n    });\n    ```", "```cs\n    public class RatingToStarsConverter : IValueConverter\n    {\n        public object Convert(object value, Type\n          targetType, object parameter, CultureInfo\n            culture)\n        {\n            throw new NotImplementedException();\n        }\n        public object ConvertBack(object value, Type\n          targetType, object parameter, CultureInfo\n            culture)\n        {\n            throw new NotImplementedException();\n        }\n    }\n    ```", "```cs\n    public object Convert(object value, Type targetType,\n        object parameter, CultureInfo culture)\n    {\n        if (value is not double rating\n            || rating < 0 || rating > 4)\n        {\n            return string.Empty;\n        }\n        ...\n    }\n    ```", "```cs\n    string fullStar = \"\\ue838\";\n    string halfStar = \"\\ue839\";\n    int fullStars = (int)rating;\n    bool hasHalfStar = rating % 1 >= 0.5;\n    return string.Concat(\n        string.Join(\"\", Enumerable.Repeat(fullStar,\n        fullStars)), hasHalfStar ? halfStar : \"\");\n    ```", "```cs\n    <ContentPage\n        x:Class=\"Recipes.Mobile.RecipeDetailPage\"\n\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2009\n          /xaml\"\n        xmlns:conv=\"clr-namespace:Recipes.Mobile\n          .Converters\"\n        Title=\"RecipeDetailPage\">\n    ```", "```cs\n    <ContentPage\n        ...\n        >\n        <ContentPage.Resources>\n            <conv:RatingToStarsConverter x:Key=\n              \"ratingToStarsConverter\" />\n        </ContentPage.Resources>\n        ...\n    ```", "```cs\n    <Label\n        FontFamily=\"MaterialIconsRegular\"\n        FontSize=\"18\"\n        Text=\"{Binding RatingDetail.AverageRating,\n          Converter={StaticResource\n    Binding Markup Extension, we can define Converter. We can reference the instance we’ve declared on top of this page by using the StaticResource Markup Extension and passing in the key value of the converter instance. The converter will return a particular string value that, in combination with the label’s FontFamily set to MaterialIconsRegular, will show icons on the screen.\n    ```", "```cs\nlblRating.SetBinding(Label.TextProperty,\n$\"{nameof(RecipeDetailViewModel.RatingDetail)}.{nameof\n  (RecipeRatingsSummaryViewModel.AverageRating)}\",\n    converter: new RatingToStarsConverter());\n```", "```cs\n    bool isBackground = parameter is string param\n        && param.ToLower() == \"background\";\n    ```", "```cs\n    var hex = value switch\n    {\n        double r when r > 0 && r < 1.4 => isBackground ?\n          \"#E0F7FA\" : \"#ADD8E6\", //blue\n        double r when r < 2.4 => isBackground ? \"#F0C085\"\n          : \"#CD7F32\", //bronze\n        double r when r < 3.5 => isBackground ? \"#E5E5E5\"\n          : \"#C0C0C0\", //silver\n        double r when r <= 4.0 => isBackground ? \"#FFF9D6\"\n          : \"#FFD700\", //gold\n        _ => null,\n    };\n    Return hex is null ? null : Color.FromArgb(hex);\n    ```", "```cs\n    <ContentPage.Resources>    ...\n        <conv:RatingToColorConverter\n          x:Key=\"ratingToColorConverter\" />\n    </ContentPage.Resources>\n    ```", "```cs\n    <Grid>\n        <Label\n            FontFamily=\"MaterialIconsRegular\"\n            FontSize=\"18\"\n            Text=\"{Binding RatingSummary.MaxRating,\n            Converter={StaticResource\n              ratingToStarsConverter}}\"\n            TextColor=\"{Binding\n              RatingSummary.AverageRating,\n            Converter={StaticResource\n              ratingToColorConverter},\n                ConverterParameter=background}\" />\n        <Label\n            FontFamily=\"MaterialIconsRegular\"\n            FontSize=\"18\"\n            Text=\"{Binding RatingSummary.AverageRating,\n            Converter={StaticResource\n              ratingToStarsConverter}}\"\n            TextColor=\"{Binding\n              RatingSummary.AverageRating,\n            Converter={StaticResource\n              ratingToColorConverter}}\" />\n    </Grid>\n    ```", "```cs\n    private bool Inverse(object value)\n        => value switch\n        {\n            bool b => !b,\n            _ => false\n        };\n    ```", "```cs\n    public object Convert(object value, Type targetType,\n      object parameter, CultureInfo culture)\n    => Inverse(value);\n    public object ConvertBack(object value, Type\n      targetType, object parameter, CultureInfo culture)\n    => Inverse(value);\n    ```", "```cs\n    private bool _hideAllergenInformation = true;\n    public bool HideAllergenInformation\n    {\n        get => _ hideAllergenInformation;\n        set\n        {\n            if (_hideAllergenInformation != value)\n            {\n                _ hideAllergenInformation = value;\n                OnPropertyChanged();\n            }\n        }\n    }\n    ```", "```cs\n    <HorizontalStackLayout>\n        <Label\n            FontAttributes=\"Italic\"\n            Text=\"Show Allergen information\"\n            VerticalOptions=\"Center\" />\n        <CheckBox IsChecked=\"{Binding\n          HideAllergenInformation, Mode=OneWayToSource,\n            Converter={StaticResource\n              inverseBoolConverter}}\" />\n    </HorizontalStackLayout>\n    <Label IsVisible=\"{Binding HideAllergenInformation,\n      Mode=OneWay, Converter={StaticResource\n        inverseBoolConverter}}\"\n        Text=\"ToDo: add allergen information\" />\n    ```", "```cs\n    public int? Calories { get; set; } = 240;\n    public int? ReadyInMinutes { get; set; } = 35;\n    ```", "```cs\n    <Label Text=\"{Binding Calories,\n      StringFormat='Calories: {0} kcal'}\" />\n    <Label Text=\"{Binding ReadyInMinutes,\n      StringFormat='Ready in: {0} minutes'}\" />\n    ```", "```cs\n    public DateTime LastUpdated { get; set; }\n        = new DateTime(2020, 7, 3);\n    ```", "```cs\n    <Label\n        FontSize=\"8\"\n        HorizontalOptions=\"End\"\n        Text=\"{Binding LastUpdated, StringFormat='Last\n    string.Format method, we can add a format specifier to a placeholder. In this case, D is a standard DateTime format string representing the long date format specifier. It formats the bound DateTime value into a long date pattern. Of course, we could achieve the same result by creating a ValueConverter, but using the StringFormat property is a lot more concise and straightforward for such simple transformations. It saves us from the additional overhead of defining a separate converter class, thereby keeping our code cleaner and more maintainable.\n    ```", "```cs\n    <Label FontSize=\"8\"\n        Text=\"{Binding RatingDetail.AverageRating,\n          StringFormat='string.Format method.\n    ```", "```cs\n<Label Text=\"{Binding Calories, StringFormat='Calories: {0}\n  kcal', TargetNullValue='No calories information\nTargetNullValue property, we dictate what value should be used if the bound property returns null. Note that the defined StringFormat will not apply when TargetNullValue is used! We can do the same thing with the binding of the ReadyInMinutes property:\n\n```", "```cs\n    public string Image { get; } = \"caesarsalad.png\";\n    ```", "```cs\n    <Image Margin=\"-10,10\"\n      Aspect=\"AspectFill\" HeightRequest=\"200\"\n      HorizontalOptions=\"Fill\"\n      Source=\"{Binding Image, TargetNullValue=fallback.png}\"\n      />\n    ```", "```cs\nTextColor=\"{Binding RatingDetail.AverageRating,\nConverter={StaticResource ratingToColorConverter},\nConverterParameter=background, TargetNullValue={x:Static\nHotPink because RatingToColorConverter returns null when the provided value is null. When we update RatingToColorConverter so that it returns a default color if the value doesn’t fall within the expected range, the TargetNullValue will not be used:\n\n```", "```cs\n\n `TargetNullValue` can be very useful for handling properties that might return a null value. However, it won’t be helpful if the property or its source is inaccessible or doesn’t exist since it isn’t a null value issue but a problem with resolving the property itself. For example, in our app, it could be that the `RatingDetail` property of `RecipeDetailViewModel` is still null because it’s not (yet) loaded. For that, we can use the `FallBackValue` property.\nFallbackValue\n`FallbackValue` is used when the binding engine is unable to retrieve a value due to an error or if the source itself is `null`, rather than when the resolved binding source returns `null`. As an example, we can set the `RatingDetail` property on `RecipeDetailViewModel` to `null` instead of assigning it a new instance and update the following data binding:\n\n```", "```cs\n<Label\n    FontSize=\"8\"\n    Text=\"{Binding RatingDetail.AverageRating,\n      StringFormat='{0:0.#} avg. rating',\n        FallbackValue='Ratings not available',\n          \"No ratings yet\" will be displayed when the AverageRating property is set to null, whereas \"Ratings not available\" will be shown when the AverageRating property cannot be resolved due to the RatingDetail property being null.\nBoth `TargetNullValue` and `FallbackValue` are very valuable properties of the `Binding Markup Extension` and are very often overlooked. However, they can help tremendously in creating simple and easy-to-maintain UIs that make sense to the user. When both `FallbackValue` and `TargetNullValue` are defined in a binding, `TargetNullValue` takes precedence when the source property is null. `FallbackValue` is used when the binding system is unable to get a property value, such as when the path is incorrect or the source is not available. So, essentially, `TargetNullValue` is used for null values, while `FallbackValue` is used for binding errors.\nUp until now, we’ve been binding to data on our ViewModel, but we can also bind to other elements in our visual tree. Let’s have a look at element and relative data binding.\nElement and relative binding\nThe versatility of data binding extends beyond linking our Views with ViewModel data. It’s also possible to bind to different elements within our visual tree, opening up many new possibilities.\nBoth **element bindings** and **relative bindings** serve the purpose of allowing bindings to other elements. However, they differ in how they identify the source element:\n\n*   In an element binding, you specify the source element by its name, which is defined by using the `x:Name` attribute in XAML. The binding refers to this specific named element.\n*   In a relative binding, you refer to the source element concerning the position of the current element in the XAML tree. For example, you might bind to a property of the parent element or a property of the next sibling element, or you might even bind to a property of the element itself.\n\nLet’s have a look at both types of binding in more detail. First up: element binding.\nElement binding\nWith element binding, we can bind to the property of another element by referencing that element by its name. For example, in our *Recipes!* app, we could remove the `HideExtendedAllergenList` property from the ViewModel and update our XAML to this:\n\n```", "```cs\n\n In the preceding example, we are binding the `IsVisible` property of `VerticalStackLayout` to the `IsChecked` property of the `cbShowAllergenList` `CheckBox`. This eliminates the need for an additional property on `RecipeDetailViewModel` and keeps the ViewModel clean and focused.\nThis direct connection between UI components streamlines the logic, reduces the ViewModel’s responsibilities, and increases the maintainability of our code. It’s a clear demonstration of how element binding can simplify interactions within the user interface.\nRelative binding\nRelative binding in XAML provides a way to set the source of a binding relative to the position of the binding target in the UI tree, and it can reference either the binding target itself or one of its ancestors.\nThe three main forms of relative binding are as follows:\n\n*   **Self**: This mode is used to bind a property to another property on the same element. It’s useful when one property depends on the value of another.\n*   **FindAncestor**: This mode is used to bind a property to a property on an ancestor element in the visual tree. You can specify the type of the ancestor element and how far up the visual tree to search.\n*   `ControlTemplate` to bind a property to a property on the control the template is applied to. It is particularly useful when creating custom templates for a control.\n\nLet’s have a look at these three forms of relative binding in more detail.\nSelf-relative binding mode\nAs an example of the self-relative binding mode, let’s take a look at the two buttons in our app that allow the user to set or remove a recipe as a favorite. Wouldn’t it be nice if we could hide the disabled button? We can easily achieve this by using the `Self` relative binding mode:\n\n```", "```cs\n\n `AddAsFavoriteCommand` is responsible for setting the button to enabled or disabled, depending on what the `CanExecute` method returns. With this relative binding, we are binding the `IsEnabled` property of the button itself to the `IsVisible` property. Now, when the button is disabled, it is not shown on the UI.\nFindAncestor relative binding mode\nIn relative bindings, `AncestorType` is useful when you need to bind to a property of a parent element in the visual tree. It essentially “walks up” the tree of UI elements until it finds an instance of the specified type. By specifying `AncestorLevel`, we can define which ancestor to bind to. By default, `AncestorLevel` is 1, meaning it will bind to the nearest ancestor of the specified type. However, if you set `AncestorLevel` to 2, it will bind to the second nearest ancestor of the specified type, and so on. This offers a great deal of flexibility and control in choosing the specific ancestor in the visual tree that you want to bind to.\nAs a simple example, we can give the root `VerticalStackLayout` a `BackgroundColor` of `GhostWhite`. Now, if we want to bind the `TextColor` property of the two buttons on the bottom of the page to the `BackgroundColor` property of `VerticalStackLayout`, we could write the following:\n\n```", "```cs\n    public string Author { get; set; } = \"Sally Burton\";\n    ```", "```cs\n    <Label FontSize=\"8\" HorizontalOptions=\"End\">\n        <Label.Text>\n            <MultiBinding StringFormat=\"Last updated:\n              {0:D} | {1}\">\n                <Binding Path=\"LastUpdated\" />\n                <Binding Path=\"Author\" />\n            </MultiBinding>\n        </Label.Text>\n    </Label>\n    ```", "```cs\n    public class RecipeRatingsSummaryiewModel\n    {\n        public int TotalReviews { get; } = 15;\n        public double MaxRating { get; } = 4d;\n        public double? AverageRating { get; set; } =\n          3.6d;}\n    ```", "```cs\n    bool isBackground = parameter is string param\n        && param.ToLower() == \"background\";\n    var hex = isBackground ? \"#F2F2F2\" : \"#EBEBEB\";\n    if (values.Count() == 2\n        && values[0] is int reviewCount\n        && values[1] is double rating)\n    {\n        if (reviewCount >= 15)\n        {\n            hex = rating switch\n            {\n                …\n            };\n        }\n    }\n    return hex is null ? null : Color.FromArgb(hex);\n    ```", "```cs\n    <conv:RatingAndReviewsToColorConverter\n      x:Key=\"ratingAndReviewsToColorConverter\" />\n    ```", "```cs\n<Label.TextColor>\n    <MultiBinding\n        Converter=\"{StaticResource\n          ratingAndReviewsToColorConverter}\"\n        ConverterParameter=\"background\"\n        TargetNullValue=\"{x:Static Colors.HotPink}\">\n        <Binding Path=\"RatingDetail.TotalReviews\" />\n        <Binding Path=\"RatingDetail.AverageRating\" />\n    </MultiBinding>\n</Label.TextColor>\n```", "```cs\n<ContentPage\n    x:Class=\"Recipes.Mobile.RecipeDetailPage\"\n    …\n    xmlns:vms=\"clr-namespace:Recipes.Client.Core\n      .ViewModels;assembly=Recipes.Client.Core\"\n    x:DataType=\"vms:RecipeDetailViewModel\"\n    Title=\"RecipeDetailPage\">\n```", "```cs\n<HorizontalStackLayout\n  x:DataType=\"vms:IngredientsListViewModel\"\n    BindingContext=\"{Binding IngredientsList,\n      Source={RelativeSource AncestorType={x:Type\n        vms:RecipeDetailViewModel}}}\">\n```", "```cs\n\n```", "```cs\n\n```", "```cs\n\n```"]