- en: '*Chapter 5*: Exploring Architecture Design Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：探索架构设计模式'
- en: In the previous chapter, we learned about the key principles of solution architecture.
    We also explored the most frequently used UML diagrams and when we should use
    each one to create a view of the solution architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了解决方案架构的关键原则。我们还探讨了最常用的 UML 图以及何时使用每种图来创建解决方案架构的视图。
- en: In this chapter, you will learn about the top architecture patterns that you
    must know to build a solid software architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解你必须知道的顶级架构模式，以构建坚实的软件架构。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the architectural patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍架构模式
- en: Exploring key architecture patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索关键架构模式
- en: Learning how to choose the right pattern for your product
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何为你的产品选择正确的模式
- en: By the end of this chapter, you will understand architectural patterns. We will
    enrich our knowledge by exploring the top architecture patterns with example use
    cases. Additionally, we will explain the criteria that we should focus on when
    choosing the right architecture pattern for our software product.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解架构模式。我们将通过探索顶级架构模式和示例用例来丰富我们的知识。此外，我们还将解释在选择适合我们软件产品的正确架构模式时应关注的准则。
- en: Before we begin learning about these patterns, first, let's understand what
    an architectural pattern actually is.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习这些模式之前，首先，让我们了解架构模式实际上是什么。
- en: Introducing the architectural patterns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍架构模式
- en: An architectural pattern is a reusable solution architecture to a common problem
    that we might face in different business industries and on various occasions.
    It offers predefined guidelines along with a set of rules to establish the underlying
    structure of the solution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式是对我们在不同的商业行业和不同场合可能遇到的一般问题的可重用解决方案架构。它提供了一套预定义的指南和规则，以建立解决方案的底层结构。
- en: 'It is important not to mix up the **.NET** design patterns and the architectural
    patterns. The first one represents a way in which to organize classes to make
    your source code more reliable, scalable, and easy to maintain, which will solve
    various problems that are internal to a specific component or module in our system.
    In comparison, the second one has a broader scope within the entire solution as
    it defines the high-level abstract structure of the solution. As a solution architect,
    you must possess knowledge of both types of patterns:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要混淆 **.NET** 设计模式和架构模式。前者代表了一种组织类的方法，可以使你的源代码更可靠、可扩展且易于维护，这将解决我们系统中特定组件或模块内部的各种问题。相比之下，后者在整个解决方案中具有更广泛的范围，因为它定义了解决方案的高级抽象结构。作为解决方案架构师，你必须了解这两种模式：
- en: '**Design Patterns** develop classes with object-oriented principles.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计模式**使用面向对象原则开发类。'
- en: '**Architectural Patterns** help to define and maintain the overall structure
    of the entire system.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构模式**有助于定义和维护整个系统的整体结构。'
- en: 'The following diagram shows the different levels of architectural decisions
    that you might need to make as a solution architect:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了作为解决方案架构师你可能需要做出的不同层次的架构决策：
- en: '![Figure 5.1: The various levels of architectural decisions](img/Figure_5.01_B17366.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：架构决策的各个层次](img/Figure_5.01_B17366.jpg)'
- en: 'Figure 5.1: The various levels of architectural decisions'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：架构决策的各个层次
- en: In the preceding diagram, you can see that choosing the architectural pattern
    is one of the earliest decisions that you must take. Following this, you should
    choose the right technology stack that you will use to build the product. After
    that, you need to decide upon the type of application and the design patterns
    that will help you to organize the code and make it both reusable and extensible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到选择架构模式是你必须最早做出的决定之一。随后，你应该选择将用于构建产品的正确技术栈。之后，你需要决定应用程序的类型以及将帮助你组织代码并使其可重用和可扩展的设计模式。
- en: Now, let's begin by getting to know the most popular architecture patterns.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从了解最流行的架构模式开始。
- en: Popular architecture patterns
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行的架构模式
- en: In this section, we will explore five popular architectural patterns. We will
    explain the core concept of each pattern, and then we will outline the key components
    of each architecture pattern. This should help you learn about the usefulness
    of architecture patterns and support you in choosing the right pattern for a proposed
    solution. Let's begin with a layered architecture.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨五种流行的架构模式。我们将解释每种模式的核心理念，然后概述每种架构模式的关键组件。这应该有助于你了解架构模式的有用性，并支持你为提出的解决方案选择正确的模式。让我们从分层架构开始。
- en: Layered architecture
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层架构
- en: This type of architecture is widely known by most architects and developers
    as **n-tier architecture**. It is used to structure the system into different
    layers, where each layer consists of a set of classes grouped in one assembly
    based on a specific context. The layers are structured horizontally so that each
    layer can consume services from one layer or the many layers that are beneath
    it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构在大多数建筑师和开发者中广为人知，被称为**n层架构**。它用于将系统结构化成不同的层，每一层都由一组基于特定上下文分组在同一个组件中的类组成。这些层是水平结构的，以便每一层都可以消费来自它自己或其下多个层的服务。
- en: 'In most cases, this architecture consists of three main layers, as shown in
    the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这种架构由三个主要层组成，如下面的图所示：
- en: '![Figure 5.2: A typical 3-tier layered architecture](img/Figure_5.02_B17366.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：典型的3层分层架构](img/Figure_5.02_B17366.jpg)'
- en: 'Figure 5.2: A typical 3-tier layered architecture'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：典型的3层分层架构
- en: 'As you can see from the preceding diagram, these are the three main layers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，这些是三个主要层：
- en: '**Presentation Layer**: This layer represents the component that is responsible
    for handling all user interactions through pages, menus, buttons, links, reports,
    forms, and more. It contains all the graphical designs and defines what the application
    looks like. It is the only layer that is visible to end users.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：这一层代表负责通过页面、菜单、按钮、链接、报告、表单等方式处理所有用户交互的组件。它包含所有图形设计，并定义了应用程序的外观。它是唯一对最终用户可见的层。'
- en: '**Business Layer**: This contains the business logic, business rules, and entities
    that define the behavior of the entire solution.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务层**：这一层包含业务逻辑、业务规则和实体，它们定义了整个解决方案的行为。'
- en: '**Data Access Layer**: This contains the code responsible for manipulating
    the database layer, which is where all the data is stored (for example, **SQL
    Server**, **Oracle**, and **MongoDB**).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问层**：这一层包含负责操作数据库层的代码，这是所有数据存储的地方（例如，**SQL Server**、**Oracle**和**MongoDB**）。'
- en: 'The following screenshot shows the 3-tier architecture in **Visual Studio**
    using the **Razor Web App** and **.NET 5** class libraries:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用**Razor Web应用**和**.NET 5**类库在**Visual Studio**中实现的3层架构：
- en: '![Figure 5.3: 3-tier architecture in Visual Studio](img/Figure_5.03_B17366.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：Visual Studio中的3层架构](img/Figure_5.03_B17366.jpg)'
- en: 'Figure 5.3: 3-tier architecture in Visual Studio'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：Visual Studio中的3层架构
- en: In the preceding example architecture, the **data access layer** is the lowest
    layer and does not reference any of the other layers. It should contain the **ADO.NET**
    call or the **EntityFramework** call to manipulate the database tables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例架构中，**数据访问层**是最低层，不引用任何其他层。它应该包含操作数据库表的**ADO.NET**调用或**EntityFramework**调用。
- en: The **business layer** references the **data access layer**. It should contain
    all the business logic and entities; here, the entities represent the business
    objects mapped to the database tables. As for the **presentation layer**, this
    is the **web app** that contains the user interface. It references the **business
    layer** and doesn't allow direct calls to the **data access layer**. The **web
    app** can be an MVC app or Razer app, as it is possible to mix these two patterns
    in order to build a solution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务层**引用**数据访问层**。它应该包含所有业务逻辑和实体；在这里，实体代表映射到数据库表的业务对象。至于**表示层**，这是包含用户界面的**Web应用**。它引用**业务层**，不允许直接调用**数据访问层**。**Web应用**可以是MVC应用或Razer应用，因为可以混合这两种模式来构建解决方案。'
- en: In the next section, let's get to know the presentation architecture in more
    detail.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地了解表示架构。
- en: Presentation architecture
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示架构
- en: One of the major issues we could face in a solution's **User** **Interface**
    (**UI**) is the presence of messy code that's difficult to maintain and scale.
    We have seen this in many web form solutions. This makes the architectural presentation
    pattern of the utmost importance, as it organizes the source code with a clear
    separation of responsibilities along with low coupling, which removes any complications
    and makes the UI code well organized and manageable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案的用户界面（**UI**）中，我们可能会遇到的一个主要问题是存在难以维护和扩展的杂乱代码。我们在许多网络表单解决方案中都看到了这种情况。这使得架构展示模式变得极其重要，因为它通过清晰的职责分离和低耦合来组织源代码，从而消除了任何复杂性，并使UI代码井然有序且易于管理。
- en: This architecture pattern helps to solve primary UI issues, such as logic that
    is coupled with the UI, state management, and the synchronization between the
    UI elements and the business entities.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构模式有助于解决主要的UI问题，如与UI耦合的逻辑、状态管理以及UI元素与业务实体之间的同步。
- en: 'There are three types of presentation patterns, as shown in the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图表所示，有三种类型的展示模式：
- en: '![Figure 5.4: The various types of presentation patterns](img/Figure_5.04_B17366.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：各种展示模式类型](img/Figure_5.04_B17366.jpg)'
- en: 'Figure 5.4: The various types of presentation patterns'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：各种展示模式类型
- en: All of these patterns focus on decoupling the UI from the logic, which allows
    for clean **HTML** markup. Let's explore these three types in the following sections.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模式都侧重于将UI与逻辑解耦，从而允许有整洁的**HTML**标记。让我们在接下来的部分中探索这三种类型。
- en: MVC (Model, View, Controller)
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MVC（模型，视图，控制器）
- en: 'The MVC pattern gives you full control over the markup. It is very popular,
    and Visual Studio has adopted it as the default template for when we want to create
    a new **ASP.NET** project. It splits the application into three main components:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式让你完全控制标记。它非常受欢迎，Visual Studio已将其作为创建新**ASP.NET**项目的默认模板。它将应用程序分为三个主要组件：
- en: '**Model**: This encapsulates the business logic and contains the data to display
    in the view.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这封装了业务逻辑并包含要在视图中显示的数据。'
- en: '**View**: This displays the content through the UI.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这通过UI显示内容。'
- en: '**Controller**: This handles the user interaction, works with the model for
    data updates, and, finally, selects a view to render the content.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这处理用户交互，与模型一起进行数据更新，最后选择一个视图来渲染内容。'
- en: 'The following diagram shows the three main components and illustrates which
    ones reference the others:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了三个主要组件，并说明了哪些组件引用了其他组件：
- en: '![Figure 5.5: The MVC pattern](img/Figure_5.05_B17366.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5：MVC模式](img/Figure_5.05_B17366.jpg)'
- en: 'Figure 5.5: The MVC pattern'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：MVC模式
- en: 'Here is an example MVC project template using **Visual Studio 2019** and **.NET
    5**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用**Visual Studio 2019**和**.NET 5**的MVC项目模板示例：
- en: '![Figure 5.6: A typical MVC project template in Visual Studio](img/Figure_5.06_B17366.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6：Visual Studio中的典型MVC项目模板](img/Figure_5.06_B17366.jpg)'
- en: 'Figure 5.6: A typical MVC project template in Visual Studio'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：Visual Studio中的典型MVC项目模板
- en: In the preceding example architecture, you can see that the three components
    are encapsulated within the same project but exist in different folders. You can
    also create a separate project for each layer and then configure the references.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例架构中，你可以看到三个组件封装在同一个项目中，但存在于不同的文件夹中。你也可以为每一层创建一个单独的项目，然后配置引用。
- en: MVP (Model, View, Presenter)
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MVP（模型，视图，演示者）
- en: 'The MVP pattern is a UI presentation architecture and is considered to be a
    derivation of the MVC pattern. It separates the architecture into three main components:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MVP模式是一种UI展示架构，被认为是MVC模式的衍生。它将架构分为三个主要组件：
- en: '**Model**: This contains the business logic of the solution.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这包含解决方案的业务逻辑。'
- en: '**View**: This contains the interfaces that enclose the data properties, which
    we will either send to or receive from the UI. In comparison to the MVC pattern,
    it doesn''t include the UI.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这包含封装数据属性的接口，我们将将其发送到或从UI接收。与MVC模式相比，它不包括UI。'
- en: '**Presenter**: This retrieves data from the **Model** and binds it back to
    the view. It works as an intermediate layer between the **Model** layer and the
    **View** layer.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演示者**：它从**模型**检索数据并将其绑定回视图。它作为**模型**层和**视图**层之间的中间层。'
- en: 'The following diagram illustrates the three main components of the MVP pattern:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了MVP模式的三个主要组件：
- en: '![Figure 5.7: The MVP pattern](img/Figure_5.07_B17366.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：MVP 模式](img/Figure_5.07_B17366.jpg)'
- en: 'Figure 5.7: The MVP pattern'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：MVP 模式
- en: 'Here is an MVP project template in Visual Studio using the **Razor Web App**
    and **.NET 5** class libraries. Check the references between the projects in order
    to gain an understanding of the relationships between the three components:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Visual Studio 中使用 **Razor Web 应用** 和 **.NET 5** 类库的 MVP 项目模板。检查项目之间的引用，以便了解三个组件之间的关系：
- en: '![Figure 5.8: A typical MVP project template in Visual Studio](img/Figure_5.08_B17366.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：Visual Studio 中的典型 MVP 项目模板](img/Figure_5.08_B17366.jpg)'
- en: 'Figure 5.8: A typical MVP project template in Visual Studio'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：Visual Studio 中的典型 MVP 项目模板
- en: In the preceding example architecture, you can see that the UI is located in
    the web app, which references the **Model**, the **View**, and the **Presenter**
    layers. The View layer doesn't reference any other project. It contains the interfaces
    that are implemented in the Presenter layer. The Model layer contains the business
    entities and the business logic; it doesn't reference any other project. As for
    the Presenter layer, this contains the actual implementation of the interfaces
    defined in the View layer. It references the Model and the View layers because
    it plays an intermediate role between them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例架构中，你可以看到 UI 位于 Web 应用中，它引用了 **模型**、**视图** 和 **演示者** 层。视图层不引用任何其他项目。它包含在演示者层中实现的接口。模型层包含业务实体和业务逻辑；它不引用任何其他项目。至于演示者层，它包含在视图层中定义的接口的实际实现。因为它在它们之间扮演着中间角色，所以它引用模型和视图层。
- en: Let's explore the third type of presentation architecture next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来探索第三种表示架构。
- en: MVVM (Model, View, ViewModel)
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MVVM（模型、视图、视图模型）
- en: 'This architecture is also considered an extension of the MVC pattern. It contains
    three main components, too. It combines the best strengths of MVC and MVP by offering
    a high level of reusability and scalability. The key concept of this architecture
    is that it moves the logic out of the controller and into **ViewModel**:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构也被认为是 MVC 模式的扩展。它也包含三个主要组件。它通过提供高可重用性和可伸缩性，结合了 MVC 和 MVP 的最佳优势。这种架构的关键概念是将逻辑从控制器移到
    **视图模型**：
- en: '**Model**: This contains the business rules and the model classes.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这包含业务规则和模型类。'
- en: '**View**: This contains the UI.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这包含 UI。'
- en: '**ViewModel**: This is an intermediate layer between **View** and **Model**.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：这是 **视图** 和 **模型** 之间的中间层。'
- en: 'The following diagram shows the three components and how they interact with
    each other:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这三个组件以及它们如何相互交互：
- en: '![Figure 5.9: The MVVM pattern](img/Figure_5.09_B17366.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：MVVM 模式](img/Figure_5.09_B17366.jpg)'
- en: 'Figure 5.9: The MVVM pattern'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：MVVM 模式
- en: Note that the `Session`, `ViewBag`, or `TempData`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Session`、`ViewBag` 或 `TempData`。
- en: 'Here is an example project template of the MVVM pattern using **Visual Studio**,
    **MVC**, and **.NET 5**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 **Visual Studio**、**MVC** 和 **.NET 5** 的 MVVM 模式示例项目模板：
- en: '![Figure 5.10: A typical MVVM project template in Visual Studio](img/Figure_5.10_B17366.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10：Visual Studio 中的典型 MVVM 项目模板](img/Figure_5.10_B17366.png)'
- en: 'Figure 5.10: A typical MVVM project template in Visual Studio'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：Visual Studio 中的典型 MVVM 项目模板
- en: We can also use the Razor Pages project template as it follows the MVVM pattern.
    This enables two-way data binding since the code of the model and the controller
    are attached to the Razor page, which allows for a simple development experience
    with a separation of concerns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 Razor Pages 项目模板，因为它遵循 MVVM 模式。这使得双向数据绑定成为可能，因为模型和控制器代码附加到 Razor 页面，从而允许以关注点分离的方式实现简单的开发体验。
- en: It is important to understand the difference between these three types of presentation
    architectures so that you know which pattern you should use for your solution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这三种表示架构之间的区别非常重要，这样你才知道应该为你的解决方案使用哪种模式。
- en: Now, let's get to know clean architecture.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解干净的架构。
- en: Clean architecture
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁架构
- en: In the n-tier layered architecture, we learned that everything depends on the
    database layer, which is considered to be a transitive dependency. Clean architecture
    is considered domain-centric architecture. The business logic and application
    layers are at the center of the design. Instead of having the business logic depend
    on the data access layer, as is the case in the n-tier architecture, clean architecture
    inverts this dependency by forcing the infrastructure and other layers to depend
    on the application core.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在n层分层架构中，我们了解到一切皆依赖于数据库层，这被视为一个传递依赖。清洁架构被认为是领域中心架构。业务逻辑和应用层是设计的中心。与n层架构中业务逻辑依赖于数据访问层的情况不同，清洁架构通过强制基础设施和其他层依赖于应用核心来反转这种依赖关系。
- en: 'The following diagram shows a typical technique that can be used to visualize
    this architecture. It uses a series of concentric circles, which are similar to
    the rings of an onion:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了可以用来可视化这个架构的典型技术。它使用一系列同心圆，类似于洋葱的环：
- en: '![Figure 5.11: Clean architecture onion view](img/Figure_5.11_B17366.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11：清洁架构洋葱视图](img/Figure_5.11_B17366.jpg)'
- en: 'Figure 5.11: Clean architecture onion view'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11：清洁架构洋葱视图
- en: In the preceding diagram, the circles represent the different components of
    the system, and the application core consists of the entities and the use cases.
    The key factor influencing this architecture is the dependency rule. It forces
    the dependency of the components to flow toward the center. The components in
    the inner circle should never depend on anything in the outer circle.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，圆圈代表系统的不同组件，应用核心由实体和用例组成。影响这个架构的关键因素是依赖规则。它强制组件的依赖关系流向中心。内圈中的组件永远不应该依赖于外圈中的任何东西。
- en: As a result, if we declare a function or a class in the outer circle, it should
    not be visible in the inner circle. In the diagram, you can see how the dependencies
    flow toward the center from the most outer circle to where the use cases and the
    entities are located.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们在外圈声明一个函数或类，它不应该在内圈中可见。在图中，你可以看到依赖关系是如何从最外圈流向用例和实体所在的位置的。
- en: 'Let''s explore the key components of this architecture:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这个架构的关键组件：
- en: The entities represent the business rules, such as objects and related methods.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体代表业务规则，如对象和相关方法。
- en: The use cases represent the application core, where all the use cases of the
    system are implemented. It manages the flow of data from and to the entities.
    This layer is not affected by the changes that might occur in the external layers,
    such as the database or the UI.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例表示应用的核心，其中实现了系统的所有用例。它管理从实体到实体之间的数据流。这一层不受外部层（如数据库或UI）可能发生的更改的影响。
- en: The interface adapters are the layers that will contain the MVC components,
    such as the controllers, the views, and the presenters. This layer plays an intermediate
    role in converting the data coming from the use cases and entities into a suitable
    format for the external components, such as the database and the controllers.
    The models in this layer are used as data structures to exchange data between
    the use cases and the presenters or the views.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口适配器是包含MVC组件（如控制器、视图和演示者）的层。在这一层中，它扮演着中间角色，将来自用例和实体的数据转换为适合外部组件（如数据库和控制器）的格式。这一层的模型用作在用例和演示者或视图之间交换数据的数据结构。
- en: The frameworks and drivers represent the outermost layer of this architecture.
    This layer contains the database and all of the UI code.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架和驱动器代表这个架构的最外层。这一层包含数据库和所有UI代码。
- en: 'The following diagram shows a horizontal view of this architecture:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了这个架构的水平视图：
- en: '![Figure 5.12: Clean architecture horizontal layer view](img/Figure_5.12_B17366.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12：清洁架构水平层视图](img/Figure_5.12_B17366.jpg)'
- en: 'Figure 5.12: Clean architecture horizontal layer view'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：清洁架构水平层视图
- en: In this diagram, there are two types of dependencies, which are represented
    by the style of the arrow. The solid arrow refers to compile-time dependencies,
    while the dashed arrow represents a runtime-only dependency. The **User Interface**
    layer deals with the interfaces defined in the application core with no direct
    access to the implementation in the **Infrastructure** layer. These interfaces
    are bound to the concrete implementation at runtime through **dependency injection**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，存在两种类型的依赖关系，它们通过箭头的样式来表示。实线箭头表示编译时依赖，而虚线箭头则代表仅运行时依赖。**用户界面**层处理应用程序核心中定义的接口，但没有直接访问**基础设施**层中的实现。这些接口在运行时通过**依赖注入**绑定到具体的实现。
- en: 'Tip:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：
- en: Dependency injection is a software design pattern. The main purpose of this
    pattern is that it allows you to have loosely coupled code that supports architecture
    patterns, such as clean architecture, to reduce the tight coupling between the
    layers. It replaces the hardcoded dependencies between the classes by using a
    builder object to initialize objects and then inject those dependencies at runtime.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种软件设计模式。这种模式的主要目的是允许你拥有松耦合的代码，支持如整洁架构这样的架构模式，以减少层之间的紧密耦合。它通过使用构建器对象初始化对象，然后在运行时注入这些依赖来替换类之间的硬编码依赖。
- en: 'The following screenshot shows a clean architecture solution template in **Visual
    Studio** with **.NET 5** and **Angular 10**:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了使用 **Visual Studio**、**.NET 5** 和 **Angular 10** 的整洁架构解决方案模板：
- en: '![Figure 5.13: A typical project template using clean architecture](img/Figure_5.13_B17366.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13：使用整洁架构的典型项目模板](img/Figure_5.13_B17366.jpg)'
- en: 'Figure 5.13: A typical project template using clean architecture'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：使用整洁架构的典型项目模板
- en: 'Let''s explore each project in this .NET solution:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这个 .NET 解决方案中的每个项目：
- en: 'The most inner layer is the `Domain` project. It doesn''t reference any other
    layer, as shown in the following screenshot. On the right-hand side, you can see
    one of the entity''s classes:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最内层是 `Domain` 项目。它不引用任何其他层，如以下截图所示。在右侧，你可以看到一个实体类的示例：
- en: '![Figure 5.14: The entities project in clean architecture](img/Figure_5.14_B17366.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14：整洁架构中的实体项目](img/Figure_5.14_B17366.jpg)'
- en: 'Figure 5.14: The entities project in clean architecture'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14：整洁架构中的实体项目
- en: 'Next, we have the `Application` project. As you can see, it references the
    `Domain` project. It contains all of the application logic by defining the interfaces
    that will be implemented in the infrastructure layer:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有 `Application` 项目。正如你所见，它引用了 `Domain` 项目。它通过定义将在基础设施层中实现接口来包含所有应用程序逻辑：
- en: '![Figure 5.15: The Application project in clean architecture](img/Figure_5.15_B17366.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15：整洁架构中的应用程序项目](img/Figure_5.15_B17366.jpg)'
- en: 'Figure 5.15: The Application project in clean architecture'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：整洁架构中的应用程序项目
- en: 'Next, we have the `Infrastructure` layer, which contains the concrete implementation
    of the interfaces defined in the `Application` layer. As per the following screenshot,
    you can see that it references the `Application` layer:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有 `基础设施` 层，它包含在 `Application` 层中定义的接口的具体实现。根据以下截图，你可以看到它引用了 `Application`
    层：
- en: '![Figure 5.16: The Infrastructure project in clean architecture](img/Figure_5.16_B17366.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16：整洁架构中的基础设施项目](img/Figure_5.16_B17366.jpg)'
- en: 'Figure 5.16: The Infrastructure project in clean architecture'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：整洁架构中的基础设施项目
- en: The last layer is `WebUI` (please refer to *Figure 5.13*). This is a single-page
    application that uses `Application` layer and the `Infrastructure` layer.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最外层是 `WebUI`（请参阅 *图 5.13*）。这是一个单页应用程序，它使用 `Application` 层和 `基础设施` 层。
- en: 'Many .NET solution templates support this architecture, which can be found
    on **GitHub** or **NuGet**. You can download one of the templates from NuGet to
    get started using the clean architecture. The following screenshot shows the NuGet
    command line required to install the same template that we used to explore this
    architecture:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 .NET 解决方案模板支持这种架构，你可以在 **GitHub** 或 **NuGet** 上找到它们。你可以从 NuGet 下载其中一个模板，以开始使用整洁架构。以下截图显示了安装我们用来探索此架构的相同模板所需的
    NuGet 命令行：
- en: '![Figure 5.17: The command line required to install the clean architecture
    solution template](img/Figure_5.17_B17366.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17：安装整洁架构解决方案模板所需的命令行](img/Figure_5.17_B17366.jpg)'
- en: 'Figure 5.17: The command line required to install the clean architecture solution
    template'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：安装干净架构解决方案模板所需的命令行
- en: In this section, we learned about clean architecture along with its main components.
    In the next section, we will explore microservices architecture, which is considered
    to be one of the modern architectures.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了干净架构及其主要组件。在下一节中，我们将探讨被认为是现代架构之一的微服务架构。
- en: Microservices architecture
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构
- en: 'The microservices architecture allows you to divide the solution into various
    components. Each component is completely independent of the other components,
    and it provides a particular service. The following diagram shows the microservices
    architecture:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构允许你将解决方案划分为各种组件。每个组件完全独立于其他组件，并提供了特定的服务。以下图表显示了微服务架构：
- en: '![Figure 5.18: The Microservices architecture style](img/Figure_5.18_B17366.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18：微服务架构风格](img/Figure_5.18_B17366.jpg)'
- en: 'Figure 5.18: The Microservices architecture style'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：微服务架构风格
- en: As per the preceding diagram, you can see that the microservices architecture
    consists of a collection of independent services. Each service is self-contained
    and should provide a single business capability within a business domain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图表，你可以看到微服务架构由一系列独立的服务组成。每个服务都是自包含的，并且应在业务域内提供单一的业务能力。
- en: 'Let''s examine the characteristics of this architecture pattern:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察这种架构模式的特点：
- en: '**Microservices** are small, autonomous, and loosely coupled services. Each
    service has its own code base, and it can be developed and maintained by a small
    team of developers.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务**是小型、自治且松散耦合的服务。每个服务都有自己的代码库，并且可以由一个小型开发团队开发和维护。'
- en: Each **service** should be self-contained and deployed separately. Updating
    one service won't require you to redeploy the entire solution.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个**服务**应该是自包含的，并且单独部署。更新一个服务不需要你重新部署整个解决方案。
- en: The services are responsible for having their own data access layer, as each
    service has a private database.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务负责拥有自己的数据访问层，因为每个服务都有自己的私有数据库。
- en: The internal implementation of each service is not visible nor accessible by
    any other service. The communication between the services is achieved through
    proper APIs.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务的内部实现对其他任何服务都是不可见且不可访问的。服务之间的通信是通过适当的 API 实现的。
- en: The **Client** app has no direct access to the services. Consuming these services
    is achieved through the API gateway, which forwards the call to the appropriate
    services.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**应用无法直接访问服务。通过 API 网关消费这些服务，它将调用转发到适当的服务。'
- en: 'The following screenshot shows a basic microservice project:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个基本的微服务项目：
- en: '![Figure 5.19: An example microservice project](img/Figure_5.19_B17366.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19：一个示例微服务项目](img/Figure_5.19_B17366.jpg)'
- en: 'Figure 5.19: An example microservice project'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19：一个示例微服务项目
- en: 'In the preceding screenshot, you can see an order microservice that is consumed
    by an e-commerce solution. The main components of this microservice project are
    as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到一个被电子商务解决方案消费的订单微服务。这个微服务项目的核心组件如下：
- en: '`Models`: These are the data entities that hold the properties mapped to database
    fields.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Models`：这些是包含映射到数据库字段的属性的数据实体。'
- en: '`OrderContext`: This derives the entity framework, `DBContexts`. It is a bridge
    between the entity order and the database.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderContext`：这个类从实体框架 `DBContexts` 派生。它是实体订单和数据库之间的桥梁。'
- en: '`OrderRepository`: This holds the CRUD functions, such as `GetOrder`, `CreateOrder`,
    and `UpdateOrder`. This class should implement the `IOrderRepository` interface.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderRepository`：这个类包含 CRUD 函数，例如 `GetOrder`、`CreateOrder` 和 `UpdateOrder`。这个类应该实现
    `IOrderRepository` 接口。'
- en: '`OrderController`: This is a class that is derived from `ControllerBase`. It
    contains all of the API RESTful actions.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderController`：这是一个从 `ControllerBase` 派生的类。它包含所有的 API RESTful 动作。'
- en: '`Docker`: This is the container that should simplify the deployment and testing
    of the microservice by bundling it along with all its dependencies into a single
    unit. It allows you to run the microservice in an isolated environment.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker`：这是一个容器，它应该通过将所有依赖项捆绑成一个单一单元来简化微服务的部署和测试。它允许你在隔离的环境中运行微服务。'
- en: The web API requests are handled by the `OrderController` class. The controller
    will call a function inside the repository that will use `DBContexts` along with
    the model to communicate with the database in order to return, add, or edit the
    requested data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Web API请求由`OrderController`类处理。控制器将调用存储库中的一个函数，该函数将使用`DBContexts`以及模型与数据库进行通信，以便返回、添加或编辑请求的数据。
- en: In the next section, we will explore service-oriented architecture.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨面向服务架构。
- en: Service-oriented architecture
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向服务架构
- en: '**Service-Oriented Architecture** (**SOA**) allows you to consume services
    that are available in the network. Its structure is similar to n-tier architecture;
    the difference is that the presentation layer can''t call the business layer directly,
    that is, it can only do so through the services. The following diagram shows the
    SOA in a layered structure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务架构**（**SOA**）允许您消费网络中可用的服务。其结构类似于n层架构；区别在于表示层不能直接调用业务层，也就是说，它只能通过服务来调用。以下图表显示了分层结构中的SOA：'
- en: '![Figure 5.20: SOA](img/Figure_5.20_B17366.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图5.20：SOA](img/Figure_5.20_B17366.jpg)'
- en: 'Figure 5.20: SOA'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20：SOA
- en: As you can see, the **Service Layer** is an abstraction layer located between
    the **Presentation Layer** and the **Business Layer**. With the existence of this
    layer, the **Presentation Layer** doesn't need to communicate directly with the
    **Business Layer**. In this scenario, you could change the **Business Layer**
    without affecting the **Presentation Layer**.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**服务层**是一个位于**表示层**和**业务层**之间的抽象层。有了这一层，**表示层**就不需要直接与**业务层**通信。在这种情况下，您可以更改**业务层**而不会影响**表示层**。
- en: '*What is the difference between microservices architecture and SOA?* Well,
    the answer is the scope. Microservices architecture is a cloud-based architecture;
    it promotes autonomous services that are self-contained, which target the application
    scope. While the SOA has an enterprise scope, each service does not need to have
    an independent database. It can handle multiple business capabilities; this is
    not the case for microservices, which only handle one single business capability
    at a time.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*微服务架构和SOA之间的区别是什么？* 好吧，答案是范围。微服务架构是一种基于云的架构；它促进自治服务，这些服务是自包含的，针对应用范围。而SOA具有企业范围，每个服务不需要有独立的数据库。它可以处理多个业务能力；微服务则不同，它一次只处理一个单一的业务能力。'
- en: 'Here is a list of .NET technologies that support you in the implementation
    of services (SOA):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个列表，列出了支持您实现服务的.NET技术（SOA）：
- en: '**.NET Web service**: This is based on the **Web Services Description Language**
    (**WSDL**) (which is also known as **XML Web Service**). It is a service layer
    that contains a set of functions that uses a standardized XML messaging system.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Web服务**：这是基于**Web服务描述语言**（**WSDL**）（也称为**XML Web服务**）。它是一个包含一组函数的服务层，这些函数使用标准化的XML消息系统。'
- en: '**Windows Communication Foundation** (**WCF**): This is part of the .NET Framework
    and is used to build service-oriented solutions. By using WCF, you can send any
    type of data, such as asynchronous messages, from one endpoint to another.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Communication Foundation**（**WCF**）：这是.NET框架的一部分，用于构建面向服务的解决方案。通过使用WCF，您可以从一个端点发送任何类型的数据，例如异步消息，到另一个端点。'
- en: '**ASP.NET RESTful Web API**: This is also part of the .NET Framework. It is
    used to build HTTP services that can be consumed by any type of application including
    web and mobile applications.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET RESTful Web API**：这也是.NET框架的一部分。它用于构建可以被任何类型的应用程序（包括Web和移动应用程序）消费的HTTP服务。'
- en: In this section, we explored some popular architecture patterns that can help
    us to create a solid foundation for our proposed solution. Adopting an architecture
    pattern is vital because it makes our platform more scalable and enhances the
    overall performance of the product. Additionally, it will prevent code redundancy.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了可以帮助我们为我们的解决方案创建坚实基础的一些流行的架构模式。采用架构模式至关重要，因为它使我们的平台更具可扩展性，并提高了产品的整体性能。此外，它将防止代码冗余。
- en: In the next section, we will explore another set of architecture patterns that
    you should know about.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨另一组您应该了解的架构模式。
- en: Exploring additional architecture patterns
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索其他架构模式
- en: In this section, we will dive into a set of additional architecture patterns
    that will allow you to perform high-level scalability and system decoupling. We
    will examine each pattern to understand how it functions. This will help us to
    build more optimized systems with reusable modules and an organized structure
    that allows for extensibility.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨一系列额外的架构模式，这些模式将使您能够执行高级可扩展性和系统解耦。我们将逐一研究每种模式，以了解其工作原理。这将帮助我们构建更优化的系统，其中包含可重用模块和有组织的结构，允许进行扩展。
- en: The serverless pattern
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端无服务器模式
- en: '**Serverless architecture** promotes cloud platforms and cloud-native code.
    It is a pattern that allows us to host our solution in a third-party infrastructure.
    Using this approach, the developers will no longer have to worry about managing
    the server software and hardware. This pattern allows us to break up our application
    into small and autonomous functions that can be triggered and scaled individually.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**无服务器架构**推广云平台和云原生代码。这是一种允许我们在第三方基础设施中托管解决方案的模式。使用这种方法，开发者将不再需要担心管理服务器软件和硬件。此模式允许我们将应用程序拆分为小型且自主的函数，这些函数可以单独触发和扩展。'
- en: 'The following diagram illustrates the serverless architecture of a single-page
    web application:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了单页Web应用的无服务器架构：
- en: '![Figure 5.21: The serverless architecture of a web app](img/Figure_5.21_B17366.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图5.21：Web应用的无服务器架构](img/Figure_5.21_B17366.jpg)'
- en: 'Figure 5.21: The serverless architecture of a web app'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21：Web应用的无服务器架构
- en: 'We can use the **Azure** serverless infrastructure to implement this pattern.
    Azure functions include the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**Azure**无服务器基础设施来实现此模式。Azure函数包括以下内容：
- en: '**CDN**: This stands for **Content Delivery Network**. It caches the content
    for a better response time.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CDN**：这代表**内容分发网络**。它缓存内容以获得更好的响应时间。'
- en: '**Azure Blob Storage**: This allows you to store large, unstructured data on
    **Microsoft**''s data storage platform.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Blob Storage**：这允许您在**微软**的数据存储平台上存储大量非结构化数据。'
- en: '**Function App**: This is an event-driven model that provides the capabilities
    to create autonomous functions that are triggered by the client through HTTP requests.
    The routing of the requests is managed by the API gateway, which is described
    next.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Function App**：这是一个事件驱动的模型，它提供了通过HTTP请求由客户端触发的自主函数的能力。请求的路由由API网关管理，将在下文中描述。'
- en: '**API Management**: This is an API gateway that is located in front of the
    functions. It allows you to decouple the frontend app from the functions located
    in the backend. With this API management, we can rewrite the HTTP URLs and manage
    requests before they reach the concrete functions in the backend. Azure API management
    is also used to overcome cross-cutting concerns such as the following:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API Management**：这是一个位于函数前面的API网关。它允许您将前端应用程序与后端中定位的函数解耦。使用这种API管理，我们可以在请求到达后端具体函数之前重写HTTP
    URL并管理请求。Azure API管理还用于克服以下跨领域关注点：'
- en: a. Caching HTTP responses
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 缓存HTTP响应
- en: b. Monitoring and audit logging HTTP requests
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 监控和审计日志HTTP请求
- en: c. Enabling **Cross-Origin Requests Sharing** (**CORS**), which enables access
    across domains
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 启用**跨源请求共享**（**CORS**），允许跨域访问
- en: d. Enforcing policies such as checking HTTP requests and applying call rates
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 强制执行策略，如检查HTTP请求并应用调用速率
- en: e. Protecting your API by enforcing an authentication mechanism by using **Auth2.0
    authorization** with **Azure Active Directory (Azure AD)**
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e. 通过使用**Auth2.0授权**与**Azure Active Directory (Azure AD**)强制执行认证机制来保护您的API
- en: '**Azure Cosmos DB**: This is a **NoSQL** database service provided by Azure
    to build modern applications.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Cosmos DB**：这是Azure提供的**NoSQL**数据库服务，用于构建现代应用程序。'
- en: '**Azure AD**: This is the cloud version of the regular active directory. It
    is used to authenticate users.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure AD**：这是常规活动目录的云版本。它用于验证用户。'
- en: '**Azure Monitor**: This collects performance metrics about the solution and
    the usage of resources.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Monitor**：它收集有关解决方案和资源使用的性能指标。'
- en: '**Azure Pipelines**: This is another service provided by Microsoft Azure. It
    provides **Continuous Integration** (**CI**) and **Continuous Delivery** (**CD**)
    services to automatically build, test, and deploy your code to any accessible
    target.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Pipelines**：这是由Microsoft Azure提供的另一项服务。它提供**持续集成**（**CI**）和**持续交付**（**CD**）服务，以自动构建、测试和部署您的代码到任何可访问的目标。'
- en: This pattern is perfect if you wish to implement the microservices architecture
    or if you want to scale your solution and benefit from pay-as-you-go services.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望实现微服务架构或想要扩展解决方案并从按需付费服务中受益，此模式非常完美。
- en: The client-server pattern
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器模式
- en: 'A **client-server pattern** is a network architecture that involves two types
    of entities: the clients and the server. It is used in scenarios where you have
    a server playing the role of a service provider and multiple clients playing the
    role of service consumers. The following diagram describes the logic behind this
    architecture:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端-服务器模式**是一种涉及两种类型实体的网络架构：客户端和服务器。它用于有服务器扮演服务提供者角色，而多个客户端扮演服务消费者角色的场景。以下图描述了该架构背后的逻辑：'
- en: '![Figure 5.22: Client-server architecture](img/Figure_5.22_B17366.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22：客户端-服务器架构](img/Figure_5.22_B17366.jpg)'
- en: 'Figure 5.22: Client-server architecture'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：客户端-服务器架构
- en: As you see in the preceding diagram, the **Client** components send an HTTP
    request over the **TCP/IP** protocol to the server. The request is processed,
    and the server connects to the database **Server** and then responds back to the
    **Client**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前图所示，**客户端**组件通过 **TCP/IP** 协议向服务器发送 HTTP 请求。请求被处理，服务器连接到数据库 **服务器**，然后向 **客户端**
    发送响应。
- en: The event-driven pattern
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动模式
- en: '**Event-driven architecture** is another pattern that allows us to highly decouple
    our applications. It is a pattern that consists of a set of services. Each service
    works asynchronously and publishes an event when its data is updated. The client
    components subscribe to the events to receive or send updates.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动架构**是另一种允许我们高度解耦应用程序的模式。它是一组服务的集合。每个服务异步工作，并在其数据更新时发布事件。客户端组件订阅事件以接收或发送更新。'
- en: Let's assume that we are building an e-commerce solution where customers are
    using coupon codes while submitting an order. The system must ensure that the
    coupon code is only used once by the same customer. Since the customer information,
    the number of orders, and the coupon code details are located in different databases,
    the system cannot simply verify the usage of the coupon code. The solution is
    to use the event-driven pattern to maintain data consistency across the different
    services.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个电子商务解决方案，其中客户在提交订单时使用优惠券代码。系统必须确保同一客户只能使用一次优惠券代码。由于客户信息、订单数量和优惠券代码详情位于不同的数据库中，系统不能简单地验证优惠券代码的使用情况。解决方案是使用事件驱动模式来维护不同服务之间的数据一致性。
- en: 'The following diagram shows the Azure event-driven architecture:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了 Azure 事件驱动架构：
- en: '![Figure 5.23: Event-driven architecture](img/Figure_5.23_B17366.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23：事件驱动架构](img/Figure_5.23_B17366.jpg)'
- en: 'Figure 5.23: Event-driven architecture'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23：事件驱动架构
- en: In the preceding diagram, pay attention to how the **HR Application** is subscribing
    to the **Employee Events** and each event has its own logic and database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前图中，请注意 **HR 应用程序** 如何订阅 **员工事件**，以及每个事件都有其自己的逻辑和数据库。
- en: The pipe-filter pattern
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道-过滤器模式
- en: 'The **pipe-filter pattern** consists of splitting a complex process into a
    group of smaller tasks. This approach is expected to improve the performance of
    our application as well as the reusability and maintainability of each task. A
    single event triggers a sequence of multiple steps, with each performing a specific
    task. The following diagram shows an example process that has been implemented
    using the pipe-filter architecture:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**管道-过滤器模式**由将复杂过程分解成一组较小任务组成。这种方法预计将提高我们应用程序的性能，以及每个任务的复用性和可维护性。单个事件触发一系列多个步骤，每个步骤执行特定的任务。以下图显示了使用管道-过滤器架构实现的示例过程：'
- en: '![Figure 5.24: The pipe-filter pattern](img/Figure_5.24_B17366.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.24：管道-过滤器模式](img/Figure_5.24_B17366.jpg)'
- en: 'Figure 5.24: The pipe-filter pattern'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24：管道-过滤器模式
- en: A good example of this pattern is **Azure Data Factory**, which allows you to
    create data-driven automated workflows in the cloud for data extraction, analysis
    and transformation, and loading.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Data Factory** 是此模式的良好示例，它允许您在云中创建数据驱动的自动化工作流，用于数据提取、分析和转换以及加载。'
- en: In this section, we explored a set of architectural patterns that you should
    know about. Each one offers a unique methodology of implementation and delivers
    key advantages to your solution. In the next section, we will learn how to choose
    the right architecture pattern when designing a solution.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了一系列你应该了解的架构模式。每一种都提供了一种独特的实现方法，并为你的解决方案带来了关键优势。在下一节中，我们将学习如何在设计解决方案时选择正确的架构模式。
- en: Choosing the right patterns
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的模式
- en: In the previous sections, we learned about major architectural patterns. However,
    you must have noticed that there are a few patterns that we didn't discuss in
    this chapter. In fact, some patterns will be introduced in the future. So, you
    will need a way in which to analyze a pattern and decide whether you want to choose
    it or not. One question that you could be asked is *how do we choose the right
    pattern for our solution?* Let's dig deep into this matter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了主要的架构模式。然而，你可能已经注意到，在这一章中我们没有讨论一些模式。实际上，一些模式将在未来介绍。因此，你需要一种方法来分析一个模式，并决定你是否想选择它。你可能会被问到的一个问题是*我们如何为我们的解决方案选择正确的模式？*
    让我们深入探讨这个问题。
- en: Architecture design is the cornerstone of a solid and successful system. However,
    there is no one-size-fits-all solution when it comes to choosing the right architecture
    for your solution. Various perspectives should be taken into account when you
    want to decide which architecture pattern to use.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 架构设计是构建稳固和成功系统的基石。然而，在选择适合你解决方案的正确架构时，并没有一种适合所有情况的解决方案。当你想要决定使用哪种架构模式时，应该考虑各种不同的视角。
- en: 'Put simply, the main selection criterion for choosing an architecture pattern
    is based on three factors:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，选择架构模式的主要标准基于三个因素：
- en: '**Software engineers** (who will work on the project): Software engineers should
    be familiar with the architecture you are proposing. This is so that they can
    easily navigate through the solution structure and start implementing new features
    as per the requirements. Then, at a later stage, when the product is delivered,
    it should be clear and straightforward to them how to fix any defects and which
    layers need to be modified. This is a very important factor to consider in order
    for the team to work efficiently and deliver a successful and stable product.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件工程师**（将参与项目）：软件工程师应该熟悉你提出的架构。这样，他们可以轻松地导航解决方案结构，并根据需求开始实现新功能。然后，在产品交付的后期，他们应该能够清楚地了解如何修复任何缺陷以及哪些层需要修改。这是团队高效工作并交付成功稳定产品的一个重要因素。'
- en: '**Client**: From the clients'' perspective, they are looking for a good quality
    product while maintaining efficiency. Additionally, they want to make sure that
    the implemented architecture can support additional features and modifications
    even after releasing the product. They want their product to be well-architected,
    scalable, and easy to maintain.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户**: 从客户的角度来看，他们寻求的是在保持效率的同时，获得高质量的产品。此外，他们还希望确保实施后的架构能够在产品发布后支持额外的功能和修改。他们希望他们的产品具有良好的架构、可扩展性和易于维护。'
- en: '**Product type**: Note that it is not a good practice to select an architecture
    pattern just because it is widely popular or because it is trendy. Don''t assume
    that this will deliver a better product. However, an architecture pattern should
    be selected based on your requirements and the type of solution we want to build.
    This will allow you to deliver a successful product.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品类型**: 注意，仅仅因为某个架构模式广受欢迎或流行，就选择它并不是一个好的做法。不要假设这样做会带来更好的产品。然而，架构模式的选择应该基于你的需求和我们要构建的解决方案类型。这将使你能够交付一个成功的产物。'
- en: 'We have explored the three main factors that should affect your selection of
    the architecture. Furthermore, here is a criterion list with key characteristics
    that you should consider when selecting an architecture pattern:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了应该影响你选择架构的三个主要因素。此外，这里有一个关键特征列表，当你选择架构模式时你应该考虑：
- en: '**Agility**: We should consider choosing the architecture that allows for high
    agility, which helps us to embrace and implement additional features and changes
    easily.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏捷性**: 我们应该考虑选择允许高度敏捷的架构，这有助于我们轻松拥抱和实施额外的功能和变更。'
- en: '**Ease of deployment**: The architecture we choose should allow us to easily
    deploy the product.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署的便捷性**: 我们选择的架构应该使我们能够轻松部署产品。'
- en: '**Testability**: The architecture should allow for a high testability rate.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**: 架构应该允许实现高可测试性。'
- en: '**Performance**: This is an important factor. The architecture should allow
    for a high-performance rate.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**: 这是一个重要的因素。架构应该允许实现高效率。'
- en: '**Scalability**: The architecture must allow us to scale our system, which
    means increasing its capacity.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**: 架构必须允许我们扩展我们的系统，这意味着增加其容量。'
- en: '**Ease of development**: The architecture should be well known by developers
    to ensure the easy development and implementation of the product. It should allow
    developers to troubleshoot the system and fix defects when needed.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发简便性**: 架构应该被开发者所熟知，以确保产品的开发和实施简便。它应该允许开发者在需要时对系统进行故障排除和修复缺陷。'
- en: One of the primary reasons that might cause complete system failure is choosing
    the wrong architecture pattern. That's why it is important to choose the right
    architecture pattern for your system, as it will solve various problems that you
    might face during the several phases of the project life cycle.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可能导致系统完全失败的主要原因之一是选择了错误的架构模式。这就是为什么选择适合您系统的正确架构模式很重要，因为它将解决你在项目生命周期几个阶段可能遇到的各种问题。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored key architecture patterns that are widely used
    in many solutions along with some modern patterns, such as clean architecture
    and microservices architecture. We also learned about a set of important architectural
    patterns that allow you to perform system decoupling and scalability. Finally,
    in this chapter, we explored the key factors that you need to consider when choosing
    the right architecture pattern.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在许多解决方案中广泛使用的核心架构模式，以及一些现代模式，如清洁架构和微服务架构。我们还了解了一系列重要的架构模式，这些模式允许你进行系统解耦和可扩展性。最后，在本章中，我们探讨了在选择合适的架构模式时需要考虑的关键因素。
- en: In the next chapter, we will dig deep into core architecture considerations,
    such as the design quality attributes and how to properly plan for system caching,
    exception handling, and deployment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨核心架构考虑因素，例如设计质量属性以及如何合理规划系统缓存、异常处理和部署。
