- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Advanced Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级单元测试
- en: As we’ve seen, testing is incredible and can give you the freedom to effectively
    refactor your code in relative safety. Sometimes, code is written in a way that
    makes testing difficult and you need a few more tools. In this chapter, we’ll
    explore a handful of popular .NET libraries that can improve the readability of
    your tests and give you more options for testing code – including those tricky
    classes with complex data or dependencies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，测试非常强大，可以给你在相对安全的情况下有效地重构代码的自由。有时，代码的编写方式使得测试变得困难，你需要一些额外的工具。在本章中，我们将探讨一些流行的.NET库，这些库可以提高你测试的可读性，并为你提供更多的测试代码选项——包括那些具有复杂数据或依赖关系的棘手类。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨以下主题：
- en: Creating readable tests with Shouldly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Shouldly创建可读性强的测试
- en: Generating test data with Bogus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bogus生成测试数据
- en: Mocking dependencies with Moq and NSubstitute
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Moq和NSubstitute模拟依赖项
- en: Pinning tests with Snapper
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Snapper固定测试
- en: Experimenting with Scientist .NET
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scientist .NET的实验
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is available from GitHub at https://github.com/PacktPublishing/Refactoring-with-CSharp
    in the `Chapter09` folder.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以从GitHub的`Chapter09`文件夹中获取，链接为https://github.com/PacktPublishing/Refactoring-with-CSharp。
- en: 'Libraries change with new releases and some of these changes may cause issues
    with code in this chapter. Because of this, here are the exact names and versions
    of the libraries that are used in this chapter at the time of writing:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 库会随着新版本的发布而发生变化，其中一些变化可能会影响本章中的代码。因此，以下是本章编写时使用的库的确切名称和版本：
- en: '**Bogus 34.0.2**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bogus 34.0.2**'
- en: '**FluentAssertions 6.11.0**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FluentAssertions 6.11.0**'
- en: '**Moq 4.20.2**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Moq 4.20.2**'
- en: '**NSubstitute 5.0.0**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NSubstitute 5.0.0**'
- en: '**Scientist 2.0.0**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scientist 2.0.0**'
- en: '**Shouldly 4.2.1**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shouldly 4.2.1**'
- en: '**Snapper 2.4.0**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Snapper 2.4.0**'
- en: Creating readable tests with Shouldly
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Shouldly创建可读性强的测试
- en: 'In [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133), we saw how the `Assert`
    class is used to verify the behavior of existing classes through code such as
    the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第六章*](B21324_06.xhtml#_idTextAnchor133)中，我们看到了如何使用`Assert`类通过如下代码来验证现有类的行为：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code verifies that `passengerCount` is equal to `35` and fails the test
    if it is a different number.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码验证`passengerCount`是否等于`35`，如果不同则测试失败。
- en: 'Unfortunately, this code has two problems:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码有两个问题：
- en: Assert methods take in the expected value first and the actual value second.
    This is different than how most people think about things and can lead to confusing
    test failure messages, as we saw in [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言方法首先接受预期值，然后是实际值。这与大多数人思考事物的方式不同，可能会导致令人困惑的测试失败消息，正如我们在[*第六章*](B21324_06.xhtml#_idTextAnchor133)中看到的。
- en: The code doesn’t read incredibly well in English, which can slow you down as
    you are reading tests.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码用英语读起来并不十分流畅，这可能会在你阅读测试时减慢你的速度。
- en: Several open-source libraries address this issue by providing an alternative
    syntax for writing assertions in unit tests through sets of extension methods
    they introduce.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 几个开源库通过引入一系列扩展方法，为编写单元测试中的断言提供替代语法，来解决这一问题。
- en: The most popular of these libraries are FluentAssertions and Shouldly. While
    FluentAssertions is by far the more popular library, I find Shouldly to read more
    naturally, so we’ll start with that.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最受欢迎的库是FluentAssertions和Shouldly。虽然FluentAssertions是迄今为止最受欢迎的库，但我发现Shouldly的阅读起来更自然，所以我们将从它开始。
- en: Let’s look at installing Shouldly and getting started with its syntax before
    looking at a similar example with FluentAssertions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看FluentAssertions的类似示例之前，让我们先看看如何安装Shouldly以及如何开始使用其语法。
- en: Installing the Shouldly NuGet package
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Shouldly NuGet包
- en: Shouldly is not a library that is included by default in any project template
    built into Visual Studio. Because of this, we need to add it to our project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Shouldly不是Visual Studio中任何项目模板默认包含的库。因此，我们需要将其添加到我们的项目中。
- en: In Visual Studio, we use a **package manager** called **NuGet Package Manager**
    to install external dependencies from package sources such as the one at [nuget.org](http://nuget.org).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，我们使用名为**NuGet包管理器**的**包管理器**来从包源（如[nuget.org](http://nuget.org)）安装外部依赖项。
- en: If you’ve programmed in JavaScript, this concept is very similar to JavaScript
    package managers such as Yarn or NPM. While other package managers download the
    code and have you compile it, NuGet downloads *compiled* versions of external
    code and allows your code to reference things defined in those projects without
    slowing your build process.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 JavaScript 进行编程，那么这个概念与 JavaScript 包管理器如 Yarn 或 NPM 非常相似。虽然其他包管理器会下载代码并让你进行编译，但
    NuGet 会下载 *编译* 版本的代码，并允许你的代码引用那些项目中定义的内容，而不会减慢你的构建过程。
- en: To install a package, right-click on the `Chapter9Tests` project in **Solution
    Explorer** and choose **Manage** **NuGet Packages**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装一个包，在 **解决方案资源管理器** 中右键点击 `Chapter9Tests` 项目，然后选择 **管理** **NuGet 包**。
- en: 'Next, click on the `Shouldly` in the search bar. Your search results should
    look something like those in *Figure 9**.1*:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在搜索栏中点击 `Shouldly`。你的搜索结果应该类似于 *图 9**.1* 中的那些：
- en: '![Figure 9.1 – NuGet Package Manager showing results for Shouldly](img/B21324_09_1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 显示 Shouldly 结果的 NuGet 包管理器](img/B21324_09_1.jpg)'
- en: Figure 9.1 – NuGet Package Manager showing results for Shouldly
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 显示 Shouldly 结果的 NuGet 包管理器
- en: You should see an entry named Shouldly by Jake Ginnivan et al. in the list on
    the left. Select it by clicking on it. The details on the right will then list
    information about this package, including its license terms and dependencies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在左侧的列表中看到一个名为 Shouldly 的条目，作者是 Jake Ginnivan 等。通过点击它来选择它。右侧的详细信息将列出有关此包的信息，包括其许可条款和依赖项。
- en: Tip
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always check the author and the exact name of the package you are looking for
    as many have similar names.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总是检查你正在寻找的作者和包的确切名称，因为许多包有类似的名字。
- en: Using the **Version** dropdown in the details area on the right, you can choose
    the specific version of the library to install. Usually, it’s fine to leave this
    as the latest stable version, but occasionally, you may need to select a prior
    version for compatibility purposes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用右侧详细信息区域的 **Version** 下拉菜单，你可以选择要安装的库的特定版本。通常，保持为最新稳定版本是没问题的，但偶尔你可能需要为了兼容性选择一个早期版本。
- en: 'When you click **Install**, Shouldly and anything it depends on will automatically
    be downloaded and installed into your project. When installing packages, a window
    may open showing you various license terms or dependencies, such as those shown
    in *Figure 9**.2*. Read these carefully, especially if you are using a library
    in your workplace:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 **安装** 时，Shouldly 及其依赖项将自动下载并安装到你的项目中。在安装包时，可能会打开一个窗口显示各种许可条款或依赖项，如 *图
    9**.2* 所示。请仔细阅读这些内容，特别是如果你在办公场所使用库的话：
- en: '![Figure 9.2 – Dependencies needed to install Shouldly](img/B21324_09_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 安装 Shouldly 所需的依赖项](img/B21324_09_2.jpg)'
- en: Figure 9.2 – Dependencies needed to install Shouldly
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 安装 Shouldly 所需的依赖项
- en: Now that we have Shouldly installed, let’s learn how to work with it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Shouldly，让我们学习如何使用它。
- en: Writing readable assertions with Shouldly
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Shouldly 编写可读的断言
- en: 'In `PassengerTests.cs`, there’s an existing `PassengerFullNameShouldBeAccurate`
    test that instantiates a `Passenger` object, grabs the value out of the object’s
    `FullName` field, and makes sure the resulting name matches the expected value,
    as shown in the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PassengerTests.cs` 文件中，有一个现有的 `PassengerFullNameShouldBeAccurate` 测试，它会实例化一个
    `Passenger` 对象，从对象的 `FullName` 字段中获取值，并确保生成的名称与预期值匹配，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using Shouldly, we can make this assertion a lot more readable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Shouldly，我们可以使这个断言变得更加易读。
- en: 'First, let’s add a `Usings.cs` file by adding a `using` for Shouldly at the
    end of that file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过在该文件的末尾添加一个 `using` 语句来添加一个 `Usings.cs` 文件：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `global using` directive allows you to work with things in the Shouldly
    namespace anywhere in the `Chapter9Tests` project. Put another way, it is the
    equivalent of if every file in the project had a `using Shouldly;` statement at
    the top of the file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这 `global using` 指令允许你在 `Chapter9Tests` 项目的任何地方使用 Shouldly 命名空间中的内容。换句话说，它等同于在项目的每个文件顶部都有一个
    `using Shouldly;` 语句。
- en: 'Now that we have Shouldly installed and its namespace imported, we can rewrite
    the assertion from earlier by using one of the many extension methods provided
    by Shouldly, as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Shouldly 并导入了其命名空间，我们可以通过使用 Shouldly 提供的许多扩展方法之一来重写之前的断言，如下所示：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, Shouldly adds a `ShouldBe` extension method to the `string`, allowing
    us to call this method in a very readable way. This code is functionally equivalent
    to `Assert.Equal`, but it is significantly more readable. Additionally, you are
    far less likely to confuse which parameter is the expected value versus the actual
    value under this way of working with things.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Shouldly 为 `string` 类型添加了一个 `ShouldBe` 扩展方法，使我们能够以非常可读的方式调用此方法。此代码在功能上等同于
    `Assert.Equal`，但可读性显著更高。此外，使用这种方式处理问题时，你混淆预期值和实际值的可能性要小得多。
- en: Shouldly has a wide variety of extension methods, including `ShouldBe`, `ShouldNotBe`,
    `ShouldBeGreaterThan`/`ShouldBeLessThan`, `ShouldContain`, `ShouldNotBeNull`/`ShouldBeNull`,
    `ShouldStartWith`/`ShouldEndWith`, and more.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Shouldly 提供了各种扩展方法，包括 `ShouldBe`、`ShouldNotBe`、`ShouldBeGreaterThan`/`ShouldBeLessThan`、`ShouldContain`、`ShouldNotBeNull`/`ShouldBeNull`、`ShouldStartWith`/`ShouldEndWith`
    等。
- en: 'To illustrate this, let’s look at a more complex test written without Shouldly:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看看一个没有使用 Shouldly 编写的更复杂的测试：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code uses `FlightScheduler` to schedule a flight using the Bogus library,
    which we’ll discuss later in this chapter. Once a flight has been scheduled, the
    code gets all the flights and asserts that the resulting collection is not null,
    has only one item, and the flight we scheduled is in that collection.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用 `FlightScheduler` 和 Bogus 库（我们将在本章后面讨论）来安排航班。一旦航班被安排，代码将获取所有航班，并通过 `Should().Be(60m)`
    语法断言结果集合不为空，只有一个项目，并且我们安排的航班在该集合中。
- en: 'This code isn’t too bad, but I still prefer the Shouldly version:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不糟糕，但我仍然更喜欢 Shouldly 版本：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In general, I find the Shouldly library to have more consistent parameter ordering
    and result in more readable tests. Because of this, I find myself more productive
    and use Shouldly wherever I can.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我发现 Shouldly 库具有更一致的参数排序，并导致更可读的测试。正因为如此，我在尽可能的地方使用 Shouldly，这使我更加高效。
- en: Practice exercise
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: As an exercise, I’d encourage you to take the starting code for this chapter
    and convert the various tests so that they use Shouldly instead of standard assertions.
    Feel free to experiment with other assertions as you go. This chapter’s final
    code uses Shouldly if you want to check your answers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，我鼓励你使用本章的起始代码，将各种测试转换为使用 Shouldly 而不是标准断言。在实验过程中，你可以自由地尝试其他断言。本章的最终代码使用
    Shouldly，如果你想要检查你的答案。
- en: Before we see what else Shouldly can do, let’s look at FluentAssertions, a popular
    library fulfilling a similar role as Shouldly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解 Shouldly 还能做什么之前，让我们看看 FluentAssertions，这是一个流行的库，它在功能上与 Shouldly 类似。
- en: Writing readable assertions with FluentAssertions
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 FluentAssertions 编写可读性强的断言
- en: FluentAssertions does the same thing that Shouldly does, but the approach of
    its syntax is less oriented on calling single methods like Shouldly’s `ShouldContain`.
    Instead, FluentAssertions prefers chaining together several method calls to produce
    a similar result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: FluentAssertions 做的是 Shouldly 做的事情，但其语法的处理方式不太倾向于调用单个方法，如 Shouldly 的 `ShouldContain`。相反，FluentAssertions
    更倾向于将多个方法调用链式连接起来以产生类似的结果。
- en: 'Let’s look at a test of the baggage pricing system as an illustration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个行李定价系统的测试来举例说明：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code creates `BaggageCalculator` and then sends a series of factors to
    that calculator’s `CalculatePrice` method before performing its assertions via
    the `Should().Be(60m)` syntax.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了 `BaggageCalculator`，然后向该计算器的 `CalculatePrice` 方法发送一系列因素，在通过 `Should().Be(60m)`
    语法进行断言之前执行。
- en: Before we explore this in more depth, I should point out that, like Shouldly,
    FluentAssertions does not come pre-installed. You’ll need to install FluentAssertions
    with NuGet Package Manager, the same way you did earlier for Shouldly. You’ll
    also need to add a `using FluentAssertions;` statement to your code file to see
    the FluentAssertions extension methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨这个话题之前，我应该指出，与 Shouldly 一样，FluentAssertions 也不是预安装的。你需要使用 NuGet 包管理器安装
    FluentAssertions，就像你之前安装 Shouldly 一样。你还需要在你的代码文件中添加一个 `using FluentAssertions;`
    语句，以便看到 FluentAssertions 扩展方法。
- en: Now that we’ve established how to get started with FluentAssertions, let’s take
    a closer look at that `result.Should().Be(60m)` syntax.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何开始使用 FluentAssertions，让我们更仔细地看看那个 `result.Should().Be(60m)` 语法。
- en: Most actions in FluentAssertions flow out of the `Should` methods. Notice that
    there are multiple `Should` methods in FluentAssertions, with each one related
    to a specific type of data you might work with.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: FluentAssertions 中的大多数操作都源于 `Should` 方法。请注意，FluentAssertions 中有多个 `Should` 方法，每个方法都与你可能处理的一种特定类型的数据相关。
- en: These `Should` methods return a strongly-typed object such as `NumericAssertions<decimal>`
    in the case of the calculator assertions. These assertion objects contain various
    constraint methods, allowing you to do targeted assertions such as `Be`, `NotBe`,
    `BeLessThan`, `BePositive`, `BeOneOf`, and others.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`Should`方法返回一个强类型对象，例如在计算器断言的情况下是`NumericAssertions<decimal>`。这些断言对象包含各种约束方法，允许你进行有针对性的断言，如`Be`、`NotBe`、`BeLessThan`、`BePositive`、`BeOneOf`等。
- en: 'There are a few advantages to the FluentAssertions approach:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: FluentAssertions方法有几个优点：
- en: It’s easier to find assertion methods since they all go through `Should()`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们都通过`Should()`进行，因此更容易找到断言方法。
- en: The constraint methods allow you to combine assertions such as `result.Should().BePositive().And.BeInRange(50,
    70)`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束方法允许你组合断言，例如`result.Should().BePositive().And.BeInRange(50, 70)`。
- en: Unfortunately, FluentAssertions has a slightly higher learning curve and is
    a little more verbose than Shouldly, which might result in slightly less readable
    tests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，FluentAssertions的学习曲线略高，并且比Shouldly更冗长，这可能会导致测试的可读性略低。
- en: Ultimately, it’s up to you and your team as to what style you prefer, but both
    Shouldly and FluentAssertions can significantly improve the readability of your
    tests and your enjoyment of the test writing experience.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，选择哪种风格取决于你和你所在的团队，但Shouldly和FluentAssertions都可以显著提高你测试的可读性以及编写测试体验的愉悦感。
- en: Before we introduce our next new library, let’s talk about one more thing Shouldly
    can do that might be helpful.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍下一个新库之前，让我们再谈一谈Shouldly可能有所帮助的另一个功能。
- en: Testing performance with Shouldly
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Shouldly测试性能
- en: One of the reasons people find themselves refactoring code is to look for ways
    of improving the performance of code that is known to be slow.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 人们发现自己需要重构代码的一个原因是为了寻找提高已知运行缓慢的代码性能的方法。
- en: Imagine you are following **Test-Driven Development** (**TDD**) and are investigating
    code that takes an unacceptably long time to iterate through a list of items.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在遵循**测试驱动开发**（**TDD**），正在调查一个迭代列表项所需时间过长的不接受代码。
- en: The first step in TDD is to write a failing test, so you now need to write a
    test that fails if the performance of a method is too slow.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的第一步是编写一个失败的测试，所以你现在需要编写一个测试，如果方法的性能太慢，这个测试就会失败。
- en: We’ll talk about reasons why you might not want to write a test around performance
    in a bit, but let’s explore how you would go about testing performance first.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论为什么你可能不想围绕性能编写测试的原因，但首先让我们探讨如何进行性能测试。
- en: 'In order to fail tests involving code that performs too slowly, you’d need
    to be able to measure how long that code took to run. To do that, you could create
    a `Stopwatch` object, start it, stop it, and then verify the duration of that
    watch, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使涉及执行过慢代码的测试失败，你需要能够测量该代码运行所需的时间。为此，你可以创建一个`Stopwatch`对象，启动它，停止它，然后验证该计时器的持续时间，如下所示：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code will fail if it takes more than 100 milliseconds (0.1 seconds) to
    run `ScheduleFlight`, but this approach has a couple of disadvantages:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ScheduleFlight`的运行时间超过100毫秒（0.1秒），这段代码将会失败，但这种方法有几个缺点：
- en: There’s a lot of setup code required for this approach. In this case, over half
    of the test method is devoted to `Stopwatch`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法需要大量的设置代码。在这种情况下，测试方法中超过一半的代码都是关于`Stopwatch`的。
- en: The test waits for the method to complete before the test is failed. If it takes
    10 seconds to complete the method, the test waits the full time. This is inefficient
    because once the 100-millisecond threshold is crossed, the test will never pass.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试在方法完成之前等待方法，如果方法需要10秒才能完成，测试将等待整个时间。这是低效的，因为一旦超过100毫秒的阈值，测试将永远不会通过。
- en: 'Shouldly gives us a more compact `Should.CompleteIn` method that solves both
    problems:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Shouldly提供了一个更紧凑的`Should.CompleteIn`方法，它解决了这两个问题：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code creates an action to schedule the flight that Shouldly will invoke
    as part of the test. This action isn’t invoked until it is passed into the `Should.CompleteIn`
    method, which also requires a maximum amount of time to allow the method to run.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个动作来安排航班，Shouldly将在测试过程中调用这个动作。这个动作只有在传递给`Should.CompleteIn`方法时才会被调用，这个方法还要求允许方法运行的最大时间量。
- en: When Shouldly runs your action, it tracks the elapsed time internally and will
    cancel your action and fail the test once that threshold is reached. This results
    in more compact test code that won’t take longer than the maximum allowable amount
    of time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当Shouldly运行你的操作时，它会内部跟踪经过的时间，一旦达到那个阈值，就会取消你的操作并使测试失败。这导致测试代码更加紧凑，不会超过最大允许的时间。
- en: So, now that we know how to write simple performance tests using Shouldly or
    plain old .NET with `Stopwatch`, let’s talk about why you might not want to do
    this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经知道了如何使用Shouldly或普通的.NET和`Stopwatch`编写简单的性能测试，让我们谈谈为什么你可能不想这样做。
- en: Good tests should be fast and result in a repeatable result. Tests will be run
    by a variety of machines in a variety of different circumstances, such as when
    the processor has relatively little work to do or when the processor is completely
    overloaded. Tests may also be run in isolation or parallel, alongside, other tests.
    Additionally, with .NET, it is normal to see variations in performance from run
    to run.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 好的测试应该是快速的，并产生可重复的结果。测试将在各种不同的机器和不同的情况下运行，例如当处理器相对较少的工作要做或当处理器完全超载时。测试也可能在隔离或并行的情况下运行，与其他测试一起。此外，在使用.NET时，看到性能的运行间变化是正常的。
- en: All these things mean that performance testing is going to be more chaotic than
    you like and the maximum allowable duration is something you should consider carefully.
    If your tests are run in a **continuous integration/continuous delivery** (**CI/CD**)
    pipeline (which they should be, as we’ll talk about in *Part 4* of this book),
    it’s likely that the build machine’s CPU and memory characteristics look nothing
    like a developer workstation. To combat this, you may need to pick a significantly
    higher number than you normally would to avoid random failures due to a slow test
    environment. On the other hand, if you make your timeout too long, you won’t detect
    legitimate performance issues.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着性能测试可能会比你想象的更加混乱，最大允许的持续时间是你应该仔细考虑的事情。如果你的测试是在**持续集成/持续交付**（**CI/CD**）管道中运行的（它们应该如此，正如我们在本书的*第4部分*中将要讨论的），那么构建机器的CPU和内存特性可能根本不像开发工作站的。为了应对这种情况，你可能需要选择一个比平时显著更高的数字，以避免由于缓慢的测试环境导致的随机失败。另一方面，如果你将超时设置得太长，你将无法检测到真正的性能问题。
- en: My general stance is that performance testing is something that should rarely
    ever be codified into unit tests due to the chaotic nature of performance metrics
    and the wide variety of machines that might run tests. Instead, I tend to prefer
    periodic profiling using a dedicated tool such as **Visual Studio Enterprise**
    or **JetBrains dotTrace** for those areas that are truly critical to performance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我的总体立场是，由于性能指标的不确定性和可能运行测试的机器种类繁多，性能测试很少应该被编码到单元测试中。相反，我倾向于更喜欢定期使用像**Visual
    Studio Enterprise**或**JetBrains dotTrace**这样的专用工具对那些真正对性能至关重要的区域进行性能分析。
- en: That said, there is value in performance tests, but you may spend more time
    than you’d expect finding a good maximum test duration number.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，性能测试确实有其价值，但你可能会花费比你预期的更多时间来找到一个好的最大测试持续时间数字。
- en: 'Let’s move on to another library that makes your life easier when testing:
    **Bogus**.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续介绍另一个使测试更容易的库：**Bogus**。
- en: Generating test data with Bogus
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bogus生成测试数据
- en: In [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133), I mentioned that tests are
    a form of documentation that explains how your system should work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B21324_06.xhtml#_idTextAnchor133)中，我提到测试是一种文档形式，它解释了你的系统应该如何工作。
- en: 'Keeping that in mind, look at the following test, which tests the interaction
    of the `Passenger` and `BoardingProcessor` classes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，看看以下测试，它测试了`Passenger`和`BoardingProcessor`类之间的交互：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A lot of setup is needed in the *Arrange* phase before `BuildMessage` can be
    called. But what aspects of that setup are important? Which parts of the `Passenger`
    object contribute to that person being allowed to board versus being told to wait?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`BuildMessage`之前，在*安排*阶段需要大量的设置。但哪些设置方面是重要的？`Passenger`对象的哪些部分有助于这个人被允许登机，而不是被告知等待？
- en: While it’s important to create test objects that look accurate, mixing irrelevant
    properties with vital properties can lead to difficulties interpreting what’s
    important about test data or why a test should pass instead of fail.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建看起来准确的测试对象很重要，但将无关紧要的属性与重要属性混合在一起可能会导致难以解释测试数据的重要性或为什么测试应该通过而不是失败。
- en: Bogus is a library that generates realistic random data of different types.
    Bogus helps solve this problem by giving you a good way of generating random data
    for those less critical parts of your objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Bogus是一个生成不同类型真实随机数据的库。Bogus通过为你提供一种生成对象中不那么关键部分随机数据的好方法来解决此问题。
- en: This has the simultaneous benefit of focusing your attention on the more critical
    portions of your tests while also generating random data to test your assertion
    that the values in the other properties truly don’t matter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这同时具有两个好处：一方面，它将你的注意力集中在测试的更关键部分，另一方面，它生成随机数据来测试你的断言，即其他属性的值真正无关紧要。
- en: Like the other libraries in this chapter, Bogus must be installed via NuGet
    and then referenced in a `using` `Bogus;` statement.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的其他库一样，Bogus必须通过NuGet安装，然后在`using` `Bogus;`语句中引用。
- en: 'Let’s look at the *Arrange* section of the earlier test using Bogus:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前测试中Bogus的*Arrange*部分：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you’ve likely noticed, this code is significantly different than the earlier
    code. It uses a `Faker<Passenger>` object from Bogus that will generate a different
    random `Passenger` object every time the `Generate()` method is called.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你很可能注意到的，这段代码与之前的代码有很大不同。它使用Bogus中的`Faker<Passenger>`对象，每次调用`Generate()`方法时都会生成一个不同的随机`Passenger`对象。
- en: 'These `Passenger` objects will use Bogus’ library of random data to generate
    reasonable test data, as shown in *Figure 9**.3*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`Passenger`对象将使用Bogus的随机数据库生成合理的测试数据，如图*9**.3*所示：
- en: '![Figure 9.3 – A randomized passenger with somewhat realistic values](img/B21324_09_3.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 一个具有某种现实值的随机乘客](img/B21324_09_3.jpg)'
- en: Figure 9.3 – A randomized passenger with somewhat realistic values
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 一个具有某种现实值的随机乘客
- en: The way this works is that you can set rules that `Faker` will follow when it
    sees a given property using the `RuleFor` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作方式是，你可以设置规则，当`Faker`使用`RuleFor`方法看到某个特定的属性时，将遵循这些规则。
- en: Using `RuleFor`, you can specify the property you want to program a response
    to in the first argument and then specify a function to get a value in the second
    parameter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RuleFor`，你可以在第一个参数中指定想要编程响应的属性，然后在第二个参数中指定一个函数来获取值。
- en: As an example, the `RuleFor(p => p.Email, f => f.Person.Email)` line has two
    function parameters. The first one uses `p` to represent the `Passenger` object
    and focuses on that object’s `Email` property. The second parameter takes in a
    `Faker` instance as `f` and the function may choose to use it to generate a value
    that `Faker` will use when generating a person.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`RuleFor(p => p.Email, f => f.Person.Email)`这一行有两个函数参数。第一个参数使用`p`来表示`Passenger`对象，并关注该对象的`Email`属性。第二个参数接收一个`Faker`实例作为`f`，函数可以选择使用它来生成`Faker`在生成人物时将使用的数据。
- en: '`Faker` contains many different types of data, from fake company names to ZIP
    codes to product names, IP addresses, and even absurd things such as hacker speak
    and “rants” such as reviews.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Faker`包含许多不同类型的数据，从虚假的公司名称到ZIP代码，再到产品名称、IP地址，甚至包括黑客语言和“狂言”如评论等荒谬事物。'
- en: Now, if you look closely at the data `Faker` generates, it doesn’t always make
    sense. For example, *Figure 9**.3* listed the person as living in Larsonland,
    Minnesota with a postal code of 78950 and a country of “Cocos (Keeling) Islands.”
    Individually, these things are fine, but these different properties conflict wildly
    with one another.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你仔细查看`Faker`生成的数据，它并不总是有道理。例如，*图9**.3*中列出的人居住在明尼苏达州的Larsonland，邮政编码为78950，国家为“科科斯（基林）群岛”。单独来看，这些信息都是合理的，但这些不同的属性之间存在着极大的冲突。
- en: If you need your data to make sense, you’ll need to write more nuanced rules
    for how these properties interact. Despite these limitations, Bogus gives you
    a great way of adding randomness to your code for the inconsequential data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要你的数据有意义，你需要编写更细致的规则来描述这些属性之间的交互。尽管存在这些限制，Bogus仍然为你提供了一个很好的方法，为那些无关紧要的数据添加随机性。
- en: 'Often, when using Bogus, you’ll create your `Faker` instance in a separate
    method or the test constructor, which simplifies your code significantly:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当使用Bogus时，你会在单独的方法或测试构造函数中创建你的`Faker`实例，这显著简化了你的代码：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice how this approach minimizes Bogus’ role in things and focuses your attention
    on how the randomly generated person is further configured. This helps you see
    that the important factors for someone not boarding the plane yet are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种方法如何最小化Bogus在其中的作用，并关注随机生成的人如何进一步配置。这有助于你看到，对于尚未登机的人来说，重要的因素如下：
- en: They are in a higher boarding group than the current group
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们比当前组有更高的登机优先级
- en: They are not military
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不是军事人员
- en: They do not need help boarding the plane
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们不需要帮助登机
- en: Bogus isn’t just for tests. For example, I’ve used Bogus successfully for prototyping
    user interfaces and generating data for small game projects. However, Bogus is
    a valuable addition to your testing toolbox.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Bogus不仅仅用于测试。例如，我已经成功地使用Bogus进行用户界面原型设计和为小型游戏项目生成数据。然而，Bogus是您测试工具箱中的一个宝贵补充。
- en: Let’s move on to look at ways of isolating dependencies with a pair of mocking
    libraries.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨使用成对模拟库来隔离依赖的方法。
- en: Mocking dependencies with Moq and NSubstitute
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Moq和NSubstitute进行模拟依赖
- en: So far, we’ve looked at a few libraries that improve the readability of your
    tests. In this section, we’ll look at **mocking frameworks** and see how libraries
    can help you more effectively test your code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了一些可以提高测试可读性的库。在本节中，我们将探讨**模拟框架**，并看看库如何帮助您更有效地测试代码。
- en: Understanding the need for mocking libraries
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模拟库的需求
- en: 'Let’s discuss why mocking frameworks are necessary by revisiting the `FlightBookingManager`
    example we introduced in the previous chapter while discussing dependency injection:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回顾上一章中讨论依赖注入时引入的`FlightBookingManager`示例来讨论为什么需要模拟框架：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, this class requires `IEmailClient` when `FlightBookingManager` is created.
    The client is then stored in the `_email` field and this is later used to send
    a message when a flight is booked. Passing in `IEmailClient` as a parameter to
    the constructor is an example of dependency injection and allows our class to
    work with anything that implements the `IEmailClient` interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这个类在创建`FlightBookingManager`时需要`IEmailClient`。客户端随后存储在`_email`字段中，并在预订航班时使用它来发送消息。将`IEmailClient`作为构造函数的参数传递是依赖注入的一个例子，它允许我们的类与实现`IEmailClient`接口的任何东西一起工作。
- en: Unfortunately, it also means that to test the class, we must provide an implementation
    of `IEmailClient`, even if we’re not explicitly testing something email-related.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这也意味着为了测试这个类，我们必须提供一个`IEmailClient`的实现，即使我们并没有明确测试与电子邮件相关的内容。
- en: Since we generally don’t want to send emails when unit testing our code, that
    means we’d need a separate implementation of `IEmailClient`. We could make one
    by declaring a class and implementing the `IEmailClient` interface with a minimal
    implementation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通常在单元测试代码时不想发送电子邮件，这意味着我们需要一个`IEmailClient`的单独实现。我们可以通过声明一个类并使用最小实现来实现`IEmailClient`接口来创建一个。
- en: 'Let’s say that `IEmailClient` was defined as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`IEmailClient`被定义为以下内容：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You could create a `TestEmailClient` that meets this requirement:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个满足这个要求的`TestEmailClient`：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, the implementation of the test client is very simple and does the minimum
    possible needed to compile the code, which in this case is returning true, indicating
    a message was successfully sent. This type of class is sometimes called a **test
    double**, a **test stub**, or simply a **mock object**. These names are due to
    these classes looking like real implementations for testing purposes without having
    all their functionality. In this chapter, I will refer to these as mock objects
    since that will help mocking frameworks make more sense later.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，测试客户端的实现非常简单，只做了编译代码所需的最小工作，在这种情况下是返回true，表示消息已成功发送。这种类型的类有时被称为**测试替身**、**测试存根**，或者简单地称为**模拟对象**。这些名称是因为这些类看起来像是用于测试目的的真实实现，但没有全部的功能。在本章中，我将把这些称为模拟对象，因为这有助于使模拟框架在以后更有意义。
- en: 'This lets us write a test using the `TestEmailClient` mock object we created:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们能够使用我们创建的`TestEmailClient`模拟对象来编写测试：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we can safely test a flight without sending an email by providing `TestEmailClient`
    instead of a real email client.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过提供`TestEmailClient`而不是真实的电子邮件客户端来安全地测试航班而不发送电子邮件。
- en: Unfortunately, mock objects have their drawbacks. Let’s say we wanted to write
    another test that verifies that trying to book a seat that’s already occupied
    doesn’t send an email. In that case, we’d need to create another mock object with
    a different implementation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，模拟对象有其缺点。假设我们想要编写另一个测试来验证尝试预订已被占用的座位不会发送电子邮件。在这种情况下，我们需要创建另一个具有不同实现的模拟对象。
- en: 'In this case, we’d want to fail the test if the `SendMessage` method was called,
    so that method should throw an exception or use the `Assert.Fail` method to cause
    the test to fail, as shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果`SendMessage`方法被调用，我们希望测试失败，因此该方法应该抛出异常或使用`Assert.Fail`方法来导致测试失败，如下所示：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let’s consider a more nuanced example. Let’s say you want to verify that the
    `BookFlight` method calls the `SendMessage` method on its `IEmailClient` one time
    and one time only.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个更复杂的情况。假设你想要验证`BookFlight`方法只调用一次其`IEmailClient`上的`SendMessage`方法。
- en: We could test this by building a specialized mock object that had a counter
    of all the times it was called, but that’s yet more complexity in our test code
    that we don’t necessarily need. If the definition of what’s in `IEmailClient`
    ever changes, all our mock objects that implement that interface will also need
    to be updated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构建一个具有调用次数计数器的专用模拟对象来测试这一点，但这会增加我们测试代码的复杂性，而我们不一定需要。如果`IEmailClient`的定义有任何变化，实现该接口的所有模拟对象也需要更新。
- en: Because so many tests need mock objects and each test tests something slightly
    different, writing and maintaining mock objects manually can be a lot of work.
    This is the core problem that mocking libraries exist to solve.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多测试都需要模拟对象，并且每个测试都测试了略有不同的事情，因此手动编写和维护模拟对象可能会非常繁琐。这正是模拟库存在要解决的问题。
- en: While there are several popular mocking libraries in .NET, the most popular
    for many years has been Moq. We’ll explore Moq next before looking at an alternative.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在.NET中存在几个流行的模拟库，但多年来最受欢迎的库是Moq。在查看替代方案之前，我们将探索Moq。
- en: Creating mock objects with Moq
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Moq创建模拟对象
- en: Moq, pronounced either “Mock” or “Mock-you” in the words of its creator, *is
    a mocking library built around using LINQ to create, configure, and verify the
    behavior of* *mock objects*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Moq，根据其创造者的说法，发音为“Mock”或“Mock-you”，是一个围绕使用LINQ创建、配置和验证模拟对象行为的模拟库。
- en: Just like the other libraries in this chapter, you’ll need to install Moq from
    NuGet Package Manager and import it into your file via a `using` `Moq;` statement.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章中的其他库一样，你需要从NuGet包管理器安装Moq，并通过`using Moq;`语句将其导入到你的文件中。
- en: With Moq, you don’t create mock objects on your own; instead, you tell Moq the
    interface you want to implement or the class you want to inherit and Moq automatically
    creates an object that meets these requirements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Moq，你不需要自己创建模拟对象；相反，你告诉Moq你想要实现或继承的接口或类，Moq会自动创建一个满足这些要求的对象。
- en: 'Let’s revisit our flight booking test from earlier in this chapter using Moq:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章前面使用Moq的航班预订测试：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we instantiate a `Mock` instance named `clientMock` that will create a
    new mock object in the form of `IEmailClient`. We then call the `Object` property
    on `clientMock` and the Moq library automatically generates an object that implements
    `IEmailClient` in the simplest way possible.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化一个名为`clientMock`的`Mock`实例，它将以`IEmailClient`的形式创建一个新的模拟对象。然后我们调用`clientMock`上的`Object`属性，Moq库会自动生成一个以最简单的方式实现`IEmailClient`的对象。
- en: Since we don’t care how the email client works in this example, this is all
    we need to do to generate a simple mock object that we can pass to `FlightBookingManager`.
    Not only is this less code, but we can stay in the test method while defining
    our mock object, and if the definition for `IEmailClient` ever changes, we don’t
    need to update the mock object since Moq takes care of that for us.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，由于我们不关心电子邮件客户端的工作原理，所以我们只需要做这些来生成一个简单的模拟对象，我们可以将其传递给`FlightBookingManager`。这不仅代码更少，而且我们可以在定义我们的模拟对象的同时保持测试方法，并且如果`IEmailClient`的定义有任何变化，我们不需要更新模拟对象，因为Moq会为我们处理这些。
- en: Of course, there’s a lot more that Moq can do, so let’s see how you can use
    it to configure how your mock objects behave.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Moq可以做很多事情，所以让我们看看如何使用它来配置模拟对象的行为。
- en: Programming Moq return values
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程Moq返回值
- en: By default, methods on Moq’s mock objects will return the default value for
    that type. For example, a method returning a `bool` object would return `false`,
    and a method returning an `int` object would return `0`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Moq模拟对象上的方法将返回该类型的默认值。例如，返回`bool`对象的方法将返回`false`，而返回`int`对象的方法将返回`0`。
- en: 'Sometimes, you need Moq to return something different. In these cases, you
    can set up your mock object by calling Moq’s `Setup` method. For example, if you
    needed the `SendMessage` method to return `true` instead of `false` for any value
    that was passed in, you could write the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要 Moq 返回不同的值。在这些情况下，你可以通过调用 Moq 的 `Setup` 方法来设置你的模拟对象。例如，如果你需要 `SendMessage`
    方法对于传入的任何值都返回 `true` 而不是 `false`，你可以编写以下代码：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the `Setup` method requires you to tell it what method or property you
    are configuring. Since we’re configuring the `SendMessage` method, we specify
    it in the arrow function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Setup` 方法要求你告诉它你正在配置的方法或属性。由于我们正在配置 `SendMessage` 方法，我们在箭头函数中指定它。
- en: Next, Moq needs to know when it should apply this rule. You can program your
    mock objects to reply differently based on different parameters, so you could
    have a `Setup` call for different parameter values to the same method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Moq 需要知道何时应用这条规则。你可以编程你的模拟对象根据不同的参数返回不同的响应，因此你可以为同一方法的不同参数值设置一个 `Setup`
    调用。
- en: In our case, we want the method to always return `true`, regardless of what
    is passed in, so we specify that with Moq’s `It.IsAny` syntax.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们希望该方法始终返回 `true`，无论传入什么，所以我们使用 Moq 的 `It.IsAny` 语法来指定。
- en: Before we finish our discussion of Moq, we’ll look at a final example and teach
    you how to verify how many times a given method was called on your mock objects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成对 Moq 的讨论之前，我们将查看一个最终的例子，并教你如何验证给定方法在模拟对象上被调用的次数。
- en: Verifying Moq calls
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 Moq 调用
- en: Sometimes, you want to test the behavior of a method and verify that calling
    one method causes it to call something on another object. Moq lets you do this
    by verifying that a method has been called a specific number of times.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你想测试一个方法的行为，并验证调用一个方法导致它调用另一个对象上的某个方法。Moq 允许你通过验证一个方法被调用特定次数来实现这一点。
- en: This can include verifying that a method wasn’t called, which can be helpful
    for cases like the example we discussed earlier involving making sure emails aren’t
    sent out in cases where a seat couldn’t be reserved.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能包括验证一个方法没有被调用，这在确保在无法预订座位的情况下不发送电子邮件的例子中可能很有帮助。
- en: 'To accomplish this, we can call Moq’s `Verify` methods, as shown in the following
    case, which verifies that an email was sent once and only once when booking a
    flight:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以调用 Moq 的 `Verify` 方法，如下所示，这验证了在预订航班时电子邮件只发送了一次：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we call `Verify` on our `Mock` instance to verify that the `SendMessage`
    method was called exactly one time with the passenger’s email address and any
    email body. If the method wasn’t called or was called multiple times, this will
    fail our test.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在我们的 `Mock` 实例上调用 `Verify` 来验证 `SendMessage` 方法恰好被调用一次，并且带有乘客的电子邮件地址和任何电子邮件正文。如果该方法没有被调用或被多次调用，这将使我们的测试失败。
- en: In other words, this one `Verify` line protects us from cases where the system
    didn’t email the user when it should have, as well as cases where it might have
    sent too many emails.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这一行 `Verify` 保护我们免受系统在应该发送电子邮件时没有发送，以及可能发送过多电子邮件的情况。
- en: Next, the code calls `VerifyNoOtherCalls`. This method will cause the test to
    fail if some other method on our `IEmailClient` was called that was not verified
    by a previous `Verify` statement. This can be handy for ensuring that the code
    is not doing unexpected things with the objects you provide it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码调用 `VerifyNoOtherCalls`。如果我们的 `IEmailClient` 上的某个其他方法被调用，而这个方法没有被之前的 `Verify`
    语句验证，这个方法将使测试失败。这可以方便地确保代码不会对你提供的对象执行意外操作。
- en: A note on verifying behavior
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于验证行为的说明
- en: The developer community has historically been divided on whether it is good
    practice to verify that calling code calls some other piece of code in your unit
    tests. The argument against verifying the behavior of your tests is that it shouldn’t
    matter how a method implements something if it produces the right results. The
    counter-argument is that sometimes, the desired result of your method is the callout
    to the external code, such as our code here, which calls the `SendMessage` call.
    You and your team will need to decide when it is appropriate to use `Verify` in
    your tests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者社区在历史上一直对在单元测试中验证调用代码是否调用你的代码中的其他部分是否是良好实践存在分歧。反对验证测试行为的人认为，如果方法产生了正确的结果，那么方法如何实现某事并不重要。反对方则认为，有时，你方法期望的结果是调用外部代码，例如我们这里的代码，它调用了
    `SendMessage` 调用。你和你的团队将需要决定何时在测试中使用 `Verify`。
- en: Moq can seem complex to work with initially, but you don’t need to use all its
    features to benefit from it. As we saw earlier, just using Moq to generate simple
    mock objects can save you significant work in maintaining a growing number of
    manually created mock objects over time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Moq 在一开始使用时可能看起来比较复杂，但你不需要使用它的所有功能就能从中受益。正如我们之前看到的，只需使用 Moq 生成简单的模拟对象，就能在维护随着时间的增长而不断增加的手动创建的模拟对象时节省大量工作。
- en: You won’t always need to use Moq’s `Setup` or `Verify` methods, but they’re
    very helpful when you want them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是需要使用 Moq 的 `Setup` 或 `Verify` 方法，但当你需要时，它们非常有帮助。
- en: For years, Moq has been the dominant mocking library in .NET, but recently,
    NSubstitute has been gaining popularity. This results in a higher likelihood that
    you may encounter it in the workplace as a substitute for Moq. Let’s explore NSubstitute
    briefly and see how it accomplishes similar things to Moq using a different syntax.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，Moq 一直是 .NET 中的主流模拟库，但最近，NSubstitute 正在逐渐流行起来。这导致你可能在工作中更可能遇到它作为 Moq 的替代品。让我们简要地探讨
    NSubstitute 并看看它是如何使用不同的语法实现与 Moq 相似的功能的。
- en: Mocking with NSubstitute
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NSubstitute 进行模拟
- en: NSubstitute is a similar mocking library to Moq, but its approach is to avoid
    arrow functions where possible and prefer code that looks more like standard method
    calls.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: NSubstitute 是与 Moq 类似的模拟库，但其方法是在可能的情况下避免箭头函数，并优先选择看起来更像标准方法调用的代码。
- en: Like other libraries in this chapter, you’ll need to install NSubstitute via
    NuGet Package Manager and then import it via a `using` `NSubstitute;` statement.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的其他库一样，你需要通过 NuGet 包管理器安装 NSubstitute，然后通过 `using NSubstitute;` 语句导入它。
- en: 'Once you have NSubstitute installed and imported, you can use it in code, as
    follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装并导入 NSubstitute，你就可以在代码中使用它，如下所示：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note how NSubstitute’s `Substitute.For` returns the object you’re creating instead
    of creating an object like `Mock<IEmailClient>` did with Moq. This change makes
    your code a little simpler to work with but also means you now need to call methods
    like `Received()` and `DidNotReceive()` to get access to the method to verify.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 NSubstitute 的 `Substitute.For` 方法返回你正在创建的对象，而不是像 Moq 中的 `Mock<IEmailClient>`
    那样创建一个对象。这个变化使得你的代码稍微简单一些，但也意味着你现在需要调用 `Received()` 和 `DidNotReceive()` 等方法来访问验证方法。
- en: In general, NSubsitute is very similar to Moq but with a simpler syntax. This
    simplicity has its advantages, particularly in code readability and a lowered
    learning curve for new developers. Unfortunately, this sometimes comes at the
    price of NSubstitute not having the full range of features you’re used to with
    Moq.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，NSubsitute 与 Moq 非常相似，但语法更简单。这种简单性有其优点，尤其是在代码可读性和降低新开发者的学习曲线方面。不幸的是，这有时是以
    NSubstitute 没有与 Moq 相同的全套功能为代价的。
- en: Now that we’ve explored mocking libraries, let’s move on to completely different
    types of unit tests.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了模拟库，让我们转向完全不同类型的单元测试。
- en: Pinning tests with Snapper
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Snapper 进行测试桩
- en: Let’s say you’ve inherited some complex legacy code that returns an object with
    a lot of properties. Some of these properties may, in turn, contain other complex
    objects with their own nest of properties. You’re just starting to work with this
    code and need to make a change, but there aren’t any tests in place and you’re
    not even sure what properties are important to verify.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你继承了一些复杂的遗留代码，这些代码返回一个具有许多属性的对象。其中一些属性可能反过来又包含其他具有自己嵌套属性的自定义对象。你刚开始与这段代码一起工作，需要做出一些更改，但现在还没有测试，甚至不确定哪些属性是重要的验证点。
- en: I’ve seen this scenario a few times now and can attest that a special testing
    library called Snapper is a fantastic solution to this problem.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经看到过这种场景几次，可以证明一个名为 Snapper 的特殊测试库是解决这个问题的绝佳方案。
- en: What Snapper does is it creates a snapshot of an object and stores it to disk
    in a JSON file. When Snapper next runs, it generates another snapshot and then
    compares it to the snapshot it stored previously. If the snapshots differ at all,
    Snapper will fail the test and alert you to that problem.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Snapper 所做的是创建一个对象的快照并将其存储到磁盘上的 JSON 文件中。当 Snapper 下次运行时，它会生成另一个快照，并将其与之前存储的快照进行比较。如果快照有任何不同，Snapper
    将会失败测试并提醒你这个问题。
- en: Snapper and Jest
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Snapper 和 Jest
- en: For those of you with a JavaScript background, Snapper was inspired by the snapshot
    testing capabilities found in JavaScript’s Jest testing library.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有 JavaScript 背景的人来说，Snapper 是受到 JavaScript 的 Jest 测试库中发现的快照测试功能的启发。
- en: Let’s see what a sample test looks like with Snapper.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Snapper 的一个示例测试是什么样的。
- en: As usual, first, we install Snapper via NuGet and add a `using` `Snapper;` statement.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，首先，我们通过 NuGet 安装 Snapper 并添加一个 `using Snapper;` 语句。
- en: 'After that, we’ll write a test against a complex object, `FlightManifest`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将针对一个复杂对象 `FlightManifest` 编写测试：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we call `ShouldMatchSnapshot` to verify that the object matches the current
    snapshot.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用 `ShouldMatchSnapshot` 来验证对象是否与当前快照匹配。
- en: 'This will generate the snapshot the first time, but subsequent runs will compare
    the object’s snapshot to the stored snapshot. If the resulting snapshot is different,
    you’ll see a test failure with details about the difference, such as the one that
    occurs when a passenger’s name is changed, as shown in *Figure 9**.4*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首次生成快照，但随后的运行将比较对象的快照与存储的快照。如果生成的快照不同，你将看到测试失败，并显示差异的详细信息，例如当乘客姓名更改时发生的差异，如
    *图 9.4* 所示。4*：
- en: '![Figure 9.4 – A failing snapshot test showing the difference between two properties](img/B21324_09_4.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 一个失败的快照测试，显示了两个属性之间的差异](img/B21324_09_4.jpg)'
- en: Figure 9.4 – A failing snapshot test showing the difference between two properties
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 一个失败的快照测试，显示了两个属性之间的差异
- en: 'Sometimes, you’ll add new properties or realize that the stored snapshot was
    based on buggy data and you’ll want to update your snapshots. You can do this
    by temporarily adding an `UpdateSnapshots` attribute to your test method, as shown
    here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你会添加新的属性或者意识到存储的快照是基于有问题的数据，你将想要更新你的快照。你可以通过临时添加一个 `UpdateSnapshots` 属性到你的测试方法中来实现，如下所示：
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After this, re-run your test to update the stored snapshot, then remove the
    `UpdateSnapshots` attribute. This final step is important because the test with
    `UpdateSnapshots` included will never fail a snapshot test but rather replace
    the snapshot every time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，重新运行你的测试以更新存储的快照，然后移除 `UpdateSnapshots` 属性。这一步很重要，因为包含 `UpdateSnapshots`
    的测试永远不会使快照测试失败，而是每次都替换快照。
- en: Snapshot testing is not for every project and not for every team. It is a very
    useful broad safety net that you can include as the first test for complex return
    values, but it is far less useful as a test that documents the behavior of a system.
    Additionally, snapshot tests can be very brittle and cause tests to fail for trivial
    things such as modified dates being different between two otherwise identical
    sets of data.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试并非适用于每个项目和每个团队。它是一个非常有用的广泛安全网，你可以将其作为复杂返回值的第一个测试，但它作为记录系统行为的测试则远没有那么有用。此外，快照测试可能非常脆弱，会导致测试因一些微不足道的事情（例如，两个本质上相同的数据集的修改日期不同）而失败。
- en: Still, I find that Snapper and snapshot testing can be an appropriate opening
    move while trying to bring tests to particularly complex areas of legacy systems.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我发现 Snapper 和快照测试在尝试将测试引入遗留系统的特别复杂区域时，可以是一个合适的开局。
- en: Now, let’s close this chapter out with a similar library that helps you compare
    several different implementations with each other.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以一个类似的库来结束这一章，这个库可以帮助你比较几个不同的实现之间的差异。
- en: Experimenting with Scientist .NET
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scientist .NET 的实验
- en: Scientist .NET is a library built by GitHub for scientifically refactoring the
    critical parts of your application.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Scientist .NET 是 GitHub 构建的一个库，用于科学地重构应用程序的关键部分。
- en: Let’s say you have a portion of your application that is vital to what the business
    does but has a significant amount of technical debt. You want to refactor it,
    but you’re afraid of breaking anything and your existing tests are not sufficient
    to address those fears, but you’re not sure what tests you need to add. In your
    estimation, the only thing that will let you feel good about your new code is
    to see how it does in production.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个对业务至关重要的应用程序部分，但它有大量的技术债务。你想重构它，但又害怕破坏任何东西，你现有的测试不足以解决这些担忧，但你又不确定需要添加哪些测试。在你的估计中，唯一能让你对你的新代码感到满意的事情是看到它在生产中的表现。
- en: This is what Scientist .NET helps with. Scientist .NET lets you deploy your
    new code alongside the legacy code it hopes to replace and compares the results
    of the two pieces of code. Alternatively, Scientist .NET can be used in unit tests
    to verify that the old version of a component and the new version of the component
    achieves the same results.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Scientist .NET 帮助的地方。Scientist .NET 允许你将新代码与它希望替换的遗留代码一起部署，并比较这两段代码的结果。或者，Scientist
    .NET 可以用于单元测试，以验证组件的旧版本和新版本是否达到相同的结果。
- en: This concept will hopefully be a bit clearer in a moment. Let’s jump into a
    specific example that looks at replacing `LegacyManifestGenerator` with `RewrittenManifestGenerator`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念在下一刻可能会更加清晰。让我们来看一个具体的例子，这个例子是关于用`RewrittenManifestGenerator`替换`LegacyManifestGenerator`。
- en: Like before, we’ll need to install the Scientist package from NuGet and then
    add a `using GitHub;` statement to the top of our file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们需要从NuGet安装Scientist包，然后在我们的文件顶部添加一个`using GitHub;`语句。
- en: 'Next, let’s look at the science experiment comparing the two manifest generators:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看比较两个清单生成器的科学实验：
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That’s a lot of code, so let’s unpack everything here bit by bit.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很多，所以让我们一点一点地解开这里的一切。
- en: First, the `Scientist.Science<FlightManifest>` line tells Scientist you’re starting
    a new experiment that will return `FlightManifest`. In this example, we’re ignoring
    this result value, but in a production scenario, you might assign the result to
    a variable and work with it after the call to the Scientist.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Scientist.Science<FlightManifest>`这一行告诉科学家你正在启动一个新的实验，该实验将返回`FlightManifest`。在这个例子中，我们忽略了这个结果值，但在生产场景中，你可能会将结果分配给一个变量，并在调用科学家之后处理它。
- en: Scientist requires you to name every experiment in the first parameter to the
    `Science` call because you may be performing multiple experiments. This experiment
    is simply named “Manifest.”
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家要求你在`Science`调用的第一个参数中命名每个实验，因为你可能正在进行多个实验。这个实验简单地命名为“Manifest”。
- en: Next, the Scientist requires an action to configure the experiment you’re about
    to perform. You might configure a few things, but here, we’re specifying four
    different things that we’ll talk about in sequence.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，科学家要求你配置你即将进行的实验。你可能需要配置一些东西，但在这里，我们指定了四个我们将依次讨论的不同事项。
- en: First, we call the `Use` method to tell the experiment what to use as the result
    of the call to the `Scientist.Science`. This should be the legacy implementation
    of the system you’re looking at replacing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`Use`方法来告诉实验将使用什么作为`Scientist.Science`调用的结果。这应该是你想要替换的系统中的旧实现。
- en: Next, we need to give Scientist one or more alternative implementations to consider
    and compare against the “control” version in the legacy system. We do this via
    a `Try` method that looks very similar to the `Use` method, but it represents
    the experimental version.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要给科学家提供一到多个备选实现，以便与旧系统中的“控制”版本进行比较。我们通过一个看起来非常类似于`Use`方法的`Try`方法来完成这个操作，但它代表的是实验版本。
- en: 'What Scientist does with these two versions is it makes the call to both implementations,
    compares the two results, and sends metrics on to something called a result publisher.
    This process is illustrated in *Figure 9**.5*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家对这两个版本所做的是调用两个实现，比较两个结果，并将指标发送到称为结果发布者的地方。这个过程在*图9.5*中得到了说明：
- en: '![Figure 9.5 – Scientist .NET performing an experiment](img/B21324_09_5.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – Scientist .NET执行实验](img/B21324_09_5.jpg)'
- en: Figure 9.5 – Scientist .NET performing an experiment
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – Scientist .NET执行实验
- en: Scientist always returns the result of the legacy version defined during `Use`,
    so your new implementation will not impact the existing logic and you’ll be able
    to identify cases where the new and old implementations do not match. This allows
    you to verify your new logic’s behavior without risking any logic bugs impacting
    end users.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家总是返回在`Use`期间定义的旧版本的版本，所以你的新实现不会影响现有的逻辑，你将能够识别出新旧实现不匹配的情况。这允许你在不冒任何逻辑错误影响最终用户的风险下验证你新逻辑的行为。
- en: Once you are satisfied that your new implementation is without issues, you can
    remove Scientist and the legacy implementation from your code and use the new
    implementation in their place.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你满意你的新实现没有问题，你就可以从你的代码中移除Scientist和旧实现，并用新实现来替换它们。
- en: For Scientist to tell if two results are equivalent, it needs to know how to
    compare them. You can configure this with the `Compare` method, which takes in
    a function that will return a `bool` object indicating if the two objects should
    be considered equivalent.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让科学家知道两个结果是否等效，它需要知道如何比较它们。你可以通过`Compare`方法来配置这一点，该方法接受一个函数，该函数将返回一个`bool`对象，指示两个对象是否应被视为等效。
- en: Finally, our code sets `ThrowOnMismatches` to `true`. You can set this property
    in Scientist to have it throw an exception when the experiment and the control
    do not match for a given input. This is only intended for use in unit tests like
    our code here and is not intended for use if you’re using Scientist in a production
    application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的代码将 `ThrowOnMismatches` 设置为 `true`。您可以在 Scientist 中设置此属性，以便在实验和控制对于给定输入不匹配时抛出异常。这仅适用于像我们这里的单元测试这样的场景，并且不适用于在生产应用程序中使用
    Scientist。
- en: Instead, you would implement Scientist’s `IResultPublisher` interface and set
    `Scientist.ResultPublisher` equal to your custom result publisher. This would
    allow you to report mismatches to a database, App Insights on Azure, or some other
    mechanism you might consider using to capture these mismatches. Getting into result
    publishers is outside the scope of this book, but see the *Further reading* section
    in this chapter for more resources.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您将实现 Scientist 的 `IResultPublisher` 接口，并将 `Scientist.ResultPublisher` 设置为您的自定义结果发布者。这将允许您将不匹配报告到数据库、Azure
    上的 App Insights 或您可能考虑用于捕获这些不匹配的其他机制。关于结果发布者的内容超出了本书的范围，但请参阅本章的 *进一步阅读* 部分，以获取更多资源。
- en: Scientist .NET is a complex solution you won’t use frequently, but it allows
    you to compare how two different implementations of an algorithm perform against
    a variety of inputs, either in a unit testing scenario or in a production application.
    I’ve personally seen Scientist .NET enable teams to collect the data they needed
    to successfully refactor highly complex code without impacting end users.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Scientist .NET 是一个您不会经常使用的复杂解决方案，但它允许您比较两种不同的算法实现如何针对各种输入进行性能比较，无论是在单元测试场景中还是在生产应用程序中。我亲眼看到
    Scientist .NET 使团队能够收集他们需要的资料，成功重构高度复杂的代码，而不会影响最终用户。
- en: Warning
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: It’s important to note that when you run an experiment in Scientist, both the
    original version in your `Use` statement and any experiments you defined in the
    `Try` calls will be called. This means that if your code has any side effects
    such as inserting into a database or sending an email, these things will occur
    twice. This might result in duplicate rows being inserted into a database or duplicate
    emails being sent.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当您在 Scientist 中运行实验时，您的 `Use` 语句中的原始版本以及您在 `Try` 调用中定义的任何实验都将被调用。这意味着如果您的代码有任何副作用，例如向数据库插入或发送电子邮件，这些操作将发生两次。这可能会导致数据库中插入重复行或发送重复的电子邮件。
- en: You can potentially avoid this downside by providing the experimental versions
    of mock objects as their dependencies instead of real versions of a database client
    or an email provider.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过提供实验版本的模拟对象作为其依赖项来避免这种缺点，而不是提供数据库客户端或电子邮件提供者的真实版本。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw several different open-source libraries that can improve
    the readability and capabilities of your tests.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了几个不同的开源库，这些库可以提高您测试的可读性和功能。
- en: Shouldly and FluentAssertions give you the readable syntax for writing assertions.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shouldly 和 FluentAssertions 为您提供了编写断言的可读性语法。
- en: Bogus allows you to generate randomized test data for values that don’t matter.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bogus 允许您为不重要的值生成随机测试数据。
- en: Moq and NSubstitute help you isolate dependencies and provide alternative implementations
    for testing.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moq 和 NSubstitute 帮助您隔离依赖并提供用于测试的替代实现。
- en: Snapper and Scientist .NET help catch issues where complex objects change in
    subtle ways.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snapper 和 Scientist .NET 有助于捕捉复杂对象以微妙方式发生变化的问题。
- en: Not every project will benefit from each of these libraries. However, knowing
    the tools at your disposal will help you as you refactor and maintain your code
    and expand your tests.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个项目都能从这些库中的每一个都受益。然而，了解您可用的工具将帮助您在重构和维护代码以及扩展测试时。
- en: While it’s possible to do all the things in this chapter without using these
    libraries, all of these libraries represent established community projects dedicated
    to solving specific technical concerns.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在不使用这些库的情况下可以完成本章中的所有事情，但所有这些库都代表了致力于解决特定技术问题的成熟社区项目。
- en: In the next chapter, we’ll close out this section of this book with a discussion
    of defensive coding practices using modern C#.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过讨论使用现代 C# 的防御性编码实践来结束本书的这一部分。
- en: Questions
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What areas of your test code could be more readable? Are there any libraries
    in this chapter that might help?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的测试代码的哪些领域可以更具可读性？本章中是否有任何库可能有所帮助？
- en: How do mocking libraries such as Moq and NSubstitute help in testing?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟库如 Moq 和 NSubstitute 如何帮助进行测试？
- en: Do you see any areas of your code where the complexity is high enough that Snapper
    or Scientist .NET might be able to help?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否在你的代码中看到了任何复杂度足够高，以至于 Snapper 或 Scientist .NET 可能能够帮助的区域？
- en: Further reading
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about the libraries discussed in this chapter
    at these URLs:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网址找到关于本章讨论的库的更多信息：
- en: '*Shouldly*: [https://github.com/shouldly/shouldly](https://github.com/shouldly/shouldly)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shouldly*: [https://github.com/shouldly/shouldly](https://github.com/shouldly/shouldly)'
- en: '*FluentAssertions*: [https://fluentassertions.com/](https://fluentassertions.com/)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FluentAssertions*: [https://fluentassertions.com/](https://fluentassertions.com/)'
- en: '*Bogus*: [https://github.com/bchavez/Bogus](https://github.com/bchavez/Bogus)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bogus*: [https://github.com/bchavez/Bogus](https://github.com/bchavez/Bogus)'
- en: '*Moq*: [https://github.com/moq/moq](https://github.com/moq/moq)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Moq*: [https://github.com/moq/moq](https://github.com/moq/moq)'
- en: '*NSubstitute*: https://nsubstitute.github.io/'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NSubstitute*: [https://nsubstitute.github.io/](https://nsubstitute.github.io/)'
- en: '*Snapper*: [https://github.com/theramis/Snapper](https://github.com/theramis/Snapper)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Snapper*: [https://github.com/theramis/Snapper](https://github.com/theramis/Snapper)'
- en: '*Scientist .**NET*: [https://github.com/scientistproject/Scientist.net](https://github.com/scientistproject/Scientist.net)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Scientist .NET*: [https://github.com/scientistproject/Scientist.net](https://github.com/scientistproject/Scientist.net)'
