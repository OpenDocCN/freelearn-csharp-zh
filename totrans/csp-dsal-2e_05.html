<html><head></head><body>
<div id="_idContainer058">
<h1 class="chapter-number" id="_idParaDest-94"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-95"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.2.1">Stacks and Queues</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far, you learned a lot about arrays and lists. </span><span class="koboSpan" id="kobo.3.2">However, these structures are not the only ones available. </span><span class="koboSpan" id="kobo.3.3">Among others, there is also a group of more specialized data structures </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.4.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">limited access </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.6.1">data structures</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">What does this mean? </span><span class="koboSpan" id="kobo.8.2">To explain the name, let’s return to the topic of arrays for the moment, which belong to the group</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.9.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">random access data structures</span></strong><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">The difference between them is only one word -  that is, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">limited</span></em><span class="koboSpan" id="kobo.13.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.14.1">random</span></em><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">As you already know, arrays allow you to store data and get access to various elements using indices. </span><span class="koboSpan" id="kobo.15.3">Thus, you can easily get the first, the middle, the </span><em class="italic"><span class="koboSpan" id="kobo.16.1">n</span></em><span class="superscript"><span class="koboSpan" id="kobo.17.1">th</span></span><span class="koboSpan" id="kobo.18.1">, or the last element from an array. </span><span class="koboSpan" id="kobo.18.2">For this reason, it can be named a random access </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">data structure.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">However, what does </span><em class="italic"><span class="koboSpan" id="kobo.21.1">limited</span></em><span class="koboSpan" id="kobo.22.1"> mean? </span><span class="koboSpan" id="kobo.22.2">The answer is very simple. </span><span class="koboSpan" id="kobo.22.3">With a limited access data structure, </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">you cannot access every element from the structure</span></strong><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">Thus, </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">the way of getting elements is strictly specified</span></strong><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">For example, you can get only the first or the last element, but you cannot get the </span><em class="italic"><span class="koboSpan" id="kobo.27.1">n</span></em><span class="superscript"><span class="koboSpan" id="kobo.28.1">th</span></span><span class="koboSpan" id="kobo.29.1"> element from the data structure. </span><span class="koboSpan" id="kobo.29.2">Popular representatives of limited access data structures are stacks and queues, which are topics mentioned in </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">You will see the application of a stack, as well as a few variants of queues, including a regular one, a priority queue, and a circular queue. </span><span class="koboSpan" id="kobo.31.2">To make understanding easier, the text is supported with illustrations and code snippets with </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">detailed explanations.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">In this chapter, the following topics will </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">be covered:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.35.1">Stacks</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.36.1">Queues</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.37.1">Priority queu</span><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.38.1">es</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Circular queue</span><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.40.1">s</span></span></li>
</ul>
<h1 id="_idParaDest-96"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.41.1">Stacks</span></h1>
<p><span class="koboSpan" id="kobo.42.1">To begin, let’s talk about a </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">stack</span></strong><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">It is a data </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.45.1">structure that allows you to </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">add a new element only at the top</span></strong><span class="koboSpan" id="kobo.47.1"> (referred to as a </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">push </span></strong><span class="koboSpan" id="kobo.49.1">operation) and </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">to get an element only by removing it from the top</span></strong><span class="koboSpan" id="kobo.51.1"> (a </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">pop</span></strong><span class="koboSpan" id="kobo.53.1"> operation). </span><span class="koboSpan" id="kobo.53.2">For this reason, a stack is consistent with</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.54.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">LIFO</span></strong><span class="koboSpan" id="kobo.56.1"> principle, which stands for </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.57.1">Last-In First-Out</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.59.1">Imagine a stack</span></p>
<p class="callout"><span class="koboSpan" id="kobo.60.1">If you want to better visualize a stack, let’s close the book for a moment, go to the kitchen, and take a look at a pile of plates, each placed on top of the other. </span><span class="koboSpan" id="kobo.60.2">You can only add a new plate to the top of the pile, and you can only get a plate from the top of the pile. </span><span class="koboSpan" id="kobo.60.3">You cannot remove the seventh plate without taking the previous six from the top, and you cannot add a plate to the middle of the pile. </span><span class="koboSpan" id="kobo.60.4">So, the last added plate (last-in) will be removed from the pile first (first-out). </span><span class="koboSpan" id="kobo.60.5">And do not even try to get a plate from the middle of the pile, as you don’t want to break plates! </span><span class="koboSpan" id="kobo.60.6">The stack operates similarly. </span><span class="koboSpan" id="kobo.60.7">It allows you to add a new element only at the top (a push operation) and to get an element only by removing it from the top (a </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">pop operation).</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">A diagram of a </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.63.1">stack with </span><em class="italic"><span class="koboSpan" id="kobo.64.1">push</span></em><span class="koboSpan" id="kobo.65.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.66.1">pop</span></em><span class="koboSpan" id="kobo.67.1"> operations is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.69.1"><img alt="Figure 5.1 – ﻿Illustration of a stack" src="image/B18069_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.70.1">Figure 5.1 – Illustration of a stack</span></p>
<p><span class="koboSpan" id="kobo.71.1">It seems to be very easy, doesn’t it? </span><span class="koboSpan" id="kobo.71.2">It really is, and you can benefit from various features of </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.72.1">stacks using the built-in generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">Stack</span></strong><span class="koboSpan" id="kobo.74.1"> class. </span><span class="koboSpan" id="kobo.74.2">It is worth remembering that it is located in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">System.Collections.Generic</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.76.1"> namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Let’s mention three methods from </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">this class:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">Push</span></strong><span class="koboSpan" id="kobo.80.1"> inserts an element at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the stack</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">Pop</span></strong><span class="koboSpan" id="kobo.83.1"> removes an element from the top of the stack and </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">returns it</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">Peek</span></strong><span class="koboSpan" id="kobo.86.1"> returns an element from the top of the stack without </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">removing it</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.88.1">You also have access to other methods, such as for removing all elements from the stack (</span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">Clear</span></strong><span class="koboSpan" id="kobo.90.1">) or for checking whether a given element is available in the stack (</span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">Contains</span></strong><span class="koboSpan" id="kobo.92.1">). </span><span class="koboSpan" id="kobo.92.2">You can get the number of elements currently in the stack using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">Count</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.94.1"> property.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.95.1">What about the performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.96.1">It is worth</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.97.1"> noting that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">Push</span></strong><span class="koboSpan" id="kobo.99.1"> method is either an </span><em class="italic"><span class="koboSpan" id="kobo.100.1">O(1)</span></em><span class="koboSpan" id="kobo.101.1"> operation, if the capacity does not need to increase, or </span><em class="italic"><span class="koboSpan" id="kobo.102.1">O(n) </span></em><span class="koboSpan" id="kobo.103.1">otherwise, where </span><em class="italic"><span class="koboSpan" id="kobo.104.1">n</span></em><span class="koboSpan" id="kobo.105.1"> is the number of elements in the stack. </span><span class="koboSpan" id="kobo.105.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">Pop</span></strong><span class="koboSpan" id="kobo.107.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">Peek</span></strong><span class="koboSpan" id="kobo.109.1"> are </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">O(1)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1"> operations.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">As the time complexity looks very promising, it is high time to take a look at some examples showing stacks </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">in a</span><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.114.1">ction.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.115.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.116.1">You can find content regarding a stack </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">at </span></span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1"><span class="No-Break"><span class="koboSpan" id="kobo.118.1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1</span></span></a></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.119.1">Example – reversing a word</span></h2>
<p><span class="koboSpan" id="kobo.120.1">For the</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.121.1"> first example, let’s try to reverse a word using a stack. </span><span class="koboSpan" id="kobo.121.2">You can do this by iterating through characters that form a string, adding each at the top of the stack, and then removing all elements from the stack. </span><span class="koboSpan" id="kobo.121.3">At the end, you receive the reversed word, as shown in the following diagram presenting how to </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">reverse </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">MARCIN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.125.1"><img alt="Figure 5.2 – ﻿Illustration of the reversing ﻿a word example" src="image/B18069_05_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.126.1">Figure 5.2 – Illustration of the reversing a word example</span></p>
<p><span class="koboSpan" id="kobo.127.1">The</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.128.1"> implementation is shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
string text = "MARCIN";
</span><strong class="bold"><span class="koboSpan" id="kobo.131.1">Stack&lt;char&gt; chars = new();</span></strong><span class="koboSpan" id="kobo.132.1">
foreach (char c in text) { chars.</span><strong class="bold"><span class="koboSpan" id="kobo.133.1">Push</span></strong><span class="koboSpan" id="kobo.134.1">(c); }
while (chars.</span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Count</span></strong><span class="koboSpan" id="kobo.136.1"> &gt; 0) { Console.Write(chars.</span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Pop</span></strong><span class="koboSpan" id="kobo.138.1">()); }</span></pre> <p><span class="koboSpan" id="kobo.139.1">Here, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">Stack</span></strong><span class="koboSpan" id="kobo.141.1"> class is created. </span><span class="koboSpan" id="kobo.141.2">In this scenario, the stack can contain only </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">char</span></strong><span class="koboSpan" id="kobo.143.1"> elements. </span><span class="koboSpan" id="kobo.143.2">Then, you iterate through all characters using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">foreach</span></strong><span class="koboSpan" id="kobo.145.1"> loop and insert each character at the top of the stack by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Push</span></strong><span class="koboSpan" id="kobo.147.1"> method. </span><span class="koboSpan" id="kobo.147.2">The remaining part of the code consists of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">while</span></strong><span class="koboSpan" id="kobo.149.1"> loop, which is executed until the stack is empty. </span><span class="koboSpan" id="kobo.149.2">This condition is checked using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">Count</span></strong><span class="koboSpan" id="kobo.151.1"> property. </span><span class="koboSpan" id="kobo.151.2">In each iteration, the top element is removed from the stack (by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">Pop</span></strong><span class="koboSpan" id="kobo.153.1">) and written in the console (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">Write</span></strong><span class="koboSpan" id="kobo.155.1"> static method of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Console</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.157.1"> class).</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">After running the code, you will receive the </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">following r</span><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.160.1">esult:</span></span></p>
<pre class="console">
<a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.161.1">NICRAM</span></pre> <h2 id="_idParaDest-98"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.162.1">Example – Tower of Hanoi</span></h2>
<p><span class="koboSpan" id="kobo.163.1">The next </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.164.1">example</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.165.1"> is a significantly more complex application of stacks. </span><span class="koboSpan" id="kobo.165.2">It is related to the mathematical game </span><em class="italic"><span class="koboSpan" id="kobo.166.1">Tower of Hanoi</span></em><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">The game requires three rods, onto which you can put discs. </span><span class="koboSpan" id="kobo.167.3">Each disc has a different size. </span><span class="koboSpan" id="kobo.167.4">At the beginning, all discs are placed on the first rod, forming a stack, ordered from the smallest (at the top) to the biggest (at the bottom). </span><span class="koboSpan" id="kobo.167.5">It is presented in</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.168.1"> the following diagram (on </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">the left):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.170.1"><img alt="Figure 5.3 – ﻿Illustration of the Tower of Hanoi example" src="image/B18069_05_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.171.1">Figure 5.3 – Illustration of the Tower of Hanoi example</span></p>
<p><span class="koboSpan" id="kobo.172.1">The aim </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.173.1">of the</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.174.1"> game is to </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">move all the discs from the first rod</span></strong><span class="koboSpan" id="kobo.176.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">FROM</span></strong><span class="koboSpan" id="kobo.178.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">to the second one</span></strong><span class="koboSpan" id="kobo.180.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">TO</span></strong><span class="koboSpan" id="kobo.182.1">). </span><span class="koboSpan" id="kobo.182.2">However, during the whole game, you </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">cannot place a bigger disc on a smaller one</span></strong><span class="koboSpan" id="kobo.184.1">. </span><span class="koboSpan" id="kobo.184.2">Moreover, you </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">can only move one disc at a time</span></strong><span class="koboSpan" id="kobo.186.1">, and, of course, you </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">can only take a disc from the top of </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.188.1">any rod</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">How could you move discs between the rods to comply with the aforementioned rules? </span><span class="koboSpan" id="kobo.190.2">The problem </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.191.1">can be divided </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">into sub-problems:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.193.1">Moving one disc</span></strong><span class="koboSpan" id="kobo.194.1">: Such a case is trivial, and you just need to move a disc from </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">FROM</span></strong><span class="koboSpan" id="kobo.196.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">TO</span></strong><span class="koboSpan" id="kobo.198.1">, without using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">AUXILIARY</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.200.1"> rod.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.201.1">Moving two discs</span></strong><span class="koboSpan" id="kobo.202.1">: You move one disc from </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">FROM</span></strong><span class="koboSpan" id="kobo.204.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">AUXILIARY</span></strong><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">Then, you move the remaining disc from </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">FROM</span></strong><span class="koboSpan" id="kobo.208.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">TO</span></strong><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">At the end, you move a disc from </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">AUXILIARY</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.212.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">TO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.215.1">Moving three discs</span></strong><span class="koboSpan" id="kobo.216.1">: You start by moving two discs from </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">FROM</span></strong><span class="koboSpan" id="kobo.218.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">AUXILIARY</span></strong><span class="koboSpan" id="kobo.220.1">, using the mechanism described earlier. </span><span class="koboSpan" id="kobo.220.2">The operation involves </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">TO</span></strong><span class="koboSpan" id="kobo.222.1"> as the auxiliary rod. </span><span class="koboSpan" id="kobo.222.2">Then, you move the remaining disc from </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">FROM</span></strong><span class="koboSpan" id="kobo.224.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">TO</span></strong><span class="koboSpan" id="kobo.226.1">, and then move two discs from </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">AUXILIARY</span></strong><span class="koboSpan" id="kobo.228.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">TO</span></strong><span class="koboSpan" id="kobo.230.1">, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">FROM</span></strong><span class="koboSpan" id="kobo.232.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">auxiliary rod.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.234.1">As you </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.235.1">can see, you can solve the problem of </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">moving</span></strong> <strong class="p-bold-italics"><span class="koboSpan" id="kobo.237.1">n</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.238.1">discs</span></strong><span class="koboSpan" id="kobo.239.1"> by moving </span><em class="italic"><span class="koboSpan" id="kobo.240.1">n-1</span></em><span class="koboSpan" id="kobo.241.1"> discs from </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">FROM</span></strong><span class="koboSpan" id="kobo.243.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">AUXILIARY</span></strong><span class="koboSpan" id="kobo.245.1">, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">TO</span></strong><span class="koboSpan" id="kobo.247.1"> as the auxiliary rod. </span><span class="koboSpan" id="kobo.247.2">Then, you </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.248.1">should move the remaining disc from </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">FROM</span></strong><span class="koboSpan" id="kobo.250.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">TO</span></strong><span class="koboSpan" id="kobo.252.1">. </span><span class="koboSpan" id="kobo.252.2">At the end, you just need to move </span><em class="italic"><span class="koboSpan" id="kobo.253.1">n-1</span></em><span class="koboSpan" id="kobo.254.1"> discs from </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">AUXILIARY</span></strong><span class="koboSpan" id="kobo.256.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">TO</span></strong><span class="koboSpan" id="kobo.258.1"> rod, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">FROM</span></strong><span class="koboSpan" id="kobo.260.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">auxiliary rod.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">Now that you know the basic rules, let’s proceed to the code. </span><span class="koboSpan" id="kobo.262.2">First, let’s focus on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Game</span></strong><span class="koboSpan" id="kobo.264.1"> class, which contains the logic related to </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the game:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">Game</span></strong><span class="koboSpan" id="kobo.268.1">
{
    public Stack&lt;int&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">From</span></strong><span class="koboSpan" id="kobo.270.1"> { get; private set; }
    public Stack&lt;int&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">To</span></strong><span class="koboSpan" id="kobo.272.1"> { get; private set; }
    public Stack&lt;int&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">Auxiliary</span></strong><span class="koboSpan" id="kobo.274.1"> { get; private set; }
    public int </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">DiscsCount</span></strong><span class="koboSpan" id="kobo.276.1"> { get; private set; }
    public int </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">MovesCount</span></strong><span class="koboSpan" id="kobo.278.1"> { get; private set; }
    public event EventHandler&lt;EventArgs&gt;? </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">MoveCompleted</span></strong><span class="koboSpan" id="kobo.280.1">;
}</span></pre> <p><span class="koboSpan" id="kobo.281.1">The class contains five properties, representing </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.283.1">Three rods (</span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">From</span></strong><span class="koboSpan" id="kobo.285.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">To</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">Auxiliary</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.290.1">The overall number of </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">discs (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">DiscsCount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.294.1">The number of performed </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">moves (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">MovesCount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.298.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">MoveCompleted</span></strong><span class="koboSpan" id="kobo.300.1"> event is declared as well. </span><span class="koboSpan" id="kobo.300.2">It is fired after each move to inform that the user interface should be refreshed. </span><span class="koboSpan" id="kobo.300.3">Therefore, you can show the proper content, illustrating the current state of </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">the rods.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Apart from the properties and the event, the class also has the </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">following constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.305.1">Game</span></strong><span class="koboSpan" id="kobo.306.1">(int discsCount)
{
    DiscsCount = discsCount;
    From = new Stack&lt;int&gt;();
    To = new Stack&lt;int&gt;();
    Auxiliary = new Stack&lt;int&gt;();
    </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">for (int i = 0; i &lt; discsCount; i++)</span></strong><span class="koboSpan" id="kobo.308.1">
    {
        int size = discsCount - i;
        </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">From.Push(size);</span></strong><span class="koboSpan" id="kobo.310.1">
    }
}</span></pre> <p><span class="koboSpan" id="kobo.311.1">The</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.312.1"> constructor takes only one parameter, namely the </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.313.1">number of discs (</span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">discsCount</span></strong><span class="koboSpan" id="kobo.315.1">), and sets it as a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">DiscsCount</span></strong><span class="koboSpan" id="kobo.317.1"> property. </span><span class="koboSpan" id="kobo.317.2">Then, new instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Stack</span></strong><span class="koboSpan" id="kobo.319.1"> class are created, and references to them are stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">From</span></strong><span class="koboSpan" id="kobo.321.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">To</span></strong><span class="koboSpan" id="kobo.323.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Auxiliary</span></strong><span class="koboSpan" id="kobo.325.1"> properties. </span><span class="koboSpan" id="kobo.325.2">At the end, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">for</span></strong><span class="koboSpan" id="kobo.327.1"> loop is used to create the necessary number of discs and to add elements to the first stack (</span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">From</span></strong><span class="koboSpan" id="kobo.329.1">), using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Push</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">It is worth noting that </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">From</span></strong><span class="koboSpan" id="kobo.334.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">To</span></strong><span class="koboSpan" id="kobo.336.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Auxiliary</span></strong><span class="koboSpan" id="kobo.338.1"> stacks only store integer values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Stack&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.340.1">). </span><span class="koboSpan" id="kobo.340.2">Each integer value represents the size of a particular disc. </span><span class="koboSpan" id="kobo.340.3">Such data is crucial due to the rules of moving discs </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">between rods.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">One of the most interesting and important parts of the code is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">MoveAsync</span></strong><span class="koboSpan" id="kobo.344.1"> recursive method. </span><span class="koboSpan" id="kobo.344.2">It takes four parameters, namely the number of discs and references to three stacks. </span><span class="koboSpan" id="kobo.344.3">However, what happens in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">MoveAsync</span></strong><span class="koboSpan" id="kobo.346.1"> method? </span><span class="koboSpan" id="kobo.346.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">look inside:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
public async Task </span><strong class="bold"><span class="koboSpan" id="kobo.349.1">MoveAsync</span></strong><span class="koboSpan" id="kobo.350.1">(int discs, Stack&lt;int&gt; from,
    Stack&lt;int&gt; to, Stack&lt;int&gt; auxiliary)
{
    if (discs == 0) { return; }
    </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">await MoveAsync(discs - 1, from, auxiliary, to);</span></strong><span class="koboSpan" id="kobo.352.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">to.Push(from.Pop());</span></strong><span class="koboSpan" id="kobo.354.1">
    MovesCount++;
    MoveCompleted?.Invoke(this, EventArgs.Empty);
    await Task.Delay(250);
    </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">await MoveAsync(discs - 1, auxiliary, to, from);</span></strong><span class="koboSpan" id="kobo.356.1">
}</span></pre> <p><span class="koboSpan" id="kobo.357.1">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">MoveAsync</span></strong><span class="koboSpan" id="kobo.359.1"> is </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.360.1">called recursively, it is necessary to</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.361.1"> specify an exit condition to prevent the method from being called infinitely. </span><span class="koboSpan" id="kobo.361.2">In this case, the method will not call itself when the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">discs</span></strong><span class="koboSpan" id="kobo.363.1"> parameter is equal </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">Otherwise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">MoveAsync</span></strong><span class="koboSpan" id="kobo.369.1"> method is called, but the order of stacks is changed. </span><span class="koboSpan" id="kobo.369.2">Then, the element is removed from the stack represented by the second parameter (</span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">from</span></strong><span class="koboSpan" id="kobo.371.1">), and inserted at the top of the stack represented by the third </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">parameter (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">to</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">In the following lines, the number of moves (</span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">MovesCount</span></strong><span class="koboSpan" id="kobo.377.1">) is incremented and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">MoveCompleted</span></strong><span class="koboSpan" id="kobo.379.1"> event is fired. </span><span class="koboSpan" id="kobo.379.2">It is responsible for refreshing the user interface. </span><span class="koboSpan" id="kobo.379.3">Then, the algorithm stops for 250 milliseconds to show the following steps of the operation in a way well visible to </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">a user.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">At the end, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">MoveAsync</span></strong><span class="koboSpan" id="kobo.383.1"> method is called again, with another configuration of rod order. </span><span class="koboSpan" id="kobo.383.2">By calling this method several times, the discs will be moved from the first (</span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">From</span></strong><span class="koboSpan" id="kobo.385.1">) rod to the second (</span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">To</span></strong><span class="koboSpan" id="kobo.387.1">) rod. </span><span class="koboSpan" id="kobo.387.2">The operations performed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">MoveAsync</span></strong><span class="koboSpan" id="kobo.389.1"> method are consistent with the description of the problem of moving </span><em class="italic"><span class="koboSpan" id="kobo.390.1">n</span></em><span class="koboSpan" id="kobo.391.1"> discs between rods, as explained in the introduction to </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">this example.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">When the class with the logic regarding the </span><em class="italic"><span class="koboSpan" id="kobo.394.1">Tower of Hanoi</span></em><span class="koboSpan" id="kobo.395.1"> game is created, let’s see how to create a user interface that allows you to present the following moves of the algorithm. </span><span class="koboSpan" id="kobo.395.2">Such a task is accomplished by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Visualization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.397.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">Visualization</span></strong><span class="koboSpan" id="kobo.400.1">
{
    private readonly Game </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">_game</span></strong><span class="koboSpan" id="kobo.402.1">;
    private readonly int </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">_columnSize</span></strong><span class="koboSpan" id="kobo.404.1">;
    private readonly char[,] </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">_board</span></strong><span class="koboSpan" id="kobo.406.1">;
    public </span><strong class="bold"><span class="koboSpan" id="kobo.407.1">Visualization</span></strong><span class="koboSpan" id="kobo.408.1">(Game game)
    {
        _game = game;
        _columnSize = Math.Max(6,
            GetDiscWidth(_game.DiscsCount) + 2);
        _board = new char[_game.DiscsCount,
            _columnSize * 3];
    }
}</span></pre> <p><span class="koboSpan" id="kobo.409.1">It</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.410.1"> contains </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.411.1">three private fields, namely storing a reference to data of the game (</span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">_game</span></strong><span class="koboSpan" id="kobo.413.1">), the number of characters to present a single rod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">_columnSize</span></strong><span class="koboSpan" id="kobo.415.1">), as well as a two-dimensional array with visualization of all rods, shown in the console (</span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">_board</span></strong><span class="koboSpan" id="kobo.417.1">). </span><span class="koboSpan" id="kobo.417.2">The constructor takes only one parameter and sets values for all </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">private fields.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">Column size is calculated using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">GetDiscWidth</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.421.1">auxiliary method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
private int </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">GetDiscWidth</span></strong><span class="koboSpan" id="kobo.424.1">(int size) =&gt; (2 * size) - 1;</span></pre> <p><span class="koboSpan" id="kobo.425.1">You draw the current state of all three rods by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Show</span></strong><span class="koboSpan" id="kobo.427.1">, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
public void </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">Show</span></strong><span class="koboSpan" id="kobo.431.1">(Game game)
{
    Console.Clear();
    if (game.DiscsCount &lt;= 0) { return; }
    </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">FillEmptyBoard();</span></strong><span class="koboSpan" id="kobo.433.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">FillRodOnBoard(1, game.From);</span></strong><span class="koboSpan" id="kobo.435.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">FillRodOnBoard(2, game.To);</span></strong><span class="koboSpan" id="kobo.437.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">FillRodOnBoard(3, game.Auxiliary);</span></strong><span class="koboSpan" id="kobo.439.1">
    Console.WriteLine(Center("FROM")
        + Center("TO") + Center("AUXILIARY"));
    </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">DrawBoard();</span></strong><span class="koboSpan" id="kobo.441.1">
    Console.WriteLine($"\nMoves: {game.MovesCount}");
    Console.WriteLine($"Discs: {game.DiscsCount}");
}</span></pre> <p><span class="koboSpan" id="kobo.442.1">The </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.443.1">method clears the current content of the console (by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Clear</span></strong><span class="koboSpan" id="kobo.445.1"> method). </span><span class="koboSpan" id="kobo.445.2">Then, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">FillEmptyBoard</span></strong><span class="koboSpan" id="kobo.447.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">FillRodOnBoard</span></strong><span class="koboSpan" id="kobo.449.1"> methods </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.450.1">to clear content that should be shown in the console and then fill it with data of the current state of rods, one in each call of </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">FillRodOnBoard</span></strong><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">Next, you show captions for each rod, draw the board, as well as write the number of moves </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">and discs.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">To clear the content of the board, you just iterate through all elements in the two-dimensional array and set the value of each item to a space, as </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.457.1">FillEmptyBoard</span></strong><span class="koboSpan" id="kobo.458.1">()
{
    for (int y = 0; y &lt; _board.GetLength(0); y++)
    {
        for (int x = 0; x &lt; _board.GetLength(1); x++)
        {
            _board[y, x] = ' ';
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.459.1">If you want to learn </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.460.1">how to fill a part of the two-dimensional array that is related to a particular rod, let’s take </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.461.1">a look at the code </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">FillRodOnBoard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">FillRodOnBoard</span></strong><span class="koboSpan" id="kobo.467.1">(int column, Stack&lt;int&gt; stack)
{
    int discsCount = _game.DiscsCount;
    int margin = _columnSize * (column - 1);
    for (int y = 0; y &lt; stack.Count; y++)
    {
        int size = stack.ElementAt(y);
        int row = discsCount - (stack.Count - y);
        int columnStart = margin + discsCount - size;
        int columnEnd = columnStart + GetDiscWidth(size);
        for (int x = columnStart; x &lt;= columnEnd; x++)
        {
            _board[row, x] = '=';
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.468.1">First, the left margin is calculated to add data in the correct section within the overall array - that is, within the correct range of columns. </span><span class="koboSpan" id="kobo.468.2">The main part of the method is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">for</span></strong><span class="koboSpan" id="kobo.470.1"> loop, where the number of iterations is equal to the number of discs located in the stack. </span><span class="koboSpan" id="kobo.470.2">In each iteration, the size of the current disc is read using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">ElementAt</span></strong><span class="koboSpan" id="kobo.472.1"> extension method (from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">System.Linq</span></strong><span class="koboSpan" id="kobo.474.1"> namespace). </span><span class="koboSpan" id="kobo.474.2">Next, you calculate an index of a row, where the disc should be shown, as well as start and end indices for columns. </span><span class="koboSpan" id="kobo.474.3">Finally, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">for</span></strong><span class="koboSpan" id="kobo.476.1"> loop is used to insert the equals sign (</span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">=</span></strong><span class="koboSpan" id="kobo.478.1">) in proper locations in </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">the array.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">One of the auxiliary methods is </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">Center</span></strong><span class="koboSpan" id="kobo.482.1">. </span><span class="koboSpan" id="kobo.482.2">It aims to add additional spaces before and after the text, passed as the parameter, to center the text in </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">the column:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
private string </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">Center</span></strong><span class="koboSpan" id="kobo.486.1">(string text)
{
    int margin = (_columnSize - text.Length) / 2;
    return text.PadLeft(margin + text.Length)
        .PadRight(_columnSize);
}</span></pre> <p><span class="koboSpan" id="kobo.487.1">The last </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.488.1">used method is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">DrawBoard</span></strong><span class="koboSpan" id="kobo.490.1">. </span><span class="koboSpan" id="kobo.490.2">It simply iterates</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.491.1"> through all elements in the two-dimensional array and writes content in the console. </span><span class="koboSpan" id="kobo.491.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
private void </span><strong class="bold"><span class="koboSpan" id="kobo.494.1">DrawBoard</span></strong><span class="koboSpan" id="kobo.495.1">()
{
    for (int y = 0; y &lt; _board.GetLength(0); y++)
    {
        string line = string.Empty;
        for (int x = 0; x &lt; _board.GetLength(1); x++)
        {
            line += _board[y, x];
        }
        Console.WriteLine(line);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.496.1">In the end, let’s take a look at the main code, located in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.498.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
Game game = new(10);
Visualization vis = new(game);
game.MoveCompleted += (s, e) =&gt; vis.Show((Game)s!);
</span><strong class="bold"><span class="koboSpan" id="kobo.500.1">await game.MoveAsync(game.DiscsCount,</span></strong><span class="koboSpan" id="kobo.501.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.502.1">game.From, game.To, game.Auxiliary);</span></strong></pre> <p><span class="koboSpan" id="kobo.503.1">Here, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">Game</span></strong><span class="koboSpan" id="kobo.505.1"> class is created. </span><span class="koboSpan" id="kobo.505.2">The parameter indicates that </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">10</span></strong><span class="koboSpan" id="kobo.507.1"> discs are used. </span><span class="koboSpan" id="kobo.507.2">In the next line, you create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">Visualization</span></strong><span class="koboSpan" id="kobo.509.1"> class responsible for</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.510.1"> showing the following steps of the game. </span><span class="koboSpan" id="kobo.510.2">You also specify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">Show</span></strong><span class="koboSpan" id="kobo.512.1"> method is called when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">MoveCompleted</span></strong><span class="koboSpan" id="kobo.514.1"> event is fired. </span><span class="koboSpan" id="kobo.514.2">Finally, you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">MoveAsync</span></strong><span class="koboSpan" id="kobo.516.1"> method to start moving discs </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">between rods.</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">You already</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.519.1"> added the necessary code to run the </span><em class="italic"><span class="koboSpan" id="kobo.520.1">Tower of Hanoi</span></em><span class="koboSpan" id="kobo.521.1"> mathematical game. </span><span class="koboSpan" id="kobo.521.2">Let’s launch the application and see it in action! </span><span class="koboSpan" id="kobo.521.3">Just after starting the program, you see that all discs are located in the first rod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">FROM</span></strong><span class="koboSpan" id="kobo.523.1">). </span><span class="koboSpan" id="kobo.523.2">In the next step, the smallest disc is moved from the top of the first rod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">FROM</span></strong><span class="koboSpan" id="kobo.525.1">) to the top of the third rod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">AUXILIARY</span></strong><span class="koboSpan" id="kobo.527.1">), as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.529.1"><img alt="Figure 5.4 – The second step in the Tower of Hanoi example" src="image/B18069_05_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.530.1">Figure 5.4 – The second step in the Tower of Hanoi example</span></p>
<p><span class="koboSpan" id="kobo.531.1">While making many other moves in the program, you can see how discs are moved between all three rods. </span><span class="koboSpan" id="kobo.531.2">One of the intermediate steps is </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.533.1"><img alt="Figure 5.5 – One of the intermediate steps in the Tower of Hanoi example" src="image/B18069_05_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.534.1">Figure 5.5 – One of the intermediate steps in the Tower of Hanoi example</span></p>
<p><span class="koboSpan" id="kobo.535.1">When the </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.536.1">necessary moves are completed, all discs are moved </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.537.1">from the first rod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">FROM</span></strong><span class="koboSpan" id="kobo.539.1">) to the second one (</span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">TO</span></strong><span class="koboSpan" id="kobo.541.1">). </span><span class="koboSpan" id="kobo.541.2">The final result is </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">presented next:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.543.1"><img alt="Figure 5.6 – Final step in the Tower of Hanoi example" src="image/B18069_05_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.544.1">Figure 5.6 – Final step in the Tower of Hanoi example</span></p>
<p><span class="koboSpan" id="kobo.545.1">Finally, it is worth mentioning the number of moves necessary to complete the </span><em class="italic"><span class="koboSpan" id="kobo.546.1">Tower of Hanoi</span></em><span class="koboSpan" id="kobo.547.1"> game. </span><span class="koboSpan" id="kobo.547.2">In the case of 10 discs, the number of moves is 1,023. </span><span class="koboSpan" id="kobo.547.3">If you use only 3 discs, the number of moves is 7. </span><span class="koboSpan" id="kobo.547.4">Generally speaking, </span><strong class="bold"><span class="koboSpan" id="kobo.548.1">the number of moves can be calculated with the formula</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.549.1">2</span></strong><span class="superscript"><span class="koboSpan" id="kobo.550.1">n</span></span><strong class="bold"><span class="koboSpan" id="kobo.551.1">-1</span></strong><span class="koboSpan" id="kobo.552.1">, where </span><em class="italic"><span class="koboSpan" id="kobo.553.1">n</span></em><span class="koboSpan" id="kobo.554.1"> is the number </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">of discs.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">That’s all! </span><span class="koboSpan" id="kobo.556.2">In this section, you learned the first limited access data structure, namely a stack. </span><span class="koboSpan" id="kobo.556.3">Now, it is high time that you get</span><a id="_idTextAnchor175"/> <a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.557.1">to know more </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">about queues.</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.559.1">Queues</span></h1>
<p><span class="koboSpan" id="kobo.560.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">queue</span></strong><span class="koboSpan" id="kobo.562.1"> is a</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.563.1"> data structure </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.564.1">that allows you </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">to add a new element only at the end of the queue</span></strong><span class="koboSpan" id="kobo.566.1"> (referred to as an </span><strong class="bold"><span class="koboSpan" id="kobo.567.1">enqueue</span></strong><span class="koboSpan" id="kobo.568.1"> operation) and </span><strong class="bold"><span class="koboSpan" id="kobo.569.1">to get an element only from the beginning of the queue</span></strong><span class="koboSpan" id="kobo.570.1"> (a </span><strong class="bold"><span class="koboSpan" id="kobo.571.1">dequeue</span></strong><span class="koboSpan" id="kobo.572.1"> operation). </span><span class="koboSpan" id="kobo.572.2">For this</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.573.1"> reason, a queue is consistent with the </span><strong class="bold"><span class="koboSpan" id="kobo.574.1">FIFO</span></strong><span class="koboSpan" id="kobo.575.1"> principle, which</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.576.1"> stands for </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.577.1">First-In First-Out</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.579.1">Imagine a queue</span></p>
<p class="callout"><span class="koboSpan" id="kobo.580.1">If you want to better imagine a queue, let’s take a break from learning data structures and algorithms, wear your favorite jacket, and go to a shop in the vicinity. </span><span class="koboSpan" id="kobo.580.2">You buy your favorite ice cream, and you see five people waiting for checkout. </span><span class="koboSpan" id="kobo.580.3">Oh no... </span><span class="koboSpan" id="kobo.580.4">You are the last one, so you need to wait until the first, second, third, fourth, and fifth person pay. </span><span class="koboSpan" id="kobo.580.5">These lines in shops can be frustrating! </span><span class="koboSpan" id="kobo.580.6">In general, new people stand at the end of the line, and the next person is taken to the checkout from the beginning of the line. </span><span class="koboSpan" id="kobo.580.7">No one is allowed to choose a person from the middle and serve them in a different order. </span><span class="koboSpan" id="kobo.580.8">The queue data structure operates similarly. </span><span class="koboSpan" id="kobo.580.9">You can only add new elements at the end of the queue and remove an element from the beginning of the queue. </span><span class="koboSpan" id="kobo.580.10">So, people who come first (first-in) are served at the </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">beginning (first-out).</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">The</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.583.1"> operation of a queue is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.585.1"><img alt="Figure 5.7 – ﻿Illustration of a queue" src="image/B18069_05_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.586.1">Figure 5.7 – Illustration of a queue</span></p>
<p><span class="koboSpan" id="kobo.587.1">It is worth mentioning that a </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.588.1">queue is a </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">recursive data structure</span></strong><span class="koboSpan" id="kobo.590.1">, similar to a stack. </span><span class="koboSpan" id="kobo.590.2">This means that </span><strong class="bold"><span class="koboSpan" id="kobo.591.1">a queue can be either empty or consists of the first element and the rest of the queue, which also forms a queue</span></strong><span class="koboSpan" id="kobo.592.1">. </span><span class="koboSpan" id="kobo.592.2">Let’s take a look at the following diagram, where the beginning of the queue is marked with a </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">bold line:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.594.1"><img alt="Figure 5.8 – A queue as a recursive data structure" src="image/B18069_05_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.595.1">Figure 5.8 – A queue as a recursive data structure</span></p>
<p><span class="koboSpan" id="kobo.596.1">The queue data structure seems to be very easy to understand, as well as being similar to a stack, apart</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.597.1"> from the way of removing an element. </span><span class="koboSpan" id="kobo.597.2">Does this mean that you can also use a built-in class to use a queue in your programs? </span><span class="koboSpan" id="kobo.597.3">Fortunately, yes! </span><span class="koboSpan" id="kobo.597.4">The available generic class is </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">Queue</span></strong><span class="koboSpan" id="kobo.599.1"> from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">System.Collections.Generic</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.601.1"> namespace.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.602.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.603.1">You can find content regarding a queue </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">at </span></span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1"><span class="No-Break"><span class="koboSpan" id="kobo.605.1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.606.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.607.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">Queue</span></strong><span class="koboSpan" id="kobo.609.1"> class contains the following set </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">of methods:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">Enqueue</span></strong><span class="koboSpan" id="kobo.612.1"> adds an element at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">the queue</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">Dequeue</span></strong><span class="koboSpan" id="kobo.615.1"> removes an element from the beginning of the queue and </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">returns it</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">Peek</span></strong><span class="koboSpan" id="kobo.618.1"> returns an element from the beginning of the queue without </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">removing it</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Clear</span></strong><span class="koboSpan" id="kobo.621.1"> removes all elements from </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the queue</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Contains</span></strong><span class="koboSpan" id="kobo.624.1"> checks whether the queue contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">given element</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.626.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">Queue</span></strong><span class="koboSpan" id="kobo.628.1"> class also contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">Count</span></strong><span class="koboSpan" id="kobo.630.1"> property, which returns the total number of elements located in the queue. </span><span class="koboSpan" id="kobo.630.2">It can be used to check whether the queue </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">is empty.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.632.1">What about the performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.633.1">It is worth mentioning that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">Enqueue</span></strong><span class="koboSpan" id="kobo.635.1"> method is either an </span><em class="italic"><span class="koboSpan" id="kobo.636.1">O(1)</span></em><span class="koboSpan" id="kobo.637.1"> operation, if the internal array does not need to be reallocated, or </span><em class="italic"><span class="koboSpan" id="kobo.638.1">O(n) </span></em><span class="koboSpan" id="kobo.639.1">otherwise, where </span><em class="italic"><span class="koboSpan" id="kobo.640.1">n</span></em><span class="koboSpan" id="kobo.641.1"> is the number of elements in the queue. </span><span class="koboSpan" id="kobo.641.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">Dequeue</span></strong><span class="koboSpan" id="kobo.643.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">Peek</span></strong><span class="koboSpan" id="kobo.645.1"> are </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.646.1">O(1)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.647.1"> operations.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">The </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.649.1">great performance results are supported by a very easy application of this data structure, as shown in the following part of </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.651.1">
List&lt;int&gt; items = [2, -4, 1, 8, 5];
</span><strong class="bold"><span class="koboSpan" id="kobo.652.1">Queue&lt;int&gt; queue = new();</span></strong><span class="koboSpan" id="kobo.653.1">
items.ForEach(queue.</span><strong class="bold"><span class="koboSpan" id="kobo.654.1">Enqueue</span></strong><span class="koboSpan" id="kobo.655.1">);
while (queue.</span><strong class="bold"><span class="koboSpan" id="kobo.656.1">Count</span></strong><span class="koboSpan" id="kobo.657.1"> &gt; 0)
{
    Console.WriteLine(queue.</span><strong class="bold"><span class="koboSpan" id="kobo.658.1">Dequeue</span></strong><span class="koboSpan" id="kobo.659.1">());
}</span></pre> <p><span class="koboSpan" id="kobo.660.1">Here, you create a new list and a queue containing only integer values. </span><span class="koboSpan" id="kobo.660.2">Then, you add all elements from the list to the queue, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">Enqueue</span></strong><span class="koboSpan" id="kobo.662.1"> method. </span><span class="koboSpan" id="kobo.662.2">At the end, you use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">while</span></strong><span class="koboSpan" id="kobo.664.1"> loop to </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.665.1">dequeue all the elements, using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">Dequeue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">It is worth noting that in the third line, you do not use the lambda expression and simply use the name of the method. </span><span class="koboSpan" id="kobo.668.2">Of course, you can use the following </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">form instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.670.1">
items.ForEach(</span><strong class="bold"><span class="koboSpan" id="kobo.671.1">i</span></strong><span class="koboSpan" id="kobo.672.1"> =&gt; queue.Enqueue</span><strong class="bold"><span class="koboSpan" id="kobo.673.1">(i)</span></strong><span class="koboSpan" id="kobo.674.1">);</span></pre> <p><span class="koboSpan" id="kobo.675.1">The additional comment is necessary for scenarios where you want to use a queue concurrently from many threads. </span><span class="koboSpan" id="kobo.675.2">In such a case, it is necessary to choose the thread-safe variant of the queue, which is represented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">ConcurrentQueue</span></strong><span class="koboSpan" id="kobo.677.1"> generic class from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">System.Collections.Concurrent</span></strong><span class="koboSpan" id="kobo.679.1"> namespace. </span><span class="koboSpan" id="kobo.679.2">This class contains a set of built-in methods to </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.680.1">perform various operations on the queue, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">Enqueue</span></strong><span class="koboSpan" id="kobo.683.1"> adds an element at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">the queue</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">TryDequeue</span></strong><span class="koboSpan" id="kobo.686.1"> tries to remove an element from the beginning and </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">return it</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">TryPeek</span></strong><span class="koboSpan" id="kobo.689.1"> tries to return an element from the beginning without </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">removing it</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.691.1">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">TryDequeue</span></strong><span class="koboSpan" id="kobo.693.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">TryPeek</span></strong><span class="koboSpan" id="kobo.695.1"> have a parameter with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">out</span></strong><span class="koboSpan" id="kobo.697.1"> keyword. </span><span class="koboSpan" id="kobo.697.2">If the operation is successful, such methods return </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">true</span></strong><span class="koboSpan" id="kobo.699.1">, and the result is returned as a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">out</span></strong><span class="koboSpan" id="kobo.701.1"> parameter. </span><span class="koboSpan" id="kobo.701.2">Moreover, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">ConcurrentQueue</span></strong><span class="koboSpan" id="kobo.703.1"> class also contains two properties, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">Count</span></strong><span class="koboSpan" id="kobo.705.1"> to get the number of elements stored in the collection and </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">IsEmpty</span></strong><span class="koboSpan" id="kobo.707.1"> to return a value indicating whether the queue </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">is empty.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.709.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.710.1">You can find content regarding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">ConcurrentQueue</span></strong><span class="koboSpan" id="kobo.712.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">at </span></span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1"><span class="No-Break"><span class="koboSpan" id="kobo.714.1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.715.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">After this short introduction, let’s proceed to two examples representing a queue in the context of a call center, with many c</span><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.717.1">l</span><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.718.1">ients and one or </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">many consultants.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.720.1">Example – call center with a single consultant</span></h2>
<p><span class="koboSpan" id="kobo.721.1">This</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.722.1"> first example represents a simple approach to the call center solution, where there are </span><strong class="bold"><span class="koboSpan" id="kobo.723.1">many clients</span></strong><span class="koboSpan" id="kobo.724.1"> (with different identifiers), and </span><strong class="bold"><span class="koboSpan" id="kobo.725.1">only one consultant</span></strong><span class="koboSpan" id="kobo.726.1">, who answers waiting calls in the same order in which </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">they appear.</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">This scenario is </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">shown next:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.730.1"><img alt="Figure 5.9 – ﻿Illustration of the call center with a single consultant example" src="image/B18069_05_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.731.1">Figure 5.9 – Illustration of the call center with a single consultant example</span></p>
<p><span class="koboSpan" id="kobo.732.1">As you </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.733.1">can see in the preceding diagram, four calls are performed by clients. </span><span class="koboSpan" id="kobo.733.2">They are added to the queue with waiting phone calls, namely from clients </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">#1234</span></strong><span class="koboSpan" id="kobo.735.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">#5678</span></strong><span class="koboSpan" id="kobo.737.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">#1468</span></strong><span class="koboSpan" id="kobo.739.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">#9641</span></strong><span class="koboSpan" id="kobo.741.1">. </span><span class="koboSpan" id="kobo.741.2">When a consultant is available, they answer the phone. </span><span class="koboSpan" id="kobo.741.3">When the call ends, the consultant can answer the next waiting call. </span><span class="koboSpan" id="kobo.741.4">According to this rule, the consultant will talk with clients in the following order: </span><strong class="bold"><span class="koboSpan" id="kobo.742.1">#1234</span></strong><span class="koboSpan" id="kobo.743.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.744.1">#5678</span></strong><span class="koboSpan" id="kobo.745.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.746.1">#1468</span></strong><span class="koboSpan" id="kobo.747.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.749.1">#9641</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">Let’s take a look at the code of the first class, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">IncomingCall</span></strong><span class="koboSpan" id="kobo.753.1">, which represents a single incoming call performed by a client. </span><span class="koboSpan" id="kobo.753.2">Its code is </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.755.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.756.1">IncomingCall</span></strong><span class="koboSpan" id="kobo.757.1">
{
    public int Id { get; set; }
    public int ClientId { get; set; }
    public DateTime CallTime { get; set; }
    public DateTime? </span><span class="koboSpan" id="kobo.757.2">AnswerTime { get; set; }
    public DateTime? </span><span class="koboSpan" id="kobo.757.3">EndTime { get; set; }
    public string? </span><span class="koboSpan" id="kobo.757.4">Consultant { get; set; }
}</span></pre> <p><span class="koboSpan" id="kobo.758.1">The class contains six properties representing a unique identifier of a call (</span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">Id</span></strong><span class="koboSpan" id="kobo.760.1">), a client identifier (</span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">ClientId</span></strong><span class="koboSpan" id="kobo.762.1">), the date and time when the call was started (</span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">CallTime</span></strong><span class="koboSpan" id="kobo.764.1">), when it was answered (</span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">AnswerTime</span></strong><span class="koboSpan" id="kobo.766.1">), and when it was ended (</span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">EndTime</span></strong><span class="koboSpan" id="kobo.768.1">), as well as the name of the </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">consultant (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">Consultant</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">The </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.773.1">most important part of the code is related to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">CallCenter</span></strong><span class="koboSpan" id="kobo.775.1"> class, which represents call-related operations. </span><span class="koboSpan" id="kobo.775.2">Its fragment is </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.777.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.778.1">CallCenter</span></strong><span class="koboSpan" id="kobo.779.1">
{
    private int _counter = 0;
    </span><strong class="bold"><span class="koboSpan" id="kobo.780.1">public Queue&lt;IncomingCall&gt; Calls { get; private set; }</span></strong><span class="koboSpan" id="kobo.781.1">
    public CallCenter() =&gt;
        Calls = </span><strong class="bold"><span class="koboSpan" id="kobo.782.1">new Queue&lt;IncomingCall&gt;();</span></strong><span class="koboSpan" id="kobo.783.1">
}</span></pre> <p><span class="koboSpan" id="kobo.784.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">CallCenter</span></strong><span class="koboSpan" id="kobo.786.1"> class contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">_counter</span></strong><span class="koboSpan" id="kobo.788.1"> field with an identifier of the last call, which is equal to the number of calls so far. </span><span class="koboSpan" id="kobo.788.2">The class also has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">Calls</span></strong><span class="koboSpan" id="kobo.790.1"> property representing a queue (with </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">IncomingCall</span></strong><span class="koboSpan" id="kobo.792.1"> instances), where data of waiting calls is stored. </span><span class="koboSpan" id="kobo.792.2">In the constructor, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">Queue</span></strong><span class="koboSpan" id="kobo.794.1"> generic class is created, and its reference is assigned to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">Calls</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.796.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.797.1">Of course, the class contains some methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">Call</span></strong><span class="koboSpan" id="kobo.799.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.801.1">
public IncomingCall </span><strong class="bold"><span class="koboSpan" id="kobo.802.1">Call</span></strong><span class="koboSpan" id="kobo.803.1">(int clientId)
{
    IncomingCall call = new()
    {
        Id = ++_counter,
        ClientId = clientId,
        CallTime = DateTime.Now
    };
    Calls.</span><strong class="bold"><span class="koboSpan" id="kobo.804.1">Enqueue</span></strong><span class="koboSpan" id="kobo.805.1">(call);
    return call;
}</span></pre> <p><span class="koboSpan" id="kobo.806.1">Here, you</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.807.1"> create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">IncomingCall</span></strong><span class="koboSpan" id="kobo.809.1"> class and set values of its properties, namely its identifier (together with pre-incrementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">_counter</span></strong><span class="koboSpan" id="kobo.811.1"> field), the client identifier (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">clientId</span></strong><span class="koboSpan" id="kobo.813.1"> parameter), and the call time. </span><span class="koboSpan" id="kobo.813.2">The created instance is added to the queue by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">Enqueue</span></strong><span class="koboSpan" id="kobo.815.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">and returned.</span></span></p>
<p><span class="koboSpan" id="kobo.817.1">The next method is </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">Answer</span></strong><span class="koboSpan" id="kobo.819.1">. </span><span class="koboSpan" id="kobo.819.2">It represents the operation of answering the call from the person waiting in the queue for the longest time. </span><span class="koboSpan" id="kobo.819.3">Such a call is represented by the element located at the beginning of the queue. </span><span class="koboSpan" id="kobo.819.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">Answer</span></strong><span class="koboSpan" id="kobo.821.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.823.1">
public IncomingCall? </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">Answer</span></strong><span class="koboSpan" id="kobo.825.1">(string consultant)
{
    if (!AreWaitingCalls()) { return null; }
    IncomingCall call = Calls.</span><strong class="bold"><span class="koboSpan" id="kobo.826.1">Dequeue</span></strong><span class="koboSpan" id="kobo.827.1">();
    call.Consultant = consultant;
    call.AnswerTime = DateTime.Now;
    return call;
}</span></pre> <p><span class="koboSpan" id="kobo.828.1">Within this method, you check whether the queue is empty. </span><span class="koboSpan" id="kobo.828.2">If so, the method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">null</span></strong><span class="koboSpan" id="kobo.830.1">, which means that there are no phone calls that can be answered by the consultant. </span><span class="koboSpan" id="kobo.830.2">Otherwise, the call is removed from the queue (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">Dequeue</span></strong><span class="koboSpan" id="kobo.832.1"> method), and its properties are updated by setting the consultant’s name (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">consultant</span></strong><span class="koboSpan" id="kobo.834.1"> parameter) and answer time (to the current date and time). </span><span class="koboSpan" id="kobo.834.2">At the end, the data of the call </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">is returned.</span></span></p>
<p><span class="koboSpan" id="kobo.836.1">Apart from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">Call</span></strong><span class="koboSpan" id="kobo.838.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">Answer</span></strong><span class="koboSpan" id="kobo.840.1"> methods, you also implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">End</span></strong><span class="koboSpan" id="kobo.842.1"> method, which is called whenever the consultant ends a call with a particular client. </span><span class="koboSpan" id="kobo.842.2">In such a case, you only set the end time, as shown in the following piece </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.844.1">
public void </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">End</span></strong><span class="koboSpan" id="kobo.846.1">(IncomingCall call)
    =&gt; call.EndTime = DateTime.Now;</span></pre> <p><span class="koboSpan" id="kobo.847.1">The</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.848.1"> last method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">CallCenter</span></strong><span class="koboSpan" id="kobo.850.1"> class is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">AreWaitingCalls</span></strong><span class="koboSpan" id="kobo.852.1">. </span><span class="koboSpan" id="kobo.852.2">It returns a value indicating whether there are any waiting calls in the queue, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">Count</span></strong><span class="koboSpan" id="kobo.854.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">Queue</span></strong><span class="koboSpan" id="kobo.856.1"> class. </span><span class="koboSpan" id="kobo.856.2">Its code is </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.858.1">
public bool </span><strong class="bold"><span class="koboSpan" id="kobo.859.1">AreWaitingCalls</span></strong><span class="koboSpan" id="kobo.860.1">() =&gt; Calls.Count &gt; 0;</span></pre> <p><span class="koboSpan" id="kobo.861.1">Let’s proceed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">Program.cs</span></strong><span class="koboSpan" id="kobo.863.1"> file and </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">its code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.865.1">
Random random = new();
</span><strong class="bold"><span class="koboSpan" id="kobo.866.1">CallCenter center = new();</span></strong><span class="koboSpan" id="kobo.867.1">
center.</span><strong class="bold"><span class="koboSpan" id="kobo.868.1">Call</span></strong><span class="koboSpan" id="kobo.869.1">(1234);
center.</span><strong class="bold"><span class="koboSpan" id="kobo.870.1">Call</span></strong><span class="koboSpan" id="kobo.871.1">(5678);
center.</span><strong class="bold"><span class="koboSpan" id="kobo.872.1">Call</span></strong><span class="koboSpan" id="kobo.873.1">(1468);
center.</span><strong class="bold"><span class="koboSpan" id="kobo.874.1">Call</span></strong><span class="koboSpan" id="kobo.875.1">(9641);
while (center.</span><strong class="bold"><span class="koboSpan" id="kobo.876.1">AreWaitingCalls</span></strong><span class="koboSpan" id="kobo.877.1">())
{
    IncomingCall call = center.</span><strong class="bold"><span class="koboSpan" id="kobo.878.1">Answer</span></strong><span class="koboSpan" id="kobo.879.1">("Marcin")!;
    Log($"Call #{call.Id} from client #{call.ClientId}
        answered by {call.Consultant}.");
    await Task.Delay(random.Next(1000, 10000));
    center.</span><strong class="bold"><span class="koboSpan" id="kobo.880.1">End</span></strong><span class="koboSpan" id="kobo.881.1">(call);
    Log($"Call #{call.Id} from client #{call.ClientId}
        ended by {call.Consultant}.");
}</span></pre> <p><span class="koboSpan" id="kobo.882.1">You </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.883.1">create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">Random</span></strong><span class="koboSpan" id="kobo.885.1"> class (for getting random numbers), as well as an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">CallCenter</span></strong><span class="koboSpan" id="kobo.887.1"> class. </span><span class="koboSpan" id="kobo.887.2">Then, you simulate making a few calls by clients, namely with the following identifiers: </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">1234</span></strong><span class="koboSpan" id="kobo.889.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">5678</span></strong><span class="koboSpan" id="kobo.891.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">1468</span></strong><span class="koboSpan" id="kobo.893.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">9641</span></strong><span class="koboSpan" id="kobo.895.1">. </span><span class="koboSpan" id="kobo.895.2">The most interesting part of the code is located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">while</span></strong><span class="koboSpan" id="kobo.897.1"> loop, which is executed until there are no waiting calls in the queue. </span><span class="koboSpan" id="kobo.897.2">Within the loop, the consultant answers the call (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">Answer</span></strong><span class="koboSpan" id="kobo.899.1"> method) and a log is generated (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">Log</span></strong><span class="koboSpan" id="kobo.901.1"> auxiliary method). </span><span class="koboSpan" id="kobo.901.2">Then, you wait for a random number of milliseconds (between </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">1000</span></strong><span class="koboSpan" id="kobo.903.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">10000</span></strong><span class="koboSpan" id="kobo.905.1">) to simulate the various lengths of a call. </span><span class="koboSpan" id="kobo.905.2">When this has elapsed, the call ends (by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">End</span></strong><span class="koboSpan" id="kobo.907.1"> method), and a proper log </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">is generated.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">The last part of the code necessary for this example is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">Log</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.911.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.912.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.913.1">Log</span></strong><span class="koboSpan" id="kobo.914.1">(string text) =&gt;
    Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] {text}");</span></pre> <p><span class="koboSpan" id="kobo.915.1">When you run the example, you will receive a result similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.917.1">
[13:10:53] Call #1 from client #1234 answered by Marcin.
</span><span class="koboSpan" id="kobo.917.2">[13:10:56] Call #1 from client #1234 ended by Marcin.
</span><span class="koboSpan" id="kobo.917.3">[13:10:56] Call #2 from client #5678 answered by Marcin.
</span><span class="koboSpan" id="kobo.917.4">[13:10:59] Call #2 from client #5678 ended by Marcin.
</span><span class="koboSpan" id="kobo.917.5">[13:10:59] Call #3 from client #1468 answered by Marcin.
</span><span class="koboSpan" id="kobo.917.6">[13:11:06] Call #3 from client #1468 ended by Marcin.
</span><span class="koboSpan" id="kobo.917.7">[13:11:06] Call #4 from client #9641 answered by Marcin.
</span><span class="koboSpan" id="kobo.917.8">[13:11:09] Call #4 from client #9641 ended by Marcin.</span></pre> <p><span class="koboSpan" id="kobo.918.1">Congratulations! </span><span class="koboSpan" id="kobo.918.2">You just completed the first example regarding a queue data structure. </span><span class="koboSpan" id="kobo.918.3">If you want to learn more about the thread-safe version of the queue-related c</span><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.919.1">l</span><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.920.1">ass, let’s proceed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">next example.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.922.1">Example – call center with many consultants</span></h2>
<p><span class="koboSpan" id="kobo.923.1">The example </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.924.1">shown in the preceding section was intentionally simplified to make understanding a queue much simpler. </span><span class="koboSpan" id="kobo.924.2">However, it is high time you make it more related to real-world problems. </span><span class="koboSpan" id="kobo.924.3">In this section, you will see how to expand it to support many consultants, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.926.1"><img alt="Figure 5.10 – ﻿Illustration of the call center with many consultants example" src="image/B18069_05_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.927.1">Figure 5.10 – Illustration of the call center with many consultants example</span></p>
<p><span class="koboSpan" id="kobo.928.1">What is important is that both clients and consultants operate at the same time. </span><span class="koboSpan" id="kobo.928.2">If there are more incoming calls than available consultants, a new call will be added to the queue and will wait until there is a consultant who can answer the call. </span><span class="koboSpan" id="kobo.928.3">If there are too many consultants and few calls, the consultants will wait for a call. </span><span class="koboSpan" id="kobo.928.4">To perform this task, you create a few threads, which access the queue. </span><span class="koboSpan" id="kobo.928.5">Therefore, you use a thread-safe version of the queue, namely the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">ConcurrentQueue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.930.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.931.1">Let’s take a </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.932.1">look at the code! </span><span class="koboSpan" id="kobo.932.2">First, you need to declare an </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">IncomingCall</span></strong><span class="koboSpan" id="kobo.934.1"> class, the code of which is exactly the same as in the previous example. </span><span class="koboSpan" id="kobo.934.2">Various modifications are necessary in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">CallCenter</span></strong><span class="koboSpan" id="kobo.936.1"> class, as </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">presented next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.938.1">
using System.Collections.Concurrent;
public class </span><strong class="bold"><span class="koboSpan" id="kobo.939.1">CallCenter</span></strong><span class="koboSpan" id="kobo.940.1">
{
    private int _counter = 0;
    </span><strong class="bold"><span class="koboSpan" id="kobo.941.1">public ConcurrentQueue&lt;IncomingCall&gt; Calls</span></strong><span class="koboSpan" id="kobo.942.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.943.1">{ get; private set; }</span></strong><span class="koboSpan" id="kobo.944.1">
    public CallCenter() =&gt; Calls =
        </span><strong class="bold"><span class="koboSpan" id="kobo.945.1">new ConcurrentQueue&lt;IncomingCall&gt;();</span></strong><span class="koboSpan" id="kobo.946.1">
}</span></pre> <p><span class="koboSpan" id="kobo.947.1">As the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">Enqueue</span></strong><span class="koboSpan" id="kobo.949.1"> method is available in both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">Queue</span></strong><span class="koboSpan" id="kobo.951.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">ConcurrentQueue</span></strong><span class="koboSpan" id="kobo.953.1"> classes, no changes are necessary in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">Call</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.955.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.956.1">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">Dequeue</span></strong><span class="koboSpan" id="kobo.958.1"> method does not exist in </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">ConcurrentQueue</span></strong><span class="koboSpan" id="kobo.960.1">. </span><span class="koboSpan" id="kobo.960.2">For this reason, you need to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">Answer</span></strong><span class="koboSpan" id="kobo.962.1"> method to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">TryDequeue</span></strong><span class="koboSpan" id="kobo.964.1"> method. </span><span class="koboSpan" id="kobo.964.2">It returns a value indicating whether the element is removed from the queue. </span><span class="koboSpan" id="kobo.964.3">The removed element is returned using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">out</span></strong><span class="koboSpan" id="kobo.966.1"> parameter, as </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.968.1">
public IncomingCall? </span><span class="koboSpan" id="kobo.968.2">Answer(string consultant)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.969.1">if (!Calls.IsEmpty</span></strong><span class="koboSpan" id="kobo.970.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.971.1">&amp;&amp; Calls.TryDequeue(out IncomingCall? </span><span class="koboSpan" id="kobo.971.2">call))</span></strong><span class="koboSpan" id="kobo.972.1">
    {
        call.Consultant = consultant;
        call.AnswerTime = DateTime.Now;
        return call;
    }
    return null;
}</span></pre> <p><span class="koboSpan" id="kobo.973.1">You</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.974.1"> can also slightly modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">AreWaitingCalls</span></strong><span class="koboSpan" id="kobo.976.1"> method to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">IsEmpty</span></strong><span class="koboSpan" id="kobo.978.1"> property instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">Count</span></strong><span class="koboSpan" id="kobo.980.1">, presented </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.982.1">
public bool AreWaitingCalls() =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.983.1">!Calls.IsEmpty</span></strong><span class="koboSpan" id="kobo.984.1">;</span></pre> <p><span class="koboSpan" id="kobo.985.1">No further modifications are necessary in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">CallCenter</span></strong><span class="koboSpan" id="kobo.987.1"> class. </span><span class="koboSpan" id="kobo.987.2">However, more changes are required in the code located in </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">Program.cs</span></strong><span class="koboSpan" id="kobo.989.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.991.1">
Random random = new();
</span><strong class="bold"><span class="koboSpan" id="kobo.992.1">CallCenter center = new();</span></strong><span class="koboSpan" id="kobo.993.1">
Parallel.Invoke(
  () =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.994.1">Clients</span></strong><span class="koboSpan" id="kobo.995.1">(center),
  () =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.996.1">Consultant</span></strong><span class="koboSpan" id="kobo.997.1">(center, "Marcin", ConsoleColor.Red),
  () =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.998.1">Consultant</span></strong><span class="koboSpan" id="kobo.999.1">(center, "James", ConsoleColor.Yellow),
  () =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1000.1">Consultant</span></strong><span class="koboSpan" id="kobo.1001.1">(center, "Olivia", ConsoleColor.Green));</span></pre> <p><span class="koboSpan" id="kobo.1002.1">Here, just after the creation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">CallCenter</span></strong><span class="koboSpan" id="kobo.1004.1"> instance, you start execution of four actions, namely representing clients and three consultants, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">Invoke</span></strong><span class="koboSpan" id="kobo.1006.1"> static method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">Parallel</span></strong><span class="koboSpan" id="kobo.1008.1"> class from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">System.Threading.Tasks</span></strong><span class="koboSpan" id="kobo.1010.1"> namespace. </span><span class="koboSpan" id="kobo.1010.2">The lambda expressions are used to specify methods that are called, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">Clients</span></strong><span class="koboSpan" id="kobo.1012.1"> for client-related operations and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">Consultant</span></strong><span class="koboSpan" id="kobo.1014.1"> for consultant-related tasks. </span><span class="koboSpan" id="kobo.1014.2">You also specify additional parameters, such as a name and a color for a </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">given consultant.</span></span></p>
<p><span class="koboSpan" id="kobo.1016.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">Clients</span></strong><span class="koboSpan" id="kobo.1018.1"> method represents operations performed cyclically by many clients. </span><span class="koboSpan" id="kobo.1018.2">Its code is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">following block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1020.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1021.1">Clients</span></strong><span class="koboSpan" id="kobo.1022.1">(CallCenter center)
{
    while (true)
    {
        int clientId = random.Next(1, 10000);
        IncomingCall call = center.</span><strong class="bold"><span class="koboSpan" id="kobo.1023.1">Call</span></strong><span class="koboSpan" id="kobo.1024.1">(clientId);
        Log($"Incoming call #{call.Id}
            from client #{clientId}");
        Log($"Waiting calls in the queue:
            {</span><strong class="bold"><span class="koboSpan" id="kobo.1025.1">center.Calls.Count</span></strong><span class="koboSpan" id="kobo.1026.1">}");
        Thread.Sleep(random.Next(500, 2000));
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1027.1">Within</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.1028.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">while</span></strong><span class="koboSpan" id="kobo.1030.1"> loop, you get a random number as an identifier of a client (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">clientId</span></strong><span class="koboSpan" id="kobo.1032.1">), and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">Call</span></strong><span class="koboSpan" id="kobo.1034.1"> method is called. </span><span class="koboSpan" id="kobo.1034.2">The client identifier is logged, together with the number of waiting calls. </span><span class="koboSpan" id="kobo.1034.3">At the end, the client-related thread is suspended for a random number of milliseconds in the range between 500 ms and 2,000 ms, to simulate the delay between another call made by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">next client.</span></span></p>
<p><span class="koboSpan" id="kobo.1036.1">The following method is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">Consultant</span></strong><span class="koboSpan" id="kobo.1038.1"> and is executed on a separate thread for each consultant. </span><span class="koboSpan" id="kobo.1038.2">The method takes three parameters, namely an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">CallCenter</span></strong><span class="koboSpan" id="kobo.1040.1">, as well as a name and color for the consultant. </span><span class="koboSpan" id="kobo.1040.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1042.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1043.1">Consultant</span></strong><span class="koboSpan" id="kobo.1044.1">(CallCenter center, string name,
    ConsoleColor color)
{
    while (true)
    {
        Thread.Sleep(random.Next(500, 1000));
        IncomingCall? </span><span class="koboSpan" id="kobo.1044.2">call = center.</span><strong class="bold"><span class="koboSpan" id="kobo.1045.1">Answer</span></strong><span class="koboSpan" id="kobo.1046.1">(name);
        if (call == null) { continue; }
        Log($"Call #{call.Id} from client #{call.ClientId}
            answered by {call.Consultant}.", color);
        Thread.Sleep(random.Next(1000, 10000));
        center.</span><strong class="bold"><span class="koboSpan" id="kobo.1047.1">End</span></strong><span class="koboSpan" id="kobo.1048.1">(call);
        Log($"Call #{call.Id} from client #{call.ClientId}
            ended by {call.Consultant}.", color);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.1049.1">Within </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.1050.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">while</span></strong><span class="koboSpan" id="kobo.1052.1"> loop, the consultant waits for a random period, between 0.5 and 1 second. </span><span class="koboSpan" id="kobo.1052.2">Then, they try to answer the first waiting call, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">Answer</span></strong><span class="koboSpan" id="kobo.1054.1"> method. </span><span class="koboSpan" id="kobo.1054.2">If there are no waiting calls, you skip to the next iteration. </span><span class="koboSpan" id="kobo.1054.3">Otherwise, the log is presented in a color of the current consultant. </span><span class="koboSpan" id="kobo.1054.4">Then, the thread is suspended for a random period of time between 1 and 10 seconds. </span><span class="koboSpan" id="kobo.1054.5">After this time, the consultant ends the call, which is indicated by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">End</span></strong><span class="koboSpan" id="kobo.1056.1"> method, and a log </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">is generated.</span></span></p>
<p><span class="koboSpan" id="kobo.1058.1">The last method is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">Log</span></strong><span class="koboSpan" id="kobo.1060.1"> and is similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">previous example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1062.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1063.1">Log</span></strong><span class="koboSpan" id="kobo.1064.1">(string text,
    ConsoleColor color = ConsoleColor.Gray)
{
    Console.ForegroundColor = color;
    Console.WriteLine(
        $"[{DateTime.Now:HH:mm:ss.fff}] {text}");
    Console.ResetColor();
}</span></pre> <p><span class="koboSpan" id="kobo.1065.1">When you run the program and wait for some time, you will receive a result similar to the one shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.1067.1"><img alt="Figure 5.11 – ﻿Screenshot of the call center with many consultants example" src="image/B18069_05_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1068.1">Figure 5.11 – Screenshot of the call center with many consultants example</span></p>
<p><span class="koboSpan" id="kobo.1069.1">You just</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.1070.1"> completed two examples representing the application of a queue in the case of a call center scenario. </span><span class="koboSpan" id="kobo.1070.2">Are you already a </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">queue master?</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1072.1">Try to modify parameters on your own</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1073.1">It is a good idea to modify various parameters of the program, such as the number of consultants, as well as delay times, especially the delay between following calls performed by clients. </span><span class="koboSpan" id="kobo.1073.2">Then, you will see how the algorithm works in the case when there are too many clients, as well as too many or too </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">few consultants.</span></span></p>
<p><span class="koboSpan" id="kobo.1075.1">However, how</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.1076.1"> can you handle clients with priority support? </span><span class="koboSpan" id="kobo.1076.2">In the current solution, they wait in the same queue as clients with the standard support plan. </span><span class="koboSpan" id="kobo.1076.3">Do you need to create two queues and first take clients from the prioritized queue? </span><span class="koboSpan" id="kobo.1076.4">If so, what should happen if you introduce another support plan? </span><span class="koboSpan" id="kobo.1076.5">Do you need to add another queue and introduce such modifications in the code? </span><span class="koboSpan" id="kobo.1076.6">Fortunately, no! </span><span class="koboSpan" id="kobo.1076.7">You can use another data structure, namely a priority queue, as </span><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.1077.1">e</span><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.1078.1">xplained in detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">following section.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.1080.1">Priority queues</span></h1>
<p><span class="koboSpan" id="kobo.1081.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.1082.1">priority queue</span></strong><span class="koboSpan" id="kobo.1083.1"> makes </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.1084.1">it possible to extend the concept of a queue by setting a </span><strong class="bold"><span class="koboSpan" id="kobo.1085.1">priority</span></strong><span class="koboSpan" id="kobo.1086.1"> for </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.1087.1">each element in the queue. </span><strong class="bold"><span class="koboSpan" id="kobo.1088.1">The elements are dequeued starting from those with the highest priority. </span><span class="koboSpan" id="kobo.1088.2">Within each priority, you dequeue items in the same order as in a standard queue.</span></strong><span class="koboSpan" id="kobo.1089.1"> It is worth mentioning that the priority can be specified simply as an integer value. </span><span class="koboSpan" id="kobo.1089.2">It depends on the implementation whether smaller or greater values indicate higher priority. </span><span class="koboSpan" id="kobo.1089.3">In the book, it is assumed that the highest priority is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">0</span></strong><span class="koboSpan" id="kobo.1091.1">, while lower priority is specified by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">1</span></strong><span class="koboSpan" id="kobo.1093.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">2</span></strong><span class="koboSpan" id="kobo.1095.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">3</span></strong><span class="koboSpan" id="kobo.1097.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1098.1">so on.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1099.1">Imagine a priority queue</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1100.1">If you want to better visualize a priority queue, close your eyes for a moment and imagine yourself going on the greatest vacation of your life. </span><span class="koboSpan" id="kobo.1100.2">All passengers are already lining up at the gate, including you, but it turns out that right next to it, there is a much shorter queue for people who have a gold airline card. </span><span class="koboSpan" id="kobo.1100.3">There are only 3 people in that line, and in yours there are over 100. </span><span class="koboSpan" id="kobo.1100.4">These 3 people will be served first, and only then will the service of your queue begin. </span><span class="koboSpan" id="kobo.1100.5">Well, that’s how a priority queue works! </span><span class="koboSpan" id="kobo.1100.6">You first serve all the highest priority items in the order they were added to the priority queue. </span><span class="koboSpan" id="kobo.1100.7">Then, you return all lower priority items, also in the order they were added to the priority queue. </span><span class="koboSpan" id="kobo.1100.8">Then, you take all items with an even lower priority, and so on, until all priorities are properly handled. </span><span class="koboSpan" id="kobo.1100.9">And now the dream about holidays is over, it’s time to get back to further learning data structures </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">and algorithms!</span></span></p>
<p><span class="koboSpan" id="kobo.1102.1">A diagram of a priority queue is </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">presented next:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.1104.1"><img alt="Figure 5.12 – ﻿Illustration of a priority queue" src="image/B18069_05_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1105.1">Figure 5.12 – Illustration of a priority queue</span></p>
<p><span class="koboSpan" id="kobo.1106.1">Let’s analyze</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.1107.1"> the diagram. </span><span class="koboSpan" id="kobo.1107.2">First, the priority queue contains two </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.1108.1">elements with the same priority (equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">1</span></strong><span class="koboSpan" id="kobo.1110.1">), namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">Marcin</span></strong><span class="koboSpan" id="kobo.1112.1"> (first) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">Lily</span></strong><span class="koboSpan" id="kobo.1114.1"> (second). </span><span class="koboSpan" id="kobo.1114.2">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">Mary</span></strong><span class="koboSpan" id="kobo.1116.1"> is added with the lowest priority (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">2</span></strong><span class="koboSpan" id="kobo.1118.1">), which means that this element is placed at the end of the queue. </span><span class="koboSpan" id="kobo.1118.2">In the next step, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">John</span></strong><span class="koboSpan" id="kobo.1120.1"> is added with the highest priority (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">0</span></strong><span class="koboSpan" id="kobo.1122.1">), so it is added at the beginning of the priority queue. </span><span class="koboSpan" id="kobo.1122.2">The third column presents the addition of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">Emily</span></strong><span class="koboSpan" id="kobo.1124.1"> with a priority equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">1</span></strong><span class="koboSpan" id="kobo.1126.1"> -  the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">Marcin</span></strong><span class="koboSpan" id="kobo.1128.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">Lily</span></strong><span class="koboSpan" id="kobo.1130.1">. </span><span class="koboSpan" id="kobo.1130.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">Emily</span></strong><span class="koboSpan" id="kobo.1132.1"> is added last, it is added after </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">Lily</span></strong><span class="koboSpan" id="kobo.1134.1">. </span><span class="koboSpan" id="kobo.1134.2">According to the aforementioned rules, you add the following elements - namely, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">Sarah</span></strong><span class="koboSpan" id="kobo.1136.1"> with a priority set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">2</span></strong><span class="koboSpan" id="kobo.1138.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">Luke</span></strong><span class="koboSpan" id="kobo.1140.1"> with a priority equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">1</span></strong><span class="koboSpan" id="kobo.1142.1">. </span><span class="koboSpan" id="kobo.1142.2">The final order is shown on the right-hand side of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">preceding diagram.</span></span></p>
<p><span class="koboSpan" id="kobo.1144.1">Of course, it is possible to implement a priority queue </span><strong class="bold"><span class="koboSpan" id="kobo.1145.1">on your own</span></strong><span class="koboSpan" id="kobo.1146.1">. </span><span class="koboSpan" id="kobo.1146.2">However, you can simplify this task by</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.1147.1"> using the </span><strong class="bold"><span class="koboSpan" id="kobo.1148.1">built-in generic class</span></strong><span class="koboSpan" id="kobo.1149.1">, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">PriorityQueue</span></strong><span class="koboSpan" id="kobo.1151.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">System.Collections.Generic</span></strong><span class="koboSpan" id="kobo.1153.1"> namespace. </span><span class="koboSpan" id="kobo.1153.2">The mentioned class requires you to specify two types, namely for the stored data and for the priority. </span><span class="koboSpan" id="kobo.1153.3">The class contains some useful methods, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1156.1"> adds an element to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">priority queue</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1159.1"> removes an element from the beginning and </span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">returns it</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">Clear</span></strong><span class="koboSpan" id="kobo.1162.1"> removes all elements from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">priority queue</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">Peek</span></strong><span class="koboSpan" id="kobo.1165.1"> returns an element from the beginning of the queue without </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">removing it</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1167.1">You can also get</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.1168.1"> the number of elements in the queue using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">Count</span></strong><span class="koboSpan" id="kobo.1170.1"> property. </span><span class="koboSpan" id="kobo.1170.2">The class contains a set of other methods as well - for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">TryDequeue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1172.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">TryPeek</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1175.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1176.1">You can find content regarding a priority queue </span><span class="No-Break"><span class="koboSpan" id="kobo.1177.1">at </span></span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.priorityqueue-2"><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.priorityqueue-2</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1180.1">To make your horizons </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.1181.1">even broader, you will learn how to use </span><strong class="bold"><span class="koboSpan" id="kobo.1182.1">another implementation</span></strong><span class="koboSpan" id="kobo.1183.1"> of the priority queue, namely using one of the</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.1184.1"> available </span><strong class="bold"><span class="koboSpan" id="kobo.1185.1">NuGet packages</span></strong><span class="koboSpan" id="kobo.1186.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">OptimizedPriorityQueue</span></strong><span class="koboSpan" id="kobo.1188.1">. </span><span class="koboSpan" id="kobo.1188.2">More information about this package is available </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">at </span></span><a href="https://www.nuget.org/packages/OptimizedPriorityQueue"><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">https://www.nuget.org/packages/OptimizedPriorityQueue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1192.1">How to install a NuGet package?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1193.1">Do you know </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.1194.1">how you can add a NuGet package to your project? </span><span class="koboSpan" id="kobo.1194.2">If not, select </span><strong class="bold"><span class="koboSpan" id="kobo.1195.1">Manage NuGet Packages</span></strong><span class="koboSpan" id="kobo.1196.1"> from the context menu of the project node in the </span><strong class="bold"><span class="koboSpan" id="kobo.1197.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.1198.1"> window. </span><span class="koboSpan" id="kobo.1198.2">Then, choose the </span><strong class="bold"><span class="koboSpan" id="kobo.1199.1">Browse</span></strong><span class="koboSpan" id="kobo.1200.1"> tab in the opened window and type the name of the package in the </span><strong class="bold"><span class="koboSpan" id="kobo.1201.1">Search</span></strong><span class="koboSpan" id="kobo.1202.1"> box. </span><span class="koboSpan" id="kobo.1202.2">Click on the name of the package and press </span><strong class="bold"><span class="koboSpan" id="kobo.1203.1">Install</span></strong><span class="koboSpan" id="kobo.1204.1">. </span><span class="koboSpan" id="kobo.1204.2">Confirm this operation and wait until the installation </span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">is ready.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.1206.1">While the package is being installed, do you know that you can also be an author of a NuGet package that can be later used by developers from various regions of the world? </span><span class="koboSpan" id="kobo.1206.2">If you create something great, please let me know! </span><span class="koboSpan" id="kobo.1206.3">In the meantime, please keep in mind that you always should comply with the license terms of particular packages, and you should not fully trust all available packages, especially those with a smaller number of downloads. </span><span class="koboSpan" id="kobo.1206.4">However, NuGet packages are a nice feature that can significantly simplify and speed up </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">your work.</span></span></p>
<p><span class="koboSpan" id="kobo.1208.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">OptimizedPriorityQueue</span></strong><span class="koboSpan" id="kobo.1210.1"> library simplifies</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.1211.1"> the application of a priority queue. </span><span class="koboSpan" id="kobo.1211.2">Within it, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">SimplePriorityQueue</span></strong><span class="koboSpan" id="kobo.1213.1"> generic class is available, which contains some useful methods, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1216.1"> adds an element to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">priority queue</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1219.1"> removes an element from the beginning of the queue and </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">returns it</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">GetPriority</span></strong><span class="koboSpan" id="kobo.1222.1"> returns the priority of </span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">the element</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">UpdatePriority</span></strong><span class="koboSpan" id="kobo.1225.1"> updates the priority of </span><span class="No-Break"><span class="koboSpan" id="kobo.1226.1">the element</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">Contains</span></strong><span class="koboSpan" id="kobo.1228.1"> checks whether the element exists in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1229.1">priority queue</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">Clear</span></strong><span class="koboSpan" id="kobo.1231.1"> removes all elements from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1232.1">priority queue</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1233.1">You can get the </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.1234.1">number of elements currently available in the priority queue</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.1235.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">Count</span></strong><span class="koboSpan" id="kobo.1237.1"> property. </span><span class="koboSpan" id="kobo.1237.2">If you want to get an element from the beginning of the priority queue without removing it, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">First</span></strong><span class="koboSpan" id="kobo.1239.1"> property. </span><span class="koboSpan" id="kobo.1239.2">Moreover, the class contains a set of other methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">TryDequeue</span></strong><span class="koboSpan" id="kobo.1241.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">TryRemove</span></strong><span class="koboSpan" id="kobo.1243.1">. </span><span class="koboSpan" id="kobo.1243.2">As you can see, the names of some members of the class are even the same, as in the case of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">PriorityQueue</span></strong><span class="koboSpan" id="kobo.1245.1"> built-in class. </span><span class="koboSpan" id="kobo.1245.2">Thus, you can easily change one implementation to another and check the impact of the implementation on the results or the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">your solution.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1247.1">What about the performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1248.1">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1250.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1252.1"> methods are </span><em class="italic"><span class="koboSpan" id="kobo.1253.1">O(log </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1254.1">n)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1"> operations.</span></span></p>
<p><span class="koboSpan" id="kobo.1256.1">If you want to see in action the priority queue depicted in the preceding diagram, you can use the following part of </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1258.1">
using Priority_Queue;
</span><strong class="bold"><span class="koboSpan" id="kobo.1259.1">SimplePriorityQueue&lt;string&gt; queue = new();</span></strong><span class="koboSpan" id="kobo.1260.1">
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1261.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1262.1">("Marcin", </span><strong class="bold"><span class="koboSpan" id="kobo.1263.1">1</span></strong><span class="koboSpan" id="kobo.1264.1">);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1265.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1266.1">("Lily", </span><strong class="bold"><span class="koboSpan" id="kobo.1267.1">1</span></strong><span class="koboSpan" id="kobo.1268.1">);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1269.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1270.1">("Mary", </span><strong class="bold"><span class="koboSpan" id="kobo.1271.1">2</span></strong><span class="koboSpan" id="kobo.1272.1">);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1273.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1274.1">("John", </span><strong class="bold"><span class="koboSpan" id="kobo.1275.1">0</span></strong><span class="koboSpan" id="kobo.1276.1">);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1277.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1278.1">("Emily", </span><strong class="bold"><span class="koboSpan" id="kobo.1279.1">1</span></strong><span class="koboSpan" id="kobo.1280.1">);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1281.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1282.1">("Sarah", </span><strong class="bold"><span class="koboSpan" id="kobo.1283.1">2</span></strong><span class="koboSpan" id="kobo.1284.1">);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1285.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1286.1">("Luke", </span><strong class="bold"><span class="koboSpan" id="kobo.1287.1">1</span></strong><span class="koboSpan" id="kobo.1288.1">);
while (queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1289.1">Count</span></strong><span class="koboSpan" id="kobo.1290.1"> &gt; 0)
{
    Console.WriteLine(queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1291.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1292.1">());
}</span></pre> <p><span class="koboSpan" id="kobo.1293.1">At the beginning, you </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.1294.1">create a new priority queue containing only </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">string</span></strong><span class="koboSpan" id="kobo.1296.1"> values. </span><span class="koboSpan" id="kobo.1296.2">Then, you </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.1297.1">add all elements in the correct order, together with specifying their priority, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1299.1"> method. </span><span class="koboSpan" id="kobo.1299.2">At the end, you use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">while</span></strong><span class="koboSpan" id="kobo.1301.1"> loop to dequeue all the elements, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1303.1"> method. </span><span class="koboSpan" id="kobo.1303.2">Pretty simple and easy to understand, </span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1">isn’t it?</span></span></p>
<p><span class="koboSpan" id="kobo.1305.1">When you run the code, you will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">following result:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1307.1">
John
Marcin
Lily
Emily
Luke
Mary
Sarah</span></pre> <p><span class="koboSpan" id="kobo.1308.1">After this short introduction to the topic of priority queues, let’s proceed to the example of a c</span><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.1309.1">a</span><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.1310.1">ll center with priority support, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">described next.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.1312.1">Example – call center with priority support</span></h2>
<p><span class="koboSpan" id="kobo.1313.1">As an</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.1314.1"> example of a priority queue, let’s present a simple approach to the call center solution, where there are many clients (with different identifiers), and only one consultant who answers waiting calls, first from clients with the priority support plan, and then from clients with the standard </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">support plan.</span></span></p>
<p><span class="koboSpan" id="kobo.1316.1">This scenario is presented in the following diagram. </span><span class="koboSpan" id="kobo.1316.2">Calls with standard priority are marked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">–</span></strong><span class="koboSpan" id="kobo.1318.1">, while calls with priority support are indicated by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">∆</span></strong><span class="koboSpan" id="kobo.1320.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.1322.1"><img alt="Figure 5.13 – ﻿Illustration of the call center with priority support example" src="image/B18069_05_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1323.1">Figure 5.13 – Illustration of the call center with priority support example</span></p>
<p><span class="koboSpan" id="kobo.1324.1">The </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.1325.1">priority queue contains only three elements, which will be served in the following order: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">#5678</span></strong><span class="koboSpan" id="kobo.1327.1"> (the priority support), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1328.1">#1234</span></strong><span class="koboSpan" id="kobo.1329.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">#1468</span></strong><span class="koboSpan" id="kobo.1331.1">. </span><span class="koboSpan" id="kobo.1331.2">However, the call from the client with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">#9641</span></strong><span class="koboSpan" id="kobo.1333.1"> identifier causes the order to change to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">#5678</span></strong><span class="koboSpan" id="kobo.1335.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">#9641</span></strong><span class="koboSpan" id="kobo.1337.1"> (due to priority support), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">#1234</span></strong><span class="koboSpan" id="kobo.1339.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1340.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">#1468</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1342.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1343.1">It is high time to write some code! </span><span class="koboSpan" id="kobo.1343.2">Let’s proceed to the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">IncomingCall</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1345.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1346.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.1347.1">IncomingCall</span></strong><span class="koboSpan" id="kobo.1348.1">
{
    public int Id { get; set; }
    public int ClientId { get; set; }
    public DateTime CallTime { get; set; }
    public DateTime? </span><span class="koboSpan" id="kobo.1348.2">AnswerTime { get; set; }
    public DateTime? </span><span class="koboSpan" id="kobo.1348.3">EndTime { get; set; }
    public string? </span><span class="koboSpan" id="kobo.1348.4">Consultant { get; set; }
    </span><strong class="bold"><span class="koboSpan" id="kobo.1349.1">public bool IsPriority { get; set; }</span></strong><span class="koboSpan" id="kobo.1350.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1351.1">Here, there is only one change in comparison to the previously presented scenario of the simple call center application - namely, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">IsPriority</span></strong><span class="koboSpan" id="kobo.1353.1"> property is added. </span><span class="koboSpan" id="kobo.1353.2">It indicates whether the current call has priority (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">true</span></strong><span class="koboSpan" id="kobo.1355.1">) or standard </span><span class="No-Break"><span class="koboSpan" id="kobo.1356.1">support (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1358.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1359.1">Some </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.1360.1">modifications are also necessary for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">CallCenter</span></strong><span class="koboSpan" id="kobo.1362.1"> class, where a type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">Calls</span></strong><span class="koboSpan" id="kobo.1364.1"> property is changed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">SimplePriorityQueue&lt;IncomingCall&gt;</span></strong><span class="koboSpan" id="kobo.1366.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1367.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1368.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.1369.1">CallCenter</span></strong><span class="koboSpan" id="kobo.1370.1">
{
    private int _counter = 0;
    </span><strong class="bold"><span class="koboSpan" id="kobo.1371.1">public SimplePriorityQueue&lt;IncomingCall&gt; Calls</span></strong><span class="koboSpan" id="kobo.1372.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1373.1">{ get; private set; }</span></strong><span class="koboSpan" id="kobo.1374.1">
    public CallCenter() =&gt; Calls =
        </span><strong class="bold"><span class="koboSpan" id="kobo.1375.1">new SimplePriorityQueue&lt;IncomingCall&gt;();</span></strong><span class="koboSpan" id="kobo.1376.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1377.1">The following changes are necessary for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1378.1">Call</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1379.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1380.1">
public IncomingCall </span><strong class="bold"><span class="koboSpan" id="kobo.1381.1">Call</span></strong><span class="koboSpan" id="kobo.1382.1">(int clientId, </span><strong class="bold"><span class="koboSpan" id="kobo.1383.1">bool isPriority</span></strong><span class="koboSpan" id="kobo.1384.1">)
{
    IncomingCall call = new()
    {
        Id = ++_counter,
        ClientId = clientId,
        CallTime = DateTime.Now,
        </span><strong class="bold"><span class="koboSpan" id="kobo.1385.1">IsPriority = isPriority</span></strong><span class="koboSpan" id="kobo.1386.1">
    };
    </span><strong class="bold"><span class="koboSpan" id="kobo.1387.1">Calls.Enqueue(call, isPriority ? </span><span class="koboSpan" id="kobo.1387.2">0 : 1);</span></strong><span class="koboSpan" id="kobo.1388.1">
    return call;
}</span></pre> <p><span class="koboSpan" id="kobo.1389.1">Here, a</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.1390.1"> value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1391.1">IsPriority</span></strong><span class="koboSpan" id="kobo.1392.1"> property is set using the parameter. </span><span class="koboSpan" id="kobo.1392.2">Moreover, while calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1394.1"> method, two parameters are used, not only the value of the element (an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">IncomingCall</span></strong><span class="koboSpan" id="kobo.1396.1"> class), but also an integer value representing the priority, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">0</span></strong><span class="koboSpan" id="kobo.1398.1"> in the case of priority support, or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1400.1"> otherwise.</span></span></p>
<p><span class="koboSpan" id="kobo.1401.1">No more changes are necessary in the methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">CallCenter</span></strong><span class="koboSpan" id="kobo.1403.1"> class, namely in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">Answer</span></strong><span class="koboSpan" id="kobo.1405.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">End</span></strong><span class="koboSpan" id="kobo.1407.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">AreWaitingCalls</span></strong><span class="koboSpan" id="kobo.1409.1">, which are shown next for </span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">your convenience:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1411.1">
public IncomingCall? </span><strong class="bold"><span class="koboSpan" id="kobo.1412.1">Answer</span></strong><span class="koboSpan" id="kobo.1413.1">(string consultant)
{
    if (!AreWaitingCalls()) { return null; }
    IncomingCall call = Calls.Dequeue();
    call.Consultant = consultant;
    call.AnswerTime = DateTime.Now;
    return call;
}
public void </span><strong class="bold"><span class="koboSpan" id="kobo.1414.1">End</span></strong><span class="koboSpan" id="kobo.1415.1">(IncomingCall call) =&gt;
    call.EndTime = DateTime.Now;
public bool </span><strong class="bold"><span class="koboSpan" id="kobo.1416.1">AreWaitingCalls</span></strong><span class="koboSpan" id="kobo.1417.1">() =&gt; Calls.Count &gt; 0;</span></pre> <p><span class="koboSpan" id="kobo.1418.1">Finally, let’s take a look at the code located in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1420.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1421.1">
Random random = new();
</span><strong class="bold"><span class="koboSpan" id="kobo.1422.1">CallCenter center = new();</span></strong><span class="koboSpan" id="kobo.1423.1">
center.</span><strong class="bold"><span class="koboSpan" id="kobo.1424.1">Call</span></strong><span class="koboSpan" id="kobo.1425.1">(1234, </span><strong class="bold"><span class="koboSpan" id="kobo.1426.1">false</span></strong><span class="koboSpan" id="kobo.1427.1">);
center.</span><strong class="bold"><span class="koboSpan" id="kobo.1428.1">Call</span></strong><span class="koboSpan" id="kobo.1429.1">(5678, </span><strong class="bold"><span class="koboSpan" id="kobo.1430.1">true</span></strong><span class="koboSpan" id="kobo.1431.1">);
center.</span><strong class="bold"><span class="koboSpan" id="kobo.1432.1">Call</span></strong><span class="koboSpan" id="kobo.1433.1">(1468, </span><strong class="bold"><span class="koboSpan" id="kobo.1434.1">false</span></strong><span class="koboSpan" id="kobo.1435.1">);
center.</span><strong class="bold"><span class="koboSpan" id="kobo.1436.1">Call</span></strong><span class="koboSpan" id="kobo.1437.1">(9641, </span><strong class="bold"><span class="koboSpan" id="kobo.1438.1">true</span></strong><span class="koboSpan" id="kobo.1439.1">);
while (center.</span><strong class="bold"><span class="koboSpan" id="kobo.1440.1">AreWaitingCalls</span></strong><span class="koboSpan" id="kobo.1441.1">())
{
    IncomingCall call = center.</span><strong class="bold"><span class="koboSpan" id="kobo.1442.1">Answer</span></strong><span class="koboSpan" id="kobo.1443.1">("Marcin")!;
    Log($"Call #{call.Id} from client #{call.ClientId} is
        answered by {call.Consultant}.", </span><strong class="bold"><span class="koboSpan" id="kobo.1444.1">call.IsPriority</span></strong><span class="koboSpan" id="kobo.1445.1">);
    await Task.Delay(random.Next(1000, 10000));
    center.</span><strong class="bold"><span class="koboSpan" id="kobo.1446.1">End</span></strong><span class="koboSpan" id="kobo.1447.1">(call);
    Log($"Call #{call.Id} from client #{call.ClientId} is
        ended by {call.Consultant}.", </span><strong class="bold"><span class="koboSpan" id="kobo.1448.1">call.IsPriority</span></strong><span class="koboSpan" id="kobo.1449.1">);
}
void </span><strong class="bold"><span class="koboSpan" id="kobo.1450.1">Log</span></strong><span class="koboSpan" id="kobo.1451.1">(string text, bool isPriority)
{
    Console.ForegroundColor = isPriority
        ? </span><span class="koboSpan" id="kobo.1451.2">ConsoleColor.Red : ConsoleColor.Gray;
    Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] {text}");
    Console.ResetColor();
}</span></pre> <p><span class="koboSpan" id="kobo.1452.1">You may be surprised to learn that only small changes are necessary in this part of the code. </span><span class="koboSpan" id="kobo.1452.2">The reason for this is that the logic regarding a used data structure is hidden in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">CallCenter</span></strong><span class="koboSpan" id="kobo.1454.1"> class. </span><span class="koboSpan" id="kobo.1454.2">Within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1456.1"> file, you call methods and use properties exposed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">CallCenter</span></strong><span class="koboSpan" id="kobo.1458.1"> class. </span><span class="koboSpan" id="kobo.1458.2">You just need to modify how you add calls to the queue (together with priorities), as well as adjust logs presented when a call is answered by the</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.1459.1"> consultant, to choose a proper color based on the call’s priority. </span><span class="No-Break"><span class="koboSpan" id="kobo.1460.1">That’s all!</span></span></p>
<p><span class="koboSpan" id="kobo.1461.1">When you run the application, you will receive a result similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.1462.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.1463.1"><img alt="Figure 5.14 – ﻿Screenshot of the call center with priority support example" src="image/B18069_05_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1464.1">Figure 5.14 – Screenshot of the call center with priority support example</span></p>
<p><span class="koboSpan" id="kobo.1465.1">As you can see, the calls are served in the correct order. </span><span class="koboSpan" id="kobo.1465.2">This means that the calls from clients with priority support are served earlier than calls from clients with the standard support plan, even though such calls need to wait much longer to </span><span class="No-Break"><span class="koboSpan" id="kobo.1466.1">be answered.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.1467.1">Circular queues</span></h1>
<p><span class="koboSpan" id="kobo.1468.1">At the end </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.1469.1">of this chapter, let’s take a look at another data structure, namely a </span><strong class="bold"><span class="koboSpan" id="kobo.1470.1">circular queue</span></strong><span class="koboSpan" id="kobo.1471.1">, also</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.1472.1"> called a </span><strong class="bold"><span class="koboSpan" id="kobo.1473.1">ring buffer</span></strong><span class="koboSpan" id="kobo.1474.1">. </span><span class="koboSpan" id="kobo.1474.2">In this case, </span><strong class="bold"><span class="koboSpan" id="kobo.1475.1">a queue forms a circle</span></strong><span class="koboSpan" id="kobo.1476.1">, internally uses </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.1477.1">an array, and the maximum number of elements that can be placed inside the queue is limited. </span><span class="koboSpan" id="kobo.1477.2">You need to specify two variables that indicate indices of the </span><strong class="bold"><span class="koboSpan" id="kobo.1478.1">front</span></strong><span class="koboSpan" id="kobo.1479.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1480.1">rear</span></strong><span class="koboSpan" id="kobo.1481.1"> elements. </span><strong class="bold"><span class="koboSpan" id="kobo.1482.1">The front one points to the element that will be dequeued first. </span><span class="koboSpan" id="kobo.1482.2">The rear one points to the element that is the last in </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1483.1">the queue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1485.1">Imagine a circular queue</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1486.1">If you want to better imagine a circular queue, think back to your young years when you persuaded your parents to take you on a roller coaster. </span><span class="koboSpan" id="kobo.1486.2">It consisted of 10 carriages, each with room for 2 people, so only 20 people could take part in 1 roller coaster ride. </span><span class="koboSpan" id="kobo.1486.3">As this was a unique attraction, such a ride took place only once an hour. </span><span class="koboSpan" id="kobo.1486.4">This meant that only 20 people were allowed to enter a queue for the roller coaster and no one else. </span><span class="koboSpan" id="kobo.1486.5">As the departure date approached, people were admitted to it in the order in which they were admitted to the queue. </span><span class="koboSpan" id="kobo.1486.6">And a circular queue works similarly! </span><span class="koboSpan" id="kobo.1486.7">It has some specific capacity, and nothing else can be enqueued to it. </span><span class="koboSpan" id="kobo.1486.8">However, when you dequeue elements, new ones can be added in place of the previous ones. </span><span class="koboSpan" id="kobo.1486.9">Well, it means that after an hour, you can fill a queue for the roller coaster with </span><span class="No-Break"><span class="koboSpan" id="kobo.1487.1">new people!</span></span></p>
<p><span class="koboSpan" id="kobo.1488.1">The </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.1489.1">mentioned data structure</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.1490.1"> is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1491.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.1492.1"><img alt="Figure 5.15 – ﻿Illustration of a circular queue" src="image/B18069_05_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1493.1">Figure 5.15 – Illustration of a circular queue</span></p>
<p><span class="koboSpan" id="kobo.1494.1">At the</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.1495.1"> beginning, the</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.1496.1"> circular queue is empty, so both </span><strong class="bold"><span class="koboSpan" id="kobo.1497.1">front</span></strong><span class="koboSpan" id="kobo.1498.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1499.1">rear</span></strong><span class="koboSpan" id="kobo.1500.1"> indices are equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">-1</span></strong><span class="koboSpan" id="kobo.1502.1">. </span><span class="koboSpan" id="kobo.1502.2">Then, you add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">2</span></strong><span class="koboSpan" id="kobo.1504.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">-4</span></strong><span class="koboSpan" id="kobo.1506.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">1</span></strong><span class="koboSpan" id="kobo.1508.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1509.1">8</span></strong><span class="koboSpan" id="kobo.1510.1"> elements, and this state is shown in the first step in the preceding diagram. </span><span class="koboSpan" id="kobo.1510.2">Here, the front index is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">0</span></strong><span class="koboSpan" id="kobo.1512.1">, and the rear one </span><span class="No-Break"><span class="koboSpan" id="kobo.1513.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1515.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1516.1">In the next step, you perform an </span><strong class="p-bold-italics"><span class="koboSpan" id="kobo.1517.1">enqueue</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1518.1"> operation that adds the item at the end of the queue</span></strong><span class="koboSpan" id="kobo.1519.1">, as in the case of a regular queue. </span><span class="koboSpan" id="kobo.1519.2">Thus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1520.1">5</span></strong><span class="koboSpan" id="kobo.1521.1"> is located at index </span><strong class="source-inline"><span class="koboSpan" id="kobo.1522.1">4</span></strong><span class="koboSpan" id="kobo.1523.1">, as shown in the third step in the preceding diagram. </span><span class="koboSpan" id="kobo.1523.2">Of course, the rear index is updated to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1524.1">4</span></strong><span class="koboSpan" id="kobo.1525.1"> while the front index remains the same, </span><span class="No-Break"><span class="koboSpan" id="kobo.1526.1">namely </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1528.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1529.1">The following</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.1530.1"> step shows a </span><strong class="p-bold-italics"><span class="koboSpan" id="kobo.1531.1">dequeue</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1532.1"> operation that removes an item from the beginning of the queue</span></strong><span class="koboSpan" id="kobo.1533.1">, so its aim is the same as in the case of a regular queue. </span><span class="koboSpan" id="kobo.1533.2">In the example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1534.1">2</span></strong><span class="koboSpan" id="kobo.1535.1"> is returned, and the front index is changed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">1</span></strong><span class="koboSpan" id="kobo.1537.1">. </span><span class="koboSpan" id="kobo.1537.2">It means that </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.1538.1">currently, the circular queue stores </span><strong class="source-inline"><span class="koboSpan" id="kobo.1539.1">4</span></strong><span class="koboSpan" id="kobo.1540.1"> elements in the part of the array between </span><strong class="source-inline"><span class="koboSpan" id="kobo.1541.1">1</span></strong><span class="koboSpan" id="kobo.1542.1"> (the front index) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1543.1">4</span></strong><span class="koboSpan" id="kobo.1544.1"> (the </span><span class="No-Break"><span class="koboSpan" id="kobo.1545.1">rear index).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1546.1">What about the performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1547.1">The </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.1548.1">performance results are great in this case! </span><span class="koboSpan" id="kobo.1548.2">Both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1549.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1550.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1551.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1552.1"> methods are </span><em class="italic"><span class="koboSpan" id="kobo.1553.1">O(1)</span></em><span class="koboSpan" id="kobo.1554.1"> operations, as you don’t need to iterate through </span><span class="No-Break"><span class="koboSpan" id="kobo.1555.1">an array.</span></span></p>
<p><span class="koboSpan" id="kobo.1556.1">You can perform many more </span><em class="italic"><span class="koboSpan" id="kobo.1557.1">enqueue</span></em><span class="koboSpan" id="kobo.1558.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1559.1">dequeue</span></em><span class="koboSpan" id="kobo.1560.1"> operations to see how the content of the queue “rotates” within a circular queue. </span><span class="koboSpan" id="kobo.1560.2">To do so, you need to implement this data structure. </span><span class="koboSpan" id="kobo.1560.3">Let’s write some code, starting with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1561.1">CircularQueue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1563.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.1564.1">CircularQueue</span></strong><span class="koboSpan" id="kobo.1565.1">&lt;T&gt;(int size)
    where T : struct
{
    private readonly T[] </span><strong class="bold"><span class="koboSpan" id="kobo.1566.1">_items</span></strong><span class="koboSpan" id="kobo.1567.1"> = new T[size];
    private int </span><strong class="bold"><span class="koboSpan" id="kobo.1568.1">_front</span></strong><span class="koboSpan" id="kobo.1569.1"> = -1;
    private int </span><strong class="bold"><span class="koboSpan" id="kobo.1570.1">_rear</span></strong><span class="koboSpan" id="kobo.1571.1"> = -1;
    private int </span><strong class="bold"><span class="koboSpan" id="kobo.1572.1">_count</span></strong><span class="koboSpan" id="kobo.1573.1"> = 0;
    public int </span><strong class="bold"><span class="koboSpan" id="kobo.1574.1">Count</span></strong><span class="koboSpan" id="kobo.1575.1"> { get { return _count; } }
}</span></pre> <p><span class="koboSpan" id="kobo.1576.1">It is a generic class that uses the primary constructor taking the maximum number of elements in the queue as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1577.1">size</span></strong><span class="koboSpan" id="kobo.1578.1"> parameter. </span><span class="koboSpan" id="kobo.1578.2">You can see four </span><span class="No-Break"><span class="koboSpan" id="kobo.1579.1">private fields:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1580.1">An array with the stored </span><span class="No-Break"><span class="koboSpan" id="kobo.1581.1">items (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">_items</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1583.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.1584.1">An index of the front and rear elements in the queue (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">_front</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1586.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1587.1">_rear</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1588.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.1589.1">The current number of elements located in the circular </span><span class="No-Break"><span class="koboSpan" id="kobo.1590.1">queue (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">_count</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1592.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1593.1">The public</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.1594.1"> read-only </span><strong class="source-inline"><span class="koboSpan" id="kobo.1595.1">Count</span></strong><span class="koboSpan" id="kobo.1596.1"> property is added as well, which</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.1597.1"> returns the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1598.1">_count</span></strong><span class="koboSpan" id="kobo.1599.1"> field. </span><span class="koboSpan" id="kobo.1599.2">If everything is clear for you, let’s take a look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">Enqueue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1601.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1602.1">
public bool </span><strong class="bold"><span class="koboSpan" id="kobo.1603.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1604.1">(T item)
{
    if (_count == _items.Length) { return false; }
    if (_front &lt; 0) { _front = _rear = 0; }
    else { _rear = ++_rear % _items.Length; }
    _items[_rear] = item;
    _count++;
    return true;
}</span></pre> <p><span class="koboSpan" id="kobo.1605.1">In the beginning, you need to check whether you have any space within the circular queue, so you compare the current number of elements in the queue (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1606.1">_count</span></strong><span class="koboSpan" id="kobo.1607.1">) with the length of the array storing such data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">_items</span></strong><span class="koboSpan" id="kobo.1609.1">). </span><span class="koboSpan" id="kobo.1609.2">If these values are equal, you return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">false</span></strong><span class="koboSpan" id="kobo.1611.1"> because there is no space, so you cannot enqueue </span><span class="No-Break"><span class="koboSpan" id="kobo.1612.1">any element.</span></span></p>
<p><span class="koboSpan" id="kobo.1613.1">The next line checks whether the circular queue is empty, which means that the front index is smaller than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">0</span></strong><span class="koboSpan" id="kobo.1615.1">. </span><span class="koboSpan" id="kobo.1615.2">If so, both front and rear indices are set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1616.1">0</span></strong><span class="koboSpan" id="kobo.1617.1">. </span><span class="koboSpan" id="kobo.1617.2">It indicates that there is only one element in the circular queue, and it is pointed to by both </span><span class="No-Break"><span class="koboSpan" id="kobo.1618.1">these indices.</span></span></p>
<p><span class="koboSpan" id="kobo.1619.1">If there is already something in the queue, you increment a value of the rear index. </span><span class="koboSpan" id="kobo.1619.2">If it is equal to the number of elements in the array, you assign </span><strong class="source-inline"><span class="koboSpan" id="kobo.1620.1">0</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1621.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.1622.1">In the last three lines, you add the new item to the place indicated by the rear index (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1623.1">_rear</span></strong><span class="koboSpan" id="kobo.1624.1">), increment the counter storing the number of elements currently located in the queue (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">_count</span></strong><span class="koboSpan" id="kobo.1626.1">), as well as return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">true</span></strong><span class="koboSpan" id="kobo.1628.1"> indicating that the enqueue operation </span><span class="No-Break"><span class="koboSpan" id="kobo.1629.1">was successful.</span></span></p>
<p><span class="koboSpan" id="kobo.1630.1">Let’s now</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.1631.1"> move to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1633.1"> method, the code of which is </span><span class="No-Break"><span class="koboSpan" id="kobo.1634.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1635.1">
public T? </span><strong class="bold"><span class="koboSpan" id="kobo.1636.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1637.1">()
{
    if (_count == 0) { return null; }
    T result = _items[_front];
    if (_front == _rear) { _front = _rear = -1; }
    else { _front = ++_front % _items.Length; }
    _count--;
    return result;
}</span></pre> <p><span class="koboSpan" id="kobo.1638.1">Here, you check whether the circular queue is empty. </span><span class="koboSpan" id="kobo.1638.2">If so, you return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1639.1">null</span></strong><span class="koboSpan" id="kobo.1640.1"> value. </span><span class="koboSpan" id="kobo.1640.2">Otherwise, you save as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1641.1">result</span></strong><span class="koboSpan" id="kobo.1642.1"> a value indicated by the front index. </span><span class="koboSpan" id="kobo.1642.2">Such a value will be returned at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.1643.1">this method.</span></span></p>
<p><span class="koboSpan" id="kobo.1644.1">In the following lines, you check whether the front and rear indices are equal. </span><span class="koboSpan" id="kobo.1644.2">It means that there is only one element in the queue. </span><span class="koboSpan" id="kobo.1644.3">If so, you set both these indices to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1645.1">-1</span></strong><span class="koboSpan" id="kobo.1646.1">, which indicates that the circular queue is empty. </span><span class="koboSpan" id="kobo.1646.2">Otherwise, you increment the front index. </span><span class="koboSpan" id="kobo.1646.3">If it is equal to the number of elements in the array, you assign </span><strong class="source-inline"><span class="koboSpan" id="kobo.1647.1">0</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1648.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.1649.1">In the last two lines, you just decrement the number of elements in the queue, as well as return the previously saved </span><span class="No-Break"><span class="koboSpan" id="kobo.1650.1">value (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1651.1">result</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1652.1">)</span></span><span class="No-Break"><span class="koboSpan" id="kobo.1653.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1654.1">Another method is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1655.1">Peek</span></strong><span class="koboSpan" id="kobo.1656.1"> and is presented </span><span class="No-Break"><span class="koboSpan" id="kobo.1657.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1658.1">
public T? </span><strong class="bold"><span class="koboSpan" id="kobo.1659.1">Peek</span></strong><span class="koboSpan" id="kobo.1660.1">()
{
    if (_count == 0) { return null; }
    return _items[_front];
}</span></pre> <p><span class="koboSpan" id="kobo.1661.1">This </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.1662.1">method just returns the first item in the queue without</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.1663.1"> removing it from the queue. </span><span class="koboSpan" id="kobo.1663.2">Of course, it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1664.1">null</span></strong><span class="koboSpan" id="kobo.1665.1"> if the queue </span><span class="No-Break"><span class="koboSpan" id="kobo.1666.1">is empty.</span></span></p>
<p><span class="koboSpan" id="kobo.1667.1">As you can see, the implementation of a circular queue is not difficult and requires a small number of lines of code. </span><span class="koboSpan" id="kobo.1667.2">So, let’s see it in action with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1668.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1669.1">CircularQueue&lt;int&gt; queue = new(8);</span></strong><span class="koboSpan" id="kobo.1670.1">
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1671.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1672.1">(2);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1673.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1674.1">(-4);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1675.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1676.1">(1);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1677.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1678.1">(8);
queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1679.1">Enqueue</span></strong><span class="koboSpan" id="kobo.1680.1">(5);
int item = queue.</span><strong class="bold"><span class="koboSpan" id="kobo.1681.1">Dequeue</span></strong><span class="koboSpan" id="kobo.1682.1">();
Console.WriteLine(item);</span></pre> <p><span class="koboSpan" id="kobo.1683.1">The preceding lines perform the operations shown in the diagram presenting a circular queue (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1684.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1685.1">.15</span></em><span class="koboSpan" id="kobo.1686.1">). </span><span class="koboSpan" id="kobo.1686.2">You create a new circular queue with places for eight elements of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1687.1">int</span></strong><span class="koboSpan" id="kobo.1688.1"> type. </span><span class="koboSpan" id="kobo.1688.2">Then, you add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1689.1">2</span></strong><span class="koboSpan" id="kobo.1690.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1691.1">-4</span></strong><span class="koboSpan" id="kobo.1692.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1693.1">1</span></strong><span class="koboSpan" id="kobo.1694.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1695.1">8</span></strong><span class="koboSpan" id="kobo.1696.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1697.1">5</span></strong><span class="koboSpan" id="kobo.1698.1"> values and dequeue </span><span class="No-Break"><span class="koboSpan" id="kobo.1699.1">one element.</span></span></p>
<p><span class="koboSpan" id="kobo.1700.1">After the introduction to the topic of circular queues, it is high time to take a look at a </span><span class="No-Break"><span class="koboSpan" id="kobo.1701.1">real-world example.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.1702.1">Example – gravity roller coaster</span></h2>
<p><span class="koboSpan" id="kobo.1703.1">Let’s </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.1704.1">simulate the behavior of a gravity roller coaster located on a mountainside. </span><span class="koboSpan" id="kobo.1704.2">There can be a maximum of 12 carts on this queue at the same time, which slide down the chute accelerated by gravity. </span><span class="koboSpan" id="kobo.1704.3">After the participant enters the cart, it accelerates automatically, and there are several turns on its path. </span><span class="koboSpan" id="kobo.1704.4">After reaching the foot of the mountain, the cart and the participant are pulled in using a simple pulley. </span><span class="koboSpan" id="kobo.1704.5">The participant gets off at the same place where they boarded the cart, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1705.1">shown next:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.1706.1"><img alt="Figure 5.16 – ﻿Illustration of a gravity roller coaster example" src="image/B18069_05_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1707.1">Figure 5.16 – Illustration of a gravity roller coaster example</span></p>
<p><span class="koboSpan" id="kobo.1708.1">You can</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.1709.1"> simulate this example using a circular queue with the maximum size set to 12, which means that a maximum of 12 people can currently be on this gravity roller coaster. </span><span class="koboSpan" id="kobo.1709.2">Another person will not be admitted until a seat becomes available. </span><span class="koboSpan" id="kobo.1709.3">Entering the cart means performing an </span><em class="italic"><span class="koboSpan" id="kobo.1710.1">enqueue</span></em><span class="koboSpan" id="kobo.1711.1"> operation, and leaving the cart means performing a </span><em class="italic"><span class="koboSpan" id="kobo.1712.1">dequeue</span></em><span class="koboSpan" id="kobo.1713.1"> operation. </span><span class="koboSpan" id="kobo.1713.2">It is also worth mentioning that it is not possible to change the order in which participants are served. </span><span class="koboSpan" id="kobo.1713.3">Whoever enters the queue first will be let out first, which is consistent with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1714.1">FIFO principle.</span></span></p>
<p><span class="koboSpan" id="kobo.1715.1">Let’s take a look at the code, which is located in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1716.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1717.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1718.1">
using </span><strong class="bold"><span class="koboSpan" id="kobo.1719.1">QueueItem</span></strong><span class="koboSpan" id="kobo.1720.1"> = (System.DateTime StartedAt,
    System.ConsoleColor Color);
const int rideSeconds = 10;
Random random = new();
CircularQueue&lt;QueueItem&gt; queue = new(12);
ConsoleColor color = ConsoleColor.Black;</span></pre> <p><span class="koboSpan" id="kobo.1721.1">Here, you specify a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1722.1">QueueItem</span></strong><span class="koboSpan" id="kobo.1723.1"> alias for the value tuple type consisting of cart entering time and the chosen color. </span><span class="koboSpan" id="kobo.1723.2">Then, the ride length is set to 10 seconds, as well as some additional variables being created, including the circular queue and the last </span><span class="No-Break"><span class="koboSpan" id="kobo.1724.1">used color.</span></span></p>
<p><span class="koboSpan" id="kobo.1725.1">The next</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.1726.1"> part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1727.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1728.1">
while (true)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1729.1">while (queue.Peek() != null)</span></strong><span class="koboSpan" id="kobo.1730.1">
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1731.1">QueueItem item = queue.Peek()!.Value;</span></strong><span class="koboSpan" id="kobo.1732.1">
        TimeSpan elapsed = DateTime.Now - item.StartedAt;
        if (elapsed.TotalSeconds &lt; rideSeconds) { break; }
        </span><strong class="bold"><span class="koboSpan" id="kobo.1733.1">queue.Dequeue();</span></strong><span class="koboSpan" id="kobo.1734.1">
        Log($"&gt; Exits\tTotal: {queue.Count}", item.Color);
    }
    bool isNew = random.Next(3) == 1;
    if (isNew)
    {
        color = color == ConsoleColor.White
            ? </span><span class="koboSpan" id="kobo.1734.2">ConsoleColor.DarkBlue
            : (ConsoleColor)(((int)color) + 1);
        if (</span><strong class="bold"><span class="koboSpan" id="kobo.1735.1">queue.Enqueue((DateTime.Now, color))</span></strong><span class="koboSpan" id="kobo.1736.1">)
        {
            Log($"&lt; Enters\tTotal: {queue.Count}", color);
        }
        else
        {
            Log($"! </span><span class="koboSpan" id="kobo.1736.2">Not allowed\tTotal: {queue.Count}",
                ConsoleColor.DarkGray);
        }
    }
    await Task.Delay(500);
}</span></pre> <p><span class="koboSpan" id="kobo.1737.1">It contains </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.1738.1">an infinite </span><strong class="source-inline"><span class="koboSpan" id="kobo.1739.1">while</span></strong><span class="koboSpan" id="kobo.1740.1"> loop. </span><span class="koboSpan" id="kobo.1740.2">Within it, you first check which items should be dequeued, which means that the ride time (that is, 10 seconds) elapsed for them. </span><span class="koboSpan" id="kobo.1740.3">If so, you also log the message. </span><span class="koboSpan" id="kobo.1740.4">Then, you draw a random number to decide whether a new item should be added to the circular queue in this iteration of an infinite </span><strong class="source-inline"><span class="koboSpan" id="kobo.1741.1">while</span></strong><span class="koboSpan" id="kobo.1742.1"> loop. </span><span class="koboSpan" id="kobo.1742.2">If so, you choose the next color from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1743.1">ConsoleColor</span></strong><span class="koboSpan" id="kobo.1744.1"> enumeration, try to enqueue a new item to the queue, as well as log the message. </span><span class="koboSpan" id="kobo.1744.2">At the end of the iteration, you wait </span><span class="No-Break"><span class="koboSpan" id="kobo.1745.1">500 milliseconds.</span></span></p>
<p><span class="koboSpan" id="kobo.1746.1">The code of the auxiliary </span><strong class="source-inline"><span class="koboSpan" id="kobo.1747.1">Log</span></strong><span class="koboSpan" id="kobo.1748.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1749.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1750.1">
void </span><strong class="bold"><span class="koboSpan" id="kobo.1751.1">Log</span></strong><span class="koboSpan" id="kobo.1752.1">(string text, ConsoleColor color)
{
    Console.ForegroundColor = color;
    Console.WriteLine($"{DateTime.Now:HH:mm:ss} {text}");
    Console.ResetColor();
}</span></pre> <p><span class="koboSpan" id="kobo.1753.1">When you run the code, you get the </span><span class="No-Break"><span class="koboSpan" id="kobo.1754.1">following result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.1755.1"><img alt="Figure 5.17 – ﻿Screenshot of the gravity roller coaster example" src="image/B18069_05_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1756.1">Figure 5.17 – Screenshot of the gravity roller coaster example</span></p>
<p><span class="koboSpan" id="kobo.1757.1">Congratulations – you </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.1758.1">now know how to use a few types of queues! </span><span class="koboSpan" id="kobo.1758.2">You took a look at a regular one, a priority queue, as well as a circul</span><a id="_idTextAnchor192"/><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.1759.1">ar one, together with examples. </span><span class="koboSpan" id="kobo.1759.2">So, it is high time to summarize </span><span class="No-Break"><span class="koboSpan" id="kobo.1760.1">the chapter.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.1761.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1762.1">In this chapter, you learned about two limited access data structures, namely stacks and queues, including regular, priority, and circular ones. </span><span class="koboSpan" id="kobo.1762.2">It is worth remembering that such data structures have strictly specified ways of accessing elements. </span><span class="koboSpan" id="kobo.1762.3">All of them also have various real-world applications. </span><span class="koboSpan" id="kobo.1762.4">Some of them were mentioned in </span><span class="No-Break"><span class="koboSpan" id="kobo.1763.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1764.1">First, you saw how a </span><strong class="bold"><span class="koboSpan" id="kobo.1765.1">stack</span></strong><span class="koboSpan" id="kobo.1766.1"> operates according to the LIFO principle. </span><span class="koboSpan" id="kobo.1766.2">In this case, you can add an element at the top of the stack (a </span><em class="italic"><span class="koboSpan" id="kobo.1767.1">push</span></em><span class="koboSpan" id="kobo.1768.1"> operation), and remove an element from the top (a </span><em class="italic"><span class="koboSpan" id="kobo.1769.1">pop</span></em><span class="koboSpan" id="kobo.1770.1"> operation). </span><span class="koboSpan" id="kobo.1770.2">The stack was shown in two examples, namely for reversing a word and for solving the </span><em class="italic"><span class="koboSpan" id="kobo.1771.1">Tower of Hanoi</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.1772.1">mathematical game.</span></span></p>
<p><span class="koboSpan" id="kobo.1773.1">In the following part of the chapter, you got to know a </span><strong class="bold"><span class="koboSpan" id="kobo.1774.1">queue</span></strong><span class="koboSpan" id="kobo.1775.1"> as a data structure, which operates according to the FIFO principle. </span><span class="koboSpan" id="kobo.1775.2">In this case, </span><em class="italic"><span class="koboSpan" id="kobo.1776.1">enqueue</span></em><span class="koboSpan" id="kobo.1777.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1778.1">dequeue</span></em><span class="koboSpan" id="kobo.1779.1"> operations were presented. </span><span class="koboSpan" id="kobo.1779.2">The queue was explained using two examples, both regarding the application simulating a call center. </span><span class="koboSpan" id="kobo.1779.3">You learned how to use a thread-safe variant of a queue-related class, which is available while developing applications in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1780.1">C# language.</span></span></p>
<p><span class="koboSpan" id="kobo.1781.1">The next data structure shown in this chapter is named a </span><strong class="bold"><span class="koboSpan" id="kobo.1782.1">priority queue</span></strong><span class="koboSpan" id="kobo.1783.1"> and is an extension of a queue that supports the priorities of particular elements. </span><span class="koboSpan" id="kobo.1783.2">In the end, you learned about a </span><strong class="bold"><span class="koboSpan" id="kobo.1784.1">circular queue</span></strong><span class="koboSpan" id="kobo.1785.1">, which expands the concept of a regular queue by forming a circle, where the first and rear elements are indicated </span><span class="No-Break"><span class="koboSpan" id="kobo.1786.1">by indices.</span></span></p>
<p><span class="koboSpan" id="kobo.1787.1">This is just the fifth chapter of this book, and you already learned a lot about various data structures and algorithms that are useful while developing applications in C#! </span><span class="koboSpan" id="kobo.1787.2">Are you interested in increasing your knowledge by learning about </span><strong class="bold"><span class="koboSpan" id="kobo.1788.1">dictionaries</span></strong><span class="koboSpan" id="kobo.1789.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1790.1">sets</span></strong><span class="koboSpan" id="kobo.1791.1">? </span><span class="koboSpan" id="kobo.1791.2">If so, let’s proceed to the next chapter and learn more </span><span class="No-Break"><span class="koboSpan" id="kobo.1792.1">about them!</span></span></p>
</div>
</body></html>