- en: '*Chapter 4*: Creating Animations with the Unity Animation System'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：使用Unity动画系统创建动画'
- en: Whether for 2D games or 3D games, if you want a game to be lively and interesting,
    good animation is essential. As a very popular game engine, Unity provides easy-to-use
    and powerful animation development tools. In this chapter, we will explore the
    animation system in Unity, sometimes referred to as **Mecanim**, to make Scenes
    and characters in your game not static, but dynamic. Then, we will demonstrate
    how to implement 3D and 2D animation in Unity with two examples. Finally, we'll
    cover how to improve the performance of the animation system in Unity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是2D游戏还是3D游戏，如果你想使游戏生动有趣，良好的动画是必不可少的。作为一个非常流行的游戏引擎，Unity提供了易于使用且功能强大的动画开发工具。在本章中，我们将探讨Unity中的动画系统，有时也称为**Mecanim**，以使你的游戏中的场景和角色不是静态的，而是动态的。然后，我们将通过两个示例演示如何在Unity中实现3D和2D动画。最后，我们将介绍如何提高Unity动画系统的性能。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下关键主题：
- en: Exploring the Unity animation system's concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Unity动画系统的概念
- en: Implementing 3D animation in Unity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中实现3D动画
- en: Implementing 2D animation in Unity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中实现2D动画
- en: Improving the performance of Unity's animation system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高Unity动画系统的性能
- en: By the end of this chapter, you will be able to create 3D and 2D animations
    in Unity, as well as knowing how to control animations through C# code and how
    to optimize animation performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建Unity中的3D和2D动画，以及了解如何通过C#代码控制动画以及如何优化动画性能。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before starting, I recommend you first download **Unity-Chan! Model** from
    Unity Asset Store: [https://assetstore.unity.com/packages/3d/characters/unity-chan-model-18705](https://assetstore.unity.com/packages/3d/characters/unity-chan-model-18705).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我建议你首先从Unity Asset Store下载**Unity-Chan! Model**：[https://assetstore.unity.com/packages/3d/characters/unity-chan-model-18705](https://assetstore.unity.com/packages/3d/characters/unity-chan-model-18705)。
- en: This cute 3D girl model asset is produced by Unity Technologies Japan, and it's
    available for all developers to download and make games with it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可爱的3D女孩模型资产由Unity Technologies Japan制作，所有开发者都可以下载并使用它来制作游戏。
- en: 'The following content is included in this asset:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本资产包含以下内容：
- en: 3D models with beautiful textures
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美丽的纹理3D模型
- en: '"Unity-Chan!" original shaders'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"Unity-Chan!"原始着色器'
- en: 31 animations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31个动画
- en: 31 still poses
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 31个静态姿势
- en: 12 emotions made from blend shapes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由混合形状制成的12种表情
- en: A sample locomotion scene and other sample Scenes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个示例移动场景和其他示例场景
- en: Now, let's get started!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: Exploring the Unity animation system's concepts
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Unity动画系统的概念
- en: 'Animation is an important aspect of game development. In this section, we will
    first learn the basic concepts of the Unity animation system. Specifically, we
    will introduce the following concepts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是游戏开发的一个重要方面。在本节中，我们将首先学习Unity动画系统的基础概念。具体来说，我们将介绍以下概念：
- en: What Animation Clips are and how to create an Animation Clip in Unity
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Animation Clips是什么以及如何在Unity中创建一个Animation Clip
- en: How to create an Animator Controller to manage a set of animations for characters
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建Animator Controller来管理一组角色动画
- en: How to use the Avatar system to work with animation rigging
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Avatar系统与动画绑定一起工作
- en: What the Animator component is and how to use it to assign animation to a GameObject
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Animator组件是什么以及如何使用它将动画分配给GameObject
- en: Let's move on!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进！
- en: Animation Clips
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Animation Clips
- en: Animation in Unity can range from simple cube rotation to complex character
    movement and actions, and they are all based on **Animation Clips**, which are
    used to store keyframe-based animations in Unity.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的动画可以从简单的立方体旋转到复杂的角色动作，它们都是基于**Animation Clips**的，这些Clips用于在Unity中存储基于关键帧的动画。
- en: We can manually create an Animation Clip file in the Unity Editor to implement
    some simple traditional keyframe animation effects via the **Animation** window,
    such as simple movement, rotation, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Unity编辑器中手动创建一个Animation Clip文件，通过**Animation**窗口实现一些简单的传统关键帧动画效果，例如简单的移动、旋转等。
- en: 'The following steps show how to animate a GameObject in a Scene:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何在场景中动画化一个GameObject：
- en: Right-click in the **Hierarchy** window (on the right-hand side) and select
    **3D Object | Cube** from the pop-up menu to create a new **Cube** object in the
    Scene.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口（右侧）中右键单击，从弹出菜单中选择**3D Object | Cube**以在场景中创建一个新的**Cube**对象。
- en: '![](img/Figure_4.01_B17146.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.01_B17146.jpg)'
- en: Figure 4.1 – Create a new Cube object in the Scene
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 在场景中创建一个新的Cube对象
- en: 'Select the **Cube** object in the Scene view. Then navigate to **Window | Animation
    | Animation** to open the **Animation** window. In addition to opening this window
    from the menu, we can also use the *Ctrl + 6* shortcut to open it:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景视图中选择**Cube**对象。然后导航到**窗口 | 动画 | 动画**以打开**动画**窗口。除了从菜单中打开此窗口外，我们还可以使用*Ctrl
    + 6*快捷键打开它：
- en: '![](img/Figure_4.02_B17146.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.02_B17146.jpg)'
- en: Figure 4.2 – Open the Animation window
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 打开动画窗口
- en: 'Click on the **Create** button in the **Animation** window to create a new
    Animation Clip:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中点击**创建**按钮以创建一个新的动画剪辑：
- en: '![](img/Figure_4.03_B17146.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.03_B17146.jpg)'
- en: Figure 4.3 – The Animation window
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 动画窗口
- en: 'Click on the **Add Property** button to display a list of available properties
    that can be animated. As shown in *Figure 4.4*, we can not only modify **Position**
    and **Rotation** but also modify the properties of other components. Here we can
    add **Scale** as the property that will be animated by clicking the **+** button
    next to it:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加属性**按钮以显示可以动画化的可用属性列表。如图*图4.4*所示，我们不仅可以修改**位置**和**旋转**，还可以修改其他组件的属性。在这里，我们可以通过点击旁边的**+**按钮将**缩放**添加为将被动画化的属性：
- en: '![](img/Figure_4.04_B17146.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.04_B17146.jpg)'
- en: Figure 4.4 – Add Property
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 添加属性
- en: 'When a property is added, two keyframes are created by default: the first keyframe
    and the second keyframe are at *0:00* and *1:00* on the timeline respectively.
    So, we need to create a third keyframe to change the `0.5`, as shown in *Figure
    4.5*:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当添加属性时，默认创建两个关键帧：第一个关键帧和第二个关键帧分别位于时间轴上的**0:00**和**1:00**。因此，我们需要创建第三个关键帧来改变`0.5`，如图*图4.5*所示：
- en: '![](img/Figure_4.05_B17146.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.05_B17146.jpg)'
- en: Figure 4.5 – Add keyframes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 添加关键帧
- en: In order to preview the animation, click on the **Play** button to play the
    Animation Clip. You will see that the volume of the Cube shrinks rapidly and then
    slowly enlarges.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了预览动画，点击**播放**按钮播放动画剪辑。你会看到立方体的体积迅速缩小然后缓慢增大。
- en: '![](img/Figure_4.06_B17146.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.06_B17146.jpg)'
- en: Figure 4.6 – Play the Animation Clip
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 播放动画剪辑
- en: 'We can also use **recording mode** to create an Animation Clip in Unity, as
    demonstrated in these steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用**录制模式**在Unity中创建动画剪辑，如下步骤所示：
- en: 'The steps to create a new GameObject and open the **Animation** window are
    the same as before. So, let''s start directly with how to use recording mode to
    create an Animation Clip for a Sphere object in the Scene. We can click the record
    button to enable keyframe recording mode, as shown in *Figure 4.7*:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的GameObject和打开**动画**窗口的步骤与之前相同。所以，让我们直接开始如何使用录制模式为场景中的球体对象创建动画剪辑。我们可以点击录制按钮以启用关键帧录制模式，如图*图4.7*所示：
- en: '![](img/Figure_4.07_B17146.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.07_B17146.jpg)'
- en: Figure 4.7 – Enable keyframe recording mode
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 启用关键帧录制模式
- en: 'After clicking the record button, it will enter recording mode. Now, we can
    modify the point in time that we want it to be at by dragging on the timeline:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击录制按钮后，它将进入录制模式。现在，我们可以通过在时间轴上拖动来修改我们想要的时间点：
- en: '![](img/Figure_4.08_B17146.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.08_B17146.jpg)'
- en: Figure 4.8 – Drag on the timeline
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 在时间轴上拖动
- en: 'In recording mode, whether you move, rotate, or scale the target GameObject
    in the Scene, Unity will automatically add the keyframe of the current time point
    to the Animation Clip. Here we can move the GameObject from its original position
    (0, 0, 0) to a new position, let''s say, (1, 0, 0). And you can see in the following
    figure that Unity created keyframes for the Sphere object:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在录制模式下，无论你是在场景中移动、旋转还是缩放目标GameObject，Unity都会自动将当前时间点的关键帧添加到动画剪辑中。在这里，我们可以将GameObject从其原始位置（0,
    0, 0）移动到新的位置，比如（1, 0, 0）。你可以在下面的图中看到Unity为球体对象创建了关键帧：
- en: '![](img/Figure_4.09_B17146.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.09_B17146.jpg)'
- en: Figure 4.9 – Unity creates keyframes
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – Unity创建关键帧
- en: 'Finally, click on the record button again to exit recording mode and click
    the **Play** button to play the Animation Clip we just created:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，再次点击录制按钮退出录制模式，并点击**播放**按钮播放我们刚刚创建的动画剪辑：
- en: '![](img/Figure_4.10_B17146.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.10_B17146.jpg)'
- en: Figure 4.10 – Play the Animation Clip
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 播放动画剪辑
- en: In addition, importing external animation assets into the Unity Editor can also
    automatically create Animation Clip files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将外部动画资产导入Unity编辑器也可以自动创建动画剪辑文件。
- en: '![](img/Figure_4.11_B17146.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.11_B17146.jpg)'
- en: Figure 4.11 – Animation Clips created automatically after importing animation
    assets
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 导入动画资产后自动创建的动画片段
- en: Animation files such as generic **FBX** files, **Autodesk® 3ds Max® (.max)**
    files, native **Autodesk® Maya® (.mb or .ma)** files, and **Blender™ (.blend)**
    files need to be imported into our Unity project first before they can be used
    by Unity. After animation files are imported, Unity will generate Animation Clip
    files. We can open the **Animation** window to view an Animation Clip by double-clicking
    the Animation Clip file in the Unity Editor, as shown in *Figure 4.11*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通用**FBX**文件、**Autodesk® 3ds Max® (.max**)文件、本地**Autodesk® Maya® (.mb或.ma**)文件和**Blender™
    (.blend**)文件等动画文件需要在Unity项目中导入后才能被Unity使用。动画文件导入后，Unity将生成动画片段文件。我们可以通过在Unity编辑器中双击动画片段文件来打开**Animation**窗口以查看动画片段，如图*图4.11*所示。
- en: 'Now that you understand what an Animation Clip is and how to create a new one
    in Unity, let''s move on to the next concept: the Animator Controller.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了什么是动画片段以及如何在Unity中创建一个新的动画片段，让我们继续下一个概念：Animator Controller。
- en: Animator Controller
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Animator Controller
- en: Imagine that our game character has multiple animations. For example, say a
    character can both run and attack – it is very important to manage both of these
    animations for the character. In a Unity project, we use the **Animator Controller**
    asset to arrange and maintain a set of animations for characters or other animated
    GameObjects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们的游戏角色拥有多个动画。例如，假设一个角色可以跑和攻击——管理这两个动画对于角色来说非常重要。在Unity项目中，我们使用**Animator
    Controller**资产来安排和维护角色或其他动画GameObject的动画集。
- en: An **Animator Controller** will reference the Animation Clips it uses and use
    a so-called **state machine** to manage various animation states and transitions
    between them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**Animator Controller**将引用它使用的动画片段，并使用所谓的**状态机**来管理各种动画状态及其之间的转换。
- en: We can import the **Unity-Chan! Model** asset that we downloaded earlier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以导入我们之前下载的**Unity-Chan!模型**资产。
- en: '![](img/Figure_4.12_B17146.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12_B17146](img/Figure_4.12_B17146.jpg)'
- en: Figure 4.12 – Unity-Chan! Model ActionCheck Scene
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – Unity-Chan!模型ActionCheck场景
- en: This asset provides multiple demo Scenes; we chose to open the `Assets/unity-chan!/Unity-chan!
    Model/Scenes` folder.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此资产提供了多个演示场景；我们选择打开`Assets/unity-chan!/Unity-chan! Model/Scenes`文件夹。
- en: '![](img/Figure_4.13_B17146.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13_B17146](img/Figure_4.13_B17146.jpg)'
- en: Figure 4.13 – Unity-Chan! Model
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – Unity-Chan!模型
- en: As *Figure 4.13* shows, the Unity-Chan! model has been set up in the Scene.
    If we open the Animator Controller file used by this model, we can see all the
    Animation Clips used by this model and the transitions between Animation Clips
    in the state machine displayed in the **Animator** window, as shown in *Figure
    4.14*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4.13*所示，Unity-Chan!模型已在场景中设置。如果我们打开此模型使用的Animator Controller文件，我们可以看到此模型使用的所有动画片段以及**Animator**窗口中显示的状态机中的动画片段之间的转换，如图*图4.14*所示。
- en: '![](img/Figure_4.14_B17146.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14_B17146](img/Figure_4.14_B17146.jpg)'
- en: Figure 4.14 – Animator Controller
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – Animator Controller
- en: 'We can also follow these steps to manually create an **Animator Controller**
    asset in the Unity Editor:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以按照以下步骤在Unity编辑器中手动创建**Animator Controller**资产：
- en: Select the **Project** view and right-click to open the menu.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**项目**视图，右键单击以打开菜单。
- en: 'Select **Create | Animator Controller** to create a new **Animator Controller**
    asset:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建 | Animator Controller**以创建一个新的**Animator Controller**资产：
- en: '![](img/Figure_4.15_B17146.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15_B17146](img/Figure_4.15_B17146.jpg)'
- en: Figure 4.15 – Create a new Animator Controller
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 – 创建新Animator Controller
- en: Double-click the **Animator Controller** asset we just created to open the **Animator**
    window.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击我们刚刚创建的**Animator Controller**资产以打开**Animator**窗口。
- en: Here, drag the **POSE01** Animation Clip into the **Animator** window directly
    to create a new state. In the state machine, a state is represented by a box because
    the **POSE01** Animation Clip is the first animation we dragged, so we can see
    this animation is connected to the entry point of the Animator Controller, indicating
    that this animation will be the default animation.![](img/Figure_4.16_B17146.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，直接将**POSE01**动画片段拖入**Animator**窗口以创建一个新的状态。在状态机中，状态由一个方框表示，因为**POSE01**动画片段是我们拖入的第一个动画，所以我们可以看到这个动画连接到了Animator
    Controller的入口点，这表明这个动画将是默认动画。![图4.16_B17146](img/Figure_4.16_B17146.jpg)
- en: Figure 4.16 – Create a new state
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 – 创建新状态
- en: Create the second state by dragging the **POSE02** Animation Clip into the **Animator**
    window.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将**POSE02**动画片段拖入**Animator**窗口来创建第二个状态。
- en: Select the **POSE01** state and right-click to open a menu, then select **Make
    Transition** to make a transition between **POSE01** and **POSE02**.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **POSE01** 状态，右键单击以打开菜单，然后选择 **创建过渡** 以在 **POSE01** 和 **POSE02** 之间创建过渡。
- en: '![](img/Figure_4.17_B17146.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17](img/Figure_4.17_B17146.jpg)'
- en: Figure 4.17 – Make Transition
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 创建过渡
- en: Now, we've created an Animator Controller asset and added some Animation Clips
    to the state machine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个动画控制器资产，并将一些动画剪辑添加到了状态机中。
- en: Avatar
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Avatar
- en: Unlike the animation we created for Unity's built-in Cube model earlier, the
    model imported from the external tools into the Unity Editor may be more complicated.
    For example, the Unity-Chan! model is a human-like model. A model in Unity is
    represented by a mesh of **triangles**, and a triangle is composed of **vertices**.
    When the model is animated, the position of the vertices will be modified. Obviously,
    when many vertices make up a model, moving each vertex individually is an inefficient
    operation. Therefore, a common technique in computer animation is not to move
    each triangle individually during the animation but to skin the model before it
    is animated. This technique is called **skeletal animation** or **rigging.**
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前为 Unity 内置的 Cube 模型创建的动画不同，从外部工具导入到 Unity 编辑器的模型可能更复杂。例如，Unity-Chan! 模型是一个类似人类的模型。在
    Unity 中，模型由 **三角形** 网格表示，而三角形由 **顶点** 组成。当模型被动画化时，顶点的位置将被修改。显然，当许多顶点组成一个模型时，单独移动每个顶点是一个低效的操作。因此，计算机动画中的一种常见技术是在动画过程中不单独移动每个三角形，而是在动画之前对模型进行蒙皮。这种技术称为
    **骨骼动画** 或 **骨架**。
- en: Unity uses a system called **Avatar** to identify whether the animation model
    is a humanoid layout and which parts of the model correspond to the head, body,
    arms, legs, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 使用一个名为 **Avatar** 的系统来识别动画模型是否为人类布局以及模型的哪些部分对应于头部、身体、手臂、腿部等。
- en: '![](img/Figure_4.18_B17146.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18](img/Figure_4.18_B17146.jpg)'
- en: Figure 4.18 – Import Settings
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 导入设置
- en: We can open the **Import Settings** window for Unity-Chan! by clicking the model
    in the Unity Editor. As *Figure 4.18* shows, we can specify the kind of rig it
    is in the **Rig** tab of the window, and in this case, **Animation Type** for
    this model is **Humanoid**. The animation system will try to match the model's
    existing bone structure with the **Avatar** bone structure. If the bone structure
    can be successfully mapped, then an **Avatar** asset will be created automatically
    as shown in *Figure 4.19*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 Unity 编辑器中点击模型来打开 Unity-Chan! 的 **导入设置** 窗口。如图 4.18 所示，我们可以在窗口的 **骨架**
    选项卡中指定其骨架类型，在这种情况下，该模型的 **动画类型** 是 **人类**。动画系统将尝试将模型的现有骨骼结构与 **Avatar** 骨骼结构相匹配。如果骨骼结构可以成功映射，则将自动创建一个
    **Avatar** 资产，如图 4.19 所示。
- en: '![](img/Figure_4.19_B17146.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19](img/Figure_4.19_B17146.jpg)'
- en: Figure 4.19 – unitychanAvatar
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – unitychanAvatar
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Bones** are a hierarchical set of interconnected parts of **skeletal animation**.
    **Skinning** makes each vertex of the triangle depend on the bone.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**骨骼** 是 **骨骼动画** 中相互连接的部件的分层集合。**蒙皮** 使得三角形的每个顶点都依赖于骨骼。'
- en: On the other hand, if the animation system cannot automatically match the model's
    existing bone structure with the **Avatar** bone structure, we need to configure
    the **Avatar** manually. In addition, even if the bone structure can be successfully
    mapped, sometimes we want to manually adjust things to achieve better results.
    At this time, we can also modify it by configuring the **Avatar** asset.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果动画系统无法自动将模型的现有骨骼结构与 **Avatar** 骨骼结构相匹配，我们需要手动配置 **Avatar**。此外，即使骨骼结构可以成功映射，有时我们可能想要手动调整以达到更好的效果。在这种情况下，我们也可以通过配置
    **Avatar** 资产来修改它。
- en: '![](img/Figure_4.20_B17146.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20](img/Figure_4.20_B17146.jpg)'
- en: Figure 4.20 – Configure Avatar
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 配置 Avatar
- en: 'Follow these steps to configure it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行配置：
- en: Click on the model to open the **Import Settings** window for it.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击模型以打开其 **导入设置** 窗口。
- en: Click the **Configure** button in the **Rig** tab of the window to open the
    **Avatar Inspector** window.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的 **骨架** 选项卡中点击 **配置** 按钮以打开 **Avatar 检查器** 窗口。
- en: Configure the bones in the **Avatar Inspector** window as shown in *Figure 4.20*.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照如图 4.20 所示，在 **Avatar 检查器** 窗口中配置骨骼。
- en: Avatar Mask
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Avatar 遮罩
- en: After we create a mapping between the bones of the model and the bone structure
    of Unity's Avatar system, we can play the animation of this character. However,
    sometimes we may not want to animate all the bones of the character. A common
    example is that the walking animation may involve a character swinging their arms,
    but if they pick up a phone to make a call, their arms should hold the phone instead
    of swinging as they walk. In this case, we want to restrict an animation to specific
    body parts, and the **Avatar Mask** asset provided by Unity can help us achieve
    this goal.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将模型骨骼与Unity的Avatar系统骨骼结构之间创建映射之后，我们可以播放这个角色的动画。然而，有时我们可能不想动画化角色的所有骨骼。一个常见的例子是行走动画可能涉及角色摆动手臂，但如果他们拿起电话打电话，他们的手臂应该握住电话而不是在行走时摆动。在这种情况下，我们希望将动画限制在特定的身体部位，Unity提供的**Avatar
    Mask**资产可以帮助我们实现这个目标。
- en: We can create a new **Avatar Mask** asset by selecting **Assets | Create | Avatar
    Mask** as shown in *Figure 4.21*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过选择**资产 | 创建 | Avatar Mask**来创建一个新的**Avatar Mask**资产，如图*图4.21*所示。
- en: '![](img/Figure_4.21_B17146.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.21_B17146.jpg)'
- en: Figure 4.21 – Create an Avatar Mask
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 – 创建Avatar Mask
- en: After creating a new **Avatar Mask** asset, we can configure it to define which
    parts of the animation should be masked. As *Figure 4.22* shows, the **Avatar
    Mask** **Inspector** window allows us to click on a diagram of a humanoid body
    to select or deselect certain parts to mask. Here we mask an arm of Unity-Chan!,
    which means some animation will not affect this arm at runtime.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新的**Avatar Mask**资产后，我们可以配置它以定义动画的哪些部分应该被遮罩。如图*图4.22*所示，**Avatar Mask**
    **检查器**窗口允许我们点击一个类人身体图来选择或取消选择某些部分进行遮罩。在这里，我们遮罩了Unity-Chan!的一个手臂，这意味着某些动画在运行时不会影响这个手臂。
- en: '![](img/Figure_4.22_B17146.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.22_B17146.jpg)'
- en: Figure 4.22 – Avatar Mask
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 – Avatar Mask
- en: In order for this Avatar Mask asset to take effect, we need to apply it to an
    Animator Controller.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个Avatar Mask资产生效，我们需要将其应用到Animator Controller上。
- en: '![](img/Figure_4.23_B17146.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.23_B17146.jpg)'
- en: Figure 4.23 – Apply the Avatar Mask asset
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 – 应用Avatar Mask资产
- en: 'In this case, we will apply this Avatar Mask asset to the Animator Controller
    we created earlier as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将按照以下步骤将此Avatar Mask资产应用到我们之前创建的Animator Controller中：
- en: Double-click the **New Animator Controller** file to open the **Animator** window.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**新Animator Controller**文件以打开**Animator**窗口。
- en: Click on the gear icon of the **Base Layer** item to open the **Layer settings**
    panel.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**基础层**项的齿轮图标以打开**层设置**面板。
- en: Then, click the radio button next to the **Mask** field and select the New **Avatar
    Mask** asset to apply from the **Select AvatarMask** window that pops up, as shown
    in *Figure 4.23*.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**Mask**字段旁边的单选按钮，并从弹出的**选择AvatarMask**窗口中选择新的**Avatar Mask**资产来应用，如图*图4.23*所示。
- en: In this way, we can limit the animation to specific body parts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以将动画限制在特定的身体部位。
- en: Next, we will explore another important concept in Unity's Animation development
    solution, namely the **Animator** component. By using Animator, we can use this
    Animator Controller asset in our game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Unity动画开发解决方案中的另一个重要概念，即**Animator**组件。通过使用Animator，我们可以在游戏中使用这个Animator
    Controller资产。
- en: Animator component
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画组件
- en: In the previous sections, we explored Animation Clips, Animator Controllers,
    and Avatar in Unity. However, just creating Animation Clips, Animator Controllers,
    and Avatar assets is not enough to animate the characters in a game Scene. We
    still need the Animator component to assign animation to the GameObject in the
    Scene.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了Animation Clips、Animator Controllers和Avatar在Unity中的使用。然而，仅仅创建Animation
    Clips、Animator Controllers和Avatar资产是不够的，以在游戏场景中动画化角色。我们仍然需要Animator组件将动画分配给场景中的GameObject。
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Animator Controllers and Animator components have similar names but different
    functions. An Animator component uses an associated Animator Controller to apply
    animations to a GameObject.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Animator Controllers和Animator组件名称相似但功能不同。Animator组件使用关联的Animator Controller将动画应用到GameObject上。
- en: If you see an Animator component on a GameObject, you will find that it will
    bring together all the various assets we discussed before. It is the root of the
    binding system in Unity's animation solution, so it is very important.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个GameObject上看到Animator组件，你会发现它将汇集我们之前讨论的所有各种资产。它是Unity动画解决方案中绑定系统的根，因此非常重要。
- en: '![](img/Figure_4.24_B17146.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.24_B17146.jpg)'
- en: Figure 4.24 – Animator component
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 – Animator组件
- en: 'Here we can drag the Unity-Chan! model into the Scene to create a new character
    GameObject, and add an Animator component to the GameObject, as *Figure 4.24*
    shows. This is how the Animator component was configured:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以将Unity-Chan!模型拖入场景以创建一个新的角色GameObject，并将Animator组件添加到GameObject中，如图4.24所示。这是Animator组件的配置方式：
- en: The Animator component needs to reference an Animator Controller, which defines
    the Animation Clips to be used. We can assign the Animator Controller that we
    created in the *Animator Controller* section to it, with the name **New Animator
    Controller**.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Animator组件需要引用Animator Controller，它定义了要使用的动画剪辑。我们可以将我们在*Animator Controller*部分创建的Animator
    Controller分配给它，名称为**新Animator Controller**。
- en: Since the Unity-Chan! model is a humanoid model, provide the corresponding Avatar
    asset to this Animator component.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Unity-Chan!模型是一个人形模型，因此需要为这个Animator组件提供相应的Avatar资产。
- en: The **Apply Root Motion** setting of the Animator component determines whether
    or not any change to the position or rotation of the root node will be applied.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Animator组件的**应用根运动**设置决定了是否将根节点的位置或旋转的任何更改应用于动画。
- en: The **Update Mode** setting of the Animator component determines the update
    mode of the Animator component. There are three different options, namely **Normal**,
    **Animate Physics**, and **Unscaled Time**.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Animator组件的**更新模式**设置决定了Animator组件的更新模式。有三个不同的选项，即**正常**、**动画物理**和**未缩放时间**。
- en: '![](img/Figure_4.25_B17146.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.25_B17146.jpg)'
- en: Figure 4.25 – The Update Mode setting
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25 – 更新模式设置
- en: The last setting is **Culling** **Mode**, which determines whether the animations
    of the Animator component should play off-screen. There are three different options,
    namely **Always Animate**, **Cull Update Transforms**, and **Cull Completely**.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的设置是**裁剪** **模式**，它决定了Animator组件的动画是否应在屏幕外播放。有三个不同的选项，即**始终动画**、**裁剪更新变换**和**完全裁剪**。
- en: '![](img/Figure_4.26_B17146.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.26_B17146.jpg)'
- en: Figure 4.26 – The Culling Mode setting
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26 – 裁剪模式设置
- en: After reading this section, we have an understanding of the concepts of Unity's
    animation system. We will use this system to create 3D animations in the next
    section!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本节后，我们对Unity动画系统的概念有了了解。我们将在下一节中使用这个系统创建3D动画！
- en: Implementing 3D animation in Unity
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中实现3D动画
- en: We have covered some important concepts, such as **Animation Clips**, **Animator
    Controllers**, **Avatar**, and **Animator components**, in the Unity animation
    system in the previous sections. In this section, you will learn how to implement
    animation for 3D models with these concepts.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经介绍了Unity动画系统中的某些重要概念，例如**动画剪辑**、**Animator控制器**、**Avatar**和**Animator组件**。在本节中，你将学习如何使用这些概念为3D模型实现动画。
- en: Importing animation assets
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入动画资产
- en: 'First, we need to know how to import animation assets into Unity from `/Assets/unity-chan!/Unity-chan!
    Model/Art/Animations` folder as shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要知道如何从`/Assets/unity-chan!/Unity-chan! Model/Art/Animations`文件夹将动画资产导入Unity，如图下所示：
- en: '![](img/Figure_4.27_B17146.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.27_B17146.jpg)'
- en: Figure 4.27 – The Animations folder
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27 – 动画文件夹
- en: Here we can select one animation asset in the **Project** window to open its
    **Import Settings** window.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以从**项目**窗口中选择一个动画资产以打开其**导入设置**窗口。
- en: '![](img/Figure_4.28_B17146.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.28_B17146.jpg)'
- en: Figure 4.28 – Import settings for animations
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28 – 动画导入设置
- en: As shown in *Figure 4.28*, click **Animation** in the **Inspector** window to
    switch to the **Animation** tab, and you can see all the Animation Clips contained
    in the animation asset.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如图4.28所示，在**检查器**窗口中点击**动画**以切换到**动画**选项卡，你可以看到包含在动画资产中的所有动画剪辑。
- en: Animation compression
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画压缩
- en: In addition, in the **Animation** tab, we can also find animation-related import
    settings.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在**动画**选项卡中，我们还可以找到与导入相关的设置。
- en: '![](img/Figure_4.29_B17146.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.29_B17146.jpg)'
- en: Figure 4.29 – The Anim. Compression setting
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29 – 动画压缩设置
- en: As shown in *Figure 4.29*, there is a setting called **Anim. Compression**,
    whose value is **Off** by default, which means that Unity doesn't reduce the keyframe
    count on import. In this case, Unity will keep the highest precision animation,
    but at the expense of a large animation size. If reducing the size of the animation,
    whether on our hard disk or in memory, is important, we can consider the two other
    **Anim. Compression** options, which are **Keyframe Reduction** and **Optimal**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 4.29* 所示，有一个名为 **动画压缩** 的设置，其默认值为 **关闭**，这意味着 Unity 在导入时不会减少关键帧的数量。在这种情况下，Unity
    将保持最高精度的动画，但代价是动画文件大小很大。如果减少动画的大小，无论是在我们的硬盘上还是在内存中，都很重要，我们可以考虑其他两个 **动画压缩** 选项，即
    **关键帧减少** 和 **最佳**。
- en: '![](img/Figure_4.30_B17146.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.30_B17146.jpg)'
- en: Figure 4.30 – Optimal
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30 – 最佳
- en: If the `0.5`; the smaller the value, the higher the precision.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值为 `0.5`；值越小，精度越高。
- en: If the **Optimal** option is selected, Unity will decide how to compress the
    Animation Clip.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择 **最佳** 选项，Unity 将决定如何压缩动画剪辑。
- en: Animation Events
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画事件
- en: We can also modify the properties of a single Animation Clip. After selecting
    an Animation Clip in the list, we can scroll down to see the settings for this
    particular Animation Clip.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以修改单个动画剪辑的属性。在列表中选择一个动画剪辑后，我们可以向下滚动以查看该特定动画剪辑的设置。
- en: '![](img/Figure_4.31_B17146.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.31_B17146.jpg)'
- en: Figure 4.31 – Settings for the Animation Clip
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31 – 动画剪辑的设置
- en: As the preceding figure shows, there is an option for the Animation Clip to
    add an Animation Event, which allows us to call functions in a script at a specified
    point in the timeline.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，动画剪辑有一个添加动画事件的选项，这允许我们在时间轴的指定点调用脚本中的函数。
- en: In order to create a new Animation Event, first, we need to position the point
    in the timeline where we want to add the event, then click the **Add Event** button
    in the upper-left corner. A small white marker on the timeline will be created,
    which indicates the new event.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的动画事件，首先，我们需要在时间轴上定位我们想要添加事件的位置，然后点击左上角的 **添加事件** 按钮。时间轴上会创建一个小白标记，表示新事件。
- en: 'After creating a new event, we also need to configure it by following these
    steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新事件后，我们还需要按照以下步骤进行配置：
- en: As we can see in *Figure 4.32*, there are multiple fields to fill in, and we
    entered the name `PrintStringFromAnimationEvent` in the `PrintStringFromAnimationEvent`
    function in a script attached to the GameObject. Several other fields can pass
    in different types of parameters for this function, such as `Float`, `Int`, and
    `String`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如 *图 4.32* 所示，有多个字段需要填写，我们在附加到 GameObject 的脚本中的 `PrintStringFromAnimationEvent`
    函数中输入了名称 `PrintStringFromAnimationEvent`。其他几个字段可以为这个函数传入不同类型的参数，例如 `Float`、`Int`
    和 `String`。
- en: '![](img/Figure_4.32_B17146.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.32_B17146.jpg)'
- en: Figure 4.32 – Add an Animation Event
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32 – 添加动画事件
- en: After setting the event, remember to click the **Apply** button to make the
    configuration of the event take effect.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置事件后，请记住点击 **应用** 按钮以使事件配置生效。
- en: 'At the same time, we need to implement a function whose name must exactly match
    the name already filled in the function field, namely `PrintStringFromAnimationEvent`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们需要实现一个函数，其名称必须与已填入函数字段的名称完全匹配，即 `PrintStringFromAnimationEvent`：
- en: '[PRE0]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This function will accept a string type parameter; once this Animation Event
    is triggered, this function will be called, and the string value will be printed
    in the **Console** window, as shown in the following figure:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将接受一个字符串类型的参数；一旦这个动画事件被触发，这个函数将被调用，并且字符串值将在 **控制台** 窗口中打印出来，如图所示：
- en: '![](img/Figure_4.33_B17146.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.33_B17146.jpg)'
- en: Figure 4.33 – Print the string value in the Console window
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33 – 在控制台窗口中打印字符串值
- en: Now that we know more about importing animation assets into Unity and how to
    set up Animation Events, let's turn our attention to setting up the Animator Controller!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何将动画资产导入 Unity 以及如何设置动画事件，让我们将注意力转向设置动画控制器！
- en: Configuring the Animator Controller
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置动画控制器
- en: After importing animation assets, we need to set up an Animator Controller to
    reference these Animation Clips that will be used in our game. In fact, we created
    an Animator Controller when we introduced it earlier and referenced two Animation
    Clips that will be used. However, we did not configure this Animator Controller;
    for instance, we did not configure how to switch between the two animations. In
    this section, we will explore how to configure an Animator Controller and use
    C# code to switch between different animations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入动画资源后，我们需要设置一个Animator Controller来引用将在我们的游戏中使用的这些Animation Clips。实际上，当我们之前介绍它时，我们已经创建了一个Animator
    Controller，并引用了两个将使用的Animation Clips。然而，我们没有配置这个Animator Controller；例如，我们没有配置如何在这两个动画之间切换。在本节中，我们将探讨如何配置Animator
    Controller并使用C#代码在不同动画之间切换。
- en: Adjusting the animation speed
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整动画速度
- en: We can view the settings of a specific state in the Animator Controller by selecting
    the state in the **Animator** window.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在**Animator**窗口中选择状态来查看Animator Controller中特定状态的设置。
- en: '![](img/Figure_4.34_B17146.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.34_B17146.jpg)'
- en: Figure 4.34 – Settings of an animation's state
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34 – 动画状态的设置
- en: There are multiple settings, such as `1`. If the `0.5`, the play speed of `2`
    will make the play speed of **Motion Time** twice the normal speed and halve the
    play time.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个设置，例如`1`。如果设置为`0.5`，则`2`的播放速度将使**运动时间**的播放速度是正常速度的两倍，播放时间是正常的一半。
- en: Animator parameters
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画器参数
- en: As we can see in *Figure 4.35*, there are other settings that require parameters
    to be used. These parameters are called **animation parameters** and they are
    variables defined in the Animator Controller that can be accessed and assigned
    values from a C# script. Therefore, they are an important part of using C# code
    to control animation. In order to add new parameters and edit existing parameters,
    we should switch to the **Parameters** section of the **Animator** window by clicking
    the **Parameters** button in the top-right corner.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*图4.35*中看到的，还有其他需要使用参数的设置。这些参数被称为**动画参数**，它们是在Animator Controller中定义的变量，可以从C#脚本中访问和分配值。因此，它们是使用C#代码控制动画的重要部分。为了添加新参数和编辑现有参数，我们应该通过点击右上角的**Parameters**按钮切换到**Animator**窗口的**Parameters**部分。
- en: '![](img/Figure_4.35_B17146.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.35_B17146.jpg)'
- en: Figure 4.35 – The Parameters section
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35 – 参数部分
- en: 'As shown in the preceding figure, the parameters can be one of the following
    four types:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，参数可以是以下四种类型之一：
- en: '**Float**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点型**'
- en: '**Int**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整型**'
- en: '**Bool**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔型**'
- en: '**Trigger**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器**'
- en: As a demonstration, we can add a new parameter called **SpeedMultiplier**. Then,
    we open the settings of the **POSE01** animation state again and check the **Parameter**
    checkbox after the **Multiplier** setting, and you can see that the newly created
    **SpeedMultiplier** parameter appears.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，我们可以添加一个名为**SpeedMultiplier**的新参数。然后，我们再次打开**POSE01**动画状态的设置，并在**Multiplier**设置之后勾选**Parameter**复选框，你将看到新创建的**SpeedMultiplier**参数出现。
- en: '![](img/Figure_4.36_B17146.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.36_B17146.jpg)'
- en: Figure 4.36 – The SpeedMultiplier parameter
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.36 – SpeedMultiplier参数
- en: 'As we mentioned earlier, these parameters can be accessed and assigned values
    using C# code. Therefore, we can create a new script to access and set a value
    of the `SpeedMultiplier` parameter as shown in the following code snippet:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这些参数可以使用C#代码访问和分配值。因此，我们可以创建一个新的脚本来访问和设置`SpeedMultiplier`参数的值，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we create a new C# script named `AnimationParametersTest` and obtain a
    reference to the Animator component, then we set the value of the parameter by
    calling the **SetFloat** method of the Animator component, because the type of
    this parameter is float. Similarly, the Animator component also has, **SetInteger**,
    **SetBool**, and **SetTrigger** methods, which are used to set values for different
    types of parameters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的C#脚本名为`AnimationParametersTest`，并获取Animator组件的引用，然后通过调用Animator组件的**SetFloat**方法来设置参数的值，因为此参数的类型是float。同样，Animator组件也有**SetInteger**、**SetBool**和**SetTrigger**方法，用于设置不同类型参数的值。
- en: Configuring transitions
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置过渡
- en: Animation parameters can also be used to implement animation switching. We can
    use animation transitions to connect two animation states and switch between them.
    However, by default, animation transitions will automatically switch between two
    connected animation states, but we obviously prefer to be able to control the
    switching of animations when developing games.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 动画参数也可以用来实现动画切换。我们可以使用动画过渡来连接两个动画状态并在它们之间切换。然而，默认情况下，动画过渡将自动在两个连接的动画状态之间切换，但我们在开发游戏时显然更喜欢能够控制动画的切换。
- en: '![](img/Figure_4.37_B17146.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图4.37](img/Figure_4.37_B17146.jpg)'
- en: Figure 4.37 – Animation transitions
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.37 – 动画过渡
- en: We can set a transition to occur only when certain conditions are true, and
    animation parameters can be used to determine whether these conditions are met,
    so we can use them here to control the switching of the animation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置一个过渡，仅在特定条件为真时发生，并且可以使用动画参数来确定这些条件是否满足，因此我们可以在这里使用它们来控制动画的切换。
- en: 'The following steps demonstrate how to add a new parameter, set up a condition,
    and control the switching of different animations from C# code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何从C#代码中添加一个新参数、设置条件以及控制不同动画的切换：
- en: Switch to the `bool` variable parameter called **Run**; its default value is
    **false**, as shown in the following screenshot.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到名为**Run**的`bool`变量参数；其默认值为**false**，如图下截图所示。
- en: '![](img/Figure_4.38_B17146.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图4.38](img/Figure_4.38_B17146.jpg)'
- en: Figure 4.38 – A new parameter
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38 – 新参数
- en: Select the transition we want to apply the condition to; here we choose the
    transition from **POSE01** to **POSE02**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要应用条件的过渡；这里我们选择从**POSE01**到**POSE02**的过渡。
- en: In the `Go To Run` to this transition, as shown in *Figure 4.39*.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Go To Run**到这个过渡中，如图*图4.39*所示。
- en: '![](img/Figure_4.39_B17146.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图4.39](img/Figure_4.39_B17146.jpg)'
- en: Figure 4.39 – Name the transition
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.39 – 命名过渡
- en: 'At the bottom of the same window, all the conditions for this transition are
    listed. By clicking the **+** button, add a new condition for this **Go To Run**
    transition, as shown here:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一窗口的底部，列出了此过渡的所有条件。通过点击**+**按钮，为这个**Go To Run**过渡添加一个新条件，如图所示：
- en: '![](img/Figure_4.40_B17146.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图4.40](img/Figure_4.40_B17146.jpg)'
- en: Figure 4.40 – Add a new condition
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.40 – 添加新条件
- en: After adding a new condition, we also need to select a parameter, the value
    of which is considered as the condition. The parameter here is **Run**. When the
    value of the **Run** parameter is **true**, it can be considered that the condition
    is met.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新条件后，我们还需要选择一个参数，其值被视为条件。这里的参数是**Run**。当**Run**参数的值为**true**时，可以认为条件已满足。
- en: '![](img/Figure_4.41_B17146.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图4.41](img/Figure_4.41_B17146.jpg)'
- en: Figure 4.41 – Select a parameter as the condition
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41 – 选择参数作为条件
- en: 'However, the default value of the **Run** parameter is **false**. Therefore,
    in order to switch from **POSE1** to **POSE2**, create a C# script to set the
    value as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，**Run**参数的默认值是**false**。因此，为了从**POSE1**切换到**POSE2**，创建一个C#脚本，设置值如下：
- en: '![](img/Figure_4.42_B17146.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图4.42](img/Figure_4.42_B17146.jpg)'
- en: Figure 4.42 – C# code snippets
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42 – C#代码片段
- en: The `Input.GetKey` method will return `true` when the user holds down the key
    identified by `KeyCode`; otherwise, it will return `false`, and then we use this
    value to set the value of the **Run** parameter. Therefore, we can control the
    switching of the animation by pressing the key.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Input.GetKey`方法会在用户按下由`KeyCode`标识的键时返回`true`；否则，它将返回`false`，然后我们使用这个值来设置**Run**参数的值。因此，我们可以通过按键来控制动画的切换。'
- en: After reading this section, we have learned how to implement animation for 3D
    models and how to control animation through C# code in Unity. Next, we will discuss
    how to implement animation for 2D assets.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本节后，我们已经学会了如何在Unity中实现3D模型的动画以及如何通过C#代码控制动画。接下来，我们将讨论如何实现2D资源的动画。
- en: Implementing 2D animation in Unity
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中实现2D动画
- en: In this section, we will use the tools we explored earlier to implement 2D animation
    in Unity.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用我们之前探索的工具在Unity中实现2D动画。
- en: The implementation of 2D animation is different from the implementation of 3D
    animation. A common implementation technique for 2D animation is to use **Sprite
    Animations**, which are Animation Clips that are created for 2D assets.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 2D动画的实现与3D动画的实现不同。2D动画的常见实现技术是使用**Sprite Animations**，这些是为2D资源创建的动画片段。
- en: There are many ways to create Sprite Animations; we can create them directly
    in the **Animation** window of the Unity Editor or create them in external tools,
    such as Aseprite, a popular animation sprite editor, and Piskel, a free online
    sprite editor.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建精灵动画有许多方法；我们可以在Unity编辑器的**动画**窗口中直接创建它们，或者在像Aseprite这样的流行动画精灵编辑器或Piskel这样的免费在线精灵编辑器等外部工具中创建它们。
- en: 'Here, we use the sprite animation created by an external tool. You can download
    this asset from Unity Asset Store here: [https://assetstore.unity.com/packages/2d/characters/free-pixel-mob-113577](https://assetstore.unity.com/packages/2d/characters/free-pixel-mob-113577).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用由外部工具创建的精灵动画。您可以从Unity Asset Store在此处下载此资产：[https://assetstore.unity.com/packages/2d/characters/free-pixel-mob-113577](https://assetstore.unity.com/packages/2d/characters/free-pixel-mob-113577)。
- en: '![](img/Figure_4.43_B17146.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.43_B17146.jpg)'
- en: Figure 4.43 – A Sprite Sheet
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.43 – 精灵表
- en: After downloading the assets, we can find that this image contains many different
    Sprites, as shown in *Figure 4.43*. We call this a **Sprite Sheet**, which is
    an image containing sequential Sprites commonly used for animation for 2D assets.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下载资产后，我们可以发现此图像包含许多不同的精灵，如图*图4.43*所示。我们称之为**精灵表**，它是一个包含连续精灵的图像，通常用于2D资产的动画。
- en: Note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If an image contains a set of non-sequential Sprite images, we call it a **Sprite
    Atlas**, which is often used to implement UI.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个图像包含一组非连续的精灵图像，我们称之为**精灵图集**，它通常用于实现UI。
- en: 'Then, we should import this image file into the Unity Editor by performing
    the following steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该通过以下步骤将此图像文件导入到Unity编辑器中：
- en: 'As shown in *Figure 4.44*, since this image contains a series of Sprite images,
    we set **Sprite Mode** to **Multiple** in the **Import Settings** window:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如*图4.44*所示，由于此图像包含一系列精灵图像，我们在**导入设置**窗口中将**精灵模式**设置为**多个**：
- en: '![](img/Figure_4.44_B17146.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.44_B17146.jpg)'
- en: Figure 4.44 – Import Settings of the Sprite Sheet
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.44 – 精灵表的导入设置
- en: Click the **Sprite Editor** button to open **Sprite Editor** in Unity. **Sprite
    Editor** provides tools that allow us to modify Sprite Sheets, such as slicing
    Sprite Sheets into individual Sprites.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**精灵编辑器**按钮，在Unity中打开**精灵编辑器**。**精灵编辑器**提供了允许我们修改精灵表的工具，例如将精灵表切割成单个精灵。
- en: '![](img/Figure_4.45_B17146.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.45_B17146.jpg)'
- en: Figure 4.45 – Sprite Editor in Unity
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.45 – Unity中的精灵编辑器
- en: 'By clicking the `16`, change the value of `1`, and then click the **Slice**
    button at the bottom of the drop-down menu and close **Sprite Editor**, as shown
    in the following screenshot:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击`16`，将`1`的值更改，然后点击下拉菜单底部的**切片**按钮，并关闭**精灵编辑器**，如图下所示截图：
- en: '![](img/Figure_4.46_B17146.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.46_B17146.jpg)'
- en: Figure 4.46 – Grid By Cell Count
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.46 – 通过单元格计数网格
- en: 'Then we can select this **Sprite Sheet** asset in the **Project** window to
    expand it, and you can see all the individual Sprites in it:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在**项目**窗口中选择此**精灵表**资产以展开它，您将看到其中所有的单个精灵：
- en: '![](img/Figure_4.47_B17146.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.47_B17146.jpg)'
- en: Figure 4.47 – Sprites in the Sprite Sheet
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.47 – 精灵表中的精灵
- en: 'At this point, we have imported the assets and created these sprites. The next
    question is, how do we use these Sprites to create Animation Clips in Unity? The
    answer is not complicated. We only need to select the Sprites that make up the
    Animation Clip we want to create and drag them into the scene. The Unity Editor
    will automatically create the Animation Clip and ask us to select the folder where
    the Animation Clip file will be stored, as shown in the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经导入了资产并创建了这些精灵。下一个问题是，我们如何使用这些精灵在Unity中创建动画剪辑？答案并不复杂。我们只需要选择组成我们想要创建的动画剪辑的精灵并将它们拖入场景。Unity编辑器将自动创建动画剪辑并询问我们选择存储动画剪辑文件的文件夹，如图下所示截图：
- en: '![](img/Figure_4.48_B17146.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.48_B17146.jpg)'
- en: Figure 4.48 – Create an Animation Clip file
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.48 – 创建动画剪辑文件
- en: In this case, we select the first eight Sprites from the Sprite Sheet and drag
    them to the Scene view of the Unity Editor. Then, we rename the Animation Clip
    file to `walk` and save it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从精灵表中选择了前八个精灵并将它们拖动到Unity编辑器的场景视图中。然后，我们将动画剪辑文件重命名为`walk`并保存。
- en: Unity will create the Animation Clip file, as I mentioned earlier, and a new
    Animator Controller asset as well. A new GameObject with an Animator component
    attached will also be created in the Scene, which references the Animator Controller,
    as shown in *Figure 4.49*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 将创建动画剪辑文件，正如我之前提到的，还将创建一个新的Animator Controller资产。在场景中还会创建一个新的GameObject，并附加Animator组件，它引用Animator
    Controller，如图 *图 4.49* 所示。
- en: '![](img/Figure_4.49_B17146.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.49_B17146.jpg)'
- en: Figure 4.49 – New GameObject in the Scene
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.49 – 场景中的新 GameObject
- en: Now we can run the game to play the animation by clicking the **Play** button
    in the Unity Editor, and we can see the **walk** animation is playing!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在Unity编辑器中点击 **播放** 按钮来运行游戏并播放动画，我们可以看到 **行走** 动画正在播放！
- en: '![](img/Figure_4.50_B17146.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.50_B17146.jpg)'
- en: Figure 4.50 – Play the walk animation
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.50 – 播放行走动画
- en: After reading this section, you have learned how to implement animation for
    2D assets; next, we will share some tips to improve animation performance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本节后，您已经学会了如何为2D资产实现动画；接下来，我们将分享一些提高动画性能的技巧。
- en: Improving the performance of Unity's animation system
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升Unity动画系统的性能
- en: In Unity, the implementation of animation may cause excessive memory usage and
    CPU overhead. In this section, we will talk about how to avoid performance problems
    caused by animation. Specifically, we'll first introduce the **Unity Profiler**
    tool and how to use it to view animation-related performance metrics, and then
    we'll look at how to reduce the CPU overhead and memory footprint of animations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，动画的实现可能会导致过度的内存使用和CPU开销。在本节中，我们将讨论如何避免由动画引起的性能问题。具体来说，我们将首先介绍 **Unity
    性能分析器** 工具及其如何用于查看与动画相关的性能指标，然后我们将探讨如何减少动画的CPU开销和内存占用。
- en: The Unity Profiler
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity 性能分析器
- en: First, we should learn how to use tools to view and locate performance bottlenecks
    rather than relying on subjective guesses and experience. Of course, it's not
    that experience is not important, but using tools will help you locate problems
    more quickly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该学习如何使用工具来查看和定位性能瓶颈，而不是依赖于主观猜测和经验。当然，经验的重要性不言而喻，但使用工具将帮助您更快地定位问题。
- en: The Unity Editor provides developers with a Profiler tool, which we can use
    to view the detailed memory usage of the game and real-time CPU overhead.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 编辑器为开发者提供了一个性能分析器工具，我们可以使用它来查看游戏的详细内存使用情况和实时CPU开销。
- en: 'In order to view performance data about the CPU overhead of animation, we should
    follow these steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看关于动画CPU开销的性能数据，我们应该遵循以下步骤：
- en: Click **Window | Analysis | Profiler** to open the **Profiler** window.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **窗口 | 分析 | 性能分析器** 打开 **性能分析器** 窗口。
- en: Click the **CPU Usage** module area in the **Profiler** window to view the performance
    data on the CPU overhead, such as the CPU time consumed by **Animator.Update**,
    as shown in *Figure 4.51*.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **性能分析器** 窗口中点击 **CPU 使用率** 模块区域，以查看CPU开销的性能数据，例如 **Animator.Update** 消耗的CPU时间，如图
    *图 4.51* 所示。
- en: '![](img/Figure_4.51_B17146.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.51_B17146.jpg)'
- en: Figure 4.51 – The Unity Profiler
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.51 – Unity 性能分析器
- en: The Unity Profiler also allows us to switch from the **Hierarchy** view to the
    **Timeline** view, which is more intuitive in some cases.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity 性能分析器还允许我们切换到 **层次结构** 视图和 **时间轴** 视图，在某些情况下这会更加直观。
- en: '![](img/Figure_4.52_B17146.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.52_B17146.jpg)'
- en: Figure 4.52 – The Timeline view in the Profiler window
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.52 – 性能分析器窗口中的时间轴视图
- en: In addition to the **CPU Usage** module, we can also view the detailed memory
    consumption of the game in the **Memory** module.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **CPU 使用率** 模块外，我们还可以在 **内存** 模块中查看游戏的详细内存消耗。
- en: 'Click on the **Memory** module area in the **Profiler** window to view the
    performance data of memory consumption. The default display mode is **Simple**
    mode, and the memory consumption is counted by types in the **Profiler** window.
    For example, the memory usage of **Textures** is about 106.3 MB, and the memory
    usage of **Meshes** is about 4.5 MB, as shown here:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **性能分析器** 窗口中点击 **内存** 模块区域，以查看内存消耗的性能数据。默认显示模式是 **简单** 模式，内存消耗在 **性能分析器**
    窗口中按类型计数。例如，**纹理** 的内存使用量约为 106.3 MB，**网格** 的内存使用量约为 4.5 MB，如图所示：
- en: '![](img/Figure_4.53_B17146.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.53_B17146.jpg)'
- en: Figure 4.53 – Memory data in the Profiler window
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.53 – 性能分析器窗口中的内存数据
- en: Compared with **Simple** mode, **Detailed** mode is more powerful. We can switch
    from **Simple** mode to **Detailed** mode by selecting **Detailed** from the drop-down
    menu in the upper-left corner.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与**简单**模式相比，**详细**模式功能更强大。我们可以通过在上左角的下拉菜单中选择**详细**来从**简单**模式切换到**详细**模式。
- en: '![](img/Figure_4.54_B17146.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.54_B17146.jpg)'
- en: Figure 4.54 – Switch to Detailed mode
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.54 – 切换到详细模式
- en: '**Detailed** mode does not display memory consumption data in real time like
    **Simple** mode. Instead, we need to manually click the **Take Sample****Playmode**
    button to sample the game memory at the current time.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细**模式不会像**简单**模式那样实时显示内存消耗数据。相反，我们需要手动点击**取样本****播放模式**按钮来在当前时间采样游戏内存。'
- en: '![](img/Figure_4.55_B17146.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.55_B17146.jpg)'
- en: Figure 4.55 – Take a memory sample
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.55 – 取内存样本
- en: Depending on the number of objects created in the game or how much memory is
    consumed, the sampling time will be different. But once the sampling is complete,
    we will see the detailed memory overhead; for example, in the following screenshot,
    there are 82 Animation Clips taking up 50.1 MB of memory.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 根据游戏中创建的对象数量或消耗的内存量，采样时间将不同。但一旦采样完成，我们将看到详细的内存开销；例如，在下面的屏幕截图中，有 82 个动画剪辑占用了
    50.1 MB 的内存。
- en: '![](img/Figure_4.56_B17146.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.56_B17146.jpg)'
- en: Figure 4.56 – Detailed memory data in the Profiler window
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.56 – 分析器窗口中的详细内存数据
- en: From the preceding introduction, we can see that the optimization of animation
    should mainly focus on CPU overhead and memory consumption. Therefore, the following
    two best practices need to be considered when using Unity's animation system to
    implement animation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的介绍中，我们可以看到动画的优化应主要关注 CPU 负载和内存消耗。因此，当使用 Unity 的动画系统实现动画时，以下两个最佳实践需要考虑。
- en: Animator's Culling Mode
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画师剔除模式
- en: In order to reduce the CPU overhead of animation, we should set the **Animator**
    window's **Culling Mode** property to **Cull Update Transforms** or **Cull Completely**.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少动画的 CPU 负载，我们应该将**动画师**窗口的**剔除模式**属性设置为**剔除更新变换**或**完全剔除**。
- en: '![](img/Figure_4.57_B17146.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.57_B17146.jpg)'
- en: Figure 4.57 – Animator's Culling Mode
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.57 – 动画师剔除模式
- en: By setting it to **Cull Update Transforms**, Unity will disable some features
    of the animation system such as Retarget, Inverse Kinematics (IK) Transforms when
    the Animator is not visible on screen. If it is set to **Cull Completely**, Unity
    will completely disable the animation when the Animator is not visible. Therefore,
    the goal of reducing CPU overhead can be achieved.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其设置为**剔除更新变换**，当动画师在屏幕上不可见时，Unity 将禁用动画系统的一些功能，如重定向、逆运动学（IK）变换。如果设置为**完全剔除**，当动画师在屏幕上不可见时，Unity
    将完全禁用动画。因此，可以减少 CPU 负载的目标可以达成。
- en: Anim. Compression
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画压缩
- en: Another best practice is to set **Anim. Compression** in the animation import
    settings window to save memory.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最佳实践是在动画导入设置窗口中将**动画压缩**设置为以节省内存。
- en: '![](img/Figure_4.58_B17146.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.58_B17146.jpg)'
- en: Figure 4.58 – Anim. Compression
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.58 – 动画压缩
- en: By setting it to **Keyframe Reduction**, Unity will reduce keyframes on import
    and compress keyframes when storing animations in files. If it is set to **Optimal**,
    Unity will decide how to compress, either by reducing keyframes or by using a
    dense format.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其设置为**关键帧减少**，Unity 将在导入时减少关键帧，并在将动画存储在文件中时压缩关键帧。如果设置为**最优**，Unity 将决定如何压缩，无论是通过减少关键帧还是使用密集格式。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by introducing some of the most important concepts
    of the Unity animation system, such as Animation Clips, Animator Controllers,
    Avatar, and the Animator component. Then, we demonstrated how to implement 3D
    animation in Unity, including how to import animation assets into the Unity Editor,
    how to create an Animation Event on an Animation Clip, how to set up animation
    parameters to control an animation via C# code, and so on.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了 Unity 动画系统的一些最重要的概念，例如动画剪辑、动画控制器、Avatar 和动画组件。然后，我们演示了如何在 Unity
    中实现 3D 动画，包括如何将动画资产导入 Unity 编辑器、如何在动画剪辑上创建动画事件、如何设置动画参数通过 C# 代码控制动画等。
- en: We also discussed how to implement 2D animation in Unity. The implementation
    of 2D animation is different from the implementation of 3D animation. A common
    implementation technique for 2D animation is to use Sprite Animations, which are
    Animation Clips that are created for 2D assets.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何在Unity中实现2D动画。2D动画的实现方式与3D动画不同。2D动画的一种常见实现技术是使用精灵动画，这些动画剪辑是为2D资产创建的。
- en: Finally, we explored some best practices for implementing animation in Unity
    to optimize the performance problems caused by the animation system.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了在Unity中实现动画的一些最佳实践，以优化由动画系统引起的性能问题。
- en: In the next chapter, we will learn about the Physics system in Unity, and at
    the same time, we will also introduce how to optimize Physics performance in Unity.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Unity中的物理系统，同时，我们也会介绍如何在Unity中优化物理性能。
