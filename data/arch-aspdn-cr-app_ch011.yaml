- en: 10 Logging patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 日志模式
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“EARLY ACCESS SUBSCRIPTION”下找到“architecting-aspnet-core-apps-3e”频道）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file46.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file46.png)'
- en: 'This chapter covers a .NET-specific feature and closes the *Designing for ASP.NET
    Core* section. The logging feature that comes with a few patterns is another building
    block that most applications need: built-in ASP.NET Core. We explore the system
    hands-on while not trying to master every aspect.Logging is a crucial aspect of
    application development and serves various purposes, such as debugging errors,
    tracing operations, analyzing usage, and more.The logging abstractions we explore
    here are another improvement of .NET Core over .NET Framework. Instead of relying
    on third-party libraries, the new, uniform system offers clean interfaces backed
    by a flexible and robust mechanism that helps implement logging into our applications.At
    the end of this chapter, you will understand what logging is and how to write
    application logs.In this chapter, we cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了.NET特定的功能，并结束了*为ASP.NET Core设计*部分。带有一些模式的日志功能是大多数应用程序需要的另一个构建块：内置的ASP.NET
    Core。我们在不试图掌握每个方面的同时，亲手探索这个系统。日志是应用程序开发的一个关键方面，它服务于各种目的，如调试错误、跟踪操作、分析使用情况等。我们在这里探索的日志抽象是.NET
    Core相对于.NET Framework的另一个改进。我们不再依赖于第三方库，新的统一系统提供了一个清洁的接口，由一个灵活且健壮的机制支持，这有助于将日志集成到我们的应用程序中。在本章结束时，你将了解什么是日志以及如何编写应用程序日志。在本章中，我们将涵盖以下主题：
- en: About logging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于日志
- en: Writing logs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写日志
- en: Log levels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志级别
- en: Logging providers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志提供者
- en: Configuring logging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置日志
- en: Structured logging
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化日志
- en: Let’s start by exploring what logging is.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来探索一下什么是日志。
- en: About logging
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于日志
- en: Logging is the practice of writing messages into a log and cataloging information
    for later use. That information can be used to debug errors, trace operations,
    analyze usage, or any other reason we can come up with. Logging is a cross-cutting
    concern, meaning it applies to every piece of your application. We talk about
    layers in *Chapter 14*, *Layering and Clean Architecture*, but until then, let’s
    just say that a cross-cutting concern affects all layers and cannot be centralized
    in just one; it affects a bit of everything.A log is made up of log entries. We
    can view each log entry as an event that happened during the program’s execution.
    Those events are then written to the log. This log can be a file, a remote system,
    `stdout`, or a combination of multiple destinations.When creating a log entry,
    we must also think about the severity of that log entry. In a way, this severity
    level represents the type of message or the level of importance that we want to
    log. We can also use it to filter those logs. `Trace`, `Error`, and `Debug` are
    examples of log entry levels. Those levels are defined in the `Microsoft.Extensions.Logging.LogLevel`
    enum.Another important aspect of a log entry is how it is structured. You can
    log a single string. Everyone on your team could log single strings in their own
    way. But what happens when someone searches for information? Chaos ensues! There’s
    the stress of not finding what that person is looking for and the displeasure
    of the log’s structure, as experienced by that same person. One way to fix this
    is by using structured logging. It is simple yet complex; you must create a structure
    the program follows for all log entries. That structure could be more or less
    complex or be serialized into JSON. The important part is that the log entries
    are structured. We won’t get into this subject here, but if you must decide on
    a logging strategy, I recommend digging into structured logging first. If you
    are part of a team, then chances are someone else already did. If that’s not the
    case, you can always bring it up. Continuous improvement is a key aspect of life.We
    could write a whole book on logging, best logging practices, structured logging,
    and distributed tracing, but this chapter aims to teach you how to use .NET logging
    abstractions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志是将消息写入日志并编制信息以备后用的实践。这些信息可以用于调试错误、追踪操作、分析使用情况或任何我们可以想到的其他原因。日志记录是一个横切关注点，这意味着它适用于你应用程序的每一部分。我们在*第14章*，*分层与清洁架构*中讨论了层，但在此之前，我们只需说横切关注点影响所有层，不能仅集中在一个层；它影响了一切。日志由日志条目组成。我们可以将每个日志条目视为程序执行期间发生的事件。这些事件随后被写入日志。这个日志可以是文件、远程系统、`stdout`或多个目的地的组合。在创建日志条目时，我们还必须考虑该日志条目的严重性。从某种意义上说，这种严重性级别代表了我们要记录的消息类型或重要性的级别。我们还可以用它来过滤这些日志。"跟踪"、"错误"和"调试"是日志条目级别的例子。这些级别在`Microsoft.Extensions.Logging.LogLevel`枚举中定义。日志条目的另一个重要方面是其结构。你可以记录单个字符串。你团队中的每个人都可以以自己的方式记录单个字符串。但当你需要搜索信息时会发生什么？混乱随之而来！有找不到那个人正在寻找的东西的压力，以及同样的人体验到的日志结构的令人不快。解决这个问题的一种方法是通过使用结构化日志记录。它简单而又复杂；你必须为所有日志条目创建一个程序遵循的结构。这个结构可能更复杂或更简单，或者可以序列化为JSON。重要的是日志条目是有结构的。我们不会在这里深入探讨这个主题，但如果你必须决定日志策略，我建议首先深入了解结构化日志记录。如果你是团队的一员，那么很可能会有人已经做了。如果不是这样，你总是可以提出这个话题。持续改进是生活的一个关键方面。我们本可以写一本关于日志、最佳日志实践、结构化日志记录和分布式跟踪的书，但本章旨在教你如何使用.NET日志抽象。
- en: Writing logs
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写日志
- en: 'First, the logging system is provider-based, meaning we must register one or
    more `ILoggerProvider` instances if we want our log entries to go somewhere. By
    default, when calling `WebApplication.CreateBuilder(args)`, it registers the Console,
    Debug, EventSource, and EventLog (Windows only) providers, but we can modify this
    list. You can add and remove providers if you need to. The required dependencies
    for using the logging system are also registered as part of this process.Before
    we look at the code, let’s learn how to create log entries, which is the objective
    behind logging. To create an entry, we can use one of the following interfaces:
    `ILogger`, `ILogger<T>`, or `ILoggerFactory`. Let’s take a look at them in more
    detail:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，日志系统是基于提供程序的，这意味着如果我们想让我们的日志条目有地方记录，我们必须注册一个或多个 `ILoggerProvider` 实例。默认情况下，当调用
    `WebApplication.CreateBuilder(args)` 时，它会注册控制台、调试、事件源和事件日志（仅限 Windows）提供程序，但我们可以修改这个列表。如果需要，您可以添加和删除提供程序。使用日志系统的必需依赖项也作为此过程的一部分进行注册。在我们查看代码之前，让我们学习如何创建日志条目，这是日志记录的目标。要创建条目，我们可以使用以下接口之一：`ILogger`、`ILogger<T>`
    或 `ILoggerFactory`。让我们更详细地看看它们：
- en: '| **Interface** | **Description** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **接口** | **描述** |'
- en: '| `ILogger` | Base type that allows us to perform logging operations. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `ILogger` | 允许我们执行日志记录操作的基本类型。|'
- en: '| `ILogger<T>` | Base type that allows us to perform logging operations. Inherit
    from the ILogger interface. The system uses the generic parameter `T` as the log
    entry’s *category* . |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `ILogger<T>` | 允许我们执行日志记录操作的基本类型。从 `ILogger` 接口继承。系统使用泛型参数 `T` 作为日志条目的 *类别*。|'
- en: '| `ILoggerFactory` | A factory interface that allows creating `ILogger` objects
    and specifying the category name manually as a string. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `ILoggerFactory` | 一个允许创建 `ILogger` 对象并手动指定类别名称（作为字符串）的工厂接口。|'
- en: 'Table 10.1: the logging interfaces.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1：日志接口。
- en: 'The following code represents the most commonly used pattern, which consists
    of injecting an `ILogger<T>` interface and storing it in an `ILogger` field before
    using it, like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示最常用的模式，该模式包括注入一个 `ILogger<T>` 接口并将其存储在一个 `ILogger` 字段中，然后再使用它，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding `Service` class has a private `_logger` field. It takes an `ILogger<Service>`
    logger as a parameter and stores it in that field. It uses that field in the `Execute`
    method to write an information-level message to the log.The `IService` interface
    is very simple and only exposes a single `Execute` method for testing purposes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `Service` 类有一个私有 `_logger` 字段。它接受一个 `ILogger<Service>` 日志记录器作为参数并将其存储在该字段中。它使用该字段在
    `Execute` 方法中向日志写入信息级别的消息。《IService》接口非常简单，仅公开一个 `Execute` 方法用于测试目的：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I loaded a small library I created to test this out, providing additional logging
    providers for testing purposes. With that, we are creating a generic host (`IHost`)
    since we don’t need a `WebApplication` in our tests, then we configure it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我加载了一个我创建的小型库来测试这个功能，为测试目的提供了额外的日志提供程序。有了这个，我们创建了一个泛型宿主 (`IHost`)，因为我们不需要在测试中使用
    `WebApplication`，然后我们进行配置：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `Arrange` phase of the test, we create some variables, configure `IHost`,
    and get an instance of the `Service` class that we want to use to test the logging
    capabilities that we programmed.The highlighted code removes all providers using
    the `ClearProviders` method. Then it uses the `AddAssertableLogger` extension
    to add a new provider. The extension method comes from the library that we loaded.
    We could have added a new provider if we wanted, but I wanted to show you how
    to remove existing providers so we can start from a clean slate. That’s something
    you might need someday.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的 `Arrange` 阶段，我们创建了一些变量，配置 `IHost`，并获取我们想要用于测试我们编写的日志功能的 `Service` 类的实例。突出显示的代码使用
    `ClearProviders` 方法删除了所有提供程序。然后它使用 `AddAssertableLogger` 扩展方法添加了一个新的提供程序。扩展方法来自我们加载的库。如果我们想添加一个新的提供程序，我们也可以这样做，但我想要展示如何删除现有的提供程序，这样我们就可以从一张干净的纸开始。这可能是你将来需要的东西。
- en: The library that I loaded is available on NuGet and is named `ForEvolve.Testing.Logging`,
    but you do not need to understand any of this to understand logging abstractions
    and examples.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我加载的库可在 NuGet 上找到，名称为 `ForEvolve.Testing.Logging`，但您不需要理解任何这些内容就能理解日志抽象和示例。
- en: 'In the `Act` phase, we call the `Execute` method of our service. This method
    logs a line to the `ILogger` implementation that is injected upon instantiation.
    Then, we assert that the line was written in the `lines` list (that’s what `AssertableLogger`
    does; it writes to a `List<string>`). In an ASP.NET Core application, all that
    logging goes to the console by default. Logging is a great way to know what is
    happening in the background when running the application.The `Service` class is
    a simple consumer of an `ILogger<Service>`. You can do the same for any class
    you want to add logging support to. Change `Service` by that class name to have
    a logger configured for your class. That generic argument becomes the logger''s
    category name when writing log entries.Since ASP.NET Core uses a `WebApplication`
    instead of a generic `IHost`, here is the same test code using that construct:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Act`阶段，我们调用我们服务的`Execute`方法。该方法将一行记录到在实例化时注入的`ILogger`实现中。然后，我们断言该行被写入到`lines`列表中（这就是`AssertableLogger`的作用；它将内容写入到`List<string>`）。在ASP.NET
    Core应用程序中，所有这些日志默认都会输出到控制台。日志记录是了解应用程序运行时后台发生情况的好方法。《Service》类是一个简单的`ILogger<Service>`消费者。你可以为任何你想添加日志支持的类做同样的事情。通过将`Service`替换为那个类名来为你的类配置一个日志记录器。这个泛型参数成为写入日志条目时的日志记录器类别名称。由于ASP.NET
    Core使用`WebApplication`而不是通用`IHost`，以下是使用该结构的相同测试代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I highlighted the changes in the preceding code. In a nutshell, the extension
    methods used on the generic host have been replaced by `WebApplicationBuilder`
    properties like `Logging` and `Services`. Finally, the `Create` method creates
    a `WebApplication` instead of an `IHost`, exactly like in the `Program.cs` file.To
    wrap this up, these test cases allowed us to implement the most commonly used
    logging pattern in ASP.NET Core and add a custom provider to ensure we logged
    the correct information. Logging is essential and adds visibility to production
    systems. Without logs, you don’t know what is happening in your system unless
    you are the only one using it, which is very unlikely. You can also log what is
    happening in your infrastructure and run real-time security analysis on those
    log streams to quickly identify security breaches, intrusion attempts, or system
    failures. These subjects are out of the scope of this book, but having strong
    logging capabilities at the application level can only help your overall logging
    strategy.Before moving on to the next subject, let’s explore an example that leverages
    the `ILoggerFactory` interface. The code sets a custom category name and uses
    the created `ILogger` instance to log a message. This is very similar to the previous
    example. Here’s the whole code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前面代码中高亮显示了变更。简而言之，在通用宿主上使用的扩展方法已经被`WebApplicationBuilder`的属性如`Logging`和`Services`所替代。最后，`Create`方法创建了一个`WebApplication`而不是`IHost`，这与`Program.cs`文件中的情况完全一样。总结来说，这些测试案例使我们能够实现ASP.NET
    Core中最常用的日志记录模式，并添加一个自定义提供程序以确保我们记录了正确的信息。日志记录是必不可少的，它为生产系统提供了可见性。除非你是唯一使用系统的人，否则没有日志，你不知道系统中发生了什么，这是非常不可能的。你还可以记录基础设施中发生的事情，并对这些日志流进行实时安全分析，以快速识别安全漏洞、入侵尝试或系统故障。这些主题超出了本书的范围，但拥有强大的应用程序级日志记录能力只能有助于你的整体日志记录策略。在继续下一个主题之前，让我们探索一个利用`ILoggerFactory`接口的示例。代码设置了一个自定义类别名称，并使用创建的`ILogger`实例记录一条消息。这与前面的例子非常相似。以下是整个代码：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code should look very familiar. Let’s focus on the highlighted
    lines, which relate to the current pattern:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该看起来非常熟悉。让我们关注高亮显示的行，它们与当前模式相关：
- en: We inject the `ILoggerFactory` interface into the `Service` class constructor
    (instead of an `ILogger<Service>`).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`ILoggerFactory`接口注入到`Service`类的构造函数中（而不是`ILogger<Service>`）。
- en: We create an `ILogger` instance with the `"` `My Service"` category name.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`"` `My Service"`这个类别名称创建了一个`ILogger`实例。
- en: We assign the logger to the `_logger` field.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将日志记录器分配给`_logger`字段。
- en: We then use that `ILogger` from the `Execute` method.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`Execute`方法中使用那个`ILogger`。
- en: As a rule of thumb, I recommend using the `ILogger<T>` interface by default.
    If impossible, or if you need a more dynamic way of setting the category name
    for your log entries, leverage the `ILoggerFactory` instead. By default, when
    using `ILogger<T>`, the category name is the T parameter, which should be the
    name of the class creating log entries. The `ILoggerFactory` interface is more
    of an internal piece than something made for us to consume; nonetheless, it exists
    and satisfies some use cases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项经验法则，我建议默认使用 `ILogger<T>` 接口。如果不可能，或者如果您需要为日志条目设置更动态的类别名称，则利用 `ILoggerFactory`。默认情况下，使用
    `ILogger<T>` 时，类别名称是 T 参数，应该是创建日志条目的类的名称。`ILoggerFactory` 接口更像是内部组件，而不是为我们消费的组件；尽管如此，它存在并满足某些用例。
- en: '**Note**'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the preceding example, the `ITestOutputHelper` interface is part of the `Xunit.Abstractions`
    assembly. It allows us to write lines as *standard output* to the test log. That
    output is available in the Visual Studio Test Explorer.
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在前面的示例中，`ITestOutputHelper` 接口是 `Xunit.Abstractions` 集合的一部分。它允许我们将行作为 *标准输出*
    写入测试日志。该输出在 Visual Studio 测试资源管理器中可用。
- en: Now that we have covered how to write log entries, it's time to learn how to
    manage their severity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何编写日志条目，现在是时候学习如何管理它们的严重性了。
- en: Log levels
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志级别
- en: 'In the previous examples, we used the `LogInformation` method to log information
    messages, but there are other levels as well, shown in the following table:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `LogInformation` 方法来记录信息消息，但还有其他级别，如下表所示：
- en: '| **Level** | **Method** | **Description** | **Production** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **方法** | **描述** | **生产** |'
- en: '| Trace | `LogTrace` | This is used to capture detailed information about the
    program, instrument execution speed, and debugging. You can also log sensitive
    information when using traces. | Disabled. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 跟踪 | `LogTrace` | 这用于捕获有关程序、执行速度和调试的详细信息。您还可以在跟踪时记录敏感信息。 | 禁用。|'
- en: '| Debug | `LogDebug` | This is used to log debugging and development information.
    | Disabled unless troubleshooting. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | `LogDebug` | 这用于记录调试和开发信息。 | 除非故障排除，否则禁用。|'
- en: '| Information | `LogInformation` | This is used to track the flow of the application.
    Normal events that occur in the system are often information-level events, such
    as the system started, the system stopped, and a user has signed in. | Enabled.
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 信息 | `LogInformation` | 这用于跟踪应用程序的流程。系统中发生的正常事件通常是信息级别的事件，例如系统启动、系统停止和用户登录。
    | 启用。|'
- en: '| Warning | `LogWarning` | This is used to log abnormal behavior in the application
    flow that does not cause the program to stop, but that may need to be investigated;
    for example, handled exceptions, failed network calls, and accessing resources
    that do not exist. | Enabled. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 警告 | `LogWarning` | 这用于记录应用程序流程中的异常行为，不会导致程序停止，但可能需要调查；例如，已处理的异常、失败的网络调用和访问不存在的资源。
    | 启用。|'
- en: '| Error | `LogError` | This is used to log errors in the application flow that
    do not cause the application to stop. Errors must usually be investigated. Examples
    include the failure of the current operation and an exception that cannot be handled.
    | Enabled. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | `LogError` | 这用于记录应用程序流程中的错误，不会导致应用程序停止。错误通常必须进行调查。例如，当前操作失败和无法处理的异常。
    | 启用。|'
- en: '| Critical | `LogCritical` | This is used to log errors that require immediate
    attention and represent a catastrophic state. The program is most likely about
    to stop, and the integrity of the application might be compromised; for example,
    a hard drive is full, the server is out of memory, or the database is in a deadlocked
    state. | Enabled with some alerts that could be configured to trigger automatically.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 严重 | `LogCritical` | 这用于记录需要立即注意的错误，表示灾难性状态。程序很可能会停止，应用程序的完整性可能受到损害；例如，硬盘已满，服务器内存不足，或数据库处于死锁状态。
    | 启用，某些警报可以配置为自动触发。|'
- en: 'Table 10.2: log entry levels'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2：日志条目级别
- en: 'As described in the preceding table, each log level serves one or more purposes.
    Those log levels tell the logger what severity a log entry is. Then, we can configure
    the system to log only entries of at least a certain level so we don’t fill out
    production logs with traces and debug entries, for example. In a project I led,
    we benchmarked multiple ways to log simple and complex messages using ASP.NET
    Core to build clear and optimized guidelines around that. We could not reach a
    fair conclusion when the messages were logged due to a large time variance between
    benchmark runs. However, we observed a constant trend when messages were not logged
    (*trace* logs with the minimum logging level configured to *debug*, for example).Based
    on that conclusion, I recommend logging the `Trace` and `Debug` messages using
    the following construct instead of interpolation, `string.Format`, or other means.
    That may sound strange to optimize for *not logging something*, but if you think
    about it, those log entries will be skipped in production, so optimizing them
    will save your production app a few milliseconds of computing time here and there.
    Moreover, it''s not harder or longer to do, so it''s just a good habit.Let’s look
    at the fastest way to *not write log entries*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所述，每个日志级别都服务于一个或多个目的。这些日志级别告诉记录器日志条目的严重性。然后，我们可以配置系统只记录至少达到一定级别的条目，例如，不要在生产日志中填充跟踪和调试条目。在我领导的项目中，我们使用ASP.NET
    Core对记录简单和复杂消息的多种方法进行了基准测试，以围绕这一点建立清晰和优化的指南。当消息被记录时，由于基准测试运行之间的大时间差异，我们无法得出公平的结论。然而，当消息没有被记录时（例如，配置了最小日志级别为*debug*的*trace*日志），我们观察到一种恒定的趋势。基于这个结论，我建议使用以下结构而不是插值、`string.Format`或其他方式来记录`Trace`和`Debug`消息。这可能听起来很奇怪，为了优化“不记录某些内容”，但如果你这么想，这些日志条目将在生产中被跳过，因此优化它们将节省你的生产应用在这里和那里的一些毫秒计算时间。此外，这并不更难或更耗时，所以这只是一个好习惯。让我们看看不写入日志条目的最快方式：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the log level is disabled, such as in production, you only pay the price
    of a method call because no processing is done on your log entries. On the other
    hand, if we use interpolation, the processing is done, so that one argument is
    passed to the `Log[Level]` method, leading to a higher cost in processing power
    for each log entry.Here’s an example of interpolation (a.k.a. what not to do):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当日志级别被禁用时，例如在生产环境中，你只需支付方法调用的代价，因为你的日志条目没有进行任何处理。另一方面，如果我们使用插值，则会进行处理，因此一个参数被传递给`Log[Level]`方法，导致每个日志条目的处理能力成本更高。以下是一个插值的例子（也就是不要这样做）：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For warning and higher levels, you can keep the good habit and use the same
    technique or other methods because we know those lines will be logged anyway.
    Therefore, using interpolation in the code or letting the logger do it later should
    yield a similar result.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于警告及以上级别，你可以保持良好的习惯，使用相同的技巧或其他方法，因为我们知道这些行无论如何都会被记录。因此，在代码中使用插值或让记录器稍后执行应该会产生类似的结果。
- en: One last note. I suggest you don’t try to over-optimize your code before there
    is a need for that. The action of investing a lot of effort in optimizing something
    that does not need optimizing is known as **premature optimization**. The idea
    is to optimize just enough upfront and fix the performance when you find real
    issues.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一点。我建议在真正需要之前不要试图过度优化你的代码。在不需要优化的东西上投入大量精力进行优化的行为被称为**过早优化**。理念是提前优化到足够的程度，并在发现真正的问题时修复性能。
- en: Now that we know the log levels that .NET offers us, let’s look at the logging
    providers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了.NET为我们提供的日志级别，让我们来看看日志提供程序。
- en: Logging providers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志提供程序
- en: 'To give you an idea of the possible built-in logging providers, here is a list
    from the official documentation (see the *Further reading* section at the end
    of this chapter):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解可能的内置日志提供程序，以下是官方文档中的一个列表（请参阅本章末尾的*进一步阅读*部分）：
- en: Console
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Console
- en: Debug
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debug
- en: EventSource
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EventSource
- en: EventLog (Windows only)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EventLog（仅限Windows）
- en: ApplicationInsights
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ApplicationInsights
- en: 'The following is a list of third-party logging providers, also from the official
    documentation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个第三方日志提供程序的列表，也来自官方文档：
- en: elmah.io
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: elmah.io
- en: Gelf
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gelf
- en: JSNLog
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSNLog
- en: KissLog.net
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KissLog.net
- en: Log4Net
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Log4Net
- en: NLog
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NLog
- en: PLogger
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLogger
- en: Sentry
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sentry
- en: Serilog
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serilog
- en: Stackdriver
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stackdriver
- en: Now, if you need any of those or your favorite logging library is part of the
    preceding list, you know you can use it. If it is not, maybe it supports ASP.NET
    Core but was not part of the documentation when I consulted it.Next, let’s learn
    how to configure the logging system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你需要这些中的任何一个，或者你喜欢的日志库是前面列表的一部分，你知道你可以使用它。如果不是，也许它支持ASP.NET Core，但在咨询时它并未包含在文档中。接下来，让我们学习如何配置日志系统。
- en: Configuring logging
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置日志记录
- en: 'As with most features of ASP.NET Core, we can configure logging. The default
    `WebApplicationBuilder` that do a lot for us, but in case we want to tweak the
    defaults, we can. On top of that, the system loads the `Logging` section of the
    configuration. That section is present, by default, in the `appsettings.json`
    file. Like all configurations, it is cumulative, so we can redefine part of it
    in another file or configuration provider.We won’t dig too deep into customization,
    but it is good to know that we can customize the minimum level of what we are
    logging. We can also use transformation files (such as `appsettings.Development.json`)
    to customize those levels per environment.For example, we can define our defaults
    in `appsettings.json`, then update a few for development purposes in `appsettings.Development.json`,
    change production settings in `appsettings.Production.json`, then change the staging
    settings in `appsettings.Staging.json`, and add some testing settings in `appsettings.Testing.json`.Before
    we move on, let’s take a peek at the default settings:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与ASP.NET Core的大多数功能一样，我们可以配置日志记录。默认的`WebApplicationBuilder`为我们做了很多工作，但如果我们想调整默认设置，我们也可以做到。除此之外，系统会加载配置中的`Logging`部分。该部分默认存在于`appsettings.json`文件中。像所有配置一样，它是累积的，因此我们可以在另一个文件或配置提供者中重新定义其部分。我们不会深入探讨自定义，但了解我们可以自定义我们记录的最小日志级别是很好的。我们还可以使用转换文件（如`appsettings.Development.json`）来根据环境自定义这些级别。例如，我们可以在`appsettings.json`中定义默认设置，然后在`appsettings.Development.json`中更新一些用于开发目的的设置，在`appsettings.Production.json`中更改生产设置，然后在`appsettings.Staging.json`中更改预发布设置，最后在`appsettings.Testing.json`中添加一些测试设置。在我们继续之前，让我们看一下默认设置：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can define default levels (using `Logging:LogLevel:Default`) and a custom
    level for each category (such as `Logging:LogLevel:Microsoft`) representing base
    namespaces. For example, from that configuration file, the minimum level is `Information`,
    while every item part of the `Microsoft` or `Microsoft.*` namespaces have a minimum
    level of `Warning`. That allows for removing noise when running the application.
    We can also leverage these configurations to debug certain parts of the application
    by lowering the log level to `Debug` or `Trace` for only a subset of items (items
    from one or more namespaces, for example).We can also filter what we want to log
    on a provider basis, using configuration or code. In the configuration file, we
    can change the default level of the console provider to `Trace`, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义默认级别（使用`Logging:LogLevel:Default`）和每个类别（例如`Logging:LogLevel:Microsoft`）的自定义级别，代表基本命名空间。例如，从该配置文件中，最小级别是`Information`，而属于`Microsoft`或`Microsoft.*`命名空间的每个项目都有最小级别为`Warning`。这允许在运行应用程序时移除噪音。我们还可以利用这些配置通过降低日志级别到`Debug`或`Trace`来调试应用程序的某些部分，仅针对项目子集（例如来自一个或多个命名空间的项目）。我们还可以根据提供者基础使用配置或代码来过滤我们想要记录的内容。在配置文件中，我们可以将控制台提供者的默认级别更改为`Trace`，如下所示：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We kept the same default values but added the `Logging:Console` section (see
    highlighted code) with a default `LogLevel` set to `Trace`. We can define as many
    settings as we need.Instead of configurations, we can use the `AddFilter` extension
    methods, as shown in the following experimental test code, or in conjunction with
    configurations.Here is the consumer class that logs data:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了相同的默认值，但添加了`Logging:Console`部分（见高亮代码），并将默认`LogLevel`设置为`Trace`。我们可以定义我们需要的任何设置。而不是配置，我们可以使用`AddFilter`扩展方法，如下面的实验测试代码所示，或者与配置一起使用。以下是记录数据的消费者类：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding class is like other classes we used during the chapter but logs
    messages using two different levels: `Information` and `Warning`. Here is a test
    case in which we leverage the `AddFilter` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类与其他我们在本章中使用的类类似，但使用两种不同的级别记录消息：`Information`和`Warning`。以下是一个测试用例，其中我们利用了`AddFilter`方法：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We created a generic host in the preceding test code and added three providers:
    the console and two test providers—one that logs to a list and another to the
    xUnit output. Then, we told the system to filter out everything that is not at
    least a `Warning` from `XunitTestOutputLoggerProvider` (see highlighted code);
    other providers are unaffected by that code.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试代码中，我们创建了一个通用主机并添加了三个提供者：控制台和两个测试提供者——一个将日志记录到列表中，另一个记录到 xUnit 输出。然后，我们告诉系统从
    `XunitTestOutputLoggerProvider` 中过滤掉所有至少不是 `Warning` 级别的日志（见高亮代码）；其他提供者不受该代码的影响。
- en: In the code, the `_output` member is a field of type `ITestOutputHelper`.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在代码中，`_output` 成员是 `ITestOutputHelper` 类型的字段。
- en: 'We now know of two options to set the minimum logging levels:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道有两种设置最小日志级别的选项：
- en: Code
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码
- en: Configuration
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: We can tweak the way we configure our logging policies as needed. Code can be
    more testable, while configurations can be updated at runtime without redeploying.
    Moreover, with the cascading model, which allows us to override configuration,
    we can cover most use cases using configurations. The biggest downside of configuration
    is that writing strings in a JSON file is more error-prone than writing code (assuming
    you are not reverting to using strings there either).I usually stick with configurations
    to set those values, as they do not change often. If you prefer code, I’m unaware
    of any drawbacks, and it’s just a matter of preference; the configuration becomes
    code at some point.Next, let’s look at a brief example of structured logging.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要调整配置日志策略的方式。代码可以更容易地进行测试，而配置可以在运行时更新，无需重新部署。此外，使用级联模型，该模型允许我们覆盖配置，我们可以使用配置覆盖大多数用例。配置的最大缺点是，在
    JSON 文件中编写字符串比编写代码更容易出错（假设你也没有退回到使用字符串）。我通常坚持使用配置来设置这些值，因为它们不经常改变。如果你更喜欢代码，我不知道有任何缺点，这只是个人偏好的问题；配置在某个时刻变成了代码。接下来，让我们看看结构化日志的一个简要示例。
- en: Structured logging
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化日志
- en: 'As stated at the beginning, structured logging can become very important and
    open opportunities. Querying a data structure is always more versatile than querying
    a single line of text. That is even more true if there is no clear guideline around
    logging, whether a line of text or a JSON-formatted data structure.To keep it
    simple, we leverage a built-in formatter (highlighted line below) that serializes
    our log entries into JSON. Here is the `Program.cs` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如开头所述，结构化日志可以变得非常重要，并开辟了机会。查询数据结构始终比查询单行文本更灵活。如果没有关于日志的明确指南，无论是文本行还是 JSON 格式的数据结构，这一点尤其正确。为了保持简单，我们利用一个内置的格式化器（以下高亮行所示），将我们的日志条目序列化为
    JSON。以下是 `Program.cs` 文件：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That transforms the console to logging JSON. For example, every time we hit
    the `/` endpoint, the console displays the following JSON:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将控制台转换为记录 JSON。例如，每次我们点击 `/` 端点时，控制台会显示以下 JSON：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Without that formatter, the usual output would have been:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 没有那个格式化器，通常的输出会是：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Based on that comparison, it is more versatile to query the JSON logs programmatically
    than the `stdout` line.The biggest benefit of structured logging is improved searchability.
    You can run more precise queries at scale with a predefined data structure.Of
    course, if you are setting up a production system, you would probably want more
    information attached to such log items like the correlation ID of the request,
    optionally some information about the current user, the server’s name on which
    the code is running, and possibly more details depending on the application.You
    may need more than the out-of-the-box features to utilize structured logging fully.
    Some third-party libraries like Serilog offer those additional capabilities. However,
    defining the way to send plain text to the logger could be a start.Each project
    should dictate the needs and depth of each feature, including logging. Moreover,
    structured logging is a broader subject that merits studying independently. Nonetheless,
    I wanted to touch on this subject a bit, and hopefully, you learned enough about
    logging to get started.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种比较，程序化查询 JSON 日志比查询 `stdout` 行更加灵活。结构化日志的最大好处是提高了可搜索性。您可以使用预定义的数据结构进行更精确的查询。当然，如果您正在设置生产系统，您可能希望将更多信息附加到这些日志项上，例如请求的相关
    ID、可选的当前用户信息、运行代码的服务器名称，以及根据应用程序可能需要更多详细信息。您可能需要比开箱即用的功能更多，以充分利用结构化日志。一些第三方库，如
    Serilog，提供了这些附加功能。然而，定义将纯文本发送到日志记录器的方式可能是一个起点。每个项目都应该规定每个功能的需求和深度，包括日志记录。此外，结构化日志是一个更广泛的主题，值得独立研究。尽管如此，我还是想简要地谈谈这个主题，并希望您已经学到了足够多的关于日志记录的知识，以便开始实践。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we delved into the concept of logging. We learned that logging
    is the practice of recording messages into a log for later use, such as debugging
    errors, tracing operations, and analyzing usage. Logging is essential, and ASP.NET
    Core offers us various ways to log information independently of third-party libraries
    while allowing us to use our favorite logging framework. We can customize the
    way the logs are written and categorized. We can use zero or more logging providers.
    We can also create custom logging providers. Finally, we can use configurations
    or code to filter logs and much more.Here is the default logging pattern to remember:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了日志记录的概念。我们了解到，日志记录是将消息记录到日志中以供以后使用的一种实践，例如调试错误、跟踪操作和分析使用情况。日志记录是必不可少的，ASP.NET
    Core 提供了各种方式来记录信息，而无需使用第三方库，同时允许我们使用我们喜欢的日志框架。我们可以自定义日志的编写和分类方式。我们可以使用零个或多个日志提供程序。我们还可以创建自定义日志提供程序。最后，我们可以使用配置或代码来过滤日志以及更多内容。以下是需要记住的默认日志模式：
- en: Inject an `ILogger<T>`, where `T` is the type of the class into which the logger
    is injected. `T` becomes the category.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入一个 `ILogger<T>`，其中 `T` 是注入日志记录器的类的类型。`T` 成为类别。
- en: Save a reference of that logger into a `private readonly ILogger` field.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该日志记录器的引用保存到 `private readonly ILogger` 字段中。
- en: Use that logger in your methods to log messages using the appropriate log level.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的函数中使用该日志记录器，使用适当的日志级别记录消息。
- en: 'The logging system is a great addition to .NET Core compared to .NET Framework.
    It allows us to standardize the logging mechanism, making our systems easier to
    maintain in the long run. For example, suppose you want to use a new third-party
    library or even a custom-made one. In that case, you can load the provider into
    your `Program`, and the entire system will adapt and start using it without any
    further changes as long as you depend only on the logging abstractions. This is
    a good example of what well-designed abstractions can bring to a system.**Here
    are a few key takeaways**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与 .NET Framework 相比，日志系统是 .NET Core 的一个很好的补充。它允许我们标准化日志机制，使我们的系统在长期内更容易维护。例如，如果您想使用一个新的第三方库，甚至是一个定制的库，您可以将提供程序加载到您的
    `Program` 中，只要您只依赖于日志抽象，整个系统就会适应并开始使用它，而无需进行任何进一步的更改。这是一个很好的例子，说明了精心设计的抽象可以为系统带来什么。**以下是一些关键要点**：
- en: Logging is a cross-cutting concern, affecting all layers of an application.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录是一个横切关注点，影响应用程序的所有层。
- en: A log comprises many log entries representing an event that occurred at runtime
    during the program's execution.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录包含许多日志条目，这些条目代表程序执行期间运行时发生的事件。
- en: The severity of a log entry is important for filtering and prioritization.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志条目的严重性对于过滤和优先级排序非常重要。
- en: The severity levels are Trace, Debug, Information, Warning, Error, and Critical.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严重级别包括 Trace、Debug、Information、Warning、Error 和 Critical。
- en: We can configure the logging system to log only certain messages based on the
    severity level of each entry.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以配置日志系统，使其仅根据每个条目的严重级别记录某些消息。
- en: Structured logging can help maintain consistency and ease of searching within
    logs.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化日志可以帮助在日志中保持一致性，并简化搜索。
- en: The logging system in .NET is provider-based, allowing us to customize the default
    providers.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET中的日志系统是基于提供者的，这允许我们自定义默认提供者。
- en: We can use interfaces like ILogger, ILogger<T>, or ILoggerFactory to create
    log entries.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`ILogger`、`ILogger<T>`或`ILoggerFactory`等接口来创建日志条目。
- en: This chapter closes the second section of this book with ASP.NET Core at its
    center. We explore design patterns to create flexible and robust components in
    the next few chapters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以ASP.NET Core为中心，结束了本书的第二部分。在接下来的几章中，我们将探讨设计模式，以创建灵活且健壮的组件。
- en: Questions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: Can we write log entries to the console and a file at the same time?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否同时将日志条目写入控制台和文件？
- en: Is it true that we should log the trace- and debug-level log entries in a production
    environment?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中，我们应该记录跟踪和调试级别的日志条目吗？
- en: What is the purpose of structured logging?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构化日志的目的是什么？
- en: How can we create a log entry in .NET?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在.NET中创建日志条目？
- en: Further reading
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here is a link to build upon what we learned in the chapter:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个链接，可以基于我们在本章中学到的内容进行构建：
- en: '[Official docs] *Logging in .NET Core and ASP.NET Core*: [https://adpg.link/MUVG](https://adpg.link/MUVG)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[官方文档] *在.NET Core和ASP.NET Core中的日志记录*: [https://adpg.link/MUVG](https://adpg.link/MUVG)'
- en: Answers
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: Yes, you can configure as many providers as you want. One could be for the console,
    and another could append entries to a file.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，你可以配置你想要的任何数量的提供者。一个可以用于控制台，另一个可以将条目追加到文件中。
- en: No, you should not log trace-level entries in production. You should only log
    debug-level entries when debugging an issue.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，在生产环境中你不应该记录跟踪级别的条目。当你调试问题时，你应该只记录调试级别的条目。
- en: Structured logging maintains a consistent structure across all log entries,
    making searching and analyzing logs easier.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构化日志在所有日志条目中保持一致的结构，这使得搜索和分析日志更加容易。
- en: We can create a log entry using interfaces like `ILogger`, `ILogger<T>`, and
    `ILoggerFactory`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`ILogger`、`ILogger<T>`和`ILoggerFactory`等接口来创建日志条目。
