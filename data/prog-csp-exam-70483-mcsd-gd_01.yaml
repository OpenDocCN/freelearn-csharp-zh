- en: Learning the Basics of C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习C#的基础知识
- en: In simple terms, programming is the art of writing a set of commands that instruct
    a computer to execute a particular task. In the early days, programming capabilities
    were limited due to memory and speed restrictions. Due to this, programmers wrote
    crude and simple tasks that did elementary jobs. With time and with more enhancements,
    people started writing programs in procedural languages such as COBOL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，编程是编写一组指令的艺术，这些指令指示计算机执行特定任务。在早期，由于内存和速度的限制，编程能力有限。因此，程序员编写了粗糙且简单的任务，执行基本工作。随着时间的推移和更多的增强，人们开始用过程式语言（如COBOL）编写程序。
- en: Although the languages did the work, the programs had some limitations. There
    was not much scope for writing reusable components or design patterns that could
    be used in different places in the application. Hence, the applications were difficult
    to maintain and scalability was a challenge.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管语言完成了工作，但程序仍有一些局限性。在应用程序的不同地方编写可重用组件或设计模式的空间不大。因此，应用程序难以维护，可扩展性也是一个挑战。
- en: As a result, efforts were made to develop high-level programming languages that
    could overcome all such challenges faced by procedural languages. With time, many
    different programming languages were devised. C was developed between 1972 and
    1973\. At the time, it was a low-level procedural language that depended upon
    the underlying platform, such as Linux or Windows. C also did not fully utilize
    the concept of object-oriented programming (which we will go through in [Chapter
    3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml), *Understanding Object-Oriented
    Programming)*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，人们努力开发高级编程语言，以克服过程式语言面临的所有这些挑战。随着时间的推移，设计了许多不同的编程语言。C是在1972年至1973年之间开发的。当时，它是一种低级的过程式语言，依赖于底层平台，如Linux或Windows。C也没有完全利用面向对象编程的概念（我们将在第3章中介绍，*理解面向对象编程*）。
- en: C++ was introduced in 1998, and provided programmers with the ability to effectively
    use the concepts of object-oriented programming while still retaining the machine-level
    programming features provided by C. In this book, we will go through the different
    aspects of programming in C#. While retaining the OOP capabilities of C++, C#
    allows us to write programs independent of the underlying hardware implementation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C++于1998年推出，为程序员提供了在保留C提供的机器级编程功能的同时，有效使用面向对象编程概念的能力。在本书中，我们将探讨C#编程的各个方面。C#保留了C++的OOP功能，使我们能够编写与底层硬件实现无关的程序。
- en: In this chapter, we will go over the basics of C#. We will review its underlying
    fundamentals and dive deep into the .NET Framework architecture. We will learn
    how common language runtime works to translate the application code to machine-level
    code. We will learn how C# is both different and similar to other languages, such
    as C and C++. We will then learn about the different components in a C# program,
    such as classes, namespaces, and assemblies. And, as a common tradition for any
    new language, we will look at the implementation of a `Hello World` program.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍C#的基础知识。我们将回顾其底层基础，并深入探讨.NET Framework架构。我们将学习公共语言运行时如何将应用程序代码转换为机器级代码。我们将了解C#与其他语言，如C和C++的不同之处和相似之处。然后，我们将学习C#程序中的不同组件，如类、命名空间和程序集。作为任何新语言的常见传统，我们将查看`Hello
    World`程序的实现。
- en: 'This chapter consists of the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Comparing C# with C and C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较C#与C和C++
- en: .NET Framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework
- en: .NET Framework release versions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework的发布版本
- en: Visual Studio for C#
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#的Visual Studio
- en: Basic structure of C#
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#的基本结构
- en: Creating a basic program in C#
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中创建一个基本程序
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For a better understanding of the chapter, you require the following knowledge:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解本章，你需要以下知识：
- en: A basic understanding of software development
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对软件开发有基本了解
- en: 'A basic understanding of common programming languages: C, C++ and C#'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对常见编程语言（C、C++和C#）有基本了解
- en: 'For the entirety of this book, we will be going through different code examples
    in C# and will be using Visual Studio 2017 Community Edition for the code examples.
    The following hardware requirements are essential for Visual Studio:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将通过C#的不同代码示例，并使用Visual Studio 2017社区版进行代码示例。以下硬件要求对Visual Studio是必需的：
- en: '**Operating system**:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：'
- en: Windows 10 or higher
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10或更高版本
- en: 'Windows Server 2016: Standard and Datacenter'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Server 2016：Standard和Datacenter
- en: Windows 8.1
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 8.1
- en: 'Windows Server 2012 R2: Essential, Standard, and Datacenter'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Server 2012 R2：Essential、Standard和Datacenter
- en: Windows 7 SP1
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 7 SP1
- en: '**Hardware requirements**:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件要求**：'
- en: Minimum 2 GB of RAM
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小2 GB的RAM
- en: 1.8 GHz or faster processor
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.8 GHz或更快的处理器
- en: '**Additional requirements**:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加要求**:'
- en: Administrative rights of the system
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统管理员权限
- en: .NET Framework 4.5
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework 4.5
- en: '**Visual Studio**: All code examples in this book have been compiled on Visual
    Studio Community Edition 2017\. It''s available for installation at: [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio**：本书中的所有代码示例都是在Visual Studio Community Edition 2017上编译的。它可以在以下网址安装：[https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)。'
- en: Sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter01](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter01).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在GitHub上找到：[https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter01](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter01)。
- en: Comparing C# with C and C++
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较C#与C和C++
- en: In this section, we will explore how C# compares against other programming languages,
    such as C and C++. We will look at aspects that make C# similar, and also areas
    in which it differs from these languages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨C#与其他编程语言（如C和C++）的比较。我们将探讨使C#与这些语言相似和不同的方面。
- en: C# versus C
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 与 C 的比较
- en: 'If you have done some previous development on C# and C , you will realize that
    they follow similar code syntax, such as the use of semi-colons, and similar declarations
    of methods; the two languages are very different from one another. Just like in
    C, we can declare data variables with the same type, such as `Char`, and `Integer`.
    The following features make C# different from C:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在C#和C上有所开发，你会意识到它们遵循类似的代码语法，例如使用分号，以及类似的方法声明；这两种语言彼此之间非常不同。就像在C中一样，我们可以使用相同的数据类型声明数据变量，例如`Char`和`Integer`。以下特性使C#与C不同：
- en: '| **Feature** | **C#** | **C** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **C#** | **C** |'
- en: '| Object-oriented programming | Object-oriented programming is the main essence
    of any high-level programming language, and C# allows us to utilize the capabilities
    of OOP using the four main pillars of encapsulation, polymorphism, inheritance,
    and abstraction. In [Chapter 3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml), *Understanding
    Object-Oriented Programming*, we will look at this in detail. | C as a programming
    languagedoes not support polymorphism, encapsulation, and inheritance.It does
    not provide features such as function overloading, virtual functions, and inheritance.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 面向对象编程 | 面向对象编程是任何高级编程语言的主要精髓，C#允许我们利用面向对象编程的四个主要支柱：封装、多态、继承和抽象。在[第3章](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml)，*理解面向对象编程*中，我们将详细探讨这一点。
    | 作为编程语言，C不支持多态、封装和继承。它不提供诸如函数重载、虚函数和继承等功能。|'
- en: '| Exception handling | Exception handling is the process of handling runtime
    errors that occur during the execution of the application. C# provides us with
    exception handling features that help us handle these scenarios in a better way.
    In [Chapter 7](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml), *Implementing Exception
    Handling*, we will look at this in detail. | C also does not provide any exception
    handling features. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 异常处理 | 异常处理是在应用程序执行过程中发生运行时错误的处理过程。C#为我们提供了异常处理功能，帮助我们更好地处理这些场景。在[第7章](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml)，*实现异常处理*中，我们将详细探讨这一点。
    | C也没有提供任何异常处理功能。|'
- en: '| Type safety | Every variable declared in a program has a type. In a typical
    type-safe language during the program compilation stage itself, the compiler will
    validate the values being assigned to variables and raise a compile time error
    if an incorrect type is assigned to it. C# is a type-safe language. However, in
    [Chapter 8](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml), *Creating and Using of
    Types in C#*, we will learn that it also allows you to use pointers using a keyword,
    `UnSafe`. | C language implements type safety, albeit with some exceptions. There
    are certain in-built functions such as `printf` that do not enforce that only
    character strings are passed to them. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 类型安全 | 程序中声明的每个变量都有一个类型。在典型的类型安全语言中，在程序编译阶段，编译器将验证分配给变量的值，如果分配了错误的类型，则会引发编译时错误。C#
    是一种类型安全的语言。然而，在[第8章](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml)，*C#中的类型创建和使用*，我们将了解到它还允许你使用关键字
    `UnSafe` 来使用指针。| C语言实现了类型安全，尽管有一些例外。有一些内置函数，如 `printf`，并不强制只传递字符字符串给它们。|'
- en: Let's now look at how C# compares against another language, C++. After exploring
    the comparison between C# and C++, we will also explore how the .NET Framework
    makes C# a platform-independent language compared to C and C++.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 C# 与另一种语言 C++ 的比较。在探索了 C# 和 C++ 的比较之后，我们还将探讨 .NET 框架如何使 C# 相比 C 和 C++
    成为一种平台无关的语言。
- en: C# versus C++
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 与 C++
- en: In most programming scenarios, C++ can be classified as an extension of C and
    can execute all the code that was written in C. It provides all the features of
    object-oriented programming while retaining the functionalities provided by C.
    There are several features that are common between C# and C++. Just as in C#,
    we can implement object-oriented programming, exception handling, and type safety
    in C++. However, there are also certain things that make C# different to C++ and
    more similar to Java.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程场景中，C++ 可以被归类为 C 的扩展，并且可以执行所有用 C 编写的代码。它提供了面向对象编程的所有功能，同时保留了 C 提供的功能。C#
    和 C++ 之间有一些共同的特征。就像在 C# 中一样，我们可以在 C++ 中实现面向对象编程、异常处理和类型安全。然而，也有一些事情使 C# 与 C++
    不同，并且更类似于 Java。
- en: Before we look at the differences and similarities between C# and C++, we must
    understand some key concepts pertaining to object-oriented programming.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨 C# 和 C++ 之间的差异和相似性之前，我们必须了解一些与面向对象编程相关的关键概念。
- en: 'The languages that implement object-oriented programming are classified in
    two categories:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实现面向对象编程的语言可以分为两类：
- en: Fully object-oriented languages
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全面向对象的编程语言
- en: Pure object-oriented languages
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯面向对象的编程语言
- en: A language is classified as a fully object-oriented programming language if
    it implements at least the four core pillars of *Abstraction*, *Encapsulation*,
    *Polymorphism*, and *Inheritance*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一门语言如果实现了至少四个核心支柱：*抽象*、*封装*、*多态*和*继承*，则被归类为完全面向对象的编程语言。
- en: On the other hand, a language can be defined as a pure object-oriented programming
    language when, apart from being fully object-oriented programming, it only contains
    classes and objects. This means that all methods, properties, and attributes declared
    must be inside a class and also should not have any predefined data types, such
    as `char` and `int`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当一门语言除了是面向对象编程之外，只包含类和对象时，它可以被定义为纯面向对象的编程语言。这意味着所有声明的所有方法、属性和属性都必须在类内部，并且也不应该有任何预定义的数据类型，例如
    `char` 和 `int`。
- en: In the case of C#, we can have predefined data types. In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, we will look into those predefined
    data types in detail. This makes C# a *fully object-oriented language* and not
    a *pure object-oriented language*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 的情况下，我们可以有预定义的数据类型。在[第2章](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml)，*理解类、结构和接口*，我们将详细探讨这些预定义的数据类型。这使得
    C# 成为一个 *完全面向对象的编程语言*，而不是一个 *纯面向对象的编程语言*。
- en: On the other hand, in the case of C++, we can define methods that are not part
    of any class. This, too, makes it a *fully object-oriented language*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在 C++ 的情况下，我们可以定义不属于任何类的函数。这也使它成为一个 *完全面向对象的编程语言*。
- en: 'Now, let''s look at some of the similarities and differences between C# and
    C++:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 C# 和 C++ 之间的一些相似之处和不同之处：
- en: '| **Feature** | **C#** | **C++** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **C#** | **C++** |'
- en: '| Object-oriented programming | As described previously, C# is a fully object-oriented
    language. | Similar to C#, C++ is also a fully object-oriented language. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 面向对象编程 | 如前所述，C# 是一种完全面向对象的语言。 | 与 C# 类似，C++ 也是一种完全面向对象的语言。 |'
- en: '| Memory management | C# has got an inbuilt garbage collector that manages
    the allocation and deallocation of memory. In [Chapter 9](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml),
    *Managing the Object Life Cycle*, we will understand memory management in C# in
    detail. | C++ does not have a built-in garbage collector. Due to this, developers
    are responsible for handling the allocation and deallocation of memory. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 内存管理 | C# 有一个内置的垃圾回收器来管理内存的分配和释放。在[第9章](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml)，*管理对象生命周期*中，我们将详细了解
    C# 中的内存管理。 | C++ 没有内置的垃圾回收器。因此，开发者负责处理内存的分配和释放。 |'
- en: '| Inheritance | C# does not support multiple inheritance. In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, we will learn what it means;
    however in simple terms, it means that a class can only inherit from one class
    at a time. | Compared to C# , C++ allows us to implement multi-level inheritance.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 继承 | C# 不支持多重继承。在[第2章](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml)，*理解类、结构和接口*中，我们将学习这意味着什么；然而，简单来说，这意味着一个类一次只能从一个类继承。
    | 与 C# 相比，C++ 允许我们实现多级继承。 |'
- en: '| Use of pointers | Although C# allows us to use pointers in our code, we need
    to declare the code with a snippet of `UnSafe`. We will look into this in detail
    in [Chapter 8](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml), *Creating and Using
    of Types in C#*. | C++ allows us to use pointers anywhere without any implicit
    declaration in the code. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 指针的使用 | 虽然 C# 允许我们在代码中使用指针，但我们需要用一段 `UnSafe` 的代码来声明它。我们将在[第8章](4eff7e9c-efbf-4e0f-9ee5-62f9934451b2.xhtml)，*在
    C# 中创建和使用类型*中详细探讨这一点。 | C++ 允许我们在代码的任何地方使用指针，而不需要任何隐式声明。 |'
- en: In the previous two sections, we saw how C# compares to both C and C++. However,
    there is one important difference that we haven't yet explored. That feature is
    platform independence and was one of the main reasons C# was introduced by Microsoft.
    When working with C and C++, we need to compile the code in accordance with the
    underlying platform features, such as the operating system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两节中，我们看到了 C# 与 C 和 C++ 的比较。然而，有一个重要的区别我们还没有探讨。这个特性是平台无关性，也是微软推出 C# 的主要原因之一。当我们使用
    C 和 C++ 时，我们需要根据底层平台特性（如操作系统）来编译代码。
- en: Suppose we write an application in C or C++ and compile it. During the compilation
    stage, the compiler translates the code into a native language code that is only
    compatible with the underlying platform. This basically implies that an application
    in C++, developed and compiled on a Windows machine, will just be compatible with
    a Windows machine. If the compiled bits are used on a different system, such as
    Linux, it will not work there.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们用 C 或 C++ 编写一个应用程序并编译它。在编译阶段，编译器将代码转换成与底层平台兼容的本地语言代码。这基本上意味着在 Windows 机器上开发和编译的
    C++ 应用程序将仅与 Windows 机器兼容。如果编译后的位被用于不同的系统，例如 Linux，它将无法在那里运行。
- en: 'This difference is caused due to the varying nature of compilers and their
    compatibility with underlying operating systems, such as Linux and Windows. These
    are some of the common compilers in Linux and Windows that are available for C
    and C++:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异是由于编译器及其与底层操作系统（如 Linux 和 Windows）的兼容性不同而造成的。以下是一些在 Linux 和 Windows 上可用的、用于
    C 和 C++ 的常见编译器：
- en: '**Linux**: GCC, Failsafe C, and SubC'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux**: GCC, Failsafe C, 和 SubC'
- en: '**Windows**: Microsoft Windows SDK, Turbo C++, and SubC'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**: Microsoft Windows SDK, Turbo C++, 和 SubC'
- en: Before C# was developed, this platform dependence issue was a major disadvantage
    compared to some of the other programming languages, such as Java. In Java, when
    an application is compiled, it's not directly converted into machine code. Instead,
    it's converted into an intermediate language known as **ByteCode**. The ByteCode
    is platform-independent and can be deployed on different platforms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 开发之前，与 Java 等其他编程语言相比，这个平台依赖性问题是一个主要的缺点。在 Java 中，当应用程序编译时，它不会直接转换成机器码。相反，它会被转换成一种称为
    **ByteCode** 的中间语言。ByteCode 是平台无关的，可以在不同的平台上部署。
- en: When Microsoft introduced C#, they inculcated the same principle in the language.
    When an application written in C# is compiled, instead of being converted to the
    native code compatible with the machine, the application is first translated to
    an intermediate language commonly known as **IL code**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软引入 C# 时，他们在语言中融入了同样的原则。当用 C# 编写的应用程序被编译时，它不会转换为与机器兼容的本机代码，而是首先被翻译成一种中间语言，通常称为
    **IL 代码**。
- en: After the IL code is generated, the **Common Language Runtime** (**CLR**) comes
    into effect. CLR is a runtime environment that sits in the memory of the underlying
    machine and converts the IL code to the native code, which is specific to the
    machine. This process is **Just-In-Time** (**JIT**) compilation. In the next section,
    we will look at the underlying platform of the .NET Framework, which handles all
    this for a C# application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成 IL 代码后，**公共语言运行时**（**CLR**）开始发挥作用。CLR 是一个运行时环境，位于底层机器的内存中，并将 IL 代码转换为特定于机器的本机代码。这个过程是**即时编译**（**JIT**）。在下一节中，我们将探讨
    .NET Framework 的底层平台，它为 C# 应用程序处理所有这些。
- en: .NET Framework
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Framework
- en: .NET Framework is a software development framework on which we can write a number
    of languages such as C#, ASP.NET, C++, Python, Visual Basic, and F#.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 是一个软件开发框架，我们可以用 C#、ASP.NET、C++、Python、Visual Basic 和 F# 等多种语言编写程序。
- en: Microsoft released the first version of .NET 1.0 in 2002\. The current version
    of .NET Framework is 4.8\. The code written in this book will be based on this
    version of .NET Framework 4.7.2.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 微软于 2002 年发布了 .NET 1.0 的第一个版本。当前 .NET Framework 的版本是 4.8。本书中编写的代码将基于此版本的 .NET
    Framework 4.7.2。
- en: .NET Framework provides language interoperability across different programming
    languages. Applications written in .NET Framework execute in an environment or
    a virtual machine component known as CLR.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 提供了跨不同编程语言的语言互操作性。在 .NET Framework 中编写的应用程序在称为 CLR 的环境或虚拟机组件中执行。
- en: 'The following diagram illustrates the different components in .NET Framework:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 .NET Framework 中的不同组件：
- en: '![](img/18581f79-2dca-4213-b12f-5f9c728b3da4.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18581f79-2dca-4213-b12f-5f9c728b3da4.png)'
- en: 'In the previous diagram, note the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，请注意以下几点：
- en: At the top of the hierarchy, we have applications or the program code that we
    write in .NET. It could be as simple as a `Hello World` console application program,
    which we will create in this chapter, or as complex as writing multi-threaded
    applications.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在层次结构的顶部，我们有应用程序或我们用 .NET 编写的程序代码。它可以像我们在本章中将要创建的简单的 `Hello World` 控制台应用程序程序一样简单，也可以像编写多线程应用程序一样复杂。
- en: The applications are based upon a set of classes or design templates, which
    constitutes a class library.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序基于一组类或设计模板，这构成了一个类库。
- en: The code written in these applications is then acted upon by CLR, which makes
    use of the **Just in Time** (**JIT**) compiler to convert the application code
    into machine code.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些应用程序中编写的代码随后由 CLR 处理，CLR 使用 **即时**（**JIT**）编译器将应用程序代码转换为机器代码。
- en: The machine code is specific to the underlying platform properties. So, for
    different systems, such as Linux or Windows, it will be different.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器代码特定于底层平台的属性。因此，对于不同的系统，如 Linux 或 Windows，它将是不同的。
- en: 'For further information on .NET Framework, please refer to the official docs
    from Microsoft: [https://docs.microsoft.com/en-us/dotnet/framework/get-started/overview](https://docs.microsoft.com/en-us/dotnet/framework/get-started/overview).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 .NET Framework 的更多信息，请参阅微软的官方文档：[https://docs.microsoft.com/en-us/dotnet/framework/get-started/overview](https://docs.microsoft.com/en-us/dotnet/framework/get-started/overview)。
- en: In the next section, we will the .NET Framework in detail learn how interact
    with each other.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细学习 .NET Framework 如何相互交互。
- en: Languages/applications
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言/应用程序
- en: 'Languages indicate the different types of applications that can be built in
    .NET Framework. If you are new to .NET Framework, you may not be familiar with
    some of the applications listed here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 语言表示在 .NET Framework 中可以构建的不同类型的应用程序。如果您是 .NET Framework 的新手，您可能不熟悉这里列出的某些应用程序：
- en: '**ADO.NET**:In an ADO.NET application, we write programs to access data from
    sources such as SQL Server, OLE DB, and XML sources.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADO.NET**：在 ADO.NET 应用程序中，我们编写程序以从 SQL Server、OLE DB 和 XML 源等数据源访问数据。'
- en: '**ASP.NET**: In an ASP.NET application, we write programs to build web apps
    such as websites and services using C#, HTML, CSS, and so on.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET**：在 ASP.NET 应用程序中，我们编写程序以使用 C#、HTML、CSS 等构建网站和服务等网络应用程序。'
- en: '**CORE**:In .NET Core applications, we write programs that support cross-platform
    functionality. The programs could be web apps, console applications, or libraries.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CORE**：在.NET Core应用程序中，我们编写支持跨平台功能的程序。这些程序可以是Web应用程序、控制台应用程序或库。'
- en: '**Windows Forms**: In Windows Forms applications, we write programs that provide
    client-side applications for desktops, tablets, and mobile devices.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Forms**：在Windows Forms应用程序中，我们编写提供桌面、平板电脑和移动设备客户端应用程序的程序。'
- en: '**WPF**: In WPF or Windows Presentation Foundation, we write programs that
    provide user interfaces in Windows-based applications. It runs only on Windows-supported
    platforms, such as Windows 10, Windows Server 2019, and Windows Vista.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WPF**：在WPF或Windows Presentation Foundation中，我们编写提供基于Windows应用程序用户界面的程序。它仅在Windows支持的平台上运行，例如Windows
    10、Windows Server 2019和Windows Vista。'
- en: '**WCF**: In WCF or Windows Communication Foundation, we write programs that
    provide a set of APIs, or in simpler terms, services, to exchange data between
    two distinct systems.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WCF**：在WCF或Windows Communication Foundation中，我们编写提供一组API，或者用更简单的说法，提供服务的程序，用于在两个不同的系统之间交换数据。'
- en: '**LINQ**: In LINQ, we write programs that provide data querying capabilities
    on .NET applications.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ**：在LINQ中，我们编写提供.NET应用程序数据查询能力的程序。'
- en: '**Parallel FX**: In Parallel FX, we write programs that support parallel programming.
    It involves writing programs that utilize the CPU''s capabilities to the fullest
    by executing several threads in parallel to complete a task.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parallel FX**：在Parallel FX中，我们编写支持并行编程的程序。这涉及到编写利用CPU能力的程序，通过并行执行多个线程来完成任务。'
- en: The class library
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类库
- en: The class library in .NET Framework consists of a collection of interfaces,
    classes, and value types on which the applications are built.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework中的类库由一组接口、类和值类型组成，应用程序就是基于这些类型构建的。
- en: 'These collections are organized in different containers known as **namespaces**.
    They are a set of standard class libraries that can be used for different purposes
    in an application. Here are some of the namespaces:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些集合组织在不同的容器中，称为**命名空间**。它们是一组标准类库，可以在应用程序的不同目的中使用。以下是一些命名空间：
- en: '`Microsoft.Sharp`: This contains a type that supports compilation and code
    generation for C# source code, and the type that supports conversion between Dynamic
    Language Runtime and C#.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Sharp`：这个库包含支持C#源代码编译和代码生成的类型，以及支持动态语言运行时与C#之间转换的类型。'
- en: '`Microsoft.Jscript`: This contains classes that support compilation and code
    generation using JavaScript.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Jscript`：这个库包含支持使用JavaScript进行编译和代码生成的类。'
- en: '`Microsoft.VisualBasic`: This contains classes that support compilation and
    code generation for Visual Basic.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.VisualBasic`：这个库包含支持Visual Basic编译和代码生成的类。'
- en: '`Microsoft.VisualC`: This contains classes that support compilation and code
    generation for Visual C++.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.VisualC`：这个库包含支持Visual C++编译和代码生成的类。'
- en: Common Language Runtime (CLR)
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见语言运行时（CLR）
- en: 'CLR is a runtime environment that sits in the memory of the underlying machine
    and converts the IL code to native code. The native code is specific to the underlying
    platform in which the code is running. This provides a platform independence feature
    in a typical application made on .NET Framework. Some of the other features provided
    by CLR are mentioned here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: CLR是一个运行时环境，它位于底层机器的内存中，将IL代码转换为本地代码。本地代码针对代码运行的底层平台是特定的。这为在.NET Framework上构建的典型应用程序提供了平台独立性功能。CLR提供的其他一些功能如下：
- en: '**Memory management**: CLR provides automatic allocation and release of memory
    across the application. Due to this, developers do not need to explicitly write
    code to manage memory. This eliminates issues that can lead to degradation of
    application performance due to memory leaks. CLR manages the allocation and removal
    of memory using a garbage collector, which manages the memory allocation in the
    following manner:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**：CLR为应用程序提供自动分配和释放内存的功能。因此，开发者不需要显式编写代码来管理内存。这消除了可能导致应用程序性能下降的内存泄漏等问题。CLR通过垃圾回收器管理内存的分配和回收，其内存分配方式如下：'
- en: '**Allocating memory**: When an application is executed in CLR, it reserves
    a continuous space of memory for its execution. The reserved space is known as
    a managed heap. The heap maintains a pointer to the memory address where the next
    object defined in the process will be allocated.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配内存**：当应用程序在CLR中执行时，它为其执行保留了一块连续的内存空间。保留的空间被称为托管堆。堆维护一个指向内存地址的指针，其中将分配下一个在过程中定义的对象。'
- en: '**Releasing memory**: During the runtime execution of the program, the garbage
    collector runs at scheduled times and examines whether the memory allocated in
    heaps are still in scope of program execution or not.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放内存**：在程序的运行时执行过程中，垃圾收集器在预定的时间运行并检查在堆中分配的内存是否仍然在程序执行的范围内。'
- en: It determines whether the program is still using the memory on the basis of
    roots or the collection of memory objects are still in the scope of the program.
    If any memory allocation is not reachable as per the collection in the root, the
    garbage collector determines that the memory allocated in that memory space can
    be released.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确定程序是否仍然基于根或内存对象集合仍在程序的范围内使用内存。如果根据根中的集合，任何内存分配都不可达，垃圾收集器将确定在该内存空间中分配的内存可以被释放。
- en: We will look into memory management in detail in [Chapter 9](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml),
    *Manage the Object Life Cycle*.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在[第9章](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml)，*管理对象生命周期*中详细探讨内存管理。
- en: '**Exception handling**: When an application is being executed, it may result
    in certain execution paths that could generate some errors in the application.
    Some of the common examples are as follows:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常处理**：当应用程序正在执行时，它可能会导致某些执行路径，这些路径可能会在应用程序中产生一些错误。以下是一些常见的例子：'
- en: When an application tries to access an object such as a file that is not present
    in the specified directory path.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序尝试访问一个文件，但该文件不在指定的目录路径中时。
- en: When an application tries to execute a query on the database but the connection
    between the application and the underlying database is broken/not open.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序尝试在数据库上执行查询，但应用程序与底层数据库之间的连接已断开/未打开时。
- en: We will look into exception handling in detail when we go through [Chapter 7](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml),
    *Implementing Exception Handling*.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们进入[第7章](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml)，*实现异常处理*时，我们将详细探讨异常处理。
- en: In the next section, we will look at the release history of .NET Framework and
    its compatibility with different versions of CLR and C#.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看.NET Framework的发布历史以及它与不同版本的CLR和C#的兼容性。
- en: .NET Framework release versions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Framework发布版本
- en: 'The first version of .NET Framework 1.0 was released in 2002\. Just like .NET
    Framework, there are different versions of CLR and C# as well. The different versions
    of .NET Framework are compatible with some particular versions of both CLR and
    C#. The following table provides a compatibility mapping between the different
    .NET Framework versions and its compatible versions of CLR:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 1.0的第一个版本于2002年发布。就像.NET Framework一样，CLR和C#也有不同的版本。不同版本的.NET
    Framework与某些特定的CLR和C#版本兼容。以下表格提供了不同.NET Framework版本与其兼容的CLR版本之间的兼容性映射：
- en: '| **.NET Framework** | **CLR version** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **.NET Framework** | **CLR版本** |'
- en: '| 1.0 | 1.0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | 1.0 |'
- en: '| 1.1 | 1.1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 1.1 | 1.1 |'
- en: '| 2.0/3.0/3.5 | 2.0 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 2.0/3.0/3.5 | 2.0 |'
- en: '| 4.0/4.5/4.5.1/4.5.2/4.6/4.6.1/4.6.2/4.7/4.7.1/4.7.2/4.8 | 4 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 4.0/4.5/4.5.1/4.5.2/4.6/4.6.1/4.6.2/4.7/4.7.1/4.7.2/4.8 | 4 |'
- en: 'The following table matches the different versions of .NET Framework with its
    compatible C# version, and lists some of the important programming features that
    were released in that version of C#:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格将.NET Framework的不同版本与其兼容的C#版本相匹配，并列出在该版本的C#中发布的一些重要编程特性：
- en: '| **Version** | **.NET Framework** | **Important features in C#** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **版本** | **.NET Framework** | **C#中的重要特性** |'
- en: '| C# 1.0/1.1/1.2 | .NET Framework 1.0/1.1 | First release of C# |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| C# 1.0/1.1/1.2 | .NET Framework 1.0/1.1 | C#的第一个版本 |'
- en: '| C# 2.0 | .NET Framework 2.0 | Generics anonymous methods, Nullable types,
    and Iterators |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| C# 2.0 | .NET Framework 2.0 | 泛型匿名方法、可空类型和迭代器 |'
- en: '| C# 3.0 | .NET Framework 2.0/3.0/3.5/4.0 | Query expressions, Lambda expression,
    and Extension methods |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| C# 3.0 | .NET Framework 2.0/3.0/3.5/4.0 | 查询表达式、Lambda表达式和扩展方法 |'
- en: '| C# 4.0 | .NET Framework 2.0/3.0/3.5/4.0 | Dynamic binding, Named/optional
    arguments, and Embedded interop types |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| C# 4.0 | .NET Framework 2.0/3.0/3.5/4.0 | 动态绑定、命名/可选参数和嵌入式互操作类型 |'
- en: '| C# 5.0 | .NET Framework 4.5 | Asynchronous members |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| C# 5.0 | .NET Framework 4.5 | 异步成员 |'
- en: '| C# 6.0 | .NET Framework 4.6/4.6.2/4.7/4.7.1/4.7.2 | Exception filters, String
    interpolation, `nameof` operator, and Dictionary initializer |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| C# 6.0 | .NET Framework 4.6/4.6.2/4.7/4.7.1/4.7.2 | 异常过滤器、字符串插值、`nameof`运算符和字典初始化器
    |'
- en: '| C# 7.0/7.1/7.2/7.3 | .NET Framework 4.6/4.6.2/4.7/4.7.1/4.7.2 | Out variables,
    Pattern matching, Reference locals and returns, and Local functions |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| C# 7.0/7.1/7.2/7.3 | .NET Framework 4.6/4.6.2/4.7/4.7.1/4.7.2 | 输出变量、模式匹配、引用局部变量和返回值、以及局部函数
    |'
- en: '| C# 8 | .NET Framework 4.8 | Read-only members and Default interface members
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| C# 8 | .NET Framework 4.8 | 只读成员和默认接口成员 |'
- en: In the next section, we will look at Visual Studio, an IDE tool provided by
    Microsoft for building applications with .NET Framework, and some of its built-in
    features that can help us during the development phase.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨微软提供的用于使用.NET Framework构建应用程序的IDE工具——Visual Studio，以及它在开发阶段的一些内置功能，这些功能可以帮助我们。
- en: Visual Studio for C#
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio for C#
- en: Microsoft Visual Studio is an **Integrated Development Environment** (**IDE**)
    tool used by developers worldwide to develop, compile, and execute their .NET
    Framework applications. There are several features provided in the tool that help
    developers not only improve the quality of the application developed, but also
    greatly reduce the time of development.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Visual Studio是一个全球开发者使用的**集成开发环境**（**IDE**）工具，用于开发、编译和执行.NET Framework应用程序。该工具提供了几个功能，可以帮助开发者不仅提高应用程序的质量，而且大大减少开发时间。
- en: 'Some of the key features of Visual Studio are mentioned here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到了Visual Studio的一些关键特性：
- en: It uses Microsoft software development platforms such as Windows API, Forms,
    WPF, and Silverlight.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用微软的软件开发平台，如Windows API、表单、WPF和Silverlight。
- en: While writing code, it provides IntelliSense code-completion features, which
    help the developers write code efficiently.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写代码时，它提供了IntelliSense代码补全功能，这有助于开发者高效地编写代码。
- en: It also provides a forms designer for building GUI applications, a class designer,
    and database schema designer.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还提供了一个表单设计器用于构建GUI应用程序，一个类设计器，以及数据库模式设计器。
- en: It provides support for different source control systems, such as GitHub and
    TFS.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持不同的源代码控制系统，如GitHub和TFS。
- en: The current version of Visual Studio is 2017\. For development purposes, Microsoft
    provides a Community Edition of Visual Studio, which is free of cost and can be
    used for non-commercial activities.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio的当前版本是2017。为了开发目的，微软提供了免费的社区版Visual Studio，可用于非商业活动。
- en: 'It''s essential that before using the Community Edition, we go through the
    terms and conditions of use as well: [https://visualstudio.microsoft.com/license-terms/mlt553321/](https://visualstudio.microsoft.com/license-terms/mlt553321/).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用社区版之前，我们必须仔细阅读使用条款和条件：[https://visualstudio.microsoft.com/license-terms/mlt553321/](https://visualstudio.microsoft.com/license-terms/mlt553321/)。
- en: In the next section, we will do a walk-through on the basic syntax involved
    in writing a basic C# application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将对编写基本C#应用程序所涉及的基本语法进行概述。
- en: Basic structure of C#
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#的基本结构
- en: 'In this section, we will go over a basic programming syntax of a C# application,
    namely: classes, namespaces, and assemblies.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍C#应用程序的基本编程语法，即：类、命名空间和程序集。
- en: 'As C# is an object-oriented language, and at the basic level it contains building
    blocks known as **classes**. The classes interact with one another, and as a result,
    provide functionality at runtime. A class consists of two components:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C#是一种面向对象的语言，在基本层面上，它包含被称为**类**的构建块。这些类相互交互，并在运行时提供功能。一个类由两个组件组成：
- en: '**Data attributes**: Data attributes refer to the different properties defined
    in the class object.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据属性**：数据属性指的是在类对象中定义的不同属性。'
- en: '**Methods**: Methods indicate the different operations that are to be executed
    in the class object.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：方法表示在类对象中要执行的不同操作。'
- en: 'As an example, we will look at the representation of a car as an object in
    C#. At a very basic level, a car will have attributes such as the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将探讨在C#中将汽车表示为对象的方式。在非常基础的层面，一辆汽车将具有以下属性：
- en: '**Make**: For example Toyota, Ford, or Honda.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**制造商**：例如Toyota、Ford或Honda。'
- en: '**Model**: For example Mustang, Focus, or Beetle.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：例如Mustang、Focus或Beetle。'
- en: '**Color**: Color of the car, such as Red or Black.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：汽车的颜色，例如红色或黑色。'
- en: '**Mileage**: Distance covered per liter of fuel consumed.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**油耗**：每升燃油消耗的距离。'
- en: Please note that a car can have more attributes, but as this example is just
    being used for the sake of explanation, we have included these basic attributes.
    While writing a C# application, all of these will be captured as attributes for
    the `Car` class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，汽车可以有更多的属性，但因为这个例子只是为了解释，所以我们只包括了这些基本属性。在编写C#应用程序时，所有这些都将被捕获为`Car`类的属性。
- en: 'Similarly, to make sure the `Car` class achieves all of the desired features,
    it will need to implement the following operations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了确保`Car`类实现所有期望的功能，它需要实现以下操作：
- en: '`StartEngine`: This function represents how the car starts moving.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartEngine`：这个函数表示汽车如何开始移动。'
- en: '`GainSpeed`: This function represents how the car accelerates.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GainSpeed`：这个函数表示汽车如何加速。'
- en: '`ApplyBrake`: This function represents how the car applies brakes to slow down.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplyBrake`：这个函数表示汽车如何应用刹车以减速。'
- en: '`StopEngine`: This function represents how the car stops.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StopEngine`：这个函数表示汽车如何停止。'
- en: While writing any application in C#, the starting point is always to capture
    all the actors/objects that are interacting with each other. Once we identify
    the actors, we can then identify the data attributes and methods that each of
    them must have so that they can exchange the required information with each other.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何C#应用程序时，起点始终是捕获所有相互交互的演员/对象。一旦我们确定了演员，我们就可以确定每个演员必须具有的数据属性和方法，以便它们可以相互交换所需的信息。
- en: 'For the `Car` example being discussed, the following would be the definition
    of the `Car` class. For the sake of explanation, we have just assumed that the
    attributes will be of type `String`; however, when we go through [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, we will go over some more
    data types that can be declared in a class. For the car example, the following
    syntax would be a representative program in a C# application:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正在讨论的`Car`示例，以下将是`Car`类的定义。为了解释方便，我们假设属性将是`String`类型；然而，当我们进入[第2章](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml)，*理解类、结构和接口*时，我们将介绍一些可以在类中声明的更多数据类型。对于汽车示例，以下语法将是一个C#应用程序中的代表性程序：
- en: '[PRE0]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In any application, there can be some classes that are related to one another.
    They can be based in terms of similar functionality, or they could be dependent
    on each other. In C#, we handle such a segregation of functionality via **namespaces**.
    For example, we can have a namespace for handling all operations related to reading/writing
    logs in the file directory. Similarly, we can have namespaces for handling all
    operations related to capturing user-specified information from inputs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，都可能有一些相互关联的类。它们可以根据相似的功能来分类，或者它们可能相互依赖。在C#中，我们通过**命名空间**来处理这种功能分离。例如，我们可以有一个命名空间来处理与文件目录中读取/写入日志相关的所有操作。同样，我们可以有命名空间来处理从输入中捕获用户指定信息的所有操作。
- en: When our applications continue to evolve and we have several namespaces, we
    may have a need to group related namespaces under one umbrella. This ensures that
    if any class changes under any particular namespaces, it will not affect all the
    classes defined in the application. This structuring of namespace is done via
    **assemblies** in C#. Assemblies are also known as DLLs, or dynamically linked
    libraries. Depending upon how we structure our code, when an application is compiled,
    it results in multiple DLLs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序继续发展和我们有几个命名空间时，我们可能需要将相关的命名空间组合在一起。这确保了如果任何特定命名空间下的任何类发生变化，它不会影响应用程序中定义的所有类。这种命名空间的构建是通过C#中的**程序集**来完成的。程序集也被称为DLL，或动态链接库。根据我们如何组织代码，当应用程序编译时，会产生多个DLL。
- en: Creating a basic program in C#
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的C#程序
- en: 'Now we will look at how to create a basic program in C#. For the sake of explanation,
    we will work on the Console Application project:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看如何创建一个基本的C#程序。为了解释方便，我们将使用控制台应用程序项目：
- en: 'To create a new project, click on File | New Project and select Console App
    (.NET Framework) as the project type:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新项目，请点击文件 | 新建项目，并选择控制台应用程序 (.NET Framework) 作为项目类型：
- en: '![](img/2a1c52af-5fec-40e3-b8cf-9ff4e0e1287d.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a1c52af-5fec-40e3-b8cf-9ff4e0e1287d.png)'
- en: After giving the solution an appropriate name and path, click on OK. Check that
    the solution has been created. At this point, you should see the Solution Explorer.
    By default, a `.cs` file, `Program.cs`, should be added to the solution. By default,
    a method by the name of `Main` will also be added to the class. This method is
    the first entry point when this application is executed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在为解决方案指定合适的名称和路径后，点击 OK。检查解决方案是否已创建。在这个时候，你应该能看到解决方案资源管理器。默认情况下，应该将一个 `.cs`
    文件 `Program.cs` 添加到解决方案中。默认情况下，还会添加一个名为 `Main` 的方法。这个方法是在应用程序执行时的第一个入口点。
- en: Please note that for a console program, it's not possible to change the default
    method, which would be the first entry point for the application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于控制台程序，无法更改默认方法，这将是应用程序的第一个入口点。
- en: '![](img/1b44c968-69ac-44f5-9faa-8d8b6230257a.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b44c968-69ac-44f5-9faa-8d8b6230257a.png)'
- en: 'Let''s open `Program.cs` at this stage. By default, the project will have the
    following `using` expressions for the following namespaces:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开 `Program.cs` 文件。默认情况下，项目将为以下命名空间提供以下 `using` 表达式：
- en: '[PRE1]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A `using` statement basically signifies that the program can use the classes
    and methods defined in those namespaces for any execution. In further chapters,
    we will go over namespaces in detail and learn how to use them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 语句基本上表示程序可以使用那些命名空间中定义的类和方法进行任何执行。在接下来的章节中，我们将详细介绍命名空间并学习如何使用它们。'
- en: 'Now, have a look at the program structure. By default, each class needs to
    be associated with a namespace. The namespace expression present in the `Program.cs`
    class indicates the namespace this class is part of:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，看看程序结构。默认情况下，每个类都需要与一个命名空间相关联。`Program.cs` 类中存在的命名空间表达式表示该类所属的命名空间：
- en: '![](img/8bcb68de-c863-4afc-8a07-e116be0fdc36.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bcb68de-c863-4afc-8a07-e116be0fdc36.png)'
- en: Please note that C# is a case-sensitive language. This basically means that
    if we change the name of the method from `Main` to `main`, CLR will not be able
    to execute this method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C# 是一种区分大小写的语言。这基本上意味着，如果我们将方法名称从 `Main` 更改为 `main`，CLR 将无法执行此方法。
- en: 'Each method in C# consists of two parts:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的每个方法都由两部分组成：
- en: '**Input parameters**: This is a list of variables that will be passed to the
    function when it''s executed.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入参数**：这是一组变量，当函数执行时，这些变量将被传递给函数。'
- en: '**Return type**: This is the value that will be returned by the function to
    the caller when the function finishes its processing.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回类型**：这是函数在完成其处理过程后返回给调用者的值。'
- en: In the case of the `Program` function declared previously, the input variable
    is a collection of arguments. The output variable is void; in other words, it
    does not return anything. In the forthcoming chapters, we will go over functions
    in more detail.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前声明的 `Program` 函数的情况下，输入变量是一组参数。输出变量是 void；换句话说，它不返回任何内容。在接下来的章节中，我们将更详细地介绍函数。
- en: 'Now, let''s write a program syntax to execute the famous `Hello World` output.
    In a console application, we can do this using `Console.Writeline`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个程序语法来执行著名的 `Hello World` 输出。在控制台应用程序中，我们可以使用 `Console.WriteLine` 来实现：
- en: 'The code implementation for this program is as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该程序的代码实现如下：
- en: '[PRE2]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this stage, we have finished the program and are ready to execute it. Click
    on Build | Build Solution. Check that there are no compile time errors:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经完成了程序并准备好执行它。点击 Build | Build Solution。检查是否有编译时错误：
- en: '![](img/cbe35388-0b3a-4270-ac57-16da0260d3bf.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbe35388-0b3a-4270-ac57-16da0260d3bf.png)'
- en: 'At this stage, internally, Visual Studio should have created an `.exe` application
    for the project:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，内部，Visual Studio 应该为项目创建了一个 `.exe` 应用程序：
- en: '![](img/0ed5ddeb-08df-4b0d-8436-698a36510ea7.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ed5ddeb-08df-4b0d-8436-698a36510ea7.png)'
- en: Open Command Prompt and navigate directly to where the `.exe` file has been
    created. Execute the `.exe` file and check that the desired output of `Hello World`
    appears in Command Prompt.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并直接导航到 `.exe` 文件创建的位置。执行 `.exe` 文件并检查 `Hello World` 的预期输出是否出现在命令提示符中。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Before we move to the next chapter, let's summarize what we have learned during
    this chapter. We had a brief recap on the building blocks of C#. We had a walk-through
    of the .NET Framework architecture and visited the different components in it.
    We also analyzed what makes C# different from programming languages such as C
    and C++. We went over the functioning of CLR and how it implements garbage collection
    in C#. We then wrote our first program, *H**ello World*. By now, you should have
    a good awareness of what C# is and the features it contains.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一章之前，让我们总结一下在本章中学到的内容。我们对C#的构建块进行了简要回顾。我们了解了.NET Framework架构，并参观了其中的不同组件。我们还分析了C#与C和C++等编程语言的不同之处。我们讨论了CLR的功能以及它在C#中如何实现垃圾回收。然后我们编写了第一个程序，*H**ello
    World*。到现在为止，你应该对C#是什么以及它包含的功能有了很好的了解。
- en: In the next chapter, we will go over some more basic principles of C# programming.
    We will analyze the different possible access modifiers in C#. Access modifiers
    make sure that the properties and methods present in a class are only exposed
    to the relevant modules in an application. We will learn the behavior and implementation
    of value and reference type data variables in C# programming. We will go over
    inheritance and interface, and how they are implemented in a C# application. We
    will discuss the differences between inheritance and interface, and the different
    scenarios in which we should use one or the other.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论C#编程的一些更多基本原理。我们将分析C#中的不同可能的访问修饰符。访问修饰符确保类中存在的属性和方法只对应用程序中的相关模块公开。我们将学习C#编程中值类型和引用类型数据变量的行为和实现。我们将讨论继承和接口，以及它们在C#应用程序中的实现方式。我们将讨论继承和接口之间的区别，以及我们应该在哪些不同场景中使用其中一个或另一个。
- en: Questions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following statements is correct with regard to C, C++, and C#?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个陈述关于C、C++和C#是正确的？
- en: C is an object-oriented language.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: C是一种面向对象的语言。
- en: C++ applications are independent of the underlying system.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++应用程序与底层系统独立。
- en: C# applications are independent of the underlying system.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#应用程序与底层系统独立。
- en: C implements all the functionality and features of C++ and C#.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: C实现了C++和C#的所有功能和特性。
- en: An assembly consists of related namespaces and classes that interact with each
    other to provide a certain functionality.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个程序集由相关的命名空间和类组成，它们相互作用以提供一定的功能。
- en: 'True'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: For a console project, we can set any function as the starting point of execution
    for the application.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于控制台项目，我们可以将任何函数设置为应用程序执行的起点。
- en: 'True'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Answers
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**C is not an object-oriented language**. C and C++ are not independent of
    the underlying platform, unlike C#, which implements the feature using Common
    language runtime. C is a subset of the functionality and features provided by
    C# and C++.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**C不是一种面向对象的语言**。C和C++与底层平台不独立，而C#通过公共语言运行时（Common language runtime）实现了这一功能。C是C#和C++提供的功能和特性的子集。'
- en: '**True**. An assembly consists of a number of related namespaces and classes
    grouped together.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**正确**。一个程序集由多个相关的命名空间和类组成，它们被分组在一起。'
- en: '**False**. For a console application, the point of entry is always the *main*
    program.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错误**。对于控制台应用程序，入口点始终是*main*程序。'
