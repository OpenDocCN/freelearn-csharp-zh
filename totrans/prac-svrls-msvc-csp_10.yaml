- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security and Observability for Serverless and Microservices Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are studies that indicate that cybercrime can be considered the third
    economy in the world. Besides that, the investment made in many companies in cyber
    security has increased a lot in the last few years. When we talk about serverless
    and microservices, we cannot ignore this topic. In fact, the area of attack of
    a distributed system is bigger than a simple monolith application.
  prefs: []
  type: TYPE_NORMAL
- en: Considering this challenging scenario, security and observability cannot be
    discussed in a single moment of the development process. The approach of security
    and privacy by design indicates that you will only achieve success and reduce
    risk in cyber security if you start thinking about it just after you start thinking
    about your solution.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to discuss how to secure applications, enable monitoring
    for both performance and security, and improve incident response, considering
    the tools and techniques we currently have.
  prefs: []
  type: TYPE_NORMAL
- en: Application Security Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good approach to thinking about security in an application is to define it
    as an onion – with different layers of protection. The most important thing about
    any application is the data that is stored and processed by it. Considering this,
    the databases of an application must be designed to have the correct access and
    protection. However, securing the database is not enough to deliver a good solution,
    so you must also think about the security of the application itself, defining
    authentication and authorization for any user who will access it. Besides that,
    you need to understand that your application will probably use third-party components
    that must also be protected. Infrastructure also needs to be monitored and secure,
    and there are sophisticated ways to do so nowadays. Last, but not least, there
    are alternative solutions that can monitor our applications by intercepting the
    traffic that arrives at it, guaranteeing another layer of security. Let’s check
    each layers of security in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Network Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It can be a little confusing for developers to think about managing a network
    in the cloud, since you might imagine that any resource provided must be public.
    The point is exactly this – we cannot consider any component as public when we
    are using public cloud providers. To do so, you must design a proper network that
    will safeguard applications. For this, a **Virtual Private Cloud (VPC)** must
    be provided.
  prefs: []
  type: TYPE_NORMAL
- en: A VPC provides a logically isolated section within a public cloud, where you
    can launch resources in a virtual network that you define. This isolation ensures
    that your resources are protected from external threats and unauthorized access.
    The focus of this is to reduce the attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: With VPC configurations, you will have fine-grained network control. By defining
    subnets, route tables, and network gateways, you can control the flow of traffic
    to and from your serverless functions and microservices. With this, only trusted
    sources can access your resources, and only exactly what you want will be exposed
    to the public internet.
  prefs: []
  type: TYPE_NORMAL
- en: When you think about microservices, there is no direct need to have them exposed
    to the internet. So, this protection is crucial for sensitive data and critical
    applications, minimizing the risk of external attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In Azure, there are two great services that can help you set the private architecture
    of your subsystems, guaranteeing that only the surfaces that really need to be
    exposed. The first one is Azure Virtual Network, which is the component that will
    enable you to design a VPC according to the configuration you decide. The second
    one is Azure Private Link, which will enable your services to connect over a private
    endpoint in a virtual network. This will give you the opportunity to reduce the
    need to expose a service to the public internet, using the Microsoft backbone
    network to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, if you have a better network design, you will be able to monitor
    and protect your solution with more efficiency. For instance, you can define Azure
    network security groups to define specific rules according to a group. You have
    the option of monitoring the traffic of the network by enabling Virtual Network
    flow logs. You can also define inbound and outbound traffic and prohibitions using
    Azure Firewall. In summary, Azure Virtual Network and its components are a powerful
    tool for securing communication between services in the cloud, ensuring data confidentiality,
    integrity, and availability.
  prefs: []
  type: TYPE_NORMAL
- en: Data Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data that arrives at a database generally comes from a user or a system.
    This means that the transmission of this data needs to be guaranteed, and we must
    consider ways to protect the interception and eventual changing of this data.
    The best way to do so is to encrypt data from the client to the server. **Hyper
    Text Transfer Protocol Secure (HTTPS)** is the alternative that, generally, all
    web servers use to do so. Together with the **Transport Layer Security (TLS)**
    protocol, we enable a secure channel to transfer data.
  prefs: []
  type: TYPE_NORMAL
- en: In a function app, for instance, HTTPS is the only protocol accepted by default.
    This means that any HTTP (which is not secure) request will be redirected to HTTPS,
    providing better security for the transfer of data. You can check it in the configuration
    of App Service.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31916_10_01.png) Figure 10.1: HTTPS Only in App Service'
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, you may also want to increase the security of this transfer layer
    by defining a specific certificate for your service. In Azure, you can do this
    by defining a domain for your app.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Azure delivers to you a certificate created by Microsoft, where
    the domain used is azurewebsites.net. However, you can buy a custom domain outside
    Azure, or even inside it, which is much easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Custom domains will represent a cost to your Azure account. You can get more
    details about custom domains at [https://learn.microsoft.com/en-us/azure/app-service/tutorial-secure-domain-certificate](https://learn.microsoft.com/en-us/azure/app-service/tutorial-secure-domain-certificate)
  prefs: []
  type: TYPE_NORMAL
- en: In the same way as you need to secure the transfer layer, you must secure your
    environment variables and secrets. Azure provides three services to do so. The
    first one is called **Azure Managed Identities** and it will let you access data
    in Azure SQL, Cosmos DB, Azure Storage, and so on without the need for a credential.
    On the other hand, if you do need to manage variables and secrets, **Azure Key
    Vault** is the correct service to store client application secrets, connection
    strings, passwords, shared access keys, and SSH keys. However, access to Azure
    Key Vault may cause performance issues for the application’s startup. That is
    why you should use **Azure App Configuration** to store non-secrets, such as client
    IDs, endpoints, and application parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Another important resource that you must consider while protecting data is the
    options you have for data encryption in the database service. For instance, in
    SQL databases, there is the possibility to use the **Transparent data encryption**
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Transparent data encryption setting](img/B31916_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Transparent data encryption setting'
  prefs: []
  type: TYPE_NORMAL
- en: With this setting, you will prevent situations where a stolen database file
    can be restored on a different server from yours. Besides that, in general, database
    servers also have **firewall rules** that will restrict direct access to them,
    which is a very important approach to not expose the database server to the public
    cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are creating an application, it is essential that you know the actor
    that will access it. To do so, you must provide an **authentication** method,
    that is, the process of verifying the identity of a user or system, ensuring that
    the entity requesting access is indeed who or what it claims to be. To do so,
    you must use credentials such as passwords, tokens, or biometric data.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the user or system identified, there is another process that will
    let this actor access resources or execute activities in the system you are designing.
    The process that enables it is called **authorization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some alternatives to deliver authentication and authorization. We
    will discuss three of them in this topic: **JSON Web Tokens (JWTs)**, OAuth 2.0,
    and OpenID Connect. They are useful techniques to provide access to websites and
    APIs, guaranteeing security for the system you are designing.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSON Web Token (JWT) enables security between the client and the server using
    an encoded JSON object, called a token, that is transferred in the HTTP header
    in a compact and stateless format. The token is created by the server as it verifies
    the authentication of the requestor. The authorization is given to ensure that
    the requestor can access the resources. JWTs pertain to industry standard RFC
    7519.
  prefs: []
  type: TYPE_NORMAL
- en: The code provided in the chapter will give you an idea about how to implement
    JWTs using .NET. It is worth noting that this code is not ready for use, since
    the authentication method is not resolved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Build` method in the `JWTBuilder` class is responsible for constructing
    a JWT based on the properties and claims that have been configured in the builder.
    A `List<Claim>` is initialized with two default claims: (1) `sub` (subject), which
    represents the subject of the token; (2) `jti` (JWT ID), a unique identifier for
    the token, generated using `Guid.NewGuid()`. Additional claims from the claims
    dictionary are appended using **Union**. Each key-value pair in the dictionary
    is converted into a Claim object. A `JwtSecurityToken` object is created with
    the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**issuer**: The entity that issued the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**audience**: The intended recipient of the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**claims**: The list of claims created earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**expires**: The expiration time, calculated as the current UTC time plus the
    configured `expiryInMinutes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**signingCredentials**: Specifies how the token is signed. It uses the provided
    `securityKey` and the `HmacSha256` algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method wraps the `JwtSecurityToken` in a custom `JWT` object and returns
    it. The `JWT` class provides additional properties like `ValidTo` (expiration
    time) and `Value` (string representation of the token).
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the client requestor receives the token, it can be encapsulated in
    the following requests to the server as authorization header information using
    the prefix **Bearer**. The server, when it receives this header information, implements
    middleware software that analyzes whether the request is appropriate for the requester.
    The great thing about it is that if the request path is protected by the JWT process,
    and the request sent does not have the proper token, the request does not arrive
    at the server for processing, only being processed by the middleware.
  prefs: []
  type: TYPE_NORMAL
- en: In the example presented in the chapter, you will find two APIs. The first one
    gives you a token for usage. The second one is the WeatherForecast API generally
    available when you create an API app using .NET. To make better use of the example,
    the Swagger documentation was implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: JWT Swagger implementation ](img/B31916_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: JWT Swagger implementation'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to run the WeatherForecast API without delivering a Bearer token,
    the response will be refused with a 401 error code, which means unauthorized.
    On the other hand, if you use the Token API to generate the token needed and use
    this token for authorization with the padlock icon available in the Swagger interface,
    the result of the API will be properly delivered.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Defining the Bearer token](img/B31916_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Defining the Bearer token'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the token provided respects the JWT standard and can be checked
    on the jwt.io web page, confirming what you defined in your solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Decoding JWT on the jwt.io web page](img/B31916_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Decoding JWT on the jwt.io web page'
  prefs: []
  type: TYPE_NORMAL
- en: Based on the sample provided, you may consider JWT as a good way to implement
    a standard method for **Authorization**.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 and OpenID Connect (OIDC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OAuth 2.0 is an open standard that enables third-party providers to give applications
    **Authorization** to access user resources without exposing their credentials.
    There are many great providers that enable you to use this technique, such as
    Google, Microsoft, Facebook, and GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The simple use of logins with passwords for authorization is considered too
    risky for enterprises nowadays. Besides that, transferring this kind of data via
    APIs is also very dangerous, considering the potential cyberattacks that we need
    to deal with currently. For this reason, **OpenID Connect (OIDC)** is a good option
    for **Authentication**, since it enables the confirmation of a user’s existence
    without exposing passwords.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, there are three important things to consider. The first one is that
    this is also an open standard, which means that we have many servers offering
    this service. The second one is that you will need to consider the usage of a
    third-party service, so the definition of a good provider must be considered.
    The third, but not less important, is that OIDC is implemented above OAuth 2.0,
    which means that, with it, you will have an entire solution for authentication
    and authorizing your users.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, we have the possibility to use OAuth 2.0 and OIDC based on the **Microsoft
    Authentication Library (MSAL)**. To do so using Azure, you first need to register
    an app in Microsoft Entra ID.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Registering an App in Microsoft Entra ID](img/B31916_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Registering an App in Microsoft Entra ID'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of project you are developing, you will have different
    ways to get the authentication of the users you want. The following code gets
    the user profile in a console app, based on a prompt that will redirect the user
    to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result will be the need to log in using Microsoft. In this case, OIDC is
    using Microsoft Entra ID as the provider to identify the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![Interface gráfica do usuário, Aplicativo  O conteúdo gerado por IA pode estar
    incorreto.](img/B31916_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Log in using Microsoft Entra ID'
  prefs: []
  type: TYPE_NORMAL
- en: Once you are logged in, Microsoft will ask if you allow it to share information
    about your account with the desired application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: Authorizing app to read your data](img/B31916_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Authorizing app to read your data'
  prefs: []
  type: TYPE_NORMAL
- en: There are two great things when you use this approach. The first one is that
    you don’t need to worry about user management. This management will be held by
    Microsoft Entra ID, which means that it will be centralized and customized using
    the expertise and experience of the provider, even in aspects of different ways
    of authenticating, such as Multiple Factors for Authentication. The second one,
    and more important, is the user will not need to remember another account, since
    they will use the one that they already use in their common work, which makes
    OIDC a popular choice for creating secure and user-friendly authentication mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Open Worldwide Application Security Project (OWASP)** is a foundation
    that works to improve the security of software in a nonprofit approach. One of
    their most well-known initiatives is the Top 10 list, which presents the riskiest
    situations in relation to your software. This list indicates situations such as
    injection attacks, broken authentication, sensitive data exposure, and security
    misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: When developing solutions, the usage of vulnerable and outdated components is
    considered one of the Top 10 risks. Libraries, frameworks, and APIs play a significant
    role in modern web application development, but these components can also introduce
    vulnerabilities into the application if not carefully managed. The decision to
    use third-party components can provide attackers with a vector to exploit the
    application, potentially leading to data breaches, unauthorized access, and other
    security incidents.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the .NET environment, the usage of components is always connected
    to NuGet. Since NuGet is the package provider, in Visual Studio, it is quite simple
    to check if you are using a library that is outdated.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: Using NuGet to check outdated libraries](img/B31916_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Using NuGet to check outdated libraries'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you must be aware that not only .NET packages need to be
    updated in a solution. When it comes to microservices, depending on the approach
    decided on to implement them, you will need to handle components that could be
    in the container or even in the infrastructure that manages the containers of
    the solution, and these parts of the application must also be continuously checked,
    evaluating whether there are any vulnerabilities that could cause damage to your
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using GitHub as a repository, you may consider using **GitHub Dependabot**
    as a tool for automatically scanning your GitHub projects for outdated dependencies
    and known vulnerabilities, and then opening PRs to update them. **Sonar** and
    **Sync** are other tools that you may consider in your pipeline to prevent third-party
    security issues.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the CVE program ([https://www.cve.org/](https://www.cve.org/))
    is to help us with that. CVE means Common Vulnerabilities and Exposures, and it
    is a list of publicly disclosed computer security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes and Azure Container Apps Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Orchestrators’ security is twofold: on one side, we have user access security,
    and on the other side, we have network security. Here, we refer to the users of
    the orchestrator, not the users of the application hosted by the orchestrator,
    that is developers, administrators, and other operators that maintain both the
    orchestrator installation and its applications.'
  prefs: []
  type: TYPE_NORMAL
- en: The security of application users is taken care of by the application itself
    with the usual web application tools that are not specific for microservices,
    that is security tokens such as authentication cookies and bearer tokens, user
    claims, roles, and authorization policies.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrator network security refers to orchestrator tools for isolating both
    different applications running in the same cluster and different parts of the
    same application.
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses both the orchestrator user’s access security and network
    security for Kubernetes and Azure Container Apps, each in a dedicated subsection.
    Let’s start with Kubernetes network security.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes network security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes network security enriches the usual IP-based firewall rules with
    constraints on higher-level software entities like Kubernetes Pods and namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, for instance, we may isolate two applications running in the same Kubernetes
    cluster by placing them into two different namespaces and then forbidding any
    communication between those two namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: We may also run sensitive Microservices in a “militarized zone” implemented
    as a namespace that exposes just a few **filtering Pods** to external communications.
    This way, the **filtering Pods** can look for adequate credentials and potential
    threats before routing the incoming communication to the microservices that must
    process them.
  prefs: []
  type: TYPE_NORMAL
- en: Pod- and namespace-based network rules are more modular and flexible than IP-address-based
    rules since they directly constrain application-level entities instead of hardware-related
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network security rules are defined through **NetworkPolicy** resources defined
    with the `.yaml` below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The policy applies to all Pods selected by `podSelector` that are in the same
    namespace of the **NetworkPolicy** resource.
  prefs: []
  type: TYPE_NORMAL
- en: If `policyType` contains the `Ingress` item, then the policy constrains input
    communications through rules that must be listed in the `ingress` section. If
    `Ingress` is not listed in `policyType`, the `ingress` section must be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: If `policyType` contains the `Egress` item, then the policy constrains output
    communications through rules that must be listed in the `egress` section. If `Egress`
    is not listed in `policyType`, the `egress` section must be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Communication from/to each Pod must satisfy the constraints of all **NetworkPolicy**
    resources that select it with their `podSelector`.
  prefs: []
  type: TYPE_NORMAL
- en: Each `from` section selects possible sources of communication that sum up to
    the sources of communication selected by all other `from` sections. Analogously,
    each `to` section selects possible destinations of communication that sum up to
    the destinations of communication selected by all other `to` sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `from` and each `to` contains a list of constraints that must be *all*
    satisfied by the allowed sources or destinations. There are three kinds of constraints
    that can be added:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraints on IP addresses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A selector expression that selects Pods of the same namespace of the **NetworkPolicy**
    resource:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A selector expression that selects other allowed namespaces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you would like to receive or send communications just to some Pods of the
    selected namespaces, you can also nest a `podSelector` inside the `namespaceSelector`
    based item as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `from` and `to` can also limit the allowed communication to a list of
    ports and port intervals as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the item contains both `port` and `endPort`, it specifies a port interval.
    Otherwise, if it contains just `port`, it specifies a single port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a policy that selects all Pods of the `mysample` namespace and accepts
    traffic from all Pods of the same namespace and from all Pods of the `mysafe`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a policy that selects all Pods of the `mysample` namespace, and accepts
    traffic from all Pods of the same namespace and from all Pods of the `mysafe`
    namespace, but only on port 80:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a policy that enables all input traffic of the `militarized-zone` namespace
    to pass through the Pods labeled with `role: access-control`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can force all traffic to pass just through the Pods with `role: access-control`
    by adding another rule that prevents traffic from external namespaces to all other
    Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`NetworkPolicy` entities constrain direct communication between Pods, that
    is communication based on Kubernetes services. However, what happens to communication
    mediated by message brokers?'
  prefs: []
  type: TYPE_NORMAL
- en: We may use a different broker for each namespace we would like to isolate, so
    that we can use `NetworkPolicy` entities to constrain access to the various message
    brokers, too. If the message broker servers run outside of the Kubernetes cluster,
    we may use `NetworkPolicy` rules that filter the message broker IP addresses.
    Otherwise, we can deploy each message broker in the same namespace it serves,
    so that its Pods are also constrained by the same `NetworkPolicy` entities that
    constrain direct communication between microservices.
  prefs: []
  type: TYPE_NORMAL
- en: If instead, we use a single message broker cluster, we are forced to use the
    message broker’s internal authorization policies to filter the access to the various
    message queues.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Apps has simpler but less powerful network security.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Apps Network Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure network security in Azure Container Apps, you must use a custom
    Azure **Virtual Network (VNET)**. This requirement introduces the need for specific
    configurations and profiles. The setup typically follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a custom Azure **VNet**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Associate a **dedicated subnet** from the VNet to each **Container Apps environment**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign a **subnet from each environment** to its respective **application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Express communication constraints between environments and applications as **firewall
    rules** on the VNet subnets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For detailed guidance on associating custom subnets with environments and applications,
    refer to the official documentation: [https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli](https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli).'
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach has some limitations. Because network rules are defined
    using **IP-address-based constraints**, rather than explicit software-level policies,
    the result is **reduced modularity** and **limited scalability**. This model may
    be sufficient for small-scale applications with a few communication restrictions,
    but as your microservices ecosystem grows, the approach can become too complicated.
  prefs: []
  type: TYPE_NORMAL
- en: If your system’s communication is handled through **external message brokers**,
    a simpler and more scalable solution is to manage access via the **broker’s authorization
    policies**, controlling which services can access specific message queues.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes User Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes user security is based on four concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: This represents the user who logs in with Kubectl. Each user has
    a unique username and authenticates with a client certificate. Both certificate
    and username must be added to the user’s Kubectl configuration file as explained
    in the *Interacting with Kubernetes: Kubectl, Minikube, and AKS* section of [*Chapter
    8*](Chapter_8.xhtml#_idTextAnchor205)*, Practical Microservices Organization with
    Kubernetes*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**User Group**: Each user group is just a name – a string that may be associated
    to each user and inserted in its client certificate. User groups simplify the
    assignation of permissions to users, since each privilege can be assigned to a
    single user or to a whole user group.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Role**: Each role represents a set of permissions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Role bindings**: Each role binding associates a role, that is a set of permissions,
    to several users and user groups. Put simply, role bindings encode a one-to-many
    relationship between roles and both users and user groups.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Permissions can be scoped either to a single namespace or to the whole Kubernetes
    cluster. Role and role bindings representing namespace-scoped permissions are
    encoded respectively in `Role` and `RoleBinding`Kubernetes resources, while role
    and role bindings representing cluster-scoped permissions are encoded respectively
    in `ClusterRole` and `ClusterRoleBinding` Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `RoleBinding` can only refer to a `Role`, while a `ClusterRoleBinding` can
    only refer to a `ClusterRole`. Here are the definitions of a `Role`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Each **Role** is identified by its name and by the namespace it applies to.
    Permissions are specified as a list of rules, where each rule contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiGroups`: The API that contains the operations and the resources involved
    in the permission. For instance, the API group for Deployments is “apps,” while
    the API group for Pods is the core API that is represented by the empty string.
    The API groups string corresponds to the API name contained in each resource `apiVersion`
    property. Each rule can specify several API groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'r`esources`: The name of the resources that can be manipulated with permission
    (Pods, Deployments, Services, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verbs`: The operations allowed on the resources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`: Getting information on specific resource instances.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`watch`: Observing resource instance properties as they change in time. That
    is, performing a `Kubectl get` or a `Kubectl describe` with the `–watch` flag
    on the resource.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`: Listing the resource in any list of results.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create`: Creating an instance of the resource.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: Deleting an instance of the resource.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`: Updating a resource instance by providing a new object that represents
    the instance. This is a case of the resource being updated with `Kubectl apply`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch`: Updating a resource instance with `Kubectl patch`. In this case, we
    specify an existing resource and then replace just a property with the value contained
    in the `-p` option. The property may also be a complex object, in which case the
    properties specified in the object tree recursively replace existing values, while
    properties not specified in the object tree are left unchanged. Here’s an example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s a role that might be adequate for developers of an application that
    runs in the `my-app` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All of `apiGroups`, r`esources`, and `verbs` accept the wildcard “*” string
    that matches everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `ClusterRole` definition is completely analogous, the only difference being
    that no namespace must be specified and that `type: Role` is replaced by `type:
    ClusterRole`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition of a `RoleBinding`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A `RoleBinding` contains a name and the reference namespace and specifies the
    `Role` it is bound to in its `roleRef` property. The `subjects` property contains
    a list of both users and users’ groups, where each item specifies the user or
    group name and the kind of subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `RoleBinding` that matches the example `developer-user-role` `Role`
    we have seen before, with all users belonging to the `developers` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ClusterBindingRole` definition is completely analogous, the only difference
    being that no namespace must be specified, `roleRef` must refer a `ClusterRole`,
    and that `type: BindingRole` is replaced by `type: ClusterBindingRole`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Client certificates do not need to be issued by a public certification authority
    but need just to be approved by the Kubernetes cluster. Here is the complete procedure
    for creating an approved certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first step, you must create the certificate key. This can be done by
    opening a Linux console and using **openssl**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You must store the `mynewuser.key` file containing the certificate key since
    it is needed to configure the Kubectl configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let’s extract the public part `mynewuser.key` in a certificate approval
    request. Again, we can do it with **openssl**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above instruction generates the `mynewuser.csr` file, containing a certificate
    approval request. `mynewuser` must be replaced by the actual username, while `example:mygroup`
    must be replaced by the name of the user group you would like to add the user
    to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you must encode the certificate request in base 64:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The previous command returns the base-64-encoded certificate in the Linux console.
    Please select and copy it. You must insert it in a `.yaml` file that encodes the
    approval request for the Kubernetes cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only fields you must change are the `name`, that is the approval request
    name, and `expirationSeconds`, which contains the certificate validity in seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let’s open the Windows console to interact with Minikube. Let’s start Minikube
    if it’s not started and then pass the previous .yaml file with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can approve the certificate with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the approval, we can get the final certificate in base 64 format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we must base 64 – decode `mytempfile.txt` to get the certificate in
    binary format. We can do it by opening a Linux console in the folder that contains
    `mytempfile.txt`, and then issuing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can use both `mynewuser.key` and `mynewuser.crt` to update the Kubectl
    configuration file of the new user as explained in the *Interacting with Kubernetes:
    Kubectl, Minikube, and AKS* section of [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205)*,
    Practical Microservices Organization with Kubernetes*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an exercise, you can use the above procedure to define a new Minikube user
    belonging to the `developers` user group, and then you can assign it developer
    privileges on the `myapp` namespace with the example `developer-user-role Role`
    and `developers-binding RoleBinding` we defined before.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all! Let’s move on to Azure Container Apps user security.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Apps User Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Azure Container Apps has no dedicated user security like Kubernetes but uses
    Azure security. Roles can be assigned to specific users either through the Azure
    portal or with the Azure CLI with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All available roles can be inspected on the Environment and Application page
    of the Azure portal. Both the application/environment resource ID and the user
    identity resource ID are available on their respective pages.
  prefs: []
  type: TYPE_NORMAL
- en: Threat Detection and Mitigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of threats we need to deal with in an application is quite huge and
    OWASP, as mentioned before, helps us with that. There are many common attacks
    that an application will need to handle and not only the protection of its network,
    data, entrance, and dependencies will be enough to deal with these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Threats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most difficult point of this scenario is detecting a threat on the fly while
    an application is running. But to detect them, we need to understand basically
    what they are, so let’s check out, in the following topics, some of the common
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Event Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an attacker manipulates input data to execute unauthorized actions within
    an application, leading to data breaches, service disruptions, or unauthorized
    access, we are under an event injection attack.
  prefs: []
  type: TYPE_NORMAL
- en: There are several strategies of mitigation, which include validating and sanitizing
    the input, guaranteeing strict input data; using strong-validation libraries,
    to define well-established libraries and framework connections; and restricting
    the privilege of users to the minimum necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Privilege Escalation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an application where you have different levels of access, privilege escalation
    occurs when an attacker gains access beyond what they need to have, accessing
    resources or functions that they are not authorized to use. The result can be
    catastrophic, leading to unauthorized data access, total system control, and further
    exploitation of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-grained access control to restrict users must be well implemented. Also,
    there is the possibility to use an **Identity and Access Management (IAM)** solution,
    which will enforce user permissions. Regular audits and **Multi-Factor Authentication
    (MFA)** will also help to mitigate possible scenarios where unauthorized users
    may access relevant data.
  prefs: []
  type: TYPE_NORMAL
- en: Denial of Service (DoS) Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s suppose you have massive and excessive traffic in your application caused
    by an attacker who wants to disrupt the availability of your solution, making
    the site simply stop responding accordingly. This is what we call a **Denial of
    Service (DoS)** attack. A DoS attack is caused by a single attacker, from a single
    point. If you have an event where multiple origins of attacks are observed, you
    must be experiencing a DDoS attack, which means that the attack is distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the main way to mitigate this kind of attack is by blocking the traffic
    generated by its origin, so traffic filtering can be the best option. There is
    also the possibility of limiting the rate of access from a specific client for
    a period, minimizing the impact of DDoS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, if you have a solution with great availability, focused on delivering
    high levels of requests, you can suffer less with this kind of attack, especially
    if we are talking about DoS. So, auto-scaling strategies, which automatically
    adjust the number of active instances of a service based on the current load,
    are a good approach for that. **Content delivery network (CDN)** implementations,
    which approximate content to the ones who are using it by implementing the content
    across multiple geographically dispersed servers, can be also a good way to protect
    from this kind of attack.
  prefs: []
  type: TYPE_NORMAL
- en: Man-in-the-Middle (MitM) Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Man-in-the-Middle (MitM)** attacks occur when you have an interception of
    communication between two parts of a system, altering data, which can cause inconsistent
    information in the solution you provide.'
  prefs: []
  type: TYPE_NORMAL
- en: As we have checked before, implementing a secure communication channel, using
    encryption protocols to secure data in transit, is certainly the best way to reduce
    the risk of this threat. Authentication mechanisms can also help in this case,
    especially if there is a way to verify the identities of communicating parties.
  prefs: []
  type: TYPE_NORMAL
- en: Code Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Software code is certainly one of the ways to cause an attack in an application,
    especially if the code enables the injection of malicious code. Malicious code
    can be added in SQL commands that do not properly restrict what is executed in
    the database, enabling leaks, changes, or even data exclusion. In cases where
    your application enables the execution of scripts, the risk is also high, and
    unauthorized actions can happen due to this. You can also have cases where code
    is injected by attackers into web pages viewed by other users. This is called
    **cross-site scripting (XSS)**.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a serious code review process, applying secure coding practices,
    is mandatory in enterprises where the software is crucial for the business. To
    help with this, the usage of a static analysis tool must be considered, based
    on the amount of code that is generated daily by the company.
  prefs: []
  type: TYPE_NORMAL
- en: Detection and Mitigation with Web Application Firewalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since you now understand the number of threats available, it is reasonable to
    say that there is no way to be entirely protected from them without a tool that
    can monitor the entire traffic, inspect it according to the different known threats,
    and alert you to take action once you have something suspicious. That is exactly
    what a **Web Application Firewall (WAF)** does.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection, XSS, and other common web exploits can be handled by WAFs, so
    you must consider their use crucial for securing serverless and microservices
    applications. This is only possible because WAFs in general monitor HTTP/HTTPS
    traffic, giving you the possibility to block malicious requests from a specific
    client, even before they reach your application.
  prefs: []
  type: TYPE_NORMAL
- en: They also provide a centralized panel for monitoring traffic and logging, which
    really simplifies the administration and increases your knowledge about the attacks
    you are suffering. It is important to mention that if you are running a public
    cloud solution, you are constantly under attack.
  prefs: []
  type: TYPE_NORMAL
- en: The service Microsoft offers as a WAF is called Azure Web Application Firewall.
    It is worth noting that Azure WAF works at Layer 7 (the application layer) of
    the OSI model and analyzes HTTP(S) traffic. To do so, it will be necessary to
    check the requests and responses passing through a channel. One of the alternatives
    for this channel is called Azure Application Gateway. This component is a web
    traffic load balancer that also works on OSI Layer 7\. It enables you to manage
    the traffic of your web applications. All the inspected traffic that suggests
    a threat is sent to Azure Monitor as an alert so that an administrator of the
    application can analyze it and take action.
  prefs: []
  type: TYPE_NORMAL
- en: As you may imagine, a solution that monitors the entire traffic of your application
    is obviously a concern when it comes to budget. So, this is certainly a point
    of discussion about investment and the trade-off of it must be analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: Sample solution architecture for enabling WAF](img/B31916_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Sample solution architecture for enabling WAF'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram represents a solution architecture using the components
    that were described in this topic. As you can see, common users access the system
    via HTTPS, Azure Application Gateway handles traffic routing, and Azure WAF protects
    the solution against web threats. There is also the implementation of a Container
    Apps environment for scaling workloads using containers, and the microservices
    are running inside a virtual network. Azure Monitor is being used for the logging
    and observability of the system, so administrator access to Azure Monitor is used
    for insights. Observability is exactly the next topic that we will discuss. Let’s
    have a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Observability for Serverless and Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen up to this point of the book, distributed systems contain a
    complexity that brings to a solution some concerns that you can’t ignore. The
    implementation of a single microservice, using techniques such as serverless or
    containerization, is generally quite simple, but observing the entire solution
    is a difficult task and is certainly one of these concerns. The adoption of the
    observability concept is a good answer to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observability is defined by three primary signals: logs, metrics, and traces.
    A log is an immutable, time-stamped record of an event. A metric is a numerical
    representation of system performance over time. A trace represents the journey
    of a request across services in a distributed system. Together, these three signals
    provide insight into system behavior, enabling proactive maintenance and fast
    troubleshooting.'
  prefs: []
  type: TYPE_NORMAL
- en: Different from traditional monitoring, which generally focuses on predefined
    metrics and system health indicators, and is often reactive, observability defends
    a proactive approach, where the monitoring is continuous to avoid critical problems,
    and fast root-cause detection is the goal.
  prefs: []
  type: TYPE_NORMAL
- en: There are several tools available to help implement observability in distributed
    systems. For logs, tools like Seq and the ELK Stack offer powerful log aggregation
    and visualization capabilities. For metrics, Prometheus is a widely used open-source
    monitoring solution, often paired with Grafana for visualization. For distributed
    tracing, Jaeger and Zipkin are popular open-source options.
  prefs: []
  type: TYPE_NORMAL
- en: However, Application Performance Monitoring (APM) tools like Azure Monitor,
    Datadog, and New Relic allow you to centralize logs, metrics, and traces in one
    place, providing a full picture of system behavior. Choosing between them depends
    on your infrastructure, cloud provider, and integration needs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand each signal of observability in detail to make it easier to
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contextual-rich data is necessary to understand exactly where and when in the
    distributed system the issue monitored started. For example, understanding the
    sequence of service calls and the data passed between them can reveal whether
    an error originated from a specific service or from the interaction between services.
    This level of detail is crucial for effective debugging and for ensuring the resilience
    and reliability of distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: So, to enhance the usability of logs, it is essential to adopt a structured
    format that is easy to query and process. One of the most common approaches is
    to use JSON for log entries, as it offers readability and broad compatibility
    across systems. However, structured logging goes beyond using a structured format.
    It requires purposefully defining the meaning (semantics) of each log field. This
    ensures consistency, improves observability, and enables better filtering, indexing,
    and correlation across logs.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, effective logging needs the use of different logging categories
    to define the severity and importance of log entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debug: Detailed information for technical internal purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Info: General information about the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Warning: Alerts that may indicate potential issues, but that did not cause
    the halting of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Error: Problems that impact the application’s operation and that need to be
    analyzed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fatal: Critical errors that cause the application to terminate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The correct usage of logging levels minimizes efforts in analyzing issues, focusing
    on critical ones in an efficient and effective approach.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to metrics that need to be monitored and evaluated for serverless
    and microservices architectures, there are specific indicators that can be monitored.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, Azure Functions measures the time it takes for a function to execute
    from start to finish. This is called **Function Execution Time**. Shorter execution
    times generally indicate better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions also measures the latency between a serverless function being
    triggered and the moment the function essentially starts running. This is called
    **Cold Start** and reducing it causes improvement of the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The number of **invocations** and the number of **errors** also illustrate how
    the function is working, helping in the analysis of performance and possible problematic
    code.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when you have containerized environments, **CPU** and **Memory
    Usage** may be good metrics to monitor. The first one can affect performance if
    it is too high, and scaling may be considered. The second one can also impact
    performance, and the the cause of memory leaks can be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Traffic** may also be a concern in containerized environments and
    can indicate issues related to communication between microservices. **Pod Health**
    can help in identifying failing or unhealthy Pods.'
  prefs: []
  type: TYPE_NORMAL
- en: These and other metrics can not only be monitored but also alerted using **threshold-based**
    algorithms and alerts. Today, in Azure, we also have some **anomaly detection**
    done by machine models that generally detect deviation of behaviors in some situations,
    like time-response.
  prefs: []
  type: TYPE_NORMAL
- en: Once alerts are properly set, it is also important to have a clear protocol
    for responding to these alerts. This is normally called the **Incident Response
    Process**. The process needs to determine how to deal with the incident (alert),
    how to communicate it, and how to discover the root cause, so the incident does
    not happen again.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have a distributed application, understanding the complete path from
    a request to its end is important to effectively diagnose situations across the
    microservices that are chained. That is why tracing is so important, and .NET
    applications together with Azure have a very good package of libraries to help
    you with it.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of Azure Monitor here is crucial for success. Of course, there are
    other APM systems that can be used to observe the traceability of an application,
    but Azure Monitor gives us facilities that you may consider using. Besides that,
    the `OpenTelemetry` library will give you the versatility needed for enterprise
    solutions. OpenTelemetry (OTel) is a cross-platform, open standard for collecting
    and emitting telemetry data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET the OpenTelemetry implementation uses well-known platform APIs for
    instrumentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Logging.ILogger<TCategoryName>` for logging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Diagnostics.Metrics.Meter` for metrics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Diagnostics.ActivitySource` and `System.Diagnostics.Activity` for distributed
    tracing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These APIs are used by OTel for collecting telemetry and exporting this data
    to an APM service selected by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to notice that the implementation of trace propagation
    using OTel for .NET and Azure Monitor is fully automated, which accelerates the
    process of observing the application’s behavior in Azure Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized Observability with Azure Monitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following example will give you an idea of how powerful Azure Monitor is
    as an APM system to centralize logging, metrics, and tracing as a professional
    observability tool, accelerating diagnosing and enabling proactive management
    with rapid troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code provided in startup uses Azure Monitor for registering the telemetry
    collected by `OpenTelemetry` libraries, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The same code has two APIs. The APIs will obtain data via another route, but
    one of them will try to access an unknown URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the API that is working with a successful endpoint will try to access
    the Packt website.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Both results are impressive. The first one indicates the endpoint with an error
    can be tracked entirely in the Azure Monitor End-to-end transaction view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: Endpoint with an error in Azure Monitor End-to-end transaction
    view](img/B31916_10_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Endpoint with an error in Azure Monitor End-to-end transaction
    view'
  prefs: []
  type: TYPE_NORMAL
- en: This monitoring would be useful to detect this endpoint error, facilitating
    the correction of this bug.
  prefs: []
  type: TYPE_NORMAL
- en: The second result is also interesting because it detects a redirection that
    could improve the performance of the request.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: Endpoint with a successful result in Azure Monitor End-to-end
    transaction view](img/B31916_10_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Endpoint with a successful result in Azure Monitor End-to-end
    transaction view'
  prefs: []
  type: TYPE_NORMAL
- en: The point here is that every call will take 67.2 milliseconds only to redirect
    to the page that is desired. Maybe an alternative solution would be to directly
    access the correct URL. We need to understand this example as a hypothetical case,
    but in real-world cases, this can increase the performance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had the opportunity to discuss security and observability
    strategies for serverless and microservices applications. We need to understand
    that the increase in threats posed by cybercrime moves us to integrate security
    from the initial stages of product development. To do so, we must apply, in our
    security by design approach, security best practices for databases, implementing
    authentication and authorization mechanisms like **JSON Web Tokens (JWTs)**, OAuth
    2.0, and **OpenID Connect (OIDC)**, and using network protection methods like
    **Virtual Private Clouds (VPCs)** and Azure Private Link. Encryption, HTTPS enforcement,
    and the use of Azure Key Vault for managing secrets are also important for modern
    application development.
  prefs: []
  type: TYPE_NORMAL
- en: Another focus of the chapter was network security, particularly in Kubernetes
    and Azure Container Apps environments. That is why the chapter explained how Kubernetes
    network policies enhance security through the isolation of applications and services
    using namespaces and Pod-based network rules. Azure’s network security strategies
    involve virtual networks, firewalls, and private links to limit exposure to public
    threats. The chapter also discussed user security, emphasizing role-based access
    control (RBAC) in Kubernetes and Azure role assignments. It also addressed securing
    dependencies by ensuring that third-party components, libraries, and containers
    are regularly updated to prevent vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also emphasized the importance of threat detection, using web application
    firewalls (WAFs) and proactive security strategies to mitigate threats such as
    injection attacks, denial-of-service (DoS) attacks, and privilege escalation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, observability was another critical topic presented, which was defined
    through three primary signals: logs, metrics, and traces. The chapter explained
    how structured logging, categorized by severity levels, can help diagnose issues
    efficiently. It also covered key performance metrics for both serverless functions
    and containerized applications, such as execution times, resource consumption,
    and error rates. Tracing techniques, including OpenTelemetry and Azure Monitor,
    were presented as solutions for tracking distributed transactions and enhancing
    system monitoring.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why is security a critical concern in serverless and microservices architectures
    compared to monolithic applications?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Security is more critical in serverless and microservices architectures because
    they significantly expand the attack surface. Unlike monolithic applications,
    distributed systems involve multiple independent services communicating over networks,
    which increases the potential entry points for cyberattacks. Each microservice,
    API, or function might expose vulnerabilities, and the complexity of managing
    security across them demands a more comprehensive and layered approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the key layers of security in an application, and why is the “onion
    model” a useful analogy?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The key layers of security include:'
  prefs: []
  type: TYPE_NORMAL
- en: Data security (e.g., encryption, secure database access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application security (e.g., authentication and authorization)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party components (e.g., library updates)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure and network security (e.g., VPCs, firewalls)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic interception and monitoring (e.g., WAFs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “onion model” is useful because it emphasizes that security must be implemented
    in multiple concentric layers. Each layer reinforces the others, reducing the
    likelihood of a single point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does a Virtual Private Cloud (VPC) improve security in cloud environments,
    and what are its key benefits?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A VPC creates a logically isolated network within the public cloud, allowing
    you to define custom subnets, routing rules, and gateways. Key benefits include:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduced exposure to public threats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-grained traffic control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with services like Azure Private Link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced monitoring and protection through network security groups and flow
    logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is the difference between authentication and authorization, and what
    are some commonly used authentication mechanisms?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Authentication** is the process of verifying the identity of a user or system.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization** determines what an authenticated user is allowed to do.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Common mechanisms include:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Tokens (JWTs)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenID Connect (OIDC)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How does a JSON Web Token (JWT) ensure secure communication between a client
    and a server?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A JWT encodes user claims in a signed JSON object transferred via HTTP headers.
    After successful authentication, the server issues a token. This token is then
    included in subsequent requests by the client. Middleware on the server verifies
    the token before allowing access. The stateless and signed nature of JWTs helps
    ensure message integrity and secure access control.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are Kubernetes resources for handling network security?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kubernetes handles network security using:'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces for isolating applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods with specific labels and rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NetworkPolicy resources to define ingress/egress rules based on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP blocks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pod selectors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespace selectors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ports and protocols
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These policies constrain communication between services in a modular, application-centric
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are Kubernetes resources for handling users’ security?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'User security in Kubernetes is managed through:'
  prefs: []
  type: TYPE_NORMAL
- en: Users and Groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles and RoleBindings (namespace-scoped)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ClusterRoles and ClusterRoleBindings (cluster-wide)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissions are defined through verbs (get, list, create, delete, etc.) and
    bound to users/groups via role bindings. Authentication typically uses client
    certificates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does Azure Container Apps have specific facilities for users and network
    security?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes:'
  prefs: []
  type: TYPE_NORMAL
- en: Network security is handled through Azure Virtual Networks and subnets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User access is managed via Azure Role-Based Access Control (RBAC), where roles
    are assigned to users through the Azure portal or CLI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure does not have a dedicated user security model like Kubernetes but relies
    on the broader Azure identity platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What are some common cyber threats, such as privilege escalation and denial-of-service
    attacks, and what strategies can be used to mitigate them?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Common threats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event injection**: Mitigated by input validation/sanitization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privilege escalation**: Mitigated by fine-grained access controls, IAM solutions,
    audits, and MFA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DoS/DDoS attacks**: Mitigated by rate limiting, traffic filtering, auto-scaling,
    and CDNs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MitM attacks**: Mitigated by HTTPS/TLS encryption and authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code injection** (e.g., SQL Injection, XSS): Mitigated by secure coding practices,
    static analysis, and WAFs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What role do Web Application Firewalls (WAFs) play in securing microservices
    applications, and what are their main advantages?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'WAFs monitor and filter HTTP/HTTPS traffic, blocking malicious requests before
    they reach the application. Advantages include:'
  prefs: []
  type: TYPE_NORMAL
- en: Protection against known web exploits (e.g., SQL injection, XSS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized logging and alerting (e.g., via Azure Monitor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to block specific clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified security administration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure’s WAF integrates with Application Gateway and operates at OSI Layer 7.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the three primary signals of observability, and how do they contribute
    to maintaining a secure and efficient system?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The three primary signals are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logs**: Immutable event records that help in debugging and auditing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics**: Quantitative performance indicators (e.g., execution time, memory
    usage).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traces**: Visualize request paths across services for root-cause analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together, they allow proactive monitoring, help detect anomalies, and support
    rapid incident response—crucial for secure and resilient systems.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Container Apps Networking: [https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli](https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Buy a custom domain: [https://learn.microsoft.com/en-us/azure/app-service/manage-custom-dns-buy-domain](https://learn.microsoft.com/en-us/azure/app-service/manage-custom-dns-buy-domain)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storing app secrets: [https://learn.microsoft.com/en-us/samples/azure/azure-sdk-for-net/app-secrets-configuration/](https://learn.microsoft.com/en-us/samples/azure/azure-sdk-for-net/app-secrets-configuration/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transparent Data Encryption: [https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption](https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSON Web Tokens: [https://jwt.io/](https://jwt.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OAuth 2.0: [https://oauth.net/](https://oauth.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MSAL: [https://learn.microsoft.com/en-us/entra/identity-platform/msal-overview](https://learn.microsoft.com/en-us/entra/identity-platform/msal-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is OIDC?: [https://www.microsoft.com/en-us/security/business/security-101/what-is-openid-connect-oidc](https://www.microsoft.com/en-us/security/business/security-101/what-is-openid-connect-oidc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OIDC: [https://openid.net/](https://openid.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OWASP: [https://owasp.org/](https://owasp.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Private Link: [https://learn.microsoft.com/en-us/azure/private-link/private-link-overview](https://learn.microsoft.com/en-us/azure/private-link/private-link-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network security groups: [https://learn.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview](https://learn.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Virtual Network flow logs: [https://learn.microsoft.com/en-us/azure/network-watcher/vnet-flow-logs-overview](https://learn.microsoft.com/en-us/azure/network-watcher/vnet-flow-logs-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Virtual Network: [https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview](https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Managed Identities: [https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Firewall: [https://learn.microsoft.com/en-us/azure/firewall/overview](https://learn.microsoft.com/en-us/azure/firewall/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Web Application Firewall: [https://azure.microsoft.com/en-us/products/web-application-firewall](https://azure.microsoft.com/en-us/products/web-application-firewall)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Application Gateway: [https://learn.microsoft.com/en-us/azure/application-gateway/](https://learn.microsoft.com/en-us/azure/application-gateway/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenTelemetry: [https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub Dependabot: [https://github.com/dependabot](https://github.com/dependabot)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sonar: [https://www.sonarsource.com/](https://www.sonarsource.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Synk: [https://snyk.io/](https://snyk.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Seq: [https://datalust.co/seq](https://datalust.co/seq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ELK Stack: [https://www.elastic.co/elastic-stack/](https://www.elastic.co/elastic-stack/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grafana: [https://grafana.com/](https://grafana.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jaeger: [https://www.jaegertracing.io/](https://www.jaegertracing.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zipkin: [https://zipkin.io/](https://zipkin.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Datadog: [https://www.datadoghq.com/](https://www.datadoghq.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New Relic: [https://newrelic.com/](https://newrelic.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  prefs: []
  type: TYPE_IMG
