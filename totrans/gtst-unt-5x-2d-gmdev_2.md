# 第二章：制作纸杯蛋糕塔

在本章的第二部分，我们将开始构建我们的游戏。我们将看到如何在二维空间中放置对象并创建最常用对象的模板。此外，我们将看到Unity如何处理脚本，并将为我们的游戏编写几个脚本。

特别是，我们将涵盖以下主题：

+   在二维空间中放置对象

+   为我们的游戏设置地图

+   使用标签和层

+   创建预制体（游戏对象的模板）

+   创建新的脚本

+   Unity中脚本的基本概念

+   为我们的游戏编写第一个两个脚本

与本书的所有其他章节一样，你将在末尾找到**作业**部分。它包含一系列不同的练习，以提高你的技能并将各种不同的功能实现到你的游戏中。

因此，让我们开始学习如何将二维对象放置到场景中。

# 二维对象

在上一章中，我们看到了在Unity中2D对象是精灵。然而，我们没有提到如何将它们导入场景。

将你的精灵拖放到场景中最简单的方法是从**项目**面板中将它们拖放到**场景视图**中。Unity将自动创建一个新的游戏对象，其名称与精灵相同，并附加一个精灵渲染器。我们已经在上一章中介绍了这个组件。由于我们不会使用排序层（正如我们在上一章中决定的），在将新的精灵拖入场景时，我们不需要更改任何设置。

将精灵添加到场景的另一种方法是右键单击**层次结构**面板，然后选择**2D对象 | 精灵**。然而，在精灵渲染器中，你需要指定要使用哪个精灵。

让我们把`Pink_Sprinkle`精灵拖入我们的场景（你可以在`Graphics/projectiles`文件夹中的`projectiles_sheet_01`文件中找到它）。它在**场景**视图中的样子如下：

![2D对象](img/image00354.jpeg)

由于精灵也是游戏对象，你可以访问它们的**变换**属性，如下所示：

![2D对象](img/image00355.jpeg)

这意味着你可以沿着*x*轴和*y*轴改变它们的位置，以及缩放和旋转。记住，*z*轴用于确定深度，正如我们在上一章中讨论的。

通过使用**缩放**参数，可以翻转精灵。然而，请注意，这也会翻转其子对象。正如我们在上一章中看到的，从Unity 5.3开始，翻转精灵时，最好使用**精灵渲染器**上的**翻转**变量。

### 注意

你可以通过导航到顶部菜单栏并选择**游戏对象 | 创建空对象**来创建一个空的游戏对象。或者，在**层次结构**面板上，点击**创建**，然后选择**创建空对象**。创建一个空的游戏对象在需要创建其他游戏对象的容器时非常有用，或者如果我们想从头开始构建游戏对象。

# 父对象

每个游戏对象都可以有一个父对象。这意味着游戏对象将随着其父对象一起移动、旋转和缩放。

我可以用很多话来解释这个概念，但有些事情视频比文字解释得更好。因此，有一个非常简短的视频解释了*层次结构和父子关系*：[https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships](https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships)。

我建议你在继续阅读这本书之前先看看它。我会在这里等你。

# 世界坐标和局部坐标之间的区别

在Unity中，每个游戏对象都有一个位置，但位置需要一个参考框架（关于参考框架的更多内容将在[第5章](part0062.xhtml#aid-1R42S1 "第5章。物理的秘诀是加一点调味料")，*物理的秘诀是加一点调味料*）。特别是，Unity提供了两种查看（和设置）坐标的方式：

+   **世界坐标**：这是游戏对象所在位置的绝对坐标（通过绝对，我是指相对于世界框架，在游戏中被认为是绝对的）

+   **局部坐标**：这是游戏对象相对于其父对象的坐标

您可以通过Unity界面右上角的一个切换按钮轻松地在两种坐标之间切换，如下面的截图所示：

![世界坐标和局部坐标之间的区别](img/image00356.jpeg)

如前一个截图所示，它们都是切换按钮，但用于在世界坐标和局部坐标之间切换的是左侧的按钮。目前，它被选中为**全局**，这意味着在世界坐标上。

# 使用Z-Buffering对不同的层进行排序

在上一章中，我们决定使用Z-Buffering而不是排序层。然而，我们需要决定我们游戏中的哪些元素将位于前景，相对于其他元素。

此外，记住相机的设置也很重要。选择**主相机**，它应该是场景中唯一的相机。**检查器**应该看起来像这样：

![使用Z-Buffering对不同的层进行排序](img/image00357.jpeg)

如您所见，默认情况下，其位置上的**Z**值设置为`-10`。这意味着您不能在精灵的**Z**值中有任何更大的负值（这意味着小于`-10`），否则它将不会被渲染。对我们来说，`-10`是完美的，我们将坚持使用它。

接下来，我们需要为所有元素分配一个**Z**值。我们可以开始将地图放置在背景中，通过分配我们心中最低的深度（即最大的**Z**值）；在这种情况下是零。

然后，我们希望有敌人。因此，我们可以将它们的**Z**值设置为`-1`。之后是弹丸和塔楼，分别`-2`和`-3`。最后，我们需要为前景添加另一个值。以下是总结表：

| **元素** | **Z值（深度）** | **原因** |
| --- | --- | --- |
| 地图 | `0` | 该地图具有最低的值，因为它将在所有事物之后。 |
| 敌人 | `-1` | 敌人在地图之后渲染，因为它们可能会穿过塔，而我们希望保持塔的可见性。此外，在它们击中敌人之前，也应该在敌人上显示弹丸。 |
| 弹丸 | `-2` | 弹丸是从塔楼发射的，所以将弹丸放在塔楼上方看起来可能有些奇怪，而从中部发射出来看起来更自然。 |
| 塔楼 | `-3` | 塔楼没有其他层在其上方，除了地图叠加。 |
| 地图叠加 | `-9` | 这位于前景，因此它必须最后渲染。我们选择`-9`而不是`-4`，因为我们可能还会添加其他层，但前景总是离相机最近的那一层。我们将在下一节中看到这一层包含的内容。 |
| 主相机 | `-10` | 默认值。 |

在我们为游戏元素创建Prefab时，我们需要记住这些值。这对本章以及本书的其余部分都很重要。

### 注意

我们将在本章的后面讨论Prefab是什么。

# 展开地图

我们终于准备好将2D地图放置到我们的场景中。

在上一章中，我们已经将分辨率设置为16:9。因此，我们将在我们的包中找到的地图已经准备好使用。

让我们从将`sugar_mountain_map`精灵从`Graphics/maps`文件夹拖入我们的场景开始。我们需要将其放置在(0,0,0)。请注意，*z*轴被设置为零。

这是我们需要的完美地图。例如，在左侧，有甜食爱好者将跟随的路径起点。在路径的尽头，有玩家需要保护的糖城堡。此外，顶部有足够的空间在[第3章](part0043.xhtml#aid-190861 "第3章。与玩家沟通 – 用户界面")，*与玩家沟通 - 用户界面*中实现我们的用户界面。

下一步是修改相机设置。我们想要做的是将整个地图适应到**相机**视图中。为了实现这一点，只需修改**大小**属性为`22.5`，如下所示：

![展开地图](img/image00358.jpeg)

因此，我们的地图将在**相机**视图中完美居中。这就是我们在选择了相机后的**场景**视图中应该看到的样子：

![展开地图](img/image00359.jpeg)

现在，让我们将上一章中切割的其中一个纸杯蛋糕塔引入进来；例如，`ChocolateChip_Cupcake_Tower_2`。如果我们将其拖动到路径的起始位置，我们会遇到以下问题：

![展开地图](img/image00360.jpeg)

或者也在地图的底部：

![展开地图](img/image00361.jpeg)

事实上，纸杯蛋糕塔不应该在石头上，而应该在它的后面，这是由于透视造成的。由于我们在2D世界中工作，我们需要创建一个透视。幸运的是，我们的包包含我们地图的叠加层。它还包含所有应该在前景中的资产，如图所示：

![展开地图](img/image00362.jpeg)

### 注意

请注意，通常，所有资产都在不同的层级上，这样我们就可以自定义它们的位置。然而，在包中，它们已经预先放置，以便您方便使用，这样我们就不需要花费时间学习令人惊叹的事情！

因此，让我们也将这个叠加层添加到场景中。它被称为`sugar_mountain_map_overlay`，可以在`Graphics/maps`文件夹内找到。再次提醒，记得将其*x*和*y*位置设置为零。完成这些后，我们没有看到任何区别，纸杯蛋糕塔仍然悬浮在石头上。实际上，我们在上一节中已经决定，所有的*z*轴值都应该分配给不同的游戏元素。如果你记得，地图叠加的值是`-9`。

一旦你设置了地图叠加的*z*轴值，我们的纸杯蛋糕应该会像我们希望的那样表现：

![展开地图](img/image00363.jpeg)

它在这里的行为也是正确的：

![展开地图](img/image00364.jpeg)

地图终于准备好了。最后的润色；我们应该将地图叠加层设置为地图本身的父级。因此，如果我们需要更改地图，它们将一起移动和缩放。

在我们继续旅程之前，记得删除纸杯蛋糕塔，因为我们只需要它进行测试。

# 图层和标签

如果你已经知道你打算做什么，最好在开始时设置好一切。特别是，Unity有一些标签可以分配给游戏对象。这些是图层和标签。Unity使用这两个属性来区分某些类型的游戏对象。

默认情况下，其中一些已经被定义，但我们需要为我们的项目添加更多。从工具栏菜单中，我们可以通过导航到**编辑** | **项目设置** | **标签和图层**来访问图层和标签设置。因此，**检查器**现在应该看起来像以下截图：

![图层和标签](img/image00365.jpeg)

### 注意

在这个菜单中，我们还可以更改用于渲染2D对象的排序图层。然而，如前所述，我们将使用Z缓冲区来实现相同的效果。

让我们展开**标签**菜单，如下所示：

![图层和标签](img/image00366.jpeg)

要添加新标签，只需在右下角点击+按钮。我们需要添加两个标签，分别是`敌人`和`**弹射物**`，如图所示：

![图层和标签](img/image00367.jpeg)

实际上，我们在游戏的开发过程中还需要这两个标签。实际上，当一个纸杯蛋糕塔搜索周围的对象时，它需要区分敌人和弹射物。

# 预制件

当场景开始充满对象时，其中一些对象可能会变得复杂。这里的复杂是指具有许多组件和子对象。如果我们需要在游戏中使用许多这样的对象，并且可能一次性更改所有这些对象，Unity 提供了创建预制件的可能性。

正如名字所暗示的，这是一个已经组装好所有必要组件并准备好放置在场景中的对象。其优点是经常可以重用它，并且可以快速更改所有实例。

### 注意

如果场景中的对象是一个预制件，那么在**层次结构**面板中它的名字是蓝色的。如果名字是红色的，那么这意味着缺少一些引用。

为了使我们的项目更有条理，让我们创建一个名为 `Prefabs` 的文件夹，如果我们还没有这样做的话。在文件夹内，右键单击并选择 `创建/预制件`。你可以按自己的意愿命名，但为了这本书，让我们保持 `Pink_Sprinkle_Projectile_Prefab` 这个名字。

我们已经在场景中有了喷雾效果，所以从**层次结构**面板中，将其拖动到 `Pink_Sprinkle_Projectile_Prefab`。

现在，我们可以从场景中删除之前的喷雾效果，因为我们不再需要它了。为了测试目的，你可以通过将预制件拖动到**场景**视图中来在场景中添加尽可能多的喷雾效果。当然，记得在继续本章的其余部分之前将它们删除。

当我们选择一个预制件的实例对象时，**检查器**中会显示三个额外的按钮，如下面的截图所示：

![预制件](img/image00368.jpeg)

这些是它们的功能：

+   **选择**：这是一个快速在**项目**面板中选择对象预制件的快捷方式。

+   **还原**：如果我们对预制件实例（当前选定的对象）进行了更改，这些更改不会影响预制件。通过点击此按钮，我们将所有更改还原到原始预制件。

+   **应用**：另一方面，如果你对对预制件实例所做的更改感到满意，通过点击此按钮，你可以将这些更改应用到预制件上。结果，你可能会修改场景中的所有其他实例。所以当你使用这个功能时要小心。

# 游戏视图

你应该已经了解游戏视图，但可能有一些你之前不知道的新功能类型。因此，在我们继续旅程之前，一个简短的回顾可能是有用的。

首先，我们有三个主要按钮，你应该非常熟悉，如下所示：

![游戏视图](img/image00369.jpeg)

第一个是播放按钮，它使你的游戏运行。第二个按钮暂停游戏，并允许你调整一些设置。最后一个按钮只让游戏运行一帧。

在左上角，我们有之前章节中提到的显示和分辨率选项卡。在对角线（右上角），有许多不同但很有用的切换按钮，如下面的截图所示：

![游戏视图](img/image00370.jpeg)

这些是它们的功能：

+   **最大化游戏播放**：如果开启此选项，每次你按下播放按钮，游戏视图将最大化到最大的窗口。这对于在几乎全屏中测试游戏非常有用；否则，如果没有第二个显示器，调整值可能会有些困难。

+   **静音音频**：如果启用，正如其名所示，它将静音游戏中的所有音频源。

+   **统计数据**：如果开启此选项，它将提供一些关于游戏性能的基本反馈，如下所示：

![游戏视图](img/image00371.jpeg)

+   **Gizmos**：这些用于识别场景中的对象。然而，我们将在第6章[通过糖果海导航——人工智能导航](part0077.xhtml#aid-29DRA1 "第6章。通过糖果海导航——人工智能导航")中看到这些，*通过糖果海导航——人工智能导航*。

# 数学背景

无论你是否喜欢数学；然而，这是一个事实，它是游戏开发所必需的。我们没有时间来探讨这个游戏背后的所有数学，因为它需要有一个完整的游戏开发工具集。然而，本节将向你介绍一些我们将需要在本书中其他部分使用的基本概念。此外，它还引用了一些官方文档，以便你可以了解更多关于它们的信息。

如果你对自己以下的一些主题感到自信，你可以自由地跳过它们：

+   **向量**：在游戏开发中，向量非常重要，因为它们能够描述空间（包括3D和2D）。它们可以表示一个位置或一个方向。你可以在[https://docs.unity3d.com/Manual/VectorCookbook.html](https://docs.unity3d.com/Manual/VectorCookbook.html)了解更多关于它们的信息，并观看这个视频：[https://unity3d.com/learn/tutorials/topics/scripting/vector-maths](https://unity3d.com/learn/tutorials/topics/scripting/vector-maths)。

+   **概率**：当我们希望从游戏中抽取样本，并包含不确定性和玩家的机会时，这一点非常重要。一个常见的例子是在即时战略（RTS）或大型多人在线角色扮演游戏（MMORPG）中，伤害量通常在一定的范围内（由角色的属性决定），但实际伤害量使用随机数。另一个例子是当攻击应该是致命的，以便造成双倍伤害。在章节末尾将解释如何在Unity中提取随机数。然而，考虑购买一本关于概率的适当数学书籍；这可能是值得的。

+   **弧度和角度**：角度可以有两种度量单位。弧度通常用于计算，但Unity有一些常数，通过乘法可以将一个单位转换为另一个表示。你可以在[https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html](https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html)和[https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html](https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html)了解更多关于这些的信息。

+   **三角学**：这非常重要，因为正弦和余弦函数经常被用来实现可信的行为，因为大自然在我们的世界中使用了它们。不幸的是，没有捷径。因此，如果你真的想理解它们并深入其中，你应该阅读任何关于三角学的书籍。然而，最重要的概念是它们将它们的参数值范围在`-1`和`+1`之间。

+   **四元数**：这是一个不太直观的数学实体，因为它涉及到复数的分析。然而，在Unity编程中，了解它们的细节并不重要（除非在非常具体的情况下）。实际上，知道Unity使用它们来存储旋转就足够了。此外，还有将欧拉表示（三个角度中最直观的）转换为其他表示的函数。这个选择背后的原因超出了本书的范围，但这是由于欧拉表示的数值不稳定性。你可以通过观看以下视频了解更多信息：[https://unity3d.com/learn/tutorials/topics/scripting/quaternions](https://unity3d.com/learn/tutorials/topics/scripting/quaternions)。

+   **Atan2()**：这是一个在游戏开发中非常重要的函数，因为它能够计算向量的角度。你可以阅读更多关于这个函数的信息：[https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html](https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html)。

# Unity中的脚本编写

在本节中，我们将学习游戏开发中最难的话题之一！然而，我强烈鼓励你不要害怕，而是要多加练习。结果，你将能够掌握你游戏中的每一个细节。这真是太棒了！

## 创建新脚本

首先，我们需要了解如何在Unity中创建新的脚本。最简单的方法是选择一个游戏对象，在**检查器**中导航到**添加组件** | **新脚本**。这样，你仍然有机会重命名它，但脚本将位于`Asset`文件夹中。此外，不可能创建一个无法附加到游戏对象的类。

如果还没有这样做，一个更好的方法是创建一个名为`Scripts`的文件夹在**项目**面板中。然后，右键单击并导航到**创建** | **C# 脚本**。结果，它将位于正确的文件夹中，如果我们创建一个无法附加到游戏对象的脚本，我们不会有问题。

在本书的其余部分，我们将假设每个新的脚本都是以这种方式创建的，并且始终位于`Scripts`文件夹中。

记住脚本的名称很重要，因为文件应该与脚本中的主类名相同。这意味着如果我们稍后更改类的名称，我们也需要相应地重命名文件。然而，这可能会破坏其他脚本中的某些引用，需要修正。因此，在更改名称时要小心。

要打开脚本，你需要双击它。Unity将打开脚本编辑器。默认情况下，它将是Monodevelop。然而，你可以通过导航到**编辑 | 首选项...**来更改此设置。在**外部工具**选项卡中，你可以更改**外部脚本编辑器**。另一个常用的脚本编辑器是Visual Studio，可以从[https://www.visualstudio.com/](https://www.visualstudio.com/)下载。

然而，如果你是第一次使用Unity，我建议你坚持使用Monodevelop。无论如何，对于这本书，我们没有任何要求（只要你能编辑脚本），所以请随意选择你最喜欢的。

## 脚本基础知识

如果这是你第一次在Unity中编写脚本，在我们开始之前，有一些信息需要了解。

### 注意

Unity主要支持两种语言：C#和JavaScript。由于我们在上一节中创建了一个C#脚本，因此我们将在这本书的其余部分使用这种语言。

### 变量

变量可以是公共的、私有的或受保护的。我们不会介绍最后一个，因为我们没有足够的时间，而且在Unity开发入门时它并不是很重要。私有变量只能在脚本本身中使用。通常，它们用于存储脚本内部不需要与其他组件共享的数据。

相反，公共变量可以从任何脚本中访问，因此我们需要注意它们的使用位置。当适用时，实现`get`和`set`函数是一个好的实践。即使在这本书中我们不会经常使用它们，了解它们是什么也值得学习，你可以在[https://msdn.microsoft.com/en-us/library/w86s7x04.aspx](https://msdn.microsoft.com/en-us/library/w86s7x04.aspx)找到相关信息。

此外，公共变量在**检查器**中是可见的。实际上，仅为了测试目的，你可以创建一个新的脚本并添加以下整数变量：

[PRE0]

因此，在保存脚本之后，你可以在**检查器**中设置其值，如下面的截图所示：

![变量](img/image00372.jpeg)

因此，为了能够使用公共变量，不需要在脚本中设置它们。通常，我们希望有一个公共变量，因为它将由另一个脚本设置，但在**检查器**中不可见。在Unity中，你可以通过使用属性来实现这一点。

### 属性

在变量和函数之前，Unity允许我们插入一个属性。属性被`[`和`]`包围，可以包含不同的参数。大约有30个属性，它们在功能和用法上确实有所不同。由于我们没有时间逐一介绍它们，我们只会介绍最常用的几个：

+   `Header`属性格式为`[Header("string")]`。它在其后的变量之前创建一个标题。以下是将属性添加到我们之前使用的测试脚本变量的示例：

    [PRE1]

    结果如下：

    ![属性](img/image00373.jpeg)

+   `HideInInspector` 属性的格式为 `[HideInInspector]`。它隐藏了其后的变量，使其在 **Inspector** 中不可见。这里是在上一个例子中的使用情况：

    [PRE2]

    这是结果：

    ![属性](img/image00374.jpeg)

+   `Range` 属性的格式为 `[Range(minValue, maxValue)]`。它捕捉变量在 `minValue` 到 `maxValue` 的数值范围内的可能值。再次，我们使用之前的例子：

    [PRE3]

    这是我们所得到的结果：

    ![属性](img/image00375.jpeg)

+   最后，`Tooltip` 属性的格式为 `[Tooltip("string")]`。当光标悬停在变量上时，它会在 **Inspector** 中创建一个工具提示：

    [PRE4]

    这里是结果（当光标悬停时）：

    ![属性](img/image00376.jpeg)

### 函数

任何从 `MonoBehaviour` 类派生的脚本都有两个主要功能：

+   `Start()`: 这个函数只会在游戏开始时被调用一次。在函数内设置所有变量和获取我们需要的引用很有用。

+   `Update()`: 这个函数在每一帧都会被调用，需要实时计算一些东西，比如速度或行为。然而，由于这个函数被调用得非常频繁，我们需要注意我们代码内部的内容，以避免游戏运行速度过慢。

还可以实现其他函数，并且它们将被自动调用。实际上，有超过 60 个！

我们稍后会用到其中的一些，所以在这里介绍它们，并在后面的章节中详细探讨：

+   `OnTriggerEnter2D()`: 当另一个具有碰撞器的对象进入附加到游戏对象的触发碰撞器时，会调用此函数。我们将在处理物理时更好地了解这一点。

+   `OnMouseDown()`: 如果游戏对象附加了碰撞器，并且玩家在游戏对象上按下鼠标按钮时，会调用此函数。此外，它还可以是一个 `Coroutine`，并且与 `GUIElements` 一起工作。

+   `OnEnable()`: 当对象变为启用和活动状态时，会调用此函数。

你可以在 [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html) 上了解更多关于它们的信息。

## 注释

正如我们在上一章中提到的，游戏开发不是一个容易的过程，因为它涉及许多阶段。因此，记录我们所做的一切非常重要。这并不意味着写一些将要发布的内容，而只是几行代码来提醒自己和团队我们已经完成了什么。实际上，人类的大脑在记住概念方面很出色，但在记住细节方面却不是很好！这在脚本编写阶段是至关重要的。能够阅读几天前自己和团队所写的内容非常重要。在编码时，如果不使用注释，很容易在众多代码行中迷失方向！

由于Unity使用C#编译器，因此可以在代码中插入注释。注释是会被忽略（不会编译）的行，正如其名所示，它们有助于给阅读代码的人留下信息。

在C#中注释主要有两种方式。第一种是在行首插入`//`，结果是从该行开始直到下一行之后的所有内容都将被忽略。第二种方式用于多行注释，它由一个开标签`/*`和一个闭标签`*/`包围。结果，这两个标签之间的所有内容都将被忽略。以下是一个示例：

[PRE5]

### 注意

注释也用于构建自动文档和作为其他内容的标记。然而，这超出了本书的范围。

我强烈建议你始终尝试在你的代码中插入注释，这样以后阅读起来会更方便。为了你的方便，本书附带的所有代码都提供了注释，帮助你理解正在发生的事情以及在哪里。

## 执行顺序

关于Unity中脚本编写的一个重要概念是**执行顺序**。某些脚本或代码部分在执行其他脚本或代码部分之前执行可能是基本的。结果，这将影响共享资源的修改方式和效率。

标准的顺序如下：

1.  **编辑器**：特别是，`Reset()`函数。

1.  **场景加载**：调用`Awake()`、`OnEnable()`和`OnLevelWasLoaded()`等函数。

1.  **在第一帧更新之前**：如果对象是活动的，将调用脚本中的所有`Start()`函数。

1.  **帧之间**：执行`OnApplicationPause()`函数。

1.  **更新**：调用所有不同的`Update()`函数。

1.  **渲染**：执行特定的渲染功能。

1.  **协程**：它们会一直执行，直到找到yield语句。

1.  **当对象被销毁时**：调用`Destroy()`函数。

1.  **退出时**：当禁用游戏对象或退出游戏时，将调用要执行的功能。

当然，这只是为了给你一个关于执行顺序的初步印象。如果你对这个主题感兴趣，你可以在官方文档中找到关于执行顺序的详细解释，网址为[https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)。

Unity还提供了在脚本中更改执行顺序的可能性，当你有特定需求时。这可以通过在工具栏中导航到**编辑** | **项目设置** | **脚本执行顺序**来实现。结果，这个窗口将出现在**检查器**中，你可以在这里更改顺序：

![执行顺序](img/image00377.jpeg)

如需了解更多信息，您可以访问以下链接：[https://docs.unity3d.com/Manual/class-ScriptExecution.html](https://docs.unity3d.com/Manual/class-ScriptExecution.html)。然而，脚本的执行顺序是为了特定的需求，而我们没有这样的需求，所以我们将不会修改这些设置。不过，我希望这一部分能帮助您更好地理解Unity背后的逻辑。话虽如此，我鼓励您在更好地理解Unity中的脚本编写时重新阅读这一部分。

# 制作喷雾

在*预制件*部分，我们为我们的喷雾投射物创建了预制件。在本节中，我们将了解如何使喷雾在2D空间中移动。特别是，我们将学习如何在Unity中为2D游戏元素创建和使用脚本。

## 投射物类

由于我们的游戏中可能有不同的投射物可以投向甜食爱好者熊猫，而不仅仅是喷雾，我们需要定义一个通用类。所有不同类型的投射物都将遵循一些通用规则：

+   它们沿直线移动

+   它们携带有关将对敌人造成多少伤害的信息

其中第一个对所有投射物都是相同的，第二个取决于将要发射的具体投射物类型。因此，我们需要创建一个模板。一旦我们将此脚本附加到游戏对象上，我们就可以设置一些变量并调整其行为。在这种情况下，我们想要调整造成的伤害量和速度。

### 编写投射物基类脚本

因此，首先，让我们创建一个新的脚本，并将其命名为`ProjectileScript`。接下来，我们需要定义四个变量。第一个是用于伤害量，第二个是速度，第三个是方向，因为我们需要知道投射物将飞向何方。最后一个变量存储其以秒为单位的生存时间。因此，它还与速度变量一起设置了投射物可以到达的距离。实际上，如果投射物没有击中目标，我们不希望它永远直线前进，因为这会消耗计算资源并减慢我们的游戏。因此，在这个持续时间之后，我们需要销毁它。为此，我们可以添加以下四个变量：

[PRE6]

接下来要做的事情是在`Start()`函数中设置一些参数。由于方向将由投掷实体的方向决定，我们无法保证它具有单位范数。因此，我们需要归一化方向。然后，我们需要将我们的投射物图形（在这种情况下是喷雾）旋转到正确的方向。为了实现这一点，我们需要使用`Atan2()`函数计算角度。在将这个角度转换为度数后，我们使用`Quaternion`类中的`AngleAxis()`函数来旋转我们的游戏对象。最后，我们需要在游戏对象被销毁之前设置一个计时器。因此，这将是我们`Start()`函数的内容：

[PRE7]

在`Update()`函数中，我们只需要将洒水器移动到那个方向。如果洒水器与某个物体发生碰撞，例如熊猫，这将是我们将在[第5章](part0056.xhtml#aid-1LCVG1 "第4章. 不再孤单 – 喜欢甜食的大熊猫出击")讨论的情况，*不再孤单 - 喜欢甜食的大熊猫出击*。因此，我们需要根据其方向和速度更新其位置，使其依赖于时间。因此，我们可以编写以下代码：

[PRE8]

最后，保存脚本。在这个脚本上还有很多工作要做。例如，方向应该只在*x*和*y*上，而不是*z*，因为它是用于Z缓冲区方法。然而，现在它是可以的，我们将在本书稍后讨论所有这些问题。

## 通过Prefab生成的无数洒水器

现在我们已经有一个实现抛物线行为的通用脚本，我们需要实际制作具有这种行为的洒水器的Prefab。

我们已经为我们的洒水器抛射物创建了一个Prefab，但我们需要对其进行更改。因此，进入**项目**面板中的`Prefab`文件夹，并选择我们的`Pink_Sprinkle_Projectile_Prefab`。在**检查器**中，我们需要添加我们刚刚创建的脚本。因此，导航到**添加组件** | **脚本** | **抛射物脚本**。结果，你应该看到以下内容：

![通过Prefab生成的无数洒水器](img/image00378.jpeg)

我们需要调整一些值，至少是为了测试目的，这样我们才能看到洒水器在移动。我们可以分配一个方向，例如(1, 1, 0)，以及任何值给**伤害**变量。最后，我们应该得到以下类似的结果：

![通过Prefab生成的无数洒水器](img/image00379.jpeg)

如果我们按下播放按钮，我们可以看到我们的洒水器按照我们指定的方向前进，并在`10`秒后被摧毁。

然后，我们需要在Prefab上分配**Z**值。由于它是一个抛射物，我们可以查看我们之前制作的物体所有的**Z**值表格。因此，我们需要将`-2`作为值分配。我们还需要将标签分配给我们的抛射物。我们稍后会使用这个标签，但现在最好将其分配给Prefab。

要分配一个标签，在**检查器**上，游戏对象名称下方，有一个**标签**字段，如下面的截图所示：

![通过Prefab生成的无数洒水器](img/image00380.jpeg)

一旦点击，就会出现一个下拉菜单，其中可以选择不同的标签，包括我们之前定义的两个标签：

![通过Prefab生成的无数洒水器](img/image00381.jpeg)

我们可以将**抛物线**标签分配给我们的Prefab，最终它应该看起来像这样：

![通过Prefab生成的无数洒水器](img/image00382.jpeg)

这就是我们制造抛射物所需做的所有事情。实际上，我们现在可以在需要时使用这个Prefab来生成洒水器。

# 制作纸杯蛋糕塔

在本节中，我们将了解如何创建我们的塔。这不是一项容易的任务，但通过这样做，我们将获得大量的脚本编写技能。

## 蛋糕塔的作用

首先，写下我们想要实现的目标，并定义蛋糕塔确切应该做什么是有用的。

最好的方法是写下列表，以便清楚地了解我们想要实现的目标：

+   蛋糕塔能够检测一定范围内的熊猫。

+   蛋糕塔根据其类型对一定范围内的熊猫发射不同类型的弹道。此外，在这个范围内，它使用一种策略来决定射击哪只熊猫。

+   在蛋糕塔能够再次射击之前，有一个装填时间。

+   蛋糕塔可以升级（到一个更大的蛋糕！），提高其统计数据，从而改变其外观。

## 编写蛋糕塔的脚本

正如我们在上一节中看到的，有许多事情需要实现。让我们先创建一个新的脚本，并将其命名为`CupcakeTowerScript`。正如我们之前提到的，对于弹道脚本，在本章中，我们实现主要逻辑，但当然，总有改进的空间，正如我们将在本书后面看到的。

### 射击熊猫

即使我们现在还没有敌人，我们也可以开始编写蛋糕塔射击敌人的行为。在本节中，我们将了解一些关于使用物理检测范围内对象的知识。然而，我们将在[第5章](part0056.xhtml#aid-1LCVG1 "第4章。不再孤单——甜食熊猫出击")中更详细地了解碰撞体，*不再孤单——甜食熊猫出击*。

让我们先定义四个变量。前三个是公共的，因此我们可以在检查器中设置它们。最后一个变量是私有的，因为我们只需要它来检查已经过去了多少时间。特别是，前三个变量存储我们塔的参数。它们是弹道Prefab、其范围和其装填时间。我们可以写下以下内容：

[PRE9]

现在，在`Update()`函数中，我们需要检查是否已经过去了足够的时间以便射击。这可以通过使用一个if语句轻松完成。无论如何，在最后，应增加已过时间：

[PRE10]

在`if`语句中，我们需要重置已过时间，以便在下一次射击时使用。然后，我们需要检查是否在其范围内有某些游戏对象：

[PRE11]

如果范围内有敌人，我们需要决定一个策略，关于塔应该针对哪个敌人。有不同方法来做这件事，塔本身可以选择不同的策略。在这里，我们将实现一个最近的敌人将被针对的策略。不同的策略和策略将在本书的最后一章讨论。

为了实现这项政策，我们需要遍历所有在范围内的游戏对象，检查它们是否实际上是敌人，并使用距离选择最近的一个。为了实现这一点，在之前的if语句中写入以下代码：

[PRE12]

一旦我们找到目标，我们需要获取塔将投掷投射物的方向。所以，让我们写下这个：

[PRE13]

最后，我们需要实例化一个新的投射物，并将其方向分配给敌人，如下所示：

[PRE14]

实例化GameObject通常很慢，应该避免。然而，出于学习目的，我们可以容忍这一点。在最后一章，我们将看到一些优化技术来消除这种实例化。至于射击敌人，这就完成了。

### 升级纸杯蛋糕塔，使其更加美味

为了创建一个升级塔的函数，我们首先需要定义一个变量来存储塔的实际等级：

[PRE15]

然后，我们需要一个包含所有不同升级的Sprite的数组，如下所示：

[PRE16]

需要第三个变量来检查纸杯蛋糕塔何时可以升级，因此我们可以添加：

[PRE17]

最后，我们可以创建我们的升级函数。首先，我们需要检查塔是否可以升级，然后提高它的等级。然后，我们可以根据我们拥有的不同图形的数量来检查，塔是否已经达到最大等级，如果是这样，通过将`isUpgradable`变量设置为false值，阻止玩家再对其进行升级。之后，我们需要升级图形，并提高统计数据。请随意调整这些值，按您喜欢的调整。然而，不要忘记分配新的Sprite。最后，您应该得到以下类似的内容：

[PRE18]

保存脚本，现在我们对此已经完成了。我们将在本书的后面修改这个函数，但现在让我们为我们的纸杯创建一个预制件。

## 通过预制件制作的预烘焙纸杯蛋糕塔

就像我们对糖霜所做的那样，我们需要对纸杯蛋糕塔做类似的事情。在**项目**面板的`Prefabs`文件夹中，通过右键单击并导航到**创建** | **预制件**创建一个新的预制件。将其命名为`SprinklesCupcakeTower`。

现在，将`Sprinkles_Cupcake_Tower_0`从`Graphics/towers`文件夹（在`cupcake_tower_sheet-01`文件内）拖放到**场景视图**中。通过导航到**添加组件** | **脚本** | `CupcakeTowerScript`将`CupcakeTowerScript`附加到对象上。**检查器**应该看起来像以下这样：

![通过预制件制作的预烘焙纸杯蛋糕塔](img/image00383.jpeg)

我们需要将 `Pink_Sprinkle_Projectile_Prefab` 分配给 **Projectile Prefab** 变量。然后，我们需要为升级分配不同的 Sprites。特别是，我们可以使用与之前相同的表格中的 `Sprinkles_Cupcake_Tower_*`（将 `*` 替换为纸杯蛋糕塔的等级）。不必过于担心塔的其他参数，例如射程半径或装填时间，因为我们将在稍后看到如何平衡游戏。最后，我们应该看到以下内容：

![通过 Prefabs 预先烘焙的纸杯蛋糕塔](img/image00384.jpeg)

最后一步是将这个游戏对象拖放到 Prefab 中。结果，我们的纸杯蛋糕塔就准备好了。

# 更多关于在 Unity 中编码的内容

在我们继续之前，还有一些其他的事情需要学习。

在本书的后面，我们将使用静态变量和继承。这些主题与 C# 比起 Unity 来说更为相关，但如果你想要成为一名优秀的游戏开发者，它们是非常重要的。接下来，你可以找到一个非常简短的说明，但我建议你从 C# 书籍中正确地学习它们。

最后，还有概率，正如我们之前讨论的，它是游戏开发中必不可少的。然而，一旦你掌握了概率的基础，你应该能够在 Unity 中生成随机数。

## 静态变量

一些类（或组件，在 Unity 的情况下），包含变量，这些变量最终可以在检查器中设置或在运行时更改。然而，整个类可以将其变量共享给所有其实例。这些变量被称为静态变量，并使用 `static` 关键字声明。一个常见的用途是共享对另一个组件的引用，所有类的实例都应该引用它。我们将在本书稍后更好地了解这一点，当我们使用静态变量时。

## 继承

如果不同的类在许多方面有共同之处，我们可以给它们一个继承结构。这意味着有一个父类，它包含这些类之间的一般和共同特征，然后它们作为父类的子类来实现。一个常见的例子是为了阐明这一点，想象一下 Fruit、Apple 和 Banana 类。Fruit 是父类，它包含成为水果的所有属性（例如，它是可食用的），子类共享父类的相同特征（因为苹果和香蕉都是水果，因此是可食用的）。然后，它们可以实现该水果的具体特征。例如，苹果是红色的，而香蕉是黄色的。

有时，父类也可以有自己的函数（例如 `Eat()`），所有子类都可以提供自己的实现。这导致了抽象方法和虚拟方法之间的区别。

抽象方法非常抽象，以至于父类不能为其提供实现，但它的子类必须提供。虚拟方法，相反，可以在父类中实现，因为它提供了通用功能，但子类可以覆盖它以提供更好的实现。

我们将在[第7章](part0088.xhtml#aid-2JTHG1 "第7章。交易蛋糕和终极蛋糕之战 – 游戏玩法编程")中更详细地探讨继承，*交易蛋糕和终极蛋糕之战 - 游戏玩法编程*。

## Unity中的随机数

在Unity中生成随机数很容易，因为Unity提供了`Random`类，它允许我们生成随机数。这个类最常用的函数是`Range()`，它生成一个介于最小值和最大值之间的随机数。以下是一个示例：

[PRE19]

想了解更多关于`Random`类的信息，请访问官方文档：[https://docs.unity3d.com/ScriptReference/Random.html](https://docs.unity3d.com/ScriptReference/Random.html)。

# 作业

在本章中，我们看到了如何使用预制体快速复制和克隆GameObject。所以，在你继续下一章之前，让我们熟练地使用预制体。

以下两个练习是游戏完成时所需的：

1.  **武装蛋糕塔（第一部分）**：在`Graphics/projectiles`文件夹中的`projectiles_sheet_01`内部，有九种不同的投射物；然而，我们只使用了其中一种，`Pink_Sprinkle`。为其他八种预制体创建名称有意义的预制体。别忘了将投射物脚本附加到所有这些预制体上。不必过于担心脚本内部分配的值，例如伤害，因为我们在本书后面的部分将看到游戏的平衡。然而，别忘了分配正确的**Z**值和适当的标签。

1.  **武装蛋糕塔（第二部分）**：在`Graphics/towers`文件夹中的`cupcake_tower_sheet-01`内部，有三个不同的塔及其相应的升级级别；然而，我们只使用了洒糖蛋糕塔。为巧克力和柠檬蛋糕塔创建另外两个预制体。别忘了将蛋糕塔脚本附加到这两个预制体上，并分配相应的投射物和升级级别图形。同样，不必过于担心值，例如范围半径，因为我们在本书后面的部分将看到游戏的平衡。然而，别忘了分配正确的**Z**值。

    以下练习将帮助你通过熟悉最佳实践来提高你的技能：

1.  **为设计师格式化脚本（第一部分）**：在我们的脚本中，我们使用了许多变量。它们旁边的注释帮助我们理解它们的功能；然而，这些注释对设计师来说是隐藏的。因此，添加工具提示以在**检查器**中显示是一个好习惯。如果你愿意，可以使用注释的文本作为工具提示的参数。

1.  **为设计师格式化脚本（第二部分）**：即使我们在**检查器**中的脚本看起来不错，如果我们给变量组添加一些标题，它们还可以得到改进。因此，分配有意义的标题并重新排列变量以适应这些标题。

1.  **为设计师格式化脚本（第三部分）**：在弹道脚本内部的`direction`变量必须设置为公共的，因为它是从纸杯蛋糕塔脚本中改变的。然而，它应该在**检查器**中可见。使用属性来隐藏它从**检查器**中。

1.  **为设计师格式化脚本（第四部分）**：在我们的脚本中，一些变量最好用滑块来显示，而不是数字输入字段，尤其是那些不能假设为负数的变量。对于这些变量，将它们的显示形式转换为滑块，并禁止它们有负值。

1.  **最佳实践（第一部分）**：在纸杯蛋糕塔脚本内部有一个`Upgrade Level`变量，它是私有的。然而，创建一个获取函数来检索其值可能是有用的。通过遵循本章*变量*部分中显示的链接中的指南，实现相应的获取函数。

1.  **最佳实践（第二部分）**：再次在纸杯蛋糕塔脚本内部，在`Upgrade()`函数中，调用`GetComponent()`函数来获取`SpriteRenderer`。最佳实践建议只调用一次这个函数，并将引用存储在一个变量中。创建一个新的变量来存储附加到纸杯蛋糕塔游戏对象的`SpriteRenderer`组件。通过在`Start()`函数中使用`GetComponent()`函数来分配其值。然后，在`Upgrade()`函数中使用这个变量来更新纸杯蛋糕塔的图形。

1.  **最佳实践（第三部分）**：我们没有为纸杯蛋糕塔定义标签，因为我们不需要区分它们。然而，为它们分配一个标签是良好的实践。这是因为将来我们可能需要它，当我们想要扩展我们的游戏时（例如，敌人试图在其限制内避免纸杯蛋糕塔）。因此，创建一个新的纸杯蛋糕塔标签，并将其分配给所有纸杯蛋糕塔Prefab（应该有三个，包括本节第一个练习中创建的一个）。

# 摘要

在本章中，我们看到了如何使用Prefab快速复制和克隆游戏对象。我们还学习了如何放置2D对象，使用Z-Buffering方法对它们进行排序，以及如何在Unity中设置标签和层。然后，我们创建了一些脚本，并在学习过程中了解到如何用几行代码编写复杂的行为。实际上，我们探索了Unity如何处理脚本，它们的主要功能和属性，以及一般的执行顺序。

然而，我们将在本书的后面部分改进本章中编写的脚本，以改善游戏玩法。实际上，本章的目标是熟悉脚本，并记录主要逻辑。因此，改进和调整留待以后。

在下一章中，我们将深入UI世界，并将其集成到我们的游戏中。
