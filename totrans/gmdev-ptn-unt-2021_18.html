<html><head></head><body>
        

                            
                    Concealing Complexity with a Facade Pattern
                
            
            
                
<p>The Facade pattern is an easy pattern to grasp because its name implies its purpose. The primary intent of the Facade pattern is to offer a simplified front-facing interface that abstracts the intricate inner workings of a complex system. This approach is beneficial for game development because games are composed of complex interactions between various systems. As a use case, we will write code that simulates the behavior and interactions of a vehicle's engine core components and then offers a simple interface to interact with the overall system.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Understanding the Facade pattern</li>
<li>Designing a bike engine</li>
<li>Implementing a bike engine</li>
<li>A basic implementation of a vehicle's engine with the Facade pattern</li>
</ul>
<p>This section includes a simplified version of the implementation of an engine for simplicity and brevity reasons. A complete implementation of this code example can be found in the <kbd>/FPP</kbd> folder of the GitHub project—the link is available under the <em>Technical requirements</em> section.</p>
<h1 id="uuid-baae01f4-e929-40da-8e20-c61873b56597">Technical requirements</h1>
<p class="mce-root">This is a hands-on chapter, so you will need to have a basic understanding of Unity and C#.</p>
<p>The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter15</a>.</p>
<p class="mce-root">Check out the following video to see the code in action: </p>
<p><a href="https://bit.ly/36wJdxe">https://bit.ly/36wJdxe</a></p>
<h1 id="uuid-0991ff58-5491-4666-bee2-9fd21c9820a9">Understanding the Facade pattern</h1>
<p>The Facade pattern's name is analogous to the facade of a building—as the name implies, it's an exterior face that hides a complex inner structure. Contrary to building architecture, in software development, the goal of a facade is not to beautify; instead, it is to simplify. As we are going to see in the following diagram, an implementation of the Facade pattern is usually limited to a single class that acts as a simplified interface to a collection of interacting subsystems:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7948ddd6-8d2d-4779-a345-a4a5cccf0d76.png" style="width:50.92em;height:38.75em;"/></p>
<p>Figure 15.1 – Unified Modeling Language (UML) diagram of the Facade pattern</p>
<p>As we can see in the preceding diagram, <kbd>EngineFacade</kbd> acts as an interface to the various components of the engine, thereupon the client is unaware of what is happening behind the scenes when calling <kbd>StartEngine()</kbd> on <kbd>EngineFacade</kbd>. It's unaware of the components that make up the engine and how to reach them; it only knows what it needs to know. This is similar to what happens when you turn the ignition key in your car—you don't see what's happening under the hood, and you don't need to; your only concern is that the engine starts. And so, the Facade pattern offers this same level of abstraction in your code, keeping the details of the system under the hood.</p>
<p>The Facade pattern is part of the structural pattern category. Patterns in this classification are concerned with how classes and objects are composed to form larger structures.</p>
<h2 id="uuid-29b2e4f2-f72e-4beb-873c-73ce7ec2a5e4">Benefits and drawbacks</h2>
<p>Here are some <strong>benefits</strong> of the Facade pattern:</p>
<ul>
<li><strong>Simplified interface to a complex body of code</strong>: A solid Facade class will conceal complexity from a client while providing a simplified interface to interact with an intricate system.</li>
<li><strong>Easy refactoring</strong>: It's easier to refactor code that's isolated behind a Facade because the system's interface remains consistent to the client while its components are being modified behind the scenes.</li>
</ul>
<p>The following are some <strong>drawbacks</strong> to watch out for:</p>
<ul>
<li><strong>It makes it easier to hide the mess</strong>: Using the Facade pattern to hide messy code behind a clean front-facing interface will defeat the pattern's core benefits in the long run, but this pattern does offer a way to mask some code smells until you have time to refactor them. However, expecting to have enough time later to fix stuff is a trap in itself because we rarely have enough time to refactor things correctly.</li>
<li><strong>Too many facades</strong>: Globally accessible manager classes that act as facades to core systems are popular among Unity developers; they often implement them by combining the Singleton and Facade patterns. Unfortunately, it's too easy to abuse this combination and end up with a code base comprising too many manager classes, each dependent on the other to function. As a consequence, debugging, refactoring, and unit testing components becomes very difficult.</li>
</ul>
<p>The Facade pattern establishes a new interface, whereas the Adapter pattern adapts an old interface. Therefore, when implementing patterns that might look and sound similar, it's essential to keep in mind that they're not necessarily identical in their purpose.</p>
<h1 id="uuid-fdf80970-78f6-436d-abc5-36d47ae315e6">Designing a bike engine</h1>
<p class="mce-root">We are not aiming to implement a complete simulation of an actual gas engine for a bike; this will take too long and demands an in-depth understanding of the physics and mechanics of a real-world engine. But we will aim to simulate, to a minimal degree, some standard components of a high-speed vehicle's motor. So first, let's break down the expected behavior of each part of our engine, as follows:</p>
<ul>
<li><strong>Cooling system</strong>: The cooling system is responsible for making sure the engine is not overheating. When the turbocharger is activated, the cooling system shuts down during a turbocharge. This behavior means that if the player overuses the turbocharger, this can overheat the engine, and in consequence, the engine will stop or explode and the bike will stop moving.</li>
<li><strong>Fuel pump</strong>: This component is responsible for managing the fuel consumption of the bike. It knows the amount of gas remaining and stops the engine if it runs out of it.</li>
<li><strong>Turbocharger</strong>: If the turbocharger is activated, the vehicle's top speed is increased, but the cooling system shuts down temporarily so that the engine's circuitry can relay power to the charger. </li>
</ul>
<p>In the next section, we will implement a skeleton class for each of these components and establish an engine <kbd>Facade</kbd> class so that clients can start and stop the engine.</p>
<p>The design intention of having the cooling system shut down when the turbocharger is activated is to create a sense of risk versus reward. The player must balance the desire to go faster with the potential consequence of overheating the engine.</p>
<h1 id="uuid-9f696e95-36c8-4d85-a029-26448f57291f">Implementing a bike engine</h1>
<p>As we are going to see, the Facade pattern is straightforward, so we will keep the following code example simple and straight to the point. To start, we will write the classes for each of the core components that make up the bike's engine, as follows:</p>
<ol>
<li>We will start with the fuel pump; the purpose of this component is to simulate the consumption of fuel so that it knows the amount remaining and shuts down the engine when it runs out. Here's the code you'll need:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>namespace Chapter.Facade<br/>{<br/>    public class FuelPump : MonoBehaviour<br/>    {<br/>        public BikeEngine engine;<br/>        public IEnumerator burnFuel;<br/><br/>        void Start()<br/>        {<br/>            burnFuel = BurnFuel();<br/>        }<br/><br/>        IEnumerator BurnFuel()<br/>        {<br/>            while (true)<br/>            {<br/>                yield return new WaitForSeconds(1);<br/>                engine.fuelAmount -= engine.burnRate;<br/><br/>                if (engine.fuelAmount &lt;= 0.0f) {<br/>                    engine.TurnOff();<br/>                    yield return 0;<br/>                }<br/>            }<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            GUI.color = Color.green;<br/>            GUI.Label(<br/>                new Rect(100, 40, 500, 20), <br/>                "Fuel: " +  engine.fuelAmount);<br/>        }<br/></pre>
<pre style="padding-left: 60px">    } <br/>}</pre>
<ol start="2">
<li>Next up is the cooling system, which is responsible for preventing the engine from overheating but gets deactivated if the turbocharger is activated. The code is illustrated in the following snippet:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>namespace Chapter.Facade {<br/>    public class CoolingSystem : MonoBehaviour {<br/>        <br/>        public BikeEngine engine;<br/>        public IEnumerator coolEngine;<br/>        private bool _isPaused;<br/><br/>        void Start() {<br/>            coolEngine = CoolEngine();<br/>        }<br/><br/>        public void PauseCooling() {<br/>            _isPaused = !_isPaused;<br/>        }<br/><br/>        public void ResetTemperature() {<br/>            engine.currentTemp = 0.0f;<br/>        }<br/><br/>        IEnumerator CoolEngine() {<br/>            while (true) {<br/>                yield return new WaitForSeconds(1);<br/><br/>                if (!_isPaused) {<br/>                    if (engine.currentTemp &gt; engine.minTemp)<br/>                        engine.currentTemp -= engine.tempRate;<br/>                    if (engine.currentTemp &lt; engine.minTemp)<br/>                        engine.currentTemp += engine.tempRate;<br/>                } else {<br/>                    engine.currentTemp += engine.tempRate;<br/>                }<br/><br/>                if (engine.currentTemp &gt; engine.maxTemp)<br/>                    engine.TurnOff();<br/>            }<br/>        }<br/><br/>        void OnGUI() {<br/>            GUI.color = Color.green;<br/>            GUI.Label(<br/>                new Rect(100, 20, 500, 20), <br/>                "Temp: " +  engine.currentTemp);<br/>        }<br/>    }<br/>}</pre>
<ol start="3">
<li>And finally, the turbocharger, when activated, increases the bike's top speed, but for it to function, it needs to deactivate the cooling system temporarily. Here's the code to accomplish this:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>namespace Chapter.Facade<br/>{<br/>    public class TurboCharger : MonoBehaviour<br/>    {<br/>        public BikeEngine engine;<br/>        <br/>        private bool _isTurboOn;<br/>        private CoolingSystem _coolingSystem;<br/><br/>        public void ToggleTurbo(CoolingSystem coolingSystem)<br/>        {<br/>            _coolingSystem = coolingSystem;<br/>            <br/>            if (!_isTurboOn)<br/>                StartCoroutine(TurboCharge());<br/>        }<br/><br/>        IEnumerator TurboCharge()<br/>        {<br/>            _isTurboOn = true;<br/>            _coolingSystem.PauseCooling();<br/><br/>            yield return new WaitForSeconds(engine.turboDuration);<br/><br/>            _isTurboOn = false;<br/>            _coolingSystem.PauseCooling();<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            GUI.color = Color.green;<br/>            GUI.Label(<br/>                new Rect(100, 60, 500, 20), <br/>                "Turbo Activated: " +  _isTurboOn);<br/>        }<br/></pre>
<pre style="padding-left: 60px">    }<br/>}</pre>
<ol start="4">
<li>Now that we have the core components of our engine ready, we need to implement a class that will permit a client to interact with them seamlessly. So, we will implement a Facade class called <kbd>BikeEngine</kbd> that will offer an interface for a client to start and stop the engine and toggle the turbocharger. But because the following code example is so long, we will review it in two parts. Here's the first part:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Facade<br/>{<br/>    public class BikeEngine : MonoBehaviour<br/>    {<br/>        public float burnRate = 1.0f;<br/>        public float fuelAmount = 100.0f;<br/>        public float tempRate = 5.0f;<br/>        public float minTemp = 50.0f;<br/>        public float maxTemp = 65.0f;<br/>        public float currentTemp;<br/>        public float turboDuration = 2.0f;<br/><br/>        private bool _isEngineOn;<br/>        private FuelPump _fuelPump;<br/>        private TurboCharger _turboCharger;<br/>        private CoolingSystem _coolingSystem;<br/><br/>        void Awake() {<br/>            _fuelPump = <br/>                gameObject.AddComponent&lt;FuelPump&gt;();<br/>            <br/>            _turboCharger = <br/>                gameObject.AddComponent&lt;TurboCharger&gt;();<br/>            <br/>            _coolingSystem = <br/>                gameObject.AddComponent&lt;CoolingSystem&gt;();<br/>        }<br/><br/>        void Start() {<br/>            _fuelPump.engine = this;<br/>            _turboCharger.engine = this;<br/>            _coolingSystem.engine = this;<br/>        }</pre>
<p style="padding-left: 60px">The first part of this class is initialization code and is self-explanatory, but the following segment is the important part:</p>
<pre style="padding-left: 60px">        public void TurnOn() {<br/>            _isEngineOn = true;<br/>            StartCoroutine(_fuelPump.burnFuel);<br/>            StartCoroutine(_coolingSystem.coolEngine);<br/>        }<br/><br/>        public void TurnOff() {<br/>            _isEngineOn = false;<br/>            _coolingSystem.ResetTemperature();<br/>            StopCoroutine(_fuelPump.burnFuel);<br/>            StopCoroutine(_coolingSystem.coolEngine);<br/>        }<br/><br/>        public void ToggleTurbo() {<br/>            if (_isEngineOn) <br/>                _turboCharger.ToggleTurbo(_coolingSystem);<br/>        }<br/><br/>        void OnGUI() {<br/>            GUI.color = Color.green;<br/>            GUI.Label(<br/>                new Rect(100, 0, 500, 20), <br/>                "Engine Running: " +  _isEngineOn);<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">As we can see, the <kbd>EngineFacade</kbd> class exposes the available functionality that the bike engine offers but, at the same time, conceals the interaction between its components. If we want to start the engine, we just need to call the <kbd>StartEngine()</kbd> method. If we didn't have a Facade pattern such as the one we just implemented, we would have to initialize each engine component individually and know each of their parameters to set and the methods to call. The Facade pattern permits us to tuck all the complexity away behind a clean interface.</p>
<p class="mce-root">But suppose we wished to add another engine component, such as a nitro injector; in that case, we would only need to modify the <kbd>BikeFacade</kbd> class and expose a new public method to allow us to trigger the injector.</p>
<h2 id="uuid-a656c327-d304-4371-be71-23d13ee71042">Testing the engine facade</h2>
<p>We can quickly test the code we just implemented by adding the following client script to a GameObject in an empty Unity scene:</p>
<pre>using UnityEngine;<br/><br/>namespace Chapter.Facade<br/>{<br/>    public class ClientFacade : MonoBehaviour<br/>    {<br/>        private BikeEngine _bikeEngine;<br/><br/>        void Start()<br/>        {<br/>            _bikeEngine = <br/>                gameObject.AddComponent&lt;BikeEngine&gt;();<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            if (GUILayout.Button("Turn On"))<br/>                _bikeEngine.TurnOn();<br/><br/>            if (GUILayout.Button("Turn Off"))<br/>                _bikeEngine.TurnOff();<br/><br/>            if (GUILayout.Button("Toggle Turbo"))<br/>                _bikeEngine.ToggleTurbo();<br/>        }<br/>    }<br/>}</pre>
<p>In the client class, we see that it's not aware of the engine's inner workings, and this is the effect we want to achieve when using the Facade pattern. The only thing the client class knows is that it can start and stop the engine and toggle on a turbocharged feature by calling the public methods made available by the <kbd>BikeEngine</kbd> class. To put it another way, just as in real life, we don't need to open the hood to start the engine; we turn the ignition key, and the components start working together without us knowing how they are interacting with each other.</p>
<p class="mce-root">In the next section, we will review alternative solutions to consider before deciding on using the Facade pattern.</p>
<p>In a potentially more advanced version of this code example, the engine would calculate the current <strong>revolutions per minute</strong> (<strong>RPM</strong>)—also known as the engine's speed—and we could connect it to a gear system regulated by a shifter input with which the player could control the bike's speed. Thus, we could easily enhance the level of realism at any time.</p>
<h1 id="uuid-c57e4342-6274-4726-899b-1fbcc5ad6064">Reviewing alternative solutions</h1>
<p>There are several alternatives to keep in mind before considering the Facade pattern, depending on what you are actually trying to accomplish. These are listed here:</p>
<ul>
<li><strong>Abstract Factory pattern:</strong> If you only want to conceal how subsystem objects are initialized from the client code, you should consider using the Abstract Factory pattern instead of the Facade pattern.</li>
<li><strong>Adapter</strong>: If you are intending to write a "wrapper" over existing classes with the intent to bridge two incompatible interfaces, then you should consider using the Adapter pattern.</li>
</ul>
<h1 id="uuid-52c50f59-244d-48a7-8627-c51ff862bb7e">Summary</h1>
<p>Even though the Facade pattern is sometimes used to hide messy code, when you use it as intended, it can enhance your code base's readability and usability by masking underlying complex interactions of subsystems behind a singular front-facing interface. Thus, it's a pattern that can be very beneficial for game programming, but one to use wisely and with good intent.</p>
<p>In the upcoming chapter, we will explore a pattern named Service Locator, which we will use to manage global dependencies and expose core services.</p>


            

            
        
    </body></html>