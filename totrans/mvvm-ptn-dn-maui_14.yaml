- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Troubleshooting and Debugging Tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on making it this far in your journey to mastering the MVVM
    pattern in .NET MAUI! By now, you’ve learned about the intricacies of data binding,
    dependency injection, converters, and various other components that make up your
    *Recipes!* app. However, as any seasoned developer will tell you, even the most
    experienced experts encounter roadblocks from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM, with all its benefits, can sometimes feel like navigating a complex maze.
    When you encounter issues, it’s not always obvious where to find the root cause
    or how to fix it. That’s where this chapter comes in. In this short but invaluable
    chapter, we’ll shine a light on common pitfalls and challenges you may face during
    your MVVM journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore three areas where issues often tend to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Common data binding issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services and Dependency Injection pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequent custom control and converter problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started on our journey through these common stumbling blocks. By the
    end of this chapter, you’ll be better equipped to troubleshoot and conquer the
    challenges that MVVM in .NET MAUI may throw your way.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure you’re in sync with the upcoming content, make your way to our GitHub
    repository at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter14](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter14).
    Kick off with the materials in the `Start` folder. And remember, if you’re ever
    in need of a consolidated reference, the `Finish` folder holds the final, refined
    code at the chapter’s close.
  prefs: []
  type: TYPE_NORMAL
- en: Common data binding issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the cornerstones of the MVVM pattern is data binding. It forms the link
    between your View and ViewModel, ensuring seamless communication between them.
    While data binding offers powerful capabilities, it’s also an area where developers
    often face challenges. This section aims to shed light on common data binding
    and ViewModel issues and how to troubleshoot them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Typos and mismatched names**: One of the simplest yet surprisingly common
    issues developers encounter is typos or mismatched property names. A small typo
    in your XAML markup or ViewModel code can disrupt the entire data binding process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneWay`, `TwoWay`, and `OneTime`, each with its own purpose, as we’ve seen
    in [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069), *Data Binding in .NET MAUI*.
    Using the wrong mode can lead to unexpected behavior in your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` to a property of type `Color` on a UI control won’t work, despite XAML
    supporting implicit type conversion in certain cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropertyChanged` events. What happens when these events don’t trigger as expected?
    The View will not be updated to reflect the changes in the ViewModel’s data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObservableCollection`. Make sure your collections update correctly and avoid
    the pitfall of inadvertently assigning a new `ObservableCollection`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView` or `CollectionView`, keep in mind that each item in the collection
    creates its own data binding scope. This means that when attempting to bind a
    property or command that resides in the ViewModel rather than the individual item,
    you’ll need to use techniques such as relative or element binding to correctly
    reference the desired context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data binding in behaviors**: Behaviors exist outside the visual tree, which
    means they do not have the same capability for locating ancestors as other UI
    elements do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some of these pitfalls, such as typos in property names and binding incompatible
    data types, can be avoided by leveraging compiled bindings, as stipulated in [*Chapter
    4*](B20941_04.xhtml#_idTextAnchor069), *Data Binding in .**NET MAUI*.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a lot of issues related to data binding can arise. Luckily,
    some of them aren’t that hard to spot and fix, as long as you know where to look.
    Let’s start off by looking at some tools in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Output and XAML Binding Failures window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With both the **Output** window and **XAML Binding Failures** window in Visual
    Studio, typos or mismatched property names can easily be spotted. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first introduce two faulty data binding statements in our code. On `RecipesOverviewPage`,
    update the `Image` and `Label` elements in the `CollectionView`’s `ItemTemplate`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the app. While the app is running, head over to Visual Studio and open
    up the **Output** window. If it’s not already open, you can open it through **Debug**
    | **Windows** | **Output**. Notice the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, let’s have a look at the **XAML Binding Failures** window in
    Visual Studio. This can be opened through **Debug** | **Windows** | **XAML Binding
    Failures**. *Figure 14**.1* shows what this window looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.1: XAML Binding Failures window](img/B20941_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: XAML Binding Failures window'
  prefs: []
  type: TYPE_NORMAL
- en: This window gives us the same information as the **Output** window. Additionally,
    it shows extra information such as where the failing binding statement is located
    and how many times this issue has occurred. The best thing about this window?
    When clicking on an item in this list, Visual Studio will open the XAML file where
    the faulty binding statement is located and will put the pointer on the exact
    data binding statement that contains the error.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have a binding failure in your application, the **XAML Binding
    Failures** window and the **Output** window in Visual Studio will provide information
    about what went wrong. The **XAML Binding Failures** window, especially, provides
    immediate insight into typos, missing properties, or data type issues. Always
    keep an eye on this window when developing your views.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to troubleshoot or debug data binding issues is by creating and
    leveraging a specialized converter. Let’s have a look!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with a DoNothingConverter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `DoNothingConverter` is an invaluable tool for debugging. By placing it in
    your binding pipeline, you can inspect the values being passed during the binding
    process. If you see unexpected values or none at all, it can help pinpoint where
    the breakdown occurs. Here’s the implementation of the `DoNothingConverter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To add and use this converter in your binding statements, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `DoNothingConverter` to the `Resources` of the page where you want to
    debug a binding statement. Here’s how we can add it to `RecipesOverviewPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the converter to the binding statement you want to debug, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Insert a breakpoint in the `Convert` or `ConvertBack` method of the `DoNothingConverter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the breakpoint is hit during runtime, it indicates a successful binding to
    an existing property on the ViewModel. You’ll notice that the breakpoint in the
    `Convert` method will not be hit for the `Titel` binding as this property doesn’t
    exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the breakpoint isn’t hit on subsequent updates of the property value, check
    the binding mode of the statement and ensure that the `PropertyChanged` method
    is triggered when the property gets updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the breakpoint is hit, you can easily inspect the bound value and compare
    it to your expectations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also examine the `targetType` parameter, which represents the type of
    the target property. Keep in mind that while XAML supports implicit type conversion
    in certain cases, it’s essential to be aware of the specific conversions supported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ConvertBack` method should be called when the property on the UI controls
    is updated and the binding mode is set to `TwoWay` or `OneWayToSource`. If you
    expect this to work but the `ConvertBack` method is not called, check the binding
    statement’s binding mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following these steps and utilizing the `DoNothingConverter` tool, you can
    effectively troubleshoot data binding issues in your MVVM application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s discuss another cause of potential data binding issues: collections.'
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with collections, especially `ObservableCollection`, developers
    frequently encounter challenges related to updates and bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using an `ObservableCollection` or any collection implementing the
    `INotifyCollectionChanged` interface, it’s usually assigned once during the initialization
    of your ViewModel. Here’s an important nuance to keep in mind: the setter for
    this property doesn’t trigger the `PropertyChanged` event. Instead, when you add
    or remove items from the collection, it triggers the `CollectionChanged` event
    on the collection instance. This event, in turn, updates the bound control, assuming
    it supports binding to `ObservableCollection`. To verify whether a specific control
    works well with the `INotifyCollectionChanged` interface, consult the control’s
    documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there’s a critical point to be aware of: if the `ObservableCollection`
    is assigned anew, the binding will effectively be *lost*, unless, of course, the
    `PropertyChanged` event is properly raised. This means that if you reassign the
    entire collection with a new instance of `ObservableCollection`, you need to ensure
    that the `PropertyChanged` event is correctly triggered. To check whether this
    event is effectively raised, you can utilize the `DoNothingConverter`.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, when you’re working with a collection that doesn’t implement `INotifyCollectionChanged`
    (as in the case of a standard `List` or similar collections), adding or removing
    items won’t be automatically detected by the UI layer. In this scenario, the `PropertyChanged`
    event must be explicitly triggered when items are added to or removed from the
    collection. Consequently, the entire list will be re-rendered in the UI when you
    make changes.
  prefs: []
  type: TYPE_NORMAL
- en: When troubleshooting issues related to collections, pay close attention to whether
    you’re using `ObservableCollection` or non-observable collections, and ensure
    that you trigger the appropriate events to keep your ViewModel and UI in sync.
    Understanding these dynamics will help you navigate the complexities of collections
    in your MVVM application more effectively and prevent potential issues.
  prefs: []
  type: TYPE_NORMAL
- en: When working with collections, remember that you don’t need to trigger a `PropertyChanged`
    event on the collection itself when a property of an item within the collection
    changes. Instead, the key lies in raising the `PropertyChanged` event on the instance
    of the specific item that underwent modification. This ensures that the UI is
    notified of changes at the item level and reflects the updated state accurately.
    In essence, you’re focusing the update event precisely where it matters, minimizing
    unnecessary updates to the entire collection.
  prefs: []
  type: TYPE_NORMAL
- en: The data binding pitfall on Behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s very easy to oversee this while writing XAML, but relative source binding
    won’t work on Behaviors. That is because Behaviors exist outside the visual tree.
    In fact, a Behavior can even be reused by multiple UI elements, hence a relative
    source binding won’t be able to retrieve a parent object. When applying relative
    source binding to a Behavior, your app will crash, preceded by an exception of
    type `System.InvalidOperationException`. The exception states the following: **Operation
    is not valid due to the current state of the object**. This exception alongside
    this message should be an indication that there is a faulty data binding statement
    defined on a Behavior. There will be no further indication in the exception or
    in the **Output** window whatsoever. The only thing you can do is systematically
    go through the Behaviors in your code and look at their binding statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, the relative source binding can be replaced by element binding,
    as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <ContentView
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: x:Name="root">
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: <toolkit:IconTintColorBehavior
  prefs: []
  type: TYPE_NORMAL
- en: TintColor="{Binding IsFavorite,
  prefs: []
  type: TYPE_NORMAL
- en: Source={x:Reference root},
  prefs: []
  type: TYPE_NORMAL
- en: Converter=...}" />
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: </ContentView>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: public static readonly BindableProperty
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IsFavoriteProperty =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BindableProperty.Create(nameof(IsFavorite), …);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public bool IsFavorite
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public static readonly BindableProperty
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IsFavoriteProperty =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BindableProperty.Create(nameof(IsFavorite),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: typeof(bool), …);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public bool IsFavorite
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'public partial class FavoriteControl : ContentView'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public static readonly BindableProperty
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IsFavoriteProperty =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BindableProperty.Create(...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: typeof(FavoriteControl),...);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public bool IsFavorite
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public static readonly BindableProperty IsFavoriteProperty = ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public bool IsFavorite
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get => (bool)GetValue(IsFavoriteProperty);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set => SetValue(IsFavoriteProperty, value);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <Image
  prefs: []
  type: TYPE_NORMAL
- en: HeightRequest="{Binding HeightRequest,
  prefs: []
  type: TYPE_NORMAL
- en: Source={x:Reference icon}}"
  prefs: []
  type: TYPE_NORMAL
- en: IsVisible="{Binding IsInteractive,
  prefs: []
  type: TYPE_NORMAL
- en: Source={RelativeSource AncestorType={x:Type
  prefs: []
  type: TYPE_NORMAL
- en: local:FavoriteControl}}}"
  prefs: []
  type: TYPE_NORMAL
- en: '... />'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
