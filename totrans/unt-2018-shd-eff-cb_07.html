<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Fragment Shaders and Grab Passes</h1>
                
            
            
                
<p class="calibre3">So far, we have relied on Surface Shaders. They have been designed to simplify the way shader coding works, providing meaningful tools for artists. If we want to push our knowledge of shaders further, we need to venture into the territory of Vertex and Fragment Shaders.</p>
<p class="calibre3">In this chapter, you will learn the following recipes:</p>
<ul class="calibre11">
<li class="calibre12">Understanding Vertex and Fragment Shaders</li>
<li class="calibre12">Using grab passes to draw behind objects</li>
<li class="calibre12">Implementing a Glass Shader</li>
<li class="calibre12">Implementing a Water Shader for 2D games</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            
                
<p class="calibre3">Compared to Surface Shaders, Vertex and Fragment Shaders come with little to no information about the physical properties that determine how light reflects on surfaces. What they lack in expressivity, they compensate for with power: Vertex and Fragment Shaders are not limited by physical constraints and are perfect for non-photorealistic effects. This chapter will focus on a technique called the <strong class="calibre5">grab pass</strong>, which allows these shaders to simulate deformations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Understanding Vertex and Fragment Shaders</h1>
                
            
            
                
<p class="calibre3">The best way to understand how Vertex and Fragment Shaders work is by creating one yourself. This recipe will show you how to write one of these shaders, which will simply apply a texture to a model and multiply it by a given color, as shown in the following screenshot:</p>
<div><img src="img/00154.jpeg" class="calibre25"/></div>
<p class="calibre3">Notice how it works similarly to how the Multiply filter in Photoshop works. That's because we will be doing the same calculation done there!</p>
<p class="calibre3">The shader presented here is very simple, and it will be used as a starting base for all the other Vertex and Fragment Shaders.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">For this recipe, we will need a new shader. Follow these steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new shader (<kbd class="calibre13">Multiply</kbd>).</li>
<li value="2" class="calibre12">Create a new material (<kbd class="calibre13">MultiplyMat</kbd>) and assign the shader to it.</li>
<li value="3" class="calibre12">Bring the soldier prefab from the <kbd class="calibre13">Chapter 06 </kbd>| <kbd class="calibre13">Prefabs</kbd> folder into the scene, and attach the new material to the prefab's head. The head can be found in the <kbd class="calibre13">Soldier</kbd> child of the <kbd class="calibre13">Soldier</kbd> object.</li>
<li value="4" class="calibre12">From there, in the Inspector tab, scroll down to the Skinned Mesh Renderer component and, under Materials, set Element 0 to the new materials. Lastly, in the <kbd class="calibre13">Albedo (RGB)</kbd> property, drag and drop the <kbd class="calibre13">Unity_soldier_Head_DIF_01</kbd> texture. The following screenshot should help demonstrate what we are looking for:</li>
</ol>
<div><img src="img/00155.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
                
            
            
                
<p class="calibre3">In all the previous chapters, we have always been able to refit Surface Shaders. This is not the case any more, as Surface and Fragment Shaders are structurally different. We will need to implement the following changes:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Delete all the properties of the shader, replacing them with the following:</li>
</ol>
<pre class="calibre18">Properties <br class="title-page-name"/>{<br class="title-page-name"/> _Color ("Color", Color) = (1,0,0,1)<br class="title-page-name"/> _MainTex ("Albedo (RGB)", 2D) = "white" {}<br class="title-page-name"/>}</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Delete all the code in the <kbd class="calibre13">SubShader</kbd> block and replace it with this:</li>
</ol>
<pre class="calibre18">SubShader <br class="title-page-name"/>{<br class="title-page-name"/> Pass <br class="title-page-name"/> {<br class="title-page-name"/> CGPROGRAM<br class="title-page-name"/><br class="title-page-name"/> #pragma vertex vert<br class="title-page-name"/> #pragma fragment frag<br class="title-page-name"/><br class="title-page-name"/> half4 _Color;<br class="title-page-name"/> sampler2D _MainTex;<br class="title-page-name"/><br class="title-page-name"/> struct vertInput <br class="title-page-name"/> {<br class="title-page-name"/> float4 pos : POSITION;<br class="title-page-name"/> float2 texcoord : TEXCOORD0;<br class="title-page-name"/> };<br class="title-page-name"/><br class="title-page-name"/> struct vertOutput <br class="title-page-name"/> {<br class="title-page-name"/> float4 pos : SV_POSITION;<br class="title-page-name"/> float2 texcoord : TEXCOORD0;<br class="title-page-name"/> };<br class="title-page-name"/><br class="title-page-name"/> vertOutput vert(vertInput input) <br class="title-page-name"/> {<br class="title-page-name"/> vertOutput o;<br class="title-page-name"/> o.pos = mul(UNITY_MATRIX_MVP, input.pos);<br class="title-page-name"/> o.texcoord = input.texcoord;<br class="title-page-name"/> return o;<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> half4 frag(vertOutput output) : COLOR<br class="title-page-name"/> {<br class="title-page-name"/> half4 mainColour = tex2D(_MainTex, output.texcoord);<br class="title-page-name"/> return mainColour * _Color;<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> ENDCG<br class="title-page-name"/> }<br class="title-page-name"/>}<br class="title-page-name"/>FallBack "Diffuse"</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Save your shader script and return to the Unity editor. Once finished, modify the Color property of the <kbd class="calibre13">MultiplyMat</kbd> material and see that we get the result we are looking for:</li>
</ol>
<div><img src="img/00156.jpeg" class="calibre25"/></div>
<p class="calibre3">This will also be the base for all future Vertex and Fragment Shaders.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works…</h1>
                
            
            
                
<p class="calibre3">As the name suggests, Vertex and Fragment Shaders work in two steps. The model is first passed through a vertex function; the result is then inputted to a Fragment function. Both these functions are assigned using <kbd class="calibre13">#pragma</kbd> directives:</p>
<pre class="calibre19">#pragma vertex vert<br class="title-page-name"/>#pragma fragment frag</pre>
<p class="calibre3">In this case, they are simply called <kbd class="calibre13">vert</kbd> and <kbd class="calibre13">frag</kbd>.</p>
<p class="calibre3">Conceptually speaking, fragments are closely related to pixels; the term fragment is often used to refer to the collection of data necessary to draw a pixel. This is also why Vertex and Fragment Shaders are often called <strong class="calibre5">Pixel Shaders</strong>.</p>
<p class="calibre3">The vertex function takes the input data in a structure that is defined as <kbd class="calibre13">vertInput</kbd> in the shader:</p>
<pre class="calibre19">struct vertInput <br class="title-page-name"/>{<br class="title-page-name"/> float4 pos : POSITION;<br class="title-page-name"/> float2 texcoord : TEXCOORD0;<br class="title-page-name"/>};</pre>
<p class="calibre3">Its name is totally arbitrary, but its content is not. Each field of the <kbd class="calibre13">struct</kbd> must be decorated with a <strong class="calibre5">binding semantic</strong>. This is a feature of Cg that allows us to mark variables so that they will be initialized with certain data, such as normal vectors and the vertex position. The binding semantic, <kbd class="calibre13">POSITION</kbd>, indicates that when <kbd class="calibre13">vertInput</kbd> is inputted to the vertex function, <kbd class="calibre13">pos</kbd> will contain the position of the current vertex. This is similar to the vertex field of the <kbd class="calibre13">appdata_full</kbd> structure in a Surface Shader. The main difference is that <kbd class="calibre13">pos</kbd> is represented in model coordinates (relative to the 3D object), which we need to convert to view coordinates manually (relative to the position on the screen).</p>
<p>The vertex function in a Surface Shader is used to alter the geometry of the model only. In a Vertex and Fragment Shader, instead, the vertex function is necessary to project the coordinates of the model to the screen.</p>
<p class="calibre3">The mathematics behind this conversion is beyond the scope of this chapter. However, this transformation can be achieved by using the <kbd class="calibre13">UnityObjectToClipPos</kbd> function, which will take a point from object space to the camera's clip space in homogeneous coordinates. This is done by multiplying by the <strong class="calibre5">model-view-projection matrix</strong>, and it is essential to find the position of a vertex on the screen:</p>
<pre class="calibre19">vertOutput o;<br class="title-page-name"/>o.pos = UnityObjectToClipPos(input.pos);</pre>
<p>For more information on this and other helper functions that ShaderLab has built-in, check out <a href="https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html" class="calibre31">https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html</a>.</p>
<p class="calibre3">The other piece of information initialized is <kbd class="calibre13">textcoord</kbd>, which uses the <kbd class="calibre13">TEXCOORD0</kbd> binding semantics to get the UV data of the first texture. No further processing is required, and this value can be passed directly to the fragment function (<kbd class="calibre13">frag</kbd>):</p>
<pre class="calibre19">o.texcoord = input.texcoord;</pre>
<p class="calibre3">While Unity will initialize <kbd class="calibre13">vertInput</kbd> for us, we are responsible for the initialization of <kbd class="calibre13">vertOutput</kbd>. Despite this, its fields still need to be decorated with binding semantics:</p>
<pre class="calibre19">struct vertOutput <br class="title-page-name"/>{<br class="title-page-name"/>  float4 pos : SV_POSITION;<br class="title-page-name"/>  float2 texcoord : TEXCOORD0;<br class="title-page-name"/>};</pre>
<p class="calibre3">Once the vertex function has initialized <kbd class="calibre13">vertOutput</kbd>, the structure is passed to the fragment function (<kbd class="calibre13">frag</kbd>). This samples the main texture of the model and multiplies it by the color provided.</p>
<p class="calibre3">As you can see, the Vertex and Fragment Shader have no knowledge of the physical properties of the material. This means that the material does not have the same effect by light sources, and it does not have data regarding how light reflects to create bumped surfaces compared to a Surface Shader; it works closer to the architecture of the graphics GPU.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more…</h1>
                
            
            
                
<p class="calibre3">One of the most confusing aspects of Vertex and Fragment Shaders is binding semantics. There are many others that you can use, and their meanings depend on context.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Input semantics</h1>
                
            
            
                
<p class="calibre3">The binding semantics in the following table can be used in <kbd class="calibre13">vertInput</kbd>, which is the structure that Unity provides to the vertex function. The fields decorated with this semantics will be initialized automatically:</p>
<table border="1" class="calibre43">
<tbody class="calibre44">
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><strong class="calibre5">Binding semantics</strong></p>
</td>
<td class="calibre46">
<p class="calibre3"><strong class="calibre5">Description</strong></p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">POSITION</kbd>, <kbd class="calibre13">SV_POSITION</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The position of a vertex in world coordinates (object space)</p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">NORMAL</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The normal of a vertex, relative to the world (not to the camera)</p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">COLOR</kbd>, <kbd class="calibre13">COLOR0</kbd>, <kbd class="calibre13">DIFFUSE</kbd>, <kbd class="calibre13">SV_TARGET</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The color information stored in the vertex</p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">COLOR1</kbd>, <kbd class="calibre13">SPECULAR</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The secondary color information stored in the vertex (usually the specular)</p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">TEXCOORD0</kbd>, <kbd class="calibre13">TEXCOORD1</kbd>, …, <kbd class="calibre13">TEXCOORDi</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The i-th UV data stored in the vertex</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Output semantics</h1>
                
            
            
                
<p class="calibre3">When binding, semantics are used in <kbd class="calibre13">vertOutput</kbd>; they do not automatically guarantee that fields will be initialized. Quite the opposite; it's our responsibility to do so. The compiler will do its best to ensure that the fields are initialized with the right data:</p>
<table border="1" class="calibre43">
<tbody class="calibre44">
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><strong class="calibre5">Binding semantics</strong></p>
</td>
<td class="calibre46">
<p class="calibre3"><strong class="calibre5">Description</strong></p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">POSITION</kbd>, <kbd class="calibre13">SV_POSITION</kbd>, <kbd class="calibre13">HPOS</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The position of a vertex in camera coordinates (clip space, from zero to one for each dimension)</p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">COLOR</kbd>, <kbd class="calibre13">COLOR0</kbd>, <kbd class="calibre13">COL0</kbd>, <kbd class="calibre13">COL</kbd>, <kbd class="calibre13">SV_TARGET</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The front primary color</p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">COLOR1</kbd>, <kbd class="calibre13">COL1</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The front secondary color</p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">TEXCOORD0</kbd>, <kbd class="calibre13">TEXCOORD1</kbd>, …, <kbd class="calibre13">TEXCOORDi</kbd>, <kbd class="calibre13">TEXi</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The i-th UV data stored in the vertex</p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre46">
<p class="calibre3"><kbd class="calibre13">WPOS</kbd></p>
</td>
<td class="calibre46">
<p class="calibre3">The position, in pixels, in the window (origin in the lower left corner)</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>
<p class="calibre3">If, for any reason, you need a field that will contain a different type of data, you can decorate it with one of the many <kbd class="calibre13">TEXCOORD</kbd> data available. The compiler will not allow fields to be left undecorated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            
                
<p class="calibre3">You can refer to the NVIDIA Reference Manual to check the other binding semantics that are available in Cg:</p>
<p class="calibre3"><a href="http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf" class="calibre10">http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the grab pass to draw behind objects</h1>
                
            
            
                
<p class="calibre3">In the <em class="calibre14">Adding transparency to PBR</em> recipe of <a href="part0131.html#3STPM0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 5</a>, <em class="calibre14">Physically-Based Rendering</em>, we have seen how a material can be made transparent. Even if a transparent material can draw over a scene, it cannot change what has been drawn underneath it. This means that those Transparent Shaders cannot create distortions such as the ones typically seen in glass or water. In order to simulate them, we need to introduce another technique called a grab pass. This allows us to access what has been drawn on-screen so far, so that a shader can use it (or alter it) with no restrictions. To learn how to use grab passes, we will create a material that grabs what's rendered behind it and draws it again on the screen. It's a shader that, paradoxically, uses several operations to show no changes at all.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">This recipe requires the following operations:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a shader (<kbd class="calibre13">GrabShader</kbd>) that we will initialize later.</li>
<li value="2" class="calibre12">Create a material (<kbd class="calibre13">GrabMat</kbd>) to host the shader.</li>
</ol>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Attach the material to a flat piece of geometry, such as a quad. Place it in front of some other object so that you cannot see through it. The quad will appear transparent as soon as the shader is complete:</li>
</ol>
<div><img src="img/00157.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
                
            
            
                
<p class="calibre3">To use a grab pass, you need to follow these steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Remove the <kbd class="calibre13">Properties</kbd> section, and the <kbd class="calibre13">Input</kbd> section; this shader will not use any of them.</li>
<li value="2" class="calibre12">In the <kbd class="calibre13">SubShader</kbd> section, remove everything, and add the following to ensure the object is treated as being <kbd class="calibre13">Transparent</kbd>:</li>
</ol>
<pre class="calibre18">Tags{ "Queue" = "Transparent" }</pre>
<ol start="3" class="calibre15">
<li class="calibre12" value="3">Then, below that, add a grab pass:</li>
</ol>
<pre class="calibre18">GrabPass{ }</pre>
<ol start="4" class="calibre15">
<li class="calibre12" value="4">After the <kbd class="calibre13">GrabPass</kbd>, we will need to add this extra pass:</li>
</ol>
<pre class="calibre18">Pass <br class="title-page-name"/>{<br class="title-page-name"/>  CGPROGRAM<br class="title-page-name"/>  #pragma vertex vert<br class="title-page-name"/>  #pragma fragment frag<br class="title-page-name"/><br class="title-page-name"/>  #include "UnityCG.cginc"<br class="title-page-name"/>  sampler2D _GrabTexture;<br class="title-page-name"/><br class="title-page-name"/>  struct vertInput <br class="title-page-name"/>  {<br class="title-page-name"/>    float4 vertex : POSITION;<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>  struct vertOutput <br class="title-page-name"/>  {<br class="title-page-name"/>    float4 vertex : POSITION;<br class="title-page-name"/>    float4 uvgrab : TEXCOORD1;<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>  // Vertex function<br class="title-page-name"/>  vertOutput vert(vertInput v) <br class="title-page-name"/>  {<br class="title-page-name"/>    vertOutput o;<br class="title-page-name"/>    o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);<br class="title-page-name"/>    o.uvgrab = ComputeGrabScreenPos(o.vertex);<br class="title-page-name"/>    return o;<br class="title-page-name"/>  }<br class="title-page-name"/>  // Fragment function<br class="title-page-name"/>  half4 frag(vertOutput i) : COLOR <br class="title-page-name"/>  {<br class="title-page-name"/>    fixed4 col = tex2Dproj(_GrabTexture, UNITY_PROJ_COORD(i.uvgrab));<br class="title-page-name"/>    return col + half4(0.5,0,0,0);<br class="title-page-name"/>  }<br class="title-page-name"/>  ENDCG<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Save your script and return to the Unity editor. Upon getting back, you should notice your material now works the way you intend it to:</li>
</ol>
<div><img src="img/00158.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works…</h1>
                
            
            
                
<p class="calibre3">This recipe not only introduces grab passes, but also Vertex and Fragment Shaders; for this reason, we have to analyze the shader in detail.</p>
<p class="calibre3">So far, all the code has always been placed directly in the <kbd class="calibre13">SubShader</kbd> section. This is because our previous shaders required only a single pass. This time, two passes are required. The first one is the <kbd class="calibre13">GrabPass{}</kbd>, which is defined simply by <kbd class="calibre13">GrabPass{}</kbd>. The rest of the code is placed in the second pass, which is contained in a <kbd class="calibre13">Pass</kbd> block.</p>
<p class="calibre3">The second pass is not structurally different from the shader shown in the first recipe of this chapter; we use the vertex function, <kbd class="calibre13">vert</kbd>, to get the position of the vertex, and then we give it a color in the Fragment function frag. The difference is that vert calculates another important detail: the UV data for the <kbd class="calibre13">GrabPass{}</kbd>. The <kbd class="calibre13">GrabPass{}</kbd> automatically creates a texture that can be referred to as follows:</p>
<pre class="calibre19">sampler2D _GrabTexture;</pre>
<p class="calibre3">In order to sample this texture, we need its UV data. The <kbd class="calibre13">ComputeGrabScreenPos</kbd> function returns data that we can use later to sample the grab texture correctly. This is done in the Fragment Shader using the following line:</p>
<pre class="calibre19">fixed4 col = tex2Dproj(_GrabTexture, UNITY_PROJ_COORD(i.uvgrab));</pre>
<p class="calibre3">This is the standard way in which a texture is grabbed and applied to the screen in its correct position. If everything has been done correctly, this shader will simply clone what has been rendered behind the geometry. We will see in the following recipes how this technique can be used to create materials such as water and glass.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more…</h1>
                
            
            
                
<p class="calibre3">Every time you use a material with <kbd class="calibre13">GrabPass{}</kbd>, Unity will have to render the screen to a texture. This operation is very expensive and limits the number of <kbd class="calibre13">GrabPass</kbd> instances that you can use in a game. Cg offers a slightly different variation:</p>
<pre class="calibre19">GrabPass {"TextureName"}</pre>
<p class="calibre3">This line not only allows you to give a name to the texture, but also shares the texture with all the materials that have a <kbd class="calibre13">GrabPass</kbd> called <kbd class="calibre13">TextureName</kbd>. This means that if you have ten materials, Unity will only do a single <kbd class="calibre13">GrabPass</kbd> and share the texture with all of them. The main problem of this technique is that it doesn't allow for effects that can be stacked. If you are creating a glass with this technique, you won't be able to have two glasses one after the other.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing a Glass Shader</h1>
                
            
            
                
<p class="calibre3">Glass is a very complicated material; it should not be a surprise that other chapters have already created shaders to simulate it in the <em class="calibre14">Adding transparency to PBR</em> recipe of <a href="part0131.html#3STPM0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 5</a>, <em class="calibre14">Physically-Based Rendering</em>. We already know how to make our glasses semi-transparent to show the objects behind it perfectly and that works for a number of applications. However, most glasses are not perfect. For instance, if you look through a stain glass window you may notice distortions or deformations when you look through them. This recipe will teach you how to achieve that effect. The idea behind this effect is to use a Vertex and Fragment Shader with a <kbd class="calibre13">GrabPass</kbd>, and then sample the grab texture with a little change to its UV data to create a distortion. You can see the effect in the following screenshot, using the glass-stained textures from the Unity Standard Assets:</p>
<div><img src="img/00159.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">The setup for this recipe is similar to the one presented previously in <a href="part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 6</a>, <em class="calibre14">Vertex Functions</em>:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new Vertex and Fragment Shader. You can start by copying the one used in the previous recipe, <em class="calibre2">Using the grab pass to draw behind objects</em>, as a base by selecting it and hitting <em class="calibre2">Ctrl</em>+<em class="calibre2">D</em> to duplicate it. Once duplicated, change its name to <kbd class="calibre13">WindowShader</kbd>.</li>
<li value="2" class="calibre12">Create a material that will use the shader (<kbd class="calibre13">WindowMat</kbd>).</li>
<li value="3" class="calibre12">Assign the material to a quad or another flat geometry that will simulate your glass.</li>
</ol>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Place some objects behind it so that you can see the distortion effect:</li>
</ol>
<div><img src="img/00160.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
                
            
            
                
<p class="calibre3">Let's start by editing the Vertex and Fragment Shaders:</p>
<ol class="calibre15">
<li class="calibre12" value="1">Create a <kbd class="calibre13">Properties</kbd> block with these items in it:</li>
</ol>
<pre class="calibre18">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}<br class="title-page-name"/>  _Colour("Colour", Color) = (1,1,1,1)<br class="title-page-name"/>  _BumpMap("Noise text", 2D) = "bump" {}<br class="title-page-name"/>  _Magnitude("Magnitude", Range(0,1)) = 0.05<br class="title-page-name"/>}</pre>
<ol start="2" class="calibre15">
<li class="calibre12" value="2">Add their variables in the second pass:</li>
</ol>
<pre class="calibre18">sampler2D _MainTex;<br class="title-page-name"/>fixed4 _Colour;<br class="title-page-name"/><br class="title-page-name"/>sampler2D _BumpMap;<br class="title-page-name"/>float _Magnitude;</pre>
<ol start="3" class="calibre15">
<li class="calibre12" value="3">Add the texture information to the input and output structures:</li>
</ol>
<pre class="calibre18">float2 texcoord : TEXCOORD0;</pre>
<ol start="4" class="calibre15">
<li class="calibre12" value="4">Transfer the UV data from the input to the output structure:</li>
</ol>
<pre class="calibre18">// Vertex function<br class="title-page-name"/>vertOutput vert(vertInput v) <br class="title-page-name"/>{<br class="title-page-name"/>  vertOutput o;<br class="title-page-name"/>  o.vertex = UnityObjectToClipPos(v.vertex);<br class="title-page-name"/>  o.uvgrab = ComputeGrabScreenPos(o.vertex);<br class="title-page-name"/>  <strong class="calibre1">o.texcoord = v.texcoord;</strong><br class="title-page-name"/>  return o;<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li class="calibre12" value="5">Use the following Fragment function:</li>
</ol>
<pre class="calibre18">half4 frag(vertOutput i) : COLOR <br class="title-page-name"/>{<br class="title-page-name"/>  half4 mainColour = tex2D(_MainTex, i.texcoord);<br class="title-page-name"/>  half4 bump = tex2D(_BumpMap, i.texcoord);<br class="title-page-name"/>  half2 distortion = UnpackNormal(bump).rg;<br class="title-page-name"/><br class="title-page-name"/>  i.uvgrab.xy += distortion * _Magnitude;<br class="title-page-name"/><br class="title-page-name"/>  fixed4 col = tex2Dproj(_GrabTexture, UNITY_PROJ_COORD(i.uvgrab));<br class="title-page-name"/>  return col * mainColour * _Colour;<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li class="calibre12" value="6">This material is transparent, so it changes its tags in the <kbd class="calibre13">SubShader</kbd> block:</li>
</ol>
<pre class="calibre18">Tags{ "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" =<br class="title-page-name"/>  "Opaque" }</pre>
<ol start="7" class="calibre15">
<li class="calibre12" value="7">What's left now is to set the texture for the glass, and for a normal map to displace the grab texture:</li>
</ol>
<div><img src="img/00161.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works…</h1>
                
            
            
                
<p class="calibre3">The core that this shader uses is a grab pass to take what has already been rendered on the screen. The part where the distortion takes place is in the Fragment function. Here, a normal map is unpacked and used to offset the UV data of the grab texture:</p>
<pre class="calibre19">half4 bump = tex2D(_BumpMap, i.texcoord);<br class="title-page-name"/>half2 distortion = UnpackNormal(bump).rg;<br class="title-page-name"/><br class="title-page-name"/>i.uvgrab.xy += distortion * _Magnitude;</pre>
<p class="calibre3">The <kbd class="calibre13">_Magnitude</kbd> slider is used to determine how strong the effect is:</p>
<div><img src="img/00162.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more…</h1>
                
            
            
                
<p class="calibre3">This effect is very generic; it grabs the screen and creates a distortion based on a normal map. There is no reason why it shouldn't be used to simulate more interesting things. Many games use distortions around explosions or other sci-fi devices. This material can be applied to a sphere and, with a different normal map, it would simulate the heat wave of an explosion perfectly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing a Water Shader for 2D games</h1>
                
            
            
                
<p class="calibre3">The Glass Shader introduced in the previous recipe is static; its distortion never changes. It takes just a few changes to convert it to an animated material, making it perfect for 2D games that feature water. This uses a similar technique to the one shown in <a href="part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 6</a>, <em class="calibre14">Vertex Functions</em>, in the recipe entitled <em class="calibre14">Animating Vertices in a Surface Shader</em>:</p>
<div><img src="img/00163.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">This recipe is based on the Vertex and Fragment Shaders described in the <em class="calibre14">Using the grab pass to draw behind objects</em> recipe, as it will rely heavily on <kbd class="calibre13">GrabPass</kbd>.</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new Vertex and Fragment Shader. You can start by copying the one used in the previous recipe, <em class="calibre2">Using the grab pass to draw behind objects</em>, as a base by selecting it and hitting <em class="calibre2">Ctrl</em>+<em class="calibre2">D</em> to duplicate it. Once duplicated, change its name to <kbd class="calibre13">WaterShader</kbd>.</li>
<li value="2" class="calibre12">Create a material that will use the shader (<kbd class="calibre13">WaterMat</kbd>).</li>
</ol>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Assign the material to a flat geometry that will represent your 2D water. In order for this effect to work, you should have something rendered behind it so that you can see the water-like displacement: </li>
</ol>
<div><img src="img/00164.jpeg" class="calibre25"/></div>
<ol start="4" class="calibre15">
<li class="calibre12" value="4">This recipe requires a noise texture, which is used to get pseudo-random values. It is important that you choose a seamless noise texture, such as the ones generated by tileable 2D Perlin noise, as shown in the following screenshot. This ensures that when the material is applied to a large object, you will not see any discontinuity. In order for this effect to work, the texture has to be imported in Repeat mode. If you want a smooth and continuous look for your water, you should also set it to Bilinear from Inspector. These settings ensure that the texture is sampled correctly from the shader:</li>
</ol>
<div><img src="img/00165.jpeg" class="calibre124"/></div>
<p>You can find an example noise texture in <kbd class="calibre37">Chapter 6</kbd> | <kbd class="calibre37">Textures</kbd> folder of the book's example code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
                
            
            
                
<p class="calibre3">To create this animated effect, you can start by refitting the shader. Follow these steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Add the following properties:</li>
</ol>
<pre class="calibre18">_NoiseTex("Noise text", 2D) = "white" {}<br class="title-page-name"/>_Colour ("Colour", Color) = (1,1,1,1)<br class="title-page-name"/>_Period ("Period", Range(0,50)) = 1<br class="title-page-name"/>_Magnitude ("Magnitude", Range(0,0.5)) = 0.05<br class="title-page-name"/>_Scale ("Scale", Range(0,10)) = 1</pre>
<ol start="2" class="calibre15">
<li class="calibre12" value="2">Add their respective variables to the second pass of the shader:</li>
</ol>
<pre class="calibre18">sampler2D _NoiseTex;<br class="title-page-name"/>fixed4 _Colour;<br class="title-page-name"/><br class="title-page-name"/>float _Period;<br class="title-page-name"/>float _Magnitude;<br class="title-page-name"/>float _Scale;</pre>
<ol start="3" class="calibre15">
<li class="calibre12" value="3">Define the following input and output structures for the vertex function:</li>
</ol>
<pre class="calibre18">struct vertInput <br class="title-page-name"/>{<br class="title-page-name"/>  float4 vertex : POSITION;<br class="title-page-name"/>  fixed4 color : COLOR;<br class="title-page-name"/>  float2 texcoord : TEXCOORD0;<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>struct vertOutput <br class="title-page-name"/>{<br class="title-page-name"/>  float4 vertex : POSITION;<br class="title-page-name"/>  fixed4 color : COLOR;<br class="title-page-name"/>  float2 texcoord : TEXCOORD0;<br class="title-page-name"/>  float4 worldPos : TEXCOORD1;<br class="title-page-name"/>  float4 uvgrab : TEXCOORD2;<br class="title-page-name"/>};</pre>
<ol start="4" class="calibre15">
<li class="calibre12" value="4">This shader needs to know the exact position of the space of every fragment. To do this, update the vertex function to the following:</li>
</ol>
<pre class="calibre18">// Vertex function<br class="title-page-name"/>vertOutput vert(vertInput v) <br class="title-page-name"/>{<br class="title-page-name"/>  vertOutput o;<br class="title-page-name"/>  o.vertex = UnityObjectToClipPos(v.vertex);<br class="title-page-name"/>  o.color = v.color;<br class="title-page-name"/>  o.texcoord = v.texcoord;<br class="title-page-name"/><br class="title-page-name"/>  o.worldPos = mul(unity_ObjectToWorld, v.vertex);<br class="title-page-name"/>  o.uvgrab = ComputeGrabScreenPos(o.vertex);<br class="title-page-name"/>        <br class="title-page-name"/>  return o;<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li class="calibre12" value="5">Use the following Fragment function:</li>
</ol>
<pre class="calibre18">fixed4 frag (vertOutput i) : COLOR <br class="title-page-name"/>{<br class="title-page-name"/>  float sinT = sin(_Time.w / _Period);<br class="title-page-name"/><br class="title-page-name"/>  float distX = tex2D(_NoiseTex, i.worldPos.xy / _Scale +                 float2(sinT,<br class="title-page-name"/>    0) ).r - 0.5;<br class="title-page-name"/>  float distY = tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(0,<br class="title-page-name"/>    sinT) ).r - 0.5;<br class="title-page-name"/><br class="title-page-name"/>  float2 distortion = float2(distX, distY);<br class="title-page-name"/>  i.uvgrab.xy += distortion * _Magnitude;<br class="title-page-name"/>  fixed4 col = tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(i.uvgrab));<br class="title-page-name"/>  return col * _Colour;<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li class="calibre12" value="6">Save your script and return to the Unity editor. Afterward, select your Water Material (<kbd class="calibre13">WatMat</kbd>)and apply the noise texture. Afterward, tweak the properties in the Water Material and notice how it modifies the things behind it.</li>
</ol>
<div><img src="img/00166.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works…</h1>
                
            
            
                
<p class="calibre3">This shader is very similar to the one introduced in the <em class="calibre14">Implementing a Glass Shader</em> recipe. The major difference is that this is an animated material; the displacement is not generated from a normal map, but takes into account the current time in order to create a constant animation. The code that displaces the UV data of the grab texture seems quite complicated; let's try to understand how it has been generated. The idea behind it is that a sinusoid function is used to make the water oscillate. This effect needs to evolve over time; to achieve this effect, the distortion generated by the shader depends on the current time that is retrieved with the built-in variable, <kbd class="calibre13">_Time</kbd>. The <kbd class="calibre13">_Period</kbd> variable determines the period of the sinusoid, which means how fast the waves appear:</p>
<pre class="calibre19">float2 distortion = float2( sin(_Time.w/_Period), <br class="title-page-name"/>  sin(_Time.w/_Period) ) – 0.5;</pre>
<p class="calibre3">The problem with this code is that you have the same displacement on the <em class="calibre14">X</em> and <em class="calibre14">Y</em> axes; as a result, the entire grab texture will rotate in a circular motion, which looks nothing like water. We obviously need to add some randomness to this.</p>
<p class="calibre3">The most common way to add random behaviors to shaders is by including a noise texture. The problem now is to find a way to sample the texture at seemingly random positions. The best way to avoid seeing an obvious sinusoid pattern is to use the sine waves as an offset in the UV data of the <kbd class="calibre13">_NoiseTex</kbd> texture:</p>
<pre class="calibre19">float sinT = sin(_Time.w / _Period);<br class="title-page-name"/>float2 distortion = float2( <br class="title-page-name"/>    tex2D(_NoiseTex, i.texcoord / _Scale + float2(sinT, 0) ).r - 0.5,<br class="title-page-name"/>    tex2D(_NoiseTex, i.texcoord / _Scale + float2(0, sinT) ).r - 0.5<br class="title-page-name"/>);</pre>
<p class="calibre3">The <kbd class="calibre13">_Scale</kbd> variable determines the size of the waves. This solution is closer to the final version but has a severe issue—if the water quad moves, the UV data follows it and you can see the water waves following the material rather than being anchored to the background. To solve this, we need to use the world position of the current fragment as the initial position for the UV data:</p>
<pre class="calibre19">float sinT = sin(_Time.w / _Period);<br class="title-page-name"/><strong class="calibre1">float2 distortion = float2( <br class="title-page-name"/>    tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(sinT, 0) ).r - 0.5,<br class="title-page-name"/>    tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(0, sinT) ).r - 0.5<br class="title-page-name"/>);<br class="title-page-name"/>i.uvgrab.xy += distortion * _Magnitude;</strong></pre>
<p class="calibre3">The result is a pleasant, seamless distortion, which doesn't move in any clear direction.</p>
<p class="calibre3">We can also improve the readability of the code by breaking apart the distortion into smaller steps:</p>
<pre class="calibre19">float sinT = sin(_Time.w / _Period);<br class="title-page-name"/><br class="title-page-name"/>float distX = tex2D(_NoiseTex, i.worldPos.xy / _Scale + <br class="title-page-name"/>  float2(sinT, 0) ).r - 0.5;<br class="title-page-name"/>float distY = tex2D(_NoiseTex, i.worldPos.xy / _Scale + <br class="title-page-name"/>  float2(0, sinT) ).r - 0.5;<br class="title-page-name"/><br class="title-page-name"/>float2 distortion = float2(distX, distY);<br class="title-page-name"/>i.uvgrab.xy += distortion * _Magnitude;</pre>
<p class="calibre3">That is what you should see in the final result.</p>
<p>As happens with all these special effects, there is no perfect solution. This recipe shows you a technique to create water-like distortion, but you are encouraged to play with it until you find an effect that fits the aesthetics of your game.</p>
<p class="calibre125"/>


            

            
        
    </body></html>