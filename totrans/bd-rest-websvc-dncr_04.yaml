- en: Item Catalogue, Cart, and Checkout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目目录、购物车和结账
- en: This chapter will take a look at coding the main sections of an e-commerce app
    and its related API endpoints.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨编码电子商务应用程序的主要部分及其相关的API端点。
- en: We have already discussed user registration and authentication in the previous
    chapter, and we will be carrying forward that knowledge to help us implement security
    inside different controllers that we build in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章讨论了用户注册和身份验证，我们将继续使用这些知识来帮助我们在本章构建的不同控制器中实现安全性。
- en: To display products and search for them efficiently, we are also going to design
    `ProductsController`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地显示产品和搜索它们，我们还将设计`ProductsController`。
- en: After that, we will also look at how to put your products into your shopping
    cart, discussing how to add, update, and delete items in a cart.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们还将探讨如何将您的产品添加到购物车中，讨论如何在购物车中添加、更新和删除项目。
- en: Last, but not least, we will also take a look at order management and processing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们还将查看订单管理和处理。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementing different controllers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现不同的控制器
- en: Product listing and product searching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品列表和产品搜索
- en: Adding, updating, and deleting cart items
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加、更新和删除购物车项目
- en: Imposing security on controllers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制器上实施安全性
- en: Order processing and shipping information
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单处理和发货信息
- en: Implementing controllers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现控制器
- en: As we are going to learn about the core functions of our app, we need to design
    its controllers so that we have REST endpoints to perform tasks from our client.
    Things such as *product listing*, *product searching*, *add to cart*, *placing
    orders*, and *processing shipments* can be done with one dedicated controller
    for each function. These controllers will be responsible for performing actions
    on the database, so we need to model classes for the related tables. Let's get
    to work!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将学习我们应用程序的核心功能，我们需要设计其控制器，以便我们有REST端点来执行来自客户端的任务。例如，*产品列表*、*产品搜索*、*添加到购物车*、*下订单*和*处理发货*可以通过为每个功能分配一个专门的控制器来完成。这些控制器将负责对数据库执行操作，因此我们需要为相关表建模类。让我们开始工作！
- en: Generating models
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成模型
- en: 'The following line can be executed inside the Package Manager Console to generate
    model classes for all the tables in the database:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行可以在包管理控制台中执行以生成数据库中所有表的模型类：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command will populate class files for each table inside the `Models`
    folder, as shown in the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将为`Models`文件夹中的每个表生成类文件，如下面的截图所示：
- en: '![](img/281b8757-ef5d-40b2-b86c-3702e6fdbabc.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/281b8757-ef5d-40b2-b86c-3702e6fdbabc.png)'
- en: If you have not already done so, please refer to the database script in [https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core)
    to generate the database table for your application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请参考[https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core)中的数据库脚本以生成您应用程序的数据库表。
- en: Generating controllers
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成控制器
- en: To generate controllers for the models, right-click on `Controllers` folder
    | Add | Controller | API Controller with actions, using Entity Framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要为模型生成控制器，右键单击`Controllers`文件夹 | 添加 | 控制器 | 使用Entity Framework的API控制器（带操作）。
- en: First, let's start with `ProductsdetailsController`, as we want to show the
    products list to our customers initially.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从`ProductsdetailsController`开始，因为我们最初想要向客户展示产品列表。
- en: 'The `Productsdetail.cs` model class generated through scaffolding should look
    like the following snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过生成器生成的`Productsdetail.cs`模型类应该看起来像以下片段：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code can also be used to generate the controller with `GET`,
    `POST`, `PUT`, and `DELETE` action methods: (We''re focusing on the `GetProductsdetail`
    method for now.)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码也可以用来生成带有`GET`、`POST`、`PUT`和`DELETE`操作方法的控制器：（我们现在专注于`GetProductsdetail`方法。）
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can quickly test whether your controller is working using Postman, as shown
    in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Postman快速测试您的控制器是否正常工作，如下面的截图所示：
- en: '![](img/d6c1645c-c091-4b39-9e5e-8da4ea9e01ee.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6c1645c-c091-4b39-9e5e-8da4ea9e01ee.png)'
- en: Here, the URL is `http://localhost:57571/api/Productsdetails` and the type is
    `GET`. We can see the results in the result box, which shows us an array of product
    details in a JSON format. Note that we sent this request by setting the `contentType`
    header with the value `application/json` inside the request's Header tab.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，URL是`http://localhost:57571/api/Productsdetails`，类型是`GET`。我们可以在结果框中看到结果，它以JSON格式显示产品详情数组。请注意，我们通过在请求的“头部”选项卡中设置`contentType`头部为`application/json`来发送此请求。
- en: Product listing
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品列表
- en: 'Let''s now design the jQuery code needed to consume this endpoint so that we
    can show these records on a web page and list our products available to buy. This
    should look as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设计所需的jQuery代码来消费此端点，以便我们可以在网页上显示这些记录并列出可供购买的产品。它应该看起来如下：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To get the code to call the API in different languages, you can click on the
    *code* link inside Postman and then select the desired language. We have already
    discussed this in previous chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取不同语言的调用API的代码，您可以在Postman中点击*代码*链接，然后选择所需的语言。我们已经在之前的章节中讨论过这一点。
- en: The preceding method makes a call to the endpoint `http://localhost:57571/api/Productsdetails`
    and loops through the records after receiving them with the `success` method.
    While looping, it builds an HTML table row that appends to a pre-existing table
    on the page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法调用端点`http://localhost:57571/api/Productsdetails`，并在收到响应后通过`success`方法遍历记录。在遍历过程中，它构建一个HTML表格行，并将其追加到页面上的现有表格中。
- en: 'The following screenshot is the reflection of the jQuery code which is showing
    the details of all products:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是显示所有产品详细信息的jQuery代码的反映：
- en: '![](img/c88b2b8d-1a9f-4846-bfd2-367b627532fe.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c88b2b8d-1a9f-4846-bfd2-367b627532fe.png)'
- en: Notice that we have one Search box at the top, as well as Add To Cart buttons
    for each product. We will take a look at these functionalities later on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在顶部有一个搜索框，以及每个产品的“添加到购物车”按钮。我们稍后会查看这些功能。
- en: 'Did you notice that the product''s main parameter, the price, is not displayed?
    This is because the price isn''t present in the `Productdetail` table. So, let''s
    now take a look at the `Product.cs` model class, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到产品的关键参数，即价格，没有显示吗？这是因为价格不在`Productdetail`表中。所以，现在让我们看看`Product.cs`模型类，如下所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Clearly, the `Product` class contains everything we need including `Name`, `Description`,
    `Url`, `Views`, and so on, with `Productdetail` as a reference point. We have
    already consumed the `GET` action of `ProductdetailsController` to display our
    products, so now it's time to read all of our products using `ProductsController`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`Product`类包含我们需要的所有内容，包括`Name`、`Description`、`Url`、`Views`等，以`Productdetail`作为参考点。我们已经消费了`ProductdetailsController`的`GET`操作来显示我们的产品，所以现在是时候使用`ProductsController`读取所有我们的产品了。
- en: 'The `GET` action of `ProductsController` would return us all of the product
    records in `Productdetail`, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductsController`的`GET`操作会返回所有`Productdetail`中的产品记录，如下所示：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The snippet in bold in the preceding code is the `Include` clause, which is
    used to include results from the `Productdetail`. Now, instead of calling `/api/Productsdetails`,
    we will call `/api/Products`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中加粗的部分是`Include`子句，它用于包含来自`Productdetail`的结果。现在，我们不再调用`/api/Productsdetails`，而是调用`/api/Products`。
- en: 'Calling this endpoint won''t actually work, this is because of circular reference.
    If you observe both the `Products` and `Productdetail` models closely, you should
    see that both contain references to each other. This creates a problem when parsing
    to JSON. To avoid this, we need to write the following code inside `Startup`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此端点实际上不会工作，这是因为存在循环引用。如果您仔细观察`Products`和`Productdetail`模型，您应该会看到它们都相互包含引用。这在解析到JSON时会产生问题。为了避免这种情况，我们需要在`Startup`中编写以下代码：
- en: '`services.AddMvc()`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`services.AddMvc()`'
- en: '`.AddJsonOptions(options =>`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`.AddJsonOptions(options =>`'
- en: '`{`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`options.SerializerSettings.ReferenceLoopHandling =`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`options.SerializerSettings.ReferenceLoopHandling =`'
- en: '`ReferenceLoopHandling.Ignore;`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReferenceLoopHandling.Ignore;`'
- en: '`});`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: 'Let''s now have a look at the response we receive for one product when we call
    this endpoint, as shown in the following snippet. Note that you would get an array
    in reality, but we are only showing you one record for brevity:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看调用此端点时我们收到的单个产品的响应，如下面的片段所示。请注意，实际上你会得到一个数组，但我们为了简洁只展示一条记录：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we need to alter our client-side code to reflect the fact that `Productdetail`
    is now inside the `Product` object, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改我们的客户端代码，以反映`Productdetail`现在位于`Product`对象中的事实，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That was easy to understand, wasn't it? Here, you should notice the changes
    we made to the URL and how we read the product details. `Productsdetail` is inside
    the `Product` object as an array, so it is written as `value.productsdetail[0]`,
    where `value` is the product object. We also introduced `value.price`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易理解，不是吗？在这里，你应该注意我们做出的URL更改以及我们如何读取产品详情。`Productsdetail`位于`Product`对象内部作为一个数组，因此它被写成`value.productsdetail[0]`，其中`value`是产品对象。我们还引入了`value.price`。
- en: 'You should now see the following screenshot, which has been updated:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下更新后的截图：
- en: '![](img/1b9d9b63-0b41-4a06-8d3b-c2bb24178216.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/1b9d9b63-0b41-4a06-8d3b-c2bb24178216.png)'
- en: Product searching
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品搜索
- en: It's now time to implement the search feature, allowing customers to put any
    string inside the search box to look up a product. We need to add one search button
    to the UI, which when clicked will receive the entered string and fetch records
    accordingly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现搜索功能，允许客户在搜索框中输入任何字符串来查找产品。我们需要在UI中添加一个搜索按钮，当点击时，将接收输入的字符串并相应地获取记录。
- en: Firstly, the `action` method needs to accept the search text entered by a customer
    as a parameter; currently, `GetProducts()` does not accept any parameter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`action`方法需要接受客户输入的搜索文本作为参数；目前`GetProducts()`不接受任何参数。
- en: 'The updated `GetProducts()` should look like the following snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的`GetProducts()`应该看起来像以下代码片段：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `searchText` parameter is taken into consideration and the results are filtered
    by the title of a book, which resides in the `Name` field of the `Productsdetail`
    collection inside the `Product` object. Thus, `Any` is used to check if the `searchText`
    is present in the `Productsdetail` object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`searchText`参数，结果会根据书籍的标题进行过滤，该标题位于`Product`对象内部的`Productsdetail`集合的`Name`字段中。因此，使用`Any`来检查`searchText`是否存在于`Productsdetail`对象中。
- en: 'Now that the API is ready to search, let''s update the client-side code to
    send the parameter as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在API已经准备好进行搜索，让我们更新客户端代码，如下发送参数：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see in the preceding snippet, `LoadProducts` now accepts a `searchText`
    parameter that is passed to the API as a URL parameter. Now it is just a matter
    of sending the parameter value to this method while calling.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码片段中所示，`LoadProducts`现在接受一个`searchText`参数，该参数作为URL参数传递给API。现在，只需在调用此方法时发送参数值即可。
- en: 'The following code illustrates the search function as it fetches text and executes
    `LoadProducts` with the entered value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了搜索功能，它获取文本并使用输入的值执行`LoadProducts`：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows this function in action:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此功能在实际操作中的样子：
- en: '![](img/92ffc624-a897-4b61-ba88-b4733c80a311.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/92ffc624-a897-4b61-ba88-b4733c80a311.png)'
- en: Adding to cart
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到购物车
- en: 'We''re now ready for the next important topic: all about adding to cart! Before
    implementing this function, however, there is something worth taking note of.
    In our application, we are not going to allow unknown users to add to cart, as
    we will be storing any information related to the cart in our database.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备进入下一个重要主题：所有关于添加到购物车的内容！然而，在实现这个功能之前，有一些值得注意的事情。在我们的应用程序中，我们不会允许未知用户添加到购物车，因为我们将在数据库中存储与购物车相关的任何信息。
- en: Implementing security
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施安全措施
- en: This is where security comes in, namely, authentication. As discussed in [Chapter
    3](09fe6ad3-7061-4ae2-a2cb-c454ba802985.xhtml), *User Registration and Administration*,
    basic authentication can be applied with the help of handlers, or bearer authentication
    can be applied with the help of tokens.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是安全措施介入的地方，即身份验证。如[第3章](09fe6ad3-7061-4ae2-a2cb-c454ba802985.xhtml)中讨论的*用户注册和管理*，可以使用处理程序应用基本身份验证，或者可以使用令牌应用携带者身份验证。
- en: First, let's generate `CartsController` using the same steps as previously.
    We now need to apply the `[Authorize]` attribute to the controller directly, so
    that all operations in the cart can be authenticated. Our app is already set up
    to handle bearer authentication.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用与之前相同的步骤生成`CartsController`。现在我们需要直接应用`[Authorize]`属性到控制器上，这样购物车中的所有操作都可以进行身份验证。我们的应用程序已经设置好以处理携带者身份验证。
- en: 'The following is a code snapshot of `CartsController`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段是`CartsController`的代码快照：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Due to the `[Authorize]` attribute, this controller won't allow you to access
    the `GET`, `POST`, `PUT`, and `DELETE` action methods if you don't provide the
    access token.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`[Authorize]`属性，如果你不提供访问令牌，这个控制器将不允许你访问`GET`、`POST`、`PUT`和`DELETE`操作方法。
- en: 'Let''s start designing some cart-related functions on the client side and try
    to call the action methods in this controller, as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设计一些与购物车相关的客户端函数，并尝试调用此控制器中的操作方法，如下面的屏幕截图所示：
- en: '![](img/43c4f6fe-749c-4aa6-9e7d-fa1b32a95f35.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43c4f6fe-749c-4aa6-9e7d-fa1b32a95f35.png)'
- en: Client-side AddToCart function
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端添加到购物车函数
- en: When a customer hits Add To Cart, information is added to another HTML table
    called My Cart. If you hit Add To Cart twice for one product, its quantity is
    updated to 2 and the price is calculated accordingly. Each click assumes one unit
    of a particular product.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户点击“添加到购物车”时，信息将被添加到另一个名为“我的购物车”的HTML表中。如果您为同一产品连续两次点击“添加到购物车”，其数量将更新为2，价格也将相应计算。每次点击假定是特定产品的一个单位。
- en: 'Let''s now dive into the code. The following snippet shows us the `AddToCart`
    function for JavaScript:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在深入代码。以下代码片段显示了JavaScript的`AddToCart`函数：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function takes the parameters `productId`, `productName`, `qty`, and `price`
    as this information is shown in the cart HTML table.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受`productId`、`productName`、`qty`和`price`作为参数，因为这些信息在购物车HTML表中显示。
- en: Notice, in the preceding image, that there is a delete icon in each row. This
    is produced by adding a `glyphicon` inside a span that is wrapped with an anchor
    whose `click` event is also defined. We will take a look at the delete functionality
    later on in this chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的图像中，每一行都有一个删除图标。这是通过在锚点内添加`glyphicon`并在其周围包裹一个span来实现的，该锚点的`click`事件也已定义。我们将在本章稍后讨论删除功能。
- en: Also, note the `data-product-id` attribute that has been added to the row. This
    helps us identify a cart row uniquely, and you will see how that helps in a moment.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意已添加到行的`data-product-id`属性。这有助于我们唯一地识别购物车行，您将在稍后看到它是如何帮助的。
- en: We are now all set to call `CartsController` to insert cart details into the
    database. However, we still need one more thing inside this method. After all,
    what happens if a product is added to the cart unexpectedly?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好调用`CartsController`将购物车详细信息插入数据库。然而，我们还需要在这个方法中添加一个东西。毕竟，如果意外地将产品添加到购物车中会发生什么？
- en: 'Here, we need the opportunity to update the cart, instead of just adding products
    to it, as shown in the following snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要更新购物车的机会，而不仅仅是向其中添加产品，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Simple, isn't it? First, the record is fetched from the cart table with the
    help of a product ID and then its quantity and price is updated accordingly. From
    that block, a `return` statement ensures that the record isn't added to the table
    anymore.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，不是吗？首先，使用产品ID从购物车表中检索记录，然后相应地更新其数量和价格。从这个块中，一个`return`语句确保记录不再添加到表中。
- en: Now everything should work on the client side. We now just need to call our
    APIs to involve database operations so that any rows that have been inserted,
    updated, and deleted are also updated on the server side.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端应该一切正常工作。我们现在只需要调用我们的API来涉及数据库操作，以便任何已插入、更新和删除的行也在服务器端更新。
- en: API calls for AddToCart
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到购物车的API调用
- en: In this section, we will take a look at the actual API calls made by the client.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看客户端实际执行的API调用。
- en: POST – api/Carts
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST – api/Carts
- en: 'Inserting data into the cart table can be done by calling the `POST` action,
    which should look like the following code block in `CartsController`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`POST`操作将数据插入购物车表，如下所示在`CartsController`中的代码块：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The client-side function to call this action can be designed as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此操作的客户端函数可以设计如下：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Straightforward, isn''t it? Now we can build a cart object and send it a `POST`
    action. You can try this out by calling the following method inside our `AddToCart()`
    function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 直接了当，不是吗？现在我们可以构建一个购物车对象并发送一个`POST`操作。您可以通过在我们的`AddToCart()`函数中调用以下方法来尝试此操作：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the first parameter is `Customerid`, which we have hard-coded. `Customerid`
    can be held in session storage for any requests—although this is considered a
    risky practice.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个参数是`Customerid`，我们已将其硬编码。`Customerid`可以存储在任何请求的会话存储中——尽管这被认为是一种风险行为。
- en: Instead of sending the `Customerid`, you can send the email id to the POST action.
    Then using email id, you can get the `Customerid`, which can be used to insert
    a Cart record.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以发送电子邮件ID到POST操作，而不是发送`Customerid`。然后使用电子邮件ID，您可以获取`Customerid`，这可以用来插入购物车记录。
- en: 'Let''s now run our app and click on Add To Cart for a particular product. Oops!
    The following error has appeared in the developer tool:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在运行我们的应用程序并点击特定产品的“添加到购物车”。哎呀！开发工具中出现了以下错误：
- en: '![](img/240e3e1e-4746-4876-b4bc-8e23d8b1b07b.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/240e3e1e-4746-4876-b4bc-8e23d8b1b07b.png)'
- en: '*Why has this happened?*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么会发生这种情况？*'
- en: The reason for this error is actually pretty obvious. As an `[Authorize]` attribute
    has been applied to the controller, every call to `CartsController` now expects
    a token generated by a request to the OAuth2.0 Authorize server with `Email Id`
    and `Password`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误的真正原因实际上非常明显。由于控制器已应用了 `[Authorize]` 属性，现在对 `CartsController` 的每次调用都期望由
    OAuth2.0 授权服务器生成的令牌，该令牌是通过带有 `Email Id` 和 `Password` 的请求生成的。
- en: We already explored *OAuth2.0 Authentication* in detail.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细探讨了 *OAuth2.0 认证*。
- en: To move on with our implementation, we will call the token server from Postman
    and use that inside our app. Ideally, when you receive an Unauthorized error,
    you should open the login screen so that the user can log in. If `Email Id` and
    `Password` are validated, a token would be returned. This token can be used for
    further requests, such as Add To Cart.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续我们的实现，我们将从 Postman 调用令牌服务器，并在我们的应用程序中使用它。理想情况下，当你收到未经授权的错误时，你应该打开登录屏幕，以便用户可以登录。如果验证了
    `Email Id` 和 `Password`，则会返回一个令牌。此令牌可用于进一步的请求，例如添加到购物车。
- en: 'To save time and space, we will generate a token using Postman directly by
    using `taditdash@gmail.com` as our email ID and `12345` as our password*.* The
    subsequent Ajax call with the token should look like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间和空间，我们将直接使用 Postman 生成一个令牌，使用 `taditdash@gmail.com` 作为我们的电子邮件 ID，并使用 `12345`
    作为我们的密码*.* 使用令牌的后续 Ajax 调用应如下所示：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we have removed the token string in the preceding snippet for brevity.
    With the previous code, one cart record will be created and data returned from
    the API will give us all the detail about that record. You can store the cart's
    `Id` on the HTML row (as shown inside the preceding code block) for further processing
    while updating or deleting the cart record.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了简洁起见，我们在前面的片段中删除了令牌字符串。使用前面的代码，将创建一个购物车记录，并从 API 返回的所有数据都将提供有关该记录的所有详细信息。您可以在
    HTML 行中存储购物车的 `Id`（如前述代码块中所示），以便在更新或删除购物车记录时进行进一步处理。
- en: 'The following screenshot of the Elements tab in the Chrome Developer Tool illustrates
    the cart record''s ID stored as a `data-cart-id` attribute:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了 Chrome 开发者工具中元素标签页的购物车记录 ID，存储为 `data-cart-id` 属性：
- en: '![](img/0855f623-f91a-4c67-bd89-27533f9274e6.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0855f623-f91a-4c67-bd89-27533f9274e6.png)'
- en: PUT – api/Carts/{id}
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PUT – api/Carts/{id}
- en: 'Now that we have added one cart record, let''s move to update that record whenever
    a customer repeatedly hits the Add To Cart button. We already have the code that
    updates the quantity and price on the client-side table, so we just need to write
    the code to call the `PUT` endpoint to update the record, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一个购物车记录，让我们转到更新记录，每当客户反复点击“添加到购物车”按钮时。我们已经有更新客户端表格中数量和价格的代码，所以我们只需要编写调用
    `PUT` 端点的代码来更新记录，如下所示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The important part of the preceding code is the URL, which also contains the
    cart `Id` because the route is actually `api/Carts/{id}`. The data goes inside
    the body.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的重要部分是 URL，它还包含购物车 `Id`，因为路由实际上是 `api/Carts/{id}`。数据放在体中。
- en: 'The parameter `cartItem` is the row which can be passed from the `AddToCart`
    function as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `cartItem` 是可以从 `AddToCart` 函数传递的行，如下所示：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The API action should look as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: API 操作应如下所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that `id` is read from the route, as it is marked with the attribute
    `[FromRoute]`, and the cart object is read from the body of the request, as it
    is marked `[FromBody]`. If an ID is not sent with a route, the client would receive
    a 400 BadRequest error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`id` 从带有 `[FromRoute]` 属性的路由中读取，而购物车对象则从请求体中读取，因为它带有 `[FromBody]` 标记。如果没有与路由一起发送
    ID，客户端将收到 400 BadRequest 错误。
- en: 'The API action has now updated the record with the necessary details, as shown
    in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: API 操作现在已更新了带有必要详细信息的记录，如下面的截图所示：
- en: '![](img/3fdcedea-ae97-4a06-8a44-167ae0bf3b07.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fdcedea-ae97-4a06-8a44-167ae0bf3b07.png)'
- en: As you can see, we have clicked Add To Cart four times. The `finalPrice` is
    calculated accordingly as `49.99 * 4`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经点击了四次“添加到购物车”。`finalPrice` 根据以下方式计算：`49.99 * 4`。
- en: DELETE – api/Carts/{id}
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE – api/Carts/{id}
- en: Route `/api/Carts/{id}` tells us that we just need to send the cart `Id` to
    the API; everything else will be handled by the API so as to delete the record
    from the database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 路由 `/api/Carts/{id}` 告诉我们我们只需要将购物车 `Id` 发送到 API；其余一切将由 API 处理，以便从数据库中删除记录。
- en: 'The action method for deleting a record is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 删除记录的操作方法如下：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The client-side application has to be updated to allow this feature. As the
    delete icon is already shown on every cart row on the HTML table, we just need
    to send the cart's ID to the API when clicked by the user.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序需要更新以允许此功能。由于删除图标已经在HTML表格的每一行中显示，我们只需在用户点击时将购物车ID发送到API。
- en: 'The following JavaScript function can be used to delete a cart record:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下JavaScript函数可以用来删除购物车记录：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the `DeleteCart` function expects one parameter, `cartId`, which
    will be provided when the delete icon is clicked. This function calls the API
    with the type `DELETE`, as well as the `Id` and URL. On successful deletion, the
    cart row is removed from the HTML table.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`DeleteCart`函数期望一个参数，`cartId`，它将在点击删除图标时提供。此函数使用类型`DELETE`以及`Id`和URL调用API。在成功删除后，购物车行将从HTML表格中移除。
- en: 'The code block where `DeleteCart` is called is inside `AddToCart`, as shown
    in the following code snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`DeleteCart`的代码块位于`AddToCart`内部，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`DeleteCart` is called inside the click event of the anchor where the delete
    icon is shown. Inside the event, we get the cart `Id` from the row itself by extracting
    the value of the `data-cart-id` attribute.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteCart`在显示删除图标的锚点的点击事件中被调用。在事件内部，我们通过提取`data-cart-id`属性的值从行本身获取购物车`Id`。'
- en: Placing orders
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下订单
- en: Our cart is now full with the correct number of the desired products, so it's
    now time to place our order. For that, we need to call another controller—`OrdersController`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的购物车现在已满，包含了所需产品的正确数量，现在是时候下订单了。为此，我们需要调用另一个控制器——`OrdersController`。
- en: 'The following two tables are responsible for the ordering process:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个表负责订单过程：
- en: '**Orders**: This stores the shipping address details, customer details, order
    status, and so on'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单**：这存储了送货地址详情、客户详情、订单状态等'
- en: '**OrdersProducts**: This stores the products added to the cart, their price,
    and their quantity'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OrdersProducts**：这存储了添加到购物车的产品、它们的价格和数量'
- en: The `Orders` class is generated by the scaffolding we did initially, which contains
    all the necessary information. Let's generate the controller with this class.
    Follow the same process to generate the controller as we did for `ProductsController`,
    `ProductsdetailsController`, and `CartsController`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Orders`类是我们最初生成的脚手架，其中包含所有必要的信息。让我们使用这个类生成控制器。按照我们为`ProductsController`、`ProductsdetailsController`和`CartsController`生成控制器的方式，遵循相同的流程生成控制器。'
- en: The model and controller class can be found in the GitHub repository.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和控制类可以在GitHub仓库中找到。
- en: 'Now it''s time to call the `POST` action of `OrdersController` to save the
    order on the client-side. The following code is the skeleton of the function that
    does that:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候调用`OrdersController`的`POST`操作来在客户端保存订单了。以下代码是执行此操作的函数的骨架：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's now explain this step-by-step.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步解释这个过程。
- en: UI design for placing an order
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下订单的UI设计
- en: Before we move on any further, we need to show a modal to the user where they
    can enter their shipping address. The modal will be opened once the Place Order
    button is clicked, as shown in the following screenshot.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要向用户显示一个模态框，让他们可以输入他们的送货地址。一旦点击“下订单”按钮，模态框就会打开，如下面的截图所示。
- en: '![](img/be1c0d95-e89f-4215-bdb1-17aeb01e44e2.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be1c0d95-e89f-4215-bdb1-17aeb01e44e2.png)'
- en: 'The following code snippet illustrates the click event for Place Order (the
    modal is opened if cart items are present):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了“下订单”的点击事件（如果购物车中有项目，则会打开模态框）：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'An Ajax call inserts an order''s record in the database by clicking Submit
    using `POST`. The following code snippet is the click event of Submit:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击“提交”使用`POST`进行Ajax调用，将订单记录插入数据库。以下代码片段是“提交”的点击事件：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The client-side PostOrder function
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端PostOrder函数
- en: Let's now move on to the steps required for `PostOrders`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到`PostOrders`所需的步骤。
- en: Building order objects to match the model class Orders.cs
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建与模型类Orders.cs匹配的订单对象
- en: Here, we have to read the values from the text boxes related to shipping information
    and match them with the fields of `Orders.cs` to build an object. `OrdersProducts`
    is an array representing the model class, `OrdersProducts.cs`. Every order can
    have multiple products associated with it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须从与送货信息相关的文本框中读取值，并将它们与`Orders.cs`的字段匹配，以构建一个对象。`OrdersProducts`是一个表示模型类`OrdersProducts.cs`的数组。每个订单可以与多个产品相关联。
- en: 'The following code implements order objects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了订单对象：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Pushing cart items into an order object as an array
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将购物车项目作为数组推入订单对象
- en: 'Populating the `OrdersProducts` array is the next step, and this can be done
    by looping through the cart table''s rows and pushing each cart row''s details
    to the array. Inside the loop, read all the necessary values from the row, either
    from its attribute or `td`. Remember to form an object and assign the values to
    field names that match the model class, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 填充`OrdersProducts`数组是下一步，这可以通过遍历购物车表的行并将每个购物车行的详情推送到数组中来实现。在循环内部，从行中读取所有必要的值，无论是从其属性还是`td`中。请记住，形成一个对象并将值分配给与模型类匹配的字段名，如下所示：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Calling POST /api/Orders
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 POST /api/Orders
- en: 'Great, now we have our object! It''s now time to call the API `/api/Orders`
    with a `POST` request so that our order goes into the database, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们有了我们的对象！现在是时候使用`POST`请求调用API `/api/Orders`，以便我们的订单进入数据库，如下所示：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If everything works correctly, you should see something like the following
    screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该会看到以下截图中的内容：
- en: '![](img/73a57966-56ba-42d0-89d3-7692b980e20b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73a57966-56ba-42d0-89d3-7692b980e20b.png)'
- en: 'But we are forgetting something here; although our order has been placed successfully,
    we need to empty the cart. This can be done by calling `DELETE /api/Carts` for
    each cart item inside the `success` function of `PostOrders`, shown as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们在这里忘记了一些事情；尽管我们的订单已经成功提交，但我们还需要清空购物车。这可以通过在`PostOrders`的`success`函数中调用`DELETE
    /api/Carts`为每个购物车项来实现，如下所示：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We've explored everything from the client side, so now it's time to check the
    API.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从客户端方面探索了一切，现在是时候检查API了。
- en: PostOrders API POST method
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostOrders API POST方法
- en: 'The Orders table looks a little different to what we sent to the client. In
    the following screenshot, note the fields marked in boxes. These are the fields
    we are not sending and will instead manipulate inside the action method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 订单表看起来与我们发送给客户端的略有不同。在以下截图中，请注意标记在框中的字段。这些是我们没有发送而是在动作方法内部操作的字段：
- en: '![](img/c498012d-ce9e-4bfd-9946-601fd6c4d6a8.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c498012d-ce9e-4bfd-9946-601fd6c4d6a8.png)'
- en: 'Fields such as name, email, and telephone number can be fetched from the Customers
    table. `Customerid` is sent from the client, using which we will fetch these details,
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 像姓名、电子邮件和电话号码这样的字段可以从客户表中获取。`Customerid`由客户端发送，我们将使用它来获取这些详细信息，如下所示：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following code snippet illustrates how a user can copy their billing address
    so that it is also their delivery address:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了用户如何复制他们的账单地址，使其也成为他们的送货地址：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Additional fields, including `datapurchased`, `lastmodified`, and `orderdatefinished`,
    will be set as `DateTime.Now`. Details such as `currency` and `currency_value`
    will be set as dollars ($) and zero (0). We will also set `Guid.NewGuid` as `shipingmethodid`
    and `paymentmethodid`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`datapurchased`、`lastmodified`和`orderdatefinished`在内的附加字段将被设置为`DateTime.Now`。像`currency`和`currency_value`这样的详细信息将被设置为美元($)和零(0)。我们还将`Guid.NewGuid`设置为`shipingmethodid`和`paymentmethodid`。
- en: 'These can be made inside the Orders constructor as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在订单构造函数内部完成，如下所示：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that the `Orderstatus` is Placed. This is something that can be updated
    by the site when an order is ready for shipping. Subsequent statuses might include
    Approved, Ready, Shipped, Delivered, and so on. If you design the admin screen,
    make sure you handle this field update along with `latsmodified` and `orderdatefinished`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`Orderstatus`是已放置。这是当订单准备好发货时网站可以更新的内容。后续状态可能包括批准、准备、已发货、已送达等。如果你设计管理界面，请确保你处理这个字段的更新，包括`latsmodified`和`orderdatefinished`。
- en: The application demonstrated in this book is not production-ready. Generally,
    there should be a login page that works with *OAuth2.0 Authentication*. Basic
    validations on the API side, as well as the client side, also need to be handled.
    In this book, our application is built to showcase the concepts we are exploring,
    but you can definitely optimize our example and even build on top of it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本书演示的应用程序尚未准备好投入生产。通常，应该有一个与*OAuth2.0认证*一起工作的登录页面。在API端以及客户端进行基本验证也是必要的。在这本书中，我们的应用程序是为了展示我们正在探索的概念而构建的，但你绝对可以优化我们的示例，甚至在此基础上构建。
- en: Exposing shipping details
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露运输详情
- en: '`GET` requests can be used on `OrdersController` with an order ID so that order
    details can be consumed by third party sites for display. For example, many courier
    companies expose their APIs, which is used by other sites to display order, shipment,
    and tracking information.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GET`请求可以在`OrdersController`中通过订单ID来获取订单详情，以便第三方网站可以显示这些信息。例如，许多快递公司公开了它们的API，其他网站可以使用这些API来显示订单、运输和跟踪信息。
- en: 'As an example, let''s check out our `GET` method `OrdersController`, which
    takes the ID as a parameter:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们检查我们的`GET`方法`OrdersController`，它接受ID作为参数：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice that the `Include` clause is used to include results from the `OrdersProducts`
    table. Let''s now perform a quick Postman call to this endpoint to see the result
    of our earlier order, as shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用了`Include`子句来包含来自`OrdersProducts`表的结果。现在让我们快速使用Postman调用此端点，查看我们之前订单的结果，如下面的截图所示：
- en: '![](img/538eb690-57ed-4097-9e78-4856fce019ef.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/538eb690-57ed-4097-9e78-4856fce019ef.png)'
- en: Here, you can see every detail relating to the order, along with its products,
    are returned from the API.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到与订单相关的每一个细节，包括其产品，都是通过API返回的。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you've reached this point of the book, you will have designed some cool things
    using APIs. Well done!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经读到这本书的这一部分，你将使用API设计了一些酷炫的东西。做得好！
- en: In this chapter, we moved towards consuming `ProductsController` to display
    the product list on our client-side app. Product attributes along with their pricing
    details were shown with a simple UI that was designed using Bootstrap, jQuery,
    and HTML.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们转向了消费`ProductsController`以在我们的客户端应用程序上显示产品列表。使用Bootstrap、jQuery和HTML设计的简单UI展示了产品属性及其定价详情。
- en: Slightly modified `GET` requests inside `ProductsController` with a `searchString`
    parameter helped us to retrieve search results from the API. Clients could easily
    implement the search function by consuming the endpoint with text.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductsController`内部稍微修改了带有`searchString`参数的`GET`请求，这帮助我们从API中检索搜索结果。客户端可以通过消费带有文本的端点轻松实现搜索功能。
- en: We then looked at our shopping cart. We explored how `CartsController` actions
    can be consumed to add, update, and delete cart items while updating the UI. In
    the process, we implemented security for the controller using authentication.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查看我们的购物车。我们探讨了如何消费`CartsController`操作来添加、更新和删除购物车项目，同时更新UI。在这个过程中，我们使用身份验证实现了控制器的安全性。
- en: Finally, we converted the items in our cart into a visualized order. This was
    done using `OrdersController`, which can also be used to provide shipping and
    tracking information to clients.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将购物车中的项目转换成了可视化的订单。这是通过使用`OrdersController`完成的，该控制器还可以用于向客户提供运输和跟踪信息。
- en: In the next chapter, we're going to take a look at different techniques for
    testing the RESTful Web API designed in .NET Core.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨测试.NET Core中设计的RESTful Web API的不同技术。
