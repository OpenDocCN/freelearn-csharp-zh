- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Avoiding Code Anti-Patterns with SOLID
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SOLID原则避免代码反模式
- en: The right design principles can keep your code from quickly going stale. While
    there are many right ways of writing code, there are anti-patterns and code smells
    that constitute the wrong way of writing code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的设计原则可以防止你的代码迅速过时。虽然编写代码有许多正确的方法，但也有一些反模式和代码异味构成了错误的编写方式。
- en: Additionally, the community has identified several principles to keep in mind
    when building software that can help your code resist accumulating technical debt
    for as long as possible. In this chapter, we’ll cover a number of these principles,
    including the famous SOLID acronym, and see how they can help you build software
    that actively resists the gradual decline toward legacy code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，社区已经确定了一些原则，在构建软件时应牢记，这有助于你的代码尽可能长时间地抵抗技术债务的积累。在本章中，我们将介绍这些原则中的许多，包括著名的SOLID缩写，并探讨它们如何帮助你构建能够积极抵抗逐渐走向过时代码的软件。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Identifying anti-patterns in C# code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别C#代码中的反模式
- en: Writing SOLID code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写SOLID代码
- en: Considering other architectural principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑其他架构原则
- en: Identifying anti-patterns in C# code
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别C#代码中的反模式
- en: I’ve often found myself telling new programmers that to build good software,
    you have to first build a lot of really bad software and learn from it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常发现自己告诉新程序员，要构建好的软件，你必须首先构建大量的非常糟糕的软件，并从中学习。
- en: 'While this statement is somewhat in jest, there is some truth to it: almost
    every developer can recognize code that’s written the wrong way and discover things
    that make it difficult to work with, and doing so helps you write better code
    the next time.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个说法有些玩笑成分，但其中确实有一些真理：几乎每个开发者都能识别出编写错误的方式，并发现使其难以工作的因素，这样做有助于你在下一次编写更好的代码。
- en: 'When your code is bad, there’s usually a part of you that knows it. You see
    little things that you don’t love: duplicated pieces of code, inconsistencies
    in naming or parameter ordering, passing too many parameters around, methods,
    or even classes that are just too big to manage effectively.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码质量不佳时，你内心通常会有所察觉。你会看到一些你不喜欢的细节：重复的代码片段、命名或参数顺序的不一致性、传递过多的参数、方法，甚至是一些太大而难以有效管理的类。
- en: These symptoms are what we commonly refer to as **code smells**, and we’ll revisit
    them later in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些症状就是我们通常所说的**代码异味**，我们将在本节稍后重新讨论。
- en: Beyond code smells are something called **anti-patterns**, which is code that
    significantly deviates from community recommendations. Unfortunately, not all
    anti-patterns are easy to notice or discover on your own, and some even seem like
    good ideas to individuals or teams until they’re fully explored.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味之外，还有一种称为**反模式**的东西，即与社区建议显著偏离的代码。不幸的是，并非所有反模式都容易察觉或自行发现，有些甚至在完全探索之前似乎对个人或团队来说是好主意。
- en: A few common C# anti-patterns I see include throwing and catching an `Exception`
    error instead of a specific type of `Exception` error, not disposing of resources
    that implement `IDisposable`, and inefficient **Language-Integrated Query** (**LINQ**)
    statements. See the *Further reading* section of this chapter for more details
    on these anti-patterns.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到的一些常见的C#反模式包括抛出和捕获一个`Exception`错误而不是特定类型的`Exception`错误，没有释放实现`IDisposable`接口的资源，以及效率低下的**语言集成查询**（**LINQ**）语句。关于这些反模式的更多细节，请参阅本章的*进一步阅读*部分。
- en: There are far too many anti-patterns to cover in this book, and the established
    practices of .NET development evolve over time. Because of this constant change,
    Visual Studio offers code analysis tools to help spot and fix violations of community
    standards. These tools include code analysis rulesets and built-in **Roslyn Analyzers**,
    which we’ll cover at more length in [*Chapter 12*](B21324_12.xhtml#_idTextAnchor259),
    *Code Analysis in* *Visual Studio*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，要涵盖的反模式太多了，而且.NET开发的既定实践随着时间的推移而演变。正因为这种持续的变化，Visual Studio提供了代码分析工具，以帮助发现和修复违反社区标准的行为。这些工具包括代码分析规则集和内置的**Roslyn分析器**，我们将在[*第12章*](B21324_12.xhtml#_idTextAnchor259)，*Visual
    Studio中的代码分析*中更详细地介绍。
- en: Not all issues in code are specific to C# code. Many issues in code stem from
    how classes interact, pass data around to one another, manage variables, and are
    generally structured. These issues emerge even in code that you intended to be
    “well structured” as you start to see your systems scale up in size as new capabilities
    are added.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的问题并不都是针对 C# 代码的。许多问题源于类之间的交互、相互传递数据、管理变量以及一般的结构。这些问题甚至在你开始看到系统规模随着新功能的添加而扩大时，也会出现在你打算“结构良好”的代码中。
- en: Thankfully, even new developers have an innate ability to spot code that is
    difficult to follow, requires more work to maintain and expand than it should,
    or involves excessive duplication. These types of issues in code are commonly
    referred to as **code smells**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，即使是新开发者也天生具有识别难以遵循的代码、需要比应有的更多工作来维护和扩展的代码，或者涉及过度重复的代码的能力。这些类型的代码问题通常被称为
    **代码异味**。
- en: What are code smells?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味是什么？
- en: Code smells are prime indicators that your current architecture has some drawbacks
    and refactoring might be in order. Pay attention to these symptoms when you encounter
    them in systems, including the code you write yourself. Learning what makes code
    difficult to work with will help you write better code and refactor existing code
    into better forms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味是当前架构存在一些缺陷且需要进行重构的强烈指标。当你遇到这些症状时，包括你编写的代码，请注意这些症状。了解使代码难以工作的原因将帮助你编写更好的代码，并将现有代码重构为更好的形式。
- en: For now, let’s move on to talk about writing **SOLID code**, which can help
    you avoid some common code smells and build robust, maintainable, and testable
    code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论编写 **SOLID 代码**，这可以帮助你避免一些常见的代码异味，并构建健壮、可维护和可测试的代码。
- en: Writing SOLID code
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写SOLID代码
- en: '**SOLID** is an acronym introduced by Michael Feathers summarizing the words
    of Robert C. Martin. The intent of SOLID is to provide developers with a set of
    principles that will guide them toward more maintainable code that resists becoming
    technical debt.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOLID** 是由迈克尔·费瑟斯（Michael Feathers）引入的一个缩写，总结了罗伯特·C·马丁（Robert C. Martin）的话。SOLID
    的目的是为开发者提供一套原则，引导他们编写更易于维护且能抵抗技术债务的代码。'
- en: 'The five principles of SOLID code are:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 代码的五个原则是：
- en: '**Single Responsibility** **Principle** (**SRP**)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责** **原则** （**SRP**）'
- en: '**Open-Closed** **Principle** (**OCP**)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭** **原则** （**OCP**）'
- en: '**Liskov Substitution** **Principle** (**LSP**)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换** **原则** （**LSP**）'
- en: '**Interface Segregation** **Principle** (**ISP**)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离** **原则** （**ISP**）'
- en: '**Dependency Inversion** **Principle** (**DIP**)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置** **原则** （**DIP**）'
- en: In this section, we’ll cover all five of these principles.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖这五个原则。
- en: Single Responsibility Principle
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'The **Single Responsibility Principle** (**SRP)** says that a class should
    be responsible for one thing and one thing only. Here are a few examples of classes
    that follow the SRP:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则** （**SRP**）表示一个类应该只负责一件事情。以下是一些遵循 SRP 的类的例子：'
- en: A class responsible for saving application data to a specific file format
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责将应用程序数据保存到特定文件格式的类
- en: A database access class dedicated to executing queries against a database table
    or set of tables
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门用于对数据库表或一组表执行查询的数据库访问类
- en: An API controller providing REST methods to interact with flight data
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供REST方法以与飞行数据交互的API控制器
- en: A class representing the user interface in a specific part of your application
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表你应用程序特定部分的用户界面的类
- en: Classes violate the SRP by trying to do more than one type of thing in the same
    class. More formally, if there’s ever more than one reason to modify a class,
    the class violates the SRP.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类通过在同一个类中尝试做多种类型的事情来违反 SRP。更正式地说，如果修改一个类的原因超过一个，那么这个类就违反了 SRP。
- en: For example, if a class is responsible for tracking a set of items in a user
    interface, responding to button presses, parsing user input, and asynchronously
    fetching data, that class very likely violates the SRP.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个类负责跟踪用户界面中一组项目的状态、响应用户按钮点击、解析用户输入以及异步获取数据，那么这个类很可能违反了 SRP。
- en: Classes that violate the SRP tend to be frequently modified, grow in complexity
    over time, and be very large classes compared to other classes in the system.
    These classes can be hard to fully understand or adequately test and can become
    brittle and buggy as they grow in complexity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 违反单一职责原则（SRP）的类往往会被频繁修改，随着时间的推移复杂性增加，并且与其他系统中的类相比，它们会变得非常大。这些类可能难以完全理解或充分测试，并且随着复杂性的增加，可能会变得脆弱和充满错误。
- en: 'One of the things that I do to help detect violations of the SRP is to have
    a class-level comment talking about what the class is responsible for. For example,
    the following XML comment describes the `FlightScheduler` class from *Part 1*
    of this book:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我用来帮助检测SRP违反的一种方法是添加一个类级别注释，讨论类的责任。例如，以下XML注释描述了本书第一部分的`FlightScheduler`类：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, the responsibility of `FlightScheduler` is clear: it exists to track
    active and pending flights within the system. Reasons for modifying this class
    should be related to the tracking of these flights and not related to other topics.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FlightScheduler`类的责任是明确的：它存在是为了跟踪系统中的活跃和待处理的航班。修改此类的原因应与这些航班的跟踪相关，而不是与其他主题相关。
- en: For this reason, I tend to put class-level comments in all classes whenever
    I define a new class to help that class stay focused on its mission over the course
    of its life.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当我在定义一个新类时，我倾向于在所有类中添加类级别注释，以帮助该类在其生命周期中保持对其任务的专注。
- en: But what if you have a class that already exists and violates the SRP?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你有一个已经存在且违反SRP（单一责任原则）的类怎么办？
- en: When you have a class that’s responsible for multiple things, I like to look
    at everything the class is currently responsible for and group them into related
    groups of members. For example, if a class has 10 fields, 25 methods, and 6 properties,
    I might go through them and try to find common topics that those things address.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个负责多项事物的类时，我喜欢查看该类目前负责的所有内容，并将它们分组到相关的成员组中。例如，如果一个类有10个字段，25个方法，和6个属性，我可能会逐一检查它们，并试图找到那些事物共同解决的问题。
- en: 'For example, if the `FlightScheduler` class violated the SRP, it might have
    members for the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`FlightScheduler`类违反了SRP，它可能包含以下成员：
- en: Scheduling and canceling flights
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 航班调度和取消
- en: Assigning crew to flights
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为航班分配机组人员
- en: Booking flights for passengers
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为乘客预订航班
- en: Changing seat assignments for passengers
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改乘客的座位分配
- en: Moving passengers to different flights
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将乘客转移到不同的航班
- en: Generating flight-scheduling documentation for management
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为管理层生成航班调度文档
- en: This class, clearly, is responsible for more than one type of thing. In a production
    system, this class might be 2,000 lines long or more and be difficult to fully
    understand and adequately test. Additionally, changes to one area of the class
    might impact other areas in unexpected ways.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个类负责多种类型的事物。在一个生产系统中，这个类可能长达2,000行或更多，难以完全理解和充分测试。此外，对类的一个区域的更改可能会以意想不到的方式影响其他区域。
- en: By looking at the groups of things a class addresses, you can usually identify
    a few key groups. I like to do this and then focus on the largest group of related
    responsibilities that are not clearly related to the core goal of the class. Once
    you identify these groupings, you can extract a new class to manage these aspects.
    Your original class can reference this class or store it as a field if needed,
    or the new class could operate completely independently of the old class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看一个类处理的事物的组，你通常可以识别出几个关键组。我喜欢这样做，然后专注于那些与类的核心目标不明确相关的最大相关责任组。一旦确定了这些分组，你就可以提取一个新的类来管理这些方面。你的原始类可以引用这个类，或者如果需要，将其存储为字段，或者新类可以完全独立于旧类运行。
- en: In the case of `FlightScheduler`, I would say that scheduling and canceling
    flights is the core part of the class, and other aspects currently in the class
    might belong more elsewhere. Looking at those other areas, there are several things
    related to managing flight reservations for passengers, so in this case, a `FlightBookingManager`
    class might be introduced to contain these related pieces of logic.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FlightScheduler`的情况下，我会说航班调度和取消是类的核心部分，而类中目前的其他方面可能更适合放在别处。查看那些其他区域，有几个与为乘客管理航班预订相关的事物，因此在这种情况下，可能需要引入一个`FlightBookingManager`类来包含这些相关的逻辑片段。
- en: By iteratively introducing new classes from functionality not related to the
    core responsibility of a class, you can shrink large classes down to manageable
    sizes and resist the complexity, quality, and testability issues found in classes
    that ignore the SRP.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代地引入与类核心责任无关的新类，你可以将大型类缩小到可管理的规模，并抵抗那些在忽略SRP（单一责任原则）的类中发现的复杂性、质量和可测试性问题。
- en: The SRP doesn’t apply just to classes but can apply to methods as well. A method
    should have a single core task it is responsible for, and that purpose should
    be communicated by the name of the method. When a method is responsible for multiple
    things or starts getting too large, it’s a good sign that you might need to extract
    a method and pull some logic out of the original method to keep the size of the
    method maintainable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则不仅适用于类，也适用于方法。一个方法应该有一个它负责的单个核心任务，并且这个目的应该通过方法名来传达。当一个方法负责多个事物或开始变得太大时，这可能是一个很好的迹象，表明你可能需要提取一个方法并将一些逻辑从原始方法中拉出来，以保持方法的大小可维护。
- en: Personally, if there were one programming principle I could impart to my younger
    self –or most early/intermediate developers out there, it would be the importance
    of the SRP in keeping your code easy to understand, test, expand, and maintain.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，如果我能向年轻时的自己——或者大多数早期/中级开发者传授一个编程原则，那将是单一职责原则（SRP）在保持代码易于理解、测试、扩展和维护方面的重要性。
- en: My personal guideline is to strive for classes under 200 lines of code long
    and methods under 20 lines of code long, but both can be challenging, and there
    are certainly exceptions to be made to these guidelines depending on the nature
    of the code you’re maintaining – remember that these are principles and guidelines,
    not firm rules or commandments.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的指导原则是努力使类不超过200行代码，方法不超过20行代码，但这都是挑战，根据你维护的代码的性质，这些指导原则可能会有例外——记住，这些是原则和指导原则，而不是严格规则或戒律。
- en: '*If you only remember one part of SOLID, remember the SRP; it’s that important
    to the health of your application.* However, there are four more principles to
    explore.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你只记得SOLID原则中的一个，那就记住单一职责原则（SRP）；它对你的应用程序的健康至关重要。* 然而，还有四个原则需要探索。'
- en: Open-Closed Principle
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: Classes are said to follow the **Open-Closed Principle (OCP)** when they are
    *open to extension* but *closed* *to modification*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当类*开放于扩展*但*封闭于修改*时，我们说它们遵循**开放封闭原则（OCP）**。
- en: This principle was originally written for C++ modules, and it doesn’t translate
    as cleanly to C# as some of the other SOLID principles, but this is essentially
    a principle about following **object-oriented programming** (**OOP**) principles
    when designing your classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则最初是为C++模块编写的，它不像其他SOLID原则那样干净地转换为C#，但这本质上是一个关于在设计类时遵循**面向对象编程（OOP）**原则的原则。
- en: If you build something to follow the OCP, you are designing a class to have
    its behavior extended through other classes inheriting it, through customizable
    properties or parameters, or through composition where you compose your class
    of other objects that change how it behaves.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建了遵循开放封闭原则的东西，你就是在设计一个类，使其行为可以通过继承它的其他类、可定制的属性或参数，或者通过组合（将你的类组合成其他对象，这些对象会改变其行为）来扩展。
- en: 'An example of using composition was covered in [*Chapter 5*](B21324_05.xhtml#_idTextAnchor101)*:
    Object-oriented Refactoring* and involved providing different cargo items for
    a flight.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B21324_05.xhtml#_idTextAnchor101)中，我们讨论了使用组合的例子：面向对象重构，并涉及到为航班提供不同的货物项目。
- en: The rest of this section will focus on using inheritance to fulfill the OCP.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余部分将专注于使用继承来实现开放封闭原则。
- en: In C#, methods do not allow overriding by default. This means you’ll need to
    explicitly opt-in to allow others to override your methods by declaring them as
    `virtual`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，默认情况下方法不允许被重写。这意味着你需要明确选择允许他人通过将它们声明为`virtual`来重写你的方法。
- en: Counterpoint
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 反驳观点
- en: I’ve heard some developers argue that declaring methods as `virtual` without
    any classes overriding them is confusing, adds unnecessary keywords to your code,
    and even slightly harms the performance of your code at runtime. All these things
    can be true, but if you are in a scenario where you cannot predict how others
    will use your code and you know they won’t be able to modify your source code,
    marking key methods as `virtual` is usually a good idea. In these scenarios, `virtual`
    adds extra flexibility.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我听说一些开发者认为，在没有类重写的情况下将方法声明为`virtual`会让人困惑，给代码添加了不必要的关键字，甚至略微损害了代码在运行时的性能。所有这些事情都可能成立，但如果你处于一个无法预测他人如何使用你的代码，并且你知道他们无法修改你的源代码的场景中，将关键方法标记为`virtual`通常是一个好主意。在这些场景中，`virtual`提供了额外的灵活性。
- en: Remember that SOLID principles *are guidelines to keep in mind* while building
    software, not firm rules you need to always follow.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，SOLID原则是在构建软件时需要记住的*指导原则*，而不是你需要始终遵循的严格规则。
- en: 'As a specific example of the OCP, let’s look at a sample `ItineraryManager`
    class representing information about a passenger’s flight itinerary as they travel
    via Cloudy Skies Airlines:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为OCP的一个具体示例，让我们看看一个代表乘客通过Cloudy Skies Airlines旅行的航班行程信息的`ItineraryManager`类样本：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we have a class that tracks the total miles a passenger has accrued, as
    well as the next flight the passenger is scheduled to fly (which may be `null`
    when their trip is completed). The class has two `virtual` methods related to
    handling completed flights as well as canceled flights. Additionally, the class
    has a non-`virtual` method called `AccumulateMiles` that updates the miles the
    passenger has accumulated on this trip.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个跟踪乘客累积的总里程以及乘客计划乘坐的下一航班（当他们的旅行完成时，这可能是`null`）的类。该类有两个与处理完成的航班以及取消的航班相关的`virtual`方法。此外，该类还有一个非`virtual`方法`AccumulateMiles`，它更新乘客在本次旅行中累积的里程。
- en: While this class meets the needs of the airline, let’s say that the airline
    wants to introduce a new logic for reward customers that gives them 100 extra
    miles for every flight they complete and rewards the scheduled mileage for a flight
    when the passenger is involuntarily moved to a new flight.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个类满足了航空公司的需求，但假设航空公司想引入一种新的逻辑来奖励客户，每当客户完成一次航班时，他们可以获得100额外里程，并且当乘客被强制转移到新的航班时，奖励该航班的预定里程。
- en: 'Under the OCP, we should be able to do this without having to modify our base
    class, assuming that the class is open to modification. It turns out we can do
    this with the following `RewardsItineraryManager` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在OCP的指导下，如果我们假设类是可修改的，我们应该能够这样做而不必修改我们的基类。结果是我们可以用以下`RewardsItineraryManager`类来实现这一点：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Without modifying our base class, we can extend the implementation of `ItineraryManager`
    with our new class that follows a slightly different logic. Thanks to the magic
    of polymorphism, we can use a `RewardsItineraryManager` class anywhere an `ItineraryManager`
    class is accepted, further supporting the closed-to-modification aspect of the
    OCP.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在不修改我们的基类的情况下，我们可以通过我们的新类扩展`ItineraryManager`的实现，这个新类遵循略微不同的逻辑。多态的神奇之处在于，我们可以在接受`ItineraryManager`类的地方使用`RewardsItineraryManager`类，进一步支持OCP的封闭性原则。
- en: Liskov Substitution Principle
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: The **Liskov Substitution Principle** (**LSP**) says that polymorphic code should
    not need to be aware of what specific types of objects it is working with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Liskov替换原则**（**LSP**）表示，多态代码不应该需要知道它正在处理的具体类型的对象。'
- en: 'That’s still a somewhat vague description, so let’s take another look at the
    `FlightCompleted` method from earlier:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一个相当模糊的描述，所以让我们再次看看之前的`FlightCompleted`方法：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method takes in a flight that it stores in the `Flight` property. If a
    prior flight was stored in that `Flight` property, the code will call the `AccumulateMiles`
    method with that flight’s `Miles` property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收一个航班并将其存储在`Flight`属性中。如果之前在该`Flight`属性中存储了航班，代码将调用该航班的`Miles`属性调用`AccumulateMiles`方法。
- en: 'The application has several classes that inherit from `FlightInfo`: `PassengerFlightInfo`
    and `CargoFlightInfo`. That means our `next` parameter may be any one of these
    three classes – or some other class that inherits from them.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有多个从`FlightInfo`继承的类：`PassengerFlightInfo`和`CargoFlightInfo`。这意味着我们的`next`参数可能是这三个类中的任何一个——或者是从它们继承的任何其他类。
- en: 'The LSP says that *any* valid instance of `FlightInfo` should not error when
    you call its `Miles` property (or any other method). For example, this version
    of `CargoFlightInfo` would be a violation of the LSP because its `Miles` property
    errors when called:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: LSP表示，任何有效的`FlightInfo`实例在调用其`Miles`属性（或任何其他方法）时都不应该出错。例如，这个版本的`CargoFlightInfo`会违反LSP，因为当调用其`Miles`属性时会出错：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Essentially, when following the LSP, the method should not have any reason to
    need to know which subclass of `FlightInfo` it’s dealing with.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，遵循LSP时，方法不应该有任何理由需要知道它正在处理`FlightInfo`的哪个子类。
- en: Because the LSP is focused on polymorphism, it applies to both class inheritance
    and interface implementations in .NET code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为LSP关注多态性，所以它适用于.NET代码中的类继承和接口实现。
- en: Speaking of interfaces, let’s move on to the ISP.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 说到接口，让我们继续讨论ISP。
- en: Interface Segregation Principle
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The **Interface Segregation Principle** (**ISP**) is a fancy way of saying that
    you should prefer many smaller specialized interfaces focused on related capabilities
    over one large interface that encompasses everything your class does.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口分离原则**（**ISP**）是一种优雅的说法，意味着你应该优先选择许多专注于相关功能的小型专业接口，而不是一个包含你类所做所有事情的庞大接口。'
- en: 'For example, imagine we had a `FlightRepository` class that managed database
    access to individual flights. In many systems, this class might implement an `IFlightRepository`
    interface that could be defined as follows with all public members of the class
    as part of the interface:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个`FlightRepository`类，该类管理对单个航班的数据库访问。在许多系统中，这个类可能实现了一个`IFlightRepository`接口，该接口可以定义如下，其中类中的所有公共成员都是接口的一部分：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, this manages common operations related to flights and provides
    some means of finding information about many flights. In a more real-world example,
    there would likely be many additional methods that would need to be added over
    the years to support new features.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这管理了与航班相关的常见操作，并提供了一些查找许多航班信息的方式。在一个更真实世界的例子中，可能需要多年内添加许多额外的功能来支持新特性。
- en: In my experience with .NET code, it is very common to have a large interface
    per major class that includes all public methods in this class. This interface
    is usually named after the class it was based on and exists mostly to support
    testability through **dependency injection** (**DI**), as we’ll touch on in the
    next chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的.NET代码经验中，每个主要类通常都有一个包含该类所有公共方法的庞大接口。这个接口通常以它所基于的类命名，并且主要存在是为了通过**依赖注入**（**DI**）来支持可测试性，我们将在下一章中涉及。
- en: However, this approach is usually a violation of the ISP. Because our interfaces
    are designed around classes instead of discrete sets of capabilities, it becomes
    harder to introduce a new class that meets some of those capabilities but not
    all.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法通常违反了ISP。因为我们的接口是围绕类而不是离散的功能集设计的，所以引入一个满足某些但不是所有这些功能的新类变得更加困难。
- en: For example, let’s say that Cloudy Skies Airlines wants to integrate with another
    subsidiary airline’s systems. It doesn’t need to add, update, or delete flights,
    but it does want a way of searching for flights. Under the `IFlightRepository`
    interface, the `AddFlight`, `UpdateFlight`, and `CancelFlight` methods would either
    need to do nothing or throw a `NotSupportedException` error when called. By the
    way, throwing the exception on a not-supported method call as part of a larger
    interface would be a violation of the LSP mentioned earlier.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设Cloudy Skies Airlines想要与另一家子公司航空公司的系统集成。它不需要添加、更新或删除航班，但它确实想要一种搜索航班的方式。在`IFlightRepository`接口下，`AddFlight`、`UpdateFlight`和`CancelFlight`方法可能需要什么也不做，或者在调用时抛出`NotSupportedException`错误。顺便说一句，在更大的接口中抛出不支持的方法调用异常，将违反之前提到的LSP。
- en: 'Instead of having one large interface per major type, the ISP advocates for
    small interfaces for tightly related capabilities. In the case of `FlightRepository`,
    it’s essentially doing two things:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个主要类型对应一个庞大接口的做法不同，ISP提倡为紧密相关的功能使用小型接口。在`FlightRepository`的例子中，它本质上做两件事：
- en: Adding, editing, and deleting flights
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加、编辑和删除航班
- en: Searching for existing flights
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索现有航班
- en: 'If we wanted to introduce interfaces, we could introduce interfaces for these
    separate sets of related capabilities, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要引入接口，我们可以为这些相关的独立功能集引入接口，如下所示：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, our `FlightRepository` class would implement both the `IFlightUpdater`
    interface and the `IFlightProvider` interface. If we wanted to integrate with
    another airline’s systems but didn’t have the ability to modify their flights,
    the `IFlightProvider` interface could be implemented without the `IFlightUpdater`
    interface.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的`FlightRepository`类将实现`IFlightUpdater`接口和`IFlightProvider`接口。如果我们想要与另一家航空公司的系统集成，但没有修改其航班的能力，那么`IFlightProvider`接口可以不实现`IFlightUpdater`接口。
- en: By segmenting our interfaces into small interfaces that denote distinct sets
    of capabilities, we make it easier to provide alternative implementations of those
    capabilities as well as test our code later.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的接口分割成表示不同功能集的小接口，我们使得提供这些功能的替代实现以及之后测试我们的代码变得更加容易。
- en: We’ve touched on DI a few times now; let’s explore that topic in more detail
    by covering the DIP and rounding out our SOLID principles.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经几次提到了依赖注入（DI）；让我们通过涵盖DIP来更详细地探讨这个主题，并完善我们的SOLID原则。
- en: Dependency Inversion Principle
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The **Dependency Inversion Principle** (**DIP**) states that your code should
    generally depend on abstractions instead of on specific implementations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）指出，你的代码通常应该依赖于抽象而不是依赖于具体的实现。'
- en: 'To illustrate this, let’s look at a `FlightBookingManager` class that helps
    passengers book flights. This class needs to register booking requests and send
    confirmation messages for the booking. Here’s its current code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看看一个`FlightBookingManager`类，它帮助乘客预订航班。这个类需要注册预订请求并发送预订确认消息。这是它的当前代码：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code allows passengers to book a flight by checking if a seat is available,
    then reserving that seat and sending a message using the `_email` field. This
    field is set in the constructor to a new instance of `SpecificMailClient`, which
    is a made-up class representing some very specific implementation of an email
    client. The constructor needs to get a connection string to instantiate this class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许乘客通过检查座位是否可用，然后预订该座位并使用`_email`字段发送消息来预订航班。这个字段在构造函数中设置为`SpecificMailClient`的新实例，这是一个虚构的类，代表电子邮件客户端的一些非常具体的实现。构造函数需要获取连接字符串来实例化这个类。
- en: This code violates the DIP because our `FlightBookingManager` class is tightly
    coupled with a specific email client. If we ever wanted to write unit tests against
    this class, the class would always try to send messages to that email client,
    which usually isn’t what you want when testing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码违反了依赖倒置原则（DIP），因为我们的`FlightBookingManager`类与一个特定的电子邮件客户端紧密耦合。如果我们想对这个类编写单元测试，这个类总是会尝试向那个电子邮件客户端发送消息，这在测试时通常不是你想要的。
- en: Additionally, if the organization wanted to change email providers and you needed
    to switch to a different email client, the `FlightBookingManager` class would
    need to change along with anywhere else in the system where we were tightly coupled
    to use the `SpecificMailClient` class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果组织想要更换电子邮件提供商，你需要切换到不同的电子邮件客户端，`FlightBookingManager`类将需要随着系统中任何其他与`SpecificMailClient`类紧密耦合的地方一起改变。
- en: Dependency inversion flips this on its head by having our classes instead depend
    on abstractions of the specific things they depend on. This is usually done by
    depending on a base class such as `EmailClientBase` that is then inherited or
    through taking in an interface such as `IEmailClient` that specific clients can
    implement.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置通过让我们的类依赖它们所依赖的具体事物的抽象来实现这一点。这通常是通过依赖一个基类，如`EmailClientBase`，然后继承它，或者通过接受一个接口，如`IEmailClient`，具体客户端可以实现它。
- en: 'We typically take in these dependencies in the constructor as a constructor
    parameter. This version of our `FlightBookingManager` class would look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将这些依赖作为构造函数参数接受。我们`FlightBookingManager`类的这个版本看起来会是这样：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, instead of taking in a connection string, we now take in an `IEmailClient`
    class. This means our class doesn’t need to know which implementation it is dealing
    with or how to instantiate an instance of that class, doesn’t need a connection
    string, doesn’t need to change if the specific email provider ever changes, and
    can be tested easier by passing in a fake email client instead of a real one (we’ll
    talk more about this in the next chapter when discussing Moq).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不再接受连接字符串，而是接受一个`IEmailClient`类。这意味着我们的类不需要知道它正在处理哪种实现，也不需要知道如何实例化该类的实例，不需要连接字符串，不需要在特定的电子邮件提供商更改时进行更改，并且可以通过传递一个模拟电子邮件客户端而不是真实的一个来更容易地进行测试（我们将在下一章讨论Moq时更多地讨论这一点）。
- en: This process of taking in a dependency from something else is called **Dependency
    Inversion** and is often an intimidating topic for new and intermediate developers,
    but at its core, Dependency Inversion is all about classes getting their dependencies
    passed into them instead of having to create specific instances themselves.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他东西中接受依赖的过程被称为**依赖倒置**，对于新和中级开发者来说，这通常是一个令人畏惧的话题，但就其核心而言，依赖倒置完全是关于类从外部获取它们的依赖，而不是必须自己创建特定的实例。
- en: Following the DIP leads to more maintainable, flexible, and testable code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循DIP会导致代码更加易于维护、灵活和可测试。
- en: This concludes the five principles in SOLID, but we still have a few more design
    principles to cover before closing out the chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了SOLID中的五个原则，但在结束这一章之前，我们还有几个设计原则要介绍。
- en: Considering other architectural principles
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑其他架构原则
- en: Before we close out the chapter, let me share three brief principles that have
    helped me in my own journey toward good software.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，让我分享三个在我自己的软件开发之旅中帮助我的简要原则。
- en: Learning the DRY principle
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习DRY原则
- en: '**Don’t Repeat Yourself** (**DRY**) is an important tenant in software development.
    The DRY principle is oriented around making sure you don’t repeat the same patterns
    in code throughout your application. Code takes a while to write, read, and maintain,
    and bugs inevitably do occur at a certain rate per line of code. As a result,
    you want to strive to solve problems once in a centralized place and then reuse
    that solution.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**）是软件开发中的一个重要原则。DRY原则的核心是确保你不会在应用程序的代码中重复相同的模式。编写代码需要花费时间，阅读和维护也需要时间，而且错误不可避免地会在每行代码中以一定的速率发生。因此，你希望努力在一个集中的地方一次性解决问题，然后重用那个解决方案。'
- en: 'Let’s look at some sample code that violates the DRY principle. This code takes
    in a `"CSA1234,CMH,ORD"` and translates it into a `FlightInfo` object:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些违反DRY原则的示例代码。这段代码接受一个`"CSA1234,CMH,ORD"`并将其转换为`FlightInfo`对象：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how the logic for parsing in each part of the CSV string is wrapped in
    checks against `null` values and the array of parts is empty. This code is very
    repetitive, and it’s easy to imagine that if a new field got added to the CSV
    data, the developer making the change would just copy and paste those five lines
    of code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到解析CSV字符串每一部分的逻辑是如何被包裹在针对`null`值和部分数组为空的检查中的。这段代码非常重复，很容易想象如果CSV数据中添加了新字段，进行更改的开发者会直接复制和粘贴这五行代码。
- en: 'There are a few problems with repeating code patterns such as this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重复代码模式，如这个问题，有几个问题：
- en: It encourages copying and pasting, which tends to produce poor code or results
    in bugs due to things that should have been changed on paste not being changed
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它鼓励复制和粘贴，这往往会产生糟糕的代码或由于在粘贴时应该更改而未更改的事情而导致错误
- en: If the logic for parsing an individual field needs to change (for example, to
    protect against empty strings), it now needs to be changed in many places
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果解析单个字段的逻辑需要改变（例如，为了防止空字符串），现在需要在很多地方进行更改
- en: 'We can fix this by extracting a method containing the logic for parsing fields:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提取包含解析字段逻辑的方法来解决这个问题：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not only is this new version easier to maintain, but it also results in less
    code overall and helps focus your attention on parts of the logic that are different
    from section to section. This improves the readability of your code while also
    reducing your likelihood of making mistakes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这个新版本更容易维护，而且它还减少了代码量，并有助于将注意力集中在不同部分之间逻辑不同的部分。这提高了代码的可读性，同时减少了你犯错误的可能性。
- en: KISS principle
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KISS原则
- en: “**Keep it simple, stupid**” (abbreviated as **KISS** and sometimes called “**Keep
    it simple, silly**”) is a principle focused on the complexity of software systems.
    As software engineers, we sometimes overthink things and make things incredibly
    complex when they don’t need to be. KISS encourages you to keep your code and
    classes as simple as possible and expand the complexity only when truly necessary.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: “**保持简单，傻瓜**”（缩写为**KISS**，有时也称为“**保持简单，愚蠢**”）是一个关注软件系统复杂性的原则。作为软件工程师，我们有时会过度思考，使事情变得极其复杂，而实际上并不需要这样。KISS原则鼓励你尽可能保持你的代码和类简单，只有在真正必要时才扩展复杂性。
- en: Typically, the more complexity you have in your systems, the longer it takes
    you to add new features, diagnose problems, onboard new team members, and resolve
    customer-facing issues. With more moving parts to your application, there are
    also more things that can break, meaning that complexity has a real chance of
    creating customer-facing issues—all for potential solutions to problems your organization
    won’t have for a few years.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的系统中复杂性越高，添加新功能、诊断问题、 onboard新团队成员和解决面向客户的问题所需的时间就越长。随着应用程序中移动部件的增加，也有更多可能出错的事情，这意味着复杂性有真正的机会创建面向客户的问题——所有这些都是为了解决你组织几年内可能不会遇到的问题的潜在解决方案。
- en: Complexity tends to grow over time and rarely ever decreases (particularly in
    database schemas). Keep it simple until you see a pressing and compelling reason
    to add more complexity.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性往往会随着时间的推移而增长，很少会减少（尤其是在数据库模式中）。保持简单，直到你看到迫切和有说服力的理由来增加复杂性。
- en: Understanding high cohesion and low coupling
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解高内聚和低耦合
- en: 'Finally, let’s close the chapter out by reviewing two terms you’ll hear occasionally
    in software engineering: **cohesion** and **coupling**.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过回顾你在软件工程中偶尔会听到的两个术语来结束本章：**内聚**和**耦合**。
- en: 'Cohesion has to do with how related different parts of the class are to the
    same thing. In a high-cohesion class, almost all parts of the class are oriented
    on the same types of capabilities. Let’s look again at the `IFlightUpdater` interface
    from earlier for an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 内聚与类的不同部分如何与同一事物相关联有关。在一个高内聚的类中，几乎所有的类部分都面向同一类型的功能。让我们再次看看之前提到的`IFlightUpdater`接口作为例子：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A class that implemented everything in this interface and added no other members
    would be a good example of *high cohesion* because all members in this interface
    are related to working with the same type of item. A *low-cohesion* class would
    start with these methods but also add many methods related to booking flights,
    generating reports, searching data, or other capabilities.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实现了这个接口中的所有内容且没有添加其他成员的类是一个很好的**高内聚**例子，因为该接口中的所有成员都与处理同一类型的项目相关。一个**低内聚**的类会从这些方法开始，但也会添加许多与预订航班、生成报告、搜索数据或其他功能相关的方法。
- en: Classes that have low cohesion usually also violate the SRP.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 具有低内聚的类通常也违反了SRP。
- en: Coupling refers to how tightly paired together with other classes a single class
    is. The more classes an individual class needs to know about to do its job, the
    more tightly coupled it is. Classes with higher coupling are harder to test due
    to a larger number of dependencies and need to be modified more frequently as
    their related classes evolve over time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合指的是单个类与其他类紧密配对的程度。一个类需要了解的其他类越多，它的耦合度就越高。具有更高耦合度的类由于依赖项较多，测试起来更困难，并且随着相关类随时间演变而需要更频繁地修改。
- en: The DIP provides a great way for classes to reduce their coupling.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: DIP为类提供了一个很好的方法来减少它们的耦合。
- en: So, when you hear people talk about wanting high cohesion and low coupling,
    they’re advocating for classes that are very tightly focused on a specific area
    and rely on as few other classes as possible to achieve that objective. When this
    combination is met, classes tend to be very focused and easy to maintain.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你听到人们谈论希望有高内聚和低耦合时，他们是在提倡具有非常专注于特定领域并且尽可能少地依赖其他类的类。当这种组合满足时，类往往非常专注且易于维护。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed code smells and anti-patterns. The right design
    principles can help keep your code focused and minimal and slow the rate at which
    it naturally accumulates complexity. This helps keep your code in good form and
    resist accumulating technical debt.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了代码异味和反模式。正确的设计原则可以帮助保持你的代码集中和最小化，并减缓它自然积累复杂性的速度。这有助于保持你的代码良好形态并抵抗技术债务的积累。
- en: The most common maxim for quality programming is SOLID, following the Single
    Responsibility Principle (SRP), making code open for extension while being closed
    to modification, the Liskov Substitution Principle (LSP) advocating for low coupling
    with polymorphic code, the interface segregation principle focused on several
    smaller interfaces over one larger interface, and the Dependency Inversion Principle
    (DIP) which talks about reducing coupling by having classes take in the things
    they need from outside of the class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 质量编程最常见的原则是SOLID，遵循单一职责原则（SRP），使代码易于扩展而难以修改，Liskov替换原则（LSP）提倡使用多态代码实现低耦合，接口隔离原则关注多个较小的接口而不是一个较大的接口，以及依赖倒置原则（DIP），它讨论通过让类从类外获取它们所需的东西来减少耦合。
- en: Now that we’ve established how to write SOLID code, we’ll explore some advanced
    testing techniques that can help test code built using these principles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了如何编写SOLID代码，我们将探讨一些高级测试技术，这些技术可以帮助测试使用这些原则构建的代码。
- en: Questions
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does the SRP affect cohesion?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SRP如何影响内聚性？
- en: Which areas of your code violate the SRP or DRY?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码中哪些区域违反了SRP或DRY？
- en: What are the advantages of DI? How does it affect coupling?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DI的优势是什么？它是如何影响耦合的？
- en: Further reading
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about materials discussed in this chapter at
    these URLs:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下URL中找到有关本章讨论的材料更多信息：
- en: '*SOLID Principles in C# with* *Examples*: [https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/](https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#中的SOLID原则及示例*：[https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/](https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/)'
- en: '*15 of the Worst C# Anti-Patterns Developers Keep Using (And How to Avoid*
    *Them)*:[https://methodpoet.com/worst-anti-patterns/](https://methodpoet.com/worst-anti-patterns/)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发者持续使用的15个最糟糕的C#反模式（以及如何避免它们）*：[https://methodpoet.com/worst-anti-patterns/](https://methodpoet.com/worst-anti-patterns/)'
- en: '*Top 10 Dotnet Exception Anti-Patterns in* *C#*: [https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/](https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#中的Top 10 Dotnet异常反模式*：[https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/](https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/)'
- en: '*Using objects that implement* *IDisposable*: [https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用实现*IDisposable*的对象*：[https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects)'
- en: '*LINQ: Caveats and* *pitfalls*: [https://dev.to/samfieldscc/linq-37k3](https://dev.to/samfieldscc/linq-37k3)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LINQ的注意事项和陷阱*：[https://dev.to/samfieldscc/linq-37k3](https://dev.to/samfieldscc/linq-37k3)'
