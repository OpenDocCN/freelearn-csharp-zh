- en: Chapter 4. C# with NGUI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：C# 与 NGUI
- en: 'In this chapter, we will talk about C# scripting with NGUI. We will learn how
    to handle events and interact with them. We''ll use them to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论使用 NGUI 的 C# 脚本。我们将学习如何处理事件并与它们交互。我们将使用它们来：
- en: Play animations and Tweens
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放动画和补间
- en: Change labels using localized text through code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代码使用本地化文本更改标签
- en: Add keyboard keys for our UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的UI添加键盘键
- en: Create notifications and tool tips
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建通知和工具提示
- en: We will also see some of the NGUI's code-oriented components, such as event
    forwarding and message sending.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到一些 NGUI 的面向代码的组件，例如事件转发和消息发送。
- en: Events methods
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件方法
- en: When using C# with NGUI, there are some methods that you will regularly use
    when you need to know if your object is currently hovered upon, pressed, or clicked.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 C# 与 NGUI 一起使用时，有一些方法您将在需要知道对象当前是否被悬停、按下或点击时经常使用。
- en: 'If you attach a script to any object with a collider on it (for example, a
    button or a 3D object), you can add the following useful methods in the script
    to catch events:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将脚本附加到具有碰撞器的任何对象上（例如，按钮或3D对象），您可以在脚本中添加以下有用的方法来捕获事件：
- en: '`OnHover(bool state)`: This method is called when the object is hovered or
    unhovered. The `state` bool gives the hover state; if `state` is `true`, the cursor
    just entered the object''s collider. If `state` is `false`, the cursor has just
    left the collider''s bounds.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHover(bool state)`: 当对象被悬停或取消悬停时调用此方法。`state` 布尔值给出悬停状态；如果 `state` 是 `true`，则光标刚刚进入对象的碰撞器。如果
    `state` 是 `false`，则光标刚刚离开碰撞器的边界。'
- en: '`OnPress(bool state)`: This method works in the exact same way as the previous
    `OnHover()` method, except it is called when the object is pressed. It works with
    a touch or click. If you need to know which mouse button was used to press the
    object, use the `UICamera.currentTouchID` variable; if this int is equal to -1,
    it''s a left-click. If it''s equal to -2, it''s a right-click. Finally, if it''s
    equal to -3, it''s a middle-click.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPress(bool state)`: 此方法与之前的 `OnHover()` 方法完全相同，只是在对象被按下时调用。它与触摸或点击一起工作。如果您需要知道用于按下对象的鼠标按钮，请使用
    `UICamera.currentTouchID` 变量；如果此 int 等于 -1，则表示左键点击。如果等于 -2，则表示右键点击。最后，如果等于 -3，则表示中键点击。'
- en: '`OnClick()`: This method is similar to `OnPress()`, except that this method
    is exclusively called when the click is validated, meaning when an `OnPress(true)`
    event occurs followed by an `OnPress(false)` event. It works with mouse click
    and touch.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnClick()`: 此方法与 `OnPress()` 类似，但此方法仅在点击被验证时调用，即 `OnPress(true)` 事件之后跟随 `OnPress(false)`
    事件。它与鼠标点击和触摸一起工作。'
- en: Note
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the `OnDoubleClick()` method, which works in the same way.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可以使用 `OnDoubleClick()` 方法，它的工作方式相同。
- en: '`OnDrag(Vector2 delta)`: This method is called at each frame when the mouse
    or touch moves between the `OnPress(true)` and `OnPress(false)` events. The `Vector2`
    `delta` argument gives you the object''s movement since the last frame.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDrag(Vector2 delta)`: 在鼠标或触摸在 `OnPress(true)` 和 `OnPress(false)` 事件之间移动的每一帧调用此方法。`Vector2`
    `delta` 参数给出对象自上一帧以来的移动。'
- en: '`OnDrop(GameObject droppedObj)`: This method is called when an object is dropped
    on the GameObject on which this script is attached. The dropped GameObject is
    passed as the `droppedObj` parameter.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDrop(GameObject droppedObj)`: 当对象被丢弃到附加此脚本的 GameObject 上时调用此方法。丢弃的 GameObject
    作为 `droppedObj` 参数传递。'
- en: '`OnSelect()`: This method is called when the user clicks on the object. It
    will not be called again until another object is clicked on or the object is deselected
    (click on nothing).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnSelect()`: 当用户点击对象时调用此方法。除非另一个对象被点击或对象被取消选择（点击空白处），否则不会再次调用。'
- en: '`OnInput(string text)`: This method is called when the user types in text while
    an object is selected. The `text` parameter gives the entered text.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnInput(string text)`: 当用户在选中对象时输入文本时调用此方法。`text` 参数给出输入的文本。'
- en: '`OnTooltip(bool state)`: This method is called when the cursor is over the
    object for more than the duration defined by the **Tooltip Delay** inspector parameter
    of **UICamera**. If the **Sticky Tooltip** Boolean of **UICamera** is checked,
    the tool tip will remain visible until the cursor moves outside the Collider''s
    Bounds, otherwise the tool tip disappears as soon as the cursor moves.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTooltip(bool state)`: 当光标在对象上超过由 **UICamera** 的 **Tooltip Delay** 检查器参数定义的持续时间时调用此方法。如果
    **UICamera** 的 **Sticky Tooltip** 布尔值被选中，则工具提示将保持可见，直到光标移出 Collider 的边界，否则工具提示将在光标移动时消失。'
- en: '`OnScroll(float delta)`: This method is called when the mouse''s scroll wheel
    is moved while the object is hovered—the delta parameter gives you the amount
    and direction of the scroll.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnScroll(float delta)`: 当鼠标的滚轮在对象上悬停时移动时，此方法会被调用——delta参数给出了滚动量及其方向。'
- en: '`OnKey(KeyCode key)`: This method is called when the user clicks on a key while
    the object is selected. The pressed key is stored in the `key` parameter.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnKey(KeyCode key)`: 当用户在对象被选中时点击一个键，此方法会被调用。按下的键存储在`key`参数中。'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you attach your script on a 3D object to catch these events, make sure it
    is on a layer included in `Event` `Mask` of `UICamera`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将脚本附加到3D对象以捕获这些事件，请确保它位于`UICamera`的`Event` `Mask`中包含的层。
- en: Creating a tool tip
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工具提示
- en: 'Let''s now use the `OnTooltip()` event to show a tool tip for our powers, as
    shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`OnTooltip()`事件来显示我们的工具提示，如下截图所示：
- en: '![Creating a tool tip](img/8667OT_04_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![创建工具提示](img/8667OT_04_01.jpg)'
- en: We will also make sure it is localized using methods integrated with NGUI.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将确保它使用与NGUI集成的集成方法进行本地化。
- en: The tool tip reference
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具提示引用
- en: 'First, we will create our tool tip that will be shown when needed. These are
    the steps to do so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个在需要时显示的工具提示。以下是执行此操作的步骤：
- en: 'Select and duplicate our **Help** GameObject with *Ctrl* + *D*. Then perform
    the following steps:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *D*选择并复制我们的**Help** GameObject。然后执行以下步骤：
- en: Rename this new duplicate as `Tooltip`.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此新副本重命名为`Tooltip`。
- en: Set **Depth** in **UIPanel** to `4`.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**UIPanel**中将**Depth**设置为`4`。
- en: Set **Clipping** in **UIPanel** to **None**.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UIPanel**中的**Clipping**设置为**None**。
- en: Remove its **Box Collider** component.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除其**Box Collider**组件。
- en: Remove its **UIDrag** `Object` component.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除其**UIDrag** `Object`组件。
- en: Remove its **UIAnchor** component.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除其**UIAnchor**组件。
- en: Reset its **Transform** position to {`0`, `0`, `0`}.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Transform**位置重置为{`0`, `0`, `0`}。
- en: 'Select our new **Background**, which is a child GameObject of **Tooltip**.
    Then perform the following steps:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的新**Background**，它是**Tooltip**的子GameObject。然后执行以下步骤：
- en: Set its **Depth** value to `0`.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Depth**值设置为`0`。
- en: Set its **Pivot** parameter to **Top Left** (left arrow + up arrow).
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Pivot**参数设置为**Top Left**（左箭头 + 上箭头）。
- en: Reset its **Transform** position to {`0`, `0`, `0`}.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Transform**位置重置为{`0`, `0`, `0`}。
- en: Set its **Dimensions** to `200` x `50`.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Dimensions**设置为`200` x `50`。
- en: 'Select **Label**, which is a child GameObject of **Tooltip**. Then perform
    the following steps:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Label**，它是**Tooltip**的子GameObject。然后执行以下步骤：
- en: Set its **Depth**to `1`.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Depth**设置为`1`。
- en: Change its text to `This is a Tooltip`.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其文本更改为`This is a Tooltip`。
- en: Change its **Overflow** parameter to **Resize Height**.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Overflow**参数更改为**Resize Height**。
- en: Remove its **Tween Position** component.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除其**Tween Position**组件。
- en: Remove its **UILocalize** component.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除其**UILocalize**组件。
- en: Set its **Pivot** parameter to **Top Left** (left arrow + up arrow).
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Pivot**参数设置为**Top Left**（左箭头 + 上箭头）。
- en: Set its **Transform** position to {`15`, `-15`, `0`}.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Transform**位置设置为{`15`, `-15`, `0`}。
- en: Set its **Dimensions** parameter to `200` x `20`.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Dimensions**参数设置为`200` x `20`。
- en: Select our **Tooltip** GameObject.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**Tooltip** GameObject。
- en: 'Attach a **Tooltip** to the selected object by navigating to **Component**
    | **NGUI** | **UI** and perform the following steps:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**Component** | **NGUI** | **UI**并为所选对象附加一个**Tooltip**，执行以下步骤：
- en: Drag our **Label** GameObject from **Tooltip** to its **Text** field.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**Label** GameObject 从**Tooltip**拖到其**Text**字段。
- en: Drag our **Window** GameObject from **Tooltip** to its **Background** field.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**Window** GameObject 从**Tooltip**拖到其**Background**字段。
- en: Ok. Our tool tip is ready to be displayed. The fact that we have set the **Pivot**
    parameter of **Label** under **Tooltip** to **Top left**, with a position of {`15`,
    `-15`, `0`}, will force a margin between the text and the background sprite.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们的工具提示已经准备好显示。我们已将**Tooltip**下的**Label**的**Pivot**参数设置为**Top left**，位置为{`15`,
    `-15`, `0`}，这将强制在文本和背景精灵之间产生一个边距。
- en: The **Overflow** parameter will let the text be resized in height only, which
    will make our tool tip coherent even if we have a long tool tip—the **Background**
    sprite will automatically resize to fit the **Label** GameObject.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Overflow**参数将允许文本仅按高度调整大小，这将使我们的工具提示即使在长工具提示的情况下也能保持一致——**Background**精灵将自动调整大小以适应**Label**
    GameObject。'
- en: Showing the tool tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示工具提示
- en: We must now show the tool tip when needed. In order to do that, we just need
    to use the `OnTooltip()` event, in which we will create a new tool tip with localized
    text.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须显示工具提示。为了做到这一点，我们只需要使用`OnTooltip()`事件，在其中我们将创建一个新的带有本地化文本的工具提示。
- en: In the **Project** view, select both our **Time** and **Bomb** prefabs and create
    and add a new `TooltipManager.cs` C# script to it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **项目** 视图中，选择我们的 **Time** 和 **Bomb** 预制件，并为其创建并添加一个新的 `TooltipManager.cs`
    C# 脚本。
- en: 'You can now open this new `TooltipManager.cs` script and declare the following
    enum, which will define which type of tool tip it must display:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以打开这个新的 `TooltipManager.cs` 脚本，并声明以下枚举，它将定义必须显示哪种类型的工具提示：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ok, now add the following `OnTooltip()` method that will create a tool tip
    with localized text depending on its current type:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在添加以下 `OnTooltip()` 方法，它将创建一个带有本地化文本的工具提示，其类型取决于当前类型：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the script. As you can see, we use a useful `Localization.instance.Get(string
    key)` method that returns localized text of the corresponding `key` parameter
    that is passed. You can now change a label to localized text through code anytime!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。如您所见，我们使用了一个有用的 `Localization.instance.Get(string key)` 方法，它返回与传递的 `key`
    参数相对应的本地化文本。您现在可以通过代码随时将标签更改为本地化文本！
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To use `Localization.instance.Get(string key)`, your label must not have a **UILocalize**
    component attached to it; otherwise, the value of **UILocalize** will overwrite
    anything you assign to the label.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Localization.instance.Get(string key)`，您的标签不得附加 **UILocalize** 组件；否则，**UILocalize**
    的值将覆盖您分配给标签的任何内容。
- en: 'Ok, we have added the code to show our tool tip with localized text. Now we
    have to add these localized strings to the `English.txt` file using the following
    code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经添加了代码来显示带有本地化文本的工具提示。现在我们必须使用以下代码将这些本地化字符串添加到 `English.txt` 文件中：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similarly, add the following lines in the `French.txt` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 `French.txt` 文件中添加以下行：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save these files and go back to Unity to assign the **TooltipManager** type''s
    variables by performing the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这些文件，然后返回 Unity，通过执行以下步骤来分配 **TooltipManager** 类型变量的值：
- en: In the **Project** view, select our **Bomb** prefab and set its **Type** field
    in **TooltipManager** to `Bomb`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 视图中，选择我们的 **Bomb** 预制件，并在 **TooltipManager** 中将其 **Type** 字段设置为 `Bomb`。
- en: In the **Project** view, select our **Time** prefab and set its **Type** field
    in **TooltipManager** to **Time**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 视图中，选择我们的 **Time** 预制件，并在 **TooltipManager** 中将其 **Type** 字段设置为 **Time**。
- en: Click on the play button. When you leave your cursor on the **Bomb** or **Time**
    power in the **Available powers** slot, our localized tool tip appears! I actually
    have the feeling that the delay is too long. Let's correct this.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击播放按钮。当您将光标放在 **可用能力** 槽中的 **Bomb** 或 **Time** 能力上时，我们的本地化工具提示就会出现！我实际上觉得延迟太长了。让我们纠正一下。
- en: Select our **Camera** GameObject from **UI Root (2D)** and set its **Tooltip
    Delay** value in **UICamera** to `0.3`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **UI Root (2D**) 中选择我们的 **Camera** GameObject，并在 **UICamera** 中将其 **Tooltip
    Delay** 值设置为 `0.3`。
- en: That's better—our localized tool tip appears within 0.3 seconds of hovering.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好——我们的本地化工具提示在悬停 0.3 秒后出现。
- en: Tween methods
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓动方法
- en: 'You can see all available Tweens by simply typing in `Tween` inside any method
    in your favorite IDE. You will see a list of `Tween` classes thanks to autocompletion,
    as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在您最喜欢的 IDE 中的任何方法中简单地输入 `Tween` 来查看所有可用的缓动方法。您将看到由于自动完成而显示的 `Tween` 类列表，如下截图所示：
- en: '![Tween methods](img/8667OT_04_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![缓动方法](img/8667OT_04_02.jpg)'
- en: The strong point of these classes is that they work in one line and don't have
    to be executed for each frame; you just have to call their `Begin()` method!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的一个优点是它们只需一行即可工作，并且不需要每帧执行；您只需调用它们的 `Begin()` 方法即可！
- en: Here, we will apply Tweens on widgets since we only have that in the scene.
    But keep in mind that it works in the exact same way with other GameObjects since
    NGUI widgets are GameObjects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将对小部件应用缓动，因为我们场景中只有这些。但请注意，它以完全相同的方式与其他 GameObjects 一起工作，因为 NGUI 小部件是
    GameObjects。
- en: Main menu apparition
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主菜单出现
- en: Let's use the `TweenPosition` class to make our main menu appear from the top
    of the screen on start. We will first use a simple Tween in only one line and
    then we will add an easing effect with a delay to make it nicer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `TweenPosition` 类使我们的主菜单在启动时从屏幕顶部出现。我们首先将使用只有一行的一个简单的缓动，然后我们将添加一个带有延迟的缓动效果，使其看起来更美观。
- en: Simple Tween
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单缓动
- en: 'We can add a **Tween Position** component to our **Container** GameObject in
    **MainMenu**, but we need to see how we create a **Tween** in code. The following
    is how we do so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 **主菜单** 中的 **Container** GameObject 上添加一个 **Tween Position** 组件，但我们需要看看如何在代码中创建
    **Tween**。以下是我们这样做的方式：
- en: Select our **Container** GameObject from **MainMenu** and create and add a new
    `AppearFromAbove.cs` C# script to it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **项目** 视图中选择我们的 **Container** GameObject，并在其中创建并添加一个新的 `AppearFromAbove.cs`
    C# 脚本。
- en: 'Now open this new `AppearFromAbove.cs` script and edit the `Start()` method
    so that it first sets the `position` value in `Container` to a higher value than
    the screen''s height. Then Tween it back to {`0`, `0`, `0`} in 1 second as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开这个新的`AppearFromAbove.cs`脚本并编辑`Start()`方法，使其首先将`Container`中的`position`值设置为高于屏幕高度。然后在一秒内将其Tween回`{0,
    0, 0}`，如下所示：
- en: '[PRE4]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Click on the play button. We now have our main menu coming down from the top
    of the screen with only two lines of code!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。现在我们的主菜单只用了两行代码就从屏幕顶部降下来！
- en: Smooth Tween
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平滑Tween
- en: We created a simple Tween, but you can also configure your Tween to add a smoothing
    method and a delay, for example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的Tweens，但你也可以配置你的Tweens以添加平滑方法和延迟，例如。
- en: 'Let''s try it now by replacing our `Start()` method''s code with the following
    one:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过将`Start()`方法的代码替换为以下代码来尝试它：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Click on the play button. We have added a nice `EaseInOut` method to our Tween.
    The menu''s vertical movement is now smoother, and all of this has been added
    through code. The following is a list of the different Tween methods that can
    add effects to Tweens:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。我们已经为我们的Tweens添加了一个不错的`EaseInOut`方法。菜单的垂直移动现在更平滑，所有这些都是通过代码添加的。以下是可以添加到Tweens以产生效果的不同的Tweens方法列表：
- en: '`Linear`: This will create a simple linear tween—no smoothing'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Linear`: 这将创建一个简单的线性tween—没有平滑'
- en: '`EaseIn`: This will make the tween smooth during the beginning'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EaseIn`: 这将在动画开始时使tween平滑'
- en: '`EaseOut`: This will make the tween smooth during the end'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EaseOut`: 这将在动画结束时使tween平滑'
- en: '`EaseInOut`: This will make the tween smooth both at the beginning and at the
    end'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EaseInOut`: 这将在动画开始和结束时使tween平滑'
- en: '`BounceIn`: This will give the tween bounce effect at the beginning'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BounceIn`: 这将在动画开始时产生弹跳效果'
- en: '`BounceOut`: This will give the tween bounce effect at the end'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BounceOut`: 这将在动画结束时产生弹跳效果'
- en: Now that you know how to use the `TweenPosition` class, you are capable of using
    other Tweens such as TweenScale, TweenRotation, TweenColor or any other available
    Tween, because they work the same way!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用`TweenPosition`类，你就可以使用其他Tweens，例如`TweenScale`、`TweenRotation`、`TweenColor`或任何其他可用的Tweens，因为它们的工作方式相同！
- en: Using keys for navigation
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按键进行导航
- en: 'The UI we have created works with the mouse. We can easily add key navigation
    for keyboard and controllers. A **UIButton Keys** component exists for that purpose.
    You have to add it to any UI element you want to be accessible with keys (the
    default **Inspector** window is as follows):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的UI可以通过鼠标操作。我们可以轻松地添加按键导航以支持键盘和控制器。存在一个**UIButton Keys**组件用于此目的。你必须将其添加到任何你希望可以通过按键访问的UI元素（默认的**检查器**窗口如下）：
- en: '![Using keys for navigation](img/8667OT_04_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![使用按键进行导航](img/8667OT_04_03.jpg)'
- en: 'Let''s try it now with our **Play**, **Exit**, and **Options** buttons:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们的**播放**、**退出**和**选项**按钮：
- en: Select our **Exit**, **Options**, and **Play** GameObjects.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**退出**、**选项**和**播放**GameObject。
- en: Attach a **Button Keys** component to them by navigating to **Component** |
    **NGUI** | **Interaction**.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**组件** | **NGUI** | **交互**，为它们附加一个**按钮按键**组件。
- en: A pop up will appear, as shown in the following screenshot, asking you if you
    want to replace or add a collider:![Using keys for navigation](img/8667OT_04_04.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个弹出窗口，如下面的截图所示，询问你是否要替换或添加碰撞体：![使用按键进行导航](img/8667OT_04_04.jpg)
- en: That's because they already have a **Box Collider** component. Click on **Replace**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为它们已经有一个**盒子碰撞体**组件。点击**替换**。
- en: 'Select the **Play** button and perform the following steps:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**播放**按钮并执行以下步骤：
- en: Check its **Starts Selected** Boolean.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查其**开始选中**布尔值。
- en: Drag our **Exit** button into the **Selected On Left** field.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**退出**按钮拖入**左侧选中**字段。
- en: Drag our **Exit** button into the **Selected On Right** field.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**退出**按钮拖入**右侧选中**字段。
- en: Drag our **Options** button into the **Selected On Down** field.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**选项**按钮拖入**向下选中**字段。
- en: 'Select the **Exit** button and perform the following steps:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**退出**按钮并执行以下步骤：
- en: Drag our **Play** button into the **Selected On Left** field.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**播放**按钮拖入**左侧选中**字段。
- en: Drag our **Play** button into the **Selected On Right** field.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**播放**按钮拖入**右侧选中**字段。
- en: Drag our **Options** button into the **Selected On Down** field.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**选项**按钮拖入**向下选中**字段。
- en: 'Select the **Options** button and perform the following steps:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**选项**按钮并执行以下步骤：
- en: Drag our **Exit** button into the **Selected On Left** field.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**退出**按钮拖入**左侧选中**字段。
- en: Drag our **Play** button into the **Selected On Right** field.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**播放**按钮拖入**右侧选中**字段。
- en: Drag our **Play** button into the **Selected On Up** field.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的 **Play** 按钮拖入 **Selected On Up** 字段。
- en: Click on play. Our **Play** button is selected by default, and if you use your
    keyboard arrows, you will be able to navigate through those three buttons and
    validate with *Return*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放。默认情况下，我们的 **Play** 按钮被选中，如果您使用键盘箭头，您将能够导航到这三个按钮并通过 *Return* 验证。
- en: Error notification
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误通知
- en: We want the user to enter a nickname in the input field and select a power before
    he or she can launch the game.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户在输入字段中输入昵称并选择力量值之后才能启动游戏。
- en: 'Right now, the user can launch the game regardless of the input and selected
    power value. Let''s correct this by preventing the game''s launch and notifying
    the user, as shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，用户可以无视输入和选定的力量值启动游戏。让我们通过以下截图所示的方法来纠正这个问题，防止游戏启动并通知用户：
- en: '![Error notification](img/8667OT_04_05.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![错误通知](img/8667OT_04_05.jpg)'
- en: 'We will use a TweenScale through code that will gradually scale up the notification
    from {0, 0, 0} to {1, 1, 1} by following these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过代码使用 TweenScale，将通知从 `{0, 0, 0}` 渐进缩放到 `{1, 1, 1}`，按照以下步骤进行：
- en: Select our **Tooltip** GameObject in the **Hierarchy** window.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 窗口中选择我们的 **Tooltip** GameObject。
- en: Duplicate it with *Ctrl* + *D*.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *D* 进行复制。
- en: 'Rename this new duplicate as `Notification` and perform the following steps:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新复制的文件重命名为 `Notification` 并执行以下步骤：
- en: Set its **Depth** parameter in **UIPanel** to 5.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **UIPanel** 中将 **Depth** 参数设置为 5。
- en: Remove its **UITooltip** component.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除其 **UITooltip** 组件。
- en: Set its **Transform** position to {`0`, `-355`, `0`}.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Transform** 位置设置为 `{`0`, `-355`, `0`}`。
- en: 'Select our **Label** GameObject in `Notification` and perform the following
    steps:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Notification` 中选择我们的 **Label** GameObject 并执行以下步骤：
- en: Change its text to `This is a Notification`.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其文本更改为 `This is a Notification`。
- en: Set the **Overflow** parameter to **Shrink Content**.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Overflow** 参数设置为 **Shrink Content**。
- en: Set its **Pivot** parameter to **Center** (middle button + middle button).
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Pivot** 参数设置为 **Center**（中间按钮 + 中间按钮）。
- en: Set its **Dimensions** to `550` x `80`.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Dimensions** 设置为 `550` x `80`。
- en: Reset its **Transform** position to {`0`, `0`, `0`}.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Transform** 位置重置为 `{`0`, `0`, `0`}`。
- en: Attach a **Localize** component to it by navigating to **Component** | **NGUI**
    | **UI**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **Component** | **NGUI** | **UI** 为其附加一个 **Localize** 组件。
- en: 'Select our **Background** GameObject in `Notification` and perform the following
    steps:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Notification` 中选择我们的 **Background** GameObject 并执行以下步骤：
- en: Set its **Pivot** parameter to **Center** (middle button + middle button).
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Pivot** 参数设置为 **Center**（中间按钮 + 中间按钮）。
- en: Reset its **Transform** position to {`0`, `0`, `0`}.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Transform** 位置重置为 `{`0`, `0`, `0`}`。
- en: Set its **Dimensions** parameters to `600` x `100`.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **Dimensions** 参数设置为 `600` x `100`。
- en: Select our **Notification** GameObject and set its **Transform** scale to {`0`,
    `0`, `1`}.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的 **Notification** GameObject 并将其 **Transform** 缩放设置为 `{`0`, `0`, `1`}`。
- en: Create and attach a new `NotificationManager.cs` C# script to it and open this
    new `NotificationManager.cs` script.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并附加一个新的 `NotificationManager.cs` C# 脚本到它，并打开这个新的 `NotificationManager.cs`
    脚本。
- en: Ok. We have our **Notification** GameObject ready with a scale of {`0`, `0`,
    `1`}. Let's use the new `NotificationManager.cs` script to launch a TweenScale
    through code when the **Notification** GameObject is activated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们已经有了缩放比例为 `{`0`, `0`, `1`}` 的 **Notification** GameObject，现在让我们使用新的 `NotificationManager.cs`
    脚本通过代码在 **Notification** GameObject 激活时启动一个 TweenScale。
- en: We will use an enum to define which notification type will be displayed. This
    time, we will use the **UILocalize** component for localized text and change the
    `key` parameter through code instead of using the `Localization.instance.Get()`
    method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用枚举来定义将显示哪种通知类型。这次，我们将使用 **UILocalize** 组件进行本地化文本，并通过代码更改 `key` 参数，而不是使用
    `Localization.instance.Get()` 方法。
- en: 'First, declare these variables in the `NotificationManager.cs` script as shown
    in the following code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `NotificationManager.cs` 脚本中声明以下变量，如下代码片段所示：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save the script. We will stock the instance of `NotificationManager` on the
    scene in the script to be able to access it from any other script easily.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。我们将在脚本中将 `NotificationManager` 的实例存储在场景中，以便能够轻松地从任何其他脚本访问它。
- en: First, let's assign our `Loc` variable using the **Inspector** window.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 **Inspector** 窗口分配我们的 `Loc` 变量。
- en: Select our **Notification** GameObject and drag our **Label** GameObject in
    **Notification** in to the **Loc** field.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 选择我们的 **Notification** GameObject 并将 **Notification** 中的 **Label** GameObject
    拖入 **Loc** 字段。
- en: 'Ok, now return to our `NotificationManager.cs` script. We will first create
    an `Awake()` method with our static instance variable''s initialization and disable
    our **Notification** GameObject to make it invisible when the game starts:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在回到我们的`NotificationManager.cs`脚本。我们将首先创建一个带有静态实例变量初始化的`Awake()`方法，并在游戏开始时禁用我们的**Notification**游戏对象，使其不可见：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that our `Awake()` method is written, let''s create an `OnEnable()` method
    that will declare the `TweenScale` object and set the corresponding `key` parameter
    for the `UILocalize` component as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了`Awake()`方法，让我们创建一个`OnEnable()`方法，它将声明`TweenScale`对象并设置`UILocalize`组件的相应`key`参数，如下所示：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget that if you change a `key` parameter when the **UILocalize** component
    is already active, you must call its `Localize()` method to update it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，如果在**UILocalize**组件已经激活时更改`key`参数，您必须调用其`Localize()`方法来更新它。
- en: Good. Click on the play button. Activate our **Notification** GameObject while
    Unity is running the play mode.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。点击播放按钮。当Unity运行播放模式时，激活我们的**Notification**游戏对象。
- en: 'You can see that our **Notification** GameObject appears smoothly. Let''s add
    a `Show()` method to display it through code as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的**Notification**游戏对象平滑地出现。让我们添加一个`Show()`方法，通过代码显示它，如下所示：
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous method shows our notification by activating its corresponding GameObject.
    The `OnEnable()` method will perform the tween and localization.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法通过激活其对应的游戏对象来显示我们的通知。`OnEnable()`方法将执行动画和本地化。
- en: 'On its last line, the `Show()` method starts the `Remove()` coroutine. Let''s
    add the following `Remove()` coroutine that will make the notification disappear
    after a given duration:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最后一行，`Show()`方法启动了`Remove()`协程。让我们添加以下`Remove()`协程，它将在给定的时间后使通知消失：
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Great. Now we can add the right localization strings in `English.txt` as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。现在我们可以在`English.txt`中添加正确的本地化字符串，如下所示：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also add the correct strings in `French.txt` as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`French.txt`中添加正确的字符串，如下所示：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can now call our `Show()` method if the player presses the play button with
    no nickname entered, or if he or she does not select a power.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家按下播放按钮而没有输入昵称，或者他没有选择一个能力，我们现在可以调用我们的`Show()`方法。
- en: 'In order to do this, we will remove the current **Load Level On Click** component
    from our **Play** button and attach a new `LaunchValidator.cs` script to it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将从我们的`Play`按钮中移除当前的**点击加载关卡**组件，并将其附加一个新的`LaunchValidator.cs`脚本：
- en: Select our `Play` button GameObject and remove its **Load Level On Click** component.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的`Play`按钮游戏对象并移除其**点击加载关卡**组件。
- en: Create and attach a new `LaunchValidator.cs` C# script to it and open this new
    `LaunchValidator.cs` script.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并附加一个新的`LaunchValidator.cs` C#脚本到它上，并打开这个新的`LaunchValidator.cs`脚本。
- en: 'In this new script, we will need our nickname''s **UIInput** component. Let''s
    declare it as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新脚本中，我们需要我们的昵称的**UIInput**组件。让我们如下声明它：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Save the script. Let's assign this variable right now in the **Inspector** window.
    Then select our **Play** GameObject and drag our **Input** GameObject from **Nickname**
    in the **Nickname Input** field in its **Launch Validator**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。现在让我们在**检查器**窗口中分配这个变量。然后选择我们的**Play**游戏对象，并将我们的**Input**游戏对象从**昵称输入**字段中的**昵称**拖到其**启动验证器**的**昵称输入**字段。
- en: 'Go back to our `LaunchValidator.cs` script. We will now add an `OnClick()`
    method to add a nickname and power validation before we actually load the game,
    as shown in the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们的`LaunchValidator.cs`脚本。我们现在将添加一个`OnClick()`方法，在实际上载游戏之前添加昵称和能力的验证，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Click on the play button. Perfect, we now have notifications that prevent the
    game from launching if the user has no nickname entered or has no power selected!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。太完美了，我们现在有了通知，如果用户没有输入昵称或没有选择能力，将阻止游戏启动！
- en: Saving the nickname
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存昵称
- en: 'In [Chapter 2](ch02.html "Chapter 2. Creating Widgets"), *Creating Widgets*,
    we entered `Nickname` in the **Auto-save Key** parameter of the nickname''s **UIInput**
    component. It works like this: if the user enters a nickname and presses *Return*,
    the input''s label `string` value is saved in the `PlayerPrefs()` method in the
    `Nickname` key.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "Chapter 2. Creating Widgets") *创建小部件*中，我们在昵称的**自动保存键**参数中输入了`Nickname`。它的工作原理是这样的：如果用户输入昵称并按下*Return*，输入的标签`string`值将被保存在`PlayerPrefs()`方法中的`Nickname`键。
- en: 'Here''s the issue: the nickname is saved if, and only if, the user presses
    *Return*. That''s a problem—most of the users will enter a name and select their
    power directly without pressing *Return*—I''m sure you''ve done it yourself too.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是：如果用户按下*Return*，昵称才会被保存。这是一个问题——大多数用户会在输入名字并直接选择他们的力量后不按*Return*——我敢肯定你也这样做过。
- en: We need to save the string in the `PlayerPrefs()` method even when the user
    clicks on the **Play** button without pressing *Return*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在用户点击**播放**按钮而不按*Return*时，将字符串保存在`PlayerPrefs()`方法中。
- en: 'We must add a line at the end of the `OnClick()` method of our `LaunchValidator.cs`
    script, which will save the nickname''s input `value` before the game scene is
    loaded. Just before the `Application.LoadLevel("Game")` line, add the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在`LaunchValidator.cs`脚本的`OnClick()`方法末尾添加一行，以便在加载游戏场景之前保存昵称的输入`value`。在`Application.LoadLevel("Game")`行之前，添加以下内容：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now the user's nickname is saved before launching the game, no matter what!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在无论用户做什么，在启动游戏之前，用户的昵称都会被保存！
- en: Sending messages
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送消息
- en: The `Notify` parameter in the **Inspector** window we used in previous chapters
    to call methods on a precise event is usually enough for sending messages. However,
    you may need to send a message to another GameObject and maybe to its children
    too.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，我们之前用来在精确事件上调用方法的`Notify`参数通常足以发送消息。然而，你可能需要向另一个GameObject及其子对象发送消息。
- en: 'That''s where the **UIButton Message** component comes in handy. We will use
    this to make our **MainMenu** GameObject scale down before the game actually quits:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，**UIButton消息**组件就派上用场了。我们将使用它来在游戏实际退出之前缩小我们的**MainMenu**GameObject的尺寸：
- en: 'Select our **Exit** GameObject and perform the following steps:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**退出**GameObject，并执行以下步骤：
- en: Attach a **Button Message** component to it by navigating to **Component** |
    **NGUI** | **Interaction**.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**组件** | **NGUI** | **交互**，将其附加一个**按钮消息**组件。
- en: Drag our **Container** GameObject from `MainMenu` into its **Target** field.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**容器**GameObject从`MainMenu`拖动到其**目标**字段。
- en: Type in `CloseMenu` in the **Function Name** parameter.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**函数名称**参数中输入`CloseMenu`。
- en: Select our **Container** GameObject in **MainMenu** and open its attached `AppearFromAbove.cs`
    script.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**MainMenu**中选择我们的**容器**GameObject，并打开其附加的`AppearFromAbove.cs`脚本。
- en: 'In this script, add a simple `CloseMenu()` method containing the following
    lines:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，添加一个简单的`CloseMenu()`方法，包含以下行：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we need to delay the execution of the `Application.Quit()` method, otherwise
    we won''t see our **Tween**. We do this using the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要延迟执行`Application.Quit()`方法，否则我们看不到我们的**Tween**。我们通过以下步骤来完成：
- en: 'Select our **GameManager** GameObject and perform the following steps:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**游戏管理器**GameObject，并执行以下步骤：
- en: Open its attached `GameManager.cs` script.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开其附加的`GameManager.cs`脚本。
- en: 'Replace the line in the `ExitPressed()` method with the following line:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下行替换`ExitPressed()`方法中的行：
- en: '[PRE17]'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a new `QuitNow()` method to actually exit the application as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`QuitNow()`方法来实际退出应用程序，如下所示：
- en: '[PRE18]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Save the script and click on the play button. When you exit the application,
    our **Menu** will automatically disappear. That's because the `Invoke()` method
    enables us to call a function with `delay` as the second parameter.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存脚本并点击播放按钮。当你退出应用程序时，我们的**菜单**将自动消失。这是因为`Invoke()`方法使我们能够以`延迟`作为第二个参数调用函数。
- en: 'Let''s add this nice scaling effect also when the player launches the game
    by performing the following steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤在玩家启动游戏时也添加这个不错的缩放效果：
- en: Select our **Play** button GameObject and open its attached `LaunchValidator.cs`
    script.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**播放**按钮GameObject，并打开其附加的`LaunchValidator.cs`脚本。
- en: 'We will need our **Container** GameObject from **MainMenu**. Declare it as
    follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要从**MainMenu**中的**容器**GameObject。声明如下：
- en: '[PRE19]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Go back to Unity and assign this new **menuContainer** variable as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，并按照以下方式分配这个新的**menuContainer**变量：
- en: Select our **Play** button GameObject and drag our **Container** GameObject
    from **MainMenu** to its **MenuContainer** field.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**播放**按钮GameObject，并将我们的**容器**GameObject从**MainMenu**拖动到其**MenuContainer**字段。
- en: 'Go back to our `LaunchValidator.cs` script. We simply have to replace the `Application.LoadLevel("Game")`
    line with the following lines:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到我们的`LaunchValidator.cs`脚本。我们只需将`Application.LoadLevel("Game")`行替换为以下行：
- en: '[PRE20]'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Ok, now we can add a new `LaunchNow()` method to actually launch the game scene
    as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们可以添加一个新的`LaunchNow()`方法来实际启动游戏场景，如下所示：
- en: '[PRE21]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Great, on exit or game launch, the menu scales out, which makes a nicer transition.
    We have also learned how to use a **UIButton Message** component.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，在退出或游戏启动时，菜单会缩放出来，这使得过渡更加流畅。我们还学习了如何使用 **UIButton Message** 组件。
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We didn't need the **Include Children** Boolean checked. But it's interesting
    to note that you can send a message to the target and all its children at once.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要勾选 **包含子项** 的布尔值。但值得注意的是，你可以一次性向目标及其所有子项发送消息。
- en: Forwarding an event
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转发事件
- en: 'Another component may be useful in some cases: **UIForward Events**. This component
    gives you the ability to send the events of the GameObject it''s attached to to
    another GameObject in the scene. It can be useful, for example, to create a multiple
    selection. Let''s try it to make it more clear. Perform the following steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，另一个组件可能很有用：**UIForward Events**。此组件允许将附加到它的 GameObject 的事件发送到场景中的另一个
    GameObject。例如，它可以用于创建多选。让我们尝试一下，使其更清晰。执行以下步骤：
- en: Select our **Bomb** GameObject in **Grid**.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **网格** 中选择我们的 **炸弹** GameObject。
- en: 'Attach a **Forward Events** component to it by navigating to **Component**
    | **NGUI** | **Interaction** and then perform the following steps:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **组件** | **NGUI** | **交互** 并将其添加到 **Forward Events** 组件，然后执行以下步骤：
- en: Drag our **Time** GameObject from **Grid** to the `Target` field.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的 **时间** GameObject 从 **网格** 拖动到 `目标` 字段。
- en: Check the **OnHover** Boolean.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选 **OnHover** 布尔值。
- en: Check the **OnPress** Boolean.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选 **OnPress** 布尔值。
- en: Check the **OnDrag** Boolean.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选 **OnDrag** 布尔值。
- en: Click on the play button. If you hover, press, and drag the **Bomb** power,
    the **Time** power will also react the same way! That is what event forwarding
    does.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮。如果你悬停、按下并拖动 **炸弹** 力量，**时间** 力量也会以相同的方式反应！这就是事件转发的作用。
- en: Now that you see how it works, you can remove the **UIForward Events** component
    from our **Bomb** GameObject.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到它是如何工作的，你可以从我们的 **炸弹** GameObject 中移除 **UIForward Events** 组件。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used C# with NGUI to create localized tool tips and error
    notifications. We learned how to use Tween classes to make our main menu appear
    and disappear smoothly with methods that ease Tweens.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 C# 和 NGUI 创建了本地化的工具提示和错误通知。我们学习了如何使用 Tween 类通过简化方法使主菜单平滑地出现和消失。
- en: We also know how to use keys for navigation in our UI, and our nickname is now
    saved when the game launches. You now know how to send messages and forward events
    using NGUI components, which may be useful to you in the future.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道如何使用键在 UI 中进行导航，并且当游戏启动时，我们的昵称现在已保存。你现在知道如何使用 NGUI 组件发送消息和转发事件，这可能在将来对你有所帮助。
- en: It's time to create a new `Game.unity` scene and build a complete scrollable
    viewport, which is the subject of [Chapter 5](ch05.html "Chapter 5. Building a
    Scrollable Viewport"), *Building a Scrollable Viewport*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个新的 `Game.unity` 场景并构建一个完整的可滚动视口，这是 [第 5 章](ch05.html "第 5 章。构建可滚动视口")，*构建可滚动视口*
    的主题。
