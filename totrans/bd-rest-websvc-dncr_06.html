<html><head></head><body>
        

                            
                    <h1 class="header-title">Testing RESTful Web Services</h1>
                
            
            
                
<p>A system cannot mature until it is tested in various scenarios. These scenarios are usually based on the experience of domain experts or existing production environments. There is always a chance that a system can crash in a production environment, even when the system is called a perfect system. For web applications, the conditions are even more critical due to performance glitches, bad user experience, and so on. A system should be put through a process or series of development principles to tackle these kinds of issues. Simply put, we must test the system. Testing is a process that ensures the quality of a system.</p>
<p>In other words, quality assurance, or testing, is a way to assess a system from different aspects. This process is also useful when a system requires testing to identify erroneous code, or if we want to assess its business compliance.</p>
<div><p>Quality assurance is a process that assesses a system and ensures its quality.</p>
</div>
<p>Testing is entirely dependent on the architectural style of the system and it varies from system to system; everything depends on how we strategize our testing approach or plan.</p>
<p>In this chapter, we will mainly focus on testing RESTful services and making our code better by following the test-driven development approach. At the end of this chapter, you will be able to use the testing paradigm in day-to-day development activities with knowledge of stubs, mocks an understanding of integration and security, and performance testing.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Test paradigms (the basics of quality assurance, including test case creation)</li>
<li>Testing the ASP.NET core controller (unit testing)</li>
<li>Stubs and mocking</li>
<li>Security testing</li>
<li>Integration testing</li>
<li>Fake objects</li>
<li>Testing service calls using Postman, Advanced RESTClient, and so on</li>
<li>User acceptance testing</li>
<li>Performance or load testing</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Test paradigms</h1>
                
            
            
                
<p>In the previous section, we saw that testing and quality assurance is one of the most important parts of the software development cycle. We should take steps to design a framework that tests the software, which is called a <strong>test paradigm</strong>.</p>
<div><p>A test paradigm is a framework of testing. It is based on the way one plans on implementing testing. In short, a test paradigm is a testing methodology.</p>
</div>
<p>A test method is where you decide how to create test cases, including what its language will be, how you will document the test cases, and so on. This also tells you how you are going to execute the test methods (for example, with black box testing).</p>
<div><p>A test method is an approach that tests or verifies the specific output on the basis of specific inputs, without knowing the internal functionality of a system.</p>
</div>
<p>Before we create test cases or develop a test paradigm or framework for testing, we need to get to grips with some important terminology.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test coverage and code coverage</h1>
                
            
            
                
<p>In general terms, coverage is what is covered and how you measure that coverage. From a developer's point of view, writing a unit test in test-driven development tells us how and what area of code is covered.</p>
<div><p>A measurement of code executed during testing is code coverage.<br/>
A measurement of test cases executed during testing is test coverage.</p>
</div>
<p>The code is unit tested and it is proven that covered code is tested. In this code coverage, there would be many things that have been covered, namely, lines of code, functions, conditions, expressions, API resources, and so on.</p>
<div><p>For software testing terms, refer to <a href="http://castb.org/wp-content/uploads/2014/05/istqb_glossary_of_testing_terms_v2.3.pdf">http://castb.org/wp-content/uploads/2014/05/istqb_glossary_of_testing_terms_v2.3.pdf</a>.</p>
</div>
<p>Test coverage and code coverage can also cover any of the following testing types:</p>
<ul>
<li>Unit testing</li>
<li>Security testing</li>
<li>Integration testing</li>
</ul>
<p>In the upcoming sections, we will look at these tests in detail using code examples.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tasks, scenarios, and use cases</h1>
                
            
            
                
<p>When someone is working with a test paradigm, they should know the terms task, scenario, and use case. In this section, we will discuss these terms in detail:</p>
<ul>
<li><strong>Task</strong>: A task is a generic word not only relevant to the software industry but to many others, too. This is an act or piece of work that needs to be completed. There will be different ways to complete the task, but the overall intention with a task is that it should be completed. In different areas, tasks have different purposes. In scrum development (<a href="https://whatis.techtarget.com/definition/storyboard">https://whatis.techtarget.com/definition/storyboard</a>), a storyboard or task board helps developers understand the work that needs to be completed.</li>
</ul>
<p style="padding-left: 60px">The following diagram illustrates what we mean by a task:</p>
<div><img src="img/0fc656b2-600e-46d8-91ce-87c5ca35cf67.png" style="width:49.08em;height:25.08em;"/></div>
<p style="padding-left: 60px">The preceding diagram is that of a story or task board; it displays the various tasks needed to finish a book, from data collection to the technical review. There are a lot of free or paid tools available on the market to manage these types of tasks.</p>
<ul>
<li><strong>Scenario</strong>: Typically, a scenario is nothing but a situation where a system has failed after interaction with a customer. In other words, a scenario is a way of understanding and writing steps in detail. For example, there are a few situations that can cause a system's login functionality to fail, and these will be documented as a scenario. In software testing, scenarios are also known as test scenarios. A scenario usually leads to one or more tests.</li>
<li><strong>Use case</strong>: A use case is a set of possible sequences of interactions between a system and a user. It can also be a collection of possible scenarios that should be assessed when a system is implemented. These use cases are more detailed and documented, and are divided into various steps, as shown in the following flowchart:</li>
</ul>
<div><img src="img/b2948f3e-a32d-4cd8-9be3-b9fdefae3de7.png" style="width:31.25em;height:19.17em;"/></div>
<p style="padding-left: 60px">In the preceding diagram, it is clear that <strong>TEST CASE</strong> is the sub-set of <strong>TEST SCENARIOS</strong>, and that <strong>USE CASE</strong> is the superset of <strong>TEST SCENARIOS</strong>. Whenever you create a test case, it comes down from a test scenario.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checklist</h1>
                
            
            
                
<p>In general, a checklist is nothing but a list of items, where an action is required in order to achieve a goal. A checklist could be a to-do list, a list of your day-to-day activities, or a list of a developer's tasks.</p>
<p>In the world of testing, a list could contain test cases to verify, a list of tests that need to be executed, and so on. A checklist varies from person to person, developer to developer, or even from organization to organization, but the purpose of a checklist is always to limit the very human behavior of forgetting something.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bugs and defects</h1>
                
            
            
                
<p>The terms bug and defect are the some of the most frequently used terms in the industry. In some organizations, these terms are used interchangeably. In general, however, a bug is related to something that is done correctly but executes an unexpected output, for example, 2 + 3 = 6. On the other hand, a defect is something that has been missed during planning.</p>
<p>Some things to note about bugs and defects:</p>
<ul>
<li>A bug is almost always due to the impure implementation of a requirement, for example, code that incorrectly fulfills a basic requirement</li>
<li>Bugs are normally identified during development or in the testing phase</li>
<li>A defect is related to a design or requirements gap that has slipped past a client or customer during production</li>
<li>A defect often indicates human error</li>
<li>Bugs can be fixed when caught during testing</li>
<li>Defects can lead to a faulty system, which can lead to design issues</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing approach</h1>
                
            
            
                
<p>In general, a testing approach is an execution path illustrating how testing will be carried out. These approaches vary system to system; if one system requires a consultative approach, it does not mean that another system does. Different systems need different testing approaches.</p>
<div><p>A testing approach is a test strategy that is nothing but an implementation of a system or project.</p>
</div>
<p>Testing strategies should be clear to everyone so that the created tests can help non-technical members of the team (such as stakeholders) understand how the system is working. Such tests can be automated, such as testing the business flow, or they can be manual tests that can be performed by a user working on the User Acceptance Testing system.</p>
<p>Testing strategies or approaches have the following techniques:</p>
<ul>
<li><strong>Proactive</strong>: This is a kind of early approach and tries to fix defects before the build is created from initial test designs</li>
<li><strong>Reactive</strong>: In this approach, testing is started once coding is complete</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Test pyramid</h1>
                
            
            
                
<p>The testing pyramid is a strategy or a way of defining what you should test in RESTful services. In other words, we can say a test pyramid helps us to define the testing scope of RESTful services.</p>
<p>The concept of the testing pyramid was developed by Mike Cohn (<a href="http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid">http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid</a>) in 2009.</p>
<p>There are various flavors of the testing pyramid; different authors have described this by indicating how they placed or prioritized their testing scope.</p>
<p>The following diagram depicts the same concept as defined by Mike Cohn:</p>
<div><img src="img/d1feb9ca-0354-4166-aa4d-0919ac8ed78c.png" style="width:30.08em;height:27.17em;"/></div>
<p>Let's talk about these layers in detail.</p>
<ul>
<li><strong>Unit tests</strong>: These are tests that test small functionalities in units of an application of RESTful services developed in ASP.NET Core</li>
<li><strong>RESTful service tests (Acceptance tests)</strong>: These are tests that test an independent service or a service that communicates with another, often external, service</li>
<li><strong>GUI tests (REST Client Tests)</strong>: These tests belong to the client or consumer who will consume RESTful services; they help in testing an entire system with an aspect of the user interface and are end-to-end tests</li>
</ul>
<div><p>We will be discussing testing in respect to an application of a RESTful service developed in ASP.NET Core.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of tests</h1>
                
            
            
                
<p>In the previous section, we discussed test approaches or testing strategies. These strategies decide how we will proceed with the testing of a system. In this section, we will discuss the various types of tests used in our application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the ASP.NET Core controller (unit testing)</h1>
                
            
            
                
<p>Unit tests are tests that typically test a single function call to ensure that the smallest piece of the program is tested. So, these tests are meant to verify specific functionality without considering other components. Here, testing strategies come in handy and ensure that the best quality assurance of a system will be performed. It adds more power when it comes with the <strong>test-driven development</strong> (<strong>TDD</strong>) approach.</p>
<div><p>You can learn and practice TDD with the help of Katas at <a href="https://github.com/garora/TDD-Katas">https://github.com/garora/TDD-Katas</a>.</p>
</div>
<p>We will discuss this with the help of a code example. Before we proceed further, please take a look at the following prerequisites:</p>
<ul>
<li>Visual Studio 2017 Update 3 or later</li>
<li>.NET Core 2.0 or later</li>
<li>C# 7.0 or later</li>
<li>ASP.NET Core 2.0 or later</li>
<li>Entity Framework Core 2.0 or later</li>
<li>xUnit and MS tests</li>
<li>The moq framework</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready for the tests</h1>
                
            
            
                
<p>In this section, we will create an ASP.NET Core API and then unit test it.</p>
<p>Complete the following steps to create your application:</p>
<ol>
<li>Open Visual Studio.</li>
<li>Go to File | New | Project or press <em>Ctrl</em> + <em>Shift</em> + <em>F5</em>:</li>
</ol>
<div><img src="img/c8aa8911-2719-4598-8e60-d91b0d2ec725.png" style="width:43.75em;height:26.58em;"/></div>
<ol start="3">
<li>Select ASP.NET Core Web Application.</li>
<li>From the template window, select ASP.NET Core API—make sure you select .NET Core 2.0.</li>
<li>Name the project, choose the path for the solution, and click OK.</li>
<li>Add the <kbd>Core</kbd> folder—in Solution Explore, right-click and select Add New Folder, and name it <kbd>Model</kbd>.</li>
<li>Add the <kbd>Interfaces</kbd> and <kbd>Model</kbd> folders under the <kbd>Core</kbd> folder.</li>
<li>Add a new class under the <kbd>Model</kbd> folder—right-click on the <kbd>Model</kbd> folder in Solution Explorer and select Add New Item. Then, select <strong>Class</strong> or click <em>Shift</em> + <em>Alt</em> + <em>C.</em></li>
</ol>
<div><p style="padding-left: 60px">Please note that the shortcut key varies as per your settings for Visual Studio.</p>
</div>
<ol start="9">
<li>Name it<kbd>Product.cs</kbd> and add the following code to this class:</li>
</ol>
<pre style="padding-left: 60px">namespace Chap06_01.Core.Model<br/>{<br/>  public class Product<br/>  {<br/>    public Guid Id { get; set; }<br/>    public string Name { get; set; }<br/>    public string Description { get; set; }<br/>    public string Image { get; set; }<br/>    public decimal Price { get; set; }<br/>    public Guid CategoryId { get; set; }<br/>    public virtual Category Category { get; set; }<br/>  }<br/>}</pre>
<ol start="10">
<li>Repeat <em>steps 7</em> and<em> 8</em> to add <kbd>Category.cs</kbd> and <kbd>ProductViewModel.cs</kbd>.</li>
<li>Repeat <em>step 6</em> and add the <kbd>Infrastructure</kbd> folder.</li>
<li>Add a new class under the <kbd>Infrastructure</kbd> folder—right-click on the <kbd>Infrastructure</kbd> folder in Solution Explorer, select Add New Item, and in that, select Class or click <em>Shift</em> + <em>Alt</em> + <em>C.</em></li>
<li>Name it as <kbd>ProductContext.cs</kbd>.</li>
</ol>
<div><p style="padding-left: 60px">In this demo project, we are not following the test-driven development approach; we will unit test our application just for demonstration purposes.</p>
</div>
<ol start="14">
<li>Now, open the <kbd>appsettings.json</kbd> file and add the following code snippet:</li>
</ol>
<pre style="padding-left: 60px">"ConnectionStrings": <br/>{<br/>  "ProductConnection": "Data Source=.;Initial<br/>  Catalog=ProductsDB;Integrated<br/>  Security=True;MultipleActiveResultSets=True"<br/>}</pre>
<ol start="15">
<li>Right-click on Project in Solution Explorer and select Manage Nuget Package.</li>
<li>Under the Nuget Package Manager screen, search <kbd>Swashbuckle.AspNetCore</kbd> and install it.</li>
</ol>
<div><strong>Swagger</strong> is open source and adheres to open specifications (<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md</a>). Swagger allows you to describe an API's structure. Swagger provides documentation to users (devs who are going to use APIs). There are a lot of open source and commercial tools available that can integrate with Swagger. <br/>
<strong><br/>
Swagger CodeGen</strong> (<a href="https://swagger.io/swagger-codegen/">https://swagger.io/swagger-codegen/</a>) helps to generate client libraries for an API.<br/>
<br/>
<strong>Swagger UI</strong> (<a href="https://swagger.io/swagger-ui/">https://swagger.io/swagger-ui/</a>) helps to generate an API's documentation.<br/>
<br/>
<strong>Swashbuckle.AspNetCore</strong> (<a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore">https://github.com/domaindrivendev/Swashbuckle.AspNetCore</a>) is a tool that helps document APIs built on ASP.NET Core.</div>
<ol start="17">
<li>Add <kbd>interface IProductRepository</kbd> under <kbd>Core/Interfaces</kbd>.</li>
<li>Add the following code to the <kbd>IProductRepository</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">namespace Chap06_01.Core.Interfaces<br/>{<br/>  public interface IProductRepository<br/>  {<br/>    void Add(Product product);<br/>    IEnumerable&lt;Product&gt; GetAll();<br/>    Product GetBy(Guid id);<br/>    void Remove(Guid id);<br/>    void Update(Product product);<br/>  }<br/>}</pre>
<p>Please note that for the complete source code, refer to the GitHub repository at <a href="https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core">https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core</a>.</p>
<ol start="19">
<li>Add the <kbd>ProductRepository</kbd> class under the <kbd>Infrastructure</kbd> folder.</li>
<li>Add the following code to <kbd>ProductRepository</kbd>:</li>
</ol>
<pre style="padding-left: 60px">namespace Chap06_01.Infrastructure<br/>{<br/>  public class ProductRepository : IProductRepository<br/>  {<br/>    private readonly ProductContext _context;<br/>    public ProductRepository(ProductContext context)<br/>    =&gt; _context = context;<br/>    public IEnumerable&lt;Product&gt; GetAll() =&gt;<br/>    _context.Products.Include(c =&gt; <br/>    c.Category).ToList();<br/>    public Product GetBy(Guid id) =&gt; _context.Products.<br/>    Include(c =&gt; c.Category).FirstOrDefault(x =&gt; x.Id == id);<br/>    public void Add(Product product)<br/>    {<br/>      _context.Products.Add(product);<br/>      _context.SaveChanges();<br/>    }<br/>    public void Update(Product product)<br/>    {<br/>      _context.Update(product);<br/>      _context.SaveChanges();<br/>    }<br/>    public void Remove(Guid id)<br/>    {<br/>      var product = GetBy(id);<br/>      _context.Remove(product);<br/>      _context.SaveChanges();<br/>    }<br/>  }<br/>}</pre>
<ol start="21">
<li>Open the <kbd>Startup.cs</kbd> file and add the following code:</li>
</ol>
<pre style="padding-left: 60px">services.AddScoped&lt;IProductRepository, ProductRepository&gt;();<br/>services.AddDbContext&lt;ProductContext&gt;<br/>(<br/>  o =&gt; o.UseSqlServer(Configuration.GetConnectionString<br/>  ("ProductConnection"))<br/>);<br/>services.AddSwaggerGen<br/>(<br/>  swagger =&gt;<br/>  {<br/>    swagger.SwaggerDoc("v1", new Info { Title = "Product <br/>    APIs", Version = "v1" });<br/>  }<br/>);</pre>
<p>Your project hierarchy should now look like the following screenshot of Solution Explorer:</p>
<div><img src="img/e5070b6c-5e6f-4ccb-b42e-a388e9bdb319.png" style="width:30.17em;height:36.00em;"/></div>
<p>Now, you are ready to play with the application! Run the application from Menu or press <em>F5</em>. In a web browser, add the suffix <kbd>/swagger</kbd> to the URL in the address bar, as shown in the following screenshot:</p>
<div><img src="img/96471cff-b54d-45c4-a2f2-90ea4dadb59b.png"/></div>
<p>This URL should show the swagger API documentation, as shown in the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-927 image-border" src="img/74fc5f0e-76a7-4926-9bf0-83d9bf381747.png" style="width:44.42em;height:30.00em;"/></div>
<p>If you click on GET /api/Product/productlist, it should return a list of products, as shown in the following screenshot:</p>
<div><img src="img/0408d5e3-949b-49f2-9e3b-2c09732aaf6a.png" style="width:32.42em;height:27.17em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing unit tests</h1>
                
            
            
                
<p>In this section, we will add a test project using ASP.NET Core 2.0 and write unit tests using xUnit. Before we start writing tests, we should set up a test project in our existing application.</p>
<p>The following are a few simple steps needed for our test project setup:</p>
<ol>
<li>From Solution Explorer in Visual Studio, right-click on Solution 'Chap06_01' (1 project) and click on Add | New Project... , as shown in the following screenshot:</li>
</ol>
<div><img src="img/f253fcb9-d4a8-4094-a762-4a95b2126c47.png" style="width:41.25em;height:43.75em;"/></div>
<ol start="2">
<li>From the Add New Project template, select .NET Core and xUnit Test Project (.NET Core) and provide a meaningful name, for example, <kbd>Chap06_01_Test</kbd>:</li>
</ol>
<div><img src="img/cb6caf7c-c5a4-4216-96f5-424f1be5f6eb.png"/></div>
<ol start="3">
<li>Add folders named <kbd>Fake</kbd> and <kbd>Services</kbd>. (Refer to the previous section to see how to add a new folder from the solution explorer.) Your project structure should now look like the following screenshot:</li>
</ol>
<div><img src="img/0f2450f7-127e-429e-b405-f9db08517906.png" style="width:23.50em;height:15.33em;"/></div>
<ol start="4">
<li>The <kbd>ProductData.cs</kbd> class should look like the following:</li>
</ol>
<pre style="padding-left: 60px">namespace Chap06_01_Test.Fake<br/>{<br/>  public class ProductData<br/>  {<br/>    public IEnumerable&lt;ProductViewModel&gt; GetProducts()<br/>    {<br/>      var productVm = new List&lt;ProductViewModel&gt;<br/>      {<br/>        new ProductViewModel<br/>        {<br/>          CategoryId = Guid.NewGuid(),<br/>          CategoryDescription = "Category Description",<br/>          CategoryName = "Category Name",<br/>          ProductDescription = "Product Description",<br/>          ProductId = Guid.NewGuid(),<br/>          ProductImage = "Image full path",<br/>          ProductName = "Product Name",<br/>          ProductPrice = 112M<br/>        },<br/>        new ProductViewModel<br/>        {<br/>          CategoryId = Guid.NewGuid(),<br/>          CategoryDescription = "Category Description-01",<br/>          CategoryName = "Category Name-01",<br/>          ProductDescription = "Product Description-01",<br/>          ProductId = Guid.NewGuid(),<br/>          ProductImage = "Image full path",<br/>          ProductName = "Product Name-01",<br/>          ProductPrice = 12M<br/>        }<br/>      };<br/>      return productVm;<br/>    }<br/>    public IEnumerable&lt;Product&gt; GetProductList()<br/>    {<br/>      return new List&lt;Product&gt;<br/>      {<br/>        new Product<br/>        {<br/>          Category = new Category(),<br/>          CategoryId = Guid.NewGuid(),<br/>          Description = "Product Description-01",<br/>          Id = Guid.NewGuid(),<br/>          Image = "image full path",<br/>          Name = "Product Name-01",<br/>          Price = 12M<br/>        },<br/>        new Product<br/>        {<br/>          Category = new Category(),<br/>          CategoryId = Guid.NewGuid(),<br/>          Description = "Product Description-02",<br/>          Id = Guid.NewGuid(),<br/>          Image = "image full path",<br/>          Name = "Product Name-02",<br/>          Price = 125M<br/>        }<br/>      };<br/>    }<br/>  }<br/>}</pre>
<p style="padding-left: 60px">In the preceding code snippet, we created fake data for <kbd>Products</kbd> and <kbd>ProductsViewModel</kbd>.</p>
<p>The full code is available to download from <a href="https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core">https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core</a>.</p>
<ol start="5">
<li><kbd>ProductTest.cs</kbd>, our unit testing class, looks like the following:</li>
</ol>
<p>Important terms for xUnit:<br/>
<ul>
<li><strong>Fact</strong> is an attribute and is used for a normal test method that is without parameters</li>
<li><strong>Theory</strong> is an attribute and is used for a parameterized test method</li>
</ul>
</p>
<pre style="padding-left: 60px">namespace Chap06_01_Test.Services<br/>{<br/>  public class ProductTests<br/>  {<br/>    [Fact]<br/>    public void Get_Returns_ActionResults()<br/>    {<br/>      // Arrange<br/>      var mockRepo = new Mock&lt;IProductRepository&gt;();<br/>      mockRepo.Setup(repo =&gt; repo.GetAll()).Returns(new<br/>      ProductData().GetProductList());<br/>      var controller = new ProductController(mockRepo.Object);<br/>      // Act<br/>      var result = controller.GetList();<br/>      // Assert<br/>      var viewResult = Assert.IsType&lt;OkObjectResult&gt;(result);<br/>      var model = <br/>      Assert.IsAssignableFrom&lt;IEnumerable&lt;ProductViewModel&gt;&gt;<br/>      (viewResult.Value);<br/>      Assert.NotNull(model);<br/>      Assert.Equal(2, model.Count());<br/>    }<br/>  }<br/>}</pre>
<p style="padding-left: 60px">In the preceding code snippet, we are simply testing our <kbd>ProductController</kbd>, which is a <kbd>Get</kbd> resource, <kbd>GetList</kbd>. In this code, we are mocking the list; we are not actually hitting the database but instead testing our <kbd>Controller</kbd> methods using fake data.</p>
<ol start="6">
<li>Run tests from Test Explorer; if your test passes, you should see something like the following screenshot:</li>
<li style="list-style-type: none">
<div><img src="img/134b6fd3-8ba7-4ed5-8c7d-aec0215473b8.png" style="width:22.67em;height:27.42em;"/></div>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Stubs and mocking</h1>
                
            
            
                
<p>Stubs are canned responses to calls made during a test, whereas mocks are meant to set expectations. They can be further explained as follows:</p>
<ul>
<li><strong>Stubs</strong>: In the <kbd>stubs</kbd> object, we always get a valid stubbed response. The response doesn't care what input you provided. In any circumstance, the output will be the same.</li>
<li><strong>Mocks</strong>: In the <kbd>mock</kbd> object, we can test or validate methods that can be called on mocked objects. This is a fake object that validates whether a unit test failed or passed. In other words, we can say that mock objects are just replicas of our actual object.</li>
</ul>
<p>In the previous section, <em>Writing unit tests</em>, we used the moq framework to implement the mocked objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Security testing</h1>
                
            
            
                
<p>Security is a very wide-reaching term and can't be explained in a few lines. In general, security testing is a way of testing whether an application is secure or if there is any chance of leaking someone's data.</p>
<div><p>Security and secure systems will be discussed in <a href="18479f1e-2030-404b-b016-1764984f46ed.xhtml">Chapter 8</a>, <em>Securing RESTful Web Services</em>.</p>
</div>
<p>Security testing is very important, especially when we working in web-based applications. Web applications are publicly available and vulnerable to attack, so authentication and authorization are the most important factors here.</p>
<p>FxCop (<a href="https://en.wikipedia.org/wiki/FxCop">https://en.wikipedia.org/wiki/FxCop</a>), which is shipped with Visual Studio and VeraCode (<a href="https://www.veracode.com/">https://www.veracode.com/</a>), is one of the most popular tools used in security testing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integration testing</h1>
                
            
            
                
<p>In unit testing, we test a single unit of code, whereas, in integration testing in a Web API, we test all services that work together (internal and external, including third-party components). Service calls should be made to ensured integration with external services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Run tests</h1>
                
            
            
                
<p>Let's take the same application we created in the previous section for unit tests:</p>
<ol>
<li>Add a new project for integration tests, and make sure the project structure looks like the following screenshot:</li>
</ol>
<div><img src="img/4c85e8fd-558e-4a73-bc28-f2800cfcb41b.png" style="width:25.67em;height:17.00em;"/></div>
<ol start="2">
<li>Write the following code in the constructor of <kbd>ProductTest.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">var server = new TestServer<br/>(<br/>  new WebHostBuilder()<br/>  .UseStartup&lt;TestStartup&gt;()<br/>);<br/>_client = server.CreateClient();</pre>
<p style="padding-left: 60px">In the preceding code block, we initialized <kbd>TestServer</kbd> , where we used <kbd>TestStartup</kbd> as our startup entry file. Finally, we created a <kbd>private readonly HttpClient _client;</kbd> of our <kbd>WebHostBuilder()</kbd>.</p>
<ol start="3">
<li>Then, write a simple method that calls the productlist resource:</li>
</ol>
<pre style="padding-left: 60px">[Fact]<br/>public async Task ReturnProductList()<br/>{<br/>  // Act<br/>  var response = await _client.GetAsync("api/Product<br/>  /productlist");<br/>  response.EnsureSuccessStatusCode();<br/>  var responseString = await response.Content.ReadAsStringAsync();<br/>  // Assert<br/>  Assert.NotEmpty(responseString);<br/>}</pre>
<p style="padding-left: 60px">In the preceding code, we are consuming our resource <kbd>GET api/product/productlist</kbd> and testing it to see if it returns the expected output.</p>
<div><p>To run the code smoothly, you need to add the <kbd>Microsoft.AspNetCore.Hosting;</kbd> and <kbd>Microsoft.AspNetCore.TestHost;</kbd> namespaces in the code.</p>
</div>
<p style="padding-left: 60px">This test also makes sure that the internal component, or any external service call made by this method, is working as expected.</p>
<ol start="4">
<li>Complete the code for <kbd>ProductTes.cs</kbd>  as follows:</li>
</ol>
<pre style="padding-left: 60px">namespace Chap06_02_Test.Services<br/>{<br/>  public class ProductTest<br/>  {<br/>    public ProductTest()<br/>    {<br/>      // Arrange<br/>      var server = new TestServer(new WebHostBuilder()<br/>      .UseStartup&lt;TestStartup&gt;());<br/>      _client = server.CreateClient();<br/>    }<br/>    private readonly HttpClient _client;<br/>    [Fact]<br/>    public async Task ReturnProductList()<br/>    {<br/>      // Act<br/>      var response = await<br/>      _client.GetAsync("api/Product/productlist");<br/>      response.EnsureSuccessStatusCode();<br/>      var responseString = await<br/>      response.Content.ReadAsStringAsync();<br/>      // Assert<br/>      Assert.NotEmpty(responseString);<br/>    }<br/>  }<br/>}</pre>
<ol start="5">
<li>Write the code for the <kbd>TestStartup</kbd> file as follows:</li>
</ol>
<pre style="padding-left: 60px">namespace Chap06_02_Test<br/>{<br/>  public class TestStartup : Startup<br/>  {<br/>    public TestStartup(IConfiguration configuration) : <br/>    base(configuration)<br/>    {  }<br/>    public static IConfiguration InitConfiguration()<br/>    {<br/>      var config = new ConfigurationBuilder()<br/>      .AddJsonFile("appsettings.json")<br/>      .Build();<br/>      return config;<br/>    }<br/>    public override void ConfigureServices(<br/>    IServiceCollection services)<br/>    {<br/>      //mock context<br/>      services.AddDbContext&lt;ProductContext&gt;<br/>      (<br/>        o =&gt; o.UseSqlServer<br/>        (<br/>          InitConfiguration().GetConnectionString<br/>          (<br/>            "ProductConnection"<br/>          )<br/>        )<br/>      );<br/>      services.AddMvc();<br/>      services.AddScoped&lt;IProductRepository, <br/>      ProductRepository&gt;();<br/>    }<br/>    public override void Configure<br/>    (<br/>      IApplicationBuilder app, IHostingEnvironment env<br/>    )<br/>    {<br/>      app.UseStaticFiles();<br/>      app.UseMvc();<br/>    }<br/>  }<br/>}</pre>
<p style="padding-left: 60px">In the preceding code, our <kbd>TestStartup</kbd> class inherited the <kbd>Startup</kbd> class, meaning we are now using its members and methods.</p>
<div><p style="padding-left: 60px">You need to make the methods <kbd>ConfigureServices</kbd> and <kbd>Configure</kbd> virtual to override these in the <kbd>TestStartup</kbd> class.</p>
</div>
<p style="padding-left: 60px">Take a look into our <kbd>InitConfiguration()</kbd> method; this method adds your test configuration file so that you can use test config values in any other environment.</p>
<p style="padding-left: 60px">In our <kbd>TestStartup</kbd> class, we overrode the <kbd>ConfigureServices</kbd> and <kbd>Configure</kbd> methods so that we could configure test services or any utilities class that was created specifically for testing purposes.</p>
<p>Now we are all set to run our tests, open Test Explorer and run a selected test. You can also run tests from the <kbd>ProductTest.cs</kbd> file (just right-click and select Run tests).</p>
<p>In case you need to debug the code, you can debug tests as well. If you do, you should get the following results:</p>
<div><img src="img/c6e3e6d4-a9c7-4a62-9d6b-2558c762313a.png" style="width:20.00em;height:23.75em;"/></div>
<p>You can write as many tests as you want. Tests also depend on what code you want to test.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fake objects</h1>
                
            
            
                
<p>As the name suggests, fake objects are objects that are not real. Fake objects are for testing purposes and contain actual code, but not with all of the genuine functionality. For instance, we can create a fake object to fetch data records using Entity Framework Core; in this case, we prefer to use InMemory (<a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory">https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory</a>) instead of a direct DB connection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Run tests</h1>
                
            
            
                
<p>Let's take the application we developed in the previous section on unit testing. Follow the steps mentioned in the preceding section and add a new xUnit test project.</p>
<p>We are looking for fake objects or data for testing purposes, so we will not be hitting our actual database server. Instead, here we will use the InMemory database.</p>
<div><p>You need to add the <kbd>Microsoft.EntityFrameworkCore.InMemory</kbd> NuGet package to start the InMemory database.</p>
</div>
<p>We are not going to change anything here, but we will create fake data and records to test. To proceed, add the following code to the <kbd>TestStartup.cs</kbd> file in the <kbd>ConfigureServices</kbd> method:</p>
<pre>//for tests use InMemory db<br/>services.AddDbContext&lt;ProductContext&gt;<br/>(<br/>  o =&gt; o.UseInMemoryDatabase<br/>  (<br/>    InitConfiguration().GetConnectionString<br/>    (<br/>      "ProductConnection"<br/>    )<br/>  )<br/>);</pre>
<div><p>Here, we are using the following:</p>
<ul>
<li>The InMemory database, used only for testing purposes, by adding  <kbd>.UseInMemoryDatabase</kbd> to the <kbd>TestStartup</kbd> class</li>
<li>For our actual code, our database server will remain unchanged in the <kbd>Startup.cs</kbd> class, that is, <kbd>.UseSqlServer</kbd></li>
</ul>
</div>
<p>Now we need fake data and records, so add the following method in the <kbd>TestStartup</kbd> class:</p>
<pre>private static void FakeData(DbContext context)<br/>{<br/>  var category = new Category<br/>  {<br/>    Id = ToGuid("A5DBF00D-2E29-4993-A0CA-7E861272C6DC"),<br/>    Description = "Technical Videos",<br/>    Name = "Videos"<br/>  };<br/>  context.Add(category);<br/>  var product = new Product<br/>  {<br/>    Id = ToGuid("02341321-C20B-48B1-A2BE-47E67F548F0F"),<br/>    CategoryId = category.Id,<br/>    Description = "Microservices for .NET Core",<br/>    Image = "microservices.jpeg",<br/>    Name = "Microservices for .NET",<br/>    Price = 651,<br/>    InStock = 5<br/>  };<br/>  context.Add(product);<br/>  context.SaveChanges();<br/>}</pre>
<p>Then, call the <kbd>FakeData(context)</kbd> method from the <kbd>Configure(IApplicationBuilder app, IHostingEnvironment env)</kbd> method, as shown in the following code:</p>
<pre>public override void Configure(IApplicationBuilder app, IHostingEnvironment env)<br/>{<br/>    var context = app.ApplicationServices.GetService&lt;ProductContext&gt;();<br/>    FakeData(context);<br/>    app.UseStaticFiles();<br/>    app.UseMvc();<br/>}</pre>
<p>Now we are ready to run tests, so open Test Explorer and hit Run All. If the tests pass, you should see something like the following screenshot:</p>
<div><img src="img/5129795f-ced5-473e-a3d8-30e15138ddb3.png" style="width:26.83em;height:31.58em;"/></div>
<p>To double-check that the tests are not hitting the actual database, let's debug the test code. Open the <kbd>ProductTest.cs</kbd> class and set a breakpoint for the following test:</p>
<pre>[Fact]<br/>public async Task ReturnProductList()<br/>{<br/>  // Act<br/>  var response = await _client.GetAsync("api/Product/productlist");<br/>  response.EnsureSuccessStatusCode();<br/>  var responseString = await response.Content.ReadAsStringAsync();<br/>  // Assert<br/>  Assert.NotEmpty(responseString);<br/>}</pre>
<p>Now right-click on Debug Test, use step-into (the <em>F11</em> key) to go into the controller and the repository, and check to see what the actual list of products is. You can see that our test is returning fake data, which means they are not hitting the actual database. The following is a screenshot of the debugged code:</p>
<div><img src="img/2ed6222f-bd5a-4546-9fd8-3f1cd16100e3.png"/></div>
<p>The preceding screenshot is from a small application that we used to demonstrate testing with fake objects. With this testing approach, our fake objects were always hit instead of any actual code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing service calls using Postman, Advanced REST Client, and more</h1>
                
            
            
                
<p>There are a lot of tools available for testing RESTful web services and APIs. These tools provide the actual output.</p>
<div><p>Web service testing tools are very useful when you have only API resources and want to test the expected output in different scenarios but do not have actual source code.</p>
</div>
<p>We will test our product APIs with the following two tools.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Postman</h1>
                
            
            
                
<p><strong>Postman</strong> (<a href="https://www.getpostman.com/">https://www.getpostman.com/</a>) is one of the most popular tools when testing web service output. It also comes with a Google Chrome extension:</p>
<ol>
<li>Launch Postman. If you don't have it, install it from the preceding link.</li>
<li>Select the Resource type as GET and enter the URL of the API; in our case, it is <kbd>http://localhost:60431/api/Product/productlist</kbd>.</li>
<li>Click on Send (alternatively, you can click on Send and Download, if you need data in the file).</li>
<li>If the test passes, you should see something like the following screenshot:</li>
</ol>
<div><img src="img/194c48ce-b5ca-4707-9973-14ec1c106d6e.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Advanced Rest Client</h1>
                
            
            
                
<p><strong>Advanced rest client</strong> (<strong>ARC</strong>) is another popular tool and also comes as a Chrome extension. You can either install it from the Chrome Extension store or directly from <a href="https://install.advancedrestclient.com/">https://install.advancedrestclient.com/</a>:</p>
<ol>
<li>Install the Chrome extension for ARC, if not yet installed.</li>
<li>Launch ARC.</li>
<li>Pass the GET resource.</li>
<li>If the test passes, you should see something like the following screenshot:</li>
</ol>
<div><img src="img/8c2d00ed-feed-489d-b4e5-956405437e09.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">User acceptance testing</h1>
                
            
            
                
<p>As the name suggests, <strong>user acceptance testing</strong> (<strong>UAT</strong>) is testing that is done by users or accepted by users. In this testing methodology, users who might be an application's end user are involved directly with testing. There might be scenarios that users test in the production environment, or they may have access to the pre-tested results that they can accept or reject.</p>
<p>This kind of testing depends on the actual user who would be using the application in a production environment. This testing usually happens in a UAT or pre-production environment.</p>
<div><p>The typical environments in the industry are known as development, staging, QA, UAT, pre-production, and production. In your organization, you might not have all the environments as per your project requirements; if so, refer to <a href="https://www.guru99.com/user-acceptance-testing.html">https://www.guru99.com/user-acceptance-testing.html</a>.</p>
</div>
<p>UAT testing is also seen as final testing, and its acceptance or rejection tells us whether a current release will be deployed to production or not. The main focus of this testing is business-related. This testing does not deal with test code or the implementation of various patterns; it simply makes sure that all the business rules and requirements have been implemented.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performance or load testing</h1>
                
            
            
                
<p>For a web application's performance, scalability is very important. An application can be very secure, well tested, and created with good code but still be avoided by the user if it's not scalable.</p>
<div><p>We will discuss scaling RESTful web services in detail in <a href="dfa68fd5-a510-4446-be5c-fe23d0ca08cd.xhtml">Chapter 9</a>, <em>Scaling RESTful Services (Performance of Web Services)</em>.</p>
</div>
<p>Performance is very important for a good API, so we need to test and make sure that our application is able to load or stress large requests. Load testing is a non-functional type of testing (<a href="https://www.guru99.com/non-functional-testing.html">https://www.guru99.com/non-functional-testing.html</a>) and the main aim of load testing is not to verify the code or test the code's health.</p>
<div><p>The main purpose of this testing is to ensure that the web API is performing well based on various measures such as scalability, reliability, and so on.</p>
</div>
<p>The following are techniques or types of performance testing:</p>
<ul>
<li><strong>Load testing</strong>: This tests the behavior of the system under various circumstances of specific load. This also covers critical transactions, database load, application servers, and so on.</li>
<li><strong>Stress testing</strong>: This is an approach where a system goes under regress testing and finds the upper-limit of a system's capacity. It is also determined by how a system behaves in a critical situation where the current load goes above the expected maximum load.</li>
<li><strong>Soak testing</strong>: This is also known as endurance testing. In this test, the main purpose is to monitor memory utilization, memory leaks, or various factors which affect system performance.</li>
<li><strong>Spike testing</strong>: This is an approach where we make sure that the system is able to sustain the workload. One of the best tasks for determining performance is suddenly increasing the user loads.</li>
</ul>
<p>In ASP.NET Core, we can perform load testing with the help of the following:</p>
<ul>
<li><strong>Visual Studio</strong>: If you have Visual Studio Enterprise Edition, you can easily create a load testing project; visit the following link for more information: <a href="https://docs.microsoft.com/en-us/vsts/load-test">https://docs.microsoft.com/en-us/vsts/load-test</a>.</li>
<li><strong>WebSurge</strong>: This is a load testing use for APIs. You can use it in the cloud or for free for learning purposes. For more information, visit <a href="http://websurge.west-wind.com/">http://websurge.west-wind.com/</a>.</li>
<li><strong>BenchmarkDotNet</strong>: This tool tells us how much of our code is performant. It tests different blocks of codes that give the same result to see which performs best. For more information, visit <a href="https://github.com/dotnet/BenchmarkDotNet">https://github.com/dotnet/BenchmarkDotNet</a>.</li>
<li><strong>Netling</strong>: This is a load testing tool for web applications. With Netling, you can make changes and retest your code to meet your performance scale. For more information, visit <a href="https://github.com/hallatore/Netling">https://github.com/hallatore/Netling</a>.</li>
</ul>
<p>Explanations, along with working examples, of these tools and Visual Studio Load Testing is beyond the scope of this book.</p>
<p>In this section, we will simply test our product APIs to check how much time it takes them to list the products we request.</p>
<div><p>You can also test the request time of APIs using a simple web client. In <a href="9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml">Chapter 10</a>, <em>Building a Web Client (Consuming Web Services)</em>, we will discuss how to build a web client in detail.</p>
</div>
<p>Take a look at the code of our <kbd>ProductTest</kbd> class, as follows:</p>
<pre>public class ProductTest<br/>  {<br/>    public ProductTest(ITestOutputHelper output)<br/>    {<br/>      _output = output;<br/>    }<br/>    private const double ExpectedRequestTime = 1000;<br/>    private const int ApiLoad = 100;<br/>    private const string RequestUri = <br/>    "http://localhost:60431/api/product/productlist";<br/>    private readonly ITestOutputHelper _output;<br/>    private static double RequestCallTime()<br/>    {<br/>      DateTime start;<br/>      DateTime end;<br/>      using (var client = new HttpClient())<br/>      {<br/>        start = DateTime.Now;<br/>        var response = client.GetAsync(RequestUri).Result;<br/>        end = DateTime.Now<br/>      }<br/>      var actual = (end - start).TotalMilliseconds;<br/>      return actual;<br/>    }<br/>    [Fact]<br/>    public void SingleCallRequestTime()<br/>    {<br/>      var actual = RequestCallTime();<br/>      _output.WriteLine($"Actual time: {ExpectedRequestTime}<br/>      millisecond. <br/>      Expected time: {actual} millisecond.");<br/>      Assert.True(actual &lt;= ExpectedRequestTime);<br/>    }<br/>    //code truncated<br/>}</pre>
<p>The preceding code is self-explanatory. We are simply calculating the time taken by single and multiple requests, and checking whether this reaches our benchmark.</p>
<p>The complete code is available to download from <a href="https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core">https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Run tests</h1>
                
            
            
                
<p>To run tests, you need to make sure that your APIs are running and accessible using the URL. To do so, use the CLI to complete the following steps:</p>
<ol>
<li>Open the Visual Studio command prompt</li>
<li>Locate the folder of your API project</li>
<li>Fire the command <kbd>dotnet run</kbd></li>
</ol>
<p>You should now a screen similar to the one in the following screenshot:</p>
<div><img src="img/5007496a-c067-4591-9173-ea6772db3043.png"/></div>
<p class="mce-root">Follow these steps to run tests using Visual Studio Test Explorer:</p>
<ol>
<li>Open the <kbd>ProductTest.cs</kbd> file</li>
<li>Open Test Explorer</li>
<li>Click Run</li>
</ol>
<p style="padding-left: 60px">This will run all the tests; you should see an output similar to the following screenshot:</p>
<div><img src="img/d18d7381-017c-40f6-aef6-76afa017f194.png" style="width:25.25em;height:32.75em;"/></div>
<p>We can also check the exact time taken for a request to be completed by individual APIs. To do this, click on <strong>Output</strong> in the test explorer of a particular <kbd>TestCase</kbd> result, and you should see the following screen:</p>
<div><img src="img/8ea433e9-9ccf-4342-b233-a5c7f6e69fee.png" style="width:38.75em;height:9.25em;"/></div>
<p>You can also run these tests using the CLI, as follows:</p>
<ol>
<li>Open the Visual Studio command prompt</li>
<li>Locate the folder of your API project</li>
<li>Fire the command <kbd>dotnet test</kbd></li>
</ol>
<p>The preceding command will run all the tests; if they pass, you should see the following screen:</p>
<div><img src="img/48deb5d8-fe65-4a84-8ff8-769f704632c8.png" style="width:46.25em;height:18.75em;"/></div>
<p>Visit <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x">https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x</a> to check all the available CLI commands.</p>
<p>In this section, we tried a simple load test that was based on request times. We tried a single call and multiple calls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Testing helps to ensure our code is error-free. Testing is also a practice for all developers who want to make their code clean and maintainable. In this chapter, we covered testing paradigms in the day-to-day activities of a development team, with the knowledge of stubs and mocks, as well as the importance of understanding integration, security, and performance testing.</p>
<p>In the coming chapters, we will discuss security, including following the OWASP security standard and JWT authentication. We will cover more complex scenarios with the use of custom filters and input validations. Data protection is always a high priority for any web application, so we will also take a look at sensitive data persistence and storage.</p>


            

            
        
    </body></html>