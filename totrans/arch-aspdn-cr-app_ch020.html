<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>19 Introduction to Microservices Architecture</title>
<link href="../styles/stylesheet1.css" rel="stylesheet" type="text/css"/>
<link href="../styles/stylesheet2.css" rel="stylesheet" type="text/css"/>
<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>
<section class="level1 pkt" data-number="20" id="introduction-to-microservices-architecture">
<h1 data-number="20"><span class="koboSpan" id="kobo.1.1" xmlns="http://www.w3.org/1999/xhtml">19 Introduction to Microservices Architecture</span></h1>
<section class="level2" data-number="20.1" id="before-you-begin-join-our-book-community-on-discord-18">
<h2 data-number="20.1"><span class="koboSpan" id="kobo.2.1" xmlns="http://www.w3.org/1999/xhtml">Before you begin: Join our book community on Discord</span></h2>
<p><span class="koboSpan" id="kobo.3.1" xmlns="http://www.w3.org/1999/xhtml">Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</span></p>
<p><a href="https://packt.link/EarlyAccess"><span class="koboSpan" id="kobo.4.1" xmlns="http://www.w3.org/1999/xhtml">https://packt.link/EarlyAccess</span></a></p>
<p><span class="koboSpan" id="kobo.5.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Qr code Description automatically generated" src="../media/file127.png" style="width:10em"/></span></p>
<p><span class="koboSpan" id="kobo.6.1" xmlns="http://www.w3.org/1999/xhtml">The chapter covers some essential microservices architecture concepts. </span><span class="koboSpan" id="kobo.6.2" xmlns="http://www.w3.org/1999/xhtml">It is designed to get you started with those principles and an overview of the concepts surrounding microservices, which should help you make informed decisions about whether to go for a microservices architecture or not.Since microservices architecture is larger in scale than the previous application-scale patterns we visited and often involves complex components or setup, there is very limited C# code in the chapter. </span><span class="koboSpan" id="kobo.6.3" xmlns="http://www.w3.org/1999/xhtml">Instead, I explain the concepts and list open-source or commercial offerings that you can leverage to apply these patterns to your applications. </span><span class="koboSpan" id="kobo.6.4" xmlns="http://www.w3.org/1999/xhtml">Moreover, you should not aim to implement many of the pieces discussed in the chapter because it can be a lot of work to get them right, and they don’t add business value, so you are better off just using an existing implementation instead. </span><span class="koboSpan" id="kobo.6.5" xmlns="http://www.w3.org/1999/xhtml">There is more context about this throughout the chapter.Monolithic architecture patterns, such as Vertical Slice and Clean Architecture, are still good to know, as you can apply those to individual microservices. </span><span class="koboSpan" id="kobo.6.6" xmlns="http://www.w3.org/1999/xhtml">Don’t worry—all of the knowledge you have acquired since the beginning of this book is not forfeit and is still worthwhile.In this chapter, we cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1" xmlns="http://www.w3.org/1999/xhtml">What are microservices?</span></li>
<li><span class="koboSpan" id="kobo.8.1" xmlns="http://www.w3.org/1999/xhtml">An introduction to event-driven architecture</span></li>
<li><span class="koboSpan" id="kobo.9.1" xmlns="http://www.w3.org/1999/xhtml">Getting started with message queues</span></li>
<li><span class="koboSpan" id="kobo.10.1" xmlns="http://www.w3.org/1999/xhtml">Implementing the Publish-Subscribe pattern</span></li>
<li><span class="koboSpan" id="kobo.11.1" xmlns="http://www.w3.org/1999/xhtml">Introducing Gateway patterns</span></li>
<li><span class="koboSpan" id="kobo.12.1" xmlns="http://www.w3.org/1999/xhtml">Project – REPR.BFF—that transforms the REPR project into microservices</span></li>
<li><span class="koboSpan" id="kobo.13.1" xmlns="http://www.w3.org/1999/xhtml">Revisiting the CQRS pattern</span></li>
<li><span class="koboSpan" id="kobo.14.1" xmlns="http://www.w3.org/1999/xhtml">The Microservices Adapter pattern</span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1" xmlns="http://www.w3.org/1999/xhtml">Let’s get started!</span></p>
</section>
<section class="level2" data-number="20.2" id="what-are-microservices">
<h2 data-number="20.2"><span class="koboSpan" id="kobo.16.1" xmlns="http://www.w3.org/1999/xhtml">What are microservices?</span></h2>
<p><span class="koboSpan" id="kobo.17.1" xmlns="http://www.w3.org/1999/xhtml">Microservices represent an application that is divided into multiple smaller applications. </span><span class="koboSpan" id="kobo.17.2" xmlns="http://www.w3.org/1999/xhtml">Each application, or microservice, interacts with the others to create a scalable system. </span><span class="koboSpan" id="kobo.17.3" xmlns="http://www.w3.org/1999/xhtml">Usually, microservices are deployed to the cloud as containerized or serverless applications.Before getting into too many details, here are the principles to keep in mind when building microservices:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1" xmlns="http://www.w3.org/1999/xhtml">Each microservice should be a cohesive unit of business.</span></li>
<li><span class="koboSpan" id="kobo.19.1" xmlns="http://www.w3.org/1999/xhtml">Each microservice should own its data.</span></li>
<li><span class="koboSpan" id="kobo.20.1" xmlns="http://www.w3.org/1999/xhtml">Each microservice should be independent of the others.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1" xmlns="http://www.w3.org/1999/xhtml">Furthermore, everything we have studied so far—the other principles of designing software—applies to microservices but on another scale. </span><span class="koboSpan" id="kobo.21.2" xmlns="http://www.w3.org/1999/xhtml">For example, you don’t want tight coupling between microservices (solved by microservices independence), but the coupling is inevitable (as with any code). </span><span class="koboSpan" id="kobo.21.3" xmlns="http://www.w3.org/1999/xhtml">There are numerous ways to solve this problem, such as the Publish-Subscribe pattern.There are no hard rules about how to design microservices, how to divide them, how big they should be, and what to put where. </span><span class="koboSpan" id="kobo.21.4" xmlns="http://www.w3.org/1999/xhtml">Nevertheless, I’ll lay down a few foundations to help you get started and orient your journey into microservices.</span></p>
<section class="level3" data-number="20.2.1" id="cohesive-unit-of-business">
<h3 data-number="20.2.1"><span class="koboSpan" id="kobo.22.1" xmlns="http://www.w3.org/1999/xhtml">Cohesive unit of business</span></h3>
<p><span class="koboSpan" id="kobo.23.1" xmlns="http://www.w3.org/1999/xhtml">A microservice should have a single business responsibility. </span><span class="koboSpan" id="kobo.23.2" xmlns="http://www.w3.org/1999/xhtml">Always design the system with the domain in mind, which should help you divide the application into multiple pieces. </span><span class="koboSpan" id="kobo.23.3" xmlns="http://www.w3.org/1999/xhtml">If you know </span><strong><span class="koboSpan" id="kobo.24.1" xmlns="http://www.w3.org/1999/xhtml">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.25.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.26.1" xmlns="http://www.w3.org/1999/xhtml">DDD</span></strong><span class="koboSpan" id="kobo.27.1" xmlns="http://www.w3.org/1999/xhtml">), a microservice will most likely represent a </span><strong><span class="koboSpan" id="kobo.28.1" xmlns="http://www.w3.org/1999/xhtml">Bounded Context</span></strong><span class="koboSpan" id="kobo.29.1" xmlns="http://www.w3.org/1999/xhtml">, which in turn is what I call a </span><em><span class="koboSpan" id="kobo.30.1" xmlns="http://www.w3.org/1999/xhtml">cohesive unit of business</span></em><span class="koboSpan" id="kobo.31.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.31.2" xmlns="http://www.w3.org/1999/xhtml">Basically, a cohesive unit of business (or bounded context) is a self-contained part of the domain with limited interactions with other parts.Even if a </span><strong><span class="koboSpan" id="kobo.32.1" xmlns="http://www.w3.org/1999/xhtml">microservice</span></strong><span class="koboSpan" id="kobo.33.1" xmlns="http://www.w3.org/1999/xhtml"> has </span><em><span class="koboSpan" id="kobo.34.1" xmlns="http://www.w3.org/1999/xhtml">micro</span></em><span class="koboSpan" id="kobo.35.1" xmlns="http://www.w3.org/1999/xhtml"> in its name, it is more important to group logical operations under it than to aim at a micro-size. </span><span class="koboSpan" id="kobo.35.2" xmlns="http://www.w3.org/1999/xhtml">Don’t get me wrong here; if your unit is tiny, that’s even better. </span><span class="koboSpan" id="kobo.35.3" xmlns="http://www.w3.org/1999/xhtml">However, suppose you split a unit of business into multiple smaller parts instead of keeping it together (breaking cohesion); you are likely to introduce useless chattiness within your system (coupling between microservices). </span><span class="koboSpan" id="kobo.35.4" xmlns="http://www.w3.org/1999/xhtml">This could lead to performance degradation and to a system that is harder to debug, test, maintain, monitor, and deploy. </span><span class="koboSpan" id="kobo.35.5" xmlns="http://www.w3.org/1999/xhtml">Moreover, it is easier to split a big microservice into smaller pieces than to assemble multiple microservices back together. </span><span class="koboSpan" id="kobo.35.6" xmlns="http://www.w3.org/1999/xhtml">Try to apply the SRP to your microservices: a microservice should have only one reason to change unless you have a good reason to do otherwise.</span></p>
</section>
<section class="level3" data-number="20.2.2" id="ownership-of-data">
<h3 data-number="20.2.2"><span class="koboSpan" id="kobo.36.1" xmlns="http://www.w3.org/1999/xhtml">Ownership of data</span></h3>
<p><span class="koboSpan" id="kobo.37.1" xmlns="http://www.w3.org/1999/xhtml">Each microservice should be the source of truth of its cohesive unit of business. </span><span class="koboSpan" id="kobo.37.2" xmlns="http://www.w3.org/1999/xhtml">A microservice should share its data through an API (a web API/HTTP, for example) or another mechanism (integration events, for example). </span><span class="koboSpan" id="kobo.37.3" xmlns="http://www.w3.org/1999/xhtml">It should own that data and not share it with other microservices directly at the database level.For instance, two different microservices should never access the same relational database table. </span><span class="koboSpan" id="kobo.37.4" xmlns="http://www.w3.org/1999/xhtml">If a second microservice needs some of the same data, it can create its own cache, duplicate the data, or query the owner of that data but not access the database directly; </span><strong><span class="koboSpan" id="kobo.38.1" xmlns="http://www.w3.org/1999/xhtml">never</span></strong><span class="koboSpan" id="kobo.39.1" xmlns="http://www.w3.org/1999/xhtml">.This data-ownership concept is probably the most critical part of the microservices architecture and leads to microservices independence. </span><span class="koboSpan" id="kobo.39.2" xmlns="http://www.w3.org/1999/xhtml">Failing at this will most likely lead to a tremendous number of problems. </span><span class="koboSpan" id="kobo.39.3" xmlns="http://www.w3.org/1999/xhtml">For example, if multiple microservices can read or write data in the same database table, each time something changes in that table, all of them must be updated to reflect the changes. </span><span class="koboSpan" id="kobo.39.4" xmlns="http://www.w3.org/1999/xhtml">If different teams manage the microservices, that means cross-team coordination. </span><span class="koboSpan" id="kobo.39.5" xmlns="http://www.w3.org/1999/xhtml">If that happens, each microservice is not independent anymore, which opens the floor to our next topic.</span></p>
</section>
<section class="level3" data-number="20.2.3" id="microservice-independence">
<h3 data-number="20.2.3"><span class="koboSpan" id="kobo.40.1" xmlns="http://www.w3.org/1999/xhtml">Microservice independence</span></h3>
<p><span class="koboSpan" id="kobo.41.1" xmlns="http://www.w3.org/1999/xhtml">At this point, we have microservices that are cohesive units of business and own their data. </span><span class="koboSpan" id="kobo.41.2" xmlns="http://www.w3.org/1999/xhtml">That defines </span><strong><span class="koboSpan" id="kobo.42.1" xmlns="http://www.w3.org/1999/xhtml">independence</span></strong><span class="koboSpan" id="kobo.43.1" xmlns="http://www.w3.org/1999/xhtml">.This independence allows the systems to scale while having minimal to no impact on the other microservices. </span><span class="koboSpan" id="kobo.43.2" xmlns="http://www.w3.org/1999/xhtml">Each microservice can also scale independently without needing the whole system to be scaled. </span><span class="koboSpan" id="kobo.43.3" xmlns="http://www.w3.org/1999/xhtml">Additionally, when the business requirements grow, each part of that domain can evolve independently.Furthermore, you could update one microservice without impacting the others or even have a microservice go offline without the whole system stopping.Of course, microservices have to interact with one another, but the way they do should define how well your system runs. </span><span class="koboSpan" id="kobo.43.4" xmlns="http://www.w3.org/1999/xhtml">A little like Vertical Slice architecture, you are not limited to using one set of architectural patterns; you can independently make specific decisions for each microservice. </span><span class="koboSpan" id="kobo.43.5" xmlns="http://www.w3.org/1999/xhtml">For example, you could choose a different way for how two microservices communicate with each other versus two others. </span><span class="koboSpan" id="kobo.43.6" xmlns="http://www.w3.org/1999/xhtml">You could even use different programming languages for each microservice.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.44.1" xmlns="http://www.w3.org/1999/xhtml">I recommend sticking to one or a few programming languages for smaller businesses and organizations, as you most likely have fewer developers, and each has more to do. </span><span class="koboSpan" id="kobo.44.2" xmlns="http://www.w3.org/1999/xhtml">Based on my experience, you want to ensure business continuity when people leave and make sure you can replace them and not sink the ship due to some obscure technologies used here and there (or too many technologies).</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.45.1" xmlns="http://www.w3.org/1999/xhtml">Now that we’ve covered the basics, let’s jump into the different ways microservices can communicate using event-driven architecture.</span></p>
</section>
</section>
<section class="level2" data-number="20.3" id="an-introduction-to-event-driven-architecture">
<h2 data-number="20.3"><span class="koboSpan" id="kobo.46.1" xmlns="http://www.w3.org/1999/xhtml">An introduction to event-driven architecture</span></h2>
<p><strong><span class="koboSpan" id="kobo.47.1" xmlns="http://www.w3.org/1999/xhtml">Event-driven architecture</span></strong><span class="koboSpan" id="kobo.48.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.49.1" xmlns="http://www.w3.org/1999/xhtml">EDA</span></strong><span class="koboSpan" id="kobo.50.1" xmlns="http://www.w3.org/1999/xhtml">) is a paradigm that revolves around consuming streams of events, or data in motion, instead of consuming static states.What I define by a static state is the data stored in a relational database table or other types of data stores, like a NoSQL documents store. </span><span class="koboSpan" id="kobo.50.2" xmlns="http://www.w3.org/1999/xhtml">That data is dormant in a central location and waiting for actors to consume and mutate it. </span><span class="koboSpan" id="kobo.50.3" xmlns="http://www.w3.org/1999/xhtml">It is stale between every mutation; the data (a record, for example) represents a finite state.On the other hand, data in motion is the opposite: you consume the ordered events and determine the change in state that each event brings or what process the program should trigger in reaction to an event.What is an event? </span><span class="koboSpan" id="kobo.50.4" xmlns="http://www.w3.org/1999/xhtml">People often interchange the words event, message, and command. </span><span class="koboSpan" id="kobo.50.5" xmlns="http://www.w3.org/1999/xhtml">Let’s try to clarify this:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.51.1" xmlns="http://www.w3.org/1999/xhtml">A message is a piece of data that represents something.</span></li>
<li><span class="koboSpan" id="kobo.52.1" xmlns="http://www.w3.org/1999/xhtml">A message can be an object, a JSON string, bytes, or anything else your system can interpret.</span></li>
<li><span class="koboSpan" id="kobo.53.1" xmlns="http://www.w3.org/1999/xhtml">An event is a message that represents something that happened in the past.</span></li>
<li><span class="koboSpan" id="kobo.54.1" xmlns="http://www.w3.org/1999/xhtml">A command is a message sent to tell one or more recipients to do something.</span></li>
<li><span class="koboSpan" id="kobo.55.1" xmlns="http://www.w3.org/1999/xhtml">A command is sent (past tense), so we can also consider it an event.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.56.1" xmlns="http://www.w3.org/1999/xhtml">A message usually has a payload (or body), headers (metadata), and a way to identify it (this can be through the body or headers).We can use events to divide a complex system into smaller pieces or have multiple systems talk to each other without creating tight coupling. </span><span class="koboSpan" id="kobo.56.2" xmlns="http://www.w3.org/1999/xhtml">Those systems could be subsystems or external applications, such as microservices.Like a REST API's </span><strong><span class="koboSpan" id="kobo.57.1" xmlns="http://www.w3.org/1999/xhtml">Data Transfer Objects (DTOs)</span></strong><span class="koboSpan" id="kobo.58.1" xmlns="http://www.w3.org/1999/xhtml">, events become the data contracts that tie the multiple systems together (coupling). </span><span class="koboSpan" id="kobo.58.2" xmlns="http://www.w3.org/1999/xhtml">It is essential to think about that carefully when designing events. </span><span class="koboSpan" id="kobo.58.3" xmlns="http://www.w3.org/1999/xhtml">Of course, we cannot foresee the future, so we can only do so much to get it perfect the first time. </span><span class="koboSpan" id="kobo.58.4" xmlns="http://www.w3.org/1999/xhtml">We can version the events to improve maintainability.EDA is a fantastic way of breaking tight coupling between microservices but requires rewiring your brain to learn this newer paradigm. </span><span class="koboSpan" id="kobo.58.5" xmlns="http://www.w3.org/1999/xhtml">Tooling is becoming more mature, and expertise is less scarce than more linear ways of thinking (like using point-to-point communication and relational databases). </span><span class="koboSpan" id="kobo.58.6" xmlns="http://www.w3.org/1999/xhtml">However, this is slowly changing and well worth learning.Before moving further, we can categorize events into the following overlapping buckets:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.59.1" xmlns="http://www.w3.org/1999/xhtml">Domain events</span></li>
<li><span class="koboSpan" id="kobo.60.1" xmlns="http://www.w3.org/1999/xhtml">Integration events</span></li>
<li><span class="koboSpan" id="kobo.61.1" xmlns="http://www.w3.org/1999/xhtml">Application events</span></li>
<li><span class="koboSpan" id="kobo.62.1" xmlns="http://www.w3.org/1999/xhtml">Enterprise events</span></li>
</ul>
<p><span class="koboSpan" id="kobo.63.1" xmlns="http://www.w3.org/1999/xhtml">As we explore next, all types of events play a similar role with different intents and scopes.</span></p>
<section class="level3" data-number="20.3.1" id="domain-events">
<h3 data-number="20.3.1"><span class="koboSpan" id="kobo.64.1" xmlns="http://www.w3.org/1999/xhtml">Domain events</span></h3>
<p><span class="koboSpan" id="kobo.65.1" xmlns="http://www.w3.org/1999/xhtml">A domain event is a term based on DDD representing an event in the domain. </span><span class="koboSpan" id="kobo.65.2" xmlns="http://www.w3.org/1999/xhtml">This event could then trigger other pieces of logic to be executed subsequently. </span><span class="koboSpan" id="kobo.65.3" xmlns="http://www.w3.org/1999/xhtml">It allows us to divide a complex process into multiple smaller processes. </span><span class="koboSpan" id="kobo.65.4" xmlns="http://www.w3.org/1999/xhtml">Domain events work well with domain-centric designs, like Clean Architecture, as we can use them to split complex domain objects into multiple smaller pieces. </span><span class="koboSpan" id="kobo.65.5" xmlns="http://www.w3.org/1999/xhtml">Domain events are usually application events. </span><span class="koboSpan" id="kobo.65.6" xmlns="http://www.w3.org/1999/xhtml">For example, we can use MediatR to publish domain events inside an application.To summarize, </span><strong><span class="koboSpan" id="kobo.66.1" xmlns="http://www.w3.org/1999/xhtml">domain events integrate pieces of domain logic together while keeping the domain logic segregated</span></strong><span class="koboSpan" id="kobo.67.1" xmlns="http://www.w3.org/1999/xhtml">, leading to loosely coupled components that hold one domain responsibility each (single responsibility principle).</span></p>
</section>
<section class="level3" data-number="20.3.2" id="integration-events">
<h3 data-number="20.3.2"><span class="koboSpan" id="kobo.68.1" xmlns="http://www.w3.org/1999/xhtml">Integration events</span></h3>
<p><span class="koboSpan" id="kobo.69.1" xmlns="http://www.w3.org/1999/xhtml">Integration events are like domain events but propagate messages to external systems, integrating multiple systems together while keeping them independent. </span><span class="koboSpan" id="kobo.69.2" xmlns="http://www.w3.org/1999/xhtml">For example, a microservice could send the </span><code><span class="koboSpan" id="kobo.70.1" xmlns="http://www.w3.org/1999/xhtml">new user registered</span></code><span class="koboSpan" id="kobo.71.1" xmlns="http://www.w3.org/1999/xhtml"> event message that other microservices react to, like saving the </span><code><span class="koboSpan" id="kobo.72.1" xmlns="http://www.w3.org/1999/xhtml">user id</span></code><span class="koboSpan" id="kobo.73.1" xmlns="http://www.w3.org/1999/xhtml"> to enable additional capabilities or sending a greeting email to that new user.We use a message broker or message queue to publish such events. </span><span class="koboSpan" id="kobo.73.2" xmlns="http://www.w3.org/1999/xhtml">We explore those after covering application and enterprise events.To summarize, </span><strong><span class="koboSpan" id="kobo.74.1" xmlns="http://www.w3.org/1999/xhtml">integration events integrate multiple systems together while keeping them independent</span></strong><span class="koboSpan" id="kobo.75.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</section>
<section class="level3" data-number="20.3.3" id="application-events">
<h3 data-number="20.3.3"><span class="koboSpan" id="kobo.76.1" xmlns="http://www.w3.org/1999/xhtml">Application events</span></h3>
<p><span class="koboSpan" id="kobo.77.1" xmlns="http://www.w3.org/1999/xhtml">An application event is an event that is internal to an application; it is just a matter of scope. </span><span class="koboSpan" id="kobo.77.2" xmlns="http://www.w3.org/1999/xhtml">If the event is internal to a single process, that event is also a domain event (most likely). </span><span class="koboSpan" id="kobo.77.3" xmlns="http://www.w3.org/1999/xhtml">If the event crosses microservices boundaries that your team owns (the same application), it is also an integration event. </span><span class="koboSpan" id="kobo.77.4" xmlns="http://www.w3.org/1999/xhtml">The event itself won’t be different; it is the reason why it exists and its scope that describes it as an application event or not.To summarize, </span><strong><span class="koboSpan" id="kobo.78.1" xmlns="http://www.w3.org/1999/xhtml">application events are related to a single application</span></strong><span class="koboSpan" id="kobo.79.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</section>
<section class="level3" data-number="20.3.4" id="enterprise-events">
<h3 data-number="20.3.4"><span class="koboSpan" id="kobo.80.1" xmlns="http://www.w3.org/1999/xhtml">Enterprise events</span></h3>
<p><span class="koboSpan" id="kobo.81.1" xmlns="http://www.w3.org/1999/xhtml">An enterprise event describes an event that crosses internal enterprise boundaries. </span><span class="koboSpan" id="kobo.81.2" xmlns="http://www.w3.org/1999/xhtml">These are tightly coupled with your organizational structure. </span><span class="koboSpan" id="kobo.81.3" xmlns="http://www.w3.org/1999/xhtml">For example, a microservice sends an event that other teams, part of other divisions or departments, consume.The governance model around those events should differ from application events only your team consumes and be more strict with strong oversight.Someone must consider who can consume that data, under what circumstances, the impact of changing the event schema (data contract), schema ownership, naming conventions, data-structure conventions, and more, or risk building an unstable data highway.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.82.1" xmlns="http://www.w3.org/1999/xhtml">I like to see EDA as a central </span><strong><span class="koboSpan" id="kobo.83.1" xmlns="http://www.w3.org/1999/xhtml">data highway</span></strong><span class="koboSpan" id="kobo.84.1" xmlns="http://www.w3.org/1999/xhtml"> in the middle of applications, systems, integrations, and organizational boundaries, where the events (data) flow between systems in a loosely coupled manner.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.85.1" xmlns="http://www.w3.org/1999/xhtml">It’s like a highway where cars flow between cities (without traffic jams). </span><span class="koboSpan" id="kobo.85.2" xmlns="http://www.w3.org/1999/xhtml">The cities are not controlling what car goes where but are open to visitors.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.86.1" xmlns="http://www.w3.org/1999/xhtml">To summarize, </span><strong><span class="koboSpan" id="kobo.87.1" xmlns="http://www.w3.org/1999/xhtml">enterprise events are integration events that cross organizational boundaries</span></strong><span class="koboSpan" id="kobo.88.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</section>
<section class="level3" data-number="20.3.5" id="conclusion-28">
<h3 data-number="20.3.5"><span class="koboSpan" id="kobo.89.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.90.1" xmlns="http://www.w3.org/1999/xhtml">In this overview of event-driven architecture, we defined events, messages, and commands. </span><span class="koboSpan" id="kobo.90.2" xmlns="http://www.w3.org/1999/xhtml">An event is a snapshot of the past, a message is data, and a command is an event that suggests other systems take action. </span><span class="koboSpan" id="kobo.90.3" xmlns="http://www.w3.org/1999/xhtml">Since all messages are from the past, calling them events is accurate. </span><span class="koboSpan" id="kobo.90.4" xmlns="http://www.w3.org/1999/xhtml">We then organized events into a few overlapping buckets to help identify the intents. </span><span class="koboSpan" id="kobo.90.5" xmlns="http://www.w3.org/1999/xhtml">We can send events for different objectives, but whether it is about designing independent components or reaching out to different parts of the business, an event remains a payload that respects a certain format (schema). </span><span class="koboSpan" id="kobo.90.6" xmlns="http://www.w3.org/1999/xhtml">That schema is the data contract (coupling) between the consumers of those events. </span><span class="koboSpan" id="kobo.90.7" xmlns="http://www.w3.org/1999/xhtml">That data contract is probably the most important piece of it all: break the contract, break the system.Now, let’s see how event-driven architecture can help us follow the </span><strong><span class="koboSpan" id="kobo.91.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.92.1" xmlns="http://www.w3.org/1999/xhtml"> principles at cloud-scale:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.93.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.94.1" xmlns="http://www.w3.org/1999/xhtml">: Systems are independent of each other by raising and responding to events. </span><span class="koboSpan" id="kobo.94.2" xmlns="http://www.w3.org/1999/xhtml">The events themselves are the glue that ties those systems together. </span><span class="koboSpan" id="kobo.94.3" xmlns="http://www.w3.org/1999/xhtml">Each piece has a single responsibility.</span></li>
<li><strong><span class="koboSpan" id="kobo.95.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.96.1" xmlns="http://www.w3.org/1999/xhtml">: We can modify the system’s behaviors by adding new consumers to a particular event without impacting the other applications. </span><span class="koboSpan" id="kobo.96.2" xmlns="http://www.w3.org/1999/xhtml">We can also raise new events to build a new process without affecting existing applications.</span></li>
<li><strong><span class="koboSpan" id="kobo.97.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.98.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
<li><strong><span class="koboSpan" id="kobo.99.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.100.1" xmlns="http://www.w3.org/1999/xhtml">: Instead of building a single system, EDA allows us to create multiple smaller systems that integrate through data contracts (events), and those contracts are the messaging interfaces of the system.</span></li>
<li><strong><span class="koboSpan" id="kobo.101.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.102.1" xmlns="http://www.w3.org/1999/xhtml">: EDA enables systems to break tight coupling by depending on the events (interfaces/abstractions) instead of communicating directly with one another, inverting the dependency flow.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.103.1" xmlns="http://www.w3.org/1999/xhtml">EDA does not only come with advantages; it also has a few drawbacks that we explore in subsequent sections of the chapter.Next, we explore message queues followed by the Publish-Subscribe pattern, two ways of interacting with events.</span></p>
</section>
</section>
<section class="level2" data-number="20.4" id="getting-started-with-message-queues">
<h2 data-number="20.4"><span class="koboSpan" id="kobo.104.1" xmlns="http://www.w3.org/1999/xhtml">Getting started with message queues</span></h2>
<p><span class="koboSpan" id="kobo.105.1" xmlns="http://www.w3.org/1999/xhtml">A </span><strong><span class="koboSpan" id="kobo.106.1" xmlns="http://www.w3.org/1999/xhtml">message queue</span></strong><span class="koboSpan" id="kobo.107.1" xmlns="http://www.w3.org/1999/xhtml"> is nothing more than a queue we leverage to send ordered messages. </span><span class="koboSpan" id="kobo.107.2" xmlns="http://www.w3.org/1999/xhtml">A queue works on a </span><strong><span class="koboSpan" id="kobo.108.1" xmlns="http://www.w3.org/1999/xhtml">First In, First Out</span></strong><span class="koboSpan" id="kobo.109.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.110.1" xmlns="http://www.w3.org/1999/xhtml">FIFO</span></strong><span class="koboSpan" id="kobo.111.1" xmlns="http://www.w3.org/1999/xhtml">) basis. </span><span class="koboSpan" id="kobo.111.2" xmlns="http://www.w3.org/1999/xhtml">If our application runs in a single process, we could use one or more </span><code><span class="koboSpan" id="kobo.112.1" xmlns="http://www.w3.org/1999/xhtml">Queue&lt;T&gt;</span></code><span class="koboSpan" id="kobo.113.1" xmlns="http://www.w3.org/1999/xhtml"> instances to send messages between our components or a </span><code><span class="koboSpan" id="kobo.114.1" xmlns="http://www.w3.org/1999/xhtml">ConcurrentQueue&lt;T&gt;</span></code><span class="koboSpan" id="kobo.115.1" xmlns="http://www.w3.org/1999/xhtml"> instance to send messages between threads. </span><span class="koboSpan" id="kobo.115.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, queues can be managed by an independent program to send messages in a distributed fashion (between applications or microservices).A distributed message queue can add more or less features to the mix, especially for cloud programs that handle failures at more levels than a single server. </span><span class="koboSpan" id="kobo.115.3" xmlns="http://www.w3.org/1999/xhtml">One of those features is the </span><strong><span class="koboSpan" id="kobo.116.1" xmlns="http://www.w3.org/1999/xhtml">dead letter queue</span></strong><span class="koboSpan" id="kobo.117.1" xmlns="http://www.w3.org/1999/xhtml">, which stores messages that failed some criteria in another queue. </span><span class="koboSpan" id="kobo.117.2" xmlns="http://www.w3.org/1999/xhtml">For example, if the target queue is full, a message could be sent to the </span><strong><span class="koboSpan" id="kobo.118.1" xmlns="http://www.w3.org/1999/xhtml">dead letter queue</span></strong><span class="koboSpan" id="kobo.119.1" xmlns="http://www.w3.org/1999/xhtml"> instead. </span><span class="koboSpan" id="kobo.119.2" xmlns="http://www.w3.org/1999/xhtml">One could requeue such messages by putting the message back at the end of the queue.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.120.1" xmlns="http://www.w3.org/1999/xhtml">Beware that requeing messages change the order of the messages. </span><span class="koboSpan" id="kobo.120.2" xmlns="http://www.w3.org/1999/xhtml">If the order is important in your app, consider this.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.121.1" xmlns="http://www.w3.org/1999/xhtml">Many messaging queue protocols exist; some are proprietary, while others are open source. </span><span class="koboSpan" id="kobo.121.2" xmlns="http://www.w3.org/1999/xhtml">Some messaging queues are cloud-based and used </span><em><span class="koboSpan" id="kobo.122.1" xmlns="http://www.w3.org/1999/xhtml">as a service</span></em><span class="koboSpan" id="kobo.123.1" xmlns="http://www.w3.org/1999/xhtml">, such as Azure Service Bus and Amazon Simple Queue Service. </span><span class="koboSpan" id="kobo.123.2" xmlns="http://www.w3.org/1999/xhtml">Others are open source and can be deployed to the cloud or on-premises, such as Apache ActiveMQ.If you need to process messages in order and want each message to be delivered to a single recipient at a time, a </span><strong><span class="koboSpan" id="kobo.124.1" xmlns="http://www.w3.org/1999/xhtml">message queue</span></strong><span class="koboSpan" id="kobo.125.1" xmlns="http://www.w3.org/1999/xhtml"> seems like the right choice. </span><span class="koboSpan" id="kobo.125.2" xmlns="http://www.w3.org/1999/xhtml">Otherwise, the </span><strong><span class="koboSpan" id="kobo.126.1" xmlns="http://www.w3.org/1999/xhtml">Publish-Subscribe</span></strong><span class="koboSpan" id="kobo.127.1" xmlns="http://www.w3.org/1999/xhtml"> pattern could be a better fit for you.Here is a basic example that illustrates what we just discussed:</span></p>
<figure>
<span class="koboSpan" id="kobo.128.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.1: A publisher that enqueues a message with a subscriber that dequeues it" src="../media/file128.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.129.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.1: A publisher that enqueues a message with a subscriber that dequeues it</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.130.1" xmlns="http://www.w3.org/1999/xhtml">For a more concrete example, in a distributed user registration process, when a user registers, we could want to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.131.1" xmlns="http://www.w3.org/1999/xhtml">Send a confirmation email.</span></li>
<li><span class="koboSpan" id="kobo.132.1" xmlns="http://www.w3.org/1999/xhtml">Process their picture and save one or more thumbnails.</span></li>
<li><span class="koboSpan" id="kobo.133.1" xmlns="http://www.w3.org/1999/xhtml">Send an onboarding message to their in-app mailbox.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.134.1" xmlns="http://www.w3.org/1999/xhtml">To sequentially achieve this, one operation after the other, we could do the following:</span></p>
<figure>
<span class="koboSpan" id="kobo.135.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.2: A process flow that sequentially executes three operations that happen after a user creates an account" src="../media/file129.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.136.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.2: A process flow that sequentially executes three operations that happen after a user creates an account</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.137.1" xmlns="http://www.w3.org/1999/xhtml">In this case, the user would not receive the </span><em><span class="koboSpan" id="kobo.138.1" xmlns="http://www.w3.org/1999/xhtml">Onboarding Message</span></em><span class="koboSpan" id="kobo.139.1" xmlns="http://www.w3.org/1999/xhtml"> if the process crashes during the </span><em><span class="koboSpan" id="kobo.140.1" xmlns="http://www.w3.org/1999/xhtml">Process Thumbnail</span></em><span class="koboSpan" id="kobo.141.1" xmlns="http://www.w3.org/1999/xhtml"> operation. </span><span class="koboSpan" id="kobo.141.2" xmlns="http://www.w3.org/1999/xhtml">Another drawback would be that to insert a new operation between the </span><em><span class="koboSpan" id="kobo.142.1" xmlns="http://www.w3.org/1999/xhtml">Process Thumbnail</span></em><span class="koboSpan" id="kobo.143.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><em><span class="koboSpan" id="kobo.144.1" xmlns="http://www.w3.org/1999/xhtml">Send an onboarding message</span></em><span class="koboSpan" id="kobo.145.1" xmlns="http://www.w3.org/1999/xhtml"> steps, we’d have to modify the </span><em><span class="koboSpan" id="kobo.146.1" xmlns="http://www.w3.org/1999/xhtml">Send an onboarding message</span></em><span class="koboSpan" id="kobo.147.1" xmlns="http://www.w3.org/1999/xhtml"> operation (tight coupling).If the order does not matter, we could queue all the messages from the </span><em><span class="koboSpan" id="kobo.148.1" xmlns="http://www.w3.org/1999/xhtml">Auth Server</span></em><span class="koboSpan" id="kobo.149.1" xmlns="http://www.w3.org/1999/xhtml"> instead, right after the user’s creation, like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.150.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.3: The Auth Server is queuing the operations sequentially while different processes execute them in parallel" src="../media/file130.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.151.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.3: The Auth Server is queuing the operations sequentially while different processes execute them in parallel</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.152.1" xmlns="http://www.w3.org/1999/xhtml">This process is better, but the </span><em><span class="koboSpan" id="kobo.153.1" xmlns="http://www.w3.org/1999/xhtml">Auth Server</span></em><span class="koboSpan" id="kobo.154.1" xmlns="http://www.w3.org/1999/xhtml"> now controls what should happen once a new user has been created. </span><span class="koboSpan" id="kobo.154.2" xmlns="http://www.w3.org/1999/xhtml">The </span><em><span class="koboSpan" id="kobo.155.1" xmlns="http://www.w3.org/1999/xhtml">Auth Server</span></em><span class="koboSpan" id="kobo.156.1" xmlns="http://www.w3.org/1999/xhtml"> was queuing an event in the previous workflow that told the system that a new user registered. </span><span class="koboSpan" id="kobo.156.2" xmlns="http://www.w3.org/1999/xhtml">However, now, it has to be aware of the post-processing workflow to queue each operation sequentially to enqueue the correct commands. </span><span class="koboSpan" id="kobo.156.3" xmlns="http://www.w3.org/1999/xhtml">Doing this is not wrong in itself and is easier to follow when you dig into the code, but it creates tighter coupling between the services where the </span><em><span class="koboSpan" id="kobo.157.1" xmlns="http://www.w3.org/1999/xhtml">Auth Server</span></em><span class="koboSpan" id="kobo.158.1" xmlns="http://www.w3.org/1999/xhtml"> is aware of the external processes. </span><span class="koboSpan" id="kobo.158.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, it packs too many responsibilities into the </span><em><span class="koboSpan" id="kobo.159.1" xmlns="http://www.w3.org/1999/xhtml">Auth Server</span></em><span class="koboSpan" id="kobo.160.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.161.1" xmlns="http://www.w3.org/1999/xhtml">SRP-wise, why would an authentication/authorization server be responsible for anything other than authentication, authorization, and managing that data?</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.162.1" xmlns="http://www.w3.org/1999/xhtml">If we continue from there and want to add a new operation between two existing steps, we would only have to modify the </span><em><span class="koboSpan" id="kobo.163.1" xmlns="http://www.w3.org/1999/xhtml">Auth Server</span></em><span class="koboSpan" id="kobo.164.1" xmlns="http://www.w3.org/1999/xhtml">, which is less error-prone than the preceding workflow.If we want the best of both worlds, we could use the </span><strong><span class="koboSpan" id="kobo.165.1" xmlns="http://www.w3.org/1999/xhtml">Publish-Subscribe</span></strong><span class="koboSpan" id="kobo.166.1" xmlns="http://www.w3.org/1999/xhtml"> pattern instead, which we cover next, and continue building on top of this example.</span></p>
<section class="level3" data-number="20.4.1" id="conclusion-29">
<h3 data-number="20.4.1"><span class="koboSpan" id="kobo.167.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.168.1" xmlns="http://www.w3.org/1999/xhtml">If you need messages to be delivered sequentially, a queue might be the right tool. </span><span class="koboSpan" id="kobo.168.2" xmlns="http://www.w3.org/1999/xhtml">The example we explored was destined to fail from the beginning, but it allowed us to explore the thinking process behind designing the system. </span><span class="koboSpan" id="kobo.168.3" xmlns="http://www.w3.org/1999/xhtml">Sometimes, the first idea is not the best and can be improved by exploring new ways of doing things or learning new skills. </span><span class="koboSpan" id="kobo.168.4" xmlns="http://www.w3.org/1999/xhtml">Being open-minded to the ideas of others can also lead to better solutions.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.169.1" xmlns="http://www.w3.org/1999/xhtml">Sometimes, just speaking out loud makes our own brain solve the issue by itself. </span><span class="koboSpan" id="kobo.169.2" xmlns="http://www.w3.org/1999/xhtml">So explain the problem to someone and see what happens.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.170.1" xmlns="http://www.w3.org/1999/xhtml">Message queues are amazing at buffering messages for high-demand scenarios where an application may not be able to handle spikes of traffic. </span><span class="koboSpan" id="kobo.170.2" xmlns="http://www.w3.org/1999/xhtml">In that case, the messages are enqueued so the application can catch up at its own speed, reading them sequentially.Implementing distributed message queues requires a lot of knowledge and effort and is not worth it for almost all scenarios. </span><span class="koboSpan" id="kobo.170.3" xmlns="http://www.w3.org/1999/xhtml">The big cloud providers like AWS and Azure offer fully managed message queue systems as a service. </span><span class="koboSpan" id="kobo.170.4" xmlns="http://www.w3.org/1999/xhtml">You can also look at </span><strong><span class="koboSpan" id="kobo.171.1" xmlns="http://www.w3.org/1999/xhtml">ActiveMQ</span></strong><span class="koboSpan" id="kobo.172.1" xmlns="http://www.w3.org/1999/xhtml">, </span><strong><span class="koboSpan" id="kobo.173.1" xmlns="http://www.w3.org/1999/xhtml">RabbitMQ</span></strong><span class="koboSpan" id="kobo.174.1" xmlns="http://www.w3.org/1999/xhtml">, or any </span><strong><span class="koboSpan" id="kobo.175.1" xmlns="http://www.w3.org/1999/xhtml">Advanced Message Queuing Protocol</span></strong><span class="koboSpan" id="kobo.176.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.177.1" xmlns="http://www.w3.org/1999/xhtml">AMQP</span></strong><span class="koboSpan" id="kobo.178.1" xmlns="http://www.w3.org/1999/xhtml">) broker.One essential aspect of choosing the right queue system is whether you are ready and have the skills to manage your own distributed message queue. </span><span class="koboSpan" id="kobo.178.2" xmlns="http://www.w3.org/1999/xhtml">Suppose you want to speed up development, cut infrastructure management costs, and have enough money. </span><span class="koboSpan" id="kobo.178.3" xmlns="http://www.w3.org/1999/xhtml">In that case, you could use a fully managed offering for at least your production environment, especially if you expect a large volume of messages. </span><span class="koboSpan" id="kobo.178.4" xmlns="http://www.w3.org/1999/xhtml">On the other hand, using a local or on-premise instance for development or smaller-scale usage may save you a considerable sum of money. </span><span class="koboSpan" id="kobo.178.5" xmlns="http://www.w3.org/1999/xhtml">Choosing an open source system with fully managed cloud offerings is a good way to achieve both: low local development cost with an always available high-performance cloud production offering that the service provider maintains for you.Another aspect is to base your choice on needs. </span><span class="koboSpan" id="kobo.178.6" xmlns="http://www.w3.org/1999/xhtml">Have clear requirements and ensure the system you choose does what you need. </span><span class="koboSpan" id="kobo.178.7" xmlns="http://www.w3.org/1999/xhtml">Some offerings cover multiple use cases like queues and pub-sub, leading to a simplified tech stack requiring fewer skills.Before moving to the pub-sub pattern, let’s see how message queues can help us follow the </span><strong><span class="koboSpan" id="kobo.179.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.180.1" xmlns="http://www.w3.org/1999/xhtml"> principles at the app scale:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.181.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.182.1" xmlns="http://www.w3.org/1999/xhtml">: Helps centralize and divide responsibilities between applications or components without them directly knowing each other, breaking tight coupling.</span></li>
<li><strong><span class="koboSpan" id="kobo.183.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.184.1" xmlns="http://www.w3.org/1999/xhtml">: Allows us to change the message producer’s or subscriber’s behaviors without the other knowing about it.</span></li>
<li><strong><span class="koboSpan" id="kobo.185.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.186.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
<li><strong><span class="koboSpan" id="kobo.187.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.188.1" xmlns="http://www.w3.org/1999/xhtml">: Each message and handler can be as small as needed, while each microservice indirectly interacts with the others to solve the bigger problem.</span></li>
<li><strong><span class="koboSpan" id="kobo.189.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.190.1" xmlns="http://www.w3.org/1999/xhtml">: By not knowing the other dependencies (breaking tight coupling between microservices), each microservice depends only on the messages (abstractions) instead of concretions (the other microservices API).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.191.1" xmlns="http://www.w3.org/1999/xhtml">One drawback is the delay between enqueuing a message and processing a message. </span><span class="koboSpan" id="kobo.191.2" xmlns="http://www.w3.org/1999/xhtml">We talk about delay and latency in more detail in subsequent sections.</span></p>
</section>
</section>
<section class="level2" data-number="20.5" id="implementing-the-publish-subscribe-pattern">
<h2 data-number="20.5"><span class="koboSpan" id="kobo.192.1" xmlns="http://www.w3.org/1999/xhtml">Implementing the Publish-Subscribe pattern</span></h2>
<p><span class="koboSpan" id="kobo.193.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.194.1" xmlns="http://www.w3.org/1999/xhtml">Publish-Subscribe</span></strong><span class="koboSpan" id="kobo.195.1" xmlns="http://www.w3.org/1999/xhtml"> pattern (Pub-Sub) is similar to what we did using </span><strong><span class="koboSpan" id="kobo.196.1" xmlns="http://www.w3.org/1999/xhtml">MediatR</span></strong><span class="koboSpan" id="kobo.197.1" xmlns="http://www.w3.org/1999/xhtml"> and what we explored in the </span><em><span class="koboSpan" id="kobo.198.1" xmlns="http://www.w3.org/1999/xhtml">Getting started with message queues</span></em><span class="koboSpan" id="kobo.199.1" xmlns="http://www.w3.org/1999/xhtml"> section. </span><span class="koboSpan" id="kobo.199.2" xmlns="http://www.w3.org/1999/xhtml">However, instead of sending one message to one handler (or enqueuing a message), we publish (send) a message (event) to zero or more subscribers (handlers). </span><span class="koboSpan" id="kobo.199.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, the publisher is unaware of the subscribers; it only sends messages out, hoping for the best (also known as </span><strong><span class="koboSpan" id="kobo.200.1" xmlns="http://www.w3.org/1999/xhtml">fire and forget</span></strong><span class="koboSpan" id="kobo.201.1" xmlns="http://www.w3.org/1999/xhtml">).</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.202.1" xmlns="http://www.w3.org/1999/xhtml">Using a message queue does not mean you are limited to only one recipient.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.203.1" xmlns="http://www.w3.org/1999/xhtml">We can use </span><strong><span class="koboSpan" id="kobo.204.1" xmlns="http://www.w3.org/1999/xhtml">Publish-Subscribe</span></strong><span class="koboSpan" id="kobo.205.1" xmlns="http://www.w3.org/1999/xhtml"> in-process or in a distributed system through a </span><strong><span class="koboSpan" id="kobo.206.1" xmlns="http://www.w3.org/1999/xhtml">message broker</span></strong><span class="koboSpan" id="kobo.207.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.207.2" xmlns="http://www.w3.org/1999/xhtml">The message broker is responsible for delivering the messages to the subscribers. </span><span class="koboSpan" id="kobo.207.3" xmlns="http://www.w3.org/1999/xhtml">Using a message broker is the way to go for microservices and other distributed systems since they are not running in a single process.This pattern has many advantages over other ways of communication. </span><span class="koboSpan" id="kobo.207.4" xmlns="http://www.w3.org/1999/xhtml">For example, we could recreate the state of a database by replaying the events that happened in the system, leading to the </span><strong><span class="koboSpan" id="kobo.208.1" xmlns="http://www.w3.org/1999/xhtml">event sourcing</span></strong><span class="koboSpan" id="kobo.209.1" xmlns="http://www.w3.org/1999/xhtml"> pattern. </span><span class="koboSpan" id="kobo.209.2" xmlns="http://www.w3.org/1999/xhtml">More on that later.The design depends on the technology used to deliver the messages and the system's configuration. </span><span class="koboSpan" id="kobo.209.3" xmlns="http://www.w3.org/1999/xhtml">For example, you could use </span><strong><span class="koboSpan" id="kobo.210.1" xmlns="http://www.w3.org/1999/xhtml">MQTT</span></strong><span class="koboSpan" id="kobo.211.1" xmlns="http://www.w3.org/1999/xhtml"> to deliver messages to </span><strong><span class="koboSpan" id="kobo.212.1" xmlns="http://www.w3.org/1999/xhtml">Internet of Things</span></strong><span class="koboSpan" id="kobo.213.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.214.1" xmlns="http://www.w3.org/1999/xhtml">IoT</span></strong><span class="koboSpan" id="kobo.215.1" xmlns="http://www.w3.org/1999/xhtml">) devices and configure them to retain the last message sent on each topic. </span><span class="koboSpan" id="kobo.215.2" xmlns="http://www.w3.org/1999/xhtml">That way, when a device connects to a topic, it receives the latest message. </span><span class="koboSpan" id="kobo.215.3" xmlns="http://www.w3.org/1999/xhtml">You could also configure a </span><strong><span class="koboSpan" id="kobo.216.1" xmlns="http://www.w3.org/1999/xhtml">Kafka</span></strong><span class="koboSpan" id="kobo.217.1" xmlns="http://www.w3.org/1999/xhtml"> broker that keeps a long history of messages and asks for all of them when a new system connects to it. </span><span class="koboSpan" id="kobo.217.2" xmlns="http://www.w3.org/1999/xhtml">All of that depends on your needs and requirements.</span></p>
<blockquote>
<p><strong><span class="koboSpan" id="kobo.218.1" xmlns="http://www.w3.org/1999/xhtml">MQTT and Apache Kafka</span></strong></p>
<blockquote>
<p><span class="koboSpan" id="kobo.219.1" xmlns="http://www.w3.org/1999/xhtml">If you were wondering what MQTT is, here is a quote from their website </span><a href="https://adpg.link/mqtt"><span class="koboSpan" id="kobo.220.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/mqtt</span></a><span class="koboSpan" id="kobo.221.1" xmlns="http://www.w3.org/1999/xhtml">:</span></p>
</blockquote>
<blockquote>
<p><em><span class="koboSpan" id="kobo.222.1" xmlns="http://www.w3.org/1999/xhtml">“MQTT is an OASIS standard messaging protocol for the Internet of Things (IoT). </span><span class="koboSpan" id="kobo.222.2" xmlns="http://www.w3.org/1999/xhtml">It is designed as an extremely lightweight publish/subscribe messaging transport […]”</span></em></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.223.1" xmlns="http://www.w3.org/1999/xhtml">Here is a quote from Apache Kafka’s website </span><a href="https://adpg.link/kafka"><span class="koboSpan" id="kobo.224.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/kafka</span></a><span class="koboSpan" id="kobo.225.1" xmlns="http://www.w3.org/1999/xhtml">:</span></p>
</blockquote>
<blockquote>
<p><em><span class="koboSpan" id="kobo.226.1" xmlns="http://www.w3.org/1999/xhtml">“Apache Kafka is an open-source distributed event streaming platform […]”</span></em></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.227.1" xmlns="http://www.w3.org/1999/xhtml">We cannot cover every single scenario of every system that follows every protocol. </span><span class="koboSpan" id="kobo.227.2" xmlns="http://www.w3.org/1999/xhtml">Therefore, I’ll highlight some shared concepts behind the Pub-Sub design pattern so you know how to get started. </span><span class="koboSpan" id="kobo.227.3" xmlns="http://www.w3.org/1999/xhtml">Then, you can dig into the specific technology you want (or need) to use.A topic is a way to organize events, a channel, a place to read or write specific events so consumers know where to find them. </span><span class="koboSpan" id="kobo.227.4" xmlns="http://www.w3.org/1999/xhtml">As you can probably imagine, sending all events to the same place is like creating a relational database with a single table: it would be suboptimal and hard to manage, use, and evolve.To receive messages, subscribers must subscribe to topics (or the equivalent of a topic):</span></p>
<figure>
<span class="koboSpan" id="kobo.228.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.4: A subscriber subscribes to a pub-sub topic" src="../media/file131.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.229.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.4: A subscriber subscribes to a pub-sub topic</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.230.1" xmlns="http://www.w3.org/1999/xhtml">The second part of the Pub-Sub pattern is to publish messages, like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.231.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.5: A publisher is sending a message to the message broker. The broker then forwards that message to N subscribers, where N can be zero or more" src="../media/file132.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.232.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.5: A publisher is sending a message to the message broker. </span><span class="koboSpan" id="kobo.232.2" xmlns="http://www.w3.org/1999/xhtml">The broker then forwards that message to </span><em><span class="koboSpan" id="kobo.233.1" xmlns="http://www.w3.org/1999/xhtml">N</span></em><span class="koboSpan" id="kobo.234.1" xmlns="http://www.w3.org/1999/xhtml"> subscribers, where </span><em><span class="koboSpan" id="kobo.235.1" xmlns="http://www.w3.org/1999/xhtml">N</span></em><span class="koboSpan" id="kobo.236.1" xmlns="http://www.w3.org/1999/xhtml"> can be zero or more</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.237.1" xmlns="http://www.w3.org/1999/xhtml">Many abstracted details here depend on the broker and the protocol. </span><span class="koboSpan" id="kobo.237.2" xmlns="http://www.w3.org/1999/xhtml">However, the following are the two primary concepts behind the Publish-Subscribe pattern:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.238.1" xmlns="http://www.w3.org/1999/xhtml">Publishers publish messages to topics.</span></li>
<li><span class="koboSpan" id="kobo.239.1" xmlns="http://www.w3.org/1999/xhtml">Subscribers subscribe to topics to receive messages when they are published.</span></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.240.1" xmlns="http://www.w3.org/1999/xhtml">Security is a crucial implementation detail not illustrated here. </span><span class="koboSpan" id="kobo.240.2" xmlns="http://www.w3.org/1999/xhtml">Security is mandatory in most systems; not every subsystem or device should have access to all topics.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.241.1" xmlns="http://www.w3.org/1999/xhtml">Publishers and subscribers could be any part of any system. </span><span class="koboSpan" id="kobo.241.2" xmlns="http://www.w3.org/1999/xhtml">For example, many Microsoft Azure services are publishers (for example, Blob storage). </span><span class="koboSpan" id="kobo.241.3" xmlns="http://www.w3.org/1999/xhtml">You can then have other Azure services (for example, Azure Functions) subscribe to those events and react to them.You can also use the </span><strong><span class="koboSpan" id="kobo.242.1" xmlns="http://www.w3.org/1999/xhtml">Publish-Subscribe</span></strong><span class="koboSpan" id="kobo.243.1" xmlns="http://www.w3.org/1999/xhtml"> pattern inside your applications—there’s no need to use cloud resources for that; this can even be done inside the same process (we explore this in the next chapter).The most significant advantage of the Publish-Subscribe pattern is breaking tight coupling between systems. </span><span class="koboSpan" id="kobo.243.2" xmlns="http://www.w3.org/1999/xhtml">One system publishes events while others consume them without the systems knowing each other.That loose coupling leads to scalability, where each system can scale independently, and messages can be processed in parallel using the required resources. </span><span class="koboSpan" id="kobo.243.3" xmlns="http://www.w3.org/1999/xhtml">It is also easier to add new processes to a workflow since the systems are unaware of the others. </span><span class="koboSpan" id="kobo.243.4" xmlns="http://www.w3.org/1999/xhtml">To add a new process that reacts to an event, you only have to create a new microservice, deploy it, start to listen to one or more events, and process them.On the downside, the message broker can become the application’s single point of failure and must be configured appropriately. </span><span class="koboSpan" id="kobo.243.5" xmlns="http://www.w3.org/1999/xhtml">It is also essential to consider the best delivery policies for each message type. </span><span class="koboSpan" id="kobo.243.6" xmlns="http://www.w3.org/1999/xhtml">An example of a policy could be to ensure the delivery of crucial messages while delaying less time-sensitive messages and dropping unimportant messages during load surges.If we revisit our previous example using Publish-Subscribe, we end up with the following simplified workflow:</span></p>
<figure>
<span class="koboSpan" id="kobo.244.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.6: The Auth Server is publishing an event representing the creation of a new user. The broker then forwards that message to the three subscribers, who then execute their tasks in parallel" src="../media/file133.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.245.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.6: The Auth Server is publishing an event representing the creation of a new user. </span><span class="koboSpan" id="kobo.245.2" xmlns="http://www.w3.org/1999/xhtml">The broker then forwards that message to the three subscribers, who then execute their tasks in parallel</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.246.1" xmlns="http://www.w3.org/1999/xhtml">Based on this workflow, we broke the tight coupling between the </span><em><span class="koboSpan" id="kobo.247.1" xmlns="http://www.w3.org/1999/xhtml">Auth Server</span></em><span class="koboSpan" id="kobo.248.1" xmlns="http://www.w3.org/1999/xhtml"> and the post-registration process. </span><span class="koboSpan" id="kobo.248.2" xmlns="http://www.w3.org/1999/xhtml">The </span><em><span class="koboSpan" id="kobo.249.1" xmlns="http://www.w3.org/1999/xhtml">Auth Server</span></em><span class="koboSpan" id="kobo.250.1" xmlns="http://www.w3.org/1999/xhtml"> is unaware of the workflow, and the individual services are unaware of each other. </span><span class="koboSpan" id="kobo.250.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, if we want to add a new task, we only have to create or update a microservice that subscribes to the right topic (in this case, the “new user registered” topic).The current system does not support synchronization and does not handle process failures or retries, but it is a good start since we combine the pros of the message queue examples and leave the cons behind.Using an event broker inverts the dependency flow. </span><span class="koboSpan" id="kobo.250.3" xmlns="http://www.w3.org/1999/xhtml">The diagrams we explored show the message flow, but here’s what happens on the dependency sides of things:</span></p>
<figure>
<span class="koboSpan" id="kobo.251.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.7: A diagram representing the inverted dependency flow of using the pub-sub pattern" src="../media/file134.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.252.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.7: A diagram representing the inverted dependency flow of using the pub-sub pattern</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.253.1" xmlns="http://www.w3.org/1999/xhtml">Now that we have explored the Publish-Subscribe pattern, we look at message brokers, then dig deeper into EDA and leverage the Publish-Subscribe pattern to create a persistent database of events that can be replayed: the Event Sourcing pattern.</span></p>
<section class="level3" data-number="20.5.1" id="message-brokers">
<h3 data-number="20.5.1"><span class="koboSpan" id="kobo.254.1" xmlns="http://www.w3.org/1999/xhtml">Message brokers</span></h3>
<p><span class="koboSpan" id="kobo.255.1" xmlns="http://www.w3.org/1999/xhtml">A message broker is a program that allows us to send (</span><strong><span class="koboSpan" id="kobo.256.1" xmlns="http://www.w3.org/1999/xhtml">publish</span></strong><span class="koboSpan" id="kobo.257.1" xmlns="http://www.w3.org/1999/xhtml">) and receive (</span><strong><span class="koboSpan" id="kobo.258.1" xmlns="http://www.w3.org/1999/xhtml">subscribe</span></strong><span class="koboSpan" id="kobo.259.1" xmlns="http://www.w3.org/1999/xhtml">) messages. </span><span class="koboSpan" id="kobo.259.2" xmlns="http://www.w3.org/1999/xhtml">It plays the mediator role at scale, allowing multiple applications to talk to each other without knowing each other (</span><strong><span class="koboSpan" id="kobo.260.1" xmlns="http://www.w3.org/1999/xhtml">loose coupling</span></strong><span class="koboSpan" id="kobo.261.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.261.2" xmlns="http://www.w3.org/1999/xhtml">The message broker is usually the central piece of any event-based distributed system that implements the publish-subscribe pattern.An application (</span><strong><span class="koboSpan" id="kobo.262.1" xmlns="http://www.w3.org/1999/xhtml">publisher</span></strong><span class="koboSpan" id="kobo.263.1" xmlns="http://www.w3.org/1999/xhtml">) publishes messages to topics, while other applications (</span><strong><span class="koboSpan" id="kobo.264.1" xmlns="http://www.w3.org/1999/xhtml">subscribers</span></strong><span class="koboSpan" id="kobo.265.1" xmlns="http://www.w3.org/1999/xhtml">) receive messages from those topics. </span><span class="koboSpan" id="kobo.265.2" xmlns="http://www.w3.org/1999/xhtml">The notion of </span><strong><span class="koboSpan" id="kobo.266.1" xmlns="http://www.w3.org/1999/xhtml">topics</span></strong><span class="koboSpan" id="kobo.267.1" xmlns="http://www.w3.org/1999/xhtml"> may differ from one protocol or system to another, but all systems I know have a topic-like concept to route messages to the right place. </span><span class="koboSpan" id="kobo.267.2" xmlns="http://www.w3.org/1999/xhtml">For example, you can publish to the </span><code><span class="koboSpan" id="kobo.268.1" xmlns="http://www.w3.org/1999/xhtml">Devices</span></code><span class="koboSpan" id="kobo.269.1" xmlns="http://www.w3.org/1999/xhtml"> topic using Kafka, but to </span><code><span class="koboSpan" id="kobo.270.1" xmlns="http://www.w3.org/1999/xhtml">devices/abc-123/do-something</span></code><span class="koboSpan" id="kobo.271.1" xmlns="http://www.w3.org/1999/xhtml"> using MQTT.How you name your topics depends significantly on the system you are using and the scale of your installation. </span><span class="koboSpan" id="kobo.271.2" xmlns="http://www.w3.org/1999/xhtml">For example, MQTT is a lightweight event broker recommending a path-like naming convention. </span><span class="koboSpan" id="kobo.271.3" xmlns="http://www.w3.org/1999/xhtml">On the other hand, Apache Kafka is a full-featured event broker and event streaming platform that is not opinionated about topic names, leaving you in charge of that. </span><span class="koboSpan" id="kobo.271.4" xmlns="http://www.w3.org/1999/xhtml">Depending on the scale of your implementation, you can use the entity name as the topic name or may need prefixes to identify who in the enterprise can interact with what part of the system. </span><span class="koboSpan" id="kobo.271.5" xmlns="http://www.w3.org/1999/xhtml">Due to the small scale of the examples in the chapter, we stick with simple topic names, making the examples easier to understand.The message broker is responsible for forwarding the messages to the registered recipients. </span><span class="koboSpan" id="kobo.271.6" xmlns="http://www.w3.org/1999/xhtml">The lifetime of those messages can vary by broker or even per individual message or topic.There are multiple message brokers out there using different protocols. </span><span class="koboSpan" id="kobo.271.7" xmlns="http://www.w3.org/1999/xhtml">Some brokers are cloud-based, such as Azure Event Grid. </span><span class="koboSpan" id="kobo.271.8" xmlns="http://www.w3.org/1999/xhtml">Other brokers are lightweight and more suited for IoT, such as Eclipse Mosquitto/MQTT. </span><span class="koboSpan" id="kobo.271.9" xmlns="http://www.w3.org/1999/xhtml">In contrast to MQTT, others are more robust and allow for high-velocity data streaming, such as Apache Kafka.What message broker to use should be based on the requirements of the software you are building. </span><span class="koboSpan" id="kobo.271.10" xmlns="http://www.w3.org/1999/xhtml">Moreover, you are not limited to one broker. </span><span class="koboSpan" id="kobo.271.11" xmlns="http://www.w3.org/1999/xhtml">Nothing stops you from picking a message broker that handles the dialogs between your microservices and using another to handle the dialogs with external IoT devices. </span><span class="koboSpan" id="kobo.271.12" xmlns="http://www.w3.org/1999/xhtml">If you are building a system in Azure, want to go serverless, or prefer paying for SaaS components that scale without investing maintenance time, you can leverage Azure services such as Event Grid, Service Bus, and Queue Storage. </span><span class="koboSpan" id="kobo.271.13" xmlns="http://www.w3.org/1999/xhtml">If you prefer open-source software, you can choose Apache Kafka and even run a fully managed cloud instance as a service using Confluent Cloud if you don’t want to manage your own cluster.</span></p>
</section>
<section class="level3" data-number="20.5.2" id="the-event-sourcing-pattern">
<h3 data-number="20.5.2"><span class="koboSpan" id="kobo.272.1" xmlns="http://www.w3.org/1999/xhtml">The event sourcing pattern</span></h3>
<p><span class="koboSpan" id="kobo.273.1" xmlns="http://www.w3.org/1999/xhtml">Now that we have explored the Publish-Subscribe pattern, learned what an event is, and talked about event brokers, it is time to explore </span><strong><span class="koboSpan" id="kobo.274.1" xmlns="http://www.w3.org/1999/xhtml">how to replay the state of an application</span></strong><span class="koboSpan" id="kobo.275.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.275.2" xmlns="http://www.w3.org/1999/xhtml">To achieve this, we can follow the </span><strong><span class="koboSpan" id="kobo.276.1" xmlns="http://www.w3.org/1999/xhtml">event sourcing pattern</span></strong><span class="koboSpan" id="kobo.277.1" xmlns="http://www.w3.org/1999/xhtml">.The idea behind event sourcing is to </span><strong><span class="koboSpan" id="kobo.278.1" xmlns="http://www.w3.org/1999/xhtml">store a chronological list of events</span></strong><span class="koboSpan" id="kobo.279.1" xmlns="http://www.w3.org/1999/xhtml"> instead of a single entity, where that collection of events becomes the source of truth. </span><span class="koboSpan" id="kobo.279.2" xmlns="http://www.w3.org/1999/xhtml">That way, every single operation is saved in the right order, helping with concurrency. </span><span class="koboSpan" id="kobo.279.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, we could replay all of these events to generate an object’s current state in a new application, allowing us to deploy new microservices more easily.Instead of just storing the data, if the system propagates it using an event broker, other systems can cache some of it as one or more </span><strong><span class="koboSpan" id="kobo.280.1" xmlns="http://www.w3.org/1999/xhtml">materialized views</span></strong><span class="koboSpan" id="kobo.281.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.282.1" xmlns="http://www.w3.org/1999/xhtml">A </span><strong><span class="koboSpan" id="kobo.283.1" xmlns="http://www.w3.org/1999/xhtml">materialized view</span></strong><span class="koboSpan" id="kobo.284.1" xmlns="http://www.w3.org/1999/xhtml"> is a model created and stored for a specific purpose. </span><span class="koboSpan" id="kobo.284.2" xmlns="http://www.w3.org/1999/xhtml">The data can come from one or more sources, improving performance when querying that data. </span><span class="koboSpan" id="kobo.284.3" xmlns="http://www.w3.org/1999/xhtml">For example, the application returns the materialized view instead of querying multiple other systems to acquire the data. </span><span class="koboSpan" id="kobo.284.4" xmlns="http://www.w3.org/1999/xhtml">You can view the materialized view as a cached entity that a microservice stores in its own database.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.285.1" xmlns="http://www.w3.org/1999/xhtml">One of the drawbacks of event sourcing is data consistency. </span><span class="koboSpan" id="kobo.285.2" xmlns="http://www.w3.org/1999/xhtml">There is an unavoidable delay between when a service adds an event to the store and when all the other services update their materialized views. </span><span class="koboSpan" id="kobo.285.3" xmlns="http://www.w3.org/1999/xhtml">We call this phenomenon </span><strong><span class="koboSpan" id="kobo.286.1" xmlns="http://www.w3.org/1999/xhtml">eventual consistency</span></strong><span class="koboSpan" id="kobo.287.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
<blockquote>
<p><strong><span class="koboSpan" id="kobo.288.1" xmlns="http://www.w3.org/1999/xhtml">Eventual consistency</span></strong><span class="koboSpan" id="kobo.289.1" xmlns="http://www.w3.org/1999/xhtml"> means that the data will be consistent at some point in the future, but not outright. </span><span class="koboSpan" id="kobo.289.2" xmlns="http://www.w3.org/1999/xhtml">The delay can be from a few milliseconds to much longer, but the goal is to keep that delay as small as possible.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.290.1" xmlns="http://www.w3.org/1999/xhtml">Another drawback is the complexity of creating such a system compared to a single application that queries a single database. </span><span class="koboSpan" id="kobo.290.2" xmlns="http://www.w3.org/1999/xhtml">Like the microservices architecture, event sourcing is not just rainbows and unicorns. </span><span class="koboSpan" id="kobo.290.3" xmlns="http://www.w3.org/1999/xhtml">It comes at a price: </span><strong><span class="koboSpan" id="kobo.291.1" xmlns="http://www.w3.org/1999/xhtml">operational complexity</span></strong><span class="koboSpan" id="kobo.292.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.293.1" xmlns="http://www.w3.org/1999/xhtml">In a microservices architecture, each piece is smaller, but gluing them together has a cost. </span><span class="koboSpan" id="kobo.293.2" xmlns="http://www.w3.org/1999/xhtml">For example, the infrastructure to support microservices is more complex than a monolith (one app and one database). </span><span class="koboSpan" id="kobo.293.3" xmlns="http://www.w3.org/1999/xhtml">The same goes for event sourcing; all applications must subscribe to one or more events, cache data (materialized view), publish events, and more. </span><span class="koboSpan" id="kobo.293.4" xmlns="http://www.w3.org/1999/xhtml">This </span><strong><span class="koboSpan" id="kobo.294.1" xmlns="http://www.w3.org/1999/xhtml">operational complexity</span></strong><span class="koboSpan" id="kobo.295.1" xmlns="http://www.w3.org/1999/xhtml"> represents the shift of complexity from the application code to the operational infrastructure. </span><span class="koboSpan" id="kobo.295.2" xmlns="http://www.w3.org/1999/xhtml">In other words, it requires more work to deploy and maintain multiple microservices and databases and to fight the possible instability of network communication between those external systems than it does for a single application containing all of the code. </span><span class="koboSpan" id="kobo.295.3" xmlns="http://www.w3.org/1999/xhtml">Monoliths are simpler: they work or don’t; they rarely partially work.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.296.1" xmlns="http://www.w3.org/1999/xhtml">A crucial aspect of event sourcing is appending new events to the store and never changing existing events (append-only). </span><span class="koboSpan" id="kobo.296.2" xmlns="http://www.w3.org/1999/xhtml">In a nutshell, microservices communicating using the Pub-Sub pattern publish events, subscribe to topics, and generate materialized views to serve their clients.</span></p>
</section>
<section class="level3" data-number="20.5.3" id="example">
<h3 data-number="20.5.3"><span class="koboSpan" id="kobo.297.1" xmlns="http://www.w3.org/1999/xhtml">Example</span></h3>
<p><span class="koboSpan" id="kobo.298.1" xmlns="http://www.w3.org/1999/xhtml">Let’s explore an example of what could happen if we combine what we just studied. </span><strong><span class="koboSpan" id="kobo.299.1" xmlns="http://www.w3.org/1999/xhtml">Context</span></strong><span class="koboSpan" id="kobo.300.1" xmlns="http://www.w3.org/1999/xhtml">: We need to build a program that manages IoT devices. </span><span class="koboSpan" id="kobo.300.2" xmlns="http://www.w3.org/1999/xhtml">We begin by creating two microservices:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.301.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.302.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwin</span></code><span class="koboSpan" id="kobo.303.1" xmlns="http://www.w3.org/1999/xhtml"> microservice handles an IoT device’s twin’s data (digital representation of the device).</span></li>
<li><span class="koboSpan" id="kobo.304.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.305.1" xmlns="http://www.w3.org/1999/xhtml">Networking</span></code><span class="koboSpan" id="kobo.306.1" xmlns="http://www.w3.org/1999/xhtml"> microservice manages the networking-related information of IoT devices (how to reach a device).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.307.1" xmlns="http://www.w3.org/1999/xhtml">As a visual reference, the final system could look as follows (we cover the </span><code><span class="koboSpan" id="kobo.308.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.309.1" xmlns="http://www.w3.org/1999/xhtml"> microservice later):</span></p>
<figure>
<span class="koboSpan" id="kobo.310.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.8: Three microservices communicating using the Publish-Subscribe pattern" src="../media/file135.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.311.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.8: Three microservices communicating using the Publish-Subscribe pattern</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.312.1" xmlns="http://www.w3.org/1999/xhtml">Here are the user interactions and the published events:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.313.1" xmlns="http://www.w3.org/1999/xhtml">A user creates a twin in the system named Device 1. </span><span class="koboSpan" id="kobo.313.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.314.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwin</span></code><span class="koboSpan" id="kobo.315.1" xmlns="http://www.w3.org/1999/xhtml"> microservice saves the data and publishes the </span><code><span class="koboSpan" id="kobo.316.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwinCreated</span></code><span class="koboSpan" id="kobo.317.1" xmlns="http://www.w3.org/1999/xhtml"> event with the following payload:</span></li>
</ol>
<div class="C1-SHConPACKT">
<pre><code><span class="koboSpan" id="kobo.318.1" xmlns="http://www.w3.org/1999/xhtml">{
    "id": "some id",
    "name": "Device 1",
    "other": "properties go here..."
</span><span class="koboSpan" id="kobo.318.2" xmlns="http://www.w3.org/1999/xhtml">}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.319.1" xmlns="http://www.w3.org/1999/xhtml">In parallel, the </span><code><span class="koboSpan" id="kobo.320.1" xmlns="http://www.w3.org/1999/xhtml">Networking</span></code><span class="koboSpan" id="kobo.321.1" xmlns="http://www.w3.org/1999/xhtml"> microservice must know when a device is created, so it subscribed to the </span><code><span class="koboSpan" id="kobo.322.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwinCreated</span></code><span class="koboSpan" id="kobo.323.1" xmlns="http://www.w3.org/1999/xhtml"> event. </span><span class="koboSpan" id="kobo.323.2" xmlns="http://www.w3.org/1999/xhtml">When a new device is created, the </span><code><span class="koboSpan" id="kobo.324.1" xmlns="http://www.w3.org/1999/xhtml">Networking</span></code><span class="koboSpan" id="kobo.325.1" xmlns="http://www.w3.org/1999/xhtml"> microservice creates default networking information for that device in its database; the default is </span><code><span class="koboSpan" id="kobo.326.1" xmlns="http://www.w3.org/1999/xhtml">unknown</span></code><span class="koboSpan" id="kobo.327.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.327.2" xmlns="http://www.w3.org/1999/xhtml">This way, the </span><code><span class="koboSpan" id="kobo.328.1" xmlns="http://www.w3.org/1999/xhtml">Networking</span></code><span class="koboSpan" id="kobo.329.1" xmlns="http://www.w3.org/1999/xhtml"> microservice knows what devices exist or not:</span></p>
<figure>
<span class="koboSpan" id="kobo.330.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.9: A workflow representing the creation of a device twin and its default networking information" src="../media/file136.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.331.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.9: A workflow representing the creation of a device twin and its default networking information</span></figcaption>
</figure>
<ol>
<li><span class="koboSpan" id="kobo.332.1" xmlns="http://www.w3.org/1999/xhtml">A user then updates the networking information of that device and sets it to </span><code><span class="koboSpan" id="kobo.333.1" xmlns="http://www.w3.org/1999/xhtml">MQTT</span></code><span class="koboSpan" id="kobo.334.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.334.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.335.1" xmlns="http://www.w3.org/1999/xhtml">Networking</span></code><span class="koboSpan" id="kobo.336.1" xmlns="http://www.w3.org/1999/xhtml"> microservice saves the data and publishes the </span><code><span class="koboSpan" id="kobo.337.1" xmlns="http://www.w3.org/1999/xhtml">NetworkingInfoUpdated</span></code><span class="koboSpan" id="kobo.338.1" xmlns="http://www.w3.org/1999/xhtml"> event with the following payload:</span></li>
</ol>
<div class="C1-SHConPACKT">
<pre><code><span class="koboSpan" id="kobo.339.1" xmlns="http://www.w3.org/1999/xhtml">{
    "deviceId": "some id",
    "type": "MQTT",
    "other": "networking properties..."
</span><span class="koboSpan" id="kobo.339.2" xmlns="http://www.w3.org/1999/xhtml">}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.340.1" xmlns="http://www.w3.org/1999/xhtml">This is demonstrated by the following diagram:</span></p>
<figure>
<span class="koboSpan" id="kobo.341.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.10: A workflow representing updating the networking type of a device" src="../media/file137.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.342.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.10: A workflow representing updating the networking type of a device</span></figcaption>
</figure>
<ol>
<li><span class="koboSpan" id="kobo.343.1" xmlns="http://www.w3.org/1999/xhtml">A user changes the device’s display name to </span><code><span class="koboSpan" id="kobo.344.1" xmlns="http://www.w3.org/1999/xhtml">Kitchen Thermostat</span></code><span class="koboSpan" id="kobo.345.1" xmlns="http://www.w3.org/1999/xhtml">, which is more relevant. </span><span class="koboSpan" id="kobo.345.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.346.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwin</span></code><span class="koboSpan" id="kobo.347.1" xmlns="http://www.w3.org/1999/xhtml"> microservice saves the data and publishes the </span><code><span class="koboSpan" id="kobo.348.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwinUpdated</span></code><span class="koboSpan" id="kobo.349.1" xmlns="http://www.w3.org/1999/xhtml"> event with the following payload. </span><span class="koboSpan" id="kobo.349.2" xmlns="http://www.w3.org/1999/xhtml">The payload uses </span><strong><span class="koboSpan" id="kobo.350.1" xmlns="http://www.w3.org/1999/xhtml">JSON patch</span></strong><span class="koboSpan" id="kobo.351.1" xmlns="http://www.w3.org/1999/xhtml"> to publish only the differences instead of the whole object (see the </span><em><span class="koboSpan" id="kobo.352.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></em><span class="koboSpan" id="kobo.353.1" xmlns="http://www.w3.org/1999/xhtml"> section for more information):</span></li>
</ol>
<div class="C1-SHConPACKT">
<pre><code><span class="koboSpan" id="kobo.354.1" xmlns="http://www.w3.org/1999/xhtml">{
    "id": "some id",
    "patches": [
        { "op": "replace", "path": "/name", "value": "Kitchen Thermostat" },
    ]
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.355.1" xmlns="http://www.w3.org/1999/xhtml">The following diagram demonstrates this:</span></p>
<figure>
<span class="koboSpan" id="kobo.356.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.11: A workflow representing a user updating the name of the device to Kitchen Thermostat" src="../media/file138.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.357.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.11: A workflow representing a user updating the name of the device to Kitchen Thermostat</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.358.1" xmlns="http://www.w3.org/1999/xhtml">From there, let’s say another team designed and built a new microservice that organizes the devices at physical locations. </span><span class="koboSpan" id="kobo.358.2" xmlns="http://www.w3.org/1999/xhtml">This new </span><code><span class="koboSpan" id="kobo.359.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.360.1" xmlns="http://www.w3.org/1999/xhtml"> microservice allows users to visualize their devices’ location on a map, such as a map of their house.The </span><code><span class="koboSpan" id="kobo.361.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.362.1" xmlns="http://www.w3.org/1999/xhtml"> microservice subscribes to all three events to manage its materialized view, like this:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.363.1" xmlns="http://www.w3.org/1999/xhtml">When receiving a </span><code><span class="koboSpan" id="kobo.364.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwinCreated</span></code><span class="koboSpan" id="kobo.365.1" xmlns="http://www.w3.org/1999/xhtml"> event, it saves its unique identifier and display name.</span></li>
<li><span class="koboSpan" id="kobo.366.1" xmlns="http://www.w3.org/1999/xhtml">When receiving a </span><code><span class="koboSpan" id="kobo.367.1" xmlns="http://www.w3.org/1999/xhtml">NetworkingInfoUpdated</span></code><span class="koboSpan" id="kobo.368.1" xmlns="http://www.w3.org/1999/xhtml"> event, it saves the communication type.</span></li>
<li><span class="koboSpan" id="kobo.369.1" xmlns="http://www.w3.org/1999/xhtml">When receiving a </span><code><span class="koboSpan" id="kobo.370.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwinUpdated</span></code><span class="koboSpan" id="kobo.371.1" xmlns="http://www.w3.org/1999/xhtml"> event, it updates the device’s display name.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.372.1" xmlns="http://www.w3.org/1999/xhtml">When the service is deployed for the first time, it replays all events from the beginning (</span><strong><span class="koboSpan" id="kobo.373.1" xmlns="http://www.w3.org/1999/xhtml">event sourcing</span></strong><span class="koboSpan" id="kobo.374.1" xmlns="http://www.w3.org/1999/xhtml">); here is what happens:</span></p>
<ol>
<li><code><span class="koboSpan" id="kobo.375.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.376.1" xmlns="http://www.w3.org/1999/xhtml"> receives the </span><code><span class="koboSpan" id="kobo.377.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwinCreated</span></code><span class="koboSpan" id="kobo.378.1" xmlns="http://www.w3.org/1999/xhtml"> event and creates the following model for that object:</span></li>
</ol>
<div class="C1-SHConPACKT">
<pre><code><span class="koboSpan" id="kobo.379.1" xmlns="http://www.w3.org/1999/xhtml">{
    "device": {
        "id": "some id",
        "name": "Device 1"
    },
    "networking": {},
    "location": {...}
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.380.1" xmlns="http://www.w3.org/1999/xhtml">The following diagram demonstrates this:</span></p>
<figure>
<span class="koboSpan" id="kobo.381.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.12: The DeviceLocation microservice replaying the DeviceTwinCreated event to create its materialized view of the device twin" src="../media/file139.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.382.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.12: The DeviceLocation microservice replaying the DeviceTwinCreated event to create its materialized view of the device twin</span></figcaption>
</figure>
<ol>
<li><span class="koboSpan" id="kobo.383.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.384.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.385.1" xmlns="http://www.w3.org/1999/xhtml"> microservice receives the </span><code><span class="koboSpan" id="kobo.386.1" xmlns="http://www.w3.org/1999/xhtml">NetworkingInfoUpdated</span></code><span class="koboSpan" id="kobo.387.1" xmlns="http://www.w3.org/1999/xhtml"> event, which updates the networking type to </span><code><span class="koboSpan" id="kobo.388.1" xmlns="http://www.w3.org/1999/xhtml">MQTT</span></code><span class="koboSpan" id="kobo.389.1" xmlns="http://www.w3.org/1999/xhtml">, leading to the following:</span></li>
</ol>
<div class="C1-SHConPACKT">
<pre><code><span class="koboSpan" id="kobo.390.1" xmlns="http://www.w3.org/1999/xhtml">{
    "device": {
        "id": "some id",
        "name": "Device 1"
    },
    "networking": {
        "type": "MQTT"
    },
    "location": {...}
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.391.1" xmlns="http://www.w3.org/1999/xhtml">The following diagram demonstrates this:</span></p>
<figure>
<span class="koboSpan" id="kobo.392.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.13: The DeviceLocation microservice replaying the NetworkingInfoUpdated event to update its materialized view of the device twin" src="../media/file140.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.393.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.13: The DeviceLocation microservice replaying the NetworkingInfoUpdated event to update its materialized view of the device twin</span></figcaption>
</figure>
<ol>
<li><span class="koboSpan" id="kobo.394.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.395.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.396.1" xmlns="http://www.w3.org/1999/xhtml"> microservice receives the </span><code><span class="koboSpan" id="kobo.397.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwinUpdated</span></code><span class="koboSpan" id="kobo.398.1" xmlns="http://www.w3.org/1999/xhtml"> event, updating the device’s name. </span><span class="koboSpan" id="kobo.398.2" xmlns="http://www.w3.org/1999/xhtml">The final model looks like this:</span></li>
</ol>
<div class="C1-SHConPACKT">
<pre><code><span class="koboSpan" id="kobo.399.1" xmlns="http://www.w3.org/1999/xhtml">{
    "device": {
        "id": "some id",
        "name": "Kitchen Thermostat"
    },
    "networking": {
        "type": "MQTT"
    },
    "location": {...}
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.400.1" xmlns="http://www.w3.org/1999/xhtml">The following diagram demonstrates this:</span></p>
<figure>
<span class="koboSpan" id="kobo.401.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.14: The DeviceLocation microservice replaying the DeviceTwinUpdated event to update its materialized view of the device twin" src="../media/file141.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.402.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.14: The DeviceLocation microservice replaying the DeviceTwinUpdated event to update its materialized view of the device twin</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.403.1" xmlns="http://www.w3.org/1999/xhtml">From there, the </span><code><span class="koboSpan" id="kobo.404.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.405.1" xmlns="http://www.w3.org/1999/xhtml"> microservice is initialized and ready. </span><span class="koboSpan" id="kobo.405.2" xmlns="http://www.w3.org/1999/xhtml">Users could set the kitchen thermostat’s location on the map or continue using the other microservices. </span><span class="koboSpan" id="kobo.405.3" xmlns="http://www.w3.org/1999/xhtml">When a user queries the </span><code><span class="koboSpan" id="kobo.406.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.407.1" xmlns="http://www.w3.org/1999/xhtml"> microservice for information about </span><code><span class="koboSpan" id="kobo.408.1" xmlns="http://www.w3.org/1999/xhtml">Kitchen Thermostat</span></code><span class="koboSpan" id="kobo.409.1" xmlns="http://www.w3.org/1999/xhtml">, it displays the </span><strong><span class="koboSpan" id="kobo.410.1" xmlns="http://www.w3.org/1999/xhtml">materialized view</span></strong><span class="koboSpan" id="kobo.411.1" xmlns="http://www.w3.org/1999/xhtml">, which contains all the required information without sending external requests.With that in mind, we could spawn new instances of the </span><code><span class="koboSpan" id="kobo.412.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.413.1" xmlns="http://www.w3.org/1999/xhtml"> microservice or other microservices, and they could generate their materialized views from past events—all of that with very limited to no knowledge of other microservices. </span><span class="koboSpan" id="kobo.413.2" xmlns="http://www.w3.org/1999/xhtml">In this type of architecture, a microservice can only know about events, not the other microservices. </span><span class="koboSpan" id="kobo.413.3" xmlns="http://www.w3.org/1999/xhtml">How a microservice handles events should be relevant only to that microservice, never to the others. </span><span class="koboSpan" id="kobo.413.4" xmlns="http://www.w3.org/1999/xhtml">The same applies to both publishers and subscribers.This example illustrates the event sourcing pattern, integration events, the materialized view, the use of a message broker, and the Publish-Subscribe pattern.In contrast, using direct communication (HTTP, gRPC, and so on) would look like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.414.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.15: Three microservices communicating directly with one another" src="../media/file142.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.415.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.15: Three microservices communicating directly with one another</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.416.1" xmlns="http://www.w3.org/1999/xhtml">If we compare both approaches by looking at the first diagram (</span><em><span class="koboSpan" id="kobo.417.1" xmlns="http://www.w3.org/1999/xhtml">Figure 16.7</span></em><span class="koboSpan" id="kobo.418.1" xmlns="http://www.w3.org/1999/xhtml">), we can see that the message broker plays the role of a </span><strong><span class="koboSpan" id="kobo.419.1" xmlns="http://www.w3.org/1999/xhtml">mediator</span></strong><span class="koboSpan" id="kobo.420.1" xmlns="http://www.w3.org/1999/xhtml"> and breaks the direct coupling between the microservices. </span><span class="koboSpan" id="kobo.420.2" xmlns="http://www.w3.org/1999/xhtml">By looking at the preceding diagram (</span><em><span class="koboSpan" id="kobo.421.1" xmlns="http://www.w3.org/1999/xhtml">Figure 16.14</span></em><span class="koboSpan" id="kobo.422.1" xmlns="http://www.w3.org/1999/xhtml">), we can see the tight coupling between the microservices, where the </span><code><span class="koboSpan" id="kobo.423.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.424.1" xmlns="http://www.w3.org/1999/xhtml"> microservice would need to interact with the </span><code><span class="koboSpan" id="kobo.425.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwin</span></code><span class="koboSpan" id="kobo.426.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.427.1" xmlns="http://www.w3.org/1999/xhtml">Networking</span></code><span class="koboSpan" id="kobo.428.1" xmlns="http://www.w3.org/1999/xhtml"> microservices directly to build the equivalent of its materialized view. </span><span class="koboSpan" id="kobo.428.2" xmlns="http://www.w3.org/1999/xhtml">Furthermore, the </span><code><span class="koboSpan" id="kobo.429.1" xmlns="http://www.w3.org/1999/xhtml">DeviceLocation</span></code><span class="koboSpan" id="kobo.430.1" xmlns="http://www.w3.org/1999/xhtml"> microservice translates one interaction into three since the </span><code><span class="koboSpan" id="kobo.431.1" xmlns="http://www.w3.org/1999/xhtml">Networking</span></code><span class="koboSpan" id="kobo.432.1" xmlns="http://www.w3.org/1999/xhtml"> microservice also talks to the </span><code><span class="koboSpan" id="kobo.433.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwin</span></code><span class="koboSpan" id="kobo.434.1" xmlns="http://www.w3.org/1999/xhtml"> microservice, leading to indirect tight coupling between microservices, which can negatively impact performance.Suppose eventual consistency is not an option, or the Publish-Subscribe pattern cannot be applied or could be too hard to apply to your scenario. </span><span class="koboSpan" id="kobo.434.2" xmlns="http://www.w3.org/1999/xhtml">In this case, microservices can directly call each other. </span><span class="koboSpan" id="kobo.434.3" xmlns="http://www.w3.org/1999/xhtml">They can achieve this using HTTP, gRPC, or any other means that best suits that particular system’s needs.I won’t be covering this topic in this book, but one thing to be careful of when calling microservices directly is the indirect call chain that could bubble up fast. </span><span class="koboSpan" id="kobo.434.4" xmlns="http://www.w3.org/1999/xhtml">You don’t want your microservices to create a super deep call chain, or your system will likely become very slow. </span><span class="koboSpan" id="kobo.434.5" xmlns="http://www.w3.org/1999/xhtml">Here is an abstract example of what could happen to illustrate what I mean:</span></p>
<figure>
<span class="koboSpan" id="kobo.435.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.16: A user calling microservice A, which then triggers a chain reaction of subsequent calls, leading to disastrous performance" src="../media/file143.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.436.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.16: A user calling microservice A, which then triggers a chain reaction of subsequent calls, leading to disastrous performance</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.437.1" xmlns="http://www.w3.org/1999/xhtml">In terms of the preceding diagram, let’s think about failures (for one). </span><span class="koboSpan" id="kobo.437.2" xmlns="http://www.w3.org/1999/xhtml">If microservice C goes offline, the whole request ends with an error. </span><span class="koboSpan" id="kobo.437.3" xmlns="http://www.w3.org/1999/xhtml">No matter the measures we put in place to mitigate the risks, if microservice C cannot recover, the system will remain down; goodbye to microservices’ promise of independence. </span><span class="koboSpan" id="kobo.437.4" xmlns="http://www.w3.org/1999/xhtml">Another issue is latency: ten calls are made for a single operation; that takes time.Such chatty systems have most likely emerged from an incorrect domain modeling phase, leading to multiple microservices working together to handle trivial tasks. </span><span class="koboSpan" id="kobo.437.5" xmlns="http://www.w3.org/1999/xhtml">Now think of </span><em><span class="koboSpan" id="kobo.438.1" xmlns="http://www.w3.org/1999/xhtml">Figure 16.15</span></em><span class="koboSpan" id="kobo.439.1" xmlns="http://www.w3.org/1999/xhtml"> but with 500 microservices instead of 6. </span><span class="koboSpan" id="kobo.439.2" xmlns="http://www.w3.org/1999/xhtml">That could be catastrophic!This type of interdependent microservices system is known as the </span><strong><span class="koboSpan" id="kobo.440.1" xmlns="http://www.w3.org/1999/xhtml">Death Star anti-pattern</span></strong><span class="koboSpan" id="kobo.441.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.441.2" xmlns="http://www.w3.org/1999/xhtml">We can see the Death Star anti-pattern as a </span><em><span class="koboSpan" id="kobo.442.1" xmlns="http://www.w3.org/1999/xhtml">distributed big ball of mud</span></em><span class="koboSpan" id="kobo.443.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.443.2" xmlns="http://www.w3.org/1999/xhtml">One way to avoid such pitfalls is to ensure that the bounded contexts are well segregated and that responsibilities are well distributed. </span><span class="koboSpan" id="kobo.443.3" xmlns="http://www.w3.org/1999/xhtml">A good domain model should allow you to avoid building a Death Star and create the “most correct” system possible instead. </span><span class="koboSpan" id="kobo.443.4" xmlns="http://www.w3.org/1999/xhtml">No matter the type of architecture you choose, if you are not building the right thing, you may end up with a big ball of mud or a Death Star. </span><span class="koboSpan" id="kobo.443.5" xmlns="http://www.w3.org/1999/xhtml">Of course, the Pub-Sub pattern and EDA can help us break the tight coupling between microservices to avoid such issues.</span></p>
</section>
<section class="level3" data-number="20.5.4" id="conclusion-30">
<h3 data-number="20.5.4"><span class="koboSpan" id="kobo.444.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.445.1" xmlns="http://www.w3.org/1999/xhtml">The Publish-Subscribe pattern uses events to break tight coupling between parts of an application. </span><span class="koboSpan" id="kobo.445.2" xmlns="http://www.w3.org/1999/xhtml">In a microservices architecture, we can use a message broker and integration events to allow microservices to talk to each other indirectly. </span><span class="koboSpan" id="kobo.445.3" xmlns="http://www.w3.org/1999/xhtml">The different pieces are now coupled with the data contract representing the event (its schema) instead of each other, leading to a potential gain in flexibility. </span><span class="koboSpan" id="kobo.445.4" xmlns="http://www.w3.org/1999/xhtml">One risk of this type of architecture is breaking events’ consumers by publishing breaking changes in the event’s format without letting them know or without having events versioning in place so they can adapt to the changes. </span><span class="koboSpan" id="kobo.445.5" xmlns="http://www.w3.org/1999/xhtml">Therefore, it is critical to think about event schema evolutions thoroughly. </span><span class="koboSpan" id="kobo.445.6" xmlns="http://www.w3.org/1999/xhtml">Most systems evolve, as will events, but since schemas are the glue between systems in a Publish-Subscribe model, it is essential to treat them as such. </span><span class="koboSpan" id="kobo.445.7" xmlns="http://www.w3.org/1999/xhtml">Some brokers, like Apache Kafka, offer a schema store and other mechanisms to help with these; some don’t.Then, we can leverage the event sourcing pattern to persist those events, allowing new microservices to populate their databases by replaying past events. </span><span class="koboSpan" id="kobo.445.8" xmlns="http://www.w3.org/1999/xhtml">The event store then becomes the source of truth of those systems. </span><span class="koboSpan" id="kobo.445.9" xmlns="http://www.w3.org/1999/xhtml">Event sourcing can also become very handy for tracing and auditing purposes since the whole history is persisted. </span><span class="koboSpan" id="kobo.445.10" xmlns="http://www.w3.org/1999/xhtml">We can also replay messages to recreate the system’s state at any given point in time, making it very powerful for debugging purposes. </span><span class="koboSpan" id="kobo.445.11" xmlns="http://www.w3.org/1999/xhtml">The storage size requirement for the event store is something to consider before going down the event sourcing path. </span><span class="koboSpan" id="kobo.445.12" xmlns="http://www.w3.org/1999/xhtml">The event store could grow quite large because we have been keeping all messages since the beginning of time and could grow fast based on the number of events sent. </span><span class="koboSpan" id="kobo.445.13" xmlns="http://www.w3.org/1999/xhtml">You could compact the history to reduce the data size but lose part of the history. </span><span class="koboSpan" id="kobo.445.14" xmlns="http://www.w3.org/1999/xhtml">Once again, you must decide based on the requirements and ask yourself the appropriate questions. </span><span class="koboSpan" id="kobo.445.15" xmlns="http://www.w3.org/1999/xhtml">For example, is it acceptable to lose part of the history? </span><span class="koboSpan" id="kobo.445.16" xmlns="http://www.w3.org/1999/xhtml">How long should we keep the data? </span><span class="koboSpan" id="kobo.445.17" xmlns="http://www.w3.org/1999/xhtml">Do we want to keep the original data in cheaper storage if we need it later? </span><span class="koboSpan" id="kobo.445.18" xmlns="http://www.w3.org/1999/xhtml">Do we even need replaying capabilities? </span><span class="koboSpan" id="kobo.445.19" xmlns="http://www.w3.org/1999/xhtml">Can we afford to keep all the data forever? </span><span class="koboSpan" id="kobo.445.20" xmlns="http://www.w3.org/1999/xhtml">What are the data retention policies or regulations the system must follow? </span><span class="koboSpan" id="kobo.445.21" xmlns="http://www.w3.org/1999/xhtml">Craft your list of questions based on the specific business problem you want to solve. </span><span class="koboSpan" id="kobo.445.22" xmlns="http://www.w3.org/1999/xhtml">This advice applies to all aspects of software engineering: clearly define the business problem first, then find how to fix it. </span><span class="koboSpan" id="kobo.445.23" xmlns="http://www.w3.org/1999/xhtml">Such patterns can be compelling but take time to learn and implement. </span><span class="koboSpan" id="kobo.445.24" xmlns="http://www.w3.org/1999/xhtml">Like message queues, cloud providers offer fully managed brokers as a service. </span><span class="koboSpan" id="kobo.445.25" xmlns="http://www.w3.org/1999/xhtml">Those can be faster to get started with than building and maintaining your own infrastructure. </span><span class="koboSpan" id="kobo.445.26" xmlns="http://www.w3.org/1999/xhtml">If building servers is your thing, you can use open-source software to “economically” build your stack or pay for managed instances of such software to save yourself the trouble. </span><span class="koboSpan" id="kobo.445.27" xmlns="http://www.w3.org/1999/xhtml">The same tips as with message queues apply here; for example, you can leverage a managed service for your production environment and a local version on the developer’s machine.Apache Kafka is one of the most popular event brokers that enables advanced functionalities like event streaming. </span><span class="koboSpan" id="kobo.445.28" xmlns="http://www.w3.org/1999/xhtml">Kafka has partially and fully managed cloud offerings like Confluent Cloud. </span><span class="koboSpan" id="kobo.445.29" xmlns="http://www.w3.org/1999/xhtml">Redis Pub/Sub is another open-source project with fully managed cloud offerings. </span><span class="koboSpan" id="kobo.445.30" xmlns="http://www.w3.org/1999/xhtml">Redis is also a key-value store trendy for distributed caching scenarios. </span><span class="koboSpan" id="kobo.445.31" xmlns="http://www.w3.org/1999/xhtml">Other offerings are (but are not limited to) Solace PubSub+, RabbitMQ, and ActiveMQ. </span><span class="koboSpan" id="kobo.445.32" xmlns="http://www.w3.org/1999/xhtml">Once again, I suggest comparing the offerings with your requirements to make the best choice for your scenarios.Now, let’s see how the Publish-Subscribe pattern can help us follow the </span><strong><span class="koboSpan" id="kobo.446.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.447.1" xmlns="http://www.w3.org/1999/xhtml"> principles at cloud-scale:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.448.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.449.1" xmlns="http://www.w3.org/1999/xhtml">: Helps centralize and divide responsibilities between applications or components without them directly knowing each other, breaking tight coupling.</span></li>
<li><strong><span class="koboSpan" id="kobo.450.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.451.1" xmlns="http://www.w3.org/1999/xhtml">: Allows us to change how publishers and subscribers behave without directly impacting the other microservices (breaking tight coupling between them).</span></li>
<li><strong><span class="koboSpan" id="kobo.452.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.453.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
<li><strong><span class="koboSpan" id="kobo.454.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.455.1" xmlns="http://www.w3.org/1999/xhtml">: Each event can be as small as needed, leading to multiple smaller communication interfaces (data contracts).</span></li>
<li><strong><span class="koboSpan" id="kobo.456.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.457.1" xmlns="http://www.w3.org/1999/xhtml">: The microservices depend on events (abstractions) instead of concretions (the other microservices), breaking tight coupling between them and inverting the dependency flow.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.458.1" xmlns="http://www.w3.org/1999/xhtml">As you may have noticed, pub-sub is very similar to message queues. </span><span class="koboSpan" id="kobo.458.2" xmlns="http://www.w3.org/1999/xhtml">The main difference is the way messages are read and dispatched:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.459.1" xmlns="http://www.w3.org/1999/xhtml">Queues: Messages are pulled one at a time, consumed by one service, and then disappear.</span></li>
<li><span class="koboSpan" id="kobo.460.1" xmlns="http://www.w3.org/1999/xhtml">Pub-Sub: Messages are read in order and sent to all consumers instead of to only one, like with queues.</span></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.461.1" xmlns="http://www.w3.org/1999/xhtml">I intentionally kept the </span><strong><span class="koboSpan" id="kobo.462.1" xmlns="http://www.w3.org/1999/xhtml">Observer design pattern</span></strong><span class="koboSpan" id="kobo.463.1" xmlns="http://www.w3.org/1999/xhtml"> out of this book since we rarely need it in .NET. </span><span class="koboSpan" id="kobo.463.2" xmlns="http://www.w3.org/1999/xhtml">C# offers multicast events, which are well-versed in replacing the Observer pattern (in most cases). </span><span class="koboSpan" id="kobo.463.3" xmlns="http://www.w3.org/1999/xhtml">If you don’t know the Observer pattern, don’t worry–chances are, you will never need it. </span><span class="koboSpan" id="kobo.463.4" xmlns="http://www.w3.org/1999/xhtml">Nevertheless, if you already know the Observer pattern, here are the differences between it and the Pub-Sub pattern.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.464.1" xmlns="http://www.w3.org/1999/xhtml">In the Observer pattern, the subject keeps a list of its observers, creating direct knowledge of their existence. </span><span class="koboSpan" id="kobo.464.2" xmlns="http://www.w3.org/1999/xhtml">Concrete observers also often know about the subject, leading to even more knowledge of other entities and more coupling.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.465.1" xmlns="http://www.w3.org/1999/xhtml">In the Pub-Sub pattern, the publisher is not aware of the subscribers; it is only aware of the message broker. </span><span class="koboSpan" id="kobo.465.2" xmlns="http://www.w3.org/1999/xhtml">The subscribers are not aware of the publishers either, only of the message broker. </span><span class="koboSpan" id="kobo.465.3" xmlns="http://www.w3.org/1999/xhtml">The publishers and subscribers are linked only through the data contract of the messages they publish or receive.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.466.1" xmlns="http://www.w3.org/1999/xhtml">We could view the Pub-Sub pattern as the distributed evolution of the Observer pattern or, more precisely, like adding a mediator to the Observer pattern.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.467.1" xmlns="http://www.w3.org/1999/xhtml">Next, we explore some patterns that directly call other microservices by visiting a new kind of </span><strong><span class="koboSpan" id="kobo.468.1" xmlns="http://www.w3.org/1999/xhtml">Façade</span></strong><span class="koboSpan" id="kobo.469.1" xmlns="http://www.w3.org/1999/xhtml">: the </span><strong><span class="koboSpan" id="kobo.470.1" xmlns="http://www.w3.org/1999/xhtml">Gateway</span></strong><span class="koboSpan" id="kobo.471.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</section>
</section>
<section class="level2" data-number="20.6" id="introducing-gateway-patterns">
<h2 data-number="20.6"><span class="koboSpan" id="kobo.472.1" xmlns="http://www.w3.org/1999/xhtml">Introducing Gateway patterns</span></h2>
<p><span class="koboSpan" id="kobo.473.1" xmlns="http://www.w3.org/1999/xhtml">When building a microservices-oriented system, the number of services grows with the number of features; the bigger the system, the more microservices you have.When you think about a user interface that has to interact with such a system, this can become tedious, complex, and inefficient (dev-wise and speed-wise). </span><span class="koboSpan" id="kobo.473.2" xmlns="http://www.w3.org/1999/xhtml">Gateways can help us achieve the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.474.1" xmlns="http://www.w3.org/1999/xhtml">Hide complexity by routing requests to the appropriate services.</span></li>
<li><span class="koboSpan" id="kobo.475.1" xmlns="http://www.w3.org/1999/xhtml">Hide complexity by aggregating responses and translating one external request into many internal ones.</span></li>
<li><span class="koboSpan" id="kobo.476.1" xmlns="http://www.w3.org/1999/xhtml">Hide complexity by exposing only the subset of features that a client needs.</span></li>
<li><span class="koboSpan" id="kobo.477.1" xmlns="http://www.w3.org/1999/xhtml">Translate a request into another protocol.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.478.1" xmlns="http://www.w3.org/1999/xhtml">A gateway can also centralize different processes, such as logging and caching requests, authenticating and authorizing users and clients, enforcing request rate limits, and other similar policies.You can see gateways as façades, but instead of being a class in a program, it is a program of its own, shielding other programs. </span><span class="koboSpan" id="kobo.478.2" xmlns="http://www.w3.org/1999/xhtml">There are multiple variants of the Gateway pattern, and we explore many of them here.Regardless of the type of gateway you need, you can code it yourself or leverage existing tools to speed up the development process.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.479.1" xmlns="http://www.w3.org/1999/xhtml">Beware that there is a strong chance that your homemade gateway version 1.0 has more flaws than a proven solution. </span><span class="koboSpan" id="kobo.479.2" xmlns="http://www.w3.org/1999/xhtml">This tip is not only applicable to gateways but to most complex systems. </span><span class="koboSpan" id="kobo.479.3" xmlns="http://www.w3.org/1999/xhtml">That being said, sometimes, no proven solution does exactly what we want, and we have to code it ourselves, which is where the real fun begins!</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.480.1" xmlns="http://www.w3.org/1999/xhtml">An open-source project that could help you out is Ocelot (</span><a href="https://adpg.link/UwiY"><span class="koboSpan" id="kobo.481.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/UwiY</span></a><span class="koboSpan" id="kobo.482.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.482.2" xmlns="http://www.w3.org/1999/xhtml">It is an API gateway written in C# that supports many things that we expect from a gateway. </span><span class="koboSpan" id="kobo.482.3" xmlns="http://www.w3.org/1999/xhtml">You can route requests using configuration or write custom code to create advanced routing rules. </span><span class="koboSpan" id="kobo.482.4" xmlns="http://www.w3.org/1999/xhtml">Since it is open source, you can contribute to it, fork it, and explore the source code if necessary.If you want a managed offering with a long list of features, you can explore Azure API Management (</span><a href="https://adpg.link/8CEX"><span class="koboSpan" id="kobo.483.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/8CEX</span></a><span class="koboSpan" id="kobo.484.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.484.2" xmlns="http://www.w3.org/1999/xhtml">It supports security, load-balancing, routing, and more. </span><span class="koboSpan" id="kobo.484.3" xmlns="http://www.w3.org/1999/xhtml">It also offers a service catalog where teams can consult and manage the APIs with internal teams, partners, and customers.We can see a gateway as a </span><strong><span class="koboSpan" id="kobo.485.1" xmlns="http://www.w3.org/1999/xhtml">reverse proxy</span></strong><span class="koboSpan" id="kobo.486.1" xmlns="http://www.w3.org/1999/xhtml"> that offers advanced functionalities. </span><span class="koboSpan" id="kobo.486.2" xmlns="http://www.w3.org/1999/xhtml">A Gateway fetches the information clients request, which can come from one or more resources, possibly from one or more servers. </span><span class="koboSpan" id="kobo.486.3" xmlns="http://www.w3.org/1999/xhtml">A reverse proxy usually routes a request to only one server. </span><span class="koboSpan" id="kobo.486.4" xmlns="http://www.w3.org/1999/xhtml">A reverse proxy often serves as a load balancer. </span><span class="koboSpan" id="kobo.486.5" xmlns="http://www.w3.org/1999/xhtml">Microsoft released a reverse proxy named YARP, written in C# and open-source (</span><a href="https://adpg.link/YARP"><span class="koboSpan" id="kobo.487.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/YARP</span></a><span class="koboSpan" id="kobo.488.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.488.2" xmlns="http://www.w3.org/1999/xhtml">Microsoft built it for their internal teams. </span><span class="koboSpan" id="kobo.488.3" xmlns="http://www.w3.org/1999/xhtml">YARP is now part of Azure App Service (</span><a href="https://adpg.link/7eu4"><span class="koboSpan" id="kobo.489.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/7eu4</span></a><span class="koboSpan" id="kobo.490.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.490.2" xmlns="http://www.w3.org/1999/xhtml">If YARP does what you need, it seems like a stable enough product to invest in that will evolve and be maintained over time. </span><span class="koboSpan" id="kobo.490.3" xmlns="http://www.w3.org/1999/xhtml">A significant advantage of such a service is the ability to deploy it with your application, optionally as a container, allowing us to use it locally during development.Now, let’s explore a few types of gateways.</span></p>
<section class="level3" data-number="20.6.1" id="gateway-routing-pattern">
<h3 data-number="20.6.1"><span class="koboSpan" id="kobo.491.1" xmlns="http://www.w3.org/1999/xhtml">Gateway Routing pattern</span></h3>
<p><span class="koboSpan" id="kobo.492.1" xmlns="http://www.w3.org/1999/xhtml">We can use this pattern to hide the complexity of our system by having the gateway route requests to the appropriate services.For example, let’s say we have two microservices: one that holds our device data and another that manages device locations. </span><span class="koboSpan" id="kobo.492.2" xmlns="http://www.w3.org/1999/xhtml">We want to show the latest known location of a specific device (</span><code><span class="koboSpan" id="kobo.493.1" xmlns="http://www.w3.org/1999/xhtml">id=102</span></code><span class="koboSpan" id="kobo.494.1" xmlns="http://www.w3.org/1999/xhtml">) and display its name and model.To achieve that, a user requests the web page, and then the web page calls two services (see the following diagram). </span><span class="koboSpan" id="kobo.494.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.495.1" xmlns="http://www.w3.org/1999/xhtml">DeviceTwin</span></code><span class="koboSpan" id="kobo.496.1" xmlns="http://www.w3.org/1999/xhtml"> microservice is accessible from </span><code><span class="koboSpan" id="kobo.497.1" xmlns="http://www.w3.org/1999/xhtml">service1.domain.com</span></code><span class="koboSpan" id="kobo.498.1" xmlns="http://www.w3.org/1999/xhtml">, and the </span><code><span class="koboSpan" id="kobo.499.1" xmlns="http://www.w3.org/1999/xhtml">Location</span></code><span class="koboSpan" id="kobo.500.1" xmlns="http://www.w3.org/1999/xhtml"> microservice is accessible from </span><code><span class="koboSpan" id="kobo.501.1" xmlns="http://www.w3.org/1999/xhtml">service2.domain.com</span></code><span class="koboSpan" id="kobo.502.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.502.2" xmlns="http://www.w3.org/1999/xhtml">From there, the web application must track the two services, their domain name, and their operations. </span><span class="koboSpan" id="kobo.502.3" xmlns="http://www.w3.org/1999/xhtml">The UI has to handle more complexity as we add more microservices. </span><span class="koboSpan" id="kobo.502.4" xmlns="http://www.w3.org/1999/xhtml">Moreover, if we decide to change </span><code><span class="koboSpan" id="kobo.503.1" xmlns="http://www.w3.org/1999/xhtml">service1</span></code><span class="koboSpan" id="kobo.504.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.505.1" xmlns="http://www.w3.org/1999/xhtml">device-twins</span></code><span class="koboSpan" id="kobo.506.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.507.1" xmlns="http://www.w3.org/1999/xhtml">service2</span></code><span class="koboSpan" id="kobo.508.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.509.1" xmlns="http://www.w3.org/1999/xhtml">location</span></code><span class="koboSpan" id="kobo.510.1" xmlns="http://www.w3.org/1999/xhtml">, we’d also need to update the web application. </span><span class="koboSpan" id="kobo.510.2" xmlns="http://www.w3.org/1999/xhtml">If there is only a UI, it is still not so bad, but if we have multiple user interfaces, each has to handle that complexity.Furthermore, if we want to hide the microservices inside a private network, it would be impossible unless all the user interfaces are also part of that private network (which exposes it). </span><span class="koboSpan" id="kobo.510.3" xmlns="http://www.w3.org/1999/xhtml">Here’s the diagram representing the interactions mentioned previously:</span></p>
<figure>
<span class="koboSpan" id="kobo.511.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.17: A web application and a mobile app that are calling two microservices directly" src="../media/file144.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.512.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.17: A web application and a mobile app that are calling two microservices directly</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.513.1" xmlns="http://www.w3.org/1999/xhtml">We can implement a gateway that does the routing for us to fix some of these issues. </span><span class="koboSpan" id="kobo.513.2" xmlns="http://www.w3.org/1999/xhtml">That way, instead of knowing what services are accessible through what sub-domain, the UI only has to know the gateway:</span></p>
<figure>
<span class="koboSpan" id="kobo.514.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.18: A web application and a mobile app that are calling two microservices through a gateway application" src="../media/file145.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.515.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.18: A web application and a mobile app that are calling two microservices through a gateway application</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.516.1" xmlns="http://www.w3.org/1999/xhtml">Of course, this brings some possible issues to the table as the gateway becomes a single point of failure. </span><span class="koboSpan" id="kobo.516.2" xmlns="http://www.w3.org/1999/xhtml">We could consider using a load balancer to ensure we have strong enough availability and fast enough performance. </span><span class="koboSpan" id="kobo.516.3" xmlns="http://www.w3.org/1999/xhtml">Since all requests pass through the gateway, we may also need to scale it up at some point.We should also ensure the gateway supports failure by implementing different resiliency patterns, such as </span><strong><span class="koboSpan" id="kobo.517.1" xmlns="http://www.w3.org/1999/xhtml">Retry</span></strong><span class="koboSpan" id="kobo.518.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.519.1" xmlns="http://www.w3.org/1999/xhtml">Circuit Breaker</span></strong><span class="koboSpan" id="kobo.520.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.520.2" xmlns="http://www.w3.org/1999/xhtml">The chances that an error will occur on the other side of the gateway increase with the number of microservices you deploy and the number of requests sent to those microservices.You can also use a routing gateway to reroute the URI to create easier-to-use URI patterns. </span><span class="koboSpan" id="kobo.520.3" xmlns="http://www.w3.org/1999/xhtml">You can also reroute ports; add, update, or remove HTTP headers; and more. </span><span class="koboSpan" id="kobo.520.4" xmlns="http://www.w3.org/1999/xhtml">Let’s explore the same example but using different URIs. </span><span class="koboSpan" id="kobo.520.5" xmlns="http://www.w3.org/1999/xhtml">Let’s assume the following:</span></p>
<table>
<tbody>
<tr class="odd">
<td><strong><span class="koboSpan" id="kobo.521.1" xmlns="http://www.w3.org/1999/xhtml">Microservice</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.522.1" xmlns="http://www.w3.org/1999/xhtml">URI</span></strong></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.523.1" xmlns="http://www.w3.org/1999/xhtml">API 1 (get a device)</span></td>
<td><code><span class="koboSpan" id="kobo.524.1" xmlns="http://www.w3.org/1999/xhtml">internal.domain.com:8001/{id}</span></code></td>
</tr>
<tr class="odd">
<td><span class="koboSpan" id="kobo.525.1" xmlns="http://www.w3.org/1999/xhtml">API 2 (get a device location)</span></td>
<td><code><span class="koboSpan" id="kobo.526.1" xmlns="http://www.w3.org/1999/xhtml">internal.domain.com:8002/{id}</span></code></td>
</tr>
</tbody>
</table><span class="koboSpan" id="kobo.527.1" xmlns="http://www.w3.org/1999/xhtml">
Table 19.1: Internal microservice URI patterns.
</span><p><span class="koboSpan" id="kobo.528.1" xmlns="http://www.w3.org/1999/xhtml">UI developers would have a harder time remembering what port is leading to what microservice and what is doing what (and who could blame them?). </span><span class="koboSpan" id="kobo.528.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, we could not transfer the requests as we did earlier (only routing the domain). </span><span class="koboSpan" id="kobo.528.3" xmlns="http://www.w3.org/1999/xhtml">We could use the gateway as a way to create memorable URI patterns for developers to consume, like these:</span></p>
<table>
<tbody>
<tr class="odd">
<td><strong><span class="koboSpan" id="kobo.529.1" xmlns="http://www.w3.org/1999/xhtml">Gateway URI</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.530.1" xmlns="http://www.w3.org/1999/xhtml">Microservice URI</span></strong></td>
</tr>
<tr class="even">
<td><code><span class="koboSpan" id="kobo.531.1" xmlns="http://www.w3.org/1999/xhtml">gateway.domain.com/devices/{id}</span></code></td>
<td><code><span class="koboSpan" id="kobo.532.1" xmlns="http://www.w3.org/1999/xhtml">internal.domain.com:8001/{id}</span></code></td>
</tr>
<tr class="odd">
<td><code><span class="koboSpan" id="kobo.533.1" xmlns="http://www.w3.org/1999/xhtml">gateway.domain.com/devices/{id}/location</span></code></td>
<td><code><span class="koboSpan" id="kobo.534.1" xmlns="http://www.w3.org/1999/xhtml">internal.domain.com:8002/{id}</span></code></td>
</tr>
</tbody>
</table><span class="koboSpan" id="kobo.535.1" xmlns="http://www.w3.org/1999/xhtml">
Table 19.1: Memorable URI patterns that are easier to use and semantically meaningful.
</span><p><span class="koboSpan" id="kobo.536.1" xmlns="http://www.w3.org/1999/xhtml">As we can see, we took the ports out of the equation to create usable, meaningful, and easy-to-remember URIs.However, we are still making two requests to the gateway to display one piece of information (the location of a device and its name/model), which leads us to our next Gateway pattern.</span></p>
</section>
<section class="level3" data-number="20.6.2" id="gateway-aggregation-pattern">
<h3 data-number="20.6.2"><span class="koboSpan" id="kobo.537.1" xmlns="http://www.w3.org/1999/xhtml">Gateway Aggregation pattern</span></h3>
<p><span class="koboSpan" id="kobo.538.1" xmlns="http://www.w3.org/1999/xhtml">Another role we can give to a gateway is aggregating requests to hide complexity from its consumers. </span><span class="koboSpan" id="kobo.538.2" xmlns="http://www.w3.org/1999/xhtml">Aggregating multiple requests into one makes it easier for consumers of a microservices system to interact with it; clients need to know about one endpoint instead of multiple. </span><span class="koboSpan" id="kobo.538.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, it moves the chattiness from the client to the gateway, which is closer to the microservices, lowering the many calls’ latency, and thus making the request-response cycle faster.Continuing with our previous example, we have two UI applications that contain a feature to show a device’s location on a map before identifying it using its name/model. </span><span class="koboSpan" id="kobo.538.4" xmlns="http://www.w3.org/1999/xhtml">To achieve this, they must call the device twin endpoint to obtain the device’s name and model and the location endpoint to get its last known location. </span><span class="koboSpan" id="kobo.538.5" xmlns="http://www.w3.org/1999/xhtml">So, two requests to display a small box times two UIs means four requests to maintain a simple feature. </span><span class="koboSpan" id="kobo.538.6" xmlns="http://www.w3.org/1999/xhtml">If we extrapolate, we could end up managing a huge number of HTTP requests for a handful of features.Here is a diagram showing our feature in its current state:</span></p>
<figure>
<span class="koboSpan" id="kobo.539.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.19: A web application and a mobile app that are calling two microservices through a gateway application" src="../media/file146.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.540.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.19: A web application and a mobile app that are calling two microservices through a gateway application</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.541.1" xmlns="http://www.w3.org/1999/xhtml">To remedy this problem, we can apply the Gateway Aggregation pattern to simplify our UIs and offload the responsibility of managing those details to the gateway.By applying the Gateway Aggregation pattern, we end up with the following simplified flow:</span></p>
<figure>
<span class="koboSpan" id="kobo.542.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.20: A gateway that aggregates the response of two requests to serve a single request from both a web application and a mobile app" src="../media/file147.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.543.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.20: A gateway that aggregates the response of two requests to serve a single request from both a web application and a mobile app</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.544.1" xmlns="http://www.w3.org/1999/xhtml">In the previous flow, the Web App calls the Gateway that calls the two APIs, then crafts a response combining the two responses it got from the APIs. </span><span class="koboSpan" id="kobo.544.2" xmlns="http://www.w3.org/1999/xhtml">The Gateway then returns that response to the Web App. </span><span class="koboSpan" id="kobo.544.3" xmlns="http://www.w3.org/1999/xhtml">With that in place, the Web App is loosely coupled with the two APIs while the Gateway plays the intermediary. </span><span class="koboSpan" id="kobo.544.4" xmlns="http://www.w3.org/1999/xhtml">With only one HTTP request, the Web App has all the information it needs, aggregated by the Gateway.Next, let’s explore the steps that occurred. </span><span class="koboSpan" id="kobo.544.5" xmlns="http://www.w3.org/1999/xhtml">The following diagram shows that the Web App makes a single request (1) while the gateway makes two calls (2 and 4). </span><span class="koboSpan" id="kobo.544.6" xmlns="http://www.w3.org/1999/xhtml">In the diagram, the requests are sent in series, but we could have sent them in parallel to speed things up:</span></p>
<figure>
<span class="koboSpan" id="kobo.545.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.21: The order in which the requests take place" src="../media/file148.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.546.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.21: The order in which the requests take place</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.547.1" xmlns="http://www.w3.org/1999/xhtml">Like the routing gateway, an aggregation gateway can become the bottleneck of your application and a single point of failure, so beware of that.Another important point is the latency between the gateway and the internal APIs. </span><span class="koboSpan" id="kobo.547.2" xmlns="http://www.w3.org/1999/xhtml">The clients will wait for every response if the latency is too high. </span><span class="koboSpan" id="kobo.547.3" xmlns="http://www.w3.org/1999/xhtml">So, deploying the gateway close to the microservices it interacts with could become crucial for system performance. </span><span class="koboSpan" id="kobo.547.4" xmlns="http://www.w3.org/1999/xhtml">The gateway can also implement caching to improve performance further and make subsequent requests faster.Next, we explore another type of gateway that creates specialized gateways instead of generic ones.</span></p>
</section>
<section class="level3" data-number="20.6.3" id="backend-for-frontend-pattern">
<h3 data-number="20.6.3"><span class="koboSpan" id="kobo.548.1" xmlns="http://www.w3.org/1999/xhtml">Backend for Frontend pattern</span></h3>
<p><span class="koboSpan" id="kobo.549.1" xmlns="http://www.w3.org/1999/xhtml">The Backend for Frontend (BFF) pattern is yet another variation of the Gateway pattern. </span><span class="koboSpan" id="kobo.549.2" xmlns="http://www.w3.org/1999/xhtml">With Backend for Frontend, instead of building a general-purpose gateway, we build a gateway per user interface (for each application that interacts with the system), lowering the complexity. </span><span class="koboSpan" id="kobo.549.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, it allows for fine-grained control of what endpoints are exposed. </span><span class="koboSpan" id="kobo.549.4" xmlns="http://www.w3.org/1999/xhtml">It removes the chances of app B breaking when changes are made to app A. </span><span class="koboSpan" id="kobo.549.5" xmlns="http://www.w3.org/1999/xhtml">Many optimizations can come out of this pattern, such as sending only the data that’s required for each call instead of sending data that only a few applications are using, saving some bandwidth along the way.Let’s say that our Web App needs to display more data about a device. </span><span class="koboSpan" id="kobo.549.6" xmlns="http://www.w3.org/1999/xhtml">To achieve that, we would need to change the endpoint and send that extra information to the mobile app as well. </span><span class="koboSpan" id="kobo.549.7" xmlns="http://www.w3.org/1999/xhtml">However, the mobile app doesn’t need that information since it doesn’t have room on its screen to display it. </span><span class="koboSpan" id="kobo.549.8" xmlns="http://www.w3.org/1999/xhtml">Next is an updated diagram that replaces the single gateway with two gateways, one per frontend:</span></p>
<figure>
<span class="koboSpan" id="kobo.550.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.22: Two Backend for Frontend gateways; one for the Web App and one for the Mobile App" src="../media/file149.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.551.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.22: Two Backend for Frontend gateways; one for the Web App and one for the Mobile App</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.552.1" xmlns="http://www.w3.org/1999/xhtml">Doing this allows us to develop specific features for each frontend without impacting the other. </span><span class="koboSpan" id="kobo.552.2" xmlns="http://www.w3.org/1999/xhtml">Each gateway now shields its particular frontend from the rest of the system and the other frontend. </span><span class="koboSpan" id="kobo.552.3" xmlns="http://www.w3.org/1999/xhtml">This is the most important benefit this pattern brings: client independence.Once again, the Backend for Frontend pattern is a gateway. </span><span class="koboSpan" id="kobo.552.4" xmlns="http://www.w3.org/1999/xhtml">Like other variations of the Gateway pattern, it can become the bottleneck of its frontend and its single point of failure. </span><span class="koboSpan" id="kobo.552.5" xmlns="http://www.w3.org/1999/xhtml">The good news is that the outage of one BFF gateway limits the impact to a single frontend, shielding the other frontends from that downtime.</span></p>
</section>
<section class="level3" data-number="20.6.4" id="mixing-and-matching-gateways">
<h3 data-number="20.6.4"><span class="koboSpan" id="kobo.553.1" xmlns="http://www.w3.org/1999/xhtml">Mixing and matching gateways</span></h3>
<p><span class="koboSpan" id="kobo.554.1" xmlns="http://www.w3.org/1999/xhtml">Now that we’ve explored three variations of the Gateway pattern, it is important to note that we can mix and match them, either at the codebase level or as multiple microservices.For example, a gateway can be built for a single client (backend for frontend), perform simple routing, and aggregate results.We can also mix them as different applications, for example, by putting multiple backend for frontend gateways in front of a more generic gateway to simplify the development and maintenance of those backend for frontend gateways.Beware that each hop has a cost. </span><span class="koboSpan" id="kobo.554.2" xmlns="http://www.w3.org/1999/xhtml">The more pieces you add between your clients and your microservices, the more time it will take for those clients to receive the response (latency). </span><span class="koboSpan" id="kobo.554.3" xmlns="http://www.w3.org/1999/xhtml">Of course, you can put mechanisms in place to lower that overhead, such as caching or non-HTTP protocols such as gRPC, but you still must consider it. </span><span class="koboSpan" id="kobo.554.4" xmlns="http://www.w3.org/1999/xhtml">That goes for everything, not just gateways.Here is an example illustrating this:</span></p>
<figure>
<span class="koboSpan" id="kobo.555.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.23: A mix of the Gateway patterns" src="../media/file150.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.556.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.23: A mix of the Gateway patterns</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.557.1" xmlns="http://www.w3.org/1999/xhtml">As you’ve possibly guessed, the Generic Gateway is the single point of failure of all applications, while at the same time, each backend for frontend gateway is a point of failure for its specific client.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.558.1" xmlns="http://www.w3.org/1999/xhtml">A </span><strong><span class="koboSpan" id="kobo.559.1" xmlns="http://www.w3.org/1999/xhtml">service mesh</span></strong><span class="koboSpan" id="kobo.560.1" xmlns="http://www.w3.org/1999/xhtml"> is an alternative to help microservices communicate with one another. </span><span class="koboSpan" id="kobo.560.2" xmlns="http://www.w3.org/1999/xhtml">It is a layer, outside of the application, that proxies communications between services. </span><span class="koboSpan" id="kobo.560.3" xmlns="http://www.w3.org/1999/xhtml">Those proxies are injected on top of each service and are referred to as </span><strong><span class="koboSpan" id="kobo.561.1" xmlns="http://www.w3.org/1999/xhtml">sidecars</span></strong><span class="koboSpan" id="kobo.562.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.562.2" xmlns="http://www.w3.org/1999/xhtml">The service mesh can also help with distributed tracing, instrumentation, and system resiliency. </span><span class="koboSpan" id="kobo.562.3" xmlns="http://www.w3.org/1999/xhtml">If your system needs service-to-service communication, a service mesh would be an excellent place to look.</span></p>
</blockquote>
</section>
<section class="level3" data-number="20.6.5" id="conclusion-31">
<h3 data-number="20.6.5"><span class="koboSpan" id="kobo.563.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.564.1" xmlns="http://www.w3.org/1999/xhtml">A gateway is a façade that shields or simplifies access to one or more other services. </span><span class="koboSpan" id="kobo.564.2" xmlns="http://www.w3.org/1999/xhtml">In this section, we explored the following:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.565.1" xmlns="http://www.w3.org/1999/xhtml">Routing</span></strong><span class="koboSpan" id="kobo.566.1" xmlns="http://www.w3.org/1999/xhtml">: This forwards a request from point A to point B (a reverse proxy).</span></li>
<li><strong><span class="koboSpan" id="kobo.567.1" xmlns="http://www.w3.org/1999/xhtml">Aggregation</span></strong><span class="koboSpan" id="kobo.568.1" xmlns="http://www.w3.org/1999/xhtml">: This combines the result of multiple sub-requests into a single response.</span></li>
<li><strong><span class="koboSpan" id="kobo.569.1" xmlns="http://www.w3.org/1999/xhtml">Backend for Frontend</span></strong><span class="koboSpan" id="kobo.570.1" xmlns="http://www.w3.org/1999/xhtml">: This is used in a one-to-one relationship with a frontend.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.571.1" xmlns="http://www.w3.org/1999/xhtml">We can use any microservices pattern, including gateways, and like any other pattern, we can mix and match them. </span><span class="koboSpan" id="kobo.571.2" xmlns="http://www.w3.org/1999/xhtml">Just consider the advantages, but also the drawbacks, that they bring to the table. </span><span class="koboSpan" id="kobo.571.3" xmlns="http://www.w3.org/1999/xhtml">If you can live with them, you’ve got your solution.Gateways often become the single point of failure of the system, so that is a point to consider. </span><span class="koboSpan" id="kobo.571.4" xmlns="http://www.w3.org/1999/xhtml">On the other hand, a gateway can have multiple instances running simultaneously behind a load balancer. </span><span class="koboSpan" id="kobo.571.5" xmlns="http://www.w3.org/1999/xhtml">Moreover, we must also consider the delay added by calling a service that calls another service since that slows down the response time.All in all, a gateway is a great tool to simplify consuming microservices. </span><span class="koboSpan" id="kobo.571.6" xmlns="http://www.w3.org/1999/xhtml">They also allow hiding the microservices topology behind them, possibly even isolated in a private network. </span><span class="koboSpan" id="kobo.571.7" xmlns="http://www.w3.org/1999/xhtml">They can also handle cross-cutting concerns such as security.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.572.1" xmlns="http://www.w3.org/1999/xhtml">It is imperative to use gateways as a requests passthrough and avoid coding business logic into them; gateways are just reverse proxies. </span><span class="koboSpan" id="kobo.572.2" xmlns="http://www.w3.org/1999/xhtml">Think single responsibility principle: a gateway is a façade in front of your microservices cluster. </span><span class="koboSpan" id="kobo.572.3" xmlns="http://www.w3.org/1999/xhtml">Of course, you can unload specific tasks into your gateways like authorization, resiliency (retry policies, for example), and similar cross-cutting concerns, but the business logic must remain in the backend microservices.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.573.1" xmlns="http://www.w3.org/1999/xhtml">The BFF’s role is to simplify the UI, so moving logic from the UI to the BFF is encouraged.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.574.1" xmlns="http://www.w3.org/1999/xhtml">In most cases, I recommend against rolling out your hand-crafted gateway and suggest leveraging existing offerings instead. </span><span class="koboSpan" id="kobo.574.2" xmlns="http://www.w3.org/1999/xhtml">There are many open-source and cloud gateways that you can use in your application. </span><span class="koboSpan" id="kobo.574.3" xmlns="http://www.w3.org/1999/xhtml">Using existing components leaves you more time to implement the business rules that solve the issues your program is trying to tackle.Of course, cloud-based offerings exist, like Azure Application Gateway and Amazon API Gateway. </span><span class="koboSpan" id="kobo.574.4" xmlns="http://www.w3.org/1999/xhtml">Both are extendable with cloud offerings like load balancers and </span><strong><span class="koboSpan" id="kobo.575.1" xmlns="http://www.w3.org/1999/xhtml">web application firewalls</span></strong><span class="koboSpan" id="kobo.576.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.577.1" xmlns="http://www.w3.org/1999/xhtml">WAF</span></strong><span class="koboSpan" id="kobo.578.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.578.2" xmlns="http://www.w3.org/1999/xhtml">For example, Azure Application Gateway also supports autoscaling, zone redundancy, and can serve as </span><strong><span class="koboSpan" id="kobo.579.1" xmlns="http://www.w3.org/1999/xhtml">Azure Kubernetes Service</span></strong><span class="koboSpan" id="kobo.580.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.581.1" xmlns="http://www.w3.org/1999/xhtml">AKS</span></strong><span class="koboSpan" id="kobo.582.1" xmlns="http://www.w3.org/1999/xhtml">) Ingress Controller (in a nutshell, it controls the traffic to your microservices cluster).If you want more control over your gateways or to deploy them with your application, you can leverage one existing options, like Ocelot, YARP, or Envoy.Ocelot is an open source production-ready API Gateway programmed in .NET. </span><span class="koboSpan" id="kobo.582.2" xmlns="http://www.w3.org/1999/xhtml">Ocelot supports routing, request aggregation, load-balancing, authentication, authorization, rate limiting, and more. </span><span class="koboSpan" id="kobo.582.3" xmlns="http://www.w3.org/1999/xhtml">It also integrates well with Identity Server. </span><span class="koboSpan" id="kobo.582.4" xmlns="http://www.w3.org/1999/xhtml">In my eyes, the biggest advantage of Ocelot is that you create the .NET project yourself, install a NuGet package, configure your gateway, and then deploy it like any other ASP.NET Core application. </span><span class="koboSpan" id="kobo.582.5" xmlns="http://www.w3.org/1999/xhtml">Since Ocelot is written in .NET, extending it if needed or contributing to the project or its ecosystem is easier.To quote their GitHub </span><code><span class="koboSpan" id="kobo.583.1" xmlns="http://www.w3.org/1999/xhtml">README.md</span></code><span class="koboSpan" id="kobo.584.1" xmlns="http://www.w3.org/1999/xhtml"> file: « </span><em><span class="koboSpan" id="kobo.585.1" xmlns="http://www.w3.org/1999/xhtml">YARP is a reverse proxy toolkit for building fast proxy servers in .NET using the infrastructure from ASP.NET and .NET. </span><span class="koboSpan" id="kobo.585.2" xmlns="http://www.w3.org/1999/xhtml">The key differentiator for YARP is that it's been designed to be easily customized and tweaked to match the specific needs of each deployment scenario.</span></em><span class="koboSpan" id="kobo.586.1" xmlns="http://www.w3.org/1999/xhtml"> »Envoy is an « </span><em><span class="koboSpan" id="kobo.587.1" xmlns="http://www.w3.org/1999/xhtml">open source edge and service proxy, designed for cloud-native applications</span></em><span class="koboSpan" id="kobo.588.1" xmlns="http://www.w3.org/1999/xhtml"> », to quote their website. </span><span class="koboSpan" id="kobo.588.2" xmlns="http://www.w3.org/1999/xhtml">Envoy is a </span><strong><span class="koboSpan" id="kobo.589.1" xmlns="http://www.w3.org/1999/xhtml">Cloud Native Computing Foundation</span></strong><span class="koboSpan" id="kobo.590.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.591.1" xmlns="http://www.w3.org/1999/xhtml">CNCF</span></strong><span class="koboSpan" id="kobo.592.1" xmlns="http://www.w3.org/1999/xhtml">) graduated project originally created by Lyft. </span><span class="koboSpan" id="kobo.592.2" xmlns="http://www.w3.org/1999/xhtml">Envoy was designed to run as a separate process from your application, allowing it to work with any programming language. </span><span class="koboSpan" id="kobo.592.3" xmlns="http://www.w3.org/1999/xhtml">Envoy can serve as a gateway and has an extendable design through TCP/UDP and HTTP filters, supports HTTP/2 and HTTP/3, gRPC, and more.Which offering to choose? </span><span class="koboSpan" id="kobo.592.4" xmlns="http://www.w3.org/1999/xhtml">If you are looking for a fully managed service, look at the cloud provider’s offering of your choice. </span><span class="koboSpan" id="kobo.592.5" xmlns="http://www.w3.org/1999/xhtml">Consider YARP or Ocelot if you are looking for a configurable reverse proxy or gateway that supports the patterns covered in this chapter. </span><span class="koboSpan" id="kobo.592.6" xmlns="http://www.w3.org/1999/xhtml">If you have complex use cases that Ocelot does not support, you can look into Envoy, a proven offering with many advanced capabilities. </span><span class="koboSpan" id="kobo.592.7" xmlns="http://www.w3.org/1999/xhtml">Please remember that these are just a few possibilities that can play the role of a gateway in a microservices architecture system and are not intended to be a complete list.Now, let’s see how gateways can help us follow the </span><strong><span class="koboSpan" id="kobo.593.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.594.1" xmlns="http://www.w3.org/1999/xhtml"> principles at cloud-scale:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.595.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.596.1" xmlns="http://www.w3.org/1999/xhtml">: A gateway can handle routing, aggregation, and other similar logic that would otherwise be implemented in different components or applications.</span></li>
<li><strong><span class="koboSpan" id="kobo.597.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.598.1" xmlns="http://www.w3.org/1999/xhtml">: I see many ways to tackle this one, but here are two takes on this:</span></li>
</ul>
<ol>
<li><span class="koboSpan" id="kobo.599.1" xmlns="http://www.w3.org/1999/xhtml">Externally, a gateway could reroute its sub-requests to new URIs without its consumers knowing about it, as long as its contract does not change.</span></li>
<li><span class="koboSpan" id="kobo.600.1" xmlns="http://www.w3.org/1999/xhtml">Internally, a gateway could load its rules from configurations, allowing it to change without updating its code.</span></li>
</ol>
<ul>
<li><strong><span class="koboSpan" id="kobo.601.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.602.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
<li><strong><span class="koboSpan" id="kobo.603.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.604.1" xmlns="http://www.w3.org/1999/xhtml">: Since a backend for frontend gateway serves a single frontend system, one contract (interface) per frontend system leads to multiple smaller interfaces instead of one big general-purpose gateway.</span></li>
<li><strong><span class="koboSpan" id="kobo.605.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.606.1" xmlns="http://www.w3.org/1999/xhtml">: We could see a gateway as an abstraction, hiding the real microservices (implementations) and inverting the dependency flow.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.607.1" xmlns="http://www.w3.org/1999/xhtml">Next, we build a BFF and evolve e-commerce application from </span><em><span class="koboSpan" id="kobo.608.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 18</span></em><span class="koboSpan" id="kobo.609.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</section>
</section>
<section class="level2" data-number="20.7" id="project-repr.bff">
<h2 data-number="20.7"><span class="koboSpan" id="kobo.610.1" xmlns="http://www.w3.org/1999/xhtml">Project – REPR.BFF</span></h2>
<p><span class="koboSpan" id="kobo.611.1" xmlns="http://www.w3.org/1999/xhtml">This project leverages the Backend for Frontend (BFF) design pattern to reduce the complexity of using the low-level API of the </span><em><span class="koboSpan" id="kobo.612.1" xmlns="http://www.w3.org/1999/xhtml">REPR project</span></em><span class="koboSpan" id="kobo.613.1" xmlns="http://www.w3.org/1999/xhtml"> we created in </span><em><span class="koboSpan" id="kobo.614.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 18</span></em><span class="koboSpan" id="kobo.615.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.615.2" xmlns="http://www.w3.org/1999/xhtml">The BFF endpoints act as several types of gateway we explore.This design makes two layers of API, so let’s start here.</span></p>
<section class="level3" data-number="20.7.1" id="layering-apis">
<h3 data-number="20.7.1"><span class="koboSpan" id="kobo.616.1" xmlns="http://www.w3.org/1999/xhtml">Layering APIs</span></h3>
<p><span class="koboSpan" id="kobo.617.1" xmlns="http://www.w3.org/1999/xhtml">From a high-level architecture perspective, we can leverage multiple layers of APIs to group different levels of operation granularity. </span><span class="koboSpan" id="kobo.617.2" xmlns="http://www.w3.org/1999/xhtml">For example, in this case, we have two layers:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.618.1" xmlns="http://www.w3.org/1999/xhtml">Low-level APIs that offer atomic foundational operations.</span></li>
<li><span class="koboSpan" id="kobo.619.1" xmlns="http://www.w3.org/1999/xhtml">High-level APIs that offer domain-specific functionalities.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.620.1" xmlns="http://www.w3.org/1999/xhtml">Here’s a diagram that represents this concept (high-level APIs are BFFs in this case, but the design could be nuanced):</span></p>
<figure>
<span class="koboSpan" id="kobo.621.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.24: diagram showcasing a two-layer architecture." src="../media/file151.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.622.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.24: diagram showcasing a two-layer architecture.</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.623.1" xmlns="http://www.w3.org/1999/xhtml">The low-level layer showcases atomic foundational operations, like adding an item to the shopping basket and removing an item from the shopping basket. </span><span class="koboSpan" id="kobo.623.2" xmlns="http://www.w3.org/1999/xhtml">Those operations are simple, so they are more complicated to use. </span><span class="koboSpan" id="kobo.623.3" xmlns="http://www.w3.org/1999/xhtml">For example, loading the products in the user’s shopping cart requires multiple API calls, one to get the items and quantity and one per item to get the product details like its name and price. </span><span class="koboSpan" id="kobo.623.4" xmlns="http://www.w3.org/1999/xhtml">The high-level layer offers domain-specific functionalities, which are easier to use but can become more complex. </span><span class="koboSpan" id="kobo.623.5" xmlns="http://www.w3.org/1999/xhtml">For example, a single endpoint could handle adding, updating, and deleting items from the shopping basket, making its usage trivial for its consumer but its logic more complex to implement. </span><span class="koboSpan" id="kobo.623.6" xmlns="http://www.w3.org/1999/xhtml">Moreover, the product team could prefer a shopping cart to a shopping basket, so the endpoint’s URL could reflect this.Let’s have a look at the advantages and disadvantages.</span></p>
<section class="level4" data-number="20.7.1.1" id="advantages-of-a-two-layer-design">
<h4 data-number="20.7.1.1"><span class="koboSpan" id="kobo.624.1" xmlns="http://www.w3.org/1999/xhtml">Advantages of a two-layer design</span></h4>
<ul>
<li><strong><span class="koboSpan" id="kobo.625.1" xmlns="http://www.w3.org/1999/xhtml">Separation of Concerns:</span></strong><span class="koboSpan" id="kobo.626.1" xmlns="http://www.w3.org/1999/xhtml"> This architecture separates the generic functionalities from the domain-specific ones, promoting cleaner code and modularization.</span></li>
<li><strong><span class="koboSpan" id="kobo.627.1" xmlns="http://www.w3.org/1999/xhtml">Scalability:</span></strong><span class="koboSpan" id="kobo.628.1" xmlns="http://www.w3.org/1999/xhtml"> Each layer can be scaled independently based on the demand.</span></li>
<li><strong><span class="koboSpan" id="kobo.629.1" xmlns="http://www.w3.org/1999/xhtml">Flexibility and Reusability:</span></strong><span class="koboSpan" id="kobo.630.1" xmlns="http://www.w3.org/1999/xhtml"> The low-level APIs can be reused across multiple high-level functionalities or applications, promoting code reusability.</span></li>
<li><strong><span class="koboSpan" id="kobo.631.1" xmlns="http://www.w3.org/1999/xhtml">Optimized Data Fetching:</span></strong><span class="koboSpan" id="kobo.632.1" xmlns="http://www.w3.org/1999/xhtml"> BFFs can call multiple low-level APIs, aggregate responses, and send only the necessary data to the frontend, reducing payload sizes and making frontend development more straightforward.</span></li>
<li><strong><span class="koboSpan" id="kobo.633.1" xmlns="http://www.w3.org/1999/xhtml">Easier Maintenance:</span></strong><span class="koboSpan" id="kobo.634.1" xmlns="http://www.w3.org/1999/xhtml"> We can address issues in a specific domain without touching the low-level generic APIs. </span><span class="koboSpan" id="kobo.634.2" xmlns="http://www.w3.org/1999/xhtml">On the other hand, we can fix an issue in a lower-level API, which will propagate to all the domains.</span></li>
<li><strong><span class="koboSpan" id="kobo.635.1" xmlns="http://www.w3.org/1999/xhtml">Tailored User Experience:</span></strong><span class="koboSpan" id="kobo.636.1" xmlns="http://www.w3.org/1999/xhtml"> High-level APIs can be crafted specifically for individual client types (web, mobile, etc.), ensuring an optimal user experience.</span></li>
<li><strong><span class="koboSpan" id="kobo.637.1" xmlns="http://www.w3.org/1999/xhtml">Security:</span></strong><span class="koboSpan" id="kobo.638.1" xmlns="http://www.w3.org/1999/xhtml"> Domain-specific functionalities can implement additional security measures relevant to their context without burdening the low-level APIs with unnecessary complexity.</span></li>
</ul>
</section>
<section class="level4" data-number="20.7.1.2" id="disadvantages-of-a-two-layer-design">
<h4 data-number="20.7.1.2"><span class="koboSpan" id="kobo.639.1" xmlns="http://www.w3.org/1999/xhtml">Disadvantages of a two-layer design</span></h4>
<ul>
<li><strong><span class="koboSpan" id="kobo.640.1" xmlns="http://www.w3.org/1999/xhtml">Increased Complexity:</span></strong><span class="koboSpan" id="kobo.641.1" xmlns="http://www.w3.org/1999/xhtml"> Maintaining two layers introduces additional deployment, monitoring, and management complexity.</span></li>
<li><strong><span class="koboSpan" id="kobo.642.1" xmlns="http://www.w3.org/1999/xhtml">Potential Performance Overhead:</span></strong><span class="koboSpan" id="kobo.643.1" xmlns="http://www.w3.org/1999/xhtml"> An additional layer introduces latency, especially if not properly optimized.</span></li>
<li><strong><span class="koboSpan" id="kobo.644.1" xmlns="http://www.w3.org/1999/xhtml">Duplication:</span></strong><span class="koboSpan" id="kobo.645.1" xmlns="http://www.w3.org/1999/xhtml"> There's potential for code duplication when similar logic gets implemented in multiple high-level functionalities.</span></li>
<li><strong><span class="koboSpan" id="kobo.646.1" xmlns="http://www.w3.org/1999/xhtml">Tight Coupling Concerns:</span></strong><span class="koboSpan" id="kobo.647.1" xmlns="http://www.w3.org/1999/xhtml"> Changes in the low-level APIs can impact multiple domain-specific functionalities. </span><span class="koboSpan" id="kobo.647.2" xmlns="http://www.w3.org/1999/xhtml">A poor design could lead to a tightly coupled distributed system.</span></li>
<li><strong><span class="koboSpan" id="kobo.648.1" xmlns="http://www.w3.org/1999/xhtml">Coordination Required:</span></strong><span class="koboSpan" id="kobo.649.1" xmlns="http://www.w3.org/1999/xhtml"> As the system evolves, ensuring that the low-level APIs meet the needs of all high-level functionalities requires more coordination among development teams.</span></li>
<li><strong><span class="koboSpan" id="kobo.650.1" xmlns="http://www.w3.org/1999/xhtml">Overhead in Development:</span></strong><span class="koboSpan" id="kobo.651.1" xmlns="http://www.w3.org/1999/xhtml"> Developers need to consider two layers, which can slow down the development process, especially if there's a need to modify both layers to achieve a specific feature or fix.</span></li>
<li><strong><span class="koboSpan" id="kobo.652.1" xmlns="http://www.w3.org/1999/xhtml">Potential for Stale Data:</span></strong><span class="koboSpan" id="kobo.653.1" xmlns="http://www.w3.org/1999/xhtml"> If high-level functionalities cache data from low-level APIs, there's potential for serving stale data to users.</span></li>
<li><strong><span class="koboSpan" id="kobo.654.1" xmlns="http://www.w3.org/1999/xhtml">Increased Risk of Failures:</span></strong><span class="koboSpan" id="kobo.655.1" xmlns="http://www.w3.org/1999/xhtml"> Introducing additional APIs increases the odds of one of them experiencing issues or outages.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.656.1" xmlns="http://www.w3.org/1999/xhtml">While a two-layer design can offer flexibility and optimization, it also introduces additional complexities. </span><span class="koboSpan" id="kobo.656.2" xmlns="http://www.w3.org/1999/xhtml">The decision to use such an architecture should be based on the specific needs of the project, the anticipated scale, and the capabilities of the development and operations teams.We look at booting up these APIs next.</span></p>
</section>
</section>
<section class="level3" data-number="20.7.2" id="running-the-microservices">
<h3 data-number="20.7.2"><span class="koboSpan" id="kobo.657.1" xmlns="http://www.w3.org/1999/xhtml">Running the microservices</span></h3>
<p><span class="koboSpan" id="kobo.658.1" xmlns="http://www.w3.org/1999/xhtml">Let’s start by exploring the deployment topology. </span><span class="koboSpan" id="kobo.658.2" xmlns="http://www.w3.org/1999/xhtml">First, we split the </span><em><span class="koboSpan" id="kobo.659.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 18</span></em><span class="koboSpan" id="kobo.660.1" xmlns="http://www.w3.org/1999/xhtml"> REPR project into two services: </span><em><span class="koboSpan" id="kobo.661.1" xmlns="http://www.w3.org/1999/xhtml">Baskets</span></em><span class="koboSpan" id="kobo.662.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><em><span class="koboSpan" id="kobo.663.1" xmlns="http://www.w3.org/1999/xhtml">Products</span></em><span class="koboSpan" id="kobo.664.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.664.2" xmlns="http://www.w3.org/1999/xhtml">Then, we add a </span><em><span class="koboSpan" id="kobo.665.1" xmlns="http://www.w3.org/1999/xhtml">BFF</span></em><span class="koboSpan" id="kobo.666.1" xmlns="http://www.w3.org/1999/xhtml"> API that fronts the two services to simplify using the system. </span><span class="koboSpan" id="kobo.666.2" xmlns="http://www.w3.org/1999/xhtml">We do not have a UI per se, but one </span><code><span class="koboSpan" id="kobo.667.1" xmlns="http://www.w3.org/1999/xhtml">http</span></code><span class="koboSpan" id="kobo.668.1" xmlns="http://www.w3.org/1999/xhtml"> file per project exists to simulate HTTP requests. </span><span class="koboSpan" id="kobo.668.2" xmlns="http://www.w3.org/1999/xhtml">Here’s a diagram that represents the relationship between the different services:</span></p>
<figure>
<span class="koboSpan" id="kobo.669.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.25: a diagram that represents the deployment topology and relationship between the different services" src="../media/file152.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.670.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.25: a diagram that represents the deployment topology and relationship between the different services</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.671.1" xmlns="http://www.w3.org/1999/xhtml">The easiest and most extendable way to start the projects is to use Docker, but it is optional; we can also start the three projects manually. </span><span class="koboSpan" id="kobo.671.2" xmlns="http://www.w3.org/1999/xhtml">Using Docker opens many possibilities, like using a real SQL Server to persist the data between runs and add more pieces to our puzzle, like a Redis cache or an event broker, to name a few.Let’s start by manually starting the apps.</span></p>
<section class="level4" data-number="20.7.2.1" id="manually-starting-the-projects">
<h4 data-number="20.7.2.1"><span class="koboSpan" id="kobo.672.1" xmlns="http://www.w3.org/1999/xhtml">Manually starting the projects</span></h4>
<p><span class="koboSpan" id="kobo.673.1" xmlns="http://www.w3.org/1999/xhtml">We have three projects and need three terminals to start them all. </span><span class="koboSpan" id="kobo.673.2" xmlns="http://www.w3.org/1999/xhtml">From the chapter directory, you can execute the following commands, one set per terminal window, and all projects should start:# In one terminal</span></p>
<div class="C0-ConsolePACKT">
<pre><code><span class="koboSpan" id="kobo.674.1" xmlns="http://www.w3.org/1999/xhtml">cd REPR.Baskets
dotnet run
# In a second terminal
cd REPR.Products
dotnet run
# In a third terminal
cd REPR.BFF
dotnet run</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.675.1" xmlns="http://www.w3.org/1999/xhtml">Doing this should work. </span><span class="koboSpan" id="kobo.675.2" xmlns="http://www.w3.org/1999/xhtml">You can use the </span><code><span class="koboSpan" id="kobo.676.1" xmlns="http://www.w3.org/1999/xhtml">PROJECT_NAME.http</span></code><span class="koboSpan" id="kobo.677.1" xmlns="http://www.w3.org/1999/xhtml"> files to test the APIs.Next, let’s explore the second option about using Docker.</span></p>
</section>
<section class="level4" data-number="20.7.2.2" id="using-docker-compose-to-run-the-projects">
<h4 data-number="20.7.2.2"><span class="koboSpan" id="kobo.678.1" xmlns="http://www.w3.org/1999/xhtml">Using Docker Compose to run the projects</span></h4>
<p><span class="koboSpan" id="kobo.679.1" xmlns="http://www.w3.org/1999/xhtml">At the same level as the solution file, the </span><code><span class="koboSpan" id="kobo.680.1" xmlns="http://www.w3.org/1999/xhtml">docker-compose.yml</span></code><span class="koboSpan" id="kobo.681.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.682.1" xmlns="http://www.w3.org/1999/xhtml">docker-compose.override.yml</span></code><span class="koboSpan" id="kobo.683.1" xmlns="http://www.w3.org/1999/xhtml">, and various </span><code><span class="koboSpan" id="kobo.684.1" xmlns="http://www.w3.org/1999/xhtml">Dockerfile</span></code><span class="koboSpan" id="kobo.685.1" xmlns="http://www.w3.org/1999/xhtml"> files are preconfigured to make the projects start in the correct order.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.686.1" xmlns="http://www.w3.org/1999/xhtml">Here’s a link to get started with Docker: </span><a href="https://adpg.link/1zfM"><span class="koboSpan" id="kobo.687.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/1zfM</span></a></p>
</blockquote>
<p><span class="koboSpan" id="kobo.688.1" xmlns="http://www.w3.org/1999/xhtml">Since ASP.NET Core uses HTTPS by default, we must register a development certificate with the container, so let’s start here.</span></p>
<section class="level5" data-number="20.7.2.2.1" id="configuring-https">
<h5 data-number="20.7.2.2.1"><span class="koboSpan" id="kobo.689.1" xmlns="http://www.w3.org/1999/xhtml">Configuring HTTPS</span></h5>
<p><span class="koboSpan" id="kobo.690.1" xmlns="http://www.w3.org/1999/xhtml">This section quickly explores using PowerShell to set up HTTPS on Windows. </span><span class="koboSpan" id="kobo.690.2" xmlns="http://www.w3.org/1999/xhtml">If you are using a different operating system or if the instructions are not working, please consult the official documentation: </span><a href="https://adpg.link/o1tu"><span class="koboSpan" id="kobo.691.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/o1tu</span></a><span class="koboSpan" id="kobo.692.1" xmlns="http://www.w3.org/1999/xhtml">First, we must generate a development certificate. </span><span class="koboSpan" id="kobo.692.2" xmlns="http://www.w3.org/1999/xhtml">In a PowerShell terminal, run the following commands:</span></p>
<div class="C0-ConsolePACKT">
<pre><code><span class="koboSpan" id="kobo.693.1" xmlns="http://www.w3.org/1999/xhtml">dotnet dev-certs https -ep "$env:APPDATA\ASP.NET\Https\adpg-net8-chapter-19.pfx" -p devpassword
dotnet dev-certs https --trust</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.694.1" xmlns="http://www.w3.org/1999/xhtml">The preceding commands create a </span><code><span class="koboSpan" id="kobo.695.1" xmlns="http://www.w3.org/1999/xhtml">pfx</span></code><span class="koboSpan" id="kobo.696.1" xmlns="http://www.w3.org/1999/xhtml"> file with the password </span><code><span class="koboSpan" id="kobo.697.1" xmlns="http://www.w3.org/1999/xhtml">devpassword</span></code><span class="koboSpan" id="kobo.698.1" xmlns="http://www.w3.org/1999/xhtml"> (you must provide a password, or it won’t work), then tell .NET to trust the dev certificates.From there, the </span><code><span class="koboSpan" id="kobo.699.1" xmlns="http://www.w3.org/1999/xhtml">ASPNETCORE_Kestrel__Certificates__Default__Path</span></code><span class="koboSpan" id="kobo.700.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.701.1" xmlns="http://www.w3.org/1999/xhtml">ASPNETCORE_Kestrel__Certificates__Default__Password</span></code><span class="koboSpan" id="kobo.702.1" xmlns="http://www.w3.org/1999/xhtml"> environment variables are configured in the </span><code><span class="koboSpan" id="kobo.703.1" xmlns="http://www.w3.org/1999/xhtml">docker-compose.override.yml</span></code><span class="koboSpan" id="kobo.704.1" xmlns="http://www.w3.org/1999/xhtml"> file and should be taken into account.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.705.1" xmlns="http://www.w3.org/1999/xhtml">If you change the certificate location or the password, you must update the </span><code><span class="koboSpan" id="kobo.706.1" xmlns="http://www.w3.org/1999/xhtml">docker-compose.override.yml</span></code><span class="koboSpan" id="kobo.707.1" xmlns="http://www.w3.org/1999/xhtml"> file.</span></p>
</blockquote>
</section>
<section class="level5" data-number="20.7.2.2.2" id="composing-the-application">
<h5 data-number="20.7.2.2.2"><span class="koboSpan" id="kobo.708.1" xmlns="http://www.w3.org/1999/xhtml">Composing the application</span></h5>
<p><span class="koboSpan" id="kobo.709.1" xmlns="http://www.w3.org/1999/xhtml">Now that we set up HTTPS, we can build the container using the following commands:</span></p>
<div class="C0-ConsolePACKT">
<pre><code><span class="koboSpan" id="kobo.710.1" xmlns="http://www.w3.org/1999/xhtml">docker compose build</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.711.1" xmlns="http://www.w3.org/1999/xhtml">We can execute the following command to start the containers:</span></p>
<div class="C0-ConsolePACKT">
<pre><code><span class="koboSpan" id="kobo.712.1" xmlns="http://www.w3.org/1999/xhtml">docker compose up</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.713.1" xmlns="http://www.w3.org/1999/xhtml">This should start the containers and feed you an aggregated log with a color per service. </span><span class="koboSpan" id="kobo.713.2" xmlns="http://www.w3.org/1999/xhtml">The beginning of the log trail should look like this:</span></p>
<div class="C0-ConsolePACKT">
<pre><code><span class="koboSpan" id="kobo.714.1" xmlns="http://www.w3.org/1999/xhtml">[+] Running 3/0
 ✔ Container c19-repr.products-1  Created    0.0s
 ✔ Container c19-repr.baskets-1   Created    0.0s
 ✔ Container c19-repr.bff-1       Created    0.0s
Attaching to c19-repr.baskets-1, c19-repr.bff-1, c19-repr.products-1
c19-repr.baskets-1   | info: Microsoft.Hosting.Lifetime[14]
c19-repr.baskets-1   |       Now listening on: http://[::]:80
c19-repr.baskets-1   | info: Microsoft.Hosting.Lifetime[14]
c19-repr.baskets-1   |       Now listening on: https://[::]:443
...</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.715.1" xmlns="http://www.w3.org/1999/xhtml">To stop the services, press </span><code><span class="koboSpan" id="kobo.716.1" xmlns="http://www.w3.org/1999/xhtml">Ctrl+C</span></code><span class="koboSpan" id="kobo.717.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.717.2" xmlns="http://www.w3.org/1999/xhtml">When you want to destroy the running application, enter the following command:</span></p>
<div class="C0-ConsolePACKT">
<pre><code><span class="koboSpan" id="kobo.718.1" xmlns="http://www.w3.org/1999/xhtml">docker compose down</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.719.1" xmlns="http://www.w3.org/1999/xhtml">Now, with </span><code><span class="koboSpan" id="kobo.720.1" xmlns="http://www.w3.org/1999/xhtml">docker compose up</span></code><span class="koboSpan" id="kobo.721.1" xmlns="http://www.w3.org/1999/xhtml">, our services should be running. </span><span class="koboSpan" id="kobo.721.2" xmlns="http://www.w3.org/1999/xhtml">To make sure, let’s try them out.</span></p>
</section>
</section>
<section class="level4" data-number="20.7.2.3" id="briefly-testing-the-services">
<h4 data-number="20.7.2.3"><span class="koboSpan" id="kobo.722.1" xmlns="http://www.w3.org/1999/xhtml">Briefly testing the services</span></h4>
<p><span class="koboSpan" id="kobo.723.1" xmlns="http://www.w3.org/1999/xhtml">The project contains the following services, each containing an </span><code><span class="koboSpan" id="kobo.724.1" xmlns="http://www.w3.org/1999/xhtml">http</span></code><span class="koboSpan" id="kobo.725.1" xmlns="http://www.w3.org/1999/xhtml"> file you can leverage to query the services using Visual Studio or in VS Code using an extension:</span></p>
<table>
<tbody>
<tr class="odd">
<td><span class="koboSpan" id="kobo.726.1" xmlns="http://www.w3.org/1999/xhtml">Service</span></td>
<td><span class="koboSpan" id="kobo.727.1" xmlns="http://www.w3.org/1999/xhtml">HTTP file</span></td>
<td><span class="koboSpan" id="kobo.728.1" xmlns="http://www.w3.org/1999/xhtml">Host</span></td>
</tr>
<tr class="even">
<td><code><span class="koboSpan" id="kobo.729.1" xmlns="http://www.w3.org/1999/xhtml">REPR.Baskets</span></code></td>
<td><code><span class="koboSpan" id="kobo.730.1" xmlns="http://www.w3.org/1999/xhtml">REPR.Baskets.http</span></code></td>
<td><a href="https://localhost:60280"><span class="koboSpan" id="kobo.731.1" xmlns="http://www.w3.org/1999/xhtml">https://localhost:60280</span></a></td>
</tr>
<tr class="odd">
<td><code><span class="koboSpan" id="kobo.732.1" xmlns="http://www.w3.org/1999/xhtml">REPR.BFF</span></code></td>
<td><code><span class="koboSpan" id="kobo.733.1" xmlns="http://www.w3.org/1999/xhtml">REPR.BFF.http</span></code></td>
<td><a href="https://localhost:7254"><span class="koboSpan" id="kobo.734.1" xmlns="http://www.w3.org/1999/xhtml">https://localhost:7254</span></a></td>
</tr>
<tr class="even">
<td><code><span class="koboSpan" id="kobo.735.1" xmlns="http://www.w3.org/1999/xhtml">REPR.Products</span></code></td>
<td><code><span class="koboSpan" id="kobo.736.1" xmlns="http://www.w3.org/1999/xhtml">REPR.Products.http</span></code></td>
<td><a href="https://localhost:57362"><span class="koboSpan" id="kobo.737.1" xmlns="http://www.w3.org/1999/xhtml">https://localhost:57362</span></a></td>
</tr>
</tbody>
</table><span class="koboSpan" id="kobo.738.1" xmlns="http://www.w3.org/1999/xhtml">
Table 19.3: each service, HTTP file, and HTTPS hostname and port.
</span><p><span class="koboSpan" id="kobo.739.1" xmlns="http://www.w3.org/1999/xhtml">We can leverage the HTTP requests from each directory to test the API. </span><span class="koboSpan" id="kobo.739.2" xmlns="http://www.w3.org/1999/xhtml">I suggest starting by trying the low-level APIs, then the BFF, so you know if something is wrong with them directly instead of wondering what is wrong with the BFF (which calls the low-level APIs).</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.740.1" xmlns="http://www.w3.org/1999/xhtml">I use the </span><em><span class="koboSpan" id="kobo.741.1" xmlns="http://www.w3.org/1999/xhtml">REST Client</span></em><span class="koboSpan" id="kobo.742.1" xmlns="http://www.w3.org/1999/xhtml"> extension in VS Code (</span><a href="https://adpg.link/UCGv"><span class="koboSpan" id="kobo.743.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/UCGv</span></a><span class="koboSpan" id="kobo.744.1" xmlns="http://www.w3.org/1999/xhtml">) and the built-in support in Visual Studio 2022 version 17.6 or later.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.745.1" xmlns="http://www.w3.org/1999/xhtml">Here’s a part of the </span><code><span class="koboSpan" id="kobo.746.1" xmlns="http://www.w3.org/1999/xhtml">REPR.Baskets.http</span></code><span class="koboSpan" id="kobo.747.1" xmlns="http://www.w3.org/1999/xhtml"> file:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.748.1" xmlns="http://www.w3.org/1999/xhtml">@Web_HostAddress = https://localhost:60280
@ProductId = 3
@CustomerId = 1
GET {{Web_HostAddress}}/baskets/{{CustomerId}}
###
POST {{Web_HostAddress}}/baskets
Content-Type: application/json
{
    "customerId": {{CustomerId}}, 
    "productId": {{ProductId}}, 
    "quantity": 10
}
...</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.749.1" xmlns="http://www.w3.org/1999/xhtml">The highlighted lines are variables that the requests reuse. </span><span class="koboSpan" id="kobo.749.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.750.1" xmlns="http://www.w3.org/1999/xhtml">###</span></code><span class="koboSpan" id="kobo.751.1" xmlns="http://www.w3.org/1999/xhtml"> characters act as a separator between requests. </span><span class="koboSpan" id="kobo.751.2" xmlns="http://www.w3.org/1999/xhtml">In VS or VS Code, you should see a </span><code><span class="koboSpan" id="kobo.752.1" xmlns="http://www.w3.org/1999/xhtml">Send request</span></code><span class="koboSpan" id="kobo.753.1" xmlns="http://www.w3.org/1999/xhtml"> button on top of each request. </span><span class="koboSpan" id="kobo.753.2" xmlns="http://www.w3.org/1999/xhtml">Executing the </span><code><span class="koboSpan" id="kobo.754.1" xmlns="http://www.w3.org/1999/xhtml">POST</span></code><span class="koboSpan" id="kobo.755.1" xmlns="http://www.w3.org/1999/xhtml"> request, then the </span><code><span class="koboSpan" id="kobo.756.1" xmlns="http://www.w3.org/1999/xhtml">GET</span></code><span class="koboSpan" id="kobo.757.1" xmlns="http://www.w3.org/1999/xhtml"> should output the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.758.1" xmlns="http://www.w3.org/1999/xhtml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
[
  {
    "productId": 3,
    "quantity": 10
  }
]</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.759.1" xmlns="http://www.w3.org/1999/xhtml">If you can reach one endpoint, this means the service is running. </span><span class="koboSpan" id="kobo.759.2" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, feel free to play with the requests, modify them, and add more.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.760.1" xmlns="http://www.w3.org/1999/xhtml">I did not move the tests over from </span><em><span class="koboSpan" id="kobo.761.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 18</span></em><span class="koboSpan" id="kobo.762.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.762.2" xmlns="http://www.w3.org/1999/xhtml">Automating the validation of our deployment could be a good exercise for you to test your testing skills.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.763.1" xmlns="http://www.w3.org/1999/xhtml">After you validate that the three services are running, we can continue and look at how the BFF communicates with the Baskets and Products services.</span></p>
</section>
</section>
<section class="level3" data-number="20.7.3" id="creating-typed-http-clients-using-refit">
<h3 data-number="20.7.3"><span class="koboSpan" id="kobo.764.1" xmlns="http://www.w3.org/1999/xhtml">Creating typed HTTP clients using Refit</span></h3>
<p><span class="koboSpan" id="kobo.765.1" xmlns="http://www.w3.org/1999/xhtml">The BFF service must communicate to the Baskets and Products services. </span><span class="koboSpan" id="kobo.765.2" xmlns="http://www.w3.org/1999/xhtml">The services are REST APIs, so we must leverage HTTP. </span><span class="koboSpan" id="kobo.765.3" xmlns="http://www.w3.org/1999/xhtml">We could leverage the out-of-the-box ASP.NET Core </span><code><span class="koboSpan" id="kobo.766.1" xmlns="http://www.w3.org/1999/xhtml">HttpClient</span></code><span class="koboSpan" id="kobo.767.1" xmlns="http://www.w3.org/1999/xhtml"> class and </span><code><span class="koboSpan" id="kobo.768.1" xmlns="http://www.w3.org/1999/xhtml">IHttpClientFactory</span></code><span class="koboSpan" id="kobo.769.1" xmlns="http://www.w3.org/1999/xhtml"> interface, then send raw HTTP requests to the downstream APIs. </span><span class="koboSpan" id="kobo.769.2" xmlns="http://www.w3.org/1999/xhtml">On the other hand, we could also create a typed client, which translates the HTTP calls to simple method calls with evocative names. </span><span class="koboSpan" id="kobo.769.3" xmlns="http://www.w3.org/1999/xhtml">We are exploring the second option, encapsulating the HTTP calls inside the typed clients.The concept is simple: we create one interface per service and translate its operation into methods. </span><span class="koboSpan" id="kobo.769.4" xmlns="http://www.w3.org/1999/xhtml">Each interface revolves around a service. </span><span class="koboSpan" id="kobo.769.5" xmlns="http://www.w3.org/1999/xhtml">Optionally, we can aggregate the services under a master interface to inject the aggregate service and have access to all child services. </span><span class="koboSpan" id="kobo.769.6" xmlns="http://www.w3.org/1999/xhtml">Moreover, this central access point allows us to reduce the number of injected services to one and improve discoverability with IntelliSense. </span><span class="koboSpan" id="kobo.769.7" xmlns="http://www.w3.org/1999/xhtml">Here’s a diagram representing this concept:</span></p>
<figure>
<span class="koboSpan" id="kobo.770.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.25: UML class diagram representing a generic typed client class hierarchy." src="../media/file153.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.771.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.25: UML class diagram representing a generic typed client class hierarchy.</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.772.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding diagram, the </span><code><span class="koboSpan" id="kobo.773.1" xmlns="http://www.w3.org/1999/xhtml">IClient</span></code><span class="koboSpan" id="kobo.774.1" xmlns="http://www.w3.org/1999/xhtml"> interface is composed and exposes the other typed clients, each of which queries a specific downstream API.In our case, we have two downstream services, so our interface hierarchy looks like the following:</span></p>
<figure>
<span class="koboSpan" id="kobo.775.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.26: UML class diagram representing the BFF downstream typed client class hierarchy." src="../media/file154.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.776.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.26: UML class diagram representing the BFF downstream typed client class hierarchy.</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.777.1" xmlns="http://www.w3.org/1999/xhtml">After implementing this, we can query the downstream APIs from our code without worrying about their data contract because our client is strongly typed.We leverage </span><em><span class="koboSpan" id="kobo.778.1" xmlns="http://www.w3.org/1999/xhtml">Refit</span></em><span class="koboSpan" id="kobo.779.1" xmlns="http://www.w3.org/1999/xhtml">, an open-source library, to implement the interfaces automatically.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.780.1" xmlns="http://www.w3.org/1999/xhtml">We could use any other library or barebone ASP.NET Core </span><code><span class="koboSpan" id="kobo.781.1" xmlns="http://www.w3.org/1999/xhtml">HttpClient</span></code><span class="koboSpan" id="kobo.782.1" xmlns="http://www.w3.org/1999/xhtml">; it does not matter. </span><span class="koboSpan" id="kobo.782.2" xmlns="http://www.w3.org/1999/xhtml">I picked </span><em><span class="koboSpan" id="kobo.783.1" xmlns="http://www.w3.org/1999/xhtml">Refit</span></em><span class="koboSpan" id="kobo.784.1" xmlns="http://www.w3.org/1999/xhtml"> to leverage its code generator, save myself the trouble of writing the boilerplate code, and save you the time of reading through such code. </span><span class="koboSpan" id="kobo.784.2" xmlns="http://www.w3.org/1999/xhtml">Refit on GitHub: </span><a href="https://adpg.link/hneJ"><span class="koboSpan" id="kobo.785.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/hneJ</span></a><span class="koboSpan" id="kobo.786.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.787.1" xmlns="http://www.w3.org/1999/xhtml">I used the out-of-the-box </span><code><span class="koboSpan" id="kobo.788.1" xmlns="http://www.w3.org/1999/xhtml">IHttpClientFactory</span></code><span class="koboSpan" id="kobo.789.1" xmlns="http://www.w3.org/1999/xhtml"> functionalities in the past, so if you want to reduce the number of dependencies in your project, you can also use that instead. </span><span class="koboSpan" id="kobo.789.2" xmlns="http://www.w3.org/1999/xhtml">Here’s a link to help you get started: </span><a href="https://adpg.link/HCj7"><span class="koboSpan" id="kobo.790.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/HCj7</span></a><span class="koboSpan" id="kobo.791.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.792.1" xmlns="http://www.w3.org/1999/xhtml">Refit acts like Mapperly and generates code based on attributes, so all we have to do is define our methods, and Refit writes the code.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.793.1" xmlns="http://www.w3.org/1999/xhtml">The </span><em><span class="koboSpan" id="kobo.794.1" xmlns="http://www.w3.org/1999/xhtml">BFF</span></em><span class="koboSpan" id="kobo.795.1" xmlns="http://www.w3.org/1999/xhtml"> project references the </span><em><span class="koboSpan" id="kobo.796.1" xmlns="http://www.w3.org/1999/xhtml">Products</span></em><span class="koboSpan" id="kobo.797.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><em><span class="koboSpan" id="kobo.798.1" xmlns="http://www.w3.org/1999/xhtml">Baskets</span></em><span class="koboSpan" id="kobo.799.1" xmlns="http://www.w3.org/1999/xhtml"> projects to reuse their DTOs. </span><span class="koboSpan" id="kobo.799.2" xmlns="http://www.w3.org/1999/xhtml">I could have architected this in many different ways, including hosting the typed client in a library of its own so we could share it between many projects. </span><span class="koboSpan" id="kobo.799.3" xmlns="http://www.w3.org/1999/xhtml">We could also extract the DTOs from the web applications to one or more shared projects so we don’t depend on the web applications themselves. </span><span class="koboSpan" id="kobo.799.4" xmlns="http://www.w3.org/1999/xhtml">For this demo, there is no need to overengineer the solution.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.800.1" xmlns="http://www.w3.org/1999/xhtml">Let’s look at the typed client interfaces, starting with the </span><code><span class="koboSpan" id="kobo.801.1" xmlns="http://www.w3.org/1999/xhtml">IBasketsClient</span></code><span class="koboSpan" id="kobo.802.1" xmlns="http://www.w3.org/1999/xhtml"> interface:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.803.1" xmlns="http://www.w3.org/1999/xhtml">using Refit;
using Web.Features;
namespace REPR.BFF;
public interface IBasketsClient
{
    [Get("/baskets/{query.CustomerId}")]
    Task&lt;IEnumerable&lt;Baskets.FetchItems.Item&gt;&gt; FetchCustomerBasketAsync(
        Baskets.FetchItems.Query query,
        CancellationToken cancellationToken);
    [Post("/baskets")]
    Task&lt;Baskets.AddItem.Response&gt; AddProductToCart(
        Baskets.AddItem.Command command,
        CancellationToken cancellationToken);
    [Delete("/baskets/{command.CustomerId}/{command.ProductId}")]
    Task&lt;Baskets.RemoveItem.Response&gt; RemoveProductFromCart(
        Baskets.RemoveItem.Command command,
        CancellationToken cancellationToken);
    [Put("/baskets")]
    Task&lt;Baskets.UpdateQuantity.Response&gt; UpdateProductQuantity(
        Baskets.UpdateQuantity.Command command,
        CancellationToken cancellationToken);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.804.1" xmlns="http://www.w3.org/1999/xhtml">The preceding interface leverages Refit’s attributes (highlighted) to explain to its code generator what to write. </span><span class="koboSpan" id="kobo.804.2" xmlns="http://www.w3.org/1999/xhtml">The operations themselves are self-explanatory and carry the features’ DTOs over HTTP.Next, we look at the </span><code><span class="koboSpan" id="kobo.805.1" xmlns="http://www.w3.org/1999/xhtml">IProductsClient</span></code><span class="koboSpan" id="kobo.806.1" xmlns="http://www.w3.org/1999/xhtml"> interface:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.807.1" xmlns="http://www.w3.org/1999/xhtml">using Refit;
using Web.Features;
namespace REPR.BFF;
public interface IProductsClient
{
    [Get("/products/{query.ProductId}")]
    Task&lt;Products.FetchOne.Response&gt; FetchProductAsync(
        Products.FetchOne.Query query,
        CancellationToken cancellationToken);
    [Get("/products")]
    Task&lt;Products.FetchAll.Response&gt; FetchProductsAsync(
        CancellationToken cancellationToken);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.808.1" xmlns="http://www.w3.org/1999/xhtml">The preceding interface is similar to </span><code><span class="koboSpan" id="kobo.809.1" xmlns="http://www.w3.org/1999/xhtml">IBasketsClient</span></code><span class="koboSpan" id="kobo.810.1" xmlns="http://www.w3.org/1999/xhtml"> but creates a typed bridge on the </span><em><span class="koboSpan" id="kobo.811.1" xmlns="http://www.w3.org/1999/xhtml">Products</span></em><span class="koboSpan" id="kobo.812.1" xmlns="http://www.w3.org/1999/xhtml"> API.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.813.1" xmlns="http://www.w3.org/1999/xhtml">The generated code contains much gibberish code and would be very hard to clean enough to make it relevant to study, so let’s assume those interfaces have working implementations instead.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.814.1" xmlns="http://www.w3.org/1999/xhtml">Next, let’s look at our aggregate:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.815.1" xmlns="http://www.w3.org/1999/xhtml">public interface IWebClient
{
    IBasketsClient Baskets { get; }
    IProductsClient Catalog { get; }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.816.1" xmlns="http://www.w3.org/1999/xhtml">The preceding interface exposes the two clients we had Refit generate for us. </span><span class="koboSpan" id="kobo.816.2" xmlns="http://www.w3.org/1999/xhtml">Its implementation is fairly straightforward as well:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.817.1" xmlns="http://www.w3.org/1999/xhtml">public class DefaultWebClient : IWebClient
{
    public DefaultWebClient(IBasketsClient baskets, IProductsClient catalog)
    {
        Baskets = baskets ?? </span><span class="koboSpan" id="kobo.817.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(baskets));
        Catalog = catalog ?? </span><span class="koboSpan" id="kobo.817.3" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(catalog));
    }
    public IBasketsClient Baskets { get; }
    public IProductsClient Catalog { get; }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.818.1" xmlns="http://www.w3.org/1999/xhtml">The preceding default implementation composes itself through constructor injection, exposing the two typed clients.Of course, dependency injection means we must register services with the container. </span><span class="koboSpan" id="kobo.818.2" xmlns="http://www.w3.org/1999/xhtml">Let’s start with some configuration. </span><span class="koboSpan" id="kobo.818.3" xmlns="http://www.w3.org/1999/xhtml">To make the setup code parametrizable and allow the Docker container to override those values, we extract the services base addresses to the settings file like this (</span><code><span class="koboSpan" id="kobo.819.1" xmlns="http://www.w3.org/1999/xhtml">appsettings.Development.json</span></code><span class="koboSpan" id="kobo.820.1" xmlns="http://www.w3.org/1999/xhtml">):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.821.1" xmlns="http://www.w3.org/1999/xhtml">{
  "Downstream": {
    "Baskets": {
      "BaseAddress": "https://localhost:60280"
    },
    "Products": {
      "BaseAddress": "https://localhost:57362"
    }
  }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.822.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code defines two keys, one per service, which we then load individually in the </span><code><span class="koboSpan" id="kobo.823.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.824.1" xmlns="http://www.w3.org/1999/xhtml"> file, like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.825.1" xmlns="http://www.w3.org/1999/xhtml">using Refit;
using REPR.BFF;
using System.Collections.Concurrent;
using System.Net;
var builder = WebApplication.CreateBuilder(args);
var basketsBaseAddress = builder.Configuration
    .GetValue&lt;string&gt;("Downstream:Baskets:BaseAddress") ?? </span><span class="koboSpan" id="kobo.825.2" xmlns="http://www.w3.org/1999/xhtml">throw new NotSupportedException("Cannot start the program without a Baskets base address.");
var productsBaseAddress = builder.Configuration
    .GetValue&lt;string&gt;("Downstream:Products:BaseAddress") ?? </span><span class="koboSpan" id="kobo.825.3" xmlns="http://www.w3.org/1999/xhtml">throw new NotSupportedException("Cannot start the program without a Products base address.");</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.826.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code loads the two configurations into variables.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.827.1" xmlns="http://www.w3.org/1999/xhtml">We can leverage all the techniques we learned in </span><em><span class="koboSpan" id="kobo.828.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 9</span></em><span class="koboSpan" id="kobo.829.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.830.1" xmlns="http://www.w3.org/1999/xhtml">Options, Settings, and Configuration</span></em><span class="koboSpan" id="kobo.831.1" xmlns="http://www.w3.org/1999/xhtml">, to create a more elaborate system.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.832.1" xmlns="http://www.w3.org/1999/xhtml">Next, we register our Refit clients like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.833.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services
    .AddRefitClient&lt;IBasketsClient&gt;()
    .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri(basketsBaseAddress))
;
builder.Services
    .AddRefitClient&lt;IProductsClient&gt;()
    .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri(productsBaseAddress))
;</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.834.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding code, calling the </span><code><span class="koboSpan" id="kobo.835.1" xmlns="http://www.w3.org/1999/xhtml">AddRefitClient</span></code><span class="koboSpan" id="kobo.836.1" xmlns="http://www.w3.org/1999/xhtml"> method replaces the .NET </span><code><span class="koboSpan" id="kobo.837.1" xmlns="http://www.w3.org/1999/xhtml">AddHttpClient</span></code><span class="koboSpan" id="kobo.838.1" xmlns="http://www.w3.org/1999/xhtml"> method and registers our auto-generated client with the container. </span><span class="koboSpan" id="kobo.838.2" xmlns="http://www.w3.org/1999/xhtml">Because Refit registration returns an </span><code><span class="koboSpan" id="kobo.839.1" xmlns="http://www.w3.org/1999/xhtml">IHttpClientBuilder</span></code><span class="koboSpan" id="kobo.840.1" xmlns="http://www.w3.org/1999/xhtml"> interface, we can use the </span><code><span class="koboSpan" id="kobo.841.1" xmlns="http://www.w3.org/1999/xhtml">ConfigureHttpClient</span></code><span class="koboSpan" id="kobo.842.1" xmlns="http://www.w3.org/1999/xhtml"> method to configure the </span><code><span class="koboSpan" id="kobo.843.1" xmlns="http://www.w3.org/1999/xhtml">HttpClient</span></code><span class="koboSpan" id="kobo.844.1" xmlns="http://www.w3.org/1999/xhtml"> as we would any other typed HTTP client. </span><span class="koboSpan" id="kobo.844.2" xmlns="http://www.w3.org/1999/xhtml">In this case, we set the </span><code><span class="koboSpan" id="kobo.845.1" xmlns="http://www.w3.org/1999/xhtml">BaseAddress</span></code><span class="koboSpan" id="kobo.846.1" xmlns="http://www.w3.org/1999/xhtml"> property to the values of the previously loaded settings.Next, we must also register our aggregate:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.847.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddTransient&lt;IWebClient, DefaultWebClient&gt;();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.848.1" xmlns="http://www.w3.org/1999/xhtml">I picked a transient state because the service only fronts other services, so it will serve the other services as they are registered, regardless of whether it is the same instance every time. </span><span class="koboSpan" id="kobo.848.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, it needs a transient or scoped lifetime because the BFF must manage who is the current customer, not the client. </span><span class="koboSpan" id="kobo.848.3" xmlns="http://www.w3.org/1999/xhtml">It would be quite a security vulnerability to allow users to decide who they want to impersonate for every request.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.849.1" xmlns="http://www.w3.org/1999/xhtml">The project does not authenticate the users, but the service we explore next is designed to make this evolve, abstracting and managing this responsibility so we could add authentication without impacting the code we are writing.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.850.1" xmlns="http://www.w3.org/1999/xhtml">Let’s explore how we manage the current user.</span></p>
</section>
<section class="level3" data-number="20.7.4" id="creating-a-service-that-serves-the-current-customer">
<h3 data-number="20.7.4"><span class="koboSpan" id="kobo.851.1" xmlns="http://www.w3.org/1999/xhtml">Creating a service that serves the current customer</span></h3>
<p><span class="koboSpan" id="kobo.852.1" xmlns="http://www.w3.org/1999/xhtml">To keep the project simple, we are not using any authentication or authorization middleware, yet we want our BFF to be realistic and to handle who’s querying the downstream APIs. </span><span class="koboSpan" id="kobo.852.2" xmlns="http://www.w3.org/1999/xhtml">To achieve this, let’s create the </span><code><span class="koboSpan" id="kobo.853.1" xmlns="http://www.w3.org/1999/xhtml">ICurrentCustomerService</span></code><span class="koboSpan" id="kobo.854.1" xmlns="http://www.w3.org/1999/xhtml"> interface that abstracts this away from the consuming code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.855.1" xmlns="http://www.w3.org/1999/xhtml">public interface ICurrentCustomerService
{
    int Id { get; }
} </span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.856.1" xmlns="http://www.w3.org/1999/xhtml">The only thing that interface does is provide us with the identifier representing the current customer. </span><span class="koboSpan" id="kobo.856.2" xmlns="http://www.w3.org/1999/xhtml">Since we do not have authentication in the project, let’s implement a development version that always returns the same value:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.857.1" xmlns="http://www.w3.org/1999/xhtml">public class FakeCurrentCustomerService : ICurrentCustomerService
{
    public int Id =&gt; 1;
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.858.1" xmlns="http://www.w3.org/1999/xhtml">Finally, we must register it in the </span><code><span class="koboSpan" id="kobo.859.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.860.1" xmlns="http://www.w3.org/1999/xhtml"> class like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.861.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddScoped&lt;ICurrentCustomerService, FakeCurrentCustomerService&gt;();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.862.1" xmlns="http://www.w3.org/1999/xhtml">With this last piece, we are ready to write some features in our BFF service.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.863.1" xmlns="http://www.w3.org/1999/xhtml">In a project that uses authentication, you can inject the </span><code><span class="koboSpan" id="kobo.864.1" xmlns="http://www.w3.org/1999/xhtml">IHttpContextAccessor</span></code><span class="koboSpan" id="kobo.865.1" xmlns="http://www.w3.org/1999/xhtml"> interface into a class to access the current </span><code><span class="koboSpan" id="kobo.866.1" xmlns="http://www.w3.org/1999/xhtml">HttpContext</span></code><span class="koboSpan" id="kobo.867.1" xmlns="http://www.w3.org/1999/xhtml"> object that contains a </span><code><span class="koboSpan" id="kobo.868.1" xmlns="http://www.w3.org/1999/xhtml">User</span></code><span class="koboSpan" id="kobo.869.1" xmlns="http://www.w3.org/1999/xhtml"> property that enables access to the current user’s </span><code><span class="koboSpan" id="kobo.870.1" xmlns="http://www.w3.org/1999/xhtml">ClaimsPrincipal</span></code><span class="koboSpan" id="kobo.871.1" xmlns="http://www.w3.org/1999/xhtml"> object, which should include the current user’s </span><code><span class="koboSpan" id="kobo.872.1" xmlns="http://www.w3.org/1999/xhtml">CustomerId</span></code><span class="koboSpan" id="kobo.873.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.873.2" xmlns="http://www.w3.org/1999/xhtml">Of course, you must ensure the authentication server returns such a claim. </span><span class="koboSpan" id="kobo.873.3" xmlns="http://www.w3.org/1999/xhtml">You must register the accessor using the following method before using it: </span><code><span class="koboSpan" id="kobo.874.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddHttpContextAccessor()</span></code><span class="koboSpan" id="kobo.875.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</blockquote>
</section>
<section class="level3" data-number="20.7.5" id="features">
<h3 data-number="20.7.5"><span class="koboSpan" id="kobo.876.1" xmlns="http://www.w3.org/1999/xhtml">Features</span></h3>
<p><span class="koboSpan" id="kobo.877.1" xmlns="http://www.w3.org/1999/xhtml">The BFF service serves an unexisting user interface, yet we can imagine what it needs to do; it must:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.878.1" xmlns="http://www.w3.org/1999/xhtml">Serve the product catalog so customers can browse the shop.</span></li>
<li><span class="koboSpan" id="kobo.879.1" xmlns="http://www.w3.org/1999/xhtml">Serve a specific product to render a product details page.</span></li>
<li><span class="koboSpan" id="kobo.880.1" xmlns="http://www.w3.org/1999/xhtml">Serve the list of items in a user’s shopping cart.</span></li>
<li><span class="koboSpan" id="kobo.881.1" xmlns="http://www.w3.org/1999/xhtml">Enable users to manage their shopping cart by adding, updating, and removing items.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.882.1" xmlns="http://www.w3.org/1999/xhtml">Of course, the list of features could go on, like allowing the users to purchase the items, which is the ultimate goal of an e-commerce website. </span><span class="koboSpan" id="kobo.882.2" xmlns="http://www.w3.org/1999/xhtml">However, we are not going that far. </span><span class="koboSpan" id="kobo.882.3" xmlns="http://www.w3.org/1999/xhtml">Let’s start with the catalog.</span></p>
<section class="level4" data-number="20.7.5.1" id="fetching-the-catalog">
<h4 data-number="20.7.5.1"><span class="koboSpan" id="kobo.883.1" xmlns="http://www.w3.org/1999/xhtml">Fetching the catalog</span></h4>
<p><span class="koboSpan" id="kobo.884.1" xmlns="http://www.w3.org/1999/xhtml">The catalog acts as a routing gateway and forwards the requests to the </span><code><span class="koboSpan" id="kobo.885.1" xmlns="http://www.w3.org/1999/xhtml">Products</span></code><span class="koboSpan" id="kobo.886.1" xmlns="http://www.w3.org/1999/xhtml"> downstream service.The first endpoint serves the whole catalog by using our typed client (highlighted):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.887.1" xmlns="http://www.w3.org/1999/xhtml">app.MapGet(
    "api/catalog",
    (IWebClient client, CancellationToken cancellationToken)
        =&gt; client.Catalog.FetchProductsAsync(cancellationToken)
);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.888.1" xmlns="http://www.w3.org/1999/xhtml">Sending the following requests should hit the endpoint:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.889.1" xmlns="http://www.w3.org/1999/xhtml">GET https://localhost:7254/api/catalog</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.890.1" xmlns="http://www.w3.org/1999/xhtml">The endpoint should respond with something like the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.891.1" xmlns="http://www.w3.org/1999/xhtml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
{
  "products": [
    {
      "id": 2,
      "name": "Apple",
      "unitPrice": 0.79
    },
    {
      "id": 1,
      "name": "Banana",
      "unitPrice": 0.30
    },
    {
      "id": 3,
      "name": "Habanero Pepper",
      "unitPrice": 0.99
    }
  ]
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.892.1" xmlns="http://www.w3.org/1999/xhtml">Here’s a visual representation of what happens:</span></p>
<figure>
<span class="koboSpan" id="kobo.893.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.27: a sequence diagram representing the BFF routing the request to the Products service" src="../media/file155.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.894.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.27: a sequence diagram representing the BFF routing the request to the Products service</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.895.1" xmlns="http://www.w3.org/1999/xhtml">The other catalog endpoint is very similar and also simply routes the request to the correct downstream service:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.896.1" xmlns="http://www.w3.org/1999/xhtml">app.MapGet(
    "api/catalog/{productId}",
    (int productId, IWebClient client, CancellationToken cancellationToken)
        =&gt; client.Catalog.FetchProductAsync(new(productId), cancellationToken)
);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.897.1" xmlns="http://www.w3.org/1999/xhtml">Sending an HTTP call will result in the same as calling it directly because the BFF only acts as a router.We explore more exciting features next.</span></p>
</section>
<section class="level4" data-number="20.7.5.2" id="fetching-the-shopping-cart">
<h4 data-number="20.7.5.2"><span class="koboSpan" id="kobo.898.1" xmlns="http://www.w3.org/1999/xhtml">Fetching the shopping cart</span></h4>
<p><span class="koboSpan" id="kobo.899.1" xmlns="http://www.w3.org/1999/xhtml">The </span><em><span class="koboSpan" id="kobo.900.1" xmlns="http://www.w3.org/1999/xhtml">Baskets</span></em><span class="koboSpan" id="kobo.901.1" xmlns="http://www.w3.org/1999/xhtml"> service only stores the </span><code><span class="koboSpan" id="kobo.902.1" xmlns="http://www.w3.org/1999/xhtml">customerId</span></code><span class="koboSpan" id="kobo.903.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.904.1" xmlns="http://www.w3.org/1999/xhtml">productId</span></code><span class="koboSpan" id="kobo.905.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><code><span class="koboSpan" id="kobo.906.1" xmlns="http://www.w3.org/1999/xhtml">quantity</span></code><span class="koboSpan" id="kobo.907.1" xmlns="http://www.w3.org/1999/xhtml"> properties. </span><span class="koboSpan" id="kobo.907.2" xmlns="http://www.w3.org/1999/xhtml">However, a shopping cart page displays the product name and price, but the </span><em><span class="koboSpan" id="kobo.908.1" xmlns="http://www.w3.org/1999/xhtml">Products</span></em><span class="koboSpan" id="kobo.909.1" xmlns="http://www.w3.org/1999/xhtml"> service manages those two properties.To overcome this problem, the endpoint acts as an aggregation gateway. </span><span class="koboSpan" id="kobo.909.2" xmlns="http://www.w3.org/1999/xhtml">It queries the shopping cart and loads all the products from the </span><em><span class="koboSpan" id="kobo.910.1" xmlns="http://www.w3.org/1999/xhtml">Products</span></em><span class="koboSpan" id="kobo.911.1" xmlns="http://www.w3.org/1999/xhtml"> service before returning an aggregated result, removing the burden of managing this complexity from the client/UI.Here’s the code main feature code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.912.1" xmlns="http://www.w3.org/1999/xhtml">app.MapGet(
    "api/cart",
    async (IWebClient client, ICurrentCustomerService currentCustomer, CancellationToken cancellationToken) =&gt;
    {
        var basket = await client.Baskets.FetchCustomerBasketAsync(
            new(currentCustomer.Id),
            cancellationToken
        );
        var result = new ConcurrentBag&lt;BasketProduct&gt;();
        await Parallel.ForEachAsync(basket, cancellationToken, async (item, cancellationToken) =&gt;
        {
            var product = await client.Catalog.FetchProductAsync(
                new(item.ProductId),
                cancellationToken
            );
            result.Add(new BasketProduct(
                product.Id,
                product.Name,
                product.UnitPrice,
                item.Quantity
            ));
        });
        return result;
    }
);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.913.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code starts by fetching the items from the Baskets service and then loads the products using the </span><code><span class="koboSpan" id="kobo.914.1" xmlns="http://www.w3.org/1999/xhtml">Parallel.ForEachAsync</span></code><span class="koboSpan" id="kobo.915.1" xmlns="http://www.w3.org/1999/xhtml"> method before returning the aggregated result.The </span><code><span class="koboSpan" id="kobo.916.1" xmlns="http://www.w3.org/1999/xhtml">Parallel</span></code><span class="koboSpan" id="kobo.917.1" xmlns="http://www.w3.org/1999/xhtml"> class allows us to execute multiple operations in parallel, in this case, multiple HTTP calls. </span><span class="koboSpan" id="kobo.917.2" xmlns="http://www.w3.org/1999/xhtml">There are many ways of achieving a similar result using .NET, and this is one of those. </span><span class="koboSpan" id="kobo.917.3" xmlns="http://www.w3.org/1999/xhtml">When an HTTP call succeeds, it adds a </span><code><span class="koboSpan" id="kobo.918.1" xmlns="http://www.w3.org/1999/xhtml">BasketProduct</span></code><span class="koboSpan" id="kobo.919.1" xmlns="http://www.w3.org/1999/xhtml"> item to the </span><code><span class="koboSpan" id="kobo.920.1" xmlns="http://www.w3.org/1999/xhtml">result</span></code><span class="koboSpan" id="kobo.921.1" xmlns="http://www.w3.org/1999/xhtml"> collection. </span><span class="koboSpan" id="kobo.921.2" xmlns="http://www.w3.org/1999/xhtml">Once all operations are completed, the endpoint returns the collection of </span><code><span class="koboSpan" id="kobo.922.1" xmlns="http://www.w3.org/1999/xhtml">BasketProduct</span></code><span class="koboSpan" id="kobo.923.1" xmlns="http://www.w3.org/1999/xhtml"> objects, which contains all the combined information required by the user interface to display the shopping cart. </span><span class="koboSpan" id="kobo.923.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the </span><code><span class="koboSpan" id="kobo.924.1" xmlns="http://www.w3.org/1999/xhtml">BasketProduct</span></code><span class="koboSpan" id="kobo.925.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.926.1" xmlns="http://www.w3.org/1999/xhtml">public record class BasketProduct(int Id, string Name, decimal UnitPrice, int Quantity)
{
    public decimal TotalPrice =&gt; UnitPrice * Quantity;
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.927.1" xmlns="http://www.w3.org/1999/xhtml">The sequence of this endpoint is like this (the </span><code><span class="koboSpan" id="kobo.928.1" xmlns="http://www.w3.org/1999/xhtml">loop</span></code><span class="koboSpan" id="kobo.929.1" xmlns="http://www.w3.org/1999/xhtml"> represents the </span><code><span class="koboSpan" id="kobo.930.1" xmlns="http://www.w3.org/1999/xhtml">Parallel.ForEachAsync</span></code><span class="koboSpan" id="kobo.931.1" xmlns="http://www.w3.org/1999/xhtml"> method):</span></p>
<figure>
<span class="koboSpan" id="kobo.932.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.28: A sequence diagram representing the shopping cart endpoint interacting with the Products and the Baskets downstream services." src="../media/file156.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.933.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.28: A sequence diagram representing the shopping cart endpoint interacting with the Products and the Baskets downstream services.</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.934.1" xmlns="http://www.w3.org/1999/xhtml">Since the requests to the </span><em><span class="koboSpan" id="kobo.935.1" xmlns="http://www.w3.org/1999/xhtml">Products</span></em><span class="koboSpan" id="kobo.936.1" xmlns="http://www.w3.org/1999/xhtml"> service are sent in parallel, we cannot predict the order they will complete. </span><span class="koboSpan" id="kobo.936.2" xmlns="http://www.w3.org/1999/xhtml">Here is an excerpt from the application log depicting what can happen (I omitted the logging code in the book, but it is available on GitHub):</span></p>
<div class="C0-ConsolePACKT">
<pre><code><span class="koboSpan" id="kobo.937.1" xmlns="http://www.w3.org/1999/xhtml">trce: GetCart[0]
      Fetching product '3'.
</span><span class="koboSpan" id="kobo.937.2" xmlns="http://www.w3.org/1999/xhtml">trce: GetCart[0]
      Fetching product '2'.
</span><span class="koboSpan" id="kobo.937.3" xmlns="http://www.w3.org/1999/xhtml">trce: GetCart[0]
      Found product '2'(Apple).
</span><span class="koboSpan" id="kobo.937.4" xmlns="http://www.w3.org/1999/xhtml">trce: GetCart[0]
      Found product '3'(Habanero Pepper).</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.938.1" xmlns="http://www.w3.org/1999/xhtml">The preceding trace shows that we requested products </span><code><span class="koboSpan" id="kobo.939.1" xmlns="http://www.w3.org/1999/xhtml">3</span></code><span class="koboSpan" id="kobo.940.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.941.1" xmlns="http://www.w3.org/1999/xhtml">2</span></code><span class="koboSpan" id="kobo.942.1" xmlns="http://www.w3.org/1999/xhtml"> but received inverted responses (</span><code><span class="koboSpan" id="kobo.943.1" xmlns="http://www.w3.org/1999/xhtml">2</span></code><span class="koboSpan" id="kobo.944.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.945.1" xmlns="http://www.w3.org/1999/xhtml">3</span></code><span class="koboSpan" id="kobo.946.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.946.2" xmlns="http://www.w3.org/1999/xhtml">This is a possibility when running code in parallel.When we send the following request to the BFF:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.947.1" xmlns="http://www.w3.org/1999/xhtml">GET https://localhost:7254/api/cart</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.948.1" xmlns="http://www.w3.org/1999/xhtml">The BFF returns a response similar to the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.949.1" xmlns="http://www.w3.org/1999/xhtml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
[
  {
    "id": 3,
    "name": "Habanero Pepper",
    "unitPrice": 0.99,
    "quantity": 10,
    "totalPrice": 9.90
  },
  {
    "id": 2,
    "name": "Apple",
    "unitPrice": 0.79,
    "quantity": 5,
    "totalPrice": 3.95
  }
]</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.950.1" xmlns="http://www.w3.org/1999/xhtml">The preceding example showcases the aggregated result, simplifying the logic the client (UI) must implement to display the shopping cart.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.951.1" xmlns="http://www.w3.org/1999/xhtml">Since we are not ordering the results, the items will not always be in the same order. </span><span class="koboSpan" id="kobo.951.2" xmlns="http://www.w3.org/1999/xhtml">As an exercise, you could sort the results using one of the existing properties or add a property that saves when a customer adds the item to the cart and sort the items using this new property; the first item added is displayed first, and so on.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.952.1" xmlns="http://www.w3.org/1999/xhtml">Let’s move to the last endpoint and explore how the BFF manages the shopping cart items.</span></p>
</section>
<section class="level4" data-number="20.7.5.3" id="managing-the-shopping-cart">
<h4 data-number="20.7.5.3"><span class="koboSpan" id="kobo.953.1" xmlns="http://www.w3.org/1999/xhtml">Managing the shopping cart</span></h4>
<p><span class="koboSpan" id="kobo.954.1" xmlns="http://www.w3.org/1999/xhtml">One of the primary goals of our BFF is to reduce the frontend’s complexity. </span><span class="koboSpan" id="kobo.954.2" xmlns="http://www.w3.org/1999/xhtml">When examining the </span><em><span class="koboSpan" id="kobo.955.1" xmlns="http://www.w3.org/1999/xhtml">Baskets</span></em><span class="koboSpan" id="kobo.956.1" xmlns="http://www.w3.org/1999/xhtml"> service, we realized it would add a bit of avoidable complexity if we were only to serve the raw operation, so instead, we decided to encapsulate all of the shopping cart logic behind a single endpoint. </span><span class="koboSpan" id="kobo.956.2" xmlns="http://www.w3.org/1999/xhtml">When a client POST to the </span><code><span class="koboSpan" id="kobo.957.1" xmlns="http://www.w3.org/1999/xhtml">api/cart</span></code><span class="koboSpan" id="kobo.958.1" xmlns="http://www.w3.org/1999/xhtml"> endpoint, it:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.959.1" xmlns="http://www.w3.org/1999/xhtml">Adds a non-existent item.</span></li>
<li><span class="koboSpan" id="kobo.960.1" xmlns="http://www.w3.org/1999/xhtml">Update an existing item’s quantity.</span></li>
<li><span class="koboSpan" id="kobo.961.1" xmlns="http://www.w3.org/1999/xhtml">Remove an item that has a quantity equal to 0 or less.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.962.1" xmlns="http://www.w3.org/1999/xhtml">With this endpoint, the clients don’t have to worry about adding or updating. </span><span class="koboSpan" id="kobo.962.2" xmlns="http://www.w3.org/1999/xhtml">Here’s a simplified sequence diagram that represents this logic:</span></p>
<figure>
<span class="koboSpan" id="kobo.963.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.29: A sequence diagram that displays the high-level algorithm of the cart endpoint." src="../media/file157.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.964.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.29: A sequence diagram that displays the high-level algorithm of the cart endpoint.</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.965.1" xmlns="http://www.w3.org/1999/xhtml">As the diagram depicts, we call the remove endpoint if the quantity is inferior or equal to zero. </span><span class="koboSpan" id="kobo.965.2" xmlns="http://www.w3.org/1999/xhtml">Otherwise, we try to add the item to the basket. </span><span class="koboSpan" id="kobo.965.3" xmlns="http://www.w3.org/1999/xhtml">If the endpoint returns a </span><code><span class="koboSpan" id="kobo.966.1" xmlns="http://www.w3.org/1999/xhtml">409 Conflict</span></code><span class="koboSpan" id="kobo.967.1" xmlns="http://www.w3.org/1999/xhtml">, we try to update the quantity. </span><span class="koboSpan" id="kobo.967.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.968.1" xmlns="http://www.w3.org/1999/xhtml">app.MapPost(
    "api/cart",
    async (UpdateCartItem item, IWebClient client, ICurrentCustomerService currentCustomer, CancellationToken cancellationToken) =&gt;
    {
        if (item.Quantity &lt;= 0)
        {
            await RemoveItemFromCart(
                item,
                client,
                currentCustomer,
                cancellationToken
            );
        }
        else
        {
            await AddOrUpdateItem(
                item,
                client,
                currentCustomer,
                cancellationToken
            );
        }
        return Results.Ok();
    }
);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.969.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code follows the same pattern but contains the previously explained logic. </span><span class="koboSpan" id="kobo.969.2" xmlns="http://www.w3.org/1999/xhtml">We explore the two highlighted methods next, starting with the </span><code><span class="koboSpan" id="kobo.970.1" xmlns="http://www.w3.org/1999/xhtml">RemoveItemFromCart</span></code><span class="koboSpan" id="kobo.971.1" xmlns="http://www.w3.org/1999/xhtml"> method:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.972.1" xmlns="http://www.w3.org/1999/xhtml">static async Task RemoveItemFromCart(UpdateCartItem item, IWebClient client, ICurrentCustomerService currentCustomer, CancellationToken cancellationToken)
{
    try
    {
        var result = await client.Baskets.RemoveProductFromCart(
            new Web.Features.Baskets.RemoveItem.Command(
                currentCustomer.Id,
                item.ProductId
            ),
            cancellationToken
        );
    }
    catch (ValidationApiException ex)
    {
        if (ex.StatusCode != HttpStatusCode.NotFound)
        {
            throw;
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.973.1" xmlns="http://www.w3.org/1999/xhtml">The highlighted code of the preceding block leverages the typed HTTP client and sends a remove item command to the </span><em><span class="koboSpan" id="kobo.974.1" xmlns="http://www.w3.org/1999/xhtml">Baskets</span></em><span class="koboSpan" id="kobo.975.1" xmlns="http://www.w3.org/1999/xhtml"> service. </span><span class="koboSpan" id="kobo.975.2" xmlns="http://www.w3.org/1999/xhtml">If the item is not in the cart, the code ignores the error and continues. </span><span class="koboSpan" id="kobo.975.3" xmlns="http://www.w3.org/1999/xhtml">Why? </span><span class="koboSpan" id="kobo.975.4" xmlns="http://www.w3.org/1999/xhtml">Because it does not affect the business logic or the end-user experience. </span><span class="koboSpan" id="kobo.975.5" xmlns="http://www.w3.org/1999/xhtml">Maybe the customer clicked the remove or update button twice. </span><span class="koboSpan" id="kobo.975.6" xmlns="http://www.w3.org/1999/xhtml">However, the code propagates to the client any other error.Let’s explore the </span><code><span class="koboSpan" id="kobo.976.1" xmlns="http://www.w3.org/1999/xhtml">AddOrUpdateItem</span></code><span class="koboSpan" id="kobo.977.1" xmlns="http://www.w3.org/1999/xhtml"> method’s code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.978.1" xmlns="http://www.w3.org/1999/xhtml">static async Task AddOrUpdateItem(UpdateCartItem item, IWebClient client, ICurrentCustomerService currentCustomer, CancellationToken cancellationToken)
{
    try
    {
        // Add the product to the cart
        var result = await client.Baskets.AddProductToCart(
            new Web.Features.Baskets.AddItem.Command(
                currentCustomer.Id,
                item.ProductId,
                item.Quantity
            ),
            cancellationToken
        );
    }
    catch (ValidationApiException ex)
    {
        if (ex.StatusCode != HttpStatusCode.Conflict)
        {
            throw;
        }
        // Update the cart
        var result = await client.Baskets.UpdateProductQuantity(
            new Web.Features.Baskets.UpdateQuantity.Command(
                currentCustomer.Id,
                item.ProductId,
                item.Quantity
            ),
            cancellationToken
        );
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.979.1" xmlns="http://www.w3.org/1999/xhtml">The preceding logic is very similar to the other method. </span><span class="koboSpan" id="kobo.979.2" xmlns="http://www.w3.org/1999/xhtml">It starts by adding the item to the cart. </span><span class="koboSpan" id="kobo.979.3" xmlns="http://www.w3.org/1999/xhtml">If it receives a </span><code><span class="koboSpan" id="kobo.980.1" xmlns="http://www.w3.org/1999/xhtml">409 Conflict</span></code><span class="koboSpan" id="kobo.981.1" xmlns="http://www.w3.org/1999/xhtml">, it tries to update its quantity. </span><span class="koboSpan" id="kobo.981.2" xmlns="http://www.w3.org/1999/xhtml">Otherwise, it lets the exception bubble up the stack to let an exception middleware catch it later to uniformize the error messages.With that code in place, we can send </span><code><span class="koboSpan" id="kobo.982.1" xmlns="http://www.w3.org/1999/xhtml">POST</span></code><span class="koboSpan" id="kobo.983.1" xmlns="http://www.w3.org/1999/xhtml"> requests to the </span><code><span class="koboSpan" id="kobo.984.1" xmlns="http://www.w3.org/1999/xhtml">api/cart</span></code><span class="koboSpan" id="kobo.985.1" xmlns="http://www.w3.org/1999/xhtml"> endpoint for adding, updating, and removing an item from the cart. </span><span class="koboSpan" id="kobo.985.2" xmlns="http://www.w3.org/1999/xhtml">The three operations return an empty </span><code><span class="koboSpan" id="kobo.986.1" xmlns="http://www.w3.org/1999/xhtml">200 OK</span></code><span class="koboSpan" id="kobo.987.1" xmlns="http://www.w3.org/1999/xhtml"> response.Assuming we have an empty shopping cart, the following request adds </span><em><span class="koboSpan" id="kobo.988.1" xmlns="http://www.w3.org/1999/xhtml">10</span></em> <em><span class="koboSpan" id="kobo.989.1" xmlns="http://www.w3.org/1999/xhtml">Habanero Peppers</span></em><span class="koboSpan" id="kobo.990.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><code><span class="koboSpan" id="kobo.991.1" xmlns="http://www.w3.org/1999/xhtml">id=3</span></code><span class="koboSpan" id="kobo.992.1" xmlns="http://www.w3.org/1999/xhtml">) to the shopping cart:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.993.1" xmlns="http://www.w3.org/1999/xhtml">POST https://localhost:7254/api/cart
Content-Type: application/json
{
    "productId": 3, 
    "quantity": 10
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.994.1" xmlns="http://www.w3.org/1999/xhtml">The following request adds </span><em><span class="koboSpan" id="kobo.995.1" xmlns="http://www.w3.org/1999/xhtml">5 Apples</span></em><span class="koboSpan" id="kobo.996.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><code><span class="koboSpan" id="kobo.997.1" xmlns="http://www.w3.org/1999/xhtml">id=2</span></code><span class="koboSpan" id="kobo.998.1" xmlns="http://www.w3.org/1999/xhtml">) to the cart:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.999.1" xmlns="http://www.w3.org/1999/xhtml">POST https://localhost:7254/api/cart
Content-Type: application/json
{
    "productId": 2, 
    "quantity": 5
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.1000.1" xmlns="http://www.w3.org/1999/xhtml">The following request updates the quantity to </span><em><span class="koboSpan" id="kobo.1001.1" xmlns="http://www.w3.org/1999/xhtml">20</span></em> <em><span class="koboSpan" id="kobo.1002.1" xmlns="http://www.w3.org/1999/xhtml">Habanero Peppers</span></em><span class="koboSpan" id="kobo.1003.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><code><span class="koboSpan" id="kobo.1004.1" xmlns="http://www.w3.org/1999/xhtml">id=3</span></code><span class="koboSpan" id="kobo.1005.1" xmlns="http://www.w3.org/1999/xhtml">) :</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.1006.1" xmlns="http://www.w3.org/1999/xhtml">POST https://localhost:7254/api/cart
Content-Type: application/json
{
    "productId": 3, 
    "quantity": 20
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.1007.1" xmlns="http://www.w3.org/1999/xhtml">The following request removes the </span><em><span class="koboSpan" id="kobo.1008.1" xmlns="http://www.w3.org/1999/xhtml">Apples</span></em><span class="koboSpan" id="kobo.1009.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><code><span class="koboSpan" id="kobo.1010.1" xmlns="http://www.w3.org/1999/xhtml">id=2</span></code><span class="koboSpan" id="kobo.1011.1" xmlns="http://www.w3.org/1999/xhtml">) from the cart:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.1012.1" xmlns="http://www.w3.org/1999/xhtml">POST https://localhost:7254/api/cart
Content-Type: application/json
{
    "productId": 2, 
    "quantity": 0
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.1013.1" xmlns="http://www.w3.org/1999/xhtml">Leaving us with </span><em><span class="koboSpan" id="kobo.1014.1" xmlns="http://www.w3.org/1999/xhtml">20</span></em> <em><span class="koboSpan" id="kobo.1015.1" xmlns="http://www.w3.org/1999/xhtml">Habanero Peppers</span></em><span class="koboSpan" id="kobo.1016.1" xmlns="http://www.w3.org/1999/xhtml"> in our shopping cart (</span><code><span class="koboSpan" id="kobo.1017.1" xmlns="http://www.w3.org/1999/xhtml">GET https://localhost:7254/api/cart</span></code><span class="koboSpan" id="kobo.1018.1" xmlns="http://www.w3.org/1999/xhtml">):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.1019.1" xmlns="http://www.w3.org/1999/xhtml">[
  {
    "id": 3,
    "name": "Habanero Pepper",
    "unitPrice": 0.99,
    "quantity": 20,
    "totalPrice": 19.80
  }
]</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.1020.1" xmlns="http://www.w3.org/1999/xhtml">The requests of the previous sequence are all in the same format, reaching the same endpoint but doing different things, which makes it very easy for the frontend client to manage.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1021.1" xmlns="http://www.w3.org/1999/xhtml">If you prefer having the UI to manage the operations individually or want to implement a batch update feature, you can; this is only an example of what you can leverage a BFF for.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1022.1" xmlns="http://www.w3.org/1999/xhtml">We are now done with the BFF service.</span></p>
</section>
</section>
<section class="level3" data-number="20.7.6" id="conclusion-32">
<h3 data-number="20.7.6"><span class="koboSpan" id="kobo.1023.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.1024.1" xmlns="http://www.w3.org/1999/xhtml">In this section, we learned about using the Backend for Frontend (BFF) design pattern to front a micro e-commerce web application. </span><span class="koboSpan" id="kobo.1024.2" xmlns="http://www.w3.org/1999/xhtml">We discussed layering APIs and the advantages and disadvantages of a two-layer design. </span><span class="koboSpan" id="kobo.1024.3" xmlns="http://www.w3.org/1999/xhtml">We autogenerated strongly typed HTTP clients using Refit, managed a shopping cart, and fetched the catalog from the BFF. </span><span class="koboSpan" id="kobo.1024.4" xmlns="http://www.w3.org/1999/xhtml">We learned how to use a BFF to reduce complexity by moving domain logic from the frontend to the backend by implementing multiple Gateway patterns.Here are a few benefits that we explored:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1025.1" xmlns="http://www.w3.org/1999/xhtml">The BFF pattern can significantly simplify the interaction between frontend and backend systems. </span><span class="koboSpan" id="kobo.1025.2" xmlns="http://www.w3.org/1999/xhtml">It provides a layer of abstraction that can reduce the complexity of using low-level atomic APIs. </span><span class="koboSpan" id="kobo.1025.3" xmlns="http://www.w3.org/1999/xhtml">It separates generic and domain-specific functionalities and promotes cleaner, more modular code.</span></li>
<li><span class="koboSpan" id="kobo.1026.1" xmlns="http://www.w3.org/1999/xhtml">A BFF can act as a gateway that routes specific requests to relevant services, reducing the work the frontend has to perform. </span><span class="koboSpan" id="kobo.1026.2" xmlns="http://www.w3.org/1999/xhtml">It can also serve as an aggregation gateway, gathering data from various services into a unified response. </span><span class="koboSpan" id="kobo.1026.3" xmlns="http://www.w3.org/1999/xhtml">This process can simplify frontend development by reducing the complexity of the frontend and the number of separate calls the frontend must make. </span><span class="koboSpan" id="kobo.1026.4" xmlns="http://www.w3.org/1999/xhtml">It can also reduce the payload size transported between the frontend and backend.</span></li>
<li><span class="koboSpan" id="kobo.1027.1" xmlns="http://www.w3.org/1999/xhtml">Each BFF is tailored to a specific client, optimizing the frontend interaction.</span></li>
<li><span class="koboSpan" id="kobo.1028.1" xmlns="http://www.w3.org/1999/xhtml">A BFF can handle issues in one domain without affecting the low-level APIs or the other applications, thus providing easier maintenance.</span></li>
<li><span class="koboSpan" id="kobo.1029.1" xmlns="http://www.w3.org/1999/xhtml">A BFF can implement security logic, such as specific domain-oriented authentication and authorization rules.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.1030.1" xmlns="http://www.w3.org/1999/xhtml">Despite these benefits, using a BFF may also increase complexity and introduce potential performance overhead. </span><span class="koboSpan" id="kobo.1030.2" xmlns="http://www.w3.org/1999/xhtml">Using a BFF is no different than any other pattern and must be counter-balanced and adapted to the specific needs of a project.Next, we revisit CQRS on a distributed scale.</span></p>
</section>
</section>
<section class="level2" data-number="20.8" id="revisiting-the-cqrs-pattern">
<h2 data-number="20.8"><span class="koboSpan" id="kobo.1031.1" xmlns="http://www.w3.org/1999/xhtml">Revisiting the CQRS pattern</span></h2>
<p><strong><span class="koboSpan" id="kobo.1032.1" xmlns="http://www.w3.org/1999/xhtml">Command Query Responsibility Segregation</span></strong><span class="koboSpan" id="kobo.1033.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.1034.1" xmlns="http://www.w3.org/1999/xhtml">CQRS</span></strong><span class="koboSpan" id="kobo.1035.1" xmlns="http://www.w3.org/1999/xhtml">) applies the </span><strong><span class="koboSpan" id="kobo.1036.1" xmlns="http://www.w3.org/1999/xhtml">Command Query Separation</span></strong><span class="koboSpan" id="kobo.1037.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.1038.1" xmlns="http://www.w3.org/1999/xhtml">CQS</span></strong><span class="koboSpan" id="kobo.1039.1" xmlns="http://www.w3.org/1999/xhtml">) principle. </span><span class="koboSpan" id="kobo.1039.2" xmlns="http://www.w3.org/1999/xhtml">Compared to what we saw in </span><em><span class="koboSpan" id="kobo.1040.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 14</span></em><span class="koboSpan" id="kobo.1041.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.1042.1" xmlns="http://www.w3.org/1999/xhtml">Mediator and CQRS Design Patterns</span></em><span class="koboSpan" id="kobo.1043.1" xmlns="http://www.w3.org/1999/xhtml">, we can push CQRS further using microservices or serverless computing. </span><span class="koboSpan" id="kobo.1043.2" xmlns="http://www.w3.org/1999/xhtml">Instead of simply creating a clear separation between commands and queries, we can divide them even more using multiple microservices and data sources.</span><strong><span class="koboSpan" id="kobo.1044.1" xmlns="http://www.w3.org/1999/xhtml">CQS</span></strong><span class="koboSpan" id="kobo.1045.1" xmlns="http://www.w3.org/1999/xhtml"> is a principle stating that a method should either return data or mutate data, but not both. </span><span class="koboSpan" id="kobo.1045.2" xmlns="http://www.w3.org/1999/xhtml">On the other hand, </span><strong><span class="koboSpan" id="kobo.1046.1" xmlns="http://www.w3.org/1999/xhtml">CQRS</span></strong><span class="koboSpan" id="kobo.1047.1" xmlns="http://www.w3.org/1999/xhtml"> suggests using one model to read the data and one model to mutate the data.</span><strong><span class="koboSpan" id="kobo.1048.1" xmlns="http://www.w3.org/1999/xhtml">Serverless computing</span></strong><span class="koboSpan" id="kobo.1049.1" xmlns="http://www.w3.org/1999/xhtml"> is a cloud execution model where the cloud provider manages the servers and allocates the resources on-demand, based on usage and configuration. </span><span class="koboSpan" id="kobo.1049.2" xmlns="http://www.w3.org/1999/xhtml">Serverless resources fall into the platform as a service (PaaS) offering.Let’s come back to our IoT example again. </span><span class="koboSpan" id="kobo.1049.3" xmlns="http://www.w3.org/1999/xhtml">We queried the last known location of a device in the previous examples, but what about the device updating that location? </span><span class="koboSpan" id="kobo.1049.4" xmlns="http://www.w3.org/1999/xhtml">This can mean pushing many updates every minute. </span><span class="koboSpan" id="kobo.1049.5" xmlns="http://www.w3.org/1999/xhtml">To solve this issue, we are going to use CQRS and focus on two operations:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1050.1" xmlns="http://www.w3.org/1999/xhtml">Updating the device location.</span></li>
<li><span class="koboSpan" id="kobo.1051.1" xmlns="http://www.w3.org/1999/xhtml">Reading the last known location of a device.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.1052.1" xmlns="http://www.w3.org/1999/xhtml">Simply put, we have a </span><code><span class="koboSpan" id="kobo.1053.1" xmlns="http://www.w3.org/1999/xhtml">Read Location</span></code><span class="koboSpan" id="kobo.1054.1" xmlns="http://www.w3.org/1999/xhtml"> microservice, a </span><code><span class="koboSpan" id="kobo.1055.1" xmlns="http://www.w3.org/1999/xhtml">Write Location</span></code><span class="koboSpan" id="kobo.1056.1" xmlns="http://www.w3.org/1999/xhtml"> microservice, and two databases. </span><span class="koboSpan" id="kobo.1056.2" xmlns="http://www.w3.org/1999/xhtml">Remember that each microservice should own its data. </span><span class="koboSpan" id="kobo.1056.3" xmlns="http://www.w3.org/1999/xhtml">This way, a user can access the last known device location through the read microservice (query model), while a device can punctually send its current position to the write microservice (command model). </span><span class="koboSpan" id="kobo.1056.4" xmlns="http://www.w3.org/1999/xhtml">By doing this, we split the load from reading and writing the data as both occur at different frequencies:</span></p>
<figure>
<span class="koboSpan" id="kobo.1057.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.30: Microservices that apply CQRS to divide the reads and writes of a device’s location" src="../media/file158.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1058.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.30: Microservices that apply CQRS to divide the reads and writes of a device’s location</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1059.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding schema that illustrates the concept, the reads are queries, and the writes are commands. </span><span class="koboSpan" id="kobo.1059.2" xmlns="http://www.w3.org/1999/xhtml">How to update the Read DB once a new value is added to the Write DB depends on the technology at play. </span><span class="koboSpan" id="kobo.1059.3" xmlns="http://www.w3.org/1999/xhtml">One essential thing in this type of architecture is that, per the CQRS pattern, a command should not return a value, enabling a “fire and forget” scenario. </span><span class="koboSpan" id="kobo.1059.4" xmlns="http://www.w3.org/1999/xhtml">With that rule in place, consumers don’t have to wait for the command to complete before doing something else.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1060.1" xmlns="http://www.w3.org/1999/xhtml">Fire and forget does not apply to every scenario; sometimes, we need synchronization. </span><span class="koboSpan" id="kobo.1060.2" xmlns="http://www.w3.org/1999/xhtml">Implementing the Saga pattern is one way to solve coordination issues.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1061.1" xmlns="http://www.w3.org/1999/xhtml">Conceptually, we can implement this example by leveraging serverless cloud infrastructures, such as Azure Functions. </span><span class="koboSpan" id="kobo.1061.2" xmlns="http://www.w3.org/1999/xhtml">Let’s revisit this example using a high-level conceptual serverless design:</span></p>
<figure>
<span class="koboSpan" id="kobo.1062.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.31: Using Azure services to manage a CQRS implementation" src="../media/file159.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1063.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.31: Using Azure services to manage a CQRS implementation</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1064.1" xmlns="http://www.w3.org/1999/xhtml">The previous diagram illustrates the following:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.1065.1" xmlns="http://www.w3.org/1999/xhtml">The device sends its location regularly by posting it to </span><em><span class="koboSpan" id="kobo.1066.1" xmlns="http://www.w3.org/1999/xhtml">Azure Function 1</span></em><span class="koboSpan" id="kobo.1067.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><em><span class="koboSpan" id="kobo.1068.1" xmlns="http://www.w3.org/1999/xhtml">Azure Function 1</span></em><span class="koboSpan" id="kobo.1069.1" xmlns="http://www.w3.org/1999/xhtml"> then publishes the </span><code><span class="koboSpan" id="kobo.1070.1" xmlns="http://www.w3.org/1999/xhtml">LocationAdded</span></code><span class="koboSpan" id="kobo.1071.1" xmlns="http://www.w3.org/1999/xhtml"> event to the event broker, which is also an event store (the Write DB).</span></li>
<li><span class="koboSpan" id="kobo.1072.1" xmlns="http://www.w3.org/1999/xhtml">All subscribers to the </span><code><span class="koboSpan" id="kobo.1073.1" xmlns="http://www.w3.org/1999/xhtml">LocationAdded</span></code><span class="koboSpan" id="kobo.1074.1" xmlns="http://www.w3.org/1999/xhtml"> event can now handle the event appropriately, in this case, </span><em><span class="koboSpan" id="kobo.1075.1" xmlns="http://www.w3.org/1999/xhtml">Azure Function 2</span></em><span class="koboSpan" id="kobo.1076.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><em><span class="koboSpan" id="kobo.1077.1" xmlns="http://www.w3.org/1999/xhtml">Azure Function 2</span></em><span class="koboSpan" id="kobo.1078.1" xmlns="http://www.w3.org/1999/xhtml"> updates the device's last known location in the </span><em><span class="koboSpan" id="kobo.1079.1" xmlns="http://www.w3.org/1999/xhtml">Read DB</span></em><span class="koboSpan" id="kobo.1080.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.1081.1" xmlns="http://www.w3.org/1999/xhtml">Any subsequent queries should result in reading the new location.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.1082.1" xmlns="http://www.w3.org/1999/xhtml">The message broker is also the event store in the preceding diagram, but we could store events elsewhere, such as in an Azure Storage Table, in a time-series database, or in an Apache Kafka cluster. </span><span class="koboSpan" id="kobo.1082.2" xmlns="http://www.w3.org/1999/xhtml">Azure-wise, the datastore could also be CosmosDB. </span><span class="koboSpan" id="kobo.1082.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, I abstracted this component for multiple reasons, including the fact that there are multiple “as-a-service” offerings to publish events in Azure and multiple ways of using third-party components (both open-source and proprietary).Furthermore, the example demonstrates </span><strong><span class="koboSpan" id="kobo.1083.1" xmlns="http://www.w3.org/1999/xhtml">eventual consistency</span></strong><span class="koboSpan" id="kobo.1084.1" xmlns="http://www.w3.org/1999/xhtml"> well. </span><span class="koboSpan" id="kobo.1084.2" xmlns="http://www.w3.org/1999/xhtml">All the last known location reads between </span><em><span class="koboSpan" id="kobo.1085.1" xmlns="http://www.w3.org/1999/xhtml">steps 1</span></em><span class="koboSpan" id="kobo.1086.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><em><span class="koboSpan" id="kobo.1087.1" xmlns="http://www.w3.org/1999/xhtml">4</span></em><span class="koboSpan" id="kobo.1088.1" xmlns="http://www.w3.org/1999/xhtml"> get the old value while the system processes the new location updates (commands). </span><span class="koboSpan" id="kobo.1088.2" xmlns="http://www.w3.org/1999/xhtml">If the command processing slows down for some reason, a longer delay could occur before the next read database updates. </span><span class="koboSpan" id="kobo.1088.3" xmlns="http://www.w3.org/1999/xhtml">The commands could also be processed in batches, leading to another kind of delay. </span><span class="koboSpan" id="kobo.1088.4" xmlns="http://www.w3.org/1999/xhtml">No matter what happens with the command processing, the read database is available all that time, whether it serves the latest data or not and whether the write system is overloaded or not. </span><span class="koboSpan" id="kobo.1088.5" xmlns="http://www.w3.org/1999/xhtml">This is the beauty of this type of design, but it is more complex to implement and maintain.</span></p>
<blockquote>
<p><strong><span class="koboSpan" id="kobo.1089.1" xmlns="http://www.w3.org/1999/xhtml">Time-series databases</span></strong><span class="koboSpan" id="kobo.1090.1" xmlns="http://www.w3.org/1999/xhtml"> are optimized for temporally querying and storing data, where you always append new records without updating old ones. </span><span class="koboSpan" id="kobo.1090.2" xmlns="http://www.w3.org/1999/xhtml">This kind of NoSQL database can be useful for temporal-intensive usage, like metrics.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1091.1" xmlns="http://www.w3.org/1999/xhtml">Once again, we used the Publish-Subscribe pattern to get another scenario going. </span><span class="koboSpan" id="kobo.1091.2" xmlns="http://www.w3.org/1999/xhtml">Assuming that events are persisted forever, the previous example could also support event sourcing. </span><span class="koboSpan" id="kobo.1091.3" xmlns="http://www.w3.org/1999/xhtml">Furthermore, new services could subscribe to the </span><code><span class="koboSpan" id="kobo.1092.1" xmlns="http://www.w3.org/1999/xhtml">LocationAdded</span></code><span class="koboSpan" id="kobo.1093.1" xmlns="http://www.w3.org/1999/xhtml"> event without impacting the code that has already been deployed. </span><span class="koboSpan" id="kobo.1093.2" xmlns="http://www.w3.org/1999/xhtml">For example, we could create a SignalR microservice that pushes the updates to its clients. </span><span class="koboSpan" id="kobo.1093.3" xmlns="http://www.w3.org/1999/xhtml">It is not CQRS-related, but it flows well with everything that we’ve explored so far, so here is an updated conceptual diagram:</span></p>
<figure>
<span class="koboSpan" id="kobo.1094.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.32: Adding a SignalR service as a new subscriber without impacting the other part of the system" src="../media/file160.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1095.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.32: Adding a SignalR service as a new subscriber without impacting the other part of the system</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1096.1" xmlns="http://www.w3.org/1999/xhtml">The SignalR microservice could be custom code or an Azure SignalR Service (backed by another Azure Function); it doesn’t matter. </span><span class="koboSpan" id="kobo.1096.2" xmlns="http://www.w3.org/1999/xhtml">With this design, the Web App could know that a change occurred before the Read DB gets updated.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1097.1" xmlns="http://www.w3.org/1999/xhtml">With this design, I wanted to illustrate that dropping new services into the mix is easier when using a Pub-Sub model than with point-to-point communication.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1098.1" xmlns="http://www.w3.org/1999/xhtml">As you can see, a microservices system adds more and more small pieces that indirectly interconnect with each other over one or more message brokers. </span><span class="koboSpan" id="kobo.1098.2" xmlns="http://www.w3.org/1999/xhtml">Maintaining, diagnosing, and debugging such systems is harder than with a single application; that’s the </span><strong><span class="koboSpan" id="kobo.1099.1" xmlns="http://www.w3.org/1999/xhtml">operational complexity</span></strong><span class="koboSpan" id="kobo.1100.1" xmlns="http://www.w3.org/1999/xhtml"> we discussed earlier. </span><span class="koboSpan" id="kobo.1100.2" xmlns="http://www.w3.org/1999/xhtml">However, containers can help deploy and maintain such systems.Starting in ASP.NET Core 3.0, the ASP.NET Core team invested much effort into </span><strong><span class="koboSpan" id="kobo.1101.1" xmlns="http://www.w3.org/1999/xhtml">distributed tracing</span></strong><span class="koboSpan" id="kobo.1102.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.1102.2" xmlns="http://www.w3.org/1999/xhtml">Distributed tracing is necessary to find failures and bottlenecks related to an event that flows from one program to another (such as microservices). </span><span class="koboSpan" id="kobo.1102.3" xmlns="http://www.w3.org/1999/xhtml">If something bugs out, it is important to trace what the user did to isolate the error, reproduce it, and then fix it. </span><span class="koboSpan" id="kobo.1102.4" xmlns="http://www.w3.org/1999/xhtml">The more independent pieces there are, the harder it can become to make that trace possible. </span><span class="koboSpan" id="kobo.1102.5" xmlns="http://www.w3.org/1999/xhtml">This is outside the scope of this book, but it is something to consider if you plan to leverage microservices.</span></p>
<section class="level3" data-number="20.8.1" id="advantages-and-potential-risks">
<h3 data-number="20.8.1"><span class="koboSpan" id="kobo.1103.1" xmlns="http://www.w3.org/1999/xhtml">Advantages and potential risks</span></h3>
<p><span class="koboSpan" id="kobo.1104.1" xmlns="http://www.w3.org/1999/xhtml">This section explores some advantages and risks of separating a data store's read and write operations using the CQRS pattern.</span></p>
<section class="level4" data-number="20.8.1.1" id="benefits-of-the-cqrs-pattern">
<h4 data-number="20.8.1.1"><span class="koboSpan" id="kobo.1105.1" xmlns="http://www.w3.org/1999/xhtml">Benefits of the CQRS pattern</span></h4>
<ul>
<li><strong><span class="koboSpan" id="kobo.1106.1" xmlns="http://www.w3.org/1999/xhtml">Scalability:</span></strong><span class="koboSpan" id="kobo.1107.1" xmlns="http://www.w3.org/1999/xhtml"> Given that read and write workloads can be scaled independently, CQRS can lead to much higher scalability in a distributed cloud- or microservices-based applications.</span></li>
<li><strong><span class="koboSpan" id="kobo.1108.1" xmlns="http://www.w3.org/1999/xhtml">Simplified and Optimized Models:</span></strong><span class="koboSpan" id="kobo.1109.1" xmlns="http://www.w3.org/1999/xhtml"> It separates the read model (query responsibility) and write model (command responsibility), which simplifies application development and can optimize performance.</span></li>
<li><strong><span class="koboSpan" id="kobo.1110.1" xmlns="http://www.w3.org/1999/xhtml">Flexibility:</span></strong><span class="koboSpan" id="kobo.1111.1" xmlns="http://www.w3.org/1999/xhtml"> Different models increase the number of choices one can make, increasing flexibility.</span></li>
<li><strong><span class="koboSpan" id="kobo.1112.1" xmlns="http://www.w3.org/1999/xhtml">Enhanced Performance:</span></strong><span class="koboSpan" id="kobo.1113.1" xmlns="http://www.w3.org/1999/xhtml"> CQRS can prevent unnecessary data fetching and allows choosing an optimized database for each job, improving the performance of both read and write operations.</span></li>
<li><strong><span class="koboSpan" id="kobo.1114.1" xmlns="http://www.w3.org/1999/xhtml">Increased Efficiency:</span></strong><span class="koboSpan" id="kobo.1115.1" xmlns="http://www.w3.org/1999/xhtml"> It enables parallel development on complex applications, as teams can work independently on the separate read and write sides of the application.</span></li>
</ul>
</section>
<section class="level4" data-number="20.8.1.2" id="potential-risks-of-using-the-cqrs-pattern">
<h4 data-number="20.8.1.2"><span class="koboSpan" id="kobo.1116.1" xmlns="http://www.w3.org/1999/xhtml">Potential Risks of using the CQRS pattern</span></h4>
<ul>
<li><strong><span class="koboSpan" id="kobo.1117.1" xmlns="http://www.w3.org/1999/xhtml">Complexity:</span></strong><span class="koboSpan" id="kobo.1118.1" xmlns="http://www.w3.org/1999/xhtml"> CQRS adds complexity to the system. </span><span class="koboSpan" id="kobo.1118.2" xmlns="http://www.w3.org/1999/xhtml">It may not be necessary for simple CRUD apps and could over-complicate the application unnecessarily. </span><span class="koboSpan" id="kobo.1118.3" xmlns="http://www.w3.org/1999/xhtml">Therefore, using CQRS only in complex systems and when the advantages outweigh the cons is advisable.</span></li>
<li><strong><span class="koboSpan" id="kobo.1119.1" xmlns="http://www.w3.org/1999/xhtml">Data Consistency:</span></strong><span class="koboSpan" id="kobo.1120.1" xmlns="http://www.w3.org/1999/xhtml"> It can introduce eventual consistency issues between the read and write sides because the read model's updates are asynchronous, which might not fit every business requirement.</span></li>
<li><strong><span class="koboSpan" id="kobo.1121.1" xmlns="http://www.w3.org/1999/xhtml">Increased Development Effort:</span></strong><span class="koboSpan" id="kobo.1122.1" xmlns="http://www.w3.org/1999/xhtml"> CQRS could mean increased development, testing, and maintenance efforts due to handling two separate models and more pieces.</span></li>
<li><strong><span class="koboSpan" id="kobo.1123.1" xmlns="http://www.w3.org/1999/xhtml">Learning Curve:</span></strong><span class="koboSpan" id="kobo.1124.1" xmlns="http://www.w3.org/1999/xhtml"> The pattern has its own learning curve. </span><span class="koboSpan" id="kobo.1124.2" xmlns="http://www.w3.org/1999/xhtml">Team members unfamiliar with the CQRS pattern will require training and to gain some experience.</span></li>
<li><strong><span class="koboSpan" id="kobo.1125.1" xmlns="http://www.w3.org/1999/xhtml">Synchronization Challenges:</span></strong><span class="koboSpan" id="kobo.1126.1" xmlns="http://www.w3.org/1999/xhtml"> Maintaining synchronization between the read and write models can be challenging, especially in high data volume cases.</span></li>
</ul>
</section>
</section>
<section class="level3" data-number="20.8.2" id="conclusion-33">
<h3 data-number="20.8.2"><span class="koboSpan" id="kobo.1127.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.1128.1" xmlns="http://www.w3.org/1999/xhtml">CQRS helps divide queries and commands and helps encapsulate and isolate each block of logic independently. </span><span class="koboSpan" id="kobo.1128.2" xmlns="http://www.w3.org/1999/xhtml">Mixing that concept with serverless computing or microservices architecture allows us to scale reads and writes independently. </span><span class="koboSpan" id="kobo.1128.3" xmlns="http://www.w3.org/1999/xhtml">We can also use different databases, empowering us with the tools we need for the transfer rate required by each part of that system (for example, frequent writes and occasional reads or vice versa).Major cloud providers like Azure and AWS provide serverless offerings to help support such scenarios. </span><span class="koboSpan" id="kobo.1128.4" xmlns="http://www.w3.org/1999/xhtml">Each cloud provider’s documentation should help you get started. </span><span class="koboSpan" id="kobo.1128.5" xmlns="http://www.w3.org/1999/xhtml">Meanwhile, for Azure, we have Azure Functions, Event Grid, Event Hubs, Service Bus, Cosmos DB, and more. </span><span class="koboSpan" id="kobo.1128.6" xmlns="http://www.w3.org/1999/xhtml">Azure also offers bindings between the different services that are triggered or react to events for you, removing a part of the complexity yet locking you down with that vendor.Now, let’s see how CQRS can help us follow the </span><strong><span class="koboSpan" id="kobo.1129.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.1130.1" xmlns="http://www.w3.org/1999/xhtml"> principles at the cloud scale:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.1131.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.1132.1" xmlns="http://www.w3.org/1999/xhtml">: Dividing an application into smaller reads and writes applications (or functions) leans toward encapsulating single responsibilities into different programs.</span></li>
<li><strong><span class="koboSpan" id="kobo.1133.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.1134.1" xmlns="http://www.w3.org/1999/xhtml">: CQRS, mixed with serverless computing or microservices, helps extend the software without needing us to modify the existing code by adding, removing, or replacing applications.</span></li>
<li><strong><span class="koboSpan" id="kobo.1135.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.1136.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
<li><strong><span class="koboSpan" id="kobo.1137.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.1138.1" xmlns="http://www.w3.org/1999/xhtml">: CQRS set us up to create multiple small interfaces (or programs) with a clear distinction between commands and queries.</span></li>
<li><strong><span class="koboSpan" id="kobo.1139.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.1140.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
</ul>
</section>
</section>
<section class="level2" data-number="20.9" id="exploring-the-microservice-adapter-pattern">
<h2 data-number="20.9"><span class="koboSpan" id="kobo.1141.1" xmlns="http://www.w3.org/1999/xhtml">Exploring the Microservice Adapter pattern</span></h2>
<p><span class="koboSpan" id="kobo.1142.1" xmlns="http://www.w3.org/1999/xhtml">The Microservice Adapter pattern allows adding missing features, adapting one system to another, or migrating an existing application to an event-driven architecture model, to name a few possibilities. </span><span class="koboSpan" id="kobo.1142.2" xmlns="http://www.w3.org/1999/xhtml">The Microservice Adapter pattern is similar to the Adapter pattern we cover in </span><em><span class="koboSpan" id="kobo.1143.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 9</span></em><span class="koboSpan" id="kobo.1144.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.1145.1" xmlns="http://www.w3.org/1999/xhtml">Structural Patterns</span></em><span class="koboSpan" id="kobo.1146.1" xmlns="http://www.w3.org/1999/xhtml">, but applied to a microservices system that uses event-driven architecture instead of creating a class to adapt an object to another signature.In the scenarios we cover in this section, the microservices system represented by the following diagram can be replaced by a standalone application as well; this pattern applies to all sorts of programs, not just microservices, which is why I abstracted away the details:</span></p>
<figure>
<span class="koboSpan" id="kobo.1147.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.33: Microservice system representation used in the subsequent examples" src="../media/file161.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1148.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.33: Microservice system representation used in the subsequent examples</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1149.1" xmlns="http://www.w3.org/1999/xhtml">Here are the examples we are covering next and possible usages of this pattern:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1150.1" xmlns="http://www.w3.org/1999/xhtml">Adapting an existing system to another.</span></li>
<li><span class="koboSpan" id="kobo.1151.1" xmlns="http://www.w3.org/1999/xhtml">Decommissioning a legacy application.</span></li>
<li><span class="koboSpan" id="kobo.1152.1" xmlns="http://www.w3.org/1999/xhtml">Adapting an event broker to another.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.1153.1" xmlns="http://www.w3.org/1999/xhtml">Let’s start by connecting a standalone system to an event-driven one.</span></p>
<section class="level3" data-number="20.9.1" id="adapting-an-existing-system-to-another">
<h3 data-number="20.9.1"><span class="koboSpan" id="kobo.1154.1" xmlns="http://www.w3.org/1999/xhtml">Adapting an existing system to another</span></h3>
<p><span class="koboSpan" id="kobo.1155.1" xmlns="http://www.w3.org/1999/xhtml">In this scenario, we have an existing system of which we don’t control the source code or don’t want to change, and we have a microservices system built around an event-driven architecture model. </span><span class="koboSpan" id="kobo.1155.2" xmlns="http://www.w3.org/1999/xhtml">We don’t have to control the source code of the microservices system either as long as we have access to the event broker.Here is a diagram that represents this scenario:</span></p>
<figure>
<span class="koboSpan" id="kobo.1156.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.34: A microservices system that interacts with an event broker and an existing system that is disconnected from the microservices" src="../media/file162.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1157.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.34: A microservices system that interacts with an event broker and an existing system that is disconnected from the microservices</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1158.1" xmlns="http://www.w3.org/1999/xhtml">As we can see from the preceding diagram, the existing system is disconnected from the microservices and the broker. </span><span class="koboSpan" id="kobo.1158.2" xmlns="http://www.w3.org/1999/xhtml">To adapt the existing system to the microservices system, we must subscribe or publish certain events. </span><span class="koboSpan" id="kobo.1158.3" xmlns="http://www.w3.org/1999/xhtml">Let’s see how to read data from the microservices (subscribe to the broker) and then update that data into the existing system.When we control the existing system’s code, we can open the source code, subscribe to one or more topics, and change the behaviors from there. </span><span class="koboSpan" id="kobo.1158.4" xmlns="http://www.w3.org/1999/xhtml">In our case, we don’t want to do that or can’t, so we can’t directly subscribe to topics, as demonstrated by the following diagram:</span></p>
<figure>
<span class="koboSpan" id="kobo.1159.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.35: Missing capabilities to connect an existing system to an event-driven one" src="../media/file163.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1160.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.35: Missing capabilities to connect an existing system to an event-driven one</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1161.1" xmlns="http://www.w3.org/1999/xhtml">This is where the microservice adapter comes into play and allows us to fill the capability gap of our existing system. </span><span class="koboSpan" id="kobo.1161.2" xmlns="http://www.w3.org/1999/xhtml">To add the missing link, we create a microservice that subscribes to the appropriate events, then apply the changes in the existing system, like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.1162.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.36: An adapter microservice adding missing capabilities to an existing system" src="../media/file164.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1163.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.36: An adapter microservice adding missing capabilities to an existing system</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1164.1" xmlns="http://www.w3.org/1999/xhtml">As we can see in the preceding diagram, the </span><code><span class="koboSpan" id="kobo.1165.1" xmlns="http://www.w3.org/1999/xhtml">Adapter</span></code><span class="koboSpan" id="kobo.1166.1" xmlns="http://www.w3.org/1999/xhtml"> microservice gets the events (subscribes to one or more topics) and then uses that data from the microservices system to execute some business logic on the existing system.In this design, the new </span><code><span class="koboSpan" id="kobo.1167.1" xmlns="http://www.w3.org/1999/xhtml">Adapter</span></code><span class="koboSpan" id="kobo.1168.1" xmlns="http://www.w3.org/1999/xhtml"> microservice allowed us to add missing capabilities to a system we had no control over with little to no disruption to users’ day-to-day activities.The example assumes the existing system had some form of extensibility mechanism like an API. </span><span class="koboSpan" id="kobo.1168.2" xmlns="http://www.w3.org/1999/xhtml">If the system does not, we would have to be more creative to interface with it.For example, the microservices system could be an e-commerce website, and the existing system could be a legacy inventory management system. </span><span class="koboSpan" id="kobo.1168.3" xmlns="http://www.w3.org/1999/xhtml">The adapter could update the legacy system with new order data.The existing system could also be an old </span><strong><span class="koboSpan" id="kobo.1169.1" xmlns="http://www.w3.org/1999/xhtml">customer relationship management</span></strong><span class="koboSpan" id="kobo.1170.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.1171.1" xmlns="http://www.w3.org/1999/xhtml">CRM</span></strong><span class="koboSpan" id="kobo.1172.1" xmlns="http://www.w3.org/1999/xhtml">) system that you want to update when users of the microservices application execute some actions, like changing their phone number or address.The possibilities are almost endless; you create a link between an event-driven system and an existing system you don’t control or don’t want to change. </span><span class="koboSpan" id="kobo.1172.2" xmlns="http://www.w3.org/1999/xhtml">In this case, the microservice adapter allows us to follow the </span><strong><span class="koboSpan" id="kobo.1173.1" xmlns="http://www.w3.org/1999/xhtml">Open-Closed principle</span></strong><span class="koboSpan" id="kobo.1174.1" xmlns="http://www.w3.org/1999/xhtml"> by extending the system without changing the existing pieces. </span><span class="koboSpan" id="kobo.1174.2" xmlns="http://www.w3.org/1999/xhtml">The primary drawback is that we are deploying another microservice that has direct coupling with the existing system, which may be best for temporary solutions. </span><span class="koboSpan" id="kobo.1174.3" xmlns="http://www.w3.org/1999/xhtml">On that same line of thought, next, we replace a legacy application with a new one with limited to no downtime.</span></p>
</section>
<section class="level3" data-number="20.9.2" id="decommissioning-a-legacy-application">
<h3 data-number="20.9.2"><span class="koboSpan" id="kobo.1175.1" xmlns="http://www.w3.org/1999/xhtml">Decommissioning a legacy application</span></h3>
<p><span class="koboSpan" id="kobo.1176.1" xmlns="http://www.w3.org/1999/xhtml">In this scenario, we have a legacy application to decommission and a microservices system to which we want to connect some existing capabilities. </span><span class="koboSpan" id="kobo.1176.2" xmlns="http://www.w3.org/1999/xhtml">To achieve this, we can create one or more adapters to migrate all features and dependencies to the new model.Here is a representation of the current state of our system:</span></p>
<figure>
<span class="koboSpan" id="kobo.1177.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.37: The original legacy application and its dependencies" src="../media/file165.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1178.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.37: The original legacy application and its dependencies</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1179.1" xmlns="http://www.w3.org/1999/xhtml">The preceding diagram shows the two distinct systems, including the legacy application we want to decommission. </span><span class="koboSpan" id="kobo.1179.2" xmlns="http://www.w3.org/1999/xhtml">Two other applications, dependency A and B, directly depend on the legacy application. </span><span class="koboSpan" id="kobo.1179.3" xmlns="http://www.w3.org/1999/xhtml">The exact migration flow is strongly dependent on your use case. </span><span class="koboSpan" id="kobo.1179.4" xmlns="http://www.w3.org/1999/xhtml">If you want to keep the dependencies, we want to migrate them first. </span><span class="koboSpan" id="kobo.1179.5" xmlns="http://www.w3.org/1999/xhtml">To do that, we can create an event-driven </span><code><span class="koboSpan" id="kobo.1180.1" xmlns="http://www.w3.org/1999/xhtml">Adapter</span></code><span class="koboSpan" id="kobo.1181.1" xmlns="http://www.w3.org/1999/xhtml"> microservice that breaks the tight coupling between the dependencies and the legacy application like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.1182.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.38: Adding a microservice adapter that implements the event-driven flow required to break tight coupling between the dependencies and the legacy application" src="../media/file166.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1183.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.38: Adding a microservice adapter that implements the event-driven flow required to break tight coupling between the dependencies and the legacy application</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1184.1" xmlns="http://www.w3.org/1999/xhtml">The preceding diagram shows an </span><code><span class="koboSpan" id="kobo.1185.1" xmlns="http://www.w3.org/1999/xhtml">Adapter</span></code><span class="koboSpan" id="kobo.1186.1" xmlns="http://www.w3.org/1999/xhtml"> microservice and the rest of a microservices system that communicates using an event broker. </span><span class="koboSpan" id="kobo.1186.2" xmlns="http://www.w3.org/1999/xhtml">As we explored in the previous example, the adapter was placed there to connect the legacy application to the microservices. </span><span class="koboSpan" id="kobo.1186.3" xmlns="http://www.w3.org/1999/xhtml">Our scenario focuses on removing the legacy application and migrating its two dependencies. </span><span class="koboSpan" id="kobo.1186.4" xmlns="http://www.w3.org/1999/xhtml">Here, we carved out the required capabilities using the adapter, allowing us to migrate the dependencies to an event-driven model and break tight coupling with the legacy application. </span><span class="koboSpan" id="kobo.1186.5" xmlns="http://www.w3.org/1999/xhtml">Such migration could be done in multiple steps, migrating each dependency one by one, and we could even create one adapter per dependency. </span><span class="koboSpan" id="kobo.1186.6" xmlns="http://www.w3.org/1999/xhtml">For the sake of simplicity, I chose to draw only one adapter. </span><span class="koboSpan" id="kobo.1186.7" xmlns="http://www.w3.org/1999/xhtml">You may want to revisit this choice if your dependencies are large or complex.Once we are done migrating the dependencies, our systems look like the following:</span></p>
<figure>
<span class="koboSpan" id="kobo.1187.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.39: The dependencies are now using an event-driven architecture, and the adapter microservice is bridging the gap between the events and the legacy system" src="../media/file167.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1188.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.39: The dependencies are now using an event-driven architecture, and the adapter microservice is bridging the gap between the events and the legacy system</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1189.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding diagram, the Adapter microservice executes the operations against the legacy application API that the two dependencies were doing before. </span><span class="koboSpan" id="kobo.1189.2" xmlns="http://www.w3.org/1999/xhtml">The dependencies are now publishing events instead of using the API. </span><span class="koboSpan" id="kobo.1189.3" xmlns="http://www.w3.org/1999/xhtml">For example, when an operation happens in </span><code><span class="koboSpan" id="kobo.1190.1" xmlns="http://www.w3.org/1999/xhtml">DependencyB</span></code><span class="koboSpan" id="kobo.1191.1" xmlns="http://www.w3.org/1999/xhtml">, it publishes an event to the broker. </span><span class="koboSpan" id="kobo.1191.2" xmlns="http://www.w3.org/1999/xhtml">The Adapter microservice picks up that event and executes the original operation against the API. </span><span class="koboSpan" id="kobo.1191.3" xmlns="http://www.w3.org/1999/xhtml">Doing this creates more complexity and is a temporary state.With this new architecture in place, we can start migrating existing features away from the legacy application into the new application without impacting the dependencies; we broke tight coupling.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1192.1" xmlns="http://www.w3.org/1999/xhtml">From this point forward, we are applying the </span><strong><span class="koboSpan" id="kobo.1193.1" xmlns="http://www.w3.org/1999/xhtml">Strangler Fig</span></strong><span class="koboSpan" id="kobo.1194.1" xmlns="http://www.w3.org/1999/xhtml"> pattern to migrate the legacy system piece by piece to our new architecture. </span><span class="koboSpan" id="kobo.1194.2" xmlns="http://www.w3.org/1999/xhtml">For the sake of simplicity, think of the Strangler Fig pattern as migrating features from one application to another, one by one. </span><span class="koboSpan" id="kobo.1194.3" xmlns="http://www.w3.org/1999/xhtml">In this case, we replaced one application with another, but we could also use the same patterns to split an application into multiple smaller applications (like microservices).</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1195.1" xmlns="http://www.w3.org/1999/xhtml">I left a few links in the further reading section in case migrating legacy systems is something you do or simply if you want to know more about that pattern.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.1196.1" xmlns="http://www.w3.org/1999/xhtml">The following diagram is a visual representation that adds the modern application we are building to replace the legacy application. </span><span class="koboSpan" id="kobo.1196.2" xmlns="http://www.w3.org/1999/xhtml">That new modern application could also be a purchased product you are putting in place instead; the concepts we are exploring apply to both use cases, but the exact steps are directly related to the technology at play.</span></p>
<figure>
<span class="koboSpan" id="kobo.1197.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.40: The modern application to replace the legacy application is starting to emerge by migrating capabilities to that new application" src="../media/file168.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1198.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.40: The modern application to replace the legacy application is starting to emerge by migrating capabilities to that new application</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1199.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding diagram, we see the new modern application has appeared. </span><span class="koboSpan" id="kobo.1199.2" xmlns="http://www.w3.org/1999/xhtml">Each time we deploy a new feature to the new application, we can remove it from the adapter, leading to a graceful transition between the two models. </span><span class="koboSpan" id="kobo.1199.3" xmlns="http://www.w3.org/1999/xhtml">At the same time, we are keeping the legacy application in place to continue to provide the capabilities that are not yet migrated.Once all the features we want to keep are migrated, we can remove the adapter and decommission the legacy application, leading to the following system:</span></p>
<figure>
<span class="koboSpan" id="kobo.1200.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.41: The new system topology after the retirement of the legacy application, showing the new modern application and its two loosely coupled dependencies" src="../media/file169.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1201.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.41: The new system topology after the retirement of the legacy application, showing the new modern application and its two loosely coupled dependencies</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1202.1" xmlns="http://www.w3.org/1999/xhtml">The preceding diagram shows the new system topology encompassing a new modern application and the two original dependencies that are now loosely coupled through event-driven architecture. </span><span class="koboSpan" id="kobo.1202.2" xmlns="http://www.w3.org/1999/xhtml">Of course, the bigger the migration, the more complex it will be and the longer it will take, but the Adapter Microservice pattern is one way to help do a partial or complete migration from one system to another.Like the preceding example, the main advantage is adding or removing capabilities without impacting the other systems, which allows us to migrate and break the tight coupling between the different dependencies. </span><span class="koboSpan" id="kobo.1202.3" xmlns="http://www.w3.org/1999/xhtml">The downside is the added complexity of this temporary solution. </span><span class="koboSpan" id="kobo.1202.4" xmlns="http://www.w3.org/1999/xhtml">Moreover, during the migration step, you will most likely need to deploy both the modern application and the adapter in the correct sequence to ensure both systems are not handling the same events twice, leading to duplicate changes. </span><span class="koboSpan" id="kobo.1202.5" xmlns="http://www.w3.org/1999/xhtml">For example, updating the phone number to the same value twice should be all right because it leads to the same final data set. </span><span class="koboSpan" id="kobo.1202.6" xmlns="http://www.w3.org/1999/xhtml">However, creating two records instead of one should be more important to mitigate as it may lead to integrity errors in the data set. </span><span class="koboSpan" id="kobo.1202.7" xmlns="http://www.w3.org/1999/xhtml">For example, creating an online order twice instead of once could create customer dissatisfaction or internal issues.And voilà, we decommissioned a system using the Microservice Adapter pattern without breaking its dependencies. </span><span class="koboSpan" id="kobo.1202.8" xmlns="http://www.w3.org/1999/xhtml">Next, we look at an </span><strong><span class="koboSpan" id="kobo.1203.1" xmlns="http://www.w3.org/1999/xhtml">Internet of Things</span></strong><span class="koboSpan" id="kobo.1204.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.1205.1" xmlns="http://www.w3.org/1999/xhtml">IoT</span></strong><span class="koboSpan" id="kobo.1206.1" xmlns="http://www.w3.org/1999/xhtml">) example.</span></p>
</section>
<section class="level3" data-number="20.9.3" id="adapting-an-event-broker-to-another">
<h3 data-number="20.9.3"><span class="koboSpan" id="kobo.1207.1" xmlns="http://www.w3.org/1999/xhtml">Adapting an event broker to another</span></h3>
<p><span class="koboSpan" id="kobo.1208.1" xmlns="http://www.w3.org/1999/xhtml">In this scenario, we are adapting an event broker to another. </span><span class="koboSpan" id="kobo.1208.2" xmlns="http://www.w3.org/1999/xhtml">In the following diagram, we look at two use cases: one that translates events from broker B to broker A (left) and the other that translates events from broker A to broker B (right). </span><span class="koboSpan" id="kobo.1208.3" xmlns="http://www.w3.org/1999/xhtml">Afterwards, we explore a more concrete example:</span></p>
<figure>
<span class="koboSpan" id="kobo.1209.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.42: An adapter microservice that translates events from broker B to broker A (left) and from broker A to broker B (right)" src="../media/file170.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1210.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.42: An adapter microservice that translates events from broker B to broker A (left) and from broker A to broker B (right)</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1211.1" xmlns="http://www.w3.org/1999/xhtml">We can see the two possible flows in the preceding diagram. </span><span class="koboSpan" id="kobo.1211.2" xmlns="http://www.w3.org/1999/xhtml">The first flow, on the left, allows the adapter to read events from broker B and publish them to broker A. </span><span class="koboSpan" id="kobo.1211.3" xmlns="http://www.w3.org/1999/xhtml">The second flow, on the right, enables the adapter to read events from broker A and publish them to broker B. </span><span class="koboSpan" id="kobo.1211.4" xmlns="http://www.w3.org/1999/xhtml">Those flows allow us to translate or copy events from one broker to another by leveraging the Microservice Adapter pattern.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.1212.1" xmlns="http://www.w3.org/1999/xhtml">In </span><em><span class="koboSpan" id="kobo.1213.1" xmlns="http://www.w3.org/1999/xhtml">Figure 16.35</span></em><span class="koboSpan" id="kobo.1214.1" xmlns="http://www.w3.org/1999/xhtml">, there is one adapter per flow. </span><span class="koboSpan" id="kobo.1214.2" xmlns="http://www.w3.org/1999/xhtml">I did that to make the two flows as independent as possible, but the adapters could be a single microservice.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.1215.1" xmlns="http://www.w3.org/1999/xhtml">This pattern can be very useful for an IoT system where your microservices leverage Apache Kafka internally for its full-featured suite of event-streaming capabilities but use MQTT to communicate with the low-powered IoT devices that connect to the system. </span><span class="koboSpan" id="kobo.1215.2" xmlns="http://www.w3.org/1999/xhtml">An adapter can solve this problem by translating the messages from one protocol to the other. </span><span class="koboSpan" id="kobo.1215.3" xmlns="http://www.w3.org/1999/xhtml">Here is a diagram that represents the complete flows, including a device and the microservices:</span></p>
<figure>
<span class="koboSpan" id="kobo.1216.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 19.43: Complete protocol adapter flows, including a device and microservices" src="../media/file171.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.1217.1" xmlns="http://www.w3.org/1999/xhtml">Figure 19.43: Complete protocol adapter flows, including a device and microservices</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.1218.1" xmlns="http://www.w3.org/1999/xhtml">Before we explore what the events could be, let’s explore both flows step by step. </span><span class="koboSpan" id="kobo.1218.2" xmlns="http://www.w3.org/1999/xhtml">The left flow allows getting events inside the system from the devices through the following sequence:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.1219.1" xmlns="http://www.w3.org/1999/xhtml">A device publishes an event to the MQTT broker.</span></li>
<li><span class="koboSpan" id="kobo.1220.1" xmlns="http://www.w3.org/1999/xhtml">The adapter reads that event.</span></li>
<li><span class="koboSpan" id="kobo.1221.1" xmlns="http://www.w3.org/1999/xhtml">The adapter publishes a similar or different event to the Kafka broker.</span></li>
<li><span class="koboSpan" id="kobo.1222.1" xmlns="http://www.w3.org/1999/xhtml">Zero or more microservices subscribed to the event act on it.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.1223.1" xmlns="http://www.w3.org/1999/xhtml">On the other hand, the right flow allows getting events out of the system to the devices through the following sequence:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.1224.1" xmlns="http://www.w3.org/1999/xhtml">A microservice publishes an event to the Kafka broker.</span></li>
<li><span class="koboSpan" id="kobo.1225.1" xmlns="http://www.w3.org/1999/xhtml">The adapter reads the event.</span></li>
<li><span class="koboSpan" id="kobo.1226.1" xmlns="http://www.w3.org/1999/xhtml">The adapter publishes a similar or different event to the MQTT broker.</span></li>
<li><span class="koboSpan" id="kobo.1227.1" xmlns="http://www.w3.org/1999/xhtml">Zero or more devices subscribed to the event act on it.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.1228.1" xmlns="http://www.w3.org/1999/xhtml">You don’t have to implement both flows; the adapter could be bidirectional (supporting both flows), we could have two unidirectional adapters that support one of the flows, or we could allow the communication to flow only one way (in or out but not both). </span><span class="koboSpan" id="kobo.1228.2" xmlns="http://www.w3.org/1999/xhtml">The choice relates to your specific use cases.Concrete examples of sending a message from a device to a microservice (left flow) could be sending its GPS position, a status update (the light is now on), or a message indicating a sensor failure.Concrete examples of sending a message to a device (right flow) could be to remotely control a speaker’s volume, flip a light on, or send a confirmation that a message has been acknowledged.In this case, the adapter is not a temporary solution but a permanent capability. </span><span class="koboSpan" id="kobo.1228.3" xmlns="http://www.w3.org/1999/xhtml">We could leverage such adapters to create additional capabilities with minimal impact on the rest of the system. </span><span class="koboSpan" id="kobo.1228.4" xmlns="http://www.w3.org/1999/xhtml">The primary downside is deploying one or more other microservices, but your system and processes are probably robust enough to handle that added complexity when leveraging such capabilities.This third scenario that leverages the Microservice Adapter is our last. </span><span class="koboSpan" id="kobo.1228.5" xmlns="http://www.w3.org/1999/xhtml">Hopefully, I sparked your imagination enough to leverage this simple yet powerful design pattern.</span></p>
</section>
<section class="level3" data-number="20.9.4" id="conclusion-34">
<h3 data-number="20.9.4"><span class="koboSpan" id="kobo.1229.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.1230.1" xmlns="http://www.w3.org/1999/xhtml">We explored the Microservice Adapter pattern that allows us to connect two elements of a system by adapting one to the other. </span><span class="koboSpan" id="kobo.1230.2" xmlns="http://www.w3.org/1999/xhtml">We explored how to push information from an event broker into an existing system that does not support such capabilities. </span><span class="koboSpan" id="kobo.1230.3" xmlns="http://www.w3.org/1999/xhtml">We also explored how to leverage an adapter to break tight coupling, migrate features into a newer system, and decommission a legacy application seamlessly. </span><span class="koboSpan" id="kobo.1230.4" xmlns="http://www.w3.org/1999/xhtml">We finally connected two event brokers through an adapter microservice, allowing a low-powered IoT device to communicate with a microservices system without draining their battery and without the complexity it would incur to use a more complex communication protocol.This pattern is very powerful and can be implemented in many ways, but it all depends on the exact use cases. </span><span class="koboSpan" id="kobo.1230.5" xmlns="http://www.w3.org/1999/xhtml">You can write an adapter using a serverless offering like an Azure function, no-code/low-code offerings like Power Automate, or C#. </span><span class="koboSpan" id="kobo.1230.6" xmlns="http://www.w3.org/1999/xhtml">Of course, these are just a few examples. </span><span class="koboSpan" id="kobo.1230.7" xmlns="http://www.w3.org/1999/xhtml">The key to designing the correct system is to nail down the problem statement because once you know what you are trying to fix, the solution becomes clearer.Now, let’s see how the Microservice Adapter pattern can help us follow the </span><strong><span class="koboSpan" id="kobo.1231.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.1232.1" xmlns="http://www.w3.org/1999/xhtml"> principles at cloud-scale:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.1233.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.1234.1" xmlns="http://www.w3.org/1999/xhtml">: The microservice adapter helps manage long- or short-term responsibilities. </span><span class="koboSpan" id="kobo.1234.2" xmlns="http://www.w3.org/1999/xhtml">For example, adding an adapter that translates between two protocols or creating a temporary adapter to decommission a legacy system.</span></li>
<li><strong><span class="koboSpan" id="kobo.1235.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.1236.1" xmlns="http://www.w3.org/1999/xhtml">: You can leverage microservice adapters to dynamically add or remove features without impacting or with limited impact on the rest of the system. </span><span class="koboSpan" id="kobo.1236.2" xmlns="http://www.w3.org/1999/xhtml">For example, in the IoT scenario, we could add support for a new protocol like AMQP without changing the rest of the system.</span></li>
<li><strong><span class="koboSpan" id="kobo.1237.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.1238.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
<li><strong><span class="koboSpan" id="kobo.1239.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.1240.1" xmlns="http://www.w3.org/1999/xhtml">: Adding smaller adapters can make changes easier and less risky than updating large legacy applications. </span><span class="koboSpan" id="kobo.1240.2" xmlns="http://www.w3.org/1999/xhtml">As we saw in the legacy system decommissioning scenario, we could also leverage temporary adapters to split large applications into smaller pieces.</span></li>
<li><strong><span class="koboSpan" id="kobo.1241.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.1242.1" xmlns="http://www.w3.org/1999/xhtml">: A microservice adapter inverts the dependency flow between the system it adapts. </span><span class="koboSpan" id="kobo.1242.2" xmlns="http://www.w3.org/1999/xhtml">For example, in the legacy system decommissioning scenario, the adapter reversed the flow from the two dependencies to the legacy system by leveraging an event broker.</span></li>
</ul>
</section>
</section>
<section class="level2" data-number="20.10" id="summary-18">
<h2 data-number="20.10"><span class="koboSpan" id="kobo.1243.1" xmlns="http://www.w3.org/1999/xhtml">Summary</span></h2>
<p><span class="koboSpan" id="kobo.1244.1" xmlns="http://www.w3.org/1999/xhtml">The microservices architecture is different from everything we’ve covered in this book and how we build monoliths. </span><span class="koboSpan" id="kobo.1244.2" xmlns="http://www.w3.org/1999/xhtml">Instead of one big application, we split it into multiple smaller ones called microservices. </span><span class="koboSpan" id="kobo.1244.3" xmlns="http://www.w3.org/1999/xhtml">Microservices must be independent of one another; otherwise, we will face the same problems associated with tightly coupled classes, but at the cloud scale.We can leverage the Publish-Subscribe design pattern to loosely couple microservices while keeping them connected through events. </span><span class="koboSpan" id="kobo.1244.4" xmlns="http://www.w3.org/1999/xhtml">Message brokers are programs that dispatch those messages. </span><span class="koboSpan" id="kobo.1244.5" xmlns="http://www.w3.org/1999/xhtml">We can use event sourcing to recreate the application’s state at any point in time, including when spawning new containers. </span><span class="koboSpan" id="kobo.1244.6" xmlns="http://www.w3.org/1999/xhtml">We can use application gateways to shield clients from the microservices cluster’s complexity and publicly expose only a subset of services.We also looked at how we can build upon the CQRS design pattern to decouple reads and writes of the same entities, allowing us to scale queries and commands independently. </span><span class="koboSpan" id="kobo.1244.7" xmlns="http://www.w3.org/1999/xhtml">We also looked at using serverless resources to create that kind of system.Finally, we explored the Microservice Adapter pattern that allowed us to adapt two systems together, decommission a legacy application, and connect two event brokers. </span><span class="koboSpan" id="kobo.1244.8" xmlns="http://www.w3.org/1999/xhtml">This pattern is simple but powerful at inverting the dependency flow between two dependencies in a loosely coupled manner. </span><span class="koboSpan" id="kobo.1244.9" xmlns="http://www.w3.org/1999/xhtml">The use of the pattern can be temporary, as we saw in the legacy application decommissioning scenario, or permanent, as we saw in the IoT scenario.On the other hand, microservices come at a cost and are not intended to replace all that exists. </span><span class="koboSpan" id="kobo.1244.10" xmlns="http://www.w3.org/1999/xhtml">Building a monolith is still a good idea for many projects. </span><span class="koboSpan" id="kobo.1244.11" xmlns="http://www.w3.org/1999/xhtml">Starting with a monolith and migrating it to microservices when scaling is another solution. </span><span class="koboSpan" id="kobo.1244.12" xmlns="http://www.w3.org/1999/xhtml">This allows us to develop the application faster (monolith). </span><span class="koboSpan" id="kobo.1244.13" xmlns="http://www.w3.org/1999/xhtml">It is also easier to add new features to a monolith than it can be to add them to a microservice application. </span><span class="koboSpan" id="kobo.1244.14" xmlns="http://www.w3.org/1999/xhtml">Most of the time, mistakes cost less in a monolith than in a microservices application. </span><span class="koboSpan" id="kobo.1244.15" xmlns="http://www.w3.org/1999/xhtml">You can also plan your future migration toward microservices, which leads to the best of both worlds while keeping operational complexity low. </span><span class="koboSpan" id="kobo.1244.16" xmlns="http://www.w3.org/1999/xhtml">For example, we could leverage the Publish-Subscribe pattern through MediatR notifications in your monolith and migrate the events dispatching responsibility to a message broker later when migrating your system to microservices architecture (if the need ever arises). </span><span class="koboSpan" id="kobo.1244.17" xmlns="http://www.w3.org/1999/xhtml">We are exploring ways to organize our monolith in </span><em><span class="koboSpan" id="kobo.1245.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 20</span></em><span class="koboSpan" id="kobo.1246.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.1247.1" xmlns="http://www.w3.org/1999/xhtml">Modular Monolith</span></em><span class="koboSpan" id="kobo.1248.1" xmlns="http://www.w3.org/1999/xhtml">.I don’t want you to discard the microservices architecture, but I want to ensure you weigh up the pros and cons of such a system before blindly jumping in. </span><span class="koboSpan" id="kobo.1248.2" xmlns="http://www.w3.org/1999/xhtml">Your team’s skill level and ability to learn new technologies may also impact the cost of jumping into the microservices boat.</span><strong><span class="koboSpan" id="kobo.1249.1" xmlns="http://www.w3.org/1999/xhtml">DevOps</span></strong><span class="koboSpan" id="kobo.1250.1" xmlns="http://www.w3.org/1999/xhtml"> (development [Dev] and IT operations [Ops]) or </span><strong><span class="koboSpan" id="kobo.1251.1" xmlns="http://www.w3.org/1999/xhtml">DevSecOps</span></strong><span class="koboSpan" id="kobo.1252.1" xmlns="http://www.w3.org/1999/xhtml"> (adding security [Sec] to the DevOps mix), which we do not cover in the book, is essential when building microservices. </span><span class="koboSpan" id="kobo.1252.2" xmlns="http://www.w3.org/1999/xhtml">It brings deployment automation, automated quality checks, auto-composition, and more. </span><span class="koboSpan" id="kobo.1252.3" xmlns="http://www.w3.org/1999/xhtml">Your microservices cluster will be very hard to deploy and maintain without that.Microservices are great when you need scaling, want to go serverless, or split responsibilities between multiple teams, but keep the operational costs in mind.In the next chapter, we combine the microservices and monolith worlds.</span></p>
</section>
<section class="level2" data-number="20.11" id="questions-18">
<h2 data-number="20.11"><span class="koboSpan" id="kobo.1253.1" xmlns="http://www.w3.org/1999/xhtml">Questions</span></h2>
<p><span class="koboSpan" id="kobo.1254.1" xmlns="http://www.w3.org/1999/xhtml">Let’s take a look at a few practice questions:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.1255.1" xmlns="http://www.w3.org/1999/xhtml">What is the most significant difference between a </span><strong><span class="koboSpan" id="kobo.1256.1" xmlns="http://www.w3.org/1999/xhtml">message queue</span></strong><span class="koboSpan" id="kobo.1257.1" xmlns="http://www.w3.org/1999/xhtml"> and a </span><strong><span class="koboSpan" id="kobo.1258.1" xmlns="http://www.w3.org/1999/xhtml">pub-sub</span></strong><span class="koboSpan" id="kobo.1259.1" xmlns="http://www.w3.org/1999/xhtml"> model?</span></li>
<li><span class="koboSpan" id="kobo.1260.1" xmlns="http://www.w3.org/1999/xhtml">What is </span><strong><span class="koboSpan" id="kobo.1261.1" xmlns="http://www.w3.org/1999/xhtml">event sourcing</span></strong><span class="koboSpan" id="kobo.1262.1" xmlns="http://www.w3.org/1999/xhtml">?</span></li>
<li><span class="koboSpan" id="kobo.1263.1" xmlns="http://www.w3.org/1999/xhtml">Can an </span><strong><span class="koboSpan" id="kobo.1264.1" xmlns="http://www.w3.org/1999/xhtml">application gateway</span></strong><span class="koboSpan" id="kobo.1265.1" xmlns="http://www.w3.org/1999/xhtml"> be both a </span><strong><span class="koboSpan" id="kobo.1266.1" xmlns="http://www.w3.org/1999/xhtml">routing gateway</span></strong><span class="koboSpan" id="kobo.1267.1" xmlns="http://www.w3.org/1999/xhtml"> and an </span><strong><span class="koboSpan" id="kobo.1268.1" xmlns="http://www.w3.org/1999/xhtml">aggregation gateway</span></strong><span class="koboSpan" id="kobo.1269.1" xmlns="http://www.w3.org/1999/xhtml">?</span></li>
<li><span class="koboSpan" id="kobo.1270.1" xmlns="http://www.w3.org/1999/xhtml">Is it true that real CQRS requires a serverless cloud infrastructure?</span></li>
<li><span class="koboSpan" id="kobo.1271.1" xmlns="http://www.w3.org/1999/xhtml">What is a significant advantage of using the BFF design pattern?</span></li>
</ol>
</section>
<section class="level2" data-number="20.12" id="further-reading-16">
<h2 data-number="20.12"><span class="koboSpan" id="kobo.1272.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></h2>
<p><span class="koboSpan" id="kobo.1273.1" xmlns="http://www.w3.org/1999/xhtml">Here are a few links that will help you build on what you learned in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1274.1" xmlns="http://www.w3.org/1999/xhtml">Event Sourcing pattern by Martin Fowler: </span><a href="https://adpg.link/oY5H"><span class="koboSpan" id="kobo.1275.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/oY5H</span></a></li>
<li><span class="koboSpan" id="kobo.1276.1" xmlns="http://www.w3.org/1999/xhtml">Event Sourcing pattern by Microsoft: </span><a href="https://adpg.link/ofG2"><span class="koboSpan" id="kobo.1277.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/ofG2</span></a></li>
<li><span class="koboSpan" id="kobo.1278.1" xmlns="http://www.w3.org/1999/xhtml">Publisher-Subscriber pattern by Microsoft: </span><a href="https://adpg.link/amcZ"><span class="koboSpan" id="kobo.1279.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/amcZ</span></a></li>
<li><span class="koboSpan" id="kobo.1280.1" xmlns="http://www.w3.org/1999/xhtml">Event-driven architecture by Microsoft: </span><a href="https://adpg.link/rnck"><span class="koboSpan" id="kobo.1281.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/rnck</span></a></li>
<li><span class="koboSpan" id="kobo.1282.1" xmlns="http://www.w3.org/1999/xhtml">Microservices architecture and patterns on microservices.io: </span><a href="https://adpg.link/41vP"><span class="koboSpan" id="kobo.1283.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/41vP</span></a></li>
<li><span class="koboSpan" id="kobo.1284.1" xmlns="http://www.w3.org/1999/xhtml">Microservices architecture and patterns by Martin Fowler: </span><a href="https://adpg.link/Mw97"><span class="koboSpan" id="kobo.1285.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/Mw97</span></a></li>
<li><span class="koboSpan" id="kobo.1286.1" xmlns="http://www.w3.org/1999/xhtml">Microservices architecture and patterns by Microsoft: </span><a href="https://adpg.link/s2Uq"><span class="koboSpan" id="kobo.1287.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/s2Uq</span></a></li>
<li><span class="koboSpan" id="kobo.1288.1" xmlns="http://www.w3.org/1999/xhtml">RFC 6902 (JSON Patch): </span><a href="https://adpg.link/bGGn"><span class="koboSpan" id="kobo.1289.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/bGGn</span></a></li>
<li><span class="koboSpan" id="kobo.1290.1" xmlns="http://www.w3.org/1999/xhtml">JSON Patch in ASP.NET Core web API: </span><a href="https://adpg.link/u6dw"><span class="koboSpan" id="kobo.1291.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/u6dw</span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.1292.1" xmlns="http://www.w3.org/1999/xhtml">Strangler Fig Application pattern:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.1293.1" xmlns="http://www.w3.org/1999/xhtml">Martin Fowler: </span><a href="https://adpg.link/Zi9G"><span class="koboSpan" id="kobo.1294.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/Zi9G</span></a></li>
<li><span class="koboSpan" id="kobo.1295.1" xmlns="http://www.w3.org/1999/xhtml">Microsoft: </span><a href="https://adpg.link/erg2"><span class="koboSpan" id="kobo.1296.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/erg2</span></a></li>
</ul>
</section>
<section class="level2" data-number="20.13" id="answers-15">
<h2 data-number="20.13"><span class="koboSpan" id="kobo.1297.1" xmlns="http://www.w3.org/1999/xhtml">Answers</span></h2>
<ol>
<li><span class="koboSpan" id="kobo.1298.1" xmlns="http://www.w3.org/1999/xhtml">The message queue gets a message and has a single subscriber dequeue it. </span><span class="koboSpan" id="kobo.1298.2" xmlns="http://www.w3.org/1999/xhtml">If nothing dequeues a message, it stays in the queue indefinitely (FIFO model). </span><span class="koboSpan" id="kobo.1298.3" xmlns="http://www.w3.org/1999/xhtml">The Pub-Sub model gets a message and sends it to zero or more subscribers.</span></li>
<li><span class="koboSpan" id="kobo.1299.1" xmlns="http://www.w3.org/1999/xhtml">Event sourcing is the process of chronologically accumulating events that happened in a system instead of persisting in the current state of an entity. </span><span class="koboSpan" id="kobo.1299.2" xmlns="http://www.w3.org/1999/xhtml">It allows you to recreate the entity's state by replaying those events.</span></li>
<li><span class="koboSpan" id="kobo.1300.1" xmlns="http://www.w3.org/1999/xhtml">Yes, you can mix Gateway patterns (or sub-patterns).</span></li>
<li><span class="koboSpan" id="kobo.1301.1" xmlns="http://www.w3.org/1999/xhtml">No, you can deploy micro-applications (microservices) on-premises if you want to.</span></li>
<li><span class="koboSpan" id="kobo.1302.1" xmlns="http://www.w3.org/1999/xhtml">It separates generic functionalities from app-specific ones, promoting cleaner code and modularization. </span><span class="koboSpan" id="kobo.1302.2" xmlns="http://www.w3.org/1999/xhtml">It also helps simplify the frontend.</span></li>
</ol>
</section>
</section>
</body>
</html>
