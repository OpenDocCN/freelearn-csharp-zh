<html><head></head><body>
<div><h1 class="chapterNumber">17</h1>
<h1 class="chapterTitle" id="_idParaDest-341">Presenting ASP.NET Core</h1>
<p class="normal">In this chapter, you will learn how to implement a web application and a web-based presentation layer. More specifically, you will learn about ASP.NET Core and how to implement a web application presentation layer based on ASP.NET Core MVC.</p>
<p class="normal">ASP.NET Core is a .NET framework for implementing web applications. The ASP.NET Core Web API was partially described in previous chapters, so this chapter will focus mainly on ASP.NET Core in general and on ASP.NET Core MVC. More specifically, this chapter will cover the following topics:</p>
<ul>
<li class="bulletList">Understanding the presentation layers of web applications</li>
<li class="bulletList">Understanding the basics of ASP.NET Core</li>
<li class="bulletList">Understanding how ASP.NET Core MVC creates the response HTML</li>
<li class="bulletList">Understanding the connection between ASP.NET Core MVC and design principles</li>
</ul>
<p class="normal">We will review and provide further details on the structure of the ASP.NET Core framework, which we discussed in part in earlier chapters. Here, the main focus is on how to implement web-based presentation <a id="_idIndexMarker1176"/>layers based on the so-called <strong class="keyWord">Model View Controller</strong> (<strong class="keyWord">MVC</strong>) architectural pattern.</p>
<p class="normal">We will also analyze how server-side HTML is created with ASP.NET Core MVC’s <strong class="keyWord">Razor</strong> template language.</p>
<p class="normal">Each concept is explained using code examples, and <em class="chapterRef">Chapter 18</em>, <em class="italic">Implementing Frontend Microservices with ASP.NET Core</em>, is dedicated to the description of a frontend microservice implemented with ASP.NET Core MVC. For a complete practical example of how to put into practice the general principles discussed in this and the next chapter, please refer to the <em class="italic">A frontend microservice</em> section in <em class="italic">Chapter 21</em>, <em class="italic">Case Study</em>.</p>
<h1 class="heading-1" id="_idParaDest-342">Technical requirements</h1>
<p class="normal">This chapter requires the free Visual Studio 2022 Community edition, ideally with all the database tools installed.</p>
<h1 class="heading-1" id="_idParaDest-343">Understanding the presentation layers of web applications</h1>
<p class="normal">This chapter discusses an architecture for implementing the presentation layers of web applications based on the ASP.NET Core framework. The presentation layers of web applications are based on <a id="_idIndexMarker1177"/>three techniques:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Mobile or desktop native applications that exchange data with servers through REST or SOAP services</strong>: We will discuss desktop applications in <em class="chapterRef">Chapter 19</em>, <em class="italic">Client Frameworks: Blazor</em>.</li>
<li class="bulletList"><strong class="keyWord">Single-Page Applications</strong> (<strong class="keyWord">SPAs</strong>): These are HTML-based applications whose dynamic HTML is created on <a id="_idIndexMarker1178"/>the client, either in JavaScript or with the help of WebAssembly (a kind of cross-browser assembly that can be used as a high-performance alternative to JavaScript). Like native applications, SPAs exchange data with the server through HTTP-based APIs, but they have the advantage of being independent of the device and its operating system, since they run in a browser. <em class="chapterRef">Chapter 19</em>, <em class="italic">Client Frameworks: Blazor</em>, describes the Blazor SPA framework, which is based on WebAssembly, since it is based itself on a .NET runtime compiled in WebAssembly.</li>
<li class="bulletList"><strong class="keyWord">HTML pages created by the server whose content depends on the data to be shown to the user</strong>: The ASP.NET Core MVC framework, which will be discussed in this chapter, is a framework for creating such dynamic HTML pages.</li>
</ul>
<p class="normal">The remainder of this chapter focuses on how to create HTML pages on the server side and, more specifically, on ASP.NET Core MVC.</p>
<h1 class="heading-1" id="_idParaDest-344">Understanding the basics of ASP.NET Core</h1>
<p class="normal">ASP.NET Core is based on the<a id="_idIndexMarker1179"/> concept of the generic host, as explained in the <em class="italic">Using generic hosts</em> subsection of <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>. The basic architecture of ASP.NET Core was outlined in the <em class="italic">A short introduction to ASP.NET Core</em> subsection of <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>.</p>
<p class="normal">It is worth remembering that the host configuration consists mainly of adding services to the <strong class="keyWord">Dependency Injection</strong> (<strong class="keyWord">DI</strong>) engine through<a id="_idIndexMarker1180"/> the <code class="inlineCode">Services</code> property of a host builder instance, whose type implements the <code class="inlineCode">IServiceCollection</code> interface:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddTransient&lt;IMyService, MyService&gt;();
...
// Add services to the container through extension methods.
builder.Services.AddControllersWithViews();
builder.Services.AddAllQueries(typeof(ManagePackagesController).Assembly);
...
...
var app = builder.Build();
</code></pre>
<p class="normal">The <code class="inlineCode">IServiceCollection</code> interface implemented by <code class="inlineCode">builder.Services</code> defines all the services that can be injected into object constructors through DI.</p>
<p class="normal">Services can be defined either by calling the various overloads of <code class="inlineCode">AddTransient</code> and <code class="inlineCode">AddSingleton</code> directly in <code class="inlineCode">Program.cs</code>, or by grouping these calls in some <code class="inlineCode">IServiceCollection</code> extension methods, which are then called in <code class="inlineCode">Program.cs</code>. The way services are handled in .NET is explained in detail in the <em class="italic">Using generic hosts </em>section of <em class="italic">Chapter 11</em>. Here, it is worth pointing out that, together with singleton and transient services, ASP.NET Core also supports another kind of service lifetime, session lifetime, which is the lifetime of a single web request served by the ASP.NET Core application. Session-scoped services are declared with <code class="inlineCode">AddScoped</code> overloads that are completely analogous to the overloads of <code class="inlineCode">AddTransient</code> and <code class="inlineCode">AddSingleton</code>.</p>
<p class="normal">Session-scoped services are useful for storing data that are specific to a single request that must be used throughout the whole request by several application components. A typical example of a .NET session-scoped service is the Entity Framework Core <code class="inlineCode">DBContexts</code>. In fact, all operations performed on the various aggregates involved in the request must use the same request-specific <code class="inlineCode">DBContext</code> so that all changes can be saved to the database in a single transaction, with a unique <code class="inlineCode">SaveChanges</code> operation.</p>
<p class="normal">Practical applications of session-scoped <code class="inlineCode">DBContext</code>s and other services are described in more detail in <em class="italic">Chapter 18</em>, <em class="italic">Implementing Frontend Microservices with ASP.NET Core</em>.</p>
<p class="normal">Usually, all applications define most of the application configuration through the host builder so that after the host is built with <code class="inlineCode">var app = builder.Build()</code>, you need to call <code class="inlineCode">app.Run()</code> or <code class="inlineCode">await app.RunAsync()</code> to launch the application.</p>
<p class="normal">The ASP.NET Core host instead<a id="_idIndexMarker1181"/> performs another configuration step after it has been built; it defines the so-called ASP.NET Core HTTP request processing pipeline, which will be described in more detail in the next subsection.</p>
<h2 class="heading-2" id="_idParaDest-345">ASP.NET Core middleware</h2>
<p class="normal">ASP.NET Core contains an internal web server called Kestrel that has just the basic web server functionalities. So in simple applications such as IoT applications, or worker microservices, we can avoid the overhead of a fully optional complex web server like IIS, Apache, or NGINX.</p>
<p class="normal">If ASP.NET Core is used to implement the <a id="_idIndexMarker1182"/>application layer of a frontend microservice/application or a classic website, Kestrel can be interfaced with all major web servers that proxy their request to Kestrel.</p>
<p class="normal">In version 8, by default, Kestrel supports all protocols up to and including version HTTP/3.</p>
<p class="normal">In turn, Kestrel passes all requests to a set of configurable modules that you can assemble according to your needs. Each module takes care of a functionality that you may or may not need. Examples of such functionalities include authorization, authentication, static file processing, protocol negotiation, and CORS handling. Since most of the modules apply transformations to<a id="_idIndexMarker1183"/> the incoming request and the final response, these modules are usually referred to as <strong class="keyWord">middleware</strong>.</p>
<p class="normal">You can put together all the <strong class="keyWord">middleware</strong> modules you need by inserting them into a common processing <a id="_idIndexMarker1184"/>framework called the <strong class="keyWord">ASP.NET Core pipeline</strong>.</p>
<p class="normal">More specifically, ASP.NET Core requests are processed by pushing a context object through a pipeline of ASP.NET Core modules, as shown in the following diagram:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_17_01.png"/></figure>
<p class="packt_figref">Figure 17.1: ASP.NET Core pipeline</p>
<p class="normal">The object that is inserted into the<a id="_idIndexMarker1185"/> pipeline is an <code class="inlineCode">HttpContext</code> instance that contains the data of the incoming request. More specifically, the <code class="inlineCode">Request</code> property of <code class="inlineCode">HttpContext</code> contains an <code class="inlineCode">HttpRequest</code> object whose properties represent the incoming request in a structured way. There are properties for headers, cookies, the request path, parameters, form fields, and the request body.</p>
<p class="normal">The various modules can contribute to the construction of the final response that is written in an <code class="inlineCode">HttpResponse</code> object, contained in the <code class="inlineCode">Response</code> property of the <code class="inlineCode">HttpContext</code> instance. The <code class="inlineCode">HttpResponse</code> class is similar to the <code class="inlineCode">HttpRequest</code> class, but its properties refer to the response being built.</p>
<p class="normal">Some modules can build an intermediate data structure that is then used by other modules in the pipeline. In general, such intermediary data can be stored in custom entries of the <code class="inlineCode">IDictionary&lt;object, object&gt;</code>, which is contained in the <code class="inlineCode">Items</code> property of the <code class="inlineCode">HttpContext</code> object. However, there is a predefined property, <code class="inlineCode">User</code>, that contains information about the currently logged-in user. The logged-in user is not computed automatically, so it must be computed by an authentication module. The <em class="italic">ASP.NET Core service authorization</em> subsection of <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>, explained how to add the standard module that performs JWT-based authentication into the ASP.NET Core pipeline.</p>
<p class="normal"><code class="inlineCode">HttpContext</code> also has a <code class="inlineCode">Connection</code> property that contains information on the underlying connection established with the client, as well as a <code class="inlineCode">WebSockets</code> property that contains information on possible WebSocket-based connections established with the clients.</p>
<p class="normal"><code class="inlineCode">HttpContext</code> also has a <code class="inlineCode">Features</code> property that contains <code class="inlineCode">IDictionary&lt;Type, object&gt;</code>, which specifies the features supported by the web server that hosts the web application and by the pipeline. Features can be set using the <code class="inlineCode">.Set&lt;TFeature&gt;(TFeature o)</code> method and retrieved using the <code class="inlineCode">.Get&lt;TFeature&gt;()</code> method.</p>
<p class="normal">Web server features are automatically added by the framework, while all other features are added by pipeline modules when they process <code class="inlineCode">HttpContext</code>.</p>
<p class="normal"><code class="inlineCode">HttpContext</code> also gives us access to the DI engine through its <code class="inlineCode">RequestServices</code> property. You can get an instance of a <a id="_idIndexMarker1186"/>type managed by the dependency engine by calling the <code class="inlineCode">.RequestServices.GetService(Type t)</code> method or, even better, the <code class="inlineCode">.GetRequiredService&lt;TService&gt;()</code> extension method that is built on top of it. </p>
<p class="normal">However, as we will see in the remainder of this chapter, all types managed by the DI engine are usually automatically injected into constructors, so these methods are only used when we’re building custom <strong class="keyWord">middleware</strong> or other customizations of the ASP.NET Core engine.</p>
<p class="normal">The <code class="inlineCode">HttpContext</code> instance that is created for processing a web request is not only available to modules but also to the application code, through DI. It is sufficient to insert an <code class="inlineCode">IHttpContextAccessor</code> parameter into the constructor of a class that is automatically dependency injected, and then access its <code class="inlineCode">HttpContext</code> property. All controllers that inherit from <code class="inlineCode">Controller</code> or <code class="inlineCode">ControllerBase</code> (see later in this section) expose an <code class="inlineCode">HttpContext</code> property that contains the request <code class="inlineCode">HttpContext</code>.</p>
<p class="normal">A middleware module is any class with the following structure:</p>
<pre class="programlisting code"><code class="hljs-code">public class CoreMiddleware
{
    private readonly RequestDelegate _next;
    public CoreMiddleware(RequestDelegate next, ILoggerFactory
    loggerFactory)
    {
        ...
        _next = next;
        ...
    }
    public async Task InvokeAsync(HttpContext context)
    {
        /*
            Insert here the module specific code that processes the
            HttpContext instance before it is passed to the next
            module.
        */
await _next.Invoke(context);
        /*
            Insert here other module specific code that processes the
            HttpContext instance, after all modules that follow this
            module finished their processing.
        */
    }
}
</code></pre>
<p class="normal">It is also possible to pass <code class="inlineCode">InvokeAsync</code> directly as a lambda to <code class="inlineCode">app.Use</code>, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">app.Use(async (context, next) =&gt;
{
   ...
    await next(context);
});
</code></pre>
<p class="normal">In general, each piece of middleware processes the <code class="inlineCode">HttpContext</code> instance that was passed by the previous module in the pipeline, and then it calls <code class="inlineCode">await _next.Invoke(context)</code> to invoke the modules in the remainder of the pipeline. When the other modules have finished their processing and the<a id="_idIndexMarker1187"/> response for the client has been prepared, each module can perform further post-processing of the response in the code that follows the <code class="inlineCode">_next.Invoke(context)</code> call.</p>
<p class="normal">Modules are registered in the ASP.NET Core pipeline by calling the <code class="inlineCode">UseMiddleware&lt;T&gt;</code> method of the built host, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code"> var app = builder.Build();
...
    app.UseMiddleware&lt;MyCustomModule&gt;
    ...
    app.Run();
</code></pre>
<p class="normal">Middleware modules are inserted into the pipeline in the same order when <code class="inlineCode">UseMiddleware</code> is called. Since each functionality that’s added to an application might require several modules and operations other than adding modules, you usually define an <code class="inlineCode">IApplicationBuilder</code> extension such as <code class="inlineCode">UseMyFunctionality</code>, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">public static class MyMiddlewareExtensions
{
    public static IApplicationBuilder UseMyFunctionality(this
    IApplicationBuilder builder,...)
    {
        //other code
        ...
        builder.UseMiddleware&lt;MyModule1&gt;();
        builder.UseMiddleware&lt;MyModule2&gt;();
        ...
        //Other code
        ...
        return builder;
    }
}
</code></pre>
<p class="normal">After that, the whole functionality can be added to the application by calling <code class="inlineCode">app.UseMyFunctionality(...)</code>. For instance, the ASP.NET Core MVC functionality can be added to the ASP.NET Core pipeline by calling <code class="inlineCode">app.UseEndpoints(....)</code>.</p>
<p class="normal">Often, functionalities that are added with each <code class="inlineCode">app.Use...</code> require that some .NET types are added to the <a id="_idIndexMarker1188"/>application DI engine. In these cases, we also define an <code class="inlineCode">IServiceCollection</code> extension named <code class="inlineCode">AddMyFunctionality</code>, which must be called by <code class="inlineCode">builder.Services</code> in <code class="inlineCode">Program.cs</code>.</p>
<p class="normal">For instance, ASP.NET Core MVC requires a call such as the following:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddControllersWithViews(o =&gt;
{
    //set here MVC options by modifying the o option parameter
}
</code></pre>
<p class="normal">If you don’t need to change the default MVC options, you can simply call <code class="inlineCode">builder.Services.AddControllersWithViews()</code>.</p>
<p class="normal">The next subsection describes another important feature of the ASP.NET Core framework – namely, how to handle application configuration data.</p>
<h2 class="heading-2" id="_idParaDest-346">Loading configuration data and using it with the options framework</h2>
<p class="normal">Understanding how ASP.NET Core<a id="_idIndexMarker1189"/> applications handle configuration is crucial for <a id="_idIndexMarker1190"/>effective application setup. In the default .NET template where an ASP.NET Core application starts, it reads configuration information (such as a database connection string) from the <code class="inlineCode">appsettings.json</code> and <code class="inlineCode">appsettings.[EnvironmentName].json</code> files, where <code class="inlineCode">EnvironmentName</code> is a string value that depends on where the application is deployed.</p>
<p class="normal">Typical values for the <code class="inlineCode">EnvironmentName</code> string are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Production</code> is used for production deployment</li>
<li class="bulletList"><code class="inlineCode">Development</code> is used during development</li>
<li class="bulletList"><code class="inlineCode">Staging</code> is used when the application is tested in staging</li>
</ul>
<p class="normal">The two JSON trees that were extracted from the <code class="inlineCode">appsettings.json</code> and <code class="inlineCode">appsettings.[EnvironmentName].json</code> files are merged into a unique tree, where the values contained in <code class="inlineCode">[EnvironmentName].json</code> override the values contained in the corresponding paths of <code class="inlineCode">appsettings.json</code>. This way, the <a id="_idIndexMarker1191"/>application can be run with different configurations in different<a id="_idIndexMarker1192"/> deployment environments. In particular, you can use a different database connection string and, hence, a different database instance in each different environment.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_17_02.png"/></figure>
<p class="packt_figref">Figure 17.2: Configuration files merging</p>
<p class="normal">Configuration information can also be passed from other sources. Given a lack of space, we list here all the other possibilities without discussing them:</p>
<ul>
<li class="bulletList">XML files</li>
<li class="bulletList"><code class="inlineCode">.ini</code> files</li>
<li class="bulletList">Operating system environment variables. The variable name is the name of the setting prefixed by the <code class="inlineCode">ASPNETCORE_</code> string, while the variable value is the setting value.</li>
<li class="bulletList">Command-line arguments of a <code class="inlineCode">dotnet</code> command that invokes the application.</li>
<li class="bulletList">An in-memory collection of key-value pairs</li>
</ul>
<p class="normal">The JSON format is, in my opinion, the most practical and readable, but JSON, XML, and <code class="inlineCode">.ini</code> are substantially equivalent, and choosing among them is just a matter of preference.</p>
<p class="normal">In memory, collections of key-value pairs offer the possibility of taking data from a database, so they are useful options<a id="_idIndexMarker1193"/> for those parameters that need to be changed by an administrator while the<a id="_idIndexMarker1194"/> application is running.</p>
<p class="normal">Finally, command-line arguments and environment variables are good options when the application can’t easily access disk storage – for instance, in the case of deployments running in a Kubernetes cluster. In fact, environment variables can be passed as parameters in the Kubernetes <code class="inlineCode">.yaml</code> files (see the <em class="italic">ReplicaSets and Deployments</em> section of <em class="italic">Chapter 20, Kubernetes</em>). They are also an acceptable choice for passing sensitive data that it is not adequate to store in files in a plain format.</p>
<p class="normal">From version 8 onward, ASP.NET Core allows you to set Kestrel HTTP and HTTPS listening ports as configuration variables. More specifically, <code class="inlineCode">HTTP_PORTS</code> contains a semicolon-separated list of all Kestrel HTTP listening ports, while <code class="inlineCode">HTTPS_PORTS</code> contains a semicolon-separated list of all HTTPs listening ports whose defaults are the usual HTTP and HTTPs ports, that is, <code class="inlineCode">80</code> and <code class="inlineCode">443</code>, respectively.</p>
<p class="normal">The <code class="inlineCode">[EnvironmentName]</code> string itself is taken from the <code class="inlineCode">ENVIRONMENT</code> configuration setting. Clearly, since it is needed to decide which configuration files to use, it cannot be contained in a configuration file, so it must be taken from the <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> operating system environment variable, or from the arguments of the <code class="inlineCode">dotnet</code> command used to launch the application.</p>
<div><p class="normal">When the application is deployed to IIS instead of being launched as a standalone program, <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> can’t be passed on the <code class="inlineCode">dotnet</code> command line.</p>
</div>
<p class="normal">In this case, it can be set in the IIS application settings. This can be done after the applications have been deployed, by clicking on the Configuration Editor and then selecting the <code class="inlineCode">system.webServer/aspNetCore</code> section. In the<a id="_idIndexMarker1195"/> window that opens, select <code class="inlineCode">environmentVariables</code>, and then<a id="_idIndexMarker1196"/> add the <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> variable with its value.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_17_03.png"/></figure>
<p class="packt_figref">Figure 17.3: Changing ASPNETCORE_ENVIRONMENT in IIS</p>
<p class="normal">However, when the application is modified and deployed again, the setting is reset to its default value, which is <code class="inlineCode">Production</code>, and it must be set again.</p>
<p class="normal">A better choice is to modify the publish profile in Visual Studio, as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">During Visual Studio deployment, Visual Studio’s <strong class="screenText">Publish</strong> wizard creates an XML publish profile. Once the preferred deployment type (Azure, Web Deploy, folder, and so on) has been chosen, and before publishing, you can edit the publish settings by choosing <strong class="screenText">Edit</strong> from the <strong class="screenText">More actions</strong> dropdown in the window that appears.</li>
<li class="numberedList">Once you have your publish file properly set, in Visual Studio <strong class="screenText">Solution Explorer</strong>, open the profile that you just prepared with the Visual Studio wizard. Profiles are saved in the <code class="inlineCode">Properties/PublishProfiles/&lt;profile name&gt;.pubxml</code> path of the project folder.</li>
<li class="numberedList">Then, edit the profile with a text editor, and add an XML property such as <code class="inlineCode">&lt;EnvironmentName&gt;Staging&lt;/EnvironmentName&gt;</code>. Since all the already defined publish profiles can be selected during the application’s publication, you can define a different publish profile for each of your environments, and then, you can select the one you need during each publication.</li>
</ol>
<p class="normal">The value you must set <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> to during deployment can also be specified in the Visual Studio ASP.NET Core project file (<code class="inlineCode">.csproj</code>) of your application, by adding the following code:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
&lt;EnvironmentName&gt;Staging&lt;/EnvironmentName&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p class="normal">This is the simplest way to do <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code>, but not the most modular, since we are forced to change the application<a id="_idIndexMarker1197"/> code before publishing to a different environment.</p>
<p class="normal">Specifying the environment either in<a id="_idIndexMarker1198"/> the publish profile or the project file works only for deployment types based on direct communication between Visual Studio and the web server, as in other deployment types, Visual Studio cannot inform the web server on how to set <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> or on how to pass the environment when the application is launched. At the time of writing, the techniques described work just for Web Deploy or when publishing on Azure.</p>
<p class="normal">During development in Visual Studio, the value to give to <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> when the application is run can be specified in the <code class="inlineCode">Properties\launchSettings.json</code> file of the ASP.NET Core project. The <code class="inlineCode">launchSettings.json</code> file contains several named groups of settings. These settings configure how to launch the web application when it is run from Visual Studio. You can choose to apply all the settings of a group by selecting the group name with the drop-down list next to Visual Studio’s run button:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_17_04.png"/></figure>
<p class="packt_figref">Figure 17.4: Choice of launch settings group</p>
<p class="normal">Your selection from this drop-down list will be visible on the run button, with the default selection being <strong class="keyWord">IIS Express</strong>.</p>
<p class="normal">Consider a development environment setup, as illustrated in this typical <code class="inlineCode">launchSettings.json</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">{
"iisSettings": {
"windowsAuthentication": false,
"anonymousAuthentication": true,
"iisExpress": {
"applicationUrl": "http://localhost:2575",
"sslPort": 44393
}
},
"profiles": {
"IIS Express": {
"commandName": "IISExpress",
"launchBrowser": true,
"environmentVariables": {
"ASPNETCORE_ENVIRONMENT": "Development"
}
},
    ...
    ...
    }
}
}
</code></pre>
<p class="normal">The named groups of settings are under the <code class="inlineCode">profiles</code> properties. There, you can choose where to host the application (<code class="inlineCode">IIS Express</code>), where to launch the browser, and the values of some environment variables.</p>
<p class="normal">The current<a id="_idIndexMarker1199"/> environment that’s been loaded from the <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> operating system environment<a id="_idIndexMarker1200"/> variable is available in the <code class="inlineCode">app.Environment</code> property during the ASP.NET Core pipeline definition.</p>
<p class="normal"><code class="inlineCode">app.Environment.IsEnvironment(string environmentName)</code> checks whether the current value of <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> is <code class="inlineCode">environmentName</code>. There are also specific shortcuts for testing development (<code class="inlineCode">.IsDevelopment()</code>), production (<code class="inlineCode">.IsProduction()</code>), and staging (<code class="inlineCode">.IsStaging()</code>). The <code class="inlineCode">app.Environment</code> property also contains the current root directory of the ASP.NET Core application (<code class="inlineCode">.WebRootPath</code>) and the directory reserved for the static files (<code class="inlineCode">.ContentRootPath</code>) that are served as is by the web server (CSS, JavaScript, images, and so on).</p>
<p class="normal">Both <code class="inlineCode">launchSettings.json</code> and all publish profiles can be accessed as children of the <strong class="keyWord">Properties</strong> node in Visual Studio Explorer, as shown in the following screenshot:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text  Description automatically generated" src="img/B19820_17_05.png"/></figure>
<p class="packt_figref">Figure 17.5: Launch settings file</p>
<p class="normal">Understanding how to map the merged configuration settings to .NET objects is key for effective data management in ASP.NET Core applications.</p>
<p class="normal">Once <code class="inlineCode">appsettings.json</code> and <code class="inlineCode">appsettings.[EnvironmentName].json</code> have been loaded, the configuration tree resulting from<a id="_idIndexMarker1201"/> their merge can be mapped to the properties of .NET objects. For example, let’s <a id="_idIndexMarker1202"/>suppose we have an <code class="inlineCode">Email</code> section of the <code class="inlineCode">appsettings</code> file that contains all of the information needed to connect to an email server, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">{
"ConnectionStrings": {
"DefaultConnection": "...."
},
"Logging": {
"LogLevel": {
"Default": "Warning"
}
},
"Email": {
"FromName": "MyName",
"FromAddress": "info@MyDomain.com",
"LocalDomain": "smtps.MyDomain.com",
"MailServerAddress": "smtps.MyDomain.com",
"MailServerPort": "465",
"UserId": "info@MyDomain.com",
"UserPassword": "mypassword"
}
</code></pre>
<p class="normal">Then, the whole <code class="inlineCode">Email</code> section can be mapped to an instance of the following class:</p>
<pre class="programlisting code"><code class="hljs-code"> public class EmailConfig
    {
        public String FromName { get; set; }
        public String FromAddress { get; set; }
        public String LocalDomain { get; set; }
        public String MailServerAddress { get; set; }
        public String MailServerPort { get; set; }
        public String UserId { get; set; }
        public String UserPassword { get; set; }
    }
</code></pre>
<p class="normal">The code that performs the mapping must be inserted in the host building stage, since the <code class="inlineCode">EmailConfig</code> instance will be available <a id="_idIndexMarker1203"/>through DI. The code we need is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">Var builder = WebApplication.CreateBuilder(args);
....
builder.Services.Configure&lt;EmailConfig&gt;(Configuration.GetSection("Email"));
    ..
</code></pre>
<p class="normal">Once we’ve configured the<a id="_idIndexMarker1204"/> preceding settings, classes that need <code class="inlineCode">EmailConfig</code> data must declare an <code class="inlineCode">IOptions&lt;EmailConfig&gt; options</code> constructor parameter that will be provided by the DI engine. An <code class="inlineCode">EmailConfig</code> instance is contained in <code class="inlineCode">options.Value</code>.</p>
<p class="normal">It is worth mentioning that the option classes’ properties can be applied to the same validation attributes we will use for ViewModels (see the <em class="italic">Server-side and client-side validation</em> subsection).</p>
<p class="normal">The next subsection describes the basic ASP.NET Core pipeline modules needed by an ASP.NET Core MVC application.</p>
<h2 class="heading-2" id="_idParaDest-347">Defining the ASP.NET Core pipeline</h2>
<p class="normal">Understanding the ASP.NET Core pipeline is key to customizing application behavior. When you create a new ASP.NET Core <a id="_idIndexMarker1205"/>MVC project in Visual Studio, a standard pipeline is created in the <code class="inlineCode">Program.cs</code> file. There, if needed, you can add further middleware or change the configuration of the existing middleware.</p>
<p class="normal">The initial pipeline definition code handles errors and performs basic HTTPS configuration:</p>
<pre class="programlisting code"><code class="hljs-code">if (app.Environment.IsDevelopment())
{
   
   
}
else //this is not part of the project template, but it is worth adding it
{
    app.UseDeveloperExceptionPage();
}
app.UseHttpsRedirection();
</code></pre>
<p class="normal">If there are errors, and if the application is in a development environment, the module installed by <code class="inlineCode">UseDeveloperExceptionPage</code> adds a detailed error report to the response. This module is a valuable debugging tool.</p>
<p class="normal">If an error occurs when the application is not in development mode, <code class="inlineCode">UseExceptionHandler</code> restores the request processing from the path it receives as an argument, that is, from <code class="inlineCode">/Home/Error</code>. In other words, it simulates a new request with the <code class="inlineCode">/Home/Error</code> path. This request is pushed into the standard MVC processing until it reaches the endpoint associated <a id="_idIndexMarker1206"/>with the <code class="inlineCode">/Home/Error</code> path, where the developer is expected to place the custom code that handles the error.</p>
<p class="normal">When the application is not in development, <code class="inlineCode">UseHsts</code> adds the <code class="inlineCode">Strict-Transport-Security</code> header to the response, which informs the browser that the application must only be accessed with HTTPS. After this declaration, compliant browsers should automatically convert any HTTP request of the application into an HTTPS request for the time specified in the <code class="inlineCode">Strict-Transport-Security</code> header. By default, <code class="inlineCode">UseHsts</code> specifies 30 days as the time in the header, but you can specify a different time and other header parameters by passing <code class="inlineCode">UseHsts</code> a lambda that configures an <code class="inlineCode">options</code> object:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddHsts(options =&gt;     {
    ...
    options.MaxAge = TimeSpan.FromDays(60);
    ...
});
</code></pre>
<p class="normal"><code class="inlineCode">UseHttpsRedirection</code> causes an automatic redirection to an HTTPS URL when an HTTP URL is received, in a way that forces a secure connection. Once the first HTTPS secure connection is established, the <code class="inlineCode">Strict-Transport-Security</code> header prevents future redirections that might be used to perform man-in-the-middle attacks.</p>
<p class="normal">The following code shows the remainder of the default pipeline:</p>
<pre class="programlisting code"><code class="hljs-code">app.UseStaticFiles();
// not in the default template but needed in all countries of the European Union
app.UseCookiePolicy();
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
...
</code></pre>
<p class="normal"><code class="inlineCode">UseStaticFiles</code> makes all files contained in the <code class="inlineCode">wwwroot</code> folder of the project (typically CSS, JavaScript, images, and font files) accessible from the web through their actual path.</p>
<p class="normal"><code class="inlineCode">UseCookiePolicy</code> has been removed in the .NET 5-8 templates, but you can still add it manually. It ensures that cookies are processed by the ASP.NET Core pipeline, but only if the user has given consent for cookie usage. Consent to cookie usage is given through a consent cookie; that is, cookie processing is enabled only if this consent cookie is found among the request cookies. This <a id="_idIndexMarker1207"/>cookie must be created by JavaScript when the user clicks a consent button. The whole string that contains both the consent cookie’s name and its contents can be retrieved from <code class="inlineCode">HttpContext.Features</code>, as shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">var consentFeature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
var showBanner = !consentFeature?.CanTrack ?? false;
var cookieString = consentFeature?.CreateConsentCookie();
</code></pre>
<p class="normal"><code class="inlineCode">CanTrack</code> is <code class="inlineCode">true</code> only if consent is required and has not been given yet. When the consent cookie is detected, <code class="inlineCode">CanTrack</code> is set to <code class="inlineCode">false</code>. This way, <code class="inlineCode">showBanner</code> is <code class="inlineCode">true</code> only if consent is required and has not been given yet. Therefore, it tells us whether to ask the user for consent.</p>
<pre>CookiePolicyOptions</code> in the code, instead of using the configuration file:</pre>
<pre class="programlisting code"><code class="hljs-code">builder.Services.Configure&lt;CookiePolicyOptions&gt;(options =&gt;
{
    options.CheckConsentNeeded = context =&gt; true;
});
</code></pre>
<p class="normal"><code class="inlineCode">UseAuthentication</code> enables authentication schemes and only appears if you select an authentication scheme when the project is created. More specifically, this middleware decodes the authorization tokens (authorization cookies, bearer tokens, etc.), and it uses the information it contains to build a <code class="inlineCode">ClaimsPrincipal</code> object that is placed in the <code class="inlineCode">HttpContext.User</code> property.</p>
<p class="normal">Specific authentication schemes can be enabled by configuring the options objects in the host building stage, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddAuthentication(o =&gt;
{
    o.DefaultScheme =
    CookieAuthenticationDefaults.AuthenticationScheme;
})
.AddCookie(o =&gt;
{
    o.Cookie.Name = "my_cookie";
})
.AddJwtBearer(o =&gt;
{
    ...
});
</code></pre>
<p class="normal">The preceding code specifies a custom authentication cookie name and adds JWT-based authentication for the REST services contained in the application. Both <code class="inlineCode">AddCookie</code> and <code class="inlineCode">AddJwtBearer</code> have overloads that accept the name of the authentication scheme before the action, which is where you can define the authentication scheme options. Since the authentication <a id="_idIndexMarker1208"/>scheme name is necessary for referring to a specific authentication scheme, when it is not specified, a default name is used:</p>
<ul>
<li class="bulletList">The standard name contained in <code class="inlineCode">CookieAuthenticationDefaults.AuthenticationScheme</code> for cookie authentication</li>
<li class="bulletList">The standard name contained in <code class="inlineCode">JwtBearerDefaults.AuthenticationScheme</code> for JWT authentication</li>
</ul>
<p class="normal">The name that’s passed into <code class="inlineCode">o.DefaultScheme</code> selects the authentication scheme, used to fill the <code class="inlineCode">User</code> property of <code class="inlineCode">HttpContext</code>. Together with <code class="inlineCode">DefaultScheme</code>, other properties also allow more advanced customizations.</p>
<p class="normal">For more information about JWT authentication, please refer to the <em class="italic">ASP.NET Core service authorization</em> subsection of <em class="chapterRef">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>.</p>
<p class="normal">If you just specify <code class="inlineCode">builder.Services.AddAuthentication()</code>, a cookie-based authentication with default parameters is assumed.</p>
<p class="normal"><code class="inlineCode">UseAuthorization</code> enables authorization based on the <code class="inlineCode">Authorize</code> attribute. Options can be configured by adding <code class="inlineCode">builder.Services.AddAuthorization</code> to the host building stage. These options allow you to define the policies for claims-based authorization.</p>
<p class="normal"><code class="inlineCode">UseRouting</code> and <code class="inlineCode">UseEndpoints</code> handle <a id="_idIndexMarker1209"/>the so-called ASP.NET Core endpoints. An endpoint is an abstraction of a handler that serves specific classes of URLs. These URLs are transformed into an <code class="inlineCode">Endpoint</code> instance with patterns. When a pattern matches a URL, an <code class="inlineCode">Endpoint</code> instance is created and filled with both the pattern’s name and the data that was extracted from the URL. This is a consequence of matching URL parts with named parts of the pattern. This can be seen in the following code snippet:</p>
<pre class="programlisting code"><code class="hljs-code">Request path: /UnitedStates/NewYork
Pattern: Name="location", match="/{Country}/{Town}"
Endpoint: DisplayName="Location", Country="UnitedStates", Town="NewYork"
</code></pre>
<p class="normal"><code class="inlineCode">UseRouting</code> adds a module that processes the request path to get the request <code class="inlineCode">Endpoint</code> instance and adds it to the <code class="inlineCode">HttpContext.Features</code> dictionary under the <code class="inlineCode">IEndpointFeature</code> type. The actual <code class="inlineCode">Endpoint</code> instance is contained in the <code class="inlineCode">Endpoint</code> property of <code class="inlineCode">IEndpointFeature</code>.</p>
<p class="normal">Each pattern also contains the handler that should process all the requests that match the pattern. This handler is passed to <code class="inlineCode">Endpoint</code> when it is created.</p>
<p class="normal">On the other hand, <code class="inlineCode">UseEndpoints</code> adds the middleware that executes the route determined by the <code class="inlineCode">UseRouting</code> logic. It is placed at the end of the pipeline, since its middleware produces the final response. Splitting the routing logic into two separate middleware modules enables authorization middleware to sit in between them and, based on the matched endpoint, to decide whether to pass the request to the <code class="inlineCode">UseEndpoints</code> middleware for its normal execution, or whether to return a 401 (<code class="inlineCode">Unauthorized</code>)/403 (<code class="inlineCode">Forbidden</code>) response immediately.</p>
<p class="normal"><code class="inlineCode">UseAuthorization</code> must always be placed after both <code class="inlineCode">UseAuthentication</code> and <code class="inlineCode">UseRouting</code> because it needs both the <code class="inlineCode">HttpContext.User</code> that is filled by <code class="inlineCode">UseAuthentication</code> and the handler selected by <code class="inlineCode">UseRouting</code>, in order to verify whether a user is authorized to access the selected request handler.</p>
<pre>UseRouting</code> middleware, but they are listed in the <code class="inlineCode">UseEndpoints</code> method. While it might appear strange that URL patterns are not <a id="_idIndexMarker1210"/>defined directly in the middleware that uses them, this was done mainly for coherence with the previous ASP.NET Core versions. In fact, previous versions contained no method analogous to <code class="inlineCode">UseRouting</code> and, instead, some unique middleware at the end of the pipeline. In the new version, patterns are still defined at the end of the pipeline for coherence with previous versions, but now, <code class="inlineCode">UseEndpoints</code> just creates a data structure containing all patterns when the application starts. Then, this data structure is processed by the <code class="inlineCode">UseRouting</code> middleware, as shown in the following code:</pre>
<pre class="programlisting code"><code class="hljs-code">app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p class="normal">Where <code class="inlineCode">app.MapControllerRoute</code> is a shortcut for:</p>
<pre class="programlisting code"><code class="hljs-code">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");
   
   
});
</code></pre>
<p class="normal">This shortcut was introduced with the 6.0 version of .NET.</p>
<p class="normal"><code class="inlineCode">MapControllerRoute</code> defines the patterns associated with the MVC engine, which will be described in the next subsection. Other methods define other types of patterns. A call such as <code class="inlineCode">.MapHub&lt;MyHub&gt;("/chat")</code> maps paths to<a id="_idIndexMarker1211"/> hubs that handle <strong class="keyWord">SignalR</strong>, an abstraction built on top of <code class="inlineCode">WebSocket</code>, whereas <code class="inlineCode">.MapHealthChecks("/health")</code> maps paths to ASP.NET Core components that return application health data.</p>
<p class="normal">You can also directly map a pattern to a custom handler with <code class="inlineCode">.MapGet</code>, which intercepts GET requests, and <code class="inlineCode">.MapPost</code>, which intercepts POST requests. This is called <strong class="keyWord">route to code</strong>. The following<a id="_idIndexMarker1212"/> is an example of <code class="inlineCode">MapGet</code>:</p>
<pre class="programlisting code"><code class="hljs-code">MapGet("hello/{country}", context =&gt;
    context.Response.WriteAsync(
    $"Selected country is {context.GetRouteValue("country")}"));
</code></pre>
<p class="normal">We can also write <code class="inlineCode">app.MapGet(...)</code> directly, since there are shortcuts for <code class="inlineCode">MapGet</code>, <code class="inlineCode">MapPost</code>, and so on.</p>
<p class="normal">All these shortcuts, together with the new features, have been named <strong class="keyWord">Minimal API</strong>. They offer a lean approach for simpler applications, which is relevant for architects considering performance optimization and API design, particularly in IoT and microservices scenarios.</p>
<p class="normal">Moreover, <code class="inlineCode">MapGet</code>, <code class="inlineCode">MapPost</code>, and <a id="_idIndexMarker1213"/>suchlike have been enhanced, and now they have overloads whose lambda returns the result directly to add to the response with no need to call <code class="inlineCode">context.Response.WriteAsync</code>. If the result isn’t a string, it is automatically converted into JSON, and the response <code class="inlineCode">Content-Type</code> is set to <code class="inlineCode">application/json</code>. For more complex needs, Minimal APIs can use the static methods of the <code class="inlineCode">Results</code> class that supports all return types supported by ASP.NET Core controllers. The following is an example of <code class="inlineCode">Results</code> class usage:</p>
<pre class="programlisting code"><code class="hljs-code">app.MapGet("/web-site-conditions", () =&gt;
	Results.File("Contracts/WebSiteConditions.pdf"));
</code></pre>
<p class="normal">Patterns are processed in the order in which they are defined until a matching pattern is found. Since the authentication/authorization middleware is placed after the routing middleware, it can process the <code class="inlineCode">Endpoint</code> request to verify whether the current user has the required authorizations to execute the <code class="inlineCode">Endpoint</code> handler.</p>
<p class="normal">Otherwise, a 401 (<code class="inlineCode">Unauthorized</code>) or 403 (<code class="inlineCode">Forbidden</code>) response is immediately returned. Only requests that survive authentication and authorization have their handlers executed by the <code class="inlineCode">UseEndpoints</code> middleware.</p>
<p class="normal">The Minimal API supports the automatic generation of the OpenAPI metadata we described in<em class="italic"> Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET. </em>They also support <strong class="keyWord">Ahead-of-Time</strong> (<strong class="keyWord">AOT</strong>) compilation during the application publication. This way, applications are immediately compiled in the target CPU language, saving the time needed by a just-in-time compilation.</p>
<p class="normal">Moreover, since AOT runs at publication time, it can perform better code optimizations, and in particular, it can trim DLL unused code. In general, AOT is not supported by controller-based applications since they make greater use of reflection.</p>
<p class="normal">Therefore, Minimal APIs are targeted to simple and fast applications, running on small devices such as IoT applications, where, on one hand, speed and reduced application size are fundamental, and on the<a id="_idIndexMarker1214"/> other hand, the benefit of structuring code through controllers is negligible. We will not describe Minimal APIs in great detail, since this book targets mainly business and enterprise applications.</p>
<p class="normal">It is worth mentioning that in the last .NET version, a new <strong class="keyWord">ASP.NET Core API</strong> project was added that scaffolds an application based on the Minimal API.</p>
<p class="normal">Like the ASP.NET Core RESTful API described in <em class="italic">Chapter 15</em>, ASP.NET Core MVC also uses attributes placed on controllers or controller methods to specify authorization rules. However, an instance of <code class="inlineCode">AuthorizeAttribute</code> can also be added to a pattern to apply its authorization constraints to all the URLs matching that pattern, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">endpoints
 .MapHealthChecks("/health")
 .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
</code></pre>
<p class="normal">The previous code makes the health check path available only to administrative users.</p>
<p class="normal">It is also worth mentioning the <code class="inlineCode">.UseCors()</code> middleware, which enables the application to handle CORS policies. We will discuss it in the <em class="italic">Communication with the server</em> section in <em class="italic">Chapter 19, Client Frameworks: Blazor</em>.</p>
<p class="normal">Having described the basic structure of the ASP.NET Core framework, we can now move on to more MVC-specific features. The next subsection describes controllers and explains how they interact with the UI components, known as Views, through ViewModels.</p>
<h2 class="heading-2" id="_idParaDest-348">Defining controllers and ViewModels</h2>
<p class="normal">In ASP.NET Core MVC, controllers and <a id="_idIndexMarker1215"/>ViewModels are central to handling requests, presenting data, and handling<a id="_idIndexMarker1216"/> the whole user-application interactions. Let’s start by understanding how requests issued at specific paths are passed to controllers.</p>
<p class="normal">The various <code class="inlineCode">.MapControllerRoute</code> calls associate URL patterns with controllers and their methods, where controllers are classes that inherit from the <code class="inlineCode">Microsoft.AspNetCore.Mvc.Controller</code> class. Controllers are discovered by inspecting all of the application’s <code class="inlineCode">.dll</code> files and are added to the DI engine. This job is performed by the call to <code class="inlineCode">builder.Services.AddControllersWithViews</code> in the <code class="inlineCode">Program.cs</code> file.</p>
<p class="normal">The pipeline module that’s added by <code class="inlineCode">UseEndpoints</code> takes the controller’s name from the <code class="inlineCode">controller</code> pattern variable, and the name of the controller method to invoke from the <code class="inlineCode">action</code> pattern variable. Since, by <a id="_idIndexMarker1217"/>convention, all controller names are expected to end with the <code class="inlineCode">Controller</code> suffix, the actual controller type name is obtained from the name found in the <code class="inlineCode">controller</code> variable by adding this suffix. Hence, for instance, if the name found in <code class="inlineCode">controller</code> is <code class="inlineCode">Home</code>, then <a id="_idIndexMarker1218"/>the <code class="inlineCode">UseEndpoints</code> module tries to get an instance of the <code class="inlineCode">HomeController</code> type from the DI engine. All of the controller public methods can be selected by the routing rules. The use of a controller public method can be prevented by decorating it with the <code class="inlineCode">[NonAction]</code> attribute. All controller methods available to the routing rules are called action methods.</p>
<p class="normal">MVC controllers work like the API controllers that we described in the <em class="italic">Implementing REST services with ASP.NET Core</em> subsection in <em class="italic">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>. The only difference is that API controllers are expected to produce JSON or XML, while MVC controllers are expected to produce HTML. For this reason, while API controllers inherit from the <code class="inlineCode">ControllerBase</code> class, MVC controllers inherit from the <code class="inlineCode">Controller</code> class, which, in turn, inherits from the <code class="inlineCode">ControllerBase</code> class and adds its methods, which are useful for HTML generation, such as invoking views, as described in the next subsection, and creating a redirect response.</p>
<p class="normal">MVC controllers can also use a routing technique similar to one of the API controllers, that is, routing based on controllers and controller method attributes. This behavior is enabled by calling the <code class="inlineCode">app.MapControllers()</code> method in the pipeline definition code in <code class="inlineCode">Program.cs</code>. If this call is placed before all other <code class="inlineCode">app.MapControllerRoute</code> calls, then the controller routes have priority over <code class="inlineCode">MapControllerRoute</code> patterns; otherwise, the opposite is true.</p>
<p class="normal"><code class="inlineCode">MapControllerRoute</code> has the advantage of deciding in a single place the whole paths used by the whole application. This way, you can optimize all application paths for a search engine, or simply for better user navigation, by changing a few lines of code in a single place. For these reasons, <code class="inlineCode">MapControllerRoute</code> is almost always used in MVC applications. However, <code class="inlineCode">MapControllerRoute</code> is rarely used with the REST API because the priority of the REST API is to avoid changes in the associations between paths and controllers, since they might prevent existing clients from working properly.</p>
<p class="normal">All the attributes we have seen <a id="_idIndexMarker1219"/>for API controllers can also be used with MVC controllers and action methods (<code class="inlineCode">HttpGet</code>, <code class="inlineCode">HttpPost</code>, …, <code class="inlineCode">Authorize</code>, and so on). Developers can write their own custom attributes <a id="_idIndexMarker1220"/>by inheriting from the <code class="inlineCode">ActionFilter</code> class or other derived classes. I will not give details on this right now, but these details can be found in the official documentation, which is referred to in the <em class="italic">Further reading</em> section.</p>
<p class="normal">When the <code class="inlineCode">UseEndpoints</code> module invokes a controller, all of its constructor parameters are filled by the DI engine, since the controller instance itself is returned by the DI engine, and since DI automatically fills constructor parameters with DI in a recursive fashion.</p>
<p class="normal">Action methods take both their input and services from their parameters, so it is crucial to understand how these parameters are filled by ASP.NET Core. They are taken from the following sources:</p>
<ul>
<li class="bulletList">Request headers</li>
<li class="bulletList">Variables in the pattern matched by the current request</li>
<li class="bulletList">Query string parameters</li>
<li class="bulletList">Form parameters (in the case of POST requests)</li>
<li class="bulletList">The request body</li>
<li class="bulletList"><strong class="keyWord">Dependency injection</strong> (<strong class="keyWord">DI</strong>), in case of services needed to process the request</li>
</ul>
<p class="normal">While the parameters filled with DI are matched by type, all other parameters are matched by <em class="italic">name</em> while ignoring the letter casing. That is, the action method parameter name must match the header, query string, form, or pattern variable. In turn, pattern variables are filled by matching the pattern with the request path.</p>
<p class="normal">When the parameter is a complex type, the behavior depends on the source.</p>
<p class="normal">If the source is the request body, a <strong class="keyWord">formatter</strong> adequate for the request <code class="inlineCode">Content-Type</code> is selected. <strong class="keyWord">Formatters</strong> are software modules capable of building complex entities, starting from a text representation of them. As a default, the request body is taken as a source for selected <code class="inlineCode">Content-Types</code>, such as <code class="inlineCode">application/json</code> and binary MIME types, because each such MIME type requires a different deserialization algorithm that is specific to it.</p>
<p class="normal">If the source is not the request body, an algorithm called model binding is used to fill all complex object public properties instead.</p>
<p class="normal">The model binding algorithm searches for a match in each property (remember that just properties are mapped; fields are not), using the property name for the match. In the case of nested complex<a id="_idIndexMarker1221"/> types, a match is searched for each nested property’s path, and the name associated with the path is obtained by chaining all the property names in the path and separating them with<a id="_idIndexMarker1222"/> dots. For instance, a parameter whose name is <code class="inlineCode">Property1.Property2.Property3…Propertyn</code> is mapped with the <code class="inlineCode">Propertyn</code> property that is in the following path of nested object properties: <code class="inlineCode">Property1</code>, <code class="inlineCode">Property2</code>, ...., <code class="inlineCode">Propertyn</code>.</p>
<p class="normal">The name that’s obtained this way must match a header name, pattern variable name, query string parameter name, and so on. For instance, an <code class="inlineCode">OfficeAddress</code> property containing a complex <code class="inlineCode">Address</code> object would generate names like <code class="inlineCode">OfficeAddress.Country</code> and <code class="inlineCode">OfficeAddress.Town</code>.</p>
<p class="normal">The model binding algorithm can also fill collections and dictionaries, but due to a lack of space, we can’t describe these cases. However, the <em class="italic">Further reading</em> section contains a link to an excellent Phil Haack post that explains them in detail.</p>
<p class="normal">By default, simple type parameters are matched with pattern variables and query string variables, while complex type parameters are matched with form parameters or the request body (depending on their MIME types). However, the preceding defaults can be changed by prefixing the parameters with attributes, as detailed here:</p>
<ul>
<li class="bulletList"><code class="inlineCode">[FromForm]</code> forces a match with form parameters</li>
<li class="bulletList"><code class="inlineCode">[FromBody]</code> forces the extraction of data from the request body</li>
<li class="bulletList"><code class="inlineCode">[FromHeader]</code> forces a match with a request header</li>
<li class="bulletList"><code class="inlineCode">[FromRoute]</code> forces a match with pattern variables</li>
<li class="bulletList"><code class="inlineCode">[FromQuery]</code> forces a match with a query string variable</li>
<li class="bulletList"><code class="inlineCode">[FromServices]</code> forces the use of DI</li>
</ul>
<p class="normal">It is worth pointing out that versions 7 and 8 of ASP.NET Core have an enhanced Minimal API to support basically the same parameter bindings of a controller’s action methods, as well as all the above parameter attributes.</p>
<p class="normal">During the match, the string that was extracted from the selected source is converted into the type of the action method parameter, using the current thread culture. If either a conversion fails or no match is found for an obligatory action method parameter, then the whole action method<a id="_idIndexMarker1223"/> invocation process fails, and a 404 response is automatically returned. For instance, in the following example, the <code class="inlineCode">id</code> parameter is matched with query string parameters or<a id="_idIndexMarker1224"/> pattern variables, since it is a simple type, while <code class="inlineCode">myclass</code> properties and nested properties are matched with form parameters, since <code class="inlineCode">MyClass</code> is a complex type. Finally, <code class="inlineCode">myservice</code> is taken from DI, since it is prefixed with the <code class="inlineCode">[FromServices]</code> attribute:</p>
<pre class="programlisting code"><code class="hljs-code"> public class HomeController : Controller
    {
        public IActionResult MyMethod(
 int id,
            MyClass myclass,
            [FromServices] MyService myservice)
        {
            ...
</code></pre>
<p class="normal">If no match is found for the <code class="inlineCode">id</code> parameter, and if the <code class="inlineCode">id</code> parameter is declared as obligatory in the <code class="inlineCode">MapControllerRoute</code> pattern, a 404 response is automatically returned, since pattern matching fails. It is common to declare parameters as not optional when they must match not-nullable single types. If, instead, no <code class="inlineCode">MyService</code> instance is found in the DI container, an exception is thrown because, in this case, the failure doesn’t depend on a wrong request but on a design error.</p>
<p class="normal">MVC controllers return an <code class="inlineCode">IActionResult</code> interface or a <code class="inlineCode">Task&lt;IActionResult&gt;</code> result if they are declared as <code class="inlineCode">async</code>. <code class="inlineCode">IActionResult</code> defines the unique method with the <code class="inlineCode">ExecuteResultAsync(ActionContext)</code> signature, which, when invoked by the framework, produces the actual response.</p>
<p class="normal">For each different <code class="inlineCode">IActionResult</code>, MVC controllers have methods that return them. The most commonly used <code class="inlineCode">IActionResult</code> is <code class="inlineCode">ViewResult</code>, which is returned by a <code class="inlineCode">View</code> method:</p>
<pre class="programlisting code"><code class="hljs-code">public IActionResult MyMethod(...)
{
   ...
   return View("myviewName", MyViewModel)
}
</code></pre>
<p class="normal"><code class="inlineCode">ViewResult</code> is a very common way for a controller to create an HTML response. More specifically, the controller interacts with business/data layers to produce an abstraction of the data that will be shown on the HTML page. This abstraction is an object called a <strong class="keyWord">ViewModel</strong>. The ViewModel is passed as a<a id="_idIndexMarker1225"/> second argument to the <code class="inlineCode">View</code> method, while the first argument is the name <a id="_idIndexMarker1226"/>of an HTML template, called <code class="inlineCode">View</code>, that is <a id="_idIndexMarker1227"/>instantiated with the data contained in the ViewModel.</p>
<p class="normal">Summing this up, the MVC controllers’ processing sequence is as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">The controllers perform some processing to create the ViewModel, which is an abstraction of the data to show on the HTML page.</li>
<li class="numberedList">Then, the controllers create <code class="inlineCode">ViewResult</code> by passing a View name and ViewModel to the <code class="inlineCode">View</code> method.</li>
<li class="numberedList">The MVC framework invokes <code class="inlineCode">ViewResult</code> and causes the template contained in the View to be instantiated with the data contained in the ViewModel.</li>
<li class="numberedList">The result of the template’s instantiation is written in the response with adequate headers.</li>
</ol>
<p class="normal">This way, the controller performs the conceptual job of HTML generation by building a ViewModel, while the View – that is, the template – takes care of all the presentation details.</p>
<p class="normal">Views will be described in greater detail in the next subsection, while the Model (ViewModel) View Controller pattern will be discussed in more detail in the <em class="italic">Understanding the connection between ASP.NET Core MVC and design principles</em> section in this chapter. Finally, a practical example will be provided in <em class="italic">Chapter 18</em>, <em class="italic">Implementing Frontend Microservices with ASP.NET Core</em>.</p>
<p class="normal">Another common <code class="inlineCode">IActionResult</code> is <code class="inlineCode">RedirectResult</code>, which creates a redirect response, hence forcing the browser to move to a specific URL. Redirects are often used once the user has successfully submitted a form that completes a previous operation. In this case, it is common to redirect the user to a page where they can select another operation.</p>
<p class="normal">The simplest way to return <code class="inlineCode">RedirectResult</code> is by passing a URL to the <code class="inlineCode">Redirect</code> method. This is the advised way to perform a redirect to a URL that is outside the web application. On the other hand, when the URL is within the web application, it is advisable to use the <code class="inlineCode">RedirectToAction</code> method, which accepts the controller’s name, the action method name, and the desired parameters for the target action method. This method has several overloads, where each overload omits some of the above parameters. In particular, the controller name can be omitted if the URL we define is handled by the same controller.</p>
<p class="normal">The framework uses this data to compute a URL that causes the desired action method to be invoked with the parameters <a id="_idIndexMarker1228"/>provided. This way, if the routing rules are changed during the application’s <a id="_idIndexMarker1229"/>development or maintenance, the new URL is automatically updated by the framework, with no need to modify all occurrences of the old URL in the code.</p>
<p class="normal">The following code shows how to call <code class="inlineCode">RedirectToAction</code>:</p>
<pre class="programlisting code"><code class="hljs-code">return RedirectToAction("MyActionName", "MyControllerName",
         new {par1Name=par1Value,..parNName=parNValue});
</code></pre>
<p class="normal">Another useful <code class="inlineCode">IActionResult</code> is <code class="inlineCode">ContentResult</code>, which can be created by calling the <code class="inlineCode">Content</code> method. <code class="inlineCode">ContentResult</code> allows you to write any string to the response and specify its MIME type, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">return Content("this is plain text", "text/plain");
</code></pre>
<p class="normal">Finally, the <code class="inlineCode">File</code> method returns <code class="inlineCode">FileResult</code>, which writes binary data in the response. There are several overloads of this method that allow the specification of a byte array, a stream, or the path of a file, plus the MIME type of the binary data.</p>
<p class="normal">Now, let’s move on to describing how actual HTML is generated in Views.</p>
<h1 class="heading-1" id="_idParaDest-349">Understanding how ASP.NET Core MVC creates the response HTML</h1>
<h2 class="heading-2" id="_idParaDest-350">Razor Views</h2>
<p class="normal">ASP.NET Core MVC uses a language called Razor <a id="_idIndexMarker1230"/>to define the HTML templates contained in the Views. Razor views are files that are compiled into .NET classes <a id="_idIndexMarker1231"/>when they’re first used, when the application has been built, or when the application has been published. By default, both pre compilation on each build and on publish are enabled, but you can also enable runtime compilation so that the Views can be modified once they have been deployed. This option can be enabled by checking the <strong class="keyWord">Enable Razor runtime compilation</strong> checkbox when the project is created in Visual Studio. You can also disable compilation on each build and on publish by adding the following code to the web application project file:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
&lt;TargetFramework&gt; net8.0 &lt;/TargetFramework&gt;
&lt;!-- add code below --&gt;
&lt;RazorCompileOnBuild&gt;false&lt;/RazorCompileOnBuild&gt;
&lt;RazorCompileOnPublish&gt;false&lt;/RazorCompileOnPublish&gt;
&lt;!-- end of code to add --&gt;
    ...
&lt;/PropertyGroup&gt;
</code></pre>
<p class="normal">Views can also be precompiled into Views libraries if you choose a Razor view library project in the window, which appears once you have chosen an ASP.NET Core project.</p>
<p class="normal">Also, following the compilation, Views <a id="_idIndexMarker1232"/>remain associated with their paths, which become their full names. Each controller has an associated folder under the <strong class="keyWord">Views</strong> folder with the same name as the controller, which is expected to contain all the Views used by that controller.</p>
<p class="normal">The following screenshot shows the folder associated with a possible <code class="inlineCode">HomeController</code> and its Views:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" src="img/B19820_17_06.png"/></figure>
<p class="packt_figref">Figure 17.6: View folders associated with controllers and the shared folder</p>
<p class="normal">The preceding screenshot also shows the <strong class="keyWord">Shared</strong> folder, which is expected to contain all the Views or partial views used by several controllers. The controller refers to views in the <code class="inlineCode">View</code> method through their paths without the <code class="inlineCode">.cshtml</code> extension. If the path starts with <code class="inlineCode">/</code>, the path is interpreted as relative to the application root. Otherwise, as a first attempt, the path is interpreted as <a id="_idIndexMarker1233"/>relative to the folder associated with the controller. If no View is found there, the View is searched for in the <strong class="keyWord">Shared</strong> folder.</p>
<p class="normal">Hence, for instance, the <code class="inlineCode">Privacy.cshtml</code> View file in the preceding screenshot can be referred to from within <code class="inlineCode">HomeController</code> as <code class="inlineCode">View("Privacy", MyViewModel)</code>. If the name of the View is the same as the name of the action method, we can simply write <code class="inlineCode">View(MyViewModel)</code>.</p>
<p class="normal">Razor views are a mix of HTML code with C# code, plus some Razor-specific statements. They usually begin with a header that contains the type of ViewModel that the View is expected to receive:</p>
<pre class="programlisting code"><code class="hljs-code">@model MyViewModel
</code></pre>
<p class="normal">This declaration may be omitted, but in this case, the view will not be specific to a specific type, and we will not be able to use the model property names in the Razor code.</p>
<p class="normal">Each view may also contain some <code class="inlineCode">using</code> statements, whose effect is the same as the <code class="inlineCode">using</code> statements of standard code files:</p>
<pre class="programlisting code"><code class="hljs-code">@model MyViewModel
@using MyApplication.Models
</code></pre>
<p class="normal"><code class="inlineCode">@using</code> statements declared in the special <code class="inlineCode">_ViewImports.cshtml</code> file – that is, in the root of the <code class="inlineCode">Views</code> folder – are automatically applied to all views.</p>
<p class="normal">Each view can also require instances of types from the DI engine in its header, with the syntax shown here:</p>
<pre class="programlisting code"><code class="hljs-code">@model MyViewModel
@using MyApplication.Models
@inject IViewLocalizer Localizer
</code></pre>
<p class="normal">The preceding code requires an instance of the <code class="inlineCode">IViewLocalizer</code> interface and places it in the <code class="inlineCode">Localizer</code> variable. The remainder of the View is a mix of C# code, HTML, and Razor control flow statements. Each area of a view can be either in HTML mode or C# mode. The code in a View area that is in HTML mode is interpreted as HTML, while the code in a View area that is in C# mode is interpreted as C#.</p>
<p class="normal">The topic that follows explains <a id="_idIndexMarker1234"/>the Razor flow of control statements.</p>
<h3 class="heading-3" id="_idParaDest-351">Learning the Razor flow of control statements</h3>
<p class="normal">If you want to write some C# code in an HTML<a id="_idIndexMarker1235"/> area, you can create a C# area with the <code class="inlineCode">@{..}</code> Razor flow of a control statement, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">@{
    //place C# code here
var myVar = 5;
    ...
    &lt;div&gt;
        &lt;!-- here you are in HTML mode again --&gt;
        ...
    &lt;/div&gt;
    //after the HTML block you are still in C# mode
var x = "my string";
}
</code></pre>
<p class="normal">The preceding example shows that it is enough to write an HTML tag to create an HTML area inside the C# area and so on recursively. As soon as the HTML tag closes, you are in C# mode again.</p>
<p class="normal">If we need to create an HTML area but don’t want to enclose it in an HTML tag, we can use the fake <code class="inlineCode">&lt;text&gt;</code> tag provided by Razor syntax:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;text&gt;
&lt;!-- here you entered HTML mode without adding an enclosing
	HTML tag --&gt;
        ...
&lt;/text&gt;
</code></pre>
<p class="normal">C# code produces no HTML, while HTML code is added to the response in the same order in which it appears. You can add text computed with C# code while in HTML mode by prefixing any C# expression with <code class="inlineCode">@</code>. If the expression is complex, in that it is composed of a chain of properties and method calls, it must be enclosed by parentheses. The following code shows some examples:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;span&gt;Current date is: &lt;/span&gt;
&lt;span&gt;@DateTime.Today.ToString("d")&lt;/span&gt;
...
&lt;p&gt;
  User name is: @($"{myName} {mySurname}")
&lt;/p&gt;
...
&lt;input type="submit" value="@myUserMessage" /&gt;
</code></pre>
<p class="normal">The <code class="inlineCode">@</code> itself can be escaped by entering it twice – <code class="inlineCode">@@</code>.</p>
<p class="normal">Types are converted into strings using the current culture settings (see the <em class="italic">Understanding the connection between ASP.NET Core MVC and design principles</em> section for details on how to set the culture of each request). Moreover, strings are automatically HTML-encoded to<a id="_idIndexMarker1236"/> avoid the <code class="inlineCode">&lt;</code> and <code class="inlineCode">&gt;</code> symbols, which might interfere with the view HTML.</p>
<p class="normal">HTML encoding can be prevented with the <code class="inlineCode">@HTML.Raw</code> function, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">@HTML.Raw(myDynamicHtml)
</code></pre>
<p class="normal">In an HTML area, alternative HTML can be selected with the <code class="inlineCode">@if</code> Razor statement:</p>
<pre class="programlisting code"><code class="hljs-code">@if(myUser.IsRegistered)
{
    //this is a C# code area
var x=5;
    ...
    &lt;p&gt;
     &lt;!-- This is an HTML area --&gt;
    &lt;/p&gt;
    //this is a C# code area again
}
else if(myUser.IsNew)
{
    ...
}
else
{
 ..
}
</code></pre>
<p class="normal">As shown in the preceding code, the beginning of each block of a Razor control flow statement is in C# mode and remains so until the first HTML open tag is encountered, and then, HTML mode starts. C# mode is resumed after the corresponding HTML close tag.</p>
<p class="normal">An HTML template can be <a id="_idIndexMarker1237"/>instantiated several times with the <code class="inlineCode">for</code>, <code class="inlineCode">foreach</code>, <code class="inlineCode">while</code>, and <code class="inlineCode">do</code> Razor statements, as shown in the following examples:</p>
<pre class="programlisting code"><code class="hljs-code">@for(int i=0; i&lt; 10; i++)
{
}
@foreach(var x in myIEnumerable)
{
}
@while(true)
{
   
}
@do
{
   
}
while(true)
</code></pre>
<p class="normal">Razor views can contain comments that do not generate any code. Any text included within <code class="inlineCode">@*...*@</code> is considered a comment and removed when the page is compiled. With a good understanding of controllers and their operational mechanics, let’s now turn to how ASP.NET Core MVC generates HTML responses using Razor views.</p>
<h3 class="heading-3" id="_idParaDest-352">Understanding Razor view properties</h3>
<p class="normal">Some standard variables are predefined in each<a id="_idIndexMarker1238"/> view. The most important variable is <code class="inlineCode">Model</code>, which contains the ViewModel that was passed to the view. For instance, if we pass a <code class="inlineCode">Person</code> model to a view, then <code class="inlineCode">&lt;span&gt;@Model.Name&lt;/span&gt;</code> displays the name of the <code class="inlineCode">Person</code> model that was passed to the view.</p>
<p class="normal">The <code class="inlineCode">ViewData</code> variable contains <code class="inlineCode">IDictionary&lt;string, object&gt;</code>, which is shared with the controller that invoked the view; that is, all controllers also have a <code class="inlineCode">ViewData</code> property containing <code class="inlineCode">IDictionary&lt;string, object&gt;</code>, and every entry that is set in the controller is also available in the <code class="inlineCode">ViewData</code> variable of the invoked view. <code class="inlineCode">ViewData</code> is an alternative to the ViewModel for a controller, allowing the passing of information to its invoked view. It is worth mentioning that the <code class="inlineCode">ViewData</code> dictionary can also be accessed as a dynamic object through the <code class="inlineCode">ViewBag</code> property. This means that dynamic <code class="inlineCode">ViewBag</code> properties are mapped to <code class="inlineCode">ViewData</code> string indices and that their values are mapped to the <code class="inlineCode">ViewData</code> entries corresponding to those indices. Using <code class="inlineCode">ViewData</code> or <code class="inlineCode">ViewBag</code> is just a matter of preference; neither one has an advantage over the other.</p>
<p class="normal">Often, <code class="inlineCode">ViewData</code> is used to store collateral data such as the value-string pairs used to populate an HTML Select. For instance, let’s suppose the ViewModel model contains <code class="inlineCode">TownId</code> and <code class="inlineCode">TownName</code> properties that the user<a id="_idIndexMarker1239"/> can change, by selecting a different town from an HTML Select. In this case, the action method might fill the <code class="inlineCode">"AllTowns"</code> entry of <code class="inlineCode">ViewData</code> with all possible town ID and town name pairs:</p>
<pre class="programlisting code"><code class="hljs-code">ViewData[=["AllTowns"]= await townsRepo.GetAll();
...
return View(new AddressViewModel{...});
</code></pre>
<p class="normal">Both controllers and Views also contain a <code class="inlineCode">TempData</code> dictionary, whose entries are remembered between two successive requests. Due to a lack of space, we can’t discuss its properties and its usage, but the interested among you can refer to the official Microsoft documentation:</p>
<p class="normal"><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-8.0#tempdata">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-8.0#tempdata</a></p>
<p class="normal">The <code class="inlineCode">User</code> view variable contains the currently logged-in user, that is, the same instance contained in the current request’s <code class="inlineCode">Http.Context.User</code> property. The <code class="inlineCode">Url</code> variable contains an instance of the <code class="inlineCode">IUrlHelper</code> interface, whose methods are utilities for computing the URLs of application pages. For instance, <code class="inlineCode">Url.Action("action", "controller", new {par1=valueOfPar1,...})</code> computes the URL that causes the action method, <code class="inlineCode">action</code>, of <code class="inlineCode">controller</code> to be invoked, with all the parameters specified in the anonymous object passed as its parameters.</p>
<p class="normal">The <code class="inlineCode">Context</code> variable contains the whole request’s <code class="inlineCode">HttpContext</code>. The <code class="inlineCode">ViewContext</code> variable contains data about the context of the view invocation, including metadata about the action method that invoked the view.</p>
<p class="normal">The next topic describes how Razor views enhance HTML tag syntax.</p>
<h3 class="heading-3" id="_idParaDest-353">Using Razor tag helpers</h3>
<p class="normal">Tag helpers in ASP.NET Core MVC are powerful tools for enhancing HTML tags with additional functionalities. More specifically, a <a id="_idIndexMarker1240"/>tag helper either enhances existing HTML tags with new tag attributes or defines completely new tags.</p>
<p class="normal">While Razor views are compiled, any tag is matched against existing tag helpers. When a match is found, the source tag is replaced with HTML created by the tag helpers. Several tag helpers may be defined for the same tag. They are all executed in an order that can be configured with a priority attribute associated with each tag helper.</p>
<p class="normal">All tag helpers defined for the same tag may cooperate while each tag instance is being processed. This is because they are passed a shared data structure where each of them may apply a contribution. Usually, the final tag helper that is invoked processes this shared data structure to produce the output HTML.</p>
<p class="normal">Tag helpers are classes that inherit from the <code class="inlineCode">TagHelper</code> class. This topic doesn’t discuss how to create new tag helpers, but it<a id="_idIndexMarker1241"/> does introduce the main predefined tag helpers that come with ASP.NET Core MVC. A complete guide on how to define tag helpers is available in the official documentation, which is referenced in the <em class="italic">Further reading</em> section.</p>
<p class="normal">To use a tag helper, you must declare the <code class="inlineCode">.dll</code> file that contains the tag helper with a declaration like the following:</p>
<pre class="programlisting code"><code class="hljs-code">@addTagHelper *, Dll.Complete.Name
</code></pre>
<p class="normal">If you would like to use just one of the tag helpers defined in the <code class="inlineCode">.dll</code> file, you must replace <code class="inlineCode">*</code> with the tag name.</p>
<p class="normal">The preceding declaration can be placed either in each view that uses the tag helpers defined in the library or, ultimately, in the <code class="inlineCode">_ViewImports.cshtml</code> file in the root of the <code class="inlineCode">Views</code> folder. By default, <code class="inlineCode">_ViewImports.cshtml</code> adds all predefined ASP.NET Core MVC tag helpers with the following declaration:</p>
<pre class="programlisting code"><code class="hljs-code">@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
</code></pre>
<p class="normal">The anchor tag is enhanced with attributes that automatically compute the URL and invoke a specific action method with given parameters, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;a asp-controller="{controller name}"
asp-action="{action method name}"
asp-route-{action method parameter1}="value1"
...
asp-route-{action method parametern}="valuen"&gt;
    put anchor text here
&lt;/a&gt;
</code></pre>
<p class="normal">Below is an example of its usage:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;a asp-controller="Home" asp-action="Index"&gt;
 Back Home
&lt;/a&gt;
</code></pre>
<p class="normal">The HTML created is:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;a href="Home/Index"&gt;
 Back Home
&lt;/a&gt;
</code></pre>
<p class="normal">It might appear that there is almost no advantage in using the tag helper. However, this isn’t true! The advantage is that <a id="_idIndexMarker1242"/>whenever the routing rules change, the tag helper automatically updates the <code class="inlineCode">href</code> that it generates to conform to the new routing rules.</p>
<p class="normal">A similar syntax is added to the <code class="inlineCode">form</code> tags:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;form asp-controller="{controller name}"
asp-action="{action method name}"
asp-route-{action method parameter1}="value1"
...
asp-route-{action method parametern}="valuen"
...
&gt;
...
</code></pre>
<p class="normal">The <code class="inlineCode">script</code> tag is enhanced with attributes that allow us to fall back to a different source if the download fails. Typical usage is to download scripts from some cloud service to optimize the browser cache and to fall back to a local copy of the script if there is a failure. The following code uses the fallback technique to download the <code class="inlineCode">bootstrap</code> JavaScript file:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;script src="https://stackpath.bootstrapcdn.com/
 bootstrap/4.3.1/js/bootstrap.bundle.min.js"
 asp-fallback-src="img/bootstrap.bundle.min.js"
 asp-fallback-test="window.jQuery &amp;&amp; window.jQuery.fn &amp;&amp; window.jQuery.fn.modal"
 crossorigin="anonymous"
 integrity="sha384-xrRywqdh3PHs8keKZN+8zzc5TX0GRTLCcmivcbNJWm2rs5C8PRhcEn3czEjhAO9o"&gt;
&lt;/script&gt;
</code></pre>
<p class="normal"><code class="inlineCode">asp-fallback-test</code> contains a JavaScript test that verifies whether the download succeeded. In the preceding example, the test verifies whether a JavaScript object has been created.</p>
<p class="normal">All HTML tags that admit an <code class="inlineCode">src</code> attribute, that is, the <code class="inlineCode">img</code> and the script tags, can be added as an <code class="inlineCode">asp-append-version</code> attribute set to <code class="inlineCode">true</code>. The <code class="inlineCode">asp-append-version</code> attribute set to <code class="inlineCode">true</code> doesn’t change the<a id="_idIndexMarker1243"/> syntax of the <code class="inlineCode">img</code> and <code class="inlineCode">script</code> tags; it just adds a hash to the <code class="inlineCode">src</code> query string to prevent cashing each time the image or <code class="inlineCode">script</code> file changes. Here is an example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;img src="img/myImage.png" asp-append-version="true"&gt;
</code></pre>
<p class="normal">Which is rendered as:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;img src="img/myImage.png?v=kM_dqr9NVtnMdsM2MUgdskVVFD"&gt;
</code></pre>
<p class="normal">The hash passed in the <code class="inlineCode">v</code> query parameter is computed from the content of the image file, so it changes whenever the image changes, thereby preventing the browser from rendering an old cached copy of the image.</p>
<p class="normal">The <code class="inlineCode">~/</code> symbol is not a feature specific to the <code class="inlineCode">img</code> tag helper and, instead, a Razor native feature you can use in all links contained in any tag of a Razor file. It stands for the application root. It is not equivalent to the HTML <code class="inlineCode">/</code> symbol that stands for the root of the domain, because ASP.NET Core applications can also be placed in subfolders of the domain. So <code class="inlineCode">~/</code> translates as <code class="inlineCode">/</code> only when the application is placed in the domain root; otherwise, it translates as <code class="inlineCode">/{application subfolder name}/</code>.</p>
<p class="normal">The <code class="inlineCode">environment</code> tag can be used to select different HTML for different environments (development, staging, and production). Its typical usage is selecting the debug versions of JavaScript files during development, as shown in this example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;environment include="Development"&gt;
        @*development version of JavaScript files*@
&lt;/environment&gt;
&lt;environment exclude="Development"&gt;
        @*development version of JavaScript files *@
&lt;/environment&gt;
</code></pre>
<p class="normal">There is also a <code class="inlineCode">cache</code> tag, which caches its content in memory to optimize rendering speed:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;cache&gt;
    @* heavy to compute content to cache *@
&lt;/cache&gt;
</code></pre>
<p class="normal">By default, content is cached for 20 minutes, but the tag has attributes that must be defined when the cache expires, such as <code class="inlineCode">expires-on="{datetime}"</code>, <code class="inlineCode">expires-after="{timespan}"</code>, and <code class="inlineCode">expires-sliding="{timespan}"</code>. Here, the difference between <code class="inlineCode">expires-sliding</code> and <code class="inlineCode">expires-after</code> is that, in the second attribute, the expiration time count is reset each time the content is requested. The <code class="inlineCode">vary-by</code> attribute causes the creation of a different<a id="_idIndexMarker1244"/> cache entry for each different value passed to <code class="inlineCode">vary-by</code>. There are also attributes such as <code class="inlineCode">vary-by-header</code>, which creates a different entry for each different value assumed by the request header specified in the <code class="inlineCode">vary-by-cookie</code> attribute, and so on.</p>
<p class="normal">All <code class="inlineCode">input</code> tags – that is, <code class="inlineCode">textarea</code>, <code class="inlineCode">input</code>, and <code class="inlineCode">select</code> – have an <code class="inlineCode">asp-for</code> attribute that accepts a properties path rooted in the view’s ViewModel as their value. For instance, if the view has a <code class="inlineCode">Person</code> ViewModel, we may have something like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;input type="text" asp-for"Address.Town"/&gt;
</code></pre>
<p class="normal">The first thing the preceding code does is assign the value of the <code class="inlineCode">Town</code> nested property to the <code class="inlineCode">value</code> attribute of the <code class="inlineCode">input</code> tag. In general, if the value is not a string, it is converted into a string using the current request culture.</p>
<p class="normal">However, it also sets the name of the input field to <code class="inlineCode">Address.Town</code> and the <code class="inlineCode">id</code> of the input field to <code class="inlineCode">Address_Town</code>. This is because dots are not allowed in tag <code class="inlineCode">ids</code>.</p>
<p class="normal">A prefix can be added to these standard names by specifying it in <code class="inlineCode">ViewData.TemplateInfo.HtmlFieldPrefix</code>. For instance, if the previous property is set to <code class="inlineCode">MyPerson</code>, the name becomes <code class="inlineCode">MyPerson.Address.Town</code>.</p>
<p class="normal">If the form is submitted to an action method that has the same <code class="inlineCode">Person</code> class as one of its parameters, the name of <code class="inlineCode">Address.Town</code> that’s given to the <code class="inlineCode">input</code> field will cause the <code class="inlineCode">Town</code> property of this parameter to be filled with the <code class="inlineCode">input</code> field. In general, the string contained in the <code class="inlineCode">input</code> field is converted into the type of property it has been matched with, using the current request culture. Summing this up, the names of <code class="inlineCode">input</code> fields are created in such a way that a complete <code class="inlineCode">Person</code> model can be recovered in the action method when the HTML page is posted.</p>
<p class="normal">The same <code class="inlineCode">asp-for</code> attribute can be used in a <code class="inlineCode">label</code> tag to cause the label to refer to the input field with the same <code class="inlineCode">asp-for</code> value.</p>
<p class="normal">The following code is an example of an <code class="inlineCode">input/label</code> pair:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;label asp-for="Address.Town"&gt;&lt;/label
&lt;input type="text" asp-for="Address.Town"/&gt;
</code></pre>
<p class="normal">When no text is inserted into the label, the text shown in the label is taken from a <code class="inlineCode">Display</code> attribute that decorates the property (<code class="inlineCode">Town</code>, in this example), if any; otherwise, the name of the property is used.</p>
<p class="normal">If <code class="inlineCode">span</code> or <code class="inlineCode">div</code> contains an <code class="inlineCode">asp-validation-for="Address.Town"</code> error attribute, then validation messages concerning the <code class="inlineCode">Address.Town</code> input will be inserted automatically inside that tag. The validation<a id="_idIndexMarker1245"/> framework will be described in the <em class="italic">Understanding the connection between ASP.NET Core MVC and design principles</em> section.</p>
<p class="normal">It is also possible to automatically create a validation error summary by adding the attribute that follows a <code class="inlineCode">div</code> or a <code class="inlineCode">span</code>:</p>
<pre class="programlisting code"><code class="hljs-code">asp-validation-summary="ValidationSummary.{All, ModelOnly}"
</code></pre>
<p class="normal">If the attribute is set to <code class="inlineCode">ValidationSummary.ModelOnly</code>, only messages that are not associated with specific <code class="inlineCode">input</code> fields will be shown in the summary, while if the value is <code class="inlineCode">ValidationSummary.All</code>, all error messages will be shown.</p>
<p class="normal">The <code class="inlineCode">asp-items</code> attribute can be applied to any <code class="inlineCode">select</code> tag to automatically generate all the <code class="inlineCode">select</code> options. It must be passed an <code class="inlineCode">IEnumerable&lt;SelectListItem&gt;</code>, where each <code class="inlineCode">SelectListItem</code> contains both the text and value of an option. <code class="inlineCode">SelectListItem</code> also contains an optional <code class="inlineCode">Group</code> property that you can use to organize the options shown in <code class="inlineCode">select</code> into groups.</p>
<p class="normal">Here is an example of how to use <code class="inlineCode">asp-items</code>:</p>
<pre class="programlisting code"><code class="hljs-code">...
@{
 var choices = new List&lt;SelectListItem&gt;
 {
   new SelectListItem {Value="value1", Text="text1", Group="group1"},
   new SelectListItem {Value="value2", Text="text2", Group="group1"}
   ...
   new SelectListItem {..., Group="group2"}
   ...
 }
}
&lt;select asp-for="MyProperty"  asp-items="choices"&gt;
 &lt;option value=""&gt;Select a value&lt;/option&gt;
&lt;/select&gt;
...
</code></pre>
<p class="normal">When added, option tags are placed before the ones generated by <code class="inlineCode">asp-items</code>.</p>
<p class="normal">The next topic shows how to <a id="_idIndexMarker1246"/>reuse view code.</p>
<h2 class="heading-2" id="_idParaDest-354">Reusing view code</h2>
<p class="normal">ASP.NET Core MVC includes several techniques for reusing view code, with the most important being the layout page.</p>
<p class="normal">In each web application, several pages<a id="_idIndexMarker1247"/> share the same structure, for instance, the same main menu or the same left or right bar. In ASP.NET Core, this common structure is factored out in views called layout pages/views.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_17_07.png"/></figure>
<p class="packt_figref">Figure 17.7: Using layout pages</p>
<p class="normal">Each view can specify the view to be used as its layout page with the following code:</p>
<pre class="programlisting code"><code class="hljs-code">@{
    Layout = "_MyLayout";
}
</code></pre>
<p class="normal">If no layout page is specified, a default layout page, defined in a <code class="inlineCode">_ViewStart.cshtml</code> file located in the <code class="inlineCode">Views</code> folder, is used. The default content of <code class="inlineCode">_ViewStart.cshtml</code> is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">@{
    Layout = "_Layout";
}
</code></pre>
<p class="normal">Therefore, the default layout page in the files scaffolded by Visual Studio is <code class="inlineCode">_Layout.cshtml</code>, which is<a id="_idIndexMarker1248"/> contained in the <code class="inlineCode">Shared</code> folder.</p>
<p class="normal">The layout page contains the HTML that’s shared with all of its children pages, the HTML page headers, and the page references to CSS and JavaScript files. The HTML produced by each view is placed inside its layout page, where the layout page calls the <code class="inlineCode">@RenderBody()</code> method, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">...
&lt;main role="main" class="pb-3"&gt;
    ...
    @RenderBody()
    ...
&lt;/main&gt;
...
</code></pre>
<p class="normal"><code class="inlineCode">ViewData</code> of each <code class="inlineCode">View</code> is copied into <code class="inlineCode">ViewData</code> of its layout page, so <code class="inlineCode">ViewData</code> can be used to pass information to the view layout page. Typically, it is used to pass the view title to the layout page, which then uses it to compose the page’s title header, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">@*In the view *@
@{
    ViewData["Title"] = "Home Page"; 
}
@*In the layout view*@
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
    ...
    &lt;title&gt;@ViewData["Title"] - My web application&lt;/title&gt;
    ...
</code></pre>
<p class="normal">While the main content produced by each view is placed in a single area of its layout page, each layout page can also define several sections placed in different areas, where each view can place further<a id="_idIndexMarker1249"/> secondary content.</p>
<p class="normal">For instance, suppose a layout page defines a <code class="inlineCode">Scripts</code> section, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">...
&lt;script src="img/site.js" asp-append-version="true"&gt;&lt;/script&gt;
@RenderSection("Scripts", required: false)
...
</code></pre>
<p class="normal">Then, the view can use the previously defined section to pass some view-specific JavaScript references, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">.....
@section scripts{
    &lt;script src="img/pageSpecificJavaScript.min.js"&gt;&lt;/script&gt;
}
.....
</code></pre>
<p class="normal">If an action method is expected to return HTML to an AJAX call, it must produce an HTML fragment instead of a whole HTML page. Therefore, in this case, no layout page must be used. This is achieved by calling the <code class="inlineCode">PartialView</code> method instead of the <code class="inlineCode">View</code> method in the controller action method. <code class="inlineCode">PartialView</code> and <code class="inlineCode">View</code> have exactly the same overloads and parameters.</p>
<p class="normal">Another way to reuse view code is to factor out a view fragment that’s common to several views into another view that is called by all previous views. A view can call another view with the <code class="inlineCode">partial</code> tag, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;partial name="_viewname" for="ModelProperty.NestedProperty"/&gt;
</code></pre>
<p class="normal">The preceding code invokes <code class="inlineCode">_viewname</code> and passes it to the object contained in <code class="inlineCode">Model.ModelProperty.NestedProperty</code> as its <code class="inlineCode">ViewModel</code>. When a view is invoked by the <code class="inlineCode">partial</code> tag, no layout page is used, since the called view is expected to return an HTML fragment.</p>
<p class="normal">The <code class="inlineCode">ViewData.TemplateInfo.HtmlFieldPrefix</code> property of the called view is set to the <code class="inlineCode">ModelProperty.NestedProperty</code> string. This way, possible input fields rendered in <code class="inlineCode">_viewname.cshtml</code> will have the same name as if they had been rendered directly by the calling view.</p>
<p class="normal">Instead of specifying the ViewModel of <code class="inlineCode">_viewname</code> through a property of the caller view (ViewModel), you can also directly pass an object that is contained in a variable or returned by a C# expression by replacing <code class="inlineCode">for</code> with <code class="inlineCode">model</code>, as shown in this example:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;partial name="_viewname" model="new MyModel{...})" /&gt;
</code></pre>
<p class="normal">In this case, the <code class="inlineCode">ViewData.TemplateInfo.HtmlFieldPrefix</code> property of the called view keeps its default value, that is, the<a id="_idIndexMarker1250"/> empty string.</p>
<p class="normal">A view can also call something more complex than another view, that is, another controller method that, in turn, renders a view. Controllers that are designed to be invoked by views are called <strong class="keyWord">view components</strong>. The<a id="_idIndexMarker1251"/> following code is an example of component invocation:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;vc:[view-component-name] par1="par1 value" par2="parameter2 value"&gt; &lt;/vc:[view-component-name]&gt;
</code></pre>
<p class="normal">Parameter names must match the ones used in the view component method. However, both the component’s name and parameter names must be translated into kebab case; that is, all the characters must be transformed into lowercase if all the characters in the original name were in uppercase, although the first letter of the name must be preceded by a <code class="inlineCode">-</code>. For instance, <code class="inlineCode">MyParam</code> must be transformed into <code class="inlineCode">my-param</code>.</p>
<p class="normal">Actually, view components are either classes that derive from the <code class="inlineCode">ViewComponent</code> class, classes decorated with the <code class="inlineCode">[ViewComponent]</code> attribute, or classes whose names end with the <code class="inlineCode">ViewComponent</code> suffix. When a component is invoked, the framework looks for either an <code class="inlineCode">Invoke</code> method or an <code class="inlineCode">InvokeAsync</code> method and passes it all the parameters that were defined in the component’s invocation. <code class="inlineCode">InvokeAsync</code> must be used if the method is defined as <code class="inlineCode">async</code>; otherwise, we must use <code class="inlineCode">Invoke</code>.</p>
<p class="normal">The following code is an example of a view component definition:</p>
<pre class="programlisting code"><code class="hljs-code">public class MyTestViewComponent : ViewComponent
    {
       
        public async Task&lt;IViewComponentResult&gt; InvokeAsync(
 int par1, bool par2)
        {
            var model= ....
            return View("ViewName", model);
        }
       
    }
</code></pre>
<p class="normal">The previously defined component must be invoked with a call such as the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;vc:my-test par1="10" par2="true"&gt;&lt;/vc:y-test&gt;
</code></pre>
<p class="normal">If the component is invoked by <a id="_idIndexMarker1252"/>a view of a controller called <code class="inlineCode">MyController</code>, <code class="inlineCode">ViewName</code> is searched for in the following paths:</p>
<ul>
<li class="bulletList"><code class="inlineCode">/Views/MyController/Components/MyTest/ViewName</code></li>
<li class="bulletList"><code class="inlineCode">/Views/Shared/Components/MyTest/ViewName</code></li>
</ul>
<h1 class="heading-1" id="_idParaDest-355">Understanding the connection between ASP.NET Core MVC and design principles</h1>
<p class="normal">The whole ASP.NET Core framework is built on top of the design principles and patterns that we analyzed in <em class="chapterRef">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, <em class="chapterRef">Chapter 13</em>, <em class="italic">Interacting with </em><em class="italic"><a id="_idIndexMarker1253"/></em><em class="italic">Data in C# – Entity Framework Core</em>, <em class="chapterRef">Chapter 6</em>, <em class="italic">Design Patterns and .NET 8 Implementation</em>, <em class="chapterRef">Chapter 7</em>, <em class="italic">Understanding the Different Domains in Software Solutions</em>, and <em class="chapterRef">Chapter 5</em>, <em class="italic">Implementing </em><em class="italic"><a id="_idIndexMarker1254"/></em><em class="italic">Code Reusability in C# 12</em>.</p>
<p class="normal">Moreover, all framework functionalities are provided through DI so that each of them can be replaced by a customized counterpart, without it affecting the remainder of the code. Moreover, these providers are not added individually to the DI engine; instead, they are grouped into collection properties of option objects (see the <em class="italic">Loading configuration data and using it with the options framework</em> subsection) for improved maintainability, and to conform to the Separation of Concerns principle, which is a generalization of the Single Responsibility principle. In fact, the order in which providers are added to their collection does matter, since they are processed in the same order as they are in the collection. Moreover, the effect of a provider also depends on the other providers that belong to the same collection, so sometimes, it is not enough to replace a provider or add a new provider, but it is necessary to also remove/replace other providers to remove their side effects.</p>
<p class="normal">Examples of providers grouped in collections include all model binders, validation providers, and data annotation providers.</p>
<p class="normal">Moreover, configuration data, instead of being available from a unique dictionary created from a configuration file, is organized into option objects thanks to the options framework we described in the first section of this chapter. This is also an application of the SOLID Interface Segregation principle.</p>
<p class="normal">However, ASP.NET Core also applies other patterns that are specific instances of the general Separation of Concerns principle, which (as mentioned earlier) is a generalization of the Single <a id="_idIndexMarker1255"/>Responsibility principle. They are as follows:</p>
<ul>
<li class="bulletList">The middleware modules <a id="_idIndexMarker1256"/>architecture (the ASP.NET Core pipeline)</li>
<li class="bulletList">Factoring out validation and globalization from the application code</li>
<li class="bulletList">The MVC pattern itself</li>
</ul>
<p class="normal">We will analyze each of these in the various subsections that follow.</p>
<h2 class="heading-2" id="_idParaDest-356">Advantages of the ASP.NET Core pipeline</h2>
<p class="normal">The ASP.NET Core pipeline architecture has two<a id="_idIndexMarker1257"/> important advantages:</p>
<ul>
<li class="bulletList">All the different operations that are<a id="_idIndexMarker1258"/> performed on the initial request are factored out into different modules, according to the Single Responsibility principle.</li>
<li class="bulletList">The modules that perform these different operations don’t need to call each other because each module is invoked once and for all by the ASP.NET Core framework. This way, the code for each module is not required to perform any action that is connected to responsibilities that have been assigned to other modules.</li>
</ul>
<p class="normal">This ensures maximum independence of functionalities and simpler code. For instance, once the authorization and authentication modules are active, no other module needs to worry about authorization anymore. Each piece controller code can focus on application-specific business stuff.</p>
<h2 class="heading-2" id="_idParaDest-357">Server-side and client-side validation</h2>
<p class="normal">Validation logic has been completely factored out from the application code and has been confined to the definition<a id="_idIndexMarker1259"/> of validation attributes. The developer just needs to specify the validation rule to apply to each <a id="_idIndexMarker1260"/>model property, by decorating the property with an adequate validation attribute.</p>
<p class="normal">Validation rules are checked automatically when action method parameters are instantiated. Both errors and paths in the model (where they occurred) are then recorded in a dictionary that is contained in the <code class="inlineCode">ModelState</code> controller property. The developer has the responsibility for verifying whether there are errors by checking <code class="inlineCode">ModelState.IsValid</code>, in which case the developer must return the same ViewModel to the same view so that the user can correct any errors.</p>
<p class="normal">Error messages are automatically shown in the view, with no action required from the developer. The developer is only required to do the following:</p>
<ul>
<li class="bulletList">Add <code class="inlineCode">span</code> or <code class="inlineCode">div</code> with an <code class="inlineCode">asp-validation-for</code> attribute next to each input field, which will be automatically filled with the possible error.</li>
<li class="bulletList">Add <code class="inlineCode">div</code> with an <code class="inlineCode">asp-validation-summary</code> attribute that will be automatically filled with the validation error summary. See the <em class="italic">Using Razor tag helpers</em> section for more details.</li>
</ul>
<p class="normal">It is sufficient to add some JavaScript references by invoking the <code class="inlineCode">_ValidationScriptsPartial.cshtml</code> view with the <code class="inlineCode">partial</code> tag, enabling the same validation rules on the client side so that errors are shown to the user before the form is posted to the server. Some predefined validation attributes are contained in the <code class="inlineCode">S stem.ComponentModel.DataAnnotations</code> and <code class="inlineCode">Microsoft.AspNetCore.Mvc</code> namespaces and include the following attributes:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">Required</code> attribute requires the user to specify a value for the property that it decorates. An implicit <code class="inlineCode">Required</code> attribute is automatically applied to all non-nullable properties, such as all floats, integers, and decimals, since they can’t have a <code class="inlineCode">null</code> value.</li>
<li class="bulletList">The <code class="inlineCode">Range</code> attribute constrains numeric quantities within a range.</li>
<li class="bulletList">They also include attributes that constrain string lengths.</li>
</ul>
<p class="normal">Custom error messages can be inserted directly into the attributes, or attributes can refer to the property of the resource types containing them.</p>
<p class="normal">The developer can define their custom attributes by providing the validation code, both in C# and in JavaScript for client-side validation. The definition of custom validation attributes is discussed in this article: <a href="https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/">https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/</a>.</p>
<p class="normal">Attribute-based validation <a id="_idIndexMarker1261"/>can be replaced by <a id="_idIndexMarker1262"/>other validation providers, such as the <strong class="keyWord">FluentValidation</strong> library that defines validation rules for each type using a fluent interface. It is enough to change a provider in<a id="_idIndexMarker1263"/> a collection contained in the MVC options object. This can be configured through an action passed to the <code class="inlineCode">builder.Services.AddControllersWithViews</code> method.</p>
<p class="normal">MVC options can be configured as follows:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddControllersWithViews(o =&gt; {
    ...
    // code that modifies o properties
});
</code></pre>
<p class="normal">The validation framework automatically checks whether numeric and date inputs are well formatted according to the selected culture.</p>
<h2 class="heading-2" id="_idParaDest-358">ASP.NET Core globalization</h2>
<p class="normal">In multicultural applications, pages must be served according to the language and cultural preferences of each user. Typically, multicultural <a id="_idIndexMarker1264"/>applications can serve their content in a few languages, and they can handle dates and numeric formats in several more languages. In fact, while the content in all supported languages must be produced manually, .NET has the native capability of formatting and parsing dates and numbers in all cultures.</p>
<p class="normal">For instance, a web application might not support unique content for all English-based cultures (en), but it might support all known English-based cultures regarding number and date formats (en-US, en-GB, en-CA, and so on).</p>
<p class="normal">The culture used for numbers and dates in a .NET thread is contained in the <code class="inlineCode">Thread.CurrentThread.CurrentCulture</code> property. Hence, by setting this property to <code class="inlineCode">new CultureInfo("en-CA")</code>, numbers and dates will be formatted/parsed according to the Canadian format. <code class="inlineCode">Thread.CurrentThread.CurrentUICulture</code>, instead, decides on the culture of the resource files; that is, it selects a culture-specific version of each resource file or view. Accordingly, a multicultural application is required to set the two cultures associated with the request thread and organize multilingual content into language-dependent resource files and/or views.</p>
<p class="normal">According to the Separation of Concerns principle, the whole logic used to set the request culture according to the user’s preferences is factored out into a specific module of the ASP.NET Core<a id="_idIndexMarker1265"/> pipeline. To configure this module, as a first step, we set the supported date/number cultures, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">var supportedCultures = new[]
{
   new CultureInfo("en-AU"),
   new CultureInfo("en-GB"),
   new CultureInfo("en"),
   new CultureInfo("es-MX"),
   new CultureInfo("es"),
   new CultureInfo("fr-CA"),
   new CultureInfo("fr"),
   new CultureInfo("it-CH"),
   new CultureInfo("it")
};
</code></pre>
<p class="normal">Then, we set the languages supported for the content. Usually, a version of the language that is not specific to any country is selected to keep the number of translations small enough, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">var supportedUICultures = new[]
{
    new CultureInfo("en"),
    new CultureInfo("es"),
    new CultureInfo("fr"),
    new CultureInfo("it")
};
</code></pre>
<p class="normal">Then, we add the culture middleware to the pipeline, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">app.UseRequestLocalization(new RequestLocalizationOptions
{
     DefaultRequestCulture = new RequestCulture("en", "en"),
     // Formatting numbers, dates, etc.
     SupportedCultures = supportedCultures,
     // UI strings that we have localized.
     SupportedUICultures = supportedUICultures,
     FallBackToParentCultures = true,
     FallBackToParentUICultures = true
});
</code></pre>
<p class="normal">If the culture requested by the <a id="_idIndexMarker1266"/>user is explicitly found among the ones listed in <code class="inlineCode">supportedCultures</code> or <code class="inlineCode">supportedUICultures</code>, it is used without modifications. Otherwise, since <code class="inlineCode">FallBackToParentCultures</code> and <code class="inlineCode">FallBackToParentUICultures</code> are <code class="inlineCode">true</code>, the parent culture is tried; that is, for instance, if the required <code class="inlineCode">fr-FR</code> culture is not found among those listed, then the framework searches for its generic version, <code class="inlineCode">fr</code>. If this attempt also fails, the framework uses the cultures specified in <code class="inlineCode">DefaultRequestCulture</code>.</p>
<p class="normal">By default, the <code class="inlineCode">culture</code> middleware searches the culture selected for the current user, with three providers that are tried in the order shown here:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">The middleware looks for the <code class="inlineCode">culture</code> and <code class="inlineCode">ui-culture</code> query string parameters.</li>
<li class="numberedList">If the previous step fails, the middleware looks for a cookie named <code class="inlineCode">.AspNetCore.Culture</code>, the value of which is expected to be as in this example: <code class="inlineCode">c=en-US|uic=en</code>.</li>
<li class="numberedList">If both previous steps fail, the middleware looks for the <code class="inlineCode">Accept-Language</code> request header sent by the browser, which can be changed in the browser settings, and which is initially set to the operating system culture.</li>
</ol>
<p class="normal">With the preceding strategy, the first time a user requests an application page, the browser culture is taken (the provider listed in <em class="italic">step 3</em>). Then, if the user clicks a language-change link with the right query string parameters, a new culture is selected by provider 1. Usually, once a language link has been clicked, the server also generates a language cookie to remember the user’s choice through provider 2.</p>
<p class="normal">The simplest way to provide content localization is to provide a different view for each language. Hence, if we would like to localize the <code class="inlineCode">Home.cshtml</code> view for different languages, we must provide views named <code class="inlineCode">Home.en.cshtml</code>, <code class="inlineCode">Home.es.cshtml</code>, and so on. If no view specific to the <code class="inlineCode">ui-culture</code> thread is found, the non-localized <code class="inlineCode">Home.cshtml</code> version of the view is chosen.</p>
<p class="normal">View localization must be enabled by calling the <code class="inlineCode">AddViewLocalization</code> method, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddControllersWithViews()
    .AddViewLocalization(LanguageViewLocationExpanderFormat.Suffix)
</code></pre>
<p class="normal">Another option is to store simple strings or HTML fragments in resource files specific to all supported languages. The usage of resource files must be enabled by calling the <code class="inlineCode">AddLocalization</code> method in<a id="_idIndexMarker1267"/> the configure services section, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddLocalization(options =&gt;
    options.ResourcesPath = "Resources");
</code></pre>
<p class="normal"><code class="inlineCode">ResourcesPath</code> is the root folder where all resource files will be placed. If it is not specified, an empty string is assumed, and the resource files will be placed in the web application root. Resource files for a specific view (say, the <code class="inlineCode">/Views/Home/Index.cshtml</code> view) must have a path like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ResourcesPath &gt;/Views/Home/Index.&lt;culture name&gt;.resx
</code></pre>
<p class="normal">Hence, if <code class="inlineCode">ResourcesPath</code> is empty, resources must have the <code class="inlineCode">/Views/Home/Index.&lt;culture name&gt;.resx</code> path; that is, they must be placed in the same folder as the view.</p>
<p class="normal">Once the key-value pairs for all the resource files associated with a view have been added, localized HTML fragments can be added to the view, as follows:</p>
<ul>
<li class="bulletList">Inject <code class="inlineCode">IViewLocalizer</code> into the view with <code class="inlineCode">@inject IViewLocalizer Localizer</code></li>
<li class="bulletList">Where needed, replace the text in the <code class="inlineCode">View</code> with access to the <code class="inlineCode">Localizer</code> dictionary, such as <code class="inlineCode">Localizer</code>[“<code class="inlineCode">myKey</code>”], where “<code class="inlineCode">myKey</code>” is a key used in the resource files.</li>
</ul>
<p class="normal">The following code shows an example of the <code class="inlineCode">IViewLocalizer</code> dictionary:</p>
<pre class="programlisting code"><code class="hljs-code">@{
    ViewData["Title"] = Localizer["HomePageTitle"];
}
&lt;h2&gt;@ViewData["MyTitle"]&lt;/h2&gt;
</code></pre>
<p class="normal">If localization fails because the key is not found in the resource file, the key itself is returned. Strings used in data annotation, such as validation attributes, are used as keys in resource files if data annotation localization is enabled, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddControllersWithViews()
    .AddViewLocalization(LanguageViewLocationExpanderFormat.Suffix)
    .AddDataAnnotationsLocalization();
</code></pre>
<p class="normal">Resource files for data annotations applied to a class whose full name is, say, <code class="inlineCode">MyWebApplication.ViewModels.Account.RegisterViewModel</code> must have the following path:</p>
<pre class="programlisting code"><code class="hljs-code">{ResourcesPath}/ViewModels/Account/RegisterViewModel.{culture name}.resx
</code></pre>
<p class="normal">It is worth pointing out that the first segment of the namespace that corresponds to the <code class="inlineCode">.dll</code> application name is replaced with <code class="inlineCode">ResourcesPath</code>. If <code class="inlineCode">ResourcesPath</code> is empty and you use the default namespaces created by Visual Studio, then the resource files must be placed in the same folder that contains the classes they are associated with.</p>
<p class="normal">It is possible to localize strings and HTML fragments in controllers, or wherever dependencies can be injected, by <a id="_idIndexMarker1268"/>associating each group of resource files with a type, such as <code class="inlineCode">MyType</code>, and then injecting either <code class="inlineCode">IHtmlLocalizer&lt;MyType&gt;</code> for HTML fragments or <code class="inlineCode">IStringLocalizer&lt;MyType&gt;</code> for strings that need to be HTML-encoded.</p>
<p class="normal">Their usage is identical to the usage of <code class="inlineCode">IViewLocalizer</code>. The path of the resource files associated with <code class="inlineCode">MyType</code> is computed, as in the case of data annotations. If you would like to use a unique group of resource files for the whole application, a common choice is to use the <code class="inlineCode">Startup</code> class as the reference type (<code class="inlineCode">IStringLocalizer&lt;Startup&gt;</code> and <code class="inlineCode">IHtmlLocalizer&lt;Startup&gt;</code>). Another common choice is to create various empty classes to use as reference types for various groups of resource files.</p>
<p class="normal">Now that we’ve learned how to manage globalization in our ASP.NET Core projects, in the next subsection, we will describe the more important pattern used by ASP.NET Core MVC to enforce a <em class="italic">separation of concerns</em>: the MVC pattern itself.</p>
<h2 class="heading-2" id="_idParaDest-359">The MVC pattern</h2>
<p class="normal">MVC is a pattern used to implement the<a id="_idIndexMarker1269"/> presentation layers <a id="_idIndexMarker1270"/>of a web application. The basic idea is to apply a <em class="italic">Separation of Concerns</em> between the logic of the presentation layer and its graphics. Logic is taken care of by controllers, while graphics are factored out into views. Controllers and views communicate through the model, which is often called the ViewModel to distinguish it from the models of the business and data layers. </p>
<p class="normal">It is worth pointing out that the original definition of the MVC pattern proposes directly the use of domain models instead of ViewModels, but then, most of the MVC web frameworks started using the concept of ViewModel because specifying the information to render in a view requires just a projection of the original domain model (just some model data possibly organized in a different way) and often additional data, such as, for instance, the items per page of a pager, and the items required by the type input selected.</p>
<p class="normal">However, what is the logic of a presentation layer? In <em class="italic">Chapter 1</em>, <em class="italic">Understanding the Importance of Software Architecture</em>, we saw that software requirements can be documented with use cases that describe the interaction between the user and the system.</p>
<p class="normal">Roughly speaking, the logic <a id="_idIndexMarker1271"/>of the presentation layer consists of the management of use cases; hence, roughly, use cases are mapped to controllers, and every single operation of a use case is mapped to an action method of those controllers. Hence, controllers take care of managing the protocol of interaction with the user and rely on the business layer for any business processing involved during each operation.</p>
<p class="normal">Each action method receives data from the user, performs some business processing, and, depending on the results of this processing, decides what to show to the user and encodes it in the ViewModel. Views receive ViewModels that describe what to show to the user and decide the graphics to use, that is, the HTML to use.</p>
<p class="normal">What are the advantages of separating the logic and user interface into two different components? The main advantages are listed here:</p>
<ul>
<li class="bulletList">Changes in graphics do not affect the remainder of the code, so you can experiment with various user interface elements to optimize the interaction with the user, without putting the reliability of the remainder of the code at risk.</li>
<li class="bulletList">The application can be tested by instantiating controllers and passing the parameters, with no need to use testing tools that operate on the browser pages. In this way, tests are easier to implement. Moreover, they do not depend on the way graphics are implemented, so they do not need to be updated each time the graphics change.</li>
<li class="bulletList">It is easier to split the job between developers who implement controllers and graphic designers who implement views. Often, graphic designers have difficulties with Razor, so they might just furnish an example HTML page that developers transform into Razor views that operate on the actual data.</li>
</ul>
<p class="normal">For an example of how to put into<a id="_idIndexMarker1272"/> practice the general principles discussed above, please refer to the <em class="italic">A frontend microservice</em> section in <em class="italic">Chapter 21</em>, <em class="italic">Case Study</em>, but it is better to read <em class="italic">Chapter 18</em>, <em class="italic">Implementing Frontend Microservices with ASP.NET Core</em>, beforehand. There, we’ll look <a id="_idIndexMarker1273"/>at how to create a frontend microservice with ASP.NET Core MVC.</p>
<h1 class="heading-1" id="_idParaDest-360">Summary</h1>
<p class="normal">In this chapter, we analyzed the ASP.NET Core pipeline and various modules that comprise an ASP.NET Core MVC application in detail, such as authentication/authorization, the options framework, and routing. Then, we described how controllers and Views map requests to the response HTML. We also analyzed all the improvements introduced in the latest versions.</p>
<p class="normal">Finally, we analyzed all the design patterns implemented in the ASP.NET Core MVC framework and, in particular, the importance of the Separation of Concerns principle and how ASP.NET Core MVC implements it in the ASP.NET Core pipeline, as well as in its validation and globalization modules. We focused in more detail on the importance of a Separation of Concerns between the presentation layer logic and graphics, as well as how the MVC pattern ensures it.</p>
<p class="normal">You can find a full example of how to use ASP.NET Core MVC in the next chapter, which deals with frontend microservices and describes a complete frontend microservice, whose presentation layer uses ASP.NET Core MVC.</p>
<h1 class="heading-1" id="_idParaDest-361">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Can you list all the middleware modules scaffolded by Visual Studio in an ASP.NET Core project?</li>
<li class="numberedList">Does the ASP.NET Core pipeline module need to inherit from a base class or implement some interface?</li>
<li class="numberedList">Is it true that a tag must have just one tag helper defined for it, as, otherwise, an exception is thrown?</li>
<li class="numberedList">Do you remember how to test if validation errors have occurred in a controller?</li>
<li class="numberedList">What is the instruction in a layout view for including the output of the main view?</li>
<li class="numberedList">How are secondary sections of the main view invoked in a layout view?</li>
<li class="numberedList">How does a controller invoke a view?</li>
<li class="numberedList">By default, how many providers are installed in the globalization module?</li>
<li class="numberedList">Are ViewModels the only way for controllers to communicate with their invoked views?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-362">Further reading</h1>
<ul>
<li class="bulletList">More details on the ASP.NET Core and ASP.NET Core MVC framework are available in its official documentation at <a href="https://docs.microsoft.com/en-US/aspnet/core/">https://docs.microsoft.com/en-US/aspnet/core/</a>.</li>
<li class="bulletList">More details on the Razor syntax can be found at <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio">https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio</a>.</li>
<li class="bulletList">How to model bind collections and dictionaries is explained in this excellent Phil Haack post: <a href="http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx">http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx</a>.</li>
<li class="bulletList">Documentation on the creation of custom tag helpers that were not discussed in this chapter can be found at <a href="https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring">https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring</a>.</li>
<li class="bulletList">Documentation on the creation of custom controller attributes can be found at <a href="https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters">https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters</a>.</li>
<li class="bulletList">The definition of custom validation attributes is discussed in this article: <a href="https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/">https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/</a></li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code175081751210902046.png"/></p>
</div>
</body></html>