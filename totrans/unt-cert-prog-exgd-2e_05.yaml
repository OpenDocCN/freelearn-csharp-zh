- en: '*Chapter 5*: Creating a Shop Scene for Our Game'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will incorporate and extend the scriptable objects that
    heavily helped make our player and the enemy ships in the previous chapter. We
    will customize a new shop scene, where we will add new upgrades for the player's
    ship with the use of scriptable objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also look at the common uses of raycasts; if you aren''t familiar with
    them, they''re best described as an invisible laser that shoots from one point
    to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Identifying game objects with a raycast'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Identifying game objects with a raycast
  prefs: []
  type: TYPE_NORMAL
- en: When the ray hits a game object with a collider, it can retrieve information
    about the object, and then we can go a little further and manipulate the object
    we've hit. For example, we can cast a ray to a game object cube, and the ray will
    confirm to us that it's a cube. Because we have the cube's reference, we can change
    its color or scale, or position or destroy it – we can pretty much do whatever
    we want with it. Here, we will use this raycast system to shoot a point from the
    camera's position to the button in three-dimensional space when we click or touch
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our shop scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing our shop selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting game objects with raycasts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding information to our description panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will be comfortable with taking a piece of artwork
    and adding functionality to make it more useful. Scriptable objects are our friends,
    and we will make more use of them in this chapter – adding properties and values
    so that each option in our shop can hold sprites, prices, and a description. The
    shop buttons will be in 3D and selected with our invisible laser (the raycast
    system).
  prefs: []
  type: TYPE_NORMAL
- en: The core exam skills covered in this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We will cover programming core interactions*:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and configuring game object behavior and physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and configuring input and controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*We will also cover working in the art pipeline*:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding materials, textures, and shaders, and writing scripts that interact
    with Unity's rendering API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*This chapter also covers developing application systems*:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting scripts for application interface flow, such as menu systems, UI
    navigation, and application settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting scripts for user-controlled customization, such as character creators,
    inventories, storefronts, and in-app purchases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing scripts for user progression features, such as scoring, leveling,
    and in-game economies, utilizing technologies such as Unity Analytics and PlayerPrefs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing scripts for two-dimensional overlays, such as **Heads-Up Displays**
    (**HUDs**), minimaps, and advertisements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*We will also cover programming scene and environment design*:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying methods for implementing game object instantiation, destruction,
    and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Finally, we will cover working in a professional software development team*:'
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing techniques for structuring scripts for modularity, readability,
    and reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_05](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_05).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: All the content for this chapter is held in the chapter's `unitypackage` file,
    including a `Complete` folder, which holds all of the work we'll carry out in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3klZZ9q](https://bit.ly/3klZZ9q).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our shop scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will make some new scriptable objects, as we did when we
    created our player's ship settings (health, speed, firepower, and so on). You
    can refer to the *Introducing our scriptable object* (`SOActorModel`) section
    of [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*, Adding and Manipulating
    Objects*, for a reminder of how this is done. Instead of changing our enemy's
    or player's ships, we will be manipulating the shop's selection of powerups (with
    a selection grid) to add our own ship upgrades that the player will be able to
    choose from. These upgrades will then be transferred to the player's ship, which
    will be visually recognized, and two of the three upgrades will carry out alterations
    to the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go into further detail, let's refresh our memory on where the shop
    scripts are within the game framework that we introduced in *Chapter 1, Setting
    Up and Structuring Our Project*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the location of the shop scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Killer Wave''s UML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Killer Wave's UML
  prefs: []
  type: TYPE_NORMAL
- en: 'Our three shop scripts (`PlayerShipBuild`, `ShopPiece`, and `SOShopSelection`)
    connect to each other from where the `PlayerShipBuild` connects to the main, center
    `GameManager` script. In short, each script''s responsibility in the shop scene
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerShipBuild` is the overall function of the shop, including adverts and
    in-game credit control. This script can be broken down into more scripts, but
    for the sake of trying to keep our framework to a minimum, it is OK for a demo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ShopPiece` handles the content of the player''s ship upgrade selections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOShopSelection` is a scriptable object that holds the data types that will
    be used in each selection grid in our shop scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the scene that we will be creating and start applying
    shop scripts to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Scene` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `shop` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the `ShopManager` prefab from the `Assets/Prefab`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `0`, `0`, and `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want a different-colored background, with **Camera** still selected in
    the **Hierarchy** window, change the **Clear Flags** property from **Skybox**
    to **Solid Color**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure the camera remains in the same screen ratio we set in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048), *Adding
    and Manipulating Objects* (that is, 1920 x 1080). Use the following screenshot
    for reference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following scene is broken into four sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Our shop layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Our shop layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the previous screenshot, let''s go through each of the numbered
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with `testLevel` scene (the scene we have been working on in the previous
    four chapters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the top left (**2**), we have a visual representation of the player's ship.
    We can see what it looks like on our player's ship if they buy an upgrade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the player's ship (**3**) is a small rectangle that will display the in-game
    credit balance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the top right (**4**), a larger rectangle will hold information about our
    selected upgrade. It will also contain a button that, if the player has enough
    credits and/or hasn't purchased the item already, will give them the option to
    buy an upgrade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can make a start with the selection grid (the shop's row of buttons). To
    save time, I have provided some template art for this scene because we will be
    replacing it in the next chapter when we create our own UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a start with the first button in our shop''s selection grid, we need
    to go to the **Hierarchy** window in the Unity Editor and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top-right corner of the `upgrade`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Looking for game objects containing the word "upgrade" in the
    Hierarchy window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Looking for game objects containing the word "upgrade" in the Hierarchy
    window
  prefs: []
  type: TYPE_NORMAL
- en: Now, select the top game object titled `UPGRADE_00`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the content of the **Scene** window is grayed out, apart from the
    selected game object in the **Hierarchy** window in the Unity Editor. This is
    to help us locate the game object we are searching for.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the round **x** symbol to the right of the search bar. This will bring
    our **Hierarchy** content back and expand the parent game objects for us, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The children of UPGRADE_00'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – The children of UPGRADE_00
  prefs: []
  type: TYPE_NORMAL
- en: 'Hold down *Ctrl* (or *command* on macOS) on your keyboard and select the three
    game objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sprite`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`itemText`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionQuad`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With these three objects selected, select the top-left tick box in the **Inspector**
    window to make these objects active. The location of the box is shown in the following
    screenshot:![Figure 5.6 – Show and hide the game objects with the tick box
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.06_B18381.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.6 – Show and hide the game objects with the tick box
  prefs: []
  type: TYPE_NORMAL
- en: 'Our grid should now show its first selection, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Our first shop button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Our first shop button
  prefs: []
  type: TYPE_NORMAL
- en: Our shop has started to take form. With the first selection set up, we can now
    go further by customizing these selections with code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Importing and calibrating our sprite game object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game object that I have labeled `sprite` will receive and display a ship
    upgrade image that will be displayed in the selection grid. To understand how
    this sprite can be displayed correctly, we can view its properties when its game
    object is selected in the **Hierarchy** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sprite` game object has a **Sprite Renderer** component attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The Sprite Renderer component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – The Sprite Renderer component
  prefs: []
  type: TYPE_NORMAL
- en: I have grayed out the `sprite` game object property is what object type we are
    going to be supplying the `powerup` property, which gives us a fire-like icon
    in the **Scene** window.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check the `powerup` property so that we are certain of its data type and
    how it's recognized in the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the sprite''s data type, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `sprite` game object still selected in our `powerup` property in the
    **Inspector** window of the **Sprite Renderer** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `powerup` sprite location will appear in the `powerup` sprite location
    pinging when selected from the **Sprite Renderer** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The location of our ''powerup'' sprite in the Project window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.09_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – The location of our 'powerup' sprite in the Project window
  prefs: []
  type: TYPE_NORMAL
- en: Next, click on the parent of the `powerup` property in the `powerup` sprite's
    import settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The majority of the information doesn't require altering, but the main point
    of focus is making sure that the **Texture Type** setting is recognized as **Sprite**
    to make the file compatible with the **Sprite Renderer** component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our `powerup` file recognized as a sprite, with
    an image preview at the bottom of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Our ''powerup'' file will be set as a Sprite in the Texture
    Type field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Our 'powerup' file will be set as a Sprite in the Texture Type
    field
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that when a sprite, such as a `powerup` texture in the previous
    screenshot, is imported into Unity, it may not be recognized as a sprite and will
    be given the `Default` type. This is because `Default` is the most common selection
    for textures, especially with three-dimensional models. `Default` also offers
    more options with regard to texture properties.
  prefs: []
  type: TYPE_NORMAL
- en: Further Information
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know more about texture types, check out [https://docs.unity3d.com/Manual/TextureTypes.html](https://docs.unity3d.com/Manual/TextureTypes.html).
  prefs: []
  type: TYPE_NORMAL
- en: With regard to our `powerup` texture, we do not need to change it to `Default`.
    When we add another selection, the same principles of checking the image type
    should be carried out. Let's now move on to the second game object of the `UPGRADE_00`
    game object – `itemText`.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying credit on our itemText game object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second child game object from `UPGRADE_00` is `itemText`. This game object
    has a `SOLD` in the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the connection between the **Text Mesh** component
    and the text in the **Scene** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Text Mesh text set to ''0000'''
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – Text Mesh text set to '0000'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the final child game object of the `UPGRADE_00` hierarchy,
    which is `SelectionQuad`.
  prefs: []
  type: TYPE_NORMAL
- en: Project file diagnosis when making SelectionQuad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, I am going to briefly explain how the shop's selection grid
    is prepared.
  prefs: []
  type: TYPE_NORMAL
- en: '`SelectionQuad` is the third child game object of the `UPGRADE_00` game object,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The SelectionQuad game object in the Hierarchy window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – The SelectionQuad game object in the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: 'This game object simply serves to show the player that they have made a selection.
    It consists of a quad mesh, which is a standard primitive that can be made in
    Unity (by right-clicking in the **Hierarchy** window and selecting **3D Object
    | Quad**). We are now going to change its appearance to make it look more interesting
    by manipulating its material values; follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the `Quad` object is moved into position, change its **Material** properties
    from an **Opaque** rendering mode to **Transparent** (**1**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click on the `64`, `152`, `255`, and `140`. The following screenshot
    shows the color property changes made to the `SelectionQuad` material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Rendering Mode set to Transparent and the RGBA values modified
    to a light blue color'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Rendering Mode set to Transparent and the RGBA values modified
    to a light blue color
  prefs: []
  type: TYPE_NORMAL
- en: That is the entirety of our `UPGRADE_00` selection. Then, copy and paste each
    game object onto two more black rectangles and rename them `UPGRADE_01` and `UPGRADE_02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the three game objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Duplicating the game objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – Duplicating the game objects
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this chapter, we are going to be using these three game
    objects to manipulate and carry information from one scene to another. Before
    we start making scripts for these selections, I want to show you some text that
    will be added to the two slightly larger buttons at the far right of the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down in the `WATCH AD` and `START`. These two game objects will hold
    the following responsibilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WATCH AD` is used when the player selects this button; an advert will play.
    Once the advert is finished, the player is rewarded with credits. These credits
    can be used to buy more upgrades.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`START` is used when the player is finished with the shop. They can move on
    by pressing the **START** button.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand `WATCH AD` and `START` by clicking on each arrow to the left of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on each game object and make them active in the **Inspector** window,
    as we did earlier in the *Introducing our shop scripts* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In each expanded game object, we have a label game object; this holds a **Text
    Mesh** component, which we have been introduced to already in this section, that
    displays our button text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the expanded `WATCH AD` and `START` objects
    in the **Hierarchy** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The WATCH AD and START button locations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.15_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – The WATCH AD and START button locations
  prefs: []
  type: TYPE_NORMAL
- en: So far, we understand that we have a shop scene that will contain scriptable
    objects for our ship's upgrades; we are also aware of how the option to watch
    adverts to gain credits is a popular mechanism with free-to-play games.
  prefs: []
  type: TYPE_NORMAL
- en: That is all that we need for the selection grid. We can now start considering
    how to turn the buttons on and off, change each upgrade art, and more in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing our shop selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to use scriptable objects to customize each selection.
    We have already used scriptable objects in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects*. This time, we will use a similar method but
    for our selection grid; hopefully, this will make you appreciate how scriptable
    objects can be expanded and used across the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048), *Adding
    and Manipulating Objects*, I make a habit of initialing scriptable objects with
    an `SO` prefix so that they''re easy to identify. Let''s create an `SOShopSelection`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Unity Editor, go to the `Assets/Script`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a script (using the same method from [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*,*
    *Adding and Manipulating Objects*) and name it `SOShopSelection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This `SOShopSelection` script will create a template of data types for our asset
    files (the same as with our player and enemy ships). These asset files will be
    attached to each of the player ship upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: 'An individual selection from the grid will take four property types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`icon`: A picture of the selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iconName`: Identifies what the selection is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: Used to describe what the upgrade is in the large selection
    box at the top right of the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cost`: Calculates how many credits it is worth so that it can be displayed
    in the credit values of the selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s open the `SOShopSelection` script and begin to code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the script, make sure that we have imported the following library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As with most scripts in Unity, we need the `UnityEngine` library so that we
    can use the `ScriptableObject` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it so that we can create assets from the scriptable object, we enter
    the following attribute above our class name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code to inherit `ScriptableObject` to the `SOShopSelection`
    script. This will give us the functionality for creating template asset files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code to hold the specific variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have made the script to hold our data for each potential selection in the
    grid. As mentioned, we have already made these types of scripts before – we are
    just using them here to customize buttons, rather than spaceships.
  prefs: []
  type: TYPE_NORMAL
- en: We can now customize our three `UPGRADE` game objects in the Unity Editor –
    let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating selection templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, we made a scriptable object that allowed us to create an
    asset file that holds custom parameters and values. These assets and their properties
    can be created by users who don't hold programming knowledge, which is ideal for
    designers and programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three selections to add to our selection grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Weapon upgrade**: Gives the player''s ship a stronger weapon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health upgrade**: Allows the player''s ship to get hit twice by an enemy
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atom bomb**: Wipes all the visible enemies out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s go back to the Unity Editor and make some asset templates for our
    selection grid:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/ScriptableObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click in an open space of the **Project** window, and from the dropdown
    that appears, select **Create** and then **Create Shop Piece**, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Creating a ''Shop Piece'''
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – Creating a 'Shop Piece'
  prefs: []
  type: TYPE_NORMAL
- en: Rename the new `Create Shop Piece` file `Shot_PowerUp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `Shot_PowerUp` still selected, navigate to the **Inspector** window, where
    we have the data types that we can enter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `Shot_PowerUp` properties that we are going
    to change next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – The Shot_PowerUp properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.17_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – The Shot_PowerUp properties
  prefs: []
  type: TYPE_NORMAL
- en: We will apply our `powerup` sprite icon to the **Icon** data type by clicking
    on the small circle to the right of its field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll down in the `powerup` sprite, and then double-click it, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Updating the shop buttons icon'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.18_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – Updating the shop buttons icon
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, enter the following property names and the values we are going to give
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`b. Shot`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blast Shot`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create another `ShopPiece` asset as we did before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This time, change the asset name from `Create Shop Piece` to `Health_Level1`
    and give it the details shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Health button properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.19_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – Health button properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now make the third asset file, using the exact same process as the last
    two assets, but this time name it `Bomb_Cluster` and give it the following details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Bomb Cluster button properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – Bomb Cluster button properties
  prefs: []
  type: TYPE_NORMAL
- en: We have made the scriptable objects and configured them for our ship's upgrades.
    Let's now make the second main script for the shop, `ShopPiece`. This script will
    hold each of the asset files we have just made and display their content around
    the shop's grid scene.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing our player ship's upgrade selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this script is to send information to each of the selection buttons
    in our shop scene. For each of the three `UPGRADE` game objects, we will create
    and attach a script that takes reference from the `SOShopSelection` scriptable
    object (the three asset files we made in the previous section) and assign them
    to each player ship's upgrade button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the `ShopPiece` script, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by navigating to `Assets/Script` from the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the script the same way as we did at the start of the *Customizing our
    shop selection* section and name the script `ShopPiece`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and begin to code, starting with the script that contains the
    `UnityEngine` library at the top of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we are using elements of Unity and attaching the `ShopPiece` script
    with the Unity Editor, this script will require the `UnityEngine` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check and enter the following code to declare the class name and inheritance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, our script should be automatically named, with `Monobehaviour` inherited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code to allow the `shopSelection` instance to be updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add a reference to the `SOShopSelection` script that we made in the last
    section. This reference is private (because it isn't labeled as `public`), but
    we expose it to the Unity Editor with a `[SerializeField]` function above it.
    This means that we can drag and drop each scriptable asset file to its field in
    the Unity Editor. If another script requires access to the private `shopSelection`
    variable, we can refer to the `ShopSelection` property that will receive and send
    its data (`get` and `set`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code to update the `shopSelection` sprite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When this script is active and runs for the first time, it runs its `Awake`
    function. Inside the function are two `if` statements; the first checks whether
    there is a `SpriteRenderer` component in any of its child game objects. If there
    is, then it grabs a reference from its `shopSelection` asset file and applies
    its icon sprite to display on the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code to update the cost value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The alternative `if` statement checks whether any of the child game objects
    of this class have a game object titled `itemText`.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a game object titled `itemText`, we update its `TextMesh` component's
    `text` value with the `shopSelection` cost value.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in the Unity Editor, we can attach the `ShopPiece` script, along with each
    asset script we made in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach each `ShopPiece` script to each `UPGRADE` game object file, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `UPGRADE_00` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either drag and drop the `ShopPiece` script from the `Assets /Script`) or click
    on **Add Component** in the **Inspector** window and type the script's name in
    the drop-down search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UPGRADE_00` will be our weapon powerup button, so for the `Assets /ScriptableObject`)
    or click on the small circle to the right of the `Shot_PowerUp`. Use the following
    screenshot as a reference to see how your **Inspector** window should look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Our ''Shop Piece'' script containing the ''Shop_PowerUp'' Scriptable
    Object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.21_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.21 – Our 'Shop Piece' script containing the 'Shop_PowerUp' Scriptable
    Object
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, repeat this process for `UPGRADE_01` by giving the game object the `ShopPiece`
    script with the `Health_Level1` asset in its `ShopPiece` component for `UPGRADE_01`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Our ''Shop Piece'' script containing the ''Health_Level1''
    Scriptable Object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.22_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.22 – Our 'Shop Piece' script containing the 'Health_Level1' Scriptable
    Object
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, complete the same procedure for `UPGRADE_02`, adding the `ShopPiece`
    script and applying `Bomb_Cluster` to the `ShopPiece` script with the `Bomb_Cluster`
    asset applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Our ''Shop Piece'' script containing the ''Bomb_Cluster'' Scriptable
    Object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.23_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.23 – Our 'Shop Piece' script containing the 'Bomb_Cluster' Scriptable
    Object
  prefs: []
  type: TYPE_NORMAL
- en: To test whether the three selection pieces work in the selection grid, save
    the scene so far and click the **Play** button in the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our selection grid should go from the top three buttons with the same image
    and same value (not in play mode) to each image and value being different (in
    play mode):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Our shop buttons updating their prices in Play Mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.24_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.24 – Our shop buttons updating their prices in Play Mode
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, our asset files have names and description data; we can use this
    for the large rectangle in the shop scene when it comes to supplying information
    about the item. Also, we need to update the player ship's visuals to show what
    a purchase looks like on the ship, as well as a few other things. In the next
    section, we are going to create a script that allows the player to press a button
    from the selection grid.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting game objects with raycasts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create the final shop script, `PlayerShipBuild`.
    This script holds properties such as selecting any button from the selection grid,
    running adverts, communicating with our existing game framework scripts, launching
    our game to play, and a few other things that we will cover.
  prefs: []
  type: TYPE_NORMAL
- en: One of the subjects you will likely come across in your Unity programmer exam
    and when developing games/applications in Unity is shooting invisible lasers,
    which are used for things such as shooting a gun, making a selection in three-dimensional
    space, and more. In this section, we are going to make a button on the selection
    grid light up blue when the player presses on it to let them know that it has
    been selected. We already have each of our buttons set up with blue rectangles
    that are permanently on. So, all that we need to do now is turn them all off when
    the scene becomes active and make any of the buttons turn on when a ray (invisible
    laser) comes into contact with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of how the player sees the selection
    screen (**SELECTION 2D**) and the same scene at an angle so that we can see the
    main camera''s clipping planes (**SELECTION 3D**). When the player presses a button
    on the selection grid, an invisible line (ray) will travel across it. If the line
    comes into contact with a game object that has a collider attached to it, we can
    get information from that game object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Shooting a ray from our camera position to select a button
    in the shop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.25_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.25 – Shooting a ray from our camera position to select a button in
    the shop
  prefs: []
  type: TYPE_NORMAL
- en: So, what we are going to do for this selection is start creating a `PlayerShipBuild`
    script and give it the functionality to shoot rays, which will then change the
    color of the button.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a script in the usual `Assets/Script`) and naming it
    `PlayerShipBuild`. You should know how to make a script now, as we did so in the
    previous *Customizing our player ship's upgrade selection* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a raycast selection, open the `PlayerShipBuild` script and follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, we require the UnityEngine library, as previously mentioned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code to declare our class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our script has a `public` access modifier and is named the same as the `PlayerShipBuild`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: This script inherits `MonoBehaviour`, so it is recognized when attached to a
    game object in the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code to hold each of the `shopButtons`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have a `private` variable that is exposed in the Editor with `[SerializeField]`
    (so we can see and edit it), which will hold an array of all 10 game object buttons
    on the selection grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code to hold two game objects for raycasting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `tmpSelection` variable is used to store the raycast selection so that we
    can check to see what we have made contact with. The target variable will be used
    later on in the script.
  prefs: []
  type: TYPE_NORMAL
- en: '`tmpSelection` will be used at the end of the selection process when it comes
    to turning the game object on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code within the `Start` function to run our method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unity's `Start` function will be the first thing called when this script becomes
    active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will enter the following code to create the `TurnOffSelectionHighlights`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within the `TurnOffSelectionHighlights` method, we run a `for` loop that makes
    sure all of the buttons have their blue rectangles turned off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into the `Update` function that is called at every
    frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `AttemptSelection` method is responsible for receiving the player's input
    for a button selection. The content of this method will be covered in detail when
    we come to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code to create our `ReturnClickedObject` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ReturnClickedObject` method also takes an argument of an `out` raycast
    hit, which will contain information of what collider the ray has made contact
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Within this method, we reset the `target` game object to remove any previous
    data. We then take reference from the camera to find where the player tapped or
    clicked their mouse on the screen and store the result in the form of a ray.
  prefs: []
  type: TYPE_NORMAL
- en: Further Information
  prefs: []
  type: TYPE_NORMAL
- en: More information about `ScreenPointToRay` can be found in Unity's scripting
    reference at [https://docs.unity3d.com/ScriptReference/Camera.ScreenPointToRay.html](https://docs.unity3d.com/ScriptReference/Camera.ScreenPointToRay.html).
  prefs: []
  type: TYPE_NORMAL
- en: We then check whether the origin and the direction of the camera from where
    we have shot the ray have made contact with a collider (within 100 world space
    meters).
  prefs: []
  type: TYPE_NORMAL
- en: If we have made contact with a collider, the `if` statement is acknowledged
    as `true`; we then take the reference of the game object it has hit and store
    it in the `target` game object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we send out (`return`) the `target` game object that the ray has come
    into contact with.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, we referred to an `AttemptSelection` method earlier in the `Update`
    function. The `AttemptSelection` method will check whether a condition is made
    when the player has made contact by tapping the screen or clicking a mouse button
    in our shop scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code to write out the `AttemptSelection` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the player has pressed the mouse button or tapped the touchscreen, we will
    fire the ray and send all `RaycastHit` objects into the `ReturnClickedObject`
    method that we mentioned in the previous section of code. The results from the
    `ReturnClickedObject` method are returned to the `target` game object that we
    made at the start of the script.
  prefs: []
  type: TYPE_NORMAL
- en: We then check whether this `target` game object exists. If it does exist, we
    then run another check to see whether this `target` game object is holding a game
    object named `itemText`. If it does have a game object with this name, we refresh
    the selection grid by turning all the blue quads off, followed by a method called
    `Select`, which is what we are going to talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: We have finally dug down into the last bit of our script where we find the name
    of the `SelectionQuad` game object and turn it on to give the player visual feedback
    of what selection they have made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following method into our code; this will make the player''s button
    selection active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Select` method doesn't need to check any conditions with `if` statements,
    as this has mostly been done for us with the previous code. We will carry out
    a search for `SelectionQuad` and store its reference as `tmpSelection`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the `tmpSelection` game object's activity to `true` so that
    it is seen in our `shop` **Scene** window.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and return to the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now attach our `PlayerShipBuild` script to our shop game object (using
    the same attaching method we used earlier in this chapter for `ShopPiece`), which
    is the parent to all of the buttons in the selection grid, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – Our ''shop'' containing the ''Player Ship Build'' script and
    the amount of ''Shop Buttons'' highlighted (0)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.26_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.26 – Our 'shop' containing the 'Player Ship Build' script and the amount
    of 'Shop Buttons' highlighted (0)
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you recall at the start of the `PlayerShipBuild` script, we added a
    game object variable that would take an array of `shopButtons`. We could have
    a `for` loop to add each `UPGRADE` game object automatically at the start of the
    script, but if, in the future, we wanted to consider using a joypad or keyboard
    to guide us through the selection grid, we would have more control over knowing
    which button is assigned to each array number. Also, this is just another way
    of programming without relying on code, as Unity is a component-based engine.
    Other controller inputs and interactions are something we are going to cover in
    [*Chapter 13*](B18381_13_Epub.xhtml#_idTextAnchor219), *Effects, Testing, Performance,
    and Alt Controls*, where we will start thinking about other platforms to port
    our game to.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the potential of updating our controls in a later lesson, here is how
    you should attach the game objects to the `shopButtons` array in the Unity Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: With the shop game object still selected in the **Hierarchy** window, it's probably
    best to lock the **Inspector** window at this point (as we did in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087),
    *Applying Art, Animation, and Particles*), as we are going to be selecting and
    dragging different game objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the shop button's size from `0` to `10` in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now get a burst of empty game object fields in the `SelectionQuad` game
    object to each field.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to make things even easier, click on the arrow to the left of each game
    object under the shop game object to expand each of the child game objects. This
    will uncover the `SelectionQuad` game objects that we need to drag across.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Inspector** window with a list of empty
    game objects and the **Hierarchy** window game objects expanded out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – Drag and drop each SelectionQuad game object from the Hierarchy
    window into the correct fields in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.27_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.27 – Drag and drop each SelectionQuad game object from the Hierarchy
    window into the correct fields in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: We have also added arrow stripes to the previous screenshot to show which `SelectionQuad`
    objects need to go into which game object field in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: Save the scene. If you locked your **Inspector** window, don't forget to unlock
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **Play** button in the Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when the scene starts, all the blue selection quads disappear, but if you
    click on any one, it will light up, depending on which button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the atom bomb button selected when the mouse
    clicks on it in the game window. This will also work with touchscreen devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – The Atom Bomb button selected'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.28_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.28 – The Atom Bomb button selected
  prefs: []
  type: TYPE_NORMAL
- en: That covers using raycasts, which is a transferable skill and can be used for
    anything that involves shooting to grab information from another game object,
    providing it has a collider attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to updating the description panel so that when a selection
    is made from the grid, we get the text on the large, dark rectangle with information
    we stored from the same scriptable objects that give information to each player
    upgrade button.
  prefs: []
  type: TYPE_NORMAL
- en: Adding information to our description panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a selection is made in the shop scene, we can take the information from
    the selection's scriptable object asset file and display its details within its
    `textBoxPanel` game object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `textBoxPanel` object in the **Hierarchy** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29 – Our ''textBoxPanel'' content in the Hierarchy window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.29_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.29 – Our 'textBoxPanel' content in the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: 'The `textBoxPanel` game object holds a black quad that is used for its background.
    It also holds four other game objects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This game object contains a `iconName` scriptable object variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`desc`: This game object also holds a `description` scriptable object variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backPanel`: This game object serves as a background for the selection grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUY?`: This game object will be covered later on when we want to confirm that
    we want to purchase the item we have selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot identifies the two scriptable object data types from
    the `Health_Level1` asset file that we made earlier in this chapter. The information
    on this large rectangle will change, depending on which button is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30 – A description of the button selected in the rectangle box'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.30_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.30 – A description of the button selected in the rectangle box
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now go back to the `PlayerShipBuild` script and add some more code to
    update the description panel (the `textBoxPanel` game object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen the `PlayerShipBuild` script and add the following variable to the top
    of the script with the other variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This game object variable will hold a reference to the `textBoxPanel` game object
    in our scene. Next, we need to grab and refer to this game object from our **Hierarchy**
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down to the `Start` function and enter the following line of code to
    store the `textBoxPanel` game object as a reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, scroll down to the content of `AttemptSelection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down until we get to the following `if` statement and add `UpdateDescriptionBox();`
    to the content of that statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UpdateDescriptionBox` method will grab the selected button's two assets.
    These asserts (`iconName` and `description)` are then applied to each `TextMesh`
    `text` component of `textboxPanel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now enter the content of this method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UpdateDescriptionBox` method will get the reference name and description
    from the shop button that's selected and will apply the string values to the shop's
    black noticeboard ( `textBoxPanel`).
  prefs: []
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the results by pressing **Play** in the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the first selection grid being selected with
    the description panel details displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31 – The description displayed for selecting the ''Blast Shot''
    weapon'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.31_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.31 – The description displayed for selecting the 'Blast Shot' weapon
  prefs: []
  type: TYPE_NORMAL
- en: With a small amount of code, the description panel lights up and displays information
    from any of the items that are selected. This is useful, as if we ever wanted
    to extend the selection grid with more items, we wouldn't need to bloat our code
    to compensate for each selection.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a shop scene that shows what is available to buy and descriptions
    of what each item is. Let's summarize what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started creating a shop scene that holds various buttons
    and panels created from three-dimensional polygons. We then created our own script
    to fill the scene with images, values, names, and descriptions of assets that
    can potentially be purchased with virtual credits.
  prefs: []
  type: TYPE_NORMAL
- en: We also made use of scriptable objects to create a template for our code so
    that it can be topped up with various in-game powerups without inflating our game's
    framework. We also made it interchangeable, so if a weapon needs changing, replacing,
    or removing, we can simply remove the template without affecting the rest of the
    code in our game framework.
  prefs: []
  type: TYPE_NORMAL
- en: The other lesson we learned in this chapter is being aware that we can create
    games that are free to download but also knowing how to create a form of income
    with a monetization game design to create revenue.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue with our shop scene and focus more on
    the content of each button and the overall functionality of our shop by adding
    content to our player's ship. We will also look at game advertisements as a form
    of currency for the player to upgrade their spaceship.
  prefs: []
  type: TYPE_NORMAL
