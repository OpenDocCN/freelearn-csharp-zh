<html><head></head><body>
        

                            
                    Using WCF Services
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating a WCF service</li>
<li>Self-hosting a WCF service</li>
<li>Hosting a WCF service in IIS Server</li>
<li>Integrating a WCF service in a WPF application</li>
</ul>
<h1 id="uuid-91edffc6-b59d-4c62-9f88-7dd2fe5c1ae4" class="">Introduction</h1>
<p>In the modern world, enterprise applications are the key to consumer-centric enterprises. Users access one or multiple devices to connect to the external world. And to succeed at this, the business needs shared services, which can be consumed by all such devices.</p>
<p>The <strong>service-oriented architecture</strong> (<strong>SOA</strong>) is a design principle that enterprises follow to outline well-defined services, using a common set of contracts. Each of these services can be individually modified independently of one another and consumed by the external world.</p>
<p><strong>Windows Communication Foundation</strong> (<strong>WCF</strong>) is a framework to build such service-oriented applications. Using WCF, you can send data/messages asynchronously from one endpoint to the other. You can host a service endpoint in IIS, or in an application directly. The messages passed via this service endpoint can be a single character or a word sent as XML, or a complex stream of binary data.</p>
<p>WCF has been widely accepted as a standard to create web services, which offers support to multiple protocols and endpoints. In WCF, there are three important things that you need to remember; these things are generally known as the <strong>ABC of WCF</strong>. The ABC of WCF endpoints defines the following elements:</p>
<ul>
<li><strong>A</strong> for <strong>Address</strong>, which specifies where the service resides. This generally follows the URL format as <kbd>schema://domain[:port]/path</kbd>, for example <kbd>http://www.kunal-chowdhury.com:8080/Services</kbd>, <kbd>https://www.kunal-chowdhury.com:8050/Services</kbd>, or <kbd>http://192.168.0.1/Services</kbd>.</li>
<li><strong>B</strong> stands for <strong>Binding</strong>, which is basically a group of elements that corresponds to the transport and protocol channels located in the channel stack, to define how the messages are handled in the service side and the client side.</li>
<li><strong>C</strong> stands for <strong>Contract</strong>, which is nothing but an agreement between the client and the server about the structure (data contract) and content (message contract) being passed through the channel.</li>
</ul>
<p>In this chapter, we will learn how to create WCF services, host them, and integrate them into a WPF application to give a service call to the defined endpoint. As this book is not about WCF, we will just be discussing basic concepts to get you started with it.</p>
<p>Please ensure that ASP.NET and WCF are correctly installed and registered. To confirm, open the <strong>Visual Studio 2017 Installer</strong>, and make sure that the ASP.NET and web development workload, as well as the Windows Communication Foundation components, are already installed.</p>
<p>If they're not there already, select them, and modify the installation:</p>
<div><img src="img/2b05231d-fff8-4ef4-b6ba-5d03a418548d.png"/></div>
<h1 id="uuid-ae1458ce-a3f9-4bec-8a1b-f12953c90a8d">Creating a WCF service</h1>
<p>A WCF service is a secure service to process business transactions, which supplies current data to others, exposing a workflow implemented using <strong>Windows Workflow Foundation</strong> as a WCF service. It provides a single programming model to leverage the features to create a unified solution to all distributed technologies. That means you can write the service once and expose different endpoints to exchange messages using any format (default is SOAP) over any transport protocol, that is, HTTP, TCP, MSMQ, Named Pipes, and so on.</p>
<div><strong>SOAP</strong> (<strong>Simple Object Access Protocol</strong>) is one of the preferred models, where communication between the server and the client happens by using XML-based data.</div>
<p>In this recipe, we will learn about <strong>data contract</strong>, <strong>data member</strong>, <strong>service contract</strong>, <strong>operation contract</strong>, you need to consider these when creating and connecting to WCF services. When a service reference is taken into an application project, the developer only needs to configure the service with a proper endpoint address. Let's start demonstrating it by creating a simple, basic WCF service.</p>
<h2 id="uuid-66eb8805-0246-4c43-a727-d9500b8835bd">Getting ready</h2>
<p>To get started, open Visual Studio IDE with administrative privileges. This is often useful while deploying the service in a server.</p>
<h2 id="uuid-679ec56f-f81a-4356-941e-0f4da37ce803">How to do it...</h2>
<p>Follow these steps to create a simple WCF service, which we will integrate into a WPF application later in this chapter:</p>
<ol>
<li>First, create a new project named <kbd>EmployeeService</kbd>. Use the WCF Service Application template while creating the project. You can find this under the WCF template category, as shown in the following screenshot:</li>
</ol>
<div><img src="img/136ba68d-a283-444a-a4ab-32be5ce99477.png"/></div>
<ol start="2">
<li>Visual Studio, by default, creates three service files (<kbd>IService1.cs</kbd>, <kbd>Service1.svc</kbd>, and <kbd>Service1.svc.cs</kbd>) inside the project. As we will create our own services from scratch, from Solution Explorer, let's delete all three of the files:
<div><img src="img/f172caeb-eb8b-4688-87ad-20e8af578300.png" style=""/></div>
</li>
<li>Let's create two folders inside the project node and name them <kbd>DataModels </kbd>and <kbd>Services</kbd>. This is optional, but it is a  good idea to keep the code files organized:</li>
</ol>
<div><img src="img/7241f331-65b7-452a-b314-3e194d4d0519.png" style=""/></div>
<ol start="4">
<li>Now, right-click on the DataModels folder, and follow the context menu entry Add | Class... to create a new class file named <kbd>Employee</kbd>.</li>
<li>Inside the class implementation of the <kbd>Employee.cs</kbd> file, add a few public properties of type <kbd>string</kbd>, and name them <kbd>ID</kbd>, <kbd>FirstName</kbd>, <kbd>LastName</kbd>, and <kbd>Designation</kbd>.</li>
<li>Set the attribute <kbd>[DataContract]</kbd> to the class level to specify that the type defines or implements a data contract and is serializable by a serializer, such as <kbd>System.Runtime.Serialization.DataContractSerializer</kbd>.</li>
<li>Set the attribute <kbd>[DataMember]</kbd> to the properties that you want to be part of the data contract, and mark it to serializable by the <kbd>System.Runtime.Serialization.DataContractSerializer</kbd>.</li>
<li>You need to resolve the namespace <kbd>System.Runtime.Serialization</kbd>, in order to use the <kbd>DataContract</kbd> and <kbd>DataMember</kbd> attributes:</li>
</ol>
<div><img src="img/23cf7efd-0aed-4694-bff8-49ec52de8ffe.png" style=""/></div>
<ol start="9">
<li>Here's the complete code:</li>
</ol>
<pre style="padding-left: 90px">using System.Runtime.Serialization; 
 
namespace EmployeeService.DataModels 
{ 
    [DataContract] 
    public class Employee 
    { 
        [DataMember] 
        public string ID { get; set; } 
 
        [DataMember] 
        public string FirstName { get; set; } 
 
        [DataMember] 
        public string LastName { get; set; } 
 
        [DataMember] 
        public string Designation { get; set; } 
    } 
} </pre>
<ol start="10">
<li>Now, right-click on the Services folder, and follow the context menu entry Add | New Item... to create a new service definition.</li>
<li>From the Add New Item dialog window, select the WCF Service as the template. Give it a name (in our case, it is <kbd>EmployeeService</kbd>), and click on the Add button, as shown in the following screenshot:</li>
</ol>
<div><img src="img/e3591510-bcd2-45f1-963b-a4a6e9a3c881.png"/></div>
<ol start="12">
<li>This will create three files under the <kbd>Services</kbd> folder: <kbd>IEmployeeService.cs</kbd>, <kbd>EmployeeService.svc</kbd>, and <kbd>EmployeeService.svc.cs</kbd>:
<div><img src="img/cb63d9d2-ad5c-49e3-a0c7-7250736b0274.png"/></div>
</li>
<li>From Solution Explorer, navigate to the <kbd>IEmployeeService.cs</kbd> file, and add the following <kbd>using</kbd> namespace declarations:</li>
</ol>
<pre style="padding-left: 90px">using EmployeeService.DataModels; 
using System.Collections.Generic; 
using System.ServiceModel; </pre>
<ol start="14">
<li>Now replace the class definition with the following code snippet, which will have three operation contracts <kbd>GetEmployeeByID</kbd>, <kbd>GetEmployees</kbd>, and <kbd>InsertEmployee</kbd>. Mark the interface as <kbd>[ServiceContract]</kbd> and the methods as <kbd>[OperationContract]</kbd>. Here's the code snippet for reference:</li>
</ol>
<pre style="padding-left: 90px">[ServiceContract] 
public interface IEmployeeService 
{ 
    [OperationContract] 
    Employee GetEmployeeByID(string empID); 
 
    [OperationContract] 
    List&lt;Employee&gt; GetEmployees(); 
 
    [OperationContract] 
    void InsertEmployee(Employee employee); 
} </pre>
<ol start="15">
<li>Now, from Solution Explorer, navigate to the <kbd>EmployeeService.svc.cs</kbd> file, and create a <kbd>static</kbd> member variable of type <kbd>List&lt;Employee&gt;</kbd>. Let's name it <kbd>m_employees</kbd>, which will be used as a static data source of our demo application:</li>
</ol>
<pre style="padding-left: 90px">private static List&lt;Employee&gt; m_employees = new List&lt;Employee&gt;(); </pre>
<ol start="16">
<li>Let's implement the interface <kbd>IEmployeeService</kbd>, as follows:</li>
</ol>
<div><img src="img/63c88383-011d-42fc-b5ca-aee91e3082bf.png"/></div>
<ol start="17">
<li>Modify the method definitions to perform the operations as per the name/functionality. Let's modify them, which will look like this:</li>
</ol>
<pre style="padding-left: 90px">public class EmployeeService : IEmployeeService 
{ 
    private static List&lt;Employee&gt; m_employees = new List&lt;Employee&gt;(); 
 
    public Employee GetEmployeeByID(string empID) 
    { 
        return m_employees.First(emp =&gt; emp.ID.Equals(empID)); 
    } 
 
    public List&lt;Employee&gt; GetEmployees() 
    { 
        return m_employees; 
    } 
 
    public void InsertEmployee(Employee employee) 
    { 
        m_employees.Add(employee); 
    } 
} </pre>
<ol start="18">
<li>That's it! Your WCF service named <kbd>EmployeeService</kbd> is now ready to host, so that applications can consume it. To check whether the service can run properly, build the project and then right-click on the <kbd>EmployeeService.svc</kbd> file, from Solution Explorer, and click on <kbd>View in Browser (Browser_Name)</kbd>, which is View in Browser (Firefox) in our case:</li>
</ol>
<div><img src="img/9813c78a-b358-41cb-807c-757633414345.png" style=""/></div>
<ol start="19">
<li>This will start the service and show you the message Service is hosted on the server.</li>
</ol>
<p>A point to note is that if you are running the service from Visual Studio, it will require administrative permission to open the specified port and host the service. In case you haven't provided the admin privileges yet, please restart Visual Studio using Run as administrator.</p>
<ol start="20">
<li>Once the service has been hosted on <kbd>localhost</kbd>, this will load the SVC file in a browser window, and it will look like the following screenshot, which tells us that the service is up and running without any issues:</li>
</ol>
<div><img src="img/a1179d76-7154-4cba-a153-c305e3ed60a3.png"/></div>
<ol start="21">
<li>Each service provides a <strong>Web Services Description Language</strong> (<strong>WSDL</strong>) that defines the public interfaces including the metadata, which is similar to <strong>interface definition language</strong> (<strong>IDA</strong>). Click on the link to generate the WSDL of the service. In case your browser does not show the generated WSDL on the screen, copy the link,  and run it inside the Internet Explorer, which will give you the following XML output:</li>
</ol>
<div><img src="img/2b261c14-bf04-4b98-800a-afe3915c0890.png"/></div>
<h2 id="uuid-1602a3fa-71b1-4dea-ae09-1172a0f2372a">How it works...</h2>
<p>In this simple WCF service, we have used few attributes. Let's learn more about each one of them.</p>
<h3 id="uuid-68ebe2a5-2a61-4ad5-96e8-b254544d32ce">The DataContract attribute</h3>
<p>A data contract is a formal agreement between a client and a service that abstractly describes the data to be exchanged. In WCF, this is the most common way to serialize an object and make it ready to be available for passing between client and service. This is done by marking the class with the <kbd>[DataContract]</kbd> attribute.</p>
<p>It is worth mentioning that the serialization is not restricted to exactly match the class name and/or the property names in the class. You can simply use the <kbd>DataContract</kbd> and <kbd>DataMember</kbd> attributes to define their names in serialization. For example, consider the following code snippet:<br/>
<kbd>[DataContract (Name = "Employee")]</kbd><br/>
<kbd>public class EmployeeModel { ... }</kbd><br/>
<br/>
In the preceding code snippet, though the class name is <kbd>EmployeeModel</kbd>, the class will be exposed to serialization as <kbd>Employee</kbd> as the name mapping has been done using the <kbd>Name</kbd> property of the attribute.</p>
<h3 id="uuid-5fd226bf-6a85-4888-83cd-9ce6d6daeb26">The DataMember attribute</h3>
<p>The <kbd>[DataMember]</kbd> attribute, on the other hand, specifies that the member is part of a data contract and is serializable by the <kbd>DataContractSerializer</kbd>. You can use the following properties while defining the data member attribute:</p>
<ul>
<li><kbd>Name</kbd>: It defines the name of the data member</li>
<li><kbd>Order</kbd>: It sets the order of serialization and deserialization of the member</li>
<li><kbd>TypeId</kbd>: It sets a unique identifier for this attribute in the derived class</li>
<li><kbd>IsRequired</kbd>: This property gets or sets a value that instructs the serialization that the member must be present during deserializing</li>
<li><kbd>EmitDefaultValue</kbd>: When defined, this property value is specified whether to serialize the default value of the data member</li>
</ul>
<p>You should apply the <kbd>[DataMember]</kbd> attribute in conjunction with the <kbd>[DataContract]</kbd> attribute to identify the members of a type that are part of the data contract.</p>
<h3 id="uuid-9b7e9bd5-4224-4f3d-97bf-219a166bc73d">The ServiceContract attribute</h3>
<p>The <kbd>[ServiceContract]</kbd> attribute is used to define an interface that provides the service. A service should have at least one service contract, decorated by the <kbd>[ServiceContract]</kbd> attribute. The following properties can be used with the <kbd>ServiceContractAttribute</kbd>:</p>
<ul>
<li><kbd>ConfigurationName</kbd>: It specifies the name of the service element in the configuration file.</li>
<li><kbd>Name</kbd>: This specifies the name of the contract in the WSDL element.</li>
<li><kbd>Namespace</kbd>: This specifies the namespace of the contract in the WSDL element.</li>
<li><kbd>SessionMode</kbd>: This specifies whether the contract requires a binding that supports sessions. It can have either of the following three values: <kbd>Allowed</kbd> (specifies that the contract supports the session), <kbd>NotAllowed</kbd> (specifies that the contract does not support the session), and <kbd>Required</kbd> (specifies that the contract does not require the session).</li>
<li><kbd>CallbackContract</kbd>: This property specifies the return contract in a duplex conversation.</li>
<li><kbd>ProtectionLevel</kbd>: This specifies the message-level security that an operation requires during runtime. It can be one of three types: <kbd>None</kbd> (only simple authentication), <kbd>Sign</kbd> (<kbd>Sign</kbd> data to help ensure data integrity), and <kbd>EncryptAndSign</kbd> (<kbd>Encrypt</kbd> and <kbd>Sign</kbd> data to ensure integrity and confidentiality of transmitted data).</li>
<li><kbd>HasProtectionLevel</kbd>: This indicates whether the <kbd>ProtectionLevel</kbd> property has been explicitly set.</li>
</ul>
<h3 id="uuid-5bee35b5-1fd4-4223-bb61-db56c4420fe8">The OperationContract attribute</h3>
<p>The <kbd>[OperationContract]</kbd> attribute is used to define the methods of the service contract. This is placed on the methods that you want to include as part of the service contract. The following properties can be used to control the structure of the operation:</p>
<ul>
<li><kbd>Action</kbd>: This property specifies the action that uniquely identifies the operation.</li>
<li><kbd>ReplyAction</kbd>: This specifies the action of the reply message of the operation.</li>
<li><kbd>AsyncPattern</kbd>: This indicates that the operation can be called asynchronously.</li>
<li><kbd>ProtectionLevel</kbd>: This specifies the message-level security that an operation requires during runtime. It can be one of three types—<kbd>None</kbd> (only simple authentication), <kbd>Sign</kbd> (sign data to help ensure data integrity), and <kbd>EncryptAndSign</kbd> (encrypt and sign data to ensure integrity and confidentiality of transmitted data).</li>
<li><kbd>HasProtectionLevel</kbd>: This indicates whether the <kbd>ProtectionLevel</kbd> property has been explicitly set.</li>
<li><kbd>IsOneWay</kbd>: This property indicates that the operation consists of a single input message and has no associated output message.</li>
<li><kbd>IsInitiating</kbd>: This specifies whether this operation can be the initial operation in a session.</li>
<li><kbd>IsTerminating</kbd>: This specifies whether WCF will attempt to terminate the current session after the operation completes.</li>
</ul>
<h1 id="uuid-9da88e85-974e-4d87-b31e-e32e3861135b">Self-hosting a WCF service</h1>
<p>To use a WCF service, you need to host it in a runtime environment, so that the service host can listen for requests from clients, direct those requests to the service, and send responses back to the client. Using the host, you can start and stop the service.</p>
<p>If you want to self-host a service, you must create an instance of the <kbd>System.ServiceModel.ServiceHost</kbd> class and configure it with endpoints. This can be done in code or in a configuration file. Once the host is ready, any client can access the service by the URL specified.</p>
<p>Self-hosting can be done in any managed application, such as a console application, a Windows service, a Windows Forms application, or a <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) application. In this recipe, we will learn how to self-host a WCF service in a console application and execute it.</p>
<h2 id="uuid-cceeeb73-836f-4c15-a24e-887068c2b386">Getting ready</h2>
<p>To get started, let's launch Visual Studio with administrative privileges. Now, open the project <kbd>CH09.EmployeeService</kbd>, which we created in the previous recipe. Ensure that the project builds successfully, and that the service launches properly in the browser. Mark down the service URL for reference, which we will be using later in this recipe.</p>
<h2 id="uuid-fcfe6acb-4587-43a9-902e-bb468e6759b9">How to do it...</h2>
<p>Let's follow these steps to create a self-hosted console application:</p>
<ol>
<li>First, add a new project of type Console Application, inside the solution, and name it <kbd>CH09.SelfHostingDemo</kbd>.</li>
<li>Now, right-click on the References node, and add the project reference of the service (<kbd>CH09.EmployeeService</kbd>):</li>
</ol>
<div><img src="img/ae00c43b-79bb-419f-aba6-93ed95a2077f.png" style=""/></div>
<ol start="3">
<li>Also add the assembly reference of <kbd>System.ServiceModel</kbd> into the console application project.</li>
<li>From Solution Explorer, navigate to the <kbd>Program.cs</kbd> file.</li>
<li>Add the following <kbd>using</kbd> namespaces inside the class file:</li>
</ol>
<pre style="padding-left: 90px">using CH09.EmployeeService.Services; 
using System; 
using System.ServiceModel; 
using System.ServiceModel.Description; </pre>
<ol start="6">
<li>Now we need to define the service URL so that we can access it from the host. Create a static member variable inside the <kbd>Program.cs</kbd> class file, as follows:</li>
</ol>
<pre style="padding-left: 90px">private static Uri serviceUrl = new Uri( 
     "http://localhost:59795/Services/EmployeeService"); </pre>
<ol start="7">
<li>The <kbd>Program</kbd> class contains a static <kbd>Main</kbd> method. Replace the definition with the following code block:</li>
</ol>
<pre style="padding-left: 90px">static void Main(string[] args) 
{ 
    // create Service Host 
    using (var serviceHost = new ServiceHost( 
       typeof(EmployeeService.Services.EmployeeService),  
       serviceUrl)) 
    { 
 
        // add the service endpoint 
        serviceHost.AddServiceEndpoint( 
                    typeof(IEmployeeService),  
                    new BasicHttpBinding(), ""); 
        serviceHost.Description.Behaviors.Add( 
                    new ServiceMetadataBehavior  
                    {  
                        HttpGetEnabled = true  
                    }); 
 
        // start the Service host 
        serviceHost.Open(); 
 
        Console.WriteLine("Service hosting time: " +  
                          DateTime.Now.ToString()); 
        Console.WriteLine(); 
        Console.WriteLine("Service Host is running..."); 
        Console.WriteLine("Press [Enter] key to stop the host..."); 
        Console.ReadLine(); 
 
        // close the Service host 
        serviceHost.Close(); 
    } 
} </pre>
<ol start="8">
<li>Build the solution, and run the console application. You will see the following output in the console output window:
<div><img src="img/eb4a7010-2170-43d6-ad0e-d267f1a98199.png" style=""/></div>
</li>
<li>The service is now hosted through the host process. Press the <em>Enter</em> key to stop the service.</li>
</ol>
<h2 id="uuid-2678bd30-4ff5-49e6-95ee-172adbf96b8c">How it works...</h2>
<p>To host the service, the host application uses the <kbd>ServiceHost</kbd> class from the <kbd>System.ServiceModel</kbd> namespace. It gets instantiated based on the type of service that you have implemented. In the preceding example, the <kbd>ServiceHost</kbd> class creates an object of <kbd>EmployeeService.Services.EmployeeService</kbd> and removes it from memory whenever the service completes execution.</p>
<p>If you check the <kbd>ServiceHost</kbd> object in the <strong>QuickWatch Window</strong>, you will notice that the object exposes several properties. The <kbd>BaseAddress</kbd> property defines the URL of the service, which maintains a runtime socket listener that listens to the port for the created service for any incoming requests. Once it receives any request, it parses the whole message passed to it and calls the service object.</p>
<p>Here's a screenshot of the QuickWatch Window, showing the number of properties exposed by the <kbd>ServiceHost</kbd> object:</p>
<div><img src="img/80d8cdb1-8a4c-45bd-b26c-0977d799e827.png"/></div>
<p>The <kbd>serviceHost.AddServiceEndpoint</kbd> adds a service endpoint to the hosted service with a specified contract, binding, and endpoint address. You can use any binding type based on your requirement, but here we have used <kbd>BasicHttpBinding</kbd> to create the service endpoint.</p>
<p>In case of <kbd>BasicHttpBinding</kbd>, SOAP messages are transferred. The SOAP message contains a well-defined envelop with a header and body of the message inside it. When a client calls the service, the <kbd>ServiceHost</kbd> class parses the message and calls the service by creating the context.</p>
<p>To see the endpoints used by the <kbd>ServiceHost</kbd> object, expand the <kbd>Description</kbd> property in the QuickWatch Window and navigate to <kbd>Endpoints</kbd>. Expand the first endpoint of the service and check the <kbd>Address</kbd>, <kbd>Binding</kbd>, <kbd>Contract</kbd> ("ABC") properties of it. This will look as follows:</p>
<div><img src="img/d867da9d-5923-41cd-bf38-c01c8882bafd.png"/></div>
<p>You can see that the <kbd>Address</kbd> points to the <kbd>BaseAdress</kbd> of the service, the <kbd>Binding</kbd> denotes the <kbd>BasicHttpBinding</kbd> that we created, and the <kbd>Contract</kbd> exposes service <kbd>Name</kbd>, <kbd>ConfigurationName</kbd>, <kbd>ContractType</kbd>, <kbd>SessionMode</kbd>, <kbd>ProtectionLevel</kbd>, <kbd>HasProtectionLevel</kbd>, and other properties.</p>
<p>When you are ready, the <kbd>serviceHost.Open()</kbd> method starts the service. It causes the communication object to transition from the created state to the opened state. When you are done, calling the <kbd>serviceHost.Close()</kbd> method stops the service. This causes the communication object to transition from its current state to the closed state.</p>
<p>In case you want your service object to be reused, you can add a <kbd>ServiceBehavior</kbd> attribute to the service class, as follows:</p>
<pre style="padding-left: 60px">[ServiceBehavior(InstanceContextMode =  
                 InstanceContextMode.Single)] 
public class EmployeeService : IEmployeeService 
{ 
    ... 
    ... 
} </pre>
<p>When you apply this attribute, it specifies the internal execution behavior of the service contract implementation. The specified <kbd>InstanceContextMode</kbd> can be one of three types:</p>
<ul>
<li><strong>PerSession</strong>: A new <kbd>System.ServiceModel.InstanceContext</kbd> object is created for each session.</li>
<li><strong>PerCall</strong>: A new <kbd>System.ServiceModel.InstanceContext</kbd> object is created prior to and recycled subsequent to each call. If the channel does not create a session, this value behaves as <kbd>PerCall</kbd>.</li>
<li><strong>Single</strong>: Only one <kbd>System.ServiceModel.InstanceContext</kbd> object is used for all incoming calls and is not recycled subsequent to the calls. If a <kbd>service</kbd> object does not exist, a new one will be created.</li>
</ul>
<h2 id="uuid-f13c6541-8d67-4035-a150-7c440d501b75">There's more...</h2>
<p>If you don't have administrative rights on your system, the application will crash with <kbd>System.ServiceModel.AddressAccessDeniedException</kbd>, saying that the HTTP could not register the URL. The error log will look like this:</p>
<div><img src="img/6fad9ef9-32d3-467a-aa69-0113308ecbb3.png"/></div>
<p>If you encounter this error, run the application under admin privileges. If you are running the application directly from Visual Studio, relaunch Visual Studio with admin privileges. To do so, right-click on the Visual Studio icon and click on Run as administrator.</p>
<h1 id="uuid-18d3cdf6-1ab0-457b-ac3f-bac5b8fc033a">Hosting a WCF service in an IIS server</h1>
<p>Another way to host a WCF service is in an <strong>IIS</strong> (<strong>Internet Information Services</strong>). It requires a physical file with a <kbd>.svc</kbd> extension to host the service properly. Unlike the previous recipe, you won't need to write any code to create the instance of <kbd>ServiceHost</kbd>. IIS automatically creates it for you while hosting the service.</p>
<p>In this recipe, we will learn how to publish an already created service to host inside the IIS server of Windows.</p>
<h2 id="uuid-a206a72b-8d56-4d5d-a142-bd7aaca3f673">Getting ready</h2>
<p>To get started, launch the Visual Studio IDE with administrative rights. To do so, right-click on the icon and click Run as administrator. Now open the existing project <kbd>CH09.EmployeeService</kbd>, which we have created earlier. Alternatively, you can also open the solution.</p>
<p>To proceed further, we assume that you are familiar with IIS and understand how to use the IIS management tool to create and manage IIS applications.</p>
<h2 id="uuid-9c847195-fb05-4226-a747-a4492026fafc">How to do it...</h2>
<p>Let's follow these steps to host our service in an IIS server:</p>
<ol>
<li>First, you need to check whether the <strong>IIS</strong> (<strong>Internet Information Services</strong>) is already installed on the system, where you are going to host the service. To check this, open the Control Panel and navigate to Turn Windows features on or off, as shown in the following screenshot:</li>
</ol>
<div><img src="img/e2fb6da1-0573-4f91-84b2-fd3506c2d978.png" style=""/></div>
<ol start="2">
<li>From the Windows Features dialog, which pops up on the screen, make sure that the Internet Information Services feature is checked. If not, check it, and click OK. This will install the IIS server on that system.</li>
<li>Now, click on Start (<img src="img/1e167e22-1ea5-4da5-942c-1aeaac7192bc.png"/>), type <kbd>inetmgr</kbd>, and click the Internet Information Services (IIS) Manager app shortcut to launch it. Make sure that the Default Web Site is up and running. In the next steps, we will be deploying our service on this website:</li>
</ol>
<div><img src="img/78545579-f1a9-41ce-b429-693f46e6bfce.png"/></div>
<ol start="4">
<li>Once the IIS is installed (in case it was not already) and the Default Web Site in IIS is up and running, navigate back to Visual Studio.</li>
<li>From the Solution Explorer, right-click on the service project (<kbd>CH09.EmployeeService</kbd>) node, and click Publish:</li>
</ol>
<div><img src="img/b564bb0d-4ba0-40cb-9edb-3414fdb72888.png" style=""/></div>
<ol start="6">
<li>This will open the publishing wizard inside Visual Studio. Navigate to the Publish tab, select publishing template as IIS, FTP, etc, and click the Publish button, demonstrated as follows:</li>
</ol>
<div><img src="img/8cfb2202-4f2c-48c6-9fa5-6d16300ac591.png" style=""/></div>
<ol start="7">
<li>This will open the Publish dialog. Make sure that the Connection tab is selected:</li>
</ol>
<p style="padding-left: 120px">1. Select Web Deploy as the publishing method type.</p>
<p style="padding-left: 120px">2. Enter the name of the server. In our case, as we are deploying it to the same system, it will be <kbd>localhost</kbd>.</p>
<p style="padding-left: 120px">3. Enter the name of the site where we are going to deploy our service. In our case, it is <kbd>Default Web Site</kbd>. To deploy it in a specific web app inside the website, enter the name of the web app after the site name. For example, to deploy in the <kbd>MyApp</kbd> web application inside the <kbd>Default Web Site</kbd>, the site name here will be <kbd>Default Web Site/MyApp</kbd>.</p>
<p style="padding-left: 120px">4. Enter the User name and Password of your web server, where you are going to deploy it. In our case, as it is <kbd>localhost</kbd>, we will not need to enter any credentials. Those two fields will be by default disabled.</p>
<p style="padding-left: 120px">5. Click on Validate Connection to confirm about the publishing details that you entered. On success, you will see a green tick mark beside the Validate Connection button.</p>
<ol start="8">
<li>Once done, click on Next to proceed to the Settings page:
<div><img src="img/e055c838-79ac-4968-ae2a-44fef73028da.png" style=""/></div>
</li>
<li>Inside the Settings page, select Release as the Configuration. Optionally, select File Publish Options based on your requirement.</li>
<li>Once you are done, click Save to start the publishing:
<div><img src="img/9e546c87-6f91-46fb-b310-3aecb9761ce0.png"/></div>
</li>
<li>Once the Visual Studio IDE builds the solution and completes the deployment to the selected website, navigate back to the Internet Information Services (IIS) Manager application (<kbd>inetmgr</kbd>).</li>
</ol>
<p> </p>
<ol start="12">
<li>Refresh the Default Web Site node, which will now list two folders, named bin and Services. Click on the Services folder, and switch to Content View. This will list the <kbd>EmployeeService.svc</kbd> file, which is present inside it. Here's a screenshot of this:</li>
</ol>
<div><img src="img/deee5118-56df-4cbd-a5b6-10cc2ad57297.png"/></div>
<ol start="13">
<li>As shown in the preceding screenshot, right-click on the <kbd>EmployeeService.svc</kbd> file, and then click Browse from the context menu entry. Alternatively, you can click on the Browse link present at the right-side Actions pane.</li>
<li>This will open the service URL in the browser window as follows:</li>
</ol>
<div><img src="img/f1270073-7a3b-4ad7-894d-dd35b14ccd70.png"/></div>
<h2 id="uuid-85a1c16b-10ed-45c3-ad2c-edc5464b7bcc">How it works...</h2>
<p>IIS hosting is integrated with ASP.NET and uses the features such as process recycling, process health monitoring, message-based activation, and more. IIS also offers integrated manageability, which makes it an enterprise-grade server.</p>
<p>To host a service in IIS, the IIS needs to be configured properly. For hosting in IIS, no additional code needs to be written. The WCF services hosted in IIS are represented as <kbd>.svc</kbd> files inside the IIS application. A <kbd>.svc</kbd> file contains a WCF-specific processing directive, that is, an <kbd>@ServiceHost</kbd>, which creates the service host and allows the hosting structure of the WCF service to activate in response to incoming messages:</p>
<pre style="padding-left: 60px">&lt;%@ ServiceHost  
    Language="C#"  
    Debug="true"  
    Service="CH09.EmployeeService.Services.EmployeeService"  
    CodeBehind="EmployeeService.svc.cs"  
%&gt; </pre>
<p>The value of the <kbd>Service</kbd> attribute is the fully qualified CLR type name (in our case, it's <kbd>CH09.EmployeeService.Services.EmployeeService</kbd>) of the service implementation. The <kbd>CodeBehind</kbd> attribute defines the relative path of the code behind the file of the <kbd>.svc</kbd>, which is <kbd>EmployeeService.svc.cs</kbd> in our example.</p>
<p>When you deploy a service, the precompiled <kbd>.dll</kbd> file gets deployed in the application's <kbd>bin</kbd> directory and updates only when a latest version of the class library gets deployed.</p>
<p>The uncompiled source file gets deployed in the application's <kbd>App_Code</kbd> directory. When the application gets the first request, these uncompiled source files dynamically load into the memory. Any changes to these deployed source files causes the entire application to be recycled. A fresh recompilation happens automatically when a new request happens to the application.</p>
<h1 id="uuid-1d0f1d3b-769d-4b51-9372-212f99c19c63">Integrating a WCF service in a WPF application</h1>
<p>Once you create a WCF service, you probably would like to integrate it into a client application. But before that, you will have to create a WCF client proxy, so that you can communicate with the service through the WCF client proxy.</p>
<p>In this recipe, we will learn how to create the proxy client and give a call to the service to pass messages between the service and the client.</p>
<h2 id="uuid-74337a55-ce88-4ea3-bafa-7d84052fc4ab">Getting ready</h2>
<p>Before going into the steps to integrate the service, we need to create a client application. Open your Visual Studio IDE, and create a new WPF project. Name it <kbd>CH09.ClientDemo</kbd>.</p>
<h2 id="uuid-9676daf1-6526-4601-87eb-6f82623fc57c">How to do it...</h2>
<p>Follow these steps to create the service proxy and integrate the service call in the client application:</p>
<ol>
<li>Right-click on the project node (<kbd>CH09.ClientDemo</kbd>), and follow the context menu path Add | Service Reference..., which will open the Add Service Reference dialog on the screen:</li>
</ol>
<div><img src="img/749d3780-5c3e-4816-83ad-bb5f8e3af136.png" style=""/></div>
<ol start="2">
<li>In the Add Service Reference dialog, enter the service URL (<kbd>http://localhost:59795/Services/EmployeeService.svc</kbd>) inside the Address field and click on the Go button:</li>
</ol>
<div><img src="img/43695922-6890-4c20-bb4e-905339b097db.png" style=""/></div>
<ol start="3">
<li>This will resolve the service address and show the details about it.</li>
</ol>
<p> </p>
<ol start="4">
<li>As shown in the following screenshot, enter <kbd>EmployeeServiceReference</kbd> as the Namespace for the service proxy and click OK:</li>
</ol>
<div><img src="img/496125a6-c623-4986-942a-aa49440dbfcc.png" style=""/></div>
<ol start="5">
<li>This will create the service proxy as Connected Services under the project:
<div><img src="img/ead9084e-c956-4066-b86b-c8d6ac0fa148.png"/></div>
</li>
<li>Build the project to make sure that there are no compilation issues.</li>
<li>Once the build gets succeeded, navigate to the <kbd>MainWindow.xaml.cs</kbd> file.</li>
<li>Create a dependency property of type <kbd>ObservableCollection&lt;Employee&gt;</kbd>, and name it as <kbd>Employees</kbd>. The property implementation will look as follows:</li>
</ol>
<pre style="padding-left: 90px">public ObservableCollection&lt;Employee&gt; Employees 
{ 
    get 
    { 
        return (ObservableCollection&lt;Employee&gt;) 
                    GetValue(EmployeesProperty); 
    } 
    set 
    { 
        SetValue(EmployeesProperty, value); 
    } 
} 
 
public static readonly DependencyProperty  
       EmployeesProperty =  
            DependencyProperty.Register( 
               "Employees",  
               typeof(ObservableCollection&lt;Employee&gt;),  
               typeof(MainWindow),  
               new PropertyMetadata(null)); </pre>
<ol start="9">
<li>Now, resolve the reference of the <kbd>Employee</kbd> class, which will add <kbd>CH09.ClientDemo.EmployeeServiceReference</kbd> as the <kbd>using</kbd> namespace:
<div><img src="img/1099f510-f417-4755-83a8-364efd49cd34.png"/></div>
</li>
<li>Make sure the following <kbd>using</kbd> namespaces are added to the class file:</li>
</ol>
<pre style="padding-left: 90px">using CH09.ClientDemo.EmployeeServiceReference; 
using System.Collections.ObjectModel; 
using System.Windows; </pre>
<ol start="11">
<li>Inside the class, create the following static instance of the proxy client, so that we can call the service APIs:</li>
</ol>
<pre style="padding-left: 90px">private static EmployeeServiceClient client =  
                       new EmployeeServiceClient(); </pre>
<ol start="12">
<li>Now, add the following two methods inside the class, and make sure that the methods are marked as <kbd>async</kbd>:</li>
</ol>
<pre style="padding-left: 90px">private async void RefreshListAsync() 
{ 
    var result = await client.GetEmployeesAsync(); 
    Employees = new ObservableCollection&lt;Employee&gt;(result); 
} 
 
private async void AddNewEmployeeAsync() 
{ 
    var employee = new Employee 
    { 
        ID = "EMP00" + (Employees.Count + 1), 
        FirstName = "User", 
        LastName = (Employees.Count + 1).ToString(), 
        Designation = "Software Engineer" 
    }; 
 
    await client.InsertEmployeeAsync(employee); 
} </pre>
<ol start="13">
<li>From Solution Explorer, navigate to the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Give a name to the <kbd>Window</kbd> instance by adding the <kbd>x:Name="window"</kbd> attribute.</li>
<li>Split the default <kbd>Grid</kbd> into two rows, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="*"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
&lt;/Grid.RowDefinitions&gt; </pre>
<ol start="16">
<li>In the first row of the <kbd>Grid</kbd> panel, add a <kbd>DataGrid</kbd>, and create a data binding between the <kbd>ItemsSource</kbd> property and the <kbd>Employees</kbd> collection. This will populate the <kbd>DataGrid</kbd> with the values from the <kbd>Employees</kbd> collection.</li>
<li>Set <kbd>AutoGenerateColumns="False"</kbd>, <kbd>CanUserAddRows="False"</kbd>, and <kbd>CanUserDeleteRows="False"</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;DataGrid ItemsSource="{Binding Employees,  
                        ElementName=window}" 
          Grid.Row="0"  
          AutoGenerateColumns="False" 
          CanUserAddRows="False" 
          CanUserDeleteRows="False"&gt; 
    &lt;DataGrid.Columns&gt; 
 
    &lt;/DataGrid.Columns&gt; 
&lt;/DataGrid&gt; </pre>
<ol start="18">
<li>As we have already asked the <kbd>DataGrid</kbd> not to generate the columns automatically, we need to manually create them, based on the need. In this demonstration, we will only display the <kbd>ID</kbd>, <kbd>Name</kbd>, and <kbd>Designation</kbd> columns in the <kbd>DataGrid</kbd>. Let's add the following columns, among which, the Name column will have a multi-binding with the <kbd>FirstName</kbd> and <kbd>LastName</kbd> properties of the <kbd>Employee</kbd> class to display the full name of the employee. Here's the code for your reference:</li>
</ol>
<pre style="padding-left: 90px">&lt;DataGrid.Columns&gt; 
    &lt;DataGridTextColumn Header="ID"  
                        Width="80" 
                        Binding="{Binding ID}"/&gt; 
    &lt;DataGridTextColumn Header="Name" 
                        Width="200"&gt; 
        &lt;DataGridTextColumn.Binding&gt; 
            &lt;MultiBinding StringFormat="{}{0} {1}"&gt; 
                &lt;Binding Path="FirstName"/&gt; 
                &lt;Binding Path="LastName"/&gt; 
            &lt;/MultiBinding&gt; 
        &lt;/DataGridTextColumn.Binding&gt; 
    &lt;/DataGridTextColumn&gt; 
    &lt;DataGridTextColumn Header="Designation"  
                        Width="150" 
                        Binding="{Binding Designation}"/&gt; 
&lt;/DataGrid.Columns&gt; </pre>
<ol start="19">
<li>In the second row of the <kbd>Grid</kbd> panel, let's add a horizontal <kbd>StackPanel</kbd> with two buttons in it. Label them as Refresh and Add. Also, expose the <kbd>Click</kbd> event of both the two buttons:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal" 
            Grid.Row="1" 
            Margin="8"&gt; 
    &lt;Button Content="Refresh" 
            Margin="4" 
            Height="26" 
            Width="80" 
            Click="OnRefreshClicked"/&gt; 
    &lt;Button Content="Add" 
            Margin="4" 
            Height="26" 
            Width="80" 
            Click="OnAddClicked"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="20">
<li>In the code behind the file of the <kbd>MainWindow.xaml</kbd> (that is, in <kbd>MainWindow.xaml.cs</kbd>), write the <kbd>Click</kbd> event implementation for both the two buttons. The <kbd>OnRefreshClicked</kbd> event will call the <kbd>RefreshListAsync()</kbd> method to fetch the employees list. The <kbd>OnAddClicked</kbd> event will call the <kbd>AddNewEmployeeAsync()</kbd> method to give a call to the service to insert a new employee record, and then call the <kbd>RefreshListAsync()</kbd> method to fetch the current employee list from the service:</li>
</ol>
<pre style="padding-left: 90px">private void OnRefreshClicked(object sender,  
                              RoutedEventArgs e) 
{ 
    RefreshListAsync(); 
} 
 
private void OnAddClicked(object sender,  
                          RoutedEventArgs e) 
{ 
    AddNewEmployeeAsync(); 
    RefreshListAsync(); 
} </pre>
<ol start="21">
<li>Let's build the project and run the application. Make sure that the service is already running and accessible.</li>
<li>You will see the following application UI on the screen:
<div><img src="img/8309d3cc-a058-42c3-b677-a00a0eac3d3b.png" style=""/></div>
</li>
<li>Click the Add button. This will create a new employee record and pass it to the service to store in the database, which is the static <kbd>m_employees</kbd> instance in our case.</li>
</ol>
<p> </p>
<ol start="24">
<li>After inserting the record, it will again give a call to the service to fetch the newly inserted details and populate the <kbd>DataGrid</kbd> in the UI. Clicking the Add button multiple times will add the number of records and fill the <kbd>DataGrid</kbd> accordingly:
<div><img src="img/ce168531-a457-445d-b279-c681600ade72.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-7ddcad1b-4831-4e15-a0e6-0439ddd98791">How it works...</h2>
<p>The WCF client proxy can be generated manually by using the <kbd>SVCUtil.exe</kbd> (<strong>Service Model Metadata Utility Tool</strong>). It is a command-line tool for generating the code from the service metadata. The following command can be used to generate the proxy code: <kbd>svcutil.exe &lt;Service URL&gt;</kbd>.</p>
<p>If you want to create the proxy client for the service that we created earlier, you can enter the following command in a console window:</p>
<pre style="padding-left: 60px"><strong>svcutil.exe http://localhost:59795/Services/<br/>EmployeeService.svc?wsdl</strong> </pre>
<p>Alternatively, you can also generate the client proxy from Visual Studio. As demonstrated previously, the Add Service Reference feature generates the proxy code automatically. Once you click the Go button after inserting the service address, the dialog displays a list of services available at the address specified. It starts generating the code when you click the OK button.</p>
<p>In our case, the <strong>Service Model Metadata Utility Tool</strong> and the Add Service Reference dialog of Visual Studio (you can use either of them) generates the following WCF client class (<kbd>EmployeeServiceClient</kbd>) for our service, which inherits from the generic <kbd>System.ServiceModel.ClientBase&lt;TChannel&gt;</kbd> class and implements the <kbd>CH09.ClientDemo.EmployeeServiceReference.IEmployeeService</kbd> interface:</p>
<pre style="padding-left: 90px">[System.Diagnostics.DebuggerStepThroughAttribute()] 
[System.CodeDom.Compiler.GeneratedCodeAttribute( 
 "System.ServiceModel", "4.0.0.0")] 
public partial class EmployeeServiceClient : System.ServiceModel.ClientBase&lt;CH09.ClientDemo.EmployeeServiceReference.IEmployeeService&gt;, CH09.ClientDemo.EmployeeServiceReference.IEmployeeService 
{         
    public EmployeeServiceClient() { 
    } 
         
    public EmployeeServiceClient(string  <br/>    endpointConfigurationName)  
             : base(endpointConfigurationName) { 
    } 
         
    public EmployeeServiceClient(string <br/>    endpointConfigurationName,  
           string remoteAddress)  
             : base(endpointConfigurationName, remoteAddress) { 
    } 
         
    public EmployeeServiceClient(string <br/>    endpointConfigurationName,  
           System.ServiceModel.EndpointAddress remoteAddress)  
             : base(endpointConfigurationName, remoteAddress) { 
    } 
         
    public EmployeeServiceClient<br/>    (System.ServiceModel.Channels.Binding binding, <br/>    System.ServiceModel.EndpointAddress remoteAddress)  
             : base(binding, remoteAddress) { 
    } 
         
    public CH09.ClientDemo.EmployeeServiceReference.Employee  
      GetEmployeeByID(string empID) { 
        return base.Channel.GetEmployeeByID(empID); 
    } 
         
    public System.Threading.Tasks.Task&lt;CH09.<br/>    ClientDemo.EmployeeServiceReference.Employee&gt;   <br/>    GetEmployeeByIDAsync(string empID) { 
        return base.Channel.GetEmployeeByIDAsync(empID); 
    } 
         
    public CH09.ClientDemo.EmployeeServiceReference.Employee[] <br/>    GetEmployees() { 
        return base.Channel.GetEmployees(); 
    } 
         
    public System.Threading.Tasks.Task&lt;CH09.<br/>    ClientDemo.EmployeeServiceReference.Employee[]&gt; <br/>    GetEmployeesAsync() { 
        return base.Channel.GetEmployeesAsync(); 
    } 
         
    public void InsertEmployee(CH09.ClientDemo.<br/>    EmployeeServiceReference.Employee employee) { 
        base.Channel.InsertEmployee(employee); 
    } 
         
    public System.Threading.Tasks.Task InsertEmployeeAsync<br/>   (CH09.ClientDemo.EmployeeServiceReference.Employee employee) { 
        return base.Channel.InsertEmployeeAsync(employee); 
    } 
} </pre>
<p>Once the service proxy gets created, you can create the instance of the service client and call the methods of the service. In our example, we created the following service client instance and marked it as <kbd>static</kbd>:</p>
<pre style="padding-left: 90px">private static EmployeeServiceClient client =  
                       new EmployeeServiceClient(); </pre>
<p>The client consists of two API method types for each operation contract that the service has exposed. One of them is a synchronous method, whereas the other is asynchronous. For example, you could see <kbd>GetEmployees()</kbd> and <kbd>GetEmployeesAsync()</kbd> methods, as listed in the following screenshot:</p>
<div><img src="img/8f1aa35b-55f0-4bfe-8c21-0f8c7181091d.png" style=""/></div>
<p>When you want to call the service in a synchronous way, call the <kbd>GetEmployees()</kbd> method. In case you want to operate in asynchronous mode, call the <kbd>GetEmployeesAsync()</kbd> method. Similarly, to get the employee details by ID, you can select between <kbd>GetEmployeeByID</kbd> and <kbd>GetEmployeeByIDAsync</kbd>, based on synchronous and asynchronous modes. It is a similar case for other service methods.</p>
<h2 id="uuid-1735c87a-0a6a-4560-b364-55e43c39c44f">There's more...</h2>
<p>A WCF service client may throw one or more exceptions, which you must handle in your code. Some of the most common exceptions are:</p>
<ul>
<li><kbd>SocketException</kbd>: This may occur when an existing connection was forcibly closed by the remote host</li>
<li><kbd>CommunicationException</kbd>: This may occur when the underlying connection was unexpectedly closed</li>
<li><kbd>CommunicationObjectAbortedException</kbd>: This may occur when the socket connection was aborted due to an error processing your message, a timeout while processing the request, or an underlying network issue</li>
</ul>


            

            
        
    </body></html>