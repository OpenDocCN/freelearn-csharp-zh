<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor195"/>6</h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor196"/>Dictionaries and Sets</h1>
<p>This chapter focuses on data structures related to dictionaries and sets. Applying these data structures makes it possible <strong class="bold">to map keys to values and perform fast lookup</strong>, as well as <strong class="bold">to make various operations on sets</strong>. To simplify your understanding of dictionaries and sets, this chapter contains illustrations and code snippets, along with detailed descriptions.</p>
<p>First, you will learn about both non-generic and generic versions of a <strong class="bold">dictionary</strong>, which is a collection of pairs, each consisting of a key and a value. Then, a <strong class="bold">sorted variant</strong> of a dictionary will be presented. The remaining part of this chapter will show you how to use <strong class="bold">hash sets</strong>, together with a <strong class="bold">“sorted” set</strong> variant. Is it possible to have a “sorted” set? You’ll learn more later in this chapter.</p>
<p>In this chapter, the following topics will be covered:</p>
<ul>
<li>Hash tables</li>
<li>Dictionaries</li>
<li>Sorted dictionaries</li>
<li>Hash sets</li>
<li>“Sorted” sets<a id="_idTextAnchor197"/></li>
</ul>
<h1 id="_idParaDest-109"><a id="_idTextAnchor198"/>Hash tables</h1>
<p>Let’s start with the first<a id="_idIndexMarker546"/> data structure, which is a <strong class="bold">hash table</strong>, also known as <a id="_idIndexMarker547"/>a <strong class="bold">hash map</strong>. <strong class="bold">It allows you to </strong><strong class="bold">map</strong><strong class="bold"> keys to particular values</strong>. One of the most important assumptions of the hash table is the possibility of <strong class="bold">a very fast lookup for a </strong><strong class="bold">value</strong><strong class="bold"> based on the </strong><strong class="bold">key</strong>, which should be the <em class="italic">O(1)</em> operation.</p>
<p class="callout-heading">Imagine a hash table or a dictionary</p>
<p class="callout">If you want to better imagine a hash table or a dictionary, it would be worth thinking about a collection containing a lot of data, where it is crucial to quickly check whether the dictionary contains a specific key, as well as quickly retrieve the value assigned to a given key. So, think about a system that allows you to determine which country a specific IP address comes from. As you know, there are many possible IP addresses, and your system must quickly obtain information from which country the user’s request comes to select the default language version of the application. This is how a hash table and dictionary work! You use an IP address as a key (for example, 50.50.50.50) and a country code as a value (for example, PL). Thus, you can quickly find out from which country the user came to you, without manually browsing the entire collection. I come to you from Poland, which I cordially invite you to visit! It contains mountains, sea, lakes, and cities with a rich history. All this is waiting here for you!</p>
<p>To achieve a very fast lookup, a <strong class="bold">hash function</strong> is used. It takes the key to generate an index of a bucket, where the <a id="_idIndexMarker548"/>value can be found. For this reason, if you need to find a value of the key, you do not need to iterate through all the items in the collection since you can just use the hash<a id="_idIndexMarker549"/> function to easily locate a proper bucket and get the value. As you can see, the role of the hash function is critical and ideally, it should generate a unique result for all keys. However, the same result may be generated for different keys. Such a<a id="_idIndexMarker550"/> situation is called a <strong class="bold">hash collision</strong> and should be dealt with.</p>
<p>A way of mapping keys to particular values is shown in the following diagram:</p>
<div><div><img alt="Figure 6.1 – Illustration of mapping keys to particular values" src="img/B18069_06_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Illustration of mapping keys to particular values</p>
<p>Due to the great performance of hash tables, they are frequently used in many real-world applications, such as for <strong class="bold">associative arrays</strong>, <strong class="bold">database indices</strong>, and <strong class="bold">cache systems</strong>.</p>
<p>The topic of implementing hash tables from scratch seems to be quite difficult, especially when it comes to using the hash function, handling hash collisions, as well as assigning particular keys to buckets. Fortunately, a suitable implementation is available while developing <a id="_idIndexMarker551"/>applications in the C# language, and its usage is very simple.</p>
<p class="callout-heading">Non-generic and generic versions</p>
<p class="callout">There are two variants of the hash table-related <a id="_idIndexMarker552"/>classes, namely non-generic (<code>Hashtable</code>) and generic (<code>Dictionary</code>). The first will be described in this section, while the other <a id="_idIndexMarker553"/>will be described in the following section. If you can use the strongly typed generic version, I strongly recommend using it.</p>
<p>Let’s take a look at the <code>Hashtable</code> class from the <code>System.Collections</code> namespace. As mentioned previously, it stores a collection of pairs, where each contains a key and a value. A pair is represented by the <code>DictionaryEntry</code> instance.</p>
<p>Here’s some example code that uses the <code>Hashtable</code> class:</p>
<pre class="source-code">
using System.Collections;
<strong class="bold">Hashtable</strong> hashtable = new()
{
    { "Key #1", "Value #1" },
    { "Key #2", "Value #2" }
};
hashtable.<strong class="bold">Add</strong>("Key #3", "Value #3");
hashtable<code>Key #1</code> and <code>Key #2</code>), by using the <code>Add</code> method (<code>Key #3</code>) or by using the indexer (<code>Key #4</code>).</p>
<p>When you use the indexer to set a value for an already existing key, the value of this element is updated. A different behavior occurs while using the <code>Add</code> method because it throws an exception when an item with the same key already exists in the collection. You can handle this situation by using the <code>try-catch</code> statement, but there is a much better approach to check whether <a id="_idIndexMarker554"/>such an entry already exists – using the <code>ContainsKey</code> method. This will be shown a bit later.</p>
<p>It is worth mentioning that the <code>null</code> value is incorrect for the key of an element, but it is acceptable as a value of an element.</p>
<p>You can easily gain access to a particular element using the indexer. As the <code>Hashtable</code> class is a non-generic variant of hash table-related classes, you need to cast the returned result to the proper type (for example, <code>string</code>), as shown here:</p>
<pre class="source-code">
string value = <code>foreach</code> loop to iterate through all pairs stored in the collection, as presented here:</p>
<pre class="source-code">
<strong class="bold">foreach (DictionaryEntry entry in hashtable)</strong>
{
    Console.WriteLine($"{<strong class="bold">entry.Key</strong>}: {<strong class="bold">entry.Value</strong>}");
}</pre> <p>The variable that’s used in the loop is of the <code>DictionaryEntry</code> type. Therefore, you can use its <code>Key</code> and <code>Value</code> properties to access the key and the value, respectively.</p>
<p>The <code>Hashtable</code> class is equipped with a few properties, such as those for getting the number of stored elements (<code>Count</code>), as well as returning the collection of keys and values (<code>Keys</code> and <code>Values</code>). You can use the following methods:</p>
<ul>
<li><code>Add</code>, which adds a new element</li>
<li><code>Remove</code>, which removes an element</li>
<li><code>Clear</code>, which removes all elements</li>
<li><code>ContainsKey</code>, which checks whether the collection contains a given key</li>
<li><code>ContainsValue</code>, which checks whether the collection contains a given value</li>
</ul>
<p class="callout-heading">What about performance?</p>
<p class="callout">A hash table is an efficient data structure. Retrieving a value by a key, checking whether the collection contains a given key, and removing an item by a key are the <em class="italic">O(1)</em> operations. As for addition, if the capacity does not need to be increased, it is the <em class="italic">O(1)</em> operation as well. Otherwise, it<a id="_idIndexMarker555"/> is the <em class="italic">O(n)</em> operation, where <em class="italic">n</em> is the number of items.</p>
<p>With this short introduction, let’s take a look at an example.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a hash table at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable">https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable</a>. </p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor199"/>Example – phone book</h2>
<p>As an example, let’s say you create an application for a phone book. The <code>Hashtable</code> class is used to store entries where<a id="_idIndexMarker556"/> the person’s name is a key and the phone number is a value, as shown here:</p>
<pre class="source-code">
<strong class="bold">NAME ---&gt; PHONE</strong>
Marcin -&gt; 101-202-303
John ---&gt; 202-303-404
Aline --&gt; 303-404-505</pre> <p>This program demonstrates how to add elements to the collection, get the number of stored items, iterate through all of them, check whether an element with a given key exists, as well as how to get a value based on the key.</p>
<p>First, let’s create a new instance of the <code>Hashtable</code> class, as well as initialize it with some entries, as shown in the following code:</p>
<pre class="source-code">
Hashtable phoneBook = new()
{
    <strong class="bold">{ "Marcin", "101-202-303" },</strong>
    { "John", "202-303-404" }
};
phoneBook<code>Count</code> property and comparing its value with <code>0</code>, as presented here:</p>
<pre class="source-code">
Console.WriteLine("Phone numbers:");
if (phoneBook.<strong class="bold">Count</strong> == 0)
{
    Console.WriteLine("Empty list.");
}</pre> <p>Then, you can iterate through all the pairs:</p>
<pre class="source-code">
<strong class="bold">foreach</strong> (DictionaryEntry entry in phoneBook)
{
    Console.WriteLine($"{<strong class="bold">entry.Key</strong>}: {<strong class="bold">entry.Value</strong>}");
}</pre> <p>Finally, let’s see how we can check whether a specific key exists in the collection, as well as how to get its value. The first task can be accomplished just by calling the <code>ContainsKey</code> method, which returns a value indicating whether a suitable element exists (<code>true</code>) or not (<code>false</code>). To get a value, you can use the indexer. Please keep in mind that you must cast the returned value to a suitable type, such as <code>string</code> in this example. This requirement is caused by the non-generic version of the hash table-related class. This code is as follows:</p>
<pre class="source-code">
Console.Write("\nSearch by name: ");
string name = Console.ReadLine() ?? string.Empty;
if (phoneBook.<strong class="bold">ContainsKey</strong>(name))
{
    string number = <strong class="bold">(string)phoneBook[name]!</strong>;
    Console.WriteLine($"Phone number: {number}");
}
else
{
    Console.WriteLine("Does not exist.");
}</pre> <p>Your first program using the hash table is ready! After launching it, you should receive a result similar to the following:</p>
<pre class="console">
Phone numbers:
Marcin: 101-202-303
Aline: 303-404-505
John: 202-303-404
Search by name: Aline
Phone number: 303-404-505</pre> <p>It is worth noting that<a id="_idIndexMarker558"/> the order of the pairs stored using the <code>Hashtable</code> class is not consistent with the order of their addition or keys. For this reason, if you need to present the sorted results, you need to sort the elements on your own or use another data structure, namely <code>SortedDictionary</code>, which is described later in this book.</p>
<p>Now, let’s take a look at one of the most common classes used while developing in C#, namely <code>Dictionary</code>, which is a generic version of hash table-rela<a id="_idTextAnchor200"/>t<a id="_idTextAnchor201"/>ed classes.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor202"/>Dictionaries</h1>
<p>In the previous section, you learned about the <code>Hashtable</code> class, a non-generic variant of the hash table-related classes. However, it has a significant limitation, because it does not allow you to specify a type of a <a id="_idIndexMarker559"/>key and a value. Both the <code>Key</code> and <code>Value</code> properties of the <code>DictionaryEntry</code> class are of the <code>object</code> type. Therefore, you need to perform boxing and unboxing operations, even if all the keys and values are of the same type. If you want to benefit from the <code>Dictionary</code> generic class, which is the main subject of this section.</p>
<p>First of all, you should specify two types, namely a type of a key and a value, while creating an instance of the <code>Dictionary</code> class. Moreover, it is possible to define the initial content of the dictionary using the following code:</p>
<pre class="source-code">
<strong class="bold">Dictionary&lt;string, string&gt;</strong> dictionary = new()
{
    <strong class="bold">{ "Key #1", "Value #1" }</strong>,
    { "Key #2", "Value #2" }
};</pre> <p>In the preceding code, a new instance of the <code>Dictionary</code> class is created. It stores <code>string</code>-based keys and values. Here, two entries exist in the dictionary, namely <code>Key #1</code> and <code>Key #2</code>. Their values are <code>Value #1</code> and <code>Value #2</code>.</p>
<p>Similar to the <code>Hashtable</code> class, you can also use the indexer to get access to a particular element within the collection, as shown in the following line of code:</p>
<pre class="source-code">
string value = dictionary<code>string</code> type is unnecessary because <code>Dictionary</code> is the strongly<a id="_idIndexMarker560"/> typed version of the hash table-related classes. Therefore, the returned value already has the proper type. If an element with the given key does not exist in the collection, <code>KeyNotFoundException</code> is thrown. To avoid problems, you can either check whether the element exists (by calling <code>ContainsKey</code>) or use the <code>TryGetValue</code> method.</p>
<p>You can add a new element or update a value of the existing one using the indexer:</p>
<pre class="source-code">
dictionary<code>key</code> cannot be equal to <code>null</code>, but <code>value</code> can be if it is allowed by the type of values stored in the collection.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a dictionary at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2</a>.</p>
<p>The <code>Dictionary</code> class is equipped with a few properties:</p>
<ul>
<li><code>Count</code>, which gets the number of stored elements</li>
<li><code>Keys</code>, which returns the collection of keys</li>
<li><code>Values</code>, which returns the collection of values</li>
</ul>
<p>You can also use some available methods:</p>
<ul>
<li><code>Add</code>, which adds a new element to the dictionary</li>
<li><code>Remove</code>, which removes an element from the dictionary</li>
<li><code>Clear</code>, which removes all the elements from the dictionary</li>
<li><code>ContainsKey</code>, which checks whether the dictionary contains a key</li>
<li><code>ContainsValue</code>, which checks whether the dictionary contains a given value</li>
<li><code>TryGetValue</code>, which tries to get a value for a given key from the dictionary</li>
</ul>
<p>As you can see, many properties and methods are almost the same as in the case of the <code>Hashtable</code> class. The <a id="_idIndexMarker561"/>consistency of naming allows you to easily use various classes without the necessity of learning everything from scratch.</p>
<p class="callout-heading">What about performance?</p>
<p class="callout">You should remember that the performance of getting a value of an element (using an indexer or <code>TryGetValue</code>), updating an existing one (using an indexer), and checking whether the given key exists in the dictionary (<code>ContainsKey</code>) approaches the <em class="italic">O(1)</em> operation. However, the process of checking whether the collection contains a given value (<code>ContainsValue</code>) is the <em class="italic">O(n)</em> operation and requires you to search the entire collection for the particular value.</p>
<p>If you want to iterate through all pairs stored in the collection, you can use a <code>foreach</code> loop. However, the variable that’s used in the loop is an instance of the <code>KeyValuePair</code> generic class with <code>Key</code> and <code>Value</code> properties, allowing you to access the key and the value. This <code>foreach</code> loop is shown in the following code snippet:</p>
<pre class="source-code">
<strong class="bold">foreach</strong> (<strong class="bold">KeyValuePair&lt;string, string&gt; pair</strong> in dictionary)
{
    Console.WriteLine($"{<strong class="bold">pair.Key</strong>}: {<strong class="bold">pair.Value</strong>}");
}</pre> <p>Here, you can also apply what you’ve learned about value tuples and the deconstruct operation. Thus, the preceding <code>foreach</code> loop can be simplified, as shown here:</p>
<pre class="source-code">
foreach (<strong class="bold">(string k, string v)</strong> in dictionary)
{
    Console.WriteLine($"{<strong class="bold">k</strong>}: {<strong class="bold">v</strong>}");
}</pre> <p>As you can see, the C# language is being equipped with more and more useful features that make your code shorter, simpler, and <a id="_idIndexMarker562"/>easier to understand. You should keep an eye on the updates to the language. Good work, C# team – I am looking forward to more!</p>
<p class="callout-heading">Thread-safe version</p>
<p class="callout">Do you remember a thread-safe queue-related class from the previous chapter? If so, the situation looks quite similar in the case of <code>Dictionary</code> because the <code>ConcurrentDictionary</code> class (from the <code>System.Collections.Concurrent</code> namespace) is available.</p>
<p>With this short introduction, let’s start coding! In the following sections, you will find two real-world examples that <a id="_idTextAnchor203"/>use dictionaries fo<a id="_idTextAnchor204"/>r storing data.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor205"/>Example – product location</h2>
<p>The first example we’ll look at is an <a id="_idIndexMarker563"/>application that helps employees of a shop to find a product’s location. Let’s imagine that each employee has a phone with your application on it, which is used to scan a barcode of the product, and the application tells them that the product should be located in area <code>A1</code> or <code>C9</code>. Sounds interesting, doesn’t it?</p>
<p>As the number of products in the shop is often very high, it is necessary to find results very quickly. For this reason, the data of products, together with their locations, is stored in the hash table, using the generic <code>Dictionary</code> class. The key is the barcode (<code>string</code>), while the value is the area code (also <code>string</code>), as shown here:</p>
<pre class="source-code">
<strong class="bold">BARCODE -------&gt; AREA</strong>
5901020304050 -&gt; A1
5910203040506 -&gt; B5
5920304050607 -&gt; C9</pre> <p>First, you create a new collection and add some data:</p>
<pre class="source-code">
<strong class="bold">Dictionary&lt;string, string&gt;</strong> products = new()
{
    { "5901020304050", "A1" },
    { "5910203040506", "B5" },
    { "5920304050607", "C9" }
};
products["5930405060708"] = "D7";</pre> <p>The code shows two ways of adding elements to the collection, namely by passing their data while creating a new instance<a id="_idIndexMarker564"/> of the class and by using the indexer. A third solution also exists and uses the <code>Add</code> method, as shown in the following part of the code:</p>
<pre class="source-code">
string key = "5940506070809";
if (!products.<strong class="bold">ContainsKey</strong>(key))
{
    products.<strong class="bold">Add</strong>(key, "A3");
}</pre> <p>Another solution uses the <code>TryAdd</code> method, as presented here:</p>
<pre class="source-code">
if (!products.<strong class="bold">TryAdd</strong>(key, "B4"))
{
    Console.WriteLine("Cannot add.");
}</pre> <p>In the following part of the code, you present data of all the products that are available in the system. To do so, you use the <code>foreach</code> loop. Before that, you check whether there are any elements in the dictionary. If not, the proper message is presented to the user. Otherwise, keys and values from all pairs are presented in the console:</p>
<pre class="source-code">
Console.WriteLine("All products:");
if (products.<strong class="bold">Count</strong> == 0) { Console.WriteLine("Empty."); }
<strong class="bold">foreach</strong> (<strong class="bold">(string k, string v)</strong> in products)
{
    Console.WriteLine($"{<strong class="bold">k</strong>}: {<strong class="bold">v</strong>}");
}</pre> <p>Now, let’s take a look at the part of the code that makes it possible to find the location of the product by its barcode. To do so, you can use <code>TryGetValue</code> to check whether the element exists. If so, a message with the target location is presented in the console. Otherwise, other information is<a id="_idIndexMarker565"/> shown. The code is presented here:</p>
<pre class="source-code">
Console.Write("\nSearch by barcode: ");
string barcode = Console.ReadLine() ?? string.Empty;
if (products.<strong class="bold">TryGetValue</strong>(barcode, <strong class="bold">out string? location</strong>))
{
    Console.WriteLine($"The product is in: {<strong class="bold">location</strong>}.");
}
else
{
    Console.WriteLine("The product does not exist.");
}</pre> <p>When you run the program, you see a list of all the products in the shop and the program asks you to enter the barcode. After typing it, you receive a message containing the area code. The result that’s shown in the console should be similar to the following:</p>
<pre class="console">
Cannot add.
All products:
5901020304050: A1
5910203040506: B5
5920304050607: C9
5930405060708: D7
5940506070809: A3
Search by barcode: 5901020304050
The product is in: A1.</pre> <p>You’ve just completed the first <a id="_idIndexMarker566"/>example! Let’s proc<a id="_idTextAnchor206"/>e<a id="_idTextAnchor207"/>ed to the next one.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor208"/>Example – user details</h2>
<p>This second example shows you<a id="_idIndexMarker567"/> how to store more complex data in the dictionary. In this scenario, you’ll create an application that shows details of a user based on their identifier, as shown here:</p>
<pre class="source-code">
<strong class="bold">ID   -&gt;</strong><strong class="bold">  FIRST NAME | LAST NAME | PHONE NUMBER</strong>
100  -&gt;  Marcin     | Jamro     | 101-202-303
210  -&gt;  John       | Smith     | 202-303-404
303  -&gt;  Aline      | Weather   | 303-404-505</pre> <p>The program starts with the data of three users. You should be able to enter an identifier and see details of the found user. Of course, the situation of the non-existence of a given user should be handled by presenting the proper information in the console.</p>
<p>First, let’s add the <code>Employee</code> record, which stores data of an employee, namely first name, last name, and phone number. The code is as follows:</p>
<pre class="source-code">
public record <strong class="bold">Employee</strong>(string FirstName, string LastName,
    string PhoneNumber);</pre> <p>Then, create a new instance of the <code>Dictionary</code> class and add data to it:</p>
<pre class="source-code">
<strong class="bold">Dictionary&lt;int, Employee&gt;</strong> employees = new()
{
    { 100, new Employee("Marcin", "Jamro", "101-202-303") },
    { 210, new Employee("John", "Smith", "202-303-404") },
    { 303, new Employee("Aline", "Weather", "303-404-505") }
};</pre> <p>The most interesting operations are performed in the following <code>do-while</code> loop:</p>
<pre class="source-code">
do
{
    Console.Write("Enter the identifier: ");
    string idString = Console.ReadLine() ?? string.Empty;
    if (!int.TryParse(idString, out int id)) { break; }
    if (employees.<strong class="bold">TryGetValue</strong>(id, <strong class="bold">out Employee? Employee</strong>))
    {
        Console.WriteLine(
            "Full name: {0} {1}\nPhone number: {2}\n",
            <strong class="bold">employee.FirstName</strong>,
            <strong class="bold">employee.LastName</strong>,
            <strong class="bold">employee.PhoneNumber</strong>);
    }
    else { Console.WriteLine("Does not exist.\n"); }
}
while (true);</pre> <p>First, the user is asked to enter an identifier of the employee, which is then parsed to the integer value. The loop is <a id="_idIndexMarker568"/>stopped when the provided identifier cannot be parsed to the integer value. Otherwise, the <code>TryGetValue</code> method is used to try to get details of the user. If the user is found (<code>TryGetValue</code> returns <code>true</code>), the details are presented in the console. Otherwise, an error message is shown.</p>
<p>When you run the application and enter some data, you will receive the following result:</p>
<pre class="console">
Enter the identifier: 100
Full name: Marcin Jamro
Phone number: 101-202-303
Enter the identifier: 101
Does not exist.</pre> <p>That’s all! You’ve completed two examples showing how to use dictionaries while developing applications in the<a id="_idIndexMarker569"/> C# language. Do you remember that another kind of dictionary was already mentioned, namely a sorted dictionary? Are you interested in finding out what it is and how you can use it in your programs? If so, move o<a id="_idTextAnchor209"/><a id="_idTextAnchor210"/>n to the next section.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor211"/>Sorted dictionaries</h1>
<p>Both non-generic and generic variants of the hash table-related classes do not keep the order of the elements. For this reason, if you need to present data from the collection sorted by keys, you need to sort<a id="_idIndexMarker570"/> them before presenting them. However, you can use another data structure, known as a <strong class="bold">sorted dictionary</strong>, to solve this problem and <strong class="bold">keep keys sorted all the time</strong>. Therefore, you can easily get the sorted collection if necessary.</p>
<p class="callout-heading">Imagine a sorted dictionary</p>
<p class="callout">If you want to better imagine a sorted dictionary, remember the times from a dozen or so years ago, when the internet was not as popular and widespread as it is today, and at home there was a book on your shelf that allowed you to learn the meaning of a word in another language. How does it work? Let’s assume that you have a Polish-English dictionary, thanks to which you can find out how to translate a specific word from Polish to English, such as <em class="italic">cześć</em> to <em class="italic">hello</em>. You open this book and look for words that start with the letter <em class="italic">c</em>. Found! Now, you are browsing through words starting with <em class="italic">c</em> to find the one you are interested in, namely <em class="italic">cześć</em>. Fortunately, it’s not that complicated because all the words are listed in the dictionary in alphabetical order. And that’s how a sorted dictionary works! You can easily view all the items in the dictionary in alphabetical order. You can also quickly check if the dictionary contains a specific key and what its value is. Today, you just enter a foreign word in a search engine and you instantly know what it means in your language, as well as in probably any other language in the world. You like this kind of technological progress, don’t you?</p>
<p>The sorted dictionary is implemented as the <code>SortedDictionary</code> generic class, available in the <code>System.Collections.Generic</code> namespace. You can specify types for keys and values while creating a new instance of <code>SortedDictionary</code>. An item key cannot be equal to <code>null</code>, but its value can be if it is allowed by the type of values stored in the collection. Moreover, the <a id="_idIndexMarker571"/>class contains similar properties and methods to <code>Dictionary</code>.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a sorted dictionary at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sorteddictionary-2">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sorteddictionary-2</a>.</p>
<p> The exemplary application is as follows:</p>
<pre class="source-code">
<strong class="bold">SortedDictionary&lt;string, string&gt;</strong> dictionary = new()
{
    { "Key #1", "Value #1" },
    { "Key #2", "Value #2" }
};
dictionary.<strong class="bold">Add</strong>("Key #3", "Value #3");
dictionary<strong class="bold">["Key #4"]</strong> = "Value #4";
string value = dictionary<strong class="bold">["Key #1"]</strong>;
dictionary.<code>Count</code>), as well as returning the collection of keys and values (<code>Keys</code> and <code>Values</code>, respectively). Moreover, you can use the available methods, which include the following:</p>
<ul>
<li><code>Add</code>, which adds a new element</li>
<li><code>Remove</code>, which removes an item</li>
<li><code>Clear</code>, which removes all elements</li>
<li><code>ContainsKey</code>, which checks whether the collection contains a particular key</li>
<li><code>ContainsValue</code>, which checks whether the collection contains a given value</li>
<li><code>TryGetValue</code>, which tries to get a value for a given key</li>
</ul>
<p>If you want to iterate through all the pairs stored in the collection, you can use the <code>foreach</code> loop. The variable that’s used in the loop is an instance of <code>KeyValuePair</code> with <code>Key</code> and <code>Value</code> properties, allowing you to access the key and the value.</p>
<p class="callout-heading">What about performance?</p>
<p class="callout">Despite the automatic sorting advantages, the <code>SortedDictionary</code> class has some performance drawbacks compared to <code>Dictionary</code> because retrieval, insertion, and removal are the <em class="italic">O(log n)</em> operations, where <em class="italic">n</em> is the number of elements in the collection, instead of <em class="italic">O(1)</em>.</p>
<p class="callout">Moreover, <code>SortedDictionary</code> is quite similar to <code>SortedList</code>, as described in <a href="B18069_03.xhtml#_idTextAnchor088"><em class="italic">Chapter 3</em></a>, <em class="italic">Arrays and Sorting</em>. However, it differs in memory-related and performance-related results. The retrieval for both these classes is the <em class="italic">O(log n)</em> operation, but insertion and removal for unsorted data is <em class="italic">O(log n)</em> for <code>SortedDictionary</code> and <em class="italic">O(n)</em> for <code>SortedList</code>. Of course, more memory is necessary for <code>SortedDictionary</code> than for <code>SortedList</code>. As you can see, choosing a proper data structure is not an easy task and you should think carefully about the scenarios in which data structures are used and take into account both the pros and cons.</p>
<p>With this short introduction, let’s see <a id="_idIndexMarker572"/>the s<a id="_idTextAnchor212"/>or<a id="_idTextAnchor213"/>ted dictionary in action.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor214"/>Example – encyclopedia</h2>
<p>As an example, let’s create a simple<a id="_idIndexMarker573"/> encyclopedia where you can add entries and show their full content. The encyclopedia can contain millions of entries, so it is crucial to provide its users with the possibility of browsing entries in the correct order, alphabetically by keys, as well as finding entries quickly. For this reason, the sorted dictionary is a good choice.</p>
<p>The concept of the encyclopedia is shown here:</p>
<pre class="source-code">
<strong class="bold">NAME     -&gt; EXPLANATION</strong>
Lancut   -&gt; A city located near Rzeszow, with a castle.
Rzeszow  -&gt; A capital of the Subcarpathian voivodeship.
Warszawa -&gt; A capital city of Poland.
Zakopane -&gt; A city located in Tatra mountains in Poland.</pre> <p>When the program is launched, it presents a simple menu with two options, namely <code>[A]dd</code> and <code>[L]ist</code>. After pressing <em class="italic">A</em>, the application asks you to enter the key and explanation for the entry. If the provided data is correct, a new entry is added to the encyclopedia. If the user presses <em class="italic">L</em>, data of all entries, sorted by keys, is presented in the console. When any other key is<a id="_idIndexMarker574"/> pressed, additional confirmation is shown and, if confirmed, the program exits.</p>
<p>Let’s take a look at the code:</p>
<pre class="source-code">
Console.WriteLine("Welcome to your encyclopedia!\n");
<strong class="bold">SortedDictionary&lt;string, string&gt;</strong> definitions = [];
do
{
    Console.WriteLine("\nChoose option ([A]dd, [L]ist): ");
    ConsoleKeyInfo keyInfo = Console.ReadKey(true);
    if (keyInfo.Key == ConsoleKey.A)
    {
        Console.Write("Enter the key: ");
        string key = Console.ReadLine() ?? string.Empty;
        Console.Write("Enter the explanation: ");
        string explanation = Console.ReadLine()
            ?? string.Empty;
        <strong class="bold">definitions[key] = explanation;</strong>
    }
    else if (keyInfo.Key == ConsoleKey.L)
    {
        <strong class="bold">foreach ((string k, string e) in definitions)</strong>
        {
            Console.WriteLine($"{<strong class="bold">k</strong>}: {<strong class="bold">e</strong>}");
        }
    }
    else
    {
        Console.WriteLine("Do you want to exit? Y or N.");
        if (Console.ReadKey().Key == ConsoleKey.Y)
        {
            break;
        }
    }
}
while (true);</pre> <p>First, a new instance of the <code>SortedDictionary</code> class is created, which represents a collection of pairs with <code>string</code>-based keys and <code>string</code>-based values. Then, the infinite <code>do-while</code> loop is used. Within it, the program waits until the user presses any key. If it is the <em class="italic">A</em> key, a key and an explanation of the entry are obtained from the values entered by the user. Then, a new entry is added to the dictionary using the indexer. Thus, if the entry with the same key <a id="_idIndexMarker575"/>already exists, it will be updated. In the case of pressing the <em class="italic">L</em> key, a <code>foreach</code> loop is used to show all entered entries. When any other key is pressed, another question is presented to the user and the program waits for confirmation. If the user presses <em class="italic">Y</em>, you break out of the loop.</p>
<p>When you run the program, you can enter a few entries, as well as present them. The result from the console can be similar to what’s shown in the following block:</p>
<pre class="console">
Welcome to your encyclopedia!
Choose option ([A]dd, [L]ist):
Enter the key: Zakopane
Enter the explanation: A city located in Tatra mountains in Poland.
Choose option ([A]dd, [L]ist):
Enter the key: Rzeszow
Enter the explanation: A capital of the Subcarpathian voivodeship.
Choose option ([A]dd, [L]ist):
Rzeszow: A capital of the Subcarpathian voivodeship.
Zakopane: A city located in Tatra mountains in Poland.
Choose option ([A]dd, [L]ist):
Do you want to exit? Y or N.</pre> <p>So far, you’ve learned about three dictionary-related classes, namely <code>Hashtable</code>, <code>Dictionary</code>, and <code>SortedDictionary</code>. To make understanding them easier, a few examples were presented, together with detailed explanations.</p>
<p>However, do you know that <a id="_idIndexMarker576"/>some other data structures sto<a id="_idTextAnchor215"/>re just keys, without values? You will learn about th<a id="_idTextAnchor216"/>ese in the next sections.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor217"/>Hash sets</h1>
<p>In many algorithms, it is necessary to perform <a id="_idIndexMarker577"/>operations on sets with various data. However, what<a id="_idIndexMarker578"/> is a <strong class="bold">set</strong>? <strong class="bold">A set is a collection of distinct objects without duplicated elements and without a particular order.</strong> Therefore, you can only get to know whether a given element is in the set or not. These sets are strictly connected with mathematical models and operations, such as union, intersection, subtraction, and symmetric difference. A set can store various data, such as integer or string values. Of course, you can also create a set with instances of a user-defined class or record, as well as add and remove elements from the set at any time.</p>
<p class="callout-heading">Imagine a hash set</p>
<p class="callout">If you want to better visualize a hash set, think for a moment about the game of chance, which is popular in many countries and involves selecting a few numbers that are then drawn from among many available ones. Depending on how many numbers you got from those drawn, you receive a prize. Of course, the chance of matching all the drawn numbers is very, very small. Now, you may be wondering where these collections are here. I’m in a hurry to answer this! There are three sets here, namely a set of all available numbers, a set of randomly drawn numbers, and a set of numbers selected by you. Each set cannot contain any <a id="_idIndexMarker579"/>duplicates. Of course, both the set of randomly drawn numbers and the set of numbers you choose are subsets of the set of all available numbers. How can you check how many numbers you have chosen correctly? It is very easy! Just perform the “intersection” operation on two sets, namely the set of randomly selected numbers and the set of numbers you selected, to obtain the result set. Now, all you have to do is keep your fingers crossed that the number of elements in this result set matches the number of elements in the set of drawn numbers. If that happens, then... you may become very rich because you matched all the drawn numbers. If so, congratulations!</p>
<p>Two exemplary sets are presented in the following figure:</p>
<div><div><img alt="Figure 6.2 – Illustration of sets with integer and string values" src="img/B18069_06_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Illustration of sets with integer and string values</p>
<p>Before seeing sets in action, it is a good idea to remind you of some basic operations that can be performed on two sets, named <strong class="bold">A</strong> and <strong class="bold">B</strong>.</p>
<p>The <strong class="bold">union</strong> (shown on the <a id="_idIndexMarker580"/>left of the<a id="_idIndexMarker581"/> following figure as <strong class="bold">A</strong><strong class="bold">∪</strong><strong class="bold">B</strong>) is <strong class="bold">a set with all elements that </strong><strong class="bold"><a id="_idIndexMarker582"/></strong><strong class="bold">belong to A or B</strong>. The <strong class="bold">intersection</strong> (presented on the right as <strong class="bold">A</strong><strong class="bold">∩</strong><strong class="bold">B</strong>) <strong class="bold">contains only the elements that belong to both A </strong><strong class="bold">and B</strong>:</p>
<div><div><img alt="Figure 6.3 – Illustration of set union and intersection" src="img/B18069_06_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Illustration of set union and intersection</p>
<p>Another common operation is set <strong class="bold">subtraction</strong>. <strong class="bold">The result set of A \ B contains elements that are the members of A and not the members of B</strong>. In the following figure, two examples are <a id="_idIndexMarker583"/>shown, namely <strong class="bold">A \ B</strong> and <strong class="bold">B \ </strong><strong class="bold">A</strong>:</p>
<div><div><img alt="Figure 6.4 – Illustration of set subtraction" src="img/B18069_06_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Illustration of set subtraction</p>
<p>While performing various operations on sets, it is also worth mentioning the <strong class="bold">symmetric difference</strong>, shown in <a id="_idIndexMarker584"/>the following <a id="_idIndexMarker585"/>figure as <strong class="bold">A ∆ B</strong>. The final set can be interpreted as a union of two sets, namely (<strong class="bold">A \ B</strong>) and (<strong class="bold">B \ A</strong>). Therefore, <strong class="bold">it contains elements that belong to only one set, either A or B</strong>. The elements that belong to both sets are excluded from the result:</p>
<div><div><img alt="Figure 6.5 – Illustration of set symmetric difference and the relationships between sets" src="img/B18069_06_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Illustration of set symmetric difference and the relationships between sets</p>
<p>Another important topic is the <strong class="bold">relationship</strong> between sets. <strong class="bold">If every element of B belongs to A, this means that B is a </strong><strong class="bold">subset</strong><strong class="bold"> of A</strong>. This is shown in the preceding diagram, on the right. At the same time, <strong class="bold">A is a </strong><strong class="bold">superset</strong><strong class="bold"> of B</strong>. Moreover, <strong class="bold">if B is a subset of A, but B is not equal to A, B is a </strong><strong class="bold">proper subset</strong><strong class="bold"> of A</strong>, and <strong class="bold">A is a </strong><strong class="bold">proper superset</strong><strong class="bold"> </strong><strong class="bold">of B</strong>.</p>
<p>While developing various kinds of applications in the C# language, you can benefit from high-performance operations provided by the <code>HashSet</code> class from the <code>System.Collections.Generic</code> namespace. The class contains a few properties, including <code>Count</code>, which returns the number of elements in the set.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a hash set at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1</a>.</p>
<p>Moreover, you can use many methods to perform operations of sets. The first group of methods makes it possible to modify the current set (on which the method is called) to create the union (<code>UnionWith</code>), the <a id="_idIndexMarker586"/>intersection (<code>IntersectWith</code>), the subtraction (<code>ExceptWith</code>), and the symmetric difference (<code>SymmetricExceptWith</code>) with the set passed as the parameter.</p>
<p>You can also check the relationship between two sets, such as checking whether the current set (on which the method is called) is a subset (<code>IsSubsetOf</code>), a superset (<code>IsSupersetOf</code>), a proper subset (<code>IsProperSubsetOf</code>) or a proper superset (<code>IsProperSupersetOf</code>) of the set passed as the parameter.</p>
<p>Furthermore, you can verify whether two sets contain the same elements (<code>SetEquals</code>) or whether two sets have at least one common element (<code>Overlaps</code>).</p>
<p>Apart from these operations, you can add a new element to the set (<code>Add</code>), remove a particular element (<code>Remove</code>), remove all elements (<code>Clear</code>), and check whether the given element exists in the set (<code>Contains</code>).</p>
<p class="callout-heading">What about performance?</p>
<p class="callout">Hash sets make it possible to perform a quick lookup for a given item. Thus, checking whether the set contains an item and removing an item are <em class="italic">O(1)</em> operations. As for addition, it is an <em class="italic">O(1)</em> operation if it does not need to increase the internal array. If resizing is necessary, it turns out to be the <em class="italic">O(n)</em> operation, where <em class="italic">n</em> is the number of items.</p>
<p>With this introduction, try to put what you’ve learned into practice. Now, let’s proceed to two examples that show how you can ap<a id="_idTextAnchor218"/><a id="_idTextAnchor219"/>ply hash sets in your applications.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor220"/>Example – coupons</h2>
<p>The first example represents a system that checks whether a one-time coupon has already been used. If so, a suitable <a id="_idIndexMarker587"/>message is presented to the user. Otherwise, the system informs the user that the coupon is valid. It is then marked as used and cannot be used again. Due to the high number of coupons, it is necessary to choose a data structure that allows you to quickly check whether an element exists in a collection. For this reason, a hash set has been chosen as a data structure for storing identifiers of used coupons.</p>
<p>Let’s take a look at the code:</p>
<pre class="source-code">
<strong class="bold">HashSet&lt;int&gt;</strong> usedCoupons = [];
do
{
    Console.Write("Enter the number: ");
    string number = Console.ReadLine() ?? string.Empty;
    if (!int.TryParse(number, out int coupon)) { break; }
    if (usedCoupons.<strong class="bold">Contains</strong>(coupon))
    {
        Console.WriteLine("Already used.");
    }
    else
    {
        usedCoupons.<strong class="bold">Add</strong>(coupon);
        Console.WriteLine("Thank you!");
    }
}
while (true);</pre> <p>First, a new instance of <code>HashSet</code> that stores integer values is created. Then, the majority of operations are performed within the <code>do-while</code> loop. Here, the program waits until the user enters the coupon identifier. If it cannot be parsed to the integer value, you break out of the loop. Otherwise, you check whether the set already contains the coupon identifier (using the <code>Contains</code> method). If so, the suitable information is presented in the console. If it does not exist, you add it to the collection of used coupons (using the <code>Add</code> method) and inform the user about the result.</p>
<p>When you break out of the loop, you just need to show the complete list of identifiers of the used coupons. You can do so<a id="_idIndexMarker588"/> using a <code>foreach</code> loop, iterating over the set, and writing its elements in the console, as shown in the following code:</p>
<pre class="source-code">
Console.WriteLine("\nUsed coupons:");
<strong class="bold">foreach</strong> (int coupon in usedCoupons)
{
    Console.WriteLine(coupon);
}</pre> <p>Now, you can launch the application, enter some data, and see how it works:</p>
<pre class="console">
Enter the number: 100
Thank you!
Enter the number: 101
Thank you! (...)
Enter the number: 101
Already used.
Enter the number:
Used coupons:
100
101
500
345</pre> <p>This is the end of the first example. Let’s proceed to the next one, where you will see a more <a id="_idTextAnchor221"/>c<a id="_idTextAnchor222"/>omplex solution that uses a hash set.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor223"/>Example – swimming pools</h2>
<p>This example presents the system for a SPA center with four swimming pools, namely recreation, competition, thermal, and for kids. Each visitor receives a special wristband that allows them to enter all the <a id="_idIndexMarker589"/>pools. However, it is necessary to scan the wristband upon each user entering any pool. Your program uses such data to create various statistics.</p>
<p>A hash set has been chosen as a data structure for storing unique numbers of wristbands that are scanned at the entrance to each swimming pool. Four sets are used, one per pool. Moreover, they are grouped in the dictionary to simplify and shorten the code, as well as make future modifications easier. To simplify testing the application, the initial data is set randomly. Then, you create statistics, namely the number of visitors by pool type, the most popular pool, the number of people who visited at least one pool, as well as the number of people who visited all the pools.</p>
<p>Let’s start with the <code>PoolTypeEnum</code> enumeration, which represents possible types of swimming pools:</p>
<pre class="source-code">
enum <strong class="bold">PoolTypeEnum</strong>
{
    Recreation,
    Competition,
    Thermal,
    Kids
};</pre> <p>Then, open <code>Program.cs</code> and add the <code>random</code> variable. This will be used to fill the hash set with some random values. The line of code is as follows:</p>
<pre class="source-code">
Random random = new();</pre> <p>In the next part of the code, you create a new instance of <code>Dictionary</code>. This contains four entries. Each key is of the <code>PoolTypeEnum</code> type and each value is of the <code>HashSet&lt;int&gt;</code> type – that is, a set with integer values. The code is shown here:</p>
<pre class="source-code">
<strong class="bold">Dictionary&lt;PoolTypeEnum, HashSet&lt;int&gt;&gt;</strong> tickets = new()
{
    { PoolTypeEnum.Recreation, new() },
    { PoolTypeEnum.Competition, new() },
    { PoolTypeEnum.Thermal, new() },
    { PoolTypeEnum.Kids, new() }
};</pre> <p>After that, you fill the<a id="_idIndexMarker590"/> sets with random values, as shown here:</p>
<pre class="source-code">
for (int i = 1; i &lt; 100; i++)
{
    <strong class="bold">foreach ((PoolTypeEnum p, HashSet&lt;int&gt; t) in tickets)</strong>
    {
        if (random.Next(2) == 1) { <strong class="bold">t.Add(i);</strong> }
    }
}</pre> <p>To do so, you use two loops, namely <code>for</code> and <code>foreach</code>. The first iterates <code>100</code> times and simulates <code>100</code> wristbands. Within it, there is a <code>foreach</code> loop, which iterates through all available pool types. For each of them, you randomly check whether a visitor entered a particular swimming pool. If so, the identifier is added to the proper set.</p>
<p>The remaining code is related to generating various statistics. First, let’s present the number of visitors by pool type. Such a task is very easy because you just need to iterate through the dictionary, as well as write the pool type and the number of elements in the set (using the <code>Count</code> property), as shown here:</p>
<pre class="source-code">
Console.WriteLine("Number of visitors by a pool type:");
<strong class="bold">foreach ((PoolTypeEnum p, HashSet&lt;int&gt; t) in tickets)</strong>
{
    Console.WriteLine($"- {<strong class="bold">p</strong>}: {<strong class="bold">t.Count</strong>}");
}</pre> <p>The next part finds the swimming pool with the maximum number of visitors. This is done using a few extension methods, namely to order the results by the number of elements in the set, in descending order (<code>OrderByDescending</code>), to choose only a pool type (<code>Select</code>), and to take only the first element (<code>FirstOrDefault</code>). Then, you just present the result. The <a id="_idIndexMarker591"/>code for doing this is shown here:</p>
<pre class="source-code">
PoolTypeEnum maxVisitors = tickets
    .<strong class="bold">OrderByDescending</strong>(t =&gt; t.Value.Count)
    .<strong class="bold">Select</strong>(t =&gt; t.Key)
    .<strong class="bold">FirstOrDefault</strong>();
Console.WriteLine($"{maxVisitors} - the most popular.");</pre> <p>Next, you want to get the number of people who visited at least one pool. You perform this task by creating a union of all sets and getting the count of the final set. First, you create a new set and fill it with identifiers regarding the recreation swimming pool. In the following lines of code, you call the <code>UnionWith</code> method to create a union with the following three sets:</p>
<pre class="source-code">
<strong class="bold">HashSet&lt;int&gt; any = new(tickets[PoolTypeEnum.Recreation]);</strong>
any.<strong class="bold">UnionWith</strong>(tickets[PoolTypeEnum.Competition]);
any.<strong class="bold">UnionWith</strong>(tickets[PoolTypeEnum.Thermal]);
any.<strong class="bold">UnionWith</strong>(tickets[PoolTypeEnum.Kids]);
Console.WriteLine($"{any.<strong class="bold">Count</strong>} people visited
    at least one pool.");</pre> <p>The last statistic is the number of people who visited all pools during one visit to the SPA center. You just need to create the intersection of all sets and get the count of the final set. To do so, you create a new set and fill it with identifiers regarding the recreation swimming pool. Then, you call the <code>IntersectWith</code> method to create an intersection with the following three sets. Finally, you get the number of elements in the set using the <code>Count</code> property and present the results, as follows:</p>
<pre class="source-code">
<strong class="bold">HashSet&lt;int&gt; all = new(tickets[PoolTypeEnum.Recreation]);</strong>
all.<strong class="bold">IntersectWith</strong>(tickets[PoolTypeEnum.Competition]);
all.<strong class="bold">IntersectWith</strong>(tickets[PoolTypeEnum.Thermal]);
all.<strong class="bold">IntersectWith</strong>(tickets[PoolTypeEnum.Kids]);
Console.WriteLine($"{all.<strong class="bold">Count</strong>} people visited all pools.");</pre> <p>That’s all! When you run the application, you may receive the following result:</p>
<pre class="console">
Number of visitors by a pool type:
- Recreation: 60
- Competition: 40
- Thermal: 47
- Kids: 45
Recreation - the most popular.
91 people visited at least one pool.
10 people visited all pools.</pre> <p>You’ve just completed two<a id="_idIndexMarker592"/> examples regarding hash sets. It’s a good idea to try to modify the code and add new features on your own to learn more about this data structure. In the n<a id="_idTextAnchor224"/><a id="_idTextAnchor225"/>ext section, we’ll look at “sorted” sets.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor226"/>“Sorted” sets</h1>
<p>The previously described <code>HashSet</code> class can be understood as a dictionary that stores only keys, without values. So, if there is the <code>SortedDictionary</code> class, maybe there is also the <code>SortedSet</code> class? There is! However, can a set be “sorted”? Why is “sorted” written with quotation marks? The<a id="_idIndexMarker593"/> answer turns out to be very simple. By definition, a set stores a collection of distinct objects without duplicated elements and without a particular order. If a set does not support order, how can it be “sorted”? For this reason, <strong class="bold">a “sorted” set can be understood as a combination of </strong><strong class="bold">HashSet</strong><strong class="bold"> and </strong><strong class="bold">SortedList</strong><strong class="bold">, not a </strong><strong class="bold">set itself.</strong></p>
<p class="callout-heading">Imagine a “sorted” set</p>
<p class="callout">If you want to better imagine a “sorted” set, recall the previous example related to the game of chance. To facilitate manual comparison of results, both the set of randomly drawn numbers and the set of numbers selected by you can be “sorted” and shown in ascending order. This is where a “sorted” set comes in handy. It’s very simple and clear, don’t you think?</p>
<p>A “sorted” set can be used if you want to have a <code>SortedSet</code> and is available in the <code>System.Collections.Generic</code> namespace.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find content regarding a "sorted" set at <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1</a>.</p>
<p>It has a set of methods, similar to those already described in the case of the <code>HashSet</code> class, including <code>UnionWith</code>, <code>IntersectWith</code>, <code>ExceptWith</code>, <code>SymmetricExceptWith</code>, <code>Overlaps</code>, <code>IsSubsetOf</code>, <code>IsSupersetOf</code>, <code>IsProperSubsetOf</code>, and <code>IsProperSupersetOf</code>.</p>
<p>It contains additional properties<a id="_idIndexMarker594"/> for returning the minimum and maximum values (<code>Min</code> and <code>Max</code>, respectively). It is also worth mentioning the <code>GetViewBetween</code> method since it returns a <code>SortedSet</code> instance with values from the given range.</p>
<p class="callout-heading">What about performance?</p>
<p class="callout">The “sorted” set is an interesting data structure in terms of its performance. It is a kind of a trade-off between functionalities and performance. Thus, checking whether the collection contains an item as well as removing any item from the collection are <em class="italic">O(log n)</em> operations. For this reason, you should expect worse performance results compared to the data structures described earlier.</p>
<p>Let’s proceed to a simple exampl<a id="_idTextAnchor227"/><a id="_idTextAnchor228"/>e to see how to use a “sorted” set in code.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor229"/>Example – removing duplicates</h2>
<p>As an example, you will create a <a id="_idIndexMarker595"/>simple application that removes duplicates from the list of names. Of course, the comparison of names should be case-insensitive, so it is not allowed to have both <code>Marcin</code> and <code>marcin</code> in the same collection.</p>
<p>To do this, we can use the following code:</p>
<pre class="source-code">
List&lt;string&gt; names =
[
    "Marcin", "Mary", "James", "Albert", "Lily",
    "Emily", "marcin", "James", "Jane"
];
<strong class="bold">SortedSet&lt;string&gt; sorted = new(</strong>
    <strong class="bold">names,</strong>
    <strong class="bold">Comparer&lt;string&gt;.Create((a, b) =&gt;</strong>
        <strong class="bold">a.ToLower().CompareTo(b.ToLower())));</strong>
foreach (string name in sorted)
{
    Console.WriteLine(name);
}</pre> <p>First, a list of names is created and initialized with nine elements, including <code>Marcin</code> and <code>marcin</code>. Then, a new instance<a id="_idIndexMarker596"/> of the <code>SortedSet</code> class is created and two parameters are passed to the constructor, namely the list of names and the case-insensitive comparer. Finally, the collection is iterated through so that you can write names in the console.</p>
<p>When you run the application, you’ll see the following result:</p>
<pre class="console">
Albert
Emily
James
Jane
Lily
Marcin
Mary</pre> <p>Do you know that you can use another variant of the <code>SortedSet</code> constructor and pass only the first parameter, namely the list, without the comparer? In such a case, the default comparer will be <a id="_idIndexMarker597"/>used and will be case-sensitive.</p>
<p>Congratulations – you’ve just co<a id="_idTextAnchor230"/>m<a id="_idTextAnchor231"/>pleted the last example shown in this chapter!</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor232"/>Summary</h1>
<p>This chapter focused on hash tables, dictionaries, and sets. All of these collections are interesting data structures that can be used in various scenarios during the development of many applications. By presenting such collections with detailed descriptions, performance explanations, and examples, you saw that choosing a proper data structure is not a trivial task and requires analyzing performance-related topics.</p>
<p>First, you learned how to use two variants of a <strong class="bold">hash table</strong>, namely non-generic and generic. The huge advantage of these is a very fast lookup for a value based on the key, which is the close <em class="italic">O(1)</em> operation. To achieve this goal, the hash function is used. Moreover, the <strong class="bold">sorted dictionary</strong> was introduced as an interesting solution to solve the problem of unsorted items in the collection and to keep keys sorted all the time.</p>
<p>Afterward, the high-performance solution to <strong class="bold">set operations</strong> was presented. A set can be understood as a collection of distinct objects without duplicated elements and without a particular order. The class that was shown makes it possible to perform various operations on sets, such as union, intersection, subtraction, and symmetric difference. Then, the concept of the <strong class="bold">“sorted” set</strong> was introduced as a sorted collection of distinct objects without duplicated elements.</p>
<p>Do you want to dive deeper into the topic of data structures and algorithms while developing applications in the C# language? If so, proceed to the next chapter, where <strong class="bold">trees</strong> are presented.</p>
</div>
</body></html>