- en: 'Chapter 5: Debugging and Compiling Your Projects'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：调试和编译你的项目
- en: As software developers, one skill that should be learned as early as possible
    is program debugging. This applies to .NET projects but also any other software
    development technology.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发人员，应该尽早学习的一项技能是程序调试。这适用于 .NET 项目，也适用于任何其他软件开发技术。
- en: If you want to get the most out of Visual Studio 2022, you must be familiar
    with its different windows that can help you observe information to fix bugs and
    know how to use as many of the debugging tools it offers, including **breakpoints**.
    A breakpoint offers the functionality to stop the execution of an application,
    allowing you to see the state of each of the objects and corroborate its behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要充分利用 Visual Studio 2022，你必须熟悉其不同的窗口，这些窗口可以帮助你观察信息以修复错误，并了解如何使用它提供的调试工具，包括**断点**。断点提供了停止应用程序执行的功能，让你能够查看每个对象的状态并证实其行为。
- en: That is why, in this chapter, we will talk about debugging in Visual Studio
    2022, the different breakpoints available, the state inspection tools, and which
    are the best scenarios for each one of them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将讨论 Visual Studio 2022 的调试，可用的不同断点，状态检查工具，以及每个工具的最佳使用场景。
- en: 'The topics we will discuss in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Debugging projects in Visual Studio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中调试项目
- en: Exploring breakpoints in Visual Studio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Visual Studio 中的断点
- en: Inspection tools for debugging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试的检查工具
- en: Let's learn about debugging in Visual Studio 2022 to detect possible errors
    in our programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在 Visual Studio 2022 中进行调试，以检测程序中的可能错误。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples shown in this chapter, Visual Studio 2022 must be installed
    with the web development workload, as shown in [*Chapter 1*](B17873_01_ePub.xhtml#_idTextAnchor013),
    *Getting Started with Visual Studio 2022*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中展示的示例，必须安装带有 Web 开发工作负载的 Visual Studio 2022，如[*第 1 章*](B17873_01_ePub.xhtml#_idTextAnchor013)中所示，*开始使用
    Visual Studio 2022*。
- en: Likewise, the code implementation will be performed on the project created in
    [*Chapter 4*](B17873_04_ePub.xhtml#_idTextAnchor052), *Creating Projects and Templates*,
    specifically in the `Program.cs` file, for easier testing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，代码实现将在[*第 4 章*](B17873_04_ePub.xhtml#_idTextAnchor052)中创建的项目上执行，*创建项目和模板*，特别是`Program.cs`文件，以便于测试。
- en: 'You can find the `Program.cs` file with the changes made throughout this chapter
    at the following link: [https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/blob/main/Chapter05/Program.cs](https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/blob/main/Chapter05/Program.cs).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到本章中修改过的`Program.cs`文件：[https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/blob/main/Chapter05/Program.cs](https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/blob/main/Chapter05/Program.cs)。
- en: Debugging projects in Visual Studio
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中调试项目
- en: Before discussing the breakpoint topic in depth in the *Exploring breakpoints
    in Visual Studio 2022* section, it is important that you know some technical aspects
    used in the debugging world, as well as in Visual Studio.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论 *Exploring breakpoints in Visual Studio 2022* 部分的断点主题之前，了解调试世界中以及 Visual
    Studio 中使用的某些技术方面很重要。
- en: Understanding the technical aspects of debugging
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解调试的技术方面
- en: It is important that you know the difference between the terms debugger and
    debugging so that you know what I mean when I mention any of these terms during
    the chapter and the book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 了解调试器和调试之间的区别很重要，这样你才能在我提到这些术语时理解我的意思，无论是本章还是整本书中。
- en: First, the term debugging refers to the action of looking for errors in the
    code. This does not necessarily include the use of a tool such as an IDE. You
    could, for example, search for errors in code written on a piece of paper, and
    you would still be debugging.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，调试这个术语指的是查找代码中的错误的行为。这并不一定包括使用像 IDE 这样的工具。例如，你可以在一张纸上查找代码中的错误，而你仍然在进行调试。
- en: This is usually not feasible, and a tool called a debugger is often used. This
    tool is attached to the application process you are going to run, allowing you
    to analyze your code while the application is running.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常不可行，因此通常会使用一个名为调试器的工具。这个工具会附加到你将要运行的应用程序进程上，允许你在应用程序运行时分析你的代码。
- en: Differentiating between debug mode and run mode
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分调试模式和运行模式
- en: It is essential to differentiate between debug mode and run mode in Visual Studio,
    as they can be confusing to those who touch the IDE for the first time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中区分调试模式和运行模式非常重要，因为这对第一次接触 IDE 的人来说可能会造成混淆。
- en: 'Let''s first analyze debug mode. This option is activated by selecting the
    **Debug** configuration (which is preselected by default) and clicking on the
    green button located in the same space as the project name, as shown in *Figure
    5.1*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先分析调试模式。此选项通过选择 **调试** 配置（默认情况下已预选）并点击位于项目名称相同空间中的绿色按钮来激活，如图 *图 5.1* 所示：
- en: '![Figure 5.1 – Visual Studio''s debug mode option'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – Visual Studio 的调试模式选项'
- en: '](img/Figure_5.01_B17873.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.01_B17873.jpg)'
- en: Figure 5.1 – Visual Studio's debug mode option
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Visual Studio 的调试模式选项
- en: When this option is pressed, the debugger will be attached to the execution
    of the application, which will allow us to use functions, such as stopping at
    a certain breakpoint in our application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下此选项时，调试器将附加到应用程序的执行，这将允许我们使用诸如在应用程序中的特定断点处停止等函数。
- en: 'On the other hand, we can also choose a second configuration in the drop-down
    list, as shown in *Figure 5.2*, called **Release**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们还可以在下拉列表中选择第二个配置，如图 *图 5.2* 所示，称为 **发布**：
- en: '![Figure 5.2 – Visual Studio''s release mode option'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – Visual Studio 的发布模式选项'
- en: '](img/Figure_5.02_B17873.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.02_B17873.jpg)'
- en: Figure 5.2 – Visual Studio's release mode option
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Visual Studio 的发布模式选项
- en: When this option is selected and we proceed to start the execution of the application,
    the debugger will not be attached, which will give you a better idea of how your
    application will behave toward the end user. This implies that you will not be
    able to perform code debugging or see where exceptions have occurred, but you
    will gain a performance improvement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择此选项并继续启动应用程序的执行时，调试器将不会附加，这将让您更好地了解应用程序如何对最终用户表现。这意味着您将无法执行代码调试或查看异常发生的位置，但您将获得性能提升。
- en: Project debugging initialization options
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目调试初始化选项
- en: As part of the debugging and execution options of an application, we must know
    that we have a set of options available to perform our tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序的调试和执行选项的一部分，我们必须知道我们有一组选项可用于执行我们的测试。
- en: 'If you drop down the options next to the green button with the name of your
    project, as shown in *Figure 5.3*, you will be able to see a set of configurations
    for the deployment of your application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您下拉带有您项目名称的绿色按钮旁边的选项，如图 *图 5.3* 所示，您将能够看到一组用于应用程序部署的配置：
- en: '![Figure 5.3 – The server configuration options for debugging'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 调试的服务器配置选项'
- en: '](img/Figure_5.03_B17873.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.03_B17873.jpg)'
- en: Figure 5.3 – The server configuration options for debugging
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 调试的服务器配置选项
- en: For example, the first three options are used to choose which server you want
    to use for testing. By default, a server called **Kestrel** is used. But it is
    also possible to use **IIS Express**, or even **WSL**, if your application is
    more oriented to Linux-based environments.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前三个选项用于选择您想要用于测试的服务器。默认情况下，使用名为 **Kestrel** 的服务器。但也可以使用 **IIS Express**，或者如果您的应用程序更倾向于基于
    Linux 的环境，甚至可以使用 **WSL**。
- en: 'In *Figure 5.4*, we can observe the following options to change the browser,
    enable script debugging, and view the debugging properties of the project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.4* 中，我们可以观察到以下选项来更改浏览器、启用脚本调试以及查看项目的调试属性：
- en: '![Figure 5.4 – Additional options for debugging'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 调试的附加选项'
- en: '](img/Figure_5.04_B17873.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.04_B17873.jpg)'
- en: Figure 5.4 – Additional options for debugging
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 调试的附加选项
- en: These options are useful if, for example, you want to use a particular browser
    to use some of its own tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您，例如，想要使用特定的浏览器来使用其自己的工具，这些选项非常有用。
- en: 'If the application has been configured in debug mode, you will see the buttons
    that allow you to control the execution of the application in the upper part of
    the IDE, as shown in *Figure 5.5*. These buttons, from left to right, are used
    to do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序已配置为调试模式，您将在 IDE 的上半部分看到允许您控制应用程序执行的按钮，如图 *图 5.5* 所示。从左到右，这些按钮用于执行以下操作：
- en: Pause the application
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停应用程序
- en: Stop the application
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止应用程序
- en: Restart the application
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动应用程序
- en: '![Figure 5.5 – Buttons to control the flow of the application'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 控制应用程序流程的按钮'
- en: '](img/Figure_5.5_B17873.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.05_B17873.jpg)'
- en: Figure 5.5 – Buttons to control the flow of the application
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 控制应用程序流程的按钮
- en: Now that we know the existing debugging concepts in Visual Studio, let's analyze
    breakpoints.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Visual Studio 中的现有调试概念，让我们来分析断点。
- en: Exploring breakpoints in Visual Studio
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Visual Studio 中的断点
- en: Breakpoints are a fundamental part of software development. They allow you to
    stop the flow of your application at any point you want to inspect the state of
    your objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 断点是软件开发的基本组成部分。它们允许你在任何想要检查对象状态的地方停止应用程序的流程。
- en: 'To place a breakpoint in Visual Studio, it is enough that we position ourselves
    right next to the numbering of the lines. This will start showing a gray circle
    that will appear and disappear as we move the cursor over the line numbers, as
    shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Visual Studio 中设置断点，我们只需将光标定位在行号旁边即可。这将开始显示一个灰色圆圈，当我们将光标移过行号时，它会出现和消失，如图所示：
- en: '![Figure 5.6 – The location for placing breakpoints in Visual Studio'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 在 Visual Studio 中放置断点的位置'
- en: '](img/Figure_5.06_B17873.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.06 – 设置断点的选项'
- en: Figure 5.6 – The location for placing breakpoints in Visual Studio
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 在 Visual Studio 中放置断点的位置
- en: 'Once we find the line we want to debug, we just need to left-click once, which
    will cause the circle to turn red, as shown in *Figure 5.7*. Once you have done
    this, if you move the cursor away from the circle, you will be able to see how
    it remains as it is, as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到想要调试的行，我们只需单击一次左键，这将导致圆圈变成红色，如图 *图 5.7* 所示。一旦你这样做，如果你将光标移出圆圈，你将能够看到它保持原样，如图所示：
- en: '![Figure 5.7 – Placing a breakpoint'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 设置断点'
- en: '](img/Figure_5.07_B17873.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.07 – 设置断点的选项'
- en: Figure 5.7 – Placing a breakpoint
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 设置断点
- en: 'If we proceed to execute the application with the breakpoint set, we will see
    how the application flow stops immediately after starting the application, as
    shown in *Figure 5.8*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续执行带有断点的应用程序，我们将看到应用程序流程在启动应用程序后立即停止，如图 *图 5.8* 所示：
- en: '![Figure 5.8 – Debugging a breakpoint'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – 调试断点'
- en: '](img/Figure_5.08_B17873.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.08 – 设置断点的选项'
- en: Figure 5.8 – Debugging a breakpoint
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 调试断点
- en: 'Once the application has stopped at the breakpoint, we have different tools
    available that we can use to view the status of the application – for example,
    if we position over a variable that is before the debug line, we will be able
    to see its current status. If it is primitive data, you will see its value immediately,
    while if it is an object, you will be able to go inside its properties to examine
    each one of them, as shown in *Figure 5.9*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序在断点处停止，我们将有不同工具可用，我们可以使用它们来查看应用程序的状态 – 例如，如果我们定位在调试行之前的变量上，我们将能够看到其当前状态。如果是原始数据，你将立即看到其值，而如果是对象，你将能够进入其属性以检查每一个，如图
    *图 5.9* 所示：
- en: '![Figure 5.9 – Examining the properties of an object'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – 检查对象属性'
- en: '](img/Figure_5.09_B17873.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.09 – 设置断点的选项'
- en: Figure 5.9 – Examining the properties of an object
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 检查对象属性
- en: 'There are more options to place breakpoints – for example, if you place yourself
    on one of the gray circles and click on it with the right button, a series of
    breakpoints will appear, which we will analyze in the *Conditional breakpoints*,
    *Temporary breakpoints*, and *Dependent breakpoints* sections so that you can
    insert them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多选项可以设置断点 – 例如，如果你将自己放在一个灰色圆圈上，并用鼠标右键点击它，将会出现一系列断点，我们将在 *条件断点*、*临时断点* 和 *依赖断点*
    部分进行分析，以便你可以插入它们：
- en: '![Figure 5.10 – The options for inserting a breakpoint'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 设置断点的选项'
- en: '](img/Figure_5.10_B17873.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 设置断点的选项'
- en: Figure 5.10 – The options for inserting a breakpoint
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 设置断点的选项
- en: 'Likewise, if you right-click on any breakpoint already placed, you will see
    options to add functionalities to them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你在已放置的任何断点上右键单击，你将看到添加功能到它们的选项：
- en: '![Figure 5.11 – The menu for modifying breakpoints'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – 修改断点的菜单'
- en: '](img/Figure_5.11_B17873.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – 修改断点的菜单'
- en: Figure 5.11 – The menu for modifying breakpoints
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 修改断点的菜单
- en: This is the easiest way to add breakpoints to your project. However, you will
    often need special breakpoints that are activated under certain circumstances,
    so we will proceed to review them in the next sections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是向你的项目添加断点最简单的方法。然而，你经常会需要某些特定情况下才会激活的特殊断点，因此我们将在下一节中继续回顾它们。
- en: Important Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Visual Studio has keyboard shortcuts created for almost all the operations we
    are going to be performing. So, I will mention them for you as *notes*, as we
    move forward throughout this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 为我们即将执行的大多数操作创建了键盘快捷键。因此，随着我们继续本章的阅读，我将为您提及它们作为*笔记*。
- en: It is possible to enter a breakpoint quickly by placing yourself on the line
    you want to debug and pressing the *F9* key.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将光标放在想要调试的行上并按 *F9* 键来快速插入断点。
- en: Navigating between breakpoints
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在断点之间导航
- en: 'Once we know how to place breakpoints in the source code, we can continue the
    execution of the application in different ways through the buttons located in
    the upper part of the menu:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何在源代码中放置断点，我们就可以通过菜单上方的按钮以不同的方式继续应用程序的执行：
- en: '![Figure 5.12 – The debugging options for application execution'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.12 – 应用程序执行的调试选项'
- en: '](img/Figure_5.12_B17873.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.12_B17873.jpg]'
- en: Figure 5.12 – The debugging options for application execution
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 应用程序执行的调试选项
- en: 'Each of them will execute the code as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将按照以下方式执行代码：
- en: '**Step into**: This allows us to execute all the source code line by line.
    If, as part of the flow, we invoke methods to which we have access through the
    source code, we will navigate to it automatically following the line-by-line debugging.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进入**：这允许我们逐行执行所有源代码。如果我们作为流程的一部分调用我们通过源代码可以访问的方法，我们将自动跟随逐行调试导航到它。'
- en: '**Step over**: This allows us to only walk through lines of code in the current
    method and not step into any methods invoked by the current method.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳过**：这允许我们仅遍历当前方法中的代码行，而不进入当前方法调用的任何方法。'
- en: '**Step out**: This button is used in case we are inside a method. It will allow
    us to step out of the execution of the method to return just to the line after
    the invocation of the method.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳出**：此按钮用于我们处于方法内部时。它将允许我们跳出方法的执行，仅返回到方法调用的下一行。'
- en: Important Note
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Each of these options has a shortcut assigned to it:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个选项都分配了一个快捷键：
- en: 'Step into: the *F11* key'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进入：*F11* 键
- en: 'Step over: the *F10* key'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跳过：*F10* 键
- en: 'Step out: *Shift* + *F11* keys'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跳出：*Shift* + *F11* 键
- en: 'If we wish to examine all the breakpoints we have in our project, we can do
    it by activating the breakpoints window. This is done from the **Debug** | **Windows**
    | **Breakpoints** menu, as seen in *Figure 5.13*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望检查项目中所有的断点，可以通过激活断点窗口来完成。这可以通过**调试** | **窗口** | **断点**菜单来完成，如图*图5.13*所示：
- en: '![Figure 5.13 – The option to display the breakpoint window'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.13 – 显示断点窗口的选项'
- en: '](img/Figure_5.13_B17873.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.13_B17873.jpg]'
- en: Figure 5.13 – The option to display the breakpoint window
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 显示断点窗口的选项
- en: This will display a new window that shows a list of all breakpoints placed in
    our project.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个新窗口，显示我们在项目中放置的所有断点的列表。
- en: Conditional breakpoints
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件断点
- en: 'There are times when you will need your breakpoint to stop when certain conditions
    are met. In this case, using conditional breakpoints is the best option. To insert
    a breakpoint of this type, just right-click on the sidebar, which will show you
    the different types of breakpoints available, as shown in the *Navigating between
    breakpoints* section. Select the **Conditional Breakpoint** type, which will open
    a window with preselected options, as shown in *Figure 5.14*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要断点在满足某些条件时停止。在这种情况下，使用条件断点是最佳选择。要插入此类断点，只需在侧边栏上右键单击，这将显示可用的不同类型的断点，如*在断点之间导航*部分所示。选择**条件断点**类型，这将打开一个带有预选选项的窗口，如图*图5.14*所示：
- en: '![Figure 5.14 – The options for conditional breakpoints'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.14 – 条件断点的选项'
- en: '](img/Figure_5.14_B17873.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.14_B17873.jpg]'
- en: Figure 5.14 – The options for conditional breakpoints
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 条件断点的选项
- en: Within a conditional breakpoint, we can configure either a **Conditional Expression**
    condition, a **Hit Count** condition, or a **Filter** condition, which we will
    discuss in the next sections.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件断点中，我们可以配置**条件表达式**条件、**命中次数**条件或**过滤器**条件，这些内容我们将在下一节中讨论。
- en: Important Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To insert a conditional expression, you can use the *Alt* + *F9* keys, followed
    by the *C* key.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入条件表达式，可以使用 *Alt* + *F9* 键，然后按 *C* 键。
- en: Conditional Expression
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件表达式
- en: 'The **Conditional Expression** option, as shown in *Figure 5.15*, will allow
    us to stop the application when a true condition that we have previously specified
    is fulfilled, or when the value of an object changes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.15* 所示的 **条件表达式** 选项，将允许我们在满足我们之前指定的真条件或对象值发生变化时停止应用程序：
- en: '![Figure 5.15 – The types of expression that can be evaluated with conditional
    expressions](img/Figure_5.15_B17873.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 可以使用条件表达式评估的表达式类型](img/Figure_5.15_B17873.jpg)'
- en: Figure 5.15 – The types of expression that can be evaluated with conditional
    expressions
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 可以使用条件表达式评估的表达式类型
- en: In the first case, we can specify a Boolean expression, ranging from the comparison
    of a pair of values to the comparison of complex objects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们可以指定一个布尔表达式，范围从一对值的比较到复杂对象的比较。
- en: 'In *Figure 5.17*, a `for` loop has been created that prints the numbers from
    `1` to `10` to have a better appreciation of the example. Also, I have placed
    a pin on the `i` variable, which you can place by simply hovering over any variable
    while the application is running and clicking on the pin symbol, as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.17* 中，创建了一个 `for` 循环，打印从 `1` 到 `10` 的数字，以便更好地理解示例。此外，我在 `i` 变量上放置了一个图钉，您可以通过在应用程序运行时简单地悬停在任何变量上并点击图钉符号来放置它，如图所示：
- en: '![Figure 5.16 – The types of expressions that can be evaluated with conditional
    expressions'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16 – 可以使用条件表达式评估的表达式类型](img/Figure_5.16_B17873.jpg)'
- en: '](img/Figure_5.16_B17873.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16 – 可以使用条件表达式评估的表达式类型](img/Figure_5.16_B17873.jpg)'
- en: Figure 5.16 – The types of expressions that can be evaluated with conditional
    expressions
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 可以使用条件表达式评估的表达式类型
- en: 'As a condition, we have indicated that we only want to stop the application
    when the value of `i` is greater than the number `5`. After starting the application,
    the breakpoint has stopped, just when `i` has a value of `6`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为条件，我们已指定我们只想在 `i` 的值大于数字 `5` 时停止应用程序。启动应用程序后，断点停止，就在 `i` 的值为 `6` 时：
- en: '![Figure 5.17 – Debugging a conditional expression'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17 – 调试条件表达式](img/Figure_5.17_B17873.jpg)'
- en: '](img/Figure_5.17_B17873.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17 – 调试条件表达式](img/Figure_5.17_B17873.jpg)'
- en: Figure 5.17 – Debugging a conditional expression
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 调试条件表达式
- en: 'In the second case, we can monitor an object, property, or field so that the
    breakpoint stops only when it changes. This can be seen in a practical way in
    *Figure 5.18*, in which the `i` variable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们可以监视一个对象、属性或字段，以便断点仅在它发生变化时停止。这可以在 *图 5.18* 中以实际的方式看到，其中 `i` 变量：
- en: '![Figure 5.18 – Evaluating a conditional expression with the When changed parameter'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.18 – 使用 When changed 参数评估条件表达式](img/Figure_5.18_B17873.jpg)'
- en: '](img/Figure_5.18_B17873.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.18 – 命中计数表达式评估](img/Figure_5.18_B17873.jpg)'
- en: Figure 5.18 – Evaluating a conditional expression with the When changed parameter
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 使用 When changed 参数评估条件表达式
- en: As a result, when the breakpoint is executed for the first time, the value of
    `i` is equal to `1`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当断点第一次执行时，`i` 的值等于 `1`。
- en: Hit Count
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命中计数
- en: 'The `25`, as we can see in *Figure 5.19*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.19* 所见，`25`：
- en: '![Figure 5.19 – Evaluating a Hit Count expression'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – 评估命中计数表达式](img/Figure_5.19_B17873.jpg)'
- en: '](img/Figure_5.19_B17873.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – 命中计数表达式评估](img/Figure_5.19_B17873.jpg)'
- en: Figure 5.19 – Evaluating a Hit Count expression
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 评估命中计数表达式
- en: This will cause the application to stop when `i` has a value of exactly `25`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致应用程序在 `i` 的值为 `25` 时停止。
- en: Filter
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤
- en: 'The last type of conditional breakpoint is the **Filter** condition. This will
    allow us to trigger a breakpoint according to a series of predefined expressions.
    These expressions can be found in the **Filter** box, as shown in *Figure 5.20*,
    and range from the machine name, through processes, to thread properties:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种条件断点是 **过滤** 条件。这将允许我们根据一系列预定义的表达式触发断点。这些表达式可以在 *图 5.20* 中找到的 **过滤** 框中找到，范围从机器名，通过进程，到线程属性：
- en: '![Figure 5.20 – The options for a Filter condition'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.20 – 过滤条件选项](img/Figure_5.20_B17873.jpg)'
- en: '](img/Figure_5.20_B17873.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.20 – 过滤条件选项](img/Figure_5.20_B17873.jpg)'
- en: Figure 5.20 – The options for a Filter condition
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – 过滤条件选项
- en: These are the types of conditional breakpoints, which are very useful for performing
    value comparisons. Now, let's look at function breakpoints.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是条件断点的类型，对于执行值比较非常有用。现在，让我们看看函数断点。
- en: Function breakpoints
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数断点
- en: The **Function Breakpoint** type, as its name indicates, will allow us to debug
    a method when it is executed, even if we have not set a breakpoint as we did in
    the *Conditional breakpoints* section. This is very useful if you have hundreds
    of lines of code and know the name of the function that you want to debug.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数断点**类型，正如其名称所示，将允许我们在方法执行时进行调试，即使我们没有像在“条件断点”部分那样设置断点。如果你有成百上千行的代码并且知道你想要调试的函数名称，这将非常有用。'
- en: 'Unlike the breakpoints we saw in the *Conditional breakpoints* section, this
    breakpoint is placed in a different way. First, as seen in *Figure 5.21*, you
    can go to the **Debug** | **New Breakpoint** | **Function Breakpoint** menu and
    insert in the window the name of the function in which we want to set the breakpoint,
    instead of placing the red dot in the code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在“条件断点”部分看到的断点不同，这个断点是以不同的方式放置的。首先，如*图 5.21*所示，你可以转到**调试** | **新建断点** | **函数断点**菜单，并在窗口中插入我们想要设置断点的函数名称，而不是在代码中放置红色圆点：
- en: '![Figure 5.21 – Adding a function breakpoint from the Debug menu'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.21 – 从调试菜单添加函数断点'
- en: '](img/Figure_5.21_B17873.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.21_B17873.jpg]'
- en: Figure 5.21 – Adding a function breakpoint from the Debug menu
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 从调试菜单添加函数断点
- en: 'The next way is to add a breakpoint function from the **Breakpoints** window,
    as shown in *Figure 5.22*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种方式是从**断点**窗口添加断点函数，如*图 5.22*所示：
- en: '![Figure 5.22 – Adding a function breakpoint from the Debug menu'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.22 – 从调试菜单添加函数断点'
- en: '](img/Figure_5.22_B17873.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.22_B17873.jpg]'
- en: Figure 5.22 – Adding a function breakpoint from the Debug menu
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – 从调试菜单添加函数断点
- en: 'Once we click on the `Program.cs` file, which has the following format:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击了具有以下格式的`Program.cs`文件：
- en: '[PRE0]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we know the name of the function to be evaluated, we can enter it in the
    **Function Name** box. We can do this in several ways:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道要评估的函数名称，我们可以在**函数名称**框中输入它。我们可以通过几种方式来做这件事：
- en: Typing the name of the function
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入函数名称
- en: Specifying the function name with a specific overload
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定的重载指定函数名称
- en: Specifying the `dll` name if we have the source code for it
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有源代码，指定`dll`名称
- en: 'In our example, we will place only the name of the `StopHere` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将只放置`StopHere`函数的名称：
- en: '![Figure 5.23 – Filling in the name of the function we are interested in debugging'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.23 – 填写我们感兴趣调试的函数名称'
- en: '](img/Figure_5.23_B17873.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.23_B17873.jpg]'
- en: Figure 5.23 – Filling in the name of the function we are interested in debugging
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 – 填写我们感兴趣调试的函数名称
- en: 'With the data established, we will proceed to execute the application, having
    previously called this new method. This will cause the application to stop at
    the start of the method (which we specified in *Figure 5.23*), as seen in *Figure
    5.24*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了数据后，我们将执行应用程序，在此之前已经调用了这个新方法。这将导致应用程序在方法开始处停止（如*图 5.23*中指定），如图 5.24*所示：
- en: '![Figure 5.24 – A demonstration of the breakpoint being executed through a
    function breakpoint'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.24 – 通过函数断点执行断点的演示'
- en: '](img/Figure_5.24_B17873.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.24_B17873.jpg]'
- en: Figure 5.24 – A demonstration of the breakpoint being executed through a function
    breakpoint
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24 – 通过函数断点执行断点的演示
- en: Important Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is possible to add a function breakpoint by pressing the *Ctrl* + *K* keys,
    followed by the *B* key.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过按下*Ctrl* + *K*键，然后按*B*键来添加函数断点。
- en: Undoubtedly, this type of breakpoint will make our life easier when we want
    to debug methods quickly. In case you want to trigger breakpoints based on the
    data of an object, you can use the data breakpoints, which we will see next.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，当我们想要快速调试方法时，这种类型的断点会使我们的生活变得更轻松。如果你想要根据对象的数据来触发断点，你可以使用数据断点，我们将在下一节中看到。
- en: Data breakpoints
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据断点
- en: If you want to be able to place breakpoints when the properties of an object
    change, then data breakpoints are your best option. If you try to add one of these
    breakpoints from the **Breakpoints** window, you will see that the option is disabled.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要能够在对象属性更改时放置断点，那么数据断点是你最好的选择。如果你尝试从**断点**窗口添加这样的断点，你会看到该选项被禁用。
- en: 'This is because we first need to place a breakpoint at a point before we want
    to start monitoring the property. Once this is done, start the application until
    the breakpoint is activated, and in one of the windows called `EnvironmentName`
    property of the `app` object:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们首先需要在想要开始监控属性之前放置一个断点。一旦完成，启动应用程序直到断点被激活，在名为 `EnvironmentName` 属性的 `app`
    对象的一个窗口中：
- en: '![Figure 5.25 – Adding a data breakpoint to break when the EnvironmentName
    property changes'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.25 – 当 EnvironmentName 属性更改时添加数据断点'
- en: '](img/Figure_5.25_B17873.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.25_B17873.jpg)'
- en: Figure 5.25 – Adding a data breakpoint to break when the EnvironmentName property
    changes
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25 – 当 EnvironmentName 属性更改时添加数据断点
- en: 'Once we select the option, we will see how a new breakpoint is created automatically,
    which will detect when the property we have specified changes, as shown in *Figure
    5.26*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择该选项，我们将看到如何自动创建一个新的断点，该断点将检测我们指定的属性何时发生变化，如图 5.26 所示：
- en: '![Figure 5.26 – The data breakpoint being created in the Breakpoints window'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.26 – 在断点窗口中创建的数据断点'
- en: '](img/Figure_5.26_B17873.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.26_B17873.jpg)'
- en: Figure 5.26 – The data breakpoint being created in the Breakpoints window
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26 – 在断点窗口中创建的数据断点
- en: 'Let''s say, subsequently, we proceed to modify the property data – for example,
    through the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，随后我们继续修改属性数据 – 例如，通过以下代码：
- en: '[PRE4]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, when we run the application, we will see how the breakpoint previously
    placed is reached, as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行应用程序时，我们将看到之前放置的断点是如何被达到的，如图所示：
- en: '![Figure 5.27 – A demonstration of a break when the property has been changed'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.27 – 属性更改时断点的演示'
- en: '](img/Figure_5.27_B17873.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.27_B17873.jpg)'
- en: Figure 5.27 – A demonstration of a break when the property has been changed
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27 – 属性更改时断点的演示
- en: Finally, you will see that when you restart the application or stop it, the
    breakpoint will disappear from the window. This is because the object reference
    is lost.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会发现当你重新启动应用程序或停止它时，断点将从窗口中消失。这是因为对象引用已丢失。
- en: Dependent breakpoints
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖断点
- en: This type of breakpoint is a special breakpoint that will only be executed if
    another breakpoint is reached first. Perhaps in a simple scenario, it is not very
    useful, but in complex scenarios, where hundreds of functionalities come into
    play, it can be of great help.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的断点是一种特殊断点，它只有在另一个断点首先被达到时才会执行。也许在简单场景中，它不是非常有用，但在复杂场景中，当数百个功能发挥作用时，它可以非常有帮助。
- en: For example, imagine that you have a method that is invoked in several places
    in your application, and you are testing a new functionality that invokes it.
    If you were to place a normal breakpoint on the method, it would stop every time
    it is invoked. With a dependent breakpoint, you can specify that you only want
    to stop execution if the breakpoint of your new functionality is reached.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下你有一个在应用程序的几个地方被调用的方法，你正在测试一个调用它的新功能。如果你要在该方法上放置一个普通断点，它会在每次被调用时停止。使用依赖断点，你可以指定只有当你的新功能断点被达到时才停止执行。
- en: 'To demonstrate this functionality, I have added a couple of methods to the
    `Program.cs` file, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示此功能，我在 `Program.cs` 文件中添加了几个方法，如下所示：
- en: '[PRE5]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The idea of the `CommonMethod` function is that we can see the content of a
    string passed as a parameter and know at what point the breakpoint has stopped.
    With this in mind, let''s add some additional lines in which we will first call
    `CommonMethod`, then `NewMethod`, and finally, `CommonMethod` again:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommonMethod` 函数的思路是我们可以看到作为参数传递的字符串的内容，并知道断点在哪个点停止。考虑到这一点，让我们添加一些额外的行，我们将首先调用
    `CommonMethod`，然后调用 `NewMethod`，最后再次调用 `CommonMethod`：'
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To place a dependent breakpoint, we will first place a normal breakpoint in
    the line of code on which we want to depend – that is, the one that first must
    be executed for the dependent breakpoint to be executed. In our example, we will
    place it in the `NewMethod` functionality, since it is the method we want to test,
    as shown in *Figure 5.28*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置一个依赖断点，我们首先将在我们想要依赖的代码行上放置一个普通断点 – 即，必须首先执行以使依赖断点执行的断点。在我们的例子中，我们将它放在 `NewMethod`
    功能中，因为它是我们想要测试的方法，如图 5.28 所示：
- en: '![Figure 5.28 – The placement of the breakpoint on which a dependent breakpoint
    will depend'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.28 – 依赖断点的断点位置'
- en: '](img/Figure_5.28_B17873.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.28_B17873.jpg)'
- en: Figure 5.28 – The placement of the breakpoint on which a dependent breakpoint
    will depend
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28 – 依赖断点所依赖的断点放置
- en: 'Then, you must right-click on the line where you want to create the dependent
    breakpoint, as shown in *Figure 5.29*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须在想要创建依赖断点的行上右键单击，如图 *图5.29* 所示：
- en: '![Figure 5.29 – Inserting a dependent breakpoint'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.29 – 插入依赖断点'
- en: '](img/Figure_5.29_B17873.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.29_B17873.jpg)'
- en: Figure 5.29 – Inserting a dependent breakpoint
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.29 – 插入依赖断点
- en: 'This option will display the **Breakpoint Settings** window, where you will
    be asked which breakpoint you want to depend on to launch the dependent breakpoint.
    In our example, we will select the only breakpoint that is part of our project,
    as shown here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将显示 **“断点设置”** 窗口，您将被告知要依赖哪个断点来启动依赖断点。在我们的示例中，我们将选择我们项目中唯一的断点，如图所示：
- en: '![Figure 5.30 – A list of breakpoints on which we can depend for dependent
    breakpoint execution'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.30 – 我们可以依赖以执行依赖断点的断点列表'
- en: '](img/Figure_5.30_B17873.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.30_B17873.jpg)'
- en: Figure 5.30 – A list of breakpoints on which we can depend for dependent breakpoint
    execution
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.30 – 我们可以依赖以执行依赖断点的断点列表
- en: 'Once this window is closed, you will see how a special breakpoint is created
    that (if you hover over it) will tell you on which other breakpoint it depends,
    as shown here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此窗口关闭，您将看到如何创建一个特殊的断点，如果您将其悬停，它将告诉您它依赖于哪个其他断点，如图所示：
- en: '![Figure 5.31 – A view of a dependent breakpoint'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.31 – 依赖断点的视图'
- en: '](img/Figure_5.31_B17873.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.31_B17873.jpg)'
- en: Figure 5.31 – A view of a dependent breakpoint
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.31 – 依赖断点的视图
- en: 'Finally, when running the application, you will see how it stops first on the
    `NewMethod` call and not on `CommonMethod`, even though it has been invoked first.
    If you continue the execution, the dependent breakpoint will stop, showing the
    **After invocation of NewMethod()** message, as shown in *Figure 5.32*:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当运行应用程序时，您将看到它首先在 `NewMethod` 调用处停止，而不是在首先调用的 `CommonMethod` 处。如果您继续执行，依赖断点将停止，并显示
    **“NewMethod() 调用之后”** 消息，如图 *图5.32* 所示：
- en: '![Figure 5.32 – The execution of a dependent breakpoint'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.32 – 依赖断点的执行'
- en: '](img/Figure_5.32_B17873.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.32_B17873.jpg)'
- en: Figure 5.32 – The execution of a dependent breakpoint
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.32 – 依赖断点的执行
- en: As you can see, this type of breakpoint can be very helpful to avoid constant
    method invocation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这种类型的断点可以非常有帮助，以避免不断的方法调用。
- en: Temporary breakpoints
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时断点
- en: 'Temporary breakpoints, as their name indicates, are breakpoints that are automatically
    deleted once they are executed. To place one of these, you must right-click on
    the breakpoint line and select the **Insert Temporary Breakpoint** option, as
    shown in *Figure 5.33*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，临时断点是一旦执行就会自动删除的断点。要放置其中一个，您必须在断点行上右键单击并选择 **“插入临时断点”** 选项，如图 *图5.33*
    所示：
- en: '![Figure 5.33 – The menu to insert a temporary breakpoint'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.33 – 插入临时断点的菜单'
- en: '](img/Figure_5.33_B17873.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.33_B17873.jpg)'
- en: Figure 5.33 – The menu to insert a temporary breakpoint
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.33 – 插入临时断点的菜单
- en: If you run the application, you will see that once the application has stopped
    at the breakpoint, it will be automatically deleted. This type of breakpoint can
    be used when we want to evaluate, for example, the first iteration of a cycle.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您将看到一旦应用程序在断点处停止，它将自动删除。这种类型的断点可以在我们想要评估循环的第一个迭代时使用。
- en: Important Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To insert a temporary breakpoint quickly, use the *F9* + *Shift* + *Alt* keys,
    followed by the *T* key.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速插入临时断点，请使用 *F9* + *Shift* + *Alt* 键，然后按 *T* 键。
- en: Now that we have examined the different types of breakpoints available in Visual
    Studio, let's see how we can take advantage of them using different inspection
    tools, which we will see in the next section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了 Visual Studio 中可用的不同类型的断点，让我们看看我们如何利用它们使用不同的检查工具，这些工具将在下一节中介绍。
- en: Inspection tools for debugging
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试检查工具
- en: When working with breakpoints, it is important that we know where to find the
    information we want to visualize and to know whether it is correct or not. For
    this, within Visual Studio, we have a series of windows that will allow us to
    visualize different types of information. So, let's look at them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用断点时，了解我们想要可视化的信息在哪里以及它是否正确非常重要。为此，在 Visual Studio 中，我们有一系列窗口，将允许我们可视化不同类型的信息。因此，让我们来看看它们。
- en: Watch window
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察窗口
- en: The **Watch** window will allow us to keep track of the values of variables
    or properties while we execute our code step by step. It is especially useful
    when we have pieces of code that are repeated several times, such as cycles or
    common methods. To access this window, we must first place a breakpoint in the
    code and execute the application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察**窗口将允许我们在逐步执行代码时跟踪变量或属性值。当我们有多次重复的代码片段，如循环或常用方法时，这尤其有用。要访问此窗口，我们必须首先在代码中设置一个断点并执行应用程序。'
- en: 'Once the application stops at the breakpoint, we will be able to deploy the
    **Debug** | **Windows** menu. This will show us a set of new debugging windows
    that we can only access while running the application. Let''s select the **Watch**
    option to choose a window, as shown in *Figure 5.34*:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序在断点处停止，我们就可以部署**调试** | **窗口**菜单。这将显示一组新的调试窗口，我们只能在应用程序运行时访问它们。让我们选择**观察**选项来选择一个窗口，如图*图5.34*所示：
- en: '![Figure 5.34 – The menu to reach the Watch windows'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.34 – 达到观察窗口的菜单'
- en: '](img/Figure_5.34_B17873.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.34_B17873.jpg]'
- en: Figure 5.34 – The menu to reach the Watch windows
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.34 – 达到观察窗口的菜单
- en: 'Once the window has been opened, we can add the name of different variables
    and properties that we want to monitor. As long as we have entered a valid variable
    name for the scope we are in, we will be shown its corresponding value in the
    **Value** column, as shown in *Figure 5.35*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦窗口已打开，我们可以添加我们想要监控的不同变量和属性的名称。只要我们为当前作用域输入了有效的变量名，我们将在**值**列中看到其对应的值，如图*图5.35*所示：
- en: '![Figure 5.35 – The monitoring of variable values and properties through the
    Watch window'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.35 – 通过观察窗口监控变量值和属性'
- en: '](img/Figure_5.35_B17873.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.35_B17873.jpg]'
- en: Figure 5.35 – The monitoring of variable values and properties through the Watch
    window
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.35 – 通过观察窗口监控变量值和属性
- en: Another very simple way to add variables to a **Watch** window is to right-click
    on the variable you want to monitor when the application is running and select
    the **Add Watch** option.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种非常简单的方法是将变量添加到**观察**窗口中，是在应用程序运行时右键单击要监控的变量，并选择**添加观察**选项。
- en: Important Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To access any **Watch** window quickly, you can use the *Ctrl* + *Alt* + *W*
    shortcut, followed by the window number (from *1* to *4*).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速访问任何**观察**窗口，你可以使用*Ctrl* + *Alt* + *W*快捷键，然后输入窗口编号（从*1*到*4*）。
- en: QuickWatch
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速观察
- en: 'The `for` loop (seen in the *Hit Count* section), as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如此可见的`for`循环（在*击中计数*部分中看到）：
- en: '![Figure 5.36 – The QuickWatch option from the Debug menu'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.36 – 从调试菜单中选择快速观察选项'
- en: '](img/Figure_5.36_B17873.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.36_B17873.jpg]'
- en: Figure 5.36 – The QuickWatch option from the Debug menu
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.36 – 从调试菜单中选择快速观察选项
- en: This option will activate a modal window, which means that we will not be able
    to continue running the application until we close it. In this window, we will
    be able to see data such as the name of the expression, the value, and the type
    of data we are evaluating.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将激活一个模态窗口，这意味着我们无法继续运行应用程序，直到我们关闭它。在这个窗口中，我们将能够看到诸如表达式名称、值和数据类型等数据。
- en: 'Something very useful in this window is that we will be able to modify the
    expression. This means that we will be able to evaluate other variables and can
    even execute some operations that we want to test. In *Figure 5.37*, we see this
    in action, having entered a new expression to evaluate whether its result is `true`
    or `false`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在此窗口中，非常有用的一点是我们将能够修改表达式。这意味着我们将能够评估其他变量，甚至可以执行一些我们想要测试的操作。在*图5.37*中，我们看到这是如何实现的，我们输入了一个新的表达式来评估其结果是否为`true`或`false`：
- en: '![Figure 5.37 – Modifying expressions in the QuickWatch window'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.37 – 在快速观察窗口中修改表达式'
- en: '](img/Figure_5.37_B17873.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.37_B17873.jpg]'
- en: Figure 5.37 – Modifying expressions in the QuickWatch window
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.37 – 在快速观察窗口中修改表达式
- en: As we can see, this offers a huge advantage, since we can test variables and
    properties that are quickly available in real time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这提供了巨大的优势，因为我们可以在实时中快速测试变量和属性。
- en: Important Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can use the *Shift* + *F9* shortcut to access the **QuickWatch** window
    quickly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*Shift* + *F9*快捷键快速访问**快速观察**窗口。
- en: The Autos and Locals windows
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动和局部窗口
- en: The **Autos** and **Locals** windows allow us to view information about variables
    and properties without the need to add them somewhere as with the **Watch** window.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动**和**局部**窗口允许我们查看变量和属性信息，而无需像**观察**窗口那样将它们添加到某个地方。'
- en: However, these have a specific scope. While the **Autos** window shows the value
    of the variables around the breakpoint we have placed, the **Locals** window will
    show values only for the current scope – that is, usually the function or method
    in which the breakpoint is located.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些窗口具有特定的作用域。当 **Autos** 窗口显示我们放置断点周围的变量值时，**局部变量** 窗口将只显示当前作用域的值 – 也就是说，通常是断点所在的函数或方法。
- en: Another important point about these windows is that they will only be shown
    when we run the application and after we have placed a breakpoint.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些窗口的另一个重要点是，它们只有在运行应用程序并放置断点后才会显示。
- en: 'For the demonstration of this window pair, I have added a new method to our
    `Program.cs` file and placed a breakpoint, as shown in *Figure 5.38*:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这对窗口，我在我们的 `Program.cs` 文件中添加了一个新方法并放置了一个断点，如图 *5.38* 所示：
- en: '![Figure 5.38 – The TestLocalsAndAutos method, with a breakpoint placed to
    demonstrate the Locals and Autos windows](img/Figure_5.38_B17873.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.38 – 测试 TestLocalsAndAutos 方法，放置断点以演示局部变量和 Autos 窗口](img/Figure_5.38_B17873.jpg)'
- en: Figure 5.38 – The TestLocalsAndAutos method, with a breakpoint placed to demonstrate
    the Locals and Autos windows
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.38 – 测试 TestLocalsAndAutos 方法，放置断点以演示局部变量和 Autos 窗口
- en: 'Once we invoke the method and only when the application is running, we will
    be able to display the windows through the **Debug** | **Windows** | **Autos**
    menu and the **Debug** | **Windows** | **Locals** menu:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调用该方法，并且只有当应用程序正在运行时，我们才能通过 **调试** | **窗口** | **Autos** 菜单和 **调试** | **窗口**
    | **局部变量** 菜单来显示窗口：
- en: '![Figure 5.39 – Accessing the Autos and Locals windows from the Debug menu'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.39 – 从调试菜单访问 Autos 和局部变量窗口'
- en: '](img/Figure_5.39_B17873.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.39_B17873.jpg)'
- en: Figure 5.39 – Accessing the Autos and Locals windows from the Debug menu
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.39 – 从调试菜单访问 Autos 和局部变量窗口
- en: 'Let''s first examine the `i` and `currentString` variables, which belong to
    the `TestLocalsAndAutos` method:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查 `i` 和 `currentString` 变量，它们属于 `TestLocalsAndAutos` 方法：
- en: '![Figure 5.40 – The Locals window'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.40 – 局部变量窗口'
- en: '](img/Figure_5.40_B17873.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.40_B17873.jpg)'
- en: Figure 5.40 – The Locals window
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.40 – 局部变量窗口
- en: 'On the other hand, if we look at the `i` variable, since it is the information
    that is in the scope of the breakpoint, which means the `for` loop:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们查看 `i` 变量，因为它是在断点作用域内的信息，这意味着 `for` 循环：
- en: '![Figure 5.41 – The Autos window'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.41 – Autos 窗口'
- en: '](img/Figure_5.41_B17873.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.41_B17873.jpg)'
- en: Figure 5.41 – The Autos window
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.41 – Autos 窗口
- en: This pair of windows is tremendously useful to see all the available information
    on our variables at a glance.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这对窗口非常有用，可以一眼看到我们变量的所有可用信息。
- en: Important Note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'It is possible to display these windows through the following shortcuts:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下快捷键显示这些窗口：
- en: '**Autos**: *Ctrl* + *D*, followed by the *A* key'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**Autos**: *Ctrl* + *D*，然后按 *A* 键'
- en: '**Locals**: *Ctrl* + *D*, followed by the *L* key'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部变量**: *Ctrl* + *D*，然后按 *L* 键'
- en: Call stacks
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用栈
- en: Although the use of windows that we saw in the *Watch window*, *QuickWatch*,
    and *The Autos and Locals windows* sections is the most-used method of error correction,
    we also have some others to keep track of the invocation flow between our methods.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在 *监视窗口*、*快速监视* 和 *Autos 和局部变量窗口* 部分看到的窗口使用方法是错误纠正中最常用的方法，但我们还有一些其他方法来跟踪方法之间的调用流程。
- en: One of such window is called **Call Stack**, which when we place a breakpoint,
    will show the stack of calls that have been made until arriving at the same one.
    To show the window, we must select the option from **Debug** | **Windows** | **Call
    Stack**. This menu item will only be available while the application is running,
    but if you want the window to show up for each debug session, you can use the
    thumbtack/pin icon to dock it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个这样的窗口称为 **调用栈**，当我们放置断点时，将显示到达相同点的调用堆栈。要显示窗口，我们必须从 **调试** | **窗口** | **调用栈**
    中选择选项。此菜单项仅在应用程序运行时可用，但如果你希望窗口在每次调试会话中显示，可以使用图钉图标将其停靠。
- en: 'In *Figure 5.42*, we have executed the same code as that in the *The Autos
    and Locals windows* section, stopping at the same breakpoint. As we can see in
    the following figure, the **Call Stack** window shows the line of code where we
    are once the application has stopped due to the breakpoint, as well as the set
    of calls between methods that have been made to reach the breakpoint:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.42* 中，我们执行了与 *自动和局部变量窗口* 部分相同的代码，并在相同的断点处停止。如图所示，**调用栈** 窗口显示了应用程序由于断点而停止时所在的代码行，以及为达到断点而调用的方法之间的调用集合：
- en: '![Figure 5.42 – The Call Stack window'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.42 – 调用栈窗口'
- en: '](img/Figure_5.42_B17873.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.42_B17873.jpg)'
- en: Figure 5.42 – The Call Stack window
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.42 – 调用栈窗口
- en: In *Figure 5.42*, we can also see the state of the application in each one of
    the calls if we double-click on any of them. This will allow us to see the values
    of properties and variables at some specific point in the flow of the application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.42* 中，如果我们双击任何一个调用，我们还可以看到每个调用中应用程序的状态。这将使我们能够看到在应用程序流程中的某个特定点的属性和变量的值。
- en: This will take us to the code section from where we invoke the method, and it
    will be highlighted with a different color so that we don't get confused with
    the colors of the breakpoint.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到调用方法的代码部分，并且将以不同的颜色突出显示，以便我们不会与断点的颜色混淆。
- en: Important Note
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To display the **Call Stack** window, you can also press the *Ctrl* + *Alt*
    + *C* keys.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示 **调用栈** 窗口，您也可以按下 *Ctrl* + *Alt* + *C* 键。
- en: Immediate window
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立即窗口
- en: Another window of great interest is the **Immediate** window. This window, which
    we can open from the **Debug** | **Windows** | **Immediate** menu, will allow
    us to make evaluations of expressions, execute statements, and print values of
    variables and properties.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有兴趣的窗口是 **立即** 窗口。这个窗口，我们可以从 **调试** | **窗口** | **立即** 菜单中打开，将允许我们评估表达式、执行语句，并打印变量和属性的值。
- en: When you open this window, you will surely be surprised to see nothing inside
    it. This is because this window will allow you to write on it, to enter the name
    of a variable or property, and even invoke methods (if they are within the scope),
    added to the fact that you will have available all the potential of IntelliSense
    while you write your expressions. IntelliSense is Visual Studio's auto-completion
    help enhanced with artificial intelligence, and we will talk more about it in
    [*Chapter 7*](B17873_07_ePub.xhtml#_idTextAnchor088), *Coding Efficiently with
    AI and Code Views*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开这个窗口时，您一定会对里面什么都没有感到惊讶。这是因为这个窗口将允许您在上面写入，输入变量或属性的名称，甚至调用方法（如果它们在作用域内），加上您在编写表达式时将拥有所有潜在的
    IntelliSense 功能。IntelliSense 是 Visual Studio 的自动完成帮助，它通过人工智能得到增强，我们将在 [*第 7 章*](B17873_07_ePub.xhtml#_idTextAnchor088)，*使用
    AI 和代码视图高效编码* 中更多地讨论它。
- en: 'In *Figure 5.43*, the invocation of the `TestLocalsAndAutos` method has been
    executed again, and we have obtained a substring of the main `currentString` string:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.43* 中，`TestLocalsAndAutos` 方法的调用再次执行，我们获得了主 `currentString` 字符串的子串：
- en: '![Figure 5.43 – The Immediate Window'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.43 – 立即窗口'
- en: '](img/Figure_5.43_B17873.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.43_B17873.jpg)'
- en: Figure 5.43 – The Immediate Window
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.43 – 立即窗口
- en: A great advantage of this window is that we can execute as many expressions
    as we want, keeping all the list of results we obtain, as well as the expressions
    entered.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口的一个很大的优点是，我们可以执行尽可能多的表达式，保留我们获得的所有结果列表以及输入的表达式。
- en: Important Note
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can display the **Immediate** window if you press the *Ctrl* + *Alt* + *I*
    keys.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按下 *Ctrl* + *Alt* + *I* 键，可以显示 **立即** 窗口。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Visual Studio has many options for debugging source code. In this chapter, we
    have learned what breakpoints are, the different types of breakpoints, and the
    associated windows that we can activate to keep track of data in variables and
    properties. This information has been of utmost importance, since it will help
    you to solve problems in your code when you face them.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 为调试源代码提供了许多选项。在本章中，我们学习了什么是断点，不同类型的断点，以及我们可以激活以跟踪变量和属性数据的关联窗口。这些信息至关重要，因为它将帮助您在遇到问题时解决代码中的问题。
- en: In the next chapter, [*Chapter 6*](B17873_06_ePub.xhtml#_idTextAnchor081)*,
    Adding Code Snippets*, you will learn about the concept of code snippets, which
    allow you to reuse common pieces of code across different projects, quickly adjusting
    them to your needs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第6章*](B17873_06_ePub.xhtml#_idTextAnchor081)*，添加代码片段*中，你将了解代码片段的概念，它允许你在不同的项目中重用常见的代码片段，并快速调整以满足你的需求。
