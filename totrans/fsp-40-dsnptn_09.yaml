- en: Chapter 9. More Data Crunching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。更多数据处理
- en: Up until this point, all F# data transformation patterns covered were dealing
    with in-memory collections. That is, important data crunching use cases, such
    as querying data, already persisted within the enterprise, and ingesting data
    from outside of the enterprise have not been considered yet.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有涵盖的 F# 数据转换模式都处理的是内存中的集合。也就是说，重要的数据处理用例，如查询企业内部已持久化的数据和从企业外部摄取数据，尚未被考虑。
- en: 'This chapter covers these data transformation scenarios and related coding
    patterns:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了这些数据转换场景和相关编码模式：
- en: Querying the external data. I'll begin with querying the data using F# query
    expressions. We are going to see how the same transformation patterns we distilled
    in [Chapter 8](text00065.html#page "Chapter 8. Data Crunching – Data Transformation
    Patterns") , *Data Crunching - Data Transformation Patterns* , in relation to
    core library function members are fully applicable to querying the external data
    presented in a data base or a web service. It also would be interesting to push
    the limits of composition in query expressions.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询外部数据。我将从使用 F# 查询表达式查询数据开始。我们将看到我们在第 8 章 [“数据处理 - 数据转换模式”](text00065.html#page
    "第 8 章。数据处理 - 数据转换模式") 中提炼出的相同转换模式，与核心库函数成员完全适用于查询数据库或 Web 服务中呈现的外部数据。探索查询表达式在组合方面的极限也将很有趣。
- en: Parsing data from the external sources. We already spent a fair amount of time
    considering pattern matching amplified by active patterns. However, I do not feel
    an imperative need for using some advanced techniques, such as parser combinators.
    I'll show some from-the-trenches examples of production quality data parsing achieved
    with just a bit of custom coding.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部源解析数据。我们已经花费了大量时间考虑由主动模式增强的模式匹配。然而，我并不觉得有必要使用一些高级技术，例如解析器组合器。我将展示一些来自实战的生产质量数据解析示例，这些示例仅通过一点自定义编码即可实现。
- en: Data querying
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据查询
- en: So far in the book, the sources of data collections were either collection generators
    or the file system. Let me move toward more realistic enterprise data sources,
    where data are persisted in databases. To access and transform such data, F# provides
    **query expressions** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/query-expressions-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/query-expressions-%5bfsharp%5d)
    ).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中数据集合的来源要么是集合生成器，要么是文件系统。让我转向更现实的业务数据源，其中数据存储在数据库中。为了访问和转换此类数据，F# 提供了
    **查询表达式** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/query-expressions-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/query-expressions-%5bfsharp%5d)
    )。
- en: '**Query expressions** represent a concrete type of **computation expressions**
    that is embedded into the language. They allow to bring data into memory by querying
    external sources and transforming incoming data to the desired shape.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询表达式**代表一种嵌入到语言中的具体类型的**计算表达式**。它们允许通过查询外部源将数据带入内存，并将传入的数据转换为所需的形状。'
- en: 'The F# query expressions are akin to sequence expressions: both produce data
    sequences. However, before the final data projection shaping the produced data
    sequence a query expression may apply to data a wide variety of data transformations
    that are similar to what we used to see in **LINQ** ([https://en.wikipedia.org/wiki/Language_Integrated_Query](https://en.wikipedia.org/wiki/Language_Integrated_Query)
    ). Query expressions can be considered LINQ support in F#.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: F# 查询表达式类似于序列表达式：两者都产生数据序列。然而，在最终数据投影塑造产生的数据序列之前，查询表达式可能应用于各种类似我们在 **LINQ**
    ([https://en.wikipedia.org/wiki/Language_Integrated_Query](https://en.wikipedia.org/wiki/Language_Integrated_Query)
    ) 中所见到的数据转换。查询表达式可以被视为 F# 中的 LINQ 支持。
- en: F# and LINQ before query expressions
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在查询表达式之前，F# 和 LINQ
- en: 'Chronologically, query expressions were introduced in F# 3.0\. Prior to that,
    F# allowed you to access the LINQ machinery via **.NET 3.5 Enumerable** **extension**
    **methods** ([https://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.110).aspx)
    ). Let''s look at the following script, which finds out the last vowel in the
    sequence of lexicographically ordered letters of the English alphabet (`Ch9_1_1.fsx`
    ):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 按照时间顺序，查询表达式是在 F# 3.0 中引入的。在那之前，F# 允许你通过 **.NET 3.5 Enumerable** 扩展方法（[https://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.110).aspx)）访问
    LINQ 机制。让我们看看以下脚本，它找出按字典顺序排列的英文字母序列中的最后一个元音字母（`Ch9_1_1.fsx`）：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we recollect that the F# sequence `alphabet` is `IEnumerable` , then the
    task can be achieved with LINQ extension methods (`Ch9_1_2.fsx` ):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回想一下 F# 中的 `alphabet` 序列是 `IEnumerable`，那么这个任务可以通过 LINQ 扩展方法（`Ch9_1_2.fsx`）来完成：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the *fluent interface* of LINQ extension methods as a rough substitute
    for the F# pipe operator, `|>` , we have achieved almost one-to-one correspondence
    between the definitions. The same result has been achieved by combining the `Seq`
    library functions, `filter-sortDescending-head` , and by combining the LINQ extension
    methods, `Where-OrderByDescending-First` .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LINQ 扩展方法的 *流畅接口* 作为 F# 管道操作符 `|>` 的粗略替代，我们实现了定义之间的几乎一对一对应。同样的结果是通过组合 `Seq`
    库函数 `filter-sortDescending-head` 和通过组合 LINQ 扩展方法 `Where-OrderByDescending-First`
    来实现的。
- en: Introducing F# query expressions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 F# 查询表达式
- en: 'You may ask why I pay so much attention to the above similarity? That is because
    query expressions are nothing more than *syntactic sugar* similar to the one we
    observed with sequence expressions in [Chapter 6](text00053.html#ch06 "Chapter 6. 
    Sequences - The Core of Data Processing Patterns") , *Sequences - The Core of
    Data Processing Patterns* . Query expressions use F# computation expressions magic
    to express chain of function applications as a linear sequence of SQL-like operations
    within built-in computation expression builder `query { ... }` . This approach
    is similar to `seq { ... }` workings for generating F# sequences. The script `Ch9_1_2.fsx`
    given in the previous section may be present using a query expression as (`Ch9_1_3.fsx`
    ):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么我如此关注上述相似性？那是因为查询表达式不过是类似于我们在 [第 6 章](text00053.html#ch06 "第 6 章. 序列
    – 数据处理模式的核心") 中观察到的序列表达式的 *语法糖*。查询表达式使用 F# 计算表达式魔法将函数应用链表达为 SQL 类似操作的线性序列，这些操作在内置的计算表达式构建器
    `query { ... }` 中进行。这种方法与 `seq { ... }` 生成 F# 序列的工作方式相似。上一节中给出的 `Ch9_1_2.fsx`
    脚本可能使用查询表达式作为（`Ch9_1_3.fsx`）：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When dissecting the preceding query expression you may spot the already familiar
    **ETL** data transformation process considered in [Chapter 8](text00065.html#page
    "Chapter 8. Data Crunching – Data Transformation Patterns") , *Data Crunching
    - Data Transformation Patterns* : given a collection, perform one or more modifications
    on its members, eventually projecting the query result. As a computation expression
    `query` provides that magic glue between adjacent lines. It makes the data flowing
    from one query operator to another in the manner similar to functions chained
    with the `>>` combinator.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析前面的查询表达式时，你可能注意到已经熟悉的 **ETL** 数据转换过程，这在 [第 8 章](text00065.html#page "第 8
    章. 数据处理 – 数据转换模式") 中已经考虑过，*数据处理 – 数据转换模式*：给定一个集合，对其成员进行一个或多个修改，最终投影查询结果。作为计算表达式
    `query` 提供了相邻行之间的神奇粘合剂。它使得数据以类似函数通过 `>>` 组合器链式连接的方式从一个查询操作符流向另一个查询操作符。
- en: Query operators
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询操作符
- en: 'Although the number of **query operators** ([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/query-expressions-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/query-expressions-%5Bfsharp%5D)
    ) is substantially less than the number of F# core library functions for collections
    - only around 40 - the query operators fit nicely into, where applicable, the
    hierarchy of data transformation patterns (another similar *classification* I
    managed to discover is the following one ([https://weblogs.asp.net/dixin/understanding-linq-to-objects-2-query-methods-and-query-expressions](https://weblogs.asp.net/dixin/understanding-linq-to-objects-2-query-methods-and-query-expressions)
    ). The mapping accompanied by the similar category names from the preceding classification
    provided in round brackets is given as following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然查询操作符的数量 ([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/query-expressions-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/query-expressions-%5Bfsharp%5D)
    ) 相对于 F# 核心库中集合函数的数量来说要少得多——只有大约 40 个——但查询操作符很好地融入了，在适用的情况下，数据转换模式的层次结构中（另一个类似的
    *分类* 我设法发现的是以下一个：[https://weblogs.asp.net/dixin/understanding-linq-to-objects-2-query-methods-and-query-expressions](https://weblogs.asp.net/dixin/understanding-linq-to-objects-2-query-methods-and-query-expressions)）。在括号中提供的与先前分类中类似名称的映射如下所示：
- en: '**The aggregation p** **attern** ( *aggregation* ): This includes functions
    such as `count` , `averageBy` , `averageByNullable` , `minBy` , `maxBy` , `minByNullable`
    , `maxByNullable` , `sumBy` , and `sumByNullable`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合模式** (*聚合*): 包括 `count`、`averageBy`、`averageByNullable`、`minBy`、`maxBy`、`minByNullable`、`maxByNullable`、`sumBy`
    和 `sumByNullable`'
- en: '**The searching pattern** : This includes the `find` function'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索模式**：这包括 `find` 函数'
- en: '**The selection pattern** ( *restriction* ): This contains  `last` , `lastOrDefault`
    , `head` , `headOrDefault` , `nth` , `exactlyOne` , `exactlyOneOrDefault` , `take`
    , `takeWhile` , `skip` , `skipWhile` , `distinct` , and `where`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择模式** (*限制*): 这包括 `last`、`lastOrDefault`、`head`、`headOrDefault`、`nth`、`exactlyOne`、`exactlyOneOrDefault`、`take`、`takeWhile`、`skip`、`skipWhile`、`distinct`
    和 `where`'
- en: '**The partitioning pattern** ( *grouping* ): This contains  `groupBy` and `groupValBy`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区模式** (*分组*): 这包括 `groupBy` 和 `groupValBy`'
- en: '**The reordering pattern** ( *ordering* ): This contains  `sortBy` , `sortByDescending`
    , `sortByNullable` , `sortByNullableDescending` , `thenBy` , `thenByDescending`
    , `thenByNullable` , and `thenByNullableDescending`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新排序模式** (*排序*): 这包括 `sortBy`、`sortByDescending`、`sortByNullable`、`sortByNullableDescending`、`thenBy`、`thenByDescending`、`thenByNullable`
    和 `thenByNullableDescending`'
- en: '**The testing pattern** ( *quantifier* ): This contains  `exists` and `all`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试模式** (*量词*): 这包括 `exists` 和 `all`'
- en: '**The mapping pattern** ( *projection* ): This contains  `select`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射模式** (*投影*): 这包括 `select`'
- en: '**The merge/split pattern** ( *convolution* ): This contains `zip` , `join`
    , `groupJoin` , and `leftOuterJoin`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合并/拆分模式** (*卷积*): 这包括 `zip`、`join`、`groupJoin` 和 `leftOuterJoin`'
- en: Nice! However, so far, the consideration was rotating around in-memory collections.
    Then how do we encompass querying out-of-memory data? F# provides considerable
    flexibility in this matter; so, let's approach it gradually in order to explore
    the richness and variety of the available schemes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！然而，到目前为止，考虑的都是在内存集合中的旋转。那么我们如何包含查询内存外的数据？F# 在这方面提供了相当大的灵活性；因此，让我们逐步进行，以便探索可用的方案之丰富性和多样性。
- en: The role of a LINQ provider
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LINQ 提供者的作用
- en: The important detail in using LINQ that often gets missed by occasional users
    is that the query mechanism is agnostic to the nature of the data collection.
    There is a layer that may be involved that abstracts the details of the concrete
    data source behind the **IQueryable<'T>** ([https://msdn.microsoft.com/en-us/library/bb351562(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/bb351562(v=vs.110).aspx)
    ) interface that we did not touch yet. Without involving this layer, you are on
    your own with our familiar `IEnumerable<'T>` interface.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 LINQ 时，经常被偶尔用户忽略的重要细节是查询机制对数据集合的性质是无关的。可能存在一个层，它抽象了位于 **IQueryable<'T>**
    ([https://msdn.microsoft.com/en-us/library/bb351562(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/bb351562(v=vs.110).aspx)
    ) 接口背后的具体数据源的细节，而我们尚未触及这个接口。不涉及这一层，你就只能依靠我们熟悉的 `IEnumerable<'T>` 接口了。
- en: Both interfaces ensure deferred execution. However, `IEnumerable<'T>` just brings
    into memory the data collection that matches a query expressed with relevant external
    means, subject to further **LINQ-to-Object** in-memory manipulations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个接口都确保了延迟执行。然而，`IEnumerable<'T>` 只是将与查询表达相关的数据集合引入内存，这些查询是通过相关外部手段表达的，并受进一步的
    **LINQ-to-Object** 内存操作的约束。
- en: By comparison, `IQueryable<'T>` allows **LINQ-to-Something** ( **LINQ-to-SQL,
    LINQ-to-OData, LINQ-to-WMI,** to name a few) workings by the virtue of the component
    named **LINQ provider** . It ensures hidden translation of a LINQ query to terms
    that the concrete substitute of *Something* part understands, followed by the
    translated query execution by *Something* , bringing just the matching data collection
    back into the memory. Those of you interested in what entity may play the role
    of *Something* , I refer to the representative-although slightly outdated - **LINQ-to-Everywhere
    - List of LINQ Providers** ([https://blogs.msdn.microsoft.com/knom/2009/04/27/linq-to-everywhere-list-of-linq-providers/](https://blogs.msdn.microsoft.com/knom/2009/04/27/linq-to-everywhere-list-of-linq-providers/)
    ).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`IQueryable<'T>` 通过名为 **LINQ provider** 的组件允许 **LINQ-to-Something**（例如
    **LINQ-to-SQL, LINQ-to-OData, LINQ-to-WMI** 等）工作。它确保 LINQ 查询被翻译成 *Something* 部分的具体替代品所理解的语言，然后由
    *Something* 执行翻译后的查询，仅将匹配的数据集合带回内存。对于那些对 *Something* 可能扮演什么角色感兴趣的人，我推荐查看代表性的、虽然有些过时的
    - **LINQ-to-Everywhere - LINQ 提供器列表** ([https://blogs.msdn.microsoft.com/knom/2009/04/27/linq-to-everywhere-list-of-linq-providers/](https://blogs.msdn.microsoft.com/knom/2009/04/27/linq-to-everywhere-list-of-linq-providers/)
    )。
- en: There are two key moments in the previous paragraph that must be understood
    properly. Firstly, *the LINQ provider fully abstracts the details of query translation
    and execution* . For the intuitively clear case of **LINQ-to-SQL** , such translation
    is quite straightforward. The translated SQL query is to be executed on the side
    of the engaged database engine, sending back over the wire only the results of
    the server-side query execution. For something like, for example, **LINQ-to-CRM**
    ([http://linqtocrm.codeplex.com/](http://linqtocrm.codeplex.com/) ), some further
    digging would be required in order to find out what exactly this particular LINQ
    provider does.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段落中有两个关键点必须正确理解。首先，*LINQ 提供器完全抽象了查询翻译和执行的细节*。对于直观清晰的 **LINQ-to-SQL** 案例，这种翻译相当直接。翻译后的
    SQL 查询将在参与数据库引擎的侧执行，仅通过网络发送服务器端查询执行的结果。对于像 **LINQ-to-CRM** ([http://linqtocrm.codeplex.com/](http://linqtocrm.codeplex.com/))
    这样的例子，需要进一步挖掘以了解这个特定的 LINQ 提供器到底做了什么。
- en: Secondly, the to-be-translated LINQ query should not contain elements that cannot
    be expressed in terms of the translated query execution engine. Such violations
    may take place through selectiveness of features in the provider implementation,
    or unintentional capturing of unrelated elements from the context. This means
    that if the provider implementation, for example, does not support the sorting
    operation, the LINQ query that has the sorting piece will be rejected by the underlying
    provider. Also, sometimes, the translated query execution engines may have varying
    abilities and the same LINQ-to-SQL query may be successfully executed by the Microsoft
    SQL engine but fail miserably on a MySQL engine.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，待翻译的 LINQ 查询不应包含无法用翻译查询执行引擎表达的内容。这种违规可能通过提供器实现中的功能选择性或从上下文中无意中捕获不相关的元素而发生。这意味着如果提供器实现，例如，不支持排序操作，那么包含排序部分的
    LINQ 查询将被底层提供器拒绝。此外，有时翻译查询执行引擎的能力可能不同，同一个 LINQ-to-SQL 查询可能由 Microsoft SQL 引擎成功执行，但在
    MySQL 引擎上却失败得非常惨重。
- en: With the role of LINQ provider in mind, let's first turn to the case of LINQ
    provider-free F# querying.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 LINQ 提供器的角色，我们首先转向无 LINQ 提供器的 F# 查询案例。
- en: External data querying via IEnumerable<'T>
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 `IEnumerable<'T>` 进行外部数据查询
- en: For this use case, let me take something that can be easily reproduced by you.
    Being on the Microsoft platform myself, I will be using the traditional test database
    Microsoft supplies to developers, namely **Adventureworks 2014** ([https://msftdbprodsamples.codeplex.com/releases/view/125550](https://msftdbprodsamples.codeplex.com/releases/view/125550)
    ). It has been installed under the **localdb** Microsoft SQL engine that comes
    with Visual Studio 2013.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个用例，让我找一个你可以轻松复制的例子。作为微软平台上的用户，我将使用微软提供给开发者的传统测试数据库，即 **Adventureworks 2014**
    ([https://msftdbprodsamples.codeplex.com/releases/view/125550](https://msftdbprodsamples.codeplex.com/releases/view/125550)
    )。它已经安装在 Visual Studio 2013 伴随的 **localdb** 微软 SQL 引擎下。
- en: 'There is a `[Person].[Person]` table in this database that carries, among other
    things, names of people. Let me perform a simple analytical task on it by performing
    the following query:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据库中有一个 `[Person].[Person]` 表，其中包含除了其他信息之外的人名。让我通过以下查询来对这个表执行一个简单的分析任务：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This allows me to find out that the database carries 1018 distinct personal
    first names. Let's find out how these names are distributed by the first letter
    in the English alphabet.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我能够发现数据库包含 1018 个独特的个人姓氏。让我们找出这些名字是如何按照英语字母表中的第一个字母分布的。
- en: 'To access the database, I will be using the simple `Reader` object of native
    .NET `System.Data.SqlClient` library. The first (and rather simplistic) approach
    would be to just provide the complete list of distinct first names over the wire
    to the memory on demand. The following script implements this approach (`Ch9_1_4.fsx`
    ):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据库，我将使用原生 .NET `System.Data.SqlClient` 库的简单 `Reader` 对象。最初（并且相当简单）的方法是将完整的独特姓氏列表通过网络发送到内存中。以下脚本实现了这种方法（`Ch9_1_4.fsx`）：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are two query expressions here: the first goes over each `letter` of
    the `alphabet` , delegating the trip to the database for the complete set of data
    to the nested second query, and then filtering out everything in memory except
    names starting with the current `letter` value, throwing away duplicates and finding
    the resulting number of names. The outer query puts this number into its place
    according to the found frequency and returns the sought-for projection `(letter,
    howMuch)` as the `distribution` sequence. Materializing it in FSI, I can observe
    the target name distribution. The timed results of running the script `Ch9_1_4.fsx`
    are presented in the following screenshot, where FSI just takes source script
    code from the given file path:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个查询表达式：第一个遍历 `alphabet` 中的每个 `letter`，将获取完整数据集的任务委托给嵌套的第二个查询，然后在内存中过滤掉除了以当前
    `letter` 值开头的名字之外的所有内容，丢弃重复项并找到名字的数量。外部查询根据找到的频率将这个数字放入其位置，并返回所寻求的投影 `(letter,
    howMuch)` 作为 `distribution` 序列。在 FSI 中实现它，我可以观察到目标名字的分布。以下截图展示了运行脚本 `Ch9_1_4.fsx`
    的计时结果，其中 FSI 只从给定的文件路径获取源脚本代码：
- en: '![External data querying via IEnumerable<''T>](img/Image00042.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![通过 IEnumerable<''T> 进行外部数据查询](img/Image00042.jpg)'
- en: 'External SQL Querying: version 1'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 SQL 查询：第1版
- en: You may notice that while running, the script performed a complete reading of
    the list of first names from the `[Person][Person]` database table for 26 times,
    which is an apparent overkill, and the approach can be improved significantly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在运行过程中，脚本从 `[Person][Person]` 数据库表中完整读取了姓氏列表26次，这显然是过度杀鸡用牛刀，这种方法可以显著改进。
- en: 'For example, we may parameterize our SQL command and get back not all names,
    but just the distinct names for each specific letter, which will dramatically
    decrease the traffic over the wire with the database. The script being refactored
    to reflect this improvement approach is given in the following code (`Ch9_1_5.fsx`
    ):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以参数化我们的 SQL 命令，并返回的不是所有名字，而是每个特定字母的独特名字，这将显著减少与数据库之间的流量。以下代码（`Ch9_1_5.fsx`）展示了重构后的脚本以反映这种改进方法：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You may notice that there is no need for the nested `query {...}` groups now,
    as a significant amount of work is delegated to the SQL engine over the wire.
    The timed results of running the refactored script are given in the following
    screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，现在不需要嵌套的 `query {...}` 组了，因为大量工作已经通过网络委托给了 SQL 引擎。以下截图显示了重构后的脚本的计时结果：
- en: '![External data querying via IEnumerable<''T>](img/Image00043.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![通过 IEnumerable<''T> 进行外部数据查询](img/Image00043.jpg)'
- en: External SQL Querying - version 2
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 SQL 查询 - 第2版
- en: You may observe an almost four-fold improvement in performance due to significant
    decrease of network traffic volume in the second version.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会观察到由于网络流量量的显著减少，性能几乎提高了四倍。
- en: 'Pushing this trend of minimizing traffic to the extreme and giving as much
    work to the SQL server as possible, I may make all work get pushed on the side
    of SQL server, leaving just a rudimentary task of getting remote data for the
    F# query, such as in the third version of the script shown here (`Ch9_1_6.fsx`
    ):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将最小化流量趋势推向极致，尽可能将工作分配给 SQL 服务器，我可能会让所有工作都推到 SQL 服务器的一侧，只留下为 F# 查询获取远程数据的初步任务，例如在此处显示的脚本的第三个版本
    (`Ch9_1_6.fsx`)：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that now all the dirty work is done by the SQL server, which is perfectly
    fine as Microsoft SQL Server is a masterpiece of software dedicated to data storing
    and crunching, and it does its work really well (if you do not detrimentally interfere,
    of course). The results of running the final script refactoring are presented
    in the following screenshot. Do not miss there the evidence that the whole data
    exchange over the wire took just a single round trip:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在所有脏活累活都由 SQL 服务器完成，这是完全正常的，因为 Microsoft SQL Server 是一款致力于数据存储和处理的软件杰作，而且它的工作做得非常好（当然，前提是你不进行有害的干扰）。运行最终脚本重构的结果在以下截图中展示。不要错过整个数据交换仅通过一次往返完成的证据：
- en: '![External data querying via IEnumerable<''T>](img/Image00044.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![通过 IEnumerable<''T> 进行外部数据查询](img/Image00044.jpg)'
- en: 'External SQL querying: version 3'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 SQL 查询：版本 3
- en: Wow, this optimization is the bomb! Version 3, in comparison with version 1,
    has roughly *17.6 times better performance* . Now your take-home lesson is hard
    to forget.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这个优化真是太棒了！与版本 1 相比，版本 3 大约 *提高了 17.6 倍的性能*。现在你的收获教训难以忘记。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Enterprise development demands that the underlying technology ensures the ample
    ability of distributing remote load. Such ability can be granted by F# `query`
    as well as by other means.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 企业开发要求底层技术确保有足够的远程负载分发能力。这种能力可以通过 F# `query` 以及其他方式实现。
- en: External data querying via IQuerable<'T>
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 IQuerable<'T> 进行外部数据查询
- en: I hope that after the bold performance results achieved in the previous section
    there is no need to convince you just how important the ability of relaying LINQ
    query execution to the remote party is. However, do not expect to take this for
    granted. This direction may have a steep learning curve, which we will notice
    shortly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望在前一节中取得的显著性能结果之后，无需再向你证明将 LINQ 查询执行转发到远程方的能力有多么重要。然而，不要期望这可以理所当然地获得。这个方向可能有一个陡峭的学习曲线，我们很快就会注意到。
- en: Let's take as a use case the 100% real task I was recently addressing on the
    job at **Jet.com Inc.** ([https://jet.com/about-us](https://jet.com/about-us)
    ). I will be building a backend for a dashboard, showing some *top-paid partners
    of Jet.com* in real time (merchants with the largest amounts of reimbursement
    for fulfilled orders that they have shipped to Jet.com customers).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我最近在 **Jet.com Inc.**（[https://jet.com/about-us](https://jet.com/about-us)）工作中遇到的一个
    100% 真实任务为例。我将构建一个仪表板的后端，实时显示 Jet.com 的 *高薪合作伙伴*（那些向 Jet.com 客户发货并完成订单获得最大赔偿金额的商家）。
- en: I will be accessing a limited amount of data from the Jet.com Quality Assurance
    environment, so the numbers will not be that indicative of real top-paid partners.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我将访问 Jet.com 质量保证环境中有限的数据，因此这些数字不会那么能说明真实的高薪合作伙伴。
- en: 'The data required for the dashboard backend are split between two databases:
    `SQL.Colossus` carries the data on payments in the `Payments` table, while `SQL.IronmanData`
    carries the data on partners in the `Partner` table.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板后端所需的数据分布在两个数据库中：`SQL.Colossus` 负责存储 `Payments` 表中的支付数据，而 `SQL.IronmanData`
    负责存储 `Partner` 表中的合作伙伴数据。
- en: 'If the case is that the data is located at the same SQL engine that supports
    cross-DB queries, then the T-SQL script that brings me the sought-for data would
    be something along the following lines (`Ch9_2.fsx` , commented section at the
    top):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据位于支持跨数据库查询的相同 SQL 引擎中，那么为我提供所需数据的 T-SQL 脚本可能如下所示（`Ch9_2.fsx`，顶部注释部分）：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After being executed against the target environment in SQL Server Management
    Studio, this yields the results reflected in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server Management Studio 中针对目标环境执行后，这会产生以下截图所示的结果：
- en: '![External data querying via IQuerable<''T>](img/Image00045.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![通过 IQuerable<''T> 进行外部数据查询](img/Image00045.jpg)'
- en: SQL Query to feed the top-paid Jet.com Partners dashboard
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 用于向 Jet.com 高薪合作伙伴仪表板提供 SQL 查询
- en: Let me make the first attempt in expressing the similar T-SQL query using the
    F# query expression `query{...}` . In order to get access to LINQ-to-SQL, I will
    be using a more advanced F# mechanism to get strongly typed access to the data
    than **ADO.NET** , which I was using in the previous section. This mechanism is
    known as the F# **type provider** . Specifically, I will be using the **SQLDataConnection
    (LINQ to SQL) type provider** ([http://fsharp.org/guides/data-access/#sql-data-access](http://fsharp.org/guides/data-access/#sql-data-access)
    ), which is a part of the standard F# distribution that has been targeting Microsoft
    Windows since F# v3.0.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我尝试使用 F# 查询表达式 `query{...}` 表达类似的 T-SQL 查询。为了访问 LINQ-to-SQL，我将使用比上一节中使用的 **ADO.NET**
    更高级的 F# 机制来获取对数据的强类型访问。这种机制被称为 F# **类型提供程序**。具体来说，我将使用 **SQLDataConnection (LINQ
    to SQL) 类型提供程序**([http://fsharp.org/guides/data-access/#sql-data-access](http://fsharp.org/guides/data-access/#sql-data-access))，这是
    F# 标准发行版的一部分，自 F# v3.0 以来一直针对 Microsoft Windows。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Those of you who are totally unfamiliar with the matter can follow this **MSDN
    walkthrough** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/walkthrough-accessing-a-sql-database-by-using-type-providers-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/walkthrough-accessing-a-sql-database-by-using-type-providers-%5bfsharp%5d)
    ) in order to better understand the contents of this section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对这个主题完全不熟悉的你们，可以遵循这个**MSDN 演练**([https://msdn.microsoft.com/visualfsharpdocs/conceptual/walkthrough-accessing-a-sql-database-by-using-type-providers-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/walkthrough-accessing-a-sql-database-by-using-type-providers-%5bfsharp%5d))来更好地理解本节的内容。
- en: 'The F# script that can be put into the core of the dashboard backend is as
    follows (`Ch9_2.fsx` ):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以放入仪表板后端核心的 F# 脚本如下（`Ch9_2.fsx`）：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Take into account that in order to adhere with the security requirements, I
    do not reveal any parameters of the Jet.com infrastructure except some (not necessarily
    coinciding with real ones) names of databases and tables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到安全要求，我没有透露任何关于 Jet.com 基础设施的信息，除了一些（不一定与真实名称相符）的数据库和表名。
- en: When it comes to the type provider, it is important to realize that the provider
    itself works at compile-time, providing typed access to the fields of the involved
    SQL tables. In order to do this, it requires access to the SQL schema information
    at compile-time. This access to the structural information in the preceding script
    is given via the `compileTimeCsusCS` and `compileTimeImCS` connection strings
    for `Colossus.DB` and `SQL.Ironman` databases, respectively.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到类型提供程序时，重要的是要意识到提供程序本身在编译时工作，为涉及的 SQL 表的字段提供类型化访问。为了做到这一点，它需要在编译时访问 SQL
    架构信息。这种对前面脚本中结构信息的访问是通过 `compileTimeCsusCS` 和 `compileTimeImCS` 连接字符串为 `Colossus.DB`
    和 `SQL.Ironman` 数据库提供的。
- en: Note that compile-time access to the local SQL engine from the type provider
    has nothing to do with application data. It just retrieves system data about SQL
    schemas. These schemas are structurally similar to ones carrying application data
    on production SQL data engine. So, the provided `Colossus` and `IronManData` types
    are built off the `localdb` SQL engine, while the `pmtContext` and `imContext`
    runtime data contexts are built off the production server(s) with the help of
    `runTimeCsusCS` and `runTimeImCS` runtime connection strings.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从类型提供程序对本地 SQL 引擎的编译时访问与应用数据无关。它只是检索有关 SQL 架构的系统数据。这些架构在结构上类似于在生产 SQL 数据引擎上承载应用数据的那些架构。因此，提供的
    `Colossus` 和 `IronManData` 类型是基于 `localdb` SQL 引擎构建的，而 `pmtContext` 和 `imContext`
    运行时数据上下文是基于生产服务器（通过 `runTimeCsusCS` 和 `runTimeImCS` 运行时连接字符串）构建的。
- en: 'The `mostPaid` function represents the query used to find any given number
    of top-paid partners along with their aggregate deposited payments. As we may
    expect, the signature of this function is `mostPaid : x:int -> System.Linq.IQueryable<string
    * decimal>` , and it is to be translated by the LINQ-to-SQL provider into plain
    T-SQL, to be executed on the SQL server side.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`mostPaid` 函数表示用于查找任何给定数量的高薪合作伙伴及其总存入支付的查询。正如我们可能预期的，这个函数的签名是 `mostPaid : x:int
    -> System.Linq.IQueryable<string * decimal>`，它将被 LINQ-to-SQL 提供程序转换为普通的 T-SQL，并在
    SQL 服务器端执行。'
- en: 'Another interesting moment is that in Jet.com''s Microsoft Azure production
    environment, cross-database queries such as the one from Figure *SQL Query to
    feed the top-paid Jet.com Partners dashboard* do not work, so I split the access
    into three phases:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的时刻是，在Jet.com的Microsoft Azure生产环境中，如图 *SQL查询为付费最高的Jet.com合作伙伴仪表板提供数据* 的跨数据库查询等操作无法正常工作，因此我将访问过程分为三个阶段：
- en: At the first phase, `active` represents a collection of tuples `(merchantId,
    paymentAmount)` of which the list of pertinent partner IDs, `activeIds` , can
    be easily projected
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一阶段，`active` 代表一个包含 `(merchantId, paymentAmount)` 元组的集合，其中相关合作伙伴ID列表 `activeIds`
    可以轻松投影
- en: At the second phase, another query, `mostActiveNames` , retrieves only those
    partner display names that belong only to the top-paid partners and packages them
    into a dictionary
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二阶段，另一个查询 `mostActiveNames` 仅检索属于付费最高的合作伙伴的合作伙伴显示名称，并将它们打包到字典中
- en: Finally, `active` experiences a transformation where the ID is substituted by
    `mostActiveNames.[id]` , yielding the final data shape required for the dashboard.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`active` 经历了一次转换，其中ID被替换为 `mostActiveNames.[id]` ，从而得到仪表板所需的最终数据形状。
- en: 'The results of running the previous script with FSI are presented in the following
    screenshot; as expected, they are identical to previous ones:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前一个脚本并使用FSI的结果在以下屏幕截图中展示；正如预期的那样，它们与之前的结果相同：
- en: '![External data querying via IQuerable<''T>](img/Image00046.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![通过IQuerable<''T>进行外部数据查询](img/Image00046.jpg)'
- en: F# Query via IQueryable<'T> in action
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过IQueryable<'T>在F#中查询的实际操作
- en: Composable queries
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可组合查询
- en: Wouldn't it be great to compose smaller F# subqueries into bigger queries? Put
    differently, it would mean composing multiple queryables into a single LINQ query
    translated into SQL and executed on the database engine side.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将较小的F#子查询组合成更大的查询不是很好吗？换句话说，这意味着将多个可查询对象组合成一个LINQ查询，该查询被翻译成SQL并在数据库引擎端执行。
- en: This sounds promising, and it has attracted the attention of some individual
    developers and groups.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很有希望，并引起了一些个人开发者及团队的注意。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The most sizeable effort was taken by a group at the University of Edinburgh,
    UK, governed by functional programming authorities such as Philip Wadler. Their
    results can be found at the **FSharpComposableQuery**  ([http://fsprojects.github.io/FSharp.Linq.ComposableQuery/index.html](http://fsprojects.github.io/FSharp.Linq.ComposableQuery/index.html)
    ) project home page, offering a NuGet package, source code, tutorial, and even
    some theoretical papers on the subject. An introductory video presentation given
    by Philip Wader is available on the SkillsMatter website: **A practical theory
    of language-integrated query** ([https://skillsmatter.com/skillscasts/4486-a-practical-theory-of-language-integrated-query](https://skillsmatter.com/skillscasts/4486-a-practical-theory-of-language-integrated-query)
    ).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 英国爱丁堡大学的一个团队投入了最多的努力，该团队由如Philip Wadler等函数式编程权威人士领导。他们的成果可以在 **FSharpComposableQuery**  ([http://fsprojects.github.io/FSharp.Linq.ComposableQuery/index.html](http://fsprojects.github.io/FSharp.Linq.ComposableQuery/index.html)
    ) 项目主页上找到，提供NuGet包、源代码、教程，甚至还有关于该主题的一些理论论文。Philip Wader在SkillsMatter网站上给出了一篇介绍视频演示：**语言集成查询的实用理论**
    ([https://skillsmatter.com/skillscasts/4486-a-practical-theory-of-language-integrated-query](https://skillsmatter.com/skillscasts/4486-a-practical-theory-of-language-integrated-query)
    )。
- en: Also, a few years ago, an alternative and more lightweight approach to composable
    queries was suggested in this **blog post** ([http://fpish.net/blog/loic.denuziere/id/3508/2013924-f-query-expressions-and-composability](http://fpish.net/blog/loic.denuziere/id/3508/2013924-f-query-expressions-and-composability)
    ) by **Loïc Denuzière** ([http://fpish.net/profile/loic.denuziere](http://fpish.net/profile/loic.denuziere)
    ). It is based on splicing partial F# query expressions together in order to build
    more complex ones. I will make a foray into composable LINQ queries based on the
    latter approach.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，几年前，Loïc Denuzière在 **这篇博客文章** ([http://fpish.net/blog/loic.denuziere/id/3508/2013924-f-query-expressions-and-composability](http://fpish.net/blog/loic.denuziere/id/3508/2013924-f-query-expressions-and-composability)
    ) 中提出了一种替代的、更轻量级的可组合查询方法，Loïc Denuzière的资料可以在 [http://fpish.net/profile/loic.denuziere](http://fpish.net/profile/loic.denuziere)
    找到。该方法基于将部分F#查询表达式拼接在一起以构建更复杂的查询。我将基于这种方法探索可组合LINQ查询。
- en: 'Just before we start writing the code, I must point out a big limitation of
    F# querying based on LINQ-to-SQL: it is not possible to perform cross-database
    and cross-engine queries, as *all subqueries must share the same LINQ context!*
    This factor might be a show-stopper for enterprises that have a multitude of **OLTP**
    and **OLAP** databases.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我必须指出基于 LINQ-to-SQL 的 F# 查询的一个重大限制：无法执行跨数据库和跨引擎查询，因为**所有子查询都必须共享相同的
    LINQ 上下文**！这个因素可能成为拥有众多 **OLTP** 和 **OLAP** 数据库的企业的一个拦路虎。
- en: In order to refactor to a composable query a T-SQL query from the script `Ch9_2.fsx`
    that was covered above in the dashboard use case discussion, I have moved a copy
    of the `Partner` table to the `SQL.Colossus` database. It can now share the same
    LINQ context with the `Payments` table.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `Ch9_2.fsx` 脚本中的 T-SQL 查询重构为可组合查询，我在仪表板用例讨论中覆盖了上述内容，我已经将 `Partner` 表的副本移动到
    `SQL.Colossus` 数据库。它现在可以与 `Payments` 表共享相同的 LINQ 上下文。
- en: 'The composition method is based on introducing a special `PartialQueryBuilder`
    class that:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 组合方法基于引入一个特殊的 `PartialQueryBuilder` 类，它：
- en: Subclasses standard `Linq.QueryBuilder` introducing extra method `Run`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入额外方法 `Run` 的标准 `Linq.QueryBuilder` 子类
- en: Augmenting `Linq.QueryBuilder` with method `Source`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Source` 方法增强 `Linq.QueryBuilder`
- en: All these measures allow you writing subqueries with the alternative expression
    builder `pquery` that gets wrapped into quotations instead of being evaluated
    . These quotations are embedded into ordinary queries and get evaluated uniformly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些措施都允许你使用替代表达式构建器 `pquery` 编写子查询，这些查询被包裹在引号中而不是被评估。这些引号被嵌入到普通查询中，并统一评估。
- en: 'In the following script, which relies on these features, I''ve omitted the
    separation of compile-time and run-time connections for brevity (`Ch9_3.fsx` ):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下脚本中，它依赖于这些功能，为了简洁起见，我省略了编译时和运行时连接的分离（`Ch9_3.fsx`）：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then goes the utility part defining `pquery` :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是定义 `pquery` 的实用部分：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, the composed queries are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，组合查询如下：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note how `mostPaid` is spliced into the `dashboard` , creating a seamless composition,
    and in turn, `dashboard` is spliced into the final query.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `mostPaid` 如何被拼接到 `dashboard` 中，从而创建了一个无缝的组成，反过来，`dashboard` 被拼接到最终的查询中。
- en: 'Running the script in FSI yields the results shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FSI 中运行脚本产生以下结果：
- en: '![Composable queries](img/Image00047.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![可组合查询](img/Image00047.jpg)'
- en: Getting dashboard data with the composed query
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合查询获取仪表板数据
- en: 'You may wonder whether there is a way to check out that the query composition
    really took place. Fortunately, that is not that hard to do. All it takes is adding
    the following property to the LINQ context, as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道是否有方法可以检查查询组合是否真的发生了。幸运的是，这并不难做到。只需向 LINQ 上下文中添加以下属性即可，如下所示：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After running the preceding script again, the LINQ log file now contains the
    SQL code executed by the SQL engine:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行前面的脚本后，LINQ 日志文件现在包含 SQL 引擎执行的 SQL 代码：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note how all `IQueryable` bits and pieces from the script F# queries get molded
    into the single SQL statement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何将脚本 F# 查询中的所有 `IQueryable` 零部件塑造成单个 SQL 语句。
- en: Data parsing
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据解析
- en: The parsing of data is absolutely essential for the enterprise. As an enterprise
    F# developer at Jet.com, I come across this data transformation pattern on a daily
    basis. Every case of **LOB** applications' integration with a third-party system
    -  **ERP** , **Bank** , or **Carrier ** - involves data parsing on the ingesting
    edges. Despite a plethora of integration technologies around that promise great
    data quality, timeliness, integrity, you name it...time and again, I am forced
    by my contractors to deal with flat fixed format files, CSV files, and Excel files.
    This is the boring reality of today.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 数据解析对企业来说绝对至关重要。作为 Jet.com 的企业级 F# 开发者，我每天都在遇到这种数据转换模式。每个 **LOB** 应用程序与第三方系统（**ERP**、**银行**
    或 **承运商**）集成的案例都涉及到在摄取边缘的数据解析。尽管有大量承诺提供优质数据、及时性、完整性的集成技术，但无论什么名字...时间一次又一次地，我被我的承包商强迫处理平面固定格式文件、CSV
    文件和 Excel 文件。这就是今天令人厌烦的现实。
- en: On this battlefield, the weaponry varies from case-by-case hand-coded solutions
    based on **Regex** and F# active patterns to fairly generic solutions targeting
    whole classes of incoming data with F# type providers. Some typical examples of
    semi-generic solutions are invoices in the form of CSV files and Excel files that
    are to be persisted in the SQL server for further processing, reconciliation,
    and future audit. I'll show how the high-quality parsing of incoming data can
    be achieved for the use case of digesting the carrier invoices ingested as an
    Excel file into the SQL server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个战场上，武器装备从基于 **Regex** 和 F# 活动模式的逐个案例手编解决方案到针对整个 incoming 数据类别的相当通用的解决方案不等。一些半通用的解决方案的典型例子是将以
    CSV 文件和 Excel 文件形式存在的发票持久化到 SQL 服务器中，以便进行进一步的处理、对账和未来的审计。我将展示如何实现高质量解析 incoming
    数据，以处理将作为 Excel 文件摄入的承运人发票消化到 SQL 服务器的用例。
- en: The use case - LaserShip invoicing
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例 - 激光船发票
- en: LaserShip is one of the "last mile" delivery companies usually engaged by e-commerce
    for same-day expedited deliveries. Jet.com uses LaserShip services along with
    other carriers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: LaserShip 是电子商务通常用于当日快递交付的“最后一英里”配送公司之一。Jet.com 使用 LaserShip 服务以及其他承运人服务。
- en: LaserShip delivers its invoicing information packaged as Excel files. For the
    purposes of reconciliation and auditing, it is desirable to load LaserShip invoices
    into the SQL server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: LaserShip 以 Excel 文件的形式提供其发票信息。为了对账和审计的目的，将 LaserShip 发票加载到 SQL 服务器中是可取的。
- en: Approaching the parsing task
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接近解析任务
- en: 'When resembling ETL tasks pop up, I usually approach them with the following
    pattern:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现类似 ETL 任务时，我通常采用以下模式来处理：
- en: Define the schema of the SQL table that will carry the loaded data. Add to the
    data that come from the carrier extra field(s) allowing you to reference any chunk
    of data back to the carrier's file it originated from. Also, add the synthetic
    and/or natural key field(s) and reasonable constraints. The sample SQL table schema
    has been provided in the form of T-SQL script `SCHEMA_LaserShip.sql` .
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将承载加载数据的 SQL 表的架构。为来自承运人的数据添加额外的字段（s），允许您将任何数据块引用回其原始的承运人文件。此外，添加合成和/或自然键字段以及合理的约束。示例
    SQL 表架构已以 T-SQL 脚本 `SCHEMA_LaserShip.sql` 的形式提供。
- en: Ingest the file with the help of **Excel Provider** ([http://fsprojects.github.io/ExcelProvider/](http://fsprojects.github.io/ExcelProvider/)
    ). Adjust the type provider settings to suppress the default field type interpretation
    and force the delivery of fields as strings. The Excel file template distributed
    by LaserShip to their customers has been provided as Excel file `Lasership Invoice
    Format.xlsx` .
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **Excel Provider** ([http://fsprojects.github.io/ExcelProvider/](http://fsprojects.github.io/ExcelProvider/))
    的帮助来摄入文件。调整类型提供程序设置以抑制默认的字段类型解释并强制将字段作为字符串提供。LaserShip 向其客户提供由 LaserShip 分发的 Excel
    文件模板，已作为 Excel 文件 `Lasership Invoice Format.xlsx` 提供。
- en: For the fields that may be omitted in the source represented the such as **nullable**
    values. Omitted values are to be filled with `System.DBNull.Value` singleton.
    Create or reuse a set of parsing functions for each field type returning a boxed
    parsed value or `System.DBNull.Value` .
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在源中表示可能被省略的字段，例如 **可空** 值。省略的值应使用 `System.DBNull.Value` 单例填充。为每个字段类型创建或重用一组解析函数，返回装箱的解析值或
    `System.DBNull.Value` 。
- en: Parse the contents of the file into the  `System.Data.DataTable` instance matching
    column names with database fields and unboxing values parsed with generic parsing
    functions. The example invoice containing an excerpt of a real invoice with personal
    data wiped out has been provided as Excel file `LaserShip20160701.xlsx` .
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件内容解析到匹配数据库字段的 `System.Data.DataTable` 实例中，使用泛型解析函数解析值。包含从真实发票摘录的示例发票，其中已删除个人数据，已作为
    Excel 文件 `LaserShip20160701.xlsx` 提供。
- en: Load the filled `DataTable` instance into the SQL server using the ADO.NET **SqlBulkCopy**
    ([https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlbulkcopy(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlbulkcopy(v=vs.110).aspx)
    ).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ADO.NET **SqlBulkCopy** ([https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlbulkcopy(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlbulkcopy(v=vs.110).aspx))
    将填充的 `DataTable` 实例加载到 SQL 服务器中。
- en: LaserShip parser implementation
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LaserShip 解析器实现
- en: 'The approach outlined earlier is implemented by the script `Ch9_4.fsx` . As
    the script length does not fit well with the book format it will not be given
    here in its entirety. Instead, I''ll reproduce in this section only the most important
    excerpts from the script with my comments:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前概述的方法是通过脚本 `Ch9_4.fsx` 实现的。由于脚本长度不适合书籍格式，因此不会在这里完整给出。相反，我将在本节中仅重现脚本中最重要的摘录以及我的注释：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The line above ensures that NuGet package **Excel Provider 0.8.0** ([https://www.nuget.org/packages/ExcelProvider](https://www.nuget.org/packages/ExcelProvider)
    ) is accessible from the script:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的行确保可以从脚本中访问 NuGet 包 **Excel Provider 0.8.0** ([https://www.nuget.org/packages/ExcelProvider](https://www.nuget.org/packages/ExcelProvider)
    )：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The line above is extremely important. It gets processed *in compile-time*
    by the referred F# Excel type provider. The type provider using the given file
    path gets to the Excel file `lasership invoice format.xlsx` that represents the
    data template. We adjust type provider settings by defining `HasHeaders` and `ForceString`
    static `bool` parameters. The type provider produces on the fly the provided type
    `LaserShip` that will allow to access any cell of the invoice row by its name:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的行非常重要。它由引用的 F# Excel 类型提供者在**编译时**进行处理。使用给定文件路径的类型提供器到达表示数据模板的 Excel 文件 `lasership
    invoice format.xlsx`。我们通过定义 `HasHeaders` 和 `ForceString` 静态 `bool` 参数来调整类型提供器设置。类型提供器会即时生成提供的类型
    `LaserShip`，这将允许通过名称访问发票行的任何单元格：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding definition of `asNullableString` function implements the idiomatic
    typed transition from the Excel data cell that we know is of type `string` to
    its `obj` representation suitable to be placed into not statically typed `System.Data.DataTable`
    in-memory data table. If data in Excel are omitted for the cell the function is
    given as argument, the returned value would be boxed `System.DBNull.Value` value
    suitable to be placed into the database field of type, described in T-SQL as `NVARCHAR(...)
    NULL` . The script defines functions similar to `asNullableString` for each type
    of the Excel file where strong type checking is required: `asNullableDate` , `asString`
    , `asNullableMoney` , and others:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之前对 `asNullableString` 函数的定义实现了从 Excel 数据单元格到其 `obj` 表示的惯用类型转换，这种表示适合放入不进行静态类型检查的
    `System.Data.DataTable` 内存中的数据表。如果 Excel 中的数据省略了作为参数传递给函数的单元格，则返回值将是适合放入以 T-SQL
    描述的数据库字段类型的 `System.DBNull.Value` 值，例如 `NVARCHAR(...) NULL`。脚本定义了类似于 `asNullableString`
    的函数，用于 Excel 文件中的每种类型，在需要强类型检查的地方：`asNullableDate`、`asString`、`asNullableMoney`
    以及其他：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding binding would be necessary for associating columns of in-memory
    data table with the database table columns for `SQLBulkCopy` :'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的绑定对于将内存中的数据表列与数据库表列关联到 `SQLBulkCopy` 是必要的：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This function definition is very important as it performs ingestion of invoice
    data from the Excel file specified by the given `excelPath` argument to the in-memory
    placeholder `Data` procured by the provided type `LaserShip` :'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数定义非常重要，因为它执行从由给定 `excelPath` 参数指定的 Excel 文件中摄入发票数据到由提供的类型 `LaserShip` 购得的内存占位符
    `Data`：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding definition of the `fillDataTable` function is the gist of the
    script. You may notice the interesting type of argument it has: `rows: IEnumerable<LaserShip.Row>`
    . In other words `rows` is a sequence of another provided type `LaserShip.Row`
    representing a single row of invoice spreadsheet. Within the function a new instance
    of `DataTabledt` is created and supplied by column names taken from `headers`
    . Then each row of the ingested Excel file is parsed into the `dt` , taking care
    of data validity. In the end the loaded data table `dt` is returned.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '之前对 `fillDataTable` 函数的定义是脚本的核心。你可能注意到它有趣的参数类型：`rows: IEnumerable<LaserShip.Row>`。换句话说，`rows`
    是另一个提供的类型 `LaserShip.Row` 的序列，代表发票工作表的单一行。在函数内部，创建了一个新的 `DataTable` 实例，并通过从 `headers`
    中获取列名来提供。然后，将摄入的 Excel 文件的每一行解析到 `dt` 中，注意数据的有效性。最后，返回加载的数据表 `dt`。'
- en: 'A small, but very important detail: the `sourceId` argument above just references
    another table that keeps track of of the processed invoices. It has been written
    into the each row of in-memory data table, so after the data upload the reference
    will be available in the persisted to SQL server data to the metadata describing
    the data originating source. Further details are beyond the scope here.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小但非常重要的细节：上面的 `sourceId` 参数仅仅引用了另一个跟踪已处理发票的表。它已经被写入内存数据表的每一行，因此在数据上传后，这个引用将在持久化到
    SQL 服务器的数据中可用，以描述数据的原始来源。更详细的内容超出了此处讨论的范围。
- en: 'Finally, another important function `loadIntoSQL` makes the bulk data upload
    into SQL server. Its definition is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，另一个重要的函数 `loadIntoSQL` 实现了将大量数据上传到 SQL 服务器。其定义如下：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There a connection `con` to the database gets opened using the provided connection
    string `connStr` value. Using the created connection and given SQL table name
    the instance of `SqlBulkCopy` is created and used for persisting in-memory `dataTable`
    to the associated SQL server table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的连接字符串 `connStr` 值打开数据库连接 `con`。使用创建的连接和给定的 SQL 表名，创建并使用 `SqlBulkCopy` 实例将内存中的
    `dataTable` 持久化到相关的 SQL 服务器表。
- en: The preceding script can be further generalized to the degree where the only
    variable part will be the data related to the concrete file type. This variable
    part can be made pluggable into the universal Excel file parser. And this can
    be achieved in fewer than a hundred lines of code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本可以进一步泛化到只有与具体文件类型相关的数据部分是可变的程度。这个可变部分可以被集成到通用的 Excel 文件解析器中。这可以在不到一百行代码内实现。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter wraps up the topic of data transformation patterns. Most of it
    is devoted to querying persisted data with the help of F# query expressions. You
    should be able to grasp the nuances of query work distribution between in-memory
    collections and the network-located data engine.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了数据转换模式的话题。大部分内容都是关于使用 F# 查询表达式查询持久化数据。你应该能够掌握查询工作在内存集合和网络位置的数据引擎之间的分配的细微差别。
- en: We also touched the important issue of data parsing, demonstrating the handful
    of simple patterns that allow you to ingest arbitrary Excel files with the helping
    hand of F# type providers, which will be further covered in [Chapter 11](text00074.html#page
    "Chapter 11. F# Expert Techniques") , *F# Expert Techniques* .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还触及了数据解析的重要问题，展示了几个简单的模式，这些模式可以帮助你借助 F# 类型提供者摄取任意 Excel 文件，这些内容将在第 11 章[“F#
    专家技巧”](text00074.html#page "第 11 章。F# 专家技巧")中进一步介绍。
- en: In the next chapter, I will concentrate on dual patterns of type specialization
    (augmentation) and type generalization in F#.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将专注于 F# 中的类型特殊化（增强）和类型泛化的双重模式。
