- en: Chapter 12. Writing Secure Code and Debugging in Visual Studio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。在Visual Studio中编写安全代码和调试
- en: 'In this chapter, we will have a look at some examples of being more efficient
    as a developer when it comes to debugging your code. We will also be looking at
    how to write secure code. Writing secure code can be a challenge, but consider
    the following: if part of your code security involves making sure that passwords
    are securely stored, why write that code over and over between projects? Write
    the code once and implement it in every new project you create. The concepts we
    will be looking at are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些作为开发者提高调试代码效率的示例。我们还将探讨如何编写安全代码。编写安全代码可能是一个挑战，但考虑以下情况：如果你的代码安全部分涉及确保密码被安全存储，为什么要在项目之间反复编写相同的代码？编写一次代码，并在你创建的每个新项目中实施它。我们将探讨的概念如下：
- en: Encrypting and storing passwords correctly
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确加密和存储密码
- en: Using `SecureString` in code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中使用 `SecureString`
- en: Securing sensitive parts of `App.config`/`web.config`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 `App.config`/`web.config` 中的敏感部分
- en: Preventing SQL injection attacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止SQL注入攻击
- en: Using **Diagnostic Tools** and **Historical Debugging**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **诊断工具** 和 **历史调试**
- en: Setting conditional breakpoints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置条件断点
- en: Using **PerfTips** to identify bottlenecks in code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **PerfTips** 识别代码中的瓶颈
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Something that many developers tend to miss is the need to write secure code.
    Development deadlines and other project-related pressures cause developers to
    put delivering code above doing it the right way. Many of you might not agree
    with me, but believe me when I say that I have heard the excuse of "We do not
    have budget for this" once too many times. This is usually when the development
    budget has been determined by other stakeholders and the developer not consulted.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者往往忽略的是编写安全代码的需求。开发截止日期和其他项目相关压力导致开发者将交付代码置于正确执行之上。你们中许多人可能不同意我的观点，但请相信我，我已经多次听到“我们没有预算做这件事”的借口。这通常是在开发预算由其他利益相关者确定，而开发者没有被咨询的情况下发生的。
- en: Consider a situation where a consultant tells the developer that they have sold
    a system to a customer. That system now needs to be developed. Furthermore, the
    developer is told that they have *x* amount of hours to complete the development.
    A document outlining the requirements is given to the developer and the developer
    is given the go-ahead to begin, and to complete development in the required time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，顾问告诉开发者他们已经向客户销售了一个系统。现在需要开发这个系统。此外，开发者被告知他们有 *x* 小时的时间来完成开发。给开发者一份概述要求的文档，并允许开发者开始，并在规定的时间内完成开发。
- en: This scenario is the reality many developers face. You might think that this
    scenario can't possibly exist, or perhaps you are reading this and relate to the
    scenario as being how the process currently works in your company. Whatever the
    case may be, this is something that happens today in software development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景是许多开发者面临的现实。你可能认为这种场景根本不可能存在，或者也许你正在阅读这篇文章，并认为这个场景与你公司当前的工作流程相符。无论情况如何，这是软件开发中今天正在发生的事情。
- en: So how do developers combat project suicide? (I call these projects this because
    projects approached like this rarely succeed.) Start by creating reusable code.
    Think of processes you repeat often enough to warrant writing a reusable DLL for.
    Did you know that you can create Visual Studio templates? If you have a standard
    project structure you use, create a template from it and re-use it for each new
    project, thereby speeding up delivery and cutting down on bugs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么开发者如何应对项目自杀？（我之所以这样称呼这些项目，是因为以这种方式处理的项目很少能成功。）首先，创建可重用代码。想想那些你经常重复执行到足以编写可重用DLL的过程。你知道你可以创建Visual
    Studio模板吗？如果你有一个你经常使用的标准项目结构，从它创建一个模板，并在每个新项目中重用它，从而加快交付速度并减少错误。
- en: A few considerations for project templates are database layers, security layers,
    common validation code (does this data table contain any data), common extension
    methods, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目模板的一些考虑包括数据库层、安全层、常见验证代码（这个数据表是否包含任何数据）、常见扩展方法等。
- en: Encrypting and storing passwords correctly
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确加密和存储密码
- en: One thing I have often seen is badly stored passwords. Just because the password
    is stored in a database on your server, does not make it secure. So what do badly
    stored passwords look like?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到的是存储不当的密码。仅仅因为密码存储在你的服务器上的数据库中，并不意味着它是安全的。那么存储不当的密码是什么样的呢？
- en: '![Encrypting and storing passwords correctly](img/B05391_12_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![正确加密和存储密码](img/B05391_12_01.jpg)'
- en: Secure passwords stored badly are no longer secure. The passwords in the previous
    screenshot are the actual user passwords. Entering the first password, `^tj_Y4$g1!8LkD`
    at the login screen will give the user access to the system. Passwords should
    be stored securely in the database. In fact, you need to employ salted password
    hashing. You should be able to encrypt the user's password, but never decrypt
    it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 存储不当的安全密码不再安全。上一张截图中的密码是实际的用户密码。在登录屏幕上输入第一个密码 `^tj_Y4$g1!8LkD` 将允许用户访问系统。密码应安全地存储在数据库中。实际上，你需要使用加盐密码散列。你应该能够加密用户的密码，但永远不要解密它。
- en: So how do you decrypt the password to match it to the password the user enters
    at the login screen? Well, you don't. You always hash the password the user enters
    at the login screen. If it matches the hash of their real password stored in the
    database, you give them access to the system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你如何解密密码以匹配用户在登录屏幕上输入的密码呢？好吧，你不需要。你总是对用户在登录屏幕上输入的密码进行散列。如果它与数据库中存储的实际密码的散列值匹配，你就允许他们访问系统。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The SQL tables in this recipe are for illustration only and are not written
    to by the code in the recipe. The database can be found in the `_database scripts`
    folder that accompanies the source code for this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的 SQL 表仅用于说明，代码中并未写入。数据库可以在与本书源代码一起提供的 `_database scripts` 文件夹中找到。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Create a new class library by right-clicking on your solution, and selecting
    **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_12_02.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在解决方案上右键单击，创建一个新的类库，然后从上下文菜单中选择 **添加** 和 **新建项目**：![如何操作…](img/B05391_12_02.jpg)
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter12`:![How to do it…](img/B05391_12_03.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**添加新项目**对话框屏幕中，从已安装的模板中选择**类库**，并将你的类命名为`Chapter12`：![如何操作…](img/B05391_12_03.jpg)
- en: Your new class library will be added to your solution with a default name of
    `Class1.cs`, which we renamed `Recipes.cs` in order to distinguish the code properly.
    You can, however, rename your class whatever you like if that makes more sense
    to you.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你新的类库将以默认名称 `Class1.cs` 添加到你的解决方案中，我们将其重命名为 `Recipes.cs` 以便正确区分代码。然而，如果你觉得这样更有意义，你可以将类重命名为你喜欢的任何名称。
- en: To rename your class, simply click on the class name in the **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_12_04.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重命名你的类，只需在 **解决方案资源管理器** 中单击类名，然后从上下文菜单中选择 **重命名**：![如何操作…](img/B05391_12_04.jpg)
- en: Visual Studio will ask you to confirm a rename of all references to the code
    element **Class1** in the project. Just click **Yes**:![How to do it…](img/B05391_12_49.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将要求你确认重命名项目中所有对代码元素 **Class1** 的引用。只需点击 **是**：![如何操作…](img/B05391_12_49.jpg)
- en: 'The following class is added to your `Chapter12` library project:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类被添加到你的 `Chapter12` 库项目中：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following `using` statement to your class:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 语句添加到你的类中：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, you need to add two properties to the class. These properties will store
    the salt and the hash. Usually you will write these values to the database along
    with the username, but for the purposes of this recipe we will simply add them
    to the static properties. Also add two methods to the class called `RegisterUser()`
    and `ValidateLogin()`. Both methods take as parameters the `username` and `password`
    variables:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要向类中添加两个属性。这些属性将存储盐和散列。通常你会在数据库中将这些值与用户名一起写入，但为了本食谱的目的，我们将简单地将其添加到静态属性中。还要添加两个名为
    `RegisterUser()` 和 `ValidateLogin()` 的方法。这两个方法都接受 `username` 和 `password` 变量作为参数：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Starting with the `RegisterUser()` method, here we do a number of things. To
    list the steps in the method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `RegisterUser()` 方法开始，这里我们做了很多事情。以下是方法中的步骤列表：
- en: We generate a truly random, cryptographically strong salt value using `RNGCryptoServiceProvider`
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `RNGCryptoServiceProvider` 生成一个真正随机、密码学上安全的盐值。
- en: Add the salt to the password and hash the salted password using `SHA256`.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将盐添加到密码中，并使用 `SHA256` 对加盐密码进行散列。
- en: Note
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It doesn't matter if you add the salt before or after the password. Just remember
    to be consistent each time you do it.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你在添加盐之前还是之后添加都无关紧要。只需每次都保持一致即可。
- en: Store the salt value and the hash value along with the username in the database.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将盐值和散列值与用户名一起存储在数据库中。
- en: Note
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to cut down on code, I have not actually added code to write the hash
    and salt values to the database. I simply added them to the properties created
    earlier. In a real-world situation, you would always write these to the database.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了减少代码量，我实际上并没有添加代码将哈希值和盐值写入数据库。我只是将它们添加到之前创建的属性中。在现实世界中，你总是会将这些写入数据库。
- en: 'This is a very secure way to handle user passwords in your application:'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是在你的应用程序中处理用户密码的一种非常安全的方式：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next method we need to create is the `ValidateLogin()` method. Here we
    take the username and validate that first. If the user entered the username incorrectly,
    do not tell them so. This would alert someone trying to compromise the system
    that they have the wrong username and that as soon as they get a wrong password
    notification, they know that the username is correct. The steps in this method
    are as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建的下一个方法是`ValidateLogin()`方法。在这里，我们首先验证用户名。如果用户输入的用户名不正确，不要告诉他们。这将警告试图破坏系统的人他们有错误的用户名，并且一旦他们收到错误密码的通知，他们就会知道用户名是正确的。这个方法中的步骤如下：
- en: Get the salt and hash values for the entered username from the database.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中获取输入用户名的盐值和哈希值。
- en: Salt the password the user entered at the login screen with the salt read from
    the database.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从数据库中读取的盐对登录屏幕上输入的用户密码进行盐化。
- en: Hash the salted password using the same hashing algorithm as when the user registered.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与用户注册时相同的哈希算法对加盐后的密码进行哈希处理。
- en: Compare the hash value read from the database to the hash value generated in
    the method. If the two hashes match, then the password is correctly entered and
    the user validated.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从数据库中读取的哈希值与在方法中生成的哈希值进行比较。如果两个哈希值匹配，则表示密码输入正确，用户已验证。
- en: Note that we never decrypt the password from the database. If you have code
    decrypting user passwords and matching that to the password entered, you need
    to reconsider and rewrite your password logic. A system should never be able to
    decrypt user passwords.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们从未从数据库中解密密码。如果你有解密用户密码并匹配输入密码的代码，你需要重新考虑并重写你的密码逻辑。系统永远不应该能够解密用户密码。
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To test the code, add a reference to the `Chapter12` class in your `CodeSamples`
    project:![How to do it…](img/B05391_12_05.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试代码，在你的`CodeSamples`项目中添加对`Chapter12`类的引用：![如何操作…](img/B05391_12_05.jpg)
- en: 'Because we created a static class, you can add the new `using static` to your
    `Program.cs` file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们已经创建了一个静态类，你可以在你的`Program.cs`文件中添加新的`using static`：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Test the code by calling the `RegisterUser()` method and pass it the `username`
    and `password` variable. After that, call the `ValidateLogin()` method and see
    whether the password matches the hash. This would obviously not happen at the
    same time in a real production system:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`RegisterUser()`方法并传入`username`和`password`变量来测试代码。之后，调用`ValidateLogin()`方法，看看密码是否与哈希值匹配。这显然不会在实际的生产系统中同时发生：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you debug the code, you will see the user has been validated:![How to do
    it…](img/B05391_12_06.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你调试代码时，你会看到用户已被验证：![如何操作…](img/B05391_12_06.jpg)
- en: 'Lastly, modify the code slightly and set the `password` variable to something
    else. This will mimic a user entering an incorrect password:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，稍微修改一下代码，将`password`变量设置为其他值。这将模拟用户输入错误密码的情况：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you debug the application, you will see that the user is not validated:![How
    to do it…](img/B05391_12_07.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你调试应用程序时，你会看到用户没有被验证：![如何操作…](img/B05391_12_07.jpg)
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Nowhere in the code did we decrypt the password. In fact, the password is never
    stored anywhere. We always worked with the hash of the password. Here are the
    important points to take away from this recipe:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的任何地方，我们都没有解密密码。事实上，密码从未在任何地方存储过。我们总是与密码的哈希值一起工作。以下是这个菜谱中需要记住的重要点：
- en: Never use the `Random` class in C# to generate your salt. Always use the `RNGCryptoServiceProvider`
    class.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要在C#中使用`Random`类来生成你的盐。始终使用`RNGCryptoServiceProvider`类。
- en: Never re-use the same salt in your code. So don't create a constant with your
    salt and use it to salt all the passwords in your system.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中永远不要重复使用相同的盐。所以不要创建一个包含你的盐的常量，并使用它来对系统中所有的密码进行盐化。
- en: Never tell the user that the password is incorrect if the password didn't match.
    Also, never tell the user that they entered an incorrect username. This prevents
    someone trying to compromise the system from knowing that they got one of the
    two login credentials correct. If either the username or password has been entered
    incorrectly, rather notify the user that their login credentials are incorrect.
    This could mean that either the username or password (or both) have been entered
    incorrectly.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果密码不匹配，不要告诉用户密码错误。同样，也不要告诉用户他们输入了错误的用户名。这可以防止试图破坏系统的人知道他们正确地获得了两个登录凭证中的一个。如果用户名或密码输入错误，最好通知用户他们的登录凭证不正确。这可能意味着用户名或密码（或两者）输入错误。
- en: You can't get the passwords from the hash or salt stored in the database. Therefore,
    if the database was compromised, the password data stored within it would not
    be at risk. The encryption of the user's password is a one-way operation, meaning
    that it can never be decrypted. Also important to note is that even if the source
    code was compromised and stolen by someone with malicious intent, you would not
    be able to use the code to decipher the encrypted data in the database.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无法从数据库中存储的哈希值或盐值中获取密码。因此，如果数据库被破坏，其中存储的密码数据就不会处于风险之中。用户密码的加密是一个单向操作，这意味着它永远不能被解密。同样重要的是要注意，即使源代码被恶意意图的人窃取，您也无法使用该代码来解密数据库中的加密数据。
- en: Combine the previous methods with a strong password policy (because even in
    2016, there are still users that think using `'l3tm31n'` for a password is good
    enough), and you have a very good password encryption routine.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将之前的方法与强大的密码策略相结合（因为即使在2016年，仍然有用户认为使用`'l3tm31n'`作为密码就足够好了），您就拥有了一个非常好的密码加密流程。
- en: 'When we look at the user access table, the correct way to store user credentials
    would look something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看用户访问表时，存储用户凭据的正确方式看起来可能像这样：
- en: '![How it works…](img/B05391_12_08.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B05391_12_08.jpg)'
- en: The salt and hash are stored alongside the username, and are secure because
    they can't be decrypted to expose the actual password.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 盐值和哈希值与用户名一起存储，并且是安全的，因为它们不能被解密以暴露实际密码。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you sign up for a service on the Internet and they send you a confirmation
    either via email or text message and display your password in this message in
    plain text, then you should seriously consider closing your account. If a system
    can read your password and send it to you in plain text, then so can anybody else.
    Never use the same password for all your logins.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在互联网上注册一项服务，并且他们通过电子邮件或短信向您发送确认，并在该消息中以纯文本形式显示您的密码，那么您应该认真考虑关闭您的账户。如果一个系统可以读取您的密码并以纯文本形式将其发送给您，那么任何人都可以这样做。永远不要为所有登录使用相同的密码。
- en: Using SecureString in code
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中使用SecureString
- en: 'Securing your application against malicious attacks is not an easy task. It
    is the constant struggle between writing secure code while minimizing bugs (which
    hackers usually exploit) and black hats writing more and more sophisticated methods
    to compromise systems and networks. I personally believe that higher learning
    institutions need to teach IT students two things:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 保护应用程序免受恶意攻击不是一项容易的任务。这是在编写安全代码的同时最小化错误（黑客通常利用这些错误）和黑帽编写越来越复杂的手段来破坏系统和网络之间的持续斗争。我个人认为，高等教育机构需要教给IT学生两件事：
- en: How to use and integrate with a popular ERP system
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用和集成流行的ERP系统
- en: Proper software security principles
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的软件安全原则
- en: In fact, I believe that secure programming 101 must not simply be a module or
    topic in a given IT course, but a whole course on its own. It needs to be handled
    with the seriousness and respect it deserves and needs to preferably be taught
    by someone that can actually hack a system or network.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我认为安全编程101不应该只是某个IT课程中的一个模块或主题，而应该是一个独立的课程。它需要得到应有的严肃和尊重，并且最好由能够实际入侵系统或网络的人来教授。
- en: White hats teaching students how to compromise systems, exploit vulnerable code,
    and infiltrate networks will make a big difference in changing the way future
    software developers approach programming. It comes down to developers knowing
    what not to do when programming defensively. It is quite possible that some of
    those students might go on to become black hats themselves, but they would have
    done that irrespective of whether they took a class on hacking secure programming
    or not.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 白帽教学生如何妥协系统、利用脆弱的代码和渗透网络，这将大大改变未来软件开发者对待编程的方式。这归结为开发者在进行防御性编程时知道不要做什么。完全有可能，其中一些学生可能会成为黑帽，但这与他们是否参加了关于安全编程黑客的课程无关。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The code might look a little funny in some places. This is because `SecureString`
    is using unmanaged memory to store the sensitive information. Rest assured that
    `SecureString` is well supported and used within the .NET Framework, as can be
    seen from the instantiation of the `SqlCredential` object used in creating connections
    to a database:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在某些地方可能看起来有点奇怪。这是因为 `SecureString` 正在使用非托管内存来存储敏感信息。请放心，`SecureString` 在 .NET
    Framework 中得到了很好的支持和使用，这可以从用于创建数据库连接的 `SqlCredential` 对象的实例化中看出：
- en: '![Getting ready](img/B05391_12_33.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B05391_12_33.jpg)'
- en: How to do it…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Start by adding a new Windows Forms project to your solution:![How to do it…](img/B05391_12_09.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在您的解决方案中添加一个新的 Windows Forms 项目：![如何操作…](img/B05391_12_09.jpg)
- en: Call the project `winformSecure` and click on the **OK** button:![How to do
    it…](img/B05391_12_10.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `winformSecure` 并单击 **确定** 按钮：![如何操作…](img/B05391_12_10.jpg)
- en: In the **Toolbox**, search for the **TextBox** control and add it to your form:![How
    to do it…](img/B05391_12_50.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **工具箱** 中搜索 **TextBox** 控件并将其添加到您的表单中：![如何操作…](img/B05391_12_50.jpg)
- en: Lastly, add a button control to your form. You can resize this form however
    you like to look more like a login form:![How to do it…](img/B05391_12_11.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在您的表单中添加一个按钮控件。您可以随意调整此表单的大小，使其看起来更像登录表单：![如何操作…](img/B05391_12_11.jpg)
- en: With the text box control selected on the Windows Forms, open up the **Properties**
    panel and click on the Events button (it looks like a lightning bolt). In the
    **Key** group, double-click on the **KeyPress** event to create the handler in
    the code behind:![How to do it…](img/B05391_12_12.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows Forms 上选择文本框控件后，打开 **属性** 面板并单击事件按钮（看起来像闪电）。在 **键** 组中，双击 **KeyPress**
    事件以在代码后创建处理程序：![如何操作…](img/B05391_12_12.jpg)
- en: 'The code that is created for you is the **KeyPress** event handler for the
    text box control. This will fire whenever a user presses a key on the keyboard:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为您创建的代码是文本框控制的 **KeyPress** 事件处理程序。这将在用户按下键盘上的任何键时触发：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Back in the **Properties** panel, expand the **Behavior** group and change the
    value of **UseSystemPasswordChar** to `true`:![How to do it…](img/B05391_12_13.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **属性** 面板中，展开 **行为** 组并将 **UseSystemPasswordChar** 的值更改为 `true`：![如何操作…](img/B05391_12_13.jpg)
- en: 'In the code behind, add the following `using` statement:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码后，添加以下 `using` 语句：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `SecureString` variable as a global variable to your Windows Forms:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SecureString` 变量作为全局变量添加到您的 Windows Forms 中：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then in the `KeyPress` event, append the `KeyChar` value to the `SecureString`
    variable every time the user presses a key. You might want to add code to ignore
    certain key presses, but this is beyond the scope of this recipe:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在 `KeyPress` 事件中，每次用户按下键时，将 `KeyChar` 值追加到 `SecureString` 变量中。您可能想要添加代码来忽略某些按键，但这超出了本食谱的范围：
- en: '[PRE11]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then in the **Login** button''s event handler, add the following code to read
    the value from the `SecureString` object. Here we are working with unmanaged memory
    and unmanaged code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在 **登录** 按钮的事件处理程序中，添加以下代码以从 `SecureString` 对象中读取值。我们正在处理非托管内存和非托管代码：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run your Windows Forms application and type in a password:![How to do it…](img/B05391_12_31.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的 Windows Forms 应用程序并输入一个密码：![如何操作…](img/B05391_12_31.jpg)
- en: Then click on the **Login** button. You will then see the password you typed
    in displayed in the message box:![How to do it…](img/B05391_12_32.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击 **登录** 按钮。您将在消息框中看到您输入的密码：![如何操作…](img/B05391_12_32.jpg)
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: It has become almost a habit for many developers to use `System.String` to store
    sensitive information such as passwords. The problem with this approach is that
    `System.String` is immutable. This means that the object created in memory by
    `System.String` can't be changed. If you modify the variable, a new object is
    created in memory. You also cannot determine when the object created by `System.String`
    will be removed from memory during garbage collection. Conversely, by using the
    `SecureString` object, you will encrypt sensitive information and when that object
    is no longer needed, it is deleted from memory. `SecureString` encrypts and decrypts
    your sensitive data in unmanaged memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多开发者来说，使用 `System.String` 来存储敏感信息，如密码，已经成为一种习惯。这种方法的缺点是 `System.String` 是不可变的。这意味着
    `System.String` 在内存中创建的对象不能被更改。如果你修改了变量，就会在内存中创建一个新的对象。你也不能确定 `System.String`
    创建的对象在垃圾回收期间何时会被从内存中移除。相反，通过使用 `SecureString` 对象，你可以加密敏感信息，当该对象不再需要时，它就会被从内存中删除。`SecureString`
    在非托管内存中加密和解密你的敏感数据。
- en: Now I need to be clear regarding one thing here. `SecureString` is by no means
    foolproof. If your system contains a virus with the sole purpose of compromising
    the `SecureString` operations, using it doesn't help much (be sure to use proper
    anti-virus software anyway). At some point during the code execution, the string
    representation of your password (or sensitive information) is visible. Secondly,
    if a hacker somehow found a way to inspect your heap or log your key strokes,
    the password might be visible. The use of `SecureString`, however makes this window
    of opportunity for a hacker much smaller. The window of opportunity reduces because
    there are less attack vectors (points of entry for a hacker), thereby reducing
    your attack surface (sum of all points of attack by a hacker).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我需要在这里明确一点。`SecureString` 绝非万无一失。如果你的系统中存在一个专门用来破坏 `SecureString` 操作的病毒，使用它帮助不大（无论如何，请确保使用合适的反病毒软件）。在代码执行的过程中，你的密码（或敏感信息）的字符串表示形式是可见的。其次，如果黑客找到了一种方法来检查你的堆或记录你的按键，密码可能会被看到。然而，使用
    `SecureString` 使得黑客的机会窗口变得更小。机会窗口的缩小是因为攻击向量（黑客的入口点）更少，从而减少了你的攻击面（黑客所有攻击点的总和）。
- en: 'The bottom line is this: `SecureString` is there for a reason. As a software
    developer concerned about security, you should be using `SecureString`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是：`SecureString` 的存在是有原因的。作为一名关注安全的软件开发者，你应该使用 `SecureString`。
- en: Securing sensitive parts of App.config/web.config
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 App.config/web.config 的敏感部分
- en: As a developer, you will undoubtedly work with sensitive information such as
    passwords. How you handle this information during development is very important.
    In the past, I have received copies of a client's live database to use for testing.
    This does pose a very real security risk for your client.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你无疑会处理诸如密码之类的敏感信息。你在开发过程中如何处理这些信息非常重要。过去，我曾收到一份客户的实时数据库副本用于测试。这对客户来说确实存在一个很大的安全风险。
- en: Often, we keep settings in a `web.config` file (when working with web applications).
    For this example, though, I will be demonstrating a console application that uses
    an `App.config` file. The same logic can be applied to a `web.config` file too.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会在 `web.config` 文件中保存设置（当与网络应用程序一起工作时）。然而，在这个例子中，我将演示一个使用 `App.config`
    文件的控制台应用程序。同样的逻辑也可以应用于 `web.config` 文件。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Creating a console application is the quickest way to demonstrate this recipe.
    If, however, you want to follow along using a web application (and securing a
    `web.config` file), you can do so.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建控制台应用程序是演示这个菜谱的最快方式。如果你想要使用网络应用程序（并保护 `web.config` 文件）来跟随，你也可以这样做。
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In the console application, locate the `App.config` file. This is the file that
    contains the sensitive data:![How to do it…](img/B05391_12_17.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，找到 `App.config` 文件。这是包含敏感数据的文件：![如何操作…](img/B05391_12_17.jpg)
- en: If you open the `App.config` file, you will see that within the `appSettings`
    tag there is a key added called `Secret`. This information should probably not
    be in the `App.config` to start off with. The problem here is that it might be
    checked into your source control. Imagine that on GitHub?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打开 `App.config` 文件，你会看到在 `appSettings` 标签内添加了一个名为 `Secret` 的键。这些信息可能一开始就不应该放在
    `App.config` 文件中。这里的问题可能是它可能会被提交到你的源代码控制中。想象一下在 GitHub 上会怎样？
- en: '[PRE13]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To overcome this vulnerability, we need to move the sensitive data out of the
    `App.config` file into another file. To do this, we specify a path to a file that
    will contain the sensitive data we want to remove from the `App.config` file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了克服这种漏洞，我们需要将敏感数据从 `App.config` 文件移到另一个文件中。为此，我们指定一个包含我们想要从 `App.config` 文件中移除的敏感数据的文件路径：
- en: '[PRE14]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering, why not simply just encrypt the information? Well, that
    is a given really. The reason this value is in plain text is just to demonstrate
    a concept here. You would probably encrypt this value anyway in a real-world situation.
    You would not, however, want this sensitive information sitting on a server in
    a code repository somewhere, even if it is encrypted. Be safe, move it out of
    your solution.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能想知道，为什么不直接加密信息呢？实际上，这确实是既定的。这个值以纯文本形式存在只是为了演示一个概念。在现实世界中，你可能会加密这个值。然而，你肯定不希望这些敏感信息以加密的形式存储在某个代码库的服务器上。请确保安全，将其从你的解决方案中移除。
- en: When you have added the path to the secure file, remove the key containing the
    sensitive information:![How to do it…](img/B05391_12_18.jpg)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加了安全文件的路径后，删除包含敏感信息的密钥：![如何操作…](img/B05391_12_18.jpg)
- en: Navigate to the path you specified in the `App.config` file property. Create
    your `secret.config` file and open it up for editing:![How to do it…](img/B05391_12_19.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `App.config` 文件属性中指定的路径。创建你的 `secret.config` 文件并打开它进行编辑：![如何操作…](img/B05391_12_19.jpg)
- en: Inside this file, repeat the `appSettings` section and add the `Secret` key
    to it. What happens now is that when your console application runs, it reads the
    `appSettings` section in your solution and finds the reference to the secret file.
    It then looks for the secret file and merges it with the `App.config` in your
    solution:![How to do it…](img/B05391_12_20.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，重复 `appSettings` 部分，并将 `Secret` 密钥添加到其中。现在发生的情况是，当你的控制台应用程序运行时，它会读取解决方案中的
    `appSettings` 部分，并找到对秘密文件的引用。然后它会查找秘密文件，并将其与解决方案中的 `App.config` 文件合并：![如何操作…](img/B05391_12_20.jpg)
- en: To see that this merge works, add a reference to your console application:![How
    to do it…](img/B05391_12_14.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证这个合并是否成功，向你的控制台应用程序添加一个引用：![如何操作…](img/B05391_12_14.jpg)
- en: Search for and add `System.Configuration` to your references:![How to do it…](img/B05391_12_15.jpg)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并添加 `System.Configuration` 到你的引用中：![如何操作…](img/B05391_12_15.jpg)
- en: When you have added the reference, your solution references should look something
    like this:![How to do it…](img/B05391_12_16.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加了引用后，你的解决方案引用应该看起来像这样：![如何操作…](img/B05391_12_16.jpg)
- en: 'To the top of your `Program.cs` file, add the following `using` statement:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Program.cs` 文件顶部添加以下 `using` 语句：
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code to read the `Secret` key setting from your `App.config`
    file. Only this time, it will read the merged file, which is made up of your `App.config`
    and your `secret.config` file:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到读取 `Secret` 密钥设置的 `App.config` 文件中。这次，它将读取合并的文件，该文件由你的 `App.config`
    和 `secret.config` 文件组成：
- en: '[PRE16]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run your console application and you will see that the sensitive data has been
    read from the `secret.config` file, which was merged with the `App.config` file
    at runtime:![How to do it…](img/B05391_12_21.jpg)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的控制台应用程序，你会看到敏感数据已经从 `secret.config` 文件中读取，该文件在运行时与 `App.config` 文件合并：![如何操作…](img/B05391_12_21.jpg)
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Something I need to point out here is that this technique will also work for
    `web.config` files. If you need to remove sensitive information from your configuration
    file, move it to another file so that it doesn't get included in your source control
    check-in or deployment.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要指出的是，这种技术也适用于 `web.config` 文件。如果你需要从配置文件中移除敏感信息，请将其移动到另一个文件，这样它就不会包含在源代码控制检查或部署中。
- en: Preventing SQL injection attacks
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止 SQL 注入攻击
- en: SQL injection attacks are a very real problem. There are too many applications
    that still make themselves vulnerable to this kind of attack. If you develop a
    web application or website, you should be vigilant of bad database operations.
    Vulnerable in-line SQL exposes the database to a SQL injection attack. A SQL injection
    attack is where an attacker modifies SQL statements via a web form input box to
    produce a different result than originally intended. This is usually attempted
    on a form where the web application is supposed to access the database to authenticate
    the user login. By not sanitizing the user input, you are exposing your data to
    exploits such as this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入攻击是一个非常现实的问题。有太多应用程序仍然容易受到这种攻击。如果你开发了一个网络应用程序或网站，你应该警惕不良的数据库操作。易受攻击的 SQL
    注入暴露了数据库容易受到这种攻击。SQL 注入攻击是指攻击者通过网页表单输入框修改 SQL 语句，以产生与最初意图不同的结果。这通常发生在网络应用程序应该访问数据库以验证用户登录的表单上。如果不清理用户输入，你将使你的数据容易受到这种攻击的利用。
- en: The accepted solution to mitigate SQL injection attacks is to create a parametrized
    stored procedure and call that from your code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解 SQL 注入攻击的接受解决方案是创建一个参数化存储过程，并从你的代码中调用它。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to create the `CookbookDB` database in your SQL Server before continuing
    this recipe. You will find the script in the `_database scripts` folder in the
    accompanying source code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本菜谱之前，你需要在 SQL Server 中创建 `CookbookDB` 数据库。你可以在附带的源代码中的 `_database scripts`
    文件夹中找到脚本。
- en: How to do it…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: For this recipe, I am using SQL Server 2012\. The concept is the same if you
    are using an older version of SQL Server. After you have created the `CookbookDB`
    database, you will see that there is a table called `UserDisplayData` under the
    `Tables` folder:![How to do it…](img/B05391_12_22.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我使用的是 SQL Server 2012。如果你使用的是更早版本的 SQL Server，概念是相同的。在你创建了 `CookbookDB`
    数据库之后，你会在 `Tables` 文件夹下看到一个名为 `UserDisplayData` 的表：![如何操作…](img/B05391_12_22.jpg)
- en: The `UserDisplayData` table is simply used to illustrate the concept of querying
    using a parameterized stored procedure. It would not have any real benefit in
    a production database, because it only returns a screen name:![How to do it…](img/B05391_12_29.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserDisplayData` 表仅用于说明使用参数化存储过程查询的概念。在生产数据库中，它没有任何实际的好处，因为它只返回一个屏幕名称：![如何操作…](img/B05391_12_29.jpg)'
- en: We need to create a stored procedure to select data from this table for a specific
    ID (user ID). Click on the `Programmability` node to expand it:![How to do it…](img/B05391_12_23.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个存储过程来从表中选择特定 ID（用户 ID）的数据。点击 `Programmability` 节点以展开它：![如何操作…](img/B05391_12_23.jpg)
- en: Next, right-click on the `Stored Procedures` node and select **New Stored Procedure…**
    from the context menu:![How to do it…](img/B05391_12_24.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击 `Stored Procedures` 节点，并从上下文菜单中选择 **New Stored Procedure…**：![如何操作…](img/B05391_12_24.jpg)
- en: 'SQL Server will create the following stored procedure template for you. This
    template consists of a section where you can comment on the particular stored
    procedure, as well as a section to add parameters you might need, and obviously
    a section that you need to add the actual SQL statement to:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQL Server 将为你创建以下存储过程模板。这个模板包括一个可以注释特定存储过程的区域，以及一个可以添加你可能需要的参数的区域，以及显然你需要添加实际
    SQL 语句的区域：
- en: '[PRE17]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Give the stored procedure a suitable name that will describe the action or
    intent of the stored procedure:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给存储过程一个合适的名称，以描述存储过程的行为或意图：
- en: '[PRE18]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are many people that do prefix their stored procedures, and I'm one of
    those. I like to keep my stored procedures grouped. I therefore name my stored
    procedures in the format *[prefix]_[tablename_or_module]_[stored_procedure_action]*.
    Having said that, I generally avoid using `sp_` as a prefix to my stored procedures.
    There are a lot of opinions on the Internet as to why this is a bad idea. It is
    generally believed that using `sp_` as a stored procedure prefix impacts on performance
    because it is used as the stored procedure prefix in the master database.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有很多人在他们的存储过程前加上前缀，我也是其中之一。我喜欢将我的存储过程分组。因此，我按照格式 *[prefix]_[tablename_or_module]_[stored_procedure_action]*
    命名我的存储过程。话虽如此，我通常避免在我的存储过程中使用 `sp_` 作为前缀。互联网上有许多关于为什么这是一个坏主意的意见。普遍认为，使用 `sp_`
    作为存储过程前缀会影响性能，因为它在 master 数据库中用作存储过程前缀。
- en: For the purposes of this recipe, I have just kept to a simple name for the stored
    procedure.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了本菜谱的目的，我只为存储过程保留了简单的名称。
- en: 'Define a parameter for this stored procedure. By doing this, you are telling
    the database that when this stored procedure is called, it will pass through a
    value of type integer that is stored in a parameter caller `@userID`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此存储过程定义一个参数。通过这样做，你是在告诉数据库，当调用此存储过程时，它将通过一个存储在参数调用 `@userID` 中的整数值传递：
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You now define the SQL statement to be used by this stored procedure. We are
    just going to do a straightforward `SELECT` statement:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在定义此存储过程要使用的 SQL 语句。我们只是做一个简单的 `SELECT` 语句：
- en: '[PRE20]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will notice that my `SELECT` statement contains the specific column names
    instead of a `SELECT * FROM`. Doing a `SELECT *` is considered bad practice. You
    would usually not want to return all the column values from a table. If you want
    all the column values, then it is better to explicitly list the columns by name
    instead of just getting all.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到我的 `SELECT` 语句包含特定的列名，而不是使用 `SELECT * FROM`。使用 `SELECT *` 被认为是坏习惯。你通常不希望从表中返回所有列的值。如果你想要所有列的值，那么最好通过名称显式列出列，而不是获取所有列。
- en: Using `SELECT *` returns unnecessary columns and increases the overhead on the
    server. This does make a difference in the bigger scheme of things, especially
    when the database starts getting a lot of traffic.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `SELECT *` 会返回不必要的列，并增加服务器上的开销。这在更大的范围内确实有影响，尤其是在数据库开始大量流量时。
- en: The thought of having to type out the column names for a large table is definitely
    not something I would look forward to. You can however use the following tricks
    to make it easy for you to add the column names to your SQL `SELECT` statement.
    You can right-click on the database table and select **Script Table As** to create
    one of several SQL statements. Secondly, you can expand the `Table` node and expand
    the table you wish to write the statement for. You will then see a node called
    `Columns`. Drag the `Columns` node onto the query editor. That will insert all
    the column names into the query editor for you.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想要为大型表输入列名的想法绝对不是我会期待的事情。然而，你可以使用以下技巧来简化将列名添加到你的 SQL `SELECT` 语句的过程。你可以在数据库表上右键单击并选择
    **Script Table As** 来创建几个 SQL 语句之一。其次，你可以展开 `Table` 节点并展开你想要编写语句的表。然后，你会看到一个名为
    `Columns` 的节点。将 `Columns` 节点拖放到查询编辑器中。这将自动将所有列名插入到查询编辑器中。
- en: When you have completed adding the code to your stored procedure, it will look
    like this:![How to do it…](img/B05391_12_25.jpg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成将代码添加到存储过程后，它看起来会是这样：![如何操作…](img/B05391_12_25.jpg)
- en: To create the stored procedure, you need to click on the **Execute** button.
    Be certain that you have the correct database selected when clicking on the **Execute**
    button:![How to do it…](img/B05391_12_26.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建存储过程，你需要单击 **Execute** 按钮。确保在单击 **Execute** 按钮时已选择正确的数据库：![如何操作…](img/B05391_12_26.jpg)
- en: The stored procedure will then be created under the `Stored Procedures` node
    in SQL Server:![How to do it…](img/B05391_12_27.jpg)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储过程将在 SQL Server 的 `Stored Procedures` 节点下创建：![如何操作…](img/B05391_12_27.jpg)
- en: We have now got to halfway through this task. It is time to construct the code
    that we will use in our application to query the database. We will be adding this
    code directly to the `Program.cs` file of your console application. While this
    code isn't considered best practice (hardcoding the server credentials), it serves
    merely to illustrate the concept of calling a parameterized stored procedure from
    C#.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经完成了这个任务的一半。现在是时候构建我们将在应用程序中用于查询数据库的代码了。我们将直接将此代码添加到控制台应用程序的 `Program.cs`
    文件中。虽然这段代码不被认为是最佳实践（硬编码服务器凭据），但它仅仅是为了说明从 C# 调用参数化存储过程的原理。
- en: 'To start, add the following `using` statement to the top of your console application:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下 `using` 语句添加到控制台应用程序的顶部：
- en: '[PRE21]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then add the variables to contain the credentials we need to log on to the
    server:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加变量来包含我们需要登录服务器的凭据：
- en: '[PRE22]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We now use `SecureString` to store the password and add it to a `SqlCredential`
    object:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在使用 `SecureString` 来存储密码并将其添加到 `SqlCredential` 对象中：
- en: '[PRE23]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more on `SecureString`, see the *Using SecureString in code* recipe of this
    chapter.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于 `SecureString` 的信息，请参阅本章的 *在代码中使用 SecureString* 菜单。
- en: 'We now create a `SqlConnection` object inside a `using` statement. This ensures
    that the SQL connection is closed when the `using` statement moves out of scope:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在 `using` 语句内部创建一个 `SqlConnection` 对象。这确保了当 `using` 语句超出作用域时，SQL 连接将被关闭：
- en: '[PRE24]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the `try`, add the following code to open the connection string and
    create a `SqlCommand` object that takes the open connection and name of the stored
    procedure as parameters. You can use the shortcut method of creating the actual
    SQL parameter to pass to the stored procedure:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try`块中，添加以下代码以打开连接字符串并创建一个`SqlCommand`对象，该对象接受打开的连接和存储过程的名称作为参数。你可以使用创建实际SQL参数的快捷方法将其传递给存储过程：
- en: '[PRE25]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because I''m just passing a parameter of type integer to the stored procedure,
    I''m not defining a length for this parameter:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我只是向存储过程传递一个整型参数，所以我没有为这个参数定义长度：
- en: '![How to do it…](img/B05391_12_30.jpg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/B05391_12_30.jpg)'
- en: 'If, however, you ever need to define a parameter of type `VarChar(MAX)`, you
    would need to define the size of the parameter type by adding `-1`. Let''s say,
    for example you need to store a student''s essay in the database, the code would
    then look as follows for the `VarChar(MAX)`:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，如果你需要定义一个类型为`VarChar(MAX)`的参数，你需要通过添加`-1`来定义参数类型的大小。例如，如果你需要将学生的论文存储到数据库中，那么对于`VarChar(MAX)`的代码将如下所示：
- en: '[PRE26]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After we have added our parameter with its value to the `SqlCommand` object,
    we specify a timeout value, execute the `SqlDataReader`, and load it into a `DataTable`.
    The value is then output to the console application:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将参数及其值添加到`SqlCommand`对象之后，我们指定一个超时值，执行`SqlDataReader`，并将其加载到`DataTable`中。然后，该值被输出到控制台应用程序：
- en: '[PRE27]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After you have added all the code to your console application, the correct
    completed code will look as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你将所有代码添加到控制台应用程序之后，正确的完整代码将如下所示：
- en: '[PRE28]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run your console application and you will see the display name output to the
    screen:![How to do it…](img/B05391_12_28.jpg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的控制台应用程序，你将看到显示名称输出到屏幕上：![如何操作…](img/B05391_12_28.jpg)
- en: How it works…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: By creating a parameterized SQL query, the compiler correctly substitutes the
    arguments before running the SQL statement against the database. It will prevent
    malicious data changing your SQL statement in order to exact a malicious result.
    This is because the `SqlCommand` object does not directly insert the parameter
    values into the statement.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建参数化SQL查询，编译器在运行SQL语句之前正确地替换了参数。它将防止恶意数据更改你的SQL语句以实现恶意结果。这是因为`SqlCommand`对象不会直接将参数值插入到语句中。
- en: To sum it all up, using parameterized stored procedures means no more Little
    Bobby Tables.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，使用参数化存储过程意味着不再有“小鲍比·表格”的问题。
- en: Using Diagnostic Tools and Historical Debugging
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用诊断工具和历史调试
- en: The trusty old bug has been the bane of software developers and engineers for
    more than 140 years. Yes, you read that right. It was in fact Thomas Edison that
    coined the term "bug" in the late 1870s. It appeared in many of his notebook entries
    where he describes for example that the incandescent lightbulb still had many
    "bugs left."
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可靠的旧虫子已经成为了软件开发者和工程师们超过140年的噩梦。是的，你没有看错。实际上，是托马斯·爱迪生在19世纪70年代末提出了“bug”这个术语。这个词出现在他许多笔记本条目中，例如，他描述了白炽灯泡仍然有许多“bug”未解决。
- en: His efforts to debug his inventions are quite legendary. Consider the true grit
    and determination it took for a man already in his mid-sixties to work 112-hour
    working weeks. He and his seven-person team (it is a common misconception that
    there were only six because the seventh member didn't appear in the group photograph)
    became known as the insomnia squad during a 5-week stint that resulted in very
    little sleep.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 他调试发明的努力是非常传奇的。考虑一下，一个已经六十多岁的男人需要工作112小时的工作周，这需要多大的真金不怕火炼和决心。他和他的七人团队（有一个常见的误解，认为只有六个人，因为第七个人没有出现在团队照片中）在5周的艰苦工作中几乎没睡过觉，因此被称为“失眠小队”。
- en: 'These days, thanks to advances in technology, software developers have a vast
    array of debugging tools (inside and outside of Visual Studio) at their disposal.
    So does debugging really matter? Of course it does. It is part of what we as software
    developers do. If we don''t debug, well, here are some examples:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于技术的进步，软件开发者可以拥有大量的调试工具（在Visual Studio内部和外部）可供使用。那么调试真的重要吗？当然很重要。它是我们作为软件开发者所做的一部分。如果我们不调试，那么这里有一些例子：
- en: In 2004, the **Electronic Data Systems** (**EDS**) Child Support System in the
    UK overpaid almost 2 million people, underpaying almost a million and resulted
    in billions of dollars in uncollected child support payments. The incompatibility
    between EDS and another system it relied on resulted in taxpayers losing money
    and negatively affecting the lives of so many single parents.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在2004年，英国**电子数据系统公司**（**EDS**）的儿童抚养金系统向近200万人多付了抚养金，向近100万人少付了抚养金，导致数十亿美元的抚养金未能收回。EDS与它依赖的另一个系统之间的不兼容性导致纳税人损失了钱财，并负面影响了许多单身父母的生活。
- en: The initial release of Apple Maps in 2012\. Enough said. While bemusing for
    many, I still find myself using Google Maps for turn-by-turn directions when in
    an unfamiliar city or area.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2012年苹果地图的首次发布。无需多言。尽管对许多人来说令人困惑，但我仍然在陌生的城市或地区使用谷歌地图进行路线导航。
- en: The Therac-25 radiation therapy machine used electrons to target tumors in patients.
    Unfortunately, a race condition in the software caused the machine to deliver
    lethal overdoses of radiation in several patients.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Therac-25放射治疗机使用电子束靶向患者的肿瘤。不幸的是，软件中的竞争条件导致机器向几位患者提供了致命的过量辐射。
- en: Examples of software bugs affecting the lives of millions of people can be found
    all over the Internet. We're not simply talking about the run-of-the-mill bugs
    either. Sometimes we're faced with seemingly insurmountable issues. It is the
    comfort of knowing how to use some of the tools available that makes the difference
    between a stable application and one that is totally unusable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上可以找到许多影响数百万人的软件缺陷的例子。我们不仅仅是在谈论普通的缺陷。有时我们面临的是看似无法克服的问题。知道如何使用一些可用工具的安慰，是稳定应用程序和完全无法使用应用程序之间的区别。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: As of writing this, IntelliTrace is only available in Visual Studio 2015 Enterprise.
    IntelliTrace is, however, not a new feature in Visual Studio. It has evolved over
    time, since Visual Studio 2010, into what we have available today.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到我写这篇文章的时候，IntelliTrace仅在Visual Studio 2015 Enterprise中可用。然而，IntelliTrace并不是Visual
    Studio的新特性。自Visual Studio 2010以来，它已经随着时间的推移发展成我们今天所拥有的功能。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First off, go to **Tools** | **Options**:![How to do it…](img/B05391_12_34.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到**工具** | **选项**：![如何操作…](img/B05391_12_34.jpg)
- en: Expand the **IntelliTrace** node and click on **General**. Ensure that **Enable
    IntalliTrace** is checked. Also, make sure that the **IntelliTrace events and
    call information** option is selected. Click on **OK**:![How to do it…](img/B05391_12_35.jpg)
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开IntelliTrace节点并点击**常规**。确保**启用IntelliTrace**被勾选。同时，确保**IntelliTrace事件和调用信息**选项被选中。点击**确定**：![如何操作…](img/B05391_12_35.jpg)
- en: 'In the `Recipes.cs` file, you might need to add the following `using` statements:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Recipes.cs`文件中，你可能需要添加以下`using`语句：
- en: '[PRE29]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add a method called `ErrorInception()` to the `Recipes` class. Also, add the
    code to read the base path and assume that there is a folder called `log`. Do
    not create this folder on your hard drive. We want an exception to be thrown.
    Lastly, add another method called `LogException()` that does nothing:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Recipes`类添加一个名为`ErrorInception()`的方法。同时，添加读取基本路径的代码，并假设存在一个名为`log`的文件夹。不要在你的硬盘上创建此文件夹。我们希望抛出一个异常。最后，添加另一个名为`LogException()`的方法，它不做任何事情：
- en: '[PRE30]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following code to your `ErrorInception()` method after the full path
    has been determined. Here we are trying to open the log file. This is where the
    exception will occur:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确定完整路径后，将以下代码添加到`ErrorInception()`方法中。这里我们正在尝试打开日志文件。这就是异常将发生的地方：
- en: '[PRE31]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you have added all your code, your code should look like this:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加了所有代码后，你的代码应该看起来像这样：
- en: '[PRE32]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `Program.cs` file, call the `ErrorInception()` method. Right after that,
    do a `Console.ReadLine()` so that our console application will pause there. Do
    not add any breakpoints anywhere to your code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，调用`ErrorInception()`方法。紧接着，执行`Console.ReadLine()`，以便我们的控制台应用程序在此处暂停。不要在你的代码中添加任何断点：
- en: '[PRE33]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Start debugging your application. The exception is thrown and the application
    continues running, a condition often experienced with much more complex applications.
    At this point, you would expect a log file to be appended with the fictitious
    data of the app, but nothing happened. It is at this point that you stop your
    application and start adding breakpoints all over your code in a hit and miss-type
    exercise. I say hit and miss because you probably will not know exactly where
    the error is. This is especially true if your code file contains a few thousand
    lines of code.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试你的应用程序。异常被抛出，应用程序继续运行，这是在更复杂的应用程序中经常遇到的情况。在这个时候，你可能会期望日志文件附加了应用程序的虚构数据，但什么也没有发生。正是在这个时候，你停止应用程序，并在你的代码中到处添加断点，进行一种试错练习。我说试错，因为你可能不知道错误的确切位置。如果你的代码文件包含几千行代码，这种情况尤其如此。
- en: 'Well now, with IntelliTrace and Historical Debugging, you just need to click
    on the **Break All** button:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好吧，现在，有了IntelliTrace和历史调试，你只需要点击**Break All**按钮：
- en: '![How to do it…](img/B05391_12_41.jpg)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/B05391_12_41.jpg)'
- en: Your application is now essentially paused. If you don't see the **Diagnostic
    Tools** window, go to **Debug** and click on **Show Diagnostic Tools** (or *Ctrl*
    + *Alt* + *F2*):![How to do it…](img/B05391_12_40.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的应用程序现在基本上是暂停的。如果你看不到**诊断工具**窗口，请转到**调试**并点击**显示诊断工具**（或*Ctrl* + *Alt* + *F2*）：![如何操作…](img/B05391_12_40.jpg)
- en: Visual Studio now displays the **Diagnostic Tools** window. Immediately you
    can see that there is a problem indicated by the red diamond icon on the **Events**
    section. In the **Events** tab at the bottom, you can click on the exception:![How
    to do it…](img/B05391_12_42.jpg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio现在显示**诊断工具**窗口。立即你可以看到在**事件**部分由红色菱形图标指示的问题。在底部的**事件**选项卡中，你可以点击异常：![如何操作…](img/B05391_12_42.jpg)
- en: Doing this expands the exception details, where you can see that the log file
    was not found. Visual Studio, however, goes one step further with Historical Debugging:![How
    to do it…](img/B05391_12_43.jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这件事可以扩展异常详细信息，你可以看到日志文件未找到。然而，Visual Studio在历史调试方面更进一步：![如何操作…](img/B05391_12_43.jpg)
- en: You will see a link at the bottom of the exception details that says **Activate
    Historical Debugging**. Click on this link. This allows you to see the actual
    line of code that caused this exception in the code editor. It also allows you
    to view the history of the application's state in the **Locals** window, call
    stack, and other windows. You now can see the specific line of code that caused
    the exception in your code editor. In the **Locals** window, you can also see
    what the path was that the application used to look for the log file. This kind
    of debugging experience is immensely powerful and allows developers to go straight
    to the source of the error. This leads to increased productivity and better code:![How
    to do it…](img/B05391_12_44.jpg)
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在异常详细信息底部看到一个链接，上面写着**激活历史调试**。点击此链接。这允许你在代码编辑器中看到导致此异常的实际代码行。它还允许你在**局部变量**窗口、调用堆栈和其他窗口中查看应用程序的状态历史。现在你可以在代码编辑器中看到导致异常的具体代码行。在**局部变量**窗口中，你还可以看到应用程序用来查找日志文件的路径。这种调试体验非常强大，允许开发者直接找到错误的源头。这导致生产力的提高和更好的代码：![如何操作…](img/B05391_12_44.jpg)
- en: How it works…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: So what is the takeaway here? If you only remember one thing, remember this.
    Once the users of your system lose faith in the abilities and potential of that
    system due to bugs, that confidence is almost impossible to regain. Even if you
    resurrect your system from the ashes, after it was laid low by bugs and other
    issues, to produce a flawless product, your users will not be easily swayed. This
    is because in their mind, the system is buggy.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里的关键点是什么？如果你只能记住一件事，那就记住这一点。一旦你的系统用户因为bug而失去对该系统能力和潜力的信心，这种信心几乎无法恢复。即使你从bug和其他问题中恢复你的系统，重新启动它，并生产出一个无瑕疵的产品，用户也不会轻易被说服。这是因为在他们心中，系统是有bug的。
- en: I once had to take over a system partially developed by a senior developer who
    was leaving the company. She had an excellent specification and a well presented
    prototype shown to the customer. The only problem was that she left the company
    shortly after the system's phase one was implemented. When the bugs came popping
    up, the client naturally asked for her assistance.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经接管了一个由即将离职的高级开发者部分开发完成的系统。她有一个优秀的规范和一个展示给客户的良好展示的原型。唯一的问题是她在系统第一阶段实施后不久就离开了公司。当bug开始出现时，客户自然要求她提供帮助。
- en: Telling the client that the developer (who has been solely responsible for building
    a relationship with the client) has left the company did not bode well to instil
    a sense of confidence. Having a single developer involved was the first mistake
    of this particular project anyway.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉客户，负责与客户建立关系的开发者（一直负责构建这种关系）已经离开公司，这对建立信心并没有好处。在这个特定项目中，只有一个开发者参与本身就是第一个错误。
- en: Secondly, phase two was about to be developed by yours truly, who was also the
    only developer assigned to this client. This had to be done while building on
    top of the buggy phase one. So I was fixing bugs while developing new features
    for the system. Luckily this time round, I had a fantastic project manager called
    Rory Shelton as my wingman. Together we were dumped in the deep end and Rory did
    a fantastic job managing the client's expectations while being totally transparent
    with the client regarding the challenges we were facing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，第二阶段将由我亲自开发，我也是唯一被分配给这个客户的开发者。这必须在构建在存在问题的第一阶段之上时完成。所以我一边修复错误，一边为系统开发新功能。幸运的是，这次我有一个叫罗里·谢尔顿的出色项目经理作为我的助手。我们一起跳进了深水区，罗里在管理客户的期望方面做得非常出色，同时对我们面临挑战的透明度也做得很好。
- en: The users were unfortunately already disillusioned with the provided system
    and didn't trust the software. This trust was never fully regained. If we had
    IntelliTrace and Historical Debugging back in 2007, I definitely would have been
    able to track down the issues in a code base that was unfamiliar to me.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用户已经对提供的系统感到失望，并且不相信软件。这种信任从未完全恢复。如果我们早在 2007 年就有 IntelliTrace 和历史调试，我肯定能够追踪到一个对我来说不熟悉的代码库中的问题。
- en: Always debug your software. When you find no more bugs, debug it again. Then
    give the system to my mom (love you mom). You as the developer of that system
    know which buttons to click and what data to enter, and in which order things
    need to happen. My mom doesn't and I can assure you that a user unfamiliar with
    a system can break it quicker than you can brew a fresh cup of coffee.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 总是调试你的软件。当你发现没有更多的错误时，再次调试它。然后把系统给我的妈妈（爱你妈妈）。作为该系统的开发者，你知道哪些按钮要点击，哪些数据要输入，以及事情需要发生的顺序。我的妈妈不知道，我可以向你保证，一个不熟悉系统的用户可以比你能煮一杯新鲜咖啡更快地破坏它。
- en: Visual Studio provides developers with a very powerful and feature rich set
    of debugging tools. Use them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 为开发者提供了一套非常强大且功能丰富的调试工具。使用它们。
- en: Setting conditional breakpoints
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置条件断点
- en: Conditional breakpoints are another hidden gem when it comes to debugging. These
    allow you to specify one or several conditions. When one of these conditions are
    met, the code will stop at the breakpoint. Using conditional breakpoints is really
    easy.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 条件断点是调试中的另一个隐藏的宝石。这些允许你指定一个或多个条件。当这些条件之一满足时，代码将在断点处停止。使用条件断点非常简单。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is nothing you specifically need to prepare to use this recipe.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个配方，你不需要特别准备任何东西。
- en: How to do it…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Add the following code to your `Program.cs` file. We are simply creating a
    list of integers and looping through that list:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 `Program.cs` 文件中。我们只是创建了一个整数列表并遍历该列表：
- en: '[PRE34]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, place a breakpoint on the `Console.WriteLine(num)` line of code inside
    the loop:![How to do it…](img/B05391_12_45.jpg)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在循环内的 `Console.WriteLine(num)` 代码行上放置一个断点：![如何做…](img/B05391_12_45.jpg)
- en: Right-click on the breakpoint and select **Conditions…** from the context menu:![How
    to do it…](img/B05391_12_46.jpg)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击断点并从上下文菜单中选择 **条件…**：![如何做…](img/B05391_12_46.jpg)
- en: You will now see that Visual Studio opens a **Breakpoint Settings** window.
    Here we specify that the breakpoint needs to be hit only when the value of `num`
    is `9`. You can add several conditions and specify different conditions. The condition
    logic is really flexible:![How to do it…](img/B05391_12_47.jpg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你会看到 Visual Studio 打开一个 **断点设置** 窗口。在这里，我们指定只有当 `num` 的值为 `9` 时，断点才需要被触发。你可以添加多个条件并指定不同的条件。条件逻辑非常灵活：![如何做…](img/B05391_12_47.jpg)
- en: Debug your console application. You will see that when the breakpoint is hit,
    the value of `num` is `9`:![How to do it…](img/B05391_12_48.jpg)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试你的控制台应用程序。你会看到当断点被触发时，`num` 的值是 `9`：![如何做…](img/B05391_12_48.jpg)
- en: How it works…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The condition is evaluated on every loop. When the condition is true, the breakpoint
    will be hit. In the example illustrated in this recipe, the true benefit of a
    conditional breakpoint is somewhat lost because it is a very small list. Consider
    this though. You are binding a data grid. Items on the grid are given specific
    icons based on the status of the item. Your grid contains hundreds of items, because
    this is a hierarchical grid. You identify the primary ID of the item which is
    bound to the grid. This primary ID is then passed to other code logic to determine
    the status, which determines the icon displayed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 条件在每次循环时都会被评估。当条件为真时，断点将被触发。在本食谱中展示的示例中，条件断点的真正好处有些被忽略了，因为它是一个非常小的列表。但考虑一下。您正在绑定一个数据网格。网格中的项目根据项目状态被赋予特定的图标。由于这是一个分层网格，您的网格包含数百个项目。您识别出绑定到网格的项目的主ID。然后，将此主ID传递给其他代码逻辑以确定状态，该状态决定了显示的图标。
- en: To debug and press the *F10* key through hundreds of loops is not productive
    in any event. With conditional breakpoints, you can specify a value for the primary
    ID, and only break when the loop hits that value. You can then go straight to
    the item that is being displayed incorrectly.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数百次循环来调试并按下 *F10* 键在任何情况下都是没有效率的。使用条件断点，您可以为主ID指定一个值，并且只有当循环达到该值时才会中断。然后您可以直接跳转到显示不正确的项目。
- en: Using PerfTips to identify bottlenecks in code
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PerfTips 识别代码中的瓶颈
- en: PerfTips are definitely one of my favorite features of Visual Studio 2015\.
    Explaining what they do doesn't do them justice. You have to see them in action.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: PerfTips 一定是 Visual Studio 2015 中我最喜欢的功能之一。解释它们的作用并不能真正公正地对待它们。您必须看到它们在实际操作中的效果。
- en: Getting ready
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Do not confuse PerfTips with CodeLens. PerfTips is a separate option from CodeLens
    in Visual Studio.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将 PerfTips 与 CodeLens 混淆。PerfTips 是 Visual Studio 中与 CodeLens 不同的独立选项。
- en: How to do it…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: PerfTips are enabled by default. But just in case you are not seeing any PerfTips,
    go to **Tools** | **Options**, and expand the **Debugging** node. Under **General**,
    to the bottom of the settings page, you will see an option called **Show elapsed
    time PerfTip while debugging**. Ensure that this option is checked:![How to do
    it…](img/B05391_12_36.jpg)
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PerfTips 默认启用。但以防您没有看到任何 PerfTips，请转到 **工具** | **选项**，并展开 **调试** 节点。在 **常规**
    下，设置页面底部，您将看到一个名为 **在调试时显示已过时间 PerfTip** 的选项。确保此选项被选中：![如何操作…](img/B05391_12_36.jpg)
- en: 'We will create a few simple methods that mimic long-running tasks. To do this,
    we will just sleep the thread for a couple of seconds. In the `Recipes.cs` file,
    add the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一些简单的模拟长时间运行任务的方法。为此，我们只需让线程休眠几秒钟。在 `Recipes.cs` 文件中，添加以下代码：
- en: '[PRE35]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In your console application, call the static method `RunFastTask()` and place
    a breakpoint on this line of code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的控制台应用程序中，调用静态方法 `RunFastTask()` 并在此行代码上放置断点：
- en: '[PRE36]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Start debugging your console application. Your breakpoint will stop on the `RunFastTask()`
    method. Hit *F10* to step over this method:![How to do it…](img/B05391_12_37.jpg)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试您的控制台应用程序。您的断点将停在 `RunFastTask()` 方法上。按 *F10* 跳过此方法：![如何操作…](img/B05391_12_37.jpg)
- en: You will notice that 11 seconds later, the next line will be highlighted and
    the PerfTip will be displayed. The PerfTip displays the time it took for the previous
    line of code to execute. So the debugger that now sits on the `Thread.Sleep`,
    shows that the `RunFastTask()` method took 11 seconds to complete. The task is
    clearly not very fast:![How to do it…](img/B05391_12_38.jpg)
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到11秒后，下一行将被突出显示，并显示 PerfTip。PerfTip 显示了上一行代码执行所需的时间。因此，现在位于 `Thread.Sleep`
    上的调试器显示 `RunFastTask()` 方法花费了11秒来完成。显然，这个任务并不快：![如何操作…](img/B05391_12_38.jpg)
- en: Stepping in to the `RunFastTask()` method, you can place further breakpoints
    and step over them one by one to find the method that is causing the longest delay.
    As you can see, PerfTips allow developers to quickly and easily identify bottlenecks
    in code:![How to do it…](img/B05391_12_39.jpg)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步入 `RunFastTask()` 方法，您可以放置更多的断点并逐个跳过它们以找到导致最长延迟的方法。正如您所看到的，PerfTips 允许开发者快速轻松地识别代码中的瓶颈：![如何操作…](img/B05391_12_39.jpg)
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are many tools on the market that do this and much more, allowing developers
    to view all sorts of code metrics. PerfTips, however, allow you to see issues
    on the fly while you are stepping through your code as per your normal debugging
    tasks. It is, in my opinion, an indispensable debugging tool.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有许多工具可以进行这项操作以及更多，让开发者能够查看各种代码指标。然而，PerfTips 允许你在按照常规调试任务逐步执行代码时即时查看问题。在我看来，它是一个不可或缺的调试工具。
