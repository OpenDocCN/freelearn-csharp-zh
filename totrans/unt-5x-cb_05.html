<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Using Cameras</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a picture-in-picture effect</li><li class="listitem" style="list-style-type: disc">Switching between multiple cameras</li><li class="listitem" style="list-style-type: disc">Making textures from screen content</li><li class="listitem" style="list-style-type: disc">Zooming a telescopic camera</li><li class="listitem" style="list-style-type: disc">Displaying a mini-map</li><li class="listitem" style="list-style-type: disc">Creating an in-game surveillance camera</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Introduction</h1></div></div></div><p>As developers, we should never forget to pay attention to the cameras. After all, they are the windows through which our players see our games. In this chapter, we will take a look at interesting ways of using cameras that enhance the player's experience.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec143"/>The big picture</h2></div></div></div><p>Cameras can be <a class="indexterm" id="id429"/>customized in many ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They can exclude objects on specific layers from rendering</li><li class="listitem" style="list-style-type: disc">They can be set to render in<a class="indexterm" id="id430"/> <strong>Orthographic</strong> mode (that is, without perspective)</li><li class="listitem" style="list-style-type: disc">They can have their<a class="indexterm" id="id431"/> <strong>Field of View</strong> (<strong>FOV</strong>) manipulated to simulate a wide angle lens</li><li class="listitem" style="list-style-type: disc">They can be rendered on top of other cameras or within specific areas of the screen</li><li class="listitem" style="list-style-type: disc">They can be rendered onto Textures</li></ul></div><p>The list goes on.</p><div><img alt="The big picture" src="img/1362OT_05_00.jpg"/><div><p>Two simultaneous camera views</p></div></div><p>Note that<a class="indexterm" id="id432"/> throughout this chapter you will notice that some recipes feature a camera rig that follows the player's third-person character. That rig is the <strong>Multipurpose Camera Rig</strong>, originally <a class="indexterm" id="id433"/>available from Unity's sample assets, which <a class="indexterm" id="id434"/>can be imported into your projects by navigating to <strong>Assets</strong> | <strong>Import Package</strong> | <strong>Camera</strong>. To make things easier, we organized the <code class="literal">MultipurposeCamera</code> Unity Package containing it as a prefab, which can be found in the <code class="literal">1362_05_codes</code> folder.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Creating a picture-in-picture effect</h1></div></div></div><p>Having more than one viewport displayed can be useful in many situations. For example, you may want to show simultaneous events going on in different locations, or you may want to have a<a class="indexterm" id="id435"/> separate window for hot-seat multiplayer games. Although you can do this manually by adjusting the <strong>Normalized Viewport Rect</strong> parameters on your camera, this recipe includes a series of extra preferences to make it more independent from the user's display configuration.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec144"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared the <code class="literal">BasicScene</code> Unity package, containing a scene named <code class="literal">BasicScene</code>. The package is in the <code class="literal">1362_05_codes</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec145"/>How to do it...</h2></div></div></div><p>To create a picture-in-picture display, just follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">BasicScene</code> package into your Unity Project.</li><li class="listitem">From the <strong>Project</strong> view, open the <strong>BasicScene</strong> level. This is a basic scene featuring an animated character and some extra geometry.</li><li class="listitem">Add a new <strong>Camera</strong> to the scene through the <strong>Create</strong> drop-down menu on top of the <strong>Hierarchy</strong> view (<strong>Create</strong> | <strong>Camera</strong>).</li><li class="listitem">Select the camera you have created and, from the <strong>Inspector</strong> view, change its <strong>Depth</strong> to <strong>1</strong>, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362OT_05_01.jpg"/></div></li><li class="listitem">From the <strong>Project</strong> view, create a new <strong>C# Script</strong> file and rename it <code class="literal">PictureInPicture</code>.</li><li class="listitem">Open your <a class="indexterm" id="id436"/>script and replace everything with the following code:<div><pre class="programlisting">using UnityEngine;

public class PictureInPicture: MonoBehaviour {
  public enum hAlignment{left, center, right};
  public enum vAlignment{top, middle, bottom};
  public hAlignment horAlign = hAlignment.left;
  public vAlignment verAlign = vAlignment.top;
  public enum UnitsIn{pixels, screen_percentage};
  public UnitsIn unit = UnitsIn.pixels;
  public int width = 50;
  public int height= 50;
  public int xOffset = 0;
  public int yOffset = 0;
  public bool  update = true;
  private int hsize, vsize, hloc, vloc;

  void Start (){
    AdjustCamera ();
  }

  void Update (){
    if(update)
    AdjustCamera ();
  }

  void AdjustCamera(){
    int sw = Screen.width;
    int sh = Screen.height;
    float swPercent = sw * 0.01f;
    float shPercent = sh * 0.01f;
    float xOffPercent = xOffset * swPercent;
    float yOffPercent = yOffset * shPercent;
    int xOff;
    int yOff;
    if(unit == UnitsIn.screen_percentage){
      hsize = width * (int)swPercent;
      vsize = height * (int)shPercent;
      xOff = (int)xOffPercent;
      yOff = (int)yOffPercent;
    } else {
      hsize = width;
      vsize = height;
      xOff = xOffset;
      yOff = yOffset;
    }

    switch (horAlign) {
      case hAlignment.left:
      hloc = xOff;
      break;
      case hAlignment.right:
      int justfiedRight = (sw - hsize);
      hloc = (justfiedRight - xOff);
      break;
      case hAlignment.center:
      float justifiedCenter = (sw * 0.5f) - (hsize * 0.5f);
      hloc = (int)(justifiedCenter - xOff);
      break;
    }

    switch (verAlign) {
      case vAlignment.top:
      int justifiedTop = sh - vsize;
      vloc = (justifiedTop - (yOff));
      break;
      case vAlignment.bottom:
      vloc = yOff;
      break;
      case vAlignment.middle:
      float justifiedMiddle = (sh * 0.5f) - (vsize * 0.5f);
      vloc = (int)(justifiedMiddle - yOff);
      break;
    }

    GetComponent&lt;Camera&gt;().pixelRect = new Rect(hloc,vloc,hsize,vsize);
  }
}</pre></div><div><div><h3 class="title"><a id="note33"/>Note</h3><p>In case you<a class="indexterm" id="id437"/> haven't noticed, we are not achieving percentages by dividing numbers by 100, but rather multiplying them by 0.01. The reason behind this is that computer processors are faster at multiplying than dividing.</p></div></div></li><li class="listitem">Save your script and attach it to the camera you previously created.</li><li class="listitem">Uncheck the new camera's <strong>Audio Listener</strong> component and change some of the <strong>PictureInPicture</strong> parameters: change <strong>Hor Align</strong> to <code class="literal">right</code>, <strong>Ver Align</strong> to <code class="literal">top</code>, and <strong>Unit</strong> to <code class="literal">pixels</code>. Leave <strong>XOffset</strong> and <strong>YOffset</strong> as <code class="literal">0</code>, change <strong>Width</strong> to <code class="literal">400</code> and <strong>Height</strong> to <code class="literal">200</code>, as<a class="indexterm" id="id438"/> shown here:<div><img alt="How to do it..." src="img/1362OT_05_02.jpg"/></div></li><li class="listitem">Play your scene. The new camera's viewport should be visible in the top-right corner of the screen, as shown below:<div><img alt="How to do it..." src="img/1362OT_05_03.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec146"/>How it works...</h2></div></div></div><p>In this example, we added a second camera in order to display the scene from a different point of view. The second camera's relative viewport was originally placed on top of the <strong>Main Camera</strong>'s viewport, hence taking up all of the screen space.</p><p>The <code class="literal">PictureInPicture</code> script changes the camera's <strong>Normalized Viewport Rect</strong>, thus resizing and <a class="indexterm" id="id439"/>positioning the viewport according to the user's preferences.</p><p>First, it reads user preferences for the component (dimensions, alignment, and offset for the PiP viewport) and converts dimensions in screen percentage to pixels.</p><p>Later, from the <code class="literal">if(unit == UnitsIn.screen_percentage){</code> conditional, the script calculates two of the viewport Rect parameters (width and height) according to the user's selection.</p><p>Later on, to <strong>switch</strong> statements to adjust the other two viewport Rect parameters (horizontal and vertical location) according to the total screen dimensions, PiP viewport dimension, vertical/horizontal alignment, and offset.</p><p>Finally, a line of code tells the camera to change the location and dimensions of the camera's <strong>Viewport Rect</strong>:</p><div><pre class="programlisting">GetComponent&lt;Camera&gt;().pixelRect = new Rect(hloc,vloc,hsize,vsize);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec147"/>There's more...</h2></div></div></div><p>The following are <a class="indexterm" id="id440"/>some aspects of your picture-in-picture that you could change:</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec35"/>Making the picture-in-picture proportional to the screen's size</h3></div></div></div><p>If you<a class="indexterm" id="id441"/> change the <strong>Unit</strong> option to <code class="literal">screen_percentage</code>, the viewport size will be based on the actual screen's dimensions instead of pixels.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec36"/>Changing the position of the picture-in-picture</h3></div></div></div><p>The <strong>Ver Align</strong> and<a class="indexterm" id="id442"/> <strong>Hor Align</strong> options can be used to change the viewport's vertical and horizontal alignment. Use them to place it where you wish.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec37"/>Preventing the picture-in-picture from updating on every frame</h3></div></div></div><p>Leave the <a class="indexterm" id="id443"/><strong>Update</strong> option unchecked if you don't plan to change the viewport position in running mode. Also, it's a good idea to leave it checked when testing and uncheck it once the position has been decided and set up.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec148"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Displaying a mini-map</em> recipe in this chapter</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Switching between multiple cameras</h1></div></div></div><p>Choosing from a variety of cameras is a common feature in many genres: racing, sports, tycoon/strategy, and many others. In this recipe, you will learn how to give players the ability to choose <a class="indexterm" id="id444"/>from many cameras by using their keyboards.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec149"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared the <code class="literal">BasicScene</code> Unity package containing a scene named <code class="literal">BasicScene</code>. The package is in the <code class="literal">1362_05_codes</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec150"/>How to do it...</h2></div></div></div><p>To implement switchable cameras, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">BasicScene</code> package into a new <strong>Project</strong>.</li><li class="listitem">From the <strong>Project</strong> view, open the <strong>BasicScene</strong> level. This is a basic scene featuring an animated character and some extra geometry.</li><li class="listitem">Add two more cameras to the scene through the <strong>Create</strong> drop-down menu on top of the <strong>Hierarchy</strong> view (<strong>Create</strong> | <strong>Camera</strong>). Rename them <code class="literal">cam1</code> and <code class="literal">cam2</code>.</li><li class="listitem">Change the <code class="literal">cam2</code> camera's position and rotation so that it won't be identical to <code class="literal">cam1</code>.</li><li class="listitem">Create an <strong>Empty</strong> GameObject by navigating to the <strong>Create</strong> drop-down menu on top of the<a class="indexterm" id="id445"/> <strong>Hierarchy</strong> view (<strong>Create</strong> | <strong>Create Empty</strong>). Then, rename it <code class="literal">Switchboard</code>.</li><li class="listitem">From the <strong>Inspector</strong> view, disable the <strong>Camera</strong> and <strong>Audio Listener</strong> components of both <code class="literal">cam1</code> and <code class="literal">cam2</code>. Also, set their <strong>Tags</strong> as <strong>MainCamera</strong>, as shown:<div><img alt="How to do it..." src="img/1362OT_05_04.jpg"/></div></li><li class="listitem">From the <strong>Project</strong> view, create a new <strong>C# Script</strong> file. Rename it <code class="literal">CameraSwitch</code> and open it in your editor.</li><li class="listitem">Open your script and replace everything with the following code:<div><pre class="programlisting">using UnityEngine;

public class CameraSwitch : MonoBehaviour {
  public GameObject[] cameras;
  public string[] shortcuts;
  public bool  changeAudioListener = true;
  void  Update (){
    if (Input.anyKeyDown) {
      for (int i=0; i&lt;cameras.Length; i++) {
        if (Input.GetKeyDown (shortcuts [i]))
          SwitchCamera (i);
      }
    }
  }

void  SwitchCamera (int indexToSelect){
  for (int i = 0; i&lt;cameras.Length; i++){
    // test whether current array index matches camera to make active
      bool cameraActive = (i == indexToSelect);
      cameras[i].GetComponent&lt;Camera&gt;().enabled = cameraActive;

    if (changeAudioListener)
          cameras[i].GetComponent&lt;AudioListener&gt;().enabled = cameraActive;
      }
    }
}</pre></div></li><li class="listitem">Attach <code class="literal">CameraSwitch</code> to the <code class="literal">Switchboard</code> GameObject.</li><li class="listitem">From the <strong>Inspector</strong> <a class="indexterm" id="id446"/>view, set both the <strong>Cameras</strong> and <strong>Shortcuts</strong> sizes to <code class="literal">3</code>. Then, drag and populate the <strong>Cameras</strong> slots with the cameras from the scene (including the <strong>Main Camera</strong>, within the <strong>Multipurpose Camera Rig</strong> | <strong>Pivot</strong> GameObject) Then, type <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code> into the <strong>Shortcuts</strong> text fields, as shown in the next screenshot:<div><img alt="How to do it..." src="img/1362OT_05_05.jpg"/></div></li><li class="listitem">Play your scene and test your cameras by pressing <em>1</em>, <em>2</em>, and <em>3</em> on the keyboard.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec151"/>How it works...</h2></div></div></div><p>The script is very straightforward. First, it compares the key being pressed to the list of shortcuts. If the key is indeed included on a list of shortcuts, it is passed on to the <code class="literal">SwitchCamera</code> function, which, in turn, goes through a list<a class="indexterm" id="id447"/> of cameras, enables the one associated with the shortcut that was received, and also enables its <strong>Audio Listener</strong>, in case the <strong>Change Audio Listener</strong> option is checked.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec152"/>There's more...</h2></div></div></div><p>Here are some ideas about how you could try twisting this recipe a bit.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec38"/>Using a single-enabled camera</h3></div></div></div><p>A different <a class="indexterm" id="id448"/>approach to the problem would be keeping all secondary cameras disabled and assigning their position and rotation to the main camera via a script (you would need to make a copy of the main camera and add it to the list, in case you wanted to save its <strong>Transform</strong> settings).</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec39"/>Triggering the switch from other events</h3></div></div></div><p>Also, you can<a class="indexterm" id="id449"/> change your camera from other GameObjects' scripts by using a line of code such as the one given here:</p><div><pre class="programlisting">GameObject.Find("Switchboard").GetComponent("CameraSwitch").SwitchCamera(1);</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec153"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating an in-game surveillance camera</em> recipe in this chapter</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Making textures from screen content</h1></div></div></div><p>If you want your<a class="indexterm" id="id450"/> game or player to take in-game snapshots and apply them as textures, this recipe will show you how. This can be very useful if you plan to implement an in-game photo gallery or display a snapshot of a past key moment at the end of a level (racing games and stunt simulations use this feature a lot). For this particular example, we will take a snapshot from within a framed region of the screen and print it on the top-right corner of the display.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec154"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared the <code class="literal">BasicScene</code> Unity package, containing a scene named <code class="literal">BasicScene</code>. The package is in the <code class="literal">1362_05_codes</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec155"/>How to do it...</h2></div></div></div><p>To create textures from screen content, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">BasicScene</code> package into a new <strong>Project</strong>.</li><li class="listitem">From the <strong>Project</strong> view, open the <strong>BasicScene</strong> level. This is a basic scene featuring an animated character and some extra geometry. It also features a <strong>Canvas</strong> for UI elements.</li><li class="listitem">Create an <strong>UI Image</strong> GameObject from the <strong>Create</strong> drop-down menu on top of the <strong>Hierarchy</strong> view (<strong>Create</strong> | <strong>UI</strong> | <strong>Image</strong>). Please note that it will be created as a child of the <strong>Canvas</strong> GameObject. Then, rename it <code class="literal">frame</code>.</li><li class="listitem">From the <strong>Inspector</strong> view, find the <strong>Image (Script)</strong> component of the <strong>frame</strong> GameObject and set <code class="literal">InputFieldBackground</code> as its <strong>Source Image</strong>. This is a sprite that comes bundled with Unity, and it's already sliced for resizing purposes.</li><li class="listitem">Now, from the <strong>Inspector</strong> view, change <strong>Rect Transform</strong> to the following values: <strong>Anchors</strong> | <strong>Min</strong> | <strong>X</strong>: <code class="literal">0.25</code>, <strong>Y</strong>: <code class="literal">0.25</code>; <strong>Anchors</strong> | <strong>Max</strong> | <strong>X</strong>: <code class="literal">0.75</code>, <strong>Y</strong>: <code class="literal">0.75</code>; <strong>Pivot</strong> | <strong>X</strong>: <code class="literal">0.5</code>, <strong>Y</strong>: <code class="literal">0.5;</code> <strong>Left</strong>: <code class="literal">0</code>; <strong>Top</strong>: <code class="literal">0</code>; <strong>Pos Z</strong>: <code class="literal">0</code>; <strong>Right</strong>: <code class="literal">0</code>; <strong>Bottom</strong>: <code class="literal">0</code>.</li><li class="listitem">From the <strong>Image (Script)</strong> component, uncheck the <strong>Fill Center</strong> option, as shown below:<div><img alt="How to do it..." src="img/1362OT_05_06.jpg"/></div></li><li class="listitem">Create an <a class="indexterm" id="id451"/><strong>UI Raw Image</strong> GameObject from the <strong>Create</strong> drop-down menu on top of the <strong>Hierarchy</strong> view (<strong>Create</strong> | <strong>UI</strong> | <strong>RawImage</strong>). Please note that it will be created as a child of the <strong>Canvas</strong> GameObject. Then, rename it <code class="literal">Photo</code>.</li><li class="listitem">From the <strong>Inspector</strong> view, find the <strong>Raw Image (Script)</strong> component of the <strong>Photo</strong> GameObject and set <code class="literal">None</code> as its <strong>Texture</strong>. Also, from the top of the <strong>Inspector</strong> view, disable the <strong>Photo</strong> GameObject by unchecking the box on the side of its name.</li><li class="listitem">Now, from the <strong>Inspector</strong> view, change the <strong>Rect Transform</strong> to the following values: <strong>Width</strong>: <code class="literal">1</code>; <strong>Height</strong>: <code class="literal">1</code>; <strong>Anchors</strong> | <strong>Min</strong> | <strong>X</strong>: <code class="literal">0</code>, <strong>Y</strong>: <code class="literal">1</code>; <strong>Anchors</strong> | <strong>Max</strong> | <strong>X</strong>: <code class="literal">0</code>, <strong>Y</strong>: <code class="literal">1</code>; <strong>Pivot</strong> | <strong>X</strong>: <code class="literal">0</code>, <strong>Y</strong>: <code class="literal">1</code>; <strong>Pos X</strong>: <code class="literal">0</code>; <strong>Pos Y</strong>: <code class="literal">0</code>; <strong>Pos Z</strong>: <code class="literal">0</code> as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362OT_05_07.jpg"/></div></li><li class="listitem">We need to create a script. In the <strong>Project</strong> view, click on the <strong>Create</strong> drop-down menu<a class="indexterm" id="id452"/> and choose <strong>C# Script</strong>. Rename it <code class="literal">ScreenTexture</code> and open it in your editor.</li><li class="listitem">Open your script and replace everything with the following code:<div><pre class="programlisting">using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class ScreenTexture : MonoBehaviour {
  public GameObject photoGUI;
  public GameObject frameGUI;
  public float ratio = 0.25f;

  void  Update (){
    if (Input.GetKeyUp (KeyCode.Mouse0))
      StartCoroutine(CaptureScreen());
  }

  IEnumerator  CaptureScreen (){
    photoGUI.SetActive (false);
    int sw = Screen.width;
    int sh = Screen.height;
    RectTransform frameTransform = frameGUI.GetComponent&lt;RectTransform&gt; ();
    Rect framing = frameTransform.rect;
    Vector2 pivot = frameTransform.pivot;
    Vector2 origin = frameTransform.anchorMin;
    origin.x *= sw;
    origin.y *= sh;
    float xOffset = pivot.x * framing.width;
    origin.x += xOffset;
    float yOffset = pivot.y * framing.height;
    origin.y += yOffset;
    framing.x += origin.x;
    framing.y += origin.y;
    int textWidth = (int)framing.width;
    int textHeight = (int)framing.height;
    Texture2D texture = new Texture2D(textWidth,textHeight);
    yield return new WaitForEndOfFrame();
    texture.ReadPixels(framing, 0, 0);
    texture.Apply();
    photoGUI.SetActive (true);
    Vector3 photoScale = new Vector3 (framing.width * ratio, framing.height * ratio, 1);
    photoGUI.GetComponent&lt;RectTransform&gt; ().localScale = photoScale;
    photoGUI.GetComponent&lt;RawImage&gt;().texture = texture;
  }
}</pre></div></li><li class="listitem">Save your script and apply it to the <strong>Main Camera</strong> GameObject within the <strong>Multipurpose Camera Rig</strong> | <strong>Pivot</strong> GameObject.</li><li class="listitem">In the <strong>Inspector</strong> <a class="indexterm" id="id453"/>view, find the <strong>Screen Texture</strong> component and populate the fields <strong>Photo GUI </strong>and <strong>Frame GUI</strong> with the GameObjects <strong>Photo</strong> and <strong>frame</strong> respectively:<div><img alt="How to do it..." src="img/1362OT_05_08.jpg"/></div></li><li class="listitem">Play the scene. You will be able to take a snapshot of the screen (and have it displayed in the top-left corner at a quarter of the original size) by clicking the mouse button, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362OT_05_09.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec156"/>How it works...</h2></div></div></div><p>First, we created a<a class="indexterm" id="id454"/> GUI frame from which to take a snapshot and a GUI element onto which to apply the texture. Then, we applied a script to the <strong>Main Camera</strong> to capture the screen content and apply a new texture to it.</p><p>The script creates a new texture and captures the left mouse button being pressed, whereupon it starts a coroutine to calculate a Rect area, copy screen pixels from that area, and apply them to a texture to be displayed by the <strong>photo</strong> GUI element, which is also resized to fit the texture.</p><p>The size of the Rect is calculated from the screen's dimensions and the frame's <strong>Rect Transform</strong> settings, particularly its Pivot, Anchors, Width, and Height. The screen pixels are then captured by the <code class="literal">ReadPixels()</code> command, and applied to the texture, which is then applied to the <strong>Raw Image</strong> photo, which is resized to meet the desired ratio between the photo size and the original pixels.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec157"/>There's more...</h2></div></div></div><p>Apart from <a class="indexterm" id="id455"/>displaying the texture as a GUI element, you can use it in other ways.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec40"/>Applying your texture to a material</h3></div></div></div><p>You can apply your<a class="indexterm" id="id456"/> texture to an existing object's material by adding a line similar to <code class="literal">GameObject.Find("MyObject").renderer.material.mainTexture = texture;</code> to the end of the <code class="literal">CaptureScreen</code> function.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec41"/>Using your texture as a screenshot</h3></div></div></div><p>You can encode<a class="indexterm" id="id457"/> your texture as a PNG image file and save it. Check out Unity's documentation on this feature at <a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Texture2D.EncodeToPNG.html">http://docs.unity3d.com/Documentation/ScriptReference/Texture2D.EncodeToPNG.html</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec158"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Saving screenshots from the game recipe in Chapter 10, Working with the External Resource Files and Devices</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Zooming a telescopic camera</h1></div></div></div><p>In this recipe, we <a class="indexterm" id="id458"/>will create a telescopic camera that zooms in whenever the left mouse button is pressed. This can be very useful, for instance, if we have a sniper in our game.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec159"/>Getting ready...</h2></div></div></div><p>For this recipe, we have prepared the <code class="literal">BasicScene</code> Unity package, containing a scene named <code class="literal">BasicScene</code>. The package is in the <code class="literal">1362_05_codes</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec160"/>How to do it...</h2></div></div></div><p>To create a telescopic camera, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">BasicScene</code> package into a new <strong>Project</strong>.</li><li class="listitem">From the <strong>Project</strong> view, open the <strong>BasicScene</strong> level. This is a basic scene featuring an animated character and some extra geometry.</li><li class="listitem">Import Unity's <strong>Effects</strong> package by navigating to <strong>Assets</strong> | <strong>Import Package</strong> | <strong>Effects.</strong></li><li class="listitem">Select the <strong>Main Camera</strong> GameObject within the <strong>Multipurpose Camera Rig</strong> | <strong>Pivot</strong> GameObject and apply the <strong>Vignette</strong> image effect (by navigating to <strong>Component</strong> | <strong>Image Effects</strong> | <strong>Camera</strong> | <strong>Vignette and Chromatic Aberration</strong>).</li><li class="listitem">We need to create a script. In the <strong>Project</strong> view, click on the <strong>Create</strong> drop-down menu and choose <strong>C# Script</strong>. Rename it <code class="literal">TelescopicView</code> and open it in your editor.</li><li class="listitem">Open your <a class="indexterm" id="id459"/>script and replace everything with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;
using UnityStandardAssets.ImageEffects;

public class TelescopicView : MonoBehaviour{
  public float zoom = 2.0f;
  public float speedIn = 100.0f;
  public float speedOut = 100.0f;
  private float initFov;
  private float currFov;
  private float minFov;
  private float addFov;
  private VignetteAndChromaticAberration v;
  public float vMax = 10.0f;

  void Start(){
    initFov = Camera.main.fieldOfView;
    minFov = initFov / zoom;
    v = this.GetComponent&lt;VignetteAndChromaticAberration&gt;() as VignetteAndChromaticAberration;
  }
  void Update(){
    if (Input.GetKey(KeyCode.Mouse0))
      ZoomView();
    else
      ZoomOut();
    float currDistance = currFov - initFov;
    float totalDistance = minFov - initFov;
    float vMultiplier = currDistance / totalDistance;
    float vAmount = vMax * vMultiplier;
    vAmount = Mathf.Clamp (vAmount,0,vMax);
    v.intensity = vAmount;
  }

  void ZoomView(){
    currFov = Camera.main.fieldOfView;
    addFov = speedIn * Time.deltaTime;

    if (Mathf.Abs(currFov - minFov) &lt; 0.5f)
      currFov = minFov;
    else if (currFov - addFov &gt;= minFov)
      currFov -= addFov;

    Camera.main.fieldOfView = currFov;
  }

  void ZoomOut(){
    currFov = Camera.main.fieldOfView;
    addFov = speedOut * Time.deltaTime;

    if (Mathf.Abs(currFov - initFov) &lt; 0.5f)
      currFov = initFov;
    else if (currFov + addFov &lt;= initFov)
      currFov += addFov;

    Camera.main.fieldOfView = currFov;
  }
}</pre></div></li><li class="listitem">Save your script <a class="indexterm" id="id460"/>and apply it to the <strong>Main Camera</strong> GameObject within the <strong>Multipurpose Camera Rig</strong> | <strong>Pivot</strong> GameObject.</li><li class="listitem">Play the level. You should see an animated vignette effect in addition to the zooming:<div><img alt="How to do it..." src="img/1362OT_05_10.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec161"/>How it works...</h2></div></div></div><p>The zooming effect is actually caused by changes to the value of the camera's <strong>Field Of View</strong> (<strong>FOV</strong>) property; small <a class="indexterm" id="id461"/>values result in closer views of a smaller area, while high values enlarge the FOV.</p><p>The <code class="literal">TelescopicView</code> script changes the camera's field of view by subtracting from it whenever the left mouse button is pressed. It also adds to the FOV value when the mouse button is <em>not</em> being held, until it reaches its original value.</p><p>The zoom limit of the FOV can be deduced from the code <code class="literal">minFov = initFov / zoom;</code>. This means that the minimum value of the FOV is equal to its original value divided by the zoom amount. For instance, if our camera features, originally, a FOV of <code class="literal">60</code>, and we set the <strong>Telescopic View Zoom</strong> amount to <code class="literal">2.0</code>, the minimum FOV allowed will be <code class="literal">60/2 = 30</code>. The difference is shown in the following two screenshots:</p><div><img alt="How it works..." src="img/1362OT_05_11.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec162"/>There's more...</h2></div></div></div><p>You can also add <a class="indexterm" id="id462"/>a variable to control the <strong>Blur Vignette</strong> level of the <strong>Vignette</strong> image effect.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Displaying a mini-map</h1></div></div></div><p>In many<a class="indexterm" id="id463"/> games, a broader view of the scene can be invaluable for navigation and information. Mini-maps are great for giving players that extra perspective that they may need when in first- or third-person mode.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec163"/>Getting ready...</h2></div></div></div><p>For this recipe, we have prepared the <code class="literal">BasicScene</code> Unity Package, containing a scene named <code class="literal">BasicScene</code>. You will also need to import three image files named <code class="literal">Compass.png, compassMarker.png</code>, and <code class="literal">compassMask.png</code>. All files are available in the <code class="literal">1362_05_05</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec164"/>How to do it...</h2></div></div></div><p>To create a mini-map, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">BasicScene</code> package into a new <strong>Project</strong>. Also, import the provided <code class="literal">png</code> files. Open the <strong>BasicScene</strong> level.</li><li class="listitem">From the <strong>Project</strong> view, select the <code class="literal">Compass</code>, <code class="literal">compassMarker</code>, and <code class="literal">compassMask</code> texture files. Then, from the <strong>Inspector</strong>, change their <strong>Texture Type</strong> to <strong>Sprite (2D and UI)</strong>, leaving the <strong>Sprite Mode</strong> as <strong>Single</strong> and the <strong>Pivot</strong> at <strong>Center</strong>. Click on <strong>Apply</strong> to confirm the changes, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362OT_05_12.jpg"/></div></li><li class="listitem">From the <strong>Hierarchy</strong> view, create a new <strong>UI Panel</strong> object (<strong>Create</strong> | <strong>UI</strong> | <strong>Panel</strong>). It will be created as a child of the UI <strong>Canvas</strong> GameObject. Rename it <code class="literal">MiniMap</code>. <a class="indexterm" id="id464"/>Then, from the <strong>Inspector</strong> view, set its alignment to <strong>Top/Right</strong>, change both the <strong>Width</strong> and <strong>Height</strong> to <code class="literal">256</code>, and its <strong>Pos X</strong> and <strong>Pos Y</strong> fields to <code class="literal">-128</code>. Also, populate the <strong>Source Image </strong>field, within the <strong>Image</strong> component, with the <strong>compassMask</strong> sprite, adjusting the <strong>Color</strong> field by bringing <strong>Alpha</strong> up to <code class="literal">255</code>, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362OT_05_13.jpg"/></div></li><li class="listitem">Add a <strong>Mask </strong>component to <strong>MiniMap </strong>(from the main menu, select <strong>Component</strong> | <strong>UI</strong> | <strong>Mask</strong>). Then, from the <strong>Inspector</strong> view, find the <strong>Mask</strong> component and uncheck <strong>Show Mask Graphic</strong> (it will become invisible, serving as a mask for the mini-map).</li><li class="listitem">Select the<a class="indexterm" id="id465"/> <strong>MsLaser</strong> GameObject (which is the player's character), and, from the top of the <strong>Inspector</strong> view, access the <strong>Layer</strong> drop-down menu. Select <strong>Add Layer…</strong> and then name a <strong>User Layer</strong> <code class="literal">Player</code>, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362OT_05_14.jpg"/></div></li><li class="listitem">Select the <strong>MsLaser</strong> character again, and, from the <strong>Layer</strong> drop-down menu, select <strong>Player</strong>:<div><img alt="How to do it..." src="img/1362OT_05_15.jpg"/></div></li><li class="listitem">From the <strong>Project</strong> view, create a new <strong>Render Texture</strong> and name it <code class="literal">Map_Render</code>. Then, from <strong>Inspector</strong>, change its size to <code class="literal">256 x 256</code>.</li><li class="listitem">From the <strong>Hierarchy</strong> view, create a new camera (<strong>Create</strong> | <strong>Camera</strong>) and rename it<a class="indexterm" id="id466"/> <code class="literal">MapCamera</code>. From the <strong>Inspector</strong> view, change its parameters as follows (shown in the screenshot that will follow):<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Clear Flags</strong>: <code class="literal">Depth Only</code></li><li class="listitem" style="list-style-type: disc"><strong>Culling Mask</strong>: <code class="literal">Mixed…</code> (unselect<strong> Player</strong>)</li><li class="listitem" style="list-style-type: disc"><strong>Projection</strong>: <code class="literal">Orthographic</code></li><li class="listitem" style="list-style-type: disc"><strong>Depth</strong>: <code class="literal">1</code> (or higher)</li><li class="listitem" style="list-style-type: disc"><strong>Target Texture</strong>: <code class="literal">Map_Render</code></li><li class="listitem" style="list-style-type: disc">Also, uncheck the camera's <strong>Audio Listener</strong> component</li></ul></div><div><img alt="How to do it..." src="img/1362OT_05_16.jpg"/></div></li><li class="listitem">From the <strong>Hierarchy</strong> view, right-click on <strong>MiniMap</strong> and navigate to <strong>UI</strong> | <strong>Raw Image</strong> to create a child UI element. Name it <code class="literal">MapTexture</code>. Then, from the <strong>Inspector</strong><a class="indexterm" id="id467"/> view, populate the <strong>Texture</strong> field with the <code class="literal">Map_Render</code> texture and click on the <strong>Set Native Size</strong> button, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362OT_05_17.jpg"/></div></li><li class="listitem">Now, right-click on <strong>MiniMap</strong> and navigate to <strong>UI</strong> | <strong>Image</strong> to create another child element. Name it <code class="literal">Compass</code>. Then, from the <strong>Inspector</strong> view, populate the <strong>Source Image</strong> field with the <code class="literal">Compass</code> image and click on the <strong>Set Native Size</strong> button.</li><li class="listitem">Once again, right-click on <strong>MiniMap </strong>and navigate to <strong>UI</strong> | <strong>Image</strong> to add another child element. Name it <code class="literal">Marker</code>. Then, from the <strong>Inspector</strong> view, populate the <strong>Source Image</strong> field with the <code class="literal">compassMarker</code> image and click on the <strong>Set Native Size</strong> button.</li><li class="listitem">From the<a class="indexterm" id="id468"/> <strong>Project</strong> view, create a new <strong>C# Script</strong> and name it <code class="literal">MiniMap</code>. Open it and replace everything with the following code:<div><pre class="programlisting">using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class MiniMap : MonoBehaviour
{
  public Transform target;
  public GameObject marker;
  public GameObject mapGUI;
  public float height = 10.0f;
  public float distance = 10.0f;
  public bool rotate = true;
  private Vector3 camAngle;
  private Vector3 camPos;
  private Vector3 targetAngle;
  private Vector3 targetPos;
  private Camera cam;

  void Start(){
    cam = GetComponent&lt;Camera&gt; ();
    camAngle = transform.eulerAngles;
    targetAngle = target.transform.eulerAngles;
    camAngle.x = 90;
    camAngle.y = targetAngle.y;
    transform.eulerAngles = camAngle;
  }

  void Update(){
    targetPos = target.transform.position;
    camPos = targetPos;
    camPos.y += height;
    transform.position = camPos;
    cam.orthographicSize = distance;
    Vector3 compassAngle = new Vector3();
    compassAngle.z = target.transform.eulerAngles.y;

    if (rotate) {
      mapGUI.transform.eulerAngles = compassAngle;
      marker.transform.eulerAngles = new Vector3();
    } else {
      marker.transform.eulerAngles = -compassAngle;
    }

  }
}</pre></div></li><li class="listitem">Save the script<a class="indexterm" id="id469"/> and attach it to <strong>MapCamera</strong>. Then, from the <strong>Inspector</strong> view, change the parameters of the <strong>Mini Map</strong> component as follows (shown in the screenshot that will follow):<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Target</strong>: <code class="literal">MsLaser</code></li><li class="listitem" style="list-style-type: disc"><strong>Marker</strong>: <code class="literal">Marker</code> (the UI element previously created)</li><li class="listitem" style="list-style-type: disc"><strong>Map GUI</strong>: <code class="literal">MiniMap</code> (the UI panel previously created)</li><li class="listitem" style="list-style-type: disc"><strong>Height</strong>: <code class="literal">10</code></li><li class="listitem" style="list-style-type: disc"><strong>Distance</strong>: <code class="literal">10</code></li><li class="listitem" style="list-style-type: disc"><strong>Rotate</strong>: Checked</li></ul></div><div><img alt="How to do it..." src="img/1362OT_05_18.jpg"/></div></li><li class="listitem">Play the scene. You should be able to see the mini-map functioning in the top-right corner of the screen:<div><img alt="How to do it..." src="img/1362OT_05_19.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec165"/>How it works...</h2></div></div></div><p>The main element <a class="indexterm" id="id470"/>of the mini-map is a texture, used as a GUI element, rendered from an orthographic camera that follows the player from a top-down perspective. Some necessary adjustments were made to <strong>MapCamera</strong>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Changing its <strong>Projection</strong> mode to <strong>Orthographic</strong> (to make it two-dimensional)</li><li class="listitem" style="list-style-type: disc">Excluding the <strong>Player</strong> tag from its <strong>Culling Mask</strong> (to make the character's model invisible to the camera)</li><li class="listitem" style="list-style-type: disc">Disabling its <strong>Audio Listener</strong> (so it won't conflict with the main camera)</li></ul></div><p>The mini-map was embellished with a compass frame and a marker indicating the player's position. All these GUI elements were parented by a <strong>Panel</strong> that also functioned as a <strong>Mask</strong> to the visual elements. Finally, a script was created, serving three purposes: configuring preferences for the <strong>Camera</strong> (such as the area covered), repositioning the <strong>Camera</strong> at runtime according to the player's transform settings, and rotating the appropriate UI elements.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec166"/>There's more...</h2></div></div></div><p>If you want to experiment more with your mini-map, read on.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec42"/>Covering a wider or narrower area</h3></div></div></div><p>The range of the mini-map is given by the <strong>Distance</strong> parameter. A higher value will result in coverage of a <a class="indexterm" id="id471"/>wider area, as the <strong>MiniMap</strong> class uses<a class="indexterm" id="id472"/> the same value as the viewport size of the orthographic camera.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec43"/>Changing the map's orientation</h3></div></div></div><p>The mini-map, by<a class="indexterm" id="id473"/> default, is set to rotate as the player changes direction. Should you want it to be static, uncheck the <strong>Rotate</strong> option to make the <strong>Marker</strong> rotate instead.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec44"/>Adapting your mini-map to other styles</h3></div></div></div><p>You can easily <a class="indexterm" id="id474"/>modify this recipe to make a top or isometric view of a racing game circuit map. Just position the camera manually and prevent it from following the character.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Creating an in-game surveillance camera</h1></div></div></div><p>Although using a<a class="indexterm" id="id475"/> second viewport can be useful in many situations, there will be times when you need to output the image rendered from a camera to a texture at runtime. To illustrate this point, in this recipe, we will make use of <strong>Render Texture</strong> to create an in-game surveillance camera that transmits its video to a monitor.</p><div><img alt="Creating an in-game surveillance camera" src="img/1362OT_05_24.jpg"/><div><p>In-game surveillance cameras</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec167"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared the <code class="literal">BasicScene</code> Unity package, containing a scene named <code class="literal">BasicScene</code>, and also two FBX 3D models for the monitor and camera objects. The package is in the <code class="literal">1362_05_codes</code> folder, and the 3D models are in the <code class="literal">1362_05_06</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec168"/>How to do it...</h2></div></div></div><p>To create a<a class="indexterm" id="id476"/> picture-in-picture display, just follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">BasicScene</code> package and the <code class="literal">monitor</code> and <code class="literal">camera</code> models into your Unity Project.</li><li class="listitem">From the <strong>Project</strong> view, open the <strong>BasicScene</strong> level. This is a basic scene featuring an animated character and some extra geometry.</li><li class="listitem">From the <strong>Project</strong> view, place the <strong>monitor</strong> and <strong>camera</strong> objects into the scene by dragging them into the <strong>Hierarchy</strong> panel. Their <strong>Transform</strong> settings should be (shown in the following screenshot): <strong>monitor</strong>: <strong>Position</strong>: <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">0.09</code>; <strong>Z</strong>: <code class="literal">4</code>. <strong>Rotation</strong>: <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">180</code>; <strong>Z</strong>: <code class="literal">0</code>. <strong>camera</strong>: <strong>Position</strong>: <strong>X</strong>: <code class="literal">-3</code>; <strong>Y</strong>: <code class="literal">0.06</code>; <strong>Z</strong>: <code class="literal">4</code>. <strong>Rotation</strong>: <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">90</code>; <strong>Z</strong>: <code class="literal">0</code>:<div><img alt="How to do it..." src="img/1362OT_05_20.jpg"/></div></li><li class="listitem">Create, from the <strong>Project</strong> view, a new <strong>Render Texture</strong>, and rename it <code class="literal">screen</code>. Then, from the <strong>Inspector</strong> view, change its <strong>Size</strong> to <code class="literal">512</code> x <code class="literal">512</code>.</li><li class="listitem">Add a new <strong>Camera</strong> to the scene through the <strong>Create</strong> drop-down menu on top of the <strong>Hierarchy</strong> view (<strong>Create</strong> | <strong>Camera</strong>). Then, from the <strong>Inspector</strong> view, name it <code class="literal">Surveillance</code> and make it a child of the <strong>camera</strong> GameObject. Then, change<a class="indexterm" id="id477"/> its <strong>Transform</strong> settings to the following: <strong>Position</strong>: <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">2</code>; <strong>Z</strong>: <code class="literal">0</code>, and <strong>Rotation</strong>: <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">0</code>; <strong>Z</strong>: <code class="literal">0</code>.</li><li class="listitem">Select the <code class="literal">Surveillance</code> camera you have created, and, from the <strong>Inspector</strong> view, change its <strong>Clipping Planes</strong> | <strong>Near</strong> to <code class="literal">0.6</code>. Also, populate the <strong>Target Texture</strong> slot with the <strong>Render Texture</strong> screen and disable the camera's <strong>Audio Listener</strong> component, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362OT_05_21.jpg"/></div></li><li class="listitem">From the <strong>Hierarchy</strong> view, expand the <strong>monitor</strong> object and select its <strong>screen</strong> child. Then, from the <strong>Inspector</strong>, find its material (named <strong>Desert</strong>), and, from the <strong>Shader</strong> drop-down menu, change  itto <strong>Unlit/Texture</strong>. Finally, set the <strong>screen</strong> texture<a class="indexterm" id="id478"/> as its base texture, as shown in the following screenshot:<div><img alt="How to do it..." src="img/1362OT_05_22.jpg"/></div></li><li class="listitem">Now it's time to add some post-processing to the texture. From the main menu, import the <strong>Effects</strong> package (<strong>Assets</strong> | <strong>Import Package</strong> | <strong>Effects</strong>).</li><li class="listitem">From the <strong>Hierarchy</strong> view, select the <code class="literal">Surveillance</code> camera. Then, from the main menu, add the <strong>Grayscale</strong> image effect component (<strong>Component</strong> | <strong>Image Effects</strong> | <strong>Color Adjustments</strong> | <strong>Grayscale</strong>). Also, add the <strong>Noise And Grain</strong> image effect (<strong>Component</strong> | <strong>Image Effects</strong> | <strong>Noise</strong> | <strong>Noise and Grain (Filmic)</strong>). Finally, from the <strong>Inspector</strong> view, set the <strong>Intensity Multiplier</strong> of the <strong>Noise And Grain</strong> to <code class="literal">4</code>.</li><li class="listitem">Play your scene. You should be able to see your actions in real time on the monitor's screen, as shown here:<div><img alt="How to do it..." src="img/1362OT_05_23.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec169"/>How it works...</h2></div></div></div><p>We achieved the final result by using the surveillance camera as source for the <strong>Render Texture</strong> applied to the <strong>screen</strong>. The camera was made a child of the camera's 3D model for easier relocation. Also, its <strong>Near Clipping</strong> plane was readjusted in order to avoid displaying parts of the camera's 3D model geometry, and its <strong>Audio Source</strong> component was disabled so that it<a class="indexterm" id="id479"/> wouldn't clash with the main camera's component.</p><p>In addition to setting up the surveillance camera, two <strong>Image Effects</strong> were added to it: <strong>Noise And Grain</strong> and <strong>Greyscale</strong>. Together, these effects should make <strong>Render Texture</strong> look more like a cheap monitor's screen.</p><p>Finally, our <strong>screen</strong> render texture was applied to the screen's 3D object's material (which had its shader<a class="indexterm" id="id480"/> changed to <strong>Unlit/texture</strong> so it could be seen in low/no light conditions, like a real monitor).</p></div></div></body></html>