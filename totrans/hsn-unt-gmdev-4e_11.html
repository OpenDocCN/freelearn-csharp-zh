<html><head></head><body>
  <div><h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-126" class="chapterTitle">Starting Your AI Journey: Building Intelligent Enemies for Your Game</h1>
    <p class="normal">What is a game if not a great challenge to the player, who needs to use their character’s abilities to tackle different scenarios? Each game imposes different kinds of obstacles for the player, but in our game, the primary challenge comes from the enemies. Imagine an enemy that can sense your presence and strategically plan its attack – this is what we aim to achieve through these AI techniques. Creating challenging and believable enemies can be complex; they must behave like real characters, smart enough to present challenges yet not so formidable as to be invincible. We are going to use basic but sufficient AI techniques to make an AI capable of sensing its surroundings and, based on that information, making decisions on what to do, using <strong class="screenText">Finite State Machines </strong>(<strong class="screenText">FSMs</strong>), along with other techniques. Those decisions will be executed using <strong class="screenText">intelligent pathfinding</strong>.</p>
    <p class="normal">In this chapter, we will examine the following AI concepts:</p>
    <ul>
      <li class="bulletList">Gathering information with sensors</li>
      <li class="bulletList">Making decisions with FSMs</li>
      <li class="bulletList">Executing FSM actions</li>
    </ul>
    <p class="normal">These components are crucial in creating enemies that are not only reactive but also exhibit a semblance of intelligence and strategy. By the end of the chapter, you will have a fully functional enemy capable of detecting the player and attacking them, so let’s start by seeing first how to make the sensor systems.</p>
    <h1 id="_idParaDest-127" class="heading-1">Gathering information with sensors</h1>
    <p class="normal">AI in games works in a three-step<a id="_idIndexMarker494"/> process: gathering information, analyzing it, and executing <a id="_idIndexMarker495"/>actions based on such analysis. This is important as it reflects a simple version of how the human mind works, making the resulting AI more realistic. As you can see, we cannot do anything without information, so let’s start with that part.</p>
    <p class="normal">There are several sources of information our AI can use, such as data about itself (life and bullets) or maybe some game state (winning condition or remaining enemies), which can easily be found with the code we’ve seen so far. One important source of information, however, is sensors such as sight and hearing. In our case, sight will be enough, so let’s learn how to code that.</p>
    <p class="normal">In this section, we will examine the following sensor concepts:</p>
    <ul>
      <li class="bulletList">Creating three-filter sensors with C#</li>
      <li class="bulletList">Creating three-filter sensors with Visual Scripting</li>
      <li class="bulletList">Debugging with gizmos</li>
    </ul>
    <p class="normal">Let’s start by seeing how to create a sensor with the three-filter approach.</p>
    <h2 id="_idParaDest-128" class="heading-2">Creating three-filter sensors with C#</h2>
    <p class="normal">The common way to code<a id="_idIndexMarker496"/> senses is through a three-filter approach to discard<a id="_idIndexMarker497"/> enemies out of sight. Each filter will discard objects that fall outside our sensors. The first filter is a distance filter, which will discard enemies too far away to be seen, then the second filter is the angle check, which will check enemies inside our viewing cone, and finally, the third filter is a raycast check, which will discard enemies that are being occluded by obstacles such as walls.</p>
    <p class="normal">Before starting, a word of advice: we will be using vector mathematics here, and covering those topics in-depth is outside the scope of this book. If you don’t understand something, feel free to just search online for the code in the screenshots.</p>
    <p class="normal">Let’s code sensors in the following way:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create an empty <code class="inlineCode">GameObject</code> called <code class="inlineCode">AI</code> as a child of the <strong class="screenText">Enemy</strong> Prefab. You need to first open the Prefab to modify its children (double-click the Prefab). Remember to set the transform of this <code class="inlineCode">GameObject</code> to <strong class="screenText">Position</strong> (<strong class="screenText">0,</strong> <strong class="screenText">1.75, 0</strong>), <strong class="screenText">Rotation (0, 0, 0)</strong>, and <strong class="screenText">Scale (1, 1, 1</strong>) so it will be aligned with the enemy’s eyes. This is done this way for the future sight sensors we will do. Consider your <strong class="screenText">Enemy </strong>Prefab might have a different height for the eyes. While we can certainly just put all AI scripts directly in the <strong class="screenText">Enemy </strong>Prefab root <code class="inlineCode">GameObject</code>, we did this just for separation and organization:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.1: AI scripts container</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Create a script<a id="_idIndexMarker498"/> called <code class="inlineCode">Sight</code> and add it to the <code class="inlineCode">AI</code> child <a id="_idIndexMarker499"/>GameObject.</li>
      <li class="numberedList">Create two fields of the <code class="inlineCode">float</code> type called <code class="inlineCode">distance</code> and <code class="inlineCode">angle</code>, and another two of the <code class="inlineCode">LayerMask</code> type called <code class="inlineCode">obstaclesLayers</code> and <code class="inlineCode">objectsLayers</code>. The <code class="inlineCode">distance</code> field will be used as the vision distance, <code class="inlineCode">angle</code> will determine the amplitude of the view cone, <code class="inlineCode">obstacleLayers</code> will be used by our obstacle check to determine which objects are considered obstacles, and <code class="inlineCode">objectsLayers</code> will be used to determine what types of objects we want the <code class="inlineCode">Sight</code> component to detect.<div><p class="normal">We just want the sight to see enemies; we are not interested in objects such as walls or power-ups. <strong class="keyWord">LayerMask</strong> is a property type that allows us to select one or more layers to use inside code, so we will be filtering objects by layer.</p>
        </div>
      </li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_02_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.2: Fields to parametrize our Sight check</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">In <code class="inlineCode">Update</code>, call <code class="inlineCode">Physics.OverlapSphere</code>, as in <em class="italic">Figure 9.3</em>.</li>
    </ol>
    <p class="normal">This function creates an imaginary<a id="_idIndexMarker500"/> sphere in the place specified by the first <a id="_idIndexMarker501"/>parameter (in our case, our position) and with a radius specified in the second parameter (the distance property) to detect objects with the layers specified in the third parameter (<code class="inlineCode">ObjectsLayers</code>). It will return an array with all the colliders found inside the sphere; these functions use physics to carry out the check, so the objects must have at least one collider.</p>
    <p class="normal">This is the method we will be using to find all enemies inside our view distance, and we will be further filtering them in the next steps. Note that we are passing our position to the first parameter, which is not actually the position of the enemy but the position of the <code class="inlineCode">AI</code> child object, given our script is located there. This highlights the importance of the position of the <code class="inlineCode">AI</code> object.</p>
    <p class="normal">Another way of accomplishing the first check is to just check the distance from the objects we want to see to the player, or if looking for other kinds of objects, to a <code class="inlineCode">Manager</code> component containing a list of them. However, the method we chose is more versatile and can be used for any kind of object.</p>
    <p class="normal">Also, you might want to check the <code class="inlineCode">Physics.OverlapSphereNonAlloc</code> version of this function, which does the same but is more performant by not allocating an array to return the results.</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Iterate over the array of objects returned by the function using a <code class="inlineCode">for</code> loop:
    <figure class="mediaobject"><img src="img/B21361_09_03_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.3: Getting all GameObjects at a certain distance</p>
    <p class="normal">To detect whether the object falls inside the vision cone, we need to calculate the angle between our viewing direction and the direction from ourselves toward the object itself. If the angle between those two directions is less than our cone angle, we consider that the object falls inside our vision. We will do that in the following steps:</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Start calculating<a id="_idIndexMarker502"/> the direction toward the object, which can be done<a id="_idIndexMarker503"/> by normalizing the difference between the object’s position and ours, as in <em class="italic">Figure 9.4</em>. You might notice we used <code class="inlineCode">bounds.center</code> instead of <code class="inlineCode">transform.position</code>; this way, we check the direction to the center of the object instead of its pivot. Remember that the player’s pivot is in the ground and the ray check might collide against it before the player:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.4: Calculating direction from our position toward the collider</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">We can use the <code class="inlineCode">Vector3.Angle</code> function to calculate the angle between two directions. In our case, we can calculate the angle between the direction toward the enemy and our forward vector to see the angle:
    <figure class="mediaobject"><img src="img/B21361_09_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.5: Calculating the angle between two directions</p>
    <p class="normal">If you want, you can instead use <code class="inlineCode">Vector3.Dot</code>, which will execute a dot product – a mathematics function to calculate the length of a vector projected to another (search online for more info). <code class="inlineCode">Vector3.Angle</code> actually uses that one but converts the result of the dot product into an angle, which needs to use trigonometry, and that can be time-consuming to calculate. Our <code class="inlineCode">Vector3.Angle</code> approach is simpler and faster to code, and, given that we don’t require many sensors because we won’t have many enemies, optimizing the sensor using dot products is not necessary now, but do consider that for games with a larger scale.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Now check whether<a id="_idIndexMarker504"/> the calculated angle is less than the one specified<a id="_idIndexMarker505"/> in the <code class="inlineCode">angle</code> field. Note that if we set an angle of <code class="inlineCode">90</code>, it will actually be <code class="inlineCode">180</code>, because if the <code class="inlineCode">Vector3.Angle</code> function returns, as an example, <code class="inlineCode">30</code>, it could be <code class="inlineCode">30</code> to the left or to the right. If our angle says <code class="inlineCode">90</code>, it could be both <code class="inlineCode">90</code> to the left and to the right, so it will detect objects in a 180-degree arc.</li>
      <li class="numberedList">Use the <code class="inlineCode">Physics.Linecast</code> function to create an imaginary line between the first and the second parameter (our position and the collider position) to detect objects with the layers specified in the third parameter (the obstacle layers) and return a Boolean indicating whether that ray hit something or not.
    <p class="normal">The idea is to use the line to detect whether there are any obstacles between ourselves and the detected collider, and if there is no obstacle, this means that we have a direct line of sight toward the object. Observe how we use the <code class="inlineCode">!</code> or <code class="inlineCode">not</code> operator in <em class="italic">Figure 9.6</em> to check that <code class="inlineCode">Physics.Linecast</code> didn’t detect any objects. Again, note that this function depends on the obstacle objects having colliders, which, in our case, we have (walls, floor, and so on):</p>
    <figure class="mediaobject"><img src="img/B21361_09_06_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.6: Using Linecast to check obstacles between the sensor and the target object</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">If the object passes the three checks, that means that this is the object we are currently seeing, so we can save it inside a field of the <code class="inlineCode">Collider</code> type called <code class="inlineCode">detectedObject</code>, to save that information for later use by the rest of the <code class="inlineCode">AI</code> scripts.
    <p class="normal">Consider using <code class="inlineCode">break</code> to stop the <code class="inlineCode">for</code> loop that is iterating the colliders to prevent wasting resources by checking the other objects, and to set <code class="inlineCode">detectedObject</code> to <code class="inlineCode">null</code> before <code class="inlineCode">for</code> to clear the result from the previous frame. If, in this frame, we don’t detect anything, it will keep the <code class="inlineCode">null</code> value so we notice that there is nothing in the sensor:</p>
    <figure class="mediaobject"><img src="img/B21361_09_07_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.7: Full sensor script</p>
    <p class="normal">In our case, we are using the sensor just to look for the player (the only object the sensor is in charge of looking for), but if you want to make the sensor more advanced, you can just keep a list of detected objects, placing inside it every object that passes the three tests instead of just the first one. In our case, it’s not necessary as we have only one player in the game.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">In the editor, configure<a id="_idIndexMarker506"/> the sensor at your will. In this case, we will set <code class="inlineCode">Objects Layer</code> to <code class="inlineCode">Player</code> so our<a id="_idIndexMarker507"/> sensor will focus its search on objects with that layer, and <code class="inlineCode">Obstacles Layer</code> to <code class="inlineCode">Default</code>, the layer we used for walls and floors. Remember the <code class="inlineCode">Sight</code> script is in the <code class="inlineCode">AI</code> GameObject, which is a child of the <code class="inlineCode">Enemy</code> Prefab:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_08_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.8: Sensor settings</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">To test this, just place an enemy with a movement speed of <strong class="screenText">0</strong> in front of the player, select its <code class="inlineCode">AI</code> child object, and then play the game to see how the property is set in the Inspector. Also, try putting an obstacle between the two and check that the property says <strong class="screenText">None</strong> (<code class="inlineCode">null</code>). If you don’t get the expected result, double-check your script, its configuration, and whether the player has the <strong class="screenText">Player</strong> layer, and the obstacles have the <strong class="screenText">Default</strong> layer. Also, you might need to raise the <code class="inlineCode">AI</code> object a little bit to prevent the ray from starting below the ground and hitting it. Feel free to make further tests to really understand your code.</li>
    </ol>
    <p class="normal">Now that we understand how the sensors work in C#, let’s see the Visual Scripting version.</p>
    <h2 id="_idParaDest-129" class="heading-2">Creating Three-Filters sensors with Visual Scripting</h2>
    <p class="normal">Regarding the Visual Scripting version, let’s check it part by part, starting with the <strong class="screenText">Overlap Sphere</strong>:</p>
    <figure class="mediaobject"><img src="img/B21361_09_09_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.9: Overlap Sphere in Visual Scripting</p>
    <p class="normal">So far, we just called <strong class="screenText">Overlap Sphere</strong> after setting the <code class="inlineCode">sensedObject</code> variable to <code class="inlineCode">null</code>. The previous image contains not only the variables we need so far but also the ones that we will use later, so remember to create all of them. Something to consider is how the <code class="inlineCode">sensedObject</code> variable in the <strong class="screenText">Variables</strong> component in the Inspector might instead have a <strong class="screenText">Null</strong> type in your case, which means no type in Visual Scripting. This isn’t possible in C# – all variables must have a type – and while we could set the <code class="inlineCode">sensedObject</code> variable to the proper type (<strong class="screenText">Collider</strong>), we will keep the variable type to be set later via a script. Even if we set the type now, Visual Scripting tends to forget the type if no value is set, and we cannot set it until we detect something.</p>
    <p class="normal">Don’t worry about that<a id="_idIndexMarker508"/> for the moment; when we set the variable through<a id="_idIndexMarker509"/> our script, it will acquire the proper type. Actually, all variables in Visual Scripting can switch types at runtime according to what we set them to, given how the <strong class="screenText">Variables</strong> component works. I don’t recommend changing a variable’s type in runtime, as it will give a different meaning to it. Try to stick with the intended variable type.</p>
    <p class="normal">We just said that all variables in C# must have a type, but that’s not entirely true. There are ways to create dynamically typed variables, but it’s not a good practice that I’d recommend using unless no other option is present.</p>
    <p class="normal">Another thing to observe is how we set the <code class="inlineCode">sensedObject</code> variable to <code class="inlineCode">null</code> at the beginning using the <strong class="screenText">Null </strong>node, which effectively represents the <code class="inlineCode">null</code> value.</p>
    <p class="normal">Now, let’s explore the <strong class="screenText">Foreach</strong> part:</p>
    <figure class="mediaobject"><img src="img/B21361_09_10_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.10: Iterating collections in Visual Scripting</p>
    <p class="normal">We can see that one of the output<a id="_idIndexMarker510"/> pins of <strong class="screenText">Overlap Sphere</strong> has a list icon, which essentially<a id="_idIndexMarker511"/> represents the <code class="inlineCode">collider</code> array returned by <strong class="screenText">Overlap Sphere</strong>. We connect that pin to the <strong class="screenText">For Each Loop</strong> node, which, as you might imagine, iterates over the elements of the provided collection (array, list, dictionary, etc.). The <strong class="screenText">Body</strong> pin represents the nodes to execute in each iteration of the loop, and the <strong class="screenText">Item</strong> output pin represents the item currently being iterated – in our case, one of the colliders detected in <strong class="screenText">Overlap Sphere</strong>. Finally, we save that item in a <strong class="screenText">Flow</strong> <code class="inlineCode">potentialDetection</code> variable (<strong class="screenText">Flow</strong> variables being the equivalent to local variables in C# functions).</p>
    <p class="normal">To maintain clarity in our Visual Scripting graph and avoid clutter, we assign the currently iterated collider to a <strong class="screenText">Flow</strong> variable named <code class="inlineCode">potentialDetection</code>. This approach eliminates the need for extensive connections across the graph, simplifying the visual layout and subsequent referencing of this collider.</p>
    <p class="normal">Now let’s explore the <strong class="screenText">Angle</strong> check:</p>
    <figure class="mediaobject"><img src="img/B21361_09_11_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.11: Angle check in Visual Scripting</p>
    <p class="normal">Here, you can see a direct translation<a id="_idIndexMarker512"/> of what we did in C# to detect the angle, so it should <a id="_idIndexMarker513"/>be pretty self-explanatory.</p>
    <p class="normal">Now, let’s explore the <strong class="screenText">Linecast</strong> part:</p>
    <figure class="mediaobject"><img src="img/B21361_09_12_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.12: Linecast check in Visual Scripting</p>
    <p class="normal">Again, this is essentially<a id="_idIndexMarker514"/> the same as we did before in C#. The only thing to highlight<a id="_idIndexMarker515"/> here is the fact we used the <strong class="screenText">Flow</strong> variable <code class="inlineCode">potentialDetection</code> to again get the position of the current item being iterated, instead of connecting the <strong class="screenText">Get Position</strong> node all the way to the For Each Item output pin.</p>
    <p class="normal">Now, let’s explore the final part:</p>
    <figure class="mediaobject"><img src="img/B21361_09_13_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.13: Setting the sensedObject</p>
    <p class="normal">Again, this is pretty much self-explanatory; if the <strong class="screenText">Linecast</strong> returns <strong class="screenText">False</strong>, we set the <code class="inlineCode">potentialDetection</code> variable (the currently iterated item) as the <code class="inlineCode">sensedObject</code> variable (the one that will be accessed by other scripts later to query which is the object our AI can see right now). Something to consider here is the usage of the <strong class="screenText">Break Loop</strong> node, which is equivalent to the C# <code class="inlineCode">break</code> keyword; essentially, we are stopping the<strong class="screenText"> Foreach</strong> loop we are currently in.</p>
    <p class="normal">Now, even if we have <a id="_idIndexMarker516"/>our sensor <a id="_idIndexMarker517"/>working, sometimes, checking whether it’s working or configured properly requires some visual aids that we can create using gizmos.</p>
    <h2 id="_idParaDest-130" class="heading-2">Debugging with gizmos</h2>
    <p class="normal">As we create our AI, we will start<a id="_idIndexMarker518"/> to detect certain errors in edge cases, usually related to misconfigurations. You may think that the player falls within the sight range of the enemy, but maybe you cannot see that the line of sight is occluded by an object, especially as the enemies move constantly. A good way to debug those scenarios is through Editor-only visual aids known as gizmos, which allow you to visualize invisible data such as the sight distance or the <code class="inlineCode">Linecasts</code> executed to detect obstacles.</p>
    <p class="normal">Let’s start seeing how to create gizmos drawing a sphere representing the sight distance by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">In the <code class="inlineCode">Sight</code> script, create an event function called <code class="inlineCode">OnDrawGizmos</code>. This event is only executed in the Editor (not in builds) and is the place to draw any gizmos in Unity.</li>
      <li class="numberedList">Use the <code class="inlineCode">Gizmos.DrawWireSphere</code> function, passing our position as the first parameter and the distance as the second parameter to draw a sphere in our position with the radius of our distance. You can check how the size of the gizmo changes as you change the <code class="inlineCode">distance</code> field:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_14_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.14: Sphere gizmo</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Optionally, you can change the color of the gizmo, setting <code class="inlineCode">Gizmos.color</code> before calling the drawing functions:
    <figure class="mediaobject"><img src="img/B21361_09_15_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.15: Gizmos drawing code</p>
    <p class="normal">Now you are drawing gizmos constantly, and if you have lots of enemies, they can pollute the <strong class="screenText">Scene</strong> view with too many gizmos. In that case, try the <code class="inlineCode">OnDrawGizmosSelected</code> event function instead, which draws gizmos only if the object is selected.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">We can draw the lines representing<a id="_idIndexMarker519"/> the cone using <code class="inlineCode">Gizmos.DrawRay</code>, which receives the origin of the line to draw and the direction of the line, which can be multiplied by a certain value to specify the length of the line, as in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_16_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.16: Drawing rotated lines</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">In the screenshot, we used <code class="inlineCode">Quaternion.Euler</code> to generate a quaternion based on the angles we want to rotate. A quaternion is a mathematical construct to represent rotations; please search for this term for more info on it. If we multiply this quaternion by a direction, we will get the rotated direction. We are taking our forward vector and rotating it according to the <code class="inlineCode">angle</code> field to generate our cone vision lines.</li>
    </ol>
    <p class="normal">Also, we multiply this direction by the sight distance to draw the line as far as our sight can see; you will see how the line matches the end of the sphere this way:</p>
    <figure class="mediaobject"><img src="img/B21361_09_17_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.17: Vision angle lines</p>
    <p class="normal">We can also draw the linecasts, which check the obstacles, but as they depend on the current situation of the game, such as the objects that pass the first two checks and their positions, we can use <code class="inlineCode">Debug.DrawLine</code> instead, which can be executed in the <code class="inlineCode">Update</code> method. This version of <code class="inlineCode">DrawLine</code> is designed to be used in runtime only. The gizmos we saw also execute in the Editor. Let’s try them in the following way:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">First, let’s debug the scenario<a id="_idIndexMarker520"/> where <code class="inlineCode">Linecast</code> didn’t detect any obstacles, so we need to draw a line between our sensor and the object. We can call <code class="inlineCode">Debug.DrawLine</code> in the <code class="inlineCode">if</code> statement that calls <code class="inlineCode">Linecast</code>, as in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_18_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.18: Drawing a line in Update</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">In the next screenshot, you can see <code class="inlineCode">DrawLine</code> in action:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_19_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.19: Line toward the detected object</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">We also want to draw<a id="_idIndexMarker521"/> a line in red when the sight is occluded by an object. In this case, we need to know where the linecast hit, so we can use an overload of the function, which provides an <code class="inlineCode">out</code> parameter that gives us more information about what the line collided with, such as the position of the hit and the normal and the collided object, as in the following screenshot:
    <figure class="mediaobject"><img src="img/B21361_09_20_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.20: Getting information about Linecast</p>
    <div><p class="normal">Parameters using the out keyword<a id="_idIndexMarker522"/> allow the method to return data also via parameters. For more info on this, check the following link: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out</a>.</p>
    </div>
    <p class="normal">Note that <code class="inlineCode">Linecast</code> doesn’t always collide with the nearest obstacle but with the first object it detects in the line, which can vary in order. If you need to detect the nearest obstacle, look for the <code class="inlineCode">Physics.Raycast</code> version of the function.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">We can use that information to draw the line from our position to the hit point in the <code class="inlineCode">else</code> part of the <code class="inlineCode">if</code> sentence when the line collides with something:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_21_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.21: Drawing a line if we have an obstacle</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">In the next screenshot, you can<a id="_idIndexMarker523"/> see the results. Ensure the <strong class="screenText">Gizmos</strong> option is on in the <strong class="screenText">Scene</strong> view toolbars (the rightmost sphere-shaped icon):</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_22_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.22: Line when an obstacle occludes vision</p>
    <p class="normal">Regarding the Visual Scripting version, the first part will look like this:</p>
    <figure class="mediaobject"><img src="img/B21361_09_23_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.23: Drawing gizmos with Visual Scripting</p>
    <p class="normal">Then, the angle lines<a id="_idIndexMarker524"/> will look like this:</p>
    <figure class="mediaobject"><img src="img/B21361_09_24_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.24: Drawing angle lines of sight in Visual Scripting</p>
    <p class="normal">Note that, here, we are showing<a id="_idIndexMarker525"/> just one; the other is essentially the same but multiplying the angle by -1. Finally, the red lines toward the detected object and obstacles will look like this:</p>
    <figure class="mediaobject"><img src="img/B21361_09_25_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.25: Drawing lines toward obstacles or detected objects in Visual Scripting</p>
    <p class="normal">Note that to accomplish this last one, we needed to change the previous <strong class="screenText">Linecast</strong> node for the version that returns <strong class="screenText">Raycast Hit</strong> info at the end.</p>
    <p class="normal">In this section, we created the sensor<a id="_idIndexMarker526"/> system that will give sight to our AI and plenty of info about what to do next. Now that we have completed our sensors, let’s use the information provided by them to make decisions with FSMs.</p>
    <h2 id="_idParaDest-131" class="heading-2">Making decisions with FSMs</h2>
    <p class="normal">We explored the concept<a id="_idIndexMarker527"/> of FSMs in the past when we used them in the <code class="inlineCode">Animator</code> component. To recap, we recommend reviewing <em class="chapterRef">Chapter 17</em>, <em class="italic">Animated Realities: Creating Animations with Animator, Cinemachine, and Timeline</em>. We learned that an FSM is a collection of states, each one representing an action that an object can be executing at a time and a set of transitions that dictates how the states are switched. This concept is not only used in animation but in a myriad of programming scenarios, and one of the common ones is AI. For AI, each state will represent a different possible AI behavior to be active at a time, and transitions will represent the conditions that need to be met for other AI behaviors to be active. For example, in a shooter game, the enemies<a id="_idIndexMarker528"/> can have states like <strong class="keyWord">Idle</strong>, <strong class="keyWord">Patrolling</strong>, <strong class="keyWord">Attacking</strong>, <strong class="keyWord">Fleeing</strong>, <strong class="keyWord">Taking Cover</strong>, and so on.</p>
    <div><p class="normal">To further reinforce the FSM concept, we recommend reviewing this link: <a href="https://gameprogrammingpatterns.com/state.html">https://gameprogrammingpatterns.com/state.html</a>.</p>
    </div>
    <p class="normal">In this section, we will examine the following AI FSM concepts:</p>
    <ul>
      <li class="bulletList">Creating the FSM in C#</li>
      <li class="bulletList">Creating transitions</li>
      <li class="bulletList">Creating the FSM in Visual Scripting</li>
    </ul>
    <p class="normal">Let’s start implementing this FSM theory by creating an FSM in C#.</p>
    <h2 id="_idParaDest-132" class="heading-2">Creating the FSM in C#</h2>
    <p class="normal">To create our own FSM, we need<a id="_idIndexMarker529"/> to recap some basic concepts. Remember<a id="_idIndexMarker530"/> that an FSM can have a state for each possible action it can execute and that only one can be executed at a time.</p>
    <p class="normal">In terms of AI, for example, we can be patrolling, attacking, fleeing, and so on. Also, remember that there are transitions between states that determine conditions to be met to change from one state to another, and in terms of AI, this can be the user being near the enemy to start attacking or life being low to start fleeing. In the next figure, you can find a simple reminder example of the two possible states of a door:</p>
    <figure class="mediaobject"><img src="img/B21361_09_26_PE.png" alt="State diagram - Wikipedia"/></figure>
    <p class="packt_figref">Figure 9.26: FSM skeleton</p>
    <p class="normal">There are several ways to implement<a id="_idIndexMarker531"/> FSMs for AI; you can even use the <code class="inlineCode">Animator</code> component<a id="_idIndexMarker532"/> if you want to or download an FSM system from the Asset Store. In our case, we are going to take the simplest approach possible – a single script with a set of <code class="inlineCode">if</code> sentences, which can be basic but is still a good start to understanding the concept. Let’s implement it by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create a script called <code class="inlineCode">EnemyFSM</code> in the <code class="inlineCode">AI</code> child object of the enemy.</li>
      <li class="numberedList">Create an enum called <code class="inlineCode">EnemyState</code> with the <code class="inlineCode">GoToBase</code>, <code class="inlineCode">AttackBase</code>, <code class="inlineCode">ChasePlayer</code>, and <code class="inlineCode">AttackPlayer</code> values. We are going to have those states in our AI.</li>
      <li class="numberedList">Create a field of the <code class="inlineCode">EnemyState</code> type called <code class="inlineCode">currentState</code>, which will hold the current state of our enemy:
    <figure class="mediaobject"><img src="img/B21361_09_27_OE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.27: EnemyFSM state definition</p>
    <div><p class="normal">For more information about<a id="_idIndexMarker533"/> how enums work, we recommend checking the following link: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum</a>.</p>
    </div></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Create three functions named after the states we defined.</li>
      <li class="numberedList">Call those functions in <code class="inlineCode">Update</code> depending on the current state:
    <figure class="mediaobject"><img src="img/B21361_09_28_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.28: An if-based FSM</p>
    <p class="normal">Yes, you can totally use a switch here, but I just prefer the regular <code class="inlineCode">if</code> syntax for this example.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Test in the Editor<a id="_idIndexMarker534"/> how changing the <code class="inlineCode">currentState</code> field will change<a id="_idIndexMarker535"/> which state is active, seeing the messages being printed in the <strong class="screenText">Console </strong>window:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_29_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 9.29: State testing</p>
    <p class="normal">As you can see, it is a pretty simple but totally functional approach. In the future, you could face having to code enemies with many more states, and this approach will start to scale badly. In such a case, you could use any FSM plugin from the Asset Store you prefer to have more powerful and scalable tools, or even consider <a id="_idIndexMarker536"/>advanced techniques <a id="_idIndexMarker537"/>like behavior trees, but that’s outside the scope of this book. Now let’s continue with this FSM, by creating its transitions.</p>
    <h1 id="_idParaDest-133" class="heading-1">Creating transitions</h1>
    <p class="normal">If you remember the transitions<a id="_idIndexMarker538"/> created in the Animator Controller, those were basically a collection<a id="_idIndexMarker539"/> of conditions that checked whether the state the transition belongs to is active. In our FSM approach, this translates simply as <code class="inlineCode">if</code> sentences that detect conditions inside the states. Let’s create the transitions between our proposed states as follows:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add a field of the <code class="inlineCode">Sight</code> type called <code class="inlineCode">sightSensor</code> in our FSM script, and drag the <code class="inlineCode">AI</code> GameObject to that field to connect it to the <code class="inlineCode">Sight</code> component there. As the FSM component is in the same object as <code class="inlineCode">Sight</code>, we can also use <code class="inlineCode">GetComponent</code> instead, but in advanced AIs, you might have different sensors that detect different objects, so I prefer to prepare my script for that scenario. You should pick the approach you like the most.</li>
      <li class="numberedList">In the <code class="inlineCode">GoToBase</code> function, check whether the detected object of the <code class="inlineCode">Sight</code> component is not <code class="inlineCode">null</code>, meaning that something is inside our line of vision. If our AI is going toward the base but detects an object in the way, we must switch to the <code class="inlineCode">Chase</code> state to pursue the player, so we change the state, as in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_30_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.30: Creating transitions</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Also, we must change to <code class="inlineCode">AttackBase</code> if we are near enough to the object that must be damaged to decrease the base life. We can create a field of the <code class="inlineCode">Transform</code> type called <code class="inlineCode">baseTransform</code> and drag the player’s base life object we created previously there so we can check the distance. Remember to add a <code class="inlineCode">float</code> field called <code class="inlineCode">baseAttackDistance</code> to make that distance configurable:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_31_PE.png" alt="A screen shot of a computer code  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 9.31: GoToBase transitions</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">In the case of <code class="inlineCode">ChasePlayer</code>, we need<a id="_idIndexMarker540"/> to check whether the player is out of sight to switch back<a id="_idIndexMarker541"/> to the <code class="inlineCode">GoToBase</code> state or whether we are near enough to the player to start attacking it. We will need another <code class="inlineCode">distance</code> field called <code class="inlineCode">PlayerAttackDistance</code>, which determines the distance to attack the player, and we might want different attack distances for those two targets. Consider an early return in the transition to prevent getting <code class="inlineCode">null</code> reference exceptions if we try to access the position of the sensor-detected object when there are not any:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_32_PE.png" alt="A picture containing text, screenshot, font  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 9.32: ChasePlayer transitions</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">For <code class="inlineCode">AttackPlayer</code>, we need<a id="_idIndexMarker542"/> to check whether the player is out of sight to get back to <code class="inlineCode">GoToBase</code> or whether<a id="_idIndexMarker543"/> it is far enough to go back to chasing it. You will notice how we multiplied <code class="inlineCode">playerAttackDistance</code> to make the stop-attacking distance a little bit greater than the start-attacking distance; this will prevent switching back and forth rapidly between attacking and chasing when the player is near that distance.</li>
      <li class="numberedList">You can make it configurable instead of hardcoding <code class="inlineCode">1.1</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_33_PE.png" alt="A screen shot of a computer code  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 9.33: AttackPlayer transitions</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">In our case, <code class="inlineCode">AttackBase</code> won’t have any transition. Once the enemy<a id="_idIndexMarker544"/> is near enough to the base<a id="_idIndexMarker545"/> to attack it, it will stay like that, even if the player starts shooting at it. Its only objective once there is to destroy the base.</li>
      <li class="numberedList">Remember you can use <code class="inlineCode">Gizmos</code> to draw the distances:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_34_PE.png" alt="A picture containing text, screenshot, font, line  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 9.34: FSM Gizmos</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="9">Test the script by selecting the <code class="inlineCode">AI</code> object prior to clicking <strong class="screenText">Play</strong> and then moving the player around, checking how the states change in the <strong class="screenText">Inspector</strong> pane. You can also keep the original <code class="inlineCode">print</code> messages in each state to see them changing in the <strong class="screenText">Console</strong> window. Remember to set the attack distances and the references to the objects. In the screenshot, you can see the settings we use:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_35_PE.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 9.35: Enemy FSM settings</p>
    <p class="normal">A little problem that we will have now<a id="_idIndexMarker546"/> is that the spawned enemies won’t have the needed references to make the distance<a id="_idIndexMarker547"/> calculations to the player’s base transform. You will notice that if you try to apply the changes on the enemy of the scene to the Prefab (<strong class="screenText">Overrides | Apply All</strong>), the <strong class="screenText">Base Transform</strong> variable will say <strong class="screenText">None</strong>. Remember that Prefabs cannot contain references to objects in the scene, which complicates our work here. One alternative would be to create <code class="inlineCode">BaseManager</code>, a singleton that holds the reference to the damage position, so our <code class="inlineCode">EnemyFSM</code> can access it. Another one could be to make use of functions such as <code class="inlineCode">GameObject.Find</code> to find our object.</p>
    <p class="normal">In this case, we will use the latter. Even though it can be less performant than the <code class="inlineCode">Manager</code> version, I want to show you how to use it to expand your Unity toolset. In this case, just set the <code class="inlineCode">baseTransform</code> field in <code class="inlineCode">Awake</code> to the return of <code class="inlineCode">GameObject</code>.<code class="inlineCode">Find</code>, using <code class="inlineCode">BaseDamagePoint</code> as the first parameter, which will look for an object with the same name, as in the following screenshot.</p>
    <p class="normal">You will see that now our wave-spawned enemies will change states:</p>
    <figure class="mediaobject"><img src="img/B21361_09_36_PE.png" alt="A picture containing text, font, line, screenshot  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 9.36: Searching for an object in the scene by name</p>
    <div><p class="normal">When I started learning about AI for games, I thought I was going to create Skynet using complex algorithms like deep learning. As you can see, we are far away from that, and the reason is that AI for games doesn’t need to be intelligent; it needs to be fun. Making it so requires careful design to generate the exact desired experience, which could be difficult to achieve with cutting-edge AI technology.</p>
      <p class="normal">Having said that, there are other AI techniques, like behavior trees, which you can learn about it in this<a id="_idIndexMarker548"/> Halo developers’ article: <a href="https://www.gamedeveloper.com/programming/gdc-2005-proceeding-handling-complexity-in-the-i-halo-2-i-ai">https://www.gamedeveloper.com/programming/gdc-2005-proceeding-handling-complexity-in-the-i-halo-2-i-ai</a></p>
      <p class="normal">Other alternative<a id="_idIndexMarker549"/> is called GOAP, and I recommend reading this paper from the F.E.A.R. developers: <a href="https://www.gamedevs.org/uploads/three-states-plan-ai-of-fear.pdf">https://www.gamedevs.org/uploads/three-states-plan-ai-of-fear.pdf</a> Finally, there’s the Game AI Pro book series, which<a id="_idIndexMarker550"/> collects several game AI-related papers, and you can learn more about it here: <a href="http://www.gameaipro.com/">http://www.gameaipro.com/</a></p>
    </div>
    <p class="normal">In this section, we made our FSM<a id="_idIndexMarker551"/> properly switch states according to the data provided by sensors and other<a id="_idIndexMarker552"/> sources, laying the foundation to start scripting the actual behavior of each state. Now that our FSM states are coded and execute transitions properly, let’s see how to do the same in Visual Scripting. Feel free to skip the following section if you are only interested in the C# version.</p>
    <h2 id="_idParaDest-134" class="heading-2">Creating the FSM in Visual Scripting</h2>
    <p class="normal">So far, most scripts in Visual Scripting<a id="_idIndexMarker553"/> were almost a mirror of the C# version<a id="_idIndexMarker554"/> with some differences in some nodes. Regarding state machines, we could do the same; instead, we are going to use the <strong class="screenText">State Machine</strong> system of Visual Scripting. The concept is the same – you have states and can switch them – but how the states are organized and when the transitions trigger is managed visually, in a similar way as the <strong class="screenText">Animator</strong> system does. So, let’s see how we can use the system by creating our first <strong class="screenText">State Machine Graph</strong> and some states. Follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add the <strong class="screenText">State Machine</strong> component to our enemy. Remember it is called <strong class="screenText">State Machine</strong> and not <strong class="screenText">Script Machine</strong>, the latter being the component for regular Visual Scripts.</li>
      <li class="numberedList">Click the <strong class="screenText">New</strong> button in the component and select a place to save the fixed asset in a similar way to what we have done so far for regular Visual Scripts. In my case, I called it <code class="inlineCode">EnemyFSM</code>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_37_PE.png" alt="A screenshot of a state machine  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 9.37: Creating a Visual Scripting State Machine</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Double-click <strong class="screenText">State Machine Graph</strong> to edit it as usual.</li>
      <li class="numberedList">Right-click in any empty<a id="_idIndexMarker555"/> area of the <strong class="screenText">Graph</strong> editor<a id="_idIndexMarker556"/> and select <strong class="screenText">Create Script State</strong> in order to create a new state:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_38_PE.png" alt="A picture containing text, screenshot, font, rectangle  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 9.38: Creating our first Visual Scripting State Machine state</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Repeat <em class="italic">step 4</em> until you end up having four states:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_39_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.39: Visual Scripting states</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Select any of them<a id="_idIndexMarker557"/> and, in the <strong class="screenText">Info</strong> panel<a id="_idIndexMarker558"/> on the left, fill the <strong class="screenText">Title</strong> field (the first one) with the name of any of the states we created before (<code class="inlineCode">GoToBase</code>, <code class="inlineCode">AttackBase</code>, <code class="inlineCode">ChasePlayer</code>, and <code class="inlineCode">AttackPlayer</code>). If you don’t see the <strong class="screenText">Info</strong> panel, click the button with the <strong class="screenText">i</strong> in the middle to display it:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_40_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 9.40: Renaming a Visual Scripting state</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Repeat that for the rest of the state nodes until you have each node named after each state created in the <em class="italic">Creating the FSM in C#</em> section of this chapter:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_41_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 9.41: All the needed states</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">You can see one of the states<a id="_idIndexMarker559"/> has a green bar at the top, which represents<a id="_idIndexMarker560"/> which node is supposed to be the first one. I renamed that initial state <code class="inlineCode">GoToBase</code> as that’s the one I prefer to be first. If you don’t have that one as the starting one, right-click the node that currently has the green bar in your state machine, select <strong class="screenText">Toggle Start</strong> to remove the green bar from it, and then repeat for the node that you want to be the first one (<code class="inlineCode">GoToBase</code> in our scenario), adding the green bar to that one.</li>
      <li class="numberedList">Something to consider is that you can have more than one start state in Visual Scripting, meaning you can have multiple states running at the same time and transitioning. If possible, I recommend avoiding having more than one state active at a time to make things simple.</li>
      <li class="numberedList">Double-click <code class="inlineCode">GoToBase</code> to enter the edit mode for these states. Connect a <strong class="screenText">String</strong> node to the <strong class="screenText">Print</strong> <strong class="screenText">Message</strong> input pin in the <strong class="screenText">OnUpdate</strong> event node to print a message saying <strong class="screenText">GoToBase</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_42_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 9.42: Our first state machine logic</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="11">In the top bar, click the <strong class="screenText">EnemyFSM</strong> label at the left of <strong class="screenText">GoToBase</strong> in order to return to the whole <strong class="screenText">State Machine</strong> view. If you don’t see it, click any text label to the right of the third button (the one that looks like <strong class="screenText">&lt;x&gt;</strong>):</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_43_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.43: Returning to the State Machine editor mode</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="12">Feel free to delete the other event nodes if you are not planning to use them.</li>
      <li class="numberedList">Repeat <em class="italic">steps 9</em> to<em class="italic"> 11</em> for each state until all of them print their names.</li>
    </ol>
    <p class="normal">With this, we have created<a id="_idIndexMarker561"/> the nodes representing the possible<a id="_idIndexMarker562"/> states of our AI. In the next section, we will be adding logic for them to something meaningful, but before that, we need to create the transitions between the states and the conditions that need to be met to trigger them by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create variables in the <strong class="screenText">Variables</strong> component of the enemy called <code class="inlineCode">baseTransform</code>, <code class="inlineCode">baseAttackDistance</code>, and <code class="inlineCode">playerAttackDistance</code>, as we are going to need them to do the transitions.</li>
      <li class="numberedList">Don’t set any type to <code class="inlineCode">baseTransform</code> as we will fill it later via code, but regarding <code class="inlineCode">baseAttackDistance</code>, make it using the <strong class="screenText">Float</strong> type and put a value of <code class="inlineCode">2</code>, and finally, for <code class="inlineCode">playerAttackDistance</code>, also use <strong class="screenText">Float</strong> and a value of <code class="inlineCode">3</code>. Feel free to change those values if you prefer:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_44_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 9.44: Variables needed for our transitions</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Right-click the <code class="inlineCode">GoToBase</code> node, select<a id="_idIndexMarker563"/> the <strong class="screenText">Make Transition</strong> option, and then click<a id="_idIndexMarker564"/> the <code class="inlineCode">ChasePlayer</code> node. This will create a transition between the two states:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_45_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.45: A transition between two states</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Repeat <em class="italic">step 3</em> for each transition we created in the C# version. The <strong class="screenText">State Machine</strong> graph will need to look like the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_46_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.46: All the needed transitions</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Double-click the yellow<a id="_idIndexMarker565"/> shape in the middle of the transition<a id="_idIndexMarker566"/> between <strong class="screenText">GoToBase</strong> and <strong class="screenText">ChasePlayer</strong> to enter the <strong class="screenText">Transition</strong> mode. Here, you will be able to specify the condition that will trigger that transition (instead of using an <code class="inlineCode">If</code> node during the state logic). Remember, you have two yellow shapes, one for each transition direction, so check you are double-clicking the correct one based on the white arrows connecting them.</li>
      <li class="numberedList">Modify the graph to check whether the <code class="inlineCode">sensedObject</code> variable is not <code class="inlineCode">null</code>. It should look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_47_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.47: Adding a transition condition</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">The transition<a id="_idIndexMarker567"/> between <strong class="screenText">GoToBase</strong> and <strong class="screenText">AttackBase</strong> should<a id="_idIndexMarker568"/> look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_48_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.48: The GoToBase to AttackBase transition condition</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Now, <strong class="screenText">ChasePlayer</strong><strong class="screenText"><a id="_idIndexMarker569"/></strong> to <strong class="screenText">GoToBase</strong> should <a id="_idIndexMarker570"/>be as follows:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_49_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.49: The ChasePlayer to GoToBase transition condition</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="9">For the <strong class="screenText">ChasePlayer</strong> to <strong class="screenText">AttackPlayer</strong> transition, do as in <em class="italic">Figure 9.50</em>. This<a id="_idIndexMarker571"/> is essentially<a id="_idIndexMarker572"/> the same as <strong class="screenText">GoToBase</strong> and <strong class="screenText">AttackBase</strong> (a distance check) but with different targets:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_50_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.50: The ChasePlayer to AttackPlayer transition condition</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="10">For the <strong class="screenText">AttackPlayer</strong> to <strong class="screenText">ChasePlayer</strong> transition, do<a id="_idIndexMarker573"/> as in <em class="italic">Figure 9.51</em>. This is another distance<a id="_idIndexMarker574"/> check but is now checking whether the distance is greater and multiplying the distance by <code class="inlineCode">1.1</code> (to prevent transition jittering, as we explained in the C# version):</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_51_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.51: The AttackPlayer to ChasePlayer transition condition</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="11">Finally, for <strong class="screenText">AttackPlayer</strong> to <strong class="screenText">GoToBase</strong>, this<a id="_idIndexMarker575"/> is the expected <a id="_idIndexMarker576"/>graph:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_52_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.52: The AttackPlayer to GoToBase transition condition</p>
    <p class="normal">A little detail we need to tackle before moving on is the fact that we still don’t have any value set in the <code class="inlineCode">baseTransform</code> variable. The idea is to fill it via code as we did in the C# version. But something to consider here is that we cannot add an <strong class="screenText">Awake</strong> event node to the whole state machine, but just to the states.</p>
    <p class="normal">In this scenario, we could<a id="_idIndexMarker577"/> use the <strong class="screenText">OnEnterState</strong> event, which is an exclusive event node for state machines. It will execute<a id="_idIndexMarker578"/> as soon as the state becomes active, which is useful for state initializations. We could add the logic to initialize the <code class="inlineCode">baseTransform</code> variable in the <strong class="screenText">OnEnterState</strong> event node of the <strong class="screenText">GoToBase</strong> state, given it is the first state we execute.</p>
    <p class="normal">This way, the <strong class="screenText">GoToBase</strong> logic will look as in <em class="italic">Figure 9.53</em>. Remember to double-click the state node to edit it:</p>
    <figure class="mediaobject"><img src="img/B21361_09_53_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.53: The GoToBase initialization logic</p>
    <p class="normal">Notice how, here, we set the result of the <strong class="screenText">Find </strong>node into the variable only on the <strong class="screenText">Null</strong> pin of <strong class="screenText">Null Check</strong>. What <strong class="screenText">Null Check</strong> does is check if our <code class="inlineCode">baseTransform</code> variable is set, going through the <strong class="screenText">Not Null</strong> pin if it is, and <strong class="screenText">Null</strong> if it isn’t. This way, we avoid executing <code class="inlineCode">GameObject.Find</code> every time we enter the <strong class="screenText">GoToBase</strong> state, but only the first time. Also note that, in this case, we will be executing the <strong class="screenText">Set Variable</strong> node not only when the object initializes but also each time <strong class="screenText">GoToBase</strong> becomes the current state. If, in any case, that results in unexpected behavior, other options could be to create a new initial state that initializes everything and then transitions to the rest of the states, or maybe do a classic Visual Scripting graph that initializes those variables in the <strong class="screenText">On Start</strong> event node.</p>
    <p class="normal">With all this, we learned how to create<a id="_idIndexMarker579"/> a decision-making system<a id="_idIndexMarker580"/> for our AI through FSMs. It will make decisions based on the info gathered via sensors and other systems. Now that our FSM states are coded and transition properly, let’s make them do something.</p>
    <h2 id="_idParaDest-135" class="heading-2">Executing FSM actions</h2>
    <p class="normal">Now we need to complete<a id="_idIndexMarker581"/> the last step – make the FSM do something interesting. Here, we can do a lot of things such as shoot the base or the player and move the enemy toward its target (the base or the player). We will be handling movement with the Unity Pathfinding system called <code class="inlineCode">NavMesh</code>, a tool that allows our AI to calculate and traverse paths between two points while avoiding obstacles, which<a id="_idIndexMarker582"/> needs some preparation to work properly.</p>
    <p class="normal">In this section, we will examine the following FSM action concepts:</p>
    <ul>
      <li class="bulletList">Calculating our scene’s NavMesh</li>
      <li class="bulletList">Using Pathfinding</li>
      <li class="bulletList">Adding final details</li>
    </ul>
    <p class="normal">Let’s start by preparing our scene for movement with Pathfinding.</p>
    <h1 id="_idParaDest-136" class="heading-1">Calculating our scene’s NavMesh</h1>
    <p class="normal">Pathfinding algorithms<a id="_idIndexMarker583"/> rely on simplified versions of the scene. Analyzing the full geometry<a id="_idIndexMarker584"/> of a complex scene is almost impossible to do in real time. There are several ways to represent Pathfinding information extracted from a scene, such as graphs and <strong class="keyWord">NavMesh</strong> geometries. Unity uses the latter – a simplified mesh similar to a 3D model that spans all areas that Unity determines are walkable. In the next screenshot, you can find an example of <code class="inlineCode">NavMesh</code> generated in a scene – that is, the light blue geometry:</p>
    <figure class="mediaobject"><img src="img/B21361_09_54_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.54: NavMesh of walkable areas in the scene</p>
    <p class="normal">Generating <code class="inlineCode">NavMesh</code> can take from seconds to minutes depending on the size of the scene. That’s why Unity’s Pathfinding system calculates the <code class="inlineCode">NavMesh</code> once in the Editor, so when we distribute our game, the user will use the pre-generated <code class="inlineCode">NavMesh</code>. In previous Unity versions, like lightmapping, <code class="inlineCode">NavMesh</code> used to be baked into a file for later use. That meant that GameObjects that contributed to the <code class="inlineCode">NavMesh</code> surface used to be static, and that they couldn’t suffer any modifications of the scene during runtime. The main advantage of the new AI navigation system in Unity is that <code class="inlineCode">NavMesh</code> objects can now change during runtime. If you destroy or move a floor tile, the AI will still adapt its behavior to walk, stay, or fall over that area. This means if a floor tile is destroyed during gameplay, the <code class="inlineCode">NavMesh</code> dynamically updates to reflect<a id="_idIndexMarker585"/> this change, showing the AI where it can no longer walk. We will install and use the AI Navigation<a id="_idIndexMarker586"/> package to add this behavior to our game.</p>
    <p class="normal">To generate <code class="inlineCode">NavMesh</code> for our scene, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Open Package Manager (<strong class="screenText">Window</strong> | <strong class="screenText">Package Manager</strong>).</li>
      <li class="numberedList">Set the <strong class="screenText">Packages</strong> dropdown to <strong class="screenText">Unity Registry</strong> mode.</li>
      <li class="numberedList">Search the list for a package called AI Navigation. This package will allow us to have access to new components that will help us define which surfaces are walkable and which agents can walk on top of them. At the time of writing the book, the current version of this package is 1.1.4:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_55.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.55: Installing the AI Navigation package</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Add a <code class="inlineCode">NavMeshSurface</code> component to the walkable surface.</li>
      <li class="numberedList">From the recently added component, click on the <strong class="screenText">Bake</strong> button at the bottom of the window, and check the generated <code class="inlineCode">NavMesh</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_56.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.56: Generating a NavMesh</p>
    <p class="normal">And that’s pretty much everything you need to do. Of course, there are lots of settings you can fiddle around with in this component, such as <strong class="screenText">Max Slope</strong>, which indicates the maximum angle of slopes the AI will be able to climb, or <strong class="screenText">Step Height</strong>, which will determine whether the AI can climb stairs, connecting the floors between the steps in <code class="inlineCode">NavMesh</code>, but as we have a plain and simple scene, the default settings will suffice.</p>
    <p class="normal">If you want to play around with them, you can go to the menu bar and select <strong class="screenText">Window</strong> | <strong class="screenText">AI</strong> | <strong class="screenText">Navigation</strong>. From there, you will be able to adjust all these parameters and re-bake the <code class="inlineCode">NavMeshSurface</code> to adjust the walkable<a id="_idIndexMarker587"/> areas depending on the size<a id="_idIndexMarker588"/> of the AI agents.</p>
    <p class="normal"> With our scene’s <code class="inlineCode">NavMesh</code> set up, we’ve laid the groundwork for sophisticated AI movement. Let’s see this in action as we program our AI to navigate the game world.</p>
    <h2 id="_idParaDest-137" class="heading-2">Using Pathfinding</h2>
    <p class="normal">For making an AI object<a id="_idIndexMarker589"/> that moves with <code class="inlineCode">NavMesh</code>, Unity provides the <code class="inlineCode">NavMeshAgent</code> component, which <a id="_idIndexMarker590"/>will make our AI stick to <code class="inlineCode">NavMesh</code>, preventing the object from going outside it. It will not only calculate the path to a specified destination automatically but will also move the object through the path with the use of <strong class="screenText">Steering </strong>behavior algorithms that mimic the way a human would move through the path, slowing down on corners and turning with interpolations instead of instantaneously. This component also ensures AI characters avoid each other. It prevents crowding by steering each character away from others, maintaining a natural flow in the game.</p>
    <p class="normal">Let’s use this powerful component by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Select the <strong class="screenText">Enemy</strong> Prefab and add the <code class="inlineCode">NavMeshAgent</code> component to it. Add it to the root object, the one called <code class="inlineCode">Enemy</code>, not the AI child – we want the whole object to move. You will see a cylinder around the object representing the area the object will occupy in <code class="inlineCode">NavMesh</code>. Note that this isn’t a collider, so it won’t be used for physical collisions:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_57_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.57: The NavMeshAgent component</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Remove the <code class="inlineCode">ForwardMovement</code> component; from now on, we will drive the movement of our enemy with <code class="inlineCode">NavMeshAgent</code>.</li>
      <li class="numberedList">In the <code class="inlineCode">Awake</code> event function of the <code class="inlineCode">EnemyFSM</code> script, use the <code class="inlineCode">GetComponentInParent</code> function to cache the reference of <code class="inlineCode">NavMeshAgent</code> into a new <code class="inlineCode">private</code> variable. This will work similarly to <code class="inlineCode">GetComponent</code> – it will look for a component in our GameObject, but if the component is not there, this version will try to look for that component in all parents. Remember to add the <code class="inlineCode">using UnityEngine.AI</code> line to use the <code class="inlineCode">NavMeshAgent</code> class in this script:
    <figure class="mediaobject"><img src="img/B21361_09_58_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.58: Caching a parent component reference</p>
    <p class="normal">As you can imagine, there is also the <code class="inlineCode">GetComponentInChildren</code> method, which searches components in <code class="inlineCode">GameObject</code> first and then in all its children if necessary.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">In the <code class="inlineCode">GoToBase</code> state function, call the <code class="inlineCode">SetDestination</code> function of the <code class="inlineCode">NavMeshAgent</code> reference, passing the position of the base object as the target:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_59_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.59: Setting a destination for our AI</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Save the script and test<a id="_idIndexMarker591"/> this with a few enemies in the scene or with the enemies spawned<a id="_idIndexMarker592"/> by the waves. You will see the problem where the enemies will never stop going toward the target position, entering inside the object, if necessary, even if the current state of their FSMs changes when they are near enough. That’s because we never tell <code class="inlineCode">NavMeshAgent</code> to stop, which we can do by setting the <code class="inlineCode">isStopped</code> field of the agent to <code class="inlineCode">true</code>.</li>
      <li class="numberedList">You might want to tweak the base attack distance to make the enemy stop a little bit closer or further away:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_60_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.60: Stopping agent movement</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">We can do the same for <code class="inlineCode">ChasePlayer</code> and <code class="inlineCode">AttackPlayer</code>. In <code class="inlineCode">ChasePlayer</code>, we can set the destination of the agent<a id="_idIndexMarker593"/> to the player’s position, and in <code class="inlineCode">AttackPlayer</code>, we can stop<a id="_idIndexMarker594"/> the movement. In this scenario, <code class="inlineCode">AttackPlayer</code> can go back again to <code class="inlineCode">GoToBase</code> or <code class="inlineCode">ChasePlayer</code>, so you need to set the <code class="inlineCode">isStopped</code> agent field to <code class="inlineCode">false</code> in those states or before doing the transition. We will pick the former, as that version will cover other states that also stop the agent without extra code. We will start with the <code class="inlineCode">GoToBase</code> state:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_61_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.61: Reactivating the agent</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Then, continue with <code class="inlineCode">ChasePlayer</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_62_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.62: Reactivating the agent and chasing the player</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="9">And finally, continue with <code class="inlineCode">AttackPlayer</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_63_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.63: Stopping the movement</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="10">You can tweak the <strong class="screenText">Acceleration</strong>, <strong class="screenText">Speed</strong>, and <strong class="screenText">Angular Speed</strong> properties<a id="_idIndexMarker595"/> of <code class="inlineCode">NavMeshAgent</code> to control how fast the enemy<a id="_idIndexMarker596"/> will move. Balance these settings to make sure the AI moves in a way that makes sense in your game. Also, remember to apply the changes to the Prefab for the spawned enemies to be affected.</li>
      <li class="numberedList">Regarding the Visual Scripting versions, <code class="inlineCode">GoToBase</code><strong class="screenText"> </strong>will look like the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><em class="italic"><img src="img/B21361_09_64_PE.png" alt="A picture containing text, diagram, font, screenshot  Description automatically generated"/></em></figure>
    <p class="packt_figref">Figure 9.64: Making our agent move</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="12">We deleted the <strong class="screenText">OnUpdate</strong> event node printing a message as we don’t need it anymore. Also, we called the <strong class="screenText">Set Destination</strong> node after setting the variable if <code class="inlineCode">if</code> was <code class="inlineCode">null</code>, and also when the variable wasn’t <code class="inlineCode">null</code> (<strong class="screenText">Not Null </strong>pin of <strong class="screenText">Null</strong> <strong class="screenText">Check</strong>). Note that all of this happens in the <strong class="screenText">On Enter State</strong> event, so we just need to do it once. We do it for every frame in the C# version for simplicity but that’s actually not necessary, so we will take advantage of the <strong class="screenText">On Enter State</strong> event. We can emulate that behavior in the C# version if we want, executing these actions at the moment we change the state (inside the <code class="inlineCode">if</code> statements that check the transition conditions), instead of using the <strong class="screenText">Update</strong> function. Finally, notice how we needed to use the <strong class="screenText">Get Parent</strong> node in order to access the <code class="inlineCode">NavMeshAgent</code> component in the enemy’s root object? This is needed because we are currently in the <code class="inlineCode">AI</code> child object instead.</li>
      <li class="numberedList">Now, the <code class="inlineCode">AttackBase</code> state will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_65_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 9.65: Making our agent stop</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="14">The <code class="inlineCode">ChasePlayer</code> state<a id="_idIndexMarker597"/> will look<a id="_idIndexMarker598"/> like this:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_66_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 9.66: The ChasePlayer logic</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="15">And finally, <code class="inlineCode">AttackPlayer</code> will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_67_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.67: The AttackPlayer logic</p>
    <div><p class="normal">While Unity has its own pathfinding system, it is not the only one, and it might not suit more advanced games. I recommend learning the basics of pathfinding, like learning about the BFS, Dijkstra, and A* algorithms. If you want to deep dive, you can learn more advanced techniques, like the tactical pathfinding explained in this Killzone developers’ paper: <a href="http://cse.unl.edu/~choueiry/Documents/straatman_remco_killzone_ai.pdf">http://cse.unl.edu/~choueiry/Documents/straatman_remco_killzone_ai.pdf</a>, or this presentation of Left 4 Dead AI systems: <a href="https://steamcdn-a.akamaihd.net/apps/valve/2009/ai_systems_of_l4d_mike_booth.pdf">https://steamcdn-a.akamaihd.net/apps/valve/2009/ai_systems_of_l4d_mike_booth.pdf</a>.</p>
    </div>
    <p class="normal"> With our AI now capable<a id="_idIndexMarker599"/> of navigating<a id="_idIndexMarker600"/> the game world, we’re close to having a fully functional enemy. Next, we’ll add the finishing touches, including shooting mechanics and animations, to complete our AI’s behavior.</p>
    <h2 id="_idParaDest-138" class="heading-2">Adding the final details</h2>
    <p class="normal">We have two things missing<a id="_idIndexMarker601"/> here: the enemy is not shooting any bullets, and it doesn’t have animations. Let’s start with fixing the shooting by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add a <code class="inlineCode">bulletPrefab</code> field of the <code class="inlineCode">GameObject</code> type to our <code class="inlineCode">EnemyFSM</code> script and a <code class="inlineCode">float</code> field called <code class="inlineCode">fireRate</code>.</li>
      <li class="numberedList">Create a function called <code class="inlineCode">Shoot</code> and call it inside <code class="inlineCode">AttackBase</code> and <code class="inlineCode">AttackPlayer</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_68_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.68: Shooting function calls</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">In the <code class="inlineCode">Shoot</code> function, put a similar<a id="_idIndexMarker602"/> code as that used in the <code class="inlineCode">PlayerShooting</code> script to shoot bullets at a specific fire rate, as in <em class="italic">Figure 9.68</em>. Remember to set the <code class="inlineCode">Enemy</code> layer in your <code class="inlineCode">Enemy</code> Prefab, if you didn’t before, to prevent the bullet from damaging the enemy itself. You might also want to raise the <code class="inlineCode">AI</code> GameObject position a little bit to shoot bullets from a position other than the ground or, better, add a <code class="inlineCode">shootPoint</code> transform field and create an empty object in the enemy to use as a spawn position. If you do that, consider making the empty object not be rotated so the enemy rotation affects the direction of the bullet properly:
    <figure class="mediaobject"><img src="img/B21361_09_69.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 9.69: Shoot function code</p>
    <p class="normal">Here, you find some duplicated shooting behavior between <code class="inlineCode">PlayerShooting</code> and <code class="inlineCode">EnemyFSM</code>. You can fix that by creating a <code class="inlineCode">Weapon</code> behavior with a function called <code class="inlineCode">Shoot</code> that instantiates bullets and takes into account the fire rate, and call it inside both components to re-utilize it.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">When the agent<a id="_idIndexMarker603"/> is stopped, not only does the movement stop but also the rotation. If the player moves while the enemy is being attacked, we still need the enemy to face the player to shoot bullets in its direction. We can create a <code class="inlineCode">LookTo</code> function that receives the target position to look at and then call it in <code class="inlineCode">AttackPlayer</code> and <code class="inlineCode">AttackBase</code>, passing the target to shoot at:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_70_PE.png" alt="A screenshot of a computer code  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 9.70: LookTo function calls</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Complete the <code class="inlineCode">LookTo</code> function by calculating the direction of our parent to the target position. We access <a id="_idIndexMarker604"/>our parent with <code class="inlineCode">transform.parent</code> because, remember, we are the child <code class="inlineCode">AI</code> object – the object that will move is our parent. Then, we set the <code class="inlineCode">Y</code> component of the direction to <code class="inlineCode">0</code> to prevent the direction from pointing upward or downward – we don’t want our enemy to rotate vertically. Finally, we set the forward vector of our parent to that direction so it will face the target position immediately. You can replace that with interpolation through quaternions to have a smoother rotation if you want to, but let’s keep things as simple as possible for now:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_71_PE.png" alt="A screen shot of a computer code  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 9.71: Looking toward a target</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Regarding the Visual Scripting<a id="_idIndexMarker605"/> version, <strong class="screenText">AttackBase</strong> actions look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_09_72_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 9.72: AttackBase state</p>
    <p class="normal">In this state, we have some things to highlight. First, we are using the <strong class="screenText">Look At </strong>node in the <strong class="screenText">On Enter State </strong>event node after the <strong class="screenText">Set Stopped</strong> node. As you might imagine, this does the same as we did with math in C#. We specify a target to look at (our base transform) and then we specify that the <strong class="screenText">World Up</strong> parameter is a vector pointing upward <code class="inlineCode">0</code>,<code class="inlineCode">1</code>,<code class="inlineCode">0</code>. This will make our object look at the base but maintain its up vector pointing to the sky, meaning our object will not look at the floor if the target is lower than it. </p>
    <p class="normal">We can use this exact function in C# if we want to (<code class="inlineCode">transform.LookAt</code>); the idea was just to show you all the options. Also, note that we execute <code class="inlineCode">LookAt</code> only when the state becomes active; as the base doesn’t move, we don’t need to constantly update our orientation.</p>
    <p class="normal">The second thing to highlight is that we used coroutines to shoot, the same idea we used in the <strong class="screenText">Enemy Spawner</strong> to constantly spawn enemies. Essentially, we make an infinite loop between<strong class="screenText"> Wait For Seconds</strong> and <strong class="screenText">Instantiate</strong>. We took this approach here because it was convenient as it takes fewer nodes in Visual Scripting.</p>
    <p class="normal">Remember to select the <strong class="screenText">On Enter State</strong> node<a id="_idIndexMarker606"/> and check the <strong class="screenText">Coroutine</strong> checkbox as we did before. Also, we need a new <code class="inlineCode">Float</code> type variable called <code class="inlineCode">fireRate</code> in the <strong class="screenText">Enemy</strong> <code class="inlineCode">AI</code> child object:</p>
    <figure class="mediaobject"><img src="img/B21361_09_73_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 9.73: Coroutines</p>
    <p class="normal">Then, <strong class="screenText">AttackPlayer</strong> will look like this:</p>
    <figure class="mediaobject"><img src="img/B21361_09_74_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 9.74: AttackPlayer state</p>
    <p class="normal">Essentially it is the same as <strong class="screenText">AttackBase</strong>, but that looks toward the <code class="inlineCode">sensedObject</code> instead of toward the player’s base, and we also made the <strong class="screenText">Look At</strong> node part of the infinite loop, to correct the enemy’s heading before shooting to target the player.</p>
    <p class="normal">With that, we have finished all AI behaviors. Of course, these scripts/graphs are big enough to deserve some rework and splitting<a id="_idIndexMarker607"/> in the future, but with this, we have prototyped our AI, and we can test it until we are happy with it, and then we can improve this code.</p>
    <h1 id="_idParaDest-139" class="heading-1">Summary</h1>
    <p class="normal">I’m pretty sure AI is not what you imagined; you are not creating Skynet here, but we have accomplished a simple but interesting AI to challenge our players, which we can iterate and tweak to tailor to our game’s expected behavior. We saw how to gather our surrounding information through sensors to make decisions on what action to execute using FSMs and different Unity systems such as Pathfinding to make the AI execute those actions. We used those systems to diagram a state machine capable of detecting the player, running to them, and attacking them, and if the player is not there, just going to the base to accomplish its task to destroy it.</p>
    <p class="normal">As we move on to the next chapter, we’ll shift our focus to another vital aspect of game development: enhancing the graphics and audio. Get ready to dive into creating materials and shaders that will bring your game world to life.</p>
    <h1 id="_idParaDest-140" class="heading-1">Learn more on Discord</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. Scan the QR code or visit the link to join the community:</p>
    <p class="normal"><a href="https://packt.link/unitydev">https://packt.link/unitydev</a></p>
    <p class="normal"><img src="img/QR_Code1498477041053909218.png" alt="" role="presentation"/></p>
  </div>
</body></html>