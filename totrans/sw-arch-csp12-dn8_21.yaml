- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '21'
- en: Case Study
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: As mentioned during the previous chapters, for this new edition, we reformulated
    the way we present the case study of the book – **World Wild Travel Club** (**WWTravelClub**).
    This case study will take you through the process of creating the software architecture
    for a travel agency.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，对于这个新版本，我们重新构思了本书的案例研究——**世界野生旅行俱乐部**（**WWTravelClub**）。这个案例研究将带你了解为旅行社创建软件架构的过程。
- en: The purpose of this case study is not to furnish a production-ready application,
    but just to help you understand the theory explained in each chapter and to provide
    an example of how to develop an enterprise application with Azure, Azure DevOps,
    C# 12, .NET 8, ASP.NET Core, and all other technologies introduced in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本案例研究的目的是不是为了提供一个现成的生产应用，而是帮助你理解每一章中解释的理论，并提供一个如何使用Azure、Azure DevOps、C# 12、.NET
    8、ASP.NET Core以及本书中介绍的所有其他技术开发企业应用的示例。
- en: Let’s start with a description of what our case study application is. Then,
    we will gradually move to formal specifications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从描述我们的案例研究应用开始。然后，我们将逐步过渡到正式规范。
- en: Introducing World Wild Travel Club
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍世界野生旅行俱乐部
- en: WWTravelClub is a travel agency that was created to revolutionize vacation planning
    and travel experiences globally. To do so, they are developing an online service,
    where each aspect of a trip is meticulously curated and supported by a dedicated
    team of destination-specific experts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: WWTravelClub是一家旨在全球范围内革新度假规划和旅行体验的旅行社。为此，他们正在开发一个在线服务，其中每个旅行的方面都经过精心策划，并由一支专门针对特定目的地的专家团队支持。
- en: The concept of this platform is that you can be both a visitor and a destination
    expert at the same time. The more you participate as an expert in a destination,
    the more points you score. These points can then be redeemed for tickets that
    people buy online using the platform.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平台的概念是你可以同时成为访客和目的地专家。你作为目的地专家参与的越多，你获得的积分就越多。这些积分可以用来兑换人们通过平台在线购买的门票。
- en: 'The responsible for the WWTravelClub project came with the following requirements
    list for the platform:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: WWTravelClub项目的负责人为该平台带来了以下要求列表：
- en: 'Common user view:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见用户视图：
- en: Promotional packages on the home page
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首页上的促销包
- en: Get a recommendation
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得推荐
- en: Search for packages
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索包
- en: 'Details for each package:'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个包的详细信息：
- en: Buy a package
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买包
- en: Buy a package with a club of experts included
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买包含专家俱乐部的包
- en: Comment on your experience
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论你的体验
- en: Ask an expert
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向专家提问
- en: Evaluate an expert
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估专家
- en: Register as a common user
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册为普通用户
- en: 'Destination expert view:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的地专家视图：
- en: The same view as the common user view
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与常见用户视图相同的视图
- en: Answer questions asking for your destination expertise
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回答询问你目的地专业知识的问题
- en: Manage the points you scored by answering questions
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理你通过回答问题获得的积分
- en: Exchange points for tickets
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用积分兑换门票
- en: 'Administrator view:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员视图：
- en: Manage packages
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理包
- en: Manage common users
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理普通用户
- en: Manage destination experts
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理目的地专家
- en: Besides the functionalities asked for on the platform, it is important to note
    that WWTravelClub intends to have more than 100 destination experts per package
    and will offer around 1,000 different packages all over the world.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了平台上要求的功能外，重要的是要注意，WWTravelClub计划为每个包配备超过100位目的地专家，并将提供全球约1,000种不同的包。
- en: It is important to know that, in general, customers do not bring the requirements
    ready for development. That is why the process of gathering requirements is so
    important, as described in *Chapter 1, Understanding the Importance of Software
    Architecture*. This process will transform the list presented above into user
    needs and system requirements. Let’s check how this will work in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，通常，客户不会为开发准备好的要求。这就是为什么收集需求的过程如此重要，如*第一章，理解软件架构的重要性*中所述。这个过程将把上述列表转换成用户需求和系统需求。让我们看看在下一节中这将如何运作。
- en: User needs and system requirements
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户需求和系统需求
- en: 'As presented in *Chapter 1, Understanding the Importance of Software Architecture*,
    to summarize the user needs, you may use the User Story pattern. We have used
    this approach here so that you can read the following user stories for WWTravelClub:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如*第一章，理解软件架构的重要性*中所述，为了总结用户需求，你可以使用用户故事模式。我们在这里采用了这种方法，以便你可以阅读以下针对WWTravelClub的用户故事：
- en: '`US_001`: As a common user, I want to view promotional packages on the home
    page so that I can easily find my next vacation.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_001`: 作为一名普通用户，我想在主页上查看促销套餐，以便我能轻松找到我的下一个假期。'
- en: '`US_002`: As a common user, I want to search for packages I cannot find on
    the home page so that I can explore other trip opportunities.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_002`: 作为一名普通用户，我想搜索主页上找不到的套餐，以便我能探索其他旅行机会。'
- en: '`US_003`: As a common user, I want to see the details of a package so that
    I can decide which package to buy.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_003`: 作为一名普通用户，我想查看套餐的详细信息，以便我能决定购买哪个套餐。'
- en: '`US_004`: As a common user, I want to register myself so that I can start buying
    the package.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_004`: 作为一名普通用户，我想注册自己，以便我能开始购买套餐。'
- en: '`US_005`: As a registered user, I want to process the payment so that I can
    buy a package.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_005`: 作为一名注册用户，我想处理支付，以便我能购买套餐。'
- en: '`US_006`: As a registered user, I want to buy a package with an expert recommendation
    included so that I can have an exclusive trip experience.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_006`: 作为一名注册用户，我想购买包含专家推荐套餐，以便我能拥有独特的旅行体验。'
- en: '`US_007`: As a registered user, I want to ask for an expert so that I can find
    out the best things to do on my trip.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_007`: 作为一名注册用户，我想请求一位专家，以便我能了解旅行中最佳的活动。'
- en: '`US_008`: As a registered user, I want to comment on my experience so that
    I can give feedback on my trip.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_008`: 作为一名注册用户，我想对我的体验进行评论，以便我能对我的旅行提供反馈。'
- en: '`US_009`: As a registered user, I want to review an expert who has helped me
    so that I can share with others how fantastic they were.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_009`: 作为一名注册用户，我想评价帮助过我的专家，以便我能与他人分享他们多么出色。'
- en: '`US_010`: As a registered user, I want to register as a destination expert
    view so that I can help people who travel to my city.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_010`: 作为一名注册用户，我想注册为目的地专家，以便我能帮助前往我所在城市旅行的人。'
- en: '`US_011`: As an expert user, I want to answer questions about my city so that
    I can score points to be exchanged in the future.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_011`: 作为一名专家用户，我想回答关于我所在城市的问题，以便我能获得未来可兑换的积分。'
- en: '`US_012`: As an expert user, I want to exchange points for tickets so that
    I can travel around the world more.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_012`: 作为一名专家用户，我想用积分兑换机票，以便我能环游世界。'
- en: '`US_013`: As an administrator user, I want to manage packages so that users
    can have fantastic opportunities to travel.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_013`: 作为一名管理员用户，我想管理套餐，以便用户能有机会享受精彩的旅行。'
- en: '`US_014`: As an administrator user, I want to manage registered users so that
    WWTravelClub can guarantee good service quality.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_014`: 作为一名管理员用户，我想管理注册用户，以便WWTravelClub能保证良好的服务质量。'
- en: '`US_015`: As an administrator user, I want to manage expert users so that all
    the questions regarding our destinations are answered.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_015`: 作为一名管理员用户，我想管理专家用户，以便所有关于我们目的地的问题都能得到解答。'
- en: '`US_016`: As an administrator user, I want to offer more than 1,000 packages
    around the world so that different countries can experience the WWTravelClub service.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_016`: 作为一名管理员用户，我想提供世界上超过1,000个套餐，以便不同国家能体验WWTravelClub的服务。'
- en: '`US_017`: As the CEO, I want to have more than 1,000 users simultaneously accessing
    the website so that the business can scale effectively.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_017`: 作为首席执行官，我想让超过1,000名用户同时访问网站，以便业务能够有效扩展。'
- en: '`US_018`: As a user, I want to access WWTravelClub in my native language so
    that I can easily understand the package offered.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_018`: 作为一名用户，我想用我的母语访问WWTravelClub，以便我能轻松理解提供的套餐。'
- en: '`US_019`: As a user, I want to access WWTravelClub in the Chrome, Firefox,
    and Edge web browsers so that I can use the web browser of my preference.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_019`: 作为一名用户，我想在Chrome、Firefox和Edge网络浏览器中访问WWTravelClub，以便我能使用我偏好的网络浏览器。'
- en: '`US_020`: As a user, I want to know that my credit card information is stored
    securely, so I can buy packages safely.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_020`: 作为一名用户，我想知道我的信用卡信息是安全存储的，以便我能安全购买套餐。'
- en: '`US_021`: As a user, I want to get a recommendation of a good place to visit
    according to other people from my city, so I can find out about new places that
    fit my style.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`US_021`: 作为一名用户，我想根据来自我所在城市的人的建议获得一个不错的旅游地点推荐，以便我能了解适合我风格的新地方。'
- en: Notice that while writing the stories, information related to non-functional
    requirements such as security, environment, performance, and scalability can be
    included.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在编写故事时，可以包含与安全、环境、性能和可扩展性等非功能性要求相关的信息。
- en: 'However, some system requirements may be omitted when you write user stories
    and need to be included in the software specification. These requirements can
    be related to legal aspects, hardware, and software prerequisites, or even points
    of attention for the correct system delivery. We discussed them in *Chapter 2,
    Non-Functional Requirements*. So non-functional requirements need to be mapped
    and listed, as well as the user stories. The WWTravelClub system requirements
    are presented in the following list. Note that requirements are written in the
    future tense because the system does not exist yet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在编写用户故事时，可能省略了一些系统要求，这些要求需要包含在软件规范中。这些要求可能与法律方面、硬件和软件先决条件有关，甚至可能涉及正确交付系统的注意事项。我们在*第2章，非功能性需求*中讨论了它们。因此，非功能性需求需要映射和列出，以及用户故事。以下列出了WWTravelClub的系统要求。请注意，要求是用将来时态写的，因为系统尚不存在：
- en: '`SR_001`: The system shall use cloud computing components to deliver the scalability
    required.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SR_001`：系统应使用云计算组件来提供所需的可伸缩性。'
- en: '`SR_002`: The system shall respect **General Data Protection Regulation** (**GDPR**)
    requirements.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SR_002`：系统应遵守**通用数据保护条例**（**GDPR**）的要求。'
- en: '`SR_003`: Any web page of this system shall respond within at least 2 seconds
    of 1,000 users accessing it concurrently.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SR_003`：在任何情况下，当1000个用户同时访问该系统时，任何网页的响应时间至少应为2秒。'
- en: The idea of having this list of user stories and system requirements is to help
    you understand how complex the development of a platform might be if you think
    about it from an architectural perspective.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列出这些用户故事和系统要求的想法是为了帮助你从架构的角度思考，了解平台开发可能有多复杂。
- en: Now that we have the list of user stories for the platform, it is time to start
    selecting the .NET project types that will be used at WWTravelClub. Let’s check
    them in the next topic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了平台用例列表，是时候开始选择在WWTravelClub中将使用的.NET项目类型了。让我们在下一节中检查它们。
- en: Main types of .NET projects used at WWTravelClub
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WWTravelClub使用的.NET项目的主要类型
- en: The development of this book’s use case will be based on various kinds of .NET
    Core Visual Studio projects. This section describes all of them. Let us select
    **New project** in the Visual Studio **File** menu.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本书用例的开发将基于各种类型的.NET Core Visual Studio项目。本节描述了所有这些项目。让我们在Visual Studio的**文件**菜单中选择**新建项目**。
- en: 'For instance, you can filter **.NET Core** project types by typing them into
    the search engine as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在搜索引擎中输入以下内容来过滤**.NET Core**项目类型：
- en: '![](img/B19820_21_01.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_21_01.png)'
- en: 'Figure 21.1: Searching types of .NET Core projects in Visual Studio'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.1：在Visual Studio中搜索.NET Core项目类型
- en: 'There, you will find common C# projects (console, a class library, Windows
    Forms, and WPF), and various types of test projects, each based on a different
    test framework: xUnit, NUnit, and MSTest. Choosing among the various testing frameworks
    is just a matter of preference since they all offer comparable features. Adding
    tests to each piece of software that composes a solution is a common practice
    and allows the software to be modified frequently without jeopardizing its reliability.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，你可以找到常见的C#项目（控制台、类库、Windows Forms和WPF），以及各种类型的测试项目，每个项目基于不同的测试框架：xUnit、NUnit和MSTest。选择各种测试框架只是个人喜好问题，因为它们都提供了类似的功能。将测试添加到构成解决方案的每一块软件中是一种常见做法，这允许软件频繁修改而不会危及其可靠性。
- en: You may also want to define your class library projects under **.NET Standard**,
    which was discussed in *Chapter 5*, *Implementing Code Reusability in C# 12*.
    These class libraries are based on standards that make them compatible with several
    .NET versions. For instance, libraries based on 2.0 standards are compatible with
    all .NET Core versions greater than or equal to 2.0, with all .NET versions greater
    than 5, and with all .NET Framework versions greater than 4.6\. This compatibility
    advantage comes at the price of having fewer available features.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能想在**.NET Standard**下定义你的类库项目，这在*第5章，实现C# 12中的代码重用*中已有讨论。这些类库基于标准，使它们与多个.NET版本兼容。例如，基于2.0标准的库与所有大于或等于2.0的.NET
    Core版本、所有大于5的.NET版本以及所有大于4.6的.NET Framework版本兼容。这种兼容性优势是以牺牲更少的功能为代价的。
- en: 'Besides filtering **project types** to the **cloud**, we have several more
    project types. Some of them will enable us to define microservices. Microservice-based
    architectures allow an application to be split into several independent microservices.
    Several instances of the same microservice can be created and distributed across
    several machines to fine-tune the performance of each application part. If you
    want to learn about microservices, we have talked about them in the following
    chapters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将**项目类型**过滤到**云**中，我们还有更多项目类型。其中一些将使我们能够定义微服务。基于微服务的架构允许将应用程序拆分为几个独立的微服务。可以创建相同微服务的多个实例，并将它们分布到多台机器上以微调每个应用程序部分的表现。如果您想了解微服务，我们已在以下章节中讨论了它们：
- en: '*Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第11章*，*将微服务架构应用于您的企业应用*'
- en: '*Chapter 14*, *Implementing Microservices with .NET*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第14章*，*使用.NET实现微服务*'
- en: '*Chapter 20*, *Kubernetes*'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第20章*，*Kubernetes*'
- en: 'In *Chapter 2*, *Non-Functional Requirements*, we described an ASP.NET Core
    application project in the subsection *Creating a scalable web app with .NET 8*.
    There, we defined an ASP.NET Core application, but Visual Studio also contains
    project templates for projects based on RESTful APIs and the most important single-page
    application frameworks, such as Angular, React, Vue.js, and the Blazor framework
    based on WebAssembly, which was discussed in *Chapter 19*, *Client Frameworks:
    Blazor*. Some of them are available with the standard Visual Studio installation,
    while others require the installation of an SPA package, called **ASP.NET and
    web development** workload.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*，*非功能性需求*中，我们在*使用.NET 8创建可扩展的Web应用*子节中描述了一个ASP.NET Core应用程序项目。在那里，我们定义了一个ASP.NET
    Core应用程序，但Visual Studio还包含基于RESTful API和最重要的单页应用框架（如Angular、React、Vue.js以及基于WebAssembly的Blazor框架）的项目模板，这些框架在第19章*客户端框架：Blazor*中进行了讨论。其中一些在标准的Visual
    Studio安装中可用，而其他则需要安装一个名为**ASP.NET和Web开发**的工作负载的SPA包。
- en: To finish, testing projects were discussed in detail in *Chapter 9*, *Testing
    Your Enterprise Application*. We suggest you, as a software architect, try all
    the templates available at Visual Studio by creating proofs of concept that may
    help you define the best project types for your solution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第9章*测试您的企业应用*中详细讨论了测试项目。我们建议您作为软件架构师，通过创建可能帮助您定义最佳项目类型的概念验证来尝试Visual Studio中所有可用的模板。
- en: Now that we have checked these different project types, let’s have a look at
    Azure DevOps and how it can be helpful in managing WWTravelClub is requirements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了这些不同的项目类型，让我们看看Azure DevOps以及它如何有助于管理WWTravelClub的需求。
- en: Managing WWTravelClub’s requirements using Azure DevOps
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Azure DevOps管理WWTravelClub的需求
- en: As discussed in *Chapter 3, Managing Requirements*, an important step for a
    software development project is where and how the team will organize the user
    stories mapped from the user needs. There, as described in the *Managing system
    requirements in Azure DevOps* section, Azure DevOps enables you to document system
    requirements using work items, which are mainly tasks or actions that need to
    be completed to deliver a product or service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第3章*管理需求*中讨论的，对于软件开发项目的一个重要步骤是团队将如何组织从用户需求映射过来的用户故事。在那里，正如在*在Azure DevOps中管理系统需求*部分中描述的，Azure
    DevOps使您能够使用工作项来记录系统需求，这些工作项主要是需要完成以交付产品或服务的任务或行动。
- en: It is also important to remember that the work items available depend on the
    *work item process* you select while creating the Azure DevOps project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要记住，可用的工项取决于您在创建Azure DevOps项目时选择的*工项流程*。
- en: 'Considering the scenario described for WWTravelClub, we decided to use the
    Agile process and have defined three Epic work items as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到为WWTravelClub描述的场景，我们决定使用敏捷流程，并定义了以下三个史诗级工作项：
- en: '![](img/B19820_21_02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_02.png)'
- en: 'Figure 21.2: User case Epics'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.2：用户案例史诗
- en: 'The creation of these work items is quite simple:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工作项的创建相当简单：
- en: Inside each work item, we link the different types of work items, as you can
    see in *Figure 21.3*.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个工作项内部，我们将不同类型的工作项相互关联，正如您在*图21.3*中可以看到的那样。
- en: 'It is important to determine that the connections between work items are useful
    during software development. Hence, as a software architect, you must provide
    this knowledge to your team, and, more than that, you must incentivize them to
    make these connections:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在软件开发过程中确定工作项之间的联系非常重要。因此，作为一名软件架构师，您必须向您的团队提供这些知识，而且更重要的是，您必须激励他们建立这些联系：
- en: '![](img/B19820_21_03.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_03.png)'
- en: 'Figure 21.3: Defining a Feature link to the Epic selected'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.3：定义一个特性链接到选定的史诗
- en: 'As soon as you create a **Feature** work item, you will be able to connect
    it to several User Story work items that detail its specifications. The following
    screenshot shows the details:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您创建了一个**特性**工作项，您将能够将其连接到多个详细说明其规格的用户故事工作项。以下截图显示了详细信息：
- en: '![](img/B19820_21_04.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_04.png)'
- en: 'Figure 21.4: Product Backlog work item'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.4：产品待办事项工作项
- en: After that, Task and Test Case work items can be created for each User Story
    work item. The user interface provided by Azure DevOps is efficacious because
    it enables you to track the chain of functionalities and the relationships between
    them.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，可以为每个用户故事工作项创建任务和测试用例工作项。Azure DevOps提供的用户界面非常有效，因为它允许您跟踪功能链及其之间的关系。
- en: '![](img/B19820_21_05.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_05.png)'
- en: 'Figure 21.5: Board view'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.5：看板视图
- en: 'Considering we are using Scrum as the basis for the Agile process, as soon
    as you complete the input for the User Story and Task work items, you will be
    able to plan the project sprints together with your team. The plan view enables
    you to drag and drop User Story work items to each planned sprint/iteration:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到我们以Scrum作为敏捷过程的基础，一旦您完成了用户故事和任务工作项的输入，您将能够与您的团队一起规划项目冲刺。计划视图允许您将用户故事工作项拖放到每个计划好的冲刺/迭代中：
- en: '![](img/B19820_21_06.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_06.png)'
- en: 'Figure 21.6: Backlogs view'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.6：待办事项视图
- en: By clicking on a specific sprint on the right, you will see just the work items
    assigned to that sprint. Each sprint page is quite like the backlog page but contains
    more tabs, where you can define **Sprint Period** and **Team Capacity**, for instance.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击右侧的特定冲刺，您将只看到分配给该冲刺的工作项。每个冲刺页面相当类似于待办事项页面，但包含更多标签页，例如，您可以定义**冲刺周期**和**团队容量**。
- en: '![Interface gráfica do usuário, Aplicativo  Descrição gerada automaticamente](img/B19820_21_07.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，应用程序，自动生成的描述](img/B19820_21_07.png)'
- en: 'Figure 21.7: Planning view'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.7：规划视图
- en: Also useful is the **Sprints** menu on the left, which enables each user to
    jump immediately to the current sprints of all the projects they are engaged in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的**冲刺**菜单也非常有用，它允许每个用户立即跳转到他们参与的所有项目的当前冲刺。
- en: This is how these work items are created. Once you understand this mechanism,
    you will be able to create and plan any software project. It is worth mentioning
    that the tool itself will not solve problems related to team management. However,
    the tool is a great way to incentivize the team to update the project status,
    so you can maintain a clear perspective of how the project is evolving.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工作项就是这样创建的。一旦您理解了这个机制，您将能够创建和规划任何软件项目。值得一提的是，工具本身并不能解决与团队管理相关的问题。然而，这个工具是激励团队更新项目状态的一个很好的方式，这样您就可以保持对项目进度的清晰视角。
- en: Now that we have defined how we will manage WWTravelClub requirements, it is
    time to start thinking about the code standard that will be followed by the developers.
    Let’s check this out in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了如何管理WWTravelClub的需求，那么是时候开始考虑开发者将遵循的代码标准了。让我们在下一节中查看。
- en: Code standard for WWTravelClub – Dos and don’ts when writing code
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WWTravelClub的代码标准 – 编写代码时的注意事项和禁忌
- en: In *Chapter 4, Best Practices in Coding C# 12*, we learned that, as a software
    architect, you must define a code standard that matches the needs of the company
    you are working for.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章，C# 12编码最佳实践*中，我们了解到，作为一名软件架构师，您必须定义一个符合您所在公司需求的代码标准。
- en: In the sample project of this book, this is no different. The way we decided
    to present the standard for it is by describing a list of dos and don’ts. We have
    followed this list while writing the samples we produced. It is worth mentioning
    that the list is a good way to start your standard and, as a software architect,
    you should discuss this list with the developers you have in the team so that
    you can develop it in a practical and good manner.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例项目中，这一点并无不同。我们决定通过描述一系列“应该做”和“不应该做”的标准来展示这一标准。我们在编写示例时遵循了这个列表。值得一提的是，这个列表是一个很好的开始标准，并且作为一个软件架构师，你应该与团队中的开发者讨论这个列表，以便以实际和良好的方式发展它。
- en: It is also important to remember that, in the *Understanding and applying tools
    that can evaluate C# code* section of *Chapter 4, Best Practices in Coding C#12*,
    we have discussed some good tools that can help you define a *coding style* for
    your team*.*
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还重要的是要记住，在第 4 章“C# 编码最佳实践 12”的“理解和应用可以评估 C# 代码的工具”部分，我们讨论了一些可以帮助你为团队定义 *coding
    style* 的好工具*。
- en: In addition, the statements below are designed to clarify the communication
    between team members and improve the performance and maintenance of the software
    you are developing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下语句旨在阐明团队成员之间的沟通，并提高你正在开发的软件的性能和维护性。
- en: 'You may consider the list below a waste of space in the book since we have
    great C# community coding standards without the need to enforce a standard. However,
    how can you guarantee maintainability without it? If defining coding standards
    was not necessary, we wouldn’t have so many projects with maintenance issues.
    So, let’s check the list of dos and don’ts defined for the WWTravelClub project:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为下面的列表在书中是浪费空间的，因为我们有很好的 C# 社区编码标准，无需强制执行标准。然而，没有它，你怎么能保证可维护性呢？如果定义编码标准不是必要的，我们就不会有那么多维护问题。所以，让我们检查为
    WWTravelClub 项目定义的“应该做”和“不应该做”的列表：
- en: DO write your code in English.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用英语编写你的代码。
- en: DO use PascalCasing for all public member, type, and namespace names consisting
    of multiple words.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于由多个单词组成的公共成员、类型和命名空间名称，始终使用 PascalCasing。
- en: DO use camelCasing for parameter names.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于参数名称，始终使用 camelCasing。
- en: DO write classes, methods, and variables with understandable names.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用可理解的名字编写类、方法和变量。
- en: DO comment public classes, methods, and properties.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对公共类、方法和属性进行注释。
- en: DO use the `using` statement whenever possible.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，始终使用 `using` 语句。
- en: DO use `async` implementation whenever possible.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，始终使用 `async` 实现。
- en: DON’T write empty `try-catch` statements.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写空的 `try-catch` 语句。
- en: DON’T write methods with a cyclomatic complexity score of more than 10.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写复杂度得分超过 10 的方法。
- en: DON’T use `break` and `continue` inside `for/while/do-while/foreach` statements.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在 `for/while/do-while/foreach` 语句中使用 `break` 和 `continue`。
- en: These dos and don’ts are simple to follow and, better than that, will yield
    great results for the code your team produces. It is worth mentioning that these
    DOs and DON’Ts are a guide, not a set of hard-and-fast rules to be followed by
    every team. They can be adapted as needed for the specific needs of a team before
    they are sent out to the team members. As a software architect, it is essential
    that all team members follow the same DOs and DON’Ts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“应该做”和“不应该做”的规则很容易遵循，而且比这更好，它们将为你的团队产生的代码带来很好的结果。值得一提的是，这些 DOs 和 DON’Ts 只是一个指南，而不是每个团队都必须遵循的硬性规则。在发送给团队成员之前，可以根据团队的具体需求进行调整。作为一个软件架构师，确保所有团队成员遵循相同的
    DOs 和 DON’Ts 是至关重要的。
- en: Considering we now have a coding standard defined, let’s learn how to apply
    SonarCloud as a tool for helping us in code analysis.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们现在已经定义了编码标准，让我们学习如何将 SonarCloud 作为代码分析的工具来帮助我们。
- en: Applying SonarCloud to WWTravelClub APIs
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 SonarCloud 应用到 WWTravelClub API 上
- en: Now that we have already created the WWTravelClub repository, we can Improve
    the code quality, as discussed in *Chapter 4, Best Practices in Coding C# 12*.
    As we saw in that chapter, Azure DevOps enables continuous integration, and this
    can be useful. In this section, we will discuss more reasons why the DevOps concept
    and the Azure DevOps platform are so useful.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 WWTravelClub 仓库，我们可以提高代码质量，正如在第 4 章“C# 编码最佳实践 12”中讨论的那样。正如我们在那一章中看到的，Azure
    DevOps 允许持续集成，这很有用。在本节中，我们将讨论更多关于 DevOps 概念和 Azure DevOps 平台为何如此有用的原因。
- en: For now, the only thing we would like to introduce is the possibility of analyzing
    code after it is committed by the developers but before it has been published.
    Nowadays, in a SaaS world for application life cycle tools, this is only possible
    because of some of the SaaS code analysis platforms that we have. This use case
    will use SonarCloud.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们想介绍的唯一一件事是，在开发人员提交代码但尚未发布之前分析代码的可能性。如今，在SaaS应用程序生命周期工具的SaaS世界中，这仅可能是因为我们有一些SaaS代码分析平台。此用例将使用SonarCloud。
- en: 'SonarCloud is the SaaS version provided by Sonar. Also, it might be worth noting
    that SonarCloud is exceptionally easy to self-host; this way, sensitive security
    information may be kept within an enterprise. It is free for open-source code
    and can analyze code stored in GitHub, Bitbucket, and Azure DevOps. The user needs
    a registration for these platforms. As soon as you log in, assuming your code
    is stored in Azure DevOps, you can follow the steps described in the following
    article to create a connection between your Azure DevOps and SonarCloud: [https://docs.sonarcloud.io/](https://docs.sonarcloud.io/).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SonarCloud是Sonar提供的SaaS版本。还值得注意的是，SonarCloud特别容易进行自托管；这样，敏感的安全信息可以保存在企业内部。对于开源代码是免费的，并且可以分析存储在GitHub、Bitbucket和Azure
    DevOps中的代码。用户需要在这些平台上进行注册。一旦登录，假设您的代码存储在Azure DevOps中，您就可以遵循以下文章中描述的步骤，在您的Azure
    DevOps和SonarCloud之间创建连接：[https://docs.sonarcloud.io/](https://docs.sonarcloud.io/)。
- en: Sonar also provides a self-managed edition that can be useful for scenarios
    where SonarCloud cannot be used. Please check [https://www.sonarsource.com/](https://www.sonarsource.com/)
    for more details.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Sonar还提供了一种自托管版本，这在SonarCloud无法使用的情况下可能很有用。请访问[https://www.sonarsource.com/](https://www.sonarsource.com/)获取更多详情。
- en: 'After setting up the connection between your project in Azure DevOps and SonarCloud,
    you will have a build pipeline like the one that follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置Azure DevOps项目与SonarCloud之间的连接后，您将拥有以下类似的构建管道：
- en: '![](img/B19820_21_08.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_08.png)'
- en: 'Figure 21.8: SonarCloud configuration in the Azure build pipeline'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.8：Azure构建管道中的SonarCloud配置
- en: 'It is worth mentioning that C# projects do not have a GUID number, and this
    is required by SonarCloud. You can easily generate one using this link: [https://www.guidgenerator.com/](https://www.guidgenerator.com/),
    or using the **Create GUID** tool in Visual Studio (**Tools** -> **Create GUID**).
    The GUID will need to be placed as in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，C#项目没有GUID编号，而SonarCloud需要这个编号。您可以使用此链接轻松生成一个：[https://www.guidgenerator.com/](https://www.guidgenerator.com/)，或者使用Visual
    Studio中的**创建GUID**工具（**工具** -> **创建GUID**）。GUID需要放置如下截图所示：
- en: '![](img/B19820_21_09.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_09.png)'
- en: 'Figure 21.9: SonarCloud project GUID'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.9：SonarCloud项目GUID
- en: 'As soon as you finish the build, the result of the code analysis will be presented
    in SonarCloud, as can be seen in the following screenshot. If you want to navigate
    to this project, you can visit [https://sonarcloud.io/summary/overall?id=gabrielbaptista_wwtravelclub-4th](https://sonarcloud.io/summary/overall?id=gabrielbaptista_wwtravelclub-4th):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成构建，代码分析的结果将在SonarCloud中展示，如下面的截图所示。如果您想导航到该项目，可以访问[https://sonarcloud.io/summary/overall?id=gabrielbaptista_wwtravelclub-4th](https://sonarcloud.io/summary/overall?id=gabrielbaptista_wwtravelclub-4th)：
- en: '![Tela de computador com jogo  Descrição gerada automaticamente](img/B19820_21_10.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕上显示游戏，自动生成的描述](img/B19820_21_10.png)'
- en: 'Figure 21.10: SonarCloud results'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.10：SonarCloud结果
- en: Also, by this time, the code analyzed is not yet in the release, so this can
    be useful for getting the next step of quality before releasing your system. You
    can use this approach as a reference for automating code analysis during committal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，到这个时候，所分析的代码尚未发布，因此这可以在发布系统之前获取下一阶段的质量。您可以将这种方法作为在提交代码时自动进行代码分析的参考。
- en: Considering we have implemented a way to continuously evaluate code quality,
    it is time to design reusable software. Let’s look at this in the next section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们已经实现了一种持续评估代码质量的方法，现在是时候设计可重用软件了。让我们在下一节中看看这个问题。
- en: Reusing code as a fast way to deliver good and safe software
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码重用作为快速交付良好且安全软件的方法
- en: 'As we checked in *Chapter 5, Implementing Code Reusability in C# 12*, a good
    approach for accelerating the delivery of good software is creating reusable components.
    The final design of the solution for evaluating content for WWTravelClub can be
    checked in the diagram below. This approach consists of using many topics that
    were discussed in that chapter. First, all the code is placed in a .NET 8 class
    library. This means that you can add this code to different types of solutions,
    such as ASP.NET Core web apps and Xamarin apps for the Android and iOS platforms:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在第5章，第12节“在C#中实现代码重用”中检查的那样，加速优质软件交付的一个好方法是创建可重用组件。下面图中可以查看为评估WWTravelClub内容而设计的最终解决方案。这种方法包括使用本章讨论的许多主题。首先，所有代码都放置在一个.NET
    8类库中。这意味着你可以将此代码添加到不同类型的解决方案中，例如ASP.NET Core Web应用和Android和iOS平台的Xamarin应用：
- en: '![Diagrama  Descrição gerada automaticamente](img/B19820_21_11.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的描述图](img/B19820_21_11.png)'
- en: 'Figure 21.11: WWTravelClub reuse approach'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.11：WWTravelClub重用方法
- en: This design makes use of object-oriented principles such as inheritance, so
    you do not need to write properties and methods more than once that can be used
    in many classes. The design also makes use of the polymorphism principle so that
    you can change the behavior of the code without changing the name of the method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '此设计利用了面向对象原则，如继承，因此你不需要在许多类中多次编写可以重复使用的属性和方法。设计还利用了多态原则，这样你可以在不更改方法名称的情况下更改代码的行为。 '
- en: To finish, the design abstracts the idea of the content by introducing generics
    as a tool that can facilitate the manipulation of similar classes, such as the
    ones we have in WWTravelClub, to evaluate content regarding cities, comments,
    destination experts, and travel packages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设计通过引入泛型作为工具来抽象内容的概念，以简化类似WWTravelClub中存在的类似类的操作，以评估有关城市、评论、目的地专家和旅行套餐的内容。
- en: The big difference between a team that incentivizes code reuse and one that
    does not is the velocity of delivering good software to end users. Of course,
    beginning this approach is not easy, but rest assured that you will get good results
    after some time working with it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励代码重用的团队与不鼓励的团队之间的主要区别是向最终用户提供优质软件的速度。当然，开始这种方法并不容易，但请放心，经过一段时间的工作后，你将获得良好的结果。
- en: Since we have covered the possibilities of code reuse using object-oriented
    principles, what about organizing the application using domains created by **domain-driven
    design** (**DDD**)? We will check it in the next section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了使用面向对象原则实现代码重用的可能性，那么我们再来看看使用由**领域驱动设计**（**DDD**）创建的领域来组织应用程序如何？我们将在下一节中检查。
- en: Understanding the domains of the WWTravelClub application
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解WWTravelClub应用程序的领域
- en: In this section we will perform the DDD analysis of the WWTravelClub system,
    trying to identify all its domains (also called **bounded contexts**), that is,
    the subsystems characterized by different languages used by the experts. Once
    identified, each domain might be assigned to a different development team and
    will give rise to a different microservice.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对WWTravelClub系统进行DDD分析，试图识别所有其领域（也称为**边界上下文**），即由专家使用不同语言定义的子系统。一旦识别出来，每个领域可能被分配给不同的开发团队，并产生不同的微服务。
- en: 'From the requirements listed in the *Introducing World Wild Travel Club* and
    *U**ser needs and system requirements* sections, we know that the WWTravelClub
    system is composed of the following parts:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从*介绍世界野生旅行俱乐部*和*用户需求和系统需求*部分列出的需求中，我们知道WWTravelClub系统由以下部分组成：
- en: Information about the available destinations and packages.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用目的地和套餐的信息。
- en: Reservation/purchase orders subsystem.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预订/购买订单子系统。
- en: Communication with the experts/review subsystem.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与专家/审查子系统的通信。
- en: Payment subsystem. We briefly analyzed the features of this subsystem and its
    relationship with the reservation purchase subsystem at the beginning of *Chapter
    7*, in the *Understanding DDD* section.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付子系统。我们在第7章开头，在*理解DDD*部分简要分析了该子系统的功能和它与预订购买子系统的关系。
- en: User accounts subsystem.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户账户子系统。
- en: Statistics reporting subsystem.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计报告子系统。
- en: 'Do the preceding subsystems represent different bounded contexts? Can some
    subsystems be split into different bounded contexts? The answers to these questions
    are given by the languages that are spoken in each subsystem:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的子系统代表不同的有界上下文吗？某些子系统可以被分割成不同的有界上下文吗？这些问题的答案由每个子系统使用的语言给出：
- en: The language that’s spoken in subsystem 1 is the language of **travel agencies**.
    There is no concept of a customer, just of locations, packages, and their features.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统1使用的语言是**旅行社**的语言。这里没有客户的概念，只有地点、套餐及其特点。
- en: The language that’s spoken in subsystem 2 is common to all service purchases,
    such as the available resources, reservations, and purchase orders. This is a
    separate bounded context.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统2使用的语言是所有服务购买中共同的，例如可用的资源、预订和采购订单。这是一个独立的有界上下文。
- en: 'The language that’s spoken in subsystem 3 has a lot in common with subsystem
    1’s language. However, there are also typical **social media** concepts, such
    as ratings, chats, post sharing, media sharing, and so on. This subsystem can
    be split into two parts: a social media subsystem that has a new Bounded Context
    and an available information subsystem that is part of the Bounded Context of
    subsystem 1.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统3使用的语言与子系统1的语言有很多共同之处。然而，也存在典型的**社交媒体**概念，如评分、聊天、帖子分享、媒体分享等。这个子系统可以分为两部分：一个拥有新有界上下文的社交媒体子系统和一个属于子系统1有界上下文的一部分的可用信息子系统。
- en: As we pointed out in the *Understanding DDD* section in *Chapter 7*, in subsystem
    4, we speak the language of **banking**. This subsystem communicates with the
    reservation purchase subsystem and executes tasks that are needed to carry out
    a purchase. From these observations, we can see that it is a different Bounded
    Context and has a customer/supplier relationship with the purchase/reservation
    system.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在第7章的*理解DDD*部分所指出的，在子系统4中，我们使用的是**银行**的语言。这个子系统与预订/采购子系统通信并执行执行购买所需的任务。从这些观察中，我们可以看出它是一个不同的有界上下文，并且与购买/预订系统有客户/供应商关系。
- en: Subsystem 5 is a separate Bounded Context (as in almost all web applications).
    It has a relationship with all the bounded contexts that have either the concept
    of a user or the concept of a customer because the concept of user accounts always
    maps to these concepts. You must be wondering how. Well, it’s quite simple—the
    currently logged-in user is assumed to be the social media user of the social
    media bounded context, the customer of the reservation/purchase bounded context,
    and the payer of the payment Bounded Context.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统5是一个独立的有界上下文（就像几乎所有的Web应用一样）。它与所有具有用户或客户概念的有界上下文有关，因为用户账户的概念总是映射到这些概念上。你可能想知道这是如何实现的。好吧，这很简单——当前登录的用户被认为是社交媒体有界上下文的社会媒体用户、预订/采购有界上下文的客户以及支付有界上下文的付款人。
- en: The query-only subsystem (that is, 6) speaks the language of analytics and statistics
    and differs a lot from the languages that are spoken in the other subsystems.
    However, it has a connection with almost all the bounded contexts since it takes
    all its input from them. The preceding constraints force us to adopt CQRS in its
    strong form, thereby considering it a query-only separated Bounded Context.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅查询的子系统（即6号）使用的是分析和统计的语言，与其他子系统的语言有很大不同。然而，它几乎与所有有界上下文都有联系，因为它从它们那里获取所有输入。前面的约束迫使我们采用强CQRS形式，因此将其视为仅查询分离的有界上下文。
- en: In conclusion, each of the listed subsystems defines a different Bounded Context,
    but part of the communication with the experts/review subsystem must be included
    in the information about the available destinations, and the package’s Bounded
    Context.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，列出的每个子系统定义了一个不同的有界上下文，但与专家/审查子系统通信的部分必须包含在可用的目的地信息以及套餐的有界上下文中。
- en: As the analysis continues and a prototype is implemented, some bounded contexts
    may split and some others may be added, but it is fundamental to immediately start
    modeling the system and to immediately start analyzing the relationships among
    the bounded contexts with the partial information we have since this will drive
    further investigations and will help us define the communication protocols and
    ubiquitous languages that are needed so that we can interact with the domain experts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分析的继续和原型的实现，一些边界上下文可能会分裂，而另一些可能会被添加，但立即开始建模系统并立即开始分析边界上下文之间的关系是至关重要的，因为我们所拥有的部分信息将推动进一步的调查，并帮助我们定义所需的通信协议和通用语言，以便我们可以与领域专家互动。
- en: 'The following is a basic first sketch of the domain map:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对领域映射的基本初步草图：
- en: '![](img/B19820_21_12.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_21_12.png)'
- en: 'Figure 21.12: WWTravelClub domain map. Thin black arrows represent data exchanged
    between bounded contexts, while thick blue arrows represent the relationships
    between bounded contexts (conformist, customer/supplier, and so on)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.12：WWTravelClub领域映射图。细黑箭头表示边界上下文之间的数据交换，而粗蓝箭头表示边界上下文之间的关系（从众者、客户/供应商等）
- en: For simplicity, we’ve omitted the **Statistics reporting** bounded context.
    We say just that it collects statistics on the daily purchases of each package.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们省略了**统计报告**边界上下文。我们只是说它收集每个包每日购买的统计数据。
- en: Here, we’re assuming that the **User accounts** and **Social** bounded contexts
    have a **conformist** relationship with all the other counded contexts that communicate
    with them because they are implemented with already existing software, so all
    the other components must adapt to them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设**用户账户**和**社交**边界上下文与所有与之通信的其他边界上下文具有**从众者**关系，因为它们使用现有的软件实现，所以所有其他组件必须适应它们。
- en: As we mentioned previously, the relationship between **Reservation** and **Payments**
    is **customer/supplier** because **Payments** provides services that are used
    to execute the tasks of **Reservation**. All the other relationships are classified
    as **partners**. The various concepts of customer/user that most bounded contexts
    have are coordinated by the **User accounts** **Authorization token** arrow, which
    indirectly takes care of mapping these concepts between all the counded contexts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，**预订**和**支付**之间的关系是**客户/供应商**，因为**支付**提供用于执行**预订**任务的服务。所有其他关系都被归类为**合作伙伴**。大多数边界上下文都有的客户/用户的各种概念由**用户账户**的**授权令牌**箭头协调，它间接地负责在所有边界上下文之间映射这些概念。
- en: 'The **Packages/locations** subsystem communicates the following information
    to **Reservation**:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**包/位置**子系统向**预订**子系统传达以下信息：'
- en: '**Chosen package info**, which contains the package information that’s needed
    to carry out a reservation/purchase'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择的包信息**，包含执行预订/购买所需的包信息'
- en: '**Price changes**, which takes care of informing pending purchase orders of
    possible price changes'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**价格变动**，负责通知待处理的购买订单可能的定价变动'
- en: Social interactions are started from an existing review provided by users (the
    **Reviews** arrow between **Packages/locations** and **Social**) and are supported
    by **Location/review info** communications from **Packages/locations** to **Social**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 社交互动始于用户提供的现有评论（**包/位置**和**社交**之间的**评论**箭头）并由**包/位置**到**社交**的**位置/评论信息**通信支持。
- en: Finally, **Reservation** communicates purchase codes, descriptions, and prices
    to **Payments** through the **Prices/codes/descriptions** arrow.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**预订**通过**价格/代码/描述**箭头将购买代码、描述和价格传达给**支付**。
- en: Having identified our application’s bounded contexts, we are in a position to
    organize the application DevOps cycle.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了我们的应用程序的边界上下文后，我们处于组织应用程序DevOps周期的位置。
- en: The WWTravelClub DevOps approach
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WWTravelClub的DevOps方法
- en: During *Chapter 8, Understanding DevOps Principles and CI/CD*, screenshots from
    the WWTravelClub project showed the steps needed to implement a good DevOps cycle.
    The WWTravelClub team has decided to use Azure DevOps because they understand
    that the tool is essential for getting the best DevOps experience for the whole
    cycle. In fact, it appears the most complete of the tools offered by GitHub, since
    it covers the whole CI/CD cycle from requirements collection to deployment in
    staging and production. Moreover, all team members already know it very well.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章，理解DevOps原则和CI/CD*中，WWTravelClub项目的截图展示了实施良好DevOps周期所需的步骤。WWTravelClub团队决定使用Azure
    DevOps，因为他们明白这个工具对于在整个周期中获得最佳的DevOps体验至关重要。实际上，它似乎是GitHub提供的工具中最完整的，因为它涵盖了从需求收集到在预生产和生产部署的整个CI/CD周期。此外，所有团队成员都已经非常熟悉它。
- en: The requirements were written using user stories, which can be found in the
    **Work items** section of Azure DevOps. The code is placed in the repository of
    the Azure DevOps project. Both concepts were explained in *Chapter 3*, *Managing
    Requirements*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 需求是用用户故事编写的，可以在Azure DevOps的**工作项**部分找到。代码放置在Azure DevOps项目的仓库中。这两个概念在*第3章，管理需求*中都有解释。
- en: The management life cycle used for getting things done is Scrum, presented in
    *Chapter 1*, *Understanding the Importance of Software Architecture*. This approach
    divides the implementation into sprints, which forces value to be delivered by
    the end of each cycle. Using the CI facilities we learned in this chapter, code
    will be compiled each time the team merges new code into the master branch of
    the repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用于完成工作的管理生命周期是Scrum，在第1章*理解软件架构的重要性*中介绍。这种方法将实施分为冲刺，这迫使每个周期结束时交付价值。使用我们在本章中学到的CI设施，每次团队将新代码合并到仓库的master分支时，代码都会被编译。
- en: Once the code is compiled and tested, the first stage of the deployment is done.
    The first stage is normally named development/test because you enable it for internal
    tests. Both Application Insights and Test and Feedback can be used to get the
    first feedback on the new release.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码编译并测试，部署的第一阶段就完成了。第一阶段通常被称为开发/测试，因为你是为了内部测试而启用它的。Application Insights和测试与反馈都可以用来获取对新版本的第一反馈。
- en: If the tests and the feedback of the new release pass, it is time to go to the
    second stage, quality assurance. Application Insights and Test and Feedback can
    be used again, but now in a more stable environment.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新版本的测试和反馈通过，那么就是时候进入第二阶段，即质量保证。Application Insights和测试与反馈可以再次使用，但现在是在一个更稳定的环境中。
- en: The cycle ends with the authorization to deploy in the production stage. This
    certainly is a tough decision, but DevOps indicates that you must do it continuously
    so you can get better feedback from customers. Application Insights keeps being
    a useful tool since you can monitor the evolution of the new release in production,
    even comparing it to past releases.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 循环以在生产阶段部署的授权结束。这当然是一个艰难的决定，但DevOps表明你必须持续这样做，以便你能从客户那里获得更好的反馈。Application Insights仍然是一个有用的工具，因为你可以在生产中监控新版本的演变，甚至将其与过去的版本进行比较。
- en: The WWTravelClub project approach described here can be used in many other modern
    application development life cycles. As a software architect, you must oversee
    the process. The tools are ready to go, and it depends on you to make things right!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的WWTravelClub项目方法可以用于许多其他现代应用开发生命周期。作为一名软件架构师，你必须监督这个过程。工具已经准备好了，而正确地使用它们取决于你！
- en: 'For this reason, even considering WWTravelClub as a hypothetical scenario,
    some concerns were considered while building it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使将WWTravelClub视为一个假设场景，在构建它时也考虑了一些担忧：
- en: CI is enabled, but a multi-stage scenario is enabled too.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI已启用，但多阶段场景也已启用。
- en: Even with a multi-stage scenario, the **PR** (**Pull Request**) is a way to
    guarantee that only good-quality code will be presented in the first stage.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是多阶段场景，**PR（Pull Request**）也是一种保证在第一阶段只展示高质量代码的方式。
- en: To do a good job in the PR, peer reviews are undertaken.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在PR（Pull Request）中做好工作，需要进行同行评审。
- en: The peer reviews check, for instance, the presence of a feature flag while creating
    a new feature.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同行评审检查，例如，在创建新功能时是否存在功能标志。
- en: The peer reviews check both unit and functional tests developed during the creation
    of the new feature.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同行评审检查了在创建新功能过程中开发的单元测试和功能测试。
- en: The preceding steps are not exclusively for WWTravelClub. You, as a software
    architect, will need to define the approach to guarantee a safe CI/CD scenario.
    You may use this as a starting point. It is worth pointing out that both in Azure
    DevOps and GitHub, we can completely disable pushing on the master branch, thus
    forcing the usage of PR for merging modifications on the master branch.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤不仅适用于WWTravelClub。作为软件架构师，您需要定义保证安全CI/CD场景的方法。您可以以此作为起点。值得注意的是，在Azure DevOps和GitHub中，我们可以完全禁用对master分支的推送，从而强制使用PR来合并master分支上的修改。
- en: In the next section, we will start with the actual code, by showing how to choose
    among various data storage options.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从实际代码开始，展示如何从各种数据存储选项中进行选择。
- en: How to choose your data storage in the cloud
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在云中选择您的数据存储
- en: 'In *Chapter 12*, *Choosing Your Data Storage in the Cloud,* we learned how
    to use NoSQL. Now we must decide whether NoSQL databases are adequate for our
    book use case WWTravelClub application. We need to store the following families
    of data:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第12章**，*选择云中的数据存储*中，我们学习了如何使用NoSQL。现在我们必须决定NoSQL数据库是否足够用于我们的书籍用例WWTravelClub应用。我们需要存储以下数据家族：
- en: '**Information about available destinations and packages**: Relevant operations
    for these data are reads since packages and destinations do not change very often.
    However, they must be accessed as fast as possible from all over the world to
    ensure a pleasant user experience when users browse the available options. Therefore,
    a distributed relational database with geographically distributed replicas is
    possible but not necessary since packages can be stored inside their destinations
    in a cheaper NoSQL database.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于可用目的地和包的信息**：这些数据的相关操作主要是读取，因为包和目的地不经常改变。然而，它们必须尽可能快地从世界各地访问，以确保用户浏览可用选项时的良好用户体验。因此，一个具有地理分布副本的分布式关系数据库是可能的，但不是必要的，因为包可以存储在其目的地中，使用更便宜的NoSQL数据库。'
- en: '**Destination reviews**: In this case, distributed write operations have a
    non-negligible impact. Moreover, most writes are additions since reviews are not
    usually updated. Additions benefit a lot from sharding and do not cause consistency
    issues like updates do. Accordingly, the best option for this data is a NoSQL
    collection.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地评论**：在这种情况下，分布式写入操作有不可忽视的影响。此外，大多数写入都是添加，因为评论通常不会被更新。添加操作从分片中受益很大，并且不会像更新那样引起一致性问题。因此，此数据最佳选项是一个NoSQL集合。'
- en: '**Reservations**: In this case, consistency errors are not acceptable because
    they may cause overbooking. Reads and writes have a comparable impact, but we
    need reliable transactions and good consistency checks. Luckily, data can be organized
    in a multi-tenant database where tenants are destinations since reservation information
    belonging to different destinations is completely unrelated. Accordingly, we may
    use sharded Azure SQL Database instances.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订**：在这种情况下，一致性错误是不可接受的，因为它们可能导致超订。读取和写入有相似的影响，但我们需要可靠的交易和良好的一致性检查。幸运的是，数据可以组织在一个多租户数据库中，其中租户是目的地，因为不同目的地的预订信息完全无关。因此，我们可以使用分片Azure
    SQL数据库实例。'
- en: In conclusion, the best option for data in the first and second bullet points
    is Cosmos DB, while the best option for the third point is Azure SQL Server. Actual
    applications may require a more detailed analysis of all data operations and their
    frequencies. In some cases, it is worth implementing prototypes for various possible
    options and executing performance tests with typical workloads on all of them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于第一和第二点中的数据，最佳选项是Cosmos DB，而对于第三点，最佳选项是Azure SQL Server。实际应用可能需要对所有数据操作及其频率进行更详细的分析。在某些情况下，为各种可能的选项实现原型并进行典型工作负载的性能测试是值得的。
- en: In the remainder of this section, we will migrate the destinations/packages
    data layer we looked at in *Chapter 13*, *Interacting with Data in C# – Entity
    Framework Core*, to Cosmos DB.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将迁移我们在**第13章**，*使用C#与数据交互 – Entity Framework Core*中查看的 destinations/packages
    数据层到Cosmos DB。
- en: Implementing the destinations/packages database with Cosmos DB
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Cosmos DB实现目的地/包数据库
- en: 'Let’s move on to the database example we built in *Chapter 13*, *Interacting
    with Data in C# – Entity Framework Core*, and implement this database with Cosmos
    DB by following these steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到我们在**第13章**，*使用C#与数据交互 – Entity Framework Core*中构建的数据库示例，并按照以下步骤使用Cosmos
    DB实现此数据库：
- en: First, we need to make a copy of the WWTravelClubDB project and rename its root
    folder as `WWTravelClubDBCosmo`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要复制 WWTravelClubDB 项目并重命名其根文件夹为 `WWTravelClubDBCosmo`。
- en: Open the project and delete the `Migrations` folder since migrations are not
    required anymore.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目并删除 `Migrations` 文件夹，因为不再需要迁移。
- en: We need to replace the SQL Server Entity Framework provider with the Cosmos
    DB provider. To do this, go to **Manage NuGet Packages** and uninstall the `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet package. Then, install the `Microsoft.EntityFrameworkCore.Cosmos` NuGet
    package.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将 SQL Server Entity Framework 提供程序替换为 Cosmos DB 提供程序。为此，请转到 **管理 NuGet 包**
    并卸载 `Microsoft.EntityFrameworkCore.SqlServer` NuGet 包。然后，安装 `Microsoft.EntityFrameworkCore.Cosmos`
    NuGet 包。
- en: 'Then, do the following on the `Destination` and `Package` entities:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对 `Destination` 和 `Package` 实体执行以下操作：
- en: Remove all data annotations.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除所有数据注释。
- en: Add the `[Key]` attribute to their `Id` properties since this is obligatory
    for Cosmos DB providers.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是 Cosmos DB 提供程序所必需的，因此需要将它们的 `Id` 属性添加 `[Key]` 属性。
- en: Transform the type of the `Id` properties of both `Package` and `Destination`
    and the `PackagesListDTO` classes from `int` to `string`. We also need to turn
    the `DestinationId` external references in `Package` and in the `PackagesListDTO`
    classes into `string`. In fact, the best option for keys in distributed databases
    is a string generated from a GUID, because it is hard to maintain an identity
    counter when table data is distributed among several servers.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Package` 和 `Destination` 以及 `PackagesListDTO` 类的 `Id` 属性类型从 `int` 转换为 `string`。我们还需要将
    `Package` 和 `PackagesListDTO` 类中的 `DestinationId` 外部引用转换为 `string`。实际上，对于分布式数据库中的键，最佳选择是从
    GUID 生成的字符串，因为当表数据分布在多个服务器之间时，维护身份计数器很难。
- en: 'In the `MainDBContext` file, we need to specify that packages related to a
    destination must be stored inside the destination document itself. This can be
    achieved by replacing the **Destination-Package** relation configuration in the
    `OnModelCreating` method with the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainDBContext` 文件中，我们需要指定与目的地相关的包必须存储在目的地文档本身内。这可以通过在 `OnModelCreating` 方法中替换
    **Destination-Package** 关系配置来实现以下代码：
- en: '[PRE0]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we must replace `HasMany` with `OwnsMany`. There is no equivalent to `WithOne`
    since once an entity is owned, it must have just one owner, and the fact that
    the `MyDestination` property contains a pointer to the father entity is evident
    from its type. Cosmos DB also allows the use of `HasMany`, but in this case, the
    two entities are not nested one in the other. There is also an `OwnOne` configuration
    method for nesting single entities inside other entities.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们必须将 `HasMany` 替换为 `OwnsMany`。没有 `WithOne` 的等效项，因为一旦实体被拥有，它必须只有一个所有者，并且
    `MyDestination` 属性包含对父实体的指针的事实可以从其类型中明显看出。Cosmos DB 也允许使用 `HasMany`，但在这个情况下，两个实体不是嵌套在一起的。还有一个
    `OwnOne` 配置方法用于在实体内部嵌套单个实体。
- en: Both `OwnsMany` and `OwnsOne` are available for relational databases, but in
    this case, the difference between `HasMany` and `HasOne` is that children entities
    are automatically included in all queries that return their father entities, with
    no need to specify an `Include` LINQ clause. However, child entities are still
    stored in separate tables.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关系数据库中，`OwnsMany` 和 `OwnsOne` 都是可用的，但在这个情况下，`HasMany` 和 `HasOne` 的区别在于子实体会自动包含在返回其父实体的所有查询中，无需指定一个
    `Include` LINQ 子句。然而，子实体仍然存储在单独的表中。
- en: '`LibraryDesignTimeDbContextFactory` must be modified to use Cosmos DB connection
    data, as shown in the following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LibraryDesignTimeDbContextFactory` 必须修改为使用 Cosmos DB 连接数据，如下面的代码所示：'
- en: '[PRE1]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, in our test console, we must explicitly create all entity principal
    keys using GUIDs:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的测试控制台中，我们必须显式地使用 GUID 创建所有实体主键：
- en: '[PRE2]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we call `context.Database.EnsureCreated()` instead of applying migrations
    since we only need to create the database. Once the database and collections have
    been created, we can fine-tune their settings from the Azure portal. Hopefully,
    future versions of the Cosmos DB Entity Framework Core provider will allow us
    to specify all collection options.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们调用 `context.Database.EnsureCreated()` 而不是应用迁移，因为我们只需要创建数据库。一旦数据库和集合创建完成，我们就可以从
    Azure 门户调整它们的设置。希望 Cosmos DB Entity Framework Core 提供程序的将来版本将允许我们指定所有集合选项。
- en: 'Finally, the final query (which starts with `context.Packages.Where...`) must
    be modified since queries can’t start with entities that are nested in other documents
    (in our case, `Packages` entities). Therefore, we must start our query from the
    unique root `DbSet<T>` property we have in our `DBContext`, that is, `Destinations`.
    We can move from listing the external collection to listing all the internal collections
    with the help of the `SelectMany` method, which performs a logical merge of all
    nested `Packages` collections. However, since Cosmos DB SQL doesn’t support `SelectMany`,
    we must force `SelectMany` to be simulated on the client with `AsEnumerable()`,
    as shown in the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，必须修改最终的查询（以 `context.Packages.Where...` 开始），因为查询不能以嵌套在其他文档中的实体（在我们的情况下，`Packages`
    实体）开头。因此，我们必须从我们的 `DBContext` 中具有唯一根 `DbSet<T>` 属性开始我们的查询，即 `Destinations`。我们可以借助
    `SelectMany` 方法从列出外部集合转换为列出所有内部集合，该方法执行所有嵌套 `Packages` 集合的逻辑合并。然而，由于 Cosmos DB
    SQL 不支持 `SelectMany`，我们必须使用 `AsEnumerable()` 在客户端强制模拟 `SelectMany`，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The remainder of the query remains unchanged. If you run the project now, you
    should see the same outputs that were received in the case of SQL Server (except
    for the primary key values).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询的其余部分保持不变。如果您现在运行项目，应该看到与 SQL Server 的情况相同的输出（除了主键值）。
- en: 'After executing the program, go to your Cosmos DB account. You should see something
    like the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序后，转到您的 Cosmos DB 账户。您应该看到如下内容：
- en: '![A picture containing table  Description automatically generated](img/B19820_21_13.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![包含表格描述的图片自动生成](img/B19820_21_13.png)'
- en: 'Figure 21.13: Execution results'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.13：执行结果
- en: The packages have been nested inside their destinations as required and Entity
    Framework Core creates a unique collection that has the same name as the `DBContext`
    class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 包已经按照要求嵌套在其目的地中，并且 Entity Framework Core 创建了一个与 `DBContext` 类同名的唯一集合。
- en: 'If you would like to continue experimenting with Cosmos DB development without
    wasting all your free Azure portal credit, you can install the Cosmos DB emulator,
    available at this link: [https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不用完所有免费的 Azure 门户信用额度的情况下继续进行 Cosmos DB 开发实验，你可以安装 Cosmos DB 模拟器，该模拟器可在以下链接中找到：[https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator)。
- en: Having learned how to choose the best options for data storage, we are in a
    position to start coding our first microservice.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何选择最佳数据存储选项之后，我们就可以开始编写我们的第一个微服务了。
- en: A worker microservice with ASP.NET Core
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个基于 ASP.NET Core 的工作微服务
- en: In this section, we will show you how to implement a microservice that receives
    communications through gRPC and an internal queue based on a database table. The
    first subsection briefly describes the microservice specifications and the overall
    architecture. You are encouraged to review *Chapter 14*, *Implementing Microservices
    with .NET,* which contains all the theory behind this example.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何实现一个通过 gRPC 和基于数据库表的内部队列接收通信的微服务。第一个小节简要描述了微服务的规范和整体架构。我们鼓励您回顾
    *第 14 章*，*使用 .NET 实现微服务*，其中包含本例背后的所有理论。
- en: The specifications and architecture
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范和架构
- en: Our example microservice is required to compute the daily sums of all purchases.
    According to the data-driven approach, we suppose that all daily sums are pre-computed
    by receiving messages that are sent as soon as a new purchase is finalized. The
    purpose of the microservice is to maintain a database of all purchases and all
    daily sums that can be queried by an administrative user. We will implement just
    the functionalities needed to fill the two database tables.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例微服务需要计算所有购买活动的每日总和。根据数据驱动方法，我们假设所有每日总和都是通过接收新购买活动完成时立即发送的消息预先计算的。微服务的目的是维护一个所有购买活动和所有每日总和的数据库，这些数据可以被管理员用户查询。我们将仅实现填充两个数据库表所需的功能。
- en: The implementation described in this section is based on an ASP.NET Core application
    that hosts a gRPC service. The gRPC service simply fills a messages queue and
    immediately returns to avoid the sender remaining blocked for the whole time of
    the computation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的实现基于一个托管 gRPC 服务的 ASP.NET Core 应用程序。gRPC 服务简单地填充一个消息队列并立即返回，以避免发送者在整个计算过程中被阻塞。
- en: The actual processing is performed by an ASP.NET Core-hosted service declared
    in the dependency injection engine associated with the application host. The worker-hosted
    service executes an endless loop where it extracts `N` messages from the queue
    and passes them to `N` parallel threads that process them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的处理是由与应用程序宿主关联的依赖注入引擎中声明的 ASP.NET Core 托管服务执行的。工作宿主服务执行一个无限循环，从中提取 `N` 条消息并传递给
    `N` 个并行线程进行处理。
- en: '![](img/B19820_21_14.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_21_14.png)'
- en: 'Figure 21.14: gRPC microservice architecture'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.14：gRPC 微服务架构
- en: When the `N` messages are taken from the queue, they are not immediately removed
    but are simply marked with the extraction time. Since messages can only be extracted
    from the queue if their last extraction time is far enough ahead (say, a time
    `T`), no other worker thread can extract them again while they are being processed.
    When message processing is successfully completed, the message is removed from
    the queue. If the processing fails, no action is taken on the message, so the
    message remains blocked in the queue till the `T` interval expires, and then it
    can be picked up again by the worker thread.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当从队列中取出 `N` 条消息时，它们不会立即被删除，而是简单地标记为提取时间。由于只有在消息的最后提取时间足够远（比如说，时间 `T`）时才能从队列中提取消息，因此在处理期间，没有其他工作线程可以再次提取它们。当消息处理成功完成后，消息将从队列中删除。如果处理失败，则不对消息采取任何操作，因此消息将保持在队列中，直到
    `T` 间隔过期，然后可以被工作线程再次取走。
- en: The microservice can be scaled vertically by increasing the processor cores
    and the number `N` of threads. It can be scaled horizontally, too, by using a
    load balancer that splits the loads into several identical copies of the ASP.NET
    Core application. This kind of horizontal scaling increases the number of threads
    that can receive messages and the number of worker threads, but since all ASP.NET
    Core applications share the same database, it is limited by database performance.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以通过增加处理器核心和线程数 `N` 来垂直扩展。它也可以通过使用负载均衡器来水平扩展，将负载分割成几个相同的 ASP.NET Core 应用程序副本。这种类型的水平扩展增加了可以接收消息的线程数和工作线程数，但由于所有
    ASP.NET Core 应用程序共享同一个数据库，因此它受限于数据库性能。
- en: The database layer is implemented in a separate **DLL** (**Dynamic Link Library)**
    and all functionalities are abstracted in two interfaces, one for interacting
    with the queue and another for adding a new purchase to the database.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库层是在一个单独的 **DLL**（**动态链接库**）中实现的，所有功能都抽象在两个接口中，一个用于与队列交互，另一个用于将新的购买记录添加到数据库中。
- en: The next subsection briefly describes the database layer. We will not give all
    the details since the main focus of the example is the microservice architecture
    and the communication technique. However, the full code is available in the `ch15/GrpcMicroService`
    folder of the GitHub repository associated with the book.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节简要描述了数据库层。由于示例的主要重点是微服务架构和通信技术，我们不会给出所有细节。然而，完整的代码可以在与本书相关的 GitHub 仓库的
    `ch15/GrpcMicroService` 文件夹中找到。
- en: Having defined the overall architecture, let’s start with the storage layer
    code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了整体架构之后，让我们从存储层代码开始。
- en: The storage layer
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储层
- en: 'The storage layer is based on a database. It uses Entity Framework Core and
    is based on three entities with their associated tables:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 存储层基于数据库。它使用 Entity Framework Core，并基于三个实体及其关联的表：
- en: A `QueueItem` entity that represents a queue item
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示队列项的 `QueueItem` 实体
- en: A `Purchase` entity that represents a single purchase
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示单个购买的 `Purchase` 实体
- en: A `DayTotal` entity that represents the total of all purchases performed in
    a given day
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示给定一天内所有购买总额的 `DayTotal` 实体
- en: 'Below is a definition of the interface that manipulates the queue:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对操作队列的接口定义：
- en: '[PRE4]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Top` extracts the `N` messages to pass to a maximum of `N` different threads.
    `Enqueue` adds a new message to the queue. Finally, `Dequeue` removes the items
    that have been successfully processed from the queue.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Top` 从队列中提取 `N` 条消息以传递给最多 `N` 个不同的线程。`Enqueue` 向队列中添加一条新消息。最后，`Dequeue` 从队列中移除已成功处理的项目。'
- en: 'The interface that updates the purchase data is defined as shown below:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 更新购买数据的接口定义如下所示：
- en: '[PRE5]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Add` adds a new purchase to the database. It returns the input queue item
    if the addition is successful, and `null` otherwise. `DayTotal` is a query method
    that returns a single day total.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add` 向数据库添加一条新的购买记录。如果添加成功，则返回输入队列项，否则返回 `null`。`DayTotal` 是一个查询方法，返回单日总额。'
- en: 'The application layer communicates with the database layer through these two
    interfaces, through the three database entities, through the `IUnitOfWork` interface
    (which, as explained in the *How data and domain layers communicate with other
    layers* section of *Chapter 13*, *Interacting with Data in C# – Entity Framework
    Core* abstracts the `DbContext`), and through a dependency injection extension
    method like the one below:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层通过这两个接口与数据库层进行通信，通过三个数据库实体，通过 `IUnitOfWork` 接口（正如在第 13 章的 *如何数据层和领域层与其他层通信*
    部分中解释的，*在 C# 中与数据交互 – Entity Framework Core* 抽象了 `DbContext`），以及通过如下类似的依赖注入扩展方法：
- en: '[PRE6]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method, which will be called in the application layer dependency injection
    definition, receives as input the database connection string and adds the `DbContext`
    abstracted with `IUnitOfWork`, with the two interfaces we defined before.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将在应用层依赖注入定义中被调用，它接收数据库连接字符串作为输入，并添加我们之前定义的两个接口抽象化的 `DbContext`。
- en: 'The database project, called `GrpcMicroServiceStore`, is contained in the `ch15/GrpcMicroService`
    folder of the GitHub repository associated with the book. It already contains
    all the necessary database migrations, so you can create the needed database with
    the steps below:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据库项目，名为 `GrpcMicroServiceStore`，位于与本书相关的 GitHub 仓库的 `ch15/GrpcMicroService`
    文件夹中。它已经包含了所有必要的数据库迁移，因此你可以按照以下步骤创建所需的数据库：
- en: In the Visual Studio **Package Manager Console**, select the **GrpcMicroServiceStore**
    project.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio **包管理器控制台** 中，选择 **GrpcMicroServiceStore** 项目。
- en: In Visual Studio **Solution Explorer**, right-click on the **GrpcMicroServiceStore**
    project and set it as the startup project.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio **解决方案资源管理器** 中，右键单击 **GrpcMicroServiceStore** 项目并将其设置为启动项目。
- en: In the Visual Studio **Package Manager Console**, issue the `Update-Database`
    command.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio **包管理器控制台** 中，执行 `Update-Database` 命令。
- en: Having a working storage layer, we can proceed with the microservices application
    layer.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有一个工作存储层之后，我们可以继续进行微服务应用层的开发。
- en: The application layer
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用层
- en: 'The application layer is an **ASP.NET Core gRPC service** project called `GrpcMicroService`.
    When the project is scaffolded by Visual Studio, it contains a `.proto` file in
    its `Protos` folder. This file needs to be deleted and replaced by a file called
    `counting.proto`, whose content must be as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层是一个名为 `GrpcMicroService` 的 **ASP.NET Core gRPC 服务** 项目。当项目由 Visual Studio
    模板化时，它在其 `Protos` 文件夹中包含一个 `.proto` 文件。需要删除此文件并替换为名为 `counting.proto` 的文件，其内容必须如下：
- en: '[PRE7]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The above code defines the gRPC service with its input and output messages and
    the .NET namespace where you place them. We import the `google/protobuf/timestamp.proto`
    predefined `.proto` file because we need the `TimeStamp` type. The request contains
    purchase data, the `time` when the request message was created, and a unique message
    `id` that is used to force message idempotency.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了带有其输入和输出消息的 gRPC 服务以及放置它们的 .NET 命名空间。我们导入 `google/protobuf/timestamp.proto`
    预定义的 `.proto` 文件，因为我们需要 `TimeStamp` 类型。请求包含购买数据，请求消息创建时的 `time`，以及一个唯一的消息 `id`，该
    `id` 用于强制消息幂等性。
- en: 'In the database layer, the implementation of the `IDayStatistics.Add` method
    uses this `id` to verify if a purchase with the same `id` has already been processed,
    in which case it returns immediately:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库层，`IDayStatistics.Add` 方法的实现使用此 `id` 来验证是否已经处理了具有相同 `id` 的购买，如果是，则立即返回：
- en: '[PRE8]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Automatic code generation for this file is enabled by replacing the existing
    `protobuf` XML tag with:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过替换现有的 `protobuf` XML 标签来启用此文件的自动代码生成：
- en: '[PRE9]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Grpc` attribute set to `"Server"` enables server-side code generation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Grpc` 属性设置为 `"Server"` 启用服务器端代码生成。
- en: 'In the `Services` project folder, the predefined gRPC service scaffolded by
    Visual Studio must be replaced with a file named `CounterService.cs` with the
    content below:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Services` 项目文件夹中，Visual Studio 预定义的 gRPC 服务模板必须替换为名为 `CounterService.cs`
    的文件，其内容如下：
- en: '[PRE10]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The actual service that receives the purchase messages inherits from the `Counter.CounterBase`
    abstract class created by the code generator from the `counting.proto` file. It
    receives the database layer interface `IMessageQueue` using dependency injection
    and overrides the abstract `Count` method inherited from `Counter.CounterBase`.
    Then, `Count` uses `IMessageQueue` to enqueue each received message.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 实际接收购买消息的服务继承自代码生成器从`counting.proto`文件创建的`Counter.CounterBase`抽象类。它通过依赖注入接收数据库层接口`IMessageQueue`，并重写从`Counter.CounterBase`继承的抽象`Count`方法。然后，`Count`使用`IMessageQueue`将每个接收到的消息入队。
- en: 'Before compiling, a few other steps are necessary:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译之前，还需要进行几个其他步骤：
- en: We must add a reference to the database-layer `GrpcMicroServiceStore` project.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须添加对数据库层`GrpcMicroServiceStore`项目的引用。
- en: 'We must add the database connection string to the `appsettings.json` setting
    file:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将数据库连接字符串添加到`appsettings.json`设置文件中：
- en: '[PRE11]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We must add all the necessary database-layer interfaces to the dependency injection
    by calling the `AddStorage` database layer extension method:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须通过调用`AddStorage`数据库层扩展方法将所有必要的数据库层接口添加到依赖注入中：
- en: '[PRE12]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `Program.cs`, we must remove the declaration of the gRPC service scaffolded
    by Visual Studio, and we must replace it with:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，我们必须删除Visual Studio生成的gRPC服务的声明，并将其替换为：
- en: '[PRE13]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, compilation should succeed. Having completed the application-layer
    infrastructure, we can move to the hosted service that performs the actual queue
    processing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，编译应该成功。完成应用层基础设施后，我们可以转向执行实际队列处理的主托管服务。
- en: Processing the queued requests
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理队列中的请求
- en: 'The actual request processing is performed by a worker-hosted service that
    runs in parallel with the ASP.NET Core pipeline. It is implemented with the hosted
    services we discussed in the *Using generic hosts* section of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*. It is worth recalling
    that hosted services are implementations of the `IHostedService` interface defined
    in the dependency injection engine as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实际请求处理由一个与ASP.NET Core管道并行运行的worker-hosted服务执行。它是在第11章的“使用通用宿主”部分中讨论的主托管服务实现的。值得回忆的是，主托管服务是依赖注入引擎中定义的`IHostedService`接口的实现，如下所示：
- en: '[PRE14]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We already described how to implement hosted services for the implementation
    of ASP.NET Core-based worker microservices in the *Implementing worker microservices
    with ASP.NET Core* section of *Chapter 14, Implementing Microservices with .NET*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在《第14章，使用.NET实现微服务》的“使用ASP.NET Core实现工作微服务”部分描述了如何实现基于ASP.NET Core的工作微服务的托管服务。
- en: 'Below, we repeat the whole code with all details that are specific to our example.
    The hosted service is defined in the `ProcessPurchases.cs` file placed in the
    `HostedServices` folder:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，我们重复整个代码，包括我们示例中特有的所有细节。主托管服务定义在`HostedServices`文件夹中的`ProcessPurchases.cs`文件中：
- en: '[PRE15]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Below is the content of the inner loop:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是内部循环的内容：
- en: '[PRE16]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The above code was already explained in the *Implementing worker microservices
    with ASP.NET Core* section of *Chapter 14, Implementing Microservices with .NET*.
    Therefore, here, we will analyze just the `toExecute` lambda that is specific
    to our example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码已在《第14章，使用.NET实现微服务》的“使用ASP.NET Core实现工作微服务”部分中解释过。因此，在这里，我们将仅分析我们示例中特有的`toExecute`
    lambda表达式：
- en: '[PRE17]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each task creates a different session scope so it can have a private copy of
    `IDayStatistics`, and then processes its request with `statistics.Add`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务创建一个不同的会话作用域，以便它可以拥有`IDayStatistics`的私有副本，然后使用`statistics.Add`处理其请求。
- en: That’s all! Now we need a source of purchase data to test our code. In the next
    subsection, we will create a fake microservice that randomly creates purchase
    data and passes it to the `Counter` `gRPC` service.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！现在我们需要一个购买数据的来源来测试我们的代码。在下一小节中，我们将创建一个模拟微服务，该微服务随机生成购买数据并将其传递给`Counter`
    `gRPC`服务。
- en: Testing the GrpcMicroservice project with a fake purchase requests generator
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模拟购买请求生成器测试GrpcMicroservice项目
- en: 'Let’s implement another microservice that feeds the previous microservice with
    randomly generated requests. The right project for a worker service that is not
    based on ASP.NET Core is the **Worker Service** project template. This project
    template automatically scaffolds a host containing a unique hosted service called
    `Worker`. We called this project `FakeSource`. In order to enable gRPC client
    usage, we must add the following NuGet packages: `Google.Protobuf`, `Grpc.NET.Client`,
    and `Grpc.Tools`.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现另一个微服务，该微服务使用随机生成的请求为之前的微服务提供数据。对于不基于 ASP.NET Core 的工作服务，合适的模板是 **Worker
    Service** 项目模板。这个项目模板自动生成一个包含一个唯一托管服务 `Worker` 的宿主。我们把这个项目命名为 `FakeSource`。为了启用
    gRPC 客户端使用，我们必须添加以下 NuGet 包：`Google.Protobuf`、`Grpc.NET.Client` 和 `Grpc.Tools`。
- en: 'Then, we must add the same `counting.proto` file as was added to the previous
    project. However, this time, we must require client code generation by placing
    the code below in the `FakeSource` project file:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须添加与之前项目相同的 `counting.proto` 文件。然而，这次，我们必须在 `FakeSource` 项目文件中放置以下代码以要求客户端代码生成：
- en: '[PRE18]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `GrpcServices` attribute set to `Client` is what enables client code generation
    instead of server code generation. The `link` tag appears since we added the same
    `counting.proto` file of the `GrpcMicroService` project as a link instead of copying
    it into the new project.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `GrpcServices` 属性设置为 `Client` 的操作使得客户端代码生成而不是服务器代码生成成为可能。由于我们将 `GrpcMicroService`
    项目的相同 `counting.proto` 文件作为链接而不是复制到新项目中，因此出现了 `link` 标签。
- en: 'The hosted service is defined with the usual endless loop:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 托管服务是用通常的无尽循环定义的：
- en: '[PRE19]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `locations` array contains locations that will be randomly selected. As
    soon as the `ExecuteAsync` method starts, it creates the `Random` instance that
    will be used in all random generations.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`locations` 数组包含将被随机选择的地点。一旦 `ExecuteAsync` 方法开始执行，它就会创建一个用于所有随机生成的 `Random`
    实例。'
- en: Each loop is enclosed in a `try`/`catch`; if an `OperationCanceledException`
    is generated, the method exits, since a similar exception is created when the
    application is being shut down and the thread is killed. In the case of other
    exceptions, the code tries to recover by simply moving to the next loop. In an
    actual production application, the final `catch` should contain instructions to
    log the intercepted exception and/or instructions for a better recovery strategy.
    In the next example, we will see more sophisticated exception handling that is
    adequate for actual production applications.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个循环都被包含在一个 `try`/`catch` 中；如果生成了 `OperationCanceledException`，则方法退出，因为当应用程序正在关闭且线程被终止时，会创建类似的异常。在遇到其他异常的情况下，代码会尝试通过简单地移动到下一个循环来恢复。在实际的生产应用程序中，最后的
    `catch` 应该包含记录拦截到的异常和/或更好的恢复策略的指令。在下一个示例中，我们将看到更复杂的异常处理，这对于实际的生产应用程序是足够的。
- en: Inside the `try`, the code creates a purchase message, sends it to the `Counter`
    service, and then sleeps for 2 seconds.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `try` 块内部，代码创建一个购买消息，将其发送到 `Counter` 服务，然后休眠 2 秒。
- en: 'Below is the code that sends the requests:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是发送请求的代码：
- en: '[PRE20]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code just prepares the message with random data; then, it creates a communication
    channel for the gRPC server address and passes it to the constructor of the `Counter`
    service proxy. Finally, the `Count` method is called on the proxy. The call is
    enclosed in a `try`/`catch`, and in the case of an error, the error is simply
    ignored, since we are just sending random data. Instead, an actual production
    application should use **Polly** to retry the communication with predefined strategies.
    **Polly** was described in the *Resilient task execution* section of *Chapter
    11*, *Applying a Microservice Architecture to Your Enterprise Application*. We
    will show you how to use **Polly** in the example in the next section.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 代码只是用随机数据准备消息；然后，它为 gRPC 服务器地址创建一个通信通道，并将其传递给 `Counter` 服务代理的构造函数。最后，在代理上调用
    `Count` 方法。调用被包含在 `try`/`catch` 中，如果发生错误，错误会被简单地忽略，因为我们只是发送随机数据。相反，实际的生产应用程序应该使用
    **Polly** 来使用预定义的策略重试通信。**Polly** 在第 11 章，*将微服务架构应用于您的企业应用程序*的 *弹性任务执行* 部分中进行了描述。在下一节中，我们将向您展示如何使用
    **Polly**。
- en: And there you have it! Now it is time to test everything. Right-click on the
    solution and select **Set Startup Projects**, then set both `FakeSource` and `GrpcMicroService`
    to start. This way, both projects will be launched simultaneously when the solution
    is run.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止！现在到了测试一切的时候了。右键单击解决方案，选择 **设置启动项目**，然后将 `FakeSource` 和 `GrpcMicroService`
    都设置为启动。这样，当解决方案运行时，这两个项目将同时启动。
- en: Launch Visual Studio and then let both processes run for a couple of minutes,
    then go to **SQL Server Object Explorer** and look for a database called `grpcmicroservice`.
    If the **SQL Server Object Explorer** window is not available in the left menu
    of Visual Studio, go to the top **Window** menu and select it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Visual Studio，然后让两个进程运行几分钟，然后转到 **SQL Server 对象资源管理器** 并查找名为 `grpcmicroservice`
    的数据库。如果 **SQL Server 对象资源管理器** 窗口在 Visual Studio 左侧菜单中不可用，请转到顶部 **窗口** 菜单并选择它。
- en: Once you have located the database, show the content of the `DayTotals` and
    `Purchases` tables. You should see all computed daily sums and all processed purchases.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到数据库，显示 `DayTotals` 和 `Purchases` 表的内容。您应该看到所有计算出的每日总和以及所有已处理购买。
- en: You can also inspect what happens in the server project by opening the `HostedServices/ProcessPurchases.cs`
    file and placing breakpoints on the `queue.Top(10)` and `await` `queue.Dequeue(...)`
    instructions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过打开 `HostedServices/ProcessPurchases.cs` 文件并在 `queue.Top(10)` 和 `await`
    `queue.Dequeue(...)` 指令上设置断点来检查服务器项目中发生的情况。
- en: You can also move `FakeSource` into a different Visual Studio solution so that
    you can simultaneously run several copies of `FakeSource` each in a different
    Visual Studio instance. It is also possible to double-click on the `FakeSource`
    project, which gives the option to save a new Visual Studio solution containing
    just a reference to the `FakeSource` project.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 `FakeSource` 移动到不同的 Visual Studio 解决方案中，这样您就可以同时在不同的 Visual Studio 实例中运行几个
    `FakeSource` 的副本。也可以双击 `FakeSource` 项目，这将提供保存包含仅对 `FakeSource` 项目引用的新 Visual Studio
    解决方案选项。
- en: The full code is in the `GrpcMicroService` subfolder of the `ch15` folder of
    the book’s GitHub repository. The next section shows you how to solve the same
    problem with queued communication using the RabbitMQ message broker.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码位于书籍 GitHub 仓库的 `ch15` 文件夹中的 `GrpcMicroService` 子文件夹中。下一节将向您展示如何使用 RabbitMQ
    消息代理以队列通信方式解决相同的问题。
- en: A worker microservice based on RabbitMQ
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 RabbitMQ 的工作微服务
- en: This section explains the modifications needed to use a message broker instead
    of gRPC communication with an internal queue. This kind of solution is usually
    more difficult to test and design but allows for better horizontal scaling, and
    also enables extra features at almost no cost since they are offered by the message
    broker itself.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了使用消息代理而不是 gRPC 通信与内部队列所需的修改。这种解决方案通常更难测试和设计，但允许更好的水平扩展，并且几乎无需额外成本即可启用额外功能，因为这些功能由消息代理本身提供。
- en: We assume that RabbitMQ has already been installed and adequately prepared,
    as explained in the *Installing RabbitMQ core* subsection of *Chapter 14, Implementing
    Microservices with .NET*.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设 RabbitMQ 已经安装并适当准备，如 *第 14 章，使用 .NET 实现微服务* 中的 *安装 RabbitMQ 核心部分* 所述。
- en: 'First, the ASP.NET Core project must be replaced by another **Worker Service**
    project. Also, this project must add the connection string to its configuration
    file and must call the `AddStorage` extension method to add all the database services
    to the dependency injection engine. Below is the full content of the `Program.cs`
    file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须将 ASP.NET Core 项目替换为另一个 **Worker Service** 项目。此外，该项目必须将其连接字符串添加到配置文件中，并调用
    `AddStorage` 扩展方法以将所有数据库服务添加到依赖注入引擎中。以下是 `Program.cs` 文件的全部内容：
- en: '[PRE21]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We don’t need the gRPC services and service proxies anymore, just ProtoBuf
    for the binary messages, so both the `FakeSource` process and the `GrpcMicroService`
    projects must add just the `Google.Protobuf` and `Grpc.Tools` NuGet packages.
    Both projects need the following `messages.proto` file, which defines just the
    purchase message:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要 gRPC 服务和代理，只需要 ProtoBuf 用于二进制消息，因此 `FakeSource` 进程和 `GrpcMicroService`
    项目都必须添加 `Google.Protobuf` 和 `Grpc.Tools` NuGet 包。两个项目都需要以下 `messages.proto` 文件，它仅定义了购买消息：
- en: '[PRE22]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The automatic generation of the message classes is enabled in both projects
    with the same XML declaration in their project files:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个项目中都启用了消息类的自动生成，它们的项目文件中包含相同的 XML 声明：
- en: '[PRE23]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Both projects need to specify `Client` code generation since no service needs
    to be created.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 两个项目都需要指定 `Client` 代码生成，因为不需要创建任何服务。
- en: To communicate with the RabbitMQ server, both projects must add the `RabbitMQ.Client`
    NuGet package.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 RabbitMQ 服务器通信，两个项目都必须添加 `RabbitMQ.Client` NuGet 包。
- en: Finally, `FakeSource` also adds the `Polly` `NuGet` package because we will
    use Polly to define reliable communication strategies.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`FakeSource` 还添加了 `Polly` `NuGet` 包，因为我们将会使用 Polly 来定义可靠的通信策略。
- en: 'The `ExecuteAsync` method of the client project is a little bit different:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端项目的`ExecuteAsync`方法略有不同：
- en: '[PRE24]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Communication requires the creation of a connection factory, then the creation
    factory generates a connection, and the connection generates a channel. The connection
    factory is created outside of the main loop since it can be reused several times,
    and it is not invalidated by communication errors.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通信需要创建一个连接工厂，然后连接工厂生成一个连接，连接生成一个通道。连接工厂在主循环外部创建，因为它可以被多次重用，并且不会被通信错误所无效化。
- en: For the connection and channel, outside of the main loop, we just define the
    variables and where to place them since they are invalidated in the case of communication
    exceptions, so we must dispose of them and recreate them from scratch after each
    exception.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接和通道，在主循环外部，我们只需定义变量和它们放置的位置，因为它们在通信异常的情况下会被无效化，所以我们必须在每次异常后从零开始释放它们并重新创建它们。
- en: The main loop is enclosed in `try`/`finally` to ensure that any channel/connection
    pair is disposed of before leaving the method.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环被包含在`try`/`finally`中，以确保在离开方法之前任何通道/连接对都被释放。
- en: 'Inside the main loop, as a first step, we create the purchase message:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环内部，作为第一步，我们创建购买消息：
- en: '[PRE25]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, the message is serialized:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，消息被序列化：
- en: '[PRE26]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before executing the communication, we define a Polly policy:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行通信之前，我们定义一个Polly策略：
- en: '[PRE27]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The above policy is an exponential retry, which, in the case of an exception,
    waits for an exponentially growing amount of time. So, if six attempts are made,
    then the second attempt is made after 2 seconds, the third after 4 seconds, the
    fourth after 8 seconds, and so on. If all attempts fail, the exception is rethrown
    and causes the message to be lost. If it’s important that messages can’t be lost,
    we can combine this strategy with a circuit break strategy (see *Resilient task
    execution* in *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise
    Application*).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 上述策略是指数重试，在异常的情况下，等待的时间呈指数增长。所以，如果尝试了六次，那么第二次尝试是在2秒后，第三次是在4秒后，第四次是在8秒后，依此类推。如果所有尝试都失败，异常会被重新抛出，导致消息丢失。如果消息不能丢失很重要，我们可以将这种策略与断路器策略（见第11章中的*Resilient
    task execution*，*将微服务架构应用于您的企业应用程序*）相结合。
- en: 'Once we have defined the retry policy, we can execute all the communication
    steps in the context of this policy:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了重试策略，我们就可以在这个策略的上下文中执行所有通信步骤：
- en: '[PRE28]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If there are no valid connections or channels, they are created. `channel.ConfirmSelect()`
    declares that we need confirmation that the message was safely received and stored
    on disk. In the case that an exception is thrown, both the channel and the connection
    are disposed of, since they might have been corrupted by the exception. This way,
    the next communication attempt will use fresh communication and a new channel.
    After the disposal, the exception is rethrown so it can be handled by the Polly
    policy.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有有效的连接或通道，则创建它们。`channel.ConfirmSelect()`声明我们需要确认消息已被安全接收并存储在磁盘上。如果在抛出异常的情况下，通道和连接都会被释放，因为它们可能已被异常损坏。这样，下一次通信尝试将使用新的通信和一个新的通道。释放后，异常被重新抛出，以便它可以由Polly策略处理。
- en: 'Finally, here are the actual communication steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是实际的通信步骤：
- en: 'First of all, if the queue doesn’t already exist, it is created. The queue
    is created as `durable`; that is, it must be stored on disk and not be `exclusive`
    so that several servers can extract messages from the queue in parallel:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果队列尚不存在，则创建它。队列被创建为`durable`；也就是说，它必须存储在磁盘上，并且不是`exclusive`，这样多个服务器可以并行地从队列中提取消息：
- en: '[PRE29]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, each message is declared as persistent; that is, it must be stored on
    disk:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，每个消息都被声明为持久化；也就是说，它必须存储在磁盘上：
- en: '[PRE30]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, the message is sent through the default exchange, which sends it to
    a specific named queue:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，消息通过默认交换发送，将其发送到特定的命名队列：
- en: '[PRE31]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As a final step, we wait until the message is safely stored on disk:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们等待消息安全地存储在磁盘上：
- en: '[PRE32]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If a confirmation doesn’t arrive within the specified timeout, an exception
    is thrown that triggers the Polly retry policy. When messages are taken from a
    local database queue, we can also use a non-blocking confirmation that triggers
    the removal of the message from the local queue.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在指定的超时时间内没有收到确认，则会抛出一个异常，触发Polly重试策略。当从本地数据库队列中取出消息时，我们也可以使用非阻塞确认来触发从本地队列中移除消息。
- en: 'The `ExecuteAsync` method of the server-hosted process is defined in the `HostedServices/ProcessPurchase.cs`
    file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器托管进程的 `ExecuteAsync` 方法在 `HostedServices/ProcessPurchase.cs` 文件中定义：
- en: '[PRE33]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inside the main loop, if an exception is thrown, it is intercepted by the empty
    `catch`. Since the two `using` statements are left, both the connection and channel
    are disposed of. Therefore, after the exception, a new loop is executed that creates
    a new fresh connection and a new channel.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环内部，如果抛出异常，它会被空的 `catch` 捕获。由于两个 `using` 语句都留在了那里，所以连接和通道都会被销毁。因此，在异常之后，会执行一个新的循环，创建一个新的新鲜连接和一个新的通道。
- en: In the `using` statement body, we ensure that our queue exists, and then set
    `prefetch` to `1`. This means that each server must extract just one message at
    a time, which ensures a fair distribution of the load among all servers. However,
    setting `prefetch` to `1` might not be convenient when servers are based on several
    parallel threads since it sacrifices thread usage optimization in favor of fair
    distribution among servers. As a consequence, threads that could successfully
    process further messages (after the first) might remain idle.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `using` 语句体内，我们确保我们的队列存在，然后将 `prefetch` 设置为 `1`。这意味着每个服务器一次只能提取一条消息，这确保了所有服务器之间负载的公平分配。然而，当服务器基于多个并行线程时，将
    `prefetch` 设置为 `1` 可能不太方便，因为它牺牲了线程使用优化以换取服务器之间的公平分配。因此，可能存在可以成功处理后续消息（在第一条之后）的线程而处于空闲状态。
- en: Then, we define a `message received` event handler. `BasicConsume` starts the
    actual message reception. With `autoAck` set to `false`, when a message is read
    from the queue, it is not removed but just blocked so it is not available to other
    servers that read from the same queue. The message is actually removed when a
    confirmation that it has been successfully processed is sent to RabbitMQ. We can
    also send a failure confirmation, in which case, the message is unblocked and
    becomes available for processing again.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个 `消息接收` 事件处理器。`BasicConsume` 开始实际的消息接收。将 `autoAck` 设置为 `false`，当从队列中读取消息时，它不会被移除，而是被阻塞，因此它对从同一队列读取的其他服务器不可用。实际上，消息是在向
    RabbitMQ 发送成功处理确认后移除的。我们还可以发送一个失败确认，在这种情况下，消息会被解除阻塞并再次可用于处理。
- en: If no confirmation is received, the message remains blocked till the connection
    and channel are disposed of.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有收到确认，消息会一直阻塞，直到连接和通道被销毁。
- en: '`BasicConsume` is non-blocking, so the `Task.Delay` after it blocks till the
    cancelation token is signaled. In any case, after 1 second, `Task.Delay` unblocks
    and both the connection and the channel are replaced with fresh ones. This prevents
    non-confirmed messages from remaining blocked forever.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicConsume` 是非阻塞的，因此在其后的 `Task.Delay` 会阻塞直到取消令牌被信号。在任何情况下，1秒后，`Task.Delay`
    会解除阻塞，并且连接和通道都会被替换为新的。这防止了未确认的消息永远处于阻塞状态。'
- en: Let’s move on to the code inside the *message received* event. This is the place
    where the actual message processing takes place.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看 *消息接收* 事件内部的代码。这是实际消息处理发生的地方。
- en: 'As a first step, the code verifies if the application is being shut down, in
    which case it disposes of the channel and connection and returns without performing
    any further operations:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，代码会验证应用程序是否正在关闭，如果是，则销毁通道和连接并返回，不执行任何进一步的操作：
- en: '[PRE34]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, a session scope is created to access all session-scoped dependency injection
    services:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个会话作用域以访问所有会话作用域的依赖注入服务：
- en: '[PRE35]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When an exception is thrown during the message processing, a `Nack` message
    is sent to RabbitMQ to inform it that the message processing failed. `ea.DeliveryTag`
    is a tag that uniquely identifies the message. The second argument set to `false`
    informs RabbitMQ that the `Nack` is just for the message identified by `ea.DeliveryTag`
    that doesn’t also involve all other messages waiting for confirmation from this
    server. Finally, the last argument set to `true` asks RabbitMQ to requeue the
    message whose processing failed.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息处理过程中抛出异常时，会向 RabbitMQ 发送一个 `Nack` 消息，通知它消息处理失败。`ea.DeliveryTag` 是一个唯一标识消息的标签。第二个参数设置为
    `false` 通知 RabbitMQ，`Nack` 只是对由 `ea.DeliveryTag` 标识的消息而言，并不涉及所有其他等待从该服务器确认的消息。最后，最后一个参数设置为
    `true` 请求 RabbitMQ 重新入队处理失败的消息。
- en: 'Inside the `try` block, we get an instance of `IDayStatistics`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `try` 块内部，我们获取一个 `IDayStatistics` 实例：
- en: '[PRE36]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we deserialize the message body to get a `PurchaseMessage` instance and
    add it to the database:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将消息体反序列化以获取一个 `PurchaseMessage` 实例并将其添加到数据库中：
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the operation fails, the `Add` operation returns `null`, so we must send
    a `Nack`; otherwise, we must send an `Ack`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作失败，`Add` 操作返回 `null`，因此我们必须发送一个 `Nack`；否则，我们必须发送一个 `Ack`：
- en: '[PRE38]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That’s all! The full code is in the `GrpcMicroServiceRabbitProto` subfolder
    of the `ch15` folder in the GitHub repository of this book. You can test the code
    by setting both the client and server projects as the start project and running
    the solution. After 1–2 minutes, the database should be populated with new purchases
    and new daily totals. In a staging/production environment, you can run several
    copies of both the client and server.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！完整的代码位于本书 GitHub 仓库中 `ch15` 文件夹的 `GrpcMicroServiceRabbitProto` 子文件夹中。您可以通过将客户端和服务器项目都设置为启动项目并运行解决方案来测试代码。1-2
    分钟后，数据库应该填充了新的购买和新的每日总计。在预发布/生产环境中，您可以运行客户端和服务器的好几份副本。
- en: The `GrpcMicroServiceRabbit` subfolder in the `ch15` folder of the GitHub repository
    contains another version of the same application that uses the *Binaron* NuGet
    package for serialization. It is faster than ProtoBuf, but being .NET-specific,
    it is not interoperable. Moreover, it has no features to facilitate message versioning.
    It is useful when performance is critical and versioning and interoperability
    are not a priority.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 仓库 `ch15` 文件夹中的 `GrpcMicroServiceRabbit` 子文件夹包含相同应用程序的另一个版本，该版本使用 *Binaron*
    NuGet 包进行序列化。它比 ProtoBuf 快，但作为 .NET 特定的，它不具有互操作性。此外，它没有便于消息版本化的功能。当性能至关重要，而版本化和互操作性不是优先事项时，它很有用。
- en: 'The *Binaron* version differs in that it has no `.proto` files or other ProtoBuf
    stuff, but it explicitly defines a `PurchaseMessage` .NET class. Moreover, ProtoBuf
    serialization and deserialization instructions are replaced by the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*Binaron* 版本的不同之处在于它没有 `.proto` 文件或其他 ProtoBuf 内容，但它明确定义了一个 `PurchaseMessage`
    .NET 类。此外，ProtoBuf 序列化和反序列化指令被以下内容替换：'
- en: '[PRE39]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Together with:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 与以下内容一起：
- en: '[PRE40]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that we have created a microservice connected to a message broker, it is
    also important to learn how to expose packages from WWTravelClub using web APIs.
    Let’s see this in the next section.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个连接到消息代理的微服务，学习如何使用 Web API 暴露 WWTravelClub 的包也同样重要。让我们在下一节中看看这个内容。
- en: Exposing WWTravelClub packages using Web APIs
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Web API 暴露 WWTravelClub 包
- en: In this section, we will implement an ASP.NET REST service that lists all the
    packages that are available for a given vacation’s start and end dates. For didactic
    purposes, we will not structure the application according to the best practices
    we have described previously; instead, we will simply generate the results with
    a LINQ query that will be directly placed in the controller action method. A well-structured
    ASP.NET Core application has been presented in *Chapter 18*, *Implementing Frontend
    Microservices with ASP.NET Core*.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个 ASP.NET REST 服务，该服务列出给定假期开始和结束日期可用的所有包。为了教学目的，我们不会根据我们之前描述的最佳实践来构建应用程序；相反，我们将简单地使用
    LINQ 查询生成结果，并将该查询直接放置在控制器操作方法中。一个结构良好的 ASP.NET Core 应用程序已在 *第 18 章*，*使用 ASP.NET
    Core 实现前端微服务* 中介绍。
- en: Let us make a copy of the `WWTravelClubDB` solution folder and rename the new
    folder `WWTravelClubWebAPI80`. The WWTravelClubDB project was built step by step
    in the various sections of *Chapter 13*, *Interacting with Data in C# – Entity
    Framework Core*. Let us open the new solution and add a new ASP.NET Core API project
    to it named `WWTravelClubWebAPI80` (the same name as the new solution folder).
    For simplicity, select **No Authentication**. Right-click on the newly created
    project and select **Set as StartUp project** to make it the default project that
    is launched when the solution is run.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制 `WWTravelClubDB` 解决方案文件夹，并将新文件夹重命名为 `WWTravelClubWebAPI80`。`WWTravelClubDB`
    项目是在 *第 13 章*，*使用 C# 与数据交互 – Entity Framework Core* 的各个部分中逐步构建的。让我们打开新的解决方案，并向其中添加一个名为
    `WWTravelClubWebAPI80` 的新 ASP.NET Core API 项目（与新的解决方案文件夹同名）。为了简单起见，选择 **无身份验证**。右键单击新创建的项目，并选择
    **设置为启动项目**，使其成为在运行解决方案时启动的默认项目。
- en: Finally, we need to add a reference to the WWTravelClubDB project.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将 WWTravelClubDB 项目添加为引用。
- en: 'ASP.NET Core projects store configuration constants in the `appsettings.json`
    file. Let’s open this file and add the database connection string for the database
    we created in the WWTravelClubDB project to it, as shown here:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 项目将配置常量存储在 `appsettings.json` 文件中。让我们打开这个文件，并将我们为 WWTravelClubDB
    项目创建的数据库连接字符串添加到其中，如下所示：
- en: '[PRE41]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we must add the WWTravelClubDB entity framework database context to `Program.cs`,
    as shown here:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将 WWTravelClubDB 实体框架数据库上下文添加到 `Program.cs` 中，如下所示：
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The option object settings that are passed to `AddDbContext` specify the usage
    of SQL Server with a connection string that is extracted from the `ConnectionStrings`
    section of the `appsettings.json` configuration file with the `Configuration.GetConnectionString("DefaultConnection")`
    method. The `b =>b.MigrationsAssembly("WWTravelClubDB")` lambda function declares
    the name of the assembly that contains the database migrations (see *Chapter 13*,
    *Interacting with Data in C# – Entity Framework Core*), which, in our case, is
    the DLL that was generated by the WWTravelClubDB project. For the preceding code
    to compile, you should add the `Microsoft.EntityFrameworkCore` namespace.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `AddDbContext` 的选项对象设置指定了使用 SQL Server，其连接字符串是从 `appsettings.json` 配置文件的
    `ConnectionStrings` 部分提取的，使用 `Configuration.GetConnectionString("DefaultConnection")`
    方法。`b =>b.MigrationsAssembly("WWTravelClubDB")` lambda 函数声明了包含数据库迁移的程序的名称（参见 *第
    13 章*，*在 C# 中与数据交互 – Entity Framework Core*），在我们的情况下，是由 WWTravelClubDB 项目生成的 DLL。为了使前面的代码能够编译，你应该添加
    `Microsoft.EntityFrameworkCore` 命名空间。
- en: 'Since we want to enrich our REST service with OpenAPI documentation, let’s
    add a reference to the `Swashbuckle.AspNetCore` NuGet package. Now, we can add
    the following very basic configuration to `Program.cs`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望用 OpenAPI 文档丰富我们的 REST 服务，让我们添加对 `Swashbuckle.AspNetCore` NuGet 包的引用。现在，我们可以在
    `Program.cs` 中添加以下非常基本的配置：
- en: '[PRE43]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we are ready to encode our service. Let’s delete `WeatherForecastController`,
    which is automatically scaffolded by Visual Studio. Then, right-click on the `Controllers`
    folder and select **Add | Controller**. Now, choose an empty API controller called
    `PackagesController`. First, let’s modify the code as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编码我们的服务。让我们删除由 Visual Studio 自动生成的 `WeatherForecastController`。然后，右键单击
    `Controllers` 文件夹并选择 **添加 | 控制器**。现在，选择一个名为 `PackagesController` 的空 API 控制器。首先，让我们按以下方式修改代码：
- en: '[PRE44]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Route` attribute declares that the basic path for our service will be
    `api/packages`. The unique action method that we implement is `GetPackagesByDate`,
    which is invoked on `HttpGet` requests on paths of the `bydate/{start}/{stop}`
    type, where `start` and `stop` are the `DateTime` parameters that are passed as
    input to `GetPackagesByDate`. The `ProduceResponseType` attributes declare the
    following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route` 属性声明我们的服务的基本路径将是 `api/packages`。我们实现的唯一操作方法是 `GetPackagesByDate`，它在
    `HttpGet` 请求上被调用，路径类型为 `bydate/{start}/{stop}`，其中 `start` 和 `stop` 是作为输入传递给 `GetPackagesByDate`
    的 `DateTime` 参数。`ProduceResponseType` 属性声明以下内容：'
- en: When a request is successful, a 200 code is returned, and the body contains
    an `IEnumerable` of the `PackagesListDTO` type (which we will soon define) containing
    the required package information.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求成功时，返回 200 状态码，并且正文包含一个 `IEnumerable` 的 `PackagesListDTO` 类型（我们很快将定义），其中包含所需的包信息。
- en: When the request is ill formed, a 400 code is returned. We don’t specify the
    type returned since bad requests are automatically handled by the ASP.NET Core
    framework through the `ApiController` attribute.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求格式不正确时，返回 400 状态码。我们未指定返回的类型，因为不良请求会自动通过 `ApiController` 属性由 ASP.NET Core
    框架处理。
- en: In the case of unexpected errors, a 500 code is returned with the exception
    error message.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现意外错误的情况下，返回 500 状态码，并带有异常错误信息。
- en: 'Now, let’s define the `PackagesListDTO` class in a new `DTOs` folder:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在新的 `DTOs` 文件夹中定义 `PackagesListDTO` 类：
- en: '[PRE45]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, let’s add the following `using` clauses to our controller code so
    that we can easily refer to our DTO and Entity Framework LINQ methods:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将以下 `using` 子句添加到我们的控制器代码中，以便我们可以轻松地引用我们的 DTO 和 Entity Framework LINQ
    方法：
- en: '[PRE46]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, we are ready to fill the body of the `GetPackagesByDate` method with the
    following code.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好用以下代码填充 `GetPackagesByDate` 方法的正文。
- en: '[PRE47]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is important to remember that we are focusing only on presenting the results
    of an API exposed using the `Swashbuckle.AspNetCore` NuGet package. It is not
    a good practice to make use of the `DbContext` in a `Controller` class, and as
    a software architect, you may define the best architectural design for your application
    (multi-tier, hexagonal, onion, clean, DDD, and so on).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，我们只关注使用 `Swashbuckle.AspNetCore` NuGet 包公开的 API 的结果展示。在 `Controller`
    类中使用 `DbContext` 不是一个好的做法，作为软件架构师，你可能需要为你的应用程序定义最佳的建筑设计（多层、六边形、洋葱、清洁、DDD 等）。
- en: The LINQ query is like the one contained in the `WWTravelClubDBTest` project
    we tested in *Chapter 13*, *Interacting with Data in C# – Entity Framework Core*.
    Once the result has been computed, it is returned with an `OK` call. The method’s
    code handles internal server errors by catching exceptions and returning a 500
    status code since bad requests are automatically handled before the `Controller`
    method is called by the `ApiController` attribute.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ查询类似于我们在第13章“与C#中的数据交互 - Entity Framework Core”中测试的`WWTravelClubDBTest`项目中的查询。一旦结果被计算出来，它就会通过一个`OK`调用返回。该方法代码通过捕获异常并返回500状态码来处理内部服务器错误，因为不良请求是在`ApiController`属性调用`Controller`方法之前自动处理的。
- en: Let’s run the solution. When the browser opens, it is unable to receive any
    result from our ASP.NET Core website. Let’s modify the browser URL so that it
    is `https://localhost:<previous port>/swagger`. It is worth mentioning that you
    can also configure your local settings file to either launch and go to the Swagger
    URL automatically, or have Swagger live under the root.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行解决方案。当浏览器打开时，它无法从我们的ASP.NET Core网站接收任何结果。让我们修改浏览器URL，使其为`https://localhost:<previous
    port>/swagger`。值得一提的是，你也可以配置你的本地设置文件，使其自动启动并转到Swagger URL，或者让Swagger在根目录下运行。
- en: 'The user interface of the OpenAPI documentation will look as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI文档的用户界面将如下所示：
- en: '![](img/B19820_21_15.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_21_15.png)'
- en: 'Figure 21.15: Swagger output'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.15：Swagger输出
- en: '**PackagesListDTO** is the model we defined to list the packages, while **ProblemDetails**
    is the model that is used to report errors in the event of bad requests. By clicking
    the **GET** button, we can get more details about our `GET` method and we can
    also test it, as shown in the following screenshot:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**PackagesListDTO**是我们定义的用于列出包的模型，而**ProblemDetails**是用于在发生错误请求时报告错误的模型。通过点击**GET**按钮，我们可以获取更多关于我们的`GET`方法的信息，我们还可以测试它，如下面的截图所示：'
- en: '![Interface gráfica do usuário, Aplicativo  Descrição gerada automaticamente](img/B19820_21_16.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，应用程序，自动生成的描述](img/B19820_21_16.png)'
- en: 'Figure 21.16: GET method details'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.16：GET方法详情
- en: Pay attention when it comes to inserting dates that are covered by packages
    in the database; otherwise, an empty list will be returned. The ones shown in
    the preceding screenshot should work.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入数据库中由包覆盖的日期时，请注意；否则，将返回一个空列表。前面截图中的那些应该可以工作。
- en: 'Dates must be entered in a correct JSON format; otherwise, a 400 Bad Request
    error is returned, like the one shown in the following code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 日期必须以正确的JSON格式输入；否则，会返回一个400 Bad Request错误，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you insert the correct input parameters, the Swagger UI returns the packages
    that satisfy the query in JSON format.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你插入正确的输入参数，Swagger UI将以JSON格式返回满足查询的包。
- en: That is all! You have implemented your first API with OpenAPI documentation!
    Now let’s check how easy it can be to implement a serverless solution using Azure
    Functions.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你已经使用OpenAPI文档实现了你的第一个API！现在让我们看看使用Azure Functions实现无服务器解决方案有多简单。
- en: Implementing Azure Functions to send emails
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Azure Functions以发送电子邮件
- en: Here, we will use a subset of the Azure components. The use case from WWTravelClub
    proposes a worldwide implementation of the service, and there is a chance that
    this service will need different architecture designs to achieve all the key performance
    points that we described in *Chapter 1*, *Understanding the Importance of Software
    Architecture*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用Azure组件的一个子集。WWTravelClub的使用案例提出了全球实施该服务，并且有可能这个服务需要不同的架构设计来实现我们在第1章“理解软件架构的重要性”中描述的所有关键性能点。
- en: If you go back to the user stories that were described in this chapter, you
    will find that many needs are related to communication. Because of this, it is
    common to have some alerts provided by emails in the solution. This implementation
    will focus on how to send emails. The architecture will be totally serverless.
    The benefits of using an architecture like that are explained below.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾本章中描述的用户故事，你会发现许多需求都与沟通相关。正因为如此，在解决方案中提供一些由电子邮件发出的警报是很常见的。本实现将专注于如何发送电子邮件。该架构将是完全无服务器的。使用这种架构的好处如下所述。
- en: 'The following diagram shows the basic structure of the architecture. To give
    users a great experience, all the emails that are sent by the application will
    be queued asynchronously, thereby preventing significant delays in the system’s
    responses:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了该架构的基本结构。为了给用户提供良好的体验，应用程序发送的所有电子邮件都将异步排队，从而防止系统响应出现重大延迟：
- en: '![Diagram  Description automatically generated](img/B19820_21_17.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成的描述](img/B19820_21_17.png)'
- en: 'Figure 21.17: Architectural design for sending emails'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.17：发送电子邮件的架构设计
- en: Basically, when a user does any action that requires sending an alert (1), the
    alert is posted in a **send email request function** (2), which stores the request
    in Azure Queue Storage (3). So, for the user, the alert is already performed at
    this moment, and they can keep working. However, since we have a queue, no matter
    the number of alerts sent, they will be processed by the **send email function**
    that is triggered (4) as soon as a request is made, respecting the time needed
    to process the requests, but guaranteeing that the receiver will get the alert
    (5). Note that there are no dedicated servers that manage Azure Functions for
    enqueuing or dequeuing messages from Azure Queue Storage. This is exactly what
    we call serverless, as described in *Chapter 16, Working with Serverless - Azure
    Functions*. It is worth mentioning that this architecture is not restricted to
    only sending emails – it can also be used to process any HTTP `POST` request.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，当用户执行任何需要发送警报的操作（1）时，警报将被发布在**发送电子邮件请求函数**（2）中，该函数将请求存储在 Azure 队列存储（3）中。因此，对于用户来说，警报已经在此时执行，他们可以继续工作。然而，由于我们有一个队列，无论发送多少警报，它们都将由**发送电子邮件函数**处理，该函数在请求一发出就会触发（4），尊重处理请求所需的时间，但保证接收者会收到警报（5）。请注意，没有专门的服务器来管理从
    Azure 队列存储中入队或出队消息的 Azure 函数。这正是我们所说的无服务器，如第 16 章“使用无服务器 - Azure 函数”中所述。值得一提的是，这种架构不仅限于发送电子邮件——它还可以用于处理任何
    HTTP `POST` 请求。
- en: Now, we will learn, in three steps, how to set up security in the API so that
    only authorized applications can use the given solution.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将分三步学习如何在 API 中设置安全措施，以确保只有授权的应用程序可以使用给定的解决方案。
- en: First step — creating an Azure queue storage
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步——创建 Azure 队列存储
- en: 'It is quite simple to create storage in the Azure portal. Let us learn how.
    First, you will need to create a storage account by clicking on **Create a resource**
    on the main page of the Azure portal and searching for **Storage account**. Then,
    you will be able to set up its basic information, such as **Storage account name**
    and **Location**. Information about **Networking** and **Data protection**, as
    shown in the following screenshot, can be checked in this wizard, too. There are
    default values for these settings that we will cover the demo:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 门户中创建存储相当简单。让我们来学习如何操作。首先，您需要通过点击 Azure 门户主页上的**创建资源**并搜索**存储帐户**来创建一个存储帐户。然后，您将能够设置其基本信息，例如**存储帐户名称**和**位置**。如以下截图所示，您也可以在此向导中检查有关**网络**和**数据保护**的信息。这些设置有默认值，我们将在演示中介绍：
- en: '![](img/B19820_21_18.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_18.png)'
- en: 'Figure 21.18: Creating an Azure storage account'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.18：创建 Azure 存储帐户
- en: 'Once you have the storage account in place, you will be able to set up a queue.
    You will find this option by clicking on the **Overview** link in the storage
    account and selecting the **Queue service** option or by selecting **Queues**
    via the **Storage account** menu. Then, you will find an option to add the queue
    (**+ Queue**), where you just need to provide its name:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您设置了存储帐户，您就可以设置一个队列。您可以通过点击存储帐户中的**概览**链接并选择**队列服务**选项，或者通过**存储帐户**菜单选择**队列**来找到此选项。然后，您将找到一个添加队列的选项（**+
    队列**），您只需提供其名称：
- en: '![Interface gráfica do usuário, Texto, Aplicativo  Descrição gerada automaticamente](img/B19820_21_19.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，文本，应用程序  自动生成的描述](img/B19820_21_19.png)'
- en: 'Figure 21.19: Defining a queue to monitor emails'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.19：定义队列以监控电子邮件
- en: 'The created queue will give you an overview of the Azure portal. There, you
    will find your queue’s URL and be able to use Storage Explorer:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的队列将为您展示 Azure 门户的概览。在那里，您将找到队列的 URL 并能够使用存储资源管理器：
- en: '![](img/B19820_21_20.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_20.png)'
- en: 'Figure 21.20: Queue created'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.20：队列已创建
- en: 'Note that you will also be able to connect to this storage using Microsoft
    Azure Storage Explorer ([https://azure.microsoft.com/en-us/features/storage-explorer/](https://azure.microsoft.com/en-us/features/storage-explorer/)):'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您还可以使用 Microsoft Azure Storage Explorer 连接到此存储（[https://azure.microsoft.com/en-us/features/storage-explorer/](https://azure.microsoft.com/en-us/features/storage-explorer/))：
- en: '![](img/B19820_21_21.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_21.png)'
- en: 'Figure 21.21: Monitoring the queue using Microsoft Azure Storage Explorer'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.21：使用 Microsoft Azure Storage Explorer 监控队列
- en: This tool is especially useful if you are not connected to the Azure portal.
    Let’s move to the second step, where we will create the function that receives
    the requests to send emails.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有连接到 Azure 门户，此工具特别有用。让我们进入第二步，在那里我们将创建接收发送电子邮件请求的函数。
- en: Second step — creating the function to send emails
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二步 — 创建发送电子邮件的函数
- en: Now, you can start programming in earnest, informing the queue that an email
    is waiting to be sent. Here, we need to use an HTTP trigger. Note that the function
    is a static class that runs asynchronously. The following code, written in Visual
    Studio, gathers the request data coming from the HTTP trigger and inserts the
    data into a queue that will be processed later. It is worth mentioning that the
    environment variable `EmailQueueConnectionString` is set in the function app settings,
    and it contains the information provided by the Azure Queue Storage connection
    string.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以开始认真编程了，通知队列有一封电子邮件等待发送。在这里，我们需要使用 HTTP 触发器。请注意，该函数是一个静态类，它异步运行。以下代码是在
    Visual Studio 中编写的，它收集来自 HTTP 触发器的请求数据并将其插入到稍后处理的队列中。值得一提的是，环境变量 `EmailQueueConnectionString`
    在函数应用设置中设置，并包含 Azure 队列存储连接字符串提供的信息。
- en: 'We have below a code snippet from the function available in the GitHub repository
    of the book:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从本书 GitHub 仓库中可用的函数代码片段：
- en: '[PRE49]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In some scenarios, you may try to avoid the queue setup indicated in the preceding
    code by using a queue output binding. Check out the details at [https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue-output?tabs=csharp](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue-output?tabs=csharp).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，您可能尝试通过使用队列输出绑定来避免前面代码中指示的队列设置。有关详细信息，请参阅[https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue-output?tabs=csharp](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue-output?tabs=csharp)。
- en: 'You can use a tool such as Postman to test your function. Before that, you
    just need to run the app in Visual Studio, which will launch Azure Functions Core
    Tools and its emulator:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Postman 等工具测试您的函数。在此之前，您只需在 Visual Studio 中运行应用程序，这将启动 Azure Functions
    Core Tools 和其模拟器：
- en: '![Interface gráfica do usuário, Texto, Aplicativo  Descrição gerada automaticamente](img/B19820_21_22.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，文本，应用程序，自动生成的描述](img/B19820_21_22.png)'
- en: 'Figure 21.22: Postman function test'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.22：Postman 函数测试
- en: 'The result will appear in Microsoft Azure Storage Explorer and the Azure portal.
    In the Azure portal, you can manage each message and dequeue each of them or even
    clear the queue storage:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将出现在 Microsoft Azure Storage Explorer 和 Azure 门户中。在 Azure 门户中，您可以管理每条消息并解除每条消息的队列，甚至可以清除队列存储：
- en: '![Interface gráfica do usuário, Texto, Aplicativo, Email  Descrição gerada
    automaticamente](img/B19820_21_23.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，文本，应用程序，电子邮件，自动生成的描述](img/B19820_21_23.png)'
- en: 'Figure 21.23: HTTP trigger and queue storage test'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.23：HTTP 触发器和队列存储测试
- en: To finish this topic, let’s move on to the final third step, where we will create
    the function that will process the requests for sending emails.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个主题，让我们进入最终的第三步，在那里我们将创建处理发送电子邮件请求的函数。
- en: Third step — creating the queue trigger function
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三步 — 创建队列触发函数
- en: 'After this, you can create a second function by right-clicking the project
    and selecting **Add -> New Azure Function**. This one will be triggered by data
    entering your queue. It is worth mentioning that, for Azure Functions v4, you
    will have the `Microsoft.Azure.WebJobs.Extensions.Storage` library added as a
    NuGet reference automatically:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过右键单击项目并选择 **添加 -> 新建 Azure Function** 来创建第二个函数。这个函数将由进入队列的数据触发。值得一提的是，对于
    Azure Functions v4，您将自动添加 `Microsoft.Azure.WebJobs.Extensions.Storage` 库作为 NuGet
    引用：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_21_24.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B19820_21_24.png)'
- en: 'Figure 21.24: Creating a queue trigger'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.24：创建队列触发器
- en: 'Once you have set the connection string inside `local.settings.json`, you will
    be able to run both functions and test them with Postman. The difference is that,
    with the second function running, if you set a breakpoint at the start of it,
    you will be able to check whether the message has been sent:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在`local.settings.json`内部设置了连接字符串，你将能够运行这两个函数并使用Postman测试它们。区别在于，当第二个函数运行时，如果你在它的开始处设置断点，你将能够检查消息是否已发送：
- en: '![Tela de computador com texto preto sobre fundo branco  Descrição gerada automaticamente](img/B19820_21_25.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕，背景为白色，黑色文字  自动生成的描述](img/B19820_21_25.png)'
- en: 'Figure 21.25: Queue triggered in Visual Studio 2022'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.25：在Visual Studio 2022中触发的队列
- en: From this point, the way to send emails will depend on the email options you
    have. You may decide to use a proxy or connect directly to your email server.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，发送电子邮件的方式将取决于你拥有的电子邮件选项。你可能决定使用代理或直接连接到你的电子邮件服务器。
- en: 'There are several advantages to creating an email service this way:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建电子邮件服务有几个优点：
- en: Once your service has been coded and tested, you can use it to send emails from
    any of your applications. This means that your code can always be reused.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你的服务被编码和测试，你就可以使用它从你的任何应用程序发送电子邮件。这意味着你的代码可以始终重用。
- en: Apps that use this service will not be stopped from sending emails due to the
    asynchronous advantages of posting in an HTTP service.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此服务的应用程序不会因为HTTP服务异步发布的优势而停止发送电子邮件。
- en: You do not need to pool the queue to check whether data is ready for processing.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要将队列池化来检查数据是否准备好处理。
- en: Finally, the queue process runs concurrently, which delivers a better experience
    in most cases. It is possible to turn it off by setting some properties in `host.json`.
    All the options for this can be found in the *Further reading* section at the
    end of this chapter.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，队列处理过程是并发运行的，这在大多数情况下提供了更好的体验。你可以通过在`host.json`中设置一些属性来关闭它。所有这些选项都可以在本章末尾的*进一步阅读*部分找到。
- en: In this part of the case study, we checked an example of an architecture where
    you connect multiple functions to avoid pooling data and enable concurrent processing.
    We have seen with this demo how great the fit between serverless and event-driven
    architecture is.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究的这部分，我们检查了一个连接多个函数以避免池化数据并启用并发处理的架构示例。我们通过这个演示看到了无服务器架构和事件驱动架构之间是多么的契合。
- en: Now, let’s change the subject a bit, and discuss how to implement a frontend
    microservice.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微改变一下主题，讨论如何实现一个前端微服务。
- en: A frontend microservice
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端微服务
- en: In this section, as an example of an ASP.NET Core MVC frontend microservice
    described in *Chapter 18, Implementing Frontend Microservices with ASP.NET Core*,
    we will implement the administrative panel for managing the destinations and packages
    of the `WWTravelClub` book use case. The application will be implemented with
    theDDDapproach and associated patterns described in *Chapter 7*, *Understanding
    the Different Domains in Software Solutions*. So, having a good understanding
    of that chapter is a fundamental prerequisite to reading this chapter. The subsections
    that follow describe the overall application specifications and organization.
    The full code of the example can be found in the `ch19` folder of the GitHub repository
    associated with the book.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以*第18章，使用ASP.NET Core实现前端微服务*中描述的ASP.NET Core MVC前端微服务为例，实现`WWTravelClub`用例的目的地和包的管理控制台。该应用程序将使用*第7章，理解软件解决方案中的不同领域*中描述的DDD方法和相关模式进行实现。因此，对那章有良好的理解是阅读本章的基本先决条件。接下来的小节将描述整体应用程序规范和组织。示例的完整代码可以在与本书相关的GitHub仓库的`ch19`文件夹中找到。
- en: As usual, let’s start by stating clearly our frontend microservice specifications.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，让我们首先明确我们的前端微服务规范。
- en: Defining application specifications
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义应用程序规范
- en: 'The destinations and packages were described in *Chapter 13*, *Interacting
    with Data in C# – Entity Framework Core*. Here, we will use the same data model,
    with the necessary modifications to adapt it to the DDD approach. The administrative
    panel must allow packages, a destination listing, and CRUD operations on it. To
    simplify the application, the two listings will be quite simple: the application
    will show all destinations sorted according to their names, while all packages
    will be sorted starting from the ones with a later validity date.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地和套餐在*第13章*，*C#中的数据交互 – Entity Framework Core*中进行了描述。在这里，我们将使用相同的数据模型，并对其进行必要的修改以适应DDD方法。管理面板必须允许套餐、目的地列表以及对其的CRUD操作。为了简化应用程序，这两个列表将非常简单：应用程序将按名称排序显示所有目的地，而所有套餐将按有效期排序。
- en: 'Furthermore, we make the following assumptions:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们做出以下假设：
- en: The application that shows destinations and packages to the user shares the
    same database used by the administrative panel. Since only the administrative
    panel application needs to modify data, there will be just one write copy of the
    database with several read-only replicas.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户展示目的地和套餐的应用程序与行政面板使用的数据库相同。由于只有行政面板应用程序需要修改数据，因此将只有一个写数据库副本和几个只读副本。
- en: Price modifications and package deletions are immediately used to update the
    user’s shopping carts. For this reason, the administrative application must send
    asynchronous communications about price changes and package removals. We will
    not implement all the communication logic here, but we will just add all such
    events to an event table, which should be used as input to a parallel thread that’s
    in charge of sending these events to all relevant microservices.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格修改和套餐删除会立即更新用户的购物车。因此，行政应用程序必须发送有关价格变化和套餐移除的异步通信。我们不会在这里实现所有通信逻辑，但我们会将所有此类事件添加到一个事件表中，该表应作为输入提供给一个负责将这些事件发送到所有相关微服务的并行线程。
- en: Here, we will give the full code for just package management; most of the code
    for destination management is designed as an exercise for you. The full code is
    available in the `ch16` folder of the GitHub repository associated with this book.
    In the remainder of this section, we will describe the application’s overall organization
    and discuss some relevant samples of code. We start with an overall description
    of the application architecture.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将提供仅用于套餐管理的完整代码；大部分目的地管理的代码被设计成你的练习。完整的代码可在与本书相关的GitHub存储库的`ch16`文件夹中找到。在本节的剩余部分，我们将描述应用程序的整体组织并讨论一些相关的代码示例。我们从一个对应用程序架构的整体描述开始。
- en: Defining the application architecture
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义应用程序架构
- en: 'The application is organized based on the guidelines described in *Chapter
    7*, *Understanding the Different Domains in Software Solutions*, while considering
    the DDD approach and related patterns. That is, the application is organized into
    three layers, each implemented as a different project:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的组织基于*第7章*，*理解软件解决方案中的不同领域*中描述的指南，同时考虑DDD方法和相关模式。也就是说，应用程序被组织成三个层次，每个层次都作为不同的项目实现：
- en: 'There’s a domain implementation layer, which contains the repository’s implementation
    and the classes describing database entities. It is a .NET library project. However,
    since it needs some interfaces, like `IServiceCollection`, which are defined in
    `Microsoft.NET.Sdk.web`, and since the layer `DBContext` must inherit from the
    identity framework in order to also handle the application authentication and
    authorization database tables, we must add a reference not only to the .NET SDK
    but also to the ASP.NET Core SDK. This can be done as follows:'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个领域实现层，其中包含存储库的实现和描述数据库实体的类。它是一个.NET库项目。然而，由于它需要一些接口，如`IServiceCollection`，这些接口在`Microsoft.NET.Sdk.web`中定义，并且由于`DBContext`层必须从身份框架继承以便也能处理应用程序的认证和授权数据库表，我们必须添加对.NET
    SDK的引用，同时也需要添加对ASP.NET Core SDK的引用。这可以通过以下方式完成：
- en: Right-click on the project icon in Solution Explorer and select **Edit project
    file**, or just double-click the project name.
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中的项目图标上右键单击，然后选择**编辑项目文件**，或者直接双击项目名称。
- en: 'In the **Edit** window, add:'
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**编辑**窗口中，添加：
- en: '[PRE50]'
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There’s also a domain layer abstraction, which contains repository specifications
    – that is, interfaces that describe repository implementations and DDD aggregates.
    In our implementation, we decided to implement aggregates by hiding the forbidden
    operations/properties of root data entities behind interfaces. Hence, for instance,
    the `Package` entity class, which is an aggregate root, has a corresponding `IPackage`
    interface in the domain layer abstraction that hides all the property setters
    of the `Package` entity. The domain layer abstraction also contains the definitions
    of all the domain events, while the event handlers that will subscribe to these
    events are defined in the application layer. `IPackage` has also the associated
    `IPackageRepository` repository interface.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个领域层抽象，其中包含存储库规范——即描述存储库实现和DDD聚合的接口。在我们的实现中，我们决定通过隐藏根数据实体的禁止操作/属性来隐藏聚合的实现。因此，例如，`Package`实体类，它是一个聚合根，在领域层抽象中有一个相应的`IPackage`接口，隐藏了`Package`实体中所有的属性设置器。领域层抽象还包含所有领域事件的定义，而将订阅这些事件的处理程序定义在应用层。`IPackage`还有一个相关的`IPackageRepository`存储库接口。
- en: All repository interfaces inherit from the empty `IRepository` interface.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 所有存储库接口都继承自空的`IRepository`接口。
- en: This way, they declare it as a repository interface, and all repository interfaces
    can be automatically discovered with reflection and added to the dependency injection
    engine together with their implementations.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，它们将其声明为一个存储库接口，所有存储库接口都可以通过反射自动发现，并与其实现一起添加到依赖注入引擎中。
- en: Finally, there’s the application layer – that is, the ASP.NET Core MVC application
    – where we define DDD queries, commands, command handlers, and event handlers.
    Controllers fill query objects and execute them to get ViewModels they can pass
    to Views. They update storage by filling command objects and executing their associated
    command handlers. In turn, command handlers use `IRepository` interfaces (that
    is, interfaces that inherit from the empty `IRepository` interface) and `IUnitOfWork`
    instances coming from the domain layer to manage and coordinate transactions.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是应用层——即ASP.NET Core MVC应用程序——在这里我们定义DDD查询、命令、命令处理程序和事件处理程序。控制器填充查询对象并执行它们以获取可以传递给视图的ViewModel。他们通过填充命令对象并执行相关的命令处理程序来更新存储。反过来，命令处理程序使用`IRepository`接口（即继承自空`IRepository`接口的接口）和来自领域层的`IUnitOfWork`实例来管理和协调事务。
- en: It is worth pointing out that, in more complex microservices, the application
    layer may be implemented as a separate library project and would contain just
    DDD queries, commands, command handlers, and event handlers. While, the MVC project
    would contain just controllers, UIs, and dependency injection.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在更复杂的微服务中，应用层可能作为一个单独的库项目来实现，它将只包含DDD查询、命令、命令处理程序和事件处理程序。而MVC项目将只包含控制器、UI和依赖注入。
- en: The application uses the **Command Query Responsibility Segregation** (**CQRS**)
    pattern; therefore, it uses command objects to modify the storage and the query
    object to query it.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序使用**命令查询责任分离**（**CQRS**）模式；因此，它使用命令对象来修改存储，并使用查询对象来查询它。
- en: 'The query is simple to use and implement: controllers fill their parameters
    and then call their execution methods. In turn, query objects have direct LINQ
    implementations that project results directly onto the ViewModels used by the
    controller Views with `Select` LINQ methods. You may also decide to hide the LINQ
    implementation behind the same repository classes used for the storage update
    operations, but this would turn the definition and modification of simple queries
    into very time-consuming tasks.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的使用和实现都很简单：控制器填充它们的参数，然后调用它们的执行方法。反过来，查询对象有直接的LINQ实现，可以直接使用`Select` LINQ方法将结果投影到控制器视图使用的ViewModel上。你也可以选择将LINQ实现隐藏在用于存储更新操作的相同存储库类后面，但这样做会将简单查询的定义和修改变成非常耗时的工作。
- en: In any case, it can be beneficial to encapsulate query objects behind interfaces
    so that their implementations can be replaced by fake implementations when you
    test controllers.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，将查询对象封装在接口后面可能是有益的，这样在测试控制器时，它们的实现可以被模拟实现所替代。
- en: However, the chain of objects and calls involved in the execution of commands
    is more complex. This is because it requires the construction and modification
    of aggregates (as well as a definition of the interaction between several aggregates
    and between aggregates and other applications through domain events) to be provided.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，执行命令所涉及的对象和调用链更为复杂。这是因为它需要提供构建和修改聚合（以及定义多个聚合之间以及聚合与其他应用程序之间的交互通过领域事件）的操作。
- en: 'The following diagram is a sketch of how storage update operations are performed.
    The circles are data being exchanged between the various layers, while rectangles
    are the procedures that process them. Moreover, dotted arrows connect interfaces
    with types that implement them:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '以下图表是存储更新操作执行方式的草图。圆圈是各层之间交换的数据，而矩形是处理它们的程序。此外，虚线箭头连接接口及其实现它们的类型：  '
- en: '![](img/B19820_21_26.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![图21.26：命令执行图](img/B19820_21_26.png)'
- en: 'Figure 21.26: Diagram of command execution'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.26：命令执行图
- en: 'Here’s the flow of action through *Figure 21.26* as a list of steps:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是*图21.26*中动作流程的步骤列表：
- en: A controller’s action method receives one or more ViewModels and performs validation.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器的动作方法接收一个或多个ViewModel并执行验证。
- en: One or more ViewModels containing changes to apply are hidden behind interfaces
    (`IMyUpdate`) defined in the domain layer. They are used to fill the properties
    of a command object. These interfaces must be defined in the domain layer since
    they will be used as arguments of the repository aggregate methods defined there.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含要应用更改的一个或多个ViewModel隐藏在领域层中定义的接口（`IMyUpdate`）后面。它们用于填充命令对象的属性。由于这些接口将作为在该层定义的存储库聚合方法的参数使用，因此它们必须在领域层中定义。
- en: A command handler matching the previous command is retrieved via **Dependency
    Injection** (**DI**) in the controller action method (through the `[FromServices]`
    parameter attribute we described in the *Defining controllers and views* subsection).
    Then, the handler is executed. During its execution, the handler interacts with
    various repository interface methods and with the aggregates they return.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**依赖注入**（**DI**）在控制器动作方法中检索与先前命令匹配的命令处理器（通过我们在*定义控制器和视图*子节中描述的`[FromServices]`参数属性）。然后，执行处理器。在其执行过程中，处理器与各种存储库接口方法和它们返回的聚合进行交互。
- en: When creating the command handler discussed in *step 3*, the ASP.NET Core DI
    engine automatically injects all parameters declared in its constructor. In particular,
    it injects all repository implementations needed to perform all command handler
    transactions. The command handler performs its job by calling the methods of these
    `IRepository` implementations received in its constructor to build aggregates
    and modify the built aggregates. Aggregates either represent already-existing
    entities or newly created ones. Handlers use the `IUnitOfWork` interface contained
    in each repository interface, as well as the concurrency exceptions returned by
    the data layer, to organize their operations as transactions. It is worth pointing
    out that each aggregate has its own repository implementation, and that the whole
    logic for updating each aggregate is defined in the aggregate itself, not in its
    associated repository implementation, to keep the code more modular.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建*步骤3*中讨论的命令处理器时，ASP.NET Core DI引擎自动注入其构造函数中声明的所有参数。特别是，它注入执行所有命令处理器事务所需的全部存储库实现。命令处理器通过调用其构造函数中接收到的这些`IRepository`实现的方法来构建聚合并修改构建的聚合来完成其工作。聚合要么代表已存在的实体，要么代表新创建的实体。处理器使用包含在每个存储库接口中的`IUnitOfWork`接口以及数据层返回的并发异常来组织其操作作为事务。值得注意的是，每个聚合都有自己的存储库实现，并且更新每个聚合的整体逻辑是在聚合本身中定义的，而不是在其关联的存储库实现中，以保持代码的模块化。
- en: Behind the scenes, in the domain layer implementation, repository implementations
    use Entity Framework to perform their job. Aggregates are implemented by root
    data entities hidden behind interfaces defined in the domain layer, while `IUnitOfWork`
    methods, which handle transactions and pass changes to the database, are implemented
    with `DbContext` methods. In other words, `IUnitOfWork` is implemented with the
    application’s `DbContext`.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在幕后，在领域层实现中，存储库实现使用Entity Framework来执行其工作。聚合通过领域层中定义的接口隐藏的根数据实体来实现，而处理事务并将更改传递到数据库的`IUnitOfWork`方法则使用`DbContext`方法实现。换句话说，`IUnitOfWork`是用应用程序的`DbContext`实现的。
- en: Domain events are generated during each aggregate process and are added to the
    aggregates themselves by calling their `AddDomainEvent` methods. However, they
    are not triggered immediately. Usually, they are triggered at the end of all the
    aggregates’ processing and before changes are passed to the database; however,
    this is not a general rule.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 领域事件在每个聚合过程中生成，并通过调用它们的 `AddDomainEvent` 方法添加到聚合本身中。然而，它们不会立即触发。通常，它们在所有聚合处理结束后、更改传递到数据库之前触发；然而，这并不是一个普遍的规则。
- en: The application handles errors by throwing exceptions.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序通过抛出异常来处理错误。
- en: A more efficient approach would be to define a request-scoped object in the
    dependency engine, where each application subpart may add its errors as domain
    events. However, while this approach is more efficient, it increases the complexity
    of the code and the application development time.
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一种更有效的方法是在依赖引擎中定义一个请求作用域的对象，其中每个应用程序子部分都可以将其错误添加为领域事件。然而，尽管这种方法更有效，但它增加了代码和应用程序开发时间的复杂性。
- en: 'The Visual Studio solution is composed of three projects:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 解决方案由三个项目组成：
- en: There’s a project containing the domain layer abstraction called `PackagesManagementDomain`,
    which is a .NET Standard 2.1 library. When a library doesn’t use features or NuGet
    packages that are specific to a .NET version, it is a good practice to implement
    it as a .NET Standard library because, this way, it doesn’t need modifications
    when the application is moved to a newer .NET version.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个包含领域层抽象的项目，名为 `PackagesManagementDomain`，它是一个 .NET Standard 2.1 库。当一个库不使用特定于
    .NET 版本的功能或 NuGet 包时，将其实现为 .NET Standard 库是一个好习惯，因为这样，当应用程序迁移到较新的 .NET 版本时，它不需要进行修改。
- en: There’s a project containing the whole domain layer implementation called `PackagesManagementDB`,
    which is a .NET 8.0 library.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个包含整个领域层实现的项目，名为 `PackagesManagementDB`，它是一个 .NET 8.0 库。
- en: Finally, there’s an ASP.NET Core MVC 8.0 project called `PackagesManagement`
    that contains both the application and presentation layers. When you define this
    project, select **No Authentication**; otherwise, the user database will be added
    directly to the ASP.NET Core MVC project instead of to the database layer. We
    will add the user database manually in the data layer.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，还有一个名为 `PackagesManagement` 的 ASP.NET Core MVC 8.0 项目，它包含应用程序和表示层。当您定义此项目时，请选择**无身份验证**；否则，用户数据库将直接添加到
    ASP.NET Core MVC 项目中，而不是数据库层。我们将在数据层手动添加用户数据库。
- en: Let’s start by creating the `PackagesManagement` ASP.NET Core MVC project so
    that the whole solution has the same name as the ASP.NET Core MVC project. Then,
    we’ll add the other two library projects to the same solution.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建 `PackagesManagement` ASP.NET Core MVC 项目，以便整个解决方案的名称与 ASP.NET Core MVC
    项目的名称相同。然后，我们将添加其他两个库项目到同一个解决方案中。
- en: Finally, let the ASP.NET Core MVC project reference both projects, while `PackagesManagementDB`
    references `PackagesManagementDomain`. We suggest you define your own projects
    and then copy the code of this book’s GitHub repository into them as you read
    this section.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让 ASP.NET Core MVC 项目同时引用这两个项目，同时 `PackagesManagementDB` 引用 `PackagesManagementDomain`。我们建议您定义自己的项目，然后在阅读本节时将本书
    GitHub 仓库中的代码复制到这些项目中。
- en: The next subsection describes the code of the `PackagesManagementDomain` domain
    layer abstraction project.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了 `PackagesManagementDomain` 领域层抽象项目的代码。
- en: Defining the domain layer abstraction
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义领域层抽象
- en: Once the `PackagesManagementDomain` Standard 2.1 library project has been added
    to the solution, we’ll add a `Tools` folder to the project root. Then, we’ll place
    all the `DomainLayer` tools contained in the code associated with `ch11`. Since
    the code contained in this folder uses data annotations and defines DI extension
    methods, we must also add references to the `System.ComponentModel.Annotations`
    and `Microsoft.Extensions.DependencyInjection.Abstration` NuGet packages.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将 `PackagesManagementDomain` 标准版 2.1 库项目添加到解决方案中，我们将在项目根目录中添加一个 `Tools` 文件夹。然后，我们将所有与
    `ch11` 相关的 `DomainLayer` 工具放置在这个文件夹中。由于这个文件夹中的代码使用了数据注释并定义了 DI 扩展方法，我们还必须添加对 `System.ComponentModel.Annotations`
    和 `Microsoft.Extensions.DependencyInjection.Abstration` NuGet 包的引用。
- en: Then, we need an `Aggregates` folder containing all the aggregate definitions
    (remember, we implemented aggregates as interfaces) – namely, `IDestination`,
    `IPackage`, and `IPackageEvent`. Here, `IPackageEvent` is the aggregate associated
    with the table where we will place events to be propagated to other applications.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们需要一个包含所有聚合定义的`Aggregates`文件夹（记住，我们将聚合实现为接口）——即`IDestination`、`IPackage`和`IPackageEvent`。在这里，`IPackageEvent`是与我们将事件传播到其他应用的表关联的聚合。 '
- en: 'As an example, let’s analyze `IPackage`:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们分析一下`IPackage`：
- en: '[PRE51]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It contains the same properties as the `Package` entity, which we saw in *Chapter
    13*, *Interacting with Data in C# – Entity Framework Core*. The only differences
    are the following:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含与我们在*第13章*中看到的`Package`实体相同的属性，*交互C#中的数据 - Entity Framework Core*。唯一的区别如下：
- en: It inherits from `IEntity<int>`, which furnishes all basic functionalities of
    aggregates
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它继承自`IEntity<int>`，这为聚合提供了所有基本功能。
- en: It has no `Id` property since it is inherited from `IEntity<int>`
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有`Id`属性，因为它继承自`IEntity<int>`。
- en: All properties are read-only, and it has a `FullUpdate` method since all aggregates
    can only be modified through update operations defined in the user domain (in
    our case, the `FullUpdate` method)
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有属性都是只读的，并且它有一个`FullUpdate`方法，因为所有聚合只能通过用户领域（在我们的案例中是`FullUpdate`方法）中定义的更新操作进行修改。
- en: Now, let’s also add a `DTOs` folder. Here, we place all interfaces used to pass
    updates to the aggregates. Such interfaces are implemented by the application
    layer ViewModels used to define such updates. In our case, it contains `IPackageFullEditDTO`,
    which we can use to update existing packages. If you would like to add the logic
    to manage destinations, you must define an analogous interface for the `IDestination`
    aggregate.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也添加一个`DTOs`文件夹。在这里，我们放置所有用于将更新传递给聚合的接口。这些接口由定义此类更新的应用层ViewModel实现。在我们的案例中，它包含`IPackageFullEditDTO`，我们可以用它来更新现有包。如果您想添加管理目标地的逻辑，您必须为`IDestination`聚合定义一个类似的接口。
- en: 'An `IRepositories` folder contains all repository specifications – namely,
    `IDestinationRepository`, `IPackageRepository`, and `IPackageEventRepository`.
    Here, `IPackageEventRepository` is the repository associated with the `IPackageEvent`
    aggregate. As an example, let’s have a look at the `IPackageRepository` repository:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`IRepositories`文件夹包含所有仓库规范——即`IDestinationRepository`、`IPackageRepository`和`IPackageEventRepository`。在这里，`IPackageEventRepository`是与`IPackageEvent`聚合关联的仓库。例如，让我们看一下`IPackageRepository`仓库：
- en: '[PRE52]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Repositories always contain just a few methods since all business logic should
    be represented as aggregate methods – in our case, just the methods to create
    a new package, to retrieve an existing package, and to delete an existing package.
    The logic to modify an existing package is included in the `FullUpdate` method
    of `IPackage`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库通常只包含几个方法，因为所有业务逻辑都应该表示为聚合方法——在我们的案例中，就是创建新包、检索现有包和删除现有包的方法。修改现有包的逻辑包含在`IPackage`的`FullUpdate`方法中。
- en: 'Finally, as with all domain layer projects, `PackagesManagementDomain` contains
    an `Events` folder containing all domain event definitions. In our case, the folder
    is named `Events` and contains the package-deleted event and the price-changed
    event:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像所有领域层项目一样，`PackagesManagementDomain`包含一个包含所有领域事件定义的`Events`文件夹。在我们的案例中，文件夹命名为`Events`，包含包删除事件和价格更改事件：
- en: '[PRE53]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When an aggregate sends all its changes to another application, it should have
    a version property. The application that receives the changes uses this version
    property to apply all changes in the right order. An explicit version number is
    necessary because changes are sent asynchronously, so the order in which they
    are received may differ from the order in which they were sent. For this purpose,
    events that are used to publish changes outside of the application have both `OldVersion`
    (the version before the change) and `NewVersion` (the version after the change)
    properties. Events associated with delete events have no `NewVersion` since, after
    being deleted, an entity can’t store any versions.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个聚合将所有更改发送到另一个应用时，它应该有一个版本属性。接收更改的应用使用这个版本属性来按正确顺序应用所有更改。显式的版本号是必要的，因为更改是异步发送的，所以它们接收的顺序可能与发送的顺序不同。为此，用于在应用外部发布更改的事件既有`OldVersion`（更改前的版本）和`NewVersion`（更改后的版本）属性。与删除事件相关的事件没有`NewVersion`属性，因为实体在被删除后无法存储任何版本。
- en: For more details on how to use and process version information to restore the
    right order of incoming messages, please refer to the *A worker microservice with
    ASP.NET Core* section of this chapter.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用和处理版本信息以恢复传入消息的正确顺序的更多细节，请参阅本章的 *使用 ASP.NET Core 的工作微服务* 部分。
- en: The next subsection explains how all interfaces defined in the domain layer
    abstraction are implemented in the domain layer implementation.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将解释在领域层抽象中定义的所有接口是如何在领域层实现中实现的。
- en: Defining the domain layer implementation
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义领域层实现
- en: The data layer project contains references to the `Microsoft.AspNetCore.Identity.EntityFrameworkCore`
    and `Microsoft.EntityFrameworkCore.SqlServer` NuGet packages, since we are using
    Entity Framework Core with SQL Server. It references `Microsoft.EntityFrameworkCore.Tools`
    and `Microsoft.EntityFrameworkCore.Design`, which are needed to generate database
    migrations, as explained in the *Entity Framework Core migrations* section of
    *Chapter 13*, *Interacting with Data in C# – Entity Framework Core*.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层项目包含对 `Microsoft.AspNetCore.Identity.EntityFrameworkCore` 和 `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet 包的引用，因为我们使用的是与 SQL Server 的 Entity Framework Core。它引用 `Microsoft.EntityFrameworkCore.Tools`
    和 `Microsoft.EntityFrameworkCore.Design`，这些是生成数据库迁移所需的，如 *第13章*，*在 C# 中与数据交互 -
    Entity Framework Core* 中的 *Entity Framework Core 迁移* 部分所述。
- en: 'We have a `Models` folder that contains all database entities. They are similar
    to the ones in *Chapter 13*, *Interacting with Data in C# – Entity Framework Core*.
    The only differences are as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `Models` 文件夹，其中包含所有数据库实体。它们与 *第13章*，*在 C# 中与数据交互 - Entity Framework Core*
    中的类似。唯一的区别如下：
- en: They inherit from `Entity<T>`, which contains all the basic features of aggregates.
    Please note that inheriting from `Entity<T>` is only needed for aggregate roots;
    all other entities must be defined as explained in *Chapter 7*, *Understanding
    the Different Domains in Software Solutions.* In our example, all entities are
    aggregate roots.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们继承自 `Entity<T>`，其中包含聚合的所有基本功能。请注意，从 `Entity<T>` 继承仅适用于聚合根；所有其他实体都必须按照 *第7章*，*理解软件解决方案中的不同领域*
    中所述进行定义。在我们的示例中，所有实体都是聚合根。
- en: They have no `Id` since it is inherited from `Entity<T>`.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它从 `Entity<T>` 继承而来，它们没有 `Id`。
- en: Some of them have an `EntityVersion` property that is decorated with the `[ConcurrencyCheck]`
    attribute. It contains the entity version, which is essential for propagating
    all entity changes to other applications. The `ConcurrencyCheck` attribute is
    needed to prevent concurrency errors while updating the entity version. This prevents
    suffering the performance penalty implied by a transaction.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一些具有带有 `[ConcurrencyCheck]` 特性的 `EntityVersion` 属性。它包含实体版本，这对于将所有实体更改传播到其他应用程序至关重要。`ConcurrencyCheck`
    特性是防止在更新实体版本时出现并发错误的必要条件。这防止了因事务而导致的性能损失。
- en: More specifically, when saving entity changes, if the value of a field marked
    with the `ConcurrencyCheck` attribute is different from the one that was read
    when the entity was loaded in memory, a concurrency exception is thrown to inform
    the calling method that someone else modified this value after the entity was
    read but before we attempted to save its changes. This way, the calling method
    can repeat the whole operation with the hope that this time, no one will write
    the same entity in the database during its execution.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，当保存实体更改时，如果带有 `ConcurrencyCheck` 特性的字段的值与在实体加载到内存时读取的值不同，则会抛出一个并发异常，以通知调用方法，在读取实体之后但在我们尝试保存其更改之前，有人修改了此值。这样，调用方法可以重复整个操作，希望这次在执行过程中没有人会在数据库中写入相同的实体。
- en: 'The only alternative to the `ConcurrencyCheck` attribute would be:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrencyCheck` 属性的唯一替代方案将是：'
- en: Start a transaction.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个事务。
- en: Read the interested aggregate.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取感兴趣的聚合。
- en: Increment its `EntityVersion` property.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加其 `EntityVersion` 属性。
- en: Update the aggregate.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新聚合。
- en: Save all changes.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有更改。
- en: Close the transaction.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭事务。
- en: The transaction duration would be unacceptably long since the transaction should
    be maintained for the time of various database commands – namely, from the initial
    read to the final update – thus, preventing other requests from accessing the
    involved tables/records for too long a time.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 事务持续时间将是不可以接受的，因为事务应该保持各种数据库命令的时间——即从初始读取到最后更新——从而防止其他请求在太长时间内访问涉及的表/记录。
- en: 'On the contrary, by using the `ConcurrencyCheck` attribute, we open just a
    very short single-command transaction when the aggregate is saved to the database:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，通过使用`ConcurrencyCheck`属性，当聚合保存到数据库时，我们只打开一个非常短的单命令事务：
- en: Read the interested aggregate.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读感兴趣的聚合。
- en: Increment the value of the `EntityVersion` property.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加实体版本`EntityVersion`属性的值。
- en: Update the aggregate.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新聚合。
- en: Save all changes with a fast single-command transaction.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用快速的单命令事务保存所有更改。
- en: 'It is worth analyzing the code of the `Package` entity:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分析`Package`实体的代码：
- en: '[PRE54]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `FullUpdate` method is the only way to update the `IPackage` aggregate.
    When the price changes, add `PackagePriceChangedEvent` to the entity list of events.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`FullUpdate`方法是更新`IPackage`聚合的唯一方式。当价格变化时，将`PackagePriceChangedEvent`添加到实体事件列表中。'
- en: 'The `MainDBContext.cs` file contains the database context definition. It doesn’t
    inherit from `DbContext` but from the following predefined context class:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainDBContext.cs`文件包含数据库上下文定义。它不继承自`DbContext`，而是继承自以下预定义的上下文类：'
- en: '[PRE55]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This context defines the user’s tables needed for the authentication. In our
    case, we opted for the `IdentityUser<T>` standard and `IdentityRole<S>` for users
    and roles, respectively, and used integers for both the `T` and `S` entity keys.
    However, we may also use classes that inherit from `IdentityUser` and `IdentityRole`
    and then add further properties.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 此上下文定义了用于身份验证的用户所需表。在我们的案例中，我们选择了`IdentityUser<T>`标准以及`IdentityRole<S>`用于用户和角色，并且对于`T`和`S`实体键都使用了整数。然而，我们也可以使用继承自`IdentityUser`和`IdentityRole`的类，然后添加更多属性。
- en: In the `OnModelCreating` method, we must call `base.OnModelCreating(builder)`
    in order to apply the configuration defined in `IdentityDbContext`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnModelCreating`方法中，我们必须调用`base.OnModelCreating(builder)`以便应用在`IdentityDbContext`中定义的配置。
- en: '`MainDBContext` implements `IUnitOfWork`. The following code shows the implementation
    of all methods that start, roll back, and commit a transaction:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainDBContext`实现了`IUnitOfWork`。以下代码显示了开始、回滚和提交事务的所有方法的实现：'
- en: '[PRE56]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: However, they are rarely used by command classes in a distributed environment.
    This is because retrying the same operation until no concurrency exception is
    returned usually ensures better performance than transactions.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在分布式环境中，它们很少被命令类使用。这是因为重复执行相同的操作直到没有返回并发异常通常比事务有更好的性能。
- en: 'It is worth analyzing the implementation of the method that passes all changes
    applied to `DbContext` to the database:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分析将所有应用到`DbContext`的更改传递到数据库的方法的实现：
- en: '[PRE57]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The preceding implementation just calls the `SaveChangesAsync` `DbContext` context
    method, which saves all changes to the database, but then it intercepts all concurrency
    exceptions and detaches all the entities involved in the concurrency error from
    the context. This way, the next time a command retries the whole failed operation,
    their updated versions will be reloaded from the database.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现只是调用`SaveChangesAsync` `DbContext`上下文方法，该方法将所有更改保存到数据库，但随后它拦截所有并发异常，并将所有涉及并发错误的实体从上下文中分离。这样，下次命令重试整个失败操作时，它们的更新版本将重新从数据库中加载。
- en: 'The `Repositories` folder contains all repository implementations. It is worth
    analyzing the implementation of the `IPackageRepository.Delete` method:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repositories`文件夹包含所有仓库实现。值得分析`IPackageRepository.Delete`方法的实现：'
- en: '[PRE58]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It reads the entity from the database and formally removes it from the `Packages`
    dataset. This will force the entity to be deleted from the database when changes
    are saved to the database. Moreover, it adds `PackageDeleteEvent` to the aggregate
    list of events.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 它从数据库中读取实体，并正式将其从`Packages`数据集中删除。这将迫使实体在更改保存到数据库时从数据库中删除。此外，它将`PackageDeleteEvent`添加到聚合事件列表中。
- en: The `Extensions` folder contains the `DBExtensions` static class, which, in
    turn, defines two extension methods to be added to the application DI engine and
    the ASP.NET Core pipeline, respectively. Once added to the pipeline, these two
    methods will connect the database layer to the application layer.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`Extensions`文件夹包含`DBExtensions`静态类，它反过来定义了两个扩展方法，分别用于添加到应用程序DI引擎和ASP.NET Core管道中。一旦添加到管道中，这两个方法将数据库层与应用程序层连接起来。'
- en: 'The `IServiceCollection` extension of `AddDbLayer` accepts (as its input parameters)
    the database connection string and the name of the `.dll` file that contains all
    migrations. Then, it does the following:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDbLayer`的`IServiceCollection`扩展接受（作为其输入参数）数据库连接字符串和包含所有迁移的`.dll`文件的名称。然后，它执行以下操作：'
- en: '[PRE59]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That is, it adds the database context to the DI engine and defines its options
    – namely, that it uses SQL Server, the database connection string, and the name
    of the `.dll` file that contains all migrations.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 即，它将数据库上下文添加到 DI 引擎中，并定义其选项——即它使用 SQL Server、数据库连接字符串以及包含所有迁移的 `.dll` 文件名称。
- en: 'Then, it does the following:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它执行以下操作：
- en: '[PRE60]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That is, it adds and configures all the types needed to handle database-based
    authentication and authorization. It adds `UserManager`, which the application
    layer can use to manage users. `AddDefaultTokenProviders` adds the provider that
    creates the authentication tokens using data contained in the database when users
    log in.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 即，它添加并配置了处理基于数据库的认证和授权所需的所有类型。它添加了 `UserManager`，应用程序层可以使用它来管理用户。`AddDefaultTokenProviders`
    添加了在用户登录时使用数据库中包含的数据创建认证令牌的提供者。
- en: Finally, it discovers and adds to the DI engine all repository implementations
    by calling the `AddAllRepositories` method, which is defined in the DDD tools
    we added to the domain layer project.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它通过调用定义在添加到领域层项目的 DDD 工具中的 `AddAllRepositories` 方法，发现并添加所有仓库实现到 DI 引擎中。
- en: The `UseDBLayer` extension method ensures migrations are applied to the database
    by calling `context.Database.Migrate()`, and then it populates the database with
    some initial objects. In our case, it uses `RoleManager` and `UserManager` to
    create an administrative role and an initial administrator, respectively. Then,
    it creates some sample destinations and packages.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseDBLayer` 扩展方法通过调用 `context.Database.Migrate()` 确保迁移应用到数据库中，然后它用一些初始对象填充数据库。在我们的例子中，它使用
    `RoleManager` 和 `UserManager` 分别创建一个管理角色和初始管理员。然后，它创建一些示例目的地和包。'
- en: '`context.Database.Migrate()` is useful to quickly set up and update staging
    and test environments. When deploying in production, if we don’t have the credentials
    for creating a new database or for modifying its structure, we can also produce
    an SQL script from the migrations using the migration tools. Then, this script
    should be examined before being applied by the person in charge of maintaining
    the database and, finally, applied with their credentials.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.Database.Migrate()` 对于快速设置和更新预发布和测试环境非常有用。在生产环境中部署时，如果我们没有创建新数据库或修改其结构的凭据，我们还可以使用迁移工具从迁移中生成一个
    SQL 脚本。然后，在应用之前，应由负责维护数据库的人员检查此脚本，并最终使用其凭据应用。'
- en: 'To create migrations, we must add the aforementioned extension methods to the
    ASP.NET Core MVC `Program.cs` file, as shown here:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建迁移，我们必须将前面提到的扩展方法添加到 ASP.NET Core MVC 的 `Program.cs` 文件中，如下所示：
- en: '[PRE61]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Please be sure that both the authorization and authentication middleware have
    been added to the ASP.NET Core pipeline in the right order; otherwise, the authentication/authorization
    engine will not work.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保已按正确顺序将授权和身份验证中间件添加到 ASP.NET Core 管道中；否则，身份验证/授权引擎将无法工作。
- en: 'Then, we must add the connection string to the `appsettings.json` file, as
    shown here:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将连接字符串添加到 `appsettings.json` 文件中，如下所示：
- en: '[PRE62]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Finally, let’s add `Microsoft.EntityFrameworkCore.Design` to the ASP.NET Core
    project.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将 `Microsoft.EntityFrameworkCore.Design` 添加到 ASP.NET Core 项目中。
- en: 'At this point, let’s open the Visual Studio Package Manager Console, select
    `PackageManagementDB` as the default project, and then launch the following command:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开 Visual Studio 的包管理器控制台，将 `PackageManagementDB` 设置为默认项目，然后运行以下命令：
- en: '[PRE63]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The preceding command will scaffold the first migration. We may apply it to
    the database with the `Update-Database` command. Please note that if you copy
    the project from GitHub, you don’t need to scaffold migrations since they have
    already been created, but you still need to update the database.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将生成第一个迁移。我们可以使用 `Update-Database` 命令将其应用到数据库中。请注意，如果您从 GitHub 复制项目，由于迁移已经创建，因此不需要生成迁移，但您仍然需要更新数据库。
- en: In the next subsection, we will define the application layer that contains the
    business logic for manipulating the aggregates.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将定义包含操作聚合体的业务逻辑的应用程序层。
- en: Defining the application layer
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义应用程序层
- en: 'As a first step, for simplicity, let’s freeze the application culture to `en-US`
    by adding the following code to the ASP.NET Core pipeline:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，为了简单起见，让我们通过向 ASP.NET Core 管道中添加以下代码将应用程序文化冻结为 `en-US`：
- en: '[PRE64]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, let’s create a `Tools` folder and place the `ApplicationLayer` code there,
    which you can find in the `ch11` code of the GitHub repository associated with
    this book. With these tools in place, we can add the code that automatically discovers
    and adds all queries, command handlers, and event handlers to the DI engine, as
    shown here:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个 `Tools` 文件夹，并将 `ApplicationLayer` 代码放在那里，这些代码可以在与本书相关的 GitHub 仓库的
    `ch11` 代码中找到。有了这些工具，我们可以添加代码，自动发现并添加所有查询、命令处理器和事件处理器到 DI 引擎中，如下所示：
- en: '[PRE65]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, we must add a `Queries` folder to place all queries and their associated
    interfaces. As an example, let’s have a look at the query that lists all packages:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须添加一个 `Queries` 文件夹来放置所有查询及其相关接口。例如，让我们看看列出所有包的查询：
- en: '[PRE66]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The query object is automatically injected into the application DB context.
    The `GetAllPackages` method uses LINQ to project all of the required information
    into `PackageInfosViewModel` and sorts all results in descending order on the
    `EndValidityDate` property.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 查询对象自动注入到应用程序 DB 上下文中。`GetAllPackages` 方法使用 LINQ 将所有必需的信息投影到 `PackageInfosViewModel`
    中，并按 `EndValidityDate` 属性降序排序所有结果。
- en: Projections that involve several properties are time-wasting and error-prone;
    that’s why there are mapping libraries that automatically generate these projections
    using naming conventions and configuration settings. Mapping libraries helps also
    in copying data from one object to another, such as, for example, from a ViewModel
    to a DTO, and vice versa.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及多个属性的投影是耗时且容易出错的；这就是为什么有映射库可以自动使用命名约定和配置设置来生成这些投影。映射库还有助于在对象之间复制数据，例如，例如，从
    ViewModel 到 DTO，反之亦然。
- en: Among all mapping software, it is worth at least mentioning AutoMapper ([https://www.nuget.org/packages/AutoMapper](https://www.nuget.org/packages/AutoMapper)).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有映射软件中，至少值得提一下 AutoMapper ([https://www.nuget.org/packages/AutoMapper](https://www.nuget.org/packages/AutoMapper))。
- en: '`PackageInfosViewModel` is placed in the `Models` folder together with all
    other ViewModels. It is common practice to organize ViewModels into folders by
    defining a different folder for each controller. It is worth analyzing the ViewModel
    used for editing packages:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '`PackageInfosViewModel` 与所有其他 ViewModel 一起放在 `Models` 文件夹中。将 ViewModel 按控制器定义不同的文件夹进行组织是一种常见的做法。值得分析用于编辑包的
    ViewModel：'
- en: '[PRE67]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It has a constructor that accepts an `IPackage` aggregate. This way, package
    data is copied into the ViewModel that is used to populate the edit view. It implements
    the `IPackageFullEditDTO` DTO interface defined in the domain layer. This way,
    it can be directly used to send `IPackage` updates to the domain layer.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个接受一个 `IPackage` 聚合的构造函数。这样，包数据就被复制到用于填充编辑视图的 ViewModel 中。它实现了在领域层定义的 `IPackageFullEditDTO`
    DTO 接口。这样，它可以直接用于向领域层发送 `IPackage` 更新。
- en: 'All properties contain validation attributes that are automatically used by
    client-side and server-side validation engines. Each property contains a `Display`
    attribute that defines the label to give to the input field that will be used
    to edit the property. It is better to place the field labels in the ViewModels
    than it is to place them directly into the views since, this way, the same names
    are automatically used in all views that use the same ViewModel. The following
    code block lists all its properties:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属性都包含客户端和服务器端验证引擎自动使用的验证属性。每个属性都包含一个 `Display` 属性，它定义了用于编辑属性的输入字段的标签。将字段标签放在
    ViewModel 中比直接放在视图中更好，因为这样，相同的名称会自动在所有使用相同 ViewModel 的视图中使用。以下代码块列出了所有属性：
- en: '[PRE68]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `Commands` folder contains all commands. As an example, let’s have a look
    at the command used to modify packages:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '`Commands` 文件夹包含所有命令。例如，让我们看看用于修改包的命令：'
- en: '[PRE69]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Its constructor must be invoked with an implementation of the `IPackageFullEditDTO`
    DTO interface, which, in our case, is the edit ViewModel we described previously.
    Command handlers are placed in the `Handlers` folder. It is worth analyzing the
    command that updates packages:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 它的构造函数必须使用 `IPackageFullEditDTO` DTO 接口的实现来调用，在我们的例子中，是之前描述的编辑 ViewModel。命令处理器放在
    `Handlers` 文件夹中。值得分析更新包的命令：
- en: '[PRE70]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Its principal constructor has automatically injected the `IPackageRepository`
    repository and an `IEventMediator` instance needed to trigger event handlers.
    The following code also shows the implementation of the standard `HandleAsync`
    command handler method:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要构造函数已自动注入 `IPackageRepository` 仓库和一个 `IEventMediator` 实例，用于触发事件处理器。以下代码还显示了标准
    `HandleAsync` 命令处理器方法的实现：
- en: '[PRE71]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`HandleAsync` uses the repository to get an instance of the entity to modify.
    If the entity is not found (it has been deleted), the commands stop its execution.
    Otherwise, all changes are passed to the retrieved aggregate. Immediately after
    the update, all events contained in the aggregate are triggered. In particular,
    if the price has changed, the event handler associated with the price change is
    executed. The concurrency check declared with the `[ConcurrencyCheck]` attribute
    on the `EntityVersion` property of the `Package` entity ensures that the package
    version is updated properly (by incrementing its previous version number by 1),
    as well as that the price-changed event is passed the right version numbers.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleAsync` 使用仓库来获取要修改的实体实例。如果实体未找到（已被删除），则停止执行命令。否则，所有更改都传递给检索到的聚合。更新后，立即触发聚合中包含的所有事件。特别是，如果价格已更改，则执行与价格变更相关的事件处理器。在
    `Package` 实体的 `EntityVersion` 属性上声明的 `[ConcurrencyCheck]` 属性确保正确更新包版本（通过将其前一个版本号增加
    1），以及将正确的版本号传递给价格变更事件。'
- en: 'Also, event handlers are placed in the `Handlers` folder. As an example, let’s
    have a look at the price-changed event handler:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，事件处理器放在 `Handlers` 文件夹中。以下是一个示例，让我们看看价格变更事件处理器：
- en: '[PRE72]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The principal constructor has automatically injected the `IPackageEventRepository`
    repository, which handles the database table and all the events to send to other
    applications. The `HandleAsync` implementation simply calls the repository method,
    which adds a new `IPackageEvent` to a queue of events to be sent to other microservices.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 主要构造函数已自动注入 `IPackageEventRepository` 仓库，该仓库处理数据库表以及要发送到其他应用程序的所有事件。`HandleAsync`
    实现简单地调用仓库方法，将新的 `IPackageEvent` 添加到要发送到其他微服务的队列中。
- en: The `IPackageEvent` records should be extracted by the above queue and sent
    to all interested microservices by a parallel task, which is not implemented in
    the GitHub code associated with this section. It can be implemented as a hosted
    service (thus inheriting from the `BackgroundService` class) and then added to
    the DI engine with a call such as `builder.Services.AddHostedService<MyHostedService>()`,
    as detailed in the *Using generic hosts* subsection of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPackageEvent` 记录应由上述队列提取，并通过一个并行任务发送给所有感兴趣的微服务，但与该部分相关的 GitHub 代码中尚未实现这一点。它可以作为一个托管服务（从而继承自
    `BackgroundService` 类）来实现，然后通过调用例如 `builder.Services.AddHostedService<MyHostedService>()`
    来将其添加到 DI 引擎中，具体细节请参考第 11 章 *将微服务架构应用于您的企业应用程序* 中的 *使用通用宿主* 子节。'
- en: We are almost finished! Just the presentation layer is missing, which, in the
    case of an MVC-based application, consists of controllers and views. The next
    subsection defines both controllers and views needed by our microservice.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！只是缺少表示层，在基于 MVC 的应用程序中，这包括控制器和视图。下一个子节定义了我们微服务所需的控制器和视图。
- en: Defining controllers and views
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义控制器和视图
- en: We need to add two more controllers to the one automatically scaffolded by Visual
    Studio – namely, `AccountController`, which takes care of user login/logout and
    registration, and `ManagePackageController`, which handles all package-related
    operations. It is enough to right-click on the `Controllers` folder and then select
    **Add | Controller**. Then, choose the controller name and select the empty MVC
    controller to avoid the possibility of Visual Studio scaffolding code you don’t
    need.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 Visual Studio 自动生成的控制器中添加两个额外的控制器——即 `AccountController`，负责用户登录/注销和注册，以及
    `ManagePackageController`，处理所有与包相关的操作。只需在 `Controllers` 文件夹上右键单击，然后选择 **添加 | 控制器**。然后，选择控制器名称，并选择空
    MVC 控制器以避免 Visual Studio 生成您不需要的代码。
- en: '![](img/B19820_21_27.png)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_21_27.png)'
- en: 'Figure 21.27: Adding AccountController'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.27：添加 AccountController
- en: 'It is worth pointing out that Visual Studio can automatically scaffold all
    of the UI for managing users if one selects to automatically add authentication
    when the MVC project is created. However, scaffolded code doesn’t respect any
    layer or onions architecture: it inserts everything in the MVC project. That’s
    why we decided to proceed manually.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，如果在一个创建MVC项目时选择自动添加身份验证，Visual Studio可以自动生成所有用于管理用户的UI。然而，生成的代码不尊重任何层或洋葱架构：它将所有内容插入到MVC项目中。这就是我们决定手动操作的原因。
- en: For simplicity, our implementation of `AccountController` just has login and
    logout methods, so you can log in just with the initial administrator user. However,
    you can add further action methods that use the `UserManager` class to define,
    update, and delete users.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们的`AccountController`实现仅包含登录和注销方法，因此您只需使用初始管理员用户即可登录。然而，您可以添加进一步的动作方法，这些方法使用`UserManager`类来定义、更新和删除用户。
- en: '![](img/B19820_21_28.png)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![图21.28](img/B19820_21_28.png)'
- en: 'Figure 21.28: Login, logout, and authentication'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.28：登录、注销和身份验证
- en: 'The `UserManager` class can be provided through DI, as shown here:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserManager`类可以通过DI提供，如下所示：'
- en: '[PRE73]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`SignInManager` takes care of login/logout operations. The `Logout` action
    method is quite simple and is shown here (for more information on authentication
    in ASP.NET Core, please refer to the *Defining the ASP.NET Core pipeline* section
    of *Chapter 17*, *Presenting ASP.NET Core*):'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignInManager`负责登录/注销操作。`Logout`动作方法相当简单，如下所示（有关ASP.NET Core中身份验证的更多信息，请参阅第17章“展示ASP.NET
    Core”中的*定义ASP.NET Core管道*部分）：'
- en: '[PRE74]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: It just calls the `signInManager.SignOutAsync` method and then redirects the
    browser to the home page. To avoid it being called by clicking a link, it is decorated
    with `HttpPost`, so it can only be invoked via a form submit.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是调用`signInManager.SignOutAsync`方法，然后将浏览器重定向到主页。为了避免通过点击链接调用它，它被装饰了`HttpPost`，因此只能通过表单提交来调用。
- en: All requests that cause modifications must never use a `GET` verb; otherwise,
    someone might erroneously trigger those actions either by clicking a link or by
    writing the wrong URL in the browser. An action triggered by GET might also be
    exploited by a phishing website that might adequately “camouflage” a link that
    triggers a dangerous GET action. The GET verb should be used just for retrieving
    information.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 所有导致修改的请求绝不能使用`GET`动词；否则，有人可能会错误地通过点击链接或在浏览器中输入错误的URL来触发这些操作。由GET触发的动作也可能被钓鱼网站利用，该网站可能会充分“伪装”一个触发危险GET动作的链接。GET动词应仅用于检索信息。
- en: 'Login, on the other hand, requires two action methods. The first one is invoked
    via `GET` and shows the login form, where the user must place their username and
    password. It is shown here:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，登录需要两个动作方法。第一个是通过`GET`调用的，显示登录表单，用户必须在此处输入用户名和密码。如下所示：
- en: '[PRE75]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: It receives `returnUrl` as its parameter when the browser is automatically redirected
    to the login page by the authorization module. This happens when an unlogged-in
    user tries to access a protected page. `returnUrl` is stored in the `ViewState`
    dictionary that is passed to the login view.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器被授权模块自动重定向到登录页面时，它接收`returnUrl`作为其参数。这种情况发生在未登录的用户尝试访问受保护页面时。`returnUrl`存储在传递给登录视图的`ViewState`字典中。
- en: 'The form in the login view passes it back to the controller, together with
    the username and password when it is submitted, as shown in this code:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 登录视图中的表单在提交时将其连同用户名和密码一起传递给控制器，如下所示：
- en: '[PRE76]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The form post is intercepted by an action method with the same `Login` name
    but decorated with the `[HttpPost]` attribute, as shown here:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 表单提交被具有相同`Login`名称但带有`[HttpPost]`属性的action方法拦截，如下所示：
- en: '[PRE77]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The preceding method receives the `Login` model used by the login view, together
    with the `returnUrl` query string parameter. The `ValidateAntiForgeryToken` attribute
    verifies a token (called an anti-forgery token) that MVC forms automatically.
    This is then added to a hidden field to prevent XSRF/CSRF attacks.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法接收登录视图使用的`Login`模型，以及`returnUrl`查询字符串参数。`ValidateAntiForgeryToken`属性验证一个令牌（称为反伪造令牌），这是MVC表单自动完成的。然后将其添加到隐藏字段中，以防止XSRF/CSRF攻击。
- en: 'Forgery attacks exploit authentication cookies stored in the victim’s browser
    to submit a legitimate authenticated request to a web application. They do this
    by inducing the user to click a button on a phishing website that causes a submit
    to the target web application. The fraudulent request is accepted since, once
    a form is submitted, the authentication cookies for the target URL are automatically
    sent by the browser. There are just two defenses against this kind of attack:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 伪造攻击利用存储在受害者浏览器中的身份验证cookie来向Web应用程序提交合法的已认证请求。他们通过诱导用户点击钓鱼网站上的按钮来实现这一点，该按钮导致向目标Web应用程序提交。由于一旦表单提交，浏览器就会自动发送目标URL的身份验证cookie，因此欺诈请求被接受。对此类攻击有两种防御措施：
- en: Authentication cookies are defined as same-origin – that is, they are sent from
    other domains just in case of GET requests. Thus, when a form is submitted from
    a phishing website to the target application, they are not sent.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证cookie被定义为同源——也就是说，只有在GET请求的情况下才从其他域发送。因此，当表单从钓鱼网站提交到目标应用程序时，它们不会被发送。
- en: Anti-forgery tokens added to forms. In this case, if authentication cookies
    are sent together with the submitted form, the application understands that the
    request comes from a different website and blocks it since it is missing a valid
    anti-forgery token.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单中添加了反伪造令牌。在这种情况下，如果与提交的表单一起发送身份验证cookie，应用程序会理解请求来自不同的网站，并由于缺少有效的反伪造令牌而阻止它。
- en: 'As a first step, the action method logs the user out if they are already logged
    in:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，如果用户已经登录，操作方法会注销用户：
- en: '[PRE78]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Otherwise, it verifies whether there are validation errors, in which case,
    it shows the same view filled with the data of the ViewModel to let the user correct
    their errors:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它会验证是否存在验证错误，如果是的话，它会显示同一个视图，并用 ViewModel 的数据填充，让用户纠正错误：
- en: '[PRE79]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If the model is valid, `signInManager` is used to log the user in:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型有效，`signInManager` 用于登录用户：
- en: '[PRE80]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If the result returned by the operation is successful, the action method redirects
    the browser to `returnUrl` if it’s not null; otherwise, it redirects the browser
    to the home page:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作返回的结果是成功的，操作方法会在 `returnUrl` 不为空的情况下将浏览器重定向到 `returnUrl`；否则，它将浏览器重定向到主页：
- en: '[PRE81]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If the login fails, it adds an error to `ModelState` and shows the same form
    to let the user try again.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录失败，它会在 `ModelState` 中添加一个错误，并显示相同的表单让用户再次尝试。
- en: '`ManagePackagesController` contains an `Index` method that shows all packages
    in table format (for more details on controllers, views, and the MVC pattern in
    general, please refer to the *The MVC pattern* section of *Chapter 17*, *Presenting
    ASP.NET Core*):'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagePackagesController` 包含一个 `Index` 方法，该方法以表格格式显示所有包（有关控制器、视图以及一般 MVC 模式的更多详细信息，请参阅第17章“展示
    ASP.NET Core”中的 *MVC 模式* 部分）：'
- en: '[PRE82]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The query object is injected into the action method by DI. Then, the action
    method invokes it and inserts the resulting `IEnumerable` into the `Items` property
    of a `PackagesListViewModel` instance. It is a good practice to include `IEnumerables`
    in ViewModels instead of passing them directly to the views so that, if necessary,
    other properties can be added without the need to modify the existing view code.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 查询对象通过依赖注入（DI）注入到操作方法中。然后，操作方法调用它并将结果 `IEnumerable` 插入到 `PackagesListViewModel`
    实例的 `Items` 属性中。在 ViewModels 中包含 `IEnumerable` 而不是直接传递给视图是一种良好的实践，这样，如果需要，可以添加其他属性而无需修改现有的视图代码。
- en: 'Moreover, it is good practice to define enumerable properties of ViewModels
    as `IReadOnlyCollection<T>` if the enumerables are read-only or as `IList<T>`
    if the enumerables can be modified or if they are involved in model binding. In
    fact, `ICollection<T>` has a `Count` property, which may be very useful when rendering
    ViewModels in views, while `IList<T`> also has indexers that are necessary for
    rendering all items with appropriate names for model binding to succeed (see this
    Phil Haack post: [http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx](http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx)).
    `IEnumerable<T>` should be preferred only in the case that one needs the typical
    lazy evaluation of `IEnumerable<T>.`'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果 `IEnumerable` 是只读的，则将 ViewModels 的可枚举属性定义为 `IReadOnlyCollection<T>`；如果可枚举可以修改或涉及模型绑定，则定义为
    `IList<T>`。实际上，`ICollection<T>` 有一个 `Count` 属性，这在渲染视图中的 ViewModels 时可能非常有用，而 `IList<T>`
    也具有索引器，这对于成功进行模型绑定是必要的（参见 Phil Haack 的这篇帖子：[http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx](http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx)）。只有在需要
    `IEnumerable<T>` 的典型延迟评估时才应首选 `IEnumerable<T>`。
- en: The results are shown in a Bootstrap table since Bootstrap CSS is automatically
    scaffolded by Visual Studio. Bootstrap is a good choice for a CSS framework, since
    it is quite simple and extensible, and is not connected to any particular company
    but is handled by an independent team.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在Bootstrap表格中，因为Bootstrap CSS是由Visual Studio自动构建的。Bootstrap是一个好的CSS框架选择，因为它相当简单且可扩展，并且与任何特定公司无关，而是由一个独立团队处理。
- en: 'The result is shown here:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19820_21_29.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B19820_21_29.png)'
- en: 'Figure 21.29: Application packages handling page'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.29：应用程序包处理页面
- en: The **New package** link (it is shaped like a **Bootstrap** button, but it is
    a link) invokes a controller `Create` action method, while the **delete** and
    **edit** links in each row invoke a `Delete` and `Edit` action method, respectively,
    and pass them the ID of the package shown in the row.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '**新包**链接（它的形状类似于**Bootstrap**按钮，但它是一个链接）调用控制器`Create`动作方法，而每一行中的**删除**和**编辑**链接分别调用`Delete`和`Edit`动作方法，并将显示在行中的包的ID传递给它们。'
- en: 'Here is the implementation of the two row links:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两个行链接的实现：
- en: '[PRE83]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'It is worth describing the code of the `HttpGet` and `HttpPost` `Edit` action
    methods:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 值得描述的是`HttpGet`和`HttpPost`的`Edit`动作方法的代码：
- en: '[PRE84]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `Edit` method of `HttpGet` uses `IPackageRepository` to retrieve the existing
    package. If the package is not found, that means it has been deleted by some other
    user, and the browser is redirected again to the list page to show the updated
    list of packages. Otherwise, the aggregate is passed to the `PackageFullEditViewModel`
    ViewModel, which is rendered by the `Edit` view.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpGet`的`Edit`方法使用`IPackageRepository`检索现有包。如果找不到包，这意味着它已被其他用户删除，浏览器将再次重定向到列表页面以显示更新的包列表。否则，聚合传递给`PackageFullEditViewModel`视图模型，该模型由`Edit`视图渲染。'
- en: 'The view used to render the package must render an HTML `select` with all possible
    package destinations, so it needs an instance of the `IDestinationListQuery` query
    that was implemented to assist with the destination selection HTML logic. This
    query is injected directly into the view since it is the view’s responsibility
    to decide how to enable the user to select a destination. The code that injects
    the query and uses it is shown here:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 用于渲染包的视图必须渲染一个包含所有可能的包目的地的HTML `select`，因此它需要一个`IDestinationListQuery`查询的实例，该查询是为了辅助目的选择HTML逻辑而实现的。该查询直接注入到视图中，因为它是由视图负责决定如何使用户能够选择目的地。注入查询并使用它的代码如下所示：
- en: '[PRE85]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The action method that processes the post of the view form is given here:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 处理视图表单POST的动作方法如下所示：
- en: '[PRE86]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If `ModelState` is valid, `UpdatePackageCommand` is created and its associated
    handler is invoked; otherwise, the View is displayed again to the user to enable
    them to correct all the errors.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ModelState`有效，则创建`UpdatePackageCommand`并调用其相关处理程序；否则，视图将再次显示给用户，以便他们能够纠正所有错误。
- en: 'The new links to the package list page and login page must be added to the
    main menu, which is in the `_Layout` view, as shown here:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 必须将指向包列表页面和登录页面的新链接添加到主菜单中，该菜单位于`_Layout`视图中，如下所示：
- en: '[PRE87]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`logoutForm` is an empty form whose only purpose is to send a post to the `Logout`
    action method. It has been added to the end of the body, as shown here:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`logoutForm`是一个空表单，它的唯一目的是向`Logout`动作方法发送一个POST请求。它已被添加到页面的末尾，如下所示：'
- en: '[PRE88]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now, the application is ready! You can run it, log in, and start to manage packages.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序已经准备好了！你可以运行它，登录，并开始管理包。
- en: After having learned how to implement, in practice, a presentation layer with
    server-side technologies in this section, we now just need to learn how to implement
    it also with client-side technologies. We will do this in the next section.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用服务器端技术实现表示层，现在我们只需要学习如何使用客户端技术实现它。我们将在下一节中这样做。
- en: Using client technologies
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用客户端技术
- en: In this section, we will implement a package search application for the WWTravelClub
    book use case. The first subsection explains how to set up the solution exploiting
    the domain layer and data layer of the MVC application we implemented in the previous
    section of this chapter.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个针对WWTravelClub书籍用例的包搜索应用程序。下一小节解释了如何利用我们在本章前一小节中实现的MVC应用程序的领域层和数据层来设置解决方案。
- en: Preparing the solution
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备解决方案
- en: We will modify the `PackagesManagement` project both to save coding time and
    to show how to transform a solution based on server-side MVC technology into a
    solution based on the Blazor client-side technology.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改 `PackagesManagement` 项目，以节省编码时间并展示如何将基于服务器端 MVC 技术的解决方案转换为基于 Blazor 客户端技术的解决方案。
- en: First of all, create a copy of the `PackagesManagement` solution folder we created
    in the previous section and rename it `PackagesManagementBlazor`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，复制我们在上一节创建的 `PackagesManagement` 解决方案文件夹，并将其重命名为 `PackagesManagementBlazor`。
- en: To open the solution, right-click on the web project (the one named `PackagesManagement`)
    and remove it (the `Remove` menu item). Then, go to the solution folder and delete
    the whole web project folder (the one named `PackagesManagement`).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开解决方案，右键单击网页项目（命名为 `PackagesManagement` 的项目）并移除它（选择 `Remove` 菜单项）。然后，转到解决方案文件夹并删除整个网页项目文件夹（命名为
    `PackagesManagement`）。
- en: Now, right-click on the solution and select **Add New Project**. Add a new **Blazor
    WebAssembly Standalone App** project called `PackagesManagementBlazor.Client`.
    Select **None** for the authentication type, **Configure for https**, and **Include
    Sample Pages**. We don’t need authentication since the search-by-location feature
    we are going to implement must also be available to unregistered users.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，右键单击解决方案并选择 **添加新项目**。添加一个名为 `PackagesManagementBlazor.Client` 的新 **Blazor
    WebAssembly 独立应用程序**项目。对于身份验证类型选择 **None**，**配置为 https**，并 **包含示例页面**。由于我们将要实现的位置搜索功能必须对未注册用户也可用，所以我们不需要身份验证。
- en: Now, add a `PackagesManagementBlazor.Server` **ASP.NET Core Web API** project.
    Select **None** for the authentication type, **Configure for https**, **Enable
    OpenAPI Support**, and **Use Controllers**.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个 `PackagesManagementBlazor.Server` **ASP.NET Core Web API** 项目。对于身份验证类型选择
    **None**，**配置为 https**，**启用 OpenAPI 支持**，和 **使用控制器**。
- en: Finally, add a `PackagesManagementBlazor.Shared` **Class Library** project,
    delete the default `Class1` class created by Visual Studio, and add this project
    to both `PackagesManagementBlazor.Client` and `PackagesManagementBlazor.Server`
    as reference.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个 `PackagesManagementBlazor.Shared` **类库**项目，删除 Visual Studio 创建的默认 `Class1`
    类，并将此项目添加到 `PackagesManagementBlazor.Client` 和 `PackagesManagementBlazor.Server`
    中作为引用。
- en: The server project needs to reference both the domain implementation (`PackagesManagementDB`)
    and the domain abstraction (`PackagesManagementDomain`) projects, so please add
    them as references.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器项目需要引用域实现（`PackagesManagementDB`）和域抽象（`PackagesManagementDomain`）项目，所以请将它们添加为引用。
- en: Both `PackagesManagementBlazor.Client` and `PackagesManagementBlazor.Server`
    must start simultaneously, so define them as starting projects by right-clicking
    on the solutions, selecting **Configure Startup Projects**, and choosing them
    as startup projects.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '`PackagesManagementBlazor.Client` 和 `PackagesManagementBlazor.Server` 必须同时启动，所以通过右键单击解决方案，选择
    **配置启动项目**，并将它们定义为启动项目。'
- en: Now, launch the solution to verify that everything works properly. Two browser
    windows should open, one for testing the REST API project and the other containing
    a Blazor application.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动解决方案以验证一切是否正常工作。应该打开两个浏览器窗口，一个用于测试 REST API 项目，另一个包含一个 Blazor 应用程序。
- en: Take note of the Blazor application URL (`https://localhost:7027/` in my case)
    since we will need it.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 Blazor 应用程序的 URL（在我的情况下是 `https://localhost:7027/`），因为我们将会用到它。
- en: The Blazor website will exchange data with the REST API website, which runs
    on a different domain (a domain is identified by both hostname and port number).
    REST API calls coming from browsers running on different domains are clues of
    potential phishing attacks; therefore, the receiving server only accepts them
    if they come from well-known domains (this way, they are sure they don’t come
    from phishing websites).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 网站将与运行在不同域上的 REST API 网站交换数据（域由主机名和端口号共同标识）。来自运行在不同域上的浏览器的 REST API 调用是潜在钓鱼攻击的线索；因此，接收服务器只接受来自知名域的请求（这样，它们可以确信这些请求不是来自钓鱼网站）。
- en: On the other hand, when a browser application tries to communicate with a different
    URL, the browser detects it and issues the call with a different protocol called
    CORS. Therefore, as soon as it detects the CORS protocol, the receiving server
    understands it is dealing with a request coming from a different website, and
    serves the request only if the other domain has been registered with a so-called
    CORS policy.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当浏览器应用程序尝试与不同的 URL 进行通信时，浏览器会检测到它，并以称为 CORS 的不同协议发出调用。因此，一旦它检测到 CORS 协议，接收服务器就会理解它正在处理来自不同网站的请求，并且只有在其他域已注册所谓的
    CORS 策略时才会服务该请求。
- en: In ASP.NET Core, CORS policies are registered with the `builder.Services.AddCors`
    extension method in `Program.cs`.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，CORS 策略通过 `Program.cs` 中的 `builder.Services.AddCors` 扩展方法注册。
- en: Therefore, in our case, we need to register a CORS policy for the domain of
    the `PackagesManagementBlazor.Client` web application in the `PackagesManagementBlazor.Server`
    web application, since all REST API calls of `PackagesManagementBlazor.Client`
    will be issued to `PackagesManagementBlazor.Server`.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下，我们需要在 `PackagesManagementBlazor.Server` 网页应用程序中为 `PackagesManagementBlazor.Client`
    网页应用程序的域注册 CORS 策略，因为 `PackagesManagementBlazor.Client` 的所有 REST API 调用都将发送到 `PackagesManagementBlazor.Server`。
- en: 'Accordingly, let’s open `Program.cs` of the `PackagesManagementBlazor.Server`
    project and enable it for CORS by adding this:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们打开 `PackagesManagementBlazor.Server` 项目的 `Program.cs`，并通过添加以下内容来启用 CORS：
- en: '[PRE89]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Also, add `app.UseCors();` in the ASP.NET Core pipeline, immediately before
    `app.UseAuthorization();` .
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `app.UseAuthorization();` 之前立即添加 `app.UseCors();` 到 ASP.NET Core 管道中。
- en: 'Now, we must enable the Blazor application to communicate with this server.
    Launch the solution again and take note of the REST API URL (in my case, `https://localhost:7269/`),
    and then replace the URL in the `HttpClient` configuration in the `Program.cs`
    file of the Blazor application with this URL:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须启用 Blazor 应用程序与该服务器进行通信。再次启动解决方案，并注意 REST API URL（在我的情况下，为 `https://localhost:7269/`），然后替换
    Blazor 应用程序的 `Program.cs` 文件中 `HttpClient` 配置中的 URL：
- en: '[PRE90]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Let’s also copy the same connection string of the old web project into the
    `PackagesManagementBlazor.Server` `appsettings.json` file:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也把旧网页项目的相同连接字符串复制到 `PackagesManagementBlazor.Server` 的 `appsettings.json`
    文件中：
- en: '[PRE91]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This way, we can reuse the database we have created. We also need to add the
    same DDD tools we added to the old web project. Add a folder named `Tools` in
    the project root and copy the contents of the `ch07` -> `ApplicationLayer` folder
    of the GitHub repository associated with the book there.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以重用我们创建的数据库。我们还需要添加与旧网页项目相同的 DDD 工具。在项目根目录中添加一个名为 `Tools` 的文件夹，并将 GitHub
    仓库中与书籍相关的 `ch07` -> `ApplicationLayer` 文件夹的内容复制到那里。
- en: 'In order to finish the solution setup, we just need to connect `PackagesManagementBlazor.Server`
    with the domain layer by adding the following code at the end of the services
    configuration code in the `Program.cs` file:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成解决方案设置，我们只需将 `PackagesManagementBlazor.Server` 与领域层连接起来，在 `Program.cs` 文件中服务配置代码的末尾添加以下代码：
- en: '[PRE92]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'It is the same method we added to the old web project. Finally, we can also
    add the `AddAllQueries` extension method, which discovers all queries in the web
    project:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们添加到旧网页项目中的相同方法。最后，我们还可以添加 `AddAllQueries` 扩展方法，该方法可以查找网页项目中的所有查询：
- en: '[PRE93]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We don’t need other automatic discovery tools since this is a query-only application.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个仅查询的应用程序，我们不需要其他自动发现工具。
- en: 'Due to a bug in Entity Framework Core 8, you also need to change a setting
    in the server project that prevents the usage of .NET culture. You must change
    the `InvariantGlobalization` project setting to `false`:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Entity Framework Core 8 中存在一个错误，您还需要在服务器项目中更改一个设置，以防止使用 .NET 文化。您必须将 `InvariantGlobalization`
    项目设置更改为 `false`：
- en: '[PRE94]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: At this point, we have the project completely configured. We just need to implement
    server-side code and client-side code that implements our package search.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完全配置了项目。我们只需实现服务器端代码和实现我们的包搜索的客户端代码。
- en: The next subsection explains how to design the server-side REST API.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节解释了如何设计服务器端 REST API。
- en: Implementing the required ASP.NET Core REST APIs
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现所需的 ASP.NET Core REST API
- en: As the first step, let’s define the ViewModels used in the communication between
    the server and the client applications. They must be defined in the `PackagesManagementBlazor.Shared`
    project that is referenced by both applications.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们定义服务器和客户端应用程序之间通信所使用的 ViewModels。它们必须在由两个应用程序引用的 `PackagesManagementBlazor.Shared`
    项目中定义。
- en: 'Let’s start with the `PackageInfosViewModel` ViewModel, which will be the data
    structure used by the Blazor application to exchange package info with the server-side
    REST API:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `PackageInfosViewModel` ViewModel 开始，它将是 Blazor 应用程序用来与服务器端 REST API 交换包信息的数据结构：
- en: '[PRE95]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Then, add the ViewModel that encloses all packages to return to the Blazor
    application:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加封装所有包的 ViewModel 以返回到 Blazor 应用程序：
- en: '[PRE96]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we can also add our query that searches packages by location. Let’s add
    a `Queries` folder in the root of the `PackagesManagementBlazor.Server` project
    and then add the interface that defines our query, `IPackagesListByLocationQuery`:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以添加我们的按位置搜索包的查询。让我们在 `PackagesManagementBlazor.Server` 项目的根目录中添加一个 `Queries`
    文件夹，然后添加定义我们的查询的接口，`IPackagesListByLocationQuery`：
- en: '[PRE97]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Finally, let’s also add the query implementation:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们也添加查询实现：
- en: '[PRE98]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We are finally ready to define our `PackagesController`:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好定义我们的 `PackagesController`：
- en: '[PRE99]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The server-side code is finished! Let’s move on to the definition of the Blazor
    service that communicates with the server.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端代码已完成！让我们继续定义与服务器通信的 Blazor 服务。
- en: Implementing the business logic in a service
  id: totrans-706
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务中实现业务逻辑
- en: 'Let’s add a `ViewModels` and a `Services` folder to the `PackagesManagementBlazor.Client`
    project. Most of the ViewModels we need were defined in the **PackagesManagementBlazor.Shared**
    project. We only need a ViewModel for the search form. Let’s add it to the `ViewModels`
    folder:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `PackagesManagementBlazor.Client` 项目中添加一个 `ViewModels` 和一个 `Services` 文件夹。我们需要的多数
    ViewModel 都在 **PackagesManagementBlazor.Shared** 项目中定义。我们只需要一个用于搜索表单的 ViewModel。让我们将其添加到
    `ViewModels` 文件夹中：
- en: '[PRE100]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Let’s call our service `PackagesClient`, and let’s add it to the `Services`
    folder:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的服务命名为 `PackagesClient`，并将其添加到 `Services` 文件夹中：
- en: '[PRE101]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The code is straightforward! The `Uri.EscapeDataString` method URL-encodes the
    parameter so it can be safely appended to the URL.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单！`Uri.EscapeDataString` 方法将参数进行 URL 编码，以便它可以安全地附加到 URL 上。
- en: 'Finally, let’s register the service in the dependency injection:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在依赖注入中注册服务：
- en: '[PRE102]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: It is worth pointing out that in a commercial application, we should have registered
    the service through an `IPackagesClient` interface in order to be able to mock
    it in the tests (`.AddScoped<IPackagesClient, PackagesClient>()`).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在一个商业应用程序中，我们应该通过一个 `IPackagesClient` 接口注册服务，以便在测试中对其进行模拟（`.AddScoped<IPackagesClient,
    PackagesClient>()`）。
- en: With everything in place, we just need to build the UI.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪，我们只需要构建用户界面。
- en: Implementing the user interface
  id: totrans-716
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现用户界面
- en: As the first step, let’s delete the application pages we don’t need – namely,
    `Pages->Counter.razor` and `Pages->Weather.razor`. Let’s also remove their links
    from the side menu in `Shared` -> `NavMenu.razor`.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们删除我们不需要的应用程序页面——即 `Pages->Counter.razor` 和 `Pages->Weather.razor`。同时，我们也从
    `Shared` -> `NavMenu.razor` 的侧菜单中移除它们的链接。
- en: 'We will put our code in the `Pages` -> `Home.razor` page. Let’s replace the
    code of this page with the following:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把代码放在 `Pages` -> `Home.razor` 页面中。让我们用以下代码替换这个页面的代码：
- en: '[PRE103]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The preceding code adds the needed `@using` statements, injects our `PackagesClient`
    service into the page, and defines the search form. When the form is successfully
    submitted, it invokes the `Search` callback, where we will place the code that
    retrieves all the results.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码添加了需要的 `@using` 语句，将我们的 `PackagesClient` 服务注入到页面中，并定义了搜索表单。当表单成功提交时，它将调用
    `Search` 回调，我们将在这里放置检索所有结果的代码。
- en: 'It is time to add the logic to display all the results and to complete the
    `@code` block. The following code must be placed immediately after the search
    form:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加显示所有结果和完成 `@code` 块的逻辑了。以下代码必须立即放置在搜索表单之后：
- en: '[PRE104]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The omitted code in the `if` block is responsible for rendering a table with
    all the results. We will show it after having commented on the preceding code.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 块中省略的代码负责渲染包含所有结果的表格。我们将在注释完前面的代码后展示它。
- en: Before retrieving the results with the `PackagesClient` service, we remove all
    previous results and set the `loading` field so the Razor code selects the `else
    if` path that replaces the previous table with a loading message. Once we’ve set
    these variables, we are forced to call `StateHasChanged` to trigger change detection
    and refresh the page. After all the results have been retrieved and the callback
    returns, there is no need to call `StateHasChanged` again because the termination
    of the callback itself triggers change detection and causes the required page
    refresh.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `PackagesClient` 服务检索结果之前，我们删除所有之前的结果，并设置 `loading` 字段，以便 Razor 代码选择替换之前表格的加载消息的
    `else if` 路径。一旦我们设置了这些变量，我们就必须调用 `StateHasChanged` 来触发更改检测并刷新页面。在检索到所有结果并且回调返回之后，不需要再次调用
    `StateHasChanged`，因为回调的终止本身就会触发更改检测并导致所需的页面刷新。
- en: 'Here is the code that renders the table with all the results:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是渲染包含所有结果的表的代码：
- en: '[PRE105]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Run the project and write the initial characters of Florence. Since we inserted
    Florence as a location in the same database in previous chapters (see the *Querying
    and updating data with Entity Framework Core* section of *Chapter 13*, *Interacting
    with Data in C# – Entity Framework Core*), some results should appear. If you
    inserted different data, please try with different starting words.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并输入 Florence 的初始字母。由于我们在前面的章节中（见第 13 章 *使用 Entity Framework Core 查询和更新数据*部分，*在
    C# 中与数据交互 – Entity Framework Core*），将 Florence 作为同一数据库中的位置插入（），应该会显示一些结果。如果您插入了不同的数据，请尝试使用不同的起始字母。
- en: Usually, together with web-based clients, all applications also furnish mobile-native
    applications to get a better performance with possibly slow mobile devices. So,
    let’s also design a mobile-native client application!
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与基于 Web 的客户端一起，所有应用程序也提供移动原生应用程序，以在可能较慢的移动设备上获得更好的性能。因此，让我们也设计一个移动原生客户端应用程序！
- en: Adding a Blazor MAUI version
  id: totrans-729
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Blazor MAUI 版本
- en: In this section, we explain how to add a Blazor MAUI version to the application
    of the previous solution.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释如何将 Blazor MAUI 版本添加到上一个解决方案的应用程序中。
- en: First of all, right-click on the solution icon in Solution Explorer and add
    a new project to the solution. Select a MAUI Blazor application and call it `PackagesManagementMAUIBlazor`.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在解决方案资源管理器中右键单击解决方案图标，并将新项目添加到解决方案中。选择一个 MAUI Blazor 应用程序，并将其命名为 `PackagesManagementMAUIBlazor`。
- en: 'Open the `PackagesManagementMAUIBlazor` project file and remove all the platforms
    you don’t want to support (I removed Android, iOS, and Mac Catalyst, and kept
    only Windows):'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `PackagesManagementMAUIBlazor` 项目文件，并移除您不想支持的 所有平台（我移除了 Android、iOS 和 Mac
    Catalyst，只保留了 Windows）：
- en: '[PRE106]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Then, add a reference to the `PackagesManagementBlazor.Shared` project.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加对 `PackagesManagementBlazor.Shared` 项目的引用。
- en: Now, right-click on the client WebAssembly project and select **Open Folder
    in File Explorer**. Then, copy the `ViewModels` and `Services` folders, and paste
    them in Visual Studio Solution Explorer under the newly created `PackagesManagementMAUIBlazor`
    node.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，右键单击客户端 WebAssembly 项目并选择**在文件资源管理器中打开文件夹**。然后，将 `ViewModels` 和 `Services`
    文件夹复制，并将它们粘贴在 Visual Studio 解决方案资源管理器中新建的 `PackagesManagementMAUIBlazor` 节点下。
- en: Then, change the namespaces of the files contained in these folders to be, respectively,
    `PackagesManagementMAUIBlazor.ViewModels` and `PackagesManagementMAUIBlazor.Services`.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将这些文件夹中包含的文件的名空间分别更改为 `PackagesManagementMAUIBlazor.ViewModels` 和 `PackagesManagementMAUIBlazor.Services`。
- en: Now, replace the content of the `Shared` and `Pages` folders of the newly created
    project with the content of the `Layout` and `Pages` folders of the client Blazor
    WebAssembly project.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将新创建的项目中的 `Shared` 和 `Pages` 文件夹的内容替换为客户端 Blazor WebAssembly 项目的 `Layout`
    和 `Pages` 文件夹的内容。
- en: 'Edit the newly copied `Home.razor` file and replace its header with:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑新复制的 `Home.razor` 文件，并将其标题替换为：
- en: '[PRE107]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Finally, add the same `HttpClient` and `PackagesClient` configurations of the
    WebAssembly project to `MAUIProgram.cs`:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 WebAssembly 项目的相同 `HttpClient` 和 `PackagesClient` 配置添加到 `MAUIProgram.cs`：
- en: '[PRE108]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: With this, you must add `PackagesManagementMAUIBlazor` to the projects to start.
    Right-click on the solution and select **Configure Startup Projects**.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，您必须将 `PackagesManagementMAUIBlazor` 添加到项目中以开始。右键单击解决方案并选择**配置启动项目**。
- en: In the windows that open, select also the newly created MAUI Blazor project.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的窗口中，选择新建的 MAUI Blazor 项目。
- en: Now, you can launch the application. Three windows should open (two browser
    windows and a Windows window) but both client project windows should show exactly
    the same application.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以启动应用程序。应该打开三个窗口（两个浏览器窗口和一个Windows窗口），但是两个客户端项目窗口应该显示完全相同的应用程序。
- en: After having discussed all the components of our WWTravelClub application, we
    need just to describe how to test it.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了我们的WWTravelClub应用程序的所有组件之后，我们只需要描述如何测试它。
- en: Testing the WWTravelClub application
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试WWTravelClub应用程序
- en: In this section, we add some unit and functional test projects to the `PackagesManagement`
    frontend microservice we described in the *A frontend microservice* section of
    this chapter. If you don’t have it, you can download it from the section of the
    GitHub repository associated with the book in the `ch19` folder. It is worth pointing
    out that in real-world projects, unit test batteries are enhanced by integration
    tests, and acceptance tests would include not only functional tests but also various
    kinds of performance tests.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向本章*前端微服务*部分描述的`PackagesManagement`前端微服务添加一些单元和功能测试项目。如果您还没有它，您可以从与本书相关的GitHub仓库的`ch19`文件夹中的部分下载它。值得注意的是，在实际项目中，单元测试集通过集成测试得到增强，而验收测试将包括不仅功能测试，还包括各种类型的性能测试。
- en: You are encouraged to review *Chapter 9*, *Testing Your Enterprise Application*,
    before continuing with this section.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本节之前，我们鼓励您回顾*第9章*，*测试您的企业应用程序*。
- en: As a first step, let’s make a new copy of the solution folder and name it `PackagesManagementWithTests`.
    Then, open the solution and add it to an xUnit .NET C# test project named `PackagesManagementTest`.
    Finally, add a reference to the ASP.NET Core project (`PackagesManagement`), since
    we will test it, and a reference to the latest version of the `Moq` `NuGet` package,
    since we require mocking capabilities.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们创建解决方案文件夹的新副本，并将其命名为`PackagesManagementWithTests`。然后，打开解决方案并将其添加到名为`PackagesManagementTest`的xUnit
    .NET C#测试项目中。最后，添加对ASP.NET Core项目（`PackagesManagement`）的引用，因为我们将会对其进行测试，并添加对最新版本的`Moq`
    `NuGet`包的引用，因为我们需要模拟功能。
- en: It is worth remembering that `Moq` is a mocking library and that the purpose
    of mocking is to decouple dependencies between classes by replacing actual classes
    with mocked classes whose behavior is under the complete control of the test code.
    This way, each class can be unit tested independently from the behavior of other
    classes it references. For more details about `Moq`, please refer to *Chapter
    9*, *Testing Your Enterprise Application*.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是`Moq`是一个模拟库，而模拟的目的是通过用完全受测试代码控制的模拟类替换实际类来解耦类之间的依赖关系。这样，每个类都可以独立于它引用的其他类的行为进行单元测试。有关`Moq`的更多详细信息，请参阅*第9章*，*测试您的企业应用程序*。
- en: At this point, we are ready to write our tests.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好编写我们的测试。
- en: 'As an example, we will write unit tests for the `Edit` method decorated with
    `[HttpPost]` of the `ManagePackagesController` controller, which is shown as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将为`ManagePackagesController`控制器中带有`[HttpPost]`装饰的`Edit`方法编写单元测试，如下所示：
- en: '[PRE109]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Before writing our test methods, let’s rename the test class that was automatically
    included in the test project as `ManagePackagesControllerTests`.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的测试方法之前，让我们将自动包含在测试项目中的测试类重命名为`ManagePackagesControllerTests`。
- en: 'The first test verifies that if there are errors in `ModelState`, the action
    method renders a view with the same model it received as an argument so that the
    user can correct all errors. We need to test all possibilities. Let’s delete the
    existing test method and write an empty `DeletePostValidationFailedTest` method,
    as follows:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试验证了如果`ModelState`中存在错误，动作方法将渲染一个与它接收的参数相同的视图，以便用户可以纠正所有错误。我们需要测试所有可能性。让我们删除现有的测试方法，并编写一个空的`DeletePostValidationFailedTest`方法，如下所示：
- en: '[PRE110]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The method must be `async` and the return type must be `Task` since the `Edit`
    method that we have to test is `async`. In this test, we don’t need mocked objects
    since no injected object will be used. Thus, as a preparation for the test, we
    just need to create a controller instance, and we must add an error to `ModelState`
    as follows:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法必须是`async`，并且返回类型必须是`Task`，因为我们必须测试的`Edit`方法本身就是`async`。在这个测试中，我们不需要模拟对象，因为没有注入的对象会被使用。因此，作为测试的准备，我们只需要创建一个控制器实例，并且我们必须按照以下方式向`ModelState`添加一个错误：
- en: '[PRE111]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Then, we invoke the method, injecting `ViewModel` and a `null` command handler
    as its arguments, since the command handler will not be used:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用该方法，注入`ViewModel`和一个`null`命令处理器作为其参数，因为命令处理器将不会被使用：
- en: '[PRE112]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'In the verification stage, we verify that the result is `ViewResult` and that
    it contains the same model that was injected into the controller:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证阶段，我们验证结果是否为`ViewResult`，并且它包含注入到控制器中的相同模型：
- en: '[PRE113]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now, we also need a test to verify that if there are no errors, the command
    handler is called, and then the browser is redirected to the `Index` controller
    action method. We call the `DeletePostSuccessTest` method:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要一个测试来验证如果没有错误，命令处理器会被调用，然后浏览器会被重定向到`Index`控制器动作方法。我们调用`DeletePostSuccessTest`方法：
- en: '[PRE114]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This time, the preparation code must include the preparation of a command handler
    mock, as follows:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，准备代码必须包括命令处理器模拟的准备，如下所示：
- en: '[PRE115]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Since the handler `HandleAsync` method returns no `async` value, we can’t use
    `ReturnsAsync`, but we have to return just a completed `Task (Task.Complete)`
    with the `Returns` method. The method to test is called with both `ViewModel`
    and the mocked handler:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`HandleAsync`方法不返回任何`async`值，我们不能使用`ReturnsAsync`，但我们必须使用`Returns`方法仅返回一个完成的`Task
    (Task.Complete)`。要测试的方法是用`ViewModel`和模拟的处理程序一起调用的：
- en: '[PRE116]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In this case, the verification code is as follows:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，验证代码如下：
- en: '[PRE117]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: As the first step, we verify that the command handler has actually been invoked
    once. A better verification should also include a check that it was invoked with
    a command that includes `ViewModel` passed to the action method. We will take
    it up as an exercise.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们验证命令处理器实际上被调用了一次。更好的验证还应包括检查它是否使用传递给动作方法的`ViewModel`调用的命令。我们将将其作为一个练习来处理。
- en: Then we verify that the action method returns `RedirectToActionResult` with
    the right action method name and with no controller name specified.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们验证动作方法返回带有正确动作方法名称的`RedirectToActionResult`，并且没有指定控制器名称。
- en: Once all the tests are ready, if the test window does not appear on the left
    bar of Visual Studio, we may simply select the **Run all tests** item from the
    Visual Studio **Test** menu. Once the test window appears, further invocations
    can be launched from within this window.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有测试都准备好了，如果测试窗口没有出现在Visual Studio的左侧栏中，我们只需从Visual Studio的**测试**菜单中选择**运行所有测试**项。一旦测试窗口出现，进一步的调用可以从该窗口内部启动。
- en: If a test fails, we can add a breakpoint to its code, so we can launch a debug
    session on it by right-clicking on it in the test window and then selecting **Debug
    selected tests**. It is worth remembering that failures do not depend necessarily
    on errors in the code under test but might also depend on errors in the testing
    code itself.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，我们可以在其代码中添加一个断点，这样我们就可以通过在测试窗口中右键单击它并选择**调试选定的测试**来启动对其的调试会话。值得记住的是，失败不一定依赖于测试代码中的错误，也可能依赖于测试代码本身的错误。
- en: In the next subsection, we will show how to upload our code to a shared Azure
    DevOps repository and how to automatize our tests with an Azure DevOps pipeline.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将展示如何将我们的代码上传到共享的Azure DevOps仓库，以及如何使用Azure DevOps管道自动化我们的测试。
- en: Connecting to an Azure DevOps repository
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到Azure DevOps仓库
- en: Tests play a fundamental role in the application CI/CD cycle, specifically in
    CI. They must be executed at least each time the master branch of the application
    repository is modified to verify that changes don’t introduce bugs.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在应用程序CI/CD周期中扮演着基本角色，特别是在CI中。它们必须在至少每次修改应用程序仓库的master分支时执行，以验证更改不会引入错误。
- en: The following steps show how to connect our solution to an Azure DevOps repository,
    where we will define an Azure DevOps pipeline that builds the project, and that
    also launches all the unit tests we defined in the `PackagesManagementTest` project
    at each build.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何将我们的解决方案连接到Azure DevOps仓库，在那里我们将定义一个Azure DevOps管道，该管道构建项目，并在每次构建时启动我们在`PackagesManagementTest`项目中定义的所有单元测试。
- en: However, the functional tests that we defined in the `PackagesManagementFTest`
    project must be executed only before a sprint is released. Therefore, they must
    be placed in a different pipeline that takes care of delivering the application.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在`PackagesManagementFTest`项目中定义的功能测试必须在发布冲刺之前执行。因此，它们必须放在不同的管道中，该管道负责交付应用程序。
- en: 'In this way, every day after all developers have pushed their changes, we can
    launch the pipeline to verify that the repository code compiles and passes all
    the unit tests:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每天在所有开发者推送他们的更改后，我们都可以启动管道来验证仓库代码是否编译并通过所有单元测试：
- en: 'As a first step, we need a free DevOps subscription. If you don’t already have
    one, please create one by clicking the **Start free** button on this page: [https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/).
    Here, let’s follow the wizard to define an organization and then a project.'
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们需要一个免费的 DevOps 订阅。如果您还没有，请通过点击此页面的**开始免费**按钮创建一个：[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)。在这里，让我们按照向导定义一个组织，然后是一个项目。
- en: 'On the project page, select the **Files** menu, click on the **Repos** menu
    item, and then copy the repository URL:'
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目页面上，选择**文件**菜单，点击**仓库**菜单项，然后复制仓库 URL：
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B19820_21_30.png)'
  id: totrans-783
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的中等置信度描述](img/B19820_21_30.png)'
- en: 'Figure 21.30: Copying the repository URL'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.30：复制仓库 URL
- en: 'Ensure you are logged in to Visual Studio with your Azure account (the same
    one used in the creation of the DevOps account). In the **Git Changes** tab, click
    the **Create Git Repository...** button:'
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您使用 Azure 账户（与创建 DevOps 账户时使用的相同账户）登录到 Visual Studio。在**Git 变更**选项卡中，点击**创建
    Git 仓库...**按钮：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19820_21_31.png)'
  id: totrans-786
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B19820_21_31.png)'
- en: 'Figure 21.31: Opening the connection window'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.31：打开连接窗口
- en: 'In the window that opens, select **Existing remote** from the left menu and
    copy and paste the remote repository URL:'
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，从左侧菜单选择**现有远程**，并复制粘贴远程仓库 URL：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19820_21_32.png)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B19820_21_32.png)'
- en: 'Figure 21.32: Connection window'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.32：连接窗口
- en: 'Then, click the **Create and Push** button and wait until the ready icon in
    the bottom-left corner of Visual Studio is checked:'
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**创建并推送**按钮，等待 Visual Studio 左下角准备图标被勾选：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B19820_21_33.png)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，团队  自动生成的描述](img/B19820_21_33.png)'
- en: 'Figure 21.33: Operation completed'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.33：操作完成
- en: At this point, the repository has been created locally, connected with the selected
    remote repository, and all changes have been committed and pushed to the remote
    repository.
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，仓库已在本地创建，与所选远程仓库连接，并且所有更改都已提交并推送到远程仓库。
- en: 'Now, click the **Pipelines** menu item to create a DevOps pipeline to build
    and test your project. In the window that appears, click the button to create
    a new pipeline:'
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**管道**菜单项以创建一个 DevOps 管道来构建和测试您的项目。在出现的窗口中，点击按钮创建一个新的管道：
- en: '![Graphical user interface, application  Description automatically generated](img/B19820_21_34.png)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B19820_21_34.png)'
- en: 'Figure 21.34: Pipeline page'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.34：管道页面
- en: 'You will be prompted to select where your repository is located:'
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被提示选择您的仓库位置：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19820_21_35.png)'
  id: totrans-799
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B19820_21_35.png)'
- en: 'Figure 21.35: Repository selection'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.35：仓库选择
- en: 'Select **Azure Repos Git** and then your repository. Then, you will be prompted
    about the nature of the project:'
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Azure Repos Git**然后选择您的仓库。然后，您将被提示关于项目的性质：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_21_36.png)'
  id: totrans-802
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19820_21_36.png)'
- en: 'Figure 21.36: Pipeline configuration'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.36：管道配置
- en: 'Select **ASP.NET Core**. A pipeline for building and testing your project will
    be automatically created for you. Save it by committing the newly created `.yaml`
    file to your repository:'
  id: totrans-804
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**ASP.NET Core**。将为您自动创建一个构建和测试项目的管道。通过将新创建的 `.yaml` 文件提交到您的仓库来保存它：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19820_21_37.png)'
  id: totrans-805
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B19820_21_37.png)'
- en: 'Figure 21.37: Pipeline properties'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.37：管道属性
- en: 'The pipeline can be run by selecting the **Queue** button, but since the standard
    pipeline scaffolded by DevOps has a trigger on the master branch of the repository,
    it is automatically launched each time changes to this branch are committed and
    each time the pipeline is modified. The pipeline can be modified by clicking the
    **Edit** button:'
  id: totrans-807
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过选择**队列**按钮来运行管道，但由于由DevOps标准化的管道在仓库的主分支上有触发器，因此每次提交此分支的更改以及每次修改管道时，它都会自动启动。可以通过点击**编辑**按钮来修改管道：
- en: '![Graphical user interface, text, application, email, Teams  Description automatically
    generated](img/B19820_21_38.png)'
  id: totrans-808
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件，团队 描述自动生成](img/B19820_21_38.png)'
- en: 'Figure 21.38: Pipeline code'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.38：管道代码
- en: 'Once in edit mode, all pipeline steps can be edited by clicking the **Settings**
    link that appears above each of them. New pipeline steps can be added as follows:'
  id: totrans-810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入编辑模式，可以通过点击每个步骤上出现的**设置**链接来编辑所有管道步骤。可以按照以下方式添加新的管道步骤：
- en: Write `- task:` where the new step must be added and then accept one of the
    suggestions that appear while you are typing the task name.
  id: totrans-811
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新步骤必须添加的位置写上 `- task:`，然后在输入任务名称时接受出现的建议之一。
- en: Once you have written a valid task name, a **Settings** link appears above the
    new step. Click it.
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你写了一个有效的任务名称，一个**设置**链接就会出现在新步骤上方。点击它。
- en: Insert the desired task parameters in the window that appears and then save.
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的窗口中插入所需的任务参数，然后保存。
- en: To have our test working, we need to specify the criteria to locate all assemblies
    that contain tests. In our case, since we have to execute just the tests contained
    in `PackagesManagementTest.dll` and not the ones contained in `PackagesManagementFTest.dll`,
    we must specify the exact .`ddl` name.
  id: totrans-814
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让我们的测试工作，我们需要指定定位包含测试的所有程序集的准则。在我们的情况下，由于我们只需要执行`PackagesManagementTest.dll`中包含的测试，而不是`PackagesManagementFTest.dll`中包含的测试，我们必须指定确切的`.ddl`名称。
- en: 'Click the **Settings** link of the `VSTest@2` test task and replace the content
    that is automatically suggested for the **Test files** field with the following:'
  id: totrans-815
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击`VSTest@2`测试任务的**设置**链接，并将自动建议的**测试文件**字段的内容替换为以下内容：
- en: '[PRE118]'
  id: totrans-816
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Then, click **Add** to modify the actual pipeline content. As soon as you confirm
    your changes in the **Save and run** dialog, the pipeline is launched and, if
    there are no errors, test results are computed. The results of tests launched
    during a specific build can be analyzed by selecting the specific build in the
    pipeline **Runs** tab and by clicking the **Tests** tab on the page that appears.
    In our case, we should see something like the following screenshot:'
  id: totrans-817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**添加**以修改实际的管道内容。一旦你在**保存并运行**对话框中确认了你的更改，管道就会被启动，如果没有错误，测试结果就会被计算。在特定构建期间启动的测试结果可以通过在管道**运行**选项卡中选择特定的构建，并点击出现的页面上的**测试**选项卡来分析。在我们的情况下，我们应该看到以下截图类似的内容：
- en: '![](img/B19820_21_39.png)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_21_39.png)'
- en: 'Figure 21.39: Test results'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.39：测试结果
- en: Summing up, we created a new Azure DevOps repository, published the solution
    to the new repository, and then created a build pipeline that executes our tests
    after each build. The build pipeline is executed as soon as we save it and will
    be executed each time someone commits to the master branch.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 总结起来，我们创建了一个新的Azure DevOps仓库，将解决方案发布到新仓库，然后创建了一个在每次构建后执行我们的测试的构建管道。一旦我们保存它，构建管道就会被执行，并且每次有人向主分支提交更改时，它都会被执行。
- en: Summary
  id: totrans-821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The main purpose of this chapter was to deliver pieces of implementations that
    can be useful to begin the challenge of delivering a software solution for an
    enterprise. Although we have not shown the complete implemention of the WWTravelClub
    application, we are confident that the microservices and code provided here can
    help you in your professional projects; this is in line with what we understand
    to be the main purpose of a software architect―to help the team in developing
    software that meets the users’ needs exactly as required.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目的是提供一些可以用于开始为企业交付软件解决方案挑战的实现片段。尽管我们没有展示WWTravelClub应用程序的完整实现，但我们相信这里提供的微服务和代码可以帮助你在你的专业项目中；这符合我们理解的软件架构师的主要目的——帮助团队开发满足用户需求的软件。
- en: Leave a review!
  id: totrans-823
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoyed this book? Help readers like you by leaving an Amazon review. Scan the
    QR code below for a 20% discount code.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论来帮助像你这样的读者。扫描下面的二维码以获取20%的折扣码。
- en: '![](img/Leave_a_review_QR.png)'
  id: totrans-825
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Leave_a_review_QR.png)'
- en: '**Limited Offer*'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠**'
