- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Presenting ASP.NET Core
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示 ASP.NET Core
- en: In this chapter, you will learn how to implement a web application and a web-based
    presentation layer. More specifically, you will learn about ASP.NET Core and how
    to implement a web application presentation layer based on ASP.NET Core MVC.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何实现 Web 应用程序和基于 Web 的表示层。更具体地说，你将了解 ASP.NET Core 以及如何基于 ASP.NET Core
    MVC 实现 Web 应用程序表示层。
- en: 'ASP.NET Core is a .NET framework for implementing web applications. The ASP.NET
    Core Web API was partially described in previous chapters, so this chapter will
    focus mainly on ASP.NET Core in general and on ASP.NET Core MVC. More specifically,
    this chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 是一种用于实现 Web 应用程序的 .NET 框架。ASP.NET Core Web API 在之前的章节中部分描述过，因此本章将主要关注
    ASP.NET Core 的总体情况以及 ASP.NET Core MVC。更具体地说，本章将涵盖以下主题：
- en: Understanding the presentation layers of web applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Web 应用程序的表示层
- en: Understanding the basics of ASP.NET Core
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core 的基础知识
- en: Understanding how ASP.NET Core MVC creates the response HTML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core MVC 如何创建响应 HTML
- en: Understanding the connection between ASP.NET Core MVC and design principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core MVC 与设计原则之间的联系
- en: We will review and provide further details on the structure of the ASP.NET Core
    framework, which we discussed in part in earlier chapters. Here, the main focus
    is on how to implement web-based presentation layers based on the so-called **Model
    View Controller** (**MVC**) architectural pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾并提供关于之前章节中部分讨论的 ASP.NET Core 框架结构的进一步细节。在这里，主要关注的是如何根据所谓的**模型-视图-控制器**（**MVC**）架构模式实现基于
    Web 的表示层。
- en: We will also analyze how server-side HTML is created with ASP.NET Core MVC’s
    **Razor** template language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将分析如何使用 ASP.NET Core MVC 的 **Razor** 模板语言创建服务器端 HTML。
- en: Each concept is explained using code examples, and *Chapter 18*, *Implementing
    Frontend Microservices with ASP.NET Core*, is dedicated to the description of
    a frontend microservice implemented with ASP.NET Core MVC. For a complete practical
    example of how to put into practice the general principles discussed in this and
    the next chapter, please refer to the *A frontend microservice* section in *Chapter
    21*, *Case Study*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个概念都通过代码示例进行解释，并且*第18章*，*使用 ASP.NET Core 实现前端微服务*，专门描述了使用 ASP.NET Core MVC
    实现的前端微服务。为了了解如何将本章和下一章中讨论的通用原则付诸实践，请参阅*第21章*，*案例研究*中的*前端微服务*部分。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the free Visual Studio 2022 Community edition, ideally
    with all the database tools installed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费 Visual Studio 2022 Community 版本，理想情况下安装了所有数据库工具。
- en: Understanding the presentation layers of web applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Web 应用程序的表示层
- en: 'This chapter discusses an architecture for implementing the presentation layers
    of web applications based on the ASP.NET Core framework. The presentation layers
    of web applications are based on three techniques:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了基于 ASP.NET Core 框架实现 Web 应用程序表示层的架构。Web 应用程序的表示层基于三种技术：
- en: '**Mobile or desktop native applications that exchange data with servers through
    REST or SOAP services**: We will discuss desktop applications in *Chapter 19*,
    *Client Frameworks: Blazor*.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过 REST 或 SOAP 服务与服务器交换数据的移动或桌面原生应用程序**：我们将在*第19章*，*客户端框架：Blazor*中讨论桌面应用程序。'
- en: '**Single-Page Applications** (**SPAs**): These are HTML-based applications
    whose dynamic HTML is created on the client, either in JavaScript or with the
    help of WebAssembly (a kind of cross-browser assembly that can be used as a high-performance
    alternative to JavaScript). Like native applications, SPAs exchange data with
    the server through HTTP-based APIs, but they have the advantage of being independent
    of the device and its operating system, since they run in a browser. *Chapter
    19*, *Client Frameworks: Blazor*, describes the Blazor SPA framework, which is
    based on WebAssembly, since it is based itself on a .NET runtime compiled in WebAssembly.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPAs**）：这些是基于 HTML 的应用程序，其动态 HTML 在客户端创建，无论是使用 JavaScript 还是借助
    WebAssembly（一种跨浏览器的组件，可以用作 JavaScript 的高性能替代品）。与原生应用程序一样，SPAs 通过基于 HTTP 的 API
    与服务器交换数据，但它们的优势在于独立于设备和其操作系统，因为它们在浏览器中运行。*第19章*，*客户端框架：Blazor*描述了基于 WebAssembly
    的 Blazor SPA 框架，因为它本身基于在 WebAssembly 中编译的 .NET 运行时。'
- en: '**HTML pages created by the server whose content depends on the data to be
    shown to the user**: The ASP.NET Core MVC framework, which will be discussed in
    this chapter, is a framework for creating such dynamic HTML pages.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由服务器创建的 HTML 页面，其内容取决于要展示给用户的数据**：本章将要讨论的 ASP.NET Core MVC 框架是一个用于创建此类动态
    HTML 页面的框架。'
- en: The remainder of this chapter focuses on how to create HTML pages on the server
    side and, more specifically, on ASP.NET Core MVC.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分重点介绍如何在服务器端创建 HTML 页面，更具体地说，是关于 ASP.NET Core MVC。
- en: Understanding the basics of ASP.NET Core
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core 的基础知识
- en: ASP.NET Core is based on the concept of the generic host, as explained in the
    *Using generic hosts* subsection of *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*. The basic architecture of ASP.NET Core was outlined
    in the *A short introduction to ASP.NET Core* subsection of *Chapter 15*, *Applying
    Service-Oriented Architectures with .NET*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 基于通用宿主的概念，如第11章的 *使用通用宿主* 子节和 *将微服务架构应用于企业应用程序* 中所述。ASP.NET Core
    的基本架构在第15章的 *使用 .NET 应用服务导向架构* 子节的 *ASP.NET Core 简介中概述。
- en: 'It is worth remembering that the host configuration consists mainly of adding
    services to the **Dependency Injection** (**DI**) engine through the `Services`
    property of a host builder instance, whose type implements the `IServiceCollection`
    interface:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，主机配置主要由向主机构建器实例的 `Services` 属性添加服务组成，该实例的类型实现了 `IServiceCollection` 接口，即通过
    `Dependency Injection` (`DI`) 引擎的 `Services` 属性：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `IServiceCollection` interface implemented by `builder.Services` defines
    all the services that can be injected into object constructors through DI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `builder.Services` 实现的 `IServiceCollection` 接口定义了可以通过 DI 注入到对象构造函数中的所有服务。
- en: Services can be defined either by calling the various overloads of `AddTransient`
    and `AddSingleton` directly in `Program.cs`, or by grouping these calls in some
    `IServiceCollection` extension methods, which are then called in `Program.cs`.
    The way services are handled in .NET is explained in detail in the *Using generic
    hosts* section of *Chapter 11*. Here, it is worth pointing out that, together
    with singleton and transient services, ASP.NET Core also supports another kind
    of service lifetime, session lifetime, which is the lifetime of a single web request
    served by the ASP.NET Core application. Session-scoped services are declared with
    `AddScoped` overloads that are completely analogous to the overloads of `AddTransient`
    and `AddSingleton`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以通过直接在 `Program.cs` 中调用 `AddTransient` 和 `AddSingleton` 的各种重载来定义，或者通过将这些调用分组到一些
    `IServiceCollection` 扩展方法中，然后在 `Program.cs` 中调用这些方法。.NET 中处理服务的方式在第11章的 *使用通用宿主*
    部分中有详细解释。这里值得指出的是，除了单例和瞬态服务之外，ASP.NET Core 还支持另一种服务生命周期，即会话生命周期，这是由 ASP.NET Core
    应用程序服务的一个单个 Web 请求的生命周期。会话作用域的服务通过 `AddScoped` 重载声明，这与 `AddTransient` 和 `AddSingleton`
    重载完全类似。
- en: Session-scoped services are useful for storing data that are specific to a single
    request that must be used throughout the whole request by several application
    components. A typical example of a .NET session-scoped service is the Entity Framework
    Core `DBContexts`. In fact, all operations performed on the various aggregates
    involved in the request must use the same request-specific `DBContext` so that
    all changes can be saved to the database in a single transaction, with a unique
    `SaveChanges` operation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 会话作用域的服务对于存储特定于单个请求且必须由多个应用程序组件在整个请求中使用的请求数据非常有用。.NET 会话作用域服务的典型示例是 Entity Framework
    Core 的 `DBContexts`。实际上，对请求中涉及的各个聚合体执行的所有操作都必须使用相同的请求特定 `DBContext`，以便所有更改都可以通过单个事务和唯一的
    `SaveChanges` 操作保存到数据库中。
- en: Practical applications of session-scoped `DBContext`s and other services are
    described in more detail in *Chapter 18*, *Implementing Frontend Microservices
    with ASP.NET Core*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 会话作用域的 `DBContext`s 和其他服务的实际应用在 *第18章*，*使用 ASP.NET Core 实现前端微服务* 中描述得更加详细。
- en: Usually, all applications define most of the application configuration through
    the host builder so that after the host is built with `var app = builder.Build()`,
    you need to call `app.Run()` or `await app.RunAsync()` to launch the application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有应用程序都通过主机构建器定义大部分应用程序配置，以便在用 `var app = builder.Build()` 构建主机后，您需要调用 `app.Run()`
    或 `await app.RunAsync()` 来启动应用程序。
- en: The ASP.NET Core host instead performs another configuration step after it has
    been built; it defines the so-called ASP.NET Core HTTP request processing pipeline,
    which will be described in more detail in the next subsection.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 主机在构建完成后执行另一个配置步骤；它定义了所谓的 ASP.NET Core HTTP 请求处理管道，这将在下一小节中更详细地描述。
- en: ASP.NET Core middleware
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core 中间件
- en: ASP.NET Core contains an internal web server called Kestrel that has just the
    basic web server functionalities. So in simple applications such as IoT applications,
    or worker microservices, we can avoid the overhead of a fully optional complex
    web server like IIS, Apache, or NGINX.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 包含一个名为 Kestrel 的内部 Web 服务器，它仅具备基本的 Web 服务器功能。因此，在像物联网应用或工作微服务这样的简单应用中，我们可以避免使用像
    IIS、Apache 或 NGINX 这样的完全可选的复杂 Web 服务器的开销。
- en: If ASP.NET Core is used to implement the application layer of a frontend microservice/application
    or a classic website, Kestrel can be interfaced with all major web servers that
    proxy their request to Kestrel.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 ASP.NET Core 实现前端微服务/应用的表示层或经典网站，Kestrel 可以与所有主要 Web 服务器接口，这些服务器将它们的请求代理到
    Kestrel。
- en: In version 8, by default, Kestrel supports all protocols up to and including
    version HTTP/3.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 8 中，Kestrel 默认支持所有协议，包括 HTTP/3 及其之前的所有版本。
- en: In turn, Kestrel passes all requests to a set of configurable modules that you
    can assemble according to your needs. Each module takes care of a functionality
    that you may or may not need. Examples of such functionalities include authorization,
    authentication, static file processing, protocol negotiation, and CORS handling.
    Since most of the modules apply transformations to the incoming request and the
    final response, these modules are usually referred to as **middleware**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，Kestrel 将所有请求传递给一组可配置的模块，您可以根据需要组装这些模块。每个模块负责您可能需要或不需要的功能。此类功能的例子包括授权、身份验证、静态文件处理、协议协商和
    CORS 处理。由于大多数模块都对传入请求和最终响应进行转换，因此这些模块通常被称为 **中间件**。
- en: You can put together all the **middleware** modules you need by inserting them
    into a common processing framework called the **ASP.NET Core pipeline**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将它们插入到一个称为 **ASP.NET Core 管道** 的通用处理框架中来组装您需要的所有 **中间件** 模块。
- en: 'More specifically, ASP.NET Core requests are processed by pushing a context
    object through a pipeline of ASP.NET Core modules, as shown in the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，ASP.NET Core 请求通过将上下文对象推送到 ASP.NET Core 模块的管道中进行处理，如下面的图所示：
- en: '![](img/B19820_17_01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.1](img/B19820_17_01.png)'
- en: 'Figure 17.1: ASP.NET Core pipeline'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1：ASP.NET Core 管道
- en: The object that is inserted into the pipeline is an `HttpContext` instance that
    contains the data of the incoming request. More specifically, the `Request` property
    of `HttpContext` contains an `HttpRequest` object whose properties represent the
    incoming request in a structured way. There are properties for headers, cookies,
    the request path, parameters, form fields, and the request body.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 插入到管道中的对象是一个 `HttpContext` 实例，它包含传入请求的数据。更具体地说，`HttpContext` 的 `Request` 属性包含一个
    `HttpRequest` 对象，其属性以结构化的方式表示传入请求。这些属性包括头部、Cookies、请求路径、参数、表单字段和请求体。
- en: The various modules can contribute to the construction of the final response
    that is written in an `HttpResponse` object, contained in the `Response` property
    of the `HttpContext` instance. The `HttpResponse` class is similar to the `HttpRequest`
    class, but its properties refer to the response being built.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 各种模块可以贡献于构建最终响应，该响应写入 `HttpResponse` 对象中，该对象包含在 `HttpContext` 实例的 `Response`
    属性中。`HttpResponse` 类与 `HttpRequest` 类类似，但其属性指的是正在构建的响应。
- en: Some modules can build an intermediate data structure that is then used by other
    modules in the pipeline. In general, such intermediary data can be stored in custom
    entries of the `IDictionary<object, object>`, which is contained in the `Items`
    property of the `HttpContext` object. However, there is a predefined property,
    `User`, that contains information about the currently logged-in user. The logged-in
    user is not computed automatically, so it must be computed by an authentication
    module. The *ASP.NET Core service authorization* subsection of *Chapter 15*, *Applying
    Service-Oriented Architectures with .NET*, explained how to add the standard module
    that performs JWT-based authentication into the ASP.NET Core pipeline.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块可以构建一个中间数据结构，然后由管道中的其他模块使用。通常，这种中间数据可以存储在 `HttpContext` 对象的 `Items` 属性中包含的
    `IDictionary<object, object>` 的自定义条目中。然而，有一个预定义的属性 `User`，它包含有关当前登录用户的信息。登录用户不是自动计算的，因此必须由认证模块计算。*第
    15 章*，*使用 .NET 应用服务导向架构*的*ASP.NET Core 服务授权*小节解释了如何将基于 JWT 的标准模块添加到 ASP.NET Core
    管道中。
- en: '`HttpContext` also has a `Connection` property that contains information on
    the underlying connection established with the client, as well as a `WebSockets`
    property that contains information on possible WebSocket-based connections established
    with the clients.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext` 还有一个 `Connection` 属性，它包含与客户端建立的基础连接的信息，以及一个 `WebSockets` 属性，它包含与客户端建立的可能基于
    WebSocket 的连接的信息。'
- en: '`HttpContext` also has a `Features` property that contains `IDictionary<Type,
    object>`, which specifies the features supported by the web server that hosts
    the web application and by the pipeline. Features can be set using the `.Set<TFeature>(TFeature
    o)` method and retrieved using the `.Get<TFeature>()` method.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext` 还有一个 `Features` 属性，它包含 `IDictionary<Type, object>`，该属性指定了托管 web
    应用的 web 服务器和管道所支持的功能。功能可以通过 `.Set<TFeature>(TFeature o)` 方法设置，并通过 `.Get<TFeature>()`
    方法检索。'
- en: Web server features are automatically added by the framework, while all other
    features are added by pipeline modules when they process `HttpContext`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 框架自动添加 Web 服务器功能，而所有其他功能则在处理 `HttpContext` 时由管道模块添加。
- en: '`HttpContext` also gives us access to the DI engine through its `RequestServices`
    property. You can get an instance of a type managed by the dependency engine by
    calling the `.RequestServices.GetService(Type t)` method or, even better, the
    `.GetRequiredService<TService>()` extension method that is built on top of it.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext` 还通过其 `RequestServices` 属性为我们提供了对 DI 引擎的访问。你可以通过调用 `.RequestServices.GetService(Type
    t)` 方法或更好的 `.GetRequiredService<TService>()` 扩展方法（它基于前者）来获取由依赖引擎管理的类型实例。'
- en: However, as we will see in the remainder of this chapter, all types managed
    by the DI engine are usually automatically injected into constructors, so these
    methods are only used when we’re building custom **middleware** or other customizations
    of the ASP.NET Core engine.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们将在本章的剩余部分看到的那样，由 DI 引擎管理的所有类型通常都是自动注入到构造函数中的，因此这些方法仅在构建自定义 **中间件** 或其他
    ASP.NET Core 引擎的自定义化时使用。
- en: The `HttpContext` instance that is created for processing a web request is not
    only available to modules but also to the application code, through DI. It is
    sufficient to insert an `IHttpContextAccessor` parameter into the constructor
    of a class that is automatically dependency injected, and then access its `HttpContext`
    property. All controllers that inherit from `Controller` or `ControllerBase` (see
    later in this section) expose an `HttpContext` property that contains the request
    `HttpContext`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为处理 web 请求而创建的 `HttpContext` 实例不仅对模块可用，而且通过 DI 对应用程序代码也可用。只需将 `IHttpContextAccessor`
    参数插入到自动依赖注入的类的构造函数中，然后访问其 `HttpContext` 属性即可。所有继承自 `Controller` 或 `ControllerBase`（见本节后面的内容）的控制器都公开一个包含请求
    `HttpContext` 的 `HttpContext` 属性。
- en: 'A middleware module is any class with the following structure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件模块是任何具有以下结构的类：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is also possible to pass `InvokeAsync` directly as a lambda to `app.Use`,
    as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以直接将 `InvokeAsync` 作为 lambda 表达式传递给 `app.Use`，如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In general, each piece of middleware processes the `HttpContext` instance that
    was passed by the previous module in the pipeline, and then it calls `await _next.Invoke(context)`
    to invoke the modules in the remainder of the pipeline. When the other modules
    have finished their processing and the response for the client has been prepared,
    each module can perform further post-processing of the response in the code that
    follows the `_next.Invoke(context)` call.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个中间件处理由管道中上一个模块传递的 `HttpContext` 实例，然后调用 `await _next.Invoke(context)` 来调用管道剩余部分的模块。当其他模块完成处理并且客户端的响应已经准备就绪时，每个模块都可以在
    `_next.Invoke(context)` 调用之后的代码中执行进一步的响应后处理。
- en: 'Modules are registered in the ASP.NET Core pipeline by calling the `UseMiddleware<T>`
    method of the built host, as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用构建宿主的 `UseMiddleware<T>` 方法将模块注册到 ASP.NET Core 管道中，如下所示：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Middleware modules are inserted into the pipeline in the same order when `UseMiddleware`
    is called. Since each functionality that’s added to an application might require
    several modules and operations other than adding modules, you usually define an
    `IApplicationBuilder` extension such as `UseMyFunctionality`, as shown in the
    following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `UseMiddleware` 时，中间件模块以相同的顺序插入到管道中。由于添加到应用程序中的每个功能可能需要几个模块以及其他操作，除了添加模块之外，你通常定义一个如以下代码所示的
    `IApplicationBuilder` 扩展，例如 `UseMyFunctionality`。
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After that, the whole functionality can be added to the application by calling
    `app.UseMyFunctionality(...)`. For instance, the ASP.NET Core MVC functionality
    can be added to the ASP.NET Core pipeline by calling `app.UseEndpoints(....)`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以通过调用 `app.UseMyFunctionality(...)` 将整个功能添加到应用程序中。例如，可以通过调用 `app.UseEndpoints(....)`
    将 ASP.NET Core MVC 功能添加到 ASP.NET Core 管道中。
- en: Often, functionalities that are added with each `app.Use...` require that some
    .NET types are added to the application DI engine. In these cases, we also define
    an `IServiceCollection` extension named `AddMyFunctionality`, which must be called
    by `builder.Services` in `Program.cs`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过每个 `app.Use...` 添加的功能需要将一些 .NET 类型添加到应用程序的依赖注入引擎中。在这些情况下，我们也会定义一个名为 `AddMyFunctionality`
    的 `IServiceCollection` 扩展，它必须在 `Program.cs` 中的 `builder.Services` 上调用。
- en: 'For instance, ASP.NET Core MVC requires a call such as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，ASP.NET Core MVC 需要如下调用：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you don’t need to change the default MVC options, you can simply call `builder.Services.AddControllersWithViews()`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要更改默认的 MVC 选项，你可以简单地调用 `builder.Services.AddControllersWithViews()`。
- en: The next subsection describes another important feature of the ASP.NET Core
    framework – namely, how to handle application configuration data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了 ASP.NET Core 框架的另一个重要特性——即如何处理应用程序配置数据。
- en: Loading configuration data and using it with the options framework
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载配置数据并使用选项框架
- en: Understanding how ASP.NET Core applications handle configuration is crucial
    for effective application setup. In the default .NET template where an ASP.NET
    Core application starts, it reads configuration information (such as a database
    connection string) from the `appsettings.json` and `appsettings.[EnvironmentName].json`
    files, where `EnvironmentName` is a string value that depends on where the application
    is deployed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core 应用程序如何处理配置对于有效设置应用程序至关重要。在默认的 .NET 模板中，ASP.NET Core 应用程序启动时会从
    `appsettings.json` 和 `appsettings.[EnvironmentName].json` 文件中读取配置信息（例如数据库连接字符串），其中
    `EnvironmentName` 是一个字符串值，它取决于应用程序部署的位置。
- en: 'Typical values for the `EnvironmentName` string are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnvironmentName` 字符串的典型值如下：'
- en: '`Production` is used for production deployment'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于生产部署使用 `Production`
- en: '`Development` is used during development'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Development` 在开发期间使用'
- en: '`Staging` is used when the application is tested in staging'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序在预发布环境中进行测试时使用 `Staging`
- en: The two JSON trees that were extracted from the `appsettings.json` and `appsettings.[EnvironmentName].json`
    files are merged into a unique tree, where the values contained in `[EnvironmentName].json`
    override the values contained in the corresponding paths of `appsettings.json`.
    This way, the application can be run with different configurations in different
    deployment environments. In particular, you can use a different database connection
    string and, hence, a different database instance in each different environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从`appsettings.json`和`appsettings.[EnvironmentName].json`文件中提取的两个JSON树被合并成一个唯一的树，其中`[EnvironmentName].json`中包含的值会覆盖`appsettings.json`中相应路径的值。这样，应用程序可以在不同的部署环境中运行不同的配置。特别是，你可以在每个不同的环境中使用不同的数据库连接字符串和数据库实例。
- en: '![](img/B19820_17_02.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_17_02.png)'
- en: 'Figure 17.2: Configuration files merging'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2：配置文件合并
- en: 'Configuration information can also be passed from other sources. Given a lack
    of space, we list here all the other possibilities without discussing them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 配置信息也可以从其他来源传递。鉴于空间有限，我们在此列出所有其他可能性，而不对其进行讨论：
- en: XML files
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML文件
- en: '`.ini` files'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.ini`文件'
- en: Operating system environment variables. The variable name is the name of the
    setting prefixed by the `ASPNETCORE_` string, while the variable value is the
    setting value.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统环境变量。变量名是以`ASPNETCORE_`字符串为前缀的设置名称，而变量值是设置值。
- en: Command-line arguments of a `dotnet` command that invokes the application.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用应用程序的`dotnet`命令的命令行参数。
- en: An in-memory collection of key-value pairs
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值对的内存集合
- en: The JSON format is, in my opinion, the most practical and readable, but JSON,
    XML, and `.ini` are substantially equivalent, and choosing among them is just
    a matter of preference.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，JSON格式是最实用和可读的，但JSON、XML和`.ini`在本质上等效，选择它们只是个人偏好的问题。
- en: In memory, collections of key-value pairs offer the possibility of taking data
    from a database, so they are useful options for those parameters that need to
    be changed by an administrator while the application is running.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，键值对的集合提供了从数据库中获取数据的可能性，因此它们是那些在应用程序运行时需要由管理员更改的参数的有用选项。
- en: Finally, command-line arguments and environment variables are good options when
    the application can’t easily access disk storage – for instance, in the case of
    deployments running in a Kubernetes cluster. In fact, environment variables can
    be passed as parameters in the Kubernetes `.yaml` files (see the *ReplicaSets
    and Deployments* section of *Chapter 20, Kubernetes*). They are also an acceptable
    choice for passing sensitive data that it is not adequate to store in files in
    a plain format.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当应用程序无法轻松访问磁盘存储时，命令行参数和环境变量是好的选择——例如，在Kubernetes集群中运行的部署情况。实际上，环境变量可以作为Kubernetes
    `.yaml`文件中的参数传递（参见第20章“Kubernetes”中的*副本集和部署*部分）。它们也是传递敏感数据的可接受选择，这些数据不适合以纯文本格式存储在文件中。
- en: From version 8 onward, ASP.NET Core allows you to set Kestrel HTTP and HTTPS
    listening ports as configuration variables. More specifically, `HTTP_PORTS` contains
    a semicolon-separated list of all Kestrel HTTP listening ports, while `HTTPS_PORTS`
    contains a semicolon-separated list of all HTTPs listening ports whose defaults
    are the usual HTTP and HTTPs ports, that is, `80` and `443`, respectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本8开始，ASP.NET Core允许你将Kestrel HTTP和HTTPS监听端口设置为配置变量。更具体地说，`HTTP_PORTS`包含所有Kestrel
    HTTP监听端口的分号分隔列表，而`HTTPS_PORTS`包含所有HTTPs监听端口的分号分隔列表，其默认值是通常的HTTP和HTTPs端口，即`80`和`443`。
- en: The `[EnvironmentName]` string itself is taken from the `ENVIRONMENT` configuration
    setting. Clearly, since it is needed to decide which configuration files to use,
    it cannot be contained in a configuration file, so it must be taken from the `ASPNETCORE_ENVIRONMENT`
    operating system environment variable, or from the arguments of the `dotnet` command
    used to launch the application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`[EnvironmentName]`字符串本身是从`ENVIRONMENT`配置设置中获取的。显然，由于它需要决定使用哪个配置文件，因此它不能包含在配置文件中，所以它必须从操作系统的`ASPNETCORE_ENVIRONMENT`环境变量或启动应用程序时使用的`dotnet`命令的参数中获取。'
- en: When the application is deployed to IIS instead of being launched as a standalone
    program, `ASPNETCORE_ENVIRONMENT` can’t be passed on the `dotnet` command line.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序部署到IIS而不是作为独立程序启动时，`ASPNETCORE_ENVIRONMENT`不能通过`dotnet`命令行传递。
- en: In this case, it can be set in the IIS application settings. This can be done
    after the applications have been deployed, by clicking on the Configuration Editor
    and then selecting the `system.webServer/aspNetCore` section. In the window that
    opens, select `environmentVariables`, and then add the `ASPNETCORE_ENVIRONMENT`
    variable with its value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它可以在 IIS 应用程序设置中设置。这可以在应用程序部署后完成，通过点击配置编辑器然后选择 `system.webServer/aspNetCore`
    部分。在打开的窗口中，选择 `environmentVariables`，然后添加 `ASPNETCORE_ENVIRONMENT` 变量及其值。
- en: '![](img/B19820_17_03.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_17_03.png)'
- en: 'Figure 17.3: Changing ASPNETCORE_ENVIRONMENT in IIS'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3：在 IIS 中更改 ASPNETCORE_ENVIRONMENT
- en: However, when the application is modified and deployed again, the setting is
    reset to its default value, which is `Production`, and it must be set again.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当应用程序被修改并重新部署时，设置会重置为其默认值，即 `Production`，并且必须再次设置。
- en: 'A better choice is to modify the publish profile in Visual Studio, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是修改 Visual Studio 中的发布配置文件，如下所示：
- en: During Visual Studio deployment, Visual Studio’s **Publish** wizard creates
    an XML publish profile. Once the preferred deployment type (Azure, Web Deploy,
    folder, and so on) has been chosen, and before publishing, you can edit the publish
    settings by choosing **Edit** from the **More actions** dropdown in the window
    that appears.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 部署期间，Visual Studio 的 **发布** 向导创建一个 XML 发布配置文件。一旦选择了首选的部署类型（Azure、Web
    Deploy、文件夹等），在发布之前，你可以通过在出现的窗口中选择 **更多操作** 下拉菜单中的 **编辑** 来编辑发布设置。
- en: Once you have your publish file properly set, in Visual Studio **Solution Explorer**,
    open the profile that you just prepared with the Visual Studio wizard. Profiles
    are saved in the `Properties/PublishProfiles/<profile name>.pubxml` path of the
    project folder.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的发布文件设置正确，在 Visual Studio **解决方案资源管理器**中，打开你刚刚使用 Visual Studio 向导准备好的配置文件。配置文件保存在项目文件夹的
    `Properties/PublishProfiles/<profile name>.pubxml` 路径下。
- en: Then, edit the profile with a text editor, and add an XML property such as `<EnvironmentName>Staging</EnvironmentName>`.
    Since all the already defined publish profiles can be selected during the application’s
    publication, you can define a different publish profile for each of your environments,
    and then, you can select the one you need during each publication.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用文本编辑器编辑配置文件，并添加一个 XML 属性，例如 `<EnvironmentName>Staging</EnvironmentName>`。由于所有已定义的发布配置文件都可以在应用程序发布期间选择，你可以为每个环境定义不同的发布配置文件，然后，你可以在每次发布时选择所需的配置文件。
- en: 'The value you must set `ASPNETCORE_ENVIRONMENT` to during deployment can also
    be specified in the Visual Studio ASP.NET Core project file (`.csproj`) of your
    application, by adding the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署期间必须设置的 `ASPNETCORE_ENVIRONMENT` 的值也可以在应用程序的 Visual Studio ASP.NET Core 项目文件（`.csproj`）中指定，通过添加以下代码：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the simplest way to do `ASPNETCORE_ENVIRONMENT`, but not the most modular,
    since we are forced to change the application code before publishing to a different
    environment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是进行 `ASPNETCORE_ENVIRONMENT` 的最简单方法，但不是最模块化的，因为我们被迫在发布到不同环境之前更改应用程序代码。
- en: Specifying the environment either in the publish profile or the project file
    works only for deployment types based on direct communication between Visual Studio
    and the web server, as in other deployment types, Visual Studio cannot inform
    the web server on how to set `ASPNETCORE_ENVIRONMENT` or on how to pass the environment
    when the application is launched. At the time of writing, the techniques described
    work just for Web Deploy or when publishing on Azure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布配置文件或项目文件中指定环境，仅适用于基于 Visual Studio 和 Web 服务器之间直接通信的部署类型，因为在其他部署类型中，Visual
    Studio 无法通知 Web 服务器如何设置 `ASPNETCORE_ENVIRONMENT` 或在应用程序启动时如何传递环境。在撰写本文时，描述的技术仅适用于
    Web Deploy 或在 Azure 上发布。
- en: 'During development in Visual Studio, the value to give to `ASPNETCORE_ENVIRONMENT`
    when the application is run can be specified in the `Properties\launchSettings.json`
    file of the ASP.NET Core project. The `launchSettings.json` file contains several
    named groups of settings. These settings configure how to launch the web application
    when it is run from Visual Studio. You can choose to apply all the settings of
    a group by selecting the group name with the drop-down list next to Visual Studio’s
    run button:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中的开发期间，当应用程序运行时，`ASPNETCORE_ENVIRONMENT` 的值可以在 ASP.NET Core
    项目的 `Properties\launchSettings.json` 文件中指定。`launchSettings.json` 文件包含几个命名的设置组。这些设置配置了从
    Visual Studio 运行 Web 应用程序的方式。你可以通过选择 Visual Studio 运行按钮旁边的下拉列表中的组名来选择应用一个组的所有设置：
- en: '![](img/B19820_17_04.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_17_04.png)'
- en: 'Figure 17.4: Choice of launch settings group'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4：启动设置组的选择
- en: Your selection from this drop-down list will be visible on the run button, with
    the default selection being **IIS Express**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您从下拉列表中的选择将在运行按钮上可见，默认选择为 **IIS Express**。
- en: 'Consider a development environment setup, as illustrated in this typical `launchSettings.json`
    file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个开发环境设置，如图中典型的 `launchSettings.json` 文件所示：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The named groups of settings are under the `profiles` properties. There, you
    can choose where to host the application (`IIS Express`), where to launch the
    browser, and the values of some environment variables.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 设置的命名组位于 `profiles` 属性下。在那里，您可以选择应用程序的托管位置（`IIS Express`）、启动浏览器的位置以及一些环境变量的值。
- en: The current environment that’s been loaded from the `ASPNETCORE_ENVIRONMENT`
    operating system environment variable is available in the `app.Environment` property
    during the ASP.NET Core pipeline definition.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当前从 `ASPNETCORE_ENVIRONMENT` 操作系统环境变量加载的环境可用，在 ASP.NET Core 管道定义期间的 `app.Environment`
    属性中。
- en: '`app.Environment.IsEnvironment(string environmentName)` checks whether the
    current value of `ASPNETCORE_ENVIRONMENT` is `environmentName`. There are also
    specific shortcuts for testing development (`.IsDevelopment()`), production (`.IsProduction()`),
    and staging (`.IsStaging()`). The `app.Environment` property also contains the
    current root directory of the ASP.NET Core application (`.WebRootPath`) and the
    directory reserved for the static files (`.ContentRootPath`) that are served as
    is by the web server (CSS, JavaScript, images, and so on).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.Environment.IsEnvironment(string environmentName)` 检查 `ASPNETCORE_ENVIRONMENT`
    的当前值是否为 `environmentName`。还有针对测试开发（`.IsDevelopment()`）、生产（`.IsProduction()`）和预发布（`.IsStaging()`）的特定快捷方式。`app.Environment`
    属性还包含 ASP.NET Core 应用程序当前根目录（`.WebRootPath`）和由 Web 服务器按原样提供的静态文件目录（`.ContentRootPath`）（CSS、JavaScript、图像等）。'
- en: 'Both `launchSettings.json` and all publish profiles can be accessed as children
    of the **Properties** node in Visual Studio Explorer, as shown in the following
    screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`launchSettings.json` 和所有发布配置文件都可以在 Visual Studio 探索器中的 **属性** 节点下作为子节点访问，如下面的截图所示：'
- en: '![Graphical user interface, text  Description automatically generated](img/B19820_17_05.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B19820_17_05.png)'
- en: 'Figure 17.5: Launch settings file'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.5：启动设置文件
- en: Understanding how to map the merged configuration settings to .NET objects is
    key for effective data management in ASP.NET Core applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何将合并的配置设置映射到 .NET 对象对于在 ASP.NET Core 应用程序中有效管理数据至关重要。
- en: 'Once `appsettings.json` and `appsettings.[EnvironmentName].json` have been
    loaded, the configuration tree resulting from their merge can be mapped to the
    properties of .NET objects. For example, let’s suppose we have an `Email` section
    of the `appsettings` file that contains all of the information needed to connect
    to an email server, as shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了 `appsettings.json` 和 `appsettings.[EnvironmentName].json`，合并后的配置树可以映射到
    .NET 对象的属性。例如，假设我们有一个 `appsettings` 文件的 `Email` 部分，其中包含连接到电子邮件服务器所需的所有信息，如下所示：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, the whole `Email` section can be mapped to an instance of the following
    class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，整个 `Email` 部分可以被映射到以下类的实例：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code that performs the mapping must be inserted in the host building stage,
    since the `EmailConfig` instance will be available through DI. The code we need
    is shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行映射的代码必须在主机构建阶段插入，因为 `EmailConfig` 实例将通过依赖注入 (DI) 提供。所需的代码如下所示：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once we’ve configured the preceding settings, classes that need `EmailConfig`
    data must declare an `IOptions<EmailConfig> options` constructor parameter that
    will be provided by the DI engine. An `EmailConfig` instance is contained in `options.Value`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了前面的设置，需要 `EmailConfig` 数据的类必须声明一个由 DI 引擎提供的 `IOptions<EmailConfig> options`
    构造函数参数。`EmailConfig` 实例包含在 `options.Value` 中。
- en: It is worth mentioning that the option classes’ properties can be applied to
    the same validation attributes we will use for ViewModels (see the *Server-side
    and client-side validation* subsection).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，选项类的属性可以应用于我们将用于 ViewModels 的相同验证属性（见 *服务器端和客户端验证* 子节）。
- en: The next subsection describes the basic ASP.NET Core pipeline modules needed
    by an ASP.NET Core MVC application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了 ASP.NET Core MVC 应用程序所需的基本 ASP.NET Core 管道模块。
- en: Defining the ASP.NET Core pipeline
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 ASP.NET Core 管道
- en: Understanding the ASP.NET Core pipeline is key to customizing application behavior.
    When you create a new ASP.NET Core MVC project in Visual Studio, a standard pipeline
    is created in the `Program.cs` file. There, if needed, you can add further middleware
    or change the configuration of the existing middleware.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core 管道对于自定义应用程序行为至关重要。当你在 Visual Studio 中创建一个新的 ASP.NET Core MVC
    项目时，`Program.cs` 文件中会创建一个标准管道。在那里，如果需要，你可以添加更多的中间件或更改现有中间件的配置。
- en: 'The initial pipeline definition code handles errors and performs basic HTTPS
    configuration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 初始管道定义代码处理错误并执行基本的 HTTPS 配置：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If there are errors, and if the application is in a development environment,
    the module installed by `UseDeveloperExceptionPage` adds a detailed error report
    to the response. This module is a valuable debugging tool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在错误，并且应用程序处于开发环境，则由 `UseDeveloperExceptionPage` 安装的模块会将详细的错误报告添加到响应中。此模块是一个宝贵的调试工具。
- en: If an error occurs when the application is not in development mode, `UseExceptionHandler`
    restores the request processing from the path it receives as an argument, that
    is, from `/Home/Error`. In other words, it simulates a new request with the `/Home/Error`
    path. This request is pushed into the standard MVC processing until it reaches
    the endpoint associated with the `/Home/Error` path, where the developer is expected
    to place the custom code that handles the error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序不在开发模式下发生错误，`UseExceptionHandler` 会从它接收的参数路径恢复请求处理，即从 `/Home/Error`。换句话说，它模拟了一个新的带有
    `/Home/Error` 路径的请求。此请求被推入标准 MVC 处理，直到它达到与 `/Home/Error` 路径关联的端点，在那里开发者预计会放置处理错误的自定义代码。
- en: 'When the application is not in development, `UseHsts` adds the `Strict-Transport-Security`
    header to the response, which informs the browser that the application must only
    be accessed with HTTPS. After this declaration, compliant browsers should automatically
    convert any HTTP request of the application into an HTTPS request for the time
    specified in the `Strict-Transport-Security` header. By default, `UseHsts` specifies
    30 days as the time in the header, but you can specify a different time and other
    header parameters by passing `UseHsts` a lambda that configures an `options` object:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序不在开发模式下时，`UseHsts` 将 `Strict-Transport-Security` 标头添加到响应中，这会通知浏览器应用程序必须仅通过
    HTTPS 访问。在此声明之后，符合规定的浏览器应自动将应用程序的任何 HTTP 请求转换为 `Strict-Transport-Security` 标头中指定时间的
    HTTPS 请求。默认情况下，`UseHsts` 将 30 天指定为标头中的时间，但你可以通过传递一个配置 `options` 对象的 lambda 表达式给
    `UseHsts` 来指定不同的时间和其他标头参数：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`UseHttpsRedirection` causes an automatic redirection to an HTTPS URL when
    an HTTP URL is received, in a way that forces a secure connection. Once the first
    HTTPS secure connection is established, the `Strict-Transport-Security` header
    prevents future redirections that might be used to perform man-in-the-middle attacks.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseHttpsRedirection` 在收到 HTTP URL 时导致自动重定向到 HTTPS URL，以强制建立安全连接。一旦建立了第一个 HTTPS
    安全连接，`Strict-Transport-Security` 标头将防止未来可能用于执行中间人攻击的重定向。'
- en: 'The following code shows the remainder of the default pipeline:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了默认管道的剩余部分：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`UseStaticFiles` makes all files contained in the `wwwroot` folder of the project
    (typically CSS, JavaScript, images, and font files) accessible from the web through
    their actual path.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseStaticFiles` 使项目 `wwwroot` 文件夹中包含的所有文件（通常是 CSS、JavaScript、图像和字体文件）可以通过其实际路径从网络访问。'
- en: '`UseCookiePolicy` has been removed in the .NET 5-8 templates, but you can still
    add it manually. It ensures that cookies are processed by the ASP.NET Core pipeline,
    but only if the user has given consent for cookie usage. Consent to cookie usage
    is given through a consent cookie; that is, cookie processing is enabled only
    if this consent cookie is found among the request cookies. This cookie must be
    created by JavaScript when the user clicks a consent button. The whole string
    that contains both the consent cookie’s name and its contents can be retrieved
    from `HttpContext.Features`, as shown in the following snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseCookiePolicy` 已从 .NET 5-8 模板中移除，但您仍然可以手动添加它。它确保只有在用户同意使用 cookie 的情况下，cookie
    才会被 ASP.NET Core 管道处理。对 cookie 使用同意是通过一个同意 cookie 来给出的；也就是说，只有在请求 cookie 中找到此同意
    cookie 时，才会启用 cookie 处理。此 cookie 必须由 JavaScript 在用户点击同意按钮时创建。包含同意 cookie 的名称及其内容的整个字符串可以从
    `HttpContext.Features` 中检索，如下面的代码片段所示：'
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`CanTrack` is `true` only if consent is required and has not been given yet.
    When the consent cookie is detected, `CanTrack` is set to `false`. This way, `showBanner`
    is `true` only if consent is required and has not been given yet. Therefore, it
    tells us whether to ask the user for consent.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要同意且尚未提供的情况下，`CanTrack` 才为 `true`。当检测到同意cookie时，`CanTrack` 被设置为 `false`。这样，只有当需要同意且尚未提供时，`showBanner`
    才为 `true`。因此，它告诉我们是否需要向用户请求同意。
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`UseAuthentication` enables authentication schemes and only appears if you
    select an authentication scheme when the project is created. More specifically,
    this middleware decodes the authorization tokens (authorization cookies, bearer
    tokens, etc.), and it uses the information it contains to build a `ClaimsPrincipal`
    object that is placed in the `HttpContext.User` property.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthentication` 启用认证方案，并且仅在创建项目时选择认证方案时出现。更具体地说，这个中间件解码授权令牌（授权cookie、bearer令牌等），并使用其中包含的信息构建一个放置在
    `HttpContext.User` 属性中的 `ClaimsPrincipal` 对象。'
- en: 'Specific authentication schemes can be enabled by configuring the options objects
    in the host building stage, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在主机构建阶段配置选项对象来启用特定的认证方案，如下所示：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code specifies a custom authentication cookie name and adds JWT-based
    authentication for the REST services contained in the application. Both `AddCookie`
    and `AddJwtBearer` have overloads that accept the name of the authentication scheme
    before the action, which is where you can define the authentication scheme options.
    Since the authentication scheme name is necessary for referring to a specific
    authentication scheme, when it is not specified, a default name is used:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码指定了一个自定义的认证cookie名称，并为应用程序中包含的 REST 服务添加了基于 JWT 的认证。`AddCookie` 和 `AddJwtBearer`
    都有重载，可以接受在操作之前认证方案的名称，这是您定义认证方案选项的地方。由于认证方案名称对于引用特定认证方案是必要的，因此当它未指定时，将使用默认名称：
- en: The standard name contained in `CookieAuthenticationDefaults.AuthenticationScheme`
    for cookie authentication
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CookieAuthenticationDefaults.AuthenticationScheme` 中包含的用于 cookie 认证的规范名称'
- en: The standard name contained in `JwtBearerDefaults.AuthenticationScheme` for
    JWT authentication
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JwtBearerDefaults.AuthenticationScheme` 中包含的用于 JWT 认证的规范名称'
- en: The name that’s passed into `o.DefaultScheme` selects the authentication scheme,
    used to fill the `User` property of `HttpContext`. Together with `DefaultScheme`,
    other properties also allow more advanced customizations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `o.DefaultScheme` 的名称用于选择认证方案，用于填充 `HttpContext` 的 `User` 属性。与 `DefaultScheme`
    一起，其他属性也允许更高级的定制。
- en: For more information about JWT authentication, please refer to the *ASP.NET
    Core service authorization* subsection of *Chapter 15*, *Applying Service-Oriented
    Architectures with .NET*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JWT 认证的更多信息，请参阅第 15 章，*使用 .NET 应用服务导向架构*中的 *ASP.NET Core 服务授权*子节。
- en: If you just specify `builder.Services.AddAuthentication()`, a cookie-based authentication
    with default parameters is assumed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是指定 `builder.Services.AddAuthentication()`，则假定使用默认参数的基于 cookie 的认证。
- en: '`UseAuthorization` enables authorization based on the `Authorize` attribute.
    Options can be configured by adding `builder.Services.AddAuthorization` to the
    host building stage. These options allow you to define the policies for claims-based
    authorization.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthorization` 允许基于 `Authorize` 属性进行授权。可以通过在主机构建阶段添加 `builder.Services.AddAuthorization`
    来配置选项。这些选项允许您定义基于声明的授权策略。'
- en: '`UseRouting` and `UseEndpoints` handle the so-called ASP.NET Core endpoints.
    An endpoint is an abstraction of a handler that serves specific classes of URLs.
    These URLs are transformed into an `Endpoint` instance with patterns. When a pattern
    matches a URL, an `Endpoint` instance is created and filled with both the pattern’s
    name and the data that was extracted from the URL. This is a consequence of matching
    URL parts with named parts of the pattern. This can be seen in the following code
    snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseRouting` 和 `UseEndpoints` 处理所谓的 ASP.NET Core 端点。端点是对处理特定 URL 类别的处理程序的抽象。这些
    URL 通过模式转换为 `Endpoint` 实例。当模式与 URL 匹配时，会创建一个 `Endpoint` 实例，并填充模式名称和从 URL 中提取的数据。这是通过将
    URL 部分与模式命名的部分匹配实现的。这可以在以下代码片段中看到：'
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`UseRouting` adds a module that processes the request path to get the request
    `Endpoint` instance and adds it to the `HttpContext.Features` dictionary under
    the `IEndpointFeature` type. The actual `Endpoint` instance is contained in the
    `Endpoint` property of `IEndpointFeature`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseRouting` 添加了一个模块，该模块处理请求路径以获取请求 `Endpoint` 实例，并将其添加到 `HttpContext.Features`
    字典中的 `IEndpointFeature` 类型下。实际的 `Endpoint` 实例包含在 `IEndpointFeature` 的 `Endpoint`
    属性中。'
- en: Each pattern also contains the handler that should process all the requests
    that match the pattern. This handler is passed to `Endpoint` when it is created.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模式还包含应处理所有匹配该模式的请求的处理程序。当创建 `Endpoint` 时，将此处理程序传递给 `Endpoint`。
- en: On the other hand, `UseEndpoints` adds the middleware that executes the route
    determined by the `UseRouting` logic. It is placed at the end of the pipeline,
    since its middleware produces the final response. Splitting the routing logic
    into two separate middleware modules enables authorization middleware to sit in
    between them and, based on the matched endpoint, to decide whether to pass the
    request to the `UseEndpoints` middleware for its normal execution, or whether
    to return a 401 (`Unauthorized`)/403 (`Forbidden`) response immediately.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`UseEndpoints` 添加了执行由 `UseRouting` 逻辑确定的路由的中间件。它放置在管道的末尾，因为其中间件生成最终响应。将路由逻辑拆分为两个单独的中间件模块使得授权中间件可以位于它们之间，并根据匹配的端点，决定是否将请求传递给
    `UseEndpoints` 中间件进行正常执行，或者立即返回 401 (`Unauthorized`)/403 (`Forbidden`) 响应。
- en: '`UseAuthorization` must always be placed after both `UseAuthentication` and
    `UseRouting` because it needs both the `HttpContext.User` that is filled by `UseAuthentication`
    and the handler selected by `UseRouting`, in order to verify whether a user is
    authorized to access the selected request handler.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthorization` 必须始终放在 `UseAuthentication` 和 `UseRouting` 之后，因为它需要由 `UseAuthentication`
    填充的 `HttpContext.User` 以及 `UseRouting` 选定的处理程序，以便验证用户是否有权访问所选请求处理程序。'
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Where `app.MapControllerRoute` is a shortcut for:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.MapControllerRoute` 是以下内容的快捷方式：'
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This shortcut was introduced with the 6.0 version of .NET.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此快捷方式是在 .NET 6.0 版本中引入的。
- en: '`MapControllerRoute` defines the patterns associated with the MVC engine, which
    will be described in the next subsection. Other methods define other types of
    patterns. A call such as `.MapHub<MyHub>("/chat")` maps paths to hubs that handle
    **SignalR**, an abstraction built on top of `WebSocket`, whereas `.MapHealthChecks("/health")`
    maps paths to ASP.NET Core components that return application health data.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapControllerRoute` 定义了与 MVC 引擎关联的模式，这将在下一小节中描述。其他方法定义了其他类型的模式。例如，`.MapHub<MyHub>("/chat")`
    将路径映射到处理 **SignalR** 的 hub，SignalR 是建立在 `WebSocket` 之上的抽象，而 `.MapHealthChecks("/health")`
    将路径映射到返回应用程序健康数据的 ASP.NET Core 组件。'
- en: 'You can also directly map a pattern to a custom handler with `.MapGet`, which
    intercepts GET requests, and `.MapPost`, which intercepts POST requests. This
    is called **route to code**. The following is an example of `MapGet`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `.MapGet` 直接将模式映射到自定义处理程序，它拦截 GET 请求，以及 `.MapPost` 拦截 POST 请求。这被称为 **路由到代码**。以下是一个
    `MapGet` 的示例：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can also write `app.MapGet(...)` directly, since there are shortcuts for
    `MapGet`, `MapPost`, and so on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接编写 `app.MapGet(...)`，因为 `MapGet`、`MapPost` 等都有快捷方式。
- en: All these shortcuts, together with the new features, have been named **Minimal
    API**. They offer a lean approach for simpler applications, which is relevant
    for architects considering performance optimization and API design, particularly
    in IoT and microservices scenarios.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些快捷方式，连同新功能，都被命名为 **Minimal API**。它们为更简单的应用程序提供了一种精简的方法，这对于考虑性能优化和 API 设计的架构师来说相关，尤其是在物联网和微服务场景中。
- en: 'Moreover, `MapGet`, `MapPost`, and suchlike have been enhanced, and now they
    have overloads whose lambda returns the result directly to add to the response
    with no need to call `context.Response.WriteAsync`. If the result isn’t a string,
    it is automatically converted into JSON, and the response `Content-Type` is set
    to `application/json`. For more complex needs, Minimal APIs can use the static
    methods of the `Results` class that supports all return types supported by ASP.NET
    Core controllers. The following is an example of `Results` class usage:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`MapGet`、`MapPost` 等类似功能已经得到增强，现在它们具有重载，其 lambda 表达式可以直接将结果返回以添加到响应中，无需调用
    `context.Response.WriteAsync`。如果结果不是字符串，它将自动转换为 JSON，并将响应 `Content-Type` 设置为 `application/json`。对于更复杂的需求，Minimal
    APIs 可以使用 `Results` 类的静态方法，该类支持 ASP.NET Core 控制器支持的所有返回类型。以下是一个 `Results` 类使用的示例：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Patterns are processed in the order in which they are defined until a matching
    pattern is found. Since the authentication/authorization middleware is placed
    after the routing middleware, it can process the `Endpoint` request to verify
    whether the current user has the required authorizations to execute the `Endpoint`
    handler.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模式按照它们定义的顺序进行处理，直到找到匹配的模式。由于身份验证/授权中间件放置在路由中间件之后，它可以处理`Endpoint`请求以验证当前用户是否有执行`Endpoint`处理器的必要授权。
- en: Otherwise, a 401 (`Unauthorized`) or 403 (`Forbidden`) response is immediately
    returned. Only requests that survive authentication and authorization have their
    handlers executed by the `UseEndpoints` middleware.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，将立即返回401（未授权）或403（禁止）响应。只有通过身份验证和授权的请求才会由`UseEndpoints`中间件执行其处理器。
- en: The Minimal API supports the automatic generation of the OpenAPI metadata we
    described in *Chapter 15*, *Applying Service-Oriented Architectures with .NET.*
    They also support **Ahead-of-Time** (**AOT**) compilation during the application
    publication. This way, applications are immediately compiled in the target CPU
    language, saving the time needed by a just-in-time compilation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最小API支持我们在第15章*使用.NET应用服务架构*中描述的OpenAPI元数据的自动生成。它们还支持在应用程序发布时的**即时编译**（**AOT**）。这样，应用程序会立即在目标CPU语言中编译，节省了即时编译所需的时间。
- en: Moreover, since AOT runs at publication time, it can perform better code optimizations,
    and in particular, it can trim DLL unused code. In general, AOT is not supported
    by controller-based applications since they make greater use of reflection.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于AOT在发布时运行，它可以执行更好的代码优化，特别是它可以修剪DLL中未使用的代码。通常，AOT不被基于控制器的应用程序支持，因为它们更多地使用了反射。
- en: Therefore, Minimal APIs are targeted to simple and fast applications, running
    on small devices such as IoT applications, where, on one hand, speed and reduced
    application size are fundamental, and on the other hand, the benefit of structuring
    code through controllers is negligible. We will not describe Minimal APIs in great
    detail, since this book targets mainly business and enterprise applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最小API针对的是简单且快速的应用程序，运行在小型设备上，如物联网应用程序，在这些应用中，一方面速度和减小应用程序大小是基本的，另一方面，通过控制器结构化代码的好处是可以忽略不计。我们不会详细描述最小API，因为这本书主要针对商业和企业应用程序。
- en: It is worth mentioning that in the last .NET version, a new **ASP.NET Core API**
    project was added that scaffolds an application based on the Minimal API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在最新的.NET版本中，添加了一个新的**ASP.NET Core API**项目，它基于最小API生成应用程序。
- en: 'Like the ASP.NET Core RESTful API described in *Chapter 15*, ASP.NET Core MVC
    also uses attributes placed on controllers or controller methods to specify authorization
    rules. However, an instance of `AuthorizeAttribute` can also be added to a pattern
    to apply its authorization constraints to all the URLs matching that pattern,
    as shown in the following example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如第15章中描述的ASP.NET Core RESTful API一样，ASP.NET Core MVC也使用放置在控制器或控制器方法上的属性来指定授权规则。然而，也可以将`AuthorizeAttribute`的实例添加到一个模式中，以便将其授权约束应用于所有匹配该模式的URL，如下面的示例所示：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The previous code makes the health check path available only to administrative
    users.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使健康检查路径仅对管理员用户可用。
- en: 'It is also worth mentioning the `.UseCors()` middleware, which enables the
    application to handle CORS policies. We will discuss it in the *Communication
    with the server* section in *Chapter 19, Client Frameworks: Blazor*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是`.UseCors()`中间件，它使应用程序能够处理CORS策略。我们将在第19章“客户端框架：Blazor”的*与服务器通信*部分中讨论它。
- en: Having described the basic structure of the ASP.NET Core framework, we can now
    move on to more MVC-specific features. The next subsection describes controllers
    and explains how they interact with the UI components, known as Views, through
    ViewModels.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了ASP.NET Core框架的基本结构之后，我们现在可以继续探讨更多与MVC相关的特性。下一小节将介绍控制器，并解释它们如何通过ViewModel与UI组件（称为视图）交互。
- en: Defining controllers and ViewModels
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义控制器和ViewModel
- en: In ASP.NET Core MVC, controllers and ViewModels are central to handling requests,
    presenting data, and handling the whole user-application interactions. Let’s start
    by understanding how requests issued at specific paths are passed to controllers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core MVC中，控制器和ViewModel是处理请求、展示数据和处理整个用户-应用程序交互的核心。让我们首先了解如何将特定路径发出的请求传递到控制器。
- en: The various `.MapControllerRoute` calls associate URL patterns with controllers
    and their methods, where controllers are classes that inherit from the `Microsoft.AspNetCore.Mvc.Controller`
    class. Controllers are discovered by inspecting all of the application’s `.dll`
    files and are added to the DI engine. This job is performed by the call to `builder.Services.AddControllersWithViews`
    in the `Program.cs` file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`.MapControllerRoute` 调用将 URL 模式与控制器及其方法关联起来，其中控制器是从 `Microsoft.AspNetCore.Mvc.Controller`
    类继承的类。控制器通过检查应用程序的所有 `.dll` 文件被发现，并添加到依赖注入引擎中。这项工作是通过在 `Program.cs` 文件中调用 `builder.Services.AddControllersWithViews`
    来完成的。'
- en: The pipeline module that’s added by `UseEndpoints` takes the controller’s name
    from the `controller` pattern variable, and the name of the controller method
    to invoke from the `action` pattern variable. Since, by convention, all controller
    names are expected to end with the `Controller` suffix, the actual controller
    type name is obtained from the name found in the `controller` variable by adding
    this suffix. Hence, for instance, if the name found in `controller` is `Home`,
    then the `UseEndpoints` module tries to get an instance of the `HomeController`
    type from the DI engine. All of the controller public methods can be selected
    by the routing rules. The use of a controller public method can be prevented by
    decorating it with the `[NonAction]` attribute. All controller methods available
    to the routing rules are called action methods.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `UseEndpoints` 添加的管道模块从 `controller` 模式变量中获取控制器名称，并从 `action` 模式变量中获取要调用的控制器方法名称。由于按照惯例，所有控制器名称都期望以
    `Controller` 后缀结尾，因此实际控制器类型名称是通过在 `controller` 变量中找到的名称添加此后缀来获得的。因此，例如，如果在 `controller`
    中找到的名称是 `Home`，那么 `UseEndpoints` 模块会尝试从依赖注入引擎中获取 `HomeController` 类型的实例。所有可由路由规则选择的控制器公共方法都可以称为操作方法。可以通过使用
    `[NonAction]` 属性来阻止使用控制器公共方法。所有可供路由规则使用的控制器方法都称为操作方法。
- en: MVC controllers work like the API controllers that we described in the *Implementing
    REST services with ASP.NET Core* subsection in *Chapter 15*, *Applying Service-Oriented
    Architectures with .NET*. The only difference is that API controllers are expected
    to produce JSON or XML, while MVC controllers are expected to produce HTML. For
    this reason, while API controllers inherit from the `ControllerBase` class, MVC
    controllers inherit from the `Controller` class, which, in turn, inherits from
    the `ControllerBase` class and adds its methods, which are useful for HTML generation,
    such as invoking views, as described in the next subsection, and creating a redirect
    response.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 控制器的工作方式类似于我们在 *第 15 章*，*使用 .NET 应用服务架构* 中 *实现 REST 服务* 的子节中描述的 API 控制器。唯一的区别是
    API 控制器预计会产生 JSON 或 XML，而 MVC 控制器预计会产生 HTML。因此，虽然 API 控制器从 `ControllerBase` 类继承，但
    MVC 控制器从 `Controller` 类继承，该类反过来又从 `ControllerBase` 类继承并添加了用于 HTML 生成的方法，如下一节所述，以及创建重定向响应。
- en: MVC controllers can also use a routing technique similar to one of the API controllers,
    that is, routing based on controllers and controller method attributes. This behavior
    is enabled by calling the `app.MapControllers()` method in the pipeline definition
    code in `Program.cs`. If this call is placed before all other `app.MapControllerRoute`
    calls, then the controller routes have priority over `MapControllerRoute` patterns;
    otherwise, the opposite is true.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 控制器也可以使用类似于 API 控制器的一种路由技术，即基于控制器和控制器方法属性的路由。这种行为是通过在 `Program.cs` 文件中的管道定义代码中调用
    `app.MapControllers()` 方法来启用的。如果这个调用放在所有其他 `app.MapControllerRoute` 调用之前，那么控制器路由比
    `MapControllerRoute` 模式具有优先级；否则，情况相反。
- en: '`MapControllerRoute` has the advantage of deciding in a single place the whole
    paths used by the whole application. This way, you can optimize all application
    paths for a search engine, or simply for better user navigation, by changing a
    few lines of code in a single place. For these reasons, `MapControllerRoute` is
    almost always used in MVC applications. However, `MapControllerRoute` is rarely
    used with the REST API because the priority of the REST API is to avoid changes
    in the associations between paths and controllers, since they might prevent existing
    clients from working properly.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapControllerRoute` 的优点是可以在一个地方决定整个应用程序使用的所有路径。这样，您可以通过在单个地方更改几行代码来优化所有应用程序路径，以便搜索引擎优化或简单地为了更好的用户导航。因此，`MapControllerRoute`
    几乎总是用于 MVC 应用程序。然而，`MapControllerRoute` 很少与 REST API 一起使用，因为 REST API 的优先级是避免路径和控制器之间的关联变化，因为这些变化可能会阻止现有客户端正常工作。'
- en: All the attributes we have seen for API controllers can also be used with MVC
    controllers and action methods (`HttpGet`, `HttpPost`, …, `Authorize`, and so
    on). Developers can write their own custom attributes by inheriting from the `ActionFilter`
    class or other derived classes. I will not give details on this right now, but
    these details can be found in the official documentation, which is referred to
    in the *Further reading* section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到的API控制器属性也可以用于MVC控制器和动作方法（`HttpGet`、`HttpPost`……、`Authorize`等）。开发者可以通过从`ActionFilter`类或其他派生类继承来编写自己的自定义属性。我现在不会详细介绍这一点，但这些细节可以在官方文档中找到，该文档在*进一步阅读*部分有提及。
- en: When the `UseEndpoints` module invokes a controller, all of its constructor
    parameters are filled by the DI engine, since the controller instance itself is
    returned by the DI engine, and since DI automatically fills constructor parameters
    with DI in a recursive fashion.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当`UseEndpoints`模块调用控制器时，所有构造函数参数都由DI引擎填充，因为控制器实例本身是由DI引擎返回的，并且DI会递归地自动用DI填充构造函数参数。
- en: 'Action methods take both their input and services from their parameters, so
    it is crucial to understand how these parameters are filled by ASP.NET Core. They
    are taken from the following sources:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 动作方法从它们的参数中获取输入和服务，因此理解这些参数如何由ASP.NET Core填充至关重要。它们来自以下来源：
- en: Request headers
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求头
- en: Variables in the pattern matched by the current request
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前请求匹配的模式中的变量
- en: Query string parameters
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询字符串参数
- en: Form parameters (in the case of POST requests)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单参数（在POST请求的情况下）
- en: The request body
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求正文
- en: '**Dependency injection** (**DI**), in case of services needed to process the
    request'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**），在需要处理请求的服务的情况下'
- en: While the parameters filled with DI are matched by type, all other parameters
    are matched by *name* while ignoring the letter casing. That is, the action method
    parameter name must match the header, query string, form, or pattern variable.
    In turn, pattern variables are filled by matching the pattern with the request
    path.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用依赖注入（DI）填充的参数按类型匹配时，所有其他参数都按*名称*匹配，忽略字母大小写。也就是说，动作方法参数名称必须与标题、查询字符串、表单或模式变量匹配。反过来，模式变量通过将模式与请求路径匹配来填充。
- en: When the parameter is a complex type, the behavior depends on the source.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数是复杂类型时，其行为取决于来源。
- en: If the source is the request body, a **formatter** adequate for the request
    `Content-Type` is selected. **Formatters** are software modules capable of building
    complex entities, starting from a text representation of them. As a default, the
    request body is taken as a source for selected `Content-Types`, such as `application/json`
    and binary MIME types, because each such MIME type requires a different deserialization
    algorithm that is specific to it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果来源是请求正文，则选择一个适合请求`Content-Type`的**格式化器**。**格式化器**是能够从它们的文本表示形式构建复杂实体的软件模块。默认情况下，请求正文被视为选择`Content-Types`（如`application/json`和二进制MIME类型）的来源，因为每种这样的MIME类型都需要一个特定的反序列化算法，该算法针对它本身。
- en: If the source is not the request body, an algorithm called model binding is
    used to fill all complex object public properties instead.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果来源不是请求正文，则使用名为模型绑定的算法来填充所有复杂对象的公共属性。
- en: 'The model binding algorithm searches for a match in each property (remember
    that just properties are mapped; fields are not), using the property name for
    the match. In the case of nested complex types, a match is searched for each nested
    property’s path, and the name associated with the path is obtained by chaining
    all the property names in the path and separating them with dots. For instance,
    a parameter whose name is `Property1.Property2.Property3…Propertyn` is mapped
    with the `Propertyn` property that is in the following path of nested object properties:
    `Property1`, `Property2`, ...., `Propertyn`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 模型绑定算法在每个属性中搜索匹配项（记住，只有属性会被映射；字段不会被映射），使用属性名称进行匹配。在嵌套复杂类型的情况下，会为每个嵌套属性的路径搜索匹配项，通过连接路径中的所有属性名称并使用点分隔来获得与路径关联的名称。例如，名称为`Property1.Property2.Property3…Propertyn`的参数与以下嵌套对象属性路径中的`Propertyn`属性映射：`Property1`、`Property2`、......、`Propertyn`。
- en: The name that’s obtained this way must match a header name, pattern variable
    name, query string parameter name, and so on. For instance, an `OfficeAddress`
    property containing a complex `Address` object would generate names like `OfficeAddress.Country`
    and `OfficeAddress.Town`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式获得的名字必须与头名称、模式变量名称、查询字符串参数名称等匹配。例如，包含复杂`Address`对象的`OfficeAddress`属性将生成如`OfficeAddress.Country`和`OfficeAddress.Town`之类的名称。
- en: The model binding algorithm can also fill collections and dictionaries, but
    due to a lack of space, we can’t describe these cases. However, the *Further reading*
    section contains a link to an excellent Phil Haack post that explains them in
    detail.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 模型绑定算法还可以填充集合和字典，但由于篇幅限制，我们无法描述这些情况。然而，在*进一步阅读*部分包含了一个链接，指向Phil Haack的一篇优秀的文章，详细解释了这些情况。
- en: 'By default, simple type parameters are matched with pattern variables and query
    string variables, while complex type parameters are matched with form parameters
    or the request body (depending on their MIME types). However, the preceding defaults
    can be changed by prefixing the parameters with attributes, as detailed here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，简单类型参数与模式变量和查询字符串变量匹配，而复杂类型参数则与表单参数或请求体（取决于它们的MIME类型）匹配。然而，可以通过在参数前添加属性来更改前面的默认设置，具体细节请参考此处：
- en: '`[FromForm]` forces a match with form parameters'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromForm]` 强制与表单参数匹配'
- en: '`[FromBody]` forces the extraction of data from the request body'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromBody]` 强制从请求体中提取数据'
- en: '`[FromHeader]` forces a match with a request header'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromHeader]` 强制与请求头匹配'
- en: '`[FromRoute]` forces a match with pattern variables'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromRoute]` 强制与模式变量匹配'
- en: '`[FromQuery]` forces a match with a query string variable'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromQuery]` 强制与查询字符串变量匹配'
- en: '`[FromServices]` forces the use of DI'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromServices]` 强制使用依赖注入（DI）'
- en: It is worth pointing out that versions 7 and 8 of ASP.NET Core have an enhanced
    Minimal API to support basically the same parameter bindings of a controller’s
    action methods, as well as all the above parameter attributes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，ASP.NET Core的7和8版本增强了最小API，以支持控制器操作方法的基本相同的参数绑定，以及上述所有参数属性。
- en: 'During the match, the string that was extracted from the selected source is
    converted into the type of the action method parameter, using the current thread
    culture. If either a conversion fails or no match is found for an obligatory action
    method parameter, then the whole action method invocation process fails, and a
    404 response is automatically returned. For instance, in the following example,
    the `id` parameter is matched with query string parameters or pattern variables,
    since it is a simple type, while `myclass` properties and nested properties are
    matched with form parameters, since `MyClass` is a complex type. Finally, `myservice`
    is taken from DI, since it is prefixed with the `[FromServices]` attribute:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配过程中，从所选源提取的字符串将使用当前线程的文化转换为操作方法参数的类型。如果转换失败或找不到必需的操作方法参数的匹配项，则整个操作方法调用过程失败，并自动返回404响应。例如，在以下示例中，由于`id`参数是简单类型，因此它与查询字符串参数或模式变量匹配，而`myclass`属性和嵌套属性则与表单参数匹配，因为`MyClass`是复杂类型。最后，从DI中获取`myservice`，因为它前面带有`[FromServices]`属性：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If no match is found for the `id` parameter, and if the `id` parameter is declared
    as obligatory in the `MapControllerRoute` pattern, a 404 response is automatically
    returned, since pattern matching fails. It is common to declare parameters as
    not optional when they must match not-nullable single types. If, instead, no `MyService`
    instance is found in the DI container, an exception is thrown because, in this
    case, the failure doesn’t depend on a wrong request but on a design error.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到`id`参数的匹配项，并且如果`id`参数在`MapControllerRoute`模式中被声明为必需，则会自动返回404响应，因为模式匹配失败。通常，当参数必须匹配非空单类型时，会将参数声明为非可选。相反，如果在DI容器中找不到`MyService`实例，则会抛出异常，因为在这种情况下，失败并不取决于错误的请求，而是设计错误。
- en: MVC controllers return an `IActionResult` interface or a `Task<IActionResult>`
    result if they are declared as `async`. `IActionResult` defines the unique method
    with the `ExecuteResultAsync(ActionContext)` signature, which, when invoked by
    the framework, produces the actual response.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MVC控制器被声明为`async`，则返回`IActionResult`接口或`Task<IActionResult>`结果。`IActionResult`定义了一个具有`ExecuteResultAsync(ActionContext)`签名的独特方法，当框架调用该方法时，会产生实际的响应。
- en: 'For each different `IActionResult`, MVC controllers have methods that return
    them. The most commonly used `IActionResult` is `ViewResult`, which is returned
    by a `View` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个不同的 `IActionResult`，MVC 控制器都有返回它们的方法。最常用的 `IActionResult` 是 `ViewResult`，它由
    `View` 方法返回：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ViewResult` is a very common way for a controller to create an HTML response.
    More specifically, the controller interacts with business/data layers to produce
    an abstraction of the data that will be shown on the HTML page. This abstraction
    is an object called a **ViewModel**. The ViewModel is passed as a second argument
    to the `View` method, while the first argument is the name of an HTML template,
    called `View`, that is instantiated with the data contained in the ViewModel.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewResult` 是控制器创建 HTML 响应的一种非常常见的方式。更具体地说，控制器与业务/数据层交互，以生成将在 HTML 页面上显示的数据的抽象。这个抽象是一个名为
    **ViewModel** 的对象。ViewModel 作为 `View` 方法的第二个参数传递，而第一个参数是名为 `View` 的 HTML 模板的名称，该模板使用
    ViewModel 中包含的数据实例化。'
- en: 'Summing this up, the MVC controllers’ processing sequence is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，MVC 控制器的处理顺序如下：
- en: The controllers perform some processing to create the ViewModel, which is an
    abstraction of the data to show on the HTML page.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器执行一些处理以创建 ViewModel，这是要在 HTML 页面上显示的数据的抽象。
- en: Then, the controllers create `ViewResult` by passing a View name and ViewModel
    to the `View` method.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，控制器通过将视图名称和 ViewModel 传递给 `View` 方法来创建 `ViewResult`。
- en: The MVC framework invokes `ViewResult` and causes the template contained in
    the View to be instantiated with the data contained in the ViewModel.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC 框架调用 `ViewResult` 并导致包含在视图中的模板使用 ViewModel 中的数据实例化。
- en: The result of the template’s instantiation is written in the response with adequate
    headers.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板实例化的结果将带有适当的头信息写入响应中。
- en: This way, the controller performs the conceptual job of HTML generation by building
    a ViewModel, while the View – that is, the template – takes care of all the presentation
    details.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，控制器通过构建 ViewModel 执行 HTML 生成的概念性工作，而视图（即模板）则负责所有展示细节。
- en: Views will be described in greater detail in the next subsection, while the
    Model (ViewModel) View Controller pattern will be discussed in more detail in
    the *Understanding the connection between ASP.NET Core MVC and design principles*
    section in this chapter. Finally, a practical example will be provided in *Chapter
    18*, *Implementing Frontend Microservices with ASP.NET Core*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中将对视图进行更详细的描述，而模型（ViewModel）视图控制器模式将在本章的 *理解 ASP.NET Core MVC 与设计原则之间的联系*
    部分进行更详细的讨论。最后，将在 *第 18 章*，*使用 ASP.NET Core 实现前端微服务* 中提供一个实际示例。
- en: Another common `IActionResult` is `RedirectResult`, which creates a redirect
    response, hence forcing the browser to move to a specific URL. Redirects are often
    used once the user has successfully submitted a form that completes a previous
    operation. In this case, it is common to redirect the user to a page where they
    can select another operation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的 `IActionResult` 是 `RedirectResult`，它创建一个重定向响应，从而强制浏览器移动到特定的 URL。重定向通常在用户成功提交一个完成先前操作的表单后使用。在这种情况下，通常将用户重定向到可以选择另一个操作的页面。
- en: The simplest way to return `RedirectResult` is by passing a URL to the `Redirect`
    method. This is the advised way to perform a redirect to a URL that is outside
    the web application. On the other hand, when the URL is within the web application,
    it is advisable to use the `RedirectToAction` method, which accepts the controller’s
    name, the action method name, and the desired parameters for the target action
    method. This method has several overloads, where each overload omits some of the
    above parameters. In particular, the controller name can be omitted if the URL
    we define is handled by the same controller.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `RedirectResult` 的最简单方式是通过传递一个 URL 给 `Redirect` 方法。这是建议用于将用户重定向到 web 应用程序外部的
    URL 的方法。另一方面，当 URL 在 web 应用程序内部时，建议使用 `RedirectToAction` 方法，该方法接受控制器的名称、操作方法的名称以及目标操作方法所需的参数。此方法有几个重载，其中每个重载省略了上述参数的一部分。特别是，如果定义的
    URL 由同一控制器处理，则可以省略控制器名称。
- en: The framework uses this data to compute a URL that causes the desired action
    method to be invoked with the parameters provided. This way, if the routing rules
    are changed during the application’s development or maintenance, the new URL is
    automatically updated by the framework, with no need to modify all occurrences
    of the old URL in the code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 框架使用这些数据来计算一个 URL，该 URL 会调用具有提供参数的期望操作方法。这样，如果在应用程序的开发或维护期间更改了路由规则，框架会自动更新新的
    URL，无需修改代码中所有旧 URL 的出现。
- en: 'The following code shows how to call `RedirectToAction`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何调用 `RedirectToAction`：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another useful `IActionResult` is `ContentResult`, which can be created by
    calling the `Content` method. `ContentResult` allows you to write any string to
    the response and specify its MIME type, as shown in the following example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 `IActionResult` 是 `ContentResult`，可以通过调用 `Content` 方法创建。`ContentResult`
    允许你将任何字符串写入响应并指定其 MIME 类型，如下面的示例所示：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, the `File` method returns `FileResult`, which writes binary data in
    the response. There are several overloads of this method that allow the specification
    of a byte array, a stream, or the path of a file, plus the MIME type of the binary
    data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`File` 方法返回 `FileResult`，它在响应中写入二进制数据。此方法有几个重载，允许指定字节数组、流或文件的路径，以及二进制数据的
    MIME 类型。
- en: Now, let’s move on to describing how actual HTML is generated in Views.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续描述如何在视图中生成实际的 HTML。
- en: Understanding how ASP.NET Core MVC creates the response HTML
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core MVC 如何创建响应 HTML
- en: Razor Views
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Razor 视图
- en: 'ASP.NET Core MVC uses a language called Razor to define the HTML templates
    contained in the Views. Razor views are files that are compiled into .NET classes
    when they’re first used, when the application has been built, or when the application
    has been published. By default, both pre compilation on each build and on publish
    are enabled, but you can also enable runtime compilation so that the Views can
    be modified once they have been deployed. This option can be enabled by checking
    the **Enable Razor runtime compilation** checkbox when the project is created
    in Visual Studio. You can also disable compilation on each build and on publish
    by adding the following code to the web application project file:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 使用名为 Razor 的语言来定义视图中的 HTML 模板。Razor 视图是文件，首次使用时、应用程序构建时或应用程序发布时会被编译成
    .NET 类。默认情况下，每次构建和发布时都会启用预编译，但你也可以启用运行时编译，以便在视图部署后进行修改。此选项可以通过在 Visual Studio
    中创建项目时勾选 **启用 Razor 运行时编译** 复选框来启用。你还可以通过向 Web 应用程序项目文件中添加以下代码来禁用每次构建和发布时的编译：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Views can also be precompiled into Views libraries if you choose a Razor view
    library project in the window, which appears once you have chosen an ASP.NET Core
    project.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在选择 ASP.NET Core 项目后出现的窗口中选择 Razor 视图库项目，视图也可以预先编译成视图库。
- en: Also, following the compilation, Views remain associated with their paths, which
    become their full names. Each controller has an associated folder under the **Views**
    folder with the same name as the controller, which is expected to contain all
    the Views used by that controller.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编译后，视图与其路径保持关联，这些路径成为它们的完整名称。每个控制器在 **Views** 文件夹下都有一个与其同名的关联文件夹，该文件夹预计将包含该控制器使用的所有视图。
- en: 'The following screenshot shows the folder associated with a possible `HomeController`
    and its Views:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了与可能的 `HomeController` 及其视图关联的文件夹：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_17_06.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序  自动生成的描述](img/B19820_17_06.png)'
- en: 'Figure 17.6: View folders associated with controllers and the shared folder'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6：与控制器和共享文件夹关联的视图文件夹
- en: The preceding screenshot also shows the **Shared** folder, which is expected
    to contain all the Views or partial views used by several controllers. The controller
    refers to views in the `View` method through their paths without the `.cshtml`
    extension. If the path starts with `/`, the path is interpreted as relative to
    the application root. Otherwise, as a first attempt, the path is interpreted as
    relative to the folder associated with the controller. If no View is found there,
    the View is searched for in the **Shared** folder.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图还显示了**共享**文件夹，该文件夹预计将包含多个控制器使用的所有视图或部分视图。控制器通过不带`.cshtml`扩展名的路径在`View`方法中引用视图。如果路径以`/`开头，则路径被视为相对于应用程序根目录的相对路径。否则，作为第一次尝试，路径被视为相对于与控制器关联的文件夹的相对路径。如果在那里找不到视图，则将在**共享**文件夹中搜索视图。
- en: Hence, for instance, the `Privacy.cshtml` View file in the preceding screenshot
    can be referred to from within `HomeController` as `View("Privacy", MyViewModel)`.
    If the name of the View is the same as the name of the action method, we can simply
    write `View(MyViewModel)`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，前面截图中的`Privacy.cshtml`视图文件可以在`HomeController`内部通过`View("Privacy", MyViewModel)`进行引用。如果视图的名称与动作方法的名称相同，我们可以简单地写`View(MyViewModel)`。
- en: 'Razor views are a mix of HTML code with C# code, plus some Razor-specific statements.
    They usually begin with a header that contains the type of ViewModel that the
    View is expected to receive:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Razor视图是HTML代码与C#代码的混合，还有一些Razor特定的语句。它们通常以包含视图预期接收的ViewModel类型的标题开始：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This declaration may be omitted, but in this case, the view will not be specific
    to a specific type, and we will not be able to use the model property names in
    the Razor code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明可以省略，但在这种情况下，视图将不会针对特定类型，我们也不能在Razor代码中使用模型属性名称。
- en: 'Each view may also contain some `using` statements, whose effect is the same
    as the `using` statements of standard code files:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图也可能包含一些`using`语句，其效果与标准代码文件中的`using`语句相同：
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`@using` statements declared in the special `_ViewImports.cshtml` file – that
    is, in the root of the `Views` folder – are automatically applied to all views.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在特殊文件`_ViewImports.cshtml`中声明的`@using`语句——即在`Views`文件夹的根目录中——将自动应用于所有视图。
- en: 'Each view can also require instances of types from the DI engine in its header,
    with the syntax shown here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图也可以在其标题中要求DI引擎的实例类型，其语法如下：
- en: '[PRE32]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code requires an instance of the `IViewLocalizer` interface and
    places it in the `Localizer` variable. The remainder of the View is a mix of C#
    code, HTML, and Razor control flow statements. Each area of a view can be either
    in HTML mode or C# mode. The code in a View area that is in HTML mode is interpreted
    as HTML, while the code in a View area that is in C# mode is interpreted as C#.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码需要一个`IViewLocalizer`接口的实例，并将其放置在`Localizer`变量中。视图的其余部分是C#代码、HTML和Razor控制流程语句的混合。视图的每个区域可以是HTML模式或C#模式。在HTML模式下处于视图区域的代码被解释为HTML，而在C#模式下处于视图区域的代码被解释为C#。
- en: The topic that follows explains the Razor flow of control statements.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题解释了控制语句的Razor流程。
- en: Learning the Razor flow of control statements
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习控制语句的Razor流程
- en: 'If you want to write some C# code in an HTML area, you can create a C# area
    with the `@{..}` Razor flow of a control statement, as shown here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在HTML区域中编写一些C#代码，你可以创建一个带有控制语句`@{..}`的Razor流程的C#区域，如下所示：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding example shows that it is enough to write an HTML tag to create
    an HTML area inside the C# area and so on recursively. As soon as the HTML tag
    closes, you are in C# mode again.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明，在C#区域内创建HTML区域并递归地创建其他HTML区域，只需编写一个HTML标签就足够了。一旦HTML标签关闭，你又将回到C#模式。
- en: 'If we need to create an HTML area but don’t want to enclose it in an HTML tag,
    we can use the fake `<text>` tag provided by Razor syntax:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要创建一个HTML区域，但又不想用HTML标签将其包围，我们可以使用Razor语法提供的虚拟`<text>`标签：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'C# code produces no HTML, while HTML code is added to the response in the same
    order in which it appears. You can add text computed with C# code while in HTML
    mode by prefixing any C# expression with `@`. If the expression is complex, in
    that it is composed of a chain of properties and method calls, it must be enclosed
    by parentheses. The following code shows some examples:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: C#代码不会产生HTML，而HTML代码将按照它出现的顺序添加到响应中。你可以在HTML模式下通过在C#表达式前加`@`来添加用C#代码计算出的文本。如果表达式复杂，即由属性链和方法的调用组成，则必须用括号括起来。以下代码显示了几个示例：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `@` itself can be escaped by entering it twice – `@@`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`@`本身可以通过输入两次来转义——`@@`。'
- en: Types are converted into strings using the current culture settings (see the
    *Understanding the connection between ASP.NET Core MVC and design principles*
    section for details on how to set the culture of each request). Moreover, strings
    are automatically HTML-encoded to avoid the `<` and `>` symbols, which might interfere
    with the view HTML.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 类型会根据当前的文化设置转换为字符串（有关如何设置每个请求的文化，请参阅*理解ASP.NET Core MVC与设计原则之间的联系*部分以获取详细信息）。此外，字符串会自动进行HTML编码以避免`<`和`>`符号，这些符号可能会干扰视图的HTML。
- en: 'HTML encoding can be prevented with the `@HTML.Raw` function, as shown here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@HTML.Raw`函数防止HTML编码，如下所示：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In an HTML area, alternative HTML can be selected with the `@if` Razor statement:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML区域中，可以使用`@if` Razor语句选择替代HTML：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As shown in the preceding code, the beginning of each block of a Razor control
    flow statement is in C# mode and remains so until the first HTML open tag is encountered,
    and then, HTML mode starts. C# mode is resumed after the corresponding HTML close
    tag.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，Razor控制流语句的每个块的开始都在C#模式下，并且保持这种模式，直到遇到第一个HTML开放标签，然后开始HTML模式。在相应的HTML关闭标签之后，将恢复C#模式。
- en: 'An HTML template can be instantiated several times with the `for`, `foreach`,
    `while`, and `do` Razor statements, as shown in the following examples:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: HTML模板可以使用`for`、`foreach`、`while`和`do` Razor语句实例化多次，如下面的示例所示：
- en: '[PRE38]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Razor views can contain comments that do not generate any code. Any text included
    within `@*...*@` is considered a comment and removed when the page is compiled.
    With a good understanding of controllers and their operational mechanics, let’s
    now turn to how ASP.NET Core MVC generates HTML responses using Razor views.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Razor视图可以包含不会生成任何代码的注释。任何包含在`@*...*@`内的文本都被视为注释，并在页面编译时被移除。在对控制器及其操作机制有良好理解的基础上，我们现在转向ASP.NET
    Core MVC如何使用Razor视图生成HTML响应。
- en: Understanding Razor view properties
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解Razor视图属性
- en: Some standard variables are predefined in each view. The most important variable
    is `Model`, which contains the ViewModel that was passed to the view. For instance,
    if we pass a `Person` model to a view, then `<span>@Model.Name</span>` displays
    the name of the `Person` model that was passed to the view.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图中都预定义了一些标准变量。最重要的变量是`Model`，它包含传递给视图的ViewModel。例如，如果我们向视图传递一个`Person`模型，那么`<span>@Model.Name</span>`将显示传递给视图的`Person`模型的名称。
- en: The `ViewData` variable contains `IDictionary<string, object>`, which is shared
    with the controller that invoked the view; that is, all controllers also have
    a `ViewData` property containing `IDictionary<string, object>`, and every entry
    that is set in the controller is also available in the `ViewData` variable of
    the invoked view. `ViewData` is an alternative to the ViewModel for a controller,
    allowing the passing of information to its invoked view. It is worth mentioning
    that the `ViewData` dictionary can also be accessed as a dynamic object through
    the `ViewBag` property. This means that dynamic `ViewBag` properties are mapped
    to `ViewData` string indices and that their values are mapped to the `ViewData`
    entries corresponding to those indices. Using `ViewData` or `ViewBag` is just
    a matter of preference; neither one has an advantage over the other.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewData`变量包含`IDictionary<string, object>`，它与调用视图的控制器共享；也就是说，所有控制器也都有一个包含`IDictionary<string,
    object>`的`ViewData`属性，并且控制器中设置的每个条目在调用视图的`ViewData`变量中也是可用的。`ViewData`是控制器对ViewModel的替代方案，允许将信息传递给其调用的视图。值得一提的是，`ViewData`字典也可以通过`ViewBag`属性作为动态对象访问。这意味着动态`ViewBag`属性映射到`ViewData`字符串索引，而它们的值映射到对应索引的`ViewData`条目。使用`ViewData`或`ViewBag`只是个人偏好的问题；两者之间没有优势。'
- en: 'Often, `ViewData` is used to store collateral data such as the value-string
    pairs used to populate an HTML Select. For instance, let’s suppose the ViewModel
    model contains `TownId` and `TownName` properties that the user can change, by
    selecting a different town from an HTML Select. In this case, the action method
    might fill the `"AllTowns"` entry of `ViewData` with all possible town ID and
    town name pairs:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`ViewData`用于存储辅助数据，例如用于填充HTML Select的值-字符串对。例如，假设ViewModel模型包含用户可以通过从HTML
    Select中选择不同的城镇来更改的`TownId`和`TownName`属性。在这种情况下，操作方法可能会将`"AllTowns"`条目填充到`ViewData`中，包含所有可能的城镇ID和城镇名称对：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Both controllers and Views also contain a `TempData` dictionary, whose entries
    are remembered between two successive requests. Due to a lack of space, we can’t
    discuss its properties and its usage, but the interested among you can refer to
    the official Microsoft documentation:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器和视图也包含一个 `TempData` 字典，其条目在连续的两个请求之间被记住。由于空间有限，我们无法讨论其属性及其用法，但感兴趣的读者可以参考官方的Microsoft文档：
- en: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-8.0#tempdata](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-8.0#tempdata)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-8.0#tempdata](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-8.0#tempdata)'
- en: The `User` view variable contains the currently logged-in user, that is, the
    same instance contained in the current request’s `Http.Context.User` property.
    The `Url` variable contains an instance of the `IUrlHelper` interface, whose methods
    are utilities for computing the URLs of application pages. For instance, `Url.Action("action",
    "controller", new {par1=valueOfPar1,...})` computes the URL that causes the action
    method, `action`, of `controller` to be invoked, with all the parameters specified
    in the anonymous object passed as its parameters.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 视图变量包含当前登录的用户，即当前请求的 `Http.Context.User` 属性中包含的相同实例。`Url` 变量包含 `IUrlHelper`
    接口的实例，其方法用于计算应用程序页面的URL。例如，`Url.Action("action", "controller", new {par1=valueOfPar1,...})`
    计算导致 `controller` 的 `action` 方法被调用的URL，其中所有参数都在传递给它的匿名对象中指定。'
- en: The `Context` variable contains the whole request’s `HttpContext`. The `ViewContext`
    variable contains data about the context of the view invocation, including metadata
    about the action method that invoked the view.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context` 变量包含整个请求的 `HttpContext`。`ViewContext` 变量包含有关视图调用上下文的数据，包括调用视图的动作方法元数据。'
- en: The next topic describes how Razor views enhance HTML tag syntax.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题描述了Razor视图如何增强HTML标签语法。
- en: Using Razor tag helpers
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Razor标签助手
- en: Tag helpers in ASP.NET Core MVC are powerful tools for enhancing HTML tags with
    additional functionalities. More specifically, a tag helper either enhances existing
    HTML tags with new tag attributes or defines completely new tags.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core MVC中，标签助手是增强HTML标签功能性的强大工具。更具体地说，标签助手要么通过新的标签属性增强现有的HTML标签，要么定义全新的标签。
- en: While Razor views are compiled, any tag is matched against existing tag helpers.
    When a match is found, the source tag is replaced with HTML created by the tag
    helpers. Several tag helpers may be defined for the same tag. They are all executed
    in an order that can be configured with a priority attribute associated with each
    tag helper.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当Razor视图被编译时，任何标签都会与现有的标签助手进行匹配。当找到匹配项时，源标签会被标签助手创建的HTML所替换。可以为同一标签定义多个标签助手。它们会按照可以配置的优先级属性关联的顺序执行。
- en: All tag helpers defined for the same tag may cooperate while each tag instance
    is being processed. This is because they are passed a shared data structure where
    each of them may apply a contribution. Usually, the final tag helper that is invoked
    processes this shared data structure to produce the output HTML.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同一标签定义的所有标签助手可以在处理每个标签实例时进行协作。这是因为它们被传递了一个共享的数据结构，每个标签助手都可以在其中应用贡献。通常，最后调用的标签助手会处理这个共享数据结构以生成输出HTML。
- en: Tag helpers are classes that inherit from the `TagHelper` class. This topic
    doesn’t discuss how to create new tag helpers, but it does introduce the main
    predefined tag helpers that come with ASP.NET Core MVC. A complete guide on how
    to define tag helpers is available in the official documentation, which is referenced
    in the *Further reading* section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 标签助手是继承自 `TagHelper` 类的类。本主题不讨论如何创建新的标签助手，但它介绍了随ASP.NET Core MVC一起提供的预定义主要标签助手。有关如何定义标签助手的完整指南可在官方文档中找到，该文档在
    *进一步阅读* 部分中引用。
- en: 'To use a tag helper, you must declare the `.dll` file that contains the tag
    helper with a declaration like the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用标签助手，你必须使用如下声明声明包含标签助手的 `.dll` 文件：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you would like to use just one of the tag helpers defined in the `.dll` file,
    you must replace `*` with the tag name.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想使用 `.dll` 文件中定义的一个标签助手，你必须将 `*` 替换为标签名称。
- en: 'The preceding declaration can be placed either in each view that uses the tag
    helpers defined in the library or, ultimately, in the `_ViewImports.cshtml` file
    in the root of the `Views` folder. By default, `_ViewImports.cshtml` adds all
    predefined ASP.NET Core MVC tag helpers with the following declaration:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明可以放置在每个使用库中定义的标签辅助器的视图中，或者最终放置在`Views`文件夹根目录下的`_ViewImports.cshtml`文件中。默认情况下，`_ViewImports.cshtml`会添加所有预定义的ASP.NET
    Core MVC标签辅助器，如下所示：
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The anchor tag is enhanced with attributes that automatically compute the URL
    and invoke a specific action method with given parameters, as shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点标签通过自动计算URL和调用带有给定参数的特定操作方法来增强，如下所示：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Below is an example of its usage:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它使用的一个示例：
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The HTML created is:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的HTML如下所示：
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It might appear that there is almost no advantage in using the tag helper. However,
    this isn’t true! The advantage is that whenever the routing rules change, the
    tag helper automatically updates the `href` that it generates to conform to the
    new routing rules.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来使用标签辅助器几乎没有优势。然而，这并不正确！优势在于，每当路由规则发生变化时，标签辅助器会自动更新它生成的`href`以符合新的路由规则。
- en: 'A similar syntax is added to the `form` tags:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的语法被添加到`form`标签中：
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `script` tag is enhanced with attributes that allow us to fall back to
    a different source if the download fails. Typical usage is to download scripts
    from some cloud service to optimize the browser cache and to fall back to a local
    copy of the script if there is a failure. The following code uses the fallback
    technique to download the `bootstrap` JavaScript file:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`script`标签通过添加允许我们在下载失败时回退到不同源的属性来增强。典型用法是从某些云服务下载脚本以优化浏览器缓存，并在失败时回退到脚本的本地副本。以下代码使用回退技术下载`bootstrap`JavaScript文件：'
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`asp-fallback-test` contains a JavaScript test that verifies whether the download
    succeeded. In the preceding example, the test verifies whether a JavaScript object
    has been created.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`asp-fallback-test`包含一个JavaScript测试，用于验证下载是否成功。在上面的示例中，测试验证是否已创建JavaScript对象。'
- en: 'All HTML tags that admit an `src` attribute, that is, the `img` and the script
    tags, can be added as an `asp-append-version` attribute set to `true`. The `asp-append-version`
    attribute set to `true` doesn’t change the syntax of the `img` and `script` tags;
    it just adds a hash to the `src` query string to prevent cashing each time the
    image or `script` file changes. Here is an example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所有接受`src`属性的HTML标签，即`img`和`script`标签，都可以添加一个设置为`true`的`asp-append-version`属性集。将`asp-append-version`属性设置为`true`不会改变`img`和`script`标签的语法；它只是在`src`查询字符串中添加一个哈希值，以防止每次图像或`script`文件更改时都进行缓存。以下是一个示例：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Which is rendered as:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 它被渲染为：
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The hash passed in the `v` query parameter is computed from the content of the
    image file, so it changes whenever the image changes, thereby preventing the browser
    from rendering an old cached copy of the image.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`v`查询参数的哈希值是从图像文件的内容计算出来的，因此每当图像发生变化时，它都会改变，从而防止浏览器渲染旧的缓存图像副本。
- en: The `~/` symbol is not a feature specific to the `img` tag helper and, instead,
    a Razor native feature you can use in all links contained in any tag of a Razor
    file. It stands for the application root. It is not equivalent to the HTML `/`
    symbol that stands for the root of the domain, because ASP.NET Core applications
    can also be placed in subfolders of the domain. So `~/` translates as `/` only
    when the application is placed in the domain root; otherwise, it translates as
    `/{application subfolder name}/`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`~/`符号不是`img`标签辅助器的特定功能，而是一个Razor原生功能，您可以在Razor文件的任何标签中的所有链接中使用。它代表应用程序根目录。它不等于代表域名根目录的HTML
    `/`符号，因为ASP.NET Core应用程序也可以放置在域名的子文件夹中。因此，`~/`仅在应用程序放置在域名根目录时才翻译为`/`；否则，它翻译为`/{应用程序子文件夹名称}/`。'
- en: 'The `environment` tag can be used to select different HTML for different environments
    (development, staging, and production). Its typical usage is selecting the debug
    versions of JavaScript files during development, as shown in this example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`environment`标签来选择不同环境（开发、测试和生成）的HTML。它的典型用法是在开发期间选择JavaScript文件的调试版本，如下例所示：
- en: '[PRE49]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'There is also a `cache` tag, which caches its content in memory to optimize
    rendering speed:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`cache`标签，它将内容缓存在内存中以优化渲染速度：
- en: '[PRE50]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: By default, content is cached for 20 minutes, but the tag has attributes that
    must be defined when the cache expires, such as `expires-on="{datetime}"`, `expires-after="{timespan}"`,
    and `expires-sliding="{timespan}"`. Here, the difference between `expires-sliding`
    and `expires-after` is that, in the second attribute, the expiration time count
    is reset each time the content is requested. The `vary-by` attribute causes the
    creation of a different cache entry for each different value passed to `vary-by`.
    There are also attributes such as `vary-by-header`, which creates a different
    entry for each different value assumed by the request header specified in the
    `vary-by-cookie` attribute, and so on.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，内容缓存为20分钟，但必须在缓存过期时定义某些属性，例如`expires-on="{datetime}"`、`expires-after="{timespan}"`和`expires-sliding="{timespan}"`。在这里，`expires-sliding`和`expires-after`之间的区别在于，在第二个属性中，每次请求内容时，过期时间计数都会重置。`vary-by`属性会导致为传递给`vary-by`的不同值创建不同的缓存条目。还有如`vary-by-header`之类的属性，它为`vary-by-cookie`属性中指定的请求头中假设的不同值创建不同的条目，等等。
- en: 'All `input` tags – that is, `textarea`, `input`, and `select` – have an `asp-for`
    attribute that accepts a properties path rooted in the view’s ViewModel as their
    value. For instance, if the view has a `Person` ViewModel, we may have something
    like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`input`标签——即`textarea`、`input`和`select`——都有一个`asp-for`属性，它接受以视图的ViewModel为根的属性路径作为其值。例如，如果视图有一个`Person`
    ViewModel，我们可能会有以下内容：
- en: '[PRE51]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first thing the preceding code does is assign the value of the `Town` nested
    property to the `value` attribute of the `input` tag. In general, if the value
    is not a string, it is converted into a string using the current request culture.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先将嵌套属性`Town`的值分配给`input`标签的`value`属性。一般来说，如果值不是字符串，它将使用当前请求文化将其转换为字符串。
- en: However, it also sets the name of the input field to `Address.Town` and the
    `id` of the input field to `Address_Town`. This is because dots are not allowed
    in tag `ids`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也将输入字段的名称设置为`Address.Town`，并将输入字段的`id`设置为`Address_Town`。这是因为不允许在标签`ids`中使用点。
- en: A prefix can be added to these standard names by specifying it in `ViewData.TemplateInfo.HtmlFieldPrefix`.
    For instance, if the previous property is set to `MyPerson`, the name becomes
    `MyPerson.Address.Town`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`ViewData.TemplateInfo.HtmlFieldPrefix`中指定前缀来向这些标准名称添加前缀。例如，如果前面的属性设置为`MyPerson`，则名称变为`MyPerson.Address.Town`。
- en: If the form is submitted to an action method that has the same `Person` class
    as one of its parameters, the name of `Address.Town` that’s given to the `input`
    field will cause the `Town` property of this parameter to be filled with the `input`
    field. In general, the string contained in the `input` field is converted into
    the type of property it has been matched with, using the current request culture.
    Summing this up, the names of `input` fields are created in such a way that a
    complete `Person` model can be recovered in the action method when the HTML page
    is posted.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单提交给一个参数包含与`Person`类相同的动作方法，分配给`input`字段的`Address.Town`名称将导致该参数的`Town`属性被`input`字段填充。一般来说，`input`字段中包含的字符串将根据当前请求文化转换为与之匹配的属性类型。总结来说，`input`字段的名称是以这种方式创建的，以便在HTML页面提交时，可以在动作方法中恢复完整的`Person`模型。
- en: The same `asp-for` attribute can be used in a `label` tag to cause the label
    to refer to the input field with the same `asp-for` value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的`asp-for`属性可以在`label`标签中使用，以使标签引用具有相同`asp-for`值的输入字段。
- en: 'The following code is an example of an `input/label` pair:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`input/label`对的示例：
- en: '[PRE52]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When no text is inserted into the label, the text shown in the label is taken
    from a `Display` attribute that decorates the property (`Town`, in this example),
    if any; otherwise, the name of the property is used.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有文本插入到标签中时，标签中显示的文本将来自装饰属性的`Display`属性（如果有；否则，使用属性的名称）。
- en: If `span` or `div` contains an `asp-validation-for="Address.Town"` error attribute,
    then validation messages concerning the `Address.Town` input will be inserted
    automatically inside that tag. The validation framework will be described in the
    *Understanding the connection between ASP.NET Core MVC and design principles*
    section.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`span`或`div`包含一个`asp-validation-for="Address.Town"`错误属性，那么关于`Address.Town`输入的验证消息将自动插入到该标签内部。验证框架将在*理解ASP.NET
    Core MVC与设计原则之间的联系*部分进行描述。
- en: 'It is also possible to automatically create a validation error summary by adding
    the attribute that follows a `div` or a `span`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过添加一个属性来自动创建验证错误摘要，该属性跟在 `div` 或 `span` 之后：
- en: '[PRE53]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If the attribute is set to `ValidationSummary.ModelOnly`, only messages that
    are not associated with specific `input` fields will be shown in the summary,
    while if the value is `ValidationSummary.All`, all error messages will be shown.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性设置为 `ValidationSummary.ModelOnly`，则仅在摘要中显示与特定 `input` 字段不相关的消息，而如果值为 `ValidationSummary.All`，则将显示所有错误消息。
- en: The `asp-items` attribute can be applied to any `select` tag to automatically
    generate all the `select` options. It must be passed an `IEnumerable<SelectListItem>`,
    where each `SelectListItem` contains both the text and value of an option. `SelectListItem`
    also contains an optional `Group` property that you can use to organize the options
    shown in `select` into groups.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `asp-items` 属性应用于任何 `select` 标签以自动生成所有 `select` 选项。它必须传递一个 `IEnumerable<SelectListItem>`，其中每个
    `SelectListItem` 包含一个选项的文本和值。`SelectListItem` 还包含一个可选的 `Group` 属性，您可以使用它将显示在 `select`
    中的选项组织成组。
- en: 'Here is an example of how to use `asp-items`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用 `asp-items` 的一个示例：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When added, option tags are placed before the ones generated by `asp-items`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加时，选项标签会放在由 `asp-items` 生成的标签之前。
- en: The next topic shows how to reuse view code.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题将展示如何重用视图代码。
- en: Reusing view code
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重用视图代码
- en: ASP.NET Core MVC includes several techniques for reusing view code, with the
    most important being the layout page.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 包含几种重用视图代码的技术，其中最重要的是布局页面。
- en: In each web application, several pages share the same structure, for instance,
    the same main menu or the same left or right bar. In ASP.NET Core, this common
    structure is factored out in views called layout pages/views.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个网络应用程序中，几个页面共享相同的结构，例如相同的主菜单或相同的左侧或右侧栏。在 ASP.NET Core 中，这种常见结构被提取到称为布局页面/视图的视图中。
- en: '![](img/B19820_17_07.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_17_07.png)'
- en: 'Figure 17.7: Using layout pages'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7：使用布局页面
- en: 'Each view can specify the view to be used as its layout page with the following
    code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图可以使用以下代码指定用作其布局页面的视图：
- en: '[PRE55]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If no layout page is specified, a default layout page, defined in a `_ViewStart.cshtml`
    file located in the `Views` folder, is used. The default content of `_ViewStart.cshtml`
    is as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定布局页面，则使用位于 `Views` 文件夹中的 `_ViewStart.cshtml` 文件中定义的默认布局页面。`_ViewStart.cshtml`
    的默认内容如下：
- en: '[PRE56]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Therefore, the default layout page in the files scaffolded by Visual Studio
    is `_Layout.cshtml`, which is contained in the `Shared` folder.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由 Visual Studio 生成的文件中的默认布局页面是 `_Layout.cshtml`，它包含在 `Shared` 文件夹中。
- en: 'The layout page contains the HTML that’s shared with all of its children pages,
    the HTML page headers, and the page references to CSS and JavaScript files. The
    HTML produced by each view is placed inside its layout page, where the layout
    page calls the `@RenderBody()` method, as shown in the following example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 布局页面包含与其所有子页面共享的 HTML、HTML 页面页眉以及指向 CSS 和 JavaScript 文件的页面引用。每个视图生成的 HTML 都放置在其布局页面内，其中布局页面调用
    `@RenderBody()` 方法，如下例所示：
- en: '[PRE57]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`ViewData` of each `View` is copied into `ViewData` of its layout page, so
    `ViewData` can be used to pass information to the view layout page. Typically,
    it is used to pass the view title to the layout page, which then uses it to compose
    the page’s title header, as shown here:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `View` 的 `ViewData` 都会被复制到其布局页面的 `ViewData` 中，因此 `ViewData` 可以用来向视图布局页面传递信息。通常，它用于传递视图标题到布局页面，然后布局页面使用它来组成页面的标题头部，如下所示：
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: While the main content produced by each view is placed in a single area of its
    layout page, each layout page can also define several sections placed in different
    areas, where each view can place further secondary content.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个视图生成的主要内容都放置在其布局页面的一个单独区域中，但每个布局页面也可以定义几个放置在不同区域的部分，其中每个视图可以放置进一步的次要内容。
- en: 'For instance, suppose a layout page defines a `Scripts` section, as shown here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个布局页面定义了一个 `Scripts` 部分，如下所示：
- en: '[PRE59]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, the view can use the previously defined section to pass some view-specific
    JavaScript references, as shown here:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，视图可以使用之前定义的部分来传递一些视图特定的 JavaScript 引用，如下所示：
- en: '[PRE60]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If an action method is expected to return HTML to an AJAX call, it must produce
    an HTML fragment instead of a whole HTML page. Therefore, in this case, no layout
    page must be used. This is achieved by calling the `PartialView` method instead
    of the `View` method in the controller action method. `PartialView` and `View`
    have exactly the same overloads and parameters.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期操作方法返回 HTML 以响应对 AJAX 的调用，则它必须生成一个 HTML 片段而不是整个 HTML 页面。因此，在这种情况下，不得使用布局页面。这是通过在控制器操作方法中调用
    `PartialView` 方法而不是 `View` 方法来实现的。`PartialView` 和 `View` 具有完全相同的重载和参数。
- en: 'Another way to reuse view code is to factor out a view fragment that’s common
    to several views into another view that is called by all previous views. A view
    can call another view with the `partial` tag, as shown here:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种重用视图代码的方法是将几个视图共有的视图片段提取到另一个由所有先前视图调用的视图中。一个视图可以使用 `partial` 标签调用另一个视图，如下所示：
- en: '[PRE61]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code invokes `_viewname` and passes it to the object contained
    in `Model.ModelProperty.NestedProperty` as its `ViewModel`. When a view is invoked
    by the `partial` tag, no layout page is used, since the called view is expected
    to return an HTML fragment.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调用 `_viewname` 并将其传递给包含在 `Model.ModelProperty.NestedProperty` 中的对象作为其 `ViewModel`。当一个视图通过
    `partial` 标签被调用时，不使用布局页面，因为期望被调用视图返回一个 HTML 片段。
- en: The `ViewData.TemplateInfo.HtmlFieldPrefix` property of the called view is set
    to the `ModelProperty.NestedProperty` string. This way, possible input fields
    rendered in `_viewname.cshtml` will have the same name as if they had been rendered
    directly by the calling view.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用视图的 `ViewData.TemplateInfo.HtmlFieldPrefix` 属性被设置为 `ModelProperty.NestedProperty`
    字符串。这样，在 `_viewname.cshtml` 中渲染的可能输入字段将具有与它们直接由调用视图渲染时相同的名称。
- en: 'Instead of specifying the ViewModel of `_viewname` through a property of the
    caller view (ViewModel), you can also directly pass an object that is contained
    in a variable or returned by a C# expression by replacing `for` with `model`,
    as shown in this example:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过调用视图（ViewModel）的属性来指定 `_viewname` 的 ViewModel 之外，您还可以通过将 `for` 替换为 `model`，直接传递包含在变量中或由
    C# 表达式返回的对象，从而直接传递一个对象。如下例所示：
- en: '[PRE62]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this case, the `ViewData.TemplateInfo.HtmlFieldPrefix` property of the called
    view keeps its default value, that is, the empty string.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，被调用视图的 `ViewData.TemplateInfo.HtmlFieldPrefix` 属性保持其默认值，即空字符串。
- en: 'A view can also call something more complex than another view, that is, another
    controller method that, in turn, renders a view. Controllers that are designed
    to be invoked by views are called **view components**. The following code is an
    example of component invocation:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还可以调用比另一个视图更复杂的东西，即另一个控制器方法，该方法反过来渲染一个视图。设计为被视图调用的控制器称为 **视图组件**。以下代码是组件调用的示例：
- en: '[PRE63]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Parameter names must match the ones used in the view component method. However,
    both the component’s name and parameter names must be translated into kebab case;
    that is, all the characters must be transformed into lowercase if all the characters
    in the original name were in uppercase, although the first letter of the name
    must be preceded by a `-`. For instance, `MyParam` must be transformed into `my-param`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称必须与视图组件方法中使用的名称匹配。然而，组件的名称和参数名称都必须转换为 kebab case；也就是说，如果原始名称中的所有字符都是大写，则必须将所有字符转换为小写，尽管名称的第一个字母必须由一个
    `-` 前缀。例如，`MyParam` 必须转换为 `my-param`。
- en: Actually, view components are either classes that derive from the `ViewComponent`
    class, classes decorated with the `[ViewComponent]` attribute, or classes whose
    names end with the `ViewComponent` suffix. When a component is invoked, the framework
    looks for either an `Invoke` method or an `InvokeAsync` method and passes it all
    the parameters that were defined in the component’s invocation. `InvokeAsync`
    must be used if the method is defined as `async`; otherwise, we must use `Invoke`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，视图组件可以是继承自 `ViewComponent` 类的类，是带有 `[ViewComponent]` 特性的类，或者其名称以 `ViewComponent`
    后缀结尾的类。当组件被调用时，框架会寻找 `Invoke` 方法或 `InvokeAsync` 方法，并将组件调用中定义的所有参数传递给它。如果方法定义为
    `async`，则必须使用 `InvokeAsync`；否则，我们必须使用 `Invoke`。
- en: 'The following code is an example of a view component definition:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个视图组件定义的示例：
- en: '[PRE64]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The previously defined component must be invoked with a call such as the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用如下所示的调用来调用先前定义的组件：
- en: '[PRE65]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If the component is invoked by a view of a controller called `MyController`,
    `ViewName` is searched for in the following paths:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件是通过名为 `MyController` 的控制器视图调用的，则 `ViewName` 在以下路径中搜索：
- en: '`/Views/MyController/Components/MyTest/ViewName`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Views/MyController/Components/MyTest/ViewName`'
- en: '`/Views/Shared/Components/MyTest/ViewName`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Views/Shared/Components/MyTest/ViewName`'
- en: Understanding the connection between ASP.NET Core MVC and design principles
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core MVC 与设计原则之间的联系
- en: The whole ASP.NET Core framework is built on top of the design principles and
    patterns that we analyzed in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*, *Chapter 13*, *Interacting with* *Data in C#
    – Entity Framework Core*, *Chapter 6*, *Design Patterns and .NET 8 Implementation*,
    *Chapter 7*, *Understanding the Different Domains in Software Solutions*, and
    *Chapter 5*, *Implementing* *Code Reusability in C# 12*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 ASP.NET Core 框架都是建立在我们在 *第 11 章*、*将微服务架构应用于企业应用程序*、*第 13 章*、*在 C# 中与数据交互
    – Entity Framework Core*、*第 6 章*、*设计模式和 .NET 8 实现*、*第 7 章*、*理解软件解决方案中的不同领域* 和
    *第 5 章*、*在 C# 12 中实现代码重用性* 中分析的设计原则和模式之上的。
- en: Moreover, all framework functionalities are provided through DI so that each
    of them can be replaced by a customized counterpart, without it affecting the
    remainder of the code. Moreover, these providers are not added individually to
    the DI engine; instead, they are grouped into collection properties of option
    objects (see the *Loading configuration data and using it with the options framework*
    subsection) for improved maintainability, and to conform to the Separation of
    Concerns principle, which is a generalization of the Single Responsibility principle.
    In fact, the order in which providers are added to their collection does matter,
    since they are processed in the same order as they are in the collection. Moreover,
    the effect of a provider also depends on the other providers that belong to the
    same collection, so sometimes, it is not enough to replace a provider or add a
    new provider, but it is necessary to also remove/replace other providers to remove
    their side effects.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有框架功能都是通过依赖注入（DI）提供的，这样每个功能都可以被定制的对应物所替代，而不会影响代码的其他部分。此外，这些提供者不是单独添加到 DI
    引擎中；相反，它们被分组到选项对象的集合属性中（参见 *加载配置数据和使用选项框架* 子节），以提高可维护性，并符合关注点分离原则，这是单一责任原则的泛化。实际上，提供者添加到其集合中的顺序很重要，因为它们将以与集合中相同的顺序进行处理。此外，提供者的效果还取决于属于同一集合的其他提供者，因此有时仅仅替换一个提供者或添加一个新的提供者是不够的，还需要移除/替换其他提供者以消除其副作用。
- en: Examples of providers grouped in collections include all model binders, validation
    providers, and data annotation providers.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 分组在集合中的提供者示例包括所有模型绑定器、验证提供者和数据注释提供者。
- en: Moreover, configuration data, instead of being available from a unique dictionary
    created from a configuration file, is organized into option objects thanks to
    the options framework we described in the first section of this chapter. This
    is also an application of the SOLID Interface Segregation principle.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，配置数据不是从配置文件创建的唯一字典中可用，而是通过我们在本章第一部分中描述的选项框架组织成选项对象。这也是 SOLID 接口分离原则的应用。
- en: 'However, ASP.NET Core also applies other patterns that are specific instances
    of the general Separation of Concerns principle, which (as mentioned earlier)
    is a generalization of the Single Responsibility principle. They are as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ASP.NET Core 还应用了其他特定于一般关注点分离原则的通用模式，该原则（如前所述）是单一责任原则的泛化。它们如下：
- en: The middleware modules architecture (the ASP.NET Core pipeline)
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件模块架构（ASP.NET Core 管道）
- en: Factoring out validation and globalization from the application code
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序代码中提取验证和全球化
- en: The MVC pattern itself
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC 模式本身
- en: We will analyze each of these in the various subsections that follow.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的各个子节中分析这些内容。
- en: Advantages of the ASP.NET Core pipeline
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core 管道的优势
- en: 'The ASP.NET Core pipeline architecture has two important advantages:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 管道架构有两个重要优势：
- en: All the different operations that are performed on the initial request are factored
    out into different modules, according to the Single Responsibility principle.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据单一责任原则，将初始请求上执行的所有不同操作分解到不同的模块中。
- en: The modules that perform these different operations don’t need to call each
    other because each module is invoked once and for all by the ASP.NET Core framework.
    This way, the code for each module is not required to perform any action that
    is connected to responsibilities that have been assigned to other modules.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行这些不同操作的模块不需要相互调用，因为每个模块都由 ASP.NET Core 框架一次性调用。这样，每个模块的代码就不需要执行与分配给其他模块的责任相关的任何操作。
- en: This ensures maximum independence of functionalities and simpler code. For instance,
    once the authorization and authentication modules are active, no other module
    needs to worry about authorization anymore. Each piece controller code can focus
    on application-specific business stuff.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了功能之间的最大独立性，并简化了代码。例如，一旦授权和认证模块激活，其他模块就无需再担心授权问题。每个控制器代码块可以专注于特定应用的业务逻辑。
- en: Server-side and client-side validation
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端和客户端验证
- en: Validation logic has been completely factored out from the application code
    and has been confined to the definition of validation attributes. The developer
    just needs to specify the validation rule to apply to each model property, by
    decorating the property with an adequate validation attribute.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 验证逻辑已完全从应用程序代码中提取出来，并限制在验证属性的定义中。开发者只需指定应用于每个模型属性的验证规则，通过装饰属性以适当的验证属性即可。
- en: Validation rules are checked automatically when action method parameters are
    instantiated. Both errors and paths in the model (where they occurred) are then
    recorded in a dictionary that is contained in the `ModelState` controller property.
    The developer has the responsibility for verifying whether there are errors by
    checking `ModelState.IsValid`, in which case the developer must return the same
    ViewModel to the same view so that the user can correct any errors.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当动作方法参数实例化时，验证规则会自动进行检查。随后，错误和模型中的路径（它们发生的位置）将被记录在包含在 `ModelState` 控制器属性中的字典中。开发者有责任通过检查
    `ModelState.IsValid` 来验证是否存在错误，在这种情况下，开发者必须返回相同的 ViewModel 到相同的视图，以便用户可以纠正任何错误。
- en: 'Error messages are automatically shown in the view, with no action required
    from the developer. The developer is only required to do the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息会自动在视图中显示，无需开发者进行任何操作。开发者只需执行以下操作：
- en: Add `span` or `div` with an `asp-validation-for` attribute next to each input
    field, which will be automatically filled with the possible error.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个输入字段旁边添加带有 `asp-validation-for` 属性的 `span` 或 `div`，该属性将被自动填充可能的错误。
- en: Add `div` with an `asp-validation-summary` attribute that will be automatically
    filled with the validation error summary. See the *Using Razor tag helpers* section
    for more details.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加带有 `asp-validation-summary` 属性的 `div`，该属性将被自动填充验证错误摘要。有关更多详细信息，请参阅 *使用 Razor
    标签辅助器* 部分。
- en: 'It is sufficient to add some JavaScript references by invoking the `_ValidationScriptsPartial.cshtml`
    view with the `partial` tag, enabling the same validation rules on the client
    side so that errors are shown to the user before the form is posted to the server.
    Some predefined validation attributes are contained in the `S stem.ComponentModel.DataAnnotations`
    and `Microsoft.AspNetCore.Mvc` namespaces and include the following attributes:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 只需通过调用带有 `partial` 标签的 `_ValidationScriptsPartial.cshtml` 视图来添加一些 JavaScript
    引用，即可在客户端启用相同的验证规则，以便在表单提交到服务器之前向用户显示错误。预定义的验证属性包含在 `System.ComponentModel.DataAnnotations`
    和 `Microsoft.AspNetCore.Mvc` 命名空间中，包括以下属性：
- en: The `Required` attribute requires the user to specify a value for the property
    that it decorates. An implicit `Required` attribute is automatically applied to
    all non-nullable properties, such as all floats, integers, and decimals, since
    they can’t have a `null` value.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Required` 属性要求用户为其装饰的属性指定一个值。对于所有非可空属性，如所有浮点数、整数和小数，会自动应用隐式的 `Required` 属性，因为它们不能有
    `null` 值。'
- en: The `Range` attribute constrains numeric quantities within a range.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range` 属性限制了数值在特定范围内。'
- en: They also include attributes that constrain string lengths.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们还包括限制字符串长度的属性。
- en: Custom error messages can be inserted directly into the attributes, or attributes
    can refer to the property of the resource types containing them.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接将自定义错误消息插入到属性中，或者属性可以引用包含它们的资源类型属性。
- en: 'The developer can define their custom attributes by providing the validation
    code, both in C# and in JavaScript for client-side validation. The definition
    of custom validation attributes is discussed in this article: [https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/).'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过提供C#和JavaScript中的验证代码来定义自己的自定义属性，以实现客户端验证。自定义验证属性的定义在本篇文章中讨论：[https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/)。
- en: Attribute-based validation can be replaced by other validation providers, such
    as the **FluentValidation** library that defines validation rules for each type
    using a fluent interface. It is enough to change a provider in a collection contained
    in the MVC options object. This can be configured through an action passed to
    the `builder.Services.AddControllersWithViews` method.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用其他验证提供者替换基于属性的验证，例如**FluentValidation**库，该库使用流畅接口为每个类型定义验证规则。只需更改MVC选项对象中包含的提供者即可。这可以通过传递给`builder.Services.AddControllersWithViews`方法的操作来配置。
- en: 'MVC options can be configured as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按如下方式配置MVC选项：
- en: '[PRE66]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The validation framework automatically checks whether numeric and date inputs
    are well formatted according to the selected culture.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 验证框架会自动检查数字和日期输入是否根据所选文化正确格式化。
- en: ASP.NET Core globalization
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core全球化
- en: In multicultural applications, pages must be served according to the language
    and cultural preferences of each user. Typically, multicultural applications can
    serve their content in a few languages, and they can handle dates and numeric
    formats in several more languages. In fact, while the content in all supported
    languages must be produced manually, .NET has the native capability of formatting
    and parsing dates and numbers in all cultures.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在多文化应用程序中，页面必须根据每个用户的语言和文化偏好提供服务。通常，多文化应用程序可以在几种语言中提供其内容，并且可以在更多语言中处理日期和数字格式。实际上，尽管所有支持的语言内容都必须手动生成，但.NET具有在所有文化中格式化和解析日期和数字的本地能力。
- en: For instance, a web application might not support unique content for all English-based
    cultures (en), but it might support all known English-based cultures regarding
    number and date formats (en-US, en-GB, en-CA, and so on).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个Web应用程序可能不支持所有基于英语的文化（en）的唯一内容，但它可能支持所有已知的基于英语的文化在数字和日期格式方面（en-US、en-GB、en-CA等）。
- en: The culture used for numbers and dates in a .NET thread is contained in the
    `Thread.CurrentThread.CurrentCulture` property. Hence, by setting this property
    to `new CultureInfo("en-CA")`, numbers and dates will be formatted/parsed according
    to the Canadian format. `Thread.CurrentThread.CurrentUICulture`, instead, decides
    on the culture of the resource files; that is, it selects a culture-specific version
    of each resource file or view. Accordingly, a multicultural application is required
    to set the two cultures associated with the request thread and organize multilingual
    content into language-dependent resource files and/or views.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: .NET线程中数字和日期使用的是`Thread.CurrentThread.CurrentCulture`属性中指定的文化。因此，通过将此属性设置为`new
    CultureInfo("en-CA")`，数字和日期将根据加拿大格式进行格式化/解析。相反，`Thread.CurrentThread.CurrentUICulture`决定资源文件的文化；也就是说，它选择每个资源文件或视图的文化特定版本。因此，多文化应用程序需要设置与请求线程相关的两个文化，并将多语言内容组织到语言相关的资源文件和/或视图中。
- en: 'According to the Separation of Concerns principle, the whole logic used to
    set the request culture according to the user’s preferences is factored out into
    a specific module of the ASP.NET Core pipeline. To configure this module, as a
    first step, we set the supported date/number cultures, as shown in the following
    example:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 根据关注点分离原则，用于根据用户偏好设置请求文化的整个逻辑被提取到一个特定的ASP.NET Core管道模块中。要配置此模块，作为第一步，我们设置支持的日期/数字文化，如下例所示：
- en: '[PRE67]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we set the languages supported for the content. Usually, a version of
    the language that is not specific to any country is selected to keep the number
    of translations small enough, as shown here:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置内容支持的语言。通常，会选择一种不特定于任何国家的语言版本，以保持翻译数量尽可能少，如下所示：
- en: '[PRE68]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, we add the culture middleware to the pipeline, as shown here:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将文化中间件添加到管道中，如下所示：
- en: '[PRE69]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If the culture requested by the user is explicitly found among the ones listed
    in `supportedCultures` or `supportedUICultures`, it is used without modifications.
    Otherwise, since `FallBackToParentCultures` and `FallBackToParentUICultures` are
    `true`, the parent culture is tried; that is, for instance, if the required `fr-FR`
    culture is not found among those listed, then the framework searches for its generic
    version, `fr`. If this attempt also fails, the framework uses the cultures specified
    in `DefaultRequestCulture`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户请求的文化在 `supportedCultures` 或 `supportedUICultures` 列表中明确找到，则使用它而不做修改。否则，由于
    `FallBackToParentCultures` 和 `FallBackToParentUICultures` 为 `true`，将尝试父文化；例如，如果所需的
    `fr-FR` 文化没有在列出的那些中找到，那么框架将搜索其通用版本，`fr`。如果这次尝试也失败，框架将使用 `DefaultRequestCulture`
    中指定的文化。
- en: 'By default, the `culture` middleware searches the culture selected for the
    current user, with three providers that are tried in the order shown here:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`culture` 中间件搜索为当前用户选择的 culture，并尝试以下顺序中的三个提供者：
- en: The middleware looks for the `culture` and `ui-culture` query string parameters.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件查找 `culture` 和 `ui-culture` 查询字符串参数。
- en: 'If the previous step fails, the middleware looks for a cookie named `.AspNetCore.Culture`,
    the value of which is expected to be as in this example: `c=en-US|uic=en`.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前面的步骤失败，中间件会查找名为 `.AspNetCore.Culture` 的 cookie，其值预期如下示例所示：`c=en-US|uic=en`。
- en: If both previous steps fail, the middleware looks for the `Accept-Language`
    request header sent by the browser, which can be changed in the browser settings,
    and which is initially set to the operating system culture.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前两个步骤都失败，中间件会查找浏览器发送的 `Accept-Language` 请求头，这可以在浏览器设置中更改，并且最初设置为操作系统文化。
- en: With the preceding strategy, the first time a user requests an application page,
    the browser culture is taken (the provider listed in *step 3*). Then, if the user
    clicks a language-change link with the right query string parameters, a new culture
    is selected by provider 1\. Usually, once a language link has been clicked, the
    server also generates a language cookie to remember the user’s choice through
    provider 2.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的策略，当用户第一次请求应用程序页面时，浏览器文化被采用（在 *步骤 3* 中列出的提供者）。然后，如果用户点击带有正确查询字符串参数的语言更改链接，提供者
    1 会选择一个新的文化。通常，一旦点击了语言链接，服务器也会生成一个语言 cookie，通过提供者 2 来记住用户的选择。
- en: The simplest way to provide content localization is to provide a different view
    for each language. Hence, if we would like to localize the `Home.cshtml` view
    for different languages, we must provide views named `Home.en.cshtml`, `Home.es.cshtml`,
    and so on. If no view specific to the `ui-culture` thread is found, the non-localized
    `Home.cshtml` version of the view is chosen.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 提供内容本地化的最简单方法是为每种语言提供不同的视图。因此，如果我们想为不同的语言本地化 `Home.cshtml` 视图，我们必须提供名为 `Home.en.cshtml`、`Home.es.cshtml`
    等的视图。如果没有找到特定于 `ui-culture` 线程的视图，则选择未本地化的 `Home.cshtml` 视图版本。
- en: 'View localization must be enabled by calling the `AddViewLocalization` method,
    as shown here:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 必须通过调用 `AddViewLocalization` 方法来启用视图本地化，如下所示：
- en: '[PRE70]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Another option is to store simple strings or HTML fragments in resource files
    specific to all supported languages. The usage of resource files must be enabled
    by calling the `AddLocalization` method in the configure services section, as
    shown here:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将简单的字符串或 HTML 片段存储在针对所有支持的语言特定的资源文件中。必须在配置服务部分调用 `AddLocalization` 方法来启用资源文件的用法，如下所示：
- en: '[PRE71]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`ResourcesPath` is the root folder where all resource files will be placed.
    If it is not specified, an empty string is assumed, and the resource files will
    be placed in the web application root. Resource files for a specific view (say,
    the `/Views/Home/Index.cshtml` view) must have a path like this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourcesPath` 是所有资源文件将被放置的根文件夹。如果没有指定，则假定为一个空字符串，资源文件将被放置在 Web 应用程序根目录下。特定视图（例如，`/Views/Home/Index.cshtml`
    视图）的资源文件必须具有如下路径：'
- en: '[PRE72]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Hence, if `ResourcesPath` is empty, resources must have the `/Views/Home/Index.<culture
    name>.resx` path; that is, they must be placed in the same folder as the view.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 `ResourcesPath` 为空，资源必须具有 `/Views/Home/Index.<culture name>.resx` 路径；也就是说，它们必须放置在视图相同的文件夹中。
- en: 'Once the key-value pairs for all the resource files associated with a view
    have been added, localized HTML fragments can be added to the view, as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了与视图相关联的所有资源文件的关键值对，就可以将本地化的 HTML 片段添加到视图中，如下所示：
- en: Inject `IViewLocalizer` into the view with `@inject IViewLocalizer Localizer`
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `IViewLocalizer` 注入视图，使用 `@inject IViewLocalizer Localizer`
- en: Where needed, replace the text in the `View` with access to the `Localizer`
    dictionary, such as `Localizer`[“`myKey`”], where “`myKey`” is a key used in the
    resource files.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要的地方，将 `View` 中的文本替换为对 `Localizer` 字典的访问，例如 `Localizer`[“`myKey`”]，其中 “`myKey`”
    是在资源文件中使用的键。
- en: 'The following code shows an example of the `IViewLocalizer` dictionary:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `IViewLocalizer` 字典的一个示例：
- en: '[PRE73]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If localization fails because the key is not found in the resource file, the
    key itself is returned. Strings used in data annotation, such as validation attributes,
    are used as keys in resource files if data annotation localization is enabled,
    as shown here:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本地化失败是因为在资源文件中找不到键，则返回键本身。如果启用了数据注解本地化，则用于数据注解的字符串（如验证属性）用作资源文件中的键，如下所示：
- en: '[PRE74]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Resource files for data annotations applied to a class whose full name is,
    say, `MyWebApplication.ViewModels.Account.RegisterViewModel` must have the following
    path:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于具有全名 `MyWebApplication.ViewModels.Account.RegisterViewModel` 的类的数据注解资源文件必须具有以下路径：
- en: '[PRE75]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: It is worth pointing out that the first segment of the namespace that corresponds
    to the `.dll` application name is replaced with `ResourcesPath`. If `ResourcesPath`
    is empty and you use the default namespaces created by Visual Studio, then the
    resource files must be placed in the same folder that contains the classes they
    are associated with.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，与 `.dll` 应用程序名称对应的命名空间的第一部分被替换为 `ResourcesPath`。如果 `ResourcesPath` 为空，并且你使用由
    Visual Studio 创建的默认命名空间，那么资源文件必须放置在与它们关联的类所在的同一文件夹中。
- en: It is possible to localize strings and HTML fragments in controllers, or wherever
    dependencies can be injected, by associating each group of resource files with
    a type, such as `MyType`, and then injecting either `IHtmlLocalizer<MyType>` for
    HTML fragments or `IStringLocalizer<MyType>` for strings that need to be HTML-encoded.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将每个资源文件组与一个类型关联，例如 `MyType`，然后在控制器或其他可以注入依赖的地方注入 `IHtmlLocalizer<MyType>`
    用于 HTML 片段或 `IStringLocalizer<MyType>` 用于需要 HTML 编码的字符串，可以本地化字符串和 HTML 片段。
- en: Their usage is identical to the usage of `IViewLocalizer`. The path of the resource
    files associated with `MyType` is computed, as in the case of data annotations.
    If you would like to use a unique group of resource files for the whole application,
    a common choice is to use the `Startup` class as the reference type (`IStringLocalizer<Startup>`
    and `IHtmlLocalizer<Startup>`). Another common choice is to create various empty
    classes to use as reference types for various groups of resource files.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的用法与 `IViewLocalizer` 的用法相同。与数据注解的情况一样，计算与 `MyType` 关联的资源文件路径。如果你希望为整个应用程序使用一组独特的资源文件，一个常见的做法是将
    `Startup` 类用作参考类型（`IStringLocalizer<Startup>` 和 `IHtmlLocalizer<Startup>`）。另一个常见的做法是为各种资源文件组创建各种空类，用作参考类型。
- en: 'Now that we’ve learned how to manage globalization in our ASP.NET Core projects,
    in the next subsection, we will describe the more important pattern used by ASP.NET
    Core MVC to enforce a *separation of concerns*: the MVC pattern itself.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在我们的 ASP.NET Core 项目中管理全球化，在下一个子节中，我们将描述 ASP.NET Core MVC 用来强制实现
    *关注点分离* 的更重要的模式：MVC 模式本身。
- en: The MVC pattern
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC 模式
- en: MVC is a pattern used to implement the presentation layers of a web application.
    The basic idea is to apply a *Separation of Concerns* between the logic of the
    presentation layer and its graphics. Logic is taken care of by controllers, while
    graphics are factored out into views. Controllers and views communicate through
    the model, which is often called the ViewModel to distinguish it from the models
    of the business and data layers.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 是一种用于实现 Web 应用程序表示层的模式。基本思想是在表示层的逻辑和其图形之间应用 *关注点分离*。逻辑由控制器处理，而图形被分解到视图中。控制器和视图通过模型进行通信，通常称为
    ViewModel，以区分业务和数据层的模型。
- en: It is worth pointing out that the original definition of the MVC pattern proposes
    directly the use of domain models instead of ViewModels, but then, most of the
    MVC web frameworks started using the concept of ViewModel because specifying the
    information to render in a view requires just a projection of the original domain
    model (just some model data possibly organized in a different way) and often additional
    data, such as, for instance, the items per page of a pager, and the items required
    by the type input selected.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，MVC模式的原始定义直接提出了使用领域模型而不是ViewModel的建议，但随后，大多数MVC Web框架开始使用ViewModel的概念，因为指定在视图中渲染的信息只需要对原始领域模型进行投影（可能以不同的方式组织一些模型数据）以及通常还需要额外的数据，例如，例如分页器每页的项目数，以及所选类型输入所需的项目。
- en: However, what is the logic of a presentation layer? In *Chapter 1*, *Understanding
    the Importance of Software Architecture*, we saw that software requirements can
    be documented with use cases that describe the interaction between the user and
    the system.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，表示层的逻辑是什么？在*第一章*，*理解软件架构的重要性*中，我们了解到软件需求可以通过用例来记录，这些用例描述了用户与系统之间的交互。
- en: Roughly speaking, the logic of the presentation layer consists of the management
    of use cases; hence, roughly, use cases are mapped to controllers, and every single
    operation of a use case is mapped to an action method of those controllers. Hence,
    controllers take care of managing the protocol of interaction with the user and
    rely on the business layer for any business processing involved during each operation.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，表示层的逻辑包括用例的管理；因此，大致上，用例映射到控制器，每个用例的每个操作映射到这些控制器的动作方法。因此，控制器负责管理与用户的交互协议，并在每个操作中涉及的业务处理方面依赖于业务层。
- en: Each action method receives data from the user, performs some business processing,
    and, depending on the results of this processing, decides what to show to the
    user and encodes it in the ViewModel. Views receive ViewModels that describe what
    to show to the user and decide the graphics to use, that is, the HTML to use.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 每个动作方法都从用户那里接收数据，执行一些业务处理，并根据处理结果决定向用户展示什么，并将其编码在ViewModel中。视图接收ViewModel，描述了要向用户展示的内容，并决定使用哪种图形，即使用哪种HTML。
- en: 'What are the advantages of separating the logic and user interface into two
    different components? The main advantages are listed here:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑和用户界面分离成两个不同的组件有哪些优点？主要优点如下：
- en: Changes in graphics do not affect the remainder of the code, so you can experiment
    with various user interface elements to optimize the interaction with the user,
    without putting the reliability of the remainder of the code at risk.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形的变化不会影响代码的其他部分，因此您可以尝试各种用户界面元素以优化与用户的交互，而不会危及代码其他部分的可靠性。
- en: The application can be tested by instantiating controllers and passing the parameters,
    with no need to use testing tools that operate on the browser pages. In this way,
    tests are easier to implement. Moreover, they do not depend on the way graphics
    are implemented, so they do not need to be updated each time the graphics change.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以通过实例化控制器并传递参数来测试，无需使用在浏览器页面上操作的测试工具。这样，测试更容易实现。此外，它们不依赖于图形的实现方式，因此不需要在图形更改时更新。
- en: It is easier to split the job between developers who implement controllers and
    graphic designers who implement views. Often, graphic designers have difficulties
    with Razor, so they might just furnish an example HTML page that developers transform
    into Razor views that operate on the actual data.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将工作分配给实现控制器的开发人员和实现视图的图形设计师之间更容易。通常，图形设计师在Razor方面有困难，所以他们可能只提供一个示例HTML页面，开发人员将其转换为操作实际数据的Razor视图。
- en: For an example of how to put into practice the general principles discussed
    above, please refer to the *A frontend microservice* section in *Chapter 21*,
    *Case Study*, but it is better to read *Chapter 18*, *Implementing Frontend Microservices
    with ASP.NET Core*, beforehand. There, we’ll look at how to create a frontend
    microservice with ASP.NET Core MVC.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何将上述讨论的一般原则付诸实践，请参阅*第21章*，*案例研究*中的*前端微服务*部分，但最好先阅读*第18章*，*使用ASP.NET Core实现前端微服务*。在那里，我们将探讨如何使用ASP.NET
    Core MVC创建前端微服务。
- en: Summary
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the ASP.NET Core pipeline and various modules that
    comprise an ASP.NET Core MVC application in detail, such as authentication/authorization,
    the options framework, and routing. Then, we described how controllers and Views
    map requests to the response HTML. We also analyzed all the improvements introduced
    in the latest versions.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细分析了ASP.NET Core管道以及构成ASP.NET Core MVC应用程序的各种模块，例如身份验证/授权、选项框架和路由。然后，我们描述了控制器和视图如何将请求映射到响应HTML。我们还分析了最新版本中引入的所有改进。
- en: Finally, we analyzed all the design patterns implemented in the ASP.NET Core
    MVC framework and, in particular, the importance of the Separation of Concerns
    principle and how ASP.NET Core MVC implements it in the ASP.NET Core pipeline,
    as well as in its validation and globalization modules. We focused in more detail
    on the importance of a Separation of Concerns between the presentation layer logic
    and graphics, as well as how the MVC pattern ensures it.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们分析了ASP.NET Core MVC框架中实现的所有设计模式，特别是关注了关注点分离原则的重要性以及ASP.NET Core MVC如何在ASP.NET
    Core管道中实现它，以及在它的验证和全球化模块中如何实现。我们更详细地关注了在表示层逻辑和图形之间的关注点分离的重要性，以及MVC模式如何确保这一点。
- en: You can find a full example of how to use ASP.NET Core MVC in the next chapter,
    which deals with frontend microservices and describes a complete frontend microservice,
    whose presentation layer uses ASP.NET Core MVC.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下一章中找到一个完整的ASP.NET Core MVC使用示例，该章涉及前端微服务，并描述了一个完整的微服务，其表示层使用ASP.NET Core
    MVC。
- en: Questions
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can you list all the middleware modules scaffolded by Visual Studio in an ASP.NET
    Core project?
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能列出Visual Studio在ASP.NET Core项目中构建的所有中间件模块吗？
- en: Does the ASP.NET Core pipeline module need to inherit from a base class or implement
    some interface?
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core管道模块是否需要继承基类或实现某个接口？
- en: Is it true that a tag must have just one tag helper defined for it, as, otherwise,
    an exception is thrown?
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个标签是否必须只定义一个标签助手，否则会抛出异常？
- en: Do you remember how to test if validation errors have occurred in a controller?
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还记得如何在控制器中测试是否发生了验证错误吗？
- en: What is the instruction in a layout view for including the output of the main
    view?
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局视图中包含主视图输出的指令是什么？
- en: How are secondary sections of the main view invoked in a layout view?
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局视图中，如何调用主视图的次要部分？
- en: How does a controller invoke a view?
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器是如何调用视图的？
- en: By default, how many providers are installed in the globalization module?
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，全球化模块中安装了多少个提供程序？
- en: Are ViewModels the only way for controllers to communicate with their invoked
    views?
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ViewModels是否是控制器与其调用的视图通信的唯一方式？
- en: Further reading
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More details on the ASP.NET Core and ASP.NET Core MVC framework are available
    in its official documentation at [https://docs.microsoft.com/en-US/aspnet/core/](https://docs.microsoft.com/en-US/aspnet/core/).
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于ASP.NET Core和ASP.NET Core MVC框架的详细信息可以在其官方文档[https://docs.microsoft.com/en-US/aspnet/core/](https://docs.microsoft.com/en-US/aspnet/core/)中找到。
- en: More details on the Razor syntax can be found at [https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio).
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Razor语法的更多细节可以在[https://docs.microsoft.com/en-US/aspnet/core/razor-pages/?tabs=visual-studio](https://docs.microsoft.com/en-US/aspnet/core/razor-pages/?tabs=visual-studio)找到。
- en: 'How to model bind collections and dictionaries is explained in this excellent
    Phil Haack post: [http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx](http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx).'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对集合和字典进行模型绑定，在Phil Haack的这篇优秀文章中有详细解释：[http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx](http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx).
- en: Documentation on the creation of custom tag helpers that were not discussed
    in this chapter can be found at [https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring](https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring).
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于本章未讨论的自定义标签助手的创建文档可以在[https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring](https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring)找到。
- en: Documentation on the creation of custom controller attributes can be found at
    [https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters).
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于创建自定义控制器属性的文档可以在[https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters)找到。
- en: 'The definition of custom validation attributes is discussed in this article:
    [https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/)'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本文讨论了自定义验证属性的定义：[https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/)
- en: Learn more on Discord
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问以及了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
