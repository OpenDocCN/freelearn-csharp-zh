<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Talk to the User – Adding Interactivity and UI Events</h1></div></div></div><p>In this chapter we will learn the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Detecting a key press on the keyboard</li><li class="listitem" style="list-style-type: disc">Detecting mouse movement and clicks</li><li class="listitem" style="list-style-type: disc">Creating an application that will use basic input for real-time control</li></ul></div><p>We have used some of these functionality in the previous chapters, but here we will try to gain a more systematic overview of what kind of basic interactivity is possible with Cinder.</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec62"/>Handling events</h1></div></div></div><p>Throughout this <a class="indexterm" id="id326"/>book we are writing a code that basically extends the functionality of the <code class="literal">cinder::app::AppBasic</code> class and base class <code class="literal">App</code> that it inherits. The methods that we are declaring and implementing are basically overrides of virtual functions that are built in the <code class="literal">AppBasic</code> and <code class="literal">App</code> classes and are called upon in certain events. Some of them can be called event handlers, and what they basically do is they respond to certain events that are happening during the application flow.</p><p>There are three basic methods that form the core of a Cinder application:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">setup()</code><a class="indexterm" id="id327"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">update()</code><a class="indexterm" id="id328"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">draw()</code><a class="indexterm" id="id329"/></li></ul></div><p>These methods handle the events that are happening inside the application core and a user can't control whether these functions are called or not (it is possible to stop the execution of the method by using <code class="literal">return</code> or similar means at the beginning of the function implementation).</p><p>Then there are methods that can be used to execute code on certain events for example moving your mouse, pressing a key on the keyboard, scrolling the mouse wheel, and so on. These are the ones we will focus on during this chapter. So here is a list of methods (or event handlers) that we will override:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">keyDown()</code><a class="indexterm" id="id330"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">keyUp()</code><a class="indexterm" id="id331"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">fileDrop()</code><a class="indexterm" id="id332"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseDown()</code><a class="indexterm" id="id333"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseUp()</code><a class="indexterm" id="id334"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseMove()</code><a class="indexterm" id="id335"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseDrag()</code><a class="indexterm" id="id336"/></li></ul></div><p>Let's <a class="indexterm" id="id337"/>create a simple drawing application that will use all of these events. To do so, we will need to create a new project. Open <strong>TinderBox</strong> and create a new project with the name <code class="literal">BasicEvents</code>. Open the project file (<code class="literal">xcode/BasicEvents.xcodeproj</code> on Mac OS X or <code class="literal">vc10\BasicEvents.sln</code> on Windows). Open the <code class="literal">BasicEventsApp.cpp</code> in the editor and let's start to add some code there.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec17"/>Using mouseMove()</h2></div></div></div><p>First we will add a <a class="indexterm" id="id338"/>custom mouse cursor that will fall down slowly while we don't move the mouse, and returns to the current mouse position when we move it. To do so we have to declare objects that will hold the x and y position of the cursor. Add the following line of code to the class declaration part of the file:</p><div><pre class="programlisting">Vec2i cursorPos;</pre></div><p>This variable will hold the <code class="literal">x</code> and <code class="literal">y</code> positions of our cursor as <code class="literal">int</code> values. The <code class="literal">i</code> part of the <code class="literal">Vec2i</code> tells us that it is a two-dimensional vector that consists of integer values.</p><p>Next we need to initialize the value by setting it to the current mouse position at the application launch. Add the following line of code to the <code class="literal">setup()</code> method implementation:</p><div><pre class="programlisting">cursorPos = getMousePos();</pre></div><p>This will get the current mouse position and assign it to our cursor position value.</p><p>Next, we want to draw a circle at the <code class="literal">cursorPos</code> coordinates. Let's navigate to the <code class="literal">draw()</code> method implementation of our application and add the following line just after the <code class="literal">gl::clear()</code> function call:</p><div><pre class="programlisting">gl::drawSolidCircle( cursorPos, 10 );</pre></div><p>We've used this function before. This will draw a circle with the radius of 10 pixels at the position defined by the <code class="literal">cursorPos</code> variable. Compile and run the project to see for yourself!</p><p>Next we want to add the falling motion to the circle. To do so, we will need to update the circle's <code class="literal">y</code> position by each frame. In other words, we are going to increase the <code class="literal">y</code> coordinate of the circle by one frame each. Let's navigate to the <code class="literal">update()</code> method implementation and add a simple line of code as follows:</p><div><pre class="programlisting">cursorPos.y++;</pre></div><p>This <a class="indexterm" id="id339"/>will let our cursor fall down. Finally we need to make it stick to the mouse on the <code class="literal">mouseMove</code> event. We will need to declare the <code class="literal">mouseMove()</code> method override in the class declaration of our application. Add the following line at the end of the class declaration:</p><div><pre class="programlisting">void mouseMove(MouseEvent event);</pre></div><p>And the method implementation to the class implementation as follows:</p><div><pre class="programlisting">void BasicEventsApp::mouseMove(MouseEvent event) {
    cursorPos = event.getPos();
}</pre></div><p>There is more than one way of getting the current mouse position and instead of <code class="literal">event.getPos()</code>. We could use <code class="literal">getMousePos()</code> <a class="indexterm" id="id340"/>and it would do the same thing that is assigned to the mouse position to the <code class="literal">cursorPos</code> variable.</p><p>Compile and run our application to see the result as shown in the following screenshot:</p><div><img alt="Using mouseMove()" src="img/9564_10_01.jpg"/></div><p>You should see a falling circle that sticks to the mouse as you move it.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec18"/>Using mouseDown()</h2></div></div></div><p>The next event <a class="indexterm" id="id341"/>handler that we are going to implement is the <code class="literal">mouseDown()</code> handler. It will execute code every time we click on any of the mouse buttons. We will write code that will add a static circle on the screen every time we click the left mouse button. It will remove the first circle when we click the right mouse button.</p><p>To begin with, we will need to declare a new variable that will be able to store more than one pair of coordinates for our generated circles. We could use an array of <code class="literal">Vec2i</code> objects but as we don't know the exact count of the circles we are going to create, we will use a C++ <code class="literal">vector</code>.</p><p>A <strong>vector</strong>
<a class="indexterm" id="id342"/> is a dynamic array that is able to store <code class="literal">std::vector::max_size</code> amount of objects of a certain type. A <code class="literal">vector</code> array changes it's size (or length) dynamically on element add (or push) and remove (or pop).</p><p>Add the following lines of code at the end of our class declaration:</p><div><pre class="programlisting">vector&lt;Vec2i&gt; circlePositions;
void mouseDown(MouseEvent event);</pre></div><p>It is possible that the <code class="literal">mouseDown()</code> method<a class="indexterm" id="id343"/> is declared for us already. If so, don't mention the second line of the code. If <code class="literal">mouseDown()</code> was not declared before, go ahead and add the event handler method to the class implementation:</p><div><pre class="programlisting">void BasicEventsApp::mouseDown(MouseEvent event)
{
    // check if the left mouse button was pressed
    if ( event.isLeft() ) {
        // it was
        Vec2i cp = event.getPos(); // save current mouse position
        circlePositions.push_back(cp); // and add it to the vector
    }
    
    // check if the right mouse button was pressed
    if ( event.isRight() ) {
        // it was
        // check if the vector has at least one element
        if ( !circlePositions.empty() ) {  
            // it has, erase the first element
            circlePositions.erase(circlePositions.begin());
        }
    }
}</pre></div><p>As you can tell from the comments in the preceding code, it checks which mouse button has been pressed and then decides what to do next. As we stated before, a circle has to be created when you click the left-mouse button and a circle has to be removed when you click on the right-mouse button. Actually we do not create circles here, we just save their positions. In the <code class="literal">draw()</code> method we will be able to chose whether we want to draw circles or something else entirely.</p><p>So let's navigate to the <code class="literal">draw()</code> method implementation and add the following code snippet:</p><div><pre class="programlisting">// declare an iterator for this specific kind of vector
vector&lt;Vec2i&gt;::iterator i;
    
// loop through circle positions
for ( i=circlePositions.begin(); i!=circlePositions.end(); ++i ) {
    // and draw circles at these positions one by one
    gl::drawSolidCircle( *i, 20 );
}</pre></div><p>To loop <a class="indexterm" id="id344"/>through a vector we have to use an iterator in this case. Vector iterators are objects that are designed to traverse the vector. In this case the iterator object is like a pointer and a <code class="literal">vector&lt;Vec2i&gt;</code> type iterator will point to a <code class="literal">Vec2i</code> object inside of it. By increasing and decreasing the iterator position we gain access to the next or previous item in the vector. It is possible to get the <code class="literal">begin()</code> and <code class="literal">end()</code> iterators from a vector and they point to the first and the past-the-end element of a vector respectively.</p><p>To access an element through the iterator (that is similar to a pointer), we have to make use of the concept of <strong>dereferencing</strong>
<a class="indexterm" id="id345"/>. To dereference a pointer we have to use an asterisk (<code class="literal">*</code>) before the pointer variable. If <code class="literal">i</code> is a pointer to the actual position of a circle, to access the actual <code class="literal">Vec2i</code> object that stores the coordinates, we have to use <code class="literal">*i</code>. To access properties of the object, we write <code class="literal">(*i).x</code> or <code class="literal">i-&gt;x</code>.</p><p>Compile and run the project. You should be able to add and remove circles by clicking on the right and left buttons of your mouse.</p><div><img alt="Using mouseDown()" src="img/9564_10_02.jpg"/></div><p>You can do the same by using the <code class="literal">mouseUp()</code> event handler instead of <code class="literal">mouseDown()</code>. The only <a class="indexterm" id="id346"/>difference is that the code will be executed when you release the mouse button.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec19"/>Using mouseDrag()</h2></div></div></div><p>Next we are going to <a class="indexterm" id="id347"/>make use of the <code class="literal">mouseDrag()</code> event handler to draw a polyline on the screen. We will need another <code class="literal">vector</code> for storing the coordinates of the points that will actually form the polyline. Let's declare the <code class="literal">vector</code> and <code class="literal">mouseDrag()</code> event handlers in the class declaration. Add the following line of code at the end of it:</p><div><pre class="programlisting">PolyLine&lt;Vec2f&gt; line;
void mouseDrag(MouseEvent event);</pre></div><p>We use <code class="literal">PolyLine&lt;Vec2f&gt;</code> here because <code class="literal">PolyLine</code> is a Cinder class that is used to store control point values of a line. We use <code class="literal">Vec2f</code> instead of <code class="literal">int</code>, because there is no <code class="literal">draw</code> function in Cinder that would accept a <code class="literal">PolyLine</code> class that consists of <code class="literal">int</code> values.</p><p>Let's move to the next step and add the implementation of the <code class="literal">mouseDrag()</code> method to the class implementation:</p><div><pre class="programlisting">void BasicEventsApp::mouseDrag(MouseEvent event) {
    // create new position from current mouse position
    Vec2f cp = event.getPos();
    
    // copy it to the PolyLine
    line.push_back(cp);
}</pre></div><p>This will add a new position with the current mouse coordinates to the <code class="literal">PolyLine</code> each time a change in mouse position is detected.</p><p>Lastly, we have to draw the <code class="literal">PolyLine</code>. So let's navigate to the <code class="literal">draw()</code> method implementation and add the following line of code there:</p><div><pre class="programlisting">if ( line.size() ) {
  gl::drawSolid(line);
}</pre></div><p>The <code class="literal">gl::drawSolid</code> function <a class="indexterm" id="id348"/>will basically draw a filled polygon. The <code class="literal">PolyLine</code> itself defines the outline of the polygon. Compile and run the project to see what I mean to say. You should end up with an image similar to the one shown in the following screenshot:</p><div><img alt="Using mouseDrag()" src="img/9564_10_03.jpg"/></div><p>If you want to draw a line, use <code class="literal">gl::draw(line)</code> instead.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec20"/>Using keyDown()</h2></div></div></div><p>It would be nice if we had the <a class="indexterm" id="id349"/>ability to clear the screen while the application is running instead of closing and reopening it to start again. Let's make use of the <code class="literal">keyDown()</code> event handler to detect a key press. What we want to do is to erase all circles and the line when the <em>C</em> key is pressed. To do that, we need to declare the <code class="literal">keyDown()</code> method in the class declaration:</p><div><pre class="programlisting">void keyDown(KeyEvent event);</pre></div><p>Next we have to implement this, so add the following code snippet at the end of the file:</p><div><pre class="programlisting">void BasicEventsApp::keyDown(KeyEvent event) {
    if ( event.getCode() == KeyEvent::KEY_c ) {
        circlePositions.clear();
        line.getPoints().clear();
    }
}</pre></div><p>The <code class="literal">keyDown()</code> method takes a <code class="literal">KeyEvent</code> parameter that contains the code of the key that is being pressed. Here we check if the key code represents the letter C on the keyboard and if that is <code class="literal">true</code>, we clear the <code class="literal">circlePositions</code> <code class="literal">vector</code> and <code class="literal">vector</code> values in the <code class="literal">PolyLine</code> object that actually stores the control points in the same manner as the <code class="literal">vector</code> <code class="literal">circlePositions</code> does.</p><p>You can <a class="indexterm" id="id350"/>do the same thing with the <code class="literal">keyUp()</code> event handler. We won't make a separate example of it now as it works exactly the same way when a key is released.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec21"/>Using fileDrop()</h2></div></div></div><p>What we will do though is we <a class="indexterm" id="id351"/>will make use of the <code class="literal">fileDrop()</code> event handler to place a picture in the background. It takes <code class="literal">FileDropEvent</code> object as a parameter. It contains the path to the file that is being dropped on to the application window. To make use of that path, we need to add these lines at the top of the class file:</p><div><pre class="programlisting">#include "cinder/gl/Texture.h"
#include "cinder/ImageIo.h"</pre></div><p>The first include is needed because it contains the <code class="literal">gl::Texture</code> class that we will need in order to store the background image and to draw it by using the <code class="literal">gl::draw()</code> function. The <code class="literal">ImageIo.h</code> file is here because of the image loading functions that we will need to load an actual image into the <code class="literal">Texture</code> instance.</p><p>Next, we need to declare a variable that will store the background image and the <code class="literal">fileDrop()</code> event method itself. Add the following lines of code at the end of the class declaration:</p><div><pre class="programlisting">gl::Texture background;
void fileDrop(FileDropEvent);</pre></div><p>Now we need to implement the <code class="literal">fileDrop()</code> method. Add the following lines of code in the class implementation:</p><div><pre class="programlisting">void BasicEventsApp::fileDrop(FileDropEvent event) {
    try {
         background = gl::Texture( loadImage( event.getFile(0) ) );
   } catch( ... ) {
         console() &lt;&lt; "unable to load file" &lt;&lt; endl;
   };
}</pre></div><p>Here we are making use of the <code class="literal">try</code> and <code class="literal">catch</code> statement. By doing this we just make sure that our application does not crash if the wrong kind of file is being dropped. We load an image into the <code class="literal">background</code> variable if we are lucky or print an error message to the console if not.</p><p>Take a<a class="indexterm" id="id352"/> closer look on the <code class="literal">console()</code> function call. The <code class="literal">console()</code> function<a class="indexterm" id="id353"/> refers to the standard output or console. This is one of the best debugging tools in the world and you should consider using it if you are not using it already.</p><p>There is one last thing missing, we have to draw the <code class="literal">background</code>. Go to the <code class="literal">draw()</code> method implementation and add the following code snippet right after the <code class="literal">gl::clear()</code> function call and before all the code we added to this method during this chapter. We do so because the background is the first thing that we need to draw in each frame:</p><div><pre class="programlisting">if ( background ) {
    gl::draw( background, getWindowBounds() );
}</pre></div><p>Before we draw a texture, we have to make sure that it actually exists. That's why we are using an extra if statement. Only then 'can' we draw the background texture within the bounds of our application window that is returned by the <code class="literal">getWindowBounds()</code> method call.</p><p>Compile and run our application. Drop an image file on to the window of our application and see what happens. You should see an image similar to the following screenshot:</p><div><img alt="Using fileDrop()" src="img/9564_10_04.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec63"/>Summary</h1></div></div></div><p>In this chapter, we gained a basic understanding about the built-in and mostly used events that any kind of application could make use of. We learned how to make use of mouse press, mouse drag, key press, and even file drop events. We also made use of some new drawing methods that were not explained in previous chapters.</p><p>In the next chapter, we are going to talk about communication between applications built-in Cinder, and other applications on the same or other networked computer by using Syphon and Open Sound Control message system.</p></div></body></html>