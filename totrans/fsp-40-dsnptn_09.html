<html><head></head><body>
<div class="chapter" title="Chapter&#xA0;9.&#xA0;More Data Crunching">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch09"/>
 Chapter 9. More Data Crunching</h1>
</div>
</div>
</div>
<p>Up until this point, all F# data transformation patterns covered were dealing with in-memory collections. That is, important data crunching use cases, such as querying data, already persisted within the enterprise, and ingesting data from outside of the enterprise have not been considered yet.</p>
<p>This chapter covers these data transformation scenarios and related coding patterns:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Querying the external data. I'll begin with querying the data using F# query expressions. We are going to see how the same transformation patterns we distilled in <a class="link" title="Chapter 8. Data Crunching – Data Transformation Patterns" href="text00065.html#page">Chapter 8</a>
 , <span class="emphasis">
<em>Data Crunching - Data Transformation Patterns</em>
</span>
 , in relation to core library function members are fully applicable to querying the external data presented in a data base or a web service. It also would be interesting to push the limits of composition in query expressions.</li>
<li class="listitem">Parsing data from the external sources. We already spent a fair amount of time considering pattern matching amplified by active patterns. However, I do not feel an imperative need for using some advanced techniques, such as parser combinators. I'll show some from-the-trenches examples of production quality data parsing achieved with just a bit of custom coding.</li>
</ul>
</div>
<div class="section" title="Data querying">
<div class="titlepage">
<div>
<div>
<h1 class="title" id="toc_1"><a id="ch09lvl1sec60"/>
 Data querying</h1>
</div>
</div>
</div>
<p>So far in the book, the sources of data collections were either collection generators or the file system. Let me move toward more realistic enterprise data sources, where data are persisted in databases. To access and transform such data, F# provides <span class="strong">
<strong>query expressions</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/query-expressions-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/query-expressions-%5bfsharp%5d</a>
 ).</p>
<p>
<span class="strong">
<strong>Query expressions</strong>
</span>
 represent a concrete type of <span class="strong">
<strong>computation expressions</strong>
</span>
 that is embedded into the language. They allow to bring data into memory by querying external sources and transforming incoming data to the desired shape.</p>
<p>The F# query expressions are akin to sequence expressions: both produce data sequences. However, before the final data projection shaping the produced data sequence a query expression may apply to data a wide variety of data transformations that are similar to what we used to see in <span class="strong">
<strong>LINQ</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Language_Integrated_Query">https://en.wikipedia.org/wiki/Language_Integrated_Query</a>
 ). Query expressions can be considered LINQ support in F#.</p>
<div class="section" title="F# and LINQ before query expressions">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch09lvl2sec101"/>
 F# and LINQ before query expressions</h2>
</div>
</div>
</div>
<p>Chronologically, query expressions were introduced in F# 3.0. Prior to that, F# allowed you to access the LINQ machinery via <span class="strong">
<strong>.NET 3.5 Enumerable</strong>
</span>
 <span class="strong">
<strong>extension</strong>
</span>
 <span class="strong">
<strong>methods</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.110).aspx</a>
 ). Let's look at the following script, which finds out the last vowel in the sequence of lexicographically ordered letters of the English alphabet (<code class="literal">Ch9_1_1.fsx</code>
 ):</p>
<pre class="programlisting">let isVowel = function 
              | 'A' | 'a' | 'E' | 'e' | 'I' | 'i' 
              | 'O' | 'o' | 'U' | 'u' -&gt; true 
              | _ -&gt; false 
 
let alphabet = seq { 'A' .. 'Z' } 
 
alphabet |&gt; Seq.filter isVowel |&gt; Seq.sortDescending |&gt; Seq.head 
// val it : char = 'U' 
</pre>
<p>If we recollect that the F# sequence <code class="literal">alphabet</code>
 is <code class="literal">IEnumerable</code>
 , then the task can be achieved with LINQ extension methods (<code class="literal">Ch9_1_2.fsx</code>
 ):</p>
<pre class="programlisting">open System.Linq 
let isVowel = function 
              | 'A' | 'a' | 'E' | 'e' | 'I' | 'i' 
              | 'O' | 'o' | 'U' | 'u' -&gt; true 
              | _ -&gt; false 
let alphabet = seq { 'A' .. 'Z' } 
alphabet.Where(isVowel).OrderByDescending(fun x -&gt; x).First() 
// val it : char = 'U' 
</pre>
<p>Using the <span class="emphasis">
<em>fluent interface</em>
</span>
 of LINQ extension methods as a rough substitute for the F# pipe operator, <code class="literal">|&gt;</code>
 , we have achieved almost one-to-one correspondence between the definitions. The same result has been achieved by combining the <code class="literal">Seq</code>
 library functions, <code class="literal">filter-sortDescending-head</code>
 , and by combining the LINQ extension methods, <code class="literal">Where-OrderByDescending-First</code>
 .</p>
</div>
<div class="section" title="Introducing F# query expressions">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_3"><a id="ch09lvl2sec102"/>
 Introducing F# query expressions</h2>
</div>
</div>
</div>
<p>You may ask why I pay so much attention to the above similarity? That is because query expressions are nothing more than <span class="emphasis">
<em>syntactic sugar</em>
</span>
 similar to the one we observed with sequence expressions in <a class="link" title="Chapter 6.  Sequences - The Core of Data Processing Patterns" href="text00053.html#ch06">Chapter 6</a>
 , <span class="emphasis">
<em>Sequences - The Core of Data Processing Patterns</em>
</span>
 . Query expressions use F# computation expressions magic to express chain of function applications as a linear sequence of SQL-like operations within built-in computation expression builder <code class="literal">query { ... }</code>
 . This approach is similar to <code class="literal">seq { ... }</code>
 workings for generating F# sequences. The script <code class="literal">Ch9_1_2.fsx</code>
 given in the previous section may be present using a query expression as (<code class="literal">Ch9_1_3.fsx</code>
 ):</p>
<pre class="programlisting">let isVowel = function 
              | 'A' | 'a' | 'E' | 'e' | 'I' | 'i' 
              | 'O' | 'o' | 'U' | 'u' -&gt; true 
              | _ -&gt; false 
 
let alphabet = seq { 'A' .. 'Z' } 
 
query { 
    for letter in alphabet do 
    where (isVowel letter) 
    sortByDescending letter 
    select letter // may be omitted 
    head 
} 
// val it : char = 'U' 
</pre>
<p>When dissecting the preceding query expression you may spot the already familiar <span class="strong">
<strong>ETL</strong>
</span>
 data transformation process considered in <a class="link" title="Chapter 8. Data Crunching – Data Transformation Patterns" href="text00065.html#page">Chapter 8</a>
 , <span class="emphasis">
<em>Data Crunching - Data Transformation Patterns</em>
</span>
 : given a collection, perform one or more modifications on its members, eventually projecting the query result. As a computation expression <code class="literal">query</code>
 provides that magic glue between adjacent lines. It makes the data flowing from one query operator to another in the manner similar to functions chained with the <code class="literal">&gt;&gt;</code>
 combinator.</p>
</div>
<div class="section" title="Query operators">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_4"><a id="ch09lvl2sec103"/>
 Query operators</h2>
</div>
</div>
</div>
<p>Although the number of <span class="strong">
<strong>query operators</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/query-expressions-%5Bfsharp%5D">https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/query-expressions-%5Bfsharp%5D</a>
 ) is substantially less than the number of F# core library functions for collections - only around 40 - the query operators fit nicely into, where applicable, the hierarchy of data transformation patterns (another similar <span class="emphasis">
<em>classification</em>
</span>
 I managed to discover is the following one (<a class="ulink" href="https://weblogs.asp.net/dixin/understanding-linq-to-objects-2-query-methods-and-query-expressions">https://weblogs.asp.net/dixin/understanding-linq-to-objects-2-query-methods-and-query-expressions</a>
 ). The mapping accompanied by the similar category names from the preceding classification provided in round brackets is given as following:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<span class="strong">
<strong>The aggregation p</strong>
</span>
 <span class="strong">
<strong>attern</strong>
</span>
 (<span class="emphasis">
<em>aggregation</em>
</span>
 ): This includes functions such as <code class="literal">count</code>
 , <code class="literal">averageBy</code>
 , <code class="literal">averageByNullable</code>
 , <code class="literal">minBy</code>
 , <code class="literal">maxBy</code>
 , <code class="literal">minByNullable</code>
 , <code class="literal">maxByNullable</code>
 , <code class="literal">sumBy</code>
 , and <code class="literal">sumByNullable</code>
</li>
<li class="listitem">
<span class="strong">
<strong>The searching pattern</strong>
</span>
 : This includes the <code class="literal">find</code>
 function</li>
<li class="listitem">
<span class="strong">
<strong>The selection pattern</strong>
</span>
 (<span class="emphasis">
<em>restriction</em>
</span>
 ): This contains  <code class="literal">last</code>
 , <code class="literal">lastOrDefault</code>
 , <code class="literal">head</code>
 , <code class="literal">headOrDefault</code>
 , <code class="literal">nth</code>
 , <code class="literal">exactlyOne</code>
 , <code class="literal">exactlyOneOrDefault</code>
 , <code class="literal">take</code>
 , <code class="literal">takeWhile</code>
 , <code class="literal">skip</code>
 , <code class="literal">skipWhile</code>
 , <code class="literal">distinct</code>
 , and <code class="literal">where</code>
</li>
<li class="listitem">
<span class="strong">
<strong>The partitioning pattern</strong>
</span>
 (<span class="emphasis">
<em>grouping</em>
</span>
 ): This contains  <code class="literal">groupBy</code>
 and <code class="literal">groupValBy</code>
</li>
<li class="listitem">
<span class="strong">
<strong>The reordering pattern</strong>
</span>
 (<span class="emphasis">
<em>ordering</em>
</span>
 ): This contains  <code class="literal">sortBy</code>
 , <code class="literal">sortByDescending</code>
 , <code class="literal">sortByNullable</code>
 , <code class="literal">sortByNullableDescending</code>
 , <code class="literal">thenBy</code>
 , <code class="literal">thenByDescending</code>
 , <code class="literal">thenByNullable</code>
 , and <code class="literal">thenByNullableDescending</code>
</li>
<li class="listitem">
<span class="strong">
<strong>The testing pattern</strong>
</span>
 (<span class="emphasis">
<em>quantifier</em>
</span>
 ): This contains  <code class="literal">exists</code>
 and <code class="literal">all</code>
</li>
<li class="listitem">
<span class="strong">
<strong>The mapping pattern</strong>
</span>
 (<span class="emphasis">
<em>projection</em>
</span>
 ): This contains  <code class="literal">select</code>
</li>
<li class="listitem">
<span class="strong">
<strong>The merge/split pattern</strong>
</span>
 (<span class="emphasis">
<em>convolution</em>
</span>
 ): This contains <code class="literal">zip</code>
 , <code class="literal">join</code>
 , <code class="literal">groupJoin</code>
 , and <code class="literal">leftOuterJoin</code>
</li>
</ul>
</div>
<p>Nice! However, so far, the consideration was rotating around in-memory collections. Then how do we encompass querying out-of-memory data? F# provides considerable flexibility in this matter; so, let's approach it gradually in order to explore the richness and variety of the available schemes.</p>
</div>
<div class="section" title="The role of a LINQ provider">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_5"><a id="ch09lvl2sec104"/>
 The role of a LINQ provider</h2>
</div>
</div>
</div>
<p>The important detail in using LINQ that often gets missed by occasional users is that the query mechanism is agnostic to the nature of the data collection. There is a layer that may be involved that abstracts the details of the concrete data source behind the <span class="strong">
<strong>IQueryable&lt;'T&gt;</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/bb351562(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/bb351562(v=vs.110).aspx</a>
 ) interface that we did not touch yet. Without involving this layer, you are on your own with our familiar <code class="literal">IEnumerable&lt;'T&gt;</code>
 interface.</p>
<p>Both interfaces ensure deferred execution. However, <code class="literal">IEnumerable&lt;'T&gt;</code>
 just brings into memory the data collection that matches a query expressed with relevant external means, subject to further <span class="strong">
<strong>LINQ-to-Object</strong>
</span>
 in-memory manipulations.</p>
<p>By comparison, <code class="literal">IQueryable&lt;'T&gt;</code>
 allows <span class="strong">
<strong>LINQ-to-Something</strong>
</span>
 (<span class="strong">
<strong>LINQ-to-SQL, LINQ-to-OData, LINQ-to-WMI,</strong>
</span>
 to name a few) workings by the virtue of the component named <span class="strong">
<strong>LINQ provider</strong>
</span>
 . It ensures hidden translation of a LINQ query to terms that the concrete substitute of <span class="emphasis">
<em>Something</em>
</span>
 part understands, followed by the translated query execution by <span class="emphasis">
<em>Something</em>
</span>
 , bringing just the matching data collection back into the memory. Those of you interested in what entity may play the role of <span class="emphasis">
<em>Something</em>
</span>
 , I refer to the representative-although slightly outdated - <span class="strong">
<strong>LINQ-to-Everywhere - List of LINQ Providers</strong>
</span>
 (<a class="ulink" href="https://blogs.msdn.microsoft.com/knom/2009/04/27/linq-to-everywhere-list-of-linq-providers/">https://blogs.msdn.microsoft.com/knom/2009/04/27/linq-to-everywhere-list-of-linq-providers/</a>
 ).</p>
<p>There are two key moments in the previous paragraph that must be understood properly. Firstly, <span class="emphasis">
<em>the LINQ provider fully abstracts the details of query translation and execution</em>
</span>
 . For the intuitively clear case of <span class="strong">
<strong>LINQ-to-SQL</strong>
</span>
 , such translation is quite straightforward. The translated SQL query is to be executed on the side of the engaged database engine, sending back over the wire only the results of the server-side query execution. For something like, for example, <span class="strong">
<strong>LINQ-to-CRM</strong>
</span>
 (<a class="ulink" href="http://linqtocrm.codeplex.com/">http://linqtocrm.codeplex.com/</a>
 ), some further digging would be required in order to find out what exactly this particular LINQ provider does.</p>
<p>Secondly, the to-be-translated LINQ query should not contain elements that cannot be expressed in terms of the translated query execution engine. Such violations may take place through selectiveness of features in the provider implementation, or unintentional capturing of unrelated elements from the context. This means that if the provider implementation, for example, does not support the sorting operation, the LINQ query that has the sorting piece will be rejected by the underlying provider. Also, sometimes, the translated query execution engines may have varying abilities and the same LINQ-to-SQL query may be successfully executed by the Microsoft SQL engine but fail miserably on a MySQL engine.</p>
<p>With the role of LINQ provider in mind, let's first turn to the case of LINQ provider-free F# querying.</p>
</div>
<div class="section" title="External data querying via IEnumerable&lt;'T&gt;">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_6"><a id="ch09lvl2sec105"/>
 External data querying via IEnumerable&lt;'T&gt;</h2>
</div>
</div>
</div>
<p>For this use case, let me take something that can be easily reproduced by you. Being on the Microsoft platform myself, I will be using the traditional test database Microsoft supplies to developers, namely <span class="strong">
<strong>Adventureworks 2014</strong>
</span>
 (<a class="ulink" href="https://msftdbprodsamples.codeplex.com/releases/view/125550">https://msftdbprodsamples.codeplex.com/releases/view/125550</a>
 ). It has been installed under the <span class="strong">
<strong>localdb</strong>
</span>
 Microsoft SQL engine that comes with Visual Studio 2013.</p>
<p>There is a <code class="literal">[Person].[Person]</code>
 table in this database that carries, among other things, names of people. Let me perform a simple analytical task on it by performing the following query:</p>
<pre class="programlisting">select count(distinct [FirstName]) from [Adventureworks2014].[Person].[Person] 
</pre>
<p>This allows me to find out that the database carries 1018 distinct personal first names. Let's find out how these names are distributed by the first letter in the English alphabet.</p>
<p>To access the database, I will be using the simple <code class="literal">Reader</code>
 object of native .NET <code class="literal">System.Data.SqlClient</code>
 library. The first (and rather simplistic) approach would be to just provide the complete list of distinct first names over the wire to the memory on demand. The following script implements this approach (<code class="literal">Ch9_1_4.fsx</code>
 ):</p>
<pre class="programlisting">open System.Data 
open System.Data.SqlClient 
 
let alphabet = seq { 'A' .. 'Z' } 
 
let connStr = @"Data Source=(localdb)projectsv12;Initial Catalog=Adventureworks2014;Integrated Security=true;" 
let dbConnection = new SqlConnection(connStr) 
dbConnection.Open() 
 
let dbCommand = new SqlCommand("select FirstName from [Person].[Person]",dbConnection) 
let names = seq { 
                printfn "reading from db"  
                use reader = dbCommand.ExecuteReader(CommandBehavior.Default) 
                while reader.Read() do yield reader.GetString(0) } 
let distribution = 
    query { 
        for letter in alphabet do 
            let howMuch = 
                query { 
                    for name in names do 
                    where (name.StartsWith(string letter)) 
                    distinct 
                    select name 
                } |&gt; Seq.length 
            sortBy howMuch 
            select (letter, howMuch) 
    } 
 
distribution |&gt; Seq.toList |&gt; printfn "%A" 
</pre>
<p>There are two query expressions here: the first goes over each <code class="literal">letter</code>
 of the <code class="literal">alphabet</code>
 , delegating the trip to the database for the complete set of data to the nested second query, and then filtering out everything in memory except names starting with the current <code class="literal">letter</code>
 value, throwing away duplicates and finding the resulting number of names. The outer query puts this number into its place according to the found frequency and returns the sought-for projection <code class="literal">(letter, howMuch)</code>
 as the <code class="literal">distribution</code>
 sequence. Materializing it in FSI, I can observe the target name distribution. The timed results of running the script <code class="literal">Ch9_1_4.fsx</code>
 are presented in the following screenshot, where FSI just takes source script code from the given file path:</p>
<div class="mediaobject"><img src="Image00042.jpg" alt="External data querying via IEnumerable&lt;'T&gt;"/>
<div class="caption">
<p>External SQL Querying: version 1</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>You may notice that while running, the script performed a complete reading of the list of first names from the <code class="literal">[Person][Person]</code>
 database table for 26 times, which is an apparent overkill, and the approach can be improved significantly.</p>
<p>For example, we may parameterize our SQL command and get back not all names, but just the distinct names for each specific letter, which will dramatically decrease the traffic over the wire with the database. The script being refactored to reflect this improvement approach is given in the following code (<code class="literal">Ch9_1_5.fsx</code>
 ):</p>
<pre class="programlisting">open System.Data 
open System.Data.SqlClient 
 
let alphabet = seq { 'A' .. 'Z' } 
 
let connStr = @"Data Source=(localdb)projectsv12;Initial Catalog=Adventureworks2014;Integrated Security=true;" 
let dbConnection = new SqlConnection(connStr) 
dbConnection.Open() 
 
let dbCommandR l = 
    new SqlCommand( 
        (sprintf "%s%s%s" "select distinct FirstName from [Person].[Person] where FirstName like '" l  
          "%'"), dbConnection) 
 
let names l = seq { 
                printfn "reading from db"  
                use reader = (dbCommandR l).ExecuteReader(CommandBehavior.Default) 
                while reader.Read() do yield reader.GetString(0) } 
 
let distribution = 
    query { 
        for letter in alphabet do 
            let howMuch = names (string letter) |&gt; Seq.length 
            sortBy howMuch 
            select (letter, howMuch) 
    } 
#time "on" 
distribution |&gt; Seq.toList |&gt; printfn "%A" 
</pre>
<p>You may notice that there is no need for the nested <code class="literal">query {...}</code>
 groups now, as a significant amount of work is delegated to the SQL engine over the wire. The timed results of running the refactored script are given in the following screenshot:</p>
<div class="mediaobject"><img src="Image00043.jpg" alt="External data querying via IEnumerable&lt;'T&gt;"/>
<div class="caption">
<p>External SQL Querying - version 2</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>You may observe an almost four-fold improvement in performance due to significant decrease of network traffic volume in the second version.</p>
<p>Pushing this trend of minimizing traffic to the extreme and giving as much work to the SQL server as possible, I may make all work get pushed on the side of SQL server, leaving just a rudimentary task of getting remote data for the F# query, such as in the third version of the script shown here (<code class="literal">Ch9_1_6.fsx</code>
 ):</p>
<pre class="programlisting">open System.Data 
open System.Data.SqlClient 
 
let connStr = @"Data Source=(localdb)projectsv12;Initial Catalog=Adventureworks2014;Integrated Security=true;" 
let dbConnection = new SqlConnection(connStr) 
dbConnection.Open() 
 
let dbCommandF = 
    new SqlCommand("select SUBSTRING(FirstName, 1, 1),count(distinct FirstName) as "count" 
                    from [Adventureworks2014].[Person].[Person] 
                    group by SUBSTRING(FirstName, 1, 1) 
                    order by count",dbConnection) 
 
let frequences = seq { 
                printfn "reading from db"  
                use reader = dbCommandF.ExecuteReader(CommandBehavior.Default) 
                while reader.Read() do yield (reader.GetString(0), reader.GetInt32(1)) } 
 
let distribution = 
    query { 
        for freq in frequences do 
        select freq 
    } 
#time "on" 
distribution |&gt; Seq.toList |&gt; printfn "%A" 
</pre>
<p>Note that now all the dirty work is done by the SQL server, which is perfectly fine as Microsoft SQL Server is a masterpiece of software dedicated to data storing and crunching, and it does its work really well (if you do not detrimentally interfere, of course). The results of running the final script refactoring are presented in the following screenshot. Do not miss there the evidence that the whole data exchange over the wire took just a single round trip:</p>
<div class="mediaobject"><img src="Image00044.jpg" alt="External data querying via IEnumerable&lt;'T&gt;"/>
<div class="caption">
<p>External SQL querying: version 3</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Wow, this optimization is the bomb! Version 3, in comparison with version 1, has roughly <span class="emphasis">
<em>17.6 times better performance</em>
</span>
 . Now your take-home lesson is hard to forget.</p>
<div class="note" title="Note">
<h3 class="title" id="toc_7"><a id="tip12"/>
 Tip</h3>
<p>Enterprise development demands that the underlying technology ensures the ample ability of distributing remote load. Such ability can be granted by F# <code class="literal">query</code>
 as well as by other means.</p>
</div>
</div>
<div class="section" title="External data querying via IQuerable&lt;'T&gt;">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_8"><a id="ch09lvl2sec106"/>
 External data querying via IQuerable&lt;'T&gt;</h2>
</div>
</div>
</div>
<p>I hope that after the bold performance results achieved in the previous section there is no need to convince you just how important the ability of relaying LINQ query execution to the remote party is. However, do not expect to take this for granted. This direction may have a steep learning curve, which we will notice shortly.</p>
<p>Let's take as a use case the 100% real task I was recently addressing on the job at <span class="strong">
<strong>Jet.com Inc.</strong>
</span>
 (<a class="ulink" href="https://jet.com/about-us">https://jet.com/about-us</a>
 ). I will be building a backend for a dashboard, showing some <span class="emphasis">
<em>top-paid partners of Jet.com</em>
</span>
 in real time (merchants with the largest amounts of reimbursement for fulfilled orders that they have shipped to Jet.com customers).</p>
<p>I will be accessing a limited amount of data from the Jet.com Quality Assurance environment, so the numbers will not be that indicative of real top-paid partners.</p>
<p>The data required for the dashboard backend are split between two databases: <code class="literal">SQL.Colossus</code>
 carries the data on payments in the <code class="literal">Payments</code>
 table, while <code class="literal">SQL.IronmanData</code>
 carries the data on partners in the <code class="literal">Partner</code>
 table.</p>
<p>If the case is that the data is located at the same SQL engine that supports cross-DB queries, then the T-SQL script that brings me the sought-for data would be something along the following lines (<code class="literal">Ch9_2.fsx</code>
 , commented section at the top):</p>
<pre class="programlisting">select top (10) min(r.DisplayName) as Name, sum(p.[Amount]) as Total 
from [sql.colossus].[dbo].[Payments] p 
join [sql.ironmandata].[dbo].[Partner] r on r.MerchantId = p.MerchantId 
where p.[IsDeposited] = 1 
group by p.[MerchantId] 
order by total desc 
</pre>
<p>After being executed against the target environment in SQL Server Management Studio, this yields the results reflected in the following screenshot:</p>
<div class="mediaobject"><img src="Image00045.jpg" alt="External data querying via IQuerable&lt;'T&gt;"/>
<div class="caption">
<p>SQL Query to feed the top-paid Jet.com Partners dashboard</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Let me make the first attempt in expressing the similar T-SQL query using the F# query expression <code class="literal">query{...}</code>
 . In order to get access to LINQ-to-SQL, I will be using a more advanced F# mechanism to get strongly typed access to the data than <span class="strong">
<strong>ADO.NET</strong>
</span>
 , which I was using in the previous section. This mechanism is known as the F# <span class="strong">
<strong>type provider</strong>
</span>
 . Specifically, I will be using the <span class="strong">
<strong>SQLDataConnection (LINQ to SQL) type provider</strong>
</span>
 (<a class="ulink" href="http://fsharp.org/guides/data-access/#sql-data-access">http://fsharp.org/guides/data-access/#sql-data-access</a>
 ), which is a part of the standard F# distribution that has been targeting Microsoft Windows since F# v3.0.</p>
<div class="note" title="Note">
<h3 class="title" id="toc_9"><a id="note13"/>
 Note</h3>
<p>Those of you who are totally unfamiliar with the matter can follow this <span class="strong">
<strong>MSDN walkthrough</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/walkthrough-accessing-a-sql-database-by-using-type-providers-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/walkthrough-accessing-a-sql-database-by-using-type-providers-%5bfsharp%5d</a>
 ) in order to better understand the contents of this section.</p>
</div>
<p>The F# script that can be put into the core of the dashboard backend is as follows (<code class="literal">Ch9_2.fsx</code>
 ):</p>
<pre class="programlisting">#r "FSharp.Data.TypeProviders" 
#r "System.Data" 
#r "System.Data.Linq" 
 
open Microsoft.FSharp.Data.TypeProviders 
open System.Linq 
 
[&lt;Literal&gt;] 
let compileTimeCsusCS = @"Data Source=(localdb)projectsv12;Initial Catalog=Colossus.DB;Integrated Security=SSPI" 
let runTimeCsusCS = @"Data Source=***;Initial Catalog=SQL.Colossus;User ID=***;Password=***" 
[&lt;Literal&gt;] 
let compileTimeImCS = @"Data Source=(localdb)projectsv12;Initial Catalog=SQL.Ironman;Integrated Security=SSPI" 
let runTimeImCS = @"Data Source=***;Initial Catalog=SQL.IronmanData;User ID=***;Password=***" 
 
type Colossus = SqlDataConnection&lt;compileTimeCsusCS&gt; 
type IronManData = SqlDataConnection&lt;compileTimeImCS&gt; 
 
let pmtContext = Colossus.GetDataContext(runTimeCsusCS) 
let imContext = IronManData.GetDataContext(runTimeImCS) 
 
let mostPaid = 
    fun x -&gt; query { 
                for payment in pmtContext.Payments do 
                where (payment.IsDeposited.HasValue &amp;&amp; payment.IsDeposited.Value) 
                groupBy payment.MerchantId into p 
                let total = query { for payment in p do sumBy payment.Amount} 
                sortByDescending total 
                select (p.Key,total) 
                take x 
             } 
 
let active = (mostPaid 10) 
let activeIds = active |&gt; Seq.map fst 
 
let mostActiveNames = 
    query { 
        for merchant in imContext.Partner do 
        where (activeIds.Contains(merchant.MerchantId)) 
        select (merchant.MerchantId,merchant.DisplayName) 
    } |&gt; dict 
 
active 
|&gt; Seq.map (fun (id, total) -&gt; (mostActiveNames.[id],total)) 
|&gt; Seq.iter (fun x -&gt; printfn "%s: %.2f" (fst x) (snd x)) 
</pre>
<p>Take into account that in order to adhere with the security requirements, I do not reveal any parameters of the Jet.com infrastructure except some (not necessarily coinciding with real ones) names of databases and tables.</p>
<p>When it comes to the type provider, it is important to realize that the provider itself works at compile-time, providing typed access to the fields of the involved SQL tables. In order to do this, it requires access to the SQL schema information at compile-time. This access to the structural information in the preceding script is given via the <code class="literal">compileTimeCsusCS</code>
 and <code class="literal">compileTimeImCS</code>
 connection strings for <code class="literal">Colossus.DB</code>
 and <code class="literal">SQL.Ironman</code>
 databases, respectively.</p>
<p>Note that compile-time access to the local SQL engine from the type provider has nothing to do with application data. It just retrieves system data about SQL schemas. These schemas are structurally similar to ones carrying application data on production SQL data engine. So, the provided <code class="literal">Colossus</code>
 and <code class="literal">IronManData</code>
 types are built off the <code class="literal">localdb</code>
 SQL engine, while the <code class="literal">pmtContext</code>
 and <code class="literal">imContext</code>
 runtime data contexts are built off the production server(s) with the help of <code class="literal">runTimeCsusCS</code>
 and <code class="literal">runTimeImCS</code>
 runtime connection strings.</p>
<p>The <code class="literal">mostPaid</code>
 function represents the query used to find any given number of top-paid partners along with their aggregate deposited payments. As we may expect, the signature of this function is <code class="literal">mostPaid : x:int -&gt; System.Linq.IQueryable&lt;string * decimal&gt;</code>
 , and it is to be translated by the LINQ-to-SQL provider into plain T-SQL, to be executed on the SQL server side.</p>
<p>Another interesting moment is that in Jet.com's Microsoft Azure production environment, cross-database queries such as the one from Figure <span class="emphasis">
<em>SQL Query to feed the top-paid Jet.com Partners dashboard</em>
</span>
 do not work, so I split the access into three phases:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">At the first phase, <code class="literal">active</code>
 represents a collection of tuples <code class="literal">(merchantId, paymentAmount)</code>
 of which the list of pertinent partner IDs, <code class="literal">activeIds</code>
 , can be easily projected</li>
<li class="listitem">At the second phase, another query, <code class="literal">mostActiveNames</code>
 , retrieves only those partner display names that belong only to the top-paid partners and packages them into a dictionary</li>
<li class="listitem">Finally, <code class="literal">active</code>
 experiences a transformation where the ID is substituted by <code class="literal">mostActiveNames.[id]</code>
 , yielding the final data shape required for the dashboard.</li>
</ul>
</div>
<p>The results of running the previous script with FSI are presented in the following screenshot; as expected, they are identical to previous ones:</p>
<div class="mediaobject"><img src="Image00046.jpg" alt="External data querying via IQuerable&lt;'T&gt;"/>
<div class="caption">
<p>F# Query via IQueryable&lt;'T&gt; in action</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
<div class="section" title="Composable queries">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_10"><a id="ch09lvl2sec107"/>
 Composable queries</h2>
</div>
</div>
</div>
<p>Wouldn't it be great to compose smaller F# subqueries into bigger queries? Put differently, it would mean composing multiple queryables into a single LINQ query translated into SQL and executed on the database engine side.</p>
<p>This sounds promising, and it has attracted the attention of some individual developers and groups.</p>
<div class="note" title="Note">
<h3 class="title" id="toc_11"><a id="note14"/>
 Note</h3>
<p>The most sizeable effort was taken by a group at the University of Edinburgh, UK, governed by functional programming authorities such as Philip Wadler. Their results can be found at the <span class="strong">
<strong>FSharpComposableQuery</strong>
</span>
  (<a class="ulink" href="http://fsprojects.github.io/FSharp.Linq.ComposableQuery/index.html">http://fsprojects.github.io/FSharp.Linq.ComposableQuery/index.html</a>
 ) project home page, offering a NuGet package, source code, tutorial, and even some theoretical papers on the subject. An introductory video presentation given by Philip Wader is available on the SkillsMatter website: <span class="strong">
<strong>A practical theory of language-integrated query</strong>
</span>
 (<a class="ulink" href="https://skillsmatter.com/skillscasts/4486-a-practical-theory-of-language-integrated-query">https://skillsmatter.com/skillscasts/4486-a-practical-theory-of-language-integrated-query</a>
 ).</p>
</div>
<p>Also, a few years ago, an alternative and more lightweight approach to composable queries was suggested in this <span class="strong">
<strong>blog post</strong>
</span>
 (<a class="ulink" href="http://fpish.net/blog/loic.denuziere/id/3508/2013924-f-query-expressions-and-composability">http://fpish.net/blog/loic.denuziere/id/3508/2013924-f-query-expressions-and-composability</a>
 ) by <span class="strong">
<strong>Loïc Denuzière</strong>
</span>
 (<a class="ulink" href="http://fpish.net/profile/loic.denuziere">http://fpish.net/profile/loic.denuziere</a>
 ). It is based on splicing partial F# query expressions together in order to build more complex ones. I will make a foray into composable LINQ queries based on the latter approach.</p>
<p>Just before we start writing the code, I must point out a big limitation of F# querying based on LINQ-to-SQL: it is not possible to perform cross-database and cross-engine queries, as <span class="emphasis">
<em>all subqueries must share the same LINQ context!</em>
</span>
 This factor might be a show-stopper for enterprises that have a multitude of <span class="strong">
<strong>OLTP</strong>
</span>
 and <span class="strong">
<strong>OLAP</strong>
</span>
 databases.</p>
<p>In order to refactor to a composable query a T-SQL query from the script <code class="literal">Ch9_2.fsx</code>
 that was covered above in the dashboard use case discussion, I have moved a copy of the <code class="literal">Partner</code>
 table to the <code class="literal">SQL.Colossus</code>
 database. It can now share the same LINQ context with the <code class="literal">Payments</code>
 table.</p>
<p>The composition method is based on introducing a special <code class="literal">PartialQueryBuilder</code>
 class that:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Subclasses standard <code class="literal">Linq.QueryBuilder</code>
 introducing extra method <code class="literal">Run</code>
</li>
<li class="listitem">Augmenting <code class="literal">Linq.QueryBuilder</code>
 with method <code class="literal">Source</code>
</li>
</ul>
</div>
<p>All these measures allow you writing subqueries with the alternative expression builder <code class="literal">pquery</code>
 that gets wrapped into quotations instead of being evaluated . These quotations are embedded into ordinary queries and get evaluated uniformly.</p>
<p>In the following script, which relies on these features, I've omitted the separation of compile-time and run-time connections for brevity (<code class="literal">Ch9_3.fsx</code>
 ):</p>
<pre class="programlisting">#r "FSharp.Data.TypeProviders" 
#r "System.Data" 
#r "System.Data.Linq" 
 
open Microsoft.FSharp.Data.TypeProviders 
open System.Linq 
 
[&lt;Literal&gt;] 
let runTimeCsusCS = @"Data Source=***;Initial Catalog=SQL.Colossus;User ID=***;Password=***" 
 
type Colossus = SqlDataConnection&lt;runTimeCsusCS&gt; 
 
let pmtContext = Colossus.GetDataContext(runTimeCsusCS) 
</pre>
<p>Then goes the utility part defining <code class="literal">pquery</code>
 :</p>
<pre class="programlisting">type PartialQueryBuilder() = 
    inherit Linq.QueryBuilder() 
    member __.Run(e:  Quotations .Expr&lt;Linq.QuerySource&lt;'T,IQueryable&gt;&gt;) = e 
 
let pquery = PartialQueryBuilder() 
 
type Linq.QueryBuilder with 
    [&lt;ReflectedDefinition&gt;] 
    member __.Source(qs: Linq.QuerySource&lt;'T,_&gt;) = qs 
</pre>
<p>Finally, the composed queries are as follows:</p>
<pre class="programlisting">let mostPaid = pquery { 
                    for payment in pmtContext.Payments do 
                    where (payment.IsDeposited.HasValue &amp;&amp; 
                           payment.IsDeposited.Value) 
                    groupBy payment.MerchantId into p 
                    let total = pquery { for payment in p do sumBy 
                                         payment.Amount} 
                    sortByDescending total 
                    select (p.Key,total) 
                    take 10 
                         } 
 
let dashboard = pquery { 
                    for merchant in pmtContext.Partner do 
                        for (id,total) in %mostPaid do 
                        where (merchant.MerchantId = id ) 
                        select (merchant.DisplayName, total) 
                       } 
 
query { for m in %dashboard do 
           select m } |&gt; Seq.iter (fun x -&gt; printfn "%s: %.2f" (fst x) (snd x)) 
</pre>
<p>Note how <code class="literal">mostPaid</code>
 is spliced into the <code class="literal">dashboard</code>
 , creating a seamless composition, and in turn, <code class="literal">dashboard</code>
 is spliced into the final query.</p>
<p>Running the script in FSI yields the results shown here:</p>
<div class="mediaobject"><img src="Image00047.jpg" alt="Composable queries"/>
<div class="caption">
<p>Getting dashboard data with the composed query</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>You may wonder whether there is a way to check out that the query composition really took place. Fortunately, that is not that hard to do. All it takes is adding the following property to the LINQ context, as shown here:</p>
<pre class="programlisting">pmtContext.Payments.Context.Log &lt;- new System.IO.StreamWriter( 
   @"C:usersgenedownloadspmtlinq.log", AutoFlush = true) 
</pre>
<p>After running the preceding script again, the LINQ log file now contains the SQL code executed by the SQL engine:</p>
<pre class="programlisting">SELECT [t0].[DisplayName] AS [Item1], [t3].[value] AS [Item2] 
FROM [dbo].[Partner] AS [t0] 
CROSS JOIN ( 
    SELECT TOP (10) [t2].[MerchantId], [t2].[value] 
    FROM ( 
        SELECT SUM([t1].[Amount]) AS [value], [t1].[MerchantId] 
        FROM [dbo].[Payments] AS [t1] 
        WHERE ([t1].[IsDeposited] IS NOT NULL) AND (([t1].[IsDeposited]) = 1) 
        GROUP BY [t1].[MerchantId] 
        ) AS [t2] 
    ORDER BY [t2].[value] DESC 
    ) AS [t3] 
WHERE [t0].[MerchantId] = [t3].[MerchantId] 
ORDER BY [t3].[value] DESC 
-- Context: SqlProvider(Sql2008) Model: AttributedMetaModel Build: 4.0.30319.33440 
</pre>
<p>Note how all <code class="literal">IQueryable</code>
 bits and pieces from the script F# queries get molded into the single SQL statement.</p>
</div>
</div>
</div>


<div class="section" title="Data parsing">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch09lvl1sec61"/>
 Data parsing</h1>
</div>
</div>
</div>
<p>The parsing of data is absolutely essential for the enterprise. As an enterprise F# developer at Jet.com, I come across this data transformation pattern on a daily basis. Every case of <span class="strong">
<strong>LOB</strong>
</span>
 applications' integration with a third-party system - <span class="strong">
<strong>ERP</strong>
</span>
 , <span class="strong">
<strong>Bank</strong>
</span>
 , or <span class="strong">
<strong>Carrier </strong>
</span>
 - involves data parsing on the ingesting edges. Despite a plethora of integration technologies around that promise great data quality, timeliness, integrity, you name it...time and again, I am forced by my contractors to deal with flat fixed format files, CSV files, and Excel files. This is the boring reality of today.</p>
<p>On this battlefield, the weaponry varies from case-by-case hand-coded solutions based on <span class="strong">
<strong>Regex</strong>
</span>
 and F# active patterns to fairly generic solutions targeting whole classes of incoming data with F# type providers. Some typical examples of semi-generic solutions are invoices in the form of CSV files and Excel files that are to be persisted in the SQL server for further processing, reconciliation, and future audit. I'll show how the high-quality parsing of incoming data can be achieved for the use case of digesting the carrier invoices ingested as an Excel file into the SQL server.</p>
<div class="section" title="The use case - LaserShip invoicing">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch09lvl2sec108"/>
 The use case - LaserShip invoicing</h2>
</div>
</div>
</div>
<p>LaserShip is one of the "last mile" delivery companies usually engaged by e-commerce for same-day expedited deliveries. Jet.com uses LaserShip services along with other carriers.</p>
<p>LaserShip delivers its invoicing information packaged as Excel files. For the purposes of reconciliation and auditing, it is desirable to load LaserShip invoices into the SQL server.</p>
</div>
<div class="section" title="Approaching the parsing task">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch09lvl2sec109"/>
 Approaching the parsing task</h2>
</div>
</div>
</div>
<p>When resembling ETL tasks pop up, I usually approach them with the following pattern:</p>
<div class="orderedlist">
<ol class="orderedlist arabic">
<li class="listitem">Define the schema of the SQL table that will carry the loaded data. Add to the data that come from the carrier extra field(s) allowing you to reference any chunk of data back to the carrier's file it originated from. Also, add the synthetic and/or natural key field(s) and reasonable constraints. The sample SQL table schema has been provided in the form of T-SQL script <code class="literal">SCHEMA_LaserShip.sql</code>
 .</li>
<li class="listitem">Ingest the file with the help of <span class="strong">
<strong>Excel Provider</strong>
</span>
 (<a class="ulink" href="http://fsprojects.github.io/ExcelProvider/">http://fsprojects.github.io/ExcelProvider/</a>
 ). Adjust the type provider settings to suppress the default field type interpretation and force the delivery of fields as strings. The Excel file template distributed by LaserShip to their customers has been provided as Excel file <code class="literal">Lasership Invoice Format.xlsx</code>
 .</li>
<li class="listitem">For the fields that may be omitted in the source represented the such as <span class="strong">
<strong>nullable</strong>
</span>
 values. Omitted values are to be filled with <code class="literal">System.DBNull.Value</code>
 singleton. Create or reuse a set of parsing functions for each field type returning a boxed parsed value or <code class="literal">System.DBNull.Value</code>
 .</li>
<li class="listitem">Parse the contents of the file into the  <code class="literal">System.Data.DataTable</code>
 instance matching column names with database fields and unboxing values parsed with generic parsing functions. The example invoice containing an excerpt of a real invoice with personal data wiped out has been provided as Excel file <code class="literal">LaserShip20160701.xlsx</code>
 .</li>
<li class="listitem">Load the filled <code class="literal">DataTable</code>
 instance into the SQL server using the ADO.NET <span class="strong">
<strong>SqlBulkCopy</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlbulkcopy(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlbulkcopy(v=vs.110).aspx</a>
 ).</li>
</ol>
<div style="height: 10px; width: 1px;"/>
</div>
</div>
<div class="section" title="LaserShip parser implementation">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_3"><a id="ch09lvl2sec110"/>
 LaserShip parser implementation</h2>
</div>
</div>
</div>
<p>The approach outlined earlier is implemented by the script <code class="literal">Ch9_4.fsx</code>
 . As the script length does not fit well with the book format it will not be given here in its entirety. Instead, I'll reproduce in this section only the most important excerpts from the script with my comments:</p>
<pre class="programlisting">#r @"C:...packagesExcelProvider.0.8.0libExcelProvider.dll" 
</pre>
<p>The line above ensures that NuGet package <span class="strong">
<strong>Excel Provider 0.8.0</strong>
</span>
 (<a class="ulink" href="https://www.nuget.org/packages/ExcelProvider">https://www.nuget.org/packages/ExcelProvider</a>
 ) is accessible from the script:</p>
<pre class="programlisting">type LaserShip = ExcelFile&lt; @"C:codePacktBookCodeChapter11lasership invoice format.xlsx", HasHeaders=true, ForceString=true&gt; 
</pre>
<p>The line above is extremely important. It gets processed <span class="emphasis">
<em>in compile-time</em>
</span>
 by the referred F# Excel type provider. The type provider using the given file path gets to the Excel file <code class="literal">lasership invoice format.xlsx</code>
 that represents the data template. We adjust type provider settings by defining <code class="literal">HasHeaders</code>
 and <code class="literal">ForceString</code>
 static <code class="literal">bool</code>
 parameters. The type provider produces on the fly the provided type <code class="literal">LaserShip</code>
 that will allow to access any cell of the invoice row by its name:</p>
<pre class="programlisting">let asNullableString = 
    function 
    | null -&gt; box System.DBNull.Value 
    | (s: string) -&gt; s.Trim() 
                     |&gt; function 
                        | "" -&gt; box System.DBNull.Value 
                        | l -&gt; box l 
</pre>
<p>The preceding definition of <code class="literal">asNullableString</code>
 function implements the idiomatic typed transition from the Excel data cell that we know is of type <code class="literal">string</code>
 to its <code class="literal">obj</code>
 representation suitable to be placed into not statically typed <code class="literal">System.Data.DataTable</code>
 in-memory data table. If data in Excel are omitted for the cell the function is given as argument, the returned value would be boxed <code class="literal">System.DBNull.Value</code>
 value suitable to be placed into the database field of type, described in T-SQL as <code class="literal">NVARCHAR(...) NULL</code>
 . The script defines functions similar to <code class="literal">asNullableString</code>
 for each type of the Excel file where strong type checking is required: <code class="literal">asNullableDate</code>
 , <code class="literal">asString</code>
 , <code class="literal">asNullableMoney</code>
 , and others:</p>
<pre class="programlisting">let headers = ["invno";"JobNumber";"TDate";...;"SourceId";"RowKey";] 
</pre>
<p>The preceding binding would be necessary for associating columns of in-memory data table with the database table columns for <code class="literal">SQLBulkCopy</code>
 :</p>
<pre class="programlisting">let loadLaserShip excelPath = 
    (new LaserShip(excelPath)).Data  
</pre>
<p>This function definition is very important as it performs ingestion of invoice data from the Excel file specified by the given <code class="literal">excelPath</code>
 argument to the in-memory placeholder <code class="literal">Data</code>
 procured by the provided type <code class="literal">LaserShip</code>
 :</p>
<pre class="programlisting">let fillDataTable sourceId (rows: IEnumerable&lt;LaserShip.Row&gt;) = 
    let dt = new DataTable() 
    do headers |&gt; Seq.iter(fun h-&gt; dt.Columns.Add(new DataColumn(h))) 
    for row in rows do 
        let dr = dt.NewRow() 
        dr.Item(0) &lt;- unbox (row.invno |&gt; asString "invno") 
         .  .  .  .  . 
        dr.Item(36) &lt;- unbox (row.PickupDate |&gt; asNullableString) 
        dr.Item(37) &lt;- sourceId 
        dt.Rows.Add(dr) 
    printfn "loaded %d rows" dt.Rows.Count 
    dt 
</pre>
<p>The preceding definition of the <code class="literal">fillDataTable</code>
 function is the gist of the script. You may notice the interesting type of argument it has: <code class="literal">rows: IEnumerable&lt;LaserShip.Row&gt;</code>
 . In other words <code class="literal">rows</code>
 is a sequence of another provided type <code class="literal">LaserShip.Row</code>
 representing a single row of invoice spreadsheet. Within the function a new instance of <code class="literal">DataTabledt</code>
 is created and supplied by column names taken from <code class="literal">headers</code>
 . Then each row of the ingested Excel file is parsed into the <code class="literal">dt</code>
 , taking care of data validity. In the end the loaded data table <code class="literal">dt</code>
 is returned.</p>
<p>A small, but very important detail: the <code class="literal">sourceId</code>
 argument above just references another table that keeps track of of the processed invoices. It has been written into the each row of in-memory data table, so after the data upload the reference will be available in the persisted to SQL server data to the metadata describing the data originating source. Further details are beyond the scope here.</p>
<p>Finally, another important function <code class="literal">loadIntoSQL</code>
 makes the bulk data upload into SQL server. Its definition is as follows:</p>
<pre class="programlisting">let loadIntoSQL tableName connStr (dataTable: DataTable) = 
    use con = new SqlConnection(connStr) 
    con.Open() 
    use bulkCopy = new SqlBulkCopy(con, DestinationTableName = tableName) 
    bulkCopy.WriteToServer(dataTable) 
    printfn "Finished write to server" 
</pre>
<p>There a connection <code class="literal">con</code>
 to the database gets opened using the provided connection string <code class="literal">connStr</code>
 value. Using the created connection and given SQL table name the instance of <code class="literal">SqlBulkCopy</code>
 is created and used for persisting in-memory <code class="literal">dataTable</code>
 to the associated SQL server table.</p>
<p>The preceding script can be further generalized to the degree where the only variable part will be the data related to the concrete file type. This variable part can be made pluggable into the universal Excel file parser. And this can be achieved in fewer than a hundred lines of code.</p>
</div>
</div>


<div class="section" title="Summary">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch09lvl1sec62"/>
 Summary</h1>
</div>
</div>
</div>
<p>This chapter wraps up the topic of data transformation patterns. Most of it is devoted to querying persisted data with the help of F# query expressions. You should be able to grasp the nuances of query work distribution between in-memory collections and the network-located data engine.</p>
<p>We also touched the important issue of data parsing, demonstrating the handful of simple patterns that allow you to ingest arbitrary Excel files with the helping hand of F# type providers, which will be further covered in <a class="link" title="Chapter 11. F# Expert Techniques" href="text00074.html#page">Chapter 11</a>
 , <span class="emphasis">
<em>F# Expert Techniques</em>
</span>
 .</p>
<p>In the next chapter, I will concentrate on dual patterns of type specialization (augmentation) and type generalization in F#.</p>
</div>
</body></html>