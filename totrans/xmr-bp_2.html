<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Building a SpeechTalk Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Building a SpeechTalk Application</h1></div></div></div><p>In this chapter, we introduce development with <code class="literal">Xamarin.Forms</code>. We will build a cross-platform application for iOS, Android, and Windows Phone that integrates native platform speech services to speak text typed from a text field.</p><p>Expected knowledge:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Microsoft Visual Studio.</li></ul></div><p>In this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cross-platform development with <code class="literal">Xamarin.Forms</code></li><li class="listitem" style="list-style-type: disc">Setting up platform projects</li><li class="listitem" style="list-style-type: disc">Setting up a <code class="literal">SpeechTalk.iOS</code> project</li><li class="listitem" style="list-style-type: disc">Setting up a <code class="literal">SpeechTalk.Droid</code> project</li><li class="listitem" style="list-style-type: disc"><code class="literal">Xamarin.Forms</code>, Windows Phone, and Visual Studio</li><li class="listitem" style="list-style-type: disc">Inversion of Control (IoC) with <code class="literal">Xamarin.Forms</code></li><li class="listitem" style="list-style-type: disc">AutoFac</li><li class="listitem" style="list-style-type: disc">iOS text-to-speech implementation</li><li class="listitem" style="list-style-type: disc">Bindings</li><li class="listitem" style="list-style-type: disc">Android text-to-speech implementation</li><li class="listitem" style="list-style-type: disc">Setting up IoC with Android</li><li class="listitem" style="list-style-type: disc">WinPhone text-to-speech implementation</li><li class="listitem" style="list-style-type: disc">IoC with Windows Phone</li><li class="listitem" style="list-style-type: disc">Platform-independent styling</li></ul></div><div class="section" title="Cross-platform development with Xamarin.Forms"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Cross-platform development with Xamarin.Forms</h1></div></div></div><p>The key ingredient in cross-platform development with Xamarin is code sharing. Sharing native code is great, but we still have the issue of writing separate user interface code for each platform. The <span class="strong"><strong>Windows Presentation Framework</strong></span> (<span class="strong"><strong>WPF</strong></span>) is a presentation system which uses an XML-based language known as <span class="strong"><strong>Extensible Application Markup Language</strong></span> (<span class="strong"><strong>XAML</strong></span>). Xamarin.Forms uses WPF and the <span class="strong"><strong>Model-View-View-Model</strong></span> (<span class="strong"><strong>MVVM</strong></span>) paradigm to build native user interfaces from a single C# shared code base, whilst maintaining access to all native APIs on each platform.</p><div class="mediaobject"><img src="graphics/B05293_02_01.jpg" alt="Cross-platform development with Xamarin.Forms"/></div><p>The preceding diagram represents a native architecture. We keep all the sharable code Inside the <span class="strong"><strong>Shared C# App Logic</strong></span> block (normally a shared project) for each platform project to access, i.e. the <code class="literal">GalleryItem</code> class would be kept here since it is shared between both projects.</p><div class="section" title="So how would this look in Xamarin.Forms?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec5"/>So how would this look in Xamarin.Forms?</h2></div></div></div><p>Using <code class="literal">Xamarin.Forms</code>, since we have the ability to share the user interface screens, we can
share the entire view and view model code between all platforms:</p><div class="mediaobject"><img src="graphics/B05293_02_02.jpg" alt="So how would this look in Xamarin.Forms?"/></div><p>In the preceding diagram, the code contained in the <span class="strong"><strong>Shared C# App Logic</strong></span> block is contained in a <span class="strong"><strong>Portable Class Library</strong></span> (<span class="strong"><strong>PCL</strong></span>), which each native project will import. <code class="literal">Xamarin.Forms</code> makes it possible to share up to 85% of code.</p><p>Let's now delve into development and setup our first <code class="literal">Xamarin.Forms</code> project.</p></div></div></div>
<div class="section" title="Setting up platform projects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Setting up platform projects</h1></div></div></div><p>In Xamarin Studio, let's start by setting up the platform projects. Go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Solution</strong></span> and select a <span class="strong"><strong>Xamarin.Forms</strong></span> app from the cross-platform menu on the left:</p><div class="mediaobject"><img src="graphics/B05293_02_03.jpg" alt="Setting up platform projects"/></div><p>Once the project is created, you will see both an iOS and Android project created along with a PCL.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Unfortunately, we can't develop our Windows Phone applications through Xamarin Studio; we will be touching on this after the iOS and Android projects.</p></div></div><p>Let's create our first <code class="literal">ContentPage</code> in XAML, right-click on the PCL, create a new XAML <code class="literal">ContentPage,</code> and call it <code class="literal">MainPage</code>:</p><div class="mediaobject"><img src="graphics/B05293_02_04.jpg" alt="Setting up platform projects"/></div><p><code class="literal">Xamarin.Forms</code> provides the option to build user interfaces entirely in C#, but it is recommended you stick with XAML because it is a very powerful markup language. The code required for a XAML sheet is much smaller than a user interface in C#.</p><p>We also want to create a new folder called <code class="literal">Pages</code> and add <code class="literal">MainPage</code> to this folder.</p><p>Our first element on the page is a <code class="literal">Grid.</code> A Grid separates a layout by rows and columns based upon the entire size of the screen. Rows work from top to bottom and columns work from left to right; copy the following into the <code class="literal">MainPage.xaml</code> sheet:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &#13;
&lt;ContentPage   &#13;
      &#13;
    x:Class="SpeechTalk.Pages.MainPage"&gt; &#13;
 &#13;
    &lt;ContentPage.Content&gt; &#13;
 &#13;
    &lt;Grid x:Name="Grid" RowSpacing="0" Padding="10, 10, 10, 10" &gt; &#13;
        &lt;Grid.RowDefinitions&gt; &#13;
            &lt;RowDefinition Height="Auto"/&gt; &#13;
            &lt;RowDefinition Height="Auto"/&gt; &#13;
            &lt;RowDefinition Height="Auto"/&gt; &#13;
        &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
        &lt;Grid.ColumnDefinitions&gt; &#13;
            &lt;ColumnDefinition Width="*"/&gt; &#13;
        &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
    &lt;/Grid&gt;  &#13;
 &#13;
    &lt;/ContentPage.Content&gt; &#13;
 &#13;
&lt;/ContentPage&gt; &#13;
</pre><p>At the top we have an XML description tag exactly like Android, which specifies an encoding and a version. We have the declaration of a <code class="literal">ContentPage</code> with the XML namespace specification attribute <code class="literal">xmlns</code>. We then specify the class name and add the <code class="literal">ContentPage.Content</code> tags, where we will create the page layout. All these XML tags are generated automatically; the only change we made was the namespace of the class:</p><pre class="programlisting">x:Class="SpeechTalk.Pages.MainPage" &#13;
</pre><p>The Grid inserted between the <code class="literal">ContentPage.Content</code> tags has three rows and three columns. Each row definition is assigned <code class="literal">Auto</code>, meaning the height of the row is based on the element assigned to it. Since we have three rows assigned with <code class="literal">Auto</code>, the Grid will only fill the height of the contained elements (similar to the <code class="literal">wrap_content</code> flag in android). The Grid will take up the entire width of the page as its one column definition is set to "*", meaning it will stretch one column to the entire width of the page. We have our basic page layout, so let's leave it there and move back into the project structure.</p><p>In <code class="literal">SpeechTalk.PCL</code>, we have a file called <code class="literal">SpeechTalk.cs</code>; we should rename this <code class="literal">App.cs</code> to match the class name. In the <code class="literal">App.cs</code>, this is the application starting point. In the constructor of the application class, you will see a <code class="literal">MainPage</code> property automatically set like so:</p><pre class="programlisting">public App () &#13;
        { &#13;
            // The root page of your application &#13;
            MainPage = new ContentPage { &#13;
                Content = new StackLayout { &#13;
                    VerticalOptions = LayoutOptions.Center, &#13;
                    Children = { &#13;
                        new Label { &#13;
                            XAlign = TextAlignment.Center, &#13;
                            Text = "Welcome to Xamarin Forms!" &#13;
                        } &#13;
                    } &#13;
                } &#13;
            }; &#13;
        } &#13;
</pre><div class="section" title="So what is happening here?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec6"/>So what is happening here?</h2></div></div></div><p>When the project is created, we automatically receive an <code class="literal">App</code> class with the <code class="literal">MainPage</code> property set to a new <code class="literal">ContentPage</code>. The preceding code block is an example of an interface built entirely via c-sharp. We want to replace this with an instantiation of our <code class="literal">MainPage</code>, and set this new object to the <code class="literal">MainPage</code> property of the <code class="literal">App</code> class.
Here is the updated constructor:</p><pre class="programlisting">public App () &#13;
        { &#13;
            MainPage = new MainPage (); &#13;
        } &#13;
</pre><p>It's much cleaner, you can already see how messy the code would look like if we were to build complex user interfaces in <span class="strong"><strong>C#</strong></span>.</p></div></div>
<div class="section" title="Setting up the SpeechTalk.iOS project"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Setting up the SpeechTalk.iOS project</h1></div></div></div><p>Let's also have a look at the project setup on the native side for iOS and Android. Open the <code class="literal">AppDelegate.cs</code> file; it should look like this:</p><pre class="programlisting">    [Register ("AppDelegate")] &#13;
    public partial class AppDelegate : global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate &#13;
    { &#13;
        public override bool FinishedLaunching (UIApplication app, NSDictionary options) &#13;
        { &#13;
            global::Xamarin.Forms.Forms.Init (); &#13;
 &#13;
            LoadApplication (new App ()); &#13;
 &#13;
            return base.FinishedLaunching (app, options); &#13;
        } &#13;
    } &#13;
</pre><p>Have a look at the super class:</p><pre class="programlisting">global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate &#13;
</pre><p>Since <code class="literal">Xamarin.Forms</code> 1.3.1 and the updated unified API, all our app delegate should be inheriting is <code class="literal">Xamarin.Forms.Platform.iOS.FormsApplicationDelegate</code>. We also have the standard <code class="literal">FinishedLaunching</code> function; in here we must call <code class="literal">Forms.Init </code>which will initialize <code class="literal">Xamarin.Forms</code>, and then call <code class="literal">LoadApplication</code> with a new instantiation of the <code class="literal">App</code> class. We then return the base class <code class="literal">FinishedLaunching</code> function, passing in the app and options objects.</p><p>You can see that this <code class="literal">FinishedLaunching</code> function is an override of the standard app delegate function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>We must initialize forms before anything else occurs in this function.</p></div></div><p>Let's run the iOS application and see what happens:</p><div class="mediaobject"><img src="graphics/B05293_02_05.jpg" alt="Setting up the SpeechTalk.iOS project"/></div><p>Fantastic, a blank application. That means we have now successfully run our first iOS <code class="literal">Xamarin.Forms</code> project.</p></div>
<div class="section" title="Setting up the SpeechTalk.Droid project"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Setting up the SpeechTalk.Droid project</h1></div></div></div><p>Let's do the same for Android and set up <code class="literal">Xamarin.Forms</code> accordingly. Inside our Android project, open the <code class="literal">MainActivity.cs</code> class and look at the <code class="literal">OnCreate</code> function:</p><pre class="programlisting">[Activity (Label = "SpeechTalk.Droid", Icon = "@drawable/icon", MainLauncher = true, ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation)] &#13;
    public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsApplicationActivity &#13;
    { &#13;
        protected override void OnCreate (Bundle bundle) &#13;
        { &#13;
            base.OnCreate (bundle); &#13;
 &#13;
            global::Xamarin.Forms.Forms.Init (this, bundle); &#13;
 &#13;
            LoadApplication (new App ()); &#13;
        } &#13;
    } &#13;
</pre><p>The <code class="literal">MainActivity</code> class must inherit <code class="literal">Xamarin.Forms.Platform.Android.FormsApplicationActivity</code>; we must call the super class <code class="literal">OnCreate</code> method before we initialize <code class="literal">Xamarin.Forms</code> and load in our new instantiated app class. That's all, we can now run the Android application and see the exact same results, a blank page. Congratulations, you have just shared your first <code class="literal">Xamarin.Forms</code> interface.</p></div>
<div class="section" title="Xamarin.Forms, Windows Phone, and Visual Studio"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Xamarin.Forms, Windows Phone, and Visual Studio</h1></div></div></div><p>Now let's look at sharing our <code class="literal">MainPage</code> interface with Windows Phone.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Not everyone will extend an app onto Windows Phone, so if you are not interested in creating a Windows Phone example you can skip this part.</p></div></div><p>We are going to be using Microsoft Visual Studio, so open it up and open the <code class="literal">SpeechTalk</code> solution file (<code class="literal">SpeechTalk.sln</code>) we created in Xamarin Studio. Portability between the two IDEs is very good; watch the solution port directly into Visual Studio and open your PCL file without any issues.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>Create a <code class="literal">GIT</code> repository to help control the continuous change between Xamarin Studio and Visual Studio, we recommend creating a GIT repository for every chapter.</p></div></div><p>The iOS and Android projects may not be compatible as we created these in Xamarin Studio.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>You can build iOS and Android applications directly in Visual Studio, but running iOS applications will require a mac build host.</p></div></div><p>Now it's time to create a new Windows Phone project:</p><div class="mediaobject"><img src="graphics/B05293_02_06.jpg" alt="Xamarin.Forms, Windows Phone, and Visual Studio"/></div><p>Unfortunately, the automated setup done with iOS and Android will not be done with the Windows Phone project. All the setup will be done manually, but this is good for walking you through the manual setup.</p><p>We import the <span class="strong"><strong>Xamarin.Forms</strong></span> nuget package:</p><div class="mediaobject"><img src="graphics/B05293_02_07.jpg" alt="Xamarin.Forms, Windows Phone, and Visual Studio"/></div><p>Now its time to look at the <code class="literal">MainPage.xaml</code> and <code class="literal">MainPage.xaml.cs</code> files in the <span class="strong"><strong>Windows Phone</strong></span> project.</p><p>Wait a minute, haven't we already made one of these?</p><p>Now that you are preparing a Windows Phone project, we can see the original WPF structure used in Xamarin.Forms.</p><p>Open up <code class="literal">MainPage.xaml</code> and paste in the following:</p><pre class="programlisting">&lt;forms:WindowsPhonePage &#13;
    x:Class="SpeechTalk.WinPhone.MainPage" &#13;
     &#13;
     &#13;
     &#13;
     &#13;
     &#13;
     &#13;
    mc:Ignorable="d" &#13;
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"&gt; &#13;
  &#13;
    &lt;Grid&gt; &#13;
  &#13;
    &lt;/Grid&gt; &#13;
&lt;/forms:WindowsPhonePage&gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>If any lines get underlined, just ignore them; this is an issue in Visual Studio.</p></div></div><div class="section" title="What can we see here?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec7"/>What can we see here?</h2></div></div></div><p>Yes, this is XAML. Windows apps are all built using the WPF framework. We create the <code class="literal">Xamarin.Forms</code> element <code class="literal">forms:WindowsPhonePage</code>. Open the <code class="literal">MainPage.xaml.cs</code> in the Windows Phone project and update the constructor:</p><pre class="programlisting">public sealed partial class MainPage &#13;
{ &#13;
    public MainPage() &#13;
    { &#13;
        InitializeComponent(); &#13;
 &#13;
        NavigationCacheMode = NavigationCacheMode.Required; &#13;
        LoadApplication(new SpeechTalk.App()); &#13;
    } &#13;
} &#13;
</pre><p>Project setup is quite simple, but we are not calling<code class="literal"> Forms.Init</code> anywhere. Open up the <code class="literal">App.xaml.cs</code> file in the <span class="strong"><strong>Windows Phone</strong></span> project and look for this block of code:</p><pre class="programlisting">if (rootFrame == null) &#13;
{ &#13;
    // Create a Frame to act as the navigation context and navigate to the first page &#13;
    rootFrame = new Frame(); &#13;
 &#13;
    // TODO: change this value to a cache size that is appropriate for your application &#13;
    rootFrame.CacheSize = 1; &#13;
 &#13;
    Xamarin.Forms.Forms.Init(e); &#13;
 &#13;
    if (e.PreviousExecutionState == ApplicationExecutionState.Terminated) &#13;
    { &#13;
        // TODO: Load state from previously suspended application &#13;
    } &#13;
 &#13;
    // Place the frame in the current Window &#13;
    Window.Current.Content = rootFrame; &#13;
}  &#13;
</pre><p>We must manually add this line:</p><pre class="programlisting">Xamarin.Forms.Forms.Init(e); &#13;
</pre><p>Set the cache size to <code class="literal">1</code>:</p><pre class="programlisting">rootFrame.CacheSize = 1; &#13;
</pre><p>Finally, we now need to reference the <span class="strong"><strong>SpeechTalk</strong></span> PCL project we created in Xamarin Studio earlier:</p><div class="mediaobject"><img src="graphics/B05293_02_08.jpg" alt="What can we see here?"/></div><p>You may run into issues with referencing this project to the targets set by the PCL by default:</p><div class="mediaobject"><img src="graphics/B05293_02_09.jpg" alt="What can we see here?"/></div><p>To fix this issue, open the <span class="strong"><strong>SpeechTalk</strong></span> PCL project and update the target configurations in <span class="strong"><strong>Properties</strong></span>:</p><div class="mediaobject"><img src="graphics/B05293_02_10.jpg" alt="What can we see here?"/></div><p>Click on the <span class="strong"><strong>Change</strong></span> button where it says <span class="strong"><strong>Targets</strong></span> and make sure the preceding checkboxes are selected. That's everything; try building and running the application. We should see a blank page like the Android and iOS projects. Gerat we have now made a cross-platform application for all platforms.</p><p>Now let's get into the fun stuff with IoC.</p></div></div>
<div class="section" title="Inversion of Control (IoC) with Xamarin.Forms"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Inversion of Control (IoC) with Xamarin.Forms</h1></div></div></div><p>The <span class="strong"><strong>Inversion of Control</strong></span> (<span class="strong"><strong>IoC</strong></span>) principle is very a useful technique when writing cross-platform applications.</p><div class="section" title="So why should we use it?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec8"/>So why should we use it?</h2></div></div></div><p>Sharing 100% of the code would be great, but it is not entirely possible; we still require some implementation from platform-specific features (for example different platform services, hardware, cameras). A way to tackle this problem is via an <span class="strong"><strong>IoC container</strong></span>. Using the IoC principle, we use an abstraction for the functionality in our shared code and pass an implementation of the abstraction into our shared code. Our IoC containers handle the instantiation of an object's dependency tree. We can register objects to their inherited interfaces and allow containers to pass registered objects as their abstracted interfaces all the way down the dependency tree (all the way to PCL).</p></div><div class="section" title="So how do we benefit from this?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec9"/>So how do we benefit from this?</h2></div></div></div><p>What if I needed view models to call methods to a native Bluetooth service in a PCL project?</p><p>To put it simply, we can't. Our PCL projects know nothing about Bluetooth services on the native side. We create an interface that sits in the PCL project, create a class that inherits this interface, and define the methods and access all the native features required. We then register this class to the inherited interface through our IoC container, and finally resolve this abstracted interface in our PCL project. When we call functions from this interface down in the PCL, it will be calling the registered class function definitions described on the native side:</p><div class="mediaobject"><img src="graphics/B05293_02_11.jpg" alt="So how do we benefit from this?"/></div><p>Now back to our <code class="literal">SpeechTalk</code> application. Because the PCL project cannot share code from the native side text-to-speech services, we will have to use IoC to access the native-side features from our PCL. Let's start by declaring an interface for our text to speech service, creating a new folder called <code class="literal">Services</code>, and adding a new <code class="literal">ITextToSpeech.cs</code> file for the interface:</p><pre class="programlisting">public interface ITextToSpeech &#13;
    { &#13;
        void Speak (string msg) &#13;
    } &#13;
</pre></div></div>
<div class="section" title="Autofac"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Autofac</h1></div></div></div><p>Before we begin implementing the different native sides to this interface, let's first add in our IoC container to handle the abstraction. There are a few IoC containers that are free online; for this example we are going to use <span class="strong"><strong>Autofac</strong></span>. Let's add the NuGet packages for the PCL, iOS, and Android projects:</p><div class="mediaobject"><img src="graphics/B05293_02_12.jpg" alt="Autofac"/></div><p>Now that we have our IoC container, let's build the iOS implementation. For each platform, we want to create objects called <span class="strong"><strong>Modules</strong></span> for registering abstracted interfaces. Let's add a new folder called IoC to the PCL project and add a new file called <code class="literal">IoC.cs</code>:</p><pre class="programlisting">public static class IoC &#13;
    { &#13;
        public static IContainer Container { get; private set; } &#13;
 &#13;
        private static ContainerBuilder builder; &#13;
 &#13;
        public static void CreateContainer()  &#13;
        { &#13;
            builder = new ContainerBuilder(); &#13;
        } &#13;
 &#13;
        public static void StartContainer() &#13;
        { &#13;
            Container = builder.Build(); &#13;
        } &#13;
 &#13;
        public static void RegisterModule(IModule module) &#13;
        { &#13;
            module.Register (builder); &#13;
        } &#13;
 &#13;
        public static void RegisterModules(IEnumerable&lt;IModule&gt; modules) &#13;
        { &#13;
            foreach (var module in modules)  &#13;
            { &#13;
                module.Register (builder); &#13;
            } &#13;
        } &#13;
 &#13;
        public static T Resolve&lt;T&gt;() &#13;
        { &#13;
            return Container.Resolve&lt;T&gt; (); &#13;
        } &#13;
    } &#13;
</pre><p>Looking at this closer, we use this static class for registering modules, registering types, resolving registered types, creating the container, and building the container.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>The <code class="literal">ContainerBuilder</code> must be built after all types have been registered.</p></div></div><p>We must register and start this container before we initialize the application. Open up your <code class="literal">AppDelegate.cs</code> file and update the <code class="literal">FinishedLaunching</code> function:</p><pre class="programlisting">        public override bool FinishedLaunching (UIApplication app, NSDictionary options) &#13;
        { &#13;
            global::Xamarin.Forms.Forms.Init (); &#13;
 &#13;
            InitIoC (); &#13;
 &#13;
            LoadApplication (new App ()); &#13;
 &#13;
            return base.FinishedLaunching (app, options); &#13;
        } &#13;
 &#13;
        private void InitIoC() &#13;
        { &#13;
            IoC.CreateContainer (); &#13;
            IoC.RegisterModule (new IOSModule()); &#13;
            IoC.RegisterModule (new PCLModule()); &#13;
            IoC.StartContainer (); &#13;
        } &#13;
</pre><p>The <code class="literal">InitIoC</code> function will first create the container, register the modules, and build the IoC container.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Our container must be created before we can start registering, and our container builder must be built before we can start resolving.</p></div></div><p>Each module has register functions that will use the created <code class="literal">ContainerBuilder</code> to register types.</p></div>
<div class="section" title="iOS text-to-speech implementation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>iOS text-to-speech implementation</h1></div></div></div><p>Each module will retrieve the current container used throughout the entire lifetime of your application. Inside the register function is where we register the class implementation of the text to speech interface. This will be done at the very start of the application before we load anything else.</p><p>Let's start first with adding the iOS module. Add a new folder in the iOS project called <span class="strong"><strong>Modules</strong></span>, create a new file called <code class="literal">iOSModule.cs</code>, and paste in the following:</p><pre class="programlisting">     &#13;
    public class IOSModule : IModule &#13;
    { &#13;
        public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;TextToSpeech&gt; ().As&lt;ITextToSpeech&gt; ().SingleInstance (); &#13;
        } &#13;
    } &#13;
</pre><p>The next step is to add the iOS text to speech service. Add a new folder called <code class="literal">Services</code> and add a new file called <code class="literal">TextToSpeech.cs</code>. In this file, we are going to access the iOS <code class="literal">AVSpeechSynthesizer</code>:</p><pre class="programlisting">public class TextToSpeech : ITextToSpeech &#13;
    { &#13;
        public void Speak (string msg) &#13;
        { &#13;
            var speechSynthesizer = new AVSpeechSynthesizer (); &#13;
 &#13;
            var speechUtterance = new AVSpeechUtterance (msg)  &#13;
            { &#13;
                Rate = AVSpeechUtterance.MaximumSpeechRate / 4, &#13;
                Voice = AVSpeechSynthesisVoice.FromLanguage ("en-US"), &#13;
                Volume = 0.5f, &#13;
                PitchMultiplier = 1.0f &#13;
            }; &#13;
 &#13;
            speechSynthesizer.SpeakUtterance (speechUtterance); &#13;
        } &#13;
    } &#13;
</pre><p>Looking closely at this class, we are going to use the speech synthesizer to produce a <code class="literal">SpeechUtterrance</code> object, which contains the text to speak. We also set the language, volume, and speech rate.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p><span class="strong"><strong>Notice how we inherit the interface we are going to register through the IoC container?</strong></span></p><p>As we are coding this class on the native side, we are able to access all native iOS features, so back in the PCL when we call the function <code class="literal">Speak</code> in the interface, the preceding code will execute.</p></div></div><p>Our next step is to implement the view model principles for our pages. Create a new folder called <code class="literal">ViewModels</code> and add two new files, <code class="literal">ViewModelBase.cs</code> and <code class="literal">MainPageViewModel.cs</code>. The <code class="literal">ViewModelBase</code> class will be the base call for all view models for handling property change events with any view model's properties:</p><pre class="programlisting">public abstract class ViewModelBase : INotifyPropertyChanged &#13;
    { &#13;
        #region Public Events &#13;
 &#13;
        public event PropertyChangedEventHandler PropertyChanged; &#13;
 &#13;
        #endregion  &#13;
 &#13;
        #region Methods &#13;
 &#13;
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null) &#13;
        { &#13;
            PropertyChangedEventHandler handler = this.PropertyChanged; &#13;
 &#13;
            if (handler != null) &#13;
            { &#13;
                handler(this, new PropertyChangedEventArgs(propertyName)); &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Let's look a bit closer. The first property defined is <code class="literal">PropertyChanged EventHandler</code>, which will fire on any property data change. Notice the use of the <code class="literal">#</code> define statements; these are useful for breaking up blocks of coding and navigating through your code sheets.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>These are particularly useful when we have big code sheets.</p></div></div><p>The class inherits the <code class="literal">INotifyPropertyChanged</code> interface, meaning we have to define the <code class="literal">OnPropertyChanged</code> function. This function is used to fire the <code class="literal">PropertyChanged </code>event to signal that a property within this class has changed data. Now let's implement the <code class="literal">MainPageViewModel</code>.</p><p>How do we use the <code class="literal">OnPropertyChanged</code> principle with our <code class="literal">MainPageViewModel</code>?</p><p>With each property in the <code class="literal">MainPageViewModel</code>, we have to call the <code class="literal">OnPropertyChanged</code> function to fire the <code class="literal">EventHandler</code>, thus notifying of a data change for a particular property. Let's begin by creating the <code class="literal">MainPageViewModel</code> with its private properties and constructor:</p><pre class="programlisting">public class MainPageViewModel : ViewModelBase &#13;
    { &#13;
        #region Private Properties &#13;
 &#13;
        private readonly ITextToSpeech _textToSpeech; &#13;
 &#13;
        private string _descriptionMessage = "Enter text and press the 'Speak' button to start speaking"; &#13;
 &#13;
        private string _speakEntryPlaceholder = "Text to speak"; &#13;
 &#13;
        private string _speakText = string.Empty; &#13;
 &#13;
        private string _speakTitle = "Speak"; &#13;
 &#13;
        private ICommand _speakCommand; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Constructors &#13;
 &#13;
        public MainPageViewModel (ITextToSpeech textToSpeech)  &#13;
        { &#13;
           _textToSpeech = textToSpeech; &#13;
 &#13;
            _speakCommand = new Command ((c) =&gt; _textToSpeech.Speak (this.SpeakText)); &#13;
        }  &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>This is the first time we are going to access the <code class="literal">Systems.Windows.Input</code> library. <span class="strong"><strong>Commands</strong></span> are used for our <code class="literal">Button</code> object on the <code class="literal">ContentPage</code>; we will set up a binding on the button so whenever a press event occurs, this command will execute, running the action it is assigned in the constructor. Notice how we are passing the <code class="literal">TextToSpeech</code> interface; this is where things will get trickier with the IoC container.</p><p>Now we add the public properties of the view model, which call the <code class="literal">OnPropertyChanged</code> function:</p><pre class="programlisting">#region Public Properties &#13;
 &#13;
        public string DescriptionMessage &#13;
        { &#13;
            get &#13;
            { &#13;
                return _descriptionMessage; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_descriptionMessage)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _descriptionMessage = value; &#13;
                OnPropertyChanged("DescriptionMessage"); &#13;
            } &#13;
        } &#13;
 &#13;
        public string SpeakEntryPlaceholder &#13;
        { &#13;
            get &#13;
            { &#13;
                return _speakEntryPlaceholder; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_speakEntryPlaceholder)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _speakEntryPlaceholder = value; &#13;
                OnPropertyChanged("SpeakEntryPlaceholder"); &#13;
            } &#13;
        } &#13;
 &#13;
        public string SpeakText &#13;
        { &#13;
            get &#13;
            { &#13;
                return _speakText; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_speakText)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _speakText = value; &#13;
                OnPropertyChanged("SpeakText"); &#13;
            } &#13;
        } &#13;
 &#13;
        public string SpeakTitle &#13;
        { &#13;
            get &#13;
            { &#13;
                return _speakTitle; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_speakTitle)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _speakTitle = value; &#13;
                OnPropertyChanged("SpeakTitle"); &#13;
            } &#13;
        } &#13;
 &#13;
        public ICommand SpeakCommand &#13;
        { &#13;
            get &#13;
            { &#13;
                return _speakCommand; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_speakCommand)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _speakCommand = value; &#13;
                OnPropertyChanged("SpeakCommand"); &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>That's it! We have our first view model. Notice the <code class="literal">get</code> and <code class="literal">set</code> methods for each property; they are exactly the same as functions, just with a nicer presentation. Every time we retrieve the data inside a <code class="literal">public</code> property, it will pull the data contained in the <code class="literal">private</code> property, and every time we set the <code class="literal">public</code> property, if the value is different to the current value, we will set the <code class="literal">private</code> variable contained and call the <code class="literal">OnPropertyChanged</code> function to fire the <code class="literal">EventHandler</code> in the base class. When this event fires, it will update whatever view is bound to it.</p></div>
<div class="section" title="Bindings"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Bindings</h1></div></div></div><p>Back in the PCL project, we are going to run through the concept of binding view models to views, displaying view model data, and propagating data changes through the <code class="literal">INotifyPropertyChanged</code> interface.</p><p>Let's begin with our <code class="literal">MainPage.cs</code> and complete the rest of the user interface for this page:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &#13;
&lt;ContentPage   &#13;
      &#13;
    x:Class="SpeechTalk.Pages.MainPage" &#13;
    BackgroundColor="White"&gt; &#13;
 &#13;
    &lt;ContentPage.Content&gt; &#13;
 &#13;
    &lt;Grid x:Name="Grid" RowSpacing="10" Padding="10, 10, 10, 10" VerticalOptions="Center"&gt; &#13;
        &lt;Grid.RowDefinitions&gt; &#13;
            &lt;RowDefinition Height="Auto"/&gt; &#13;
            &lt;RowDefinition Height="Auto"/&gt; &#13;
            &lt;RowDefinition Height="Auto"/&gt; &#13;
        &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
        &lt;Grid.ColumnDefinitions&gt; &#13;
            &lt;ColumnDefinition Width="*"/&gt; &#13;
        &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
        &lt;Label x:Name="DesciptionLabel" Font="Arial, 20" Grid.Row="0" Grid.Column="0"/&gt; &#13;
 &#13;
        &lt;Entry x:Name="SpeakEntry" Grid.Row="1" Grid.Column="0"/&gt; &#13;
 &#13;
        &lt;Button x:Name="SpeakButton" Grid.Row="2" Grid.Column="0"/&gt; &#13;
    &lt;/Grid&gt; &#13;
 &#13;
    &lt;/ContentPage.Content&gt; &#13;
 &#13;
&lt;/ContentPage&gt; &#13;
</pre><p>We now have a <code class="literal">Label</code>, <code class="literal">Entry</code>, and <code class="literal">Button</code>; each has the <code class="literal">x:Name</code>, <code class="literal">Grid.Row</code>, and <code class="literal">Grid.Column</code> properties assigned.</p><p>Notice how we relate the rows and columns to the definitions section previously?</p><p>We have also set, on the bounding Grid, padding values for left, up, right, and down; set the vertical options to <code class="literal">Center</code>; and set a row spacing of <code class="literal">10</code>. The <code class="literal">Padding</code> will place gaps around the entire bounds of the Grid and the <code class="literal">ContentPage</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>Padding works exactly like margins in HTML.</p></div></div><p>The <code class="literal">RowSpacing</code> property will set the gaps between each row; as each element is placed in a new row, they will be stacked vertically with a pixel spacing of <code class="literal">10</code> between each. Since we only have 1 column, this column width will take up the entire width of the <span class="strong"><strong>Grid</strong></span>, so each element will be at the full width of the <code class="literal">Grid</code>.</p><p>Finally, setting the <code class="literal">VerticalOptions</code> of the <code class="literal">Grid</code> to <code class="literal">Center</code> will position all elements to the center of the Grid. Now let's set up the binding between the <code class="literal">MainPage</code> and <code class="literal">MainPageViewModel</code>.</p><p>Create a new file, add it to the modules folder called <code class="literal">PCLModule.cs</code>, and paste in the following:</p><pre class="programlisting">    public class PCLModule : IModule &#13;
    { &#13;
        public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;MainPageViewModel&gt; ().SingleInstance(); &#13;
            builer.RegisterType&lt;MainPage&gt; ().SingleInstance(); &#13;
        } &#13;
    } &#13;
</pre><p>Hold on... why are we registering our pages and view models in the container?</p><p>We don't need to abstract these.</p><p>Registering both views and view models in the container allows us to add our related view models in the constructor; as we only ever need one instance of both the view and view model throughout the entire lifetime of the application, we can set up the <code class="literal">MainPage.xaml.cs</code> file like this:</p><pre class="programlisting">public partial class MainPage : ContentPage &#13;
    { &#13;
        public MainPage () &#13;
        { &#13;
            InitializeComponent (); &#13;
        } &#13;
 &#13;
        public MainPage (MainPageViewModel model) &#13;
        { &#13;
            BindingContext = model; &#13;
            InitializeComponent (); &#13;
        } &#13;
    } &#13;
</pre><p>The instance of the <code class="literal">MainPageViewModel</code> that was created in the container when registered will be pulled out of the <code class="literal">MainPage</code> constructor on creation. This is the same technique used with the instance of the <code class="literal">MainPageViewModel</code>, where we place the <code class="literal">ITextToSpeech</code> abstraction in the constructor; it will pull out the instance registered on the native side, and in turn we can now use this object to start calling the functions that will run the <code class="literal">native-side</code> code.</p><p>Now back to the <code class="literal">MainPage.xaml</code> sheet, let's set up the property bindings; update the label, entry, and button to the following:</p><pre class="programlisting">&lt;Label x:Name="DesciptionLabel" Text="{Binding DescriptionMessage}" Font="Arial, 20" Grid.Row="0" Grid.Column="0"/&gt; &#13;
 &#13;
&lt;Entry x:Name="SpeakEntry" Placeholder="{Binding SpeakEntryPlaceholder}" Text="{Binding SpeakText, Mode=TwoWay}" Grid.Row="1" Grid.Column="0"/&gt; &#13;
 &#13;
&lt;Button x:Name="SpeakButton" Text="{Binding SpeakTitle}" Command="{Binding SpeakCommand}" Grid.Row="2" Grid.Column="0"/&gt;  &#13;
</pre><p>We have set up bindings for the text on the label and entry properties; notice the two-way binding mode set on the entry text property?</p><p>What this means is if we change the data from the user interface (as it is a text box, will we will be changing the data on the UI front) or the view model, both endpoints will receive the data change accordingly. We have also set up a binding with the command on the button; now, whenever we press this button on the page, it will run the action assigned to it in the view model.</p><p>Now that all the coding is done, let's run the application; try typing in text and pressing the <span class="strong"><strong>Speak</strong></span> button and have a listen:</p><div class="mediaobject"><img src="graphics/B05293_02_13.jpg" alt="Bindings"/></div><p>Well done! You have just completed your first iOS <code class="literal">Xamarin.Forms</code> application.</p><p>For some extra exercises, try changing the properties of volume and speech on the <code class="literal">SpeechUtterance</code> object for iOS.</p></div>
<div class="section" title="Android text-to-speech implementation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Android text-to-speech implementation</h1></div></div></div><p>Now let's implement the IoC container and text to speech for Android. Start by creating a folder for the both the Android Modules and Services, add in two files to it, <code class="literal">TextToSpeechDroid.cs</code> and <code class="literal">DroidModule.cs</code>.</p><p>Let's start with the text to speech service; for <code class="literal">TextToSpeechDroid.cs</code>. And add the following:</p><pre class="programlisting">public class TextToSpeechDroid :  Java.Lang.Object, ITextToSpeech, Android.Speech.Tts.TextToSpeech.IOnInitListener  &#13;
    { &#13;
        private Android.Speech.Tts.TextToSpeech _speaker; &#13;
 &#13;
        private string _toSpeak; &#13;
 &#13;
        public void Speak (string msg) &#13;
        { &#13;
            var ctx = Forms.Context; &#13;
            _toSpeak = msg; &#13;
 &#13;
            if (_speaker == null)  &#13;
            { &#13;
                _speaker = new Android.Speech.Tts.TextToSpeech (ctx, this); &#13;
            }  &#13;
            else  &#13;
            { &#13;
                var p = new Dictionary&lt;string,string&gt; (); &#13;
                speaker.Speak (_toSpeak, QueueMode.Flush, p); &#13;
            } &#13;
        } &#13;
 &#13;
        #region TextToSpeech.IOnInitListener implementation &#13;
 &#13;
        public void OnInit (OperationResult status) &#13;
        { &#13;
            if (status.Equals (OperationResult.Success))  &#13;
            { &#13;
                var p = new Dictionary&lt;string,string&gt; (); &#13;
                _speaker.Speak (_toSpeak, QueueMode.Flush, p); &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>This <code class="literal">IOnInitListener</code> interface requires the <code class="literal">OnInit</code> function to be implemented. The <code class="literal">OnInit</code> function is called to signal the completion of the <code class="literal">TextToSpeech </code>engine initialization. We then implement the interface's function <code class="literal">Speak</code> to speak the text passed in. At the start of the function, we check to see that a new <code class="literal">TextToSpeech</code> object has been initialized; if we have then speak the message.</p></div>
<div class="section" title="Setting up IoC with Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Setting up IoC with Android</h1></div></div></div><p>Now for the IoC implementation. It works exactly the same as iOS; let's add the Android module:</p><pre class="programlisting">    public class DroidModule : IModule &#13;
    { &#13;
        public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;TextToSpeechDroid&gt; ().As&lt;ITextToSpeech&gt; ().SingleInstance (); &#13;
        } &#13;
    } &#13;
</pre><p>Easy, right?</p><p>Now we have to set up the IoC container in our <code class="literal">MainActivity.cs</code> class; simply copy the iOS function in the <code class="literal">AppDelegate</code> file called <code class="literal">initIoC</code> and paste this into the <code class="literal">MainActivity</code> class, replace the instantiation of the <code class="literal">iOSModule</code> with your <code class="literal">DroidModule</code>, then simply add the function call after the initialization of <code class="literal">Xamarin.Forms</code>:</p><pre class="programlisting">protected override void OnCreate (Bundle bundle) &#13;
        { &#13;
            base.OnCreate (bundle); &#13;
 &#13;
            global::Xamarin.Forms.Forms.Init (this, bundle); &#13;
 &#13;
            InitIoC (); &#13;
 &#13;
            LoadApplication (new App ()); &#13;
        } &#13;
 &#13;
        private void InitIoC() &#13;
        { &#13;
            IoC.CreateContainer (); &#13;
            IoC.RegisterModule (new DroidModule()); &#13;
            IoC.RegisterModule (new PCLModule()); &#13;
            IoC.StartContainer (); &#13;
        } &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>You may have issues trying to get the speech to work on Android. One thing you may need to set up first is within <span class="strong"><strong>Settings</strong></span> | <span class="strong"><strong>Controls</strong></span> | <span class="strong"><strong>Text-to-Speech</strong></span> options. Here is where you will have to install voice data if the default has not already been installed. If you run the app and no speech occurs, you will have to configure the voice data.</p></div></div><p>That's all for Android, now try running the app and hear some speech.</p></div>
<div class="section" title="WinPhone text-to-speech implementation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>WinPhone text-to-speech implementation</h1></div></div></div><p>Now we go back to Windows Phone for the last implementation. See how tricky it can be when you have to switch between multiple platforms. Imagine if we had to change languages and re-write IoC containers; the amount of work would be much greater. Not only that, there would be no point in using IoC, because we cannot share any code.</p><p>So firstly, don't forget to import the nuget package for <span class="strong"><strong>Autofac</strong></span>:</p><div class="mediaobject"><img src="graphics/B05293_02_14.jpg" alt="WinPhone text-to-speech implementation"/></div><p>Now that we have access to the <span class="strong"><strong>Autofac</strong></span> framework, let's continue implementing the text to speech service. Start with adding a new folder called <span class="strong"><strong>Services</strong></span>, then add the <code class="literal">TextToSpeechWinPhone.cs</code> file and implement it:</p><pre class="programlisting">public class TextToSpeechWinPhone : ITextToSpeech &#13;
        { &#13;
            public async void Speak(string text) &#13;
            { &#13;
                MediaElement mediaElement = new MediaElement (); &#13;
 &#13;
                var synth = new Windows.Media.SpeechSynthesis. SpeechSynthesizer (); &#13;
 &#13;
                SpeechSynthesisStream stream = await synth.SynthesizeTextToStreamAsync(text); &#13;
 &#13;
                mediaElement.SetSource(stream, stream.ContentType); &#13;
                mediaElement.Play(); &#13;
            } &#13;
        } &#13;
</pre><p>Looking at this more closely, you can see the instantiation of <code class="literal">MediaElement</code>; this is used to play an audio source. Our source in this case is <code class="literal">SpeechSynthesisStream</code>; this stream is built via a speech synthesizer. When we call the function <code class="literal">SynthesizeTextToStreamAsync</code>, it will be an audio stream based on the text inserted into this function. We then set the <code class="literal">MediaElement</code> source to the stream and call the <code class="literal">Play</code> function to begin speaking. One addition to configuring Windows Phone is checking the capability in the app manifest file.</p></div>
<div class="section" title="IoC with Windows Phone"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>IoC with Windows Phone</h1></div></div></div><p>Implementing IoC with Windows Phone is very much the same as iOS and Android. We simply add the same function, <code class="literal">InitIoC</code>, at our application's starting point; in this case, it is the <code class="literal">MainPage</code> constructor of the Windows Phone project (try not to get the two confused), and we call it right before the <code class="literal">LoadApplication</code> function:</p><pre class="programlisting">public MainPage() &#13;
    { &#13;
        InitializeComponent(); &#13;
 &#13;
        InitIoC(); &#13;
 &#13;
        NavigationCacheMode = NavigationCacheMode.Required; &#13;
        LoadApplication(new SpeechTalk.App()); &#13;
    } &#13;
 &#13;
    private void InitIoC() &#13;
    { &#13;
        IoC.CreateContainer(); &#13;
        IoC.RegisterModule(new WinPhoneModule ()); &#13;
        IoC.RegisterModule(new PCLModule ()); &#13;
        IoC.StartContainer(); &#13;
    } &#13;
</pre><p>Simple! Now we can run the Windows application.</p></div>
<div class="section" title="Platform independent styling"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Platform independent styling</h1></div></div></div><p>Hold on! What has happened with the <code class="literal">MainPage</code>—no button, no text?</p><p>What is happening here is we have not specified colors for these elements, so the default color of the text has come up as white. Open up <code class="literal">MainPage.xaml</code> and change the text colors accordingly:</p><pre class="programlisting">&lt;Label x:Name="DesciptionLabel" Text="{Binding DescriptionMessage}" TextColor="Black" Font="Arial, 20" Grid.Row="0" Grid.Column="0"/&gt; &#13;
 &#13;
&lt;Button x:Name="SpeakButton" Text="{Binding SpeakTitle}" TextColor="Blue" Command="{Binding SpeakCommand}" Grid.Row="2" Grid.Column="0"/&gt; &#13;
</pre><p>It might be a good idea to color the background of the <code class="literal">Entry</code> object as well, so we can see the text definition:</p><pre class="programlisting">&lt;Entry x:Name="SpeakEntry" Placeholder="{Binding SpeakEntryPlaceholder}" BackgroundColor="Silver" Text="{Binding SpeakText, Mode=TwoWay}" Grid.Row="1" Grid.Column="0"/&gt; &#13;
</pre><p>Now run it again and see the text, button, and entry background display.</p><p>But wait! What if we don't want these colors to change for iOS and Android, or we want to set these colors differently based on the platform?</p><p>Here is another trick to try: in the <code class="literal">MainPage.xaml</code> sheet, we are going to change the background color of the entry based upon whether it is iOS, Android, or Windows Phone:</p><pre class="programlisting">&lt;Entry x:Name="SpeakEntry" Placeholder="{Binding SpeakEntryPlaceholder}" Text="{Binding SpeakText, Mode=TwoWay}" Grid.Row="1" Grid.Column="0"&gt; &#13;
            &lt;Entry.BackgroundColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="White" &#13;
                    WinPhone="Silver" &#13;
                    iOS="White"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Entry.BackgroundColor&gt; &#13;
        &lt;/Entry&gt; &#13;
</pre><p>We start by specifying the property tag we are changing, and then a tag for <code class="literal">OnPlatform</code> in which we specify the argument type, which is <code class="literal">Color</code>. Let's take it a step further and change the text colors for the <code class="literal">Button</code> and <code class="literal">Label</code> as well:</p><pre class="programlisting">&lt;Label x:Name="DesciptionLabel" Text="{Binding DescriptionMessage}" Font="Arial, 20" Grid.Row="0" Grid.Column="0"&gt; &#13;
            &lt;Label.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Black" &#13;
                    WinPhone="Black" &#13;
                    iOS="Black"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Label.TextColor&gt; &#13;
        &lt;/Label&gt; &#13;
 &#13;
        &lt;Button x:Name="SpeakButton" Text="{Binding SpeakTitle}" Command="{Binding SpeakCommand}" Grid.Row="2" Grid.Column="0"&gt; &#13;
            &lt;Button.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Navy" &#13;
                    WinPhone="Blue" &#13;
                    iOS="Navy"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Button.TextColor&gt; &#13;
        &lt;/Button&gt; &#13;
</pre><p>This is a nice little variation between styles for the first page. As you build more complex XAML sheets, you may find some areas where you will have to change pixel items, change color, and perform other styling to give it that extra edge.</p><p>Let's call it a day and end this project here; it's now time to build our GPS locator.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we learned how to create a text to speech service using <code class="literal">Xamarin.Forms</code>. We have learned about native speech service libraries for each platform. In the next chapter, we will learn how to handle background location update events and using latitude and longitude to calculate positions. You will also learn how to implement location services on each platform by using <code class="literal">Xamarin.Forms</code> and <code class="literal">Xamarin.Forms.Maps</code>.</p></div></body></html>