<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Editor Extensions and Immediate Mode GUI (IMGUI)</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Menu items to log messages and clear the console</li>
<li>Displaying a panel with text data</li>
<li>An interactive panel and persistent storage</li>
<li>Creating GameObjects, parenting and registering Undo actions</li>
<li>Working with selected objects and deactivating menu items</li>
<li>Menu item to create 100 randomly positioned prefab clones</li>
<li>A progress bar to display proportion completed of Editor extension processing</li>
<li>An editor extension to allow pickup type (and parameters) to be changed at design time via a custom Inspector UI</li>
<li>An editor extension to have an object-creator GameObject, with buttons to instantiate different pickups at cross-hair object's location in scene</li>
<li>Extensible class-based code architecture to manage complex IMGUIs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>One aspect of game development in general (and inventories as our particular examples in this chapter) is the distinction about when we undertake an activity. <span class="KeyWordPACKT">Runtime</span> is when the game is running (and when all our software and <span class="KeyWordPACKT">UI</span> choices take effect). However, d<span class="KeyWordPACKT">esign-time</span> is the time when different members of our game design team work on constructing a wide range of game components, including the scripts, audio and visual assets, and the process of constructing each game level (or scene in Unity-speak).</p>
<p>Unity's Editor extensions are scripting and multimedia components that enable a game software engineer to make <span class="KeyWordPACKT">design-time</span> work easier and less likely to introduce errors. Editor extensions allow workflow improvements, thus allowing designers to achieve their goals quicker and more easily; for example, removing the need for any scripting knowledge when generating many randomly located inventory pickups in a scene via a menu choice or editing the type or properties of pickups being hand-placed in different locations in a level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Big picture</h1>
                </header>
            
            <article>
                
<p><span>Apart from plain text, there are four sections below will give you an idea of what this chapter is about.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unity Immediate Mode GUI (IMGUI)</h1>
                </header>
            
            <article>
                
<p>In the early versions of Unity, all <strong><span class="KeyWordPACKT">UI</span></strong> components were created through code - there was no <strong><span class="KeyWordPACKT">Canvas</span></strong>, or <span class="KeyWordPACKT"><strong>Rect</strong> Transform</span>, or drag-and-drop <strong><span class="KeyWordPACKT">UI</span></strong> control layout and so on. A few years ago (Unity 4.6), Unity introduced what we now know as the <strong><span class="KeyWordPACKT">UI</span></strong> system. The new (play-mode) <span class="KeyWordPACKT">UI</span> system is an example of a <strong><span class="KeyWordPACKT">Retained Mode</span> <span class="KeyWordPACKT">UI</span></strong>; the <strong><span class="KeyWordPACKT">UI</span></strong> items we created are remembered frame-to-frame and don't need to be re-created/displayed by us as developers. However, the code-based <span class="KeyWordPACKT">GUI</span> system still has an important role to play for Editor Extensions. The <strong><span class="KeyWordPACKT">IMGUI</span></strong> system is called <span class="KeyWordPACKT"><strong>Immediate Mode</strong>,</span> since its code executes one more times each frame. Therefore, there is no need to clear previous GUI displays, since that it automatic.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying and saving changes</h1>
                </header>
            
            <article>
                
<p>The concept of serialization is raised in the Editor extension recipes, whereby we need to remember that, when we are editing item properties in the Inspector, each change needs to be saved to disk, so that the updated property is correct when we next use or edit that item. This is achieved in the <kbd><span class="CodeInTextPACKT">OnInspectorGUI()</span></kbd> method by first calling the <kbd><span class="CodeInTextPACKT">serializedObject.Update()</span></kbd> method and, after all changes have been made in the Inspector, finally calling the <kbd><span class="CodeInTextPACKT">serializedObject.ApplyModifiedProperties()</span></kbd> method.</p>
<p>We can detect when the user has made a change to a GUI control by interrogating Unity's special public bool value: <kbd><span class="CodeInTextPACKT">GUI.changed</span></kbd>. This is set to true if a GUI control has changed input data (for example, if the user has been typing or clicking GUI controls). Here is a simple example of using <kbd><span class="CodeInTextPACKT">GUI.changed</span></kbd> to log a message when the content of a text input field has been updated:</p>
<pre>stringToEdit = GUILayout.TextField(stringToEdit, 25);<br/> <br/> if (GUI.changed)<br/>     Debug.Log("new contents of 'stringToEdit' = " + stringToEdit); </pre>
<p>Unity's <span class="CodeInTextPACKT">EditorGUI</span> class provides <kbd>Begin-End <span class="CodeInTextPACKT">ChangeCheck()</span></kbd> methods that will set <span class="CodeInTextPACKT">GUI.changed</span> to true if the user has changed one or more interactive GUI components in a block of statements delimited by these methods:</p>
<pre>EditorGUI.BeginChangeCheck();<br/> stringToEdit = GUILayout.TextField(stringToEdit, 25);<br/> ... other interactive GUI statements here<br/> EditorGUI.EndChangeCheck();<br/> <br/> // logic if any have changed<br/> if(GUI.changed)<br/>     ... do actions since user has changed at least one GUI control </pre>
<p>If they have, we can save a statement, since <kbd><span class="CodeInTextPACKT">EditorGUI.EndChangeCheck()</span></kbd>, as well as declaring the end of the block of statements for <span class="CodeInTextPACKT">GUI.change. This</span> also returns the <span class="CodeInTextPACKT">bool</span> value of <span class="CodeInTextPACKT">GUI.changed</span>. So, we can actually use this method call in our if-statement instead of <span class="CodeInTextPACKT">GUI.changed</span>. In essence:</p>
<pre>EditorGUI.BeginChangeCheck();<br/> stringToEdit = GUILayout.TextField(stringToEdit, 25);<br/> ... other interactive GUI statements here<br/> <br/> // logic if any have changed<br/> if(EditorGUI.EndChangeCheck())<br/>     ... do actions since user has changed at least one GUI control </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory - EditorPrefs persistent storage</h1>
                </header>
            
            <article>
                
<p class="MsoSalutation">An issue with Immediate Mode systems is that everything is temporary and forgotten. Unity provides <strong><span class="ScreenTextPACKT"><span class="packt_screen">EditorPrefs</span></span>,</strong> similar to <strong><span class="ScreenTextPACKT"><span class="packt_screen">PlayerPrefs</span></span>,</strong> a facility for storing data that is remembered between the closing of a panel and its reopening. Just as with <strong><span class="ScreenTextPACKT"><span class="packt_screen">PlayerPrefs</span>,</span></strong> different <strong>types</strong> of values can be stored and retrieved using <kbd><span class="CodeInTextPACKT">Get&lt;&gt;()</span></kbd> and <kbd><span class="CodeInTextPACKT">Set&lt;&gt;()</span></kbd> methods, including:</p>
<ul>
<li><kbd>SetString(&lt;key&gt;, &lt;value&gt;)</kbd></li>
<li><kbd>GetString(&lt;key&gt;)</kbd></li>
<li>And so on<br/></li>
</ul>
<p>Also provided are methods to delete all stored <span class="ScreenTextPACKT">EditorPrefs</span> data (<kbd><span class="CodeInTextPACKT">DeleteAll()</span></kbd>), to delete just one item for a given key (<kbd><span class="CodeInTextPACKT">DeleteKey(&lt;key&gt;)</span></kbd>), and to check if an item exists for a given key (<kbd><span class="CodeInTextPACKT">HasKey(&lt;key&gt;)</span></kbd>).</p>
<div class="packt_infobox">Of course, <kbd>DeleteAll()</kbd> isn't something to be used without careful consideration. There is an example of <kbd>DeleteAll()</kbd> in the Unity documentation that ensures the game developer is first asked if they are sure they really want to delete all stored values:Â <a href="https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html">https://docs.unity3d.com/ScriptReference/EditorPrefs.DeleteAll.html</a></div>
<p>Typically, values are <strong>loaded</strong> from <span class="packt_screen"><strong><span class="ScreenTextPACKT">EditorPrefs</span></strong></span> using getters (if the <kbd><span class="CodeInTextPACKT">&lt;key&gt;</span></kbd>s exist) each time the panel gets the focus. For example:</p>
<pre>private void OnFocus()  <br/> {<br/>     if (EditorPrefs.HasKey("PlayerName"))<br/>         playerName = EditorPrefs.GetString("PlayerName");<br/> } </pre>
<p>Likewise, when panels lose focus (<kbd><span class="CodeInTextPACKT">OnLostFocus()</span></kbd>) or are closed (<kbd><span class="CodeInTextPACKT">OnDestroy()</span></kbd>) we may wish to automatically save any values to <span class="CodeInTextPACKT">EditorPrefs</span> using setters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conclusions and further resources</h1>
                </header>
            
            <article>
                
<p>While Editor extensions are quite an advanced topic, having someone on your team who can write custom editor components, such as those we illustrate, can greatly increase the productivity of a small team with only one or two members who are confident at scripting.</p>
<p>In this chapter, we introduce recipes demonstrating some Unity Editor extension scripts, illustrating how we can make things easier, less-script based, and less prone to errors, by limiting and controlling the properties of objects and how they are selected or changed via the Inspector.</p>
<p>There is a lot to working with Editor Extensions and the IMGUI. Here is a list of resources to learn more about these topics:</p>
<ul>
<li>Learn more about EditorPrefs in the Unity Documentation:Â <a href="https://docs.unity3d.com/ScriptReference/EditorPrefs.html"><span class="URLPACKT">https://docs.unity3d.com/ScriptReference/EditorPrefs.html</span></a></li>
<li>Unity blog post about IMGUI: <a href="https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/"><span class="URLPACKT">https://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/</span></a></li>
<li>Video about IMGUI by Casey Muratori: <a href="https://caseymuratori.com/blog_0001"><span class="URLPACKT">https://caseymuratori.com/blog_0001</span></a></li>
<li>the Unity Immediate Mode GUI reference pages: <a href="https://docs.unity3d.com/Manual/GUIScriptingGuide.html"><span class="URLPACKT">https://docs.unity3d.com/Manual/GUIScriptingGuide.html</span></a></li>
<li>The Unity GUI event scripting reference page:Â <a href="https://docs.unity3d.com/ScriptReference/Event.html">https://docs.unity3d.com/ScriptReference/Event.html</a></li>
<li>Unity scripting OnGUI reference page: <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnGUI.html</a></li>
<li>Ryan Meier's blog:Â <a href="http://www.ryan-meier.com/blog/?p=72"><span class="URLPACKT">http://www.ryan-meier.com/blog/?p=72</span></a></li>
<li>Tutsplus tutorials and custom scripts (including grids and color pickers):Â <a href="http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047"><span class="URLPACKT">http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047</span></a></li>
<li>Gamasutra getting starting Editor Extensions article:Â <a href="https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php"><span class="URLPACKT">https://www.gamasutra.com/blogs/ElmarTalibzade/20160418/270604/Getting_Started_Creating_Editor_Extensions_in_Unity.php</span></a></li>
</ul>
<ul>
<li>Menu items:Â <a href="https://docs.unity3d.com/ScriptReference/MenuItem.html"><span class="URLPACKT">https://docs.unity3d.com/ScriptReference/MenuItem.html</span></a></li>
<li>EditorGUI.BeingChangeCheck:Â <a href="https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html"><span class="URLPACKT">https://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Menu items to log messages and clear the console</h1>
                </header>
            
            <article>
                
<p>Custom menus are a great way to offer game developers easy access to your Editor Extension features. Logging actions is a good way to display and keep a record of actions performance and object properties that have been changed. In this recipe, we'll create a new menu for the Unity Editor application and a menu item that when selected logs a simple message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/83266c1e-2c0e-4c62-96d0-8d0956aba787.png" style="width:21.00em;height:4.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a menu with a menu item to log messages to console, follow these steps:</p>
<ol>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder, <span class="ScreenTextPACKT">Editor</span>.</li>
<li>In your new <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> folder, create a new C# script-class named <kbd><span class="CodeInTextPACKT">ConsoleUtilities.cs</span></kbd>, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> using System.Reflection;<br/> <br/> public class ConsoleUtilities : EditorWindow<br/> {<br/>     [MenuItem("My Utilities/Clear Console")]<br/>     public static void ClearLogConsole()<br/>     {<br/>         var assembly = Assembly.GetAssembly(typeof(SceneView));<br/>         var type = assembly.GetType("UnityEditor.LogEntries");<br/>         var method = type.GetMethod("Clear");<br/>         method.Invoke(new object(), null);<br/>     }<br/> <br/>     [MenuItem("My Utilities/Log a message")]<br/>     public static void LogHello()<br/>     { <br/>         Debug.Log("Hello from my console utilties");<br/>     }<br/> } </pre>
<ol start="3">
<li>After a few seconds, you should now see a menu named <span class="ScreenTextPACKT"><span class="packt_screen">My Utilities</span></span> appear with two items <span class="ScreenTextPACKT"><span class="packt_screen">Clear Console</span></span> and <span class="ScreenTextPACKT"><span class="packt_screen">Log a message</span></span>.</li>
<li>You should now be able to clear the console and generate Log messages with these menu items.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You created an editor extension script-class in a folder <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> that extends the <kbd><span class="CodeInTextPACKT">EditorWindow</span></kbd> class. You defined two methods; each method was immediately preceded by an attribute to add a menu item to a menu named <span class="ScreenTextPACKT"><span class="packt_screen">My Utilities</span></span>.</p>
<p>The <kbd><span class="CodeInTextPACKT">ClearLogConsole()</span></kbd> method was immediately preceded by an attribute declaring a new menu, My Utilities, and its single menu item <kbd>Clear Console</kbd>:</p>
<pre>    [MenuItem("My Utilities/Clear Console")] </pre>
<p>The <span class="packt_screen"><span class="ScreenTextPACKT">MenuItem</span></span> <strong>attribute</strong> immediately precedes a <strong>static</strong> method, that implements the actions to be executed if the menu item is selected by the user. The menu path is in the form:</p>
<ul>
<li><span class="packt_screen">MenuName/MenuItemName</span> or</li>
<li><span class="ScreenTextPACKT"><span class="packt_screen">MenuName/SubMenuName/MenuItemName</span></span> and so on for submenus</li>
</ul>
<p>The <kbd><span class="CodeInTextPACKT">LogHello()</span></kbd> method creates a new Log message each time it is invoked.</p>
<p>The <kbd><span class="CodeInTextPACKT">ClearLogConsole()</span></kbd> method gets a reference to the Unity logs and clears them.</p>
<p>You can learn more about Editor Extensions for menus in the Unity tutorial on this topic: <a href="https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items"><span class="URLPACKT">https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items</span></a></p>
<div class="packt_infobox">It should be noted that using Reflection is very slow and so generally only used for Editor scripts or scripts that are only executed once and a short delay will not impact upon the user's or game developer's quality of experience.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>There are some details that you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keyboard shortcuts</h1>
                </header>
            
            <article>
                
<p>Special characters in the Menu Item string can be used to specify a keyboard shortcut for the menu item:</p>
<ul>
<li><span class="packt_screen">%</span> indicates the CTRL-key (Windows) or CMD-key (Mac)</li>
<li><span class="packt_screen">#</span> indicate the SHIFT-key</li>
<li><span class="ScreenTextPACKT"><span class="packt_screen">&lt;c&gt;</span></span> then the (lowercase) letter or character shortcut key (e.g. 'k' for the K-key)</li>
</ul>
<p>When keyboard shortcut has been defined, Unity also indicates this to the right of the menu item:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/15001952-a500-46a8-8342-4e63f2308462.png" style="width:22.58em;height:5.00em;"/></p>
<p>So, let's add shortcuts so that <em>CTRL</em>/<em>CMD</em>-<em>L</em> logs a message and <em>CTRL</em>/<em>CMD</em>-<em>K</em> clears the log (keys <em><span class="ScreenTextPACKT">L</span></em> and <em><span class="ScreenTextPACKT">K</span></em> are next to each other on the keyboard):</p>
<pre>[MenuItem("My Utilities/Log a message %l")] // CMD + L<br/> public static void LogHello()<br/> {<br/>     Debug.Log("Hello from my console utilties");<br/> }<br/> <br/> [MenuItem("My Utilities/Clear Console %k")] // CMD + K<br/> public static void ClearLogConsole()<br/> {<br/>     var assembly = Assembly.GetAssembly(typeof(SceneView));<br/>     var type = assembly.GetType("UnityEditor.LogEntries");<br/>     var method = type.GetMethod("Clear");<br/>     method.Invoke(new object(), null);<br/> } </pre>
<p>Learn more about Unity Menu Item Keyboard Shortcuts at <span class="URLPACKT"><kbd>https://docs.unity3d.com/ScriptReference/MenuItem.html</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sub-menus</h1>
                </header>
            
            <article>
                
<p>You can create sub-menus by adding a third text item between forward slashes, in the following form:</p>
<pre>Menu Name/Sub-menu name/menu item </pre>
<p>So, to have a menu <span class="packt_screen"><span class="ScreenTextPACKT">Utilities</span></span> with a sub-menu <span class="packt_screen"><span class="ScreenTextPACKT">Console</span></span> and two items for that submenu, you could write the following:</p>
<pre>[MenuItem("Utilities/Console/Clear Console")]<br/> public static void ClearLogConsole() {<br/>     // code here<br/> }<br/> <br/> [MenuItem("Utilities/Console/Log a message")]<br/> public static void LogHello() {<br/>     // code here<br/> } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying a panel with text data</h1>
                </header>
            
            <article>
                
<p>Sometimes, we want to create and display a new panel as part of an Editor Extension. In this recipe, we create a menu item that creates and displays a new panel, displaying some text information:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c0f137bd-4fe3-40cb-bb0d-6bf2240af0b2.png" style="width:24.08em;height:9.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To display a panel with text data, follow these steps:</p>
<ol>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder, <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span>.</li>
<li>In your new <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> folder, create a new C# script-class named <kbd><span class="CodeInTextPACKT">InformationPanel.cs</span></kbd>, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> <br/> public class InformationPanel : EditorWindow<br/> {<br/>     [MenuItem("My Game/Info Panel")]<br/>     public static void ShowWindow()<br/>     {<br/>         GetWindow&lt;InformationPanel&gt;("My Game", true);<br/>     }<br/> <br/>     private void OnGUI()<br/>     {<br/>         GUILayout.Label("Hello editor world");<br/>         GUILayout.FlexibleSpace();<br/>         GUILayout.Label("Here is some important information");<br/>     }<br/> } </pre>
<ol start="3">
<li>After a few seconds, you should now see a menu named <span class="ScreenTextPACKT"><span class="packt_screen">My Game</span></span> appear, with menu item <span class="ScreenTextPACKT"><span class="packt_screen">Info Panel</span></span>.</li>
<li>Select menu item <span class="ScreenTextPACKT"><span class="packt_screen">Info Panel</span></span> - you should now see a new panel appear, entitled <span class="ScreenTextPACKT"><span class="packt_screen">My Game</span></span> and containing the two text messages.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You preceded the <kbd><span class="CodeInTextPACKT">ShowWindow()</span></kbd> method with an attribute to add a menu item <span class="ScreenTextPACKT">Info Panel</span> to a menu named <span class="ScreenTextPACKT">My Game</span>. The <kbd><span class="CodeInTextPACKT">GetWindow()</span></kbd> statement gets a reference to an InformationPanel object - if no such window-panel exists, it creates one. It searches for a window-panel of type (that is, for this script-class). The first argument is the title of the panel <span class="ScreenTextPACKT">My Game</span>. The true for the second argument tells Unity to make the window-panel have the focus (if a window panel already existed).</p>
<div class="packt_infobox">If a new window panel has been created it will always be given the focus.</div>
<p>The <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method, which executes a least once every frame, uses <kbd><span class="CodeInTextPACKT">GUILayout</span></kbd> to display two text labels. Since <kbd><span class="CodeInTextPACKT">GUILayout</span></kbd> begins adding items at the top-left, the first message Hello editor world appears in the top-left of the panel. Then there is a <kbd><span class="CodeInTextPACKT">FlexibleSpace()</span></kbd> statement. This tells the GUI layout manager to fill up as much (default - vertical) space as it can, while allowing space in the panel for any other content. The third statement displays a second text label. The result is that the second text label is pushed to the bottom of the panel by the <kbd><span class="CodeInTextPACKT">FlexibleSpace()</span></kbd>.</p>
<p>Try resizing the panel; you'll see the second text label is always at the bottom.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>Here are some details that you won't want to miss throughout.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vertical centering</h1>
                </header>
            
            <article>
                
<p>If we wanted to vertically center some text, we can have a <kbd><span class="CodeInTextPACKT">FlexibleSpace()</span></kbd> statement both before and after the content. For example, the following code would vertically center text <kbd>Here is some important information</kbd>:</p>
<pre>GUILayout.Label("Hello editor world");<br/> <br/> GUILayout.FlexibleSpace();<br/> GUILayout.Label("Here is some important information");<br/> GUILayout.FlexibleSpace(); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vertical and horizontal centering (middle of an area)</h1>
                </header>
            
            <article>
                
<p>To center horizontally, we need to change from the default vertical layout by starting (and ending) a horizontal layout, in the following form:</p>
<pre>GUILayout.BeginHorizontal();<br/> // content here is laid out horiztonally<br/> GUILayout.EndHorizontal(); </pre>
<p>By the having <kbd><span class="CodeInTextPACKT">FlexibleSpace()</span></kbd> before and after the content in the horizontal layout, we can center content horizontally as well.</p>
<p>To center both vertically and horizontally, we use <kbd><span class="CodeInTextPACKT">FlexibleSpace()</span></kbd> before and after the horizontal layout, and also before and after the content inside the horizontal layout. For example:</p>
<pre>private void OnGUI() {<br/>     GUILayout.Label("Hello editor world");<br/>     GUILayout.FlexibleSpace();<br/> <br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/> <br/>         GUILayout.Label("I am in the center !!!");<br/> <br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     GUILayout.FlexibleSpace();<br/> } </pre>
<p>This use of flexible spacing is illustrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9a5319f2-cdbc-45f0-b8dd-af703305c03f.png" style="width:30.25em;height:13.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An interactive panel with persistent storage</h1>
                </header>
            
            <article>
                
<p>With Immediate Mode, we have to store the values of interactive controls like buttons and text inputs at the time we display them. Also, we need to decide if, and when, to persistently store values to be remembered when the panel is out of focus or closed.</p>
<p>In this recipe, we display a text label saying hello to the player and using their name if it has been found in the <span class="packt_screen"><span class="ScreenTextPACKT">EditorPrefs</span></span> storage. We also offer a text input and a button and, when the button is clicked, we update the name being greeted:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/510a539f-d625-4cec-a4f9-c8aa242d7a97.png" style="width:22.25em;height:9.08em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To offer an interactive panel with persistent storage, follow these steps:</p>
<ol>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new <span class="packt_screen">Editor</span> folder.</li>
<li>In your new <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> folder, create a new C# script-class named <kbd><span class="CodeInTextPACKT">Welcome.cs</span></kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> <br/> public class Welcome : EditorWindow<br/> {<br/>     private string playerName = "";<br/>     private string tempName = "";<br/> <br/>     [MenuItem("Welcome/Hello Player")]<br/>     public static void ShowWindow()<br/>     {<br/>         GetWindow&lt;Welcome&gt;("Welcome", true);<br/>     }<br/> <br/>     private void OnGUI()<br/>     {<br/>         // hello<br/>         string helloMessage = "Hello (no name)";<br/>         if (playerName.Length &gt; 0){<br/>             helloMessage = "Hello " + playerName;<br/>         }<br/> <br/>         GUILayout.Label(helloMessage);<br/>         GUILayout.FlexibleSpace();<br/> <br/>         // text input<br/>         tempName = EditorGUILayout.TextField("Player name:", tempName);<br/> <br/>         // button<br/>         if (GUILayout.Button("Update")){<br/>             playerName = tempName;<br/>         }<br/>     }<br/> } </pre>
<ol start="3">
<li>After a few seconds, you should now see a menu named <span class="packt_screen"><span class="ScreenTextPACKT">Welcome</span></span> appear with menu item <span class="ScreenTextPACKT"><span class="packt_screen">Hello Player</span></span>.</li>
<li>Select the menu item <span class="ScreenTextPACKT"><span class="packt_screen">Hello Player</span>. Y</span>ou should now see a new panel appear, entitled <span class="ScreenTextPACKT"><span class="packt_screen">Welcome</span></span>, displaying a hello message, a text input box, and a button labeled <span class="ScreenTextPACKT"><span class="packt_screen">Update</span></span>.</li>
<li>Enter your name in the text box and, when you press the button, you should see a message greeting you by name.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You preceded the <kbd><span class="CodeInTextPACKT">ShowWindow()</span></kbd>Â  method with an attribute to add a menu item, <span class="ScreenTextPACKT"><span class="packt_screen">Hello Player</span>,</span> to a menu named <span class="ScreenTextPACKT">Welcome</span>. The <kbd><span class="CodeInTextPACKT">GetWindow()</span></kbd> statement gets a reference to an <kbd><span class="CodeInTextPACKT">EditorWindow</span></kbd> object of type (that is, for this script-class), creating a new one if no existing window-panel of this type can be found.</p>
<p>The <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method, which executes every frame, uses <span class="CodeInTextPACKT">GUILayout</span> to display the following:</p>
<ul>
<li>A text label in the form <span class="ScreenTextPACKT"><span class="packt_screen">Hello</span></span></li>
<li>A text input with the prompt <span class="ScreenTextPACKT"><span class="packt_screen">Player</span> <span class="packt_screen">name</span></span></li>
<li>An <span class="packt_screen"><span class="ScreenTextPACKT">Update</span></span> button</li>
</ul>
<p class="mce-root"/>
<p>There is some <kbd><span class="CodeInTextPACKT">FlexibleSpace()</span></kbd> between the first item (greeting label) and the input box and button, so the input box and button appear at the bottom of the panel.</p>
<p>There are two private string variables:</p>
<ul>
<li><kbd>playerName</kbd></li>
<li><kbd>tempName</kbd></li>
</ul>
<p>The <kbd><span class="CodeInTextPACKT">playerName</span></kbd> variable is used to decide what greeting to display. If the length of this string is greater than zero (in essence, it's not an empty string), then the hello message will be <span class="ScreenTextPACKT">Hello</span>. If <kbd><span class="CodeInTextPACKT">playerName</span></kbd> was empty, then the message will be <span class="ScreenTextPACKT">Hello (no name).</span></p>
<p>The second variable, <kbd>tempName</kbd>, is set to the value in the text box. This has to be re-assigned every frame (in <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd>), since the text box is redisplayed every frame. Each time the user types different text in the text box, the new text is immediately stored in the <kbd>tempName</kbd> variable.</p>
<p>Finally, there is an <kbd>if</kbd> statement that displays the Update button. If, during a frame, the button is clicked by the user, then the <kbd><span class="CodeInTextPACKT">if</span>-</kbd>statement will be executed, which copies the <kbd><span class="CodeInTextPACKT">tempName</span></kbd> from the text box into the <kbd><span class="CodeInTextPACKT">playerName</span></kbd> variable. The very next frame, we'll see the greeting change to reflect the new value inside <kbd><span class="CodeInTextPACKT">playerName</span></kbd>.</p>
<div class="packt_infobox">We have used <kbd><span class="CodeInTextPACKT">EditorGUILayout.TextField(...)</span></kbd> for the text field entry, whereas the other methods are <span class="CodeInTextPACKT">GUILayout</span> methods. <kbd>The <span class="CodeInTextPACKT">EditorGUILayout</span></kbd> methods make interactive controls easier, while the <span class="CodeInTextPACKT">GUILayout</span> methods make layout easier. For window-panels like this you can mix-and-match these GUI methods.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>There are some details that you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Persistent storage with EditorPrefs</h1>
                </header>
            
            <article>
                
<p>At present, if the panel is closed (for example, due to a new panel layout being invoked), then any name that was being shown will be lost. However, we can add some code that uses the <span class="packt_screen"><span class="ScreenTextPACKT">EditorPrefs</span></span> system to store the new name each time the <span class="packt_screen"><span class="ScreenTextPACKT">Update</span></span> button is clicked. Additional code can then check for anÂ <span class="packt_screen"><span class="ScreenTextPACKT">EditorPrefs</span></span> value when the panel is newly displayed and initialize <kbd>playerName</kbd> to the stored value.</p>
<p>First, when the panel is created/gets the focus, let's attempt to read an <span class="packt_screen"><span class="ScreenTextPACKT">EditorPrefs</span></span> item with the key <kbd>"PlayerName"</kbd>. If found, we'll retrieve that string and assign theÂ <kbd>playerName</kbd>Â variable to the stored value:</p>
<pre class="SourceCode">private void OnFocus() {<br/> if (EditorPrefs.HasKey("PlayerName"))<br/> playerName = EditorPrefs.GetString("PlayerName");<br/> }</pre>
<p>Now, let's create a method that will save the value in <kbd><span class="CodeInTextPACKT">playerName</span></kbd> into <span class="packt_screen">EditorPrefs</span>, again using the key <kbd>"PlayerName"</kbd>:</p>
<pre>private void SavePrefs() {<br/>     EditorPrefs.SetString("PlayerName", playerName);<br/> } </pre>
<p>There are two times we may wish to ensure the value is saved, when the panel loses focus and when it is closed (destroyed). So, for both these events, we'll write methods that will invoke our <kbd><span class="CodeInTextPACKT">SavePrefs()</span></kbd> method:</p>
<pre>// automatic save when panel loses focus<br/> private void OnLostFocus() {<br/>     SavePrefs();<br/> }<br/> <br/> // automatic save when panel closed/destroyed<br/> private void OnDestroy() {<br/>     SavePrefs();<br/> } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GUILayout versus EditorGUILayout</h1>
                </header>
            
            <article>
                
<p>You may have noticed there were two different <kbd><span class="CodeInTextPACKT">GUILayout</span></kbd> different method calls in this recipe:</p>
<pre>GUILayout.Label(helloMessage);<br/> GUILayout.FlexibleSpace();<br/> tempName = EditorGUILayout.TextField("Player name:", tempName);</pre>
<p><kbd><span class="CodeInTextPACKT">GUILayout</span></kbd> and <kbd>EditorGUILayout</kbd> both perform very similar roles, in that they provide UI controls with some automated layout - that is, we don't have to specify exact (x,y) values or rectangles for the window-panel size and position of each item. <kbd><span class="CodeInTextPACKT">GUILayout</span></kbd> offers some of the more flexible layout options, like <span class="CodeInTextPACKT"><kbd>FlexibleSpace</kbd> and</span> horizontal and vertical groups, which with <kbd><span class="CodeInTextPACKT">FlexibleSpace</span></kbd> can vertically and horizontally align items. However, <kbd><span class="CodeInTextPACKT">EditorGUILayout</span></kbd> offers easier and more powerful numeric and text input fields, as well as color selection widgets, foldout groups, and so on.</p>
<p>DM Gregory, in a StackExchange post in 2017, lists many of the extra methods available when using <kbd><span class="CodeInTextPACKT">EditorGUILayout</span></kbd>: <a href="https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout"><span class="URLPACKT">https://gamedev.stackexchange.com/questions/139192/difference-between-guilayout-and-editorguilayout</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating GameObjects, parenting, and registering Undo actions</h1>
                </header>
            
            <article>
                
<p>Whether from a menu item, or an <span class="packt_screen"><span class="ScreenTextPACKT">Inspector</span></span> view, there are times when we want to create a new <span class="packt_screen">GameObject</span> in the scene from an Editor Extension. In this recipe, we'll create a new <span class="packt_screen">GameObject</span> and set its position and color randomly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8c5ba467-2b3e-4745-bb68-6d273af200dd.png" style="width:31.50em;height:16.08em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create an object and change its value follow these steps:</p>
<ol>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder, <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span>.</li>
<li>In your new <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> folder create a new C# script-class named <span class="CodeInTextPACKT"><kbd>ObjectManager.cs</kbd></span>, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> <br/> public class ObjectManager : EditorWindow<br/> {<br/>     [MenuItem("GameObject/MyObjectManager/Create New Empty Game Object")]<br/>     static void CreateCustomEmptyGameObject(MenuCommand menuCommand)<br/>     {<br/>         GameObject go = new GameObject("GameObject - custom - Empty");<br/>         go.transform.position = RandomPosition(5);<br/> <br/>         // Ensure it gets reparented if this was a context click (otherwise does nothing)<br/>         GameObjectUtility.SetParentAndAlign(go, menuCommand.context as GameObject);<br/> <br/>         // Register the creation in the undo system<br/>         Undo.RegisterCreatedObjectUndo(go, "Create " + go.name);<br/>         Selection.activeObject = go;<br/>     }<br/> <br/>     private static Vector3 RandomPosition(float limit)<br/>     {<br/>         float x = Random.Range(-limit, limit);<br/>         float y = Random.Range(-limit, limit);<br/>         float z = Random.Range(-limit, limit);<br/>         return new Vector3(x,y,z);<br/>     }<br/> } </pre>
<ol start="3">
<li>After a few seconds, you'll see added to the GameObject menu a new sub-menu named <span class="ScreenTextPACKT"><span class="packt_screen">MyObjectManager</span></span> appear, with menu item <span class="ScreenTextPACKT">Create New Empty Game Object</span>.</li>
</ol>
<ol start="4">
<li>Choose menu: <span class="packt_screen"><span class="ScreenTextPACKT">GameObject | MyObjectManager | Create New Empty Game Object</span></span>.</li>
<li>You should now see a new GameObject named <span class="ScreenTextPACKT"><span class="packt_screen">GameObject - custom - Empty</span></span> created in the Hierarchy panel. If you select this object, it's position (x,y,z) values should be random, in the range -0.5 ... 0.5.</li>
<li>You can Undo this create <span class="packt_screen">GameObject</span> from the <span class="packt_screen">Edit</span> menu (or <em>CTRL/CMD-Z</em>).</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb80dd6d-d551-41d9-ad44-547ba7ba622e.png" style="width:34.33em;height:3.17em;"/></p>
<ol start="7">
<li>With the new empty GameObject selected in the <span class="ScreenTextPACKT">Hierarchy</span>, right-mouse click to get the context menu for this object. Now, choose <span class="packt_screen">menu: <span class="ScreenTextPACKT">Create | MyObjectManager | Create New Empty Game Object</span></span>.</li>
<li>You should now see a second empty GameObject created as a child of the first one;</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/db175896-d0cd-4921-9cc7-11ad781235e8.png" style="width:18.67em;height:9.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You preceded the <kbd><span class="CodeInTextPACKT">CreateCustomEmptyGameObject(...)</span></kbd> method with an attribute to add to existing menu GameObject a sub-menu MyObjectManager with menu item <span class="ScreenTextPACKT"><span class="packt_screen">Create New Empty Game Object</span>.</span></p>
<p>The <kbd><span class="CodeInTextPACKT">CreateCustomEmptyGameObject(...)</span></kbd> method creates a new, empty GameObject with the name <span class="ScreenTextPACKT"><span class="packt_screen">GameObject - custom - Empty</span>.</span> It then sets the position property to a Vector3 random location, returned from method <kbd><span class="CodeInTextPACKT">RandomPosition(...)</span></kbd>.</p>
<p>The <kbd><span class="CodeInTextPACKT">CreateCustomEmptyGameObject(...)</span></kbd> method then uses the <kbd><span class="CodeInTextPACKT">GameObjectUtility.SetParentAndAlign(...)</span></kbd> method to parent the new GameObject to the object selected in the Hierarchy, if the menu was invoked in the contents of a selected GameObject. Otherwise, the new GameObject will have no parent in the Hierarchy.</p>
<p>The <kbd><span class="CodeInTextPACKT">RandomPosition(...)</span></kbd> method takes as input a float parameter &lt;limit&gt;, and generates three values (x,y,z) in the random range from negative to positive &lt;limit&gt;. It then creates and returns a new Vector3 object with these three values.</p>
<p>Because we chose to add our action to the special GameObject menu, our sub-menu item appears in the <span class="ScreenTextPACKT">Hierarchy</span> panel's content Create menu as: <span class="ScreenTextPACKT"><span class="packt_screen">Create | MyObjectManager | Create New Empty Game Object</span></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>There are some details that you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering object changes to allow Undo'ing of actions</h1>
                </header>
            
            <article>
                
<p>When we performance an object creation/deletion/change action in the Unity Editor, we should offer the user the change to Undo the action. Unity makes it very easy for us to facilitate this, through registration of the changed object by providing an Undo class.</p>
<p>We can add to <kbd><span class="CodeInTextPACKT">CreateCustomEmptyGameObject(...)</span></kbd> a call to the <span class="CodeInTextPACKT"><kbd>Undo.RegisterCreatedObjectUndo(...)</kbd> method</span>. This registers the GameObject creation in the Unity system Undo register so that the action can be undone if the uses wishes to do so:</p>
<pre>[MenuItem("GameObject/MyObjectManager/Create New Empty Game Object")]<br/> static void CreateCustomEmptyGameObject(MenuCommand menuCommand)<br/> {<br/>     GameObject go = new GameObject("GameObject - custom - Empty");<br/>     go.transform.position = RandomPosition(5);<br/> <br/>     // Ensure it gets reparented if this was a context click (otherwise does nothing)<br/>     GameObjectUtility.SetParentAndAlign(go, menuCommand.context as GameObject);<br/> <br/>     // Register the creation in the undo system<br/>     Undo.RegisterCreatedObjectUndo(go, "Create " + go.name);<br/>     Selection.activeObject = go;<br/> } </pre>
<p>Learn more about the Undo features in the Unity documentation pages: <a href="https://docs.unity3d.com/ScriptReference/Undo.html" target="_blank">https://docs.unity3d.com/ScriptReference/Undo.html</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating primitive 3D GameObjects with random colors</h1>
                </header>
            
            <article>
                
<p>Rather than creating empty GameObjects, we can create new GameObjects that are 3D primitives like cubes and spheres etc. We can do this using the <kbd><span class="CodeInTextPACKT">GameObject.CreatePrimitive(...)</span></kbd> method. By adding the following three methods, we'll be able to create randomly positioned, randomly colored, random 3D GameObjects from a second menu item in our <span class="packt_screen"><span class="ScreenTextPACKT">MyObjectManager</span></span> sub-menu:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23903447-0d03-4556-a156-be5484f6ee2e.png" style="width:30.83em;height:12.67em;"/></p>
<p>Let's write a method to add a second menu item, which offers to create random GameObjects with 3D primitives:</p>
<pre>[MenuItem("GameObject/MyObjectManager/Create New RandomShape GameObject")]<br/> static void CreateCustomPrimitiveGameObject(MenuCommand menuCommand){<br/>     // Create a custom game object<br/>     GameObject go = BuildGameObjectRandomPrimitive();<br/>     go.transform.position = RandomPosition(5);<br/>     go.GetComponent&lt;Renderer&gt;().sharedMaterial = RandomMaterialColor();<br/> } </pre>
<p>We can choose a random integer from 0..3 to choose between Cube/Sphere/Capsule/Cylinder 3D primitives for our new GameObject:</p>
<pre>private static GameObject BuildGameObjectRandomPrimitive() {<br/>     GameObject go;<br/>     PrimitiveType primitiveType = PrimitiveType.Cube;<br/>     int type = Random.Range(0, 4);<br/> <br/>     switch (type) {<br/>         case 0:<br/>             primitiveType = PrimitiveType.Sphere;<br/>             break;<br/> <br/>         case 1:<br/>             primitiveType = PrimitiveType.Capsule;<br/>             break;<br/> <br/>         case 2:<br/>             primitiveType = PrimitiveType.Cylinder;<br/>             break;<br/>     }<br/> <br/>     go = GameObject.CreatePrimitive(primitiveType);<br/>     go.name = "GameObject - custom - " + primitiveType.ToString();<br/>     return go;<br/> } </pre>
<p>Here is the final method we need to create a new <span class="packt_screen"><span class="ScreenTextPACKT">Material</span></span> with a random color, that can be assigned to the new primitives <span class="packt_screen"><span class="ScreenTextPACKT">sharedMaterial</span></span> property:</p>
<pre>private static Material RandomMaterialColor() {<br/>     Shader shaderSpecular = Shader.Find("Specular");<br/>     Material material = new Material(shaderSpecular);<br/>     material.color = Random.ColorHSV();<br/> <br/>     return material;<br/> } </pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with selected objects and deactivating menu items</h1>
                </header>
            
            <article>
                
<p>Sometimes, we only want to execute some statements if an object is currently selected, related to those actions. In this recipe, we learn how to disable a menu item if nothing is selected. If a GameObject is selected, we'll get a reference to that object and move it back to the origin (0,0,0):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2d2fce19-bada-4533-9dac-a2384ef117f4.png" style="width:35.92em;height:3.17em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To work with selected objects and deactivate menu items follow these steps:</p>
<ol start="1">
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder, <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span>.</li>
<li>In your new <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> folder create a new C# script-class named <kbd><span class="CodeInTextPACKT">SelectedObjectManager.cs</span></kbd>, containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEditor;<br/> using UnityEngine;<br/> <br/> public class SelectedObjectManager : EditorWindow<br/> {<br/>     [MenuItem("MyMenu/Move To Origin")]<br/>     static void ZeroPosition()<br/>     {<br/>         GameObject selectedGameObject = Selection.activeTransform.gameObject;<br/> <br/>         Undo.RecordObject (selectedGameObject.transform, "Zero Transform Position");<br/>         selectedGameObject.transform.position = Vector3.zero;<br/>     }<br/> <br/>     [MenuItem("MyMenu/Move To Origin", true)]<br/>     static bool ValidateZeroPosition()<br/>     {<br/>         // Return false if no transform is selected.<br/>         return Selection.activeTransform != null;<br/>     }<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>After a few seconds, you'll see a new menu <span class="ScreenTextPACKT">MyMenu</span> created, with menu item <span class="ScreenTextPACKT"><span class="packt_screen">Move To Origin</span></span>.</li>
<li>If no GameObject is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Hierarchy</span></span>, then the <span class="ScreenTextPACKT"><span class="packt_screen">Move To Origin</span></span> menu item should be greyed out (inactive).</li>
<li>Create a new, empty GameObject and set its transform position to (5,6,7).</li>
<li>With this new GameObject selected in the Hierarchy, choose <span class="packt_screen">menu: <span class="ScreenTextPACKT">MyMenu | Move To Origin</span></span>. The menu item should be active, and once chosen the position of the GameObject should be zeroed to (0,0,0).</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You preceded the <kbd><span class="CodeInTextPACKT">ZeroPosition()</span></kbd> method with a <span class="ScreenTextPACKT">MenuItem</span> attribute to create a new menu MyMenu with menu item Move To Origin. This method gets a reference to the currently selected GameObject using the <kbd><span class="CodeInTextPACKT">Selection.activeTransform.gameObject</span></kbd> property. The object is registered to the Undo systems property change record, and then its transform position is set to (0,0,0).</p>
<p>There is a second method, <kbd><span class="CodeInTextPACKT">ValidateZeroPosition()</span></kbd>. This method is preceded by a <span class="packt_screen"><span class="ScreenTextPACKT">MenuItem</span></span> attribute with the same <strong>menu path</strong> as method <kbd><span class="CodeInTextPACKT">ZeroPosition()</span></kbd>. The <span class="packt_screen"><span class="ScreenTextPACKT">MenuItem</span></span> attribute is passed true to indicate this is a validation method:</p>
<pre>[MenuItem("MyMenu/MoveToOrigin", true)] </pre>
<p>Validation methods must be static methods, marked with the same <span class="packt_screen"><span class="ScreenTextPACKT">MenuItem</span></span> attribute as the item they are validating, and pass true to the validation argument. The method must return a <span class="CodeInTextPACKT">bool</span> true/false, to indicate whether the condition has been met for the menu item to be active.</p>
<p><kbd><span class="CodeInTextPACKT">ValidateZeroPosition()</span></kbd> returns the bool true/false value of the expression <kbd><span class="CodeInTextPACKT">Selection.activeTransform != null</span></kbd>. In other words, it returns true if there is a selected GameObject, and false if there is not.</p>
<p>Learn more about Editor Extension menu items in the Unity tutorial: <a href="https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items">https://unity3d.com/learn/tutorials/topics/interface-essentials/unity-editor-extensions-menu-items</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Menu item to create 100 randomly positioned prefab clones</h1>
                </header>
            
            <article>
                
<p>Sometimes we want to create <em>lots</em> of pickups, randomly in our scene. Rather than doing this by hand, it is possible to add a custom menu and item to the Unity editor, which, when selected, will execute a script. In this recipe, we create a menu item that calls a script to create 100 randomly positioned star pickup prefabs in the <span class="packt_screen">S<span class="ScreenTextPACKT">cene</span></span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/799bffad-3fcb-4213-acdf-c4c0e3ff159d.png" style="width:27.25em;height:15.17em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you are starting with the project <kbd>Simple2Dgame_SpaceGirl</kbd> setup from the first recipe in <a href="c6ad221f-b476-4471-8259-9ad448749a32.xhtml">Chapter 3</a><em>, Inventory UI</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create an editor extension to add 100 randomly located copies of a prefab with one menu click, follow these steps:</p>
<ol start="1">
<li>Start with a new copy of mini-game <kbd>Simple2Dgame_SpaceGirl</kbd>.</li>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder named <span class="ScreenTextPACKT"><span class="packt_screen">Prefabs</span></span>. Inside this new folder, create a new empty prefab named <kbd><span class="ScreenTextPACKT">prefab_star</span></kbd>. Populate this prefab by dragging GameObject star from the Hierarchy panel over <kbd><span class="ScreenTextPACKT">prefab_star</span></kbd> in the <span class="ScreenTextPACKT">Project</span> panel. The prefab should now turn blue and have a copy of all of GameObject star's properties and components.</li>
</ol>
<ol start="3">
<li>Delete GameObject <span class="ScreenTextPACKT">star</span> from the <span class="ScreenTextPACKT"><span class="packt_screen">Hierarchy</span></span>.</li>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder named <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span>. Inside this new folder, create a new C# script class named <kbd><span class="CodeInTextPACKT">MyGreatGameEditor</span></kbd>, with the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEditor;<br/> <br/> public class MyGreatGameEditor : MonoBehaviour {<br/>     const float X_MAX = 10f;<br/>     const float Y_MAX = 10f;<br/> <br/>     static GameObject starPrefab;<br/> <br/>     [MenuItem("My-Great-Game/Make 100 stars")]<br/>     static void PlacePrefabs() {<br/>         string assetPath = "Assets/Prefabs/prefab_star.prefab";<br/>         starPrefab = (GameObject)AssetDatabase.LoadMainAssetAtPath(assetPath);<br/> <br/>         int total = 100;<br/>         for(int i = 0; i &lt; total; i++){<br/>             CreateRandomInstance();<br/>         }<br/>     }<br/> <br/>     static void CreateRandomInstance() {<br/>         Vector3 randomPosition = RandomPosition();<br/>         Instantiate(starPrefab, randomPosition, Quaternion.identity);<br/>     }<br/> <br/>     private static Vector3 RandomPosition() {<br/>         float x = Random.Range(-X_MAX, X_MAX);<br/>         float y = Random.Range(-Y_MAX, Y_MAX);<br/>         float z = 0;<br/>         return new Vector3(x,y,z);<br/>     }<br/> }</pre>
<ol start="5">
<li>After a few seconds, depending on the speed of your computer, you should see a new menu appear, <span class="ScreenTextPACKT">My Great Game</span>, with a single menu item, <span class="ScreenTextPACKT">Make 100 stars</span>.</li>
<li>Choose this menu item and, as if by magic, you should now see 100 new <kbd><span class="ScreenTextPACKT">prefab_star(Clone)</span></kbd> GameObjects appear in the scene!</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The core aim of this recipe is to add a new menu, containing a single menu item that will execute the action we desire. <kbd>C# attribute <span class="CodeInTextPACKT">[MenuItem("&lt;menuName&gt;/&lt;menuItemName&gt;")]</span></kbd> declares the menu name and the menu item name, and Unity will execute the static method that follows in the code listing, each time the menu item is selected by the user.</p>
<p>In this recipe, the <kbd><span class="CodeInTextPACKT">[MenuItem("My-Great-Game/Make 100 stars")]</span></kbd> statement declares the menu name as <span class="ScreenTextPACKT"><span class="packt_screen">My-Great-Game</span></span> and the menu item as Make 100 stars. The method immediately following this attribute is the <kbd><span class="CodeInTextPACKT">PlacePrefabs()</span></kbd> method. When this method is executed, it makes the <kbd><span class="CodeInTextPACKT">starPrefab</span></kbd> variable become a reference to the prefab found via the <kbd><span class="CodeInTextPACKT">Assets/Prefabs/prefab_star.prefab</span></kbd> path. Then, a For-loop is executed 100 times, each time calling the <kbd><span class="CodeInTextPACKT">CreateRandomInstance()</span></kbd> method.</p>
<p>The <kbd><span class="CodeInTextPACKT">RandomPosition()</span></kbd> method returns a Vector3 variable that is a random position, making use of <kbd><span class="CodeInTextPACKT">X_MAX</span></kbd> and <kbd><span class="CodeInTextPACKT">Y_MAX</span></kbd> constants (z is always zero).</p>
<p>The <kbd><span class="CodeInTextPACKT">CreateRandomInstance()</span></kbd> method get a Vector3 <span class="CodeInTextPACKT">randomPosition</span> by calling the <span class="CodeInTextPACKT"><kbd>RandomPosition()</kbd> method</span>. The <span class="CodeInTextPACKT"><kbd>Instantiate(...</kbd>)</span> built-in method is then used to create a new GameObject in the scene, making a clone of the prefab and locating it at the position defined by <span class="CodeInTextPACKT">randomPosition</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Some details you don't want to miss:</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Childing each new GameObject to a single parent, to avoid filling up the Hierarchy with 100s of new objects</h1>
                </header>
            
            <article>
                
<p>Rather than having hundreds of new object clones fill up our Hierarchy panel, a good way to keep things tidy is to have an empty "parent" GameObject and child a collection of related GameObjects to it. Let's have a GameObject in the Hierarchy named <span class="ScreenTextPACKT"><span class="packt_screen">Star-container</span></span> and child all the new stars to this object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/85e72b55-0d08-4081-be7e-4035aa2043e7.png" style="width:17.08em;height:13.58em;"/></p>
<p>We need a variable that will be a reference to our container object, <span class="CodeInTextPACKT">starContainerGO</span>. We also need a new method, <kbd><span class="CodeInTextPACKT">CreateStarContainerGO()</span></kbd>, which will find a reference to GameObject <span class="ScreenTextPACKT">star-container</span>, if such an object already exists it is deleted, and then the method will create a new empty GameObject and give it this name. Add the following variable and method to our script class:</p>
<pre>static GameObject starContainerGo;<br/> <br/> static void CreateStarContainerGo() {<br/>     string containerName = "Star-container";<br/>     starContainerGo = GameObject.Find(containerName);<br/>     if (null != starContainerGO)<br/>         DestroyImmediate(starContainerGO);<br/> <br/>     starContainerGo = new GameObject(containerName);<br/> } </pre>
<p>Before we create the prefab clones, we need to first ensure we have created our star container GameObject. So, we need to call our new method as the first thing we do when the <kbd><span class="CodeInTextPACKT">PlacePrefabs()</span></kbd> method is executed, so add a statement to call this method at the beginning of the <kbd><span class="CodeInTextPACKT">PlacePrefabs()</span></kbd> method:</p>
<pre>static void PlacePrefabs(){<br/>     CreateStarContainerGo();<br/> <br/>     // rest of method as before ...<br/> } </pre>
<p>Now, we need to modify the <kbd><span class="CodeInTextPACKT">CreateRandomInstance()</span></kbd> method so that it gets a reference to the new GameObject it has just created and can then child this new object to our <span class="ScreenTextPACKT">star-container</span> GameObject variable <span class="CodeInTextPACKT">starContainerGO</span>. Modify the <kbd><span class="CodeInTextPACKT">CreateRandomInstance()</span></kbd> method so that it looks as follows:</p>
<pre>static void CreateRandomInstance() {<br/>     float x = UnityEngine.Random.Range(-X_MAX, X_MAX);<br/>     float y = UnityEngine.Random.Range(-Y_MAX, Y_MAX);<br/>     float z = 0;<br/>     Vector3 randomPosition = new Vector3(x,y,z);<br/> <br/>     GameObject newStarGo = (GameObject)Instantiate(starPrefab, â¨randomPosition, Quaternion.identity);<br/>     newStarGo.transform.parent = starContainerGO.transform;<br/> } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A progress bar to display proportion completed of Editor extension processing</h1>
                </header>
            
            <article>
                
<p>If an <strong><span class="ScreenTextPACKT">Editor</span></strong> task is going to take more than half a second or so, then we should indicate progress complete/remaining to the user via a progress bar so that they understand that something is actually happening and the application has not crashed and frozen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0ca27244-3283-4684-a2bd-5b611289e806.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this recipe with that copy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To add a progress bar during the loop (and then remove it after the loop is complete), replace the <kbd><span class="CodeInTextPACKT">PlacePrefabs()</span></kbd> method with the following code:</p>
<pre>static void PlacePrefabs(){ 

   string assetPath = "Assets/Prefabs/prefab_star.prefab"; 

   starPrefab = (GameObject)AssetDatabase.LoadMainAssetAtPath(assetPath); 

   int total = 100; 

      for(int i = 0; i &lt; total; i++){ 

         CreateRandomInstance(); 

         EditorUtility.DisplayProgressBar("Creating your starfield", â¨i + "%", i/100f); 

      } 

      EditorUtility.ClearProgressBar(); 

   } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As can be seen, inside the for loop, we call the <kbd><span class="CodeInTextPACKT">EditorUtility.DisplayProgressBar(...)</span></kbd> method, passing three parameters. The first is a string title for the progress bar dialog window, the second is a string to show below the bar itself (usually a percentage is sufficient), and the final parameter is a value between 0.0 and 1.0, indicating the percentage complete to be displayed.</p>
<p>Since we have loop variable i that is a number from 1 to 100, we can display this integer followed by a percentage sign for our second parameter and just divide this number by 100 to get the decimal value needed to specify how much of the progress bar should be shown as completed. If the loop were running for some other number, we'd just divide the loop counter by the loop total to get our decimal progress value.</p>
<p>Finally, after the loop has finished, we remove the progress bar with the <span class="CodeInTextPACKT"><kbd>EditorUtility.ClearProgressBar()</kbd> statement</span>. If we don't have this step, the progress bar window-panel will be left floating around - annoying the user!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An editor extension to allow pickup type (and parameters) to be changed at design time via a custom Inspector UI</h1>
                </header>
            
            <article>
                
<p>The use of <strong><span class="ScreenTextPACKT">enums</span></strong> and corresponding drop-down menus in the Inspector panel to restrict changes to one of a limited set often works fine (for example, pickup types for a pickup object). However, the trouble with this approach is, when two or more properties are related and need to be changed together, there is a danger of changing one property, for example, pickup type from <span class="packt_screen"><span class="ScreenTextPACKT">Heart</span></span> to <span class="ScreenTextPACKT"><span class="packt_screen">Key</span></span>, but forgetting to change corresponding properties; for example, leaving the Sprite Renderer component still showing a <span class="packt_screen"><span class="ScreenTextPACKT">Heart</span></span> sprite. Such mismatches cause problems both in terms of messing up intended level design and, of course, the frustration for the player when they collide with something showing one pickup image, but a different kind of pickup type is added to the inventory!</p>
<p>If a class of GameObject has several related properties or components, which all need to be changed together, then a good strategy is to use Unity Editor extensions to do all the associated changes each time a different choice is made from a drop-down menu showing the defined set of enumerated choices.</p>
<p>In this recipe, we introduce an <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> extension for <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> components of GameObjects:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f0b3f7fc-bd92-4c7b-b8c9-a2135307ecc1.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you are starting with the <kbd><span class="ScreenTextPACKT">Simple2Dgame_SpaceGirl</span></kbd> project setup from the first recipe in <em>Chapter 3, Inventory UI</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create an editor extension to allow pickup type (and parameters) to be changed at Design Time via a custom Inspector UI, follow these steps:</p>
<ol>
<li>Start with a new copy of mini-game <kbd><span class="ScreenTextPACKT">Simple2Dgame_SpaceGirl</span></kbd>.</li>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder named <span class="ScreenTextPACKT"><span class="packt_screen">EditorSprites</span></span>. Move the following images from folder <span class="ScreenTextPACKT">Sprites</span> into this new folder: <span class="ScreenTextPACKT"><span class="packt_screen">star</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">healthheart</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">icon_key_green_100</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">icon_key_green_32</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">icon_star_32</span></span>, and <span class="ScreenTextPACKT"><span class="packt_screen">icon_heart_32</span></span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b24734bd-643b-42d2-ba7e-8a8b6a53e77c.png"/></p>
<ol start="3">
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Hierarchy</span></span> panel, rename GameObject star to be named <span class="ScreenTextPACKT"><span class="packt_screen">pickup</span></span>.</li>
<li>Edit the tags, changing tag <span class="packt_screen"><span class="ScreenTextPACKT">Star</span></span> to <span class="ScreenTextPACKT"><span class="packt_screen">Pickup</span></span>. Ensure the pickup GameObject now has the tag <span class="ScreenTextPACKT">Pickup</span>.</li>
<li>Create C# script-class <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> and add an instance-object as a component to GameObject pickup in the Hierarchy:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System;<br/> using System.Collections;<br/> <br/> public class PickUp : MonoBehaviour {<br/>   public enum PickUpType {<br/>     Star, Health, Key<br/>   }<br/> <br/>   [SerializeField]<br/>   public PickUpType type;<br/> <br/>   public void SetSprite(Sprite newSprite){<br/>     SpriteRenderer spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();<br/>     spriteRenderer.sprite = newSprite;<br/>   }<br/> } </pre>
<ol start="6">
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder named <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span>.</li>
<li>Inside this new <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> folder, create a new C# script class named <kbd><span class="CodeInTextPACKT">PickUpEditor</span></kbd>, with the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using System.Collections;<br/> using System;<br/> using UnityEditor;<br/> using System.Collections.Generic;<br/> <br/> [CanEditMultipleObjects]<br/> [CustomEditor(typeof(PickUp))]<br/> public class PickUpEditor : Editor<br/> {<br/>   public Texture iconHealth;<br/>   public Texture iconKey;<br/>   public Texture iconStar;<br/> <br/>   public Sprite spriteHealth100;<br/>   public Sprite spriteKey100;<br/>   public Sprite spriteStar100;<br/> <br/>   UnityEditor.SerializedProperty pickUpType;<br/> <br/>   private Sprite sprite;<br/>   private PickUp pickupObject;<br/> <br/>   void OnEnable () {<br/>     iconHealth = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_heart_32.png", typeof(Texture)) as Texture;<br/>     iconKey = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_key_32.png", typeof(Texture)) as Texture;<br/>     iconStar = â¨AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/â¨icon_star_32.png", typeof(Texture)) as Texture;<br/> <br/>     spriteHealth100 = â¨AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/â¨healthheart.png", typeof(Sprite)) as Sprite;<br/>     spriteKey100 = â¨AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/â¨icon_key_100.png", typeof(Sprite)) as Sprite;<br/>     spriteStar100 = â¨AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/â¨star.png", typeof(Sprite)) as Sprite;<br/> <br/>     pickupObject = (PickUp)target;<br/>     pickUpType = serializedObject.FindProperty ("type");<br/>   }<br/> <br/> <br/>   public override void OnInspectorGUI()<br/>   {<br/>     serializedObject.Update ();<br/> <br/>     string[] pickUpCategories = TypesToStringArray();<br/>     pickUpType.enumValueIndex = â¨EditorGUILayout.Popup("PickUp TYPE: ", â¨pickUpType.enumValueIndex, pickUpCategories);<br/> <br/>     PickUp.PickUpType type = â¨(PickUp.PickUpType)pickUpType.enumValueIndex;<br/>     switch(type)<br/>     {<br/>     case PickUp.PickUpType.Health:<br/>       InspectorGUI_HEALTH();<br/>       break;<br/> <br/>     case PickUp.PickUpType.Key:<br/>       InspectorGUI_KEY();<br/>       break;<br/> <br/>     case PickUp.PickUpType.Star:<br/>     default:<br/>       InspectorGUI_STAR();<br/>       break;<br/>     }<br/> <br/>     serializedObject.ApplyModifiedProperties ();<br/>   }<br/> <br/>   private void InspectorGUI_HEALTH()<br/>   {<br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.Label(iconHealth);<br/>     GUILayout.Label("HEALTH");<br/>     GUILayout.Label(iconHealth);<br/>     GUILayout.Label("HEALTH");<br/>     GUILayout.Label(iconHealth);<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     pickupObject.SetSprite(spriteHealth100);<br/>   }<br/> <br/>   private void InspectorGUI_KEY()<br/>   {<br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.Label("KEY");<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.Label("KEY");<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     pickupObject.SetSprite(spriteKey100);<br/>   }<br/> <br/>   private void InspectorGUI_STAR()<br/>   {<br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.Label(iconStar);<br/>     GUILayout.Label("STAR");<br/>     GUILayout.Label(iconStar);<br/>     GUILayout.Label("STAR");<br/>     GUILayout.Label(iconStar);<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     pickupObject.SetSprite(spriteStar100);<br/>   }<br/>   private string[] TypesToStringArray(){<br/>     var pickupValues = â¨(PickUp.PickUpType[])Enum.GetValues(typeofâ¨(PickUp.PickUpType));<br/> <br/>     List&lt;string&gt; stringList = new List&lt;string&gt;();<br/> <br/>     foreach(PickUp.PickUpType pickupValue in pickupValues){<br/>       string stringName = pickupValue.ToString();<br/>       stringList.Add(stringName);<br/>     }<br/> <br/>     return stringList.ToArray();<br/>   }<br/> } </pre>
<ol start="8">
<li>In the Inspector panel, select GameObject pickup and choose different values of the drop-down menu <span class="ScreenTextPACKT"><span class="packt_screen">PickUp Type</span></span>. You should see corresponding changes in the image and icons in the Inspector for the <span class="ScreenTextPACKT"><span class="packt_screen">Pick Up (Script)</span></span> component (three icons with the name of the type in between). The <span class="packt_screen"><span class="ScreenTextPACKT">Sprite</span></span> property of the <span class="ScreenTextPACKT"><span class="packt_screen">Sprite Renderer</span></span> component for this GameObject should change. Also, in the Scene panel, you'll see the image in the scene change to the appropriate image for the pickup type you have chosen.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/22162569-212f-431a-9c3c-2979c10784a9.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Our script class <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> has the enum <kbd><span class="CodeInTextPACKT">PickUpType</span></kbd> with the three values: <kbd><span class="CodeInTextPACKT">Star</span></kbd>, <kbd><span class="CodeInTextPACKT"><span class="packt_screen">Health</span></span></kbd>, and <kbd><span class="CodeInTextPACKT">Key</span></kbd>. Also, there is the variable <span class="CodeInTextPACKT">type</span>, storing the type of the parent GameObject. Finally, there is a <kbd><span class="CodeInTextPACKT">SetSprite(...)</span></kbd> method that sets the <span class="ScreenTextPACKT"><span class="packt_screen">Sprite Renderer</span></span> component of the parent GameObject to be set to the provided <span class="packt_screen"><span class="ScreenTextPACKT">Sprite</span></span> parameter. It is this method that is called from the editor script each time the pickup type is changed from the drop-down menu (with the corresponding sprite for the new type being passed).</p>
<p>The vast majority of the work for this recipe is the responsibility of the script class <kbd><span class="CodeInTextPACKT">PickUpEditor</span></kbd>. While there is a lot in this script, its work is relatively straightforward: for each frame, via method <kbd><span class="CodeInTextPACKT">OnInspectorGUI()</span></kbd>, a dropdown list of <span class="CodeInTextPACKT">PickUpType</span> values is presented to the user. Based on the value selected from this drop-down list, one of three methods is executed: <kbd><span class="CodeInTextPACKT">InspectorGUI_HEALTH()</span></kbd>, <kbd><span class="CodeInTextPACKT">InspectorGUI_KEY()</span></kbd>, or <kbd><span class="CodeInTextPACKT">InspectorGUI_STAR()</span></kbd>. Each of these methods displays three icons and the name of the type in the Inspector beneath the drop-down menu and ends by calling the <kbd><span class="CodeInTextPACKT">SetSprite(...)</span></kbd> method of the GameObject being edited in the Inspector to update the Sprite Renderer component of the parent GameObject with the appropriate sprite.</p>
<p>The C# attribute <kbd><span class="CodeInTextPACKT">[CustomEditor(typeof(PickUp))]</span></kbd> appearing before our class is declared, tells Unity to use this special editor script to display component properties in the Inspector panel for <span class="ScreenTextPACKT"><span class="packt_screen">Pick</span> <span class="packt_screen">Up</span> <span class="packt_screen">(Script)</span></span> components of GameObjects, rather than Unity's default Inspector which displays public variables of such scripted components.</p>
<p>Before and after its main work, the <kbd><span class="CodeInTextPACKT">OnInspectorGUI()</span></kbd> method first ensures that any variables relating to the object being edited in the Inspector have been updated - <kbd><span class="CodeInTextPACKT">serializedObject.Update()</span></kbd>. The last statement of this method correspondingly ensures that any changes to variables in the editor script have been copied back to the GameObject being edited - <kbd><span class="CodeInTextPACKT">serializedObject.ApplyModifiedProperties()</span></kbd>.</p>
<p>The <kbd><span class="CodeInTextPACKT">OnEnable()</span></kbd> method of script class <span class="CodeInTextPACKT">PickUpEditor</span> loads the three small icons (for display in the Inspector) and the three larger sprite images (to update the Sprite Renderer for display in the Scene/Game panels). The <kbd><span class="CodeInTextPACKT">pickupObject</span></kbd>variable is set to be a reference to the PickUp scripted component, allowing us to call the <kbd><span class="CodeInTextPACKT">SetSprite(...)</span></kbd> method. The <kbd><span class="CodeInTextPACKT">pickUpType</span></kbd> variable is set to be linked to the type variable of the <span class="CodeInTextPACKT">PickUp</span> scripted component whose special Inspector editor view makes this script possible - <kbd><span class="CodeInTextPACKT">serializedObject.FindProperty ("type")</span></kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Here are some details you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Offer the custom editing of pickup parameters via Inspector</h1>
                </header>
            
            <article>
                
<p>Many pickups have additional properties, rather than simply being an item being carried. â¨For example, a health pickup may add health points to the player's character, a coin pickup may add money points to the character's bank balance, and so on. So, let's add an integer points variable to our <span class="CodeInTextPACKT">PickUp</span> class and offer the user the ability to easily edit this points value via a <span class="ScreenTextPACKT"><span class="packt_screen">GUI slider</span></span> in our customer <span class="packt_screen"><span class="ScreenTextPACKT">Inspector</span></span> editor:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/06fa225e-b993-4694-8e80-de8e7188c895.png"/></p>
<p>To add an editable points property to our <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> objects, follow these steps:</p>
<ol>
<li>Add the following extra line into C# script <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> to create our new integer <span class="CodeInTextPACKT">points</span> variable:</li>
</ol>
<pre style="padding-left: 60px">public int points; </pre>
<ol start="2">
<li>Add the following extra line into C# script <kbd><span class="CodeInTextPACKT">PickUpEditor</span></kbd> to work with our new integer points variable:</li>
</ol>
<pre style="padding-left: 60px">UnityEditor.SerializedProperty points; </pre>
<ol start="3">
<li>Add the following extra line into the <kbd><span class="CodeInTextPACKT">OnEnable()</span></kbd> method in C# script <kbd><span class="CodeInTextPACKT">PickUpEditor</span></kbd> to associate our new points variable with its corresponding value in the <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> scripted component of the GameObject being edited:</li>
</ol>
<pre style="padding-left: 60px">csharp void OnEnable () {    

points = serializedObject.FindProperty ("points");    

pickUpType = serializedObject.FindProperty ("type");    

// rest of method as before...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>Now, we can add an extra line into each GUI method for the different <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> types. For example, we can add a statement to display an <kbd><span class="CodeInTextPACKT">IntSlider</span></kbd> to the user to be able to see and modify the points value for a Health PickUp object. We add a new statement at the end of the <kbd><span class="CodeInTextPACKT">InspectorGUI_HEALTH()</span></kbd> method in C# script <kbd><span class="CodeInTextPACKT">PickUpEditor</span></kbd> to display a modifiable <kbd><span class="CodeInTextPACKT">IntSlider</span></kbd> representing our new points variable as follows:</li>
</ol>
<pre style="padding-left: 60px">private void InspectorGUI_HEALTH(){<br/>   // beginning of method just as before...<br/> <br/>   pickupObject.SetSprite(spriteHealth100);<br/> <br/> // now display Int Slider for points<br/>   points.intValue = EditorGUILayout.IntSlider â¨("Health points", points.intValue, 0, 100);<br/> } </pre>
<p>We provide four parameters to the <kbd><span class="CodeInTextPACKT">IntSlider(...)</span></kbd> method. The first is the text label the user will see next to the slider. The second is the initial value the slider displays. The last two are the maximum and minimum values. In our example, we are permitting values from 0 to 100, but if health pickups only offer one, two, or three health points, then we'd just call with <span class="CodeInTextPACKT"><kbd>EditorGUILayout.IntSlider</kbd> <kbd>("Health points, points.intValue, 1, 5")</kbd></span>. This method returns a new integer value based on where the slider has been positioned, and this new value is stored back into the integer value part of our <kbd><span class="CodeInTextPACKT">SerializedProperty</span></kbd> variable <span class="CodeInTextPACKT">points</span>.</p>
<p>Note that the loading and saving of values from the scripted component in the GameObject and our editor script is all part of the work undertaken by our calls to the <kbd><span class="CodeInTextPACKT">Update()</span></kbd> method and the <kbd><span class="CodeInTextPACKT">ApplyModifiedProperties()</span></kbd> method on the serialized object in the <kbd><span class="CodeInTextPACKT">OnInspectorGUI()</span></kbd> method.</p>
<p>Note that, since points may not have any meaning for some pickups, for example, keys, then we simply would not display any slider for the GUI Inspector editor when the user is editing <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> objects of that type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Offer a drop-down list of tags for key-pickup to fit via Inspector</h1>
                </header>
            
            <article>
                
<p>While the concept of points may have no meaning for a key pickup, the concept of the type of lock that a given key fits is certainly something we may wish to implement in a game. Since Unity offers us a defined (and editable) list of string tags for any GameObject, often it is sufficient, and straightforward, to represent the type of lock or door corresponding to a key via its tag. For example, a green key might fit all objects tagged <span class="packt_screen"><span class="ScreenTextPACKT">LockGreen</span></span> and so on:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/311aa5a6-740a-4547-9412-0b2a02812fce.png" style="width:27.92em;height:24.75em;"/></p>
<p>Therefore, it is very useful to be able to offer a custom Inspector editor for a string property of key pickups that stores the tag of the lock(s) the key can open. This task combines several actions, including using C# to retrieve an array of tags from the Unity editor, then the building and offering of a drop-down list of these tags to the user, with the current value already selected in this list.</p>
<p class="mce-root"/>
<p>To add a selectable list of strings for the tag for lock(s) that a key fits, follow these steps:</p>
<ol>
<li>Add the following extra line into C# Script <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> to create our new integer <kbd><span class="CodeInTextPACKT">fitsLockTag</span></kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">public string fitsLockTag; </pre>
<ol start="2">
<li>Add the following extra line into C# script <kbd><span class="CodeInTextPACKT">PickUpEditor</span></kbd> to work with our new integer <kbd><span class="CodeInTextPACKT">fitsLockTag</span></kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">UnityEditor.SerializedProperty fitsLockTag; </pre>
<ol start="3">
<li>Add the following extra line into the <kbd><span class="CodeInTextPACKT">OnEnable()</span></kbd> method in C# script <kbd><span class="CodeInTextPACKT">PickUpEditor</span></kbd> to associate our new <kbd><span class="CodeInTextPACKT">fitsLockTag</span></kbd> variable with its corresponding value in the <kbd><span class="CodeInTextPACKT">PickUp</span></kbd> scripted component of the GameObject being edited:</li>
</ol>
<pre style="padding-left: 60px">csharp void OnEnable () {      

fitsLockTag = â¨serializedObject.FindProperty ("fitsLockTag");     points = serializedObject.FindProperty ("points");      

pickUpType = serializedObject.FindProperty ("type");      

// rest of method as before... </pre>
<ol start="4">
<li>Now, we need to add some extra lines of code into the GUI method for key <span class="CodeInTextPACKT">PickUps</span>. We need to add several statements to the end of method <kbd><span class="CodeInTextPACKT">InspectorGUI_KEY()</span></kbd> in C# script <span class="CodeInTextPACKT">PickUpEditor</span> to set up and display a selectable popup drop-down list representing our new <kbd><span class="CodeInTextPACKT">fitsLockTag</span></kbd> variable as follows. Replace the <kbd><span class="CodeInTextPACKT">InspectorGUI_KEY()</span></kbd> method with the following code:</li>
</ol>
<pre style="padding-left: 60px">private void InspectorGUI_KEY() {<br/>     GUILayout.BeginHorizontal();<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.Label("KEY");<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.Label("KEY");<br/>     GUILayout.Label(iconKey);<br/>     GUILayout.FlexibleSpace();<br/>     GUILayout.EndHorizontal();<br/> <br/>     pickupObject.SetSprite(spriteKey100);<br/> <br/>     string[] tags = â¨UnityEditorInternal.InternalEditorUtility.tags;<br/>     Array.Sort(tags);<br/>     int selectedTagIndex = â¨Array.BinarySearch(tags, fitsLockTag.stringValue);<br/>     if(selectedTagIndex &lt; 0)<br/>         selectedTagIndex = 0;<br/> <br/>     selectedTagIndex = â¨EditorGUILayout.Popup("Tag of door key fits: ", â¨selectedTagIndex, tags);<br/> <br/>     fitsLockTag.stringValue = tags[selectedTagIndex];<br/> } </pre>
<p>We've added several statements to the end of this method. First tags, an array of strings, is created (and sorted), containing the list of tags currently available in the Unity editor for the current game. We then attempt to find the location in this array of the current value of <kbd><span class="CodeInTextPACKT">fitsLockTag</span></kbd> - we can use the <kbd><span class="CodeInTextPACKT">BinarySearch(...)</span></kbd> method of built-in script class Array because we have alphabetically sorted our array (which also makes it easier for the user to navigate). If the string in <kbd><span class="CodeInTextPACKT">fitsLockTag</span></kbd> cannot be found in array tags, then the first item will be selected by default (index 0).</p>
<p>The user is then shown the drop-down list via the <kbd><span class="CodeInTextPACKT">GUILayout</span></kbd> method <kbd><span class="CodeInTextPACKT">EditorGUILayout.Popup(...)</span></kbd> and this method returns the index of whichever item is selected. The selected index is stored into <kbd><span class="CodeInTextPACKT">selectedTagIndex</span></kbd> and the last statement in the method extracts the corresponding string and stores that string into the <kbd><span class="CodeInTextPACKT">fitsLockTag</span></kbd> variable.</p>
<div class="packt_tip">Note: Rather than displaying all possible tags, a further refinement might remove all items from array <span class="CodeInTextPACKT">tags</span> that do not have the prefix <span class="ScreenTextPACKT">Lock</span>. So the user is only presented with tags such as <span class="ScreenTextPACKT">LockBlue</span> and <span class="ScreenTextPACKT">LockGreen</span>, and so on.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logic to open doors with keys based on fitsLockTag</h1>
                </header>
            
            <article>
                
<p>In our player collision logic, we can now search through our inventory to see if any key items fit the lock we have collided with. For example, if a green door was collided with, and the player was carrying a key that could open such doors, then that item should be removed from the inventory <kbd><span class="CodeInTextPACKT">List&lt;&gt;</span></kbd> and the door should be opened.</p>
<p>To implement this, you would need to add an if test inside the <kbd><span class="CodeInTextPACKT">OnTriggerEnter()</span></kbd> method to detected collision with the item tagged <kbd><span class="CodeInTextPACKT">Door</span></kbd>, and then logic to attempt to open the door, and, if unsuccessful, do the appropriate action (for example, play sound) to inform the player they cannot open the door yet (we'll assume we have written a door animation controller that plays the appropriate animation and sounds and when a door is to be opened):</p>
<pre>if("Door" == hitCollider.tag){<br/>     if(!OpenDoor(hitCollider.gameObject))<br/>         DoorNotOpenedAction();<br/> } </pre>
<p>The <kbd><span class="CodeInTextPACKT">OpenDoor()</span></kbd> method would need to identify which item (if any) in the inventory can open such a door, and, if found, then that item should be removed from the <kbd><span class="CodeInTextPACKT">List&lt;&gt;</span></kbd> and the door should be opened by the appropriate method:</p>
<pre>private bool OpenDoor(GameObject doorGO){<br/>     // search for key to open the tag of doorGO<br/>     int colorKeyIndex = FindItemIndex(doorGO.tag);<br/>     if( colorKeyIndex &gt; -1 ){<br/>         // remove key item from inventory List&lt;&gt;<br/>         inventory.RemoveAt( colorKeyIndex );<br/> <br/>         // now open the door...<br/>         DoorAnimationController doorAnimationController = â¨doorGO.GetComponent&lt;&gt;(DoorAnimationController);<br/>         doorAnimationController.OpenDoor();<br/> <br/>         return true;<br/>     }<br/> <br/>     return false;<br/> } </pre>
<p class="mce-root"/>
<p>The following is the code for a method to find the inventory list key item fitting a door tag:</p>
<pre>private int FindItemIndex(string doorTag){<br/>     for (int i = 0; i &lt; inventory.Count; i++){<br/>         PickUp item = inventory[i];<br/>         if( (PickUp.PickUpType.Key == item.type) &amp;&amp; â¨ (item.fitsLockTag == doorTag))<br/>             return i;<br/>     }<br/> <br/>     // not found<br/>     return -1;<br/> } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The need to add [SerializeField] for private properties</h1>
                </header>
            
            <article>
                
<p>Note that, if we wished to create editor extensions to work with private variables, then we'd need to explicitly add <kbd><span class="CodeInTextPACKT">[SerializeField]</span></kbd> in the line immediately before the variable to be changed by the editor script. Public variables are serialized by default in Unity, so this was not required for our public type variable in script class <span class="CodeInTextPACKT">PickUp</span>, although it's good practice to flag ALL variables that are changeable via an Editor Extension in this way.</p>
<p>Learn more from the Unity editor scripts documentation pages: <a href="http://docs.unity3d.com/ScriptReference/Editor.html">http://docs.unity3d.com/ScriptReference/Editor.html</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An editor extension to have an object-creator GameObject, with buttons to instantiate different pickups at cross-hair object location in scene</h1>
                </header>
            
            <article>
                
<p>If a level designer wishes to place each pickup carefully "by hand", we can still make this easier than having to drag copies of prefabs manually from the Projects panel. In this recipe, we provide a "cross-hairs" GameObject, with buttons in the Inspector allowing the game designer to create instances of three different kinds of prefab at precise locations by clicking the appropriate button when the center of the cross-hairs is at the desired location.</p>
<p>A <span class="ScreenTextPACKT"><span class="packt_screen">Unity Editor</span></span> extension is at the heart of this recipe and illustrates how such extensions can allow less technical members of a game development team to take an active role in level creation within the Unity Editor.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23016e79-f90b-4f6d-aea8-0b6a444af84c.png" style="width:30.75em;height:9.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you are starting with the <kbd><span class="ScreenTextPACKT">Simple2Dgame_SpaceGirl</span></kbd> project setup from the first recipe in <a href="c6ad221f-b476-4471-8259-9ad448749a32.xhtml"/><a href="c6ad221f-b476-4471-8259-9ad448749a32.xhtml">Chapter 3</a><em>, Inventory UI</em>.</p>
<p>For this recipe, we have prepared the cross-hairs image you need in a folder named <span class="packt_screen"><span class="ScreenTextPACKT">Sprites</span></span> in the <kbd>18_09</kbd>Â folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create an object-creator GameObject, follow these steps:</p>
<ol>
<li>Start with a new copy of mini-game <kbd><span class="ScreenTextPACKT">Simple2Dgame_SpaceGirl</span></kbd>.</li>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, rename GameObject star as <span class="ScreenTextPACKT"><span class="packt_screen">pickup</span></span>.</li>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder named <span class="ScreenTextPACKT"><span class="packt_screen">Prefabs</span></span>. Inside this new folder, create three new empty prefabs named <span class="ScreenTextPACKT"><span class="packt_screen">star</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">heart</span></span>, and <span class="ScreenTextPACKT"><span class="packt_screen">key</span></span>.</li>
<li>Populate the star prefab by dragging GameObject <span class="packt_screen"><span class="ScreenTextPACKT">pickup</span></span> from the <span class="packt_screen"><span class="ScreenTextPACKT">Hierarchy</span></span> panel over star in the <span class="packt_screen">Pro<span class="ScreenTextPACKT">j</span>ect</span> panel. The prefab should now turn blue and have a copy of all of the star GameObject's properties and components.</li>
<li>Add a new tag <span class="packt_screen"><span class="ScreenTextPACKT">Heart</span></span> in the <span class="ScreenTextPACKT"><span class="packt_screen">Inspector</span></span>. Select GameObject <span class="packt_screen"><span class="ScreenTextPACKT">pickup</span></span> in the <span class="packt_screen"><span class="ScreenTextPACKT">Hierarchy</span></span> panel and assign it the tag <span class="ScreenTextPACKT"><span class="packt_screen">Heart</span></span>. Also, drag from the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel (folder <span class="ScreenTextPACKT">Sprites</span>) the <span class="packt_screen"><span class="ScreenTextPACKT">healthheart</span></span> image into the <span class="packt_screen"><span class="ScreenTextPACKT">Sprite</span></span> property of GameObject <span class="packt_screen"><span class="ScreenTextPACKT">pickup</span></span> so that the player sees the heart image on screen for this pickup item.</li>
</ol>
<ol>
<li>Populate the <span class="ScreenTextPACKT">heart</span> prefab by dragging GameObject pickup from the <span class="packt_screen"><span class="ScreenTextPACKT">Hierarchy</span></span> panel over heart in the <span class="packt_screen"><span class="ScreenTextPACKT">Prefabs</span></span> folder in the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel. The prefab should now turn blue and have a copy of all of the <span class="ScreenTextPACKT">pickup</span> GameObject's properties and components.</li>
<li>Add a new tag <span class="packt_screen"><span class="ScreenTextPACKT">Key</span></span> in the <span class="ScreenTextPACKT"><span class="packt_screen">Inspector</span></span>. Select GameObject's pickup in the <span class="ScreenTextPACKT">Hierarchy</span> panel and assign it this tag <span class="ScreenTextPACKT"><span class="packt_screen">Key</span></span>. Also, drag from the <span class="ScreenTextPACKT">Project</span> panel (folder <span class="ScreenTextPACKT">Sprites</span>) image <span class="packt_screen"><span class="ScreenTextPACKT">icon_key_green_100</span></span> into the <span class="ScreenTextPACKT">Sprite</span> property of GameObject's pickup so that the player sees the key image on screen for this pickup item.</li>
<li>Populate the <span class="ScreenTextPACKT">key</span> prefab by dragging GameObject pickup from the <span class="packt_screen"><span class="ScreenTextPACKT">Hierarchy</span></span> panel over <span class="ScreenTextPACKT">key</span> in the <span class="packt_screen"><span class="ScreenTextPACKT">Prefabs</span></span> folder in the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel. The prefab should now turn blue and have a copy of all of the pickup GameObject's properties and components.</li>
<li>Delete GameObject <span class="packt_screen"><span class="ScreenTextPACKT">pickup</span></span> from the Hierarchy.</li>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a new folder named <span class="ScreenTextPACKT">Editor</span>. Inside this new folder, create a new C# script class named <kbd><span class="CodeInTextPACKT">ObjectBuilderEditor</span></kbd>, with the following code:</li>
</ol>
<pre style="padding-left: 60px"><span>using </span>UnityEngine<span>;<br/></span><span>using </span>UnityEditor<span>;<br/></span><span><br/></span>[CustomEditor(<span>typeof</span>(ObjectBuilderScript))]<br/><span>public class </span>ObjectBuilderEditor : Editor{<br/>   <span>private </span>Texture <span>iconStar</span><span>;<br/></span><span>   </span><span>private </span>Texture <span>iconHeart</span><span>;<br/></span><span>   </span><span>private </span>Texture <span>iconKey</span><span>;<br/></span><span>   <br/></span><span>   </span><span>private </span>GameObject <span>prefabHeart</span><span>;<br/></span><span>   </span><span>private </span>GameObject <span>prefabStar</span><span>;<br/></span><span>   </span><span>private </span>GameObject <span>prefabKey</span><span>;<br/></span><span>   <br/></span><span>   </span><span>void </span><span>OnEnable </span>() {<br/>      iconStar = AssetDatabase.LoadAssetAtPath(<span>"Assets/EditorSprites/icon_star_32.png"</span><span>, </span><span>typeof</span>(Texture)) <span>as </span>Texture<span>;<br/></span><span>      </span>iconHeart = AssetDatabase.LoadAssetAtPath(<span>"Assets/EditorSprites/icon_heart_32.png"</span><span>, </span><span>typeof</span>(Texture)) <span>as </span>Texture<span>;<br/></span><span>      </span>iconKey = AssetDatabase.LoadAssetAtPath(<span>"Assets/EditorSprites/icon_key_green_32.png"</span><span>, </span><span>typeof</span>(Texture)) <span>as </span>Texture<span>;<br/></span><span>      <br/></span><span>      </span>prefabStar = AssetDatabase.LoadAssetAtPath(<span>"Assets/Prefabs/star.prefab"</span><span>, </span><span>typeof</span>(GameObject)) <span>as </span>GameObject<span>;<br/></span><span>      </span>prefabHeart = AssetDatabase.LoadAssetAtPath(<span>"Assets/Prefabs/heart.prefab"</span><span>, </span><span>typeof</span>(GameObject)) <span>as </span>GameObject<span>;<br/></span><span>      </span>prefabKey = AssetDatabase.LoadAssetAtPath(<span>"Assets/Prefabs/key.prefab"</span><span>, </span><span>typeof</span>(GameObject)) <span>as </span>GameObject<span>;<br/></span><span>   </span>}<br/>   <br/>   <span>public override void </span><span>OnInspectorGUI</span>() {<br/>      GUILayout.Label(<span>""</span>)<span>;<br/></span><span>      </span>GUILayout.BeginHorizontal()<span>;<br/></span><span>      </span>GUILayout.FlexibleSpace()<span>;<br/></span><span>      </span>GUILayout.Label(<span>"Click button to create instance of prefab"</span>)<span>;<br/></span><span>      </span>GUILayout.FlexibleSpace()<span>;<br/></span><span>      </span>GUILayout.EndHorizontal()<span>;<br/></span><span>      </span>GUILayout.Label(<span>""</span>)<span>;<br/></span><span>      <br/></span><span>      </span>GUILayout.BeginHorizontal()<span>;<br/></span><span>      </span>GUILayout.FlexibleSpace()<span>;<br/></span><span>      </span><span>if</span>(GUILayout.Button(iconStar)) AddObjectToScene(prefabStar)<span>;<br/></span><span>      </span>GUILayout.FlexibleSpace()<span>;<br/></span><span>      </span><span>if</span>(GUILayout.Button(iconHeart)) AddObjectToScene(prefabHeart)<span>;<br/></span><span>      </span>GUILayout.FlexibleSpace()<span>;<br/></span><span>      </span><span>if</span>(GUILayout.Button(iconKey)) AddObjectToScene(prefabKey)<span>;<br/></span><span>      </span>GUILayout.FlexibleSpace()<span>;<br/></span><span>      </span>GUILayout.EndHorizontal()<span>;<br/></span><span>   </span>}<br/>   <br/>   <span>private void </span><span>AddObjectToScene</span>(GameObject prefabToCreateInScene) {<br/>      ObjectBuilderScript myScript = (ObjectBuilderScript)target<span>;<br/></span><span>      </span>GameObject newGo = Instantiate(prefabToCreateInScene<span>, </span>myScript.gameObject.transform.position<span>, </span>Quaternion.identity)<span>;<br/></span><span>      </span>newGo.name = prefabToCreateInScene.name<span>;<br/></span><span>   </span>}<br/>}</pre>
<ol start="11">
<li>Our <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> script is expecting to find the three icons in a folder named <span class="ScreenTextPACKT"><span class="packt_screen">EditorSprites</span></span>, so let's do this. First, create a new folder named <span class="ScreenTextPACKT"><span class="packt_screen">EditorSprites</span></span>. Next, drag the three 32 x 32 pixel icons from the Sprit<span class="ScreenTextPACKT">e</span>s folder into this new <span class="packt_screen"><span class="ScreenTextPACKT">EditorSprites</span></span> folder. Our <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> script should now be able to load these icons for image-based buttons that it will be drawing in the <span class="ScreenTextPACKT"><span class="packt_screen">Inspector</span></span>, from which the user chooses which pickup prefab object to clone into the scene.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/af577152-388f-4dca-ab3c-8162c0884ff7.png"/></p>
<ol start="12">
<li>From the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, drag <kbd>sprite <span class="ScreenTextPACKT">cross_hairs.fw</span></kbd> into the Scene. Rename this GameObject <span class="ScreenTextPACKT"><span class="packt_screen">object-creator-cross-hairs</span></span>, and in its <span class="ScreenTextPACKT"><span class="packt_screen">Sprite Renderer</span></span> component in the Inspector, set <span class="packt_screen"><span class="ScreenTextPACKT">Sorting Layer</span></span> to <span class="ScreenTextPACKT"><span class="packt_screen">Foreground</span></span>.</li>
<li>Attach the following C# script to GameObject <span class="ScreenTextPACKT"><span class="packt_screen">object-creator-cross-hairs</span></span>:</li>
</ol>
<pre>    using UnityEngine;<br/> <br/>     public class ObjectBuilderScript : MonoBehaviour {<br/>       void Awake(){<br/>         gameObject.SetActive(false);<br/>       }<br/>     } </pre>
<ol start="14">
<li>Select the <span class="ScreenTextPACKT"><span class="packt_screen">Rect Tool</span></span> (shortcut key T), and as you drag gameObject <span class="packt_screen"><span class="ScreenTextPACKT">object-creator-cross-hairs</span></span> and click on the desired icon in the <span class="ScreenTextPACKT"><span class="packt_screen">Inspector</span></span>, new <span class="packt_screen"><span class="ScreenTextPACKT">pickup</span></span> GameObjects will be added to the scene's Hierarchy.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The script class <kbd><span class="CodeInTextPACKT">ObjectBuilderScript</span></kbd> has just two methods, one of which has just one statement - the <kbd><span class="CodeInTextPACKT">Awake()</span></kbd> method simply makes this GameObject become inactive when the game is running (since we don't want the user to see our cross-hairs created tool during gameplay). The <kbd><span class="CodeInTextPACKT">AddObjectToScene(...)</span></kbd> method receives a reference to a prefab as a parameter and instantiates a new clone of the prefab in the scene at the location of GameObject object-creator-cross-hairs at that point in time.</p>
<p>Script class <kbd><span class="CodeInTextPACKT">ObjectBuilderEditor</span></kbd> has a C# attribute <kbd><span class="CodeInTextPACKT">[CustomEditor(typeof(ObjectBuilderScript))]</span></kbd> immediately before the class is declared, telling Unity to use this class to control how <kbd>ObjectBuilderScript</kbd> GameObject properties and components are shown to the user in the <span class="ScreenTextPACKT">Inspector</span>.</p>
<p>There are six variables, three textures for the icons to form the buttons in the <span class="ScreenTextPACKT">Inspector</span>, and three GameObject references to the prefabs of which instances will be created. The <kbd><span class="CodeInTextPACKT">OnEnable()</span></kbd> method assigns values to these six variables using the built-in method <kbd><span class="CodeInTextPACKT">AssetDatabase.LoadAssetAtPath()</span></kbd>, retrieving the icons from the <span class="ScreenTextPACKT">Project</span> folder <span class="ScreenTextPACKT">EditorSprites</span> and getting references to the prefabs in the <span class="ScreenTextPACKT">Project</span> folder <span class="ScreenTextPACKT">Prefabs</span>.</p>
<p>The <kbd><span class="CodeInTextPACKT">OnInspectorGUI()</span></kbd> method has a variable <span class="CodeInTextPACKT">myScript</span>, which is set to be a reference to the instance of scripted component <kbd><span class="CodeInTextPACKT">ObjectBuilderScript</span></kbd> in GameObject <span class="packt_screen">object-creator-cross-hairs</span> (so we can call its method when a prefab has been chosen). The method then displays a mixture of empty text <kbd><span class="CodeInTextPACKT">Labels</span></kbd> (to get some vertical spacing) and <kbd><span class="CodeInTextPACKT">FlexibleSpace</span></kbd> (to get some horizontal spacing and centering) and displays three buttons to the user, with icons of star, heart, and key. The scripted GUI technique for Unity custom <span class="packt_screen"><span class="ScreenTextPACKT">Inspector</span></span> GUIs wraps an <kbd>if</kbd> statement around each button, and on the frame the user clicks the button, the statement block of the if statement will be executed. When any of the three buttons is clicked, a call is made to <kbd><span class="CodeInTextPACKT">AddObjectToScene(...)</span></kbd> of the scripted component <kbd>ObjectBuilderScript</kbd>, passing the prefab corresponding to the button that was clicked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extensible class-based code architecture to manage complex IMGUIs</h1>
                </header>
            
            <article>
                
<p>For complex objects and editor interactions, you may find the number of GUI statements gets high, and code can quickly get hard to manage with very long <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> methods. One approach to organise complex GUIs involves a list of items, and each item being an object-instance of a wrapper-class for a GUI control object. Each wrapper class will implement its own <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method.</p>
<p>In this recipe, we'll use this approach to create a complex GUI with well-organised code. This recipe is adapted from an example posted by <span class="packt_screen"><span class="ScreenTextPACKT">Statement</span></span> on answers.unity.com in 2013 to a question about the different IMGUI libraries: <a href="https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html">https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html</a></p>
<p>We'll create IMGUI static labels, interactive text boxes and a button, and illustrate some flexible space and centering using <kbd><span class="CodeInTextPACKT">BeginHorizontal()</span></kbd> and <kbd><span class="CodeInTextPACKT">EndHorizontal()</span></kbd>, where the fiddly GUILayout statements are put into their own classes.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e71780bc-4b94-4685-99ac-9010da763561.png" style="width:30.75em;height:16.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create an extensible class-based code architecture to manage complex IMGUIs, follow these steps:</p>
<ol>
<li>First let's create an <strong>interface</strong>, that is, a template script-class that defines a method all implementing-classes must have. Create a folder <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span>. Inside that create a folder <span class="ScreenTextPACKT"><span class="packt_screen">MyGUI</span></span>. Inside that create a new C# script-class named <kbd><span class="CodeInTextPACKT">IMyGUI</span></kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">public interface IMyGUI<br/> {<br/>     void OnGUI();<br/> } </pre>
<ol start="2">
<li>Now, let's define a <span class="packt_screen"><span class="ScreenTextPACKT">FlexibleSpace</span></span> class for our GUI library. Create a C# script class named <kbd><span class="CodeInTextPACKT">MyGUIFlexibleSpace</span></kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> <br/> public class MyGUIFlexibleSpace : IMyGUI<br/> {<br/>     public void OnGUI()<br/>     {<br/>         GUILayout.FlexibleSpace();<br/>     }<br/> }</pre>
<ol start="3">
<li>Now, we'll create a button class. Create a C# script class named <kbd><span class="CodeInTextPACKT">MyGUIButton</span></kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> <br/> public class MyGUIButton : IMyGUI<br/> {<br/>     public GUIContent label = new GUIContent();<br/>     public event System.Action OnClick;<br/> <br/>     public void OnGUI() {<br/>         // if button clicked, invoke methods registed with 'OnClick' event<br/>         if (GUILayout.Button (label) &amp;&amp; OnClick != null)<br/>             OnClick ();<br/>     }<br/> } </pre>
<ol start="4">
<li>Now, we'll create an input Text Field class. Create a C# script class named <kbd><span class="CodeInTextPACKT">MyGUITextField</span></kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEditor;<br/> <br/> public class MyGUITextField : IMyGUI<br/> {<br/>     public string text = "";<br/>     public GUIContent label = new GUIContent();<br/> <br/>     public void OnGUI() {<br/>         text = EditorGUILayout.TextField (label, text);<br/>     }<br/> } </pre>
<ol start="5">
<li>Now, we'll create a non-interactive text label class. Create a C# script class named <kbd><span class="CodeInTextPACKT">MyGUILabel</span></kbd> containing the following:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> <br/> public class MyGUILabel : IMyGUI {<br/>     private string text;<br/>     private bool centerFully;<br/> <br/>     public MyGUILabel(string text, bool centerFully = false) {<br/>         this.text = text;<br/>         this.centerFully = centerFully;<br/>     }<br/> <br/>     public void OnGUI() {<br/>         if (centerFully) {<br/>             GUILayout.BeginVertical();<br/>             GUILayout.FlexibleSpace();<br/>             GUILayout.BeginHorizontal();<br/>             GUILayout.FlexibleSpace();<br/>         }<br/> <br/>         GUILayout.Label(text);<br/>         if (centerFully) {<br/>             GUILayout.FlexibleSpace();<br/>             GUILayout.EndHorizontal();<br/>             GUILayout.FlexibleSpace();<br/>             GUILayout.EndVertical();<br/>         }<br/>     }<br/> } </pre>
<ol start="6">
<li>In <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span> folder,</span> we'll now create a class to display an interactive custom panel, making use of our <kbd><span class="ScreenTextPACKT">MyGUI</span></kbd> classes above. Create <kbd>C# script-class <span class="CodeInTextPACKT">MyEditorWindow</span></kbd> containing the following to start with:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/> using UnityEditor;<br/> using System.Collections.Generic;<br/> <br/> // adapted from answers.unity.com sample code posted by 'Statememt' (Dec 2013)<br/> // https://answers.unity.com/questions/601131/editorgui-editorguilayout-gui-guilayout-pshhh-when.html<br/> public class MyEditorWindow : EditorWindow<br/>  {<br/>      MyGUITextField username;<br/>      MyGUITextField realname;<br/>      MyGUIButton registerButton;<br/>      MyGUIFlexibleSpace flexibleSpace;<br/> <br/>      // Optional, but may be convenient.<br/>      List&lt;IMyGUI&gt; gui = new List&lt;IMyGUI&gt;();<br/> <br/>      [MenuItem("Example/Show Window")]<br/>      public static void ShowWindow () {<br/>          GetWindow&lt;MyEditorWindow&gt;("My Reg Panel", true);<br/>      }<br/> }</pre>
<ol start="7">
<li>We'll now add the method to display a menu item to open our window-panel. Add the following to <kbd>C# script-class <span class="CodeInTextPACKT">MyEditorWindow</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">[MenuItem("Example/Show Window")]<br/> public static void ShowWindow () {<br/>  GetWindow&lt;MyEditorWindow&gt;("My Reg Panel", true);<br/> } </pre>
<ol start="8">
<li>We'll now add a method to setup our <kbd><span class="ScreenTextPACKT">MyGUI</span></kbd> objects and add them to our GUI list of objects. Add the following to C# script-class<kbd>Â <span class="CodeInTextPACKT">MyEditorWindow</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    void OnEnable()<br/>     {<br/>         username = new MyGUITextField ();<br/>         username.label.text = "Username";<br/>         username.text = "JDoe";<br/> <br/>         realname = new MyGUITextField ();<br/>         realname.label.text = "Real name";<br/>         realname.text = "John Doe";<br/> <br/>         registerButton = new MyGUIButton ();<br/>         registerButton.label.text = "Register";<br/>          // add RegisterUser() to button's OnClick event broadcaster<br/>         registerButton.OnClick += LogUser;<br/> <br/>         bool centerFully = true;<br/>         gui.Add(new MyGUILabel("Unity 2018 is great", centerFully));<br/> <br/>         gui.Add (username);<br/>         gui.Add (realname);<br/>         gui.Add(new MyGUIFlexibleSpace());<br/>         gui.Add (registerButton);<br/>     } </pre>
<ol start="9">
<li>We'll now add a method loop through and display all our GUI objects each frame. Add the following to C# script-class <kbd><span class="CodeInTextPACKT">MyEditorWindow</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    void OnGUI() {<br/>      foreach (var item in gui)<br/>          item.OnGUI();<br/>     }</pre>
<p class="mce-root"/>
<ol start="10">
<li>Finally, we need to add a method to respond to the button clicks (<kbd><span class="CodeInTextPACKT">LogUser</span></kbd>). Also a method to ensure we re-register this method when the window is disabled (to avoid memory leaks). Add these two methods to C# script-<kbd>class <span class="CodeInTextPACKT">MyEditorWindow</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    private void OnDisable()<br/>     {<br/>      registerButton.OnClick -= LogUser;<br/>     }<br/> <br/>     void LogUser()<br/>     {<br/>      var msg = "Registering " + realname.text + " as " + username.text;<br/>      Debug.Log (msg);<br/>     } </pre>
<ol start="11">
<li>After a few seconds, you should now see a menu named <span class="packt_screen"><span class="ScreenTextPACKT">Example</span></span> appear with aÂ <span class="ScreenTextPACKT">S<span class="packt_screen">how Window</span> item</span>.</li>
<li>You should now be able to display our custom registration panel by choosing this menu item.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Since there are several C# script-classes, each shall be separately described in the following.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Script-class MyEditorWindow</h1>
                </header>
            
            <article>
                
<p>In C# script-class <span class="CodeInTextPACKT"><kbd>MyEditorWindow</kbd>,</span> you preceded the <kbd><span class="CodeInTextPACKT">ShowWindow()</span></kbd> method with an attribute to add a menu item <span class="ScreenTextPACKT"><span class="packt_screen">Show Window</span></span> to a menu named <span class="ScreenTextPACKT">Example</span>. The <kbd><span class="CodeInTextPACKT">GetWindow()</span></kbd> statement gets a reference to an <kbd><span class="CodeInTextPACKT">MyEditorWindow</span></kbd> object - if no such window-panel exists, it creates one. The first argument is the title of the panel <span class="ScreenTextPACKT"><span class="packt_screen">My Reg Panel</span></span>. The true for the second argument tells Unity to make the window-panel have the focus (if a window panel already existed).</p>
<p>The <kbd><span class="CodeInTextPACKT">OnEnable()</span></kbd> method is executed when the window-panel first becomes enabled (active). It creates 2 <kbd>MyGUITextField</kbd> objects for username and real name, and a register <kbd>MyGUIButton</kbd>. Each of these objects are based on the <span class="CodeInTextPACKT">MyGUI</span> component script-classes in folder <kbd><span class="CodeInTextPACKT">MyGUI</span>.</kbd> Then GUI objects are added in the sequence we wish, to the list variable <kbd><span class="CodeInTextPACKT">guiCompoennts</span></kbd>. The first GUI component added to the list is a new object-instance of an non-interactive <kbd><span class="CodeInTextPACKT">MyGUILabel</span></kbd> (passing the text string Unity 2018 is great and a true for full centering). Then, we add the two text input components (username and real name), then a new <kbd><span class="CodeInTextPACKT">MyGUIFlexible</span></kbd> space object-instance, and finally a <kbd><span class="CodeInTextPACKT">MyGUIButton</span></kbd> with the label Register, whose <kbd><span class="CodeInTextPACKT">OnClick</span></kbd> event will cause the invocation of the <span class="CodeInTextPACKT"><kbd>LogUser()</kbd> method</span>.</p>
<p>The <span class="CodeInTextPACKT"><kbd>LogUser()</kbd></span> method logs the names in the two text fields to the Debug.Log.</p>
<p>The <kbd><span class="CodeInTextPACKT">OnDisable()</span></kbd> method ensures that when the window-panel is being disabled/closed we de-register the <kbd><span class="CodeInTextPACKT">LogUser()</span></kbd> method from the <span class="CodeInTextPACKT">OnClick</span> event of the button object.</p>
<p>The <span class="CodeInTextPACKT"><kbd>OnGUI()</kbd> method</span>, which executes every frame, simply loops through each GUI compoennt in list <span class="CodeInTextPACKT">guiComponents</span>, invoking the components' <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method. So each frame, our GUI is redisplayed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Script-class IMyGUI</h1>
                </header>
            
            <article>
                
<p>This C# script-class declares an <strong>interface named</strong> <span class="CodeInTextPACKT">IMyGUI</span>. An interface is a template script-class that defines method(s) all implementing classes must implement. Our interface class is very simple, it simply requires all implementing classes must defined an <span class="CodeInTextPACKT"><kbd>OnGUI()</kbd> method</span>. There is a naming convention that recommends all interface classes have a capital letter I, before the upper-camel case class name.</p>
<p>By declaring this interface, we can now implement lots of different <kbd><span class="CodeInTextPACKT">IMyGUI</span></kbd> classes, which can all be treated the same way - that is, they can have their <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method invoked each frame.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Script-class MyGUIFlexibleSpace</h1>
                </header>
            
            <article>
                
<p>This simple script-class adds a <kbd><span class="CodeInTextPACKT">GUILayout.FlexibleSpace()</span></kbd> to the IMGUI system when its <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method is invoked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Script-class MyGUITextField</h1>
                </header>
            
            <article>
                
<p>This class declares two public items: a public string (for the text the user can see and edit), and a public label. Its <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method displays the labelled text field, and stores its value back into variable text.</p>
<p>So our custom editor classes can set the initial text value and label, and also read any new value of the text from an object-instance of this class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Script-class MyGUILabel</h1>
                </header>
            
            <article>
                
<p>This class has two private values: the text to be displayed, and a bool, defining whether or not to fully center the text. Its <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method will add a <kbd><span class="CodeInTextPACKT">GUILayout.Lable()</span></kbd> to the GUI, and if the bool is <span class="CodeInTextPACKT">true</span>, it will add other GUILayout components before and after the label to ensure the label is both vertically and horizontally centered when displayed.</p>
<p>This is an example of how some of the complexity of an interface can be delegated to its own class like this. By setting a single bool to true, several Begin/End/Vertical/Horizontal statements and <span class="CodeInTextPACKT">FlexibleSpace</span> statements are added to the GUI that is output.</p>
<p>The screenshot illustrates how the flexible space and vertical/horizonal groups result in the desired alignment and spacing in the window-panel the user sees:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/466a14ac-e0db-4fff-86f4-4accbd7ed5c2.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Script-class MyGUIButton</h1>
                </header>
            
            <article>
                
<p>This class declares a public label, and also a public <kbd><span class="CodeInTextPACKT">OnClick</span></kbd> event. During the execution of its <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method, if the button has been clicked any methods that have been registered to listen for, <kbd><span class="CodeInTextPACKT">OnClick</span></kbd> events will be invoked.</p>
<p>There is a condition in the <kbd><span class="CodeInTextPACKT">OnGUI()</span></kbd> method, to ensure that if no methods are registered to list for <kbd><span class="CodeInTextPACKT">OnClick</span></kbd> events, then no statement is executed.</p>
<p>We can see the <kbd><span class="CodeInTextPACKT">LogUser</span></kbd> method of the <kbd><span class="CodeInTextPACKT">MyEditorWindow</span></kbd> the window-panel object being registered for the <kbd><span class="CodeInTextPACKT">OnClick</span></kbd> event of the <kbd>registerButton</kbd> object, in its <kbd><span class="CodeInTextPACKT">OnEnable()</span></kbd> method:</p>
<pre>registerButton = new MyGUIButton ();<br/> registerButton.label.text = "Register";<br/> // add RegisterUser() to button's OnClick event broadcaster<br/> registerButton.OnClick += LogUser; </pre>
<p>While perhaps overkill for this simple window-panel, this recipe illusrtates how the use of an Interface and a list of GUI component objects, allows for an extensible system of custom GUI component classes to be created, while allowing the complexity of the <kbd>EditorWindow</kbd> classes to be maintained.</p>
<p>Â </p>
<p>NOTE: An alternative to C# events would be to use Unity Events and in some cases lambda expressions. You can read a discussion of such topics in these online articles:</p>
<ul>
<li><kbd><span class="URLPACKT"><span>http://www.blockypixel.com/2012/09/c-in-unity3d-dynamic-methods-with-lambda-expressions/</span></span></kbd></li>
<li><kbd><span class="URLPACKT"><span>https://forum.unity.com/threads/how-to-use-an-action.339952/</span></span></kbd></li>
</ul>


            </article>

            
        </section>
    </body></html>