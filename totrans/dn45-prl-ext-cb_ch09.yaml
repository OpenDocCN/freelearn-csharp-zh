- en: Chapter 9. Dataflow Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 数据流库
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Reading from and writing to a dataflow block synchronously
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步从数据流块读取和写入
- en: Reading from and writing to a dataflow block asynchronously
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步从数据流块读取和写入
- en: Implementing a producer-consumer dataflow pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现生产者-消费者数据流模式
- en: Creating a dataflow pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据流管道
- en: Cancelling a dataflow block
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消数据流块
- en: Specifying the degree of parallelism
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定并行度
- en: Unlink dataflow blocks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断开数据流块链接
- en: Using `JoinBlock` to read from multiple data sources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `JoinBlock` 从多个数据源读取
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The Task Parallel Library's dataflow is a new library that is designed to increase
    the robustness of highly concurrent applications. TPL dataflow uses asynchronous
    message passing and pipelining to obtain more control and better performance than
    manual threading.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任务并行库（TPL）的数据流是一个旨在提高高度并发应用程序鲁棒性的新库。TPL 数据流使用异步消息传递和管道化，以获得比手动线程更好的控制和性能。
- en: A dataflow consists of a series of blocks. Each block can be a source or target
    for data. Data typically enters into a dataflow by being posted to a propagation
    block, which is a block that implements `ISourceBlock<T>` and `ITargetBlock<T>`.
    The source block can be linked to other target or propagation blocks. The data
    flows from one block to the next block in the chain asynchronously. The data is
    buffered at the source or target block until it is needed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流由一系列块组成。每个块都可以是数据源或目标。数据通常通过将数据发布到传播块（实现 `ISourceBlock<T>` 和 `ITargetBlock<T>`
    的块）进入数据流。源块可以连接到其他目标或传播块。数据异步地从链中的第一个块流向下一个块。数据在源或目标块中缓冲，直到需要时。
- en: The predefined blocks fall into three categories. There are buffering blocks
    which hold data for use by data consumers, there are execution blocks that call
    a user-provided delegate for each piece of received data, and there are grouping
    blocks which combine data from one or more sources and under various constraints.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的块分为三类。有缓冲块，用于存储数据以供数据消费者使用；有执行块，为每条接收到的数据调用用户提供的委托；还有分组块，将来自一个或多个源的数据在各种约束下组合起来。
- en: The TPL dataflow library provides three types of buffering blocks. There is
    the `System.Threading.Tasks.Dataflow.BufferBlock<T>` class, the `System.Threading.Tasks.Dataflow.BroadcastBlock<T>`
    class, and the `System.Threading.Tasks.Dataflow.WriteOnceBlock<T>` class. The
    `BufferBlock<T>` class is a general-purpose asynchronous messaging class. `BufferBlock<T>`
    stores a **First-In- First-Out** (**FIFO**) queue of messages that can be written
    to by multiple sources or read from by multiple targets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 数据流库提供了三种类型的缓冲块。有 `System.Threading.Tasks.Dataflow.BufferBlock<T>` 类，`System.Threading.Tasks.Dataflow.BroadcastBlock<T>`
    类，以及 `System.Threading.Tasks.Dataflow.WriteOnceBlock<T>` 类。`BufferBlock<T>` 类是一个通用异步消息类。`BufferBlock<T>`
    存储一个 **先进先出**（**FIFO**）队列的消息，可以由多个源写入或由多个目标读取。
- en: The `BroadcastBlock<T>` class is useful when you pass multiple messages to another
    component, or a message to multiple components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`BroadcastBlock<T>` 类在将多个消息传递给另一个组件，或将消息传递给多个组件时很有用。'
- en: The `WriteOnceBlock<T>` class is similar the `BroadcastBlock<T>` class, except
    that a `WriteOnceBlock<T>` object can be written one time only.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteOnceBlock<T>` 类与 `BroadcastBlock<T>` 类类似，但 `WriteOnceBlock<T>` 对象只能写入一次。'
- en: The TPL dataflow library provides three types of execution blocks. There is
    the `ActionBlock<TInput>` class, the `System.Threading.Tasks.Dataflow.TransformBlock<TInput,
    TOutput>` class, and the `System.Threading.Tasks.Dataflow.TransformManyBlock<TInput,
    TOutput>` class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 数据流库提供了三种类型的执行块。有 `ActionBlock<TInput>` 类，`System.Threading.Tasks.Dataflow.TransformBlock<TInput,
    TOutput>` 类，以及 `System.Threading.Tasks.Dataflow.TransformManyBlock<TInput, TOutput>`
    类。
- en: The `ActionBlock<TInput>` class is a target block that calls a delegate when
    it receives data. You can think of a `ActionBlock<TInput>` object as a delegate
    that runs asynchronously when data becomes available.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionBlock<TInput>` 类是一个目标块，在接收到数据时调用委托。你可以将 `ActionBlock<TInput>` 对象视为一个在数据可用时异步运行的委托。'
- en: The `TransformBlock<TInput, TOutput>` class resembles the `ActionBlock<TInput>`
    class, except that it acts both as a source and as a target.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformBlock<TInput, TOutput>` 类类似于 `ActionBlock<TInput>` 类，但它同时作为源和目标。'
- en: The `TransformManyBlock<TInput, TOutput>` class resembles the `TransformBlock<TInput,`
    `TOutput>` class, except that `TransformManyBlock<TInput, TOutput>` produces zero
    or more output values for each input value, instead of only one output value for
    each input value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformManyBlock<TInput, TOutput>`类与`TransformBlock<TInput, TOutput>`类相似，但`TransformManyBlock<TInput,
    TOutput>`对每个输入值产生零个或多个输出值，而不是每个输入值只产生一个输出值。'
- en: The TPL dataflow library also provides three types of join blocks. There is
    the `BatchBlock<T>` class, the `JoinBlock<T1, T2>` class, and the `BatchedJoinBlock<T1,
    T2>` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 数据流库还提供了三种类型的连接块。有`BatchBlock<T>`类、`JoinBlock<T1, T2>`类和`BatchedJoinBlock<T1,
    T2>`类。
- en: The `BatchBlock<T>` class combines sets of input data, which are known as batches,
    into arrays of output data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatchBlock<T>`类将输入数据集（称为批次）组合成输出数据数组。'
- en: The `JoinBlock<T1, T2>` and `JoinBlock<T1, T2, T3>` classes collect input elements
    and propagate out `System.Tuple<T1, T2>` or `System.Tuple<T1, T2, T3>` objects
    that contain those elements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`JoinBlock<T1, T2>`和`JoinBlock<T1, T2, T3>`类收集输入元素，并传播出包含这些元素的`System.Tuple<T1,
    T2>`或`System.Tuple<T1, T2, T3>`对象。'
- en: The `BatchedJoinBlock<T1, T2>` and `BatchedJoinBlock<T1, T2, T3>` classes collect
    batches of input elements and propagate out the `System.Tuple(IList(T1), IList(T2))`
    or `System.Tuple(IList(T1), IList(T2), IList(T3))` objects that contain those
    elements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatchedJoinBlock<T1, T2>`和`BatchedJoinBlock<T1, T2, T3>`类收集输入元素批次，并传播出包含这些元素的`System.Tuple(IList(T1),
    IList(T2))`或`System.Tuple(IList(T1), IList(T2), IList(T3))`对象。'
- en: The Dataflow library's infrastructure is built on .NET 4.5's Task Parallel Library.
    These dataflow components are useful when you have multiple operations that must
    communicate with one another asynchronously or when you want to process data as
    it becomes available.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流库的基础架构建立在.NET 4.5的并行任务库之上。这些数据流组件在您有多个必须异步相互通信的操作或您想处理可用数据时非常有用。
- en: Reading from and writing to a dataflow block synchronously
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步从数据流块读取和写入
- en: Writing a message synchronously to a dataflow block is done by calling the `Post<TInput>`
    method of a block. Let's use the `Receive` method of the block to receive data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用块的`Post<TInput>`方法来同步将消息写入数据流块。让我们使用块的`Receive`方法来接收数据。
- en: In this recipe, we are going to create a `Console` application that uses a `for`
    loop to synchronously write some numbers to `BufferBlock` using the `Post` method.
    The application then reads the data back from `BufferBlock` using the `Receive`
    method and writes the data to `Console`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个使用`for`循环同步将一些数字写入`BufferBlock`的`Console`应用程序，使用`Post`方法。然后，应用程序使用`Receive`方法从`BufferBlock`读取数据，并将数据写入`Console`。
- en: Getting ready…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: The TPL dataflow library doesn't ship with the rest of the TPL. To use the TPL
    dataflow library in your solutions, you need to use NuGet Package Manager to set
    your reference.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 数据流库不与 TPL 一起分发。要在您的解决方案中使用 TPL 数据流库，您需要使用 NuGet 包管理器来设置您的引用。
- en: After creating your new project in Visual Studio 2012, go to the **Solution**
    **Explorer**, right-click on **References**, and click on **Manage** **NuGet**
    **Package**.![Getting ready…](img/0225OT_09_01.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中创建您的全新项目后，转到**解决方案资源管理器**，右键单击**引用**，然后单击**管理 NuGet 包**。![准备中…](img/0225OT_09_01.jpg)
- en: In the NuGet Package Manager window, click on **Online** from the menu on the
    left and search for **TPL Dataflow**.![Getting ready…](img/0225OT_09_02.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 NuGet 包管理器窗口中，点击左侧菜单中的**在线**，并搜索**TPL Dataflow**。![准备中…](img/0225OT_09_02.jpg)
- en: How to do it…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's create a new `Console` application so we can see how to create a dataflow
    block and write to it synchronously.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的`Console`应用程序，以便我们可以看到如何创建数据流块并将其同步写入。
- en: Start a new project using the **Console Application** project template and assign
    `Dataflow ReadingWriting` as the **Solution name**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**控制台应用程序**项目模板启动一个新项目，并将**解决方案名称**设置为`Dataflow ReadingWriting`。
- en: Next, go to the **Solution Explorer**, right-click on **References**, click
    on **Manage NuGetPackages**, and add a reference to the **TPL Dataflow** library.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到**解决方案资源管理器**，右键单击**引用**，点击**管理 NuGet 包**，并添加对**TPL Dataflow**库的引用。
- en: Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件，并将以下`using`指令添加到`Program`类的顶部。
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `Main` method of the `Program` class, create a `BufferBlock<int>` object.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类的`Main`方法中，创建一个`BufferBlock<int>`对象。
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let's create a `for` loop that loops from zero to ten and writes the square
    of the loop index to the buffer block using the `Post` method.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个从零到十的循环，并使用`Post`方法将循环索引器的平方写入缓冲块。
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's create another `for` loop that loops from zero to ten that calls
    the `Receive` method on the buffer block for each iteration, and writes the results
    to `Console`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个从零到十的循环，在每次迭代中调用缓冲块的`Receive`方法，并将结果写入`Console`。
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finish up by writing a message to the `Console` application and waiting for
    user input before exiting.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向`Console`应用程序发送消息并等待用户输入后再退出。
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Visual Studio 2012, press *F5* to run the project. Click on the **Start**
    button, and your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_09_03.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。点击**开始**按钮，您的应用程序应该如图所示：![如何做…](img/0225OT_09_03.jpg)
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This simple example shows how to read from and write to a message block directly.
    More often, you will be connecting dataflow blocks to form pipelines, or linear
    sequences of blocks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例展示了如何直接从消息块读取和写入。更常见的情况是，您将连接数据流块以形成管道，或线性序列的块。
- en: Writing to a block directly is a pretty easy matter; you just need to call the
    `Post<TInput>` method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向块写入是一个相当简单的事情；您只需要调用`Post<TInput>`方法。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Post` method acts synchronously, and returns once the target block has
    decided to accept or reject the item.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post`方法同步执行，并在目标块决定接受或拒绝项目后返回。'
- en: Conversely, data can be directly received from `bufferingBlock` by calling the
    `Receive` method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，可以通过调用`Receive`方法直接从`bufferingBlock`接收数据。
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Receive` method has a few convenient overloads that can accept a time out
    period, `CancellationToken` or both.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Receive`方法有几个方便的重载，可以接受超时时间、`CancellationToken`或两者。'
- en: Reading from and writing to a dataflow block asynchronously
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步从数据流块读取和写入
- en: Writing a message asynchronously to a dataflow block is done by calling the
    `SendAsync<TInput>` method of a block. You use the `ReceiveAsync` method of the
    block to receive data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 向数据流块异步发送消息是通过调用块的`SendAsync<TInput>`方法来完成的。您使用块的`ReceiveAsync`方法来接收数据。
- en: In this recipe, we are going to create a `Console` application that uses a `for`
    loop to asynchronously write some numbers to `BufferBlock` using the `SendAsync`
    method. The application then reads the data back from `BufferBlock` using the
    `ReceiveAsync` method and writes the data to `Console`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个使用`for`循环异步将一些数字写入`BufferBlock`的`Console`应用程序，使用`SendAsync`方法。然后，应用程序使用`ReceiveAsync`方法从`BufferBlock`读取数据，并将数据写入`Console`。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Start a new project using the **Console Application** project template and assign
    `Dataflow ReadWriteAsync` as the **Solution name**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**控制台应用程序**项目模板启动一个新的项目，并将`Solution name`设置为`Dataflow ReadWriteAsync`。
- en: Next, go to **Solution** **Explorer**, right-click on **references**, click
    on **Manage NuGet Packages** and add a reference to the TPL Dataflow library.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到**解决方案资源管理器**，右键单击**引用**，点击**管理NuGet包**，并将TPL数据流库添加为引用。
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`，并将以下`using`指令添加到`Program`类的顶部：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now let's create a `static async` method that returns `Task` called `WriteDataAsync`.
    The method takes a `BufferBlock<int>` parameter, and uses a `for` loop to iterate
    from zero to ten. In each iteration of the loop, we need to use the `SendAsync`
    method to write the square of the loop indexer to `bufferingBlock`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个返回`Task`的`static async`方法，命名为`WriteDataAsync`。该方法接受一个`BufferBlock<int>`参数，并使用一个`for`循环从零迭代到十。在循环的每次迭代中，我们需要使用`SendAsync`方法将循环索引器的平方写入`bufferingBlock`。
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, let's create a `static async` method that returns `Task` called `ReadDataAsync`.
    The method takes a `BufferBlock<int>` parameter, and uses a `for` loop to read
    the data from `BufferBlock` and display it to `Console`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个返回`Task`的`static async`方法，命名为`ReadDataAsync`。该方法接受一个`BufferBlock<int>`参数，并使用一个`for`循环从`BufferBlock`读取数据并将其显示到`Console`。
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, let's create the implementation of the `Main` method. Here we just
    need to wait on calls to `WriteDataAsync` and `ReadDataAsync`. We also need to
    wait on user input before exiting.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建`Main`方法的实现。在这里，我们只需要等待对`WriteDataAsync`和`ReadDataAsync`的调用。我们还需要在退出前等待用户输入。
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, in Visual Studio 2012, press *F5* to run the project. Click on the **Start**
    button. Your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_09_04.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 Visual Studio 2012 中，按 *F5* 运行项目。点击 **开始** 按钮。你的应用程序应该如图所示：![如何操作…](img/0225OT_09_04.jpg)
- en: How it works…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This application uses the `SendAsync` method to asynchronously write to a `BufferBlock<int>`
    object and the `ReceiveAsync` method to read from the same object. We also use
    the `async` and `await` operators to send data to and read data from the target
    block.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序使用 `SendAsync` 方法异步地向 `BufferBlock<int>` 对象写入，并使用 `ReceiveAsync` 方法从同一个对象读取。我们还使用
    `async` 和 `await` 操作符将数据发送到目标块并从目标块读取数据。
- en: Notice that both the `ReadDataAsync` and `WriteDataAsync` methods are marked
    as `async`, with a return type of `Task`. We use the `await` keyword to asynchronously
    make the call to `SendAsync` and `ReceiveAsync`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ReadDataAsync` 和 `WriteDataAsync` 方法都被标记为 `async`，返回类型为 `Task`。我们使用 `await`
    关键字异步调用 `SendAsync` 和 `ReceiveAsync`。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ReceiveAsync` method is especially useful when you want to act on data
    as the data becomes available.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据可用时，`ReceiveAsync` 方法特别有用，当你想要对数据进行操作时。
- en: Implementing a producer-consumer dataflow pattern
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现生产者-消费者数据流模式
- en: TPL dataflow blocks can also be used in a producer-consumer pattern, where a
    producer sends messages to a block, and the consumer reads messages from a block.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 数据流块也可以用于生产者-消费者模式，其中生产者向一个块发送消息，消费者从这个块读取消息。
- en: In this recipe, we are going to create a `Console` application to demonstrate
    a basic producer-consumer pattern that uses dataflow. The producer will use a
    `for` loop to create some random numbers and add them to `BufferBlock<int>`. The
    consumer task will asynchronously receive the data from `BufferBlock` as it becomes
    available, and returns a sum of all the numbers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个 `控制台` 应用程序来演示使用数据流的基本生产者-消费者模式。生产者将使用 `for` 循环创建一些随机数字并将它们添加到
    `BufferBlock<int>`。消费者任务将异步地接收 `BufferBlock` 中的数据，并在数据可用时返回所有数字的总和。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's create another `Console` application and see how we can use dataflow blocks
    to implement a producer-consumer pattern.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个 `控制台` 应用程序，看看我们如何使用数据流块实现生产者-消费者模式。
- en: Start a new project using the **Console Application** project template and assign
    `Dataflow ProducerConsumer` as the **Solution name**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **控制台应用程序** 项目模板创建一个新的项目，并将 `Dataflow ProducerConsumer` 作为 **解决方案名称**。
- en: Next, go to **Solution Explorer**, right-click on **References**, click on **Manage
    NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 **解决方案资源管理器**，右键单击 **引用**，单击 **管理 NuGet 包**，并将对 **TPL Dataflow** 库的引用添加到其中。
- en: Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 并将以下 `using` 指令添加到 `Program` 类的顶部。
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's start by creating a `static` method on the `Program` class called `Produce`.
    This method returns `void`, and takes a parameter of type `ITargetBlock<int>`.
    This method will use a `for` loop to generate random numbers, and then use the
    `Post` method to send them to the block. When the `Produce` method is finished
    adding, it calls the `Complete` method on the block.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 `Program` 类上创建一个名为 `Produce` 的 `static` 方法开始。此方法返回 `void`，并接受一个类型为 `ITargetBlock<int>`
    的参数。此方法将使用 `for` 循环生成随机数字，然后使用 `Post` 方法将它们发送到块。当 `Produce` 方法完成添加后，它将调用块上的 `Complete`
    方法。
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, let's create a method called `ConsumeAsync`. As you probably guessed from
    the method name, this is an `async` method that returns `Task<int>`.The `ConsumeAsync`
    method needs a parameter type of `ISourceBlock<int>`. This method used a `while`
    loop to get data from the block as it becomes available, and produces a sum of
    the numbers.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为 `ConsumeAsync` 的方法。正如你可能从方法名中猜到的，这是一个返回 `Task<int>` 的 `async`
    方法。`ConsumeAsync` 方法需要一个类型为 `ISourceBlock<int>` 的参数。此方法使用 `while` 循环从块中获取数据，当数据可用时产生数字的总和。
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ok, let's finish up by implementing the `Main` method of the `Program` class.
    This method just needs to start `producer` and `consumer`, and display the results
    when finished.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们通过实现 `Program` 类的 `Main` 方法来完成。这个方法只需要启动 `producer` 和 `consumer`，并在完成后显示结果。
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_09_05.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你的应用程序应该如图所示：![如何操作…](img/0225OT_09_05.jpg)
- en: How it works…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `Produce` method is very straightforward. We declared a parameter of the
    interface type `ITargetBlock<TInput>`. `ITargetBlock` is an interface implemented
    by `BufferBlock` that represents a dataflow block that is a target for data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Produce` 方法非常直接。我们声明了一个接口类型 `ITargetBlock<TInput>` 的参数。`ITargetBlock` 是由 `BufferBlock`
    实现的接口，它表示一个数据流块，是数据的目标。'
- en: The `Produce` method just uses a `for` loop to send data to the target block
    using the `Post` method. After it is finished adding the data, it calls the complete
    method to signal that it is finished.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Produce` 方法仅使用 `for` 循环通过 `Post` 方法将数据发送到目标块。在完成添加数据后，它调用完成方法来表示操作已完成。'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ConsumeAsync` accepts a parameter of the interface type `ISourceBlock`, which
    represents a dataflow block that is a source of data. To act asynchronously, the
    `ConsumeAsync` method calls the `OutputAvailiableAsync` method to receive a notification
    when the source block has data available when the source block is finished, and
    will never have additional data. Other than that, it just uses the `Receive` method
    to receive the data and sums up the results.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsumeAsync` 接受一个接口类型 `ISourceBlock` 的参数，该接口表示一个数据流块，它是数据源。为了异步操作，`ConsumeAsync`
    方法调用 `OutputAvailiableAsync` 方法以在源块完成时接收通知，并且源块将不会有额外的数据。除此之外，它只是使用 `Receive`
    方法接收数据并汇总结果。'
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating a dataflow pipeline
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据流管道
- en: As we have seen so far, you can use `Post`, `Receive`, and `RecieveAsync` to
    send and receive messages from source blocks. You can also connect message blocks
    to form a dataflow pipeline. A dataflow pipeline is a chain of dataflow blocks,
    each of which performs a specific task and contributes to a larger goal. Each
    block in the pipeline performs its work when it receives a message from another
    dataflow block.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，您可以使用 `Post`、`Receive` 和 `RecieveAsync` 从源块发送和接收消息。您还可以将消息块连接起来形成一个数据流管道。数据流管道是一系列数据流块，每个块执行特定任务并为更大的目标做出贡献。管道中的每个块在接收到来自另一个数据流块的消息时执行其工作。
- en: In this recipe, we are to return to our WordCount example one final time. We
    are going to create a `Console` application that forms a dataflow pipeline for
    downloading the contents of a classic book, filters out the small words from the
    book contents, and returns a count of the words.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将再次回到我们的 WordCount 示例。我们将创建一个 `Console` 应用程序，该应用程序形成一个数据流管道以下载经典书籍的内容，过滤掉书籍内容中的小单词，并返回单词计数。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Now, let's see how we can chain dataflow blocks together to form a pipeline.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将数据流块链接起来形成一个管道。
- en: Start a new project using the **Console Application** project template and assign
    `DataflowPipeline` as the **Solution name**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **控制台应用程序** 项目模板创建一个新的项目，并将 `DataflowPipeline` 作为 **解决方案名称**。
- en: Next, go to the **Solution Explorer**, right-click on **References**, click
    on **Manage NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 **解决方案资源管理器**，右键单击 **引用**，单击 **管理 NuGet 包**，并添加对 **TPL Dataflow** 库的引用。
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 并将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first step is to create the dataflow blocks that participate in the pipeline.
    In the `Main` method, create `TransformBlock<string,string>` that takes the string
    input parameter and uses `WebClient` to download the book contents as a string.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建参与管道的数据流块。在 `Main` 方法中，创建一个 `TransformBlock<string,string>`，它接受字符串输入参数并使用
    `WebClient` 将书籍内容作为字符串下载。
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, let's add `TransformBlock<string, string[]>` which receives the output
    from the previous block, removes the spaces, and splits the words into a string
    array.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加 `TransformBlock<string, string[]>`，它接收前一个块的输出，删除空格，并将单词拆分到一个字符串数组中。
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ok, let's create `TransformBlock<string[],int>` that filters out words less
    than three characters and returns a count of the words.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们创建一个 `TransformBlock<string[],int>`，该块过滤掉少于三个字符的单词，并返回单词的计数。
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, let's create `ActionBlock<int>` to display the word count to `Console`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建 `ActionBlock<int>` 来将单词计数显示到 `Console`。
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let's use the `LinkTo` method to connect the source blocks and target blocks
    to form the pipeline.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `LinkTo` 方法将源块和目标块连接起来形成管道。
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, we need to add some completion tasks to enable each dataflow block to
    perform a final action after processing all data elements.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一些完成任务，以便每个数据流块在处理完所有数据元素后执行最终操作。
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, let's add some code to `Main` to post the data to the pipeline, complete
    the pipeline activity, wait for the pipeline to finish, and wait for user input
    before exiting.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在 `Main` 方法中添加一些代码来发布数据到管道，完成管道活动，等待管道完成，并在退出之前等待用户输入。
- en: '[PRE25]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    display the output as shown in the following screenshot:![How to do it…](img/0225OT_09_06.jpg)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你的应用程序应该显示如下截图所示的结果：![如何操作…](img/0225OT_09_06.jpg)
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this application we used `TransformBlock<TInput, TOutput>` to enable each
    member of the pipeline to perform an operation on its input data and send the
    results to the next step in the pipeline. For example, `downloadBook TransformBlock`
    takes a string input and returns a string output to the next step.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们使用了 `TransformBlock<TInput, TOutput>` 来使管道的每个成员能够对其输入数据执行操作并将结果发送到管道的下一步。例如，`downloadBook
    TransformBlock` 接收字符串输入并返回字符串输出到下一步。
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The only exception is the tail of the pipeline is `ActionBlock<TInput>` because
    it performs an action on its input and does not produce a result.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是管道的尾部是 `ActionBlock<TInput>`，因为它对其输入执行操作但不产生结果。
- en: The next step is to connect each block in the pipeline to the next. The `LinkTo`
    method of `DataflowBlock` is used to connect `ISourceBlock<TOutput>` to `TargetBlock<TInput>`.
    When you call the `LinkTo` method to connect a source to a target, the source
    will propagate data to the target as it becomes available.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将管道中的每个块连接到下一个。`DataflowBlock` 的 `LinkTo` 方法用于将 `ISourceBlock<TOutput>`
    连接到 `TargetBlock<TInput>`。当你调用 `LinkTo` 方法将源连接到目标时，源将在数据可用时将数据传播到目标。
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We also added some completion tasks to propagate completion through the pipeline.
    Each completion task sets the next dataflow block to the completed state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一些完成任务以通过管道传播完成状态。每个完成任务都将下一个数据流块设置为完成状态。
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we used `DataflowBlock.Post<TInput>` to synchronously send data to
    the head of the pipeline. The following is the URL string of the book we are downloading:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `DataflowBlock.Post<TInput>` 同步将数据发送到管道的头部。以下是我们正在下载的书籍的 URL 字符串：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Cancelling a dataflow block
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消数据流块
- en: Since dataflow blocks are built on the `Task` infrastructure of the TPL, cancellation
    is supported by obtaining `CancellationToken` from `CancellationTokenSource`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据流块建立在 TPL 的 `Task` 基础设施之上，因此可以通过从 `CancellationTokenSource` 获取 `CancellationToken`
    来支持取消操作。
- en: In this recipe, we will create a dataflow pipeline to download the contents
    of a classic book and perform a word count, except this time, we will enable the
    blocks that form the pipeline to be cancelled.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个数据流管道以下载经典书籍的内容并执行词频统计，但这次，我们将启用构成管道的块可以取消。
- en: How to do it…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's see how we can add cancellation to our dataflow blocks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将取消操作添加到我们的数据流块中。
- en: Start a new project using the **Console Application** project template and assign
    `CancelDataflow` as the **Solution name**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **控制台应用程序** 项目模板创建一个新的项目，并将 `Solution name` 设置为 `CancelDataflow`。
- en: Next, go to the **Solution Explorer**, right-click on **References**, click
    on **Manage NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 **解决方案资源管理器**，右键单击 **引用**，单击 **管理 NuGet 包**，并添加对 **TPL Dataflow** 库的引用。
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 并将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `Main` method, create a new `CancellationTokenSource` object.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法中，创建一个新的 `CancellationTokenSource` 对象。
- en: '[PRE31]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, let's create the blocks that form the pipeline. The blocks are exactly
    as before, except, this time they are created with a new `ExecutionDataflowBlockOptions`
    parameter that sets `CancellationToken`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建构成管道的块。这些块与之前完全相同，只是这次它们是用一个新的 `ExecutionDataflowBlockOptions` 参数创建的，该参数设置
    `CancellationToken`。
- en: '[PRE32]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, let's use the `LinkTo` method to connect the source blocks and target blocks
    to form the pipeline.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `LinkTo` 方法将源块和目标块连接起来以形成管道。
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we need to add some completion tasks to enable each dataflow block to
    perform a final action after processing all data elements.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一些完成任务，以便每个数据流块在处理完所有数据元素后执行最终操作。
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, add a `try` block to post the data to the head of the pipeline, complete
    the pipeline activity, and cancel the token.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个 `try` 块将数据发布到管道的头部，完成管道活动，并取消令牌。
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, add a `catch` block that handles `AggregateException` and a `finally`
    block to wait for user input before exiting.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个处理 `AggregateException` 的 `catch` 块和一个在退出前等待用户输入的 `finally` 块。
- en: '[PRE36]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_09_07.jpg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你的应用程序应该如图所示：![如何实现…](img/0225OT_09_07.jpg)
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This application forms a dataflow pipeline to process the contents of a book
    and return a word count as in the previous recipe. The difference is that we set
    up cancellation by creating a `CancellationTokenSource` object, and then setting
    the `CancellationToken` property of the `ExecutionDataflowBlockOptions` object
    associated with the blocks in our pipeline.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序形成一个数据流管道来处理书籍的内容，并返回与前面配方中相同的单词计数。不同之处在于，我们通过创建一个 `CancellationTokenSource`
    对象来设置取消，然后设置与我们的管道中的块关联的 `ExecutionDataflowBlockOptions` 对象的 `CancellationToken`
    属性。
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We set the `CancellationToken` property of the `ExecutionDataflowBlockOptions`
    object to `CancellationToken` obtained from the `CancellationTokenSource` object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `ExecutionDataflowBlockOptions` 对象的 `CancellationToken` 属性设置为从 `CancellationTokenSource`
    对象获得的 `CancellationToken`。
- en: As with all other cancellations in the TPL, we need to handle the `OperationCancelled`
    exception, which will be wrapped in a `AggregateException` object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TPL 中的所有其他取消一样，我们需要处理 `OperationCancelled` 异常，该异常将被包装在 `AggregateException`
    对象中。
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Specifying the degree of parallelism
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定并行度
- en: In the previous recipe, we saw how to use the `CancellationToken` property of
    the `ExecutionDataflowBlockOptions` object to enable cancellation of a pipeline.
    In this recipe, we will see how to use the `MaxDegreeOfParallelism` property to
    enable dataflow blocks to process more than one message at a time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们看到了如何使用 `ExecutionDataflowBlockOptions` 对象的 `CancellationToken` 属性来启用管道的取消。在这个配方中，我们将看到如何使用
    `MaxDegreeOfParallelism` 属性来启用数据流块一次处理多个消息。
- en: We are going to create a `Console` application that performs two dataflow calculations,
    and prints the elapsed time of each calculation. The first calculation sets the
    maximum degree of parallelism to one. The second operation is the same as the
    first, but sets the maximum degree of parallelism to the number of available processors
    on your machine.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个执行两个数据流计算的 `Console` 应用程序，并打印每个计算的耗时。第一个计算将最大并行度设置为1。第二个操作与第一个相同，但将最大并行度设置为机器上可用的处理器数量。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Now, let's see how to add cancellation to our dataflow blocks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何向我们的数据流块添加取消功能。
- en: Start a new project using the **Console Application** project template and assign
    `DegreeOfParallelism` as the **Solution name**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **Console Application** 项目模板创建一个新的项目，并将 `DegreeOfParallelism` 作为 **解决方案名称**。
- en: Next, go to the **Solution Explorer**, right-click on **References**, click
    on **Manage NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 **解决方案资源管理器**，右键单击 **引用**，单击 **管理 NuGet 包**，并添加对 **TPL Dataflow** 库的引用。
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 文件，并将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE39]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's start by creating a `static` method on the `Program` class called `ComputeTime`.
    The method needs to accept an `integer` parameter for `maxDegreeOfParallelism`
    and an `integer` parameter for `messageCount`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 `Program` 类上创建一个名为 `ComputeTime` 的 `static` 方法开始。该方法需要接受一个 `maxDegreeOfParallelism`
    的 `integer` 参数和一个 `messageCount` 的 `integer` 参数。
- en: '[PRE40]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `ComputeTime` method, create `ActionBlock<int>` that just sleeps for
    the time period of the `integer` parameter. `ActionBlock` also needs to use a
    `ExecutionDataflowBlockOptions` parameter and set the `MaxDegreeOfParallelism`
    property to the value of the method parameter.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ComputeTime` 方法中，创建一个 `ActionBlock<int>`，它只是休眠 `integer` 参数的时间段。`ActionBlock`
    还需要使用 `ExecutionDataflowBlockOptions` 参数，并将 `MaxDegreeOfParallelism` 属性设置为方法参数的值。
- en: '[PRE41]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's finish up the `ComputeTime` method by creating a `Stopwatch` object, using
    a `for` loop to post data to the action block, complete the action block, and
    return the elapsed time.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过创建一个 `Stopwatch` 对象，使用 `for` 循环将数据发布到操作块，完成操作块，并返回耗时来完成 `ComputeTime` 方法。
- en: '[PRE42]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, we need to implement the `Main` method. Let's start by getting the processor
    count of your machine; call the `ComputeTime` method twice (once with the `maxDegreeOfParallelism`
    parameter set to one, and once with the `maxDegreeOfParallelism` parameter set
    to your processor count), and display the results.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现 `Main` 方法。让我们首先获取机器的处理器数量；调用 `ComputeTime` 方法两次（一次将 `maxDegreeOfParallelism`
    参数设置为 一，另一次设置为处理器数量），并显示结果。
- en: '[PRE43]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    have results as shown in the following screenshot:![How to do it…](img/0225OT_09_08.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。您的应用程序应该有如下截图所示的结果：![如何操作…](img/0225OT_09_08.jpg)
- en: How it works…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we just use the `ComputeTime` method to set the maximum degree
    of parallelism of `ActionBlock<int>` to the value of the `maxDegreeOfParallelism`
    method parameter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们只是使用 `ComputeTime` 方法将 `ActionBlock<int>` 的最大并行度设置为 `maxDegreeOfParallelism`
    方法参数的值。
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We call this method twice, once with the `maxDegreeOfParallelism` parameter
    set to one, and once with the `maxDegreeOfParallelism` parameter set to the processor
    count of your machine.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用此方法两次，一次将 `maxDegreeOfParallelism` 参数设置为 一，另一次设置为机器的处理器数量。
- en: A maximum degree of parallelism of one causes the dataflow block to process
    messages serially, and a degree of parallelism of greater than one enables the
    dataflow block to process messages in parallel.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当并行度为一时，数据流块会顺序处理消息，而当并行度大于一时，数据流块可以并行处理消息。
- en: Unlink dataflow blocks
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消链接数据流块
- en: We have previously seen how to link dataflow blocks together to form a pipeline.
    This recipe is going to show how to unlink a dataflow block from its source.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到如何将数据流块链接在一起以形成一个管道。这个配方将展示如何将数据流块从其源中取消链接。
- en: We are going to show how to unlink a dataflow block by creating a `Console`
    application that creates three transform blocks, each of which calls a method
    to perform a calculation. The transform block objects will each be linked to a
    `WriteOnceBlock<T>` object, with the `MaxMessages` property set to one. This will
    instruct the source blocks to unlink after the first message is received at the
    target.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个 `Console` 应用程序来展示如何取消链接数据流块，该应用程序创建三个转换块，每个转换块都调用一个执行计算的方法。转换块对象将分别链接到一个
    `WriteOnceBlock<T>` 对象，其 `MaxMessages` 属性设置为 一。这将指示源块在目标接收第一条消息后取消链接。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Start a new project using the **Console Application** project template and assign
    `DegreeOfParallelism` as the **Solution name**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **控制台应用程序** 项目模板创建一个新的项目，并将 `DegreeOfParallelism` 作为 **解决方案名称**。
- en: Next, go to **Solution Explorer**, right-click on **References**, click on **Manage
    NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 **解决方案资源管理器**，右键单击 **引用**，单击 **管理 NuGet 包**，并添加对 **TPL Dataflow** 库的引用。
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 并将以下 `using` 指令添加到 `Program` 类的顶部：
- en: '[PRE45]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: First, let's create a `static` method called `DoCalculation`. This method accepts
    `integer` and `CancellationToken` as parameters, and returns `integer`. This method
    is going to simulate a lengthy calculation that takes a few seconds to complete,
    then returns a somewhat arbitrary value.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 `DoCalculation` 的 `static` 方法。此方法接受 `integer` 和 `CancellationToken`
    作为参数，并返回 `integer`。此方法将模拟一个耗时几秒钟才能完成的长时间计算，然后返回一个相当随机的值。
- en: '[PRE46]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Next, let's create another `static` method called `ReceiveFromAny<T>`. This
    method will take a parameter array of `ISourceBlock<T>` and return `T`. This method
    will receive a value from the first source in the `source` array that returns
    a value. It will create new `WriteOnceBlock<T>` and link it to each source block,
    with a `DataFlowLinkOptions` parameter and the `MaxMessages` property set to one.
    Finally, it will receive the value produced by `WriteOnceBlock`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建另一个名为 `ReceiveFromAny<T>` 的 `static` 方法。此方法将接受一个 `ISourceBlock<T>`
    参数数组，并返回 `T`。此方法将从 `source` 数组中的第一个返回值的源接收一个值。它将创建一个新的 `WriteOnceBlock<T>` 并将其链接到每个源块，使用
    `DataFlowLinkOptions` 参数和 `MaxMessages` 属性设置为 一。最后，它将接收由 `WriteOnceBlock` 产生的值。
- en: '[PRE47]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, let's implement the `Main` method. `Main` needs to create a new `CancellationToken`
    object, create three `System.Threading.Tasks.Dataflow.TransformBlock` objects
    that each call the `DoCalculation` method, posts data to each of `TransformBlocks`,
    and receives the result.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们实现`Main`方法。`Main`需要创建一个新的`CancellationToken`对象，创建三个调用`DoCalculation`方法、将数据发送到每个`TransformBlocks`并接收结果的`System.Threading.Tasks.Dataflow.TransformBlock`对象。
- en: '[PRE48]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_09_09.jpg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。你的应用程序应该如图所示：![如何实现…](img/0225OT_09_09.jpg)
- en: How it works…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `Main` method of this application is responsible for creating our `TransformBlock`
    objects, creating `Func` to call the `DoCalculation` method, posting some data
    to `TransformBlocks`, and calling `RecieveFromAny` with `TransformBlocks` as parameter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的`Main`方法负责创建我们的`TransformBlock`对象，创建`Func`以调用`DoCalculation`方法，将一些数据发送到`TransformBlocks`，并使用`TransformBlocks`作为参数调用`RecieveFromAny`。
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `RecieveFromAny` method creates a new `WriteOnceBlock<T>` object, uses a
    `for` loop to link the `WriteOnceBlocks` to the source `TransformBlocks`, and
    receives the first data the `WriteOnceBlock` produces.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecieveFromAny`方法创建一个新的`WriteOnceBlock<T>`对象，使用`for`循环将`WriteOnceBlocks`链接到源`TransformBlocks`，并接收`WriteOnceBlock`产生的第一个数据。'
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The link to the source blocks is created using the `LinkTo` method as before,
    but this time a new `DataflowLinkOptions` object is used as a parameter, with
    the `MaxMessages` property set to one.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LinkTo`方法创建源块之间的链接，就像之前一样，但这次使用一个新的`DataflowLinkOptions`对象作为参数，并将`MaxMessages`属性设置为1。
- en: The `MaxMessages` property is used to set the maximum number of messages that
    may be consumed across a link.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaxMessages`属性用于设置跨链接可能消耗的最大消息数。'
- en: Using JoinBlock to read from multiple data sources
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`JoinBlock`从多个数据源读取
- en: This recipe is going to show how to use `JoinBlock` to perform an operation
    when data is available from multiple sources.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将展示如何使用`JoinBlock`在多个数据源有可用数据时执行操作。
- en: 'We are going to create a `Console` application that defines two types of resources:
    `NetworkResource` and `MemoryResource`. We will use the `NetworkResource` and
    `MemoryResource` pair to perform an operation. To enable the operation to occur
    when both required resources are available, we will use `JoinBlock<T1, T2>`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Console`应用程序，该程序定义了两种类型的资源：`NetworkResource`和`MemoryResource`。我们将使用`NetworkResource`和`MemoryResource`对来执行操作。为了使操作在所需资源都可用时发生，我们将使用`JoinBlock<T1,
    T2>`。
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Let's see how to use `JoinBlock` to perform an operation based on data from
    multiple sources.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`JoinBlock`根据多个数据源的数据执行操作。
- en: Start a new project using the **Console Application** project template and assign
    `JoinBlock` as the **Solution name**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**控制台应用程序**项目模板启动一个新的项目，并将`JoinBlock`分配为**解决方案名称**。
- en: Next, go to **Solution Explorer**, right-click on **References**, click on **Manage
    NuGet Packages**, and add a reference to the **TPL Dataflow** library.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到**解决方案资源管理器**，右键单击**引用**，单击**管理NuGet包**，并添加对**TPL Dataflow**库的引用。
- en: 'Open up `Program.cs` and add the following `using` directives to the top of
    your `Program` class:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件，并将以下`using`指令添加到`Program`类的顶部：
- en: '[PRE51]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Inside the `Program` class above the `Main` method, create an `abstract` class
    definition for resource, and a concrete `class` definition for `MemoryResource`
    and `NetworkResource`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上面的`Program`类中的`Main`方法内部，创建一个资源`abstract`类定义，以及`MemoryResource`和`NetworkResource`的`class`定义。
- en: '[PRE52]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, in the `Main` method, create a `BufferBlock<MemoryResource>` and a `BufferBlock<NetworkResource>`
    object.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Main`方法中，创建一个`BufferBlock<MemoryResource>`和一个`BufferBlock<NetworkResource>`对象。
- en: '[PRE53]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next, create a `JoinBlock<NetworkResource, MemoryResource>`. Create a `GroupingDataflowBlockOptions`
    object parameter and set the `Greedy` property to false.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`JoinBlock<NetworkResource, MemoryResource>`。创建一个`GroupingDataflowBlockOptions`对象参数，并将`Greedy`属性设置为false。
- en: '[PRE54]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we need to create a `ActionBlock<Tuple<NetworkResource, MemoryResource>>`
    object to simulate `NetworkResource` doing a lengthy network access operation.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个`ActionBlock<Tuple<NetworkResource, MemoryResource>>`对象来模拟`NetworkResource`执行一个耗时的网络访问操作。
- en: '[PRE55]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finally, let's finish up the `Main` method by linking the resource objects,
    linking `JoinBlock` to `ActionBlock`, and posting data to the resource blocks.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过链接资源对象、将`JoinBlock`链接到`ActionBlock`以及向资源块发送数据来完成`Main`方法。
- en: '[PRE56]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    display results as shown in the following screenshot:![How to do it…](img/0225OT_09_10.jpg)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 键运行项目。你的应用程序应显示如下截图所示的结果：![如何操作…](img/0225OT_09_10.jpg)
- en: How it works…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This application starts by creating two `BufferBlock<T>` objects; one holds
    network resources and one holds memory resources.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序从创建两个 `BufferBlock<T>` 对象开始；一个用于存储网络资源，另一个用于存储内存资源。
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Then we created a non-greedy `JoinBlock` to join the network resources to the
    memory resources by setting the `Greedy` property to `false`. In the default greedy
    mode, the join block will greedily take the data from the source, but it still
    won't produce a result tuple until all necessary data is available. This is primarily
    important when sources are connected to multiple join blocks. If all of the joins
    take data greedily from the sources, you can end up in situations where data would
    be available to satisfy one of the joins, but end up being taken greedily and
    split across multiple joins such that none of them could be satisfied, and thus,
    none will produce results until more data comes along.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个非贪婪的 `JoinBlock`，通过将 `Greedy` 属性设置为 `false` 来将网络资源连接到内存资源。在默认的贪婪模式下，连接块会贪婪地从源中获取数据，但只有在所有必要的数据都可用时才会产生结果元组。这主要在源连接到多个连接块时非常重要。如果所有连接都贪婪地从源中获取数据，你可能会遇到数据可以满足其中一个连接的情况，但最终会被贪婪地获取并分配到多个连接中，这样就没有任何一个可以满足，因此，在更多数据到来之前，它们都不会产生结果。
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The next step is to create `ActionBlock` that operates network and memory resources.
    The action just simulates a lengthy operation on a network resource and then releases
    the resources back to their pools.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个操作网络和内存资源的 `ActionBlock`。该操作仅模拟对网络资源进行长时间操作，然后释放资源回到它们的池中。
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, we link our resources together, populate our resource pools and allow
    data to flow through for a few seconds.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将资源连接起来，填充资源池，并允许数据流动几秒钟。
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
