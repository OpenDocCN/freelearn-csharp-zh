- en: 18 Request-EndPoint-Response (REPR) and Minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file120.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces the **Request-EndPoint-Response (REPR)** pattern, which
    builds on top of Vertical Slice Architecture and CQS. We continue to simplify
    our codebase to make it even more readable, maintainable, and less abstract, yet
    still testable.
  prefs: []
  type: TYPE_NORMAL
- en: We pronounce REPR like “reaper”, which sounds way better than “rer” or “reper”.
    I must credit Steve "ardalis" Smith for this outstanding pattern name. I left
    a link to his article in the *Further reading* section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We leveraged this pattern already, possibly without you knowing about its name.
    Now it is time to formally introduce it, then assemble a technology stack to make
    it scalable for a real-world application.We build that solution, then improve
    it during the chapter to make it better by exploring manual techniques, existing
    tools, and open-source libraries. The result is not perfect, but we are not done
    improving this new e-commerce-inspired solution.
  prefs: []
  type: TYPE_NORMAL
- en: The key to this approach is learning to think about architecture and improve
    your design skills, so you have the tools to overcome the unique challenges the
    real world will throw at you!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Request-EndPoint-Response (REPR) pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project – REPR—A slice of the real-world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore the pattern before jumping into a more hands-on example.
  prefs: []
  type: TYPE_NORMAL
- en: Request-EndPoint-Response (REPR) pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Request-EndPoint-Response (REPR) pattern offers a simple approach similar
    to what we explored in Vertical Slice Architecture which deviates from the traditional
    Model-View-Controller (MVC) pattern. As we explored in the MVC Chapter, REST APIs
    don't have views, so we have to distort the concept to make it work. REPR is more
    appropriate than MVC for building REST APIs in the context of HTTP since each
    URL is a way to describe how to reach an endpoint (execute an operation), not
    a controller.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: REPR aims to align our REST APIs to HTTP and treat the inherent request-response
    concept being the web as a first-class citizen in our application design.On top
    of this, the REPR pattern using Minimal APIs is well-aligned with Vertical Slice
    Architecture and facilitates building feature-oriented software instead of layer-heavy
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'REPR has three components:'
  prefs: []
  type: TYPE_NORMAL
- en: A request that contains the required information for the endpoint to do its
    work and plays the role of an input DTO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An endpoint handler containing the business logic to execute, which is the central
    piece of this pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A response that the endpoint returns to the client and plays the role of an
    output DTO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can treat each request as a *Query* or a *Command* as we explore in the
    CQS and Vertical Slice Architecture chapters.Here''s a diagram that represents
    this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.1: a diagram representing the logical flow and the REPR pattern.](img/file121.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.1: a diagram representing the logical flow and the REPR pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram should sound familiar since it resembles what we explored
    in the Vertical Slice Architecture. However, instead of Request-Handler-Result,
    we use Request-Endpoint-Response (a.k.a. REPR).Bottom line, a request can be a
    Query or a Command, then it hits the endpoint that executes the logic and finally
    returns a response.
  prefs: []
  type: TYPE_NORMAL
- en: The server returns an HTTP response even when the response’s body is empty.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s explore an example using Minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: Project – SimpleEndpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SimpleEndpoint project showcases a few simple features and patterns to organize
    our REPR features without dependencies on external libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: ShuffleText'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first feature gets a string as input, shuffles its content, and returns
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code leverages the `Random` API and shuffles the `request.Text`
    property then returns the results wrapped in a `Response` object.Before executing
    our feature, we must create a minimal API map and register our handler with the
    container. Here’s the Program.cs class that achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code registers the `ShuffleText.Endpoint` as a singleton so we
    can inject it in the delegate. The delegate leverages the `[AsParameters]` attribute
    to bind the route parameter to the `ShuffleText.Request` property. Finally, the
    logic is straightforward; the endpoint delegate sends the request to the injected
    endpoint handler and returns the result, which ASP.NET Core serializes to JSON.When
    we send the following HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We receive some gibberish results similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is close to the simplest we can get out of the box. Next, we encapsulate
    the endpoint itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: RandomNumber'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This feature generates a number of random numbers between a minimum and a maximum.The
    first pattern divided the code between the `Program.cs` file and the feature itself.
    In this pattern, we encapsulate the endpoint delegate into the feature (same file
    in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is very similar to the first feature. However, the delegate
    we named `Endpoint` is now part of the feature class (highlighted code). The class
    that contains the logic is now called `Handler` instead of `Endpoint`. This change
    makes the full feature live closer together.Nonetheless, we still need to register
    the dependency with the container and map the endpoint to our delegate like this
    in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is routing the request to the `RandomNumber.Endpoint` method.When
    we send the following HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We receive a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We moved more of our feature’s code together; however, our code is still divided
    into two files. Let’s explore a way to fix this next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: UpperCase'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This feature transforms the input text to uppercase and returns the result.Our
    objective is to centralize as much of the code as possible in the `UpperCase`
    feature class so we control it from a single place. To achieve this, we create
    the following extension methods (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we changed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `UpperCase` class is static to allow us to create extension methods. Turning
    the `UpperCase` class into a static class does not hinder our maintainability
    because we use it as an organizer and do not instantiate it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the `AddUpperCase` method that registers the dependencies with the
    container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the `MapUpperCase` method that creates the endpoint itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Program.cs file, we can now register our feature like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls our extension methods, which move all the related code
    into the `UpperCase` class but its connection with ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: I find this approach elegant and very clean for a no-dependency project. Of
    course, we could design this in a million different ways, use an existing library
    to help us, scan the assembly and auto-register our features, and more.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use this pattern to build a real-world application. I’d suggest creating
    an `AddFeatures` and a `MapFeatures` extension method that register all the features
    instead of cluttering the `Program.cs` file, but besides a few final organization
    touch, this is a robust enough pattern. We explore more of this in the next project.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When we send the following HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We receive the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we explored REPR and how to encapsulate our REPR features in several
    ways, we are almost ready to explore a larger project.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a feature-based design using Minimal APIs, the REPR pattern, and no
    external dependencies is possible and simple. We organized our project in different
    ways. Each feature comprises a request, a response, and a handler attached to
    an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We can combine the handler and the endpoint to make it a three-component pattern.
    What I like about having a distinct handler is that we can reuse the handler in
    a non-HTTP context; say, we could create a CLI tool in front of the application
    and reuse the same logic. It all depends on what we are building.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s see how the REPR pattern can help us follow the **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Each piece has a single responsibility, and all pieces are centralized
    under a feature for ease of navigation, making this pattern a perfect SRP ally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Using an approach similar to what we did with the `UpperCase` feature,
    we can change the feature’s behavior without affecting the rest of the codebase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: The REPR pattern divides a feature into three smaller interfaces: the
    request, the endpoint, and the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we familiarized ourselves with the REPR pattern, it is time to explore
    a larger project, including exception handling and grey-box testing.
  prefs: []
  type: TYPE_NORMAL
- en: Project – REPR—A slice of the real-world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Context**: this project slightly differs from the previous ones about products
    and stocks. We remove the inventory from the product, add a unit price, and create
    a barebone shopping basket as a foundation for an e-commerce application. The
    inventory management became so complex that we had to extract and handle it separately
    (not included here).By using the REPR pattern, Minimal APIs, and what we learned
    with Vertical Slice Architecture, we analyzed that the application contains two
    major areas:'
  prefs: []
  type: TYPE_NORMAL
- en: A product catalog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this first iteration, we kept the management of the products away from
    the application, supporting only the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing all products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching the details of a product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As for the shopping cart, we kept it to a minimum. The basket only persists
    the `Id` of the products in the cart and its quantity. The basket does not support
    any more advanced use cases. Here are the operations it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an item to the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch the items that are in the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove an item from the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the quantity of an item in the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, the shopping cart is not aware of the product catalog.
  prefs: []
  type: TYPE_NORMAL
- en: We improve the application in *Chapter 19*, *Introduction to Microservices Architecture*,
    and *Chapter 20*, *Modular Monolith*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s assemble the stack we’ll build upon next.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling our stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I want to keep the project as barebone as possible, using Minimal APIs, yet,
    we don’t have to struggle with manually implementing every single concern ourselves.
    Here are the tools we will use to build this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ASP.NET Core Minimal API* as our backbone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FluentValidation* as our validation framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FluentValidation.AspNetCore.Http* connects FluentValidation into Minimal API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapperly* is our mapping framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ExceptionMapper* helps us handle exceptions globally, shifting our pattern
    to error management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*EF Core* (InMemory) as our ORM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From a terminal window, we can use the CLI to install the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We know most of those pieces and will dig deeper into the new ones in time.
    Meanwhile, let’s explore the structure of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the code structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The directory structure is very similar to what we explored in Vertical Slice
    Architecture. The root of the project contains the `Program.cs` file and a `Features`
    directory that holds the features or slices. The following diagram represents
    the features:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.2: The project''s directory structure that represents the features''
    hierarchical relationships.](img/file122.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.2: The project''s directory structure that represents the features''
    hierarchical relationships.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The features inside each area share a cohesive bond and some pieces of code
    (coupling), while the two areas are entirely disconnected (loosely coupled).The
    `Program.cs` file is very light and only bootstraps the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted lines are extension methods defined in the `Features` class
    (located under the `Features` folder), which cascades the responsibility of registering
    the dependencies with the container, mapping the endpoints, and seeding the database
    to each area. Here’s the skeleton of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now explore the `AddFeatures` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddFeatures` method registers FluentValidation and the Minimal API filters
    to validate our endpoints (the highlighted line). Each slice defines its own configuration
    methods, like the `AddProductsFeature` and `AddBasketsFeature` methods. We will
    come back to those. Meanwhile, let’s explore the `MapFeatures` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MapFeatures` method creates a root route group, adds the *FluentValidation*
    filter to it so the validation applies to all endpoints in this group, then it
    calls the `MapProductsFeature` and `MapBasketsFeature` methods that map their
    features into the group. Finally, the `SeedFeaturesAsync` method seeds the database
    using the feature extension methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With those building blocks in place, the program starts, adds features, and
    registers endpoints. Afterward, each category of features—products and baskets—cascades
    the calls, letting each feature registers its pieces. Next are a few diagrams
    representing the call hierarchy from the `Program.cs` file. Let’s start with the
    `AddFeatures` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.3: the call hierarchy of the AddFeatures method.](img/file123.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.3: the call hierarchy of the AddFeatures method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram showcases the division of responsibilities where each
    piece aggregates its sub-parts or registers its dependencies.A similar flow happens
    from the `MapFeatures` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.4: the call hierarchy of the MapFeatures method.](img/file124.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.4: the call hierarchy of the MapFeatures method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `SeedFeaturesAsync` method utilizes a similar approach to seed
    the in-memory database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.5: the call hierarchy of the SeedFeaturesAsync method.](img/file125.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.5: the call hierarchy of the SeedFeaturesAsync method.'
  prefs: []
  type: TYPE_NORMAL
- en: These diagrams showcase the entry point (`Program.cs`) sending a request to
    each feature so that every piece handles itself.
  prefs: []
  type: TYPE_NORMAL
- en: In a real project using an actual database, you do not want to seed the database
    this way. In this case, it works because each time we start the project, the database
    is empty because it only lives for the time the program runs—it lives in memory.
    There are numerous strategies to seed your data sources in real life, from executing
    a SQL script to deploying a Docker container that runs only once.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we explored the high-level view of the program, it is time to dig into
    a feature and explore how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the shopping basket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section explores the `AddItem` and `FetchItems` features of the shopping
    basket slice. The slice is completely decoupled from the `Products` slice, and
    does not know the products themselves. All it knows is how to accumulate product
    identifiers and quantities and associate those with a customer. We address this
    problem later.
  prefs: []
  type: TYPE_NORMAL
- en: There are no customer features and no authentication to keep the project simple.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The code of the `Features/Baskets/Baskets.cs` file powers the shopping basket
    features. Here’s the skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code of the preceding block contains the `BasketItem` data model
    and the `BasketContext` EF Core `DbContext`, which all basket features share.
    It also includes the three methods that register and make the features work (`AddBasketsFeature`,
    `MapBasketsFeature`, and `SeedBasketsAsync`). The other methods and classes are
    divided into several files. We explore a few of them in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `partial` modifier to split the nested classes into multiple files.
    We made the class `static` to create extension methods in it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `BasketItem` class allows us to persist a simple shopping cart to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BasketContext` class configures the primary key of the `BasketItem` class
    and exposes the `Items` property (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddBasketsFeature` method registers each feature and the `BasketContext`
    with the IoC container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the `AddDbContext` method, the `AddBasketsFeature` delegates the registration
    of dependencies to each feature. We explore the highlighted ones shortly. The
    EF Core code registers the in-memory provider that serves the `BasketContext`.Next,
    the `MapBasketsFeature` method maps the endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a group, naming it `baskets`, making its endpoints
    accessible using the `/baskets` URL prefix. We also tag the group “Baskets” to
    leverage an OpenAPI generator in the future. Then the method uses a similar pattern
    to the `AddBasketsFeature` method and delegates the endpoint mapping to the features.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed that the method returns the `endpoints` object directly? This
    allows us to chain the feature mapping. In another scenario, we could return the
    `group` object (`RouteGroupBuilder` instance) to let the caller further configure
    the group. What we build is always about the needs and objectives.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finally, the `SeedBasketsAsync` method does nothing; we do not create any shopping
    cart when starting the program, unlike the `Products` slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We could have omitted the preceding method. I left it so we follow a linear
    pattern between the features. Such a linear pattern makes it easier to understand
    and learn. It also allows identifying the recurring pieces we could work on to
    automate the registration process.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have covered the shared pieces, let’s add data to our shopping basket.
  prefs: []
  type: TYPE_NORMAL
- en: AddItem feature
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The role of the `AddItem` feature is to create a `BasketItem` object and persist
    it in the database. To achieve this, we leverage the REPR pattern. Inspired by
    the preceding few chapters, we name the request `Command` (CQS pattern), add a
    mapper object using Mapperly, and leverage FluentValidation to ensure the request
    is valid. Here’s the skeleton of the `AddItem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code contains all the necessary pieces of the feature:'
  prefs: []
  type: TYPE_NORMAL
- en: The request (the `Command` class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response (the `Response` class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The endpoint (the `MapAddItem` method pointing the requests to the `Handler`
    class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mapper object that has Mapperly generate the mapping code for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A validator class that ensures the input we receive is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AddAddItem` method registers its services with the IoC container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with the `AddAddItem` method that registers the feature’s services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `MapAddItem` method routes the appropriate POST requests with a valid
    `Command` object in its body to the `Handler` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `Command` instance is a copy of the `BasketItem` class, while the response
    only returns the `ProductId` and `Quantity` properties. The highlighted lines
    represent the endpoint handing off the `Command` object to the use case `Handler`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We could write the `Handler` code in the delegate, which would make unit testing
    the delegate very hard.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `Handler` class is the glue of the feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code contains the business logic of the feature by ensuring the
    item is not already in the basket. If it is, it throws a `DuplicateBasketItemException`.
    Otherwise, it saves the item to the database. It then returns a `Response` object.
  prefs: []
  type: TYPE_NORMAL
- en: Each customer (`CustomerId`) can have each product (`ProductId`) once in its
    cart (composite primary key), which is why we test for this condition.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The handler leveraged the `Mapper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Implicitly, the `Command` object was validated using the following `Validator`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, in the `Features.cs` file, we called the `AddFluentValidationFilter`
    method on the root route group, letting the `FluentValidationEndpointFilter` class
    validate the inputs for us using the `Validator` class.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With this in place, we can send the following HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The endpoint responds with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And has the following HTTP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To recap, here’s what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core routes the request to the delegate we registered in the `MapAddItem`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The validation middle runs an `AddItem.Validator` object against the `AddItem.Command`
    sent to the endpoint. The request is valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `HandleAsync` method of the `AddItem.Handler` class is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming the item is not already in the customer’s basket, it is added to the
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `HandleAsync` method returns a `Response` object to the delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The delegate returns a `201 Create` status code with the `Location` header set
    to the URL of the product that got added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the preceding list depicts, the process is quite simple; a request gets
    in, the business logic is executed (endpoint), then a response goes out: REPR.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more pieces, but they save us the trouble of object mapping
    and validation. Those pieces are optional; you can conceive your own stack with
    more or less pieces in it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On top of the feature code, we also have a few tests to assess that the business
    logic remains correct over time. We cover those under the *Grey-box testing* section.
    Meanwhile, let’s look at the `FetchItems` feature.
  prefs: []
  type: TYPE_NORMAL
- en: FetchItems feature
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we know the pattern, this feature should be faster to cover. It allows
    a client to retrieve the shopping basket of the specified customer using the following
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The client expects a collection of items in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the client knows about the customer, it does not need the endpoint to
    return the `CustomerId` property, which is why the `Item` class only has two of
    the `BasketItem` properties.Here are the `Mapper` and the `Validator` classes,
    which should be self-explanatory at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a last piece of plumbing is the `AddFetchItems` method which registers
    the feature’s services with the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to the endpoint itself, forwarding the `FetchItems.Query` object to a `FetchItems.Handler`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is simpler than the `AddItem` feature because it serializes
    the handler’s response directly as a 200 OK status code without transforming it.Finally,
    the `Handler` class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code loads all the items associated with the specified customer
    from the database and returns them. If there are no items, the client receives
    an empty array.That’s it; we can now send the following HTTP request and hit the
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming we added an item to the basket, we should receive a response similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We now have a working shopping basket!
  prefs: []
  type: TYPE_NORMAL
- en: You can explore the other features in the codebase available on GitHub ([https://adpg.link/ikAn](https://adpg.link/ikAn)).
    All features have tests and are functional.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we look at exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Managing exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `AddItem` feature throws a `DuplicateBasketItemException` when the product
    is already in the basket. However, when that happens, the server returns an error
    that resembles the following (partial output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That error is ugly and impractical for a client calling the API. To circumvent
    this, we can add a try-catch somewhere and treat each exception individually,
    or we can use a middleware to catch the exceptions and normalize their output.Managing
    exceptions one by one is tedious and error-prone. On the other hand, centralizing
    exception management and treating them as a cross-cutting concern transforms the
    tedious mechanism into a new tool to leverage. Moreover, it ensures that the API
    always returns the errors in the same format with no additional effort.Let’s program
    a basic middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an exception handler middleware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A middleware in ASP.NET Core is executed as part of the pipeline and can run
    before and after the execution of an endpoint.When an exception occurs, the request
    is re-executed in a parallel pipeline, allowing different middleware to manage
    the error flow.To create a middleware, we must implement an `InvokeAsync` method.
    The easiest way to do this is by implementing the `IMiddleware` interface. You
    can add middleware types to the default or exception-handling alternate pipelines.The
    following code represents a basic exception-handling middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The middleware fetches the `IExceptionHandlerFeature` to access the error and
    outputs an object containing the error message (ASP.NET Core manages this feature).
    If the feature is unavailable, the middleware throws a `NotSupportedException`,
    which rethrows the original exception.
  prefs: []
  type: TYPE_NORMAL
- en: Any type of exception a middleware of the alternate pipeline throws will rethrow
    the original exception.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If any, the highlighted code executes the next middleware in the pipeline.
    These pipelines are like a chain of responsibilities but with a different objective.To
    register the middleware, we must first add it to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must register it as part of the exception-handling alternate pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also register more middleware or create them inline, like this:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The possibilities are vast.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, if we try to add a duplicated item to the basket, we get a *500 Internal
    Server Error* with the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This response is more elegant than before and easier to handle for the clients.
    We could also alter the status code in the middleware. However, customizing this
    middleware would take many pages, so we leverage an existing library instead.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling using ExceptionMapper
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `ForEvolve.ExceptionMapper` package is an ASP.NET Core middleware that
    allows us to map exceptions to different status codes. Out-of-the-box, it offers
    many exception types to get started, handles them, and allows easy mapping between
    a custom exception and a status code. By default, the library serializes the exceptions
    to a `ProblemDetails` object (based on RFC 7807) by leveraging as many ASP.NET
    Core components as possible, so we can customize parts of the library by customizing
    ASP.NET Core.To get started, in the `Program.cs` file, we must add the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to add a duplicated product to the basket, we receive a response
    with a *409 Conflict* status code with the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This output is starting to look like something!
  prefs: []
  type: TYPE_NORMAL
- en: The `debug` object (highlighted) only appears in development or as an opt-in
    option.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'How can the middleware know it’s a 409 Conflict and not a 500 Internal Server
    Error? Simple! The `DuplicateBasketItemException` inherits from the `ConflictException`
    that comes from the `ForEvolve.ExceptionMapper` namespace (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: With this setup, we can leverage exceptions to return errors with different
    status codes.
  prefs: []
  type: TYPE_NORMAL
- en: I have used this methodology for many years, and it simplifies the program structure
    and developers' lives. The idea is to harness the power and simplicity of exceptions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example, we may want to map EF Core errors, `DbUpdateException` and `DbUpdateConcurrencyException`,
    to a *409 Conflict* as well, so in case we forget to catch a database error, the
    middleware will do it for us. To achieve this, we can customize the middleware
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, if a client hits an unhandled EF Core exception, the server
    will respond with something like the following (I omitted the stack trace for
    brevity reasons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In an actual project, for security reasons, I recommend customizing the error
    handling further to hide the fact that we are using EF Core. We must give as little
    information as possible about our systems to malicious actors to keep them as
    secure and safe as possible. We won’t cover creating custom exception handlers
    here because it is out of the scope of the chapter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As we can see, it is easy to register custom exceptions and associate them
    with a status code. We can do this with any custom exception or inherit from an
    existing one to make it work with customization.As of version 3.0.29, *ExceptionMapper*
    offers the following custom exception associations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Exception Type | Status Code |'
  prefs: []
  type: TYPE_TB
- en: '| `BadRequestException` | `StatusCodes.Status400BadRequest` |'
  prefs: []
  type: TYPE_TB
- en: '| `ConflictException` | `StatusCodes.Status409Conflict` |'
  prefs: []
  type: TYPE_TB
- en: '| `ForbiddenException` | `StatusCodes.Status403Forbidden` |'
  prefs: []
  type: TYPE_TB
- en: '| `GoneException` | `StatusCodes.Status410Gone` |'
  prefs: []
  type: TYPE_TB
- en: '| `NotFoundException` | `StatusCodes.Status404NotFound` |'
  prefs: []
  type: TYPE_TB
- en: '| `ResourceNotFoundException` | `StatusCodes.Status404NotFound` |'
  prefs: []
  type: TYPE_TB
- en: '| `UnauthorizedException` | `StatusCodes.Status401Unauthorized` |'
  prefs: []
  type: TYPE_TB
- en: '| `GatewayTimeoutException` | `StatusCodes.Status504GatewayTimeout` |'
  prefs: []
  type: TYPE_TB
- en: '| `InternalServerErrorException` | `StatusCodes.Status500InternalServerError`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ServiceUnavailableException` | `StatusCodes.Status503ServiceUnavailable`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 18.1: ExceptionMapper custom exception associations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inherit from those standard exceptions, and the middleware will associate
    them with the correct status code as we did with the `DuplicateBasketItemException`
    class.*ExceptionMapper* also maps the following .NET exceptions automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BadHttpRequestException` to `StatusCodes.Status400BadRequest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotImplementedException` to `StatusCodes.Status501NotImplemented`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the project, there are three custom exceptions that you can find on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BasketItemNotFoundException` that inherits from `NotFoundException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DuplicateBasketItemException` that inherits from `ConflictException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductNotFoundException` that inherits from `NotFoundException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we explore this way of thinking about error propagation a little more.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging exceptions to propagate errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the middleware of *ExceptionMapper* in place, we can treat exceptions
    as a simple tool to propagate errors to the clients. We can throw an existing
    exception, like a `NotFoundException`, or create a custom reusable one with a
    more precise preconfigured error message.When we want the server to return a specific
    error, all we must do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new exception type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherit from an existing type from *ExceptionMapper* or register our custom
    exception with the middleware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throw our custom exception anywhere in the REPR flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let the middleware do its job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s a simplified representation of this flow, using the `AddItem` endpoint
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.6: a simplified view of an exception flow using ExceptionMapper.](img/file126.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.6: a simplified view of an exception flow using ExceptionMapper.'
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we have a simple way to return errors to the clients from
    anywhere in the REPR flow. Moreover, our errors are consistently formatted the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling pattern and the *ExceptionMapper* library also work with
    MVC and allow customizing the error formatting process.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, let’s explore a few test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Grey-box testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using Vertical Slice Architecture or REPR makes writing grey-box tests very
    convenient. The test project mainly comprises integration tests that use the grey-box
    philosophy. Since we know the application under test's inner workings, we can
    manipulate the data from the EF Core `DbContext` objects, which allows us to write
    almost end-to-end tests very quickly. The confidence level we get from those tests
    is very high because they test the whole stack, including HTTP, not just some
    scattered pieces, leading to a very high level of code coverage per test case.
    Of course, integration tests are slower, yet not that slow. It is up to you to
    create the right balance of unit and integration tests. In this case, I focused
    on grey-box integration testing, which led to 13 tests covering 97.2% of the lines
    and 63.1% of the branches. The guard clauses represent most of the branches that
    we do not test. We could write a few unit tests to boost the numbers if we’d like.
  prefs: []
  type: TYPE_NORMAL
- en: We explored white-, grey- and black-box testing in *Chapter 2*, *Automated Testing*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s start by exploring the AddItem tests.
  prefs: []
  type: TYPE_NORMAL
- en: AddItemTest
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `AddItem` feature is the first use case we explored. We need three tests
    to cover all scenarios but the `Handler` class guard clauses.
  prefs: []
  type: TYPE_NORMAL
- en: First test method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following grey-box integration test ensures an HTTP POST request adds the
    item to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Arrange* block of the preceding test case creates a test application and
    an `HttpClient`. It then sends an `AddItem.Command` to the endpoint in its *Act*
    block.Afterward, it splits the *Assert* block in two: the HTTP response and the
    database itself. The first part ensures that the endpoint returns the expected
    data. The second part ensures that the database is in the correct state.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a good habit to ensure the database is in the correct state, especially
    with EF Core or most Unit of Work implementations, because one could add an item
    and forget to save the changes leading to an incorrect database state. Yet, the
    data returned by the endpoint would have been correct.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We could test more or less elements here. We could refactor the *Assert* block
    so it becomes more elegant. We can and should continuously improve all types of
    code, including tests. However, in this case, I wanted to keep as much of the
    logic in the test method to make it easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: It is also a good practice to keep test methods as independent as possible.
    This does not mean that improving readability and encapsulating code into helper
    classes or methods is wrong; on the contrary.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The only opaque piece of the test method is the `C18WebApplication` class, which
    inherits from the `WebApplicationFactory<Program>` class and implements a few
    helper methods to simplify the configuration of the test application. You can
    treat it as an instance of the `WebApplicationFactory<Program>` class. Feel free
    to browse the code on GitHub and explore its inner workings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an `Application` class is a good reusability pattern. However, creating
    an application per test method is not the most performant because you are booting
    the entire program for every test.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use test fixtures to reuse and share an instance of the program between
    multiple tests. However, remember that the application's state and potentially
    the database are also shared between tests.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: To the second test, next.
  prefs: []
  type: TYPE_NORMAL
- en: Second test method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This test ensures that the `Location` header contains a valid URL. This test
    is important since the `Baskets` and the `Products` features are loosely coupled
    and can change independently. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test method is similar to the first one. The *Arrange* block creates
    an application, seeds the database, and creates an `HttpClient`. The `SeedAsync`
    method is one of the helper methods of the `C18WebApplication` class.The *Act*
    block sends a request to create a basket item.The *Assert* block is divided in
    two. The first ensures that the HTTP response contains a `Location` header and
    that the status code is 201\. The second part (highlighted) takes the `Location`
    header and sends an HTTP request to validate the URL’s validity. This test ensures
    that if we change the URL of the `Products.FetchOne` endpoint, say we prefer `/catalog`
    over `/products`, this test will alert us.We explore the third test case next.
  prefs: []
  type: TYPE_NORMAL
- en: Third test method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The last test method ensures that the endpoint responds with a 409 Conflict
    status when a consumer tries to add an existing item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test method is very similar to the other two.The *Arrange* block
    creates a test application, seeds the database, and creates an `HttpClient`.The
    *Act* block sends a request using the only item in the database, which we expect
    to result in a conflict.The first part of the *Assert* block ensures that the
    endpoint returns the expected `ProblemDetails` object. The second part validates
    that the endpoint has not changed the quantity in the database.With those three
    tests, we are covering the relevant code of the `AddItem` feature.The other test
    cases are similar, sending HTTP requests and validating the database content.
    Each feature has between one and three tests. We explore a test related to the
    `UpdateQuantity` feature next.
  prefs: []
  type: TYPE_NORMAL
- en: UpdateQuantityTest
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We did not cover the `UpdateQuantity` feature, but one of its branches is that
    if the current quantity and the new quantities are the same, the endpoint will
    not update the data. Here’s the snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this use case, we subscribe to the `SavedChanges` event on the EF Core
    `DbContext`, then ensure the code never calls it. This uses no mocks or stubs
    and tests the real code.This test stands out of the lot, so I considered it worth
    exploring before moving on. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test method should sound very familiar by now. However, we use
    a different pattern here.In the *Arrange* block, we create a test application
    and seed the database, but we do not create an `HttpClient`. We use the `ServiceProvider`
    to create the dependencies instead. Then manually instantiate the `UpdateQuantity.Handler`
    class. This allows us to customize the `BasketContext` instance to assess whether
    the endpoint called its `SaveChange` method (highlighted code).The *Act* block
    invokes the `HandleAsync` method directly with a command that should not trigger
    the update because the item has the same quantity as the one we seeded. Unlike
    the other tests, we are not sending an HTTP request.The *Assert* block is simpler
    than the other tests we explored because we test the method, not the HTTP response
    or the database. In this case, we only care whether the `saved` variable is `true`
    or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: This test is much faster than the other because no HTTP is involved. When calling
    the `CreateClient` method of a `WebApplicationFactory<T>` object (the `C18WebApplication`
    class in this case), it starts the webserver and then creates the `HttpClient`,
    which has a significant performance overhead.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember this tip when you have to optimize your test suites.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: And we are done; the test knows whether or not the `DbContext`’s `SavedChanges`
    method was called. Let’s summarize what we learned before moving to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We delved into the Request-EndPoint-Response (REPR) design pattern and learned
    that REPR follows the most foundational pattern of the web. The client sends a
    request to an endpoint, which processes it and returns a response. The pattern
    focuses on designing the backend code around the endpoint, making it faster to
    develop, easier to find your way around the project, and more focused on features
    than MVC and layers.We also took a CQS approach around the requests, making them
    queries or commands, depicting all that can happen in a program: read or write
    states.We explored ways to organize the code around such a pattern, from implementing
    trivial to more complex features. We built a technology stack to create an e-commerce
    web application that leverages the REPR pattern and a feature-oriented design.
    We learned how to leverage middleware to handle exceptions globally and how the
    *ExceptionMapper* library provides us with this capability. We also used grey-box
    testing to cover almost all of the project''s logic with just a few tests.Next,
    we explore microservices architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Must we use the *FluentValidation* and *ExceptionMapper* libraries when implementing
    the REPR pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three components of the REPR pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the REPR pattern dictate that we use nested classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are grey-box integration tests provide much confidence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name an advantage of handling exceptions using middleware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few links to build upon what we learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'FluentValidation: [https://adpg.link/xXgp](https://adpg.link/xXgp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FluentValidation.AspNetCore.Http: [https://adpg.link/qsao](https://adpg.link/qsao)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ExceptionMapper: [https://adpg.link/ESDb](https://adpg.link/ESDb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mapperly: [https://adpg.link/Dwcj](https://adpg.link/Dwcj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MVC Controllers are Dinosaurs - Embrace API Endpoints: [https://adpg.link/NGjm](https://adpg.link/NGjm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No. REPR does not dictate how to implement it. You can create your own stack
    or go barebone ASP.NET Core minimal API and implement everything by hand in the
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: REPR consists of a request, an endpoint, and a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. REPR does not prescribe any implementation details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grey-box integration tests provide much confidence in their outcome because
    they test the feature almost end-to-end, ensuring all the pieces are there, from
    the services in the IoC container to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling exceptions using middleware allows for centralizing the management
    of exceptions, encapsulating that responsibility in a single place. It also provides
    for uniformizing the output, sending the clients a response in the same format
    for all errors. It removes the burden of handling each exception individually,
    eliminating `try`-`catch` boilerplate code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
