- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a News App Using .NET MAUI Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a news app that leverages the **Shell** navigation
    functionality provided to us by the .NET MAUI team at Microsoft. The old way of
    doing this, which involved using **ContentPage**, **FlyoutPage**, **TabbedPage**,
    or **NavigationPage** as the main page, as we did in *Chapter 2*, still works,
    but we are sure that you will enjoy the new way of defining the structure of your
    app. Also, you can mix and match the old and new.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to define an app structure
    using Shell, consume data from a REST API, configure navigation, and pass data
    between views using query-style routes.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is Shell, then? In Shell, you define the structure of your app using
    **Extensible Application Markup Language** (**XAML**) instead of hiding it in
    spread-out pieces of code in your app. You can also navigate using routes, just
    like those fancy web developers are doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Shell navigation page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a flyout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a navigation bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating using routes and passing data in query strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming data from a public **representational state transfer** (**REST**)
    **application programming** **interface** (**API**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding content in the form of a `CollectionView` control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to complete this project, you will need to have Visual Studio for
    Mac or Windows installed, as well as the necessary .NET MAUI workload components.
    See *Chapter 1*, *Introduction to .NET MAUI*, for more details on how to set up
    your environment.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a .NET MAUI project using the **single-project** feature as
    the code-sharing strategy. It will contain two parts, detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we will create views and make them navigable using Shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second part, we will add some content by consuming a **REST API** for
    news
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part is not needed to learn about Shell, but it will take you a bit
    further down the road to a complete app.
  prefs: []
  type: TYPE_NORMAL
- en: The build time for this project is about 1.5 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Building the news app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be all about building a news app from the beginning. It will
    guide you through every step, but it will not go into every detail. For that,
    we recommend *Chapter 2*, *Building Our First .NET MAUI App*, which goes into
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project, like all the rest, is a **File** | **New** | **Project...**-style
    project. This means that we will not be importing any code at all. So, this first
    section is all about creating the project and setting up the basic project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to create a new .NET MAUI project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Visual Studio 2022 and select **Create a** **new project**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Visual Studio 2022](img/Figure_4.1_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Visual Studio 2022
  prefs: []
  type: TYPE_NORMAL
- en: This will open the **Create a new** **project** wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the search field, type in `maui` and select the **.NET MAUI App** item from
    the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Create a new project](img/Figure_4.2_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Create a new project
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `News` as the name of the app, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Configure your new project](img/Figure_4.3_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Configure your new project
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step will prompt you for the version of .NET Core to support. At the
    time of writing, .NET 6 is available as **Long-Term Support** (**LTS**), and .NET
    7 is available as **Standard Term Support**. For this book, we will assume that
    you will be using .NET 7:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Additional information](img/Figure_4.4_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Additional information
  prefs: []
  type: TYPE_NORMAL
- en: Finalize the setup by clicking **Create** and wait for Visual Studio to create
    the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it for project creation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by setting up the structure of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the structure of the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will start to build the **Views** and **ViewModels** of
    the app. The *Using MVVM – creating views and ViewModels* section in *Chapter
    2* contains more details on **Model-View-ViewModel** (**MVVM**) as a design pattern.
    It’s recommended that you read that first if you don’t know what MVVM is.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ViewModel base class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ViewModel` is the mediator between `View` and `Model`. Let’s create a base
    class for `ViewModels` with common functionality that we can reuse. In practice,
    `ViewModel` must implement an interface called `INotifyPropertyChanged` for MVVM
    to function. We will do so in the base class and will also add a little handy
    helper tool called **CommunityToolkit.Mvvm** that will save us a lot of time.
    Again, please check out *Chapter 2*, *Building Our First .NET MAUI App*, if you
    are feeling unsure about MVVM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a base class. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, create a folder called `ViewModels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ViewModels` folder, create a class called `ViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the existing class so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Excellent! Let’s implement `INotifyPropertyChanged` in the base `ViewModel`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: A quick recap of CommunityToolkit.Mvvm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CommunityToolkit.Mvvm is a NuGet package that contains a few source generators
    that can automatically generate the necessary implementation details for `INotifyPropertyChanged`.
    More specifically, it will inject a call that will raise the `PropertyChanged`
    event whenever a setter is called. It also takes care of property dependencies;
    if I change the `FirstName` property, the `FullName` read-only property will also
    get a `PropertyChanged` event. Before CommunityToolkit.Mvvm, you would have had
    to write this code manually.
  prefs: []
  type: TYPE_NORMAL
- en: It’s all explained in more detail in *Chapter 2*, *Building Our First .NET MAUI
    App*. Have you read it yet?
  prefs: []
  type: TYPE_NORMAL
- en: Adding a reference to CommunityToolkit.Mvvm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'CommunityToolkit.Mvvm and its dependencies are installed using NuGet. So, let’s
    install the NuGet package:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, install the CommunityToolkit.Mvvm NuGet package, version
    8.0.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept any license dialog boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will install the relevant NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing INotifyPropertyChanged
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`ViewModel` sits between `View` and `Model`. When a change in `ViewModel` occurs,
    `View` must be notified. The mechanism for this is the `INotifyPropertyChanged`
    interface, which defines an event that the controls in `View` subscribe to. The
    `ObservableObject` attribute is the magic that will generate the `INotifyPropertyChanged`
    implementation for us. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open up `ViewModels.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This instructs CommunityToolkit.Mvvm to implement the `INotifyPropertyChanged`
    interface. The next step is all about reducing the number of lines of code that
    we will have to write. Normally, you would have to manually raise the `PropertyChanged`
    event from your code, but thanks to source generators, which write code at build
    time, we simply have to create normal properties and let CommunityToolkit.Mvvm
    do the magic.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on and create our first `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HeadlinesViewModel class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will now start to create some `View` and `ViewModel` placeholders that we
    will expand on during this chapter. We will not directly implement all graphical
    features; instead, we’ll keep it simple and think of all these pages as placeholders
    for what’s to come next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the `HeadlinesViewModel` class, which will serve as the `ViewModel`
    for `HeadlinesView`. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, under the `ViewModels` folder, create a new class called
    `Head``linesViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the class so that it inherits from the `ViewModel` base class, as shown
    in bold in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OK – not bad. It doesn’t do much yet, but we’ll just leave it for now. Let’s
    create the matching view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating HeadlinesView
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This view will eventually show a list of news, but for now, it will be kept
    simple. Follow these steps to create the page:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, create a folder named `Views`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Views` folder, select **Add**, and then click **New Item...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up. Otherwise, move on to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `HeadlinesView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add** to create the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot to view the preceding information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Add New Item](img/Figure_4.5_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Add New Item
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some placeholder code to `HeadlinesView`, just to have something
    to navigate to and from. We will replace it with something hotter later on in
    this chapter, but to keep things simple, let’s add a label. To do so, proceed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, under the `Views` folder, open `HeadlinesView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the XAML code by adding the following code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will set the title of the page and add a label with the text `HeadlinesView`
    centered in the middle of the page. Let’s move on and create some additional view
    placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ArticleItem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The app will eventually display a list of articles where each article will be
    rendered using a reusable component. We will call this reusable component `ArticleItem`.
    In .NET MAUI, a reusable component is called a **ContentView**. Please don’t confuse
    this with an MVVM View, which is represented by a page in .NET MAUI. We know that
    this is confusing, but the rule is that a .NET MAUI page is an MVVM View and a
    .NET MAUI ContentView is essentially a reusable control.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let’s create the `ArticleItem` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, right-click the `Views` folder, select **Add**, and then
    click **New Item...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up. Otherwise, move on to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Important*: Make sure that you select the **ContentView** template in the
    next step and *not* the **ContentPage** template.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select `ArticleItem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add** to create the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot to view the preceding information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Add New Item – ArticleItem.xaml](img/Figure_4.6_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Add New Item – ArticleItem.xaml
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to alter the XAML code that’s been generated at this point, so
    we’ll simply leave it as is.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ArticleView
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the previous section, we created the `ArticleItem` content view. This view
    (`ArticleView`) will contain `WebView` to display each article. But for the moment,
    let’s just add `ArticleView` as a placeholder. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, right-click the `Views` folder, select **Add**, and then
    click **New Item...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up. Otherwise, move on to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **.NET MAUI** under the **C# Items** node on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `ArticleView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add** to create the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since this view is also a placeholder view at the moment, we’ll just add a
    label to indicate the type of page. Edit the content by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open `ArticleView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the XAML code by adding the following code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Alright – just one more view to mock before we can start to wire things up.
  prefs: []
  type: TYPE_NORMAL
- en: Creating AboutView
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last view will be created in the same way as all the others. Proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, right-click the `Views` folder, select **Add**, and then
    click **New Item...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `AboutView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add** to create the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This view is the only view that will stay a placeholder view. It’s up to you
    to do something with it if you choose to build something cool out of this project
    later. So, we will only add a label that states that this is `AboutView`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open `AboutView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the XAML code by adding the following code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have all the views we need to start wiring the app up. The first
    step is to configure dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By using dependency injection as a pattern, we can keep our code cleaner and
    more testable. This app will use constructor injection, which means that all dependencies
    that a class has must be passed through its constructor. The container then constructs
    objects for you, so you don’t have to care too much about the dependency chain.
    Since .NET MAUI already includes a dependency injection framework, called Microsoft.Extensions.DependencyInjection,
    there is nothing extra to install.
  prefs: []
  type: TYPE_NORMAL
- en: Confused about dependency injection?
  prefs: []
  type: TYPE_NORMAL
- en: Check out the *Wiring up a dependency injection* section in *Chapter 2*, *Building
    Our First .NET MAUI App*, for more details on dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Registering Views and ViewModels with dependency injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When registering classes with the container, it is recommended to use extension
    methods to group the types. The extension methods will take a single parameter
    and return a single value, the `MauiAppBuilder` instance. This is how the `CreateMauiApp`
    method. For this app, we have `Views` and `ViewModels` to register for now. Let’s
    create the method:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open the `MauiProgram.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to the `MauiProgram` class; the changes are highlighted
    in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The .NET MAUI `MauiAppBuilder` class exposes the `Services` property, which
    is the dependency injection container. We simply need to add the types we want
    dependency injection to know about; the container will do the rest for us. Think
    of a builder as something that collects a lot of information on what needs to
    be done, and then finally builds the object we need. It’s a very useful pattern
    on its own, by the way.
  prefs: []
  type: TYPE_NORMAL
- en: We're only using the builder for one thing at the moment. Later on, we will
    use it to register any class in the assembly that inherits from our abstract `ViewModel`
    class. The container is now prepared for us to ask for these types.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to make some graphical touches to our app. We will rely on **Font
    Awesome** to do the magic.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and configuring Font Awesome
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Font Awesome is a free collection of images packaged into a font. .NET MAUI
    has excellent support for using Font Awesome in toolbars, navigation bars, and
    all over the place. It’s not strictly needed to make this app, but we think that
    it’s worth the extra round trip since you are most likely going to need something
    like this in your new killer app.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to download the font.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Font Awesome
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Downloading the font is straightforward. Please note the renaming of the file
    – it’s not needed but it’s easier to edit configuration files and such if they
    have simpler names. Follow these steps to acquire and copy the font to each project:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to [https://fontawesome.com/download](https://fontawesome.com/download).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Free for Desktop** button to download Font Awesome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the downloaded file, then locate the `otfs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Font Awesome 5 Free-Solid-900.otf` file to `FontAwesome.otf` (you
    can keep the original name, but it’s just less to type if you rename it). Your
    filename may be different since Font Awesome is continually updating but it should
    be similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `FontAwesome.otf` to the `Resources/Fonts` folder in the `News` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alright – now, we need to register Font Awesome with .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring .NET MAUI to use Font Awesome
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It would be nice if all we needed to do was to copy the font file into the
    project folders. A lot does happen with just that action. The default .NET MAUI
    template includes all the fonts in the `Resources/Fonts` folder with the following
    item definition in the `News.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that the font files are processed and included in the app package
    automatically. What is left is to register the font with the .NET MAUI runtime
    so that it is available to our XAML resources. To do that, add the following highlighted
    line to the `MauiProgram.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This line adds an alias that we can use in the next section to create static
    resources. The first parameter is the filename for the font file, while the second
    is the alias for the font that we can use in the `FontFamily` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: All that is left is to define some icons in a resource dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Deﬁning some icons in the resource dictionary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have defined the font, we will put that to use and define five icons
    to use in our app. We’ll add the XAML first; then, we’ll examine one of the `FontImage`
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open `App.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code marked in bold under the existing `ResourceDictionary.MergedDictionaries`
    tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`FontImage` is a class that can be used anywhere in .NET MAUI that expects
    an `ImageSource` object. It’s designed to render one character (or glyph) into
    an image. The `FontImage` class needs a few attributes to work, detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A key for reference that will be used by other views in the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `FontFamily` resource that uses the alias reference back to the `Font` resource
    that we defined in the preceding section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Glyph` object, which represents the image to be shown. To find which image
    these cryptic values refer to, check out [fontawesome.com](http://fontawesome.com),
    click on **Icons**, select **free and open-source icons**, and start browsing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Size` and `Color`. These are not strictly needed but they’re nice to define.
    They are used for a few of the icons in this app so that they render properly
    for light themes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Font Awesome is now installed and configured. We’ve done a lot of work to get
    to the actual topic of this chapter. It’s time to define the shell!
  prefs: []
  type: TYPE_NORMAL
- en: Defining the shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As stated earlier, .NET MAUI Shell is the newest way of defining the structure
    of your app. The different projects in this book use alternate ways of defining
    the overall structure of the app, but .NET MAUI Shell is, in our opinion, the
    best way of defining the UI structure. We hope you find it as exciting as we do!
  prefs: []
  type: TYPE_NORMAL
- en: Deﬁning the basic structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’re going to start by defining a basic structure for the app without really
    adding any of our defined views to it. After that, we’ll add the actual views
    one by one. But let’s start by adding some content and creating `ContentPage`
    objects using XAML directly. Follow these two steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open the `AppShell.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter the file so that it looks like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s break this down. First, by default, the .NET MAUI Shell template disables
    the flyout menu. Since we want to use it in this app, you must remove the line
    that disables it. The direct children of Shell itself are two `FlyoutItem` objects
    and one `ShellContent` object. All three of these have `Title` and `Icon` properties
    defined, as shown in the following screenshot. The icons are referenced to the
    Font Awesome resources we created earlier. This will render a flyout, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The app flyout](img/Figure_4.7_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The app flyout
  prefs: []
  type: TYPE_NORMAL
- en: The flyout is accessible by swiping in from the left. `Flyout` objects can have
    multiple children, while the `ShellContent` element can only have a single child.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ShellContent` with a page with the title **Headlines** and a tab that
    defines two child pages on its own. The first level of children will render the
    tab bar at the bottom of the app, as shown in the following screenshot. The second
    level of children, under the **Tab** element with the **News** title, will be
    rendered as a tab bar directly under the title of the navigation bar at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The Shell tabs and pages](img/Figure_4.8_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The Shell tabs and pages
  prefs: []
  type: TYPE_NORMAL
- en: The **Settings** and **About** flyouts will simply render the pages that they
    define.
  prefs: []
  type: TYPE_NORMAL
- en: Making the app run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to try the app out and see whether it looks like the screenshots shown
    throughout this chapter. The app should now run. If not, stay calm and simply
    go through the code again. Once you are done navigating around the app, we can
    create a news service to fetch news from, and extend all those views that we’ve
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the news service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find cool content, we’ll consume an already existing `News` API provided
    by [newsapi.org](http://newsapi.org). To do so, we must register for an API key
    that we can use to request the news. If you aren’t comfortable with doing so,
    you can mock the news service if you would like, instead of using the API.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we must do is obtain an API key.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining an API key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of registering is pretty straightforward. Be aware, however, that
    the UI of [newsapi.org](http://newsapi.org) might have changed by the time you
    read this.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK – let’s get that key:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to [https://newsapi.org/](https://newsapi.org/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Get** **API key**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill out the form, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 4.9 – Register for API \uFEFFkey](img/Figure_4.9_B19214.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Register for API key
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the API key provided on the next page, as illustrated in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Registration complete](img/Figure_4.10_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Registration complete
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a place to store the key for easy access. We’ll create a static
    class that will hold the key for us. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, create a new class called `Settings` in the root folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code shown in the following snippet, replacing the placeholder text
    with the API key you obtained in the preceding steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The important thing here is that you copy and paste the key into the file. Now,
    we need models.
  prefs: []
  type: TYPE_NORMAL
- en: A note on tokens and other secrets
  prefs: []
  type: TYPE_NORMAL
- en: This is not a recommended way to store an API key or any other token that should
    be secured in your app. To securely store tokens and other data, you should use
    **secure storage** (see [https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/storage/secure-storage](https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/storage/secure-storage))
    and obtain the data from a secure server, preferably gated by some form of user
    authentication. You could also require the user to provide the API key through
    a settings page – hint, hint.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The data returned from the API needs to go somewhere, and the most convenient
    way of accessing it would be to deserialize the data into `Models`. Let’s create
    our models:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, create a new folder called `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Models` folder, add a new class called `NewsApiModels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `JsonPropertyName` attributes on each property allow the `System.Text.Json`
    deserializer to map the name from the JSON received from the web API into the
    C# object. When we call the API, the API will return a `NewsResult` object that
    will, in turn, contain a list of articles. The next step is to create a service
    that will wrap the API and allow us to access the latest news.
  prefs: []
  type: TYPE_NORMAL
- en: Tip for creating POCO classes
  prefs: []
  type: TYPE_NORMAL
- en: If you ever need to create a class model out of a bunch of **JavaScript Object
    Notation** (**JSON**), you can use the **Paste JSON as Classes** tool in Visual
    Studio for Windows (**Edit** | **Paste Special** | **Paste JSON** **as Classes**).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The service class will wrap the API so that we can access it in a nice .NET-ish
    kind of way.
  prefs: []
  type: TYPE_NORMAL
- en: But we’ll start by defining an enum that will define the scope of the news that
    we request.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the NewsScope enum
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `NewsScope` enum defines the different kinds of news that our service supports.
    Let’s add it by following these few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, create a new folder called `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Services` folder, add a new file called `NewsScope.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to create the `NewsService` class that will wrap the call to
    the `News` API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the NewsService class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The purpose of the `NewsService` class is to wrap the HTTP calls to the news
    REST API and make them easily accessible to our code in the form of regular .NET
    method calls. To make it easier to replace the source of the news – for example,
    to use a mock in tests – we will use an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the `INewsService` interface, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Services` folder, create a new interface called `INewsService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the interface so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Creating the `NewsService` class is now quite straightforward. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Services` folder, create a new class called `NewsService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the class so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `NewsService` class is composed of five methods; I know there are technically
    eight, but we will get to that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The first method, `GetNews`, is the method that we will eventually call from
    our app. It takes one parameter, `scope`, which is the enum that we created earlier.
    Depending on the value of this parameter, we will get different types of news.
    The first thing this method does is resolve the URL to call, and it does so by
    calling the `GetUrl` method with the scope.
  prefs: []
  type: TYPE_NORMAL
- en: The `GetUrl` method uses a switch expression to resolve the URL and, depending
    on the value of the scope parameter passed, returns one of three URLs. The URL
    points to the REST API of the `News` API with some predefined query parameters
    and the API key that we registered for.
  prefs: []
  type: TYPE_NORMAL
- en: When we’ve resolved the correct URL, we are ready to make the HTTP request and
    download the news in the form of JSON. The built-in `HttpClient` class in .NET
    does a fine job of fetching the JSON for us. All that is left after acquiring
    the data is to deserialize it into the news models that we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say a word or two about the remainder of the methods and the `HttpClient`
    class. `HttpClient` is now the recommended class to use when requesting data from
    the web. It is a much safer implementation than was previously available. It has
    been shipping with .NET 5+ and is available as a separate NuGet package for previous
    versions. With that, there are a few peculiarities when using `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: First, `HttpClient` can hold onto native resources, so it must be properly disposed
    of. To properly dispose of `HttpClient`, we need to derive from and implement
    `IDisposable`. This is the reason for the extra methods that are in the class,
    `Dispose(bool)` and `Dispose()`. All they do is make sure that the instance of
    `HttpClient` is disposed of properly.
  prefs: []
  type: TYPE_NORMAL
- en: Second, `HttpClient` will pool those native resources, so it is recommended
    that you reuse an instance of `HttpClient` as much as possible. This is the reason
    for creating the `HttpClient` instance in the `NewsService` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Final word – since the `GetFromJsonAsync` call can throw an exception and it
    is called from an `async` method, you must handle the exception; otherwise, it
    will be lost on the executing thread and your only indication that something is
    wrong will be the fact that you have no items. For this app, we are just going
    to create a `NewsResult` object that contains one `Article` that has the exception
    in it so that something is displayed. There are much better ways of handling errors,
    but this will do for this app.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to wire up the `NewsService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the NewsService class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to wire up the `NewsService` class in our app and integrate
    it with a real news source. We will extend all the existing `ViewModels` that
    we have and define the UI elements to be able to render the news in the `Views`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the HeadlinesViewModel class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In MVVM, `ViewModel` is the place to handle the logic of the app. The model
    is the news data that we will get from our `NewsService` class. We will now extend
    the `HeadlinesViewModel` class so that it uses `NewsService` to fetch news:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, expand the `ViewModels` folder and open the `HeadlinesViewModel.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code marked in bold and resolve the references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we are using (constructor) dependency injection, we need to inject our
    dependencies into the constructor. The only dependency this `ViewModel` has is
    `NewsService`, and we store it internally in the class as a field.
  prefs: []
  type: TYPE_NORMAL
- en: The `CurrentNews` property is defined to get something to bind the UI to.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have two `Initialize` methods – one that takes `scope` as an enum and
    one that takes `scope` as a string. The string overload of the `Initialize` method
    will be used in XAML. It simply translates the string into the enum representation
    of `scope` and then calls the other `Initialize` method, which, in turn, calls
    the `GetNews(...)` method on the news service.
  prefs: []
  type: TYPE_NORMAL
- en: The property at the end, `ItemSelected`, returns a .NET MAUI command that we
    will wire up to respond to when the user of the app selects an item. Half of the
    method is implemented from the start. The selected item will be passed into the
    method. Then, we encode the URL to the article since we will be passing it as
    a query parameter when we navigate within the app. We will get back to the navigation
    part in a while.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about the `ObservableProperty` and `RelayCommand` attributes,
    refresh your memory by reviewing *Chapter 2*, *Building Our First .NET* *MAUI
    App*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the code to fetch the data, we’ll move on to defining the UI
    to display it.
  prefs: []
  type: TYPE_NORMAL
- en: Extending HeadlinesView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`HeadlinesView` is a shared view that will be used in several places in the
    app. The purpose of this view is to display a list of articles and to allow for
    navigation from one article into a web browser that will display the entire article.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To extend `HeadlinesView` we must do two things – first, must we edit the XAML
    and define the UI; then, we need to add some code to initialize it. Proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, expand the `Views` folder and open the `HeadlinesView.xaml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the XAML, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`HeadlinesView` uses `CollectionView` to display the list of articles. The
    `ItemsSource` property is set to the `CurrentNews.Articles` property of `ViewModel`,
    which, after loading news, should contain a list of news. While the list is empty
    or loading, we display a loading label, defined within the `CollectionView.EmptyView`
    element. You could, of course, create any valid UI inside of that tag to create
    a cooler loading screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Each article in the `CurrentNews.Articles` list will be rendered using whatever
    is inside the `CollectionView.ItemTemplate` element, and it’s what’s inside of
    the `ContentView` element that will represent the actual item. The article will
    be rendered using an `ArticleItem` view, which is a custom control that we defined
    earlier. We will define this view after we are done with this view.
  prefs: []
  type: TYPE_NORMAL
- en: To enable navigation from the view, we need to detect when a user clicks on
    a specific article. We can do so by adding `TapGestureRecognizer` and binding
    it to the `ItemSelectedCommand` property of the root `ViewModel`. The `Source={x:Reference
    headlinesview}}` snippet is what references the current context back to the root
    of the page, not the current article in the list that we are iterating. If we
    didn’t specify the source, the binding engine would try to bind the `ItemSelectedCommand`
    property to a property defined in the current article of the `CurrentNews.Articles`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all for the GUI part. Now, we need to alter the code-behind to enable
    initialization based on data that we will pass from the XAML itself. Follow these
    steps to make it happen:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open the `HeadlinesView.xaml.cs` code-behind file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code marked in bold to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Usually, we don’t want to add code to the code-behind of a view directly, but
    we need to make an exception so that arguments can be passed from XAML to our
    `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the routing information that was used to create the view, we will initialize
    `ViewModel` differently. The `GetScopeFromRoute` method will parse the location
    information from `Shell` to determine which scope is used to query the news service.
    Then, we can call a private method that creates an instance of `HeadlinesViewModel`
    for us, sets it as the binding context of the view, and calls the `Initialize()`
    method on `ViewModel`, which makes the REST call to the `News` API. We will define
    the routes when we edit the shell file.
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to extend `ContentView` of `ArticleItem` so that it displays
    a single-row item in the news lists.
  prefs: []
  type: TYPE_NORMAL
- en: Extending ContentView of ArticleItem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ContentView` of `ArticleItem` represents one item in a list of news, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – A sample news item](img/Figure_4.11_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – A sample news item
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the layout shown in *Figure 4**.11*, we will use a `Grid` control.
    Follow these steps to create the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, expand the `Views` folder and open the `ArticleItem.xaml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the XAML code, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding XAML code defines a grid layout with two columns and five rows.
    The `Grid.Row` and `Grid.Column` attributes position child elements into the grid,
    while the `Grid.ColumnSpan` attribute allows for a control to span multiple columns.
  prefs: []
  type: TYPE_NORMAL
- en: A rounded image can be achieved using a `Border` element with `StrokeShape="RoundRectangle
    15,15,15,15"` specified in conjunction with the `Image` `Aspect` attribute set
    to `AspectFill`.
  prefs: []
  type: TYPE_NORMAL
- en: Strings in labels can be formatted directly in the binding statement. Check
    out the `Text="{Binding PublishedAt, StringFormat='{0:MMMM d, yyyy}'}"` line of
    code, which formats a date into a specific string format.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the gray divider line is `BoxView` at the end of the XAML code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created `NewsService` and fixed all its related views, it’s
    time to make use of them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding to dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since `HeadlinesViewModel` depends on `INewsService`, we need to register it
    in our dependency injection container (please see the *Wiring up dependency injection*
    section in *Chapter 2* for more details on dependency injection in .NET MAUI).
    Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open the `MauiProgram.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `RegisterAppTypes()` method and add the following line marked in
    bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow for the dependency injection of `NewsService`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a ContentTemplate attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we only have placeholder code in our `AppShell` file. Let’s replace
    this with actual content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open `AppShell.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `FlyoutItem` element with the title set to `Home`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the XAML so that the `ShellContent` element becomes self-closing, add
    the following `ContentTemplate` attribute marked in bold, and replace the contents
    of the `Tab` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Two things are going on here. The first is that we specify the content of `ShellContent`
    using the `ContentTemplate` attribute. This means that we point to the type of
    view that we want to have created when the shell becomes visible. Usually, you
    want to defer the creation of a view until right before it is going to be displayed,
    and the `ContentTemplate` attribute gives you that. Notice that the `Route` attribute
    for that `FlyoutItem` is set to `headlines`.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing is that we have the same thing going on below for the `Local`
    and `Global` news but instead using the `local` and `global` routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the app at this point, you should end up with something that looks
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The main list view](img/Figure_4.12_B19214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – The main list view
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to implement is how we can view the articles when we
    tap on the item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Handling navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are on the home stretch now for this app. The only thing we need to do is
    implement navigation to the article view, which will display the entire article
    in a web view. Since we are using Shell, we will be navigating using routes. Routes
    can be registered directly in the Shell markup – for example, in the `AppShell.xaml`
    file. We can do this by using `Route` attributes on the `ShellContent` elements,
    as we did in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we will add a route programmatically and register a view
    to handle it for us. We will also create a navigation service to abstract the
    concept of navigation a bit.
  prefs: []
  type: TYPE_NORMAL
- en: So, buckle up, and let’s finish this app!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the navigation service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is to define an interface that will wrap .NET MAUI navigation.
    Why do we do this? Well, it’s a good practice to separate the interfaces from
    the implementation; it makes unit testing easier, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the INavigation interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `INavigation` interface is simple, and we will overshoot the target a little
    bit. We are only interested in the `NavigateTo` method, but we will add the `PushModal()`
    and `PopModal()` methods since it is likely that you will use them if you continue
    extending the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the navigation interface is simple, as the following steps illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, expand the `ViewModels` folder and add a new file called
    `INavigate.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `NavigateTo()` method declaration takes the route we want to navigate to.
    This is the method that we will be calling. The `PushModal()` method adds a new
    page on top of the navigation stack as a modal page, forcing the user only to
    interact with this specific page. The `PopModal()` method removes it from the
    navigation stack. So, if you use the `PushModal()` method, make sure that you
    give the user a way to pop it off the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, you will be stuck viewing the modal page forever.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all for the interface. Let’s create an implementation using .NET MAUI
    Shell.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the INavigate interface using .NET MAUI Shell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The implementation is very straightforward since each method is only calling
    .NET MAUI static methods provided by the Shell API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Navigator` class, as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, add a new class called `Navigator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is simply pass-through code that calls already existing methods. Now, we
    need to register the type with our dependency injection container so that it can
    be consumed by the `ViewModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the Navigator class with dependency injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the `ViewModel` class and its descendants to have access to the `Navigator`
    instance, we will have to register it with the container, just like we did with
    `NewService`; just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open the `MauiProgram.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `RegisterAppTypes` method and add the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can add the `INavigate` interface to the `ViewModel` class and its descendants.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the INavigate interface to the ViewModel class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To be able to access `Navigator`, we must extend the `ViewModel` base class,
    making it available to all `ViewModels`. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open the `ViewModels` folder, and then open the `ViewModel.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `HeadlinesViewModel.cs` file and make the highlighted changes to the
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The base `ViewModel` now exposes the `Navigator` property through the `INavigate`
    interface. At this point, we are ready to wire up the navigation to our `Article`
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating using routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Routes are a very handy way to navigate since they abstract the creation of
    the page away. All we need to know is the route to the view we want to navigate
    to – .NET MAUI Shell takes care of the rest for us. If you are familiar with how
    web navigation works, you might recognize the way that we pass arguments in routes.
    They are passed as query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing the ItemSelected command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Previously, we defined the `ItemSelected` method in the `HeadlinesViewModel`
    class. Now, it’s time to add code that will perform the navigation to `ArticleView`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, expand the `ViewModels` folder and open `HeadlinesViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `ItemSelected` method and add the following line marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we define a route called `articleview` that takes a query-line parameter
    called `url` that points to the URL of the article itself. It will look something
    like this: `articleview?url=www.mypage.com`. Only the data passed after the `url=`
    argument must be `HttpUtility.UrlEncode()` method, which is defined in `System.Web`
    for us.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `NavigateTo()` method call uses this encoded data in the query
    parameter. On the recipient side of the navigation call, we need to handle the
    incoming `url` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Extending ArticleView so that it receives query data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`ArticleView` is responsible for rendering the article for us. To keep things
    simple (and also illustrate that you don’t always need `ViewModel`), we will not
    define `ViewModel` for this class; instead, we will define `BindingContext` as
    an instance of the `UrlWebViewSource` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `ArticleView.xaml.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, expand the `Views` folder and open the `ArticleView.xaml.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code marked in bold to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ArticleView` is dependent on a URL being set, and we do so by defining a set-only
    property called `Url`. When this property is set, it creates a new instance of
    `UrlWebViewSource` with the value of the property and assigns it to the page’s
    `BindingContext`. This setter is called by the Shell framework since we added
    an attribute called `QueryProperty` to the class itself. It takes two arguments
    – the first is which property to set, while the second is the name of the `url`
    query parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the data comes URL encoded, we need to decode it using the `HttpUtility.UrlDecode()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have a binding context that points to the web page we want to
    display. Now, we just need to define `WebView` in the XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Extending ArticleView with WebView
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This page only has one purpose, and that is to display the web page from the
    URL that we passed to it. Let’s add a `WebView` control to the page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, expand the `Views` folder and open `ArticleView.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted XAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `WebView` control will take up all available space in the view. The source
    will be set to `.`, meaning that it will be the same as the `BindingContext` property
    of `ViewModel`. In this case, the `BindingContext` property is a `UrlWebViewSource`
    instance, which is exactly what `WebView` needs to navigate and display the content.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only got one step left – our app needs to know about the `ArticleView`
    route and what to do with it.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the route
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned previously, routes can be added declaratively in the XAML (`Route="MyDucks"`)
    or code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open the `AppShell.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `RegisterRoute()` method takes two arguments – the first is the route we
    want to use, and it’s the one that we specify in the `NavigateTo()` calls. The
    second is the type of page (view) that we want to create – in our case, we want
    to create `ArticleView`.
  prefs: []
  type: TYPE_NORMAL
- en: Cool! That wraps it up. The app should now run, and you should be able to navigate
    to the article from any of your `CollectionViews`. Good work!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to define a navigation structure using .NET
    MAUI Shell, how to navigate to views using routes, and how to pass arguments between
    views in the form of a query string. There is a lot more to Shell, but this should
    get you started and confident enough to start exploring the Shell APIs. Also,
    keep in mind that the Shell APIs are constantly evolving, so make sure you check
    out the latest features available.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to create an API client for an arbitrary REST API, which
    always comes in handy since most of the apps you will write need to communicate
    with a server at some point. There is a very good chance that the server will
    expose its data and functionality through a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in extending the app even further, try designing your
    own `News` API key to be set through the settings.
  prefs: []
  type: TYPE_NORMAL
- en: The next project will be about creating a match-making app, and how to create
    a swiping-enabled yes/no image selector app using nothing but .NET MAUI to render
    and animate cross-platform UI controls.
  prefs: []
  type: TYPE_NORMAL
