<html><head></head><body>
		<div id="_idContainer108">
			<h1 id="_idParaDest-86"><em class="italic"><a id="_idTextAnchor085"/>Chapter 5</em>: Application Profiling and Tracing</h1>
			<p>Application profiling is <a id="_idIndexMarker393"/>the internal examination of the inner workings of a computer program. We use application profiling to measure the performance of a program's internals. This helps us to identify any performance bottlenecks and memory issues. Then, we can use this information to refactor and improve the performance of the program.</p>
			<p>Application tracing<a id="_idIndexMarker394"/> is used to monitor the internal performance of a computer program as it is running. You can trace the execution of your computer program during development, testing, and when released into production.</p>
			<p>When used together, application profiling and application tracing can be very powerful and useful in identifying why computer programs are slow.</p>
			<p>In this chapter, you will learn how to profile your applications to identify any poor areas of performance. You will come to understand code metrics and how to perform static code analysis. In your drive to write more performant code, you will learn how to make use of memory dumps, the loaded modules viewer, debugging, tracing, and <strong class="source-inline">dotnet-counters</strong>. By the time you have completed this chapter, you will have the necessary skills and experience you need to profile and trace your own applications.</p>
			<p>In this chapter, we will be covering the following main topics:</p>
			<ul>
				<li><strong class="bold">Understanding code metrics</strong>: In this section, we will be looking at what application, assembly, namespace, type, method, and field metrics various tools can offer us.</li>
				<li><strong class="bold">Performing static code analysis</strong>: In this section, we will look at performing static code analysis with Visual Studio 2022. And we will be generating metrics for our software that consist of the maintainability index, cyclomatic complex, the depth of inheritance, class coupling, units of source code, and lines of executable code.</li>
				<li><strong class="bold">Generating and viewing memory dumps</strong>: In this section, we will look at how to generate and view memory dumps when a breakpoint is hit in code or when an application is encountered.</li>
				<li><strong class="bold">Viewing loaded modules</strong>: In this section, we will display the <strong class="bold">Modules</strong> window in Visual Studio so that we can view the modules that are loaded into memory by our application and view information about those modules.</li>
				<li><strong class="bold">Debugging your applications</strong>: This section highlights the various debugging options that are available to us.</li>
				<li><strong class="bold">Using tracing and diagnostics tools</strong>: In this section, we will introduce tools that can help us to perform tracing and diagnostics on our software applications. Specifically, we will consider Visual Studio 2022, JetBrains dotMemory, and JetBrains dotTrace.</li>
				<li><strong class="bold">Installing and using dotnet-counters</strong>: In this section, we will install <strong class="source-inline">dotnet-counters</strong> and use them to list .NET processes that can be monitored, list the available counters that we can use to gather performance data, monitor a .NET process, and collect data for that process in a CSV file for post-processing analysis in Excel.</li>
				<li><strong class="bold">Tracking down and fixing a memory leak with dotMemory</strong>: In this section, we will use dotMemory to hunt down a memory leak in a WPF application and fix it.</li>
				<li><strong class="bold">Finding the cause of a UI freeze with dotTrace</strong>: In this section, we will use dotTrace to hunt down the cause of a UI freeze in a WPF application and fix it.</li>
				<li><strong class="bold">Optimizing application performance and memory traffic</strong>: In this section, we will use dotTrace to identify opportunities to improve performance and memory traffic for a WPF application.</li>
			</ul>
			<p>After completing this chapter, you will be skilled in the following things:</p>
			<ul>
				<li>Understanding code metrics and being able to use them to improve code quality and performance</li>
				<li>Performing static code analysis to improve code quality and performance</li>
				<li>Using loaded modules to identify what modules your code uses</li>
				<li>Effectively debugging software</li>
				<li>Effectively tracing software</li>
				<li>Using <strong class="source-inline">dotnet-counters</strong> to perform first-level performance investigations</li>
				<li>Using JetBrains dotMemory to track down memory leaks and fix them</li>
				<li>Using JetBrains dotTrace to track down the cause of UI freezes and fix them</li>
				<li>Using JetBrains dotTrace to track down performance and memory traffic issues and fix them<p class="callout-heading">Note</p><p class="callout">Don't be alarmed if you are asked to access code from previous chapters for some of the examples. Due to the page limitation for chapters, adding code examples for those exercises would have exceeded the count limit for this chapter.</p></li>
			</ul>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Technical requirements</h1>
			<p>The technical requirements to follow along with this chapter are as follows:</p>
			<ul>
				<li>Visual Studio 2022 or higher</li>
				<li>JetBrains dotMemory</li>
				<li>JetBrains dotTrace</li>
				<li>Source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH05">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH05</a></li>
				<li>Optional: Microsoft Excel or some other CSV file viewer</li>
			</ul>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Understanding code metrics</h1>
			<p>In this section, we<a id="_idIndexMarker395"/> will be looking at the code metrics that can be gathered using various tools that are paid for, free, and open source. Source code metrics are extracted from source code and are used to measure the quality and performance of our source code. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Different tools have different metrics that they can measure and calculate. Since each tool is different, it is a good idea for you to see what tools and metrics are available that satisfy your own project's requirements.</p>
			<p>In the upcoming subsections, we will learn about the different code metrics that we can use to measure our code and improve performance.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Application metrics</h2>
			<p>Application metrics <a id="_idIndexMarker396"/>cover your application's complete<a id="_idIndexMarker397"/> source code across assemblies. They give you the big picture regarding how many lines of code your application has, along with how many lines are covered by tests. </p>
			<p>In this section, we will cover, from a high level, the various metrics that certain tools such as the <em class="italic">ndepends</em> tool offer. As part of your own studies, identify different application metrics gathering tools. Then, see what metrics they offer. Choose the tool that best fits your needs. In the next section, the generation of code metrics will be demonstrated using Visual Studio's built-in static code analysis tool to generate the following metrics: the maintainability index, cyclomatic complexity, the depth of inheritance, class coupling, the lines of source code, and the lines of executing code. These and other metrics are described next.</p>
			<p>Although metrics are different between tool vendors, available application metrics might include the following:</p>
			<ul>
				<li><strong class="bold">Lines of Code</strong> (<strong class="bold">LOC</strong>): There<a id="_idIndexMarker398"/> are two types of LOC measurements. They include logical LOC and physical LOC. A logical LOC refers to those lines of code that can span one or more lines and are terminated by either a closing curly brace or a semicolon. A physical LOC refers to actual lines of code including comments and whitespace.</li>
				<li><strong class="bold">Lines of comment</strong>: The <a id="_idIndexMarker399"/>number of lines used for comments.</li>
				<li><strong class="bold">Percentage comment</strong>: This <a id="_idIndexMarker400"/>metric identifies the percentage of code that is made up of comments. It is calculated using this formula: <em class="italic">100 x Lines of Comment/(Lines of Comment + Lines of Code)</em>.</li>
				<li><strong class="bold">IL instructions</strong>: When<a id="_idIndexMarker401"/> your code compiles, it is converted into <strong class="bold">Intermediate Language</strong> (<strong class="bold">IL</strong>) code. Depending on how you code your C# code, this can lead to the generation of a large or small number of IL instructions. It makes sense to measure the number of IL instructions generated by your code. That's because even if the code is small, it could generate many IL instructions. And conversely, a method can be large but generate smaller lines of code compared to the smaller version of the code. The smaller number of IL instructions, the easier the method is to maintain.<p class="callout-heading">Note</p><p class="callout">The company <em class="italic">ndepend</em> has a recommendation on their documentation code-metrics page that states methods that produce IL instructions higher than 100 are hard to understand and maintain. Additionally, they state that unless the methods are autogenerated by code generation tools, methods that produce 200 lines or more of IL instructions are extremely complex and should be split into smaller methods.</p></li>
				<li><strong class="bold">Application assemblies</strong>: The<a id="_idIndexMarker402"/> application assembly count.</li>
				<li><strong class="bold">Application namespaces</strong>: The<a id="_idIndexMarker403"/> application namespace count.</li>
				<li><strong class="bold">Application methods</strong>: The <a id="_idIndexMarker404"/>application method count.</li>
				<li><strong class="bold">Application fields</strong>: The <a id="_idIndexMarker405"/>application field count.</li>
				<li><strong class="bold">Lines of code covered</strong>: The <a id="_idIndexMarker406"/>number of lines covered by tests.</li>
				<li><strong class="bold">Lines of code not covered</strong>: The<a id="_idIndexMarker407"/> number of lines not covered by tests.</li>
			</ul>
			<p>Now we will cover what assembly metrics are and what types of metrics can be gathered.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Assembly metrics</h2>
			<p>Assembly metrics<a id="_idIndexMarker408"/> are more focused on measuring the quality and stability of individual assemblies. Since an application can consist of many assemblies, problems can arise in any one or more of those assemblies. If multiple assemblies rely on one poorly performing assembly, then the whole application will be affected. Additionally, it is good to be able to reuse assemblies in different projects, so coupling should be kept to an absolute minimum.</p>
			<p>Gathering <a id="_idIndexMarker409"/>assembly metrics enables you to understand how your assemblies are coupled together, and you can also see how abstract and stable or unstable they are. Additionally, you can determine whether they are reusable in their current form based on those metrics. The various metrics that are available to measure assembly source code include the following:</p>
			<ul>
				<li><strong class="bold">Afferent coupling</strong>: This<a id="_idIndexMarker410"/> is the count of classes in other assemblies that rely on classes within the current assembly.</li>
				<li><strong class="bold">Efferent coupling</strong>: This is <a id="_idIndexMarker411"/>the count of classes in the current assembly that depend upon classes in other packages.</li>
				<li><strong class="bold">Relational cohesion</strong>: The<a id="_idIndexMarker412"/> average count of internal relationships per type within an assembly.</li>
				<li><strong class="bold">Instability</strong>: The <a id="_idIndexMarker413"/>ratio of efferent coupling to total coupling.</li>
				<li><strong class="bold">Abstractness</strong>: The<a id="_idIndexMarker414"/> ratio of internal abstract classes and interfaces to internal types.</li>
				<li><strong class="bold">Distance from the main sequence</strong>: A number that indicates the balance between<a id="_idIndexMarker415"/> abstractness and stability.</li>
			</ul>
			<p>Now, let's look at what namespace metrics are and what kind of metrics can be gathered.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Namespace metrics</h2>
			<p>Namespaces<a id="_idIndexMarker416"/> are an important part of any professional <a id="_idIndexMarker417"/>quality API. Correctly partitioning your code into relevantly named namespaces helps programmers understand your API and find what they are looking for more easily. Namespace metrics help you to understand whether you have dependency cycles and whether your assemblies are high-level, mid-level, or low-level.</p>
			<p>The metrics that are available concerning the code quality of namespaces include the following:</p>
			<ul>
				<li><strong class="bold">Afferent coupling</strong>: The<a id="_idIndexMarker418"/> count of namespaces that directly depend on the current namespace.</li>
				<li><strong class="bold">Efferent coupling</strong>: The<a id="_idIndexMarker419"/> count of different namespaces that the current namespace depends on.</li>
				<li><strong class="bold">Level</strong>: The<a id="_idIndexMarker420"/> level value of a namespace. This metric can help you identify dependency cycles. Additionally, it helps you objectively classify your assemblies, namespaces, methods, and types as high-level, mid-level, or low-level.</li>
			</ul>
			<p>It's time to look at what type metrics are and the type of metrics that can be gathered.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Type metrics</h2>
			<p>Type refers<a id="_idIndexMarker421"/> to <a id="_idIndexMarker422"/>class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types. </p>
			<p>Types and how they are coded and used are behind all the problems we experience as programmers and end users. Understanding how they are used in our programs is an effective way of identifying a variety of issues with our code. When problems are identified, they can be rectified.</p>
			<p>Type code quality metrics include the following:</p>
			<ul>
				<li><strong class="bold">Type rank</strong>: A <a id="_idIndexMarker423"/>computed value that is computed based on the application of a ranking algorithm, similar to Google's PageRank algorithm, on types dependencies graph.</li>
				<li><strong class="bold">Afferent coupling</strong>: The<a id="_idIndexMarker424"/> count of types that depend upon the current type.</li>
				<li><strong class="bold">Efferent coupling</strong>: The<a id="_idIndexMarker425"/> count of types that the current type directly depends on.</li>
				<li><strong class="bold">Lack of cohesion methods</strong>: For<a id="_idIndexMarker426"/> the code to adhere to<a id="_idIndexMarker427"/> the <strong class="bold">single responsibility principle</strong> (<strong class="bold">SRP</strong>), it will have only one reason to change, and no more.</li>
				<li><strong class="bold">Cyclomatic complexity</strong>: The<a id="_idIndexMarker428"/> count of pathways through a method.</li>
				<li><strong class="bold">IL cyclomatic complexity</strong>: The <a id="_idIndexMarker429"/>count of pathways through IL code.</li>
				<li><strong class="bold">Size of instance</strong>: The<a id="_idIndexMarker430"/> size, in bytes, of the instances of the specified type.</li>
				<li><strong class="bold">Interfaces implemented</strong>: The <a id="_idIndexMarker431"/>count of interfaces implemented.</li>
				<li><strong class="bold">Association between classes</strong>: The<a id="_idIndexMarker432"/> count of members from other types that are directly used in the body of the methods of the current type.</li>
				<li><strong class="bold">The number of children</strong>: The<a id="_idIndexMarker433"/> count of subclasses for a class, or the count of types that implement an interface.</li>
				<li><strong class="bold">Depth of inheritance tree</strong>: The <a id="_idIndexMarker434"/>count of base classes for a class or structure.</li>
			</ul>
			<p>Now we will look at what method metrics are and the types of method metrics that can be gathered.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Method metrics</h2>
			<p>Normally, methods <a id="_idIndexMarker435"/>are behind most performance issues. It is <a id="_idIndexMarker436"/>the method within a class that executes instructions that can cause any number of issues for your customers. These problems can include runtime errors, data errors, and performance issues. Being able to see and understand how a method interacts with other methods can be a real big help in solving various issues including performance issues. The method metrics that are available for analyzing the code quality of methods include the following:</p>
			<ul>
				<li><strong class="bold">Method rank</strong>: A<a id="_idIndexMarker437"/> computed value based on the application of a ranking algorithm, similar to Google's PageRank algorithm, on the method dependencies graph.</li>
				<li><strong class="bold">Afferent coupling</strong>: The <a id="_idIndexMarker438"/>count of methods that directly depend upon the current method.</li>
				<li><strong class="bold">Efferent coupling</strong>: The <a id="_idIndexMarker439"/>count of methods that the current method directly depends on.</li>
				<li><strong class="bold">IL nesting depth</strong>: The<a id="_idIndexMarker440"/> maximum count of encapsulated scopes inside a method body computed from the IL code.</li>
				<li><strong class="bold">Parameters</strong>: The<a id="_idIndexMarker441"/> number of parameters used in the method signature.</li>
				<li><strong class="bold">Variables</strong>: The<a id="_idIndexMarker442"/> method body variable count.</li>
				<li><strong class="bold">Overloads</strong>: The <a id="_idIndexMarker443"/>method overload count.</li>
				<li><strong class="bold">Percentage branch coverage</strong>: The<a id="_idIndexMarker444"/> percentage of branches covered by tests generated from opcodes.</li>
			</ul>
			<p>The final metrics that we will look at are field metrics.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Field metrics</h2>
			<p>The <a id="_idIndexMarker445"/>metrics <a id="_idIndexMarker446"/>available for measuring coupling at the <a id="_idIndexMarker447"/>field level is <strong class="bold">afferent coupling</strong>. This refers to the count of methods that directly uses a variable. The higher the count, the more unstable the software becomes. So, this metric can be useful for improving the stability of the software.</p>
			<p>The size of instance metric measures the size, in bytes, of the instances of a specified type.</p>
			<p>In the next section, we will look at how to improve the architecture and code quality by performing static code analysis.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Performing static code analysis</h1>
			<p>The purpose <a id="_idIndexMarker448"/>of static code analysis is to help you improve your overall architectural quality, code quality, and performance by doing the following:</p>
			<ul>
				<li>Visualizing software architecture and its software dependencies</li>
				<li>Enforcing the designated architectural rules regarding laying, subsystems, calling rules, and more</li>
				<li>Identifying code that has been cloned and modified using cut, copy, and paste</li>
				<li>Identifying dead code that can be removed</li>
				<li>Calculating various software metrics</li>
				<li>Performing code style checks and flagging violations</li>
			</ul>
			<p>Many companies<a id="_idIndexMarker449"/> employ static code analysis as part of <a id="_idIndexMarker450"/>their <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) process. There are various stages at which problems can come to light. These stages are listed as follows:</p>
			<ul>
				<li>When compiling source code in the IDE</li>
				<li>When running unit tests and end-to-end system tests</li>
				<li>When pushing source code to version control and issuing a pull request</li>
				<li>When a pull request has been issued and the code is issued to the build pipeline</li>
			</ul>
			<p>Performing static code analysis during the coding phase helps to prevent issues from being flagged further down the development and release processes.</p>
			<p>In Visual Studio via the <strong class="bold">Project Properties</strong> | <strong class="bold">Code Analysis</strong> page, you can run analyzers on the build and live analyses. You can enable .NET analyzers and set the analysis level to <strong class="bold">preview</strong>, <strong class="bold">latest</strong>, <strong class="bold">5.0</strong>, and <strong class="bold">none</strong>. Additionally, you can enforce CodeStyle on build. <em class="italic">Figure 5.1</em> shows the <strong class="bold">Code Analysis</strong> page:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_5.01_B16617.jpg" alt="Figure 5.1 – The Visual Studio Code Analysis page on the Project Properties tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – The Visual Studio Code Analysis page on the Project Properties tab</p>
			<p>The <strong class="bold">Code Metrics Results</strong> window<a id="_idIndexMarker451"/> is available from the <strong class="bold">View</strong> menu by selecting <strong class="bold">View</strong> | <strong class="bold">Other Windows – Code Metrics Results</strong>. The <strong class="bold">Code Metrics Results</strong> window is displayed in <em class="italic">Figure 5.2</em>:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_5.02_B16617.jpg" alt="Figure 5.2 – The Code Metrics Results window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – The Code Metrics Results window</p>
			<p>Right-click on the <strong class="source-inline">CH04_Finalization</strong> project and select <strong class="bold">Analyze</strong> and <strong class="bold">Code Cleanup</strong> | <strong class="bold">Calculate Code Metrics</strong> from the context pop-up menu. The <strong class="bold">Code Metrics Results</strong> window will be updated with the results of the analysis:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_5.03_B16617.jpg" alt="Figure 5.3 – Visual Studio 2022 Code Metrics Results for the CH04_WeakReference project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Visual Studio 2022 Code Metrics Results for the CH04_WeakReference project</p>
			<p>The <strong class="bold">Code Metrics Results</strong> window <a id="_idIndexMarker452"/>provides six code metrics that have been calculated for our project from <strong class="source-inline">CH04_Finalization</strong>.</p>
			<p class="callout-heading">Learn About the Metrics in Detail</p>
			<p class="callout">If you want to learn more about the metrics (<strong class="bold">Maintainability Index</strong>, <strong class="bold">Cyclomatic Complexity</strong>, <strong class="bold">Depth of Inheritance</strong>, <strong class="bold">Class Coupling</strong>, <strong class="bold">Lines of Source Code</strong>, and <strong class="bold">Lines of Executable code</strong>), then you can find a dedicated chapter (<a href="B16617_12_Final_SB_Epub.xhtml#_idTextAnchor215"><em class="italic">Chapter 12</em></a>) in my other book, <em class="italic">Clean Code in C#</em> (<a href="https://www.packtpub.com/product/clean-code-in-c/9781838982973">https://www.packtpub.com/product/clean-code-in-c/9781838982973</a>), which is published by Packt.</p>
			<p>From the traffic-light indicators of the <strong class="bold">Maintainability Index</strong> column, you can see that our project has green lights all the way. This means that our project is maintainable. </p>
			<p>The cyclomatic complexity of our methods is between <strong class="bold">1</strong> and <strong class="bold">2</strong>, so our individual method code contains no risk. However, the overall cyclomatic complexity of our project is <strong class="bold">31</strong>, which is medium risk. This value is the summation of the overall cyclomatic complexity of each of the classes within our project. The cyclomatic complexity of each of our classes is the summation of the cyclomatic complexity of each of the methods. Since none of the classes have a cyclomatic complexity of more than <strong class="bold">13</strong>, our code is complex but only poses a low risk to our project. Because the overall complexity of the project is <strong class="bold">31</strong>, we should<a id="_idIndexMarker453"/> look to see whether the code can be refactored to lower the cyclomatic complexity. Sometimes, you will find that code is as simple as you can make it and that it is not possible to reduce cyclomatic complexity. That is okay. Just use your common sense and better judgment when you encounter such code.</p>
			<p>The maximum depth of inheritance in our project is <strong class="bold">2</strong>. That is because our <strong class="source-inline">FreeAllocateMemory</strong> class inherits from our <strong class="source-inline">DisposableBase</strong> class, which inherits from the <strong class="source-inline">System.Object</strong> class. If we study what the <strong class="source-inline">DisposableBase</strong> class does, we can see that it will not cause us any issues.</p>
			<p>The total number of lines of code in our project is about <strong class="bold">200</strong>. There are <strong class="bold">50</strong> lines of executable code. That's because we are making effective use of whitespace so that our code is easy to read. Easy-to-read code is easier to understand, extend, and maintain.</p>
			<p>Open the <strong class="bold">Error List</strong> window by selecting <strong class="bold">View</strong> | <strong class="bold">Error List</strong>. Then, right-click on the project and select <strong class="bold">Analyze</strong> and <strong class="bold">Code Cleanup</strong> | <strong class="bold">Run Code Analysis</strong>. The <strong class="bold">Error List</strong> window will be updated with any errors, warnings, or informational messages for us to address. <em class="italic">Figure 5.4</em> shows the results of running code analysis on <strong class="source-inline">CH06_Collections</strong>:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_5.04_B16617.jpg" alt="Figure 5.4 – The Visual Studio 2022 code analysis results for the CH04_Finalization project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – The Visual Studio 2022 code analysis results for the CH04_Finalization project</p>
			<p>In the preceding screenshot, we can see that we have 0 errors, 4 warnings, and 62 messages. The three informational messages inform us that three different methods do not access instance data and can be marked as static.</p>
			<p>In the <strong class="source-inline">CH04_Finalization.DisposableBase</strong> class, we implement the <strong class="source-inline">IDisposable</strong> interface. In this class, code analysis raises two informational messages for code analysis rule CA1816. This code analysis rule informs us that the <strong class="source-inline">Dispose</strong> methods should call <strong class="source-inline">SuppressFinalize</strong>. Despite calling <strong class="source-inline">GC.SuppressFinalize</strong>, we are receiving this code analysis rule as an informational message. Therefore, to remove (suppress) the warning, we wrap the code in <strong class="source-inline">#pragma</strong> compiler directives. This <a id="_idIndexMarker454"/>can be done manually or by right-clicking on the message and selecting <strong class="bold">Suppress</strong> | <strong class="bold">In Source</strong>. Suppressing these messages updates the <strong class="source-inline">DisposableBase</strong> source file as follows:</p>
			<pre class="source-code">#pragma warning disable CA1816 </pre>
			<pre class="source-code">// Dispose methods should call SuppressFinalize</pre>
			<pre class="source-code">public void Dispose()</pre>
			<pre class="source-code">#pragma warning restore CA1816 </pre>
			<pre class="source-code">// Dispose methods should call SuppressFinalize</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    Dispose(true);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">private void Dispose(bool disposing)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    if (disposing)</pre>
			<pre class="source-code">#pragma warning disable CA1816 </pre>
			<pre class="source-code">// Dispose methods should call SuppressFinalize</pre>
			<pre class="source-code">        GC.SuppressFinalize(this);</pre>
			<pre class="source-code">#pragma warning restore CA1816 </pre>
			<pre class="source-code">// Dispose methods should call SuppressFinalize</pre>
			<pre class="source-code">ReleaseManagedResources();</pre>
			<pre class="source-code">ReleaseUnmanagedResources();</pre>
			<pre class="source-code">}</pre>
			<p>Now that the <strong class="source-inline">DisposableBase</strong> class has been updated with these <strong class="source-inline">#pragma</strong> warning disable CA1816 statements, notice that the messages are no longer displayed in the error list.</p>
			<p>Well, we have<a id="_idIndexMarker455"/> had a look at how to generate code metrics and run code analysis on our <strong class="source-inline">CH04_Finalization</strong> project using Visual Studio 2022. Now, let's move on to look at how to generate memory dumps and analyze them.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Generating and viewing memory dumps</h1>
			<p>When debugging in Visual Studio, if your program has stopped on a breakpoint or an exception, then the <strong class="bold">Save Dump As</strong> menu option becomes available in the <strong class="bold">Debug</strong> menu. </p>
			<p>A minidump<a id="_idIndexMarker456"/> with a heap file provides a snapshot of an application's memory, shows the process that was running, and lists the modules that were loaded at a <a id="_idIndexMarker457"/>point in time. Dump files enable you to examine the stack, threads, and variables as they were within the application and memory at the point in time when the dump was saved.</p>
			<p>You would<a id="_idIndexMarker458"/> save a minidump with heap files when testing software and a crash is encountered, and when a customer program crash cannot be replicated on your computer.</p>
			<p>Let's go through the process of saving and loading a minidump with a heap file:</p>
			<ol>
				<li>Using our <strong class="source-inline">CH04_WeakReferences</strong> project, put a breakpoint on the following line in the <strong class="source-inline">program.cs</strong> file:<p class="source-code">Console.WriteLine("Press any key to continue.");</p></li>
				<li>Run the project to the breakpoint. Then, when the breakpoint is hit, select <strong class="bold">Debug</strong> | <strong class="bold">Save Dump As</strong>. Save the dump file to where you would like to save it. The filename will be called <strong class="source-inline">CH04_WeakReference.dmp</strong>. This file is a minidump with a heap file.</li>
				<li>To read the file, select <strong class="bold">File</strong> | <strong class="bold">Open</strong> | <strong class="bold">File</strong>. Then, select the file you just saved. You should see the following window:</li>
			</ol>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_5.05_B16617.jpg" alt="Figure 5.5 – A minidump with a heap file loaded in Visual Studio 2022&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – A minidump with a heap file loaded in Visual Studio 2022</p>
			<p>The <a id="_idIndexMarker459"/>preceding<a id="_idIndexMarker460"/> screenshot shows us that we can see the time at which the file was last updated, the process name, the computer architecture, the exception code and information, the heap information, and the error information. Then, we have the CLR and OS versions. Finally, there is a list of modules, including their names, versions, and paths.</p>
			<p>You have just learned how to generate and read memory dumps in Visual Studio 2022. Now we will look at using the <strong class="bold">Modules</strong> window in Visual Studio 2022 to view what modules have been loaded by our projects.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Viewing loaded modules</h1>
			<p>To <a id="_idIndexMarker461"/>identify what might be causing performance issues such as excessive memory load, or that might be generating runtime errors, it can be useful to see what modules have been loaded into memory. In this section, you will learn how to view loaded modules and understand the items of information provided regarding those modules.</p>
			<p>When <a id="_idIndexMarker462"/>you are debugging in Visual Studio 2022, the <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> menu contains the menus, as shown in <em class="italic">Figure 5.6</em>:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_5.06_B16617.jpg" alt="Figure 5.6 – The Windows menu during a debugging session&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – The Windows menu during a debugging session</p>
			<p>From the preceding menu, as shown in <em class="italic">Figure 5.6</em>, you can select <strong class="bold">Modules</strong> during a debugging session. This will load the <strong class="bold">Modules</strong> window, as shown in <em class="italic">Figure 5.7</em>:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_5.07_B16617.jpg" alt="Figure 5.7 – The Modules window showing the loaded modules for the current process&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – The Modules window showing the loaded modules for the current process</p>
			<p>As <em class="italic">Figure 5.7</em> shows, the <strong class="source-inline">CH04_WeakReferences.exe</strong> process runs in the <strong class="bold">clrhost</strong> AppDomain, and loads the following modules:</p>
			<ul>
				<li><strong class="source-inline">System.Private.CoreLib.dll</strong></li>
				<li><strong class="source-inline">CH04_WeakReference.dll</strong></li>
				<li><strong class="source-inline">System.Runtime.dll</strong></li>
				<li><strong class="source-inline">System.Console.dll</strong></li>
			</ul>
			<p>The list of fields<a id="_idIndexMarker463"/> that are displayed in the <strong class="bold">Modules</strong> window is as follows:</p>
			<ul>
				<li><strong class="bold">Name</strong>: The name of the loaded assembly (loaded module)</li>
				<li><strong class="bold">Path</strong>: The path to the loaded module</li>
				<li><strong class="bold">Optimized</strong>: Yes/no</li>
				<li><strong class="bold">User Code</strong>: Yes/no</li>
				<li><strong class="bold">Symbol Status</strong>: Skipped loading symbols/symbols loaded</li>
				<li><strong class="bold">Symbol File</strong>: The path and filename of the loaded symbol file</li>
				<li><strong class="bold">Order</strong>: The order of assembly loading</li>
				<li><strong class="bold">Version</strong>: The assembly version</li>
				<li><strong class="bold">Address</strong>: The memory address of the loaded module</li>
				<li><strong class="bold">Process</strong>: The process identifier and executable name responsible for causing the modules to be loaded into memory</li>
				<li><strong class="bold">AppDomain</strong>: The name of the application domain that the module is running under. This doesn't have any meaning in .NET Core and .NET 5 or higher. It is displayed because the debugger UI does not make the distinction between the .NET Framework and .NET Core.</li>
			</ul>
			<p>You can use this information to see what modules are loaded, whereabouts they reside in memory, whether the symbols have been loaded, whether the code is system code or user code, and <a id="_idIndexMarker464"/>whether the code is optimized or not optimized. If you find user code that has not been optimized, then you can apply optimizations to improve performance.</p>
			<p>In the next section, we will look at how to further debug your applications by briefly covering the tools available to you that you should already be familiar with.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Debugging your applications</h1>
			<p>It is<a id="_idIndexMarker465"/> assumed that you know how to debug your code by running through your code, stepping out and stepping over the code, running to the cursor, and setting breakpoints. However, there are other useful tools available when using the debugger. These include the following:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_5.08_B16617.jpg" alt="Figure 5.8 – The Debug | Windows menu&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – The Debug | Windows menu</p>
			<p>As you<a id="_idIndexMarker466"/> can see, there are a good number of different windows available to help debug your applications. The <strong class="bold">Immediate</strong> window is very good for executing commands when your program is paused. The <strong class="bold">Locals</strong> window is good for seeing the present state of your variables, and the call stack is useful for finding where an exception occurred, especially if it is in close code that is not yours! Take the time to run through your source code with these windows open. Different windows such as <strong class="bold">XAML Binding Failures</strong> are only used when working on the XAML-based code. But other windows, such as <strong class="bold">Immediate</strong>, <strong class="bold">Locals</strong>, <strong class="bold">Output</strong>, <strong class="bold">Autos</strong>, and <strong class="bold">Call Stack,</strong> can be used with all project types. The best way to get the most out of these tools is to use them for yourself and get to know them as you work through your code. Next, we will look at using tracing and diagnostics tools.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Using tracing and diagnostics tools</h1>
			<p>In this <a id="_idIndexMarker467"/>section, we will look at some profiling tools to help you trace and diagnose any issues with your code. By tracing and diagnosing your program, you can identify areas of performance concern and address them. Such concerns might be the number of memory allocations and the number of bytes they are using and identifying the number of objects surviving garbage collection. Such information can be useful in improving memory usage and performance and in preventing and removing memory leaks.</p>
			<p>We will look at two offerings from<a id="_idIndexMarker468"/> JetBrains, called <strong class="bold">dotMemory</strong> and <strong class="bold">dotTrace</strong>, that<a id="_idIndexMarker469"/> are valuable tools in this respect. But first, we will start by looking at the built-in profiler that comes with Visual Studio 2022 called <strong class="bold">Performance Profiler</strong>.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Using the Visual Studio 2022 Performance Profiler</h2>
			<p>Now we<a id="_idIndexMarker470"/> are going to view the performance profile for our project. This will show us the number of objects over time and the<a id="_idIndexMarker471"/> way garbage collection is being utilized in our project, along with the number of objects that survive garbage collection. We can drill down on this profile to the assembly and method levels. This enables us to see the number of object allocations within a method and the total number of bytes those allocations use up. And because of this information, we can identify the areas of our program that generate the most memory usage. With such information, we can consider heavy allocation code for refactoring to improve memory performance.</p>
			<p>To access the Visual Studio 2022 Performance Profile, select <strong class="bold">Performance Profiler</strong> from the Visual Studio 2022 <strong class="bold">Debug</strong> menu. This will bring up a tab, as shown in <em class="italic">Figure 5.9</em>:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_5.09_B16617.jpg" alt="Figure 5.9 – The Visual Studio 2022 Performance Profiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – The Visual Studio 2022 Performance Profiler</p>
			<p>Now, we<a id="_idIndexMarker472"/> will run an analysis on<a id="_idIndexMarker473"/> the <strong class="source-inline">CH04_Finalization</strong> project:</p>
			<ol>
				<li value="1">Select your startup project.</li>
				<li>Then, select the tool that you want to use. In our case, we have selected<strong class="source-inline"> CH04_Finalization</strong>. And the tool we have selected is the tool for tracking .NET object allocations. This enables us to see where the .NET objects are allocated and when they are reclaimed. </li>
				<li>Click on the <strong class="bold">Start</strong> button to start profiling the application. The profiler will run and then stop when the code stops. You will see a report similar to the one in <em class="italic">Figure 5.10</em>:</li>
			</ol>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/Figure_5.10_B16617.jpg" alt="Figure 5.10 – The complete Visual Studio 2022 Performance Profiler report &#13;&#10;showing live objects over time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – The complete Visual Studio 2022 Performance Profiler report showing live objects over time</p>
			<p>The <a id="_idIndexMarker474"/>main chart area shows<a id="_idIndexMarker475"/> the number of live objects over time. There are also four tabs that contain <strong class="bold">Allocations</strong>, <strong class="bold">Call Tree</strong>, <strong class="bold">Functions</strong>, and <strong class="bold">Collections</strong> data.</p>
			<ol>
				<li value="4">On the <strong class="bold">Allocations</strong> tab, you can see the types used and the number of their allocations. Clicking on a type brings up the <strong class="bold">Backtrace</strong> for that type. You can see the number of allocations for that type and the number of bytes allocated in your functions, as shown in <em class="italic">Figure 5.11</em>:</li>
			</ol>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Image87475.jpg" alt="Figure 5.11 – The Visual Studio 2022 Performance Profiler allocations of System.Sbyte[]&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – The Visual Studio 2022 Performance Profiler allocations of System.Sbyte[]</p>
			<p>In <em class="italic">Figure 5.11</em>, we can see that in our <strong class="source-inline">Main</strong> method, there are 19 allocations of the <strong class="source-inline">System.Sbyte[]</strong> type with an allocation size of <strong class="bold">952</strong> bytes. </p>
			<ol>
				<li value="5">Select<a id="_idIndexMarker476"/> the <strong class="bold">Call Tree</strong> tab. Showing <a id="_idIndexMarker477"/>just our code and the hot path with the hot path expanded, we can see that in the <strong class="source-inline">DisplayGeneration(Product product)</strong> method, there is one <strong class="source-inline">System.Int32</strong> allocation that is <strong class="bold">24</strong> bytes in size, as shown in <em class="italic">Figure 5.12</em>:</li>
			</ol>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_5.12_B16617.jpg" alt="Figure 5.12 – The Visual Studio 2022 Performance Profiler Call Tree tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – The Visual Studio 2022 Performance Profiler Call Tree tab</p>
			<ol>
				<li value="6">Select<a id="_idIndexMarker478"/> the <strong class="bold">Functions</strong> tab. You <a id="_idIndexMarker479"/>will see that the <strong class="source-inline">Main</strong> method has a total of <strong class="bold">347</strong> allocations, <strong class="bold">27</strong> self-allocations, and is a total of <strong class="bold">1,438</strong> bytes in size, as shown in <em class="italic">Figure 5.13</em>:</li>
			</ol>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_5.13_B16617.jpg" alt="Figure 5.13 – Visual Studio 2022 Performance Profiler Functions tab showing allocations and sizes for various methods&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Visual Studio 2022 Performance Profiler Functions tab showing allocations and sizes for various methods</p>
			<ol>
				<li value="7">Click <a id="_idIndexMarker480"/>on the <strong class="bold">Collections</strong> tab. Then, click<a id="_idIndexMarker481"/> on a row. You will see two pie charts for the top collected types and top survived types, as shown in <em class="italic">Figure 5.14</em>:</li>
			</ol>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_5.14_B16617.jpg" alt="Figure 5.14 – Visual Studio 2022 Performance Profiler showing a breakdown of the garbage collection &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – Visual Studio 2022 Performance Profiler showing a breakdown of the garbage collection </p>
			<p>In <em class="italic">Figure 5.14</em>, we <a id="_idIndexMarker482"/>can see the number <a id="_idIndexMarker483"/>of live objects over time along with the object delta (% change). Additionally, we can see the top collected types and top survived types in the two pie charts.</p>
			<p>The Visual Studio 2022 Performance Profiler is a very useful tool that enables you to view allocations, byte sizes, and garbage collected and survived objects. You can also see the number of<a id="_idIndexMarker484"/> live<a id="_idIndexMarker485"/> objects over time. Now that you have been introduced to the profiler and know what it is capable of, let's move our attention to the JetBrains tool <a id="_idIndexMarker486"/>called <strong class="bold">dotMemory</strong>.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Using JetBrains dotMemory</h2>
			<p>We <a id="_idIndexMarker487"/>use<a id="_idIndexMarker488"/> dotMemory to profile and optimize memory and to help us identify memory leaks and other memory-related issues. In this section, we will be discussing the JetBrains dotMemory memory profiler.</p>
			<p>The memory profiler will provide a chart with milliseconds on the <em class="italic">x</em> axis and megabytes on the <em class="italic">y</em> axis, which shows your application's memory usage over time. The following list of items is displayed on the chart:</p>
			<ul>
				<li><strong class="bold">Total used</strong>: The total amount of memory used.</li>
				<li><strong class="bold">Unmanaged memory</strong>: The total amount of memory placed on the stack.</li>
				<li><strong class="bold">Heap generation 0</strong>: The amount of memory taken up by new objects. These objects will be less than 80,000 bytes in size.</li>
				<li><strong class="bold">Heap generation 1</strong>: The objects that survive generation 0 garbage collection.</li>
				<li><strong class="bold">Heap generation 2</strong>: Long-lived objects that survive level 1 garbage collection.</li>
				<li><strong class="bold">Large object heap (LOH)</strong>: The amount of memory used by objects that are 80,000 bytes or larger in size.</li>
				<li><strong class="bold">Allocated in LOH since GC</strong>: The amount of memory used on the LOH after garbage collection has taken place.</li>
			</ul>
			<p>Let's see the dotMemory memory profiler in action. If you have not already done so, download and install dotMemory from JetBrains and the code for <strong class="source-inline">chapter 4</strong> from the GitHub page. Open dotMemory, and you will be presented with a screen similar to the one shown in <em class="italic">Figure 5.15</em>:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_5.15_B16617.jpg" alt="Figure 5.15 – The dotMemory Memory Profiler ready to profile .NET Core Application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – The dotMemory Memory Profiler ready to profile .NET Core Application</p>
			<p>In <em class="italic">Figure 5.15</em>, we<a id="_idIndexMarker489"/> have selected to profile <strong class="bold">.NET Core Application</strong>. The <a id="_idIndexMarker490"/>application selected for profiling is <strong class="source-inline">CH04_PreventingMemoryLeaks.dll</strong>. Click on the <strong class="bold">Run</strong> button. This will enable the profiler to start running and profiling your application. Once the application has been profiled, a report will be displayed showing the results in graphical form, as shown in <em class="italic">Figure 5.16</em>:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_5.16_B16617.jpg" alt="Figure 5.16 – The profile report for CH04_PreventingMemoryLeaks.dll&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – The profile report for CH04_PreventingMemoryLeaks.dll</p>
			<p>As you can see <a id="_idIndexMarker491"/>from the preceding screenshot, our <a id="_idIndexMarker492"/>application uses a total of <strong class="bold">8.16 MB</strong> of memory. This is not that much. Most of the memory is placed on the stack, as shown by the unmanaged memory usage at <strong class="bold">8.06 MB</strong>. The rest of the memory is on the heap. On the heap, <strong class="bold">24 KB</strong> has been allocated on generation <strong class="bold">0</strong>, <strong class="bold">77.6 KB</strong> has been allocated on generation <strong class="bold">1</strong>, and <strong class="bold">1.3 KB</strong> has been allocated on generation <strong class="bold">2</strong>. The most heap memory, <strong class="bold">19.2 KB</strong>, was placed on the LOH and did not remain after garbage collection. </p>
			<p>Having seen the dotMemory tool in action, we can now turn our attention to what the JetBrains dotTrace tool has to offer us in terms of tracing and profiling.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Using JetBrains dotTrace</h2>
			<p>In this<a id="_idIndexMarker493"/> section, we will be looking at JetBrains dotTrace. You<a id="_idIndexMarker494"/> will learn how to use the JetBrains dotTrace tool to perform application tracing at runtime on your programs. This will help you to identify bottlenecks and memory issues in your executable programs.</p>
			<p>The profiler options available in dotTrace include the following:</p>
			<ul>
				<li><strong class="bold">Sampling</strong>: An accurate measurement of call time. This is optimal for most use cases.</li>
				<li><strong class="bold">Tracing</strong>: An accurate measurement of call number. This is optimal for analyzing algorithm complexity.</li>
				<li><strong class="bold">Line-byline</strong>: Advanced use cases only.</li>
				<li><strong class="bold">Timeline</strong>: The measurement of temporal performance data. This is optimal for most use cases, including the analysis of multithreaded applications:</li>
			</ul>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_5.17_B16617.jpg" alt="Figure 5.17 – JetBrains dotTrace ready to profile our application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – JetBrains dotTrace ready to profile our application</p>
			<p><em class="italic">Figure 5.17</em> shows<a id="_idIndexMarker495"/> the initial state of dotTrace. We have selected <strong class="bold">CH03_PassByValueAndReference.exe</strong> as our application to profile. And for our profiling option, we have selected to go with the default <strong class="bold">Sampling</strong> setting. Make sure that <strong class="bold">Collect profiling data from start</strong> is selected. Then, click on the <strong class="bold">Run</strong> button to start tracing.</p>
			<p>When the tracing <a id="_idIndexMarker496"/>has been completed, the dotTrace Performance Viewer will automatically open, as shown in <em class="italic">Figure 5.18</em>:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_5.18_B16617.jpg" alt="Figure 5.18 – JetBrains dotTrace Performance Viewer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18 – JetBrains dotTrace Performance Viewer</p>
			<p>The outcome of profiling the <strong class="source-inline">CH03_PassByValueAndReference.exe</strong> file is shown in the default view of <em class="italic">Figure 5.18</em>. If you click on the <strong class="bold">Hot spots</strong> icon and highlight the <strong class="source-inline">Main</strong> line, you will see the program code. The breakdown of the <strong class="source-inline">Main</strong> method shows that 19 ms (43.20%) of time was spent executing system code, 13 ms (29.56%) of time was<a id="_idIndexMarker497"/> spent performing File I/O, and 12 ms (27.24%) of time<a id="_idIndexMarker498"/> was executing the <strong class="bold">String</strong> subsystem, as shown in <em class="italic">Figure 5.19</em>:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_5.19_B16617.jpg" alt="Figure 5.19 – Breakdown of the main method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19 – Breakdown of the main method</p>
			<p><em class="italic">Figure 5.19</em> shows the <strong class="source-inline">Main</strong> method source code and the fact that between <strong class="source-inline">Main</strong> and <strong class="source-inline">InParameterModifier</strong>, the <strong class="source-inline">Main</strong> method takes the most time to process. This information can be helpful to identify and work with bottlenecks.</p>
			<p>We have seen two tools for memory profiling and tracing that can be used to measure performance and identify bottlenecks and problems. Now, let's move our attention to installing and using <strong class="source-inline">dotnet-counters</strong>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Installing and using dotnet-counters</h1>
			<p>In this section, we will install and<a id="_idIndexMarker499"/> use <strong class="source-inline">dotnet-counters</strong>. These counters are very useful data-gathering tools that help us to monitor the health of our programs.</p>
			<p>Open Developer Command Prompt for Visual Studio 2022. Then, type in<a id="_idIndexMarker500"/> the following command and press <em class="italic">Enter</em>:</p>
			<p class="source-code">dotnet tool install --global dotnet-counters --version 3.1.141901</p>
			<p>This will download and<a id="_idIndexMarker501"/> install dotnet-tools. A successful installation will be presented, as shown in <em class="italic">Figure 5.20</em>:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_5.20_B16617.jpg" alt="Figure 5.20 – The successful installation of dotnet-tools version 3.1.141901 using &#13;&#10;Developer Command Prompt&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20 – The successful installation of dotnet-tools version 3.1.141901 using Developer Command Prompt</p>
			<p>The purpose<a id="_idIndexMarker502"/> of using <strong class="source-inline">dotnet-counters</strong> is to perform health monitoring and a first-level performance investigation of your applications. If when using this program, potential performance problems are identified, then you can perform a more serious performance investigation using tools such as PerfView or dotnet-trace:</p>
			<ul>
				<li>To periodically collect selected counter values and export them to a file for post-processing, use the <strong class="source-inline">dotnet-counters collect</strong> command. </li>
				<li>The <strong class="source-inline">dotnet-counters list</strong> command displays a list of the counter names and descriptions that are grouped by the provider. </li>
				<li>And to display a list of .NET processes that can be monitored, you can use the <strong class="source-inline">dotnet-counters ps</strong> command.</li>
				<li>Using the <strong class="source-inline">dotnet-counters monitor</strong> command, you can display periodically refreshed values for selected counters.</li>
			</ul>
			<p>To get a list of the available options for each command, append <strong class="source-inline">-h</strong> or <strong class="source-inline">–help</strong>. Let's put each of those commands to use. And before we do, add the following lines to the end of the <strong class="source-inline">CH04_WeakRefereces</strong> <strong class="source-inline">Main</strong> method in the <strong class="source-inline">Program</strong> class:</p>
			<pre class="source-code">Console.WriteLine("Press any key to continue.");</pre>
			<pre class="source-code">Console.ReadKey();</pre>
			<p>Run the program. It will pause and wait for you to press a key before it continues.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Collecting data and saving it to a file for post-analysis</h2>
			<p>Now <a id="_idIndexMarker503"/>we will use <strong class="source-inline">dotnet-counters</strong> to save data to a file that we<a id="_idIndexMarker504"/> can analyze once our program has finished running:</p>
			<ol>
				<li value="1">Remove the breakpoint of <strong class="source-inline">CH04_WeakReferences</strong> in the <strong class="source-inline">Program</strong> class. </li>
				<li>Update the <strong class="source-inline">ProcessReferences()</strong> method in the <strong class="source-inline">Program</strong> class as follows:<p class="source-code">private static void ProcessReferences()</p><p class="source-code">{</p><p class="source-code">int x = 0;</p><p class="source-code">while(x &lt; 10000)</p><p class="source-code">{</p><p class="source-code">    StrongReferences.ListObjects();</p><p class="source-code">    WeakReferences.ListObjects();</p><p class="source-code">    Thread.Sleep(2000);</p><p class="source-code">    GC.Collect();</p><p class="source-code">    x++;</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>Add a breakpoint to the <strong class="source-inline">while (x &lt; 10000)</strong> loop.</li>
				<li>Then, run the program. Running the program will require some time – approximately 10,000 iterations x 2 seconds = 5.5h.</li>
				<li>When the program stops on the breakpoint added in <em class="italic">step 3</em>, open Command Prompt as an admin and type in <strong class="source-inline">dotnet-counters ps</strong> followed by <em class="italic">Enter</em>. If you don't run as an admin, you will encounter counter access errors.</li>
				<li>Obtain the process ID for the program.</li>
				<li>Change<a id="_idIndexMarker505"/> the directory in Command Prompt to point to <strong class="source-inline">C:\Temp</strong>. Create the directory if it does not exist.</li>
				<li>Enter the <strong class="source-inline">dotnet-counters collect --process-id 1234</strong> command (replace <strong class="bold">1234</strong> with the ID of your .NET process) followed by <em class="italic">Enter</em>.</li>
				<li>The performance data will now be collected.</li>
				<li>Remove the breakpoint added in <em class="italic">step 3</em> and continue the program. When you have let the program run a little while, press the <em class="italic">q</em> key. Your Command Prompt screen should look similar to <em class="italic">Figure 5.21</em>:</li>
			</ol>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_5.21_B16617.jpg" alt="Figure 5.21 – The Developer Command Prompt having completed a collection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21 – The Developer Command Prompt having completed a collection</p>
			<ol>
				<li value="11">Open the file called <strong class="source-inline">C:\Temp\counter.csv</strong> in <strong class="bold">Excel</strong>. <em class="italic">Figure 5.22</em> shows an excerpt of the data contained within the spreadsheet:</li>
			</ol>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_5.22_B16617.jpg" alt="Figure 5.22 – An excerpt from counter.csv&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22 – An excerpt from counter.csv</p>
			<p>As you <a id="_idIndexMarker506"/>can see, there are various items that are recorded by the <strong class="source-inline">dotnet-counters</strong> collect process. These items include CPU usage, garbage collection data, heap information, exception information, the number of loaded assemblies, and JIT compilation information.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Listing .NET processes that can be monitored</h2>
			<p>To<a id="_idIndexMarker507"/> list .NET processes that can be monitored, open the Developer Command Prompt screen and type in the <strong class="source-inline">dotnet-counters ps</strong> command. You should see an output similar to the following:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_5.23_B16617.jpg" alt="Figure 5.23 – The list of .NET processes that can be monitored&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23 – The list of .NET processes that can be monitored</p>
			<p>As <em class="italic">Figure 5.23</em> shows, the only process that can be monitored is process <strong class="bold">5364</strong>. Process <strong class="bold">5364</strong> is the program<a id="_idIndexMarker508"/> that we are currently debugging. If more .NET programs were running, then more would appear on this list.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Listing the available list of well-known .NET counters</h2>
			<p>To<a id="_idIndexMarker509"/> list the available .NET counters, run the following command:</p>
			<pre class="source-code">dotnet-counters list</pre>
			<p>You will see a list of counters and their descriptions output to the console. For <strong class="source-inline">Microsoft.AspNetCore.Hosting</strong>, the available counters are listed as follows:</p>
			<ul>
				<li><strong class="bold">requests-per-second</strong>: The request rate</li>
				<li><strong class="bold">total-requests</strong>: The total number of requests</li>
				<li><strong class="bold">current-requests</strong>: The current number of requests</li>
				<li><strong class="bold">failed-requests</strong>: The failed number of requests</li>
			</ul>
			<p>The available well-known<a id="_idIndexMarker510"/> counters for <strong class="source-inline">System.Runtime</strong> are listed as follows:</p>
			<ul>
				<li><strong class="bold">cpu-usage</strong>: The amount of time the process has utilized the CPU in milliseconds</li>
				<li><strong class="bold">working-set</strong>: The amount of working set used by the process in megabytes</li>
				<li><strong class="bold">gc-heap-size</strong>: The total heap reported by the garbage collector in megabytes</li>
				<li><strong class="bold">gen-0-gc-count</strong>: The number of generation 0 garbage collections per minute</li>
				<li><strong class="bold">gen-1-gc-count</strong>: The number of generation 1 garbage collections per minute</li>
				<li><strong class="bold">gen-2-gc-count</strong>: The number of generation 2 garbage collections per minute</li>
				<li><strong class="bold">loh size</strong>: Large object heap size</li>
				<li><strong class="bold">alloc-rate</strong>: The number of bytes allocated in the managed heap per second</li>
				<li><strong class="bold">assembly-count</strong>: The number of assemblies loaded</li>
				<li><strong class="bold">exception-count</strong>: The number of exceptions per second</li>
				<li><strong class="bold">threadpool-thread-count</strong>: The number of thread pool threads</li>
				<li><strong class="bold">monitor-lock-contention-count</strong>: The number of times there were contentions when trying to take the monitor lock per second</li>
				<li><strong class="bold">threadpool-queue-length</strong>: The number of work items in the thread pool queue</li>
				<li><strong class="bold">threadpool-completed-items-count</strong>: The number of completed work items in the thread pool</li>
				<li><strong class="bold">active-timer-count</strong>: The <a id="_idIndexMarker511"/>number of timers that are currently active</li>
			</ul>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Monitoring a .NET process</h2>
			<p>We are<a id="_idIndexMarker512"/> going to run our <strong class="source-inline">CH04_WeakReferences</strong> project. Once you have the project running, run the following command to get the process ID:</p>
			<pre class="source-code">dotnet-counters ps</pre>
			<p>Then, once you have the process ID for your .NET program, run the following command:</p>
			<pre class="source-code">dotnet-counters monitor –process-id 6719</pre>
			<p>For me, the process has an ID of <strong class="bold">6719</strong>. Replace <strong class="bold">6719</strong> with whatever your process ID is. The result should be that you see the .NET counters being displayed and updated in real time, as shown in <em class="italic">Figure 5.24</em>:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_5.24_B16617.jpg" alt="Figure 5.24 – The dotnet-counters being listed and updated in real time for our &#13;&#10;CH04_WeakReferences project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24 – The dotnet-counters being listed and updated in real time for our CH04_WeakReferences project</p>
			<p>Press <em class="italic">q</em> to quit. As you<a id="_idIndexMarker513"/> can see, we have <strong class="bold">19.042%</strong> garbage collection fragmentation. There are <strong class="bold">19,640</strong> bytes on the LOH, and <strong class="bold">80,864</strong> bytes are assigned to generation <strong class="bold">2</strong>. We have <strong class="bold">9</strong> assemblies loaded and <strong class="bold">24</strong> bytes allocated to generation <strong class="bold">0</strong> and generation <strong class="bold">1</strong>. We have observed that memory fragmentation has occurred at <strong class="bold">19.042%</strong>, so this can be investigated further to see why we have fragmentation and to see whether we can avoid this.</p>
			<p>In the next section, we are going to look at an example that tracks down a memory leak in a WPF application.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Tracking down and fixing a memory leak with dotMemory</h1>
			<p>In this<a id="_idIndexMarker514"/> section, we are going to run through an example of how to track down and fix memory leaks. A <strong class="bold">memory leak</strong> occurs <a id="_idIndexMarker515"/>when objects become inaccessible and remain in memory <a id="_idIndexMarker516"/>without being garbage collected. As the number of objects builds up, memory runs out and you end up with an <strong class="source-inline">OutOfMemoryException</strong> exception<a id="_idIndexMarker517"/> being thrown by the application.</p>
			<p>Our example <a id="_idIndexMarker518"/>will be a WPF application called <strong class="source-inline">CH05_GameOfLife</strong>. To save time and space, download the source code for the WPF application. This will help you to focus on the task at hand, which is to track down the memory leak and fix it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When profiling and tracing, you are better off building your projects using <strong class="bold">Release</strong> mode. The reason for this is that <strong class="bold">Debug</strong> builds contain compiler instructions that might affect profiling results.</p>
			<p>Perform the following steps:</p>
			<ol>
				<li value="1">Download and compile the <strong class="source-inline">CH05_GameOfLife</strong> project in <strong class="bold">Release</strong> mode.</li>
				<li>Open <strong class="bold">dotMemory</strong>. The version used in this example is <strong class="bold">2020.3.4</strong></li>
				<li>Under <strong class="bold">New Session</strong>, select <strong class="bold">Local</strong>. Then, under <strong class="bold">Profile Application</strong>, select <strong class="bold">.NET Core Application</strong>. Select the <strong class="bold">CH05_GameOfLife.exe</strong> file under <strong class="bold">.NET Core Application</strong>, and for the <strong class="bold">Profiler Options</strong>, select <strong class="bold">Collect memory allocation and traffic data from the start</strong>. <em class="italic">Figure 5.25</em> shows dotMemory prepared to profile our application:</li>
			</ol>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_5.25_B16617.jpg" alt="Figure 5.25 – dotMemory ready to profile our .NET 6.0 application CH05_GameOfLife.exe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.25 – dotMemory ready to profile our .NET 6.0 application CH05_GameOfLife.exe</p>
			<ol>
				<li value="4">Click <strong class="bold">Run</strong> to<a id="_idIndexMarker519"/> start <a id="_idIndexMarker520"/>profiling our application. You <a id="_idIndexMarker521"/>will see a new <strong class="bold">Analysis</strong> tab <a id="_idIndexMarker522"/>appear in dotMemory, as shown in <em class="italic">Figure 5.26</em>:</li>
			</ol>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_5.26.jpg" alt="Figure 5.26 – dotMemory displaying the Analysis tab during the profiling of our app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.26 – dotMemory displaying the Analysis tab during the profiling of our app</p>
			<ol>
				<li value="5">When<a id="_idIndexMarker523"/> the profiler starts, it also <a id="_idIndexMarker524"/>starts <a id="_idIndexMarker525"/>our <a id="_idIndexMarker526"/>application. Click on the <strong class="bold">Start</strong> button of our application, as shown in <em class="italic">Figure 5.27</em>:</li>
			</ol>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Image87625.jpg" alt="Figure 5.27 – Running CH05_GameOfLife &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.27 – Running CH05_GameOfLife </p>
			<ol>
				<li value="6">After <em class="italic">Game of Life</em> has <a id="_idIndexMarker527"/>been running for a while, click on the <strong class="bold">Get Snapshot</strong> button to <a id="_idIndexMarker528"/>take a <a id="_idIndexMarker529"/>memory snapshot. This will capture the application's <a id="_idIndexMarker530"/>managed heap at that moment in time.</li>
				<li>Close the advert.</li>
				<li>Take another snapshot so that we have two snapshots. Then, close the <em class="italic">Game of Life</em> application to stop the profiler. <em class="italic">Figure 5.28</em> shows the dotMemory <strong class="bold">Analysis</strong> tab with both snapshots taken: </li>
			</ol>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Figure_5.28.jpg" alt="Figure 5.28 – The dotMemory Analysis tab displaying both memory snapshots&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.28 – The dotMemory Analysis tab displaying both memory snapshots</p>
			<ol>
				<li value="9">The next <a id="_idIndexMarker531"/>step <a id="_idIndexMarker532"/>is for <a id="_idIndexMarker533"/>us to compare the two<a id="_idIndexMarker534"/> different snapshots. <em class="italic">Figure 5.29</em> shows a close-up of the two snapshots side by side:</li>
			</ol>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_5.29.jpg" alt="Figure 5.29 – dotMemory snapshots 1 and 2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.29 – dotMemory snapshots 1 and 2</p>
			<ol>
				<li value="10">Click on <strong class="bold">Compare</strong> to open <a id="_idIndexMarker535"/>the detailed side-by-side <a id="_idIndexMarker536"/>comparison of the two snapshots. You <a id="_idIndexMarker537"/>should see the comparison, as<a id="_idIndexMarker538"/> shown in <em class="italic">Figure 5.30</em>:</li>
			</ol>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/Figure_5.30_B16617.jpg" alt="Figure 5.30 – The side-by-side snapshot comparison screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.30 – The side-by-side snapshot comparison screen</p>
			<p>As you can see, this view shows the number of new objects created, the number of objects that have been collected (dead objects) by the garbage collector, and the number of objects that have survived garbage collection. This is a good source of information that can be used to identify memory leaks.</p>
			<ol>
				<li value="11">Click on the <strong class="bold">Namespace</strong> column. Then, expand the <strong class="bold">CH05_GameOfLife</strong> namespace <a id="_idIndexMarker539"/>and highlight the <strong class="bold">AdWindow</strong> entry, as<a id="_idIndexMarker540"/> shown in <em class="italic">Figure 5.31</em>:</li>
			</ol>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/Figure_5.31_B16617.jpg" alt="Figure 5.31 – The analysis by Namespace with CH05_GameOfLife highlighted&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.31 – The analysis by Namespace with CH05_GameOfLife highlighted</p>
			<ol>
				<li value="12">In the <strong class="bold">Survived objects</strong> column, click on number <strong class="bold">1</strong> in the <strong class="bold">AdWindow</strong> row. This <a id="_idIndexMarker541"/>will bring up the dialog, as<a id="_idIndexMarker542"/> shown in <em class="italic">Figure 5.32</em>:</li>
			</ol>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/Figure_5.32_B16617.jpg" alt="Figure 5.32 – dotMemory dialog prompting the opening of a snapshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.32 – dotMemory dialog prompting the opening of a snapshot</p>
			<ol>
				<li value="13">Select the newer snapshot option.</li>
				<li>Then, click on the <strong class="bold">Key Retention Paths</strong> tab. The JetBrains dotMemory view will change to a view that is similar to <em class="italic">Figure 5.33</em>:</li>
			</ol>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/Figure_5.33_B16617.jpg" alt="Figure 3.33 – The Key Retention Paths tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.33 – The Key Retention Paths tab</p>
			<p>You can<a id="_idIndexMarker543"/> see that <strong class="source-inline">EventHandler</strong> is <a id="_idIndexMarker544"/>keeping <strong class="source-inline">AdWindow</strong> alive, and <strong class="source-inline">EventHandler</strong> is referenced <a id="_idIndexMarker545"/>by<a id="_idIndexMarker546"/> the <strong class="source-inline">DispatcherTimer</strong> class. The <strong class="source-inline">DispatcherTimer</strong> class is referenced by the <strong class="source-inline">Tick</strong> event.</p>
			<ol>
				<li value="15">Click on the <strong class="source-inline">DispatcherTimer</strong> box. This will take you to the <strong class="bold">Outgoing References</strong> tab for the <strong class="source-inline">DispatcherTimer</strong> class, as shown in <em class="italic">Figure 3.34</em>:</li>
			</ol>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/Figure_5.34_B16617.jpg" alt="Figure 3.34 – The Outgoing References table displaying the details of DispatcherTimeruse&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.34 – The Outgoing References table displaying the details of DispatcherTimeruse</p>
			<p>This<a id="_idIndexMarker547"/> tab certainly shows that <strong class="source-inline">Tick EventHandler</strong> is retaining bytes, which is leading to our <strong class="source-inline">DispatcherTimer</strong> object <a id="_idIndexMarker548"/>being kept alive in memory.</p>
			<ol>
				<li value="16">Click on <a id="_idIndexMarker549"/>the <strong class="bold">Creation Stack Trace</strong> tab. This will<a id="_idIndexMarker550"/> help us to identify the method responsible for our <strong class="source-inline">EventHandler</strong> creation. The method appears at the top, as shown in <em class="italic">Figure 3.35</em>:</li>
			</ol>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/Figure_5.35_B16617.jpg" alt="Figure 3.35 – The Creation Stack Trace tab showing the AdWindow constructor that creates the timer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.35 – The Creation Stack Trace tab showing the AdWindow constructor that creates the timer</p>
			<ol>
				<li value="17">Locate the <strong class="source-inline">AdWindow</strong> constructor in the <strong class="source-inline">AdWindow</strong> class of the <strong class="bold">CH05_GameOfLife</strong> project:<p class="source-code">public AdWindow(Window owner)</p><p class="source-code">{</p><p class="source-code">    ... </p><p class="source-code">    _adTimer = new DispatcherTimer { </p><p class="source-code">        Interval = TimeSpan.FromSeconds(3) </p><p class="source-code">};</p><p class="source-code">  _adTimer.Tick += ChangeAds;</p><p class="source-code">  _adTimer.Start();</p><p class="source-code">}</p></li>
			</ol>
			<p>As you<a id="_idIndexMarker551"/> can see from the preceding <a id="_idIndexMarker552"/>code snippet, we are subscribing to the <strong class="source-inline">Tick</strong> event, which is handled by the <strong class="source-inline">ChangeAds</strong> method. But the<a id="_idIndexMarker553"/> one thing we are not doing is <a id="_idIndexMarker554"/>unsubscribing from the event when we no longer require it. This is the reason for the memory leak.</p>
			<ol>
				<li value="18">To rectify our memory leak, all we have to do is unsubscribe from the event when we no longer need it. And to do this, we update the <strong class="source-inline">OnClosed</strong> method, as shown in the following code:<p class="source-code">protected override void OnClosed(EventArgs e)</p><p class="source-code">{</p><p class="source-code">  _adTimer.Tick -= ChangeAds;</p><p class="source-code">  base.OnClosed(e);</p><p class="source-code">}</p></li>
			</ol>
			<p>We have now rectified our memory leak by unsubscribing from the <strong class="source-inline">Tick</strong> event when we close<a id="_idIndexMarker555"/> the <strong class="source-inline">AdWindow</strong> constructor. Repeat the steps to profile this memory leak, and <a id="_idIndexMarker556"/>you will see <a id="_idIndexMarker557"/>that it has now been<a id="_idIndexMarker558"/> fixed, as shown in <em class="italic">Figure 5.36</em>:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/Figure_5.36.jpg" alt="Figure 5.36 – dotMemory showing that the memory leak has been fixed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.36 – dotMemory showing that the memory leak has been fixed</p>
			<p class="callout-heading"> Note</p>
			<p class="callout">We have effectively tracked down and fixed a memory leak with dotMemory. The memory leak was because we did not unsubscribe from an event we were subscribed to. This is a very common source of memory leaks in C#. To learn more about dotMemory and how to use it in various scenarios, please visit the official How-To documentation by <a id="_idIndexMarker559"/>JetBrains at <a href="https://www.jetbrains.com/help/dotmemory/Examples.html">https://www.jetbrains.com/help/dotmemory/Examples.html</a>.</p>
			<p>In the next section, we will look at how to track down and fix a UI freeze using dotTrace.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Finding the cause of a UI freeze with dotTrace</h1>
			<p>In this section, we <a id="_idIndexMarker560"/>will be using dotTrace to hunt <a id="_idIndexMarker561"/>down the reason for a UI freeze so that we can fix it. Again, to save time, we will use a project that has already been provided for you. Obtain the book's source code from the URL specified in the <em class="italic">Technical requirements</em> section. In the source code for <strong class="source-inline">CH05</strong>, you will find a project called <strong class="source-inline">CH05_BatchFileProcessing</strong>.</p>
			<p>This project opens a number of text files specified by the user and then reverses each of the strings it finds. When the user clicks on the <strong class="bold">Process Files</strong> button, a separate <strong class="source-inline">BackgroundWorker</strong> thread is started that runs on a separate thread. In the left-hand corner, the progress of file processing is displayed. This changes to <strong class="bold">All files were successfully processed when done</strong>. However, a problem exists whereby the UI freezes while the files are being processed.</p>
			<p>To find the source <a id="_idIndexMarker562"/>of this UI freeze and fix it, we are going <a id="_idIndexMarker563"/>to use timeline profiling, which is available using dotTrace:</p>
			<ol>
				<li value="1">Build the <strong class="bold">CH05_BatchFileProcessing</strong> project in <strong class="bold">Release</strong> mode.</li>
				<li>Open dotTrace.</li>
				<li>Select <strong class="bold">Profile Local App</strong> | <strong class="bold">.NET Core Application</strong> | <strong class="bold">Timeline</strong>, and select the executable you just compiled. Make sure to tick <strong class="bold">Collect profiling data from start</strong>. <em class="italic">Figure 5.37</em> shows dotTrace being configured before we start running it:</li>
			</ol>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/Figure_5.37_B16617.jpg" alt="Figure 5.37 – dotTrace prior to us running the Timeline profiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.37 – dotTrace prior to us running the Timeline profiler</p>
			<ol>
				<li value="4">Click on the <strong class="bold">Run</strong> button to begin the timeline profiling. The profiler will be opened, as shown in <em class="italic">Figure 5.38</em>:</li>
			</ol>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/Figure_5.38_B16617.jpg" alt="Figure 5.38 – The dotTrace Timeline profiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.38 – The dotTrace Timeline profiler</p>
			<p>The<a id="_idIndexMarker564"/> profiler <a id="_idIndexMarker565"/>will start the <strong class="bold">CH05_BatchFileProcessor</strong> program, as shown in <em class="italic">Figure 5.39</em>:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/Figure_5.39_B16617.jpg" alt="Figure 5.39 – The batch file processor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.39 – The batch file processor</p>
			<p>When the application has finished processing the files, the UI will be displayed, as shown in <em class="italic">Figure 5.40</em>:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/Figure_5.40_B16617.jpg" alt="Figure 5.40 – CH05_BatchFileProcessor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.40 – CH05_BatchFileProcessor</p>
			<ol>
				<li value="5">Click<a id="_idIndexMarker566"/> on the <strong class="bold">Get Snapshot</strong> and <strong class="bold">Wait</strong> buttons on the timeline profiler. This will save the <a id="_idIndexMarker567"/>snapshot and open it in the dotTrace <strong class="bold">Timeline Viewer</strong> application, as shown in <em class="italic">Figure 5.41</em>:</li>
			</ol>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/Figure_5.41.jpg" alt="Figure 5.41 – The dotTrace Timeline Viewer application with a loaded timeline snapshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.41 – The dotTrace Timeline Viewer application with a loaded timeline snapshot</p>
			<ol>
				<li value="6">You can close the <strong class="bold">CH05_BatchFileProcessor</strong> and dotTrace profiler applications down. But keep the dotTrace <strong class="bold">Timeline Viewer</strong> application open.</li>
				<li>All filter values are calculated for all currently visible threads. We are only interested in threads that have activity on them. So, hide all threads that have no activity on them by selecting them, right-clicking, and selecting <strong class="bold">Hide</strong> selected threads.</li>
				<li>Our <strong class="bold">BackgroundWorker</strong> thread is the <strong class="bold">.NET ThreadPoolWorker</strong> thread with<a id="_idIndexMarker568"/> an ID of <strong class="bold">12764</strong>, as shown in <em class="italic">Figure 5.42</em>:</li>
			</ol>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/Figure_5.42.jpg" alt="Figure 5.42 – The dotTrace Timeline Viewer application with our &#13;&#10;BackgroundWorker thread highlighted&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.42 – The dotTrace Timeline Viewer application with our BackgroundWorker thread highlighted</p>
			<ol>
				<li value="9">Zoom into <a id="_idIndexMarker569"/>the timeline for the <strong class="bold">.NET ThreadPool Worker</strong>. You can see that the timeline consists of three states. These states are <strong class="bold">Running</strong>, <strong class="bold">Waiting for CPU</strong>, and <strong class="bold">Waiting</strong>. You can see our thread's timeline in <em class="italic">Figure 5.43</em>:</li>
			</ol>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/Figure_5.43_B16617.jpg" alt="Figure 5.43 – Our thread's activity within the timeline trace&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.43 – Our thread's activity within the timeline trace</p>
			<p>On the left-hand side of the screen, you will see the <strong class="bold">Thread State</strong> section within the <strong class="bold">Filters</strong> panel. Select each of the states in turn, and you will see the timeline highlighted accordingly. Have a play with all of the different filters available. Investigate what each option provides you. This is a good way to learn. The collapsed <strong class="bold">Filters</strong> panel is displayed in <em class="italic">Figure 5.44</em>:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/Figure_5.44_B16617.jpg" alt="Figure 5.44 – The collapsed dotTrace Filters panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.44 – The collapsed dotTrace Filters panel</p>
			<ol>
				<li value="10">On the<a id="_idIndexMarker570"/> right-hand <a id="_idIndexMarker571"/>side of the screen, you will see the <strong class="bold">Call Stack</strong> panel and the <strong class="bold">Source View</strong> panel. If you click anywhere on the thread's timeline, you will see the call stack at that point in time. The call tree will be displayed for that stack trace. If you click on an entry in the call stack, the code will be decompiled and displayed within the <strong class="bold">Source View</strong> tab. This functionality enables you to see what code is running at what point in time. Also, this view displays the full assembly's name, namespace, and class name for the code you are looking at. <em class="italic">Figure 5.45</em> displays the <strong class="bold">Call Stack</strong> panel:</li>
			</ol>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/Figure_5.45_B16617.jpg" alt="Figure 5.45 – The dotTrace Call Stack panel with the Backtraces tab displayed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.45 – The dotTrace Call Stack panel with the Backtraces tab displayed</p>
			<p><em class="italic">Figure 5.46</em> displays<a id="_idIndexMarker572"/> the <strong class="bold">Source View</strong> panel:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/Figure_5.46_B16617.jpg" alt="Figure 5.46 – The dotTrace Source View screen showing decompiled C# and IL source code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.46 – The dotTrace Source View screen showing decompiled C# and IL source code</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The colored bar that runs across the <strong class="bold">Call Stack</strong> panel, as shown in <em class="italic">Figure 5.45</em>, displays the different subsystems in use; in this case, <strong class="source-inline">String</strong>. Depending on what is happening at a particular point in time, this line might be multicolored if multiple subsystems are in use. This bar is also useful for showing thread locks, among other things.</p>
			<ol>
				<li value="11">Now we<a id="_idIndexMarker573"/> are <a id="_idIndexMarker574"/>ready to investigate why our UI is freezing. The purple lines in <em class="italic">Figure 5.47</em> represent moments in time when our UI is freezing:</li>
			</ol>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/Figure_5.47_B16617.jpg" alt="Figure 5.47 – The dotTrace filtered view displaying our thread and highlighting UI freezes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.47 – The dotTrace filtered view displaying our thread and highlighting UI freezes</p>
			<p>The <a id="_idIndexMarker575"/>purple line <a id="_idIndexMarker576"/>that we are interested in is the last very long one.</p>
			<ol>
				<li value="12">In the <strong class="bold">Filters</strong> section, select <strong class="bold">Events</strong> | <strong class="bold">.NET Memory Allocation</strong>.</li>
				<li>Then, select <strong class="bold">Thread State</strong> | <strong class="bold">Running</strong>.</li>
				<li>Select <strong class="bold">Subsystems</strong> | <strong class="bold">User code</strong>, and deselect everything else. You should see the following under <strong class="bold">Methods and Subsystems</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/Figure_5.48_B16617.jpg" alt="Figure 5.48 – The dotTrace Methods and Subsystems screen highlighting problematic user code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.48 – The dotTrace Methods and Subsystems screen highlighting problematic user code</p>
			<p>Looking<a id="_idIndexMarker577"/> at the preceding highlighted <a id="_idIndexMarker578"/>method called <strong class="source-inline">ProcessInProgress</strong>, we are calling it 100% of the time during the time period when the UI freeze occurs. Clicking on <strong class="source-inline">ProcessInProgress</strong> will display the contents of the <strong class="source-inline">MainWindow.xaml.cs</strong> file. Our offending code is as follows:</p>
			<p class="source-code">private void ProcessInProgress(</p>
			<p class="source-code">object sender, </p>
			<p class="source-code">ProgressChangedEventArgs e</p>
			<p class="source-code">)</p>
			<p class="source-code">{</p>
			<p class="source-code">var upd = (ProgressUpdater)e.UserState;</p>
			<p class="source-code">lblProgress.Content = $"File {upd.CurrentFileNmb} of {upd.</p>
			<p class="source-code">    TotalFiles}: {e.ProgressPercentage}%";</p>
			<p class="source-code">} </p>
			<p>Our <a id="_idIndexMarker579"/>code is updating the progress label with the value <a id="_idIndexMarker580"/>passed into the method, which is of the <strong class="source-inline">ProgressChangedEventArgs</strong> type. So, what is calling this method? It is the <strong class="source-inline">ProcessFiles</strong> method in the <strong class="source-inline">FileProcessor</strong> class:</p>
			<p class="source-code">...                </p>
			<p class="source-code">for (var i = 0; i &lt; FilePaths.Count; i++)</p>
			<p class="source-code">{</p>
			<p class="source-code">     ...</p>
			<p class="source-code">for (var j = 0; j &lt; _lines.Length; j++)</p>
			<p class="source-code">{</p>
			<p class="source-code">    var line = _lines[j];</p>
			<p class="source-code">    var stringReverser = new StringReverser(line);</p>
			<p class="source-code">    _lines[j] = stringReverser.Reverse();</p>
			<p class="source-code">    if (j % 5 == 0)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var p = (float)(j + 1) / _lines.Length * 100;</p>
			<p class="source-code">        Worker.ReportProgress((int)p, _updater);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">File.WriteAllLines(path, _lines);</p>
			<p class="source-code">}</p>
			<p>This <a id="_idIndexMarker581"/>method iterates through the files that the<a id="_idIndexMarker582"/> user has selected. Each file is read along with each line, line by line. Each line has its text reversed. The problem is that we are calling this method far too often. So, the solution is to change <strong class="source-inline">(j % 5 == 0)</strong> to <strong class="source-inline">(j% 1000 == 0)</strong>.</p>
			<ol>
				<li value="15">Make the change to the code recompile and rerun the profiler. This time, there will be no lag. And you will see that the UI freeze has been fixed.</li>
			</ol>
			<p>Now you have used dotTrace and the Timeline profile to track down and fix a UI freeze. In the final section, we will look a<a id="_idTextAnchor109"/>t using dotTrace to optimize application performance and memory traffic. </p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Optimizing application performance and memory traffic with dotTrace</h1>
			<p>In this section, we<a id="_idIndexMarker583"/> are going to continue tracing our <strong class="source-inline">CH05_BatchFileProcessing</strong> project. We have fixed the UI freeze and will <a id="_idIndexMarker584"/>be running another trace to see<a id="_idIndexMarker585"/> whether we can identify any further issues. When analyzing the trace, we will see that a lot of memory traffic is <a id="_idIndexMarker586"/>being generated that is affecting the performance of our application. So, we will address this issue and fix it:</p>
			<ol>
				<li value="1">Open dotTrace. Your previous session should be saved. Select it, and click on the <strong class="bold">Run</strong> button to start tracing. The sample application will then be started.</li>
				<li>Select the text files, and click on the <strong class="bold">Process Files</strong> button.</li>
				<li>Once the files have been processed, kill the application. This will flush the data and load our trace in the trace viewer. Then, close dotTrace.</li>
				<li>Once the trace snapshot has been loaded into <strong class="bold">Timeline Viewer</strong>, click on the button to <strong class="bold">Show Snapshot</strong>.</li>
				<li>In the <strong class="bold">Filters</strong> view, select <strong class="bold">Events</strong> | <strong class="bold">.NET Memory Allocations and Thread State</strong> | <strong class="bold">Running</strong>.</li>
				<li>Hide all threads except our <strong class="bold">.NET ThreadPool Worker</strong> thread.</li>
				<li>In<a id="_idIndexMarker587"/> the <strong class="bold">Call Stack</strong> view<a id="_idIndexMarker588"/> under <strong class="bold">Methods and Subsystems</strong>, click on <strong class="bold">Own</strong> to view the percentage of memory<a id="_idIndexMarker589"/> allocations made by our code. You <a id="_idIndexMarker590"/>will see that our method for reversing a string allocates <strong class="bold">28.5%</strong> of the network traffic. The largest amount of memory traffic is generated by the <strong class="bold">Concat</strong> method within the <strong class="source-inline">System.String</strong> class. This will be the result of our <strong class="source-inline">CH05_BatchFileProcessing.StringReverse.Reverse()</strong> call. <em class="italic">Figure 5.49</em> shows the results of our trace in which we can see our methods and the percentages of memory traffic they generate:</li>
			</ol>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/Figure_5.49_B16617.jpg" alt="Figure 5.49 – The dotTrace Timeline Viewer Call Stack screen showing our methods and memory traffic percentage&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.49 – The dotTrace Timeline Viewer Call Stack screen showing our methods and memory traffic percentage</p>
			<p>The two different MB sizes are our own memory allocation in this method excluding memory allocations in the child method calls from this method/the amount of <a id="_idIndexMarker591"/>memory allocated by this method or any child methods called from this method. As<a id="_idIndexMarker592"/> you can see, the memory allocation is <strong class="bold">73 MB</strong>/<strong class="bold">252 MB</strong> for the <strong class="source-inline">Reverse()</strong> method and <strong class="bold">2.9 MB</strong>/<strong class="bold">255 MB</strong> for the <strong class="source-inline">ProcessFiles()</strong> method.</p>
			<ol>
				<li value="8">Open<a id="_idIndexMarker593"/> this class in Visual Studio. The<a id="_idIndexMarker594"/> code for the <strong class="source-inline">Reverse()</strong> method is as follows:<p class="source-code">public string Reverse()</p><p class="source-code">{</p><p class="source-code">char[] charArray = _original.ToCharArray();</p><p class="source-code">string stringResult = null;</p><p class="source-code">for (int i = charArray.Length; i &gt; 0; i--)</p><p class="source-code">{</p><p class="source-code">    stringResult += charArray[i - 1];</p><p class="source-code">}</p><p class="source-code">return stringResult;</p><p class="source-code">}</p></li>
			</ol>
			<p>As you can see, this method reverses a string by assigning it to an array. The array is then iterated backward, with each character assigned to a string using string concatenation. And herein lies the problem with our application's performance.</p>
			<p>It is well documented that the most performant way to build up a string is to use the <strong class="source-inline">StringBuilder</strong> class. And we could do that here. However, there is another way to <a id="_idIndexMarker595"/>improve the performance of this method. Replace the existing <strong class="source-inline">Reverse()</strong> string method with the following version:</p>
			<p class="source-code">public string Reverse()</p>
			<p class="source-code">{</p>
			<p class="source-code">     char[] charArray = _original.ToCharArray();</p>
			<p class="source-code">     Array.Reverse(charArray);</p>
			<p class="source-code">return new string(charArray);</p>
			<p class="source-code">}</p>
			<p>In our <a id="_idIndexMarker596"/>revised code, we <a id="_idIndexMarker597"/>reverse the array and return a new string from the reverse array.</p>
			<ol>
				<li value="9">Build <a id="_idIndexMarker598"/>your project in <strong class="bold">Release</strong> mode and then run a new trace. <em class="italic">Figure 5.50</em> show<a id="_idTextAnchor111"/>s the results of the new trace:</li>
			</ol>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/Figure_5.50_B16617.jpg" alt="Figure 5.50 – The new trace showing our improved performance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.50 – The new trace showing our improved performance</p>
			<p>We can<a id="_idIndexMarker599"/> see from our trace that the<a id="_idIndexMarker600"/> memory allocation for the <strong class="source-inline">ProcessFiles</strong> method <a id="_idIndexMarker601"/>went from <strong class="bold">2.9 MB</strong>/<strong class="bold">255 MB</strong>, generating <strong class="bold">1.2%</strong> of the memory <a id="_idIndexMarker602"/>traffic, to <strong class="bold">3.8 MB</strong>/<strong class="bold">37 MB</strong> of memory allocation, generating <strong class="bold">10.1%</strong> of the memory traffic.</p>
			<p>Plus, our <strong class="source-inline">Reverse()</strong> method went from allocating <strong class="bold">73 MB</strong>/<strong class="bold">252 MB</strong>, and generating <strong class="bold">28.5%</strong> of the memory traffic, to allocating <strong class="bold">0 MB</strong>/<strong class="bold">19 MB</strong> of memory, generating <strong class="bold">0%</strong> of the memory traffic.</p>
			<p>That is a good performance improvement!</p>
			<p>In this chapter, we have covered various methods of measuring and analyzing code. With the data we obtained, we have managed to fix a memory leak caused by not unsubscribing <a id="_idIndexMarker603"/>to event<a id="_idIndexMarker604"/> handlers, fix a UI freeze caused by too frequent UI updates, and improve<a id="_idIndexMarker605"/> the application performance and memory traffic caused by the<a id="_idIndexMarker606"/> way we were batch processing string reversal. Now, it is time to summarize what we have learned.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor112"/>Summary</h1>
			<p>We started with application profiling and tracing by looking at the various code metrics that are available to us. Various tools have different metrics available. These metrics cover the application, assemblies, namespaces, types, methods, and fields.</p>
			<p>Then, we moved on to look at how we can perform static code analysis. We demonstrated static code analysis using Visual Studio 2022's built-in code analysis tool. We saw how to generate the following metrics: the maintainability index, cyclomatic complexity, the depth of inheritance, class coupling, lines of source code, and lines of executable code.</p>
			<p>The next thing we looked at was the generation of memory dumps and how to view them from within Visual Studio 2022. We can view the dump time, the dump's location, the name of the process, the processor architecture, any exception information, the OS version, and the CLR version. Additionally, we can view loaded module names and their versions and physical paths.</p>
			<p>Next, we looked at how to open the <strong class="bold">Modules</strong> window during a debugging session. The <strong class="bold">Modules</strong> window shows us the name and path of the module, whether the module is optimized, whether it is user code or system code, its symbol status, order, version, process, and AppDomain. We also saw the other options available in the <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> menu that add to our debugging capabilities.</p>
			<p>Then, we looked at the tracing and diagnostics tools called Visual Studio 2022, JetBrains dotMemory, and JetBrains dotTrace. These tools provide an overall excellent debugg<a id="_idTextAnchor113"/>ing experience that provides all the information we need to track down any type of bug, including those that cause memory leakages and other memory-related issues.</p>
			<p>Next, we looked at <strong class="source-inline">dotnet-counters</strong> and how to use this. We learned how to list the .NET processes that can be monitored. Then, we saw how to list the available well-known .NET counters. And our concluding section saw us collecting data and saving data to a file for post-analysis.</p>
			<p>Finally, we worked through three examples of using JetBrains dotMemory and JetBrains dotTrace to fix a memory leak and UI freeze, improve performance, and reduce memory traffic.</p>
			<p>In the next chapter, we will be taking a detailed look at the <strong class="bold">Collections</strong> framework. However, before then, take the time to further your reading and answer the following questions to reinforce what you have learned.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor114"/>Questions</h1>
			<ol>
				<li value="1">What aspects of our computer programs are covered by code metrics?</li>
				<li>What metrics does the Visual Studio 2022 static code analysis produce?</li>
				<li>What kinds of things can we view from the Visual Studio-generated minidumps with heap?</li>
				<li>What columns are available in the <strong class="bold">Modules</strong> window?</li>
				<li>What are the names of the four debugging, profiling, and tracing tools for performing the various diagnostic operations that we mentioned earlier?</li>
				<li>What operations did we carry out using .NET counters?</li>
			</ol>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor115"/>Further reading</h1>
			<ul>
				<li>Debugging Visual Studio 2019: <a href="https://docs.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-debugger?view=vs-2019">https://docs.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-debugger?view=vs-2019</a>.</li>
				<li>Dump files in the Visual Studio debugger: https://docs.microsoft.com/visualstudio/debugger/using-dump-files?view=vs-2019.</li>
				<li><strong class="source-inline">dotnet-counters</strong>: https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters.</li>
				<li><em class="italic">.NET Core Counters internals: how to integrate counters in your monitoring pipeline</em>: <a href="https://medium.com/criteo-engineering/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e#:~:text=dotnet-counters%3A%20collect%20the%20metrics%20corresponding%20to%20some%20performance,how%20to%20fetch%20them%20v">https://medium.com/criteo-engineering/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e#:~:text=dotnet-counters%3A%20collect%20the%20metrics%20corresponding%20to%20some%20performance,how%20to%20fetch%20them%20via%20the%20EventPipe%20infrastructure</a>.</li>
				<li><em class="italic">JetBrains dotTrace</em>: https://www.jetbrains.com/profiler/.</li>
				<li><em class="italic">JetBrains dotMemory</em>: <a href="https://www.jetbrains.com/dotmemory/">https://www.jetbrains.com/dotmemory/</a>.</li>
				<li><em class="italic">ndepend</em>: <a href="https://www.ndepend.com/">https://www.ndepend.com/</a>.</li>
				<li><em class="italic">Overview of .NET source code analysis</em>: <a href="https://docs.microsoft.com/dotnet/fundamentals/code-analysis/overview">https://docs.microsoft.com/dotnet/fundamentals/code-analysis/overview</a>.</li>
			</ul>
		</div>
	</body></html>