<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>7 Strategy, Abstract Factory, and Singleton Design Patterns</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="8">7 Strategy, Abstract Factory, and Singleton Design Patterns</h1>

<h2 data-number="8.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file32.png" style="width:10em"/></p>
<p>This chapter explores object creation using a few classic, simple, and yet powerful design patterns from the <strong>Gang of Four</strong> (<strong>GoF</strong>). These patterns allow developers to encapsulate and reuse behaviors, centralize object creation, add flexibility to our designs, or control object lifetime. Moreover, you will most likely use some of them in all software you build directly or indirectly in the future.</p>
<blockquote>
<p><strong>GoF</strong></p>
<blockquote>
<p>Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides are the authors of <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> (1994), known as the <strong>Gang of Four</strong> (<strong>GoF</strong>). In that book, they introduce 23 design patterns, some of which we revisit in this book.</p>
</blockquote>
</blockquote>
<p>Why are they that important? Because they are the building blocks of robust object composition and help create flexibility and reliability. Moreover, in <em>Chapter 8</em>, <em>Dependency Injection</em>, we make those patterns even more powerful!But first things first. In this chapter, we cover the following topics:</p>
<ul>
<li>The Strategy design pattern</li>
<li>The Abstract Factory design pattern</li>
<li>The Singleton design pattern</li>
</ul>


<h2 data-number="8.2">The Strategy design pattern</h2>
<p>The Strategy pattern is a behavioral design pattern that allows us to change object behaviors at runtime. We can also use this pattern to compose complex object trees and rely on it to follow the <strong>Open/Closed Principle</strong> (<strong>OCP</strong>) without much effort. Moreover, it plays a significant role in the <em>composition over inheritance</em> way of thinking. In this chapter, we focus on the behavioral part of the Strategy pattern. The next chapter covers how to use the Strategy pattern to compose systems dynamically.</p>

<h3 data-number="8.2.1">Goal</h3>
<p>The Strategy pattern aims to extract an algorithm (a strategy) from the host class needing it (the context or consumer). That allows the consumer to decide on the strategy (algorithm) to use at runtime.For example, we could design a system that fetches data from two different types of databases. Then we could apply the same logic to that data and use the same user interface to display it. To achieve this, we could use the Strategy pattern to create two strategies, one named <code>FetchDataFromSql</code> and the other <code>FetchDataFromCosmosDb</code>. Then we could plug the strategy we need at runtime in the <code>context</code> class. That way, when the consumer calls the <code>context</code>, the <code>context</code> does not need to know where the data comes from, how it is fetched, or what strategy is in use; it only gets what it needs to work, delegating the fetching responsibility to an abstracted strategy (an interface).</p>


<h3 data-number="8.2.2">Design</h3>
<p>Before any further explanation, let’s take a look at the following class diagram:</p>
<figure>
<img alt="Figure 7.1: Strategy pattern class diagram" src="img/file33.png"/><figcaption aria-hidden="true">Figure 7.1: Strategy pattern class diagram</figcaption>
</figure>
<p>Based on the preceding diagram, the building blocks of the Strategy pattern are the following:</p>
<ul>
<li><code>Context</code> is a class that depends on the <code>IStrategy</code> interface and leverages an implementation of the <code>IStrategy</code> interface to execute the <code>ExecuteAlgo</code> method.</li>
<li><code>IStrategy</code> is an interface defining the strategy API.</li>
<li><code>ConcreteStrategy1</code> and <code>ConcreteStrategy2</code> represent one or more different concrete implementations of the <code>IStrategy</code> interface.</li>
</ul>
<p>In the following diagram, we explore what happens at runtime. The actor represents any code consuming the <code>Context</code> object.</p>
<figure>
<img alt="Figure 7.2: Strategy pattern sequence diagram" src="img/file34.png"/><figcaption aria-hidden="true">Figure 7.2: Strategy pattern sequence diagram</figcaption>
</figure>
<p>When the consumer calls the <code>Context.SomeOperation()</code> method, it does not know which implementation is executed, which is an essential part of this pattern. The <code>Context</code> class should not be aware of the strategy it uses either. It should run the strategy through the interface, unaware of the implementation. That is the strength of the Strategy pattern: it abstracts the implementation away from both the <code>Context</code> class and its consumers. Because of that, we can change the strategy during either the object creation or at runtime without the object knowing, changing its behavior on the fly.</p>
<blockquote>
<p><strong>Note</strong></p>
<blockquote>
<p>We could even generalize that last sentence and extend it to any interface. Depending on an interface breaks the ties between the consumer and the implementation by relying on that abstraction instead.</p>
</blockquote>
</blockquote>


<h3 data-number="8.2.3">Project – Strategy</h3>
<p><strong>Context</strong>: We want to sort a collection differently, eventually even using different sort algorithms (out of the scope of the example but possible). Initially, we want to support sorting the elements of any collection in ascending or descending order.To achieve this, we need to implement the following building blocks:</p>
<ul>
<li>The <code>Context</code> is the <code>SortableCollection</code> class.</li>
<li>The <code>IStrategy</code> is the <code>ISortStrategy</code> interface.</li>
<li>The concrete strategies are:</li>
</ul>
<ol>
<li><code>SortAscendingStrategy</code></li>
<li><code>SortDescendingStrategy</code></li>
</ol>
<p>The consumer is a small REST API that allows the user to change the strategy, sort the collection, and display the items. Let’s start with the <code>ISortStrategy</code> interface:</p>
<div><pre><code>public interface ISortStrategy
{
    IOrderedEnumerable&lt;string&gt; Sort(IEnumerable&lt;string&gt; input);
}</code></pre>
</div>
<p>That interface contains only one method that expects a string collection as input and returns an ordered string collection. Now let’s inspect the two implementations:</p>
<div><pre><code>public class SortAscendingStrategy : ISortStrategy
{
    public IOrderedEnumerable&lt;string&gt; Sort(IEnumerable&lt;string&gt; input)
        =&gt; input.OrderBy(x =&gt; x);
}
public class SortDescendingStrategy : ISortStrategy
{
    public IOrderedEnumerable&lt;string&gt; Sort(IEnumerable&lt;string&gt; input)
        =&gt; input.OrderByDescending(x =&gt; x);
}</code></pre>
</div>
<p>Both implementations are super simple, using <strong>Language Integrated Query</strong> (<strong>LINQ</strong>) to sort the input and return the result directly.</p>
<blockquote>
<p><strong>Tip</strong></p>
<blockquote>
<p>When using expression-bodied methods, please ensure you do not make the method harder to read for your colleagues (or future you) by creating very complex one-liners. Writing multiple lines often makes the code easier to read.</p>
</blockquote>
</blockquote>
<p>The next building block to inspect is the <code>SortableCollection</code> class. It is composed of multiple string items (the <code>Items</code> property) and can sort them using an <code>ISortStrategy</code>. On top of that, it implements the <code>IEnumerable&lt;string&gt;</code> interface through its <code>Items</code> property, making it iterable. Here’s the class:</p>
<div><pre><code>using System.Collections;
using System.Collections.Immutable;
namespace MySortingMachine;
public sealed class SortableCollection : IEnumerable&lt;string&gt;
{
    private ISortStrategy _sortStrategy;
    private ImmutableArray&lt;string&gt; _items;
    public IEnumerable&lt;string&gt; Items =&gt; _items;
    public SortableCollection(IEnumerable&lt;string&gt; items)
    {
        _items = items.ToImmutableArray();
        _sortStrategy = new SortAscendingStrategy();
    }
    public void SetSortStrategy(ISortStrategy strategy)
        =&gt; _sortStrategy = strategy;
    public void Sort()
    {
        _items = _sortStrategy
            .Sort(Items)
            .ToImmutableArray()
        ;
    }
    public IEnumerator&lt;string&gt; GetEnumerator()
        =&gt; Items.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator()
        =&gt; ((IEnumerable)Items).GetEnumerator();
}</code></pre>
</div>
<p>The <code>SortableCollection</code> class is the most complex one so far, so let’s take a more in-depth look:</p>
<ul>
<li>The <code>_sortStrategy</code> field references the algorithm: an <code>ISortStrategy</code> implementation.</li>
<li>The <code>_items</code> field references the strings themselves.</li>
<li>The <code>Items</code> property exposes the strings to the consumers of the class.</li>
<li>The constructor initializes the <code>Items</code> property using the <code>items</code> parameter and sets the default sorting strategy.</li>
<li>The <code>SetSortStrategy</code> method allows consumers to change the strategy at runtime.</li>
<li>The <code>Sort</code> method uses the <code>_sortStrategy</code> field to sort the items.</li>
<li>The two <code>GetEnumerator</code> methods represent the implementation of the <code>IEnumerable&lt;string&gt;</code> interface and make the class enumerable through the <code>Items</code> property.</li>
</ul>
<p>With that code, we can see the Strategy pattern in action. The <code>_sortStrategy</code> field represents the current algorithm, respecting an <code>ISortStrategy</code> contract, which is updatable at runtime using the <code>SetSortStrategy</code> method. The <code>Sort</code> method delegates the work to the <code>ISortStrategy</code> implementation (the concrete strategy). Therefore, changing the value of the <code>_sortStrategy</code> field leads to a change of behavior of the <code>Sort</code> method, making this pattern very powerful yet simple. The highlighted code represents this pattern.</p>
<blockquote>
<p>The <code>_items</code> field is an <code>ImmutableArray&lt;string&gt;</code>, which makes changing the list impossible from the outside. For example, a consumer cannot pass a <code>List&lt;string&gt;</code> to the constructor, then change it later. Immutability has many advantages.</p>
</blockquote>
<p>Let’s experiment with this by looking at the <code>Consumer.API</code> project a REST API application that uses the previous code. Next is a breakdown of the <code>Program.cs</code> file:</p>
<div><pre><code>using MySortingMachine;
SortableCollection data = new(new[] { 
    "Lorem", "ipsum", "dolor", "sit", "amet." });</code></pre>
</div>
<p>The <code>data</code> member is the context, our sortable collection of items. Next, we look at some boilerplate code to create the application and serialize <code>enum</code> values as strings:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Services.ConfigureHttpJsonOptions(options =&gt; {
    options.SerializerOptions.Converters
        .Add(new JsonStringEnumConverter());
});
var app = builder.Build();</code></pre>
</div>
<p>Finally, the last part represents the consumer of the context:</p>
<div><pre><code>app.MapGet("/", () =&gt; data);
app.MapPut("/", (ReplaceSortStrategy sortStrategy) =&gt;
{
    ISortStrategy strategy = sortStrategy.SortOrder == SortOrder.Ascending
        ? new SortAscendingStrategy()
        : new SortDescendingStrategy();
    data.SetSortStrategy(strategy);
    data.Sort();
    return data;
});
app.Run();
public enum SortOrder
{
    Ascending,
    Descending
}
public record class ReplaceSortStrategy(SortOrder SortOrder);</code></pre>
</div>
<p>In the preceding code, we declared the following endpoints:</p>
<ul>
<li>The first endpoint returns the <code>data</code> object when a client sends a <code>GET</code> request.</li>
<li>The second endpoint allows changing the sort strategy based on the <code>SortOrder</code> enum when a client sends a <strong>PUT</strong> request. Once the strategy is modified, it sorts the collection and returns the sorted data.</li>
</ul>
<p>The highlighted code represents the consumption of this implementation of the strategy pattern.</p>
<blockquote>
<p>The <code>ReplaceSortStrategy</code> class is an input DTO. Combined with the <code>SortOrder</code> enum, they represent the data contract of the second endpoint.</p>
</blockquote>
<p>When we run the API and request the first endpoint, it responds with the following JSON body:</p>
<div><pre><code>[
  "Lorem",
  "ipsum",
  "dolor",
  "sit",
  "amet."
]</code></pre>
</div>
<p>As we can see, the items are in the order we set them because the code never called the <code>Sort</code> method. Next, let’s send the following HTTP request to the API to change the sort strategy to “descending”:</p>
<div><pre><code>PUT https://localhost:7280/
Content-Type: application/json
{
    "sortOrder": "Descending"
}</code></pre>
</div>
<p>After the execution, the endpoint responds with the following JSON data:</p>
<div><pre><code>[
  "sit",
  "Lorem",
  "ipsum",
  "dolor",
  "amet."
]</code></pre>
</div>
<p>As we can see from the content, the sorting algorithm worked. Afterward, the list will remain in the same order if we query the GET endpoint. Next, let’s look at this use case using a sequence diagram:</p>
<figure>
<img alt="Figure 7.3: Sequence diagram sorting the items using the “sort descending strategy”" src="img/file35.png"/><figcaption aria-hidden="true">Figure 7.3: Sequence diagram sorting the items using the “sort descending strategy”</figcaption>
</figure>
<p>The preceding diagram shows the <code>Program</code> creating a strategy and assigning it to <code>SortableCollection</code> using its <code>SetSortStrategy</code> method. Then, when the <code>Program</code> calls the <code>Sort()</code> method, the <code>SortableCollection</code> instance delegates the sorting computation to the underlying implementation of the <code>ISortStrategy</code> interface. That implementation is the <code>SortDescendingStrategy</code> class (the <strong>strategy</strong>) which was set by the <code>Program</code> at the beginning.</p>
<blockquote>
<p>Sending another <code>PUT</code> request but specifying the <code>Ascending</code> sort order end up in a similar result, but the items would be sorted alphabetically.</p>
<blockquote>
<p>The HTTP requests are available in the <code>Consumer.API.http</code> file.</p>
</blockquote>
</blockquote>
<p>From a strategy pattern perspective, the <code>SortableCollection</code> class (the <strong>context</strong>) is responsible for referencing and using the current strategy.</p>


<h3 data-number="8.2.4">Conclusion</h3>
<p>The Strategy design pattern is very effective at delegating responsibilities to other objects, allowing you to hand over the responsibility of an algorithm to other objects while keeping its usage trivial. It also allows having a rich interface (context) with behaviors that can change at runtime.As we can see, the Strategy pattern is excellent at helping us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: It helps extract responsibilities from external classes and use them interchangeably.</li>
<li><strong>O</strong>: It allows extending classes without updating its code by changing the current strategy at runtime, which is pretty much the actual definition of the OCP.</li>
<li><strong>L</strong>: It does not rely on inheritance. Moreover, it plays a large role in the <em>composition over inheritance principle</em>, helping us avoid inheritance altogether and the LSP.</li>
<li><strong>I</strong>: By creating smaller strategies based on lean and focused interfaces, the Strategy pattern is an excellent enabler of the ISP.</li>
<li><strong>D</strong>: The creation of dependencies is moved from the class using the strategy (the context) to the class’s consumer. That makes the context depend on abstraction instead of implementation, inverting the flow of control.</li>
</ul>
<blockquote>
<p><strong>C# Features</strong></p>
<blockquote>
<p>If you noticed C# features you are less familiar with, <em>Appendix A</em> explains many of them briefly.</p>
</blockquote>
</blockquote>
<p>Next, let’s explore the Abstract Factory pattern.</p>



<h2 data-number="8.3">The Abstract Factory design pattern</h2>
<p>The Abstract Factory design pattern is a creational design pattern from the GoF. We use creational patterns to create other objects, and factories are a very popular way of doing that.The Strategy pattern is the backbone of dependency injection, enabling the composition of complex object trees, while factories are used to create some of those complex objects that can’t be assembled automatically by a dependency injection library. More on that in the next chapter.</p>

<h3 data-number="8.3.1">Goal</h3>
<p>The Abstract Factory pattern is used to abstract the creation of a family of objects. It usually implies the creation of multiple object types within that family. A family is a group of related or dependent objects (classes).Let’s think about creating automotive vehicles. There are multiple vehicle types, and there are multiple models and makes for each type. We can use the Abstract Factory pattern to model this sort of scenario.</p>
<blockquote>
<p><strong>Note</strong></p>
<blockquote>
<p>The <em>Factory Method</em> pattern also focuses on creating a single type of object instead of a family. We only cover Abstract Factory here, but we use other types of factories later in the book.</p>
</blockquote>
</blockquote>


<h3 data-number="8.3.2">Design</h3>
<p>With Abstract Factory, the consumer asks for an abstract object and gets one. The factory is an abstraction, and the resulting objects are also abstractions, decoupling the creation of an object from its consumers.That allows adding or removing families of objects produced together without impacting the consumers (all actors communicate through abstractions).In our case, the family (the set of objects the factory can produce) is composed of a car and a bike, and each factory (family) must produce both objects.If we think about vehicles, we could have the ability to create low- and high-end models of each vehicle type. Here is a diagram representing how to achieve that using the Abstract Factory pattern:</p>
<figure>
<img alt="Figure 7.4: Abstract Factory class diagram" src="img/file36.png"/><figcaption aria-hidden="true">Figure 7.4: Abstract Factory class diagram</figcaption>
</figure>
<p>In the diagram, we have the following elements:</p>
<ul>
<li>The <code>IVehicleFactory</code> interface represents the Abstract Factory. It defines two methods: one that creates cars of type <code>ICar</code> and another that creates bikes of type <code>IBike</code>.</li>
<li>The <code>HighEndVehicleFactory</code> class is a concrete factory implementing the <code>IVehicleFactory</code> interface. It handles high-end vehicle model creation, and its methods return <code>HighEndCar</code> or <code>HighEndBike</code> instances.</li>
<li>The <code>LowEndVehicleFactory</code> is a second concrete factory implementing the <code>IVehicleFactory</code> interface. It handles low-end vehicle model creation, and its methods return <code>LowEndCar</code> or <code>LowEndBike</code> instances.</li>
<li><code>LowEndCar</code> and <code>HighEndCar</code> are two implementations of <code>ICar</code>.</li>
<li><code>LowEndBike</code> and <code>HighEndBike</code> are two implementations of <code>IBike</code>.</li>
</ul>
<p>Based on that diagram, consumers use the concrete factories through the <code>IVehicleFactory</code> interface and should not be aware of the implementation used underneath. Applying this pattern abstracts away the vehicle creation process.</p>


<h3 data-number="8.3.3">Project – Abstract Factory</h3>
<p><strong>Context</strong>: We need to support the creation of multiple models of vehicles. We also need to be able to add new models as they become available without impacting the system. To begin with, we only support high-end and low-end models, but we know this will change sooner rather than later. The program must only support the creation of cars and bikes.For the sake of our demo, the vehicles are just empty classes and interfaces because learning how to model vehicles is not necessary to understand the pattern; that would be noise. The following code represents those entities:</p>
<div><pre><code>public interface ICar { }
public interface IBike { }
public class LowEndCar : ICar { }
public class LowEndBike : IBike { }
public class HighEndCar : ICar { }
public class HighEndBike : IBike { }</code></pre>
</div>
<p>Next, we look at the part that we want to study—the factories:</p>
<div><pre><code>public interface IVehicleFactory
{
    ICar CreateCar();
    IBike CreateBike();
}
public class LowEndVehicleFactory : IVehicleFactory
{
    public IBike CreateBike() =&gt; new LowEndBike();
    public ICar CreateCar() =&gt; new LowEndCar();
}
public class HighEndVehicleFactory : IVehicleFactory
{
    public IBike CreateBike() =&gt; new HighEndBike();
    public ICar CreateCar() =&gt; new HighEndCar();
}</code></pre>
</div>
<p>The factories are simple implementations that describe the pattern well:</p>
<ul>
<li><code>LowEndVehicleFactory</code> creates low-end models.</li>
<li><code>HighEndVehicleFactory</code> creates high-end models.</li>
</ul>
<p>The consumer of this code is an xUnit test project. Unit tests are often your first consumers, especially if you are doing <strong>test-driven development</strong> (<strong>TDD</strong>).To make the tests easier, I created the following base test class:</p>
<div><pre><code>using Xunit;
namespace Vehicles;
public abstract class BaseAbstractFactoryTest&lt;TConcreteFactory, TExpectedCar, TExpectedBike&gt;
    where TConcreteFactory : IVehicleFactory, new()
{
    // Test methods here
}</code></pre>
</div>
<p>The key to that class is the following generic parameters:</p>
<ul>
<li>The <code>TConcreteFactory</code> parameter represents the type of concrete factory we want to test. Its generic constraint specifies that it must implement the <code>IVehicleFactory</code> interface and have a parameterless constructor.</li>
<li>The <code>TExpectedCar</code> parameter represents the type of <code>ICar</code> we expect from the <code>CreateCar</code> method.</li>
<li>The <code>TExpectedBike</code> parameter represents the type of <code>IBike</code> we expect from the <code>CreateBike</code> method.</li>
</ul>
<p>The first test method contained by that class is the following:</p>
<div><pre><code>[Fact]
public void Should_create_a_ICar_of_type_TExpectedCar()
{
    // Arrange
    IVehicleFactory vehicleFactory = new TConcreteFactory();
    var expectedCarType = typeof(TExpectedCar);
    // Act
    ICar result = vehicleFactory.CreateCar();
    // Assert
    Assert.IsType(expectedCarType, result);
}</code></pre>
</div>
<p>The preceding test method creates a vehicle factory using the TConcreteFactory generic parameter, then creates a car using that factory. Finally, it asserts ICar instance is of the expected type.The second test method contains by that class is the following:</p>
<div><pre><code>[Fact]
public void Should_create_a_IBike_of_type_TExpectedBike()
{
    // Arrange
    IVehicleFactory vehicleFactory = new TConcreteFactory();
    var expectedBikeType = typeof(TExpectedBike);
    // Act
    IBike result = vehicleFactory.CreateBike();
    // Assert
    Assert.IsType(expectedBikeType, result);
}</code></pre>
</div>
<p>The preceding test method is very similar and creates a vehicle factory using the <code>TConcreteFactory</code> generic parameter but then creates a bike instead of a car using that factory. Finally, it asserts <code>IBike</code> instance is of the expected type.</p>
<blockquote>
<p>I used the <code>ICar</code> and <code>IBike</code> interfaces to type the variables instead of <code>var</code>, to clarify the <code>result</code> variable type. In another context, I would have used <code>var</code> instead. The same applies to the <code>IVehicleFactory</code> interface.</p>
</blockquote>
<p>Now, to test the low-end factory, we declare the following test class:</p>
<div><pre><code>namespace Vehicles.LowEnd;
public class LowEndVehicleFactoryTest : BaseAbstractFactoryTest&lt;LowEndVehicleFactory, LowEndCar, LowEndBike&gt;
{ 
}</code></pre>
</div>
<p>That class solely depends on the <code>BaseAbstractFactoryTest</code> class and specifies the types to test for (highlighted).Next, to test the high-end factory, we declare the following test class:</p>
<div><pre><code>namespace Vehicles.HighEnd;
public class HighEndVehicleFactoryTest : BaseAbstractFactoryTest&lt;HighEndVehicleFactory, HighEndCar, HighEndBike&gt;
{
}</code></pre>
</div>
<p>Like the low-end factory, that class depends on the <code>BaseAbstractFactoryTest</code> class and specifies the types to test for (highlighted).</p>
<blockquote>
<p>In a more complex scenario where we can’t use the <code>new()</code> generic constraint, we can leverage an IoC container to create the instance of <code>TConcreteFactory</code> and optionally mock its dependencies.</p>
</blockquote>
<p>With that test code, we created the following two sets of two tests:</p>
<ul>
<li>A <code>LowEndVehicleFactory</code> class that should create a <code>LowEndCar</code> instance.</li>
<li>A <code>LowEndVehicleFactory</code> class that should create a <code>LowEndBike</code> instance.</li>
<li>A <code>HighEndVehicleFactory</code> class that should create a <code>HighEndCar</code> instance.</li>
<li>A <code>HighEndVehicleFactory</code> class that should create a <code>HighEndBike</code> instance.</li>
</ul>
<p>We now have four tests: two for bikes and two for cars.If we review the tests’ execution, both test methods are unaware of types. They use the Abstract Factory (<code>IVehicleFactory</code>) and test the <code>result</code> against the expected type without knowing what they are testing but the abstraction. That shows how loosely coupled the consumers (tests) and the factories are.</p>
<blockquote>
<p>We would use the <code>ICar</code> or the <code>IBike</code> instances in a real-world program to do something relevant based on the specifications. That could be a racing game or a rich person’s garage management system; who knows!</p>
</blockquote>
<p>The important part of this project is <strong>the abstraction of the object creation process</strong>. The test code (consumer) is not aware of the implementations.Next, we extend our implementation.</p>


<h3 data-number="8.3.4">Project – The mid-range vehicle factory</h3>
<p>To prove the flexibility of our design based on the Abstract Factory pattern, let’s add a new concrete factory named <code>MidRangeVehicleFactory</code>. That factory should return a <code>MidRangeCar</code> or a <code>MidRangeBike</code> instance. Once again, the car and bike are just empty classes (of course, in your programs, they will do something):</p>
<div><pre><code>public class MiddleGradeCar : ICar { }
public class MiddleGradeBike : IBike { }</code></pre>
</div>
<p>The new <code>MidRangeVehicleFactory</code> looks pretty much the same as the other two:</p>
<div><pre><code>public class MidRangeVehicleFactory : IVehicleFactory
{
    public IBike CreateBike() =&gt; new MiddleGradeBike();
    public ICar CreateCar() =&gt; new MiddleGradeCar();
}</code></pre>
</div>
<p>Now, to test the mid-range factory, we declare the following test class:</p>
<div><pre><code>namespace Vehicles.MidRange;
public class MidRangeVehicleFactoryTest : BaseAbstractFactoryTest&lt;MidRangeVehicleFactory, MidRangeCar, MidRangeBike&gt;
{
}</code></pre>
</div>
<p>Like the low-end and high-end factories, the mid-range test class depends on the <code>BaseAbstractFactoryTest</code> class and specifies the types to test for (highlighted).If we run the tests, we now have the following six passing tests:</p>
<figure>
<img alt="Figure 7.5: Visual Studio Test Explorer showcasing the six passing tests." src="img/file37.png"/><figcaption aria-hidden="true">Figure 7.5: Visual Studio Test Explorer showcasing the six passing tests.</figcaption>
</figure>
<p>So, without updating the consumer (the <code>AbstractFactoryTest</code> class), we added a new family of vehicles, the middle-end cars and bikes; kudos to the Abstract Factory pattern for that wonderfulness!</p>


<h3 data-number="8.3.5">Impacts of the Abstract Factory</h3>
<p>Before concluding, what would happen if we packed everything in a large interface instead of using an Abstract Factory (breaking the ISP along the way)? We could have created something like the following interface:</p>
<div><pre><code>public interface ILargeVehicleFactory
{
    HighEndBike CreateHighEndBike();
    HighEndCar CreateHighEndCar();
    LowEndBike CreateLowEndBike();
    LowEndCar CreateLowEndCar();
}</code></pre>
</div>
<p>As we can see, the preceding interface contains four specific methods and seems docile. However, the consumers of that code would be tightly coupled with those specific methods. For example, to change a consumer's behavior, we’d need to update its code, like changing the call from <code>CreateHighEndBike</code> to <code>CreateLowEndBike</code>, which breaks the OCP. On the other hand, with the factory method, we can set a different factory for the consumers to spit out different results, which moves the flexibility out of the object itself and becomes a matter of composing the object graph instead (more on that in the next chapter).Moreover, when we want to add mid-range vehicles, we must update the <code>ILargeVehicleFactory</code> interface, which becomes a breaking change (the implementation(s) of the <code>ILargeVehicleFactory</code> must be updated). Here’s an example of the two new methods:</p>
<div><pre><code>public interface ILargeVehicleFactory
{
    HighEndBike CreateHighEndBike();
    HighEndCar CreateHighEndCar();
    LowEndBike CreateLowEndBike();
    LowEndCar CreateLowEndCar();
    MidRangeBike CreateMidRangeBike();
    MidRangeCar CreateMidRangeCar();
}</code></pre>
</div>
<p>From there, once the implementation(s) are updated, if we want to consume the new mid-range vehicles, we need to open each consumer class and apply the changes there, which once again breaks the OCP.</p>
<blockquote>
<p>The most crucial part is understanding and seeing the coupling and its impacts. Sometimes, it's okay to tightly couple one or more classes together as we don’t always need the added flexibility the SOLID principles and some design patterns can bring.</p>
</blockquote>
<p>Now let’s conclude before exploring the last design pattern of the chapter.</p>


<h3 data-number="8.3.6">Conclusion</h3>
<p>The Abstract Factory pattern is excellent for abstracting away the creation of object families, isolating each family and its concrete implementation, leaving the consumers unaware of the family created at runtime by the factory.We talk more about factories in the next chapter; meanwhile, let’s see how the Abstract Factory pattern can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: Each concrete factory is solely responsible for creating a family of objects. You could combine Abstract Factory with other creational patterns, such as the <strong>Prototype</strong> and <strong>Builder</strong> patterns for more complex creational needs.</li>
<li><strong>O</strong>: We can create new families of objects, like the mid-range vehicles, without breaking existing client code.</li>
<li><strong>L</strong>: We aim at composition, so there’s no need for any inheritance, implicitly discarding the need for the LSP. If you use abstract classes in your design, you must ensure you don’t break the LSP when creating new abstract factories.</li>
<li><strong>I</strong>: Extracting a small abstraction with many implementations where each concrete factory focuses on one family makes that interface very focused on one task instead of having a large interface that exposes all types of products (like the <code>ILargeVehicleFactory</code> interface).</li>
<li><strong>D</strong>: By depending only on interfaces, the consumer is unaware of the concrete types it uses.</li>
</ul>
<p>Next, we explore the last design pattern of the chapter.</p>



<h2 data-number="8.4">The Singleton design pattern</h2>
<p>The Singleton design pattern allows creating and reusing a single instance of a class. We could use a static class to achieve almost the same goal, but not everything is doable using static classes. For example, a static class can’t implement an interface. We can’t pass an instance of a static class as an argument because there is no instance. We can only use static classes directly, which leads to tight coupling every time.The Singleton pattern in C# is an anti-pattern, and we should rarely use it, if ever, and use dependency injection instead. That said, it is a classic design pattern worth learning to at least avoid implementing it. We explore a better alternative in the next chapter.Here are a few reasons why we are covering this pattern:</p>
<ul>
<li>It translates into a singleton scope in the next chapter.</li>
<li>Without knowing about it, you cannot locate it, try to remove it, or avoid its usage.</li>
<li>It is a simple pattern to explore.</li>
<li>It leads to other patterns, such as the <strong>Ambient Context</strong> pattern.</li>
</ul>

<h3 data-number="8.4.1">Goal</h3>
<p>The Singleton pattern limits the number of instances of a class to one. Then, the idea is to reuse the same instance subsequently. A singleton encapsulates both the object logic itself and its creational logic. For example, the Singleton pattern could lower the cost of instantiating an object with a large memory footprint since the program instantiates it only once.Can you think of a SOLID principle that gets broken right there?The Singleton pattern promotes that one object must have two responsibilities, breaking the <strong>Single Responsibility Principle</strong> (<strong>SRP</strong>). A singleton is the object itself and its own factory.</p>


<h3 data-number="8.4.2">Design</h3>
<p>This design pattern is straightforward and is limited to a single class. Let’s start with a class diagram:</p>
<figure>
<img alt="Figure 7.6: Singleton pattern class diagram" src="img/file38.png"/><figcaption aria-hidden="true">Figure 7.6: Singleton pattern class diagram</figcaption>
</figure>
<p>The <code>Singleton</code> class is composed of the following:</p>
<ul>
<li>A private static field that holds its unique instance.</li>
<li>A public static <code>Create()</code> method that creates or returns the unique instance.</li>
<li>A private constructor, so external code cannot instantiate it without passing by the <code>Create</code> method.</li>
</ul>
<blockquote>
<p>You can name the <code>Create()</code> method anything or even get rid of it, as we see in the next example. We could name it <code>GetInstance()</code>, or it could be a static property named <code>Instance</code> or bear any other relevant name.</p>
</blockquote>
<p>We can translate the preceding diagram to the following code:</p>
<div><pre><code>public class MySingleton
{
    private static MySingleton? _instance;
    private MySingleton() { }
    public static MySingleton Create()
    {
        _instance ??= new MySingleton();
        return _instance;
    }
}</code></pre>
</div>
<blockquote>
<p>The null-coalescing assignment operator <code>??=</code> assigns the new instance of <code>MySingleton</code> only if the <code>_instance</code> member is <code>null</code>. That line is equivalent to writing the following if statement:</p>
</blockquote>
<pre><code>if (_instance == null)
{
    _instance = new MySingleton();
}</code></pre>
<p>Before discussing the code more, let’s explore our new class's behavior. We can see in the following unit test that <code>MySingleton.Create()</code> always returns the same instance as expected:</p>
<div><pre><code>public class MySingletonTest
{
    [Fact]
    public void Create_should_always_return_the_same_instance()
    {
        var first = MySingleton.Create();
        var second = MySingleton.Create();
        Assert.Same(first, second);
    }
}</code></pre>
</div>
<p>And voilà! We have a working Singleton pattern, which is extremely simple—probably the most simple design pattern that I can think of.Here is what is happening under the hood:</p>
<ol>
<li>The first time that a consumer calls <code>MySingleton.Create()</code>, it creates the first instance of <code>MySingleton</code>. Since the constructor is <code>private</code>, it can only be created from the inside.</li>
<li>The <code>Create</code> method then persists that first instance to the <code>_instance</code> field for future use.</li>
<li>When a consumer calls <code>MySingleton.Create()</code> a second time, it returns the <code>_instance</code> field, reusing the class's previous (and only) instance.</li>
</ol>
<p>Now that we understand the logic, there is a potential issue with that design: it is not thread-safe. If we want our singleton to be thread-safe, we can <code>lock</code> the instance creation like this:</p>
<div><pre><code>public class MySingletonWithLock
{
    private static readonly object _myLock = new();
    private static MySingletonWithLock? _instance;
    private MySingletonWithLock() { }
    public static MySingletonWithLock Create()
    {
        lock (_myLock)
        {
            _instance ??= new MySingletonWithLock();
        }
        return _instance;
    }
}</code></pre>
</div>
<p>In the preceding code, we ensure two threads are not attempting to access the <code>Create</code> method simultaneously to ensure they are not getting different instances. Next, we improve our thread-safe example by making it shorter.</p>


<h3 data-number="8.4.3">An alternate (better) way</h3>
<p>Previously, we used the “long way” of implementing the Singleton pattern and had to implement a thread-safe mechanism. Now that classic is behind us. We can shorten that code and even get rid of the <code>Create()</code> method like this:</p>
<div><pre><code>public class MySimpleSingleton
{
    public static MySimpleSingleton Instance { get; } = new MySimpleSingleton();
    private MySimpleSingleton() { }
}</code></pre>
</div>
<p>The preceding code relies on the static initializer to ensure that only one instance of the <code>MySimpleSingleton</code> class is created and assigned to the <code>Instance</code> property.</p>
<blockquote>
<p>This simple technique should do the trick unless the singleton's constructor executes some heavy processing.</p>
</blockquote>
<p>With the property instead of a method, we can use the singleton class like this:</p>
<div><pre><code>MySimpleSingleton.Instance.SomeOperation();</code></pre>
</div>
<p>We can prove the correctness of that claim by executing the following test method:</p>
<div><pre><code>[Fact]
public void Create_should_always_return_the_same_instance()
{
    var first = MySimpleSingleton.Instance;
    var second = MySimpleSingleton.Instance;
    Assert.Same(first, second);
}</code></pre>
</div>
<p>It is usually best to delegate responsibilities to the language or the framework whenever possible like we did here with the property initializer. Using a static constructor would also be a valid, thread-safe alternative, once again delegating the job to language features.</p>
<blockquote>
<p><strong>Beware of the arrow operator.</strong></p>
<blockquote>
<p>It may be tempting to use the arrow operator <code>=&gt;</code> to initialize the <code>Instance</code> property like this: <code>public static MySimpleSingleton Instance =&gt; new MySimpleSingleton();</code>, but doing so would return a new instance every time. This would defeat the purpose of what we want to achieve. On the other hand, the property initializer runs only once.</p>
</blockquote>
<blockquote>
<p>The arrow operator makes the <code>Instance</code> property an expression-bodied member, equivalent to creating the following getter: <code>get { return new MySimpleSingleton(); }</code>. You can consult <em>Appendix A</em> for more information about expression-bodies statements.</p>
</blockquote>
</blockquote>
<p>Before we conclude the chapter, the Singleton (anti-)pattern also leads to a code smell.</p>


<h3 data-number="8.4.4">Code smell – Ambient Context</h3>
<p>That last implementation of the <strong>Singleton</strong> pattern led us to the <strong>Ambient Context</strong> pattern. We could even call the Ambient Context an anti-pattern, but let’s just state that it is a consequential code smell.I do not recommend using ambient contexts for multiple reasons. First, I do my best to avoid anything global; an ambient context is a global state. Globals, like static members in C#, can look very convenient because they are easy to access and use. They are always there and accessible whenever needed: easy. However, they bring many drawbacks in terms of flexibility and testability.When using an ambient context, the following occurs:</p>
<ul>
<li><strong>Tight coupling</strong>: global states lead to less flexible systems; consumers are tightly coupled with the ambient context.</li>
<li><strong>Testing difficulty</strong>: global objects are harder to replace, and we cannot easily swap them for other objects, like a mock.</li>
<li><strong>Unforseen impacts</strong>: if some part of your system messes up your global state, that may have unexpected consequences on other parts of your system, and you may have difficulty finding out the root cause of those errors.</li>
<li><strong>Potential misuse</strong>: developers could be tempted to add non-global concerns to the ambient context, leading to a bloated component.</li>
</ul>
<blockquote>
<p><strong>Fun fact</strong></p>
<blockquote>
<p>Many years ago, before the JavaScript frameworks era, I fixed a bug in a system where some function was overriding the value of <code>undefined</code> due to a subtle error. This is an excellent example of how global variables could impact your whole system and make it more brittle. The same applies to the Ambient Context and Singleton patterns in C#; globals can be dangerous and annoying.</p>
</blockquote>
<blockquote>
<p>Rest assured that, nowadays, browsers won’t let developers update the value of <code>undefined</code>, but it was possible back then.</p>
</blockquote>
</blockquote>
<p>Now that we’ve discussed global objects, an ambient context is a global instance, usually available through a static property. The Ambient Context pattern can bring good things, but it is a code smell that smells bad.</p>
<blockquote>
<p>There are a few examples in .NET Framework, such as <code>System.Threading.Thread.CurrentPrincipal</code> and <code>System.Threading.Thread.CurrentThread</code>, that are scoped to a thread instead of being purely global like most static members. An ambient context does not have to be a singleton, but that is what they are most of the time. Creating a non-global (scoped) ambient context is harder and requires more work.</p>
</blockquote>
<p>Is the Ambient Context pattern good or bad? I’d go with both! It is useful primarily because of its convenience and ease of use. Most of the time, it could and should be designed differently to reduce its drawbacks.There are many ways of implementing an ambient context, but to keep it brief and straightforward, we are focusing only on the singleton version of the ambient context. The following code is a good example:</p>
<div><pre><code>public class MyAmbientContext
{
    public static MyAmbientContext Current { get; } = new MyAmbientContext();
    private MyAmbientContext() { }
    public void WriteSomething(string something)
    {
        Console.WriteLine($"This is your something: {something}");
    }
}</code></pre>
</div>
<p>That code is an exact copy of the <code>MySimpleSingleton</code> class, with a few subtle changes:</p>
<ul>
<li><code>Instance</code> is named <code>Current</code>.</li>
<li>The <code>WriteSomething</code> method is new but has nothing to do with the Ambient Context pattern itself; it is just to make the class do something.</li>
</ul>
<p>If we take a look at the test method that follows, we can see that we use the ambient context by calling <code>MyAmbientContext.Current</code>, just like we did with the last singleton implementation:</p>
<div><pre><code>[Fact]
public void Should_echo_the_inputted_text_to_the_console()
{
    // Arrange (make the console write to a StringBuilder
    // instead of the actual console)
    var expectedText = "This is your something: Hello World!" + Environment.NewLine;
    var sb = new StringBuilder();
    using (var writer = new StringWriter(sb))
    {
        Console.SetOut(writer);
        // Act
        MyAmbientContext.Current.WriteSomething("Hello World!");
    }
    // Assert
    var actualText = sb.ToString();
    Assert.Equal(expectedText, actualText);
}</code></pre>
</div>
<p>The property could include a public setter or support more complex logic. Building the right classes and exposing the right behaviors is up to you and your specifications.To conclude this interlude, avoid ambient contexts and use instantiable classes instead. We see how to replace a singleton with a single instance of a class using dependency injection in the next chapter. That gives us a more flexible alternative to the Singleton pattern. We can also create a single instance per HTTP request, which saves us the trouble of coding it while eliminating the disadvantages.</p>


<h3 data-number="8.4.5">Conclusion</h3>
<p>The Singleton pattern allows the creation of a single instance of a class for the whole lifetime of the program. It leverages a <code>private static</code> field and a <code>private</code> constructor to achieve its goal, exposing the instantiation through a <code>public static</code> method or property. We can use a field initializer, the <code>Create</code> method itself, a static constructor, or any other valid C# options to encapsulate the initialization logic.Now let’s see how the Singleton pattern can help us (not) follow the SOLID principles:</p>
<ul>
<li><strong>S</strong>: The singleton violates this principle because it has two clear responsibilities:
<ul>
<li>It has the responsibility for which it has been created (not illustrated here), like any other class.</li>
<li>It has the responsibility of creating and managing itself (lifetime management).</li>
</ul></li>
<li><strong>O</strong>: The Singleton pattern also violates this principle. It enforces a single static instance, locked in place by itself, which limits extensibility. It is impossible to extend the class without changing its code.</li>
<li><strong>L</strong>: There is no inheritance directly involved, which is the only good point.</li>
<li><strong>I</strong>: No C# interface is involved, which violates this principle. However, we can look at the class interface instead, so building a small targeted singleton instance would satisfy this principle.</li>
<li><strong>D</strong>: The singleton class has a rock-solid hold on itself. It also suggests using its static property (or method) directly without using an abstraction, breaking the DIP with a sledgehammer.</li>
</ul>
<p>As you can see, the Singleton pattern violates all the SOLID principles but the LSP and should be used cautiously. Having only a single instance of a class and always using that same instance is a common concept. However, we explore more proper ways to do this in the next chapter, leading me to the following advice: do not use the Singleton pattern, and if you see it used somewhere, try refactoring it out.</p>
<blockquote>
<p>I suggest avoiding static members that create global states as a general good practice. They can make your system less flexible and more brittle. There are occasions where <code>static</code> members are worth using, but try keeping their number as low as possible. Ask yourself if you can replace that <code>static</code> member or class with something else before coding one.</p>
</blockquote>
<p>Some may argue that the Singleton design pattern is a legitimate way of doing things. However, in ASP.NET Core, I am afraid I have to disagree: we have a powerful mechanism to do it differently, called dependency injection. When using other technologies, maybe, but not with modern .NET.</p>



<h2 data-number="8.5">Summary</h2>
<p>In this chapter, we explored our first GoF design patterns. These patterns expose some of the essential basics of software engineering, not necessarily the patterns themselves, but the concepts behind them:</p>
<ul>
<li>The Strategy pattern is a behavioral pattern that we use to compose most of our future classes. It allows swapping behavior at runtime by composing an object with small pieces and coding against interfaces, following the SOLID principles.</li>
<li>The Abstract Factory pattern brings the idea of abstracting away object creation, leading to a better separation of concerns. More specifically, it aims to abstract the creation of object families and follow the SOLID principles.</li>
<li>Even if we defined it as an anti-pattern, the Singleton pattern brings the application-level objects to the table. It allows the creation of a single instance of an object that lives for the whole lifetime of a program. The pattern violates most SOLID principles.</li>
</ul>
<p>We also peeked at the Ambient Context code smell, which is used to create an omnipresent entity accessible from everywhere. It is often implemented as a singleton and brings a global state object to the program.The next chapter explores how dependency injection helps us compose complex yet maintainable systems. We also revisit the Strategy, the Factory, and the Singleton patterns to see how to use them in a dependency-injection-oriented context and how powerful they really are.</p>


<h2 data-number="8.6">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>Why is the Strategy pattern a behavioral pattern?</li>
<li>How could we define the goal of the creational patterns?</li>
<li>If I write the code <code>public MyType MyProp =&gt; new MyType();</code>, and I call the property twice (<code>var v1 = MyProp; var v2 = MyProp;</code>), are <code>v1</code> and <code>v2</code> the same instance or two different instances?</li>
<li>Is it true that the Abstract Factory pattern allows us to add new families of elements without modifying the existing consuming code?</li>
<li>Why is the Singleton pattern an anti-pattern?</li>
</ol>


<h2 data-number="8.7">Answers</h2>
<ol>
<li>It helps manage behaviors at runtime, such as changing an algorithm in the middle of a running program.</li>
<li>The creational patterns are responsible for creating objects.</li>
<li><code>v1</code> and <code>v2</code> are two different instances. The code on the right-hand side of the arrow operator is executed every time you call the property’s getter.</li>
<li>Yes, it is true. That’s the primary goal of the pattern, as we demonstrated in the <code>MidRangeVehicleFactory</code> code sample.</li>
<li>The Singleton pattern violates the SOLID principles and encourages using global (static) state objects. We can avoid this pattern most of the time.</li>
</ol>


</body>
</html>
