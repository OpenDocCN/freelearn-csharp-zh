<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer066">
<h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor148"/>9</h1>
<h1 id="_idParaDest-147"><a id="_idTextAnchor149"/>Handling User Input and Validation</h1>
<p>User input forms the core of any interactive application. The way we manage this input, validate it, and respond to it directly influences the user experience of our application. While backend validation of user input is indispensable to maintaining data integrity, providing immediate and useful feedback on the frontend is equally important for a good user experience. In this chapter, we’re going to dig into the crucial topic of managing user input and validation within a .NET MAUI application utilizing the MVVM <span class="No-Break">design pattern.</span></p>
<p>This chapter is organized into the <span class="No-Break">following sections:</span></p>
<ul>
<li>Implementing input validation <span class="No-Break">on ViewModels</span></li>
<li>Visualizing validation errors <span class="No-Break">with triggers</span></li>
<li>Prompts <span class="No-Break">and alerts</span></li>
<li>Confirming or <span class="No-Break">canceling navigation</span></li>
</ul>
<p>With the aim of making our application more dynamic and interactive, this chapter will focus on handling user input effectively – ensuring a smooth and seamless user experience. Let’s <span class="No-Break">dive in!</span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor150"/>Technical requirements</h1>
<p>In this chapter, we’ll further enrich the <em class="italic">Recipes!</em> app with more features. To stay in sync, all the resources and code snippets are available on GitHub: <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09</a>. If you’re looking to actively code alongside the chapter, it’s best to kick off from the <strong class="source-inline">Start</strong> folder. The finalized version can be found in the <span class="No-Break"><strong class="source-inline">Finish</strong></span><span class="No-Break"> folder.</span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor151"/>Implementing input validation on ViewModels</h1>
<p>Input validation can be implemented in various ways and at different points within the life cycle of user interaction. It could happen as soon as a user changes a property, providing immediate feedback on the validity of the data entered. On the other hand, it might be performed only when <a id="_idIndexMarker596"/>the user initiates a certain action, such as clicking a button, thereby offering a more cumulative validation experience. Deciding on when and how to implement validation often depends on the specific requirements of your project. It’s a balance between the need for immediate feedback and maintaining a smooth, uninterrupted user flow. There’s no one-size-fits-all solution, and the strategy can vary based on the complexity of the data, the form of user interaction, and the overall design of <span class="No-Break">your application.</span></p>
<p>Implementing validation on the frontend offers several advantages: it provides users with immediate feedback, ensuring a more responsive and intuitive experience. Moreover, by catching and rectifying issues right at the source, we can reduce the risk of sending incorrect data to the backend. However, it's essential to note that frontend validation should complement, not replace, backend validation. The ViewModel is the ideal location for frontend validation as it serves as our first line of defense against potential data inconsistencies or errors before they reach <span class="No-Break">backend systems.</span></p>
<p>In this section, we’ll be focusing on the implementation of input validation in ViewModels. We’ll specifically delve into the use of the <strong class="source-inline">ObservableValidator</strong>, a powerful tool that’s part of the MVVM Community Toolkit. This feature makes handling validation responses and displaying meaningful feedback to the user a breeze. Let’s move on to explore the <strong class="source-inline">ObservableValidator</strong> in detail, and how it can enhance our approach to <span class="No-Break">input validation.</span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor152"/>Using the ObservableValidator</h2>
<p>Validating user input is a<a id="_idIndexMarker597"/> cornerstone of robust applications. While it’s entirely possible to write our own validation logic – checking properties as they update or when commands are invoked and then populating validation properties that can be bound to the UI – it often involves reinventing common <a id="_idIndexMarker598"/>patterns. Instead of starting from scratch, why not leverage existing tools designed for this exact purpose? One of the best practices for user input validation in the MVVM pattern is the use of the <strong class="source-inline">ObservableValidator</strong>. This class, a part of the MVVM Community Toolkit, inherits from the <strong class="source-inline">ObservableObject</strong> class and implements the <strong class="source-inline">System.ComponentModel.INotifyDataErrorInfo</strong> interface. This interface, which isn’t specific to .NET MAUI, provides a robust system for reporting and managing errors in objects. It includes an <strong class="source-inline">ErrorsChanged</strong> event that you can subscribe to in order to be notified of changes in validation status and a <strong class="source-inline">GetErrors</strong> method that<a id="_idIndexMarker599"/> retrieves validation errors for a specified property or the <span class="No-Break">entire object.</span></p>
<p>When a property value is updated, the <strong class="source-inline">ObservableValidator</strong> has the ability to automatically validate it using its <strong class="source-inline">SetProperty</strong> method overloads. It also offers <strong class="source-inline">TrySetProperty</strong> overloads that update a property value only when validation is successful and can return any<a id="_idIndexMarker600"/> generated errors. For scenarios that require manual control over validation, the <strong class="source-inline">ObservableValidator</strong> provides <strong class="source-inline">ValidateProperty</strong> and <strong class="source-inline">ValidateAllProperties</strong> methods, which can be used to manually trigger validation for specific properties or all properties, respectively. Additionally, it offers a <strong class="source-inline">ClearAllErrors</strong> method, ideal for resetting a form <span class="No-Break">for reuse.</span></p>
<p>The flexibility of <strong class="source-inline">ObservableValidator</strong> extends to compatibility with the wide range of validation attributes provided by the <strong class="source-inline">System.ComponentModel.DataAnnotations</strong> namespace. This means you can leverage a set of common validation rules that are essential in many scenarios, such as <strong class="source-inline">[Required]</strong>, <strong class="source-inline">[StringLength]</strong>, <strong class="source-inline">[Range]</strong>, <strong class="source-inline">[Compare]</strong>, <strong class="source-inline">[RegularExpression]</strong>, and many more. These attributes allow for an expressive way to define validation rules directly on your ViewModel’s properties, leading to a highly readable and maintainable code base. The <strong class="source-inline">ObservableValidator</strong> will pick up these attributes when validating a property, making the validation process seamless and straightforward. You can also define your own specific validation rules by encapsulating complex validation logic into dedicated validation methods or even in custom <strong class="source-inline">ValidationAttribute</strong> classes, which can be reused across <span class="No-Break">your application.</span></p>
<p>Let’s go ahead and see how we can add validation to <strong class="source-inline">AddRatingViewModel</strong> using <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">ObservableValidator</strong></span><span class="No-Break">.</span></p>
<h3>Pre-configured validation rules</h3>
<p>As previously mentioned, the <strong class="source-inline">ObservableValidator</strong> class leverages the power of the validation attributes found within the <strong class="source-inline">System.ComponentModel.DataAnnotations</strong> namespace. These attributes can be easily applied to your properties and<a id="_idIndexMarker601"/> the <strong class="source-inline">ObservableValidator</strong> class will use them for validating the corresponding property values. This relationship between the <strong class="source-inline">ObservableValidator</strong> and the <strong class="source-inline">DataAnnotations</strong> namespace offers an array of pre-configured validation rules, simplifying the process of implementing input validation in your ViewModel. Let’s start by marking some properties <span class="No-Break">as required:</span></p>
<ol>
<li>Head over to <strong class="source-inline">AddRatingViewModel</strong> and instead of inheriting the <strong class="source-inline">ObservableObject</strong> class, make it inherit the <strong class="source-inline">ObservableValidator</strong> class, as <span class="No-Break">shown here:</span><pre class="source-code">
public class AddRatingViewModel : <strong class="bold">ObservableValidator</strong>, INavigationParameterReceiver, INavigatedFrom</pre></li> <li>Next, we can add the <strong class="source-inline">Required</strong> attribute to the <strong class="source-inline">EmailAddress</strong>, <strong class="source-inline">DisplayName</strong>, and <span class="No-Break"><strong class="source-inline">RatingInput</strong></span><span class="No-Break"> properties:</span><pre class="source-code">
<strong class="bold">[Required]</strong>
public string EmailAddress { … }
<strong class="bold">[Required]</strong>
public string DisplayName { ... }
<strong class="bold">[Required]</strong>
public string RatingInput { ... }</pre></li> <li>The <strong class="source-inline">AddRatingViewModel</strong> class contains a <strong class="source-inline">SubmitCommand</strong>, which calls the <strong class="source-inline">OnSubmit</strong> method. Let’s update this method so it validates all the properties and writes the validation messages to the <span class="No-Break">debug window:</span><pre class="source-code">
private Task OnSubmit()
{
    <strong class="bold">ValidateAllProperties();</strong>
    if(<strong class="bold">HasErrors</strong>)
    {
        var errors = <strong class="bold">GetErrors();</strong>
        Debug.WriteLine( string.Join("\n",
            errors.Select(e =&gt; e.ErrorMessage)));
    }
    else
    {
        Debug.WriteLine("All OK");
    }
    return Task.CompletedTask;
}</pre><p class="list-inset">With the <strong class="source-inline">ValidateAllProperties</strong> method, all properties of the current class are validated. After calling this method, we can check the <strong class="source-inline">HasErrors</strong> property to see if there <a id="_idIndexMarker602"/>are any violations. If so, the <strong class="source-inline">GetErrors</strong> method allows us to retrieve a list of <strong class="source-inline">ValidationResult</strong> objects. A <strong class="source-inline">ValidationResult</strong> object contains a list of member names affected by this result and <span class="No-Break">an </span><span class="No-Break"><strong class="source-inline">ErrorMessage</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>Go ahead and debug the app! If you go to the <strong class="source-inline">AddRatingPage</strong>, leave everything empty and click the <strong class="bold">Submit</strong> button. You’ll see the error messages printed in the <strong class="bold">Output</strong> window in <span class="No-Break">Visual Studio.</span></p>
<p class="callout-heading">Validating and errors</p>
<p class="callout">The <strong class="source-inline">ValidateAllProperties</strong> method validates all <a id="_idIndexMarker603"/>properties in the ViewModel. The <strong class="source-inline">ValidateProperty</strong> method, which accepts a value and property name<a id="_idIndexMarker604"/> will check whether the given value is valid for the given property. This is an easy way to validate a single property. The <strong class="source-inline">HasErrors</strong> property will be set according to the properties that have been validated. The same thing goes for the <strong class="source-inline">GetErrors</strong> method: it returns <strong class="source-inline">ValidationResult</strong> objects for the properties that have been validated. This method also has an overload where you can pass in a property name to get back the errors for that specific property. The <strong class="source-inline">GetErrors</strong> method <a id="_idIndexMarker605"/>won’t do any validation by itself, trying to get the errors of a property that hasn’t been validated will yield no results. The <strong class="source-inline">ClearErrors</strong> method <a id="_idIndexMarker606"/>allows for removing all errors or only those of a particular property when a property name <span class="No-Break">is provided.</span></p>
<p>Let’s enhance our validation by <a id="_idIndexMarker607"/>adding more validation rules and disabling the <strong class="bold">Submit</strong> button until all input <span class="No-Break">is valid.</span></p>
<p>On the <strong class="source-inline">EmailAddress</strong> property, we should add an additional validation attribute. We can use the <strong class="source-inline">RegularExpressionAttribute</strong> to check whether a value matches a given <span class="No-Break">regex expression:</span></p>
<ol>
<li>The following snippet shows how we can add an extra validation attribute to the <strong class="source-inline">EmailAddress</strong> property using the <strong class="source-inline">RegularExpressionAttribute</strong> to ensure the value matches a specified regex pattern. This pattern will be used to validate whether the given value is an <span class="No-Break">email address:</span><pre class="source-code">
public const string EmailValidationRegex =
 "^[aA-zZ0-9]+@[aA-zZ]+\.[aA-zZ]{2, 3}$";
...
[Required]
<strong class="bold">[RegularExpression(EmailValidationRegex)]</strong>
public string EmailAddress { ... }</pre></li> <li>To ensure the <strong class="source-inline">DisplayName</strong> property has a minimum and maximum length, we can use the <strong class="source-inline">MinLength</strong> and <strong class="source-inline">MaxLength</strong> attributes. Let’s <span class="No-Break">add them:</span><pre class="source-code">
<strong class="bold">public const int DisplayNameMinLength = 5;</strong>
<strong class="bold">public const int DisplayNameMaxLength = 25;</strong>
...
[Required]
<strong class="bold">[MinLength(DisplayNameMinLength)]</strong>
<strong class="bold">[MaxLength(DisplayNameMaxLength)]</strong>
public string DisplayName { ... }</pre></li> <li>To constrain the <strong class="source-inline">RatingInput</strong> property to a value between 0 and 4 with zero or one decimal point, we<a id="_idIndexMarker608"/> can use the <strong class="source-inline">RangeAttribute</strong> for the range constraint and <strong class="source-inline">RegularExpressionAttribute</strong> for the <span class="No-Break">decimal limit:</span><pre class="source-code">
<strong class="bold">public const string RangeDecimalRegex = @"^\d+(\.\d{1,1})?$";</strong>
<strong class="bold">public const double RatingMinVal = 0d;</strong>
<strong class="bold">public const double RatingMaxVal = 4d;</strong>
...
[Required]
<strong class="bold">[RegularExpression(RangeDecimalRegex)]</strong>
<strong class="bold">[Range(RatingMinVal, RatingMaxVal)]</strong>
public string RatingInput { ... }</pre></li> <li>And finally, we want to validate each property when its value gets updated. The <strong class="source-inline">ObservableValidator</strong> class has an overloaded <strong class="source-inline">SetProperty</strong> method, which accepts a <strong class="source-inline">bool</strong> value indicating whether the provided value needs to be validated. This is how it looks for the <span class="No-Break"><strong class="source-inline">EmailAddress</strong></span><span class="No-Break"> property:</span><pre class="source-code">
SetProperty(ref _emailAddress, value, <strong class="bold">true</strong>);</pre><p class="list-inset">We can go ahead and update the <strong class="source-inline">DisplayName</strong>, <strong class="source-inline">RatingInput</strong>, and <strong class="source-inline">Review</strong> properties on this ViewModel as well, to use this overloaded <strong class="source-inline">SetProperty</strong> method, passing in <strong class="source-inline">true</strong> in order to trigger validation when the value is set. If we were to<a id="_idIndexMarker609"/> pass in <strong class="source-inline">false</strong> as the last parameter, the validation would not <span class="No-Break">be triggered.</span></p></li> </ol>
<p class="callout-heading">SetProperty and TrySetProperty</p>
<p class="callout">Note that this overloaded <strong class="source-inline">SetProperty</strong> will set the <a id="_idIndexMarker610"/>value of the backing field and trigger the <strong class="source-inline">PropertyChanged</strong> event, no matter whether the provided value is valid or not. There <a id="_idIndexMarker611"/>is also a <strong class="source-inline">TrySetProperty</strong> on the <strong class="source-inline">ObservableValidator</strong> class, which will not set the value on the property when it is invalid. It returns a <strong class="source-inline">bool</strong> value indicating whether the value was set or not and has an <strong class="source-inline">out</strong> parameter, which returns a collection <span class="No-Break">of errors.</span></p>
<ol>
<li value="5">The <strong class="source-inline">AddRatingViewModel</strong> class contains a command <strong class="source-inline">SubmitCommand</strong>. This command should only be executable when the provided values of the properties are considered valid. For that, we can point the <strong class="source-inline">canExecute</strong> function of the <strong class="source-inline">SubmitCommand</strong> to the <strong class="source-inline">HasErrors</strong> property, as <span class="No-Break">shown here:</span><pre class="source-code">
SubmitCommand =
    new AsyncRelayCommand(OnSubmit, <strong class="bold">() =&gt; !HasErrors</strong>);</pre></li> <li>Finally, we need a place to call the <strong class="source-inline">NotifyCanExecuteChanged</strong> method of the <strong class="source-inline">SubmitCommand</strong>, so the <strong class="source-inline">canExecute</strong> function can be re-evaluated. The <strong class="source-inline">ObservableValidator</strong> class exposes an event called <strong class="source-inline">ErrorsChanged</strong>, which gets triggered whenever there is a change in validation errors. That’s the ideal moment to call the <strong class="source-inline">NotifyCanExecuteChanged</strong> method of the <strong class="source-inline">SubmitCommand</strong>. Let’s subscribe to this event and <span class="No-Break">implement this:</span><pre class="source-code">
public AddRatingViewModel(
    INavigationService navigationService)
{
    ...
    <strong class="bold">ErrorsChanged += AddRatingViewModel_ErrorsChanged;</strong>
}
private void AddRatingViewModel_ErrorsChanged(
    object? sender, DataErrorsChangedEventArgs e)
{
    <strong class="bold">SubmitCommand.NotifyCanExecuteChanged();</strong>
}</pre></li> </ol>
<p>Now, if you run the app and<a id="_idIndexMarker612"/> navigate to <strong class="source-inline">AddRatingPage</strong>, you’ll find the <strong class="bold">Submit</strong> button is initially disabled. It will only be enabled when all required fields have valid input. This is all thanks to the automatic evaluation of property values when they change and the result of the <strong class="source-inline">CanExecute</strong> method of <strong class="source-inline">SubmitCommand</strong> being based on the absence of validation errors. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> shows what this <span class="No-Break">looks like:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 9.1: Enabled Submit button when there are no errors (right)" height="799" src="image/B20941_09_01.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: Enabled Submit button when there are no errors (right)</p>
<p>The pre-configured validation attributes we’ve discussed so far can simplify the process of adding validation to your ViewModels. However, there will be scenarios where these built-in rules don’t meet your specific requirements, and you’ll need to create your own custom validation logic. Let’s<a id="_idIndexMarker613"/> explore how to implement <span class="No-Break">that next.</span></p>
<h3>Creating custom validation rules</h3>
<p>Often, the pre-configured validation <a id="_idIndexMarker614"/>rules just won’t cut it and you’ll need to add your own custom validation logic. When working with the <strong class="source-inline">ObservableValidator</strong> class, there<a id="_idIndexMarker615"/> are two options for implementing custom <span class="No-Break">validation rules:</span></p>
<ul>
<li>The first approach involves creating a completely new validation attribute by extending the base <strong class="source-inline">ValidationAttribute</strong> class. This allows you to encapsulate your own validation logic in a reusable component, keeping your ViewModel cleaner and more focused on its primary responsibility. You can then apply this custom attribute to any property in the same way you’d apply the <span class="No-Break">built-in attributes.</span></li>
<li>The second option involves using the <strong class="source-inline">CustomValidation</strong> attribute, which enables you to specify a static method to handle the validation right at the point of declaration. This method allows for more localized, context-specific validation scenarios where creating a separate attribute class might <span class="No-Break">be overkill.</span></li>
</ul>
<p>Let’s examine both methods in more detail to see how they can be used to address custom <span class="No-Break">validation requirements.</span></p>
<h4>Create a custom attribute</h4>
<p>Let’s add a validation rule that we<a id="_idIndexMarker616"/> want to use on the <strong class="source-inline">Review</strong> property. Although a review is optional, if provided, it must fall within a certain length range. Since such a rule could potentially be reused across different scenarios, it makes sense to put this validation logic in a custom attribute. Here’s how we can go <span class="No-Break">about it:</span></p>
<ol>
<li>Right-click the <strong class="source-inline">Recipes.Client.Core</strong> project in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add</strong> | <strong class="bold">New Folder</strong>. Enter <strong class="source-inline">Validation</strong> as the name of the <span class="No-Break">new folder.</span></li>
<li>Right-click th<a id="_idTextAnchor153"/>e <strong class="source-inline">Validation</strong> folder, select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>, and enter <strong class="source-inline">EmptyOrWithinRangeAttribute</strong> as the <span class="No-Break">class name.</span></li>
<li>Make this class inherit the <strong class="source-inline">ValidationAttribute</strong> class <span class="No-Break">like this:</span><pre class="source-code">
public class EmptyOrWithinRangeAttribute : ValidationAttribute</pre></li> <li>Next, add two <a id="_idIndexMarker617"/>properties, <strong class="source-inline">MinLength</strong> and <strong class="source-inline">MaxLength</strong>, of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">:</span><pre class="source-code">
public int MinLength { get; set; }
public int MaxLength { get; set; }</pre><p class="list-inset">These properties allow an even wider usage of this attribute. They allow developers to customize the length constraints each time they apply this attribute to a property. This way, the exact minimum and maximum lengths required for validation can be tailored to fit each individual property’s needs as the developer can declare the desired minimum and <span class="No-Break">maximum length.</span></p></li> <li>The next step is to override the <strong class="source-inline">IsValid</strong> method. This method gets invoked when the validation process begins for the property where the attribute is applied. Let’s see how we can <span class="No-Break">implement it:</span><pre class="source-code">
protected override ValidationResult IsValid(object? value, ValidationContext validationContext)
{
    if (value is string valueAsString &amp;&amp; (
        string.IsNullOrEmpty(valueAsString) ||
        (valueAsString.Length &gt;= MinLength
        &amp;&amp; valueAsString.Length &lt;= MaxLength)))
    {
        return ValidationResult.Success;
    }
    else
    {
        return new ValidationResult($"The value should be between {MinLength} and {MaxLength} characters long, or empty.");
    }
}</pre><p class="list-inset">The value parameter, of type <strong class="source-inline">object</strong>, represents the property value that needs to be validated. The <a id="_idIndexMarker618"/>second parameter, of type <strong class="source-inline">ValidationContext</strong>, provides further context, including the instance of the object being validated and the property. Returning <strong class="source-inline">ValidationResult.Success</strong> indicates that the given value is valid, else we return a descriptive <span class="No-Break">error message.</span></p></li> <li>Finally, we can use this attribute on the <strong class="source-inline">Review</strong> property of the <strong class="source-inline">AddRatingViewModel</strong> <span class="No-Break">like this:</span><pre class="source-code">
<strong class="bold">[EmptyOrWithinRange(MinLength = 10, MaxLength = 250)]</strong>
public string Review
{
    get =&gt; _review;
    set =&gt; SetProperty(ref _review, value, true);
}</pre></li> </ol>
<p>With our custom validation attribute in place, the <strong class="source-inline">Review</strong> property can be validated so that it is empty or falls within<a id="_idIndexMarker619"/> the given length range. This attribute can easily be reused across the <span class="No-Break">entire app.</span></p>
<h4>Using the CustomValidation attribute</h4>
<p>The <strong class="bold">CustomValidation</strong> attribute is<a id="_idIndexMarker620"/> typically used for very <a id="_idIndexMarker621"/>specific validation that is reused less throughout the app. This attribute points to a static method with a specific signature: it must return a <strong class="source-inline">ValidationResult</strong> object and take a parameter matching the type of the property being validated, along with a <strong class="source-inline">ValidationContext</strong> object. This is similar to the <strong class="source-inline">IsValid</strong> method we override when implementing our own <strong class="source-inline">ValidationAttribute</strong>. Let’s add an additional validation to the <strong class="source-inline">Review</strong> property so that it is required when the given rating is less than or equal <span class="No-Break">to 2:</span></p>
<ol>
<li>In the <strong class="source-inline">AddRatingViewModel</strong>, add a new static method called <strong class="source-inline">ValidateReview</strong> with the <span class="No-Break">following implementation:</span><pre class="source-code">
public static ValidationResult ValidateReview(string review, ValidationContext context)
{
    AddRatingViewModel instance =
        (AddRatingViewModel)context.ObjectInstance;
    if (double.TryParse(instance.RatingInput,
        out var rating))
    {
        if (rating &lt;= 2 &amp;&amp;
            string.IsNullOrEmpty(review))
        {
            return new("A review is mandatory when rating the recipe 2 or less.");
        }
    }
    return ValidationResult.Success;
}</pre><p class="list-inset">This method accepts a parameter of type <strong class="source-inline">string</strong>, matching the type of the property we want to validate. The second parameter is of type <strong class="source-inline">ValidationContext</strong>, which we can use to access the instance of the object the property is defined on. This allows us to access other properties on the object that is being validated, such as the <strong class="source-inline">RatingInput</strong> property in our case. When we can parse the <strong class="source-inline">RatingInput</strong> value to <strong class="source-inline">double</strong>, we can check whether it is less<a id="_idIndexMarker622"/> than or equal to 2. If that is the case and the given review value is empty, we return a validation error. Otherwise, <strong class="source-inline">Success</strong> <span class="No-Break">is returned.</span></p></li> <li>Now, we need to add a <strong class="source-inline">CustomValidation</strong> attribute to the <strong class="source-inline">Review</strong> property and point this to the static <strong class="source-inline">ValidateReview</strong> method that we just created. Let’s see how <span class="No-Break">that’s done:</span><pre class="source-code">
<strong class="bold">[CustomValidation(</strong>
<strong class="bold">    typeof(AddRatingViewModel),</strong>
<strong class="bold">    nameof(ValidateReview))]</strong>
[EmptyOrWithinRange(MinLength = 2, MaxLength = 250)]
public string Review
{
    get =&gt; _review;
    set =&gt; SetProperty(ref _review, value, true);
}</pre><p class="list-inset">The first parameter the <strong class="source-inline">CustomValidation</strong> attribute requires is the type the static validation method is defined on. In our case, we defined it on <strong class="source-inline">AddRatingViewModel</strong> itself, so we pass that in as the type. This means it is possible to define your validation methods elsewhere, bundling them in separate classes, for example. The second parameter is the name of the validation method. We use the <strong class="source-inline">nameof</strong> keyword to avoid magic strings and add compile-time <span class="No-Break">error checking.</span></p></li> <li>As the validation of the <strong class="source-inline">Review</strong> property is also dependent on the entered <strong class="source-inline">RatingInput</strong> property, we must make sure the <strong class="source-inline">Review</strong> property is also validated when the <strong class="source-inline">RatingInput</strong> property changes. As the following snippet shows, we can easily do this by <a id="_idIndexMarker623"/>calling the <strong class="source-inline">ValidateProperty</strong> method for the <strong class="source-inline">Review</strong> property when the value on the <strong class="source-inline">RatingInput</strong> property <span class="No-Break">is updated:</span><pre class="source-code">
[Required]
[RegularExpression(RangeDecimalRegex)]
[Range(RatingMinVal, RatingMaxVal)]
public string RatingInput
{
    get =&gt; _ratingInput;
    set
    {
        SetProperty(ref _ratingInput, value, true);
        <strong class="bold">ValidateProperty(Review, nameof(Review));</strong>
    }
}</pre></li> </ol>
<p>That’s it! That is all that’s needed to add custom validation, leveraging the <strong class="source-inline">CustomValidation</strong> attribute. This approach typically is for validation checking that is to be reused on different objects less. In this particular case, we access the <strong class="source-inline">ValidationContext</strong> <strong class="source-inline">ObjectInstance</strong> and cast it to a certain type, which naturally makes it unusable on <span class="No-Break">different types.</span></p>
<p>Run your application and notice how the <strong class="bold">Submit</strong> button gets disabled when a rating of less than 3 is given and the review is left empty. Our validation logic is operating as expected! However, the current implementation lacks user-friendliness because it does not provide any feedback regarding<a id="_idIndexMarker624"/> invalid entries. Let’s see how to display these validation errors to <span class="No-Break">the user.</span></p>
<h3>Showing errors onscreen</h3>
<p>There are basically two<a id="_idIndexMarker625"/> approaches to show validation errors to the user. The first method usually provides an overview of all issues at once, typically at the top or bottom of a form. The second approach gives feedback right on the input field where the error <a id="_idIndexMarker626"/>occurred. This can often help users to correct the error more directly and quickly. Both methods have their uses and are often combined in applications for the best <span class="No-Break">user ex<a id="_idTextAnchor154"/><a id="_idTextAnchor155"/>perience.</span></p>
<h4>Showing all errors</h4>
<p>While <strong class="source-inline">ObservableValidator</strong> doesn’t provide a <a id="_idIndexMarker627"/>property that lists all validation errors directly, it does offer a <strong class="source-inline">GetErrors</strong> method to fetch them. Sadly, data binding to methods isn’t possible. To align better with MVVM practices and facilitate data binding, it would be beneficial to introduce an <strong class="source-inline">Errors</strong> property of type <strong class="source-inline">ObservableCollection&lt;ValidationResult&gt;</strong>. This way, we can bind to our validation errors in <span class="No-Break">the UI.</span></p>
<p>Let’s see how we can <span class="No-Break">achieve this:</span></p>
<ol>
<li>Add a property called <strong class="source-inline">Errors</strong> of type <strong class="source-inline">ObservableCollection&lt;ValidationResult&gt;</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">AddRatingViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
public ObservableCollection&lt;ValidationResult&gt; Errors { get; } = new();</pre></li> <li>The <strong class="source-inline">AddRatingViewModel_ErrorsChanged</strong> method on <strong class="source-inline">AddRatingViewModel</strong> is invoked when the <strong class="source-inline">ErrorsChanged</strong> event of <strong class="source-inline">ObservableValidator</strong> is triggered. Currently, this calls the <strong class="source-inline">NotifyCanExecuteChanged</strong> method on the <strong class="source-inline">SubmitCommand</strong>, but let’s update it so that it also (re-)populates the <strong class="source-inline">Errors</strong> collection that we just defined. The following code block shows how we can <span class="No-Break">do this:</span><pre class="source-code">
private void AddRatingViewModel_ErrorsChanged(object? sender, DataErrorsChangedEventArgs e)
{
    <strong class="bold">Errors.Clear();</strong>
<strong class="bold">    GetErrors().ToList().ForEach(Errors.Add);</strong>
    SubmitCommand.NotifyCanExecuteChanged();
}</pre><p class="list-inset">The preceding code first clears the <strong class="source-inline">Errors</strong> collection. Next, it calls the <strong class="source-inline">GetErrors</strong> method of <strong class="source-inline">ObservableValidator</strong> to get all the errors. With the <strong class="source-inline">ForEach</strong> method, we can loop over all the items and call the <strong class="source-inline">Errors.Add</strong> method<a id="_idIndexMarker628"/> to add the current item to the <span class="No-Break"><strong class="source-inline">Errors</strong></span><span class="No-Break"> collection.</span></p></li> <li>The preceding code should add all the current validation errors to the <strong class="source-inline">Errors</strong> property. The only thing that is left to do is to bind this collection to our view, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;VerticalStackLayout BindableLayout.ItemsSource="{Binding Errors}"&gt;
    &lt;BindableLayout.ItemTemplate&gt;
        &lt;DataTemplate x:DataType="annotations:ValidationResult"&gt;
            &lt;Label Text="{Binding ErrorMessage}"
                FontSize="12" TextColor="Red"/&gt;
        &lt;/DataTemplate&gt;
    &lt;/BindableLayout.ItemTemplate&gt;
&lt;/VerticalStackLayout&gt;</pre><p class="list-inset">At this point, you should find the XAML code familiar and straightforward: the <strong class="source-inline">Errors</strong> collection is bound to the <strong class="source-inline">BindableLayout</strong> <strong class="source-inline">ItemsSource</strong> property on a <strong class="source-inline">VerticalStackLayout</strong>. The <strong class="source-inline">ItemTemplate</strong> stipulates that for each item we want to render a <strong class="source-inline">Label</strong> that shows its <strong class="source-inline">ErrorMessage</strong> property. The <strong class="source-inline">DataType</strong> of the <strong class="source-inline">DataTemplate</strong> is a <strong class="source-inline">ValidationResult</strong>. The <strong class="source-inline">annotations</strong> XML namespace<a id="_idIndexMarker629"/> is defined at the top of the <span class="No-Break">page: </span><span class="No-Break"><strong class="source-inline"/></span><span class="No-Break">.</span></p></li> </ol>
<p>The preceding code will result in showing a list of all the validation errors onscreen. Run the application and you should see the validation errors appearing and disappearing as you enter values, as <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">9</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break"> demonstrates.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<img alt="Figure 9.2: Showing up-to-date validation errors" height="906" src="image/B20941_09_02.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: Showi<a id="_idTextAnchor156"/>ng up-to-date validation errors</p>
<p>Although this already should improve the user experience a lot, we can take this a step further. Let’s enhance the UX by showing error messages inline, directly adjacent to the relevant <span class="No-Break">inpu<a id="_idTextAnchor157"/><a id="_idTextAnchor158"/>t fields.</span></p>
<h4>Showing inline errors</h4>
<p>The main challenge when it comes to <a id="_idIndexMarker630"/>displaying individual errors is developing a mechanism that enables us to retrieve and display validation errors related to a single property, rather than all validation errors at once. There is a very simple approach to this: for each property, expose an additional property containing a collection of errors for that property. Take a look at the <span class="No-Break">following exampl<a id="_idTextAnchor159"/>e:</span></p>
<pre class="source-code">
public List&lt;ValidationResult&gt; EmailValidationErrors
{
    get =&gt; GetErrors(nameof(EmailAddress)).ToList();
}</pre> <p>This <strong class="source-inline">EmailValidationErrors</strong> property gives a list of only the validation errors related to the <strong class="source-inline">EmailAddress</strong> property. This <strong class="source-inline">EmailValidationErrors</strong> property can be bound to the UI so that we can display the errors only relevant to the <strong class="source-inline">EmailAddress</strong> property on the screen. In order to keep this bound list up-to-date, we need to make sure we trigger the <strong class="source-inline">PropertyChanged</strong> event of the <strong class="source-inline">EmailValidationErrors</strong> property each time the <strong class="source-inline">EmailAddress</strong> property is updated, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
public string EmailAddress
{
    get =&gt; _emailAddress;
    set
    {
        SetProperty(ref _emailAddress, value, true);
        <strong class="bold">OnPropertyChanged(nameof(EmailValidationErrors));</strong>
    }
}</pre> <p>By creating a dedicated property for each input’s validation errors and ensuring it’s updated whenever the input value changes, we can effectively isolate and display validation errors for individual fields. However, it does come with a caveat: for forms with numerous input fields, this method can be somewhat labor-intensive and repetitive. Let me show you an alternative that automates this process and saves us some manual work. The end result will be that we are going<a id="_idIndexMarker631"/> to bind to a particular property called <strong class="source-inline">ErrorExposer</strong>. Then, using its <strong class="bold">indexer</strong>, we will specify which property’s validation errors we want to<a id="_idIndexMarker632"/> retrieve and display, something <span class="No-Break">like this:</span></p>
<pre class="source-code">
&lt;VerticalStackLayout BindableLayout.ItemsSource="{Binding <strong class="bold">ErrorExposer[EmailAddress]</strong>}"&gt;</pre> <p>Let’s see how we can implement <span class="No-Break">this mechanism:</span></p>
<ol>
<li>In the <strong class="bold">Solution Explorer</strong>, right-click the <strong class="source-inline">Validation</strong> folder that we created earlier, select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>, and enter <strong class="source-inline">ValidationErrorExposer</strong> as the <span class="No-Break">class name.</span></li>
<li>The <strong class="source-inline">ValidationErrorExposer</strong> class should implement two interfaces: <strong class="source-inline">INotifyPropertyChanged</strong> and <strong class="source-inline">IDisposable</strong>, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
public class ValidationErrorExposer : INotifyPropertyChanged, IDisposable
{
    public event PropertyChangedEventHandler? PropertyChanged;
    public void Dispose()
    {
    }
}</pre></li> <li>Next, let’s introduce a <strong class="source-inline">readonly</strong> field <strong class="source-inline">validator</strong> of type <strong class="source-inline">ObservableValidator</strong>. The value for this field should be passed in through the class constructor, as <span class="No-Break">shown here:</span><pre class="source-code">
readonly ObservableValidator validator;
public ValidationErrorExposer(
        ObservableValidator observableValidator)
{
    validator = observableValidator;
}</pre><p class="list-inset">The passed-in <strong class="source-inline">observableValidator</strong> is the instance that we want to automatically expose per-property <span class="No-Break">validation errors.</span></p></li> <li>It’s time to add the <strong class="source-inline">ValidationErrorExposer</strong> indexer. An indexer in .NET allows an instance of a class to be accessed using an index, similar to an array or dictionary. This index can be of any type, such as a string or an int, and it lets you retrieve or set values<a id="_idIndexMarker633"/> without explicitly calling a method or property. In this case, we set the index to be a string as it represents the name of the property we want to get the validation errors of. This is how we can <span class="No-Break">do this:</span><pre class="source-code">
public List&lt;ValidationResult&gt; this[string <strong class="bold">property</strong>]
    =&gt; validator.GetErrors(<strong class="bold">property</strong>).ToList();</pre><p class="list-inset">The indexer on <strong class="source-inline">ValidationErrorExposer</strong> accepts a string value as the index and returns a list of <strong class="source-inline">ValidationResult</strong> objects. This value, which represents the name of the property we want to get the errors of, is passed into the <strong class="source-inline">ObservableValidator</strong> <strong class="source-inline">GetErrors</strong> method. The result is returned as <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break">.</span></p></li> <li>In the constructor of the <strong class="source-inline">ValidationErrorExposer</strong> class, we should also subscribe to the <strong class="source-inline">ErrorsChanged</strong> event of the <strong class="source-inline">ObservableValidator</strong> that is being passed in, <span class="No-Break">like this:</span><pre class="source-code">
public ValidationErrorExposer(ObservableValidator observableValidator)
{
    validator = observableValidator;
    validator.ErrorsChanged += ObservableValidator_ErrorsChanged;
}
private void ObservableValidator_ErrorsChanged(object? sender, DataErrorsChangedEventArgs e)
    =&gt; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs($"Item[{e.PropertyName}]"));</pre><p class="list-inset">While it might seem<a id="_idIndexMarker634"/> like there’s some magic happening, the concept is fairly straightforward. In .NET MAUI, if an object has an indexer, you can bind to that indexer property as demonstrated by <strong class="source-inline">{Binding ErrorExposer[EmailAddress]}</strong>, where <strong class="source-inline">ErrorExposer</strong> is an instance of a type that contains an indexer. To notify the UI of an updated value, we can invoke the <strong class="source-inline">PropertyChanged</strong> event from the <strong class="source-inline">ErrorExposer</strong> and pass <strong class="source-inline">Item[EmailAddress]</strong> as the property name. Doing so will prompt all bindings tied to <strong class="source-inline">ErrorExposer[EmailAddress]</strong> to re-evaluate. Alternatively, invoking the <strong class="source-inline">PropertyChanged</strong> event with <strong class="source-inline">PropertyChangedEventArgs</strong> having <strong class="source-inline">Item</strong> as the property name will trigger a re-evaluation of all bindings associated with <span class="No-Break">the indexer.</span></p></li> <li>Finally, in <strong class="source-inline">ValidationErrorExposer</strong>, we should update the <strong class="source-inline">Dispose</strong> method to <span class="No-Break">the following:</span><pre class="source-code">
public void Dispose()
    =&gt; _validator.ErrorsChanged -=         ObservableValidator_ErrorsChanged;</pre><p class="list-inset">Because we have subscribed to the <strong class="source-inline">ObservableValidator</strong> <strong class="source-inline">ErrorsChanged</strong> method, we need to provide a mechanism to unhook from this event, preventing any memory leaks. For that, we can use the <span class="No-Break"><strong class="source-inline">Dispose</strong></span><span class="No-Break"> method.</span></p></li> <li>Let’s head back to <strong class="source-inline">AddRatingViewModel</strong> and add a property of type <strong class="source-inline">ValidationErrorExposer</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
public ValidationErrorExposer ErrorExposer { get; }</pre></li> <li>In the constructor of <strong class="source-inline">AddRatingViewModel</strong>, assign a new instance to <span class="No-Break">this property:</span><pre class="source-code">
public AddRatingViewModel(INavigationService navigationService)
{
...
    <strong class="bold">ErrorExposer = new (this);</strong>
...
}</pre><p class="list-inset">We pass in <strong class="source-inline">this</strong> to the constructor of the <strong class="source-inline">ValidationErrorExposer</strong> class because it is the instance of the <strong class="source-inline">AddRatingViewModel</strong> itself that inherits from <strong class="source-inline">ObservableValidator</strong> and thus holds all <span class="No-Break">validation errors.</span></p></li> <li>In XAML, we can now<a id="_idIndexMarker635"/> bind to a list of validation errors, specific to a particular property using the indexer on the <strong class="source-inline">ValidationErrorExposer</strong> class. This allows us to show these errors close to the relevant input fields themselves, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
&lt;Editor Text="{Binding Review, Mode=TwoWay}" /&gt;
&lt;VerticalStackLayout <strong class="bold">BindableLayout.ItemsSource="{Binding ErrorExposer[Review]}"</strong>&gt;
    &lt;BindableLayout.ItemTemplate&gt;
        ...
    &lt;/BindableLayout.ItemTemplate&gt;
&lt;/VerticalStackLayout&gt;</pre></li> </ol>
<p><strong class="source-inline">ValidationErrorExposer</strong> allows us to easily get validation errors from a specific property, without needing to do any manual work: once this is in place, we can bind to the errors of any specific <a id="_idIndexMarker636"/>property using its <span class="No-Break">indexer property.</span></p>
<p>Displaying validation errors near user input further improves the user experience. Let’s explore how to visually indicate the validity of entered values, improving the experience <span class="No-Break">even more.</span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor160"/>Visualizing validation errors with triggers</h1>
<p><strong class="bold">Triggers</strong> help us customize how <a id="_idIndexMarker637"/>UI elements work and look without <a id="_idIndexMarker638"/>building new controls <span class="No-Break">from scratch.</span></p>
<p>While there are different types of<a id="_idIndexMarker639"/> triggers, we’ll focus on <strong class="bold">data triggers</strong>. These kick in when a property (on the ViewModel) changes, allowing us to adjust elements of a UI control dynamically, based on what the <span class="No-Break">user does.</span></p>
<p class="callout-heading">Types of triggers</p>
<p class="callout">There are different types of <a id="_idIndexMarker640"/>triggers in .NET MAUI: PropertyTrigger, DataTrigger, EventTrigger, and so on… They all allow you to change the appearance of a UI control declaratively in XAML based upon a trigger. They only differ in what triggers the <a id="_idIndexMarker641"/>change: a property value, a bound value, an event. You can learn more about them <span class="No-Break">at </span><a href="https://learn.microsoft.com/dotnet/maui/fundamentals/triggers"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/fundamentals/triggers</span></a><span class="No-Break">.</span></p>
<p>In essence, a DataTrigger provides a way to declaratively set up UI changes in response to data changes, directly within your XAML, without having to write procedural code in your code-behind, a custom ValueConverter, <span class="No-Break">or ViewModel.</span></p>
<p>DataTriggers are a fairly easy-to-understand concept. So, let’s just dive in and add a visual indicator right next to the different <strong class="source-inline">Entry</strong> controls, indicating with a symbol and a particular color whether the entered value is valid or not, as <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">9</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break"> shows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<img alt="Figure 9.3: Indicating input is valid (right) or not (left)" height="156" src="image/B20941_09_03.jpg" width="1312"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: Indicating input is valid (right) or not (left)</p>
<p class="callout-heading">What about ValueConverters?</p>
<p class="callout">In <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Databinding in .NET MAUI</em>, we <a id="_idIndexMarker642"/>discussed the usage of value converters. The things that you can do with DataTriggers are also achievable with value converters and vice versa. But, with a DataTrigger, it is very easy to implement these visual effects declaratively, without a single line of C# code, also making the XAML <span class="No-Break">more readable.</span></p>
<p>Let’s have a look at how we <a id="_idIndexMarker643"/>can implement these visual cues<a id="_idIndexMarker644"/> <span class="No-Break">using DataTriggers:</span></p>
<ol>
<li>First, add a <strong class="source-inline">Grid</strong> around the <strong class="source-inline">Entry</strong> for the <span class="No-Break"><strong class="source-inline">EmailAddress</strong></span><span class="No-Break"> property:</span><pre class="source-code">
&lt;Grid ColumnDefinitions="*, Auto" HeightRequest="45"&gt;
    &lt;Entry
        Keyboard="Email"
        Text="{Binding EmailAddress, Mode=TwoWay}"
        VerticalOptions="End" /&gt;
&lt;/Grid&gt;</pre><p class="list-inset">This <strong class="source-inline">Grid</strong> has two columns, with the <strong class="source-inline">Entry</strong> in the first one, and we will be adding the validity indicator in the <span class="No-Break">second one.</span></p></li> <li>Inside this <strong class="source-inline">Grid</strong>, below the <strong class="source-inline">Entry</strong>, add the following <strong class="source-inline">Label</strong>, which will serve as the <span class="No-Break">validity indicator:</span><pre class="source-code">
&lt;Label
    Grid.Column="1" FontFamily="MaterialIconsRegular"
    FontSize="20" Text="&amp;#xe000;" TextColor="Red"
    VerticalOptions="Center"&gt;
&lt;/Label&gt;</pre><p class="list-inset">By default, this <strong class="source-inline">Label</strong> shows the invalid state: red text and an exclamation <span class="No-Break">mark icon.</span></p></li> <li>Now, we can add the <strong class="source-inline">DataTrigger</strong> and define that the <strong class="source-inline">Label</strong> needs to show a blue checkmark when the<a id="_idIndexMarker645"/> provided email address is valid. The following snippet shows how <a id="_idIndexMarker646"/>we can <span class="No-Break">do that:</span><pre class="source-code">
&lt;Label ... &gt;
    &lt;Label.Triggers&gt;
        &lt;DataTrigger
            TargetType="Label"
            Binding="{Binding ErrorExposer[EmailAddress].Count}"
            Value="0"&gt;
            &lt;Setter Property="Text"
                Value="&amp;#xe86c;" /&gt;
            &lt;Setter Property="TextColor"
                Value="Blue" /&gt;
        &lt;/DataTrigger&gt;
    &lt;/Label.Triggers&gt;
&lt;/Label&gt;</pre><p class="list-inset">A <strong class="source-inline">DataTrigger</strong> has a <strong class="source-inline">Binding</strong> property that allows us to bind to a certain value. In this case, we bind to the <strong class="source-inline">Count</strong> property of the list of validation errors related to the <strong class="source-inline">EmailAddress</strong> property. With the <strong class="source-inline">Value</strong> property, we can set a condition for this bound property. We set the value to <strong class="source-inline">"0"</strong>, meaning that there are no validation errors associated with the <strong class="source-inline">EmailAddress</strong> property. When the value of the property meets this condition, the trigger activates. Once activated, the trigger can change one or more properties of the UI control. In this particular case, we’re updating the <strong class="source-inline">Text</strong> and <strong class="source-inline">TextColor</strong> properties by specifying a <strong class="source-inline">Setter</strong> for these properties and providing a <span class="No-Break">certain </span><span class="No-Break"><strong class="source-inline">Value</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>As said, this can also be achieved with custom <strong class="source-inline">ValueConverter</strong>s, but this declarative way of defining it in <a id="_idIndexMarker647"/>XAML is very readable, maintainable, and easy <span class="No-Break">to use.</span></p>
<p class="callout-heading">Behaviors</p>
<p class="callout">Another way to give the user visual cues about the validity of entered values is by using <strong class="bold">Behaviors</strong>. Behaviors are like little plugins <a id="_idIndexMarker648"/>you can add to your UI elements, enhancing their default behavior without having to subclass them. They’re particularly useful because they encapsulate logic in reusable pieces, allowing developers to apply the same functionality across different controls. For example, a Behavior might allow a text input field to only accept numerical input or change its color when certain conditions are met. The .NET MAUI Community Toolkit comes with a set of ready-to-use Behaviors! You can <a id="_idIndexMarker649"/>learn more about them <span class="No-Break">at </span><a href="https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors</span></a><span class="No-Break">.</span></p>
<p>In the next section, we’ll have a look at how to display prompts and alerts, essential parts for providing user feedback <a id="_idIndexMarker650"/>and <span class="No-Break">gathering input.</span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor161"/>Prompts and alerts</h1>
<p>Direct feedback and clear communication are paramount when it comes to a solid user experience. As users navigate your application and interact with various inputs, there are moments where a subtle notification or a direct prompt can make all the difference. Prompts and alerts serve as these essential tools, guiding users through their journey, ensuring they’re informed and make <span class="No-Break">intentional decisions.</span></p>
<p>Showing prompts and alerts is <a id="_idIndexMarker651"/>something that is platform-specific. Luckily .NET MAUI has got us covered as they provide simple and intuitive APIs for this. On the other hand, in an MVVM scenario, displaying a prompt or alert is mostly triggered from a ViewModel, which should be framework-independent. The solution, of course, is creating an interface for this functionality that a ViewModel can talk to. On the MAUI side of things, we can easily implement this interface and register it in our DI container so the implementation gets injected into the ViewModels. Let’s go ahead and set <span class="No-Break">this up!</span></p>
<ol>
<li>To begin with, let’s add an interface that defines some methods for displaying prompts and alerts. Right-click the <strong class="source-inline">Recipes.Client.Core</strong> project in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add</strong> | <strong class="bold">New Folder</strong>. Give it the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">Services</strong></span><span class="No-Break">.</span></li>
<li>Add a new interface to <a id="_idIndexMarker652"/>this folder and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">IDialogService</strong></span><span class="No-Break">.</span></li>
<li>The methods defined in an <strong class="source-inline">IDialogService</strong> can defer from project to project. The following code block shows some method declarations that are often present in an <span class="No-Break"><strong class="source-inline">IDialogService</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
public interface IDialogService
{
    Task Notify(string title, string message,
        string buttonText = "OK");
    Task&lt;bool&gt; AskYesNo(string title, string message,
        string trueButtonText = "Yes",
        string falseButtonText = "No");
    Task&lt;string?&gt; Ask(string title, string message,
        string acceptButtonText = "OK",
        string cancelButtonText = "Cancel");
}</pre><p class="list-inset">As said, depending on your specific use case, this interface might be extended with some other <a id="_idIndexMarker653"/>concrete <span class="No-Break">method definitions.</span></p></li> <li>Next, we need to add an implementation for this interface. Add a new folder called <strong class="source-inline">Services</strong> to the <span class="No-Break"><strong class="source-inline">Recipes.Mobile</strong></span><span class="No-Break"> project.</span></li>
<li>Right-click the new <strong class="source-inline">Services</strong> folder and select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>. Enter <strong class="source-inline">DialogService</strong> as the name of the new class and add the <span class="No-Break">following code:</span><pre class="source-code">
public class DialogService : IDialogService
{
    public Task Notify(string title, string message,
        string buttonText = "OK")
        =&gt; Application.Current.MainPage
            .DisplayAlert(title, message, buttonText);
    public Task&lt;bool&gt; AskYesNo(string title,
        string message,
        string trueButtonText = "Yes",
        string falseButtonText = "No")
        =&gt; Application.Current.MainPage
            .DisplayAlert(title, message,
            trueButtonText, falseButtonText);
    public Task&lt;string?&gt; Ask(string title,
        string message,
        string acceptButtonText = "OK",
        string cancelButtonText = "Cancel")
        =&gt; Application.Current.MainPage
            .DisplayPromptAsync(title, message,
            acceptButtonText, cancelButtonText);
}</pre><p class="list-inset">In .NET MAUI, the <strong class="source-inline">Page</strong> class <a id="_idIndexMarker654"/>provides various methods for displaying alerts, prompts, and action sheets. Within the <strong class="source-inline">DialogService</strong> class, we can access these methods by referencing <strong class="source-inline">MainPage</strong> through the static <strong class="source-inline">Current</strong> property of the <span class="No-Break"><strong class="source-inline">Application</strong></span><span class="No-Break"> class.</span></p></li> <li>The next thing we need to do is register <strong class="source-inline">DialogService</strong> in our DI container. Move over to <strong class="source-inline">MauiProgram.cs</strong> and add <span class="No-Break">the following:</span><pre class="source-code">
builder.Services.AddSingleton&lt;IDialogService, DialogService&gt;();</pre></li> <li>Finally, we can add the <strong class="source-inline">IDialogService</strong> as a dependency to our ViewModels. Let’s add it to <strong class="source-inline">AddRatingViewModel</strong> as <span class="No-Break">shown here:</span><pre class="source-code">
readonly IDialogService dialogService;
...
public AddRatingViewModel(INavigationService navigationSerivce, IDialogService dialogService)
{
...
    this.dialogService = dialogService;
...
}</pre></li> <li>Move over to the <strong class="source-inline">OnSubmit</strong> method and update it as <span class="No-Break">shown here:</span><pre class="source-code">
private async Task OnSubmit()
{
    var result = await _dialogService.AskYesNo(
        "Are you sure?",
        "Are you sure you want to add this rating?");
    if (result)
    {
        //ToDo: Submit data
        await _dialogService.Notify("Rating sent",
            "Thank you for your feedback!");
        GoBackCommand.Execute(null);
    }
}</pre><p class="list-inset">In the updated <strong class="source-inline">OnSubmit</strong> method, we first ask for confirmation. If the user confirms, an alert will be shown<a id="_idIndexMarker655"/> saying the rating was sent (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.3</em>). After the user closes the alert, <strong class="source-inline">GoBackCommand</strong> is invoked, closing <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">AddRatingPage</strong></span><span class="No-Break">.</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer065">
<img alt="Figure 9.3: Showing alerts and prompts" height="342" src="image/B20941_09_04.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: Showing alerts and prompts</p>
<p>With the <strong class="source-inline">IDialogService</strong> and its <strong class="source-inline">DialogService</strong> implementation in place, we have laid the foundation for basic<a id="_idIndexMarker656"/> popup interactions in our application. Next, we’ll explore how to leverage this to prompt users for confirmation when they attempt to leave a <span class="No-Break">specific page.</span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor162"/>Confirming or canceling navigation</h1>
<p>As users interact with our application, there may be moments when they’re about to navigate away from a page containing unsaved changes or important input. To prevent potential data loss, it’s essential to <a id="_idIndexMarker657"/>prompt for confirmation before allowing such navigation. Let’s<a id="_idIndexMarker658"/> see how we could build this by leveraging the <strong class="source-inline">NavigationService</strong> that we built in the <span class="No-Break">previous chapter:</span></p>
<ol>
<li>Let’s start by adding the following interface called <strong class="source-inline">INavigatable</strong> to the <strong class="source-inline">Navigation</strong> folder of the <span class="No-Break"><strong class="source-inline">Recipes.Client.Core</strong></span><span class="No-Break"> project:</span><pre class="source-code">
public interface INavigatable
{
    Task&lt;bool&gt; CanNavigateFrom(NavigationType navigationType);
}</pre><p class="list-inset">ViewModels that want to<a id="_idIndexMarker659"/> control whether the user is able to navigate can implement this<a id="_idIndexMarker660"/> interface. This is analogous to the other interfaces we introduced in the context of navigation, such as the <strong class="source-inline">INavigatedFrom</strong>, <strong class="source-inline">INavigatedTo</strong>, and <span class="No-Break"><strong class="source-inline">INavigationParameterReceiver</strong></span><span class="No-Break"> interfaces.</span></p></li> <li>Extend the <strong class="source-inline">INavigationInterceptor</strong> interface with the following <span class="No-Break">method definition:</span><pre class="source-code">
Task&lt;bool&gt; CanNavigate(object bindingContext, NavigationType type);</pre></li> <li>The <strong class="source-inline">NavigationService</strong> class, which implements the <strong class="source-inline">INavigationInterceptor</strong> interface, now needs to implement this method. Here’s what it <span class="No-Break">looks like:</span><pre class="source-code">
public Task&lt;bool&gt; CanNavigate(object bindingContext, NavigationType type)
{
    if(bindingContext is INavigatable navigatable)
        return navigatable.CanNavigateFrom(type);
    return Task.FromResult(true);
}</pre><p class="list-inset">This method checks whether the given <strong class="source-inline">bindingContext</strong> parameter implements the <strong class="source-inline">INavigatable</strong> interface. If that’s the case, it returns the result from its <strong class="source-inline">CanNavigateFrom</strong> method, passing in the <strong class="source-inline">NavigationType</strong>. If the <strong class="source-inline">bindingContext</strong> doesn’t<a id="_idIndexMarker661"/> implement the <strong class="source-inline">INavigatable</strong> interface, <strong class="source-inline">true</strong> is returned, indicating the<a id="_idIndexMarker662"/> navigation can <span class="No-Break">be executed.</span></p></li> <li>In the <strong class="source-inline">AppShell</strong> class, we must now override the <strong class="source-inline">OnNavigating</strong> method. In this method, we can retrieve a <strong class="source-inline">ShellNavigatingDeferral</strong> from the passed-in <strong class="source-inline">ShellNavigatingEventArgs</strong>. This deferral token can be used to complete the navigation. Or, if the navigation should be canceled, the <strong class="source-inline">Cancel</strong> method on the <strong class="source-inline">ShellNavigatingEventArgs</strong> can be called. The next code block shows the <span class="No-Break">overridden method:</span><pre class="source-code">
protected override async void OnNavigating(ShellNavigatingEventArgs args)
{
    base.OnNavigating(args);
    var token = args.GetDeferral();
    if(token is not null)
    {
        var canNavigate = await interceptor
        .CanNavigate(CurrentPage?.BindingContext, GetNavigationType(args.Source));
        if (canNavigate)
            token.Complete();
        else
            args.Cancel();
    }
}</pre><p class="list-inset">By calling the interceptor’s <strong class="source-inline">CanNavigate</strong> method, we can determine whether we must complete the navigation or not. Depending on the outcome, we can call the <strong class="source-inline">Complete</strong> method on <a id="_idIndexMarker663"/>the deferral token and complete the navigation or call the <strong class="source-inline">Cancel</strong> method <a id="_idIndexMarker664"/>on the passed-in <strong class="source-inline">args</strong> to <span class="No-Break">cancel it.</span></p></li> <li>Finally, we can go to <strong class="source-inline">AddRatingViewModel</strong>, make it implement the <strong class="source-inline">INavigatable</strong> interface, and add <span class="No-Break">the following:</span><pre class="source-code">
public class AddRatingViewModel : ObservableValidator, INavigationParameterReceiver, INavigatedFrom, <strong class="bold">INavigatable</strong>
{
...
    <strong class="bold">public Task&lt;bool&gt; CanNavigateFrom(</strong>
<strong class="bold">        NavigationType navigationType) =&gt;</strong>
<strong class="bold">        _dialogService.AskYesNo(</strong>
<strong class="bold">        "Leaving this page...",</strong>
<strong class="bold">        "Are you sure you want to leave this page?");</strong>
}</pre></li> </ol>
<p>As a result, when navigating from the <strong class="source-inline">AddRatingView</strong>, the <strong class="source-inline">OnNavigating</strong> method on the <strong class="source-inline">Shell</strong> class will get called, which – via the <strong class="source-inline">NavigationService</strong> – will call the <strong class="source-inline">CanNavigateFrom</strong> method on the <strong class="source-inline">AddRatingViewModel</strong>. The ViewModel will present a dialog to the user and <a id="_idIndexMarker665"/>return the response. Depending on the response given by the user, the navigation will be completed or canceled. The <strong class="source-inline">INavigatable</strong> interface <a id="_idIndexMarker666"/>can be implemented by any ViewModel and can contain any business logic to determine whether navigation is allowed <span class="No-Break">or not.</span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor163"/>Summary</h1>
<p>In this chapter, we delved deep into enhancing user experience through effective validation, prompts, and alerts. We explored the power of <strong class="source-inline">ObservableValidator</strong> for validation logic and learned the nuances of showing errors both as a collective list and inline, right next to input fields. With triggers, we learned how to customize UI elements without reinventing the wheel. We also explored using an <strong class="source-inline">IDialogService</strong> leveraging alerts and prompts, which is essential in contexts where user feedback or confirmations, such as during critical actions or navigations, are required. As we move forward, we’ll pivot to a vital aspect of many modern apps: making remote <span class="No-Break">API calls.</span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor164"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">ObservableValidator</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator</span></a></li>
<li><span class="No-Break">Triggers: </span><a href="https://learn.microsoft.com/dotnet/maui/fundamentals/triggers"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/fundamentals/triggers</span></a></li>
<li><span class="No-Break">Behaviors: </span><a href="https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors</span></a></li>
<li>.NET MAUI Community Toolkit <span class="No-Break">Behaviors: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/</span></a></li>
<li>.NET MAUI <span class="No-Break">popups: </span><a href="https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups</span></a></li>
</ul>
</div>
</div></body></html>