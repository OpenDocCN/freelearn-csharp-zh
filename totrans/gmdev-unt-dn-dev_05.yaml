- en: '*Chapter 3*: Developing UI with the Unity UI System'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：使用 Unity UI 系统开发 UI'
- en: The UI is very important for a game, and Unity offers three different UI solutions
    for game developers. They are the **Immediate Mode Graphical User Interface**
    (**IMGUI)**, the **Unity UI** (**uGUI**) package, and the **UI Toolkit**. IMGUI
    is a relatively old UI solution in Unity and it is not recommended for building
    a runtime UI. The UI Toolkit is the latest UI solution; however, it is still missing
    some features you can find in the uGUI package and IMGUI. The uGUI package is
    a mature UI solution in Unity that is widely used in the game industry. Therefore,
    this chapter will introduce how to use uGUI to develop the UI of your game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UI 对于游戏来说非常重要，Unity 为游戏开发者提供了三种不同的 UI 解决方案。它们是**即时模式图形用户界面**（**IMGUI**）、**Unity
    UI**（**uGUI**）包和**UI 工具包**。IMGUI 是 Unity 中相对较旧的 UI 解决方案，不建议用于构建运行时 UI。UI 工具包是最新
    UI 解决方案；然而，它仍然缺少一些在 uGUI 包和 IMGUI 中可以找到的功能。uGUI 包是 Unity 中成熟的 UI 解决方案，在游戏行业中得到广泛应用。因此，本章将介绍如何使用
    uGUI 开发您游戏的 UI。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: C# scripts and common UI elements in Unity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 中的 C# 脚本和常见 UI 元素
- en: C# scripts and the UI Event System in Unity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 中的 C# 脚本和 UI 事件系统
- en: The **Model-View-ViewModel** (**MVVM**) pattern and the UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（**MVVM**）模式和 UI'
- en: Performance tips to increase performance of the UI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高性能的 UI 性能提示
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: C# scripts and common UI components in Unity
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 中的 C# 脚本和常见 UI 组件
- en: uGUI has been provided as a built-in package in the Unity Editor since Unity
    2019; therefore, we can see the content of the uGUI package directly in the **Project**
    window, which also includes the C# source code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Unity 2019 以来，uGUI 已作为内置包提供在 Unity 编辑器中；因此，我们可以在**项目**窗口中直接查看 uGUI 包的内容，它还包括
    C# 源代码。
- en: '![Figure 3.1 – The uGUI package'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – uGUI 包]'
- en: '](img/Figure_3.1_B17146.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B17146.jpg)'
- en: Figure 3.1 – The uGUI package
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – uGUI 包
- en: As we mentioned in the previous chapter, the Unity development workflow is primarily
    built around the structure of components. uGUI is no exception. It is a `GameObject`
    with a set of components.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章中提到的，Unity 开发工作流程主要围绕组件的结构构建。uGUI 也不例外。它是一个带有组件集的`GameObject`。
- en: As shown in *Figure 3.1*, we can find the C# source code of many commonly used
    UI elements, such as **Text**, **Slider**, and **Toggle**. However, some UI components
    are implemented using C++ code inside the engine, such as **Canvas**, and the
    code of such components cannot be viewed from within the Unity Editor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 3.1*所示，我们可以找到许多常用 UI 元素的 C# 源代码，例如**文本**、**滑动条**和**切换**。然而，一些 UI 组件是在引擎内部使用
    C++ 代码实现的，例如**画布**，此类组件的代码无法从 Unity 编辑器中查看。
- en: 'In this section, we will introduce the commonly used UI components in Unity.
    We can divide these components into the following four categories, according to
    their functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 Unity 中常用的 UI 组件。根据其功能，我们可以将这些组件分为以下四个类别：
- en: '`Canvas`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`画布`'
- en: '`Image and Raw Image`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图像和原始图像`'
- en: '`Text`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文本`'
- en: '`Selectable UI components`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可选择的 UI 组件`'
- en: Canvas
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布
- en: '**Canvas** is the most basic and important UI component of uGUI. To understand
    how to use uGUI correctly and efficiently, it is essential to understand **Canvas**
    first.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布**是 uGUI 中最基本且最重要的 UI 组件。要正确且高效地使用 uGUI，首先理解**画布**是至关重要的。'
- en: '**Canvas** is the component used to render UI elements in uGUI. All UI elements
    should be located inside the area of a canvas, which is very simple to create
    in a scene.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布**是用于在 uGUI 中渲染 UI 元素的组件。所有 UI 元素都应该位于画布区域内，这在场景中创建起来非常简单。'
- en: '![Figure 3.2 – Creating a canvas from the Hierarchy window'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 从层次结构窗口创建画布]'
- en: '](img/Figure_3.2_B17146.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B17146.jpg)'
- en: Figure 3.2 – Creating a canvas from the Hierarchy window
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 从层次结构窗口创建画布
- en: 'As shown in *Figure 3.2*, you can create a new canvas as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 3.2*所示，您可以按照以下步骤创建一个新的画布：
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中右键单击以打开菜单。
- en: Select **UI** | **Canvas**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**UI** | **画布**。
- en: In addition to creating a new **Canvas** object from the **Hierarchy** window,
    we can also create a new **Canvas** object by clicking **GameObject** | **UI**
    | **Canvas**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以从**层次结构**窗口创建一个新的**画布**对象外，我们还可以通过点击**GameObject** | **UI** | **画布**来创建一个新的**画布**对象。
- en: '![Figure 3.3 – Creating a canvas from the GameObject menu'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 从 GameObject 菜单创建画布]'
- en: '](img/Figure_3.3_B17146.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.3_B17146.jpg)'
- en: Figure 3.3 – Creating a canvas from the GameObject menu
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 3.2* and *Figure 3.3*, we can also create other different
    UI elements from these menus, such as **Text**, **Button**, **Image**, and **Slider**.
    Since all UI elements are the children of **Canvas**, if you want to create a
    new UI element directly and there is no canvas, a new **Canvas** object will be
    created automatically. The new UI element will be a child object of the **Canvas**
    object parent.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – A Canvas object'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B17146.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – A Canvas object
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Once a **Canvas** object is created, we can see that there is not only a **Canvas**
    component attached to this GameObject but also **Rect Transform**, **Canvas Scaler**,
    and **Graphic Raycaster** components. As mentioned previously, **Canvas** is the
    component used to render UI elements, so all UI components must be children of
    Canvas; otherwise, they will not be rendered by Unity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We will explore them separately in order.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas component
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you select the **Canvas** object in the scene, you may be surprised to find
    that its position is strange. By default, it is not in the field of view of **Main
    Camera**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – A Canvas object with the Screen Space - Overlay render mode
    in the scene'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B17146.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – A Canvas object with the Screen Space - Overlay render mode in
    the scene
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because the **Canvas** component attached to this GameObject provides
    three different **render modes**, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Screen Space - Overlay**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen Space - Camera**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**World Space**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Render modes'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B17146.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Render modes
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The **Screen Space - Overlay** render mode places UI elements on the screen
    that are rendered on top of the scene. Therefore, the cameras located in the scene
    used to render the game scene will not affect the rendering of the UI. This is
    the default render mode provided by the **Canvas** component.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: As the name implies, the **Screen Space - Camera** render mode is somewhat similar
    to the previous one. However, as can be seen from the name, the second render
    mode will be affected by the camera.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Screen Space - Camera render mode'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B17146.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – The Screen Space - Camera render mode
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 3.7*, if the **Screen Space - Camera** render mode
    is selected, we need to specify a camera for this canvas and set a distance between
    them. Furthermore, if we still select this canvas in the scene, we will find that
    it has been moved into the field of view of this particular camera.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – A Canvas object with the Screen Space - Camera render mode in
    the scene'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B17146.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – A Canvas object with the Screen Space - Camera render mode in the
    scene
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the UI elements are rendered by this camera, which means that
    the camera settings affect the appearance of the UI. This is different from the
    **Screen Space - Overlay** render mode.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，UI元素是由这个相机渲染的，这意味着相机的设置会影响UI的外观。这与**Screen Space - Overlay**渲染模式不同。
- en: '*Figure 3.9* shows that when the **Field of View** value of this camera is
    changed from 100 to 30, the game scene and the UI have changed:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.9*显示，当此相机的**Field of View**值从100变为30时，游戏场景和UI发生了变化：'
- en: '![Figure 3.9 – The field of view (FoV) of the camera is 100 in the upper half
    and 30 in the lower half'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.9 – 相机的视场（FoV）在上半部分为100，下半部分为30'
- en: '](img/Figure_3.9_B17146.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B17146.jpg)'
- en: Figure 3.9 – The field of view (FoV) of the camera is 100 in the upper half
    and 30 in the lower half
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 相机的视场（FoV）在上半部分为100，下半部分为30
- en: The last render mode is **World Space**. In this mode, the canvas will work
    like any other GameObject in the scene. The biggest difference between this mode
    and the **Screen Space - Camera** render mode is that we can manually adjust the
    size, position, and even rotation angle of the canvas, just like a normal GameObject.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种渲染模式是**World Space**。在这种模式下，画布将像场景中的任何其他GameObject一样工作。这种模式与**Screen Space
    - Camera**渲染模式之间最大的区别是我们可以手动调整画布的大小、位置，甚至旋转角度，就像一个普通GameObject一样。
- en: 'As shown in *Figure 3.10*, we can use the **Rect Transform** component of this
    **Canvas** object to adjust its **Width** and **Rotation** values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.10*所示，我们可以使用此**Canvas**对象的**Rect Transform**组件来调整其**Width**和**Rotation**值：
- en: '![Figure 3.10 – The World Space render mode'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.10 – 世界空间渲染模式'
- en: '](img/Figure_3.10_B17146.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B17146.jpg)'
- en: Figure 3.10 – The World Space render mode
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 世界空间渲染模式
- en: '*Figure 3.11* shows the **Canvas** object in the scene after manually setting
    the **Width** and **Rotation** values:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.11*显示了在场景中手动设置**Width**和**Rotation**值后的**Canvas**对象：'
- en: '![Figure 3.11 – A Canvas object with the World Space render mode in the scene'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.11 – 场景中具有世界空间渲染模式的Canvas对象'
- en: '](img/Figure_3.11_B17146.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B17146.jpg)'
- en: Figure 3.11 – A Canvas object with the World Space render mode in the scene
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 场景中具有世界空间渲染模式的Canvas对象
- en: Here, we use the **RectTransform** component to set the size of the canvas.
    Every UI object will contain a **RectTransform** component, just like every normal
    GameObject will contain a Transform component. Next, we will explore the **RectTransform**
    component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用**RectTransform**组件来设置画布的大小。每个UI对象都将包含一个**RectTransform**组件，就像每个普通GameObject都将包含一个Transform组件一样。接下来，我们将探讨**RectTransform**组件。
- en: The Rect Transform component
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rect Transform组件
- en: The **Rect Transform** component is similar to the regular **Transform** component.
    The biggest difference is that the former is used for UI elements instead of regular
    GameObjects. When a new UI element object is created, the **Rect Transform** component
    will be automatically attached to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rect Transform**组件与常规的**Transform**组件类似。最大的区别是前者用于UI元素而不是常规的GameObject。当创建一个新的UI元素对象时，**Rect
    Transform**组件将自动附加到它上。'
- en: Looking at this component, you can see some properties that can be seen on the
    **Transform** component, such as **Position**, **Rotation**, and **Scale**. There
    are also some unique properties.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 观察此组件，你可以看到一些在**Transform**组件上可以看到的属性，例如**Position**、**Rotation**和**Scale**。还有一些独特的属性。
- en: '![Figure 3.12 – A Rect Transform component'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.12 – 一个Rect Transform组件'
- en: '](img/Figure_3.12_B17146.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.12_B17146.jpg)'
- en: Figure 3.12 – A Rect Transform component
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 一个Rect Transform组件
- en: These unique ones are **Anchor** and **Pivot**. We will discuss these in turn.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些独特的属性是**Anchor**和**Pivot**。我们将依次讨论这些。
- en: Anchors
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 锚点
- en: The anchors are numerical values indicating the position of the four corners
    of the area as seen from the `AnchorMin.x` and `AnchorMin.y`, and the upper right
    is represented by `AnchorMax.x` and `AnchorMax.y`. By default, the lower left
    is 0.5 and 0.5, and the upper right is also 0.5 and 0.5, centered relative to
    the parent, as shown in *Figure 3.12*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点是指示区域四个角位置的数值，从`AnchorMin.x`和`AnchorMin.y`的角度看，右上角由`AnchorMax.x`和`AnchorMax.y`表示。默认情况下，左下角是0.5和0.5，右上角也是0.5和0.5，相对于父对象居中，如*图3.12*所示。
- en: 'We can directly modify the value of anchors – for example, we can change the
    lower-left corner from 0.5 and 0.5 to 0 and 0, so that the lower-left corner of
    the parent and child are the same. Then, we change the upper-right corner from
    0.5 and 0.5 to 0.5 and 1, which means that the position of the upper-right corner
    of the child is half of the *x* axis position of the upper-right corner of the
    parent. The result is shown in *Figure 3.13*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接修改锚点的值 – 例如，我们可以将左下角从 0.5 和 0.5 更改为 0 和 0，这样父元素和子元素的左下角就相同了。然后，我们将右上角从
    0.5 和 0.5 更改为 0.5 和 1，这意味着子元素的右上角位置是父元素右上角 *x* 轴位置的一半。结果如图 3.13 所示：
- en: '![Figure 3.13 – Modifying the anchors'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.13 – 修改锚点'
- en: '](img/Figure_3.13_B17146.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B17146.jpg)'
- en: Figure 3.13 – Modifying the anchors
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 修改锚点
- en: Anchors are very useful when developing the UI in Unity. For example, if you
    want to display the UI at the top of the screen, such as a title, you need to
    specify the distance from the top of the parent. If you want to display the UI
    at the bottom of the screen, such as a footer, you need to specify the distance
    from the bottom of the parent.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点在 Unity 中开发 UI 时非常有用。例如，如果您想在屏幕顶部显示 UI，例如标题，您需要指定从父元素顶部的距离。如果您想在屏幕底部显示 UI，例如页脚，您需要指定从父元素底部的距离。
- en: 'In order to make it easier for developers to use anchors, Unity provides some
    anchor presets, as shown in *Figure 3.14*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发者更容易使用锚点，Unity 提供了一些锚点预设，如图 3.14 所示：
- en: '![Figure 3.14 – Anchor Presets'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.14 – 锚点预设'
- en: '](img/Figure_3.14_B17146.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B17146.jpg)'
- en: Figure 3.14 – Anchor Presets
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 锚点预设
- en: Pivot
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中心点
- en: 'The **Pivot** point is the origin of this rectangle area. The value of the
    **Pivot** point is specified in normalized values between 0 and 1\. When the UI
    element is scaled or rotated, it will scale or rotate around that point:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**中心点** 是这个矩形区域的起点。**中心点** 的值是在 0 和 1 之间的归一化值。当 UI 元素缩放或旋转时，它将围绕该点进行缩放或旋转：'
- en: '![Figure 3.15 – Rotate 45 degrees along the z axis around the center and'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.15 – 以中心为中心沿 z 轴旋转 45 度]'
- en: 45 degrees along the z axis around the upper-right corner
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 沿 z 轴以右上角为中心旋转 45 度
- en: '](img/Figure_3.15_B17146.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15_B17146.jpg)'
- en: Figure 3.15 – Rotate 45 degrees along the *z* axis around the center and 45
    degrees along the *z* axis around the upper-right corner
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 以中心为中心沿 *z* 轴旋转 45 度，以右上角为中心沿 *z* 轴旋转 45 度]
- en: '*Figure 3.15* shows a 45-degree rotation along the *z* axis around the center,
    which has a **Pivot** point value of 0.5 and 0.5, and a 45-degree rotation along
    the *z* axis around the upper-right corner, which has a **Pivot** point value
    of 1 and 1.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.15* 展示了以中心为中心沿 *z* 轴的 45 度旋转，其 **中心点** 值为 0.5 和 0.5，以及以右上角为中心沿 *z* 轴的
    45 度旋转，其 **中心点** 值为 1 和 1。'
- en: The Canvas Scaler component
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Canvas Scaler 组件
- en: 'Along with the **Canvas** component, a **Canvas Scaler** component is also
    created automatically. The **Canvas Scaler** component is used to control the
    overall scale and pixel density of UI elements inside a canvas. By using **Canvas
    Scaler**, we can implement a resolution-independent UI layout:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **Canvas** 组件外，还会自动创建一个 **Canvas Scaler** 组件。**Canvas Scaler** 组件用于控制画布内
    UI 元素的整体缩放和像素密度。通过使用 **Canvas Scaler**，我们可以实现分辨率无关的 UI 布局：
- en: '![Figure 3.16 – The Canvas Scaler component'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.16 – Canvas Scaler 组件'
- en: '](img/Figure_3.16_B17146.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16_B17146.jpg)'
- en: Figure 3.16 – The Canvas Scaler component
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – Canvas Scaler 组件
- en: 'There are three **UI Scale Mode** types provided by a **Canvas Scaler** component:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas Scaler 组件提供的 **UI 缩放模式** 有三种类型：
- en: '**Constant Pixel Size**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒定像素尺寸**'
- en: '**Scale With Screen Size**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与屏幕尺寸缩放**'
- en: '**Constant Physical Size**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒定物理尺寸**'
- en: If the canvas render mode is **ScreenSpace - Overlay** or **ScreenSpace - Camera**,
    then we can set the UI Scale Mode. On the other hand, if the canvas render mode
    is **World Space**, the UI Scale Mode cannot be modified. Next, we will introduce
    these three different modes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果画布渲染模式是 **ScreenSpace - Overlay** 或 **ScreenSpace - Camera**，则我们可以设置 UI 缩放模式。另一方面，如果画布渲染模式是
    **World Space**，则无法修改 UI 缩放模式。接下来，我们将介绍这三种不同的模式。
- en: '**Constant Pixel Size** is the default UI Scale Mode. In this mode, the size
    of the UI elements will retain the same size in pixels regardless of screen size.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**恒定像素尺寸** 是默认的 UI 缩放模式。在此模式下，UI 元素的大小将保持像素大小不变，无论屏幕大小如何。'
- en: '![Figure 3.17 – The Hello World UI text displayed in different screen sizes'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.17 – 在不同屏幕尺寸下显示的 Hello World UI 文本'
- en: (1920 x 1080 in the upper half and 3840 x 2160 in the lower half)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: （上半部分为1920 x 1080，下半部分为3840 x 2160）
- en: '](img/Figure_3.17_B17146.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.17_B17146.jpg)'
- en: Figure 3.17 – The Hello World UI text displayed in different screen sizes (1920
    x 1080 in the upper half and 3840 x 2160 in the lower half)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – 在不同屏幕大小下显示的Hello World UI文本（上半部分为1920 x 1080，下半部分为3840 x 2160）
- en: As shown in *Figure 3.17*, a **Hello World** UI text will retain its own size
    in pixels. When the screen resolution is relatively low (*1920 x 1080*), the text
    will be displayed larger. When at a higher screen resolution (*3840 x 2160*),
    the text will be displayed smaller.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.17*所示，一个**Hello World** UI文本将保持其像素大小不变。当屏幕分辨率相对较低（*1920 x 1080*）时，文本将显示得更大。当屏幕分辨率较高（*3840
    x 2160*）时，文本将显示得较小。
- en: If you want to keep the UI elements displayed consistently under different screen
    resolutions, the **Scale With Screen Size** mode is an ideal option.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在不同的屏幕分辨率下保持UI元素显示的一致性，**根据屏幕大小缩放**模式是一个理想的选择。
- en: '![Figure 3.18 – The Scale With Screen Size mode'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.18 – 根据屏幕大小缩放模式'
- en: '](img/Figure_3.18_B17146.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.18_B17146.jpg)'
- en: Figure 3.18 – The Scale With Screen Size mode
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 根据屏幕大小缩放模式
- en: If **UI Scale Mode** is set to **Scale With Screen Size**, the position and
    size of the UI elements will be specified according to the value of pixels in
    the **Reference Resolution** properties, as shown in *Figure 3.18*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当**UI缩放模式**设置为**根据屏幕大小缩放**时，UI元素的位置和大小将根据**参考分辨率**属性中的像素值指定，如*图3.18*所示。
- en: If the current screen resolution is greater than the reference resolution, the
    canvas will be scaled to fit the screen resolution. Conversely, if the current
    screen resolution is less than the reference resolution, the canvas will shrink
    to fit the screen resolution.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前屏幕分辨率大于参考分辨率，画布将被缩放以适应屏幕分辨率。反之，如果当前屏幕分辨率小于参考分辨率，画布将缩小以适应屏幕分辨率。
- en: If the screen resolution ratio is the same as the reference resolution ratio,
    it is very easy to scale and shrink the UI elements. But when the screen resolution
    ratio is different from the reference resolution ratio, scaling the canvas will
    distort it. In order to avoid this situation, the resolution of the canvas will
    also depend on the setting of **Screen Match Mode**, which you can also see in
    *Figure 3.18*. By default, the **Screen Match Mode** setting is **Match Width
    or Height**, which allows you to scale the canvas area with the width or height
    as the reference, or a value in between.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕分辨率比例与参考分辨率比例相同时，缩放和缩小UI元素非常容易。但当屏幕分辨率比例与参考分辨率比例不同时，缩放画布会导致其变形。为了避免这种情况，画布的分辨率也将取决于**屏幕匹配模式**的设置，您也可以在*图3.18*中看到。默认情况下，**屏幕匹配模式**设置为**匹配宽度和高度**，这允许您以宽度或高度作为参考，或介于两者之间的值来缩放画布区域。
- en: When **UI Scale Mode** is set to **Constant Physical Size**, the position and
    size of UI elements are specified in physical units such as *millimeters* and
    *inches*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当**UI缩放模式**设置为**常量物理大小**时，UI元素的位置和大小以物理单位如*毫米*和*英寸*指定。
- en: '![Figure 3.19 – The Constant Physical Size mode'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19 – 常量物理大小模式'
- en: '](img/Figure_3.19_B17146.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.19_B17146.jpg)'
- en: Figure 3.19 – The Constant Physical Size mode
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – 常量物理大小模式
- en: In addition to the **Canvas Scaler** component, another component is also automatically
    created, which we will take a look at next.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**画布缩放器**组件外，还会自动创建另一个组件，我们将在下一节中查看。
- en: The Graphic Raycaster component
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形射线投射器组件
- en: As the name suggests, the **Graphic Raycaster** component is used to perform
    raycasting against a list of UI elements within a canvas to determine which of
    the UI elements has been hit. So it can translate the player's input into UI events.
    It should be noted that there needs to be an **Event System** component in the
    scene for **Graphic Raycaster** to work properly. About the **Event System** component,
    we will introduce it later in the section "*C# scripts and the UI Event System
    in Unity*".
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，**图形射线投射器**组件用于对画布内的一组UI元素进行射线投射，以确定哪个UI元素被击中。因此，它可以将在玩家输入转换为UI事件。需要注意的是，场景中需要有**事件系统**组件，**图形射线投射器**才能正常工作。关于**事件系统**组件，我们将在“*C#脚本和Unity中的UI事件系统*”部分中稍后介绍。
- en: 'This is useful when you need to determine whether the cursor is over UI elements
    in the scene, such as UI text or UI images. For example, say you want the player
    to be able to drag and drop a UI image into your game to change its position,
    then you have to know whether the player''s cursor is over the UI image and get
    data about the cursor movement when the drag occurs. In this case, you need to
    create a script that implements the `IPointerDownHandler` and `IDragHandler` interfaces
    defined in the `UnityEngine.EventSystems` namespace, meaning that you can get
    events when the player clicks and drags the image, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这在您需要确定光标是否位于场景中的UI元素上时很有用，例如UI文本或UI图像。例如，假设您想让玩家能够将UI图像拖放到游戏中以改变其位置，那么您必须知道玩家的光标是否位于UI图像上，并在拖动时获取光标移动的数据。在这种情况下，您需要创建一个脚本，实现`UnityEngine.EventSystems`命名空间中定义的`IPointerDownHandler`和`IDragHandler`接口，这意味着当玩家点击和拖动图像时，您可以获取事件，如下所示：
- en: '[PRE0]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s break down the code as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解代码：
- en: We add the `UnityEngine.EventSystems` namespace with the `using` keyword to
    get events related to clicking and dragging UI elements.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`using`关键字添加`UnityEngine.EventSystems`命名空间以获取与点击和拖动UI元素相关的事件。
- en: The `DragAndDropExample` class implements the two interfaces, namely, `IPointerDownHandler`
    and `IDragHandler`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DragAndDropExample`类实现了两个接口，即`IPointerDownHandler`和`IDragHandler`。'
- en: Specifically, we implement the `OnPointerDown` method in the `IPointerDownHandler`
    interface, which will be called when the UI element is clicked.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体来说，我们在`IPointerDownHandler`接口中实现了`OnPointerDown`方法，该方法将在UI元素被点击时被调用。
- en: And we implemented the `OnDrag` method in the `IDragHandler` interface. When
    a drag occurs, this method will be called every time the cursor is moved.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`IDragHandler`接口中实现了`OnDrag`方法。当发生拖动时，每次光标移动时都会调用此方法。
- en: In the implementation of the `OnPointerDown` method, which takes `PointerEventData`
    as an argument, gets an instance of the `RectTransform` component, and assigns
    it to the `_rectTransform` field.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`OnPointerDown`方法的实现中，该方法接受`PointerEventData`作为参数，获取`RectTransform`组件的实例，并将其分配给`_rectTransform`字段。
- en: In the implementation of the `OnDrag` method, which also takes `PointerEventData`
    as an argument, gets the cursor position, and modifies the `position` property
    of the `_rectTransform` field to move the UI element.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`OnDrag`方法的实现中，该方法也接受`PointerEventData`作为参数，获取光标位置，并修改`_rectTransform`字段的`position`属性以移动UI元素。
- en: In order for this script to work, you need to attach the script to the UI element
    in the scene that you want to drag and drop.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此脚本工作，您需要将脚本附加到场景中您想要拖放的那个UI元素上。
- en: '![Figure 3.20 – Dragging and dropping a UI image'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.20 – Dragging and dropping a UI image](img/Figure_3.20_B17146.jpg)'
- en: '](img/Figure_3.20_B17146.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.20 – Dragging and dropping a UI image](img/Figure_3.20_B17146.jpg)'
- en: Figure 3.20 – Dragging and dropping a UI image
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.20 – Dragging and dropping a UI image](img/Figure_3.20_B17146.jpg)'
- en: '*Figure 3.20* shows the UI image drag and drop interaction based on the **Graphic
    Raycaster** component.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.20*显示了基于**Graphic Raycaster**组件的UI图像拖放交互。'
- en: The components described previously are automatically created when a **Canvas**
    object is created. Next, we will introduce other UI elements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的组件在创建**Canvas**对象时自动创建。接下来，我们将介绍其他UI元素。
- en: Image
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Image
- en: Displaying images is an important function of the UI. There are two types of
    components provided by uGUI that display images – the **Image** component and
    the **Raw Image** component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显示图像是UI的一个重要功能。uGUI提供了两种显示图像的组件类型——**Image**组件和**Raw Image**组件。
- en: We will now explain these features and how to use them properly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将解释这些功能以及如何正确使用它们。
- en: The Image component
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像组件
- en: You can use the **Image** component to display an image on your UI.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**Image**组件在UI上显示图像。
- en: '![Figure 3.21 – Creating a new image'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.21 – Creating a new image](img/Figure_3.21_B17146.jpg)'
- en: '](img/Figure_3.21_B17146.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.21 – Creating a new image](img/Figure_3.21_B17146.jpg)'
- en: Figure 3.21 – Creating a new image
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – 创建新图像
- en: 'As shown in *Figure 3.21*, you can create a new image as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.21*所示，您可以按照以下步骤创建一个新图像：
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中右键单击以打开菜单。
- en: Select **UI** > **Image**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**UI** > **Image**。
- en: If you want to create a background image for your game UI, you can also select
    **UI** > **Panel**. The panel is nothing but an image.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在游戏UI中创建背景图像，也可以选择**UI** > **Panel**。面板实际上就是一个图像。
- en: '![Figure 3.22 – The Image component'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.22 – The Image component](img/Figure_3.22_B17146.jpg)'
- en: '](img/Figure_3.22_B17146.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.22 – The Image component](img/Figure_3.22_B17146.jpg)'
- en: Figure 3.22 – The Image component
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 – 图像组件
- en: In this case, we create a panel as the background. As you can see in *Figure
    3.22*, here we specify a texture called **SF Background** as the source image
    of this **Image** component. It should be noted that the texture used by the **Image**
    component must be set to the Sprite type when imported into Unity.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建一个面板作为背景。如图*图3.22*所示，这里我们指定一个名为**SF背景**的纹理作为此**图像**组件的源图像。需要注意的是，当导入Unity时，**图像**组件使用的纹理必须设置为精灵类型。
- en: '![Figure 3.23 – Texture Import Settings'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.23 – 纹理导入设置'
- en: '](img/Figure_3.23_B17146.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.23_B17146.jpg)'
- en: Figure 3.23 – Texture Import Settings
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 – 纹理导入设置
- en: '**Texture Type** can be set in the texture''s **Import Settings** panel, as
    shown in *Figure 3.23*.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**纹理类型**可以在纹理的**导入设置**面板中设置，如图*图3.23*所示。'
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sprites are 2D graphic objects used for the UI and other elements of 2D gameplay.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图像精灵是用于UI和其他2D游戏元素中的2D图形对象。
- en: The advantage of using sprites as an image source is that the corners will not
    be stretched or distorted when resizing the sprites.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用精灵作为图像源的优势在于，在调整精灵大小时，角落不会拉伸或扭曲。
- en: '![Figure 3.24 – The Sprite Editor'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.24 – 精灵编辑器'
- en: '](img/Figure_3.24_B17146.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.24_B17146.jpg)'
- en: Figure 3.24 – The Sprite Editor
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 – 精灵编辑器
- en: This is because **Sprite Editor** in Unity provides the option of **9-slicing**
    the image, which divides the image into nine regions. As shown in *Figure 3.24*,
    in this case, when the image is resized, the corners of the image will remain
    the same.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Unity中的**精灵编辑器**提供了**九宫格分割**图像的选项，将图像分割成九个区域。如图*图3.24*所示，在这种情况下，当图像被调整大小时，图像的角落将保持不变。
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 9-slicing is a common technique in UI implementation. The main advantage of
    using 9-slicing is that it can handle the stretching of the image very well. Once
    an image is stretched, there will be problems such as distortion and blurring,
    but some parts of the image can be stretched. For example, a UI background frame,
    the middle part of which is usually a solid color, can be stretched, but the four
    corners of the image may have some special patterns that cannot be stretched.
    At this time, we can use the 9-slicing technique to divide the whole image into
    nine grids, and each of the four corners is in a grid. Then, we can only stretch
    and enlarge the middle part of the image and keep the four corners as they are.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 九宫格分割是UI实现中的一种常见技术。使用九宫格分割的主要优势是它可以很好地处理图像的拉伸。一旦图像被拉伸，就会出现扭曲和模糊等问题，但图像的一些部分可以被拉伸。例如，UI背景框，其中通常中间部分是纯色，可以被拉伸，但图像的四个角落可能有不能拉伸的特殊图案。在这种情况下，我们可以使用九宫格分割技术将整个图像分成九个网格，其中四个角落各在一个网格中。然后，我们只能拉伸和放大图像的中间部分，而保持四个角落不变。
- en: Therefore, in most cases, using the **Image** component to display UI images
    is the preferred choice.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在大多数情况下，使用**图像**组件来显示UI图像是首选的选择。
- en: The Raw Image component
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始图像组件
- en: The **Raw Image** component is another component used to display images on the
    game UI.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始图像**组件是另一个用于在游戏UI上显示图像的组件。'
- en: '![Figure 3.25 – Creating a new raw image'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.25 – 创建新的原始图像'
- en: '](img/Figure_3.25_B17146.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.25_B17146.jpg)'
- en: Figure 3.25 – Creating a new raw image
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 – 创建新的原始图像
- en: 'As shown in *Figure 3.25*, you can create a new image, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.25*所示，您可以创建一个新的图像，如下所示：
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中右键单击以打开菜单。
- en: Select **UI** > **Raw Image**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**UI** > **原始图像**。
- en: 'The difference between the **Raw Image** component and the **Image** component
    is that the source of an **Image** component must be a **Sprite** type. Conversely,
    **Raw Image** accepts any texture. Also, the function of the **Raw Image** component
    is simpler than an **Image** component, as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始图像**组件和**图像**组件之间的区别是，**图像**组件的源必须是**精灵**类型。相反，**原始图像**接受任何纹理。此外，**原始图像**组件的功能比**图像**组件简单，如下面的截图所示：'
- en: '![Figure 3.26 – A Raw Image component'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.26 – 原始图像组件'
- en: '](img/Figure_3.26_B17146.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.26_B17146.jpg)'
- en: Figure 3.26 – A Raw Image component
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26 – 原始图像组件
- en: 'The following code snippet shows how to modify the image displayed by the **Image**
    and **Raw Image** components:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何修改**图像**和**原始图像**组件显示的图像：
- en: '[PRE1]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It should be noted that in order to be able to access UI-related classes in
    the code, we need to use the `UnityEngine.UI` namespace.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，为了能够在代码中访问UI相关的类，我们需要使用`UnityEngine.UI`命名空间。
- en: Another important part of the UI is **text**. Next, let's explore the two components
    provided by uGUI to display text.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: UI 的另一个重要部分是 **文本**。接下来，让我们探索 uGUI 提供的用于显示文本的两个组件。
- en: Text
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本
- en: The simplest way to display characters in uGUI is to use the **Text** component.
    However, it is also troublesome to adjust the spacing between characters and express
    decorations with **Text** alone. **TextMeshPro** is another option, which provides
    gorgeous character expression. In this section, we will explore the **Text** and
    **TextMeshPro** components in turn.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 uGUI 中显示字符的最简单方法是使用 **Text** 组件。然而，仅使用 **Text** 来调整字符间距和表达装饰也是一件麻烦事。**TextMeshPro**
    是另一个选项，它提供了华丽的字符表达。在本节中，我们将依次探索 **Text** 和 **TextMeshPro** 组件。
- en: The Text component
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本组件
- en: 'The **Text** component is a component commonly used to display UI text since
    the early days of uGUI. Creating text for the game UI is very simple; just follow
    these step:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**Text** 组件是自 uGUI 早期以来常用以显示 UI 文本的组件。为游戏 UI 创建文本非常简单；只需遵循以下步骤：'
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次** 窗口中右键点击以打开菜单。
- en: Select **UI** > **Text**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **UI** > **文本** 下选择。
- en: '![Figure 3.27 – Creating text'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.27 – 创建文本'
- en: '](img/Figure_3.27_B17146.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.27_B17146.jpg)'
- en: Figure 3.27 – Creating text
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27 – 创建文本
- en: 'A **Text** object will be created in the canvas; we can find it in the **Scene**
    view of the Unity Editor, as shown in *Figure 3.28*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布中创建一个 **Text** 对象；我们可以在 Unity 编辑器的 **场景** 视图中找到它，如图 *图 3.28* 所示：
- en: '![Figure 3.28 – Text in the Scene view'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.28 – 场景视图中的文本'
- en: '](img/Figure_3.28_B17146.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.28_B17146.jpg)'
- en: Figure 3.28 – Text in the Scene view
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28 – 场景视图中的文本
- en: You can see that the text content is in a white frame, which represents the
    **Rect Transform** component attached to this **Text** object and identifies its
    size. If changing the font size causes the text content to exceed this white frame,
    the text content cannot be displayed. Therefore, remember to consider the **Rect
    Transform** component of **Text** when changing the font size.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到文本内容在一个白色框架中，这代表附加到这个 **Text** 对象上的 **Rect Transform** 组件，并标识其大小。如果更改字体大小导致文本内容超出这个白色框架，文本内容将无法显示。因此，在更改字体大小时，请记住考虑
    **Text** 的 **Rect Transform** 组件。
- en: In addition to changing the font size, you can also change the font used or
    enable **Rich Text**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改字体大小外，您还可以更改使用的字体或启用 **富文本**。
- en: '![Figure 3.29 – The Text component'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.29 – 文本组件'
- en: '](img/Figure_3.29_B17146.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.29_B17146.jpg)'
- en: Figure 3.29 – The Text component
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.29 – 文本组件
- en: As you can see in *Figure 3.29*, if the `<b></b>, <i></i>,` and `<color></color>`,
    within the text to provide style changes to the text.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 3.29* 所示，您可以在文本中添加 `<b></b>`, `<i></i>`, 和 `<color></color>` 标签，以提供文本的样式变化。
- en: However, the function provided by the **Text** component is relatively simple.
    When the **Text** component changes, the polygon used to display the text needs
    to be recalculated, resulting in graphic reconstruction, which can cause potential
    performance problems, and when displayed in high resolution, the text rendered
    by this component looks very blurry. Therefore, after the original **Text** component,
    Unity also provides another text solution for the UI. Next, we will introduce
    the **TextMesh Pro** component.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**Text** 组件提供的功能相对简单。当 **Text** 组件发生变化时，用于显示文本的多边形需要重新计算，这会导致图形重建，可能会引起潜在的性能问题，并且当以高分辨率显示时，该组件渲染的文本看起来非常模糊。因此，在原始的
    **Text** 组件之后，Unity 还为 UI 提供了另一个文本解决方案。接下来，我们将介绍 **TextMesh Pro** 组件。
- en: The TextMeshPro component
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TextMeshPro 组件
- en: '**TextMeshPro** (**TMP**) is the ultimate text solution for the UI provided
    by Unity. It is a powerful mechanism for text rendering that can be used to replace
    the **Text** component. **TextMesh Pro** has been designed to take advantage of
    **Signed Distance Field** (**SDF**) rendering, allowing it to render text beautifully
    at any resolution. You can also create custom shaders for **TextMesh Pro** to
    get effects such as outlines and soft shadows.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextMeshPro** (**TMP**) 是 Unity 提供的终极 UI 文本解决方案。它是一种强大的文本渲染机制，可以用来替换 **Text**
    组件。**TextMesh Pro** 被设计用来利用 **Signed Distance Field** (**SDF**) 渲染，使其能够在任何分辨率下渲染出美丽的文本。您还可以为
    **TextMesh Pro** 创建自定义着色器，以获得轮廓和柔化阴影等效果。'
- en: It should be noted that it is not included in the default `Unity UI` package,
    but is included in the `TextMeshPro` package. So if you can't find **TextMesh
    Pro** when creating UI text, then you should first check whether this package
    has been added to your project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，它不包括在默认的`Unity UI`包中，但包含在`TextMeshPro`包中。因此，如果您在创建UI文本时找不到**TextMesh Pro**，那么您应该首先检查此包是否已添加到您的项目中。
- en: '![Figure 3.30 – Creating a TextMeshPro object'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.30 – 创建TextMeshPro对象'
- en: '](img/Figure_3.30_B17146.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.30_B17146.jpg)'
- en: Figure 3.30 – Creating a TextMeshPro object
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.30 – 创建TextMeshPro对象
- en: 'Creating **TextMeshPro** text for the game UI is very simple; just follow these
    steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为游戏UI创建**TextMeshPro**文本非常简单；只需遵循以下步骤：
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 窗口中右键单击以打开菜单。
- en: Select **UI** > **Text** > **TextMeshPro**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **UI** > **文本** > **TextMeshPro**。
- en: '![Figure 3.31 – The TextMeshPro component'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.31 – TextMeshPro组件'
- en: '](img/Figure_3.31_B17146.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.31_B17146.jpg)'
- en: Figure 3.31 – The TextMeshPro component
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.31 – TextMeshPro组件
- en: As shown in *Figure 3.31*, the text rendered by **TextMeshPro** is sharper than
    that rendered by the **Text** component.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.31所示，**TextMeshPro**渲染的文本比**文本**组件渲染的文本更清晰。
- en: In addition to rendering the text sharper, **TextMeshPro** also provides improved
    control over text format and layout. As shown in *Figure 3.32*, you can directly
    change the style of the text through the editor. There are several common styles
    to choose from, such as *bold* and italics. Similarly, you can also use tags to
    modify the text style, just like the **Text** component, and features such as
    **Spacing Options**, **Alignment**, and **Wrapping**, can be used to control the
    text layout.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了渲染更清晰的文本外，**TextMeshPro** 还提供了对文本格式和布局的改进控制。如图3.32所示，您可以通过编辑器直接更改文本的样式。有几种常见的样式可供选择，例如
    *粗体* 和 *斜体*。同样，您也可以使用标签来修改文本样式，就像 **文本** 组件一样，并且可以使用 **间距选项**、**对齐** 和 **换行**
    等功能来控制文本布局。
- en: In addition, you can also achieve more rendering effects, such as clicking the
    outline option of the shader to add outline effects to the text.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以实现更多渲染效果，例如点击着色器的轮廓选项以向文本添加轮廓效果。
- en: '![Figure 3.32 – The TextMeshPro component'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.32 – TextMeshPro组件'
- en: '](img/Figure_3.32_B17146.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.32_B17146.jpg)'
- en: Figure 3.32 – The TextMeshPro component
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.32 – TextMeshPro组件
- en: Using TextMesh Pro to implement your UI text is a good choice.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TextMesh Pro来实现您的UI文本是一个不错的选择。
- en: Selectable UI components
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选择UI组件
- en: You can use selectable components in uGUI to handle interactions. These components
    include **Button**, **Toggle**, **Slider**, **Dropdown**, **Input Field**, and
    **Scrollbar**. In this section, we will mainly discuss the most commonly used
    component, namely, the **Button** component.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用uGUI中的可选择组件来处理交互。这些组件包括 **按钮**、**切换**、**滑动条**、**下拉菜单**、**输入字段** 和 **滚动条**。在本节中，我们将主要讨论最常用的组件，即
    **按钮** 组件。
- en: Button
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮
- en: 'Creating a **Button** element for the game UI is very simple; just follow these
    steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为游戏UI创建一个 **按钮** 元素非常简单；只需遵循以下步骤：
- en: Right-click in the **Hierarchy** window to open the menu.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 窗口中右键单击以打开菜单。
- en: Select **UI** > **Button - TextMeshPro**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **UI** > **按钮 - TextMeshPro**。
- en: '![Figure 3.33 – Creating a Button object'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.33 – 创建按钮对象'
- en: '](img/Figure_3.33_B17146.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.33_B17146.jpg)'
- en: Figure 3.33 – Creating a Button object
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.33 – 创建按钮对象
- en: As shown in *Figure 3.33*, there are two options to create a button in the menu,
    namely, **Button** and **Button -TextMeshPro**. Here, we select **Button -TextMeshPro**
    so that the text content on the button is rendered by **TextMeshPro**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.33所示，在菜单中有两种创建按钮的选项，即 **按钮** 和 **按钮 -TextMeshPro**。在这里，我们选择 **按钮 -TextMeshPro**，以便按钮上的文本内容由**TextMeshPro**渲染。
- en: '![Figure 3.34 – An Image component and a Button component are attached to the
    button'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.34 – 一个图像组件和一个按钮组件被附加到按钮上'
- en: '](img/Figure_3.34_B17146.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.34_B17146.jpg)'
- en: Figure 3.34 – An Image component and a Button component are attached to the
    button
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34 – 一个图像组件和一个按钮组件被附加到按钮上
- en: Once a default button object is created, this object includes not only a **Button**
    component but also an **Image** component. This is because the **Button** component
    only provides the function of interacting with the user; it does not provide the
    function of graphic display. Therefore, the image of the button needs an **Image**
    component to display.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个默认按钮对象，该对象不仅包含**Button**组件，还包含**Image**组件。这是因为**Button**组件仅提供与用户交互的功能；它不提供图形显示的功能。因此，按钮的图像需要一个**Image**组件来显示。
- en: Selected states
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择状态
- en: The `Selectable` class, namely, `Normal`, `Highlighted`, `Pressed`, `Selected`,
    and `Disabled`, which are defined by an enumeration named `Selectable.SelectionState`.
    Therefore, as shown in *Figure 3.34*, there are five different colors in the **Transition**
    section corresponding to these five different selected states, which means that
    when the user interacts with this button, this button will provide different feedback
    according to the different states.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Selectable`类，即`Normal`、`Highlighted`、`Pressed`、`Selected`和`Disabled`，这些状态由名为`Selectable.SelectionState`的枚举定义。因此，如图*图3.34*所示，**“Transition”**部分对应这五种不同的选择状态，这意味着当用户与该按钮交互时，该按钮将根据不同的状态提供不同的反馈。'
- en: onClick
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: onClick
- en: The important role of a button is to receive user clicks and trigger corresponding
    events. In Unity, it is very easy to set up button `onClick` events. You can either
    manually set up button `onClick` events in the editor or set button `onClick`
    events programmatically.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的重要作用是接收用户点击并触发相应的事件。在Unity中，设置按钮`onClick`事件非常简单。您可以在编辑器中手动设置按钮`onClick`事件，或者通过编程方式设置按钮`onClick`事件。
- en: In order to set up a new event to the button in the editor, we can click the
    **+** button at the bottom of the **On Click ()** section, as shown in *Figure
    3.35*. This will create a new action.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在编辑器中的按钮上设置一个新事件，我们可以点击**“+”**按钮，位于**“On Click ()”**部分的底部，如图*图3.35*所示。这将创建一个新的动作。
- en: '![Figure 3.35 – Setting up a new onClick event in the editor'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.35 – 在编辑器中设置新的onClick事件'
- en: '](img/Figure_3.35_B17146.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.35_B17146.jpg]'
- en: Figure 3.35 – Setting up a new onClick event in the editor
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.35 – 在编辑器中设置新的onClick事件
- en: 'We can also programmatically set the button `onClick` event; the following
    code shows how to do this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过编程方式设置按钮`onClick`事件；以下代码展示了如何进行此操作：
- en: '[PRE2]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this section, we learned about commonly used UI components and got an understanding
    of uGUI, the UI solution provided by Unity. Next, we will explore the UI Event
    System in Unity. If there is no event system in the scene, UI elements such as
    buttons cannot interact with players, so it's an important topic.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了常用的UI组件，并对Unity提供的UI解决方案uGUI有了了解。接下来，我们将探索Unity中的UI事件系统。如果场景中没有事件系统，UI元素如按钮就无法与玩家交互，因此这是一个重要的主题。
- en: C# scripts and the UI Event System in Unity
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#脚本和Unity中的UI事件系统
- en: '**EventSystem** is a mechanism for sending events to objects in a game that
    supports keyboards, mice, screen touches, and so on. EventSystem consists of multiple
    modules for sending events. If there is no **EventSystem** object in the scene,
    then, when creating a canvas, an **EventSystem** object will be automatically
    created along with it.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**EventSystem**是一个将事件发送到支持键盘、鼠标、屏幕触摸等输入的游戏对象的机制。EventSystem由多个用于发送事件的模块组成。如果场景中没有**EventSystem**对象，那么在创建画布时，将自动创建一个**EventSystem**对象。'
- en: '![Figure 3.36 – EventSystem'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.36 – EventSystem'
- en: '](img/Figure_3.36_B17146.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.36_B17146.jpg]'
- en: Figure 3.36 – EventSystem
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.36 – EventSystem
- en: As shown in *Figure 3.36*, the **Inspector** window of the **EventSystem** object
    exposes very few functionalities. This is because EventSystem is designed as a
    manager for cooperation between various **input modules**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.36*所示，**EventSystem**对象的**Inspector**窗口暴露了非常少的函数。这是因为EventSystem被设计为各种**输入模块**之间协作的管理器。
- en: 'It should be noted that there can be, at most, one **EventSystem** object in
    a scene. If there are multiple **EventSystem** objects in the scene, a warning
    message will be displayed, as shown in *Figure 3.37*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，场景中最多只能有一个**EventSystem**对象。如果场景中有多个**EventSystem**对象，将显示警告信息，如图*图3.37*所示：
- en: '![Figure 3.37 – A warning message when there are multiple EventSystem objects'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.37 – A warning message when there are multiple EventSystem objects'
- en: '](img/Figure_3.37_B17146.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.37_B17146.jpg]'
- en: Figure 3.37 – A warning message when there are multiple EventSystem objects
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.37 – 存在多个EventSystem对象时的警告信息
- en: When the game is running, **EventSystem** will look for the **InputModule**
    component attached to the same GameObject. This is because **InputModule** is
    the class responsible for the main logic of **EventSystem**. We can also find
    the Input Module used in this case, as shown in *Figure 3.36*, namely, **Standalone
    Input Module**. Next, we will introduce Input Modules.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Input Modules
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity provides two built-in Input Modules, namely, the **Standalone Input Module**
    and the **Touch Input Module**. In the past, the Standalone Input Module was used
    for keyboards, mice, and game controllers, and the Touch Input Module was for
    touch panels such as smartphones. Nowadays, the Standalone Input Module is compatible
    with all platforms and the Touch Input Module has been deprecated, so you can
    treat the Input Module as the Standalone Input Module.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the Input Module is to map hardware-specific inputs (such as
    touches, joysticks, mice, and game controllers) to events sent through the messaging
    system.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The new Input System package
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to this default built-in Input Module, Unity also provides a new,
    more powerful, flexible, and configurable **Input System** package.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.38 – The Input System package'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.38_B17146.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.38 – The Input System package
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use the new input system, then you need to install the package
    from the Package Manager window, as shown in *Figure 3.38*. Moreover, a newly
    created **EventSystem** component will still use the legacy **Standalone Input
    Module** component by default, so you need to manually replace it with the new
    **InputSystemUIInputModule** component, as shown in *Figure 3.39*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.39 – Replace with InputSystemUIInputModule'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.39_B17146.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.39 – Replace with InputSystemUIInputModule
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: By reading this section, we learned that in order to ensure that the game UI
    can correctly respond to player input, an **EventSystem** component and an Input
    Module are necessary. Next, let's move on to discussing how to create UI in Unity
    using the Model-View-ViewModel (MVVM) pattern.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-ViewModel (MVVM) pattern and the UI
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common challenge in Unity development is to find elegant ways to decouple
    components from each other, especially when developing the UI because it involves
    UI logic and UI rendering. **Model–View–ViewModel** (**MVVM**) is a software architectural
    pattern that helps developers separate the **ViewModel**, which is the UI logic,
    from the **View**, which is the UI graphics. In this section, we will explore
    how to implement an MVVM pattern in Unity.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.40 – MVVM'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.40_B17146.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.40 – MVVM
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'As its name suggests, MVVM consists of three parts:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '`Database`, or `PlayerPrefs`, which stores player preferences in Unity, and
    so on.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonoBehaviour` and is attached to the UI object. Its main role is to manage
    UI elements and trigger UI events, but it does not implement any concrete UI logic
    itself.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonoBehaviour`. It does not need to consider what the UI looks like; it only
    needs to implement concrete logic.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonoBehaviour`。它不需要考虑UI的外观；它只需要实现具体逻辑。'
- en: 'We can see that there are three parts in MVVM, so how should they be connected?
    Generally, we use two ways to connect them:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到MVVM中有三个部分，那么它们应该如何连接呢？通常，我们使用两种方式来连接它们：
- en: '`ViewModel` and `View`. Elements bound to data will automatically reflect every
    data change. By using data binding, a `ViewModel` can modify the value of the
    UI control in the View.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`和`View`。绑定到数据的元素将自动反映每个数据变化。通过使用数据绑定，`ViewModel`可以修改View中UI控件的价值。'
- en: '**Event-driven programming**: This method is used to raise events from the
    View triggered by user actions, which are then processed by the ViewModel.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动编程**：这种方法用于从由用户操作触发的View中引发事件，然后由ViewModel处理。'
- en: There are some mature MVVM framework implementations for Unity, such as the
    **Loxodon Framework**, which is a lightweight MVVM framework built specifically
    to target Unity. You can find its repository on GitHub ([https://github.com/vovgou/loxodon-framework](https://github.com/vovgou/loxodon-framework))
    or add it to your project via Unity Asset Store directly.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Unity，有一些成熟的MVVM框架实现，例如**Loxodon Framework**，这是一个专门针对Unity构建的轻量级MVVM框架。您可以在GitHub上找到它的仓库（[https://github.com/vovgou/loxodon-framework](https://github.com/vovgou/loxodon-framework)）或直接通过Unity
    Asset Store将其添加到您的项目中。
- en: '![Figure 3.41 – Loxodon Framework'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.41 – Loxodon Framework'
- en: '](img/Figure_3.41_B17146.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.41_B17146.jpg)'
- en: Figure 3.41 – Loxodon Framework
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.41 – Loxodon Framework
- en: Since our next example will use this framework, I recommend that you import
    this framework into your project first. After importing this framework, you should
    find it in the `Assets` folder of your project.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的下一个示例将使用这个框架，我建议您首先将此框架导入到您的项目中。导入此框架后，您应该在项目的`Assets`文件夹中找到它。
- en: '![Figure 3.42 – The LoxodonFramework folder'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.42 – LoxodonFramework文件夹'
- en: '](img/Figure_3.42_B17146.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.42_B17146.jpg)'
- en: Figure 3.42 – The LoxodonFramework folder
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.42 – LoxodonFramework文件夹
- en: 'Now, let''s perform the following steps to implement a sample MVVM UI via **LoxodonFramework**
    in Unity:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤在Unity中使用**LoxodonFramework**实现一个示例MVVM UI：
- en: First, let's set up `LoxodonFramework` in our game scene. We need to create
    a new canvas and add the **GlobalWindowManager** component to this canvas, as
    shown in *Figure 3.43*. A **GlobalWindowManager** component is a container that
    is used to manage views.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的游戏场景中设置`LoxodonFramework`。我们需要创建一个新的画布，并将**GlobalWindowManager**组件添加到这个画布上，如图*图3.43*所示。一个**GlobalWindowManager**组件是一个用于管理视图的容器。
- en: '![Figure 3.43 – The GlobalWindowManager component'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.43 – GlobalWindowManager组件'
- en: '](img/Figure_3.43_B17146.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.43_B17146.jpg)'
- en: Figure 3.43 – The GlobalWindowManager component
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.43 – GlobalWindowManager组件
- en: 'Next, we need to define a view. As we mentioned earlier, a view represents
    UI elements in Unity. As you can see from the following code, this view is relatively
    simple, containing only a button UI element and a text UI element, and this `SampleView`
    class inherits from the `Window` class in the Loxodon Framework. In the following
    code, you can also find the `BindingSet` class, which is used to bind and connect
    properties of `ViewModel` and `View`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个视图。正如我们之前提到的，视图在Unity中代表UI元素。从下面的代码中可以看出，这个视图相对简单，只包含一个按钮UI元素和一个文本UI元素，并且这个`SampleView`类继承自Loxodon
    Framework中的`Window`类。在下面的代码中，您还可以找到`BindingSet`类，它用于绑定和连接`ViewModel`和`View`的属性：
- en: '[PRE3]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break down this example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个例子：
- en: The two `_submitButton` and `_message` fields of this `SampleView` class refer
    to a `Button` component and a `TextMeshProUGUI` component, respectively.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个`SampleView`类的两个`_submitButton`和`_message`字段分别引用一个`Button`组件和一个`TextMeshProUGUI`组件。
- en: In the `OnCreate` method, we first create a `BindingSet` instance to bind `SampleView`
    to its corresponding `ViewModel` class – that is, `SampleViewModel`. We will introduce
    how to create the `SampleViewModel` class later.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`OnCreate`方法中，我们首先创建一个`BindingSet`实例来绑定`SampleView`到其对应的`ViewModel`类——即`SampleViewModel`。我们将在后面介绍如何创建`SampleViewModel`类。
- en: Then, we bind the `text` property of the `_message` field in `SampleView` to
    the `Message` property in `SampleViewModel` by calling the `Bind` method of `BindingSet`.
    You can see in the code that we use `OneWay` binding here, which means that only
    the view model can modify the value of the UI element in the view.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`BindingSet`的`Bind`方法将`SampleView`中`_message`字段的`text`属性绑定到`SampleViewModel`中的`Message`属性。在代码中可以看到，我们这里使用的是`OneWay`绑定，这意味着只有视图模型可以修改视图中的UI元素的值。
- en: We also bind the `onClick` event of the `_submitButton` field in `SampleView`
    to the `Submit` method in `SampleViewModel`. Finally, we call the `Build` method
    of `BindingSet` to build the binding.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还绑定`SampleView`中`_submitButton`字段的`onClick`事件到`SampleViewModel`中的`Submit`方法。最后，我们调用`BindingSet`的`Build`方法来构建绑定。
- en: At the same time, we also need to create these required UI elements in the Unity
    scene, as shown in the following figure. Let's call it **SampleUI**.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，我们还需要在Unity场景中创建这些所需的UI元素，如图所示。让我们称它为**SampleUI**。
- en: '![Figure 3.44 – Setting up the UI elements'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.44 – 设置UI元素'
- en: '](img/Figure_3.44_B17146.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.44_B17146.jpg)'
- en: Figure 3.44 – Setting up the UI elements
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.44 – 设置UI元素
- en: Then, let's create a new folder called `Resources` and create a prefab for this
    sample UI by dragging it from the **Hierarchy** window to the **Resources** folder,
    as shown in the following screenshot. So far, we have created UI elements and
    a **View** component that represent UI elements in the MVVM architecture. **SampleUI**
    can be removed from the scene because we will load its prefab and create the UI
    at runtime.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个名为`Resources`的新文件夹，并将此示例UI的预制件从**Hierarchy**窗口拖动到**Resources**文件夹中，如图所示。到目前为止，我们已经创建了UI元素和一个代表MVVM架构中UI元素的**View**组件。**SampleUI**可以从场景中移除，因为我们将在运行时加载其预制件并创建UI。
- en: '![Figure 3.45 – The SampleUI prefab'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.45 – SampleUI预制件'
- en: '](img/Figure_3.45_B17146.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.45_B17146.jpg)'
- en: Figure 3.45 – The SampleUI prefab
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.45 – SampleUI预制件
- en: 'We also need a `SampleViewModel` class, which implements concrete logic. The
    `SampleViewModel` class inherits from the `ViewModelBase` class in the Loxodon
    framework, and the logic is implemented in the `Submit` method, which modifies
    the `Message` property. In the view we created earlier, we bound the button''s
    `onClick` event to the `Submit` method in the `SampleViewModel` class, and we
    also bound the view''s `text` property of the Text UI element to the `Message`
    property of `SampleViewModel`. Therefore, after the `Submit` method modifies the
    `Message` property, the modified message content will be displayed on the UI:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`SampleViewModel`类，它实现了具体逻辑。`SampleViewModel`类继承自Loxodon框架中的`ViewModelBase`类，逻辑在`Submit`方法中实现，该方法修改`Message`属性。在之前创建的视图中，我们将按钮的`onClick`事件绑定到`SampleViewModel`类中的`Submit`方法，并且还将视图的Text
    UI元素的`text`属性绑定到`SampleViewModel`的`Message`属性。因此，在`Submit`方法修改`Message`属性后，修改后的消息内容将显示在UI上：
- en: '[PRE4]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, start up code is needed to register services and create the UI. The
    following start up code supports loading the prefab of `ApplicationContext` class
    in the following code; we use it to store data and services that can be accessed
    by other classes in the Loxodon Framework. Then, the code registers the `IUIViewLocator`
    service to load the UI prefab and create the UI elements:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，需要启动代码来注册服务和创建用户界面。以下启动代码支持在以下代码中加载`ApplicationContext`类的预制件；我们使用它来存储可以被Loxodon框架中的其他类访问的数据和服务。然后，代码注册了`IUIViewLocator`服务来加载UI预制件并创建UI元素：
- en: '[PRE5]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's run the game. As you can see in the following screenshot, we create a
    view that displays the message text at the top and a `SampleViewModel` class to
    update the message information, and the view will also update the UI text to display
    the latest information through data binding.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行游戏。如图所示，我们创建了一个显示消息文本的视图和一个用于更新消息信息的`SampleViewModel`类，视图将通过数据绑定更新UI文本以显示最新信息。
- en: '![Figure 3.46 – The sample UI with MVVM'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.46 – 带有MVVM的示例UI'
- en: '](img/Figure_3.46_B17146.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.46_B17146.jpg)'
- en: Figure 3.46 – The sample UI with MVVM
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.46 – 带有MVVM的示例UI
- en: This way, the UI graphics and UI logic are separated. UI designers and programmers
    can work at the same time without relying on each other, thereby improving the
    efficiency of UI development in Unity.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，UI图形和UI逻辑就被分离开了。UI设计师和程序员可以同时工作，而不需要相互依赖，从而提高了Unity中UI开发的效率。
- en: In this section, we discussed how to use MVVM to implement the UI in Unity.
    Next, we will learn what we must pay attention to when implementing the UI in
    Unity – that is, optimizing UI performance.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何使用MVVM在Unity中实现UI。接下来，我们将学习在Unity中实现UI时需要注意的事项——即优化UI性能。
- en: Performance tips to increase performance of the UI
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高UI性能的性能提示
- en: The UI is an important part of a game, so if you do not implement it properly,
    it may cause potential performance issues. In this section, we will discuss the
    best practices for implementing the game UI in Unity to optimize the performance
    problems caused by the UI.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: UI是游戏的重要组成部分，因此如果你没有正确实现它，可能会引起潜在的性能问题。在本节中，我们将讨论在Unity中实现游戏UI的最佳实践，以优化由UI引起的性能问题。
- en: The Unity Profiler
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity Profiler
- en: 'The first best practice tip is to be good at using the Unity **Profiler**.
    The Profiler is a tool that you can use to get performance data about your game,
    including **CPU Usage**, **GPU Usage**, **Rendering**, **Memory,** **UI**, and
    **UI Details**. In order to view performance data about the UI, perform the following
    steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条最佳实践建议是熟练使用Unity **Profiler**。Profiler是一个工具，你可以用它来获取关于你游戏性能数据，包括**CPU使用率**、**GPU使用率**、**渲染**、**内存**、**UI**和**UI详细信息**。为了查看关于UI的性能数据，请执行以下步骤：
- en: Click **Window** > **Analysis** > **Profiler** to open the **Profiler** window.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**窗口** > **分析** > **Profiler**以打开**Profiler**窗口。
- en: Click the **UI** or **UI Details** module area in the **Profiler** window to
    view performance data related to the UI, such as the CPU time consumed by **Layout**
    and **Render**.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Profiler**窗口中单击**UI**或**UI详细信息**模块区域，以查看与UI相关的性能数据，例如**布局**和**渲染**消耗的CPU时间。
- en: '![Figure 3.47 – The UI area in the Profiler window'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.47 – 分析窗口中的UI区域'
- en: '](img/Figure_3.47_B17146.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.47_B17146.jpg](img/Figure_3.47_B17146.jpg)'
- en: Figure 3.47 – The UI area in the Profiler window
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.47 – 分析窗口中的UI区域
- en: 'In addition to the **UI** and **UI Details** areas, the **CPU Usage** area
    in the **Profiler** window also provides performance information related to the
    UI. In the **CPU Usage** area, you can see the CPU time consumed by a specific
    marker, such as **UGUI.Rendering.RenderOverlays**, as shown in the following screenshot:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**UI**和**UI详细信息**区域外，**Profiler**窗口中的**CPU使用率**区域还提供了与UI相关的性能信息。在**CPU使用率**区域，你可以看到特定标记（如**UGUI.Rendering.RenderOverlays**）消耗的CPU时间，如下面的截图所示：
- en: '![Figure 3.48 – The CPU Usage area in the Profiler window'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.48 – 分析窗口中的CPU使用率区域'
- en: '](img/Figure_3.48_B17146.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.48_B17146.jpg](img/Figure_3.48_B17146.jpg)'
- en: Figure 3.48 – The CPU Usage area in the Profiler window
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.48 – 分析窗口中的CPU使用率区域
- en: This was just a brief introduction to the Profiler tool. In the following chapters,
    we will discuss the Unity Profiler in detail.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对Profiler工具的简要介绍。在接下来的章节中，我们将详细讨论Unity Profiler。
- en: Multiple canvases
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个画布
- en: The second-best practice tip is a very important aspect that needs to be considered
    when implementing the UI in Unity, especially when your game UI is very complex.
    If necessary, you may need to create multiple canvases to manage and display different
    UI elements. As we have mentioned before, a canvas generates meshes representing
    the UI elements placed on it and regenerates the meshes when the UI elements change.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条最佳实践建议是在Unity中实现UI时需要考虑的一个重要方面，尤其是在你的游戏UI非常复杂时。如果需要，你可能需要创建多个画布来管理和显示不同的UI元素。正如我们之前提到的，一个画布生成表示放置在其上的UI元素的网格，并在UI元素更改时重新生成网格。
- en: Suppose that you build the UI of the entire game in a single canvas with thousands
    of UI elements, and when one or more UI elements on the canvas change, all the
    meshes used to display the UI regenerate. This may be expensive, and you may experience
    CPU spikes that take a few milliseconds.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个画布中构建了整个游戏的UI，包含数千个UI元素，当画布上的一个或多个UI元素发生变化时，用于显示UI的所有网格都会重新生成。这可能会很昂贵，你可能会遇到持续几毫秒的CPU峰值。
- en: Therefore, it is a good idea to create multiple different canvases to manage
    them, based on the update frequency of UI elements. For example, frequently updated
    dynamic UI elements such as progress bars and timers can be in one canvas, and
    infrequently updated static UI elements such as UI panels and background images
    can be in another. Of course, there is no magic bullet; you need to manage the
    canvas on a project-by-project basis.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据UI元素的更新频率创建多个不同的画布来管理它们是一个好主意。例如，进度条和计时器等频繁更新的动态UI元素可以放在一个画布中，而UI面板和背景图像等不常更新的静态UI元素可以放在另一个画布中。当然，没有一劳永逸的方法；您需要根据项目来管理画布。
- en: Use Sprite Atlas
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用精灵图集
- en: As we introduced when discussing UI images, sprites are 2D graphic objects used
    for the UI and other elements of 2D gameplay. When importing a new texture into
    the Unity Editor, we can set the texture type of this texture to a sprite. So,
    your game project may contain a lot of sprite files. If so, many sprites are treated
    as separate individuals, and rendering performance may decrease. This is because
    Unity will issue a **draw call** for each sprite in the scene, and multiple draw
    calls may consume a lot of resources and negatively affect your game performance.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论UI图像时，我们已经介绍了精灵是用于UI和其他2D游戏元素的两个维图形对象。当将新纹理导入Unity编辑器时，我们可以将此纹理的纹理类型设置为精灵。因此，您的游戏项目可能包含大量的精灵文件。如果是这样，许多精灵被视为独立的个体，这可能会降低渲染性能。这是因为Unity将为场景中的每个精灵发出**绘制调用**，多个绘制调用可能会消耗大量资源并负面影响您的游戏性能。
- en: Note
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A draw call is a call to the graphics API to draw objects (for example, to draw
    a triangle).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制调用是调用图形API来绘制对象（例如，绘制一个三角形）。
- en: 'As shown in the following screenshot, there are two draw calls to render **Button1**
    and **Button2** because these two buttons use two different textures:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，有两个绘制调用用于渲染**Button1**和**Button2**，因为这些两个按钮使用了两个不同的纹理：
- en: '![Figure 3.49 – Multiple draw calls'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.49 – 多个绘制调用'
- en: '](img/Figure_3.49_B17146.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.49_B17146.jpg]'
- en: Figure 3.49 – Multiple draw calls
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.49 – 多个绘制调用
- en: So, it is a good idea to combine several textures or sprites into a combined
    texture.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将几个纹理或精灵组合成一个组合纹理是一个好主意。
- en: 'We can perform the following steps to use the **Sprite Atlas** provided by
    Unity to combine textures:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下步骤来使用Unity提供的**精灵图集**来组合纹理：
- en: If the **Sprite Atlas** packing is disabled, enable it in **Edit** > **Project
    Settings** > **Editor** > **Sprite Packer** > **Mode**.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**精灵图集**打包被禁用，请在**编辑** > **项目设置** > **编辑器** > **精灵打包器** > **模式**中启用它。
- en: Click **Assets** > **Create** > **2D** > **Sprite Atlas** to create a Sprite
    Atlas asset.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**资产** > **创建** > **2D** > **精灵图集**以创建精灵图集资产。
- en: '![Figure 3.50 – Creating a Sprite Atlas'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.50 – 创建精灵图集'
- en: '](img/Figure_3.50_B17146.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.50_B17146.jpg]'
- en: Figure 3.50 – Creating a Sprite Atlas
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.50 – 创建精灵图集
- en: Under the **Objects for Packing** drop-down menu of the Sprite Atlas asset,
    select the **+** symbol to add textures or folders to the Sprite Atlas.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在精灵图集资产的**打包对象**下拉菜单中，选择**+**符号以添加纹理或文件夹到精灵图集。
- en: However, we still need to be aware that although Sprite Atlas can effectively
    reduce the count of draw calls, improper use can easily lead to a waste of memory.
    When a sprite is active in an atlas, Unity loads all the sprites in the atlas
    to which the sprite belongs. If there are many sprites in an atlas, even if only
    one sprite is referenced in the scene, the whole atlas will be loaded, which will
    cause large memory consumption. In order to solve this problem, the sprites can
    be packaged into multiple smaller atlases according to their purpose. For example,
    the sprites used in the login panel can be packaged as a login panel atlas, while
    the sprites used in the game character panel are packaged as a character panel
    atlas.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要意识到，尽管精灵图集可以有效地减少绘制调用的数量，但不当的使用很容易导致内存浪费。当一个精灵在图集中激活时，Unity将加载属于该精灵的图集中的所有精灵。如果图集中有大量的精灵，即使场景中只引用了一个精灵，整个图集也将被加载，这会导致大量内存消耗。为了解决这个问题，可以根据其用途将精灵打包到多个较小的图集中。例如，用于登录面板的精灵可以打包为登录面板图集，而用于游戏角色面板的精灵可以打包为角色面板图集。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by introducing some of the most commonly used UI
    component classes of the uGUI solution, such as the **Canvas**, **Rect Transform**,
    and **Image** components. We then explained the Event System in Unity, the legacy
    Input Module, and the new more powerful Input System package provided by Unity.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了uGUI解决方案中最常用的UI组件类，例如**Canvas**、**Rect Transform**和**Image**组件。然后，我们解释了Unity中的事件系统、遗留的输入模块以及Unity提供的更强大的新输入系统包。
- en: We also discussed how to decouple components from each other when developing
    the UI in Unity by using the MVVM architectural pattern.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了在Unity中开发UI时，如何通过使用MVVM架构模式将组件相互解耦。
- en: Finally, we explored some best practices for implementing the game UI in Unity
    to optimize the performance problems caused by the UI.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了在Unity中实现游戏UI的一些最佳实践，以优化由UI引起的性能问题。
- en: In the next chapter, we will learn about the animation system in Unity and,
    at the same time, we will also introduce how to optimize animation performance
    in Unity.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Unity中的动画系统，同时，我们也会介绍如何在Unity中优化动画性能。
