- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Service-Oriented Architectures with .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **Service-Oriented Architecture** (**SOA**) refers to a modular architecture
    where interaction between system components is achieved through communication.
    This approach has evolved for years and is now the basis of all communication
    between systems over the Internet. SOA allows applications from different organizations
    to exchange data and transactions automatically. Besides that, it allows organizations
    to offer services on the Internet. For instance, in a banking application, SOA
    can allow separate services for account management, transaction processing, and
    customer support to communicate seamlessly. More than that, it can enable suppliers
    to access customer support directly.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, as we discussed in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*, communication-based interaction solves the binary
    compatibility and version mismatch problems that inevitably appear in complex
    systems made up of modules that share the same address space. Moreover, with SOA
    and its pattern of communication, you do not need to deploy different copies of
    the same component in the various systems/subsystems that use it – each component
    only needs to be deployed in one place, even if they are written in different
    programming languages, simplifying the overall cycle of **Continuous Integration/Continuous
    Delivery** (**CI/CD**).
  prefs: []
  type: TYPE_NORMAL
- en: If a newer version conforms to the communication interface that is declared
    to the clients, no incompatibilities can occur. For instance, if you have a backend
    service that calculates tax based on a specific rule and the entry of selling
    data, if the specific rule changes, but the selling data doesn’t, you will be
    able to update the service without changing the application in the clients. On
    the other hand, with DLLs/packages, when the same interface is maintained, incompatibilities
    may arise because of possible version mismatches in terms of the dependencies
    of other DLLs/packages that the library module might have in common with its clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Organizing clusters/networks of cooperating services was discussed in *Chapter
    11*, *Applying a Microservice Architecture to Your Enterprise Application*. In
    this chapter, we will focus on the two main communication interfaces used all
    over the world. More specifically, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of the SOA approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOAP and REST web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does .NET 8 deal with SOA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to publicly expose data from an
    application through an ASP.NET Core service.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the Visual Studio 2022 free Community edition or better
    with all the database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: All the concepts in this chapter will be clarified with practical examples based
    on the WWTravelClub book use case, located in *Chapter 21, Case Study*. You will
    find the code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of the SOA approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like classes in an object-oriented architecture, services are implementations
    of interfaces that, in turn, come from a system’s functional specifications. Therefore,
    the first step in *service* design is the definition of its *abstract interface*.
    During this initial stage, you might have two approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Define all the service operations as interface methods that operate on the types
    of your favorite language (C#, Java, C++, JavaScript, and so on) and decide which
    operations to implement with synchronous communication and which ones to implement
    with asynchronous communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the contract first in an interoperable format. In this approach, you
    can use definition files using patterns like OpenAPI, Protobuf, WSDL, and AsyncAPI
    without touching the programming language with which the services will be developed,
    using some tools to help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interfaces that are defined in this initial stage will not necessarily be
    used in the actual service implementation and are just useful design tools. Once
    we have decided on the architecture of the services, these interfaces are usually
    redefined so that we can adapt them to the peculiarity of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that SOA messages must keep the same kind of semantics
    as method calls/answers. Besides, SOA follows stateless development; that is,
    the reaction to a message must not depend on any previously received messages
    because the server does not save information from prior requests, which means
    the messages must be independent of each other.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if the purpose of messages is to create a new database entry,
    this semantic must not change with the context of other messages, and the way
    the database entry is created must depend on the content of the current message
    and not on other previously received messages. Consequently, a client cannot create
    sessions and cannot log in to a service, perform some operations, and then log
    out. An authentication token must be repeated in each message.
  prefs: []
  type: TYPE_NORMAL
- en: The reasons for this constraint are modularity, testability, and maintainability.
    In fact, a session-based service would be very hard to test and modify due to
    the interactions that are *hidden* in the session data.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have decided on the interface that is going to be implemented by a
    service, you must decide which communication stack/SOA to adopt. The communication
    stack must be part of some official or *de facto* standard to ensure the interoperability
    of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interoperability is the main constraint prescribed by SOA: services must offer
    a communication interface that does not depend on a specific library used, implementation
    language, or deployment platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Considering you have decided on the communication stack/architecture, you need
    to adapt your previous interfaces to the peculiarities of the architecture (see
    the *REST web services* subsection of this chapter for more details). Then, you
    must translate these interfaces into the chosen communication language. This means
    that you must map all the programming language types into types that are available
    in the chosen communication language.
  prefs: []
  type: TYPE_NORMAL
- en: The actual translation of data is usually performed automatically by the SOA
    libraries that are used by your development environment. However, some configuration
    might be needed, and, in any case, we must be aware of how our programming language
    types are transformed before each communication. For instance, some numeric types
    might be transformed into types with less precision or with different ranges of
    values. In .NET 8, for instance, you should be aware that floating-point numeric
    types vary between **float** (~6-9 digits), **double** (~15-17 digits), and **decimal**
    (~28-29 digits). You may consider the alternative of using string variables to
    reduce the risk of imprecision while transferring numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: The interoperability constraint can be interpreted in a lighter form in the
    case of microservices that are not accessible outside of their clusters since
    they need to communicate with other microservices that belong to the same cluster.
    In this case, this means that the communication stack might be platform-specific
    so that it can increase performance, but it must be standard to avoid compatibility
    problems with other microservices that might be added to the cluster as the application
    evolves.
  prefs: []
  type: TYPE_NORMAL
- en: We have spoken of the *communication stack* and not of the *communication protocol*
    because SOA communication standards usually define the format of the message’s
    content and provide different possibilities for the specific protocol that is
    used to embed those messages. For instance, REST services usually run over HTTP/HTTPS
    based on JSON messages, while the SOAP protocol just defines an XML-based format
    for the various kinds of messages, but SOAP messages can be conveyed by various
    protocols. Usually, the most common protocol that is used for SOAP is also HTTP,
    but you may decide to jump to the HTTP level and send SOAP messages directly over
    TCP/IP for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice of communication stack you should adopt depends on several factors,
    as described below. When it comes to accessing data, maybe the communication stack
    will be mandatory and decided by the provider, but you should also be concerned
    about these factors when providing a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compatibility constraints**: If your service must be publicly available on
    the Internet to business clients, then you must conform to the most common choices,
    which means using SOAP over either HTTP or REST services. The most common choices
    are different if your clients are not business clients but **Internet of Things**
    (**IoT**) clients. Also, within IoT, the protocols that are used in different
    application areas can be different. For instance, marine vehicle status data is
    typically exchanged with *Signal K*. Although this protocol is too specific and
    is presented here just as an example, as a software architect, you must understand
    that you may face this kind of standard in a specific area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development/deployment platform**: Not all communication stacks are available
    on all development frameworks and on all deployment platforms, but luckily, all
    the most common communication stacks that are used in public business services,
    such as SOAP- and JSON-based REST communication, are available on all the main
    development/deployment platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: If your system is not exposed to the outside world and is
    a private part of your microservice cluster, performance considerations have a
    higher priority. In this scenario, gRPC, which we will discuss soon in this chapter,
    can be noted as a good option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability of tools and knowledge in your team**: Knowing about the availability
    of tools in your team/organization is important when it comes to choosing between
    acceptable communication stacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, this kind of constraint always has less priority than compatibility
    constraints since it makes no sense to conceive a system that is easy to implement
    for your team but that almost nobody can use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Flexibility versus available features**: Some communication solutions, while
    less complete, offer a higher degree of flexibility, while other solutions, though
    more complete, offer less flexibility. The need for flexibility started a movement
    from SOAP-based services to more flexible REST services in the last few years.
    This point will be discussed in more detail when we describe SOAP and REST services
    in the remainder of this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service description**: When services must be exposed on the Internet, client
    applications need a publicly available description of the service specifications
    to design their communication clients. Some communication stacks include languages
    and conventions to describe service specifications. Formal service specifications
    that are exposed this way can be processed so that they automatically create communication
    clients. SOAP goes further and allows service discoverability by means of a public
    XML-based directory containing information about the tasks each web service can
    carry out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have chosen the communication stack you wish to use, you must use
    the tools that are available in your development environment to implement the
    service in a way that conforms to the chosen communication stack. Sometimes, communication
    stack compliance is automatically ensured by the development tools, but sometimes,
    it may require some development effort. For instance, in the .NET world, the compliance
    of SOAP services is automatically ensured by development tools if you use WCF,
    while the compliance of REST services falls under the developer’s responsibility,
    although you have, since .NET 5, automatic support for the OpenAPI standard using
    Swagger. Some of the fundamental features of SOA solutions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Allows the client to authenticate to access service operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Handles the client’s permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: This is how communication is kept safe, that is, how to prevent
    unauthorized systems from reading and/or modifying the content of the communication.
    Typically, encryption prevents both unauthorized modifications and reading, while
    electronic signature algorithms prevent just modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exceptions**: Returns exceptions to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message reliability**: Ensures that messages reliably reach their destination
    in case of possible infrastructure faults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Though sometimes desirable, the following features are not always necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed transactions**: The capability to handle distributed transactions,
    thus undoing all the changes you have made whenever the distributed transactions
    fail or are aborted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for the Publisher/Subscriber pattern**: If and how events and notifications
    are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Addressing**: If and how references to other services and/or methods are
    supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing**: If and how messages can be routed through a network of services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder of this section will describe SOAP services a bit. However, the
    focus will be REST services since today they are the *de facto* standard for business
    services that are exposed outside of their clusters/servers. For performance reasons,
    microservices use other protocols, discussed in *Chapter 11*, *Applying a Microservice
    Architecture to Your Enterprise Application*, *Chapter 14*, *Implementing Microservices
    with .NET*. For inter-cluster communication, **Advanced Message Queuing Protocol**
    (**AMQP**) is used, and links are given in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Simple Object Access Protocol** (**SOAP**) allows both one-way messages
    and request/reply messages. Communication can be both synchronous and asynchronous,
    as explained in *Chapter 1, Understanding the Importance of Software Architecture*,
    and *Chapter 2, Non-Functional Requirements*, but if the underlying protocol is
    synchronous, such as in the case of HTTP, the sender receives an acknowledgment
    saying that the message was received (but not necessarily processed). When asynchronous
    communication is used, the sender must listen for incoming communications. Often,
    asynchronous communication is implemented with the Publisher/Subscriber pattern,
    which we described in *Chapter 6*, *Design Patterns and .NET 8 Implementation*.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are represented as XML documents called **envelopes**. Each envelope
    contains `header`, `body`, and `fault` elements. The `body` is where the actual
    content of the message is placed. The `fault` element contains possible errors,
    so it is the way exceptions are exchanged when communication occurs. Finally,
    the `header` contains any auxiliary information that enriches the protocol but
    does not contain domain data. For example, the `header` may contain an authentication
    token and/or a signature if the message is signed.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the default namespace for the SOAP envelope at [https://www.w3.org/2003/05/soap-envelope/](https://www.w3.org/2003/05/soap-envelope/).
  prefs: []
  type: TYPE_NORMAL
- en: The underlying protocol that is used to send the XML envelopes is usually HTTP,
    since this is the protocol of the Internet, but the SOAP specification allows
    any protocol, so we can use TCP/IP or SMTP directly. As a matter of fact, the
    more diffused underlying protocol is HTTP, so if you do not have a good reason
    to choose another protocol, you should use HTTP to maximize the interoperability
    of the service.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SOAP specifications contain the basics of message exchange, while other auxiliary
    features are described in separate specification documents called `WS-` `*` and
    are usually handled by adding extra information in the SOAP header. `WS-*` specifications
    handle all the fundamental and desirable features of SOA we listed previously.
    We have some of them below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **WS-*** | **Main objective** |'
  prefs: []
  type: TYPE_TB
- en: '| `WS-Security` | Takes care of security, including authentication, authorization,
    and encryption/signatures |'
  prefs: []
  type: TYPE_TB
- en: '| `WS-Eventing` / `WS-Notification` | Two alternative ways of implementing
    the Publisher/Subscriber pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `WS-ReliableMessaging` | Concerned with the reliable delivery of messages
    in case of possible faults |'
  prefs: []
  type: TYPE_TB
- en: '| `WS-Transaction` | Concerned with distributed transactions |'
  prefs: []
  type: TYPE_TB
- en: 'Table 15.1: Summary of Key WS-* Specifications and Their Main Objectives in
    SOAP-Based SOA'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `WS- *` specifications are in no way exhaustive but are the more
    relevant and supported features. In fact, actual implementations in various environments
    (such as Java and .NET) furnish the more relevant `WS- *` services, but no implementation
    supports all the `WS- *` specifications.
  prefs: []
  type: TYPE_NORMAL
- en: All the XML documents/document parts involved in the SOAP protocol are formally
    defined in XSD documents, like in the example below, which are special XML documents
    whose content provides a description of XML structures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Also, all your custom data structures (classes and interfaces in an object-oriented
    language) must be translated into XSD if they are going to be part of a SOAP envelope.
  prefs: []
  type: TYPE_NORMAL
- en: Each XSD specification has an associated `namespace` that identifies the specification
    and a physical location where it can be found. Both the namespace and the physical
    location are URIs. The location URI does not need to be publicly accessible if
    the web service is accessible just from within an intranet.
  prefs: []
  type: TYPE_NORMAL
- en: The whole definition of a service is an XSD specification that may contain references
    to other namespaces, that is, to other XSD documents. Simply put, all the messages
    via SOAP communication must be defined in an XSD specification. Then, a server
    and a client can communicate if they refer to the same XSD specifications. This
    means, for instance, that you need to create a new XSD specification each time
    you add another field to a message. After that, you need to update all the XSD
    files that reference the old message definition to the new message definition
    by creating a new version of them. In turn, these modifications require the creation
    of other versions for other XSD files, and so on. Therefore, simple modifications
    that maintain compatibility with the previous behavior (clients could simply ignore
    the field that was added) may cause an exponential chain of version changes.
  prefs: []
  type: TYPE_NORMAL
- en: Difficulties associated with the standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last few years, the difficulty in handling modifications, along with
    the complexity of handling the configuration of all the `WS- *` specifications
    and performance problems, caused a gradual move toward the simpler REST services
    that we will describe in the upcoming sections. This move started with services
    that were called from JavaScript due to the difficulty of implementing complete
    SOAP clients that were able to run efficiently in a web browser. Moreover, the
    complex SOAP machinery was oversized for the simple needs of the typical clients
    running in a browser and may have caused a complete waste of development time.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, services aimed at non-JavaScript clients started a massive
    move toward REST services, and nowadays, the preferred choice is REST services,
    with SOAP being used either for compatibility with legacy systems or when features
    that are not supported by REST services are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we can consider REST services that transfer data with JSON, the most-used
    approach all over the world. Security aspects, design patterns for enabling transactional
    support, performance, and even documentation have improved all over the years,
    so this is certainly the best alternative for applying SOAs nowadays. Let’s have
    a look at REST web services in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: REST web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST services were initially conceived to avoid the complex machinery of SOAP
    in simple cases, such as calls to a service from the JavaScript code of a web
    page. Then, they gradually became the preferred choice for complex systems. REST
    services use HTTP to exchange data in JSON or, less commonly, in XML format. Simply
    put, they replace the SOAP body with the HTTP body, the SOAP header with the HTTP
    header, and the HTTP response code replaces the fault element and furnishes further
    auxiliary information on the operation that was performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reason for the success of REST services is that HTTP already offers
    most of the SOAP features natively, which means we can avoid building a SOAP level
    on top of HTTP. Moreover, the whole HTTP machinery is simpler than SOAP: simpler
    to program, simpler to configure, and simpler to implement efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, REST services impose fewer constraints on the clients. Type compatibility
    between servers and clients conforms to the more flexible JavaScript type compatibility
    model because JSON is a subset of JavaScript. Moreover, when XML is used in place
    of JSON, it maintains the same JavaScript type compatibility rules. No XML namespaces
    need to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: When using JSON and XML, if the server adds some more fields to the response
    while keeping the same semantics of all the other fields compatible with the previous
    client, they can simply ignore the new fields. Accordingly, changes that are made
    to a REST service definition only need to be propagated to previous clients in
    the case of breaking changes that cause actual incompatible behavior in the server.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it is likely that changes will be self-limited and won’t result in
    an exponential chain of changes because type compatibility does not require the
    reference to a specific type to be defined in a unique shared place and simply
    requires that the shape of types is compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Service type compatibility rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s clarify the REST service type compatibility rules with an example. Imagine
    that several services use a `Person` object that contains `Name`, `Surname`, and
    `Address` string fields. This object is served by **S1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Type compatibility is ensured if the service and client refer to different
    copies of the preceding definition. It is also acceptable for the client to use
    a definition with fewer fields since it can simply ignore all the other fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can only use a definition with fewer fields within your “own” code. Attempting
    to send information back to the server without the expected fields may cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine the scenario where you have an **S2** service that takes `Person`
    objects from **S1** and adds them to the responses it returns on some of its methods.
    Suppose the **S1** service that handles the `Person` object replaces the `Address`
    string with a complex object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After the breaking change, the **S2** service will have to adapt its communication
    client that calls the **S1** service to the new format. Then, it can convert the
    new `Person` format into the older one before using `Person` objects in its responses.
    This way, the **S2** service avoids propagating the breaking change of **S1**.
  prefs: []
  type: TYPE_NORMAL
- en: In general, basing type compatibility on the object shape (tree of nested properties)
    instead of a reference to the same formal type definition increases flexibility
    and modifiability. The price we pay for this increased flexibility is that type
    compatibility cannot be computed automatically by comparing the formal definition
    of server and client interfaces. In fact, in the absence of a univocal specification,
    each time a new version of the service is released, the developer must verify
    that the semantics of all the fields that the client and server have in common
    remain unchanged from the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind REST services is to give up the severity checks and complex
    protocols for greater flexibility and simplicity, while SOAP does exactly the
    opposite.
  prefs: []
  type: TYPE_NORMAL
- en: REST and native HTTP features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The REST services manifesto states that REST uses native HTTP features to implement
    all the required service features. So, for instance, authentication will be performed
    directly with the HTTP `Authorization` field, encryption will be achieved with
    HTTPS, exceptions will be handled with an HTTP error status code, and routing
    and reliable messaging will be handled by the machinery the HTTP protocol relies
    on. Addressing is achieved by using URLs to refer to services, their methods,
    and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: There is no native support for asynchronous communication since HTTP is a synchronous
    protocol. There is also no native support for the Publisher/Subscriber pattern,
    but two services can interact with the Publisher/Subscriber pattern by each exposing
    an endpoint to the other. More specifically, the first service exposes a subscription
    endpoint, while the second one exposes an endpoint where it receives its notifications,
    which are authorized through a common secret that is exchanged during the subscription.
    This pattern is quite common. GitHub also allows us to send repository events
    to our REST services.
  prefs: []
  type: TYPE_NORMAL
- en: REST services offer no easy options when it comes to implementing distributed
    transactions, since HTTP is stateless. However, approaches like the SAGA pattern,
    described in *Chapter 14, Implementing Microservices with .NET*, and event sourcing,
    described in *Chapter 7, Understanding the Different Domains in Software Solutions*,
    helped a lot in the last years to solve this difficulty. Besides, luckily, most
    application areas do not need the strong form of consistency that is ensured by
    distributed transactions. For them, lighter forms of consistency, such as *eventual
    consistency*, are enough and are preferred for performance reasons. Please refer
    to *Chapter 12*, *Choosing Your Data Storage in the Cloud*, for a discussion on
    the various types of consistencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The REST manifesto not only prescribes the usage of the predefined solutions
    that are already available in HTTP but also the usage of a web-like semantic.
    In general, service operations can be conceived as CRUD operations, but not limited
    to them on resources that are identified by URLs (the same resource may be identified
    by several URLs). In fact, REST is an acronym for **Representational State Transfer**,
    meaning that each URL is the representation of some sort of entity. As a best
    practice, each kind of service request needs to adopt the appropriate HTTP verb
    and return the status code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` (read operation): The URL represents the resource that is returned by
    the read operation. Thus, `GET` operations mimic pointer dereferencing. In the
    case of a successful operation, a 200 (OK) status code is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` (creation operation): The JSON/XML object that is contained in the request
    body is added as a new resource to the object represented by the operation URL.
    If the new resource is successfully created immediately, a 201 (created) status
    code is returned, along with a response object that depends on the operation and
    an indication as to where the created resource can be retrieved from. The response
    object should contain the most specific URL that identifies the created resource.
    If creation is deferred to a later time, a 202 (accepted) status code is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` (edit operation): The JSON/XML object contained in the request body replaces
    the object referenced by the request URL. In the case of a successful operation,
    a 200 (OK) status code is returned. This operation is idempotent, meaning that
    repeating the same request twice causes the same modification. 204 (No Content)
    is also a possible return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: The JSON/XML object contained in the request body contains instructions
    on how to modify the object referenced by the request URL. This operation is not
    idempotent since the modification may be an increment of a numeric field. In the
    case of a successful operation, a 200 (OK) status code is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: The resource referenced by the request URL is removed. In the case
    of a successful operation, a 200 (OK) status code is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the resource has been moved from the request URL to another URL, a redirect
    code is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '`301` (moved permanently), plus the new URL where we can find the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`307` (moved temporarily), plus the new URL where we can find the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the operation fails, a status code that depends on the kind of failure is
    returned. Some examples of failure codes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`400` (bad request): The request that was sent to the server is ill formed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404` (not found): When the request URL does not refer to any known object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`405` (method not allowed): When the request verb is not supported by the resource
    referenced by the URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401` (unauthorized): The operation requires authentication, but the client
    has not furnished any valid authorization header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403` (forbidden): The client is correctly authenticated but has no right to
    perform the operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`409` (conflict): The operation failed due to some conflict with the current
    state of the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`412` (precondition failed): The operation failed due to some precondition
    desired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`422` (unprocessable content): The request was well formatted, but there are
    semantic errors in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list of status codes is not exhaustive. A reference to an exhaustive
    list will be provided in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: It is fundamental to point out that `POST`/`PUT`/`PATCH`/`DELETE` operations
    may have – and usually have – side effects on other resources. Otherwise, it would
    be impossible to code operations that act simultaneously on several resources.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the HTTP verb must conform with the operation that is performed
    on the resource and referenced by the request URL, but the operation might affect
    other resources. The same operation might be performed with a different HTTP verb
    on one of the other involved resources. It is the developer’s responsibility to
    choose which way to perform the same operation to implement it in the service
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the side effects of HTTP verbs, REST services can encode all these
    operations as CRUD operations on resources represented by URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Often, moving an existing service to REST requires us to split the various inputs
    between the request URL and the request body. More specifically, we extract the
    input fields that univocally define one of the objects involved in the method’s
    execution and use them to create a URL that univocally identifies that object.
    Then, we decide on which HTTP verb to use based on the operation that is performed
    on the selected object. Finally, we place the remainder of the input in the request
    body.
  prefs: []
  type: TYPE_NORMAL
- en: If our services were designed with an object-oriented architecture focused on
    the business domain objects (such as DDD, as described in *Chapter 7, Understanding
    the Different Domains in Software Solutions*), the REST translation of all the
    service methods should be quite immediate since services should already be organized
    around domain resources. Otherwise, moving to REST might require some service
    interface redefinitions.
  prefs: []
  type: TYPE_NORMAL
- en: The adoption of full REST semantics has the advantage that services can be extended
    with or without small modifications being made to the preexisting operation definitions.
    In fact, extensions should mainly manifest as additional properties of some objects
    and as additional resource URLs with some associated operations. Therefore, preexisting
    clients can simply ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: Example of methods in the REST language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let us learn how methods can be expressed in the REST language with a simple
    example of an intra-bank money transfer. We will present here two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first one, a bank account can be represented by a URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://mybank.com/accounts/{bank account number}`'
  prefs: []
  type: TYPE_NORMAL
- en: If we imagine a bank transfer we may represent it as a `PATCH` request, whose
    body contains an object with properties representing the amount of money, time
    of transfer, description, and the account receiving the money.
  prefs: []
  type: TYPE_NORMAL
- en: The operation modifies the account mentioned in the URL but also the receiving
    account as a *side effect*. If the account doesn’t have enough money, a `409`
    (conflict) status code is returned, along with an object with all the error details
    (an error description, the available funds, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since all the bank operations are recorded in the account statement,
    the creation and addition of a new transfer object for a *bank account operations*
    collection associated with the bank account is a better way to represent the transfer.
    In this second approach, the URL might be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://mybank.com/accounts/{bank account number}/transactions`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the HTTP verb is `POST` since we are creating a new object. The body content
    is the same, and a `422` status code is returned if there is a lack of funds.
  prefs: []
  type: TYPE_NORMAL
- en: Both representations of the transfer cause the same changes in the database.
    Moreover, once the inputs are extracted from the different URLs and from the possibly
    different request bodies, the subsequent processing is the same. In both cases,
    we have the same inputs and the same processing – it is just the exterior appearance
    of the two requests that are different.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the introduction of the virtual *transactions* collection allows us
    to extend the service with several more *transaction* collection-specific methods.
    It is worth pointing out that the *transaction* collection does not need to relate
    to a database table or any physical object: it lives in the world of URLs and
    creates a convenient way for us to model the transfer.'
  prefs: []
  type: TYPE_NORMAL
- en: The increased usage of REST services leads to a description of REST service
    interfaces to be created like the ones developed for SOAP. This standard is called
    **OpenAPI**. We will talk about this in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenAPI is a specification that is used worldwide for describing the REST APIs.
    The OpenAPI Initiative was founded in November 2015, as an open-source project
    under the Linux Foundation, with the help of companies like SmartBear, Google,
    IBM, and Microsoft. The specification is currently versioned as 3.1\. The whole
    service is described by a JSON or YAML endpoint, that is, an endpoint that describes
    the service with a JSON object. This JSON object has a general section that applies
    to the whole service and contains the general features of the service, such as
    its version and description, as well as shared definitions.
  prefs: []
  type: TYPE_NORMAL
- en: You can find OpenAPI Specification examples at [https://github.com/OAI/OpenAPI-Specification/](https://github.com/OAI/OpenAPI-Specification/).
  prefs: []
  type: TYPE_NORMAL
- en: Then, each service endpoint has a specific section that describes the endpoint
    URL or URL format (in case some inputs are included in the URL), all its inputs,
    all the possible output types and status codes, and all the authorization protocols.
    Each endpoint-specific section can reference the definitions contained in the
    general section.
  prefs: []
  type: TYPE_NORMAL
- en: A complete description of the OpenAPI syntax is out of the scope of this book,
    but you will find visual editors on the Internet that can help you clarify the
    specification mentioned before. A great example is provided by SmartBear, one
    of the companies that founded the initiative, and it is called Swagger Editor.
    In the beta version of the online tool, you can load an example using OpenAPI
    version 3.1.0\. This helps companies to create API contracts even before deciding
    the programming language of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Various development frameworks automatically generate OpenAPI documentation
    by processing the REST API code, and further information is provided by the developer,
    so your team does not need to have in-depth knowledge of OpenAPI syntax. An example
    of this is the `Swashbuckle.AspNetCore` NuGet package that we will present in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The *How does .NET 8 deal with SOA?* section explains how we can automatically
    generate OpenAPI documentation in ASP.NET Core REST API projects, while the use
    case presented in *Chapter 21, Case Study,* will provide a practical example of
    its usage.
  prefs: []
  type: TYPE_NORMAL
- en: We will end this subsection by talking about how to handle authentication and
    authorization in REST services.
  prefs: []
  type: TYPE_NORMAL
- en: REST service authorization and authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since REST services are stateless, when authentication is required, the client
    must send an authentication token in every single request. That token is usually
    placed in the HTTP authorization header, but this depends on the type of authentication
    protocol you are using. The simplest way to authenticate is through the explicit
    transmission of a shared secret. This can be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The shared secret is called an API key. Since, at the time of writing, there
    is no standard on how to send it, API keys can also be sent in other headers,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that API-key-based authentication needs HTTPS to stop
    shared secrets from being stolen. API keys are very simple to use, but they do
    not convey information about user authorizations, so they can be adopted when
    the operations allowed by the client are quite standard, and there are no complex
    authorization patterns. Moreover, when exchanged in requests, API keys are susceptible
    to being attacked on the server or client side. A common pattern to mitigate this
    is to create a “service account” user and restrict their authorizations to just
    those needed and use the API keys from that specific account when interacting
    with the API.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a more sophisticated authentication service, you may consider using
    the OAuth 2.0 protocol. For instance, when you implement “Sign in with [Some specific
    social media],” you are probably using this protocol. Of course, to use it, you
    have to define an authentication service provider.
  prefs: []
  type: TYPE_NORMAL
- en: Safer techniques use shared secrets that are valid for a long period of time,
    just by the user logging in. Then, the login returns a short-life token that is
    used as a shared secret in all the subsequent requests. When the short-lived secret
    is going to expire, it can be renewed with a call to a renew endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The whole logic is completely decoupled from the short-life token-based authorization
    logic. The login is usually based on login endpoints that receive long-term credentials
    and return short-life tokens. Login credentials are either usual username-password
    pairs that are passed as input to the login method or other kinds of authorization
    tokens that are converted into short-life tokens that are served by the login
    endpoint. Login can also be achieved with various authentication protocols based
    on X.509 certificates.
  prefs: []
  type: TYPE_NORMAL
- en: The most widespread short-life token type is the so-called bearer token. Each
    bearer token encodes information about how long it lasts and a list of assertions,
    called claims, that can be used for authorization purposes. Bearer tokens are
    returned by either login operations or renewal operations. Their characteristic
    feature is that they are not tied to the client that receives them or to any other
    specific client, but they identify the client, which can simply use them in its
    invocations.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how a client gets a bearer token, this is all a client needs to be
    granted, including all the rights implied by its claims. It is enough to transfer
    a bearer token to another client to empower that client with all the rights implied
    by all the bearer token claims since no proof of identity is required by bearer-token-based
    authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, once a client gets a bearer token, it can delegate some operations
    to third parties by transferring its bearer token to them. Typically, when a bearer
    token must be used for delegation, during the login phase, the client specifies
    the claims to include to restrict what operations can be authorized by the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to API key authentication, bearer-token-based authentication is disciplined
    by standards. They must use the following `Authorization` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Bearer tokens can be implemented in several ways. REST services typically use
    JWTs that are strings with a Base64 URL encoding of JSON objects. More specifically,
    JWT creation starts with a JSON header, as well as a JSON payload. The JSON header
    specifies the kind of token and how it is signed, while the payload consists of
    a JSON object that contains all the claims as property/value pairs. The following
    is an example header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the header and payload are Base64 URL-encoded, and the corresponding
    string is concatenated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding string is then signed with the algorithm specified in the header,
    which, in our example, is `RSA +SHA256`, and the signature string is concatenated
    with the original string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the final bearer token string. A symmetric signature can
    be used instead of RSA, but, in this case, both the JWT issuer and all the services
    using it for authorization must share a common secret, while, with RSA, the private
    key of the JWT issuer does not need to be shared with anyone, since the signature
    can be verified with just the issuer public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some payload properties are standard, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iss`: Issuer of the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aud`: The audience, that is, the services and/or operations that can use the
    token for authorization. If a service does not see its identifier within this
    list, it should reject the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub`: A string that identifies the *principal* (that is, the user) to which
    the JWT was issued.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iat`, `exp`, and `nbf`: These are for the time the JWT was issued, its expiration
    time, and, if set, the time after which the token is valid, respectively. All
    the times are expressed as seconds from midnight UTC on January 1, 1970\. Here,
    all the days are considered as having exactly 86,400 seconds in them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other claims may be defined as public if we represent them with a unique URI;
    otherwise, they are considered private to the issuer and to the services known
    to the issuer.
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering a natural scenario where the number of APIs will increase in your
    application, and, more than that, the business logic will obviously evolve, as
    a software architect, you must decide how you are going to version the APIs, guaranteeing
    the compatibility between your services and the clients that consume these services.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to mention that there are several versioning options for doing
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URI**: It consists of defining the version of the API in its URI, for example,
    `https://wwtravelclub.com/v1/trips`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameter**: You can define a parameter in the request that defines the version,
    for instance, `https://wwtravelclub.com/trips?version=2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Media type**: In this case, the desired version of the API will be presented
    in the HTTP `Accept` header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom request header**: Like the media type versioning technique, but in
    this case the HTTP header will be customized by you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two alternatives are the most commonly used, but the important point
    here is that you must consider crucial the implementation of a versioning technique.
  prefs: []
  type: TYPE_NORMAL
- en: How does .NET 8 deal with SOA?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WCF technology has not been ported to .NET 5+ and there are no plans to perform
    a complete port of it. Part of the source code was donated, and an open-source
    project started out of it. You can find information about this project at [https://github.com/CoreWCF/CoreWCF](https://github.com/CoreWCF/CoreWCF).
    Instead, Microsoft is investing in gRPC, Google’s open-source technology. Besides,
    .NET 8 has excellent support for REST services through ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: There is a tool developed by Microsoft to help you with the migration of WCF
    applications to the latest .NET. You can find it at [https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/](https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reasons behind the decision to abandon WCF are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As we have already discussed, SOAP technology has been overtaken by REST technology
    in most application areas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WCF technology is strictly tied to Windows, so it would be very expensive to
    reimplement all its features from scratch in .NET 5+. Since support for full .NET
    will continue, users who need WCF can still rely on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general strategy, with .NET 5+, Microsoft prefers investing in open-source
    technologies that can be shared with other competitors. That is why, instead of
    investing in WCF, Microsoft provided a gRPC implementation starting from .NET
    Core 3.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next subsections will cover the support provided inside Visual Studio for
    each technology we have mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP client support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In WCF, service specifications are defined through .NET interfaces, and the
    actual service code is supplied in classes that implement those interfaces. Endpoints,
    underlying protocols (HTTP and TCP/IP), and any other features are defined in
    a configuration file. In turn, the configuration file can be edited with an easy-to-use
    configuration tool. Therefore, the developer is responsible for providing just
    the service behavior as a standard .NET class and for configuring all the service
    features in a declarative way. This way, the service configuration is completely
    decoupled from the actual service behavior, and each service can be reconfigured
    so that it can be adapted to a different environment without the need to modify
    its code.
  prefs: []
  type: TYPE_NORMAL
- en: While .NET 8 does not support SOAP technology for creating new services, it
    does support the usage of SOAP clients when there are many SOAP services as legacy.
    More specifically, it is quite easy to create a SOAP service proxy for an existing
    SOAP service in Visual Studio (please refer to *Chapter 6*, *Design Patterns and
    .NET 8 Implementation*, for a discussion of what a proxy is and of the Proxy pattern).
  prefs: []
  type: TYPE_NORMAL
- en: In the case of services, a proxy is a class that implements the service interface
    and whose methods perform their jobs by calling the analogous methods of the remote
    service.
  prefs: []
  type: TYPE_NORMAL
- en: To create a service proxy, right-click **Dependencies** in your project in **Solution
    Explorer**, and then select **Add connected service**. Then, in the form that
    appears, select **Microsoft WCF Service Reference Provider**. There, you can specify
    the URL of the service (where the WSDL service description is contained), the
    namespace where you wish to add the proxy class, and much more. At the end of
    the wizard, Visual Studio automatically adds all the necessary NuGet packages
    and scaffolds the proxy class. This is enough to create an instance of this class
    and to call its methods so that we can interact with the remote SOAP service.
  prefs: []
  type: TYPE_NORMAL
- en: There are also third parties, such as NuGet packages, that provide limited support
    for SOAP services, but currently, they aren’t very useful since such limited support
    does not include features that aren’t available in REST services.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The .NET SDK supports the gRPC project template, which scaffolds both a gRPC
    server and a gRPC client. gRPC implements a remote procedure call pattern that
    offers both synchronous and asynchronous calls, reducing the traffic of messages
    between the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Using gRPC is super easy since Visual Studio’s gRPC project template scaffolds
    everything so that the gRPC service and its clients are working. The developer
    just needs to define the application-specific C# service interface and a class
    that implements it.
  prefs: []
  type: TYPE_NORMAL
- en: For configuring it, services are defined through interfaces written in a Protobuf
    file, and their code is provided in C# classes that implement those interfaces,
    while clients interact with those services through proxies that implement the
    same service interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC is a good option for internal communications within a microservices cluster.
    Since there are gRPC libraries for all the main languages and development frameworks,
    it can be used in Kubernetes-based clusters. Besides, gRPC is more efficient than
    the REST services protocol due to its more compact representation of data and
    its being easier to use since everything to do with the protocol is taken care
    of by the development framework.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we have added a brand-new chapter dedicated to discussing this
    implementation, *Chapter 14*, *Implementing Microservices with .NET*, and you
    can check details about the technology at [https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0](https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0).
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the section is dedicated to .NET support for REST services
    from both the server and client sides.
  prefs: []
  type: TYPE_NORMAL
- en: A short introduction to ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core applications are .NET applications based on the *Host* concept
    we described in the *Using generic hosts* subsection of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using C# 12 and .NET 8, the template for creating ASP.NET Core apps has changed
    a bit. The main purpose is to simplify how we set it up. The `Program.cs` file
    of each ASP.NET application now creates a host, builds it, and runs it without
    needing the `Startup` class anymore, as we can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Environment` is taken from the `ASPNETCORE_ENVIRONMENT` environment variable.
    In turn, it is defined in the `Properties\launchSettings.json` file when the application
    runs in Visual Studio over **Solution Explorer**. In this file, you can define
    several environments that can be selected with the dropdown next to Visual Studio’s
    run button, **IIS Express**. By default, the **IIS Express** setting sets `ASPNETCORE_ENVIRONMENT`
    to `Development`. The following is a typical `launchSettings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The value to use for `ASPNETCORE_ENVIRONMENT` when the application is published
    can be added to the published XML file after it has been created by Visual Studio.
    This value is `<EnvironmentName>Staging</EnvironmentName>`. It can also be specified
    in your Visual Studio ASP.NET Core project file (`.csproj`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Each middleware in the pipeline is defined by an `app.Use<something>` method,
    which often accepts some options. Each of them processes the requests and then
    either forwards the modified request to the next one in the pipeline or returns
    an HTTP response. When an HTTP response is returned, it is processed by all the
    previous ones in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are inserted in the pipeline in the order they are defined by the `app.Use<something>`
    method calls. The preceding code adds an error page if `ASPNETCORE_ENVIRONMENT`
    is `Development`. A complete description of the ASP.NET Core pipeline will be
    given in the *Understanding the presentation layers of web applications* section
    of *Chapter 17*, *Presenting ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will explain how the MVC framework lets you implement
    REST services.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing REST services with ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Today, we can guarantee that the use of MVC and a web API is consolidated. In
    the MVC framework, HTTP requests are processed by classes called controllers.
    Each request is mapped to the call of a controller public method. The selected
    controller and controller methods depend on the shape of the request path, and
    they are defined by routing rules, which, for the REST API, are usually provided
    through attributes associated with both the `Controller` class and its methods.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 6 has introduced minimal APIs to simplify the mechanism of implementing
    APIs with C#. You can find a good explanation of it at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis).
  prefs: []
  type: TYPE_NORMAL
- en: '`Controller` methods that process HTTP requests are called action methods.
    When the controller and action methods are selected, the MVC framework creates
    a controller instance to serve the request. All the parameters of the controller
    constructors are resolved with dependency injection.'
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the *Using generic hosts* subsection of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*, for a description
    of how to use dependency injection with a .NET host and to the *Dependency injection
    pattern* subsection of *Chapter 6*, *Design Patterns and .NET 8 Implementation*,
    for a general discussion of dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a typical REST API controller and its controller method definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `[ApiController]` attribute declares that the controller is a REST API controller.
    `[Route("api/[controller]")]` declares that the controller must be selected on
    paths that start with `api/<controller name>`. The controller’s name is the name
    of the controller class without the `Controller` postfix. This is preferred over
    hardcoding a controller name to save time on refactoring. Thus, in this case,
    we have `api/values`.
  prefs: []
  type: TYPE_NORMAL
- en: '`[HttpGet("{id}")]` declares that the method must be invoked on GET requests
    of the `api/values/<id>` type, where `id` must be a number that’s passed as an
    argument to the method invocation. This can be done with `Get(int id)`. There
    is also an `Http<verb>` attribute for each HTTP verb: `HttpPost` and `HttpPatch`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may also have another method defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method is invoked on `GET` requests of the `api/values` type, that is,
    on `GET` requests without `id` after the controller’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Several action methods can have the same name, but only one should be compatible
    with each request path; otherwise, an exception is thrown. In other words, routing
    rules and `Http<verb>` attributes must univocally define which controller and
    which of its action methods to select for each request.
  prefs: []
  type: TYPE_NORMAL
- en: By default, parameters are passed to the action methods of API controllers according
    to the following rules.
  prefs: []
  type: TYPE_NORMAL
- en: Simple types (`integers`, `floats`, and `DateTimes`) are taken from the request
    path if routing rules specify them as parameters, as in the case of the previous
    example’s `[HttpGet("{id}")]` attribute. If they are not found in the routing
    rules, the ASP.NET Core framework looks for query string parameters with the same
    name. Thus, for instance, if we replace `[HttpGet("{id}")]` with `[HttpGet]`,
    the ASP.NET Core framework will look for something like `api/values?id=<id type>`
    or `api/values/{id}`.
  prefs: []
  type: TYPE_NORMAL
- en: Complex types are extracted from the request body by formatters. The right formatter
    is chosen according to the value of the request’s `Content-Type` header. If no
    `Content-Type` header is specified, the JSON formatter is taken. The JSON formatter
    tries to parse the request body as a JSON object and then tries to transform this
    JSON object into an instance of the .NET complex type. If either the JSON extraction
    or the subsequent conversion fails, an exception is thrown. As described in *Chapter
    2, Non-Functional Requirements*, be careful with exceptions since their computational
    costs are much higher than a normal code flow.
  prefs: []
  type: TYPE_NORMAL
- en: If an exception is inevitable, consider using the recommendations for logging
    described in *Chapter 4, Best Practices in Coding C# 12*. By default, just the
    JSON input formatter is supported, but you can also add an XML formatter that
    can be used when `Content-Type` specifies XML content.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize the source that is used to fill an action method parameter
    by prefixing the parameter with an adequate attribute. The following code shows
    some examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type of an action method can be an `IActionResult` interface, a
    type that implements that interface, or a DTO directly. In turn, `IActionResult`
    has just the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method is called by the MVC framework at the right time to create the actual
    response and response headers. The `ActionContext` object, when passed to the
    method, contains the whole context of the HTTP request, which includes a request
    object with all the necessary information about the original HTTP requests (headers,
    body, and cookies), as well as a response object that collects all the pieces
    of the response that is being built.
  prefs: []
  type: TYPE_NORMAL
- en: 'You do not have to create an implementation of `IActionResult` manually since
    `ControllerBase` already has methods to create `IActionResult` implementations
    so that all the necessary HTTP responses are generated. Some of these methods
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OK`: This returns a 200 status code, as well as an optional result object.
    It is used as either `return OK()` or `return OK(myResult)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BadRequest`: This returns a 400 status code, as well as an optional response
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Created(string uri, object o)`: This returns a 201 status code, as well as
    a result object and the URI of the created resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Accepted`: This returns a 202 status result, as well as an optional result
    object and resource URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unauthorized`: This returns a 401 status result, as well as an optional result
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Forbid`: This returns a 403 status result, as well as an optional list of
    failed permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StatusCode(int statusCode, object o = null)`: This returns a custom status
    code, as well as an optional result object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action method can return a result object directly with `return myObject`.
    This is equivalent to returning `OK(myObject)`.
  prefs: []
  type: TYPE_NORMAL
- en: When all the result paths return a result object of the same type, say, `MyType`,
    the action method can be declared as returning `ActionResult<MyType>`. You may
    also return responses like `NotFound`, but for sure, you will get a better type
    of check with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: By default, result objects are serialized in JSON in the response body. However,
    if an XML formatter has been added to the ASP.NET Core framework processing pipeline,
    as shown previously, the way the result is serialized depends on the `Accept`
    header of the HTTP request. More specifically, if the client explicitly requires
    XML format with the `Accept` header, the object will be serialized in XML; otherwise,
    it will be serialized in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex objects that are passed as input to action methods can be validated
    with validation attributes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If the controller has been decorated with the `[ApiController]` attribute and
    if validation fails, the ASP.NET Core framework automatically creates a `BadRequest`
    response containing a dictionary with all the validation errors detected, without
    executing the action method. Therefore, you do not need to add further code to
    handle validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Action methods can also be declared as `async` methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Practical examples of controllers/action methods will be shown in *Use case
    – exposing WWTravelClub packages,* presented in *Chapter 21, Case Study*. In the
    next subsection, we will explain how to handle authorization and authentication
    with JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core service authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using a JWT, authorizations are based on the claims contained in the JWT.
    All the token claims in any action method can be accessed through the `User.Claims`
    controller property. Since `User.Claims` is an `IEnumerable<Claim>`, it can be
    processed with LINQ to verify complex conditions on claims.
  prefs: []
  type: TYPE_NORMAL
- en: 'If authorization is based on *role* claims, you can simply use the `User.IsInRole`
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, permissions are not usually checked from within action methods and
    are automatically checked by the MVC framework according to authorization attributes
    that decorate either the whole controller or a single action method. If an action
    method or the whole controller is decorated with `[Authorize]`, then access to
    the action method is possible only if the request has a valid authentication token,
    which means we don’t have to perform a check on the token claims. It is also possible
    to check whether the token contains a set of roles using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'More complex conditions on claims require that authorization policies be defined
    while building the app in `Program.cs`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After that, you can decorate the action methods or controllers with `[Authorize(Policy
    = "Father")]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using JWT-based authorization, you must configure it in `Program.cs`.
    First, you must add the middleware that processes authentication tokens in ASP.NET
    Core, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you must configure the authentication services. There, you define the
    authentication options that will be injected through dependency injection into
    the authentication middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code provides a name to the authentication scheme, that is, a
    default name. Then, it specifies JWT authentication options. Usually, we require
    that the authentication middleware verifies that the JWT is not expired (`ValidateLifetime
    = true`), that it has the right issuer and audience (see the *REST service authorization
    and authentication* section of this chapter), and that its signature is valid.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example uses a symmetric signing key generated from a string.
    This means that the same key is used to sign and verify the signature. This is
    an acceptable choice if JWTs are created by the same website that uses them, but
    it is not an acceptable choice if there is a unique JWT issuer that controls access
    to several web API sites.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we should use an asymmetric key (typically, an `RsaSecurityKey`), so JWT
    verification requires just the knowledge of the public key associated with the
    actual private signing key. IdentityServer 4 can be used to quickly create a website
    that works as an authentication server. It emits a JWT with the usual username/password
    credentials or converts other authentication tokens. If you use an authentication
    server such as IdentityServer 4, you do not need to specify the `IssuerSigningKey`
    option since the authorization middleware is able to retrieve the required public
    key from the authorization server automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is enough to provide the authentication server URL, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if you decide to emit a JWT in your web API’s site, you
    can define a `Login` action method that accepts an object with a username and
    password and that, while relying on database information, builds the JWT with
    code similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, `JwtSecurityTokenHandler().WriteToken(token)` generates the actual token
    string from the token properties contained in the `JwtSecurityToken` instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will learn how to empower our web API with an OpenAPI
    documentation endpoint so that proxy classes for communicating with our services
    can be generated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core support for OpenAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the information that is needed to fill in an OpenAPI JSON document can
    be extracted from web API controllers through reflection, that is, input types
    and sources (path, request body, and header) and endpoint paths (these can be
    extracted from routing rules). Returned output types and status codes, in general,
    cannot be easily computed since they can be generated dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the MVC framework provides the `ProducesResponseType` attribute
    so that we can declare a possible return type – a status code pair. It is enough
    to decorate each action method with as many `ProducesResponseType` attributes
    as there are possible types, that is, possible status code pairs, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If no object is returned along a path, we can just declare the status code
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can also specify just the status code when all the paths return the same
    type and when that type is specified in the action method return type as `ActionResult<CommonReturnType>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the action methods have been documented, to generate any actual documentation
    for the JSON endpoints, we must install the `Swashbuckle.AspNetCore` NuGet package
    and place some code in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 5+, you can automatically include it by leaving **OpenAPI support**
    checked when creating a project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first argument of the `SwaggerDoc` method is the documentation endpoint
    name. By default, the documentation endpoint is accessible through the `<webroot>//swagger/<endpoint
    name>/swagger.json` path, but this can be changed in several ways. The rest of
    the information contained in the `Info` class is self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: We can add several `SwaggerDoc` calls to define several documentation endpoints.
    However, by default, all the documentation endpoints will contain the same documentation,
    which includes a description of all the REST services included in the project.
    This default can be changed by calling the `c.DocInclusionPredicate(Func<string,
    ApiDescription> predicate)` method from within `services.AddSwaggerGen(c => {...})`.
  prefs: []
  type: TYPE_NORMAL
- en: '`DocInclusionPredicate` must be passed a function that receives a JSON document
    name and an action method description and must return `true` if the documentation
    of the action must be included in that JSON document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare that your REST APIs need a JWT, you must add the following code
    within `services.AddSwaggerGen(c => {...})`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enrich the JSON documentation endpoint with information that has been
    extracted from triple-slash comments, which are usually added to generate automatic
    code documentation. The following code shows some examples of this. The following
    snippet shows how we can add a method description and parameter information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows how we can add parameter descriptions and return
    type descriptions for each HTTP status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable extraction from triple-slash comments, we must enable code documentation
    creation by adding the following code to our project file (`.csproj`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must enable code documentation processing from within `services.AddSwaggerGen(c
    => {...})` by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our documentation endpoints are ready, we can add some more middleware
    that is contained in the same `Swashbuckle.AspNetCore` NuGet package to generate
    a friendly user interface that we can test our REST API on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you have several documentation endpoints, you need to add a `SwaggerEndpoint`
    call for each of them. We will use this interface to test the REST API defined
    in the book use case, presented in *Chapter 21, Case Study*. There you will also
    find out how to use Postman, an API platform for building and using APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a working JSON documentation endpoint, you can automatically
    generate the C# or TypeScript code of a proxy class, presented in *Chapter 6,
    Design Patterns and .NET 8 Implementation*, with one of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The NSwagStudio Windows program, which is available at [https://github.com/RicoSuter/NSwag/wiki/NSwagStudio](https://github.com/RicoSuter/NSwag/wiki/NSwagStudio).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `NSwag.CodeGeneration.CSharp` or `NSwag.CodeGeneration.TypeScript`NuGet
    packages if you want to customize code generation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `NSwag.MSBuild` NuGet package if you want to tie code generation to Visual
    Studio build operations. The documentation for this can be found at [https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild](https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next subsection, you will learn how to invoke a REST API from another
    REST API or from a .NET client.
  prefs: []
  type: TYPE_NORMAL
- en: .NET HTTP clients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `HttpClient` class in the `System.Net.Http` namespace is a .NET Standard
    2.0 built-in HTTP client class. While it could be used directly whenever we need
    to interact with a REST service, there are some problems in creating and releasing
    `HttpClient` instances repeatedly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Their creation is expensive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an `HttpClient` is released, for instance, in a using statement, the underlying
    connection is not closed immediately but at the first garbage collection session.
    Therefore, repeated creation and release operations quickly exhaust the maximum
    number of connections the operating system can handle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, either a single `HttpClient` instance is reused, such as a Singleton,
    or `HttpClient` instances are somehow pooled. Starting from the 2.1 version of
    .NET Core, the `HttpClientFactory` class was introduced to pool HTTP clients.
    More specifically, whenever a new `HttpClient` instance is required for an `HttpClientFactory`
    object, a new `HttpClient` is created. However, the underlying `HttpClientMessageHandler`
    instances, which are expensive to create, are pooled until their maximum lifetime
    expires.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClientMessageHandler` instances must have a finite duration since they
    cache DNS resolution information that may change over time. The default lifetime
    of `HttpClientMessageHandler` is 2 minutes, but it can be redefined by the developer.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `HttpClientFactory` allows us to automatically pipeline all the HTTP operations
    with other operations. For instance, we can add a Polly retry strategy to handle
    all the failures of all our HTTP operations automatically. For an introduction
    to Polly, please refer to the *Resilient task execution* subsection of *Chapter
    5*, *Implementing Code Reusability in C# 12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to exploit the advantages offered by the `HttpClientFactory`
    class is to add the `Microsoft.Extensions.Http` NuGet package and then follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a proxy class, say, `MyProxy`, to interact with the desired REST service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let `MyProxy` accept an `HttpClient` instance in its constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `HttpClient` that was injected into the constructor to implement all
    the necessary operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare your proxy in the services configuration method of your host, which,
    in the case of an ASP.NET Core application, is in the `Program.cs` class. In the
    simplest case, the declaration is something similar to `builder.Services.AddHttpClient<MyProxy>()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will automatically add `MyProxy` to the services that are available for
    dependency injection, so you can easily inject it, for instance, in your controller’s
    constructors. Moreover, each time an instance of `MyProxy` is created, an `HttpClient`
    is returned by an `HttpClientFactory` and is automatically injected into its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructors of the classes that need to interact with a REST service,
    we may also need an interface instead of a specific proxy implementation with
    a declaration of the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This way, each client that is passed to the proxy is preconfigured so that it
    requires a JSON response and must work with a specific service. Once the base
    address has been defined, each HTTP request needs to specify the relative path
    of the service method to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to perform a `POST` to a service. This requires
    an extra package, `System.Net.Http.Json`, because of the usage of `PostAsJsonAsync`.
    Here, we are stating that the `HttpClient` that was injected into the proxy constructor
    has been stored in the `webClient` private field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use Polly, you do not need to intercept and handle communication errors
    since this job is performed by Polly. First, you need to verify the status code
    to decide what to do next. Then, you can parse the JSON string contained in the
    response body to get a .NET instance of a type that, in general, depends on the
    status code. The code to perform the parsing is based on the `System.Text.Json`
    NuGet package’s `JsonSerializer` class and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing a `GET` request is similar, but instead of calling `PostAsJsonAsync`,
    you need to call `GetAsync`, as shown here. The use of other HTTP verbs is completely
    analogous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this section, accessing HTTP APIs is quite simple and requires
    the implementation of some .NET 6 libraries. Since the beginning of .NET Core,
    Microsoft has been working a lot on improving the performance and simplicity of
    this part of the framework. It is up to you to keep yourself updated on the documentation
    and facilities they keep implementing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced SOA, its design principles, and its constraints.
    Among them, interoperability is worth remembering.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we focused on well-established standards for business applications that
    achieve the interoperability that is needed for publicly exposed services. Therefore,
    SOAP and REST services were discussed in detail, along with the transition from
    SOAP services to REST services that has taken place in most application areas
    in the last few years. Then, REST service principles, authentication/authorization,
    and documentation were described in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the tools that are available in .NET 8 that we can use
    to implement and interact with services. We looked at a variety of frameworks
    for intra-cluster communication, such as .NET remoting and gRPC, and tools for
    SOAP- and REST-based public services.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we mainly focused on REST services. Their ASP.NET Core implementations
    were described in detail, along with the techniques we can use to authenticate/authorize
    them and their documentation. We also focused on how to implement efficient .NET
    proxies so that we can interact with REST services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use .NET 8 to implement microservices
    with ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can services use cookie-based sessions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it good practice to implement a service with a custom communication protocol?
    Why or why not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a `POST` request to a REST service cause a deletion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many dot-separated parts are contained in a JWT bearer token?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, where are the complex type parameters of a REST service’s action
    methods taken from?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a controller declared as a REST service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main documentation attributes of ASP.NET Core services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are ASP.NET Core REST service routing rules declared?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should a proxy be declared so that we can take advantage of .NET `HttpClientFactory`
    class features?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter mainly focused on the more commonly used REST service. If you
    are interested in SOAP services, a good place to start is the Wikipedia page regarding
    SOAP specifications: [https://en.wikipedia.org/wiki/List_of_web_service_specifications](https://en.wikipedia.org/wiki/List_of_web_service_specifications).
    On the other hand, if you are interested in the Microsoft .NET WCF technology
    for implementing SOAP services, you can refer to WCF’s official documentation
    here: [https://docs.microsoft.com/en-us/dotnet/framework/wcf/](https://docs.microsoft.com/en-us/dotnet/framework/wcf/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter mentioned the AMQP protocol as an option for intra-cluster communication
    without describing it. Detailed information on this protocol is available on AMQP’s
    official site: [https://www.amqp.org/](https://www.amqp.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on gRPC is available on Google gRPC’s official site: [https://grpc.io/](https://grpc.io/).
    More information on the Visual Studio gRPC project template can be found here:
    [https://docs.microsoft.com/en-US/aspnet/core/grpc/](https://docs.microsoft.com/en-US/aspnet/core/grpc/).
    You may also want to check out gRPC-Web at [https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More details on ASP.NET Core services are available in the official documentation:
    [https://docs.microsoft.com/en-US/aspnet/core/web-api/](https://docs.microsoft.com/en-US/aspnet/core/web-api/).
    More information on the .NET HTTP client is available here: [https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests](https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal APIs are described at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on JWT authentication is available here: [https://jwt.io/](https://jwt.io/).
    If you would like to generate JWTs with IdentityServer, you may refer to its official
    documentation page: [https://docs.duendesoftware.com/identityserver/v7](https://docs.duendesoftware.com/identityserver/v7).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on OpenAPI is available at [https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/),
    while more information on Swashbuckle can be found on its GitHub repository page:
    [https://github.com/domaindrivendev/Swashbuckle](https://github.com/domaindrivendev/Swashbuckle).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Leave_a_review_QR.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Limited Offer*'
  prefs: []
  type: TYPE_NORMAL
