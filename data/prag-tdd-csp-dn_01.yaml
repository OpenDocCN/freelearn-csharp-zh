- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Writing Your First TDD Implementation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个TDD实现
- en: I’ve always liked books that start with a quick end-to-end demo about the proposed
    subject before diving into the details. That gives me a sense of what I am going
    to learn. I wanted to share with you the same experience by beginning this book
    with a tiny application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直喜欢那些在深入细节之前，先快速演示一下所提议主题的书籍。这让我对将要学习的内容有一个大致的了解。我希望通过以一个小型应用程序开始这本书，与你分享同样的体验。
- en: Here, we will simulate minimal business requirements, and while implementing
    them, we will touch on **unit testing** and **test-driven development** (**TDD**)
    concepts. Don’t worry if a concept is not clear or requires further explanation,
    as this chapter purposely skims over topics to give you a flavor. By the end of
    the book, we will have covered all the concepts that were skimmed over.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将模拟最小化的业务需求，并在实现它们的过程中，会涉及到**单元测试**和**测试驱动开发**（**TDD**）的概念。如果某个概念不清楚或需要进一步解释，请不要担心，因为这一章故意略过了这些主题，以便给你一个大致的了解。到书的结尾，我们将涵盖所有被略过的话题。
- en: Also, note that we will use the terms *unit testing* and *TDD* interchangeably
    with little distinction. The difference will be clearer by [*Chapter 5*](B18370_05.xhtml#_idTextAnchor114),
    *Test-Driven Development Explained*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们将互换使用*单元测试*和*TDD*这两个术语，几乎不加区分。区别将在[*第五章*](B18370_05.xhtml#_idTextAnchor114)“测试驱动开发解释”中变得更加清晰。
- en: 'In this chapter, you will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将涵盖以下主题：
- en: Choosing your **integrated development environment** (**IDE**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你的**集成开发环境**（**IDE**）
- en: Building a solution skeleton with unit testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单元测试构建解决方案框架
- en: Implementing requirements with TDD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TDD实现需求
- en: By the end of the chapter, you will be comfortable writing basic unit tests
    using **xUnit** and have a fair understanding of what TDD is.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够熟练地使用**xUnit**编写基本的单元测试，并对TDD有一个公正的理解。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch01](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch01)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch01](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch01)'
- en: Choosing your IDE
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择你的IDE
- en: From a TDD perspective, different IDEs will affect your productivity. TDD implementation
    can be boosted by IDEs that have rich code refactoring and code generation capabilities,
    and selecting the right one will reduce repetitive—and potentially boring—tasks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从TDD的角度来看，不同的IDE会影响你的生产力。具有丰富代码重构和代码生成功能的IDE可以提升TDD的实现，选择正确的一个将减少重复——甚至可能令人厌烦——的任务。
- en: 'In the following sections, I have presented three popular IDEs with C# support:
    **Visual Studio** (**VS**), **VS Code**, and **JetBrains Rider**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我介绍了三个支持C#的流行IDE：**Visual Studio**（**VS**）、**VS Code**和**JetBrains
    Rider**。
- en: Microsoft VS
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微软VS
- en: This chapter and the rest of the book will use *VS 2022 Community Edition*—this
    should also work with the *Professional* and *Enterprise* editions. Individual
    developers can use *VS Community Edition* for free to create their own free or
    paid applications. Organizations can also use it under some restrictions. For
    the full license and product details, visit [https://visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及本书的其余部分将使用*VS 2022社区版*——这也应该适用于*专业版*和*企业版*。个人开发者可以免费使用*VS社区版*来创建自己的免费或付费应用程序。组织也可以在一定的限制下使用它。有关完整的许可证和产品详细信息，请访问[https://visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/)。
- en: If you have an earlier version of VS and do not want to upgrade, then you can
    have *VS 2022 Community Edition* installed side by side with previous versions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个更早版本的VS并且不想升级，那么你可以将*VS 2022社区版*与之前的版本并行安装。
- en: Both the *Windows* and *Mac* editions of *VS 2022* have the required tools to
    build our code and run the tests. I have done all the projects, screenshots, and
    instructions in this book using the *Windows* edition. You can download VS from
    [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*VS 2022*的*Windows*和*Mac*版本都包含了构建我们的代码和运行测试所需的工具。我在这本书中所有的项目、截图和说明都是使用*Windows*版本完成的。你可以从[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)下载VS。'
- en: 'When installing VS, you will need at least the **ASP.NET and web development**
    box selected to be able to follow along with the book, as illustrated in the following
    screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 VS 时，您至少需要选择 **ASP.NET 和 Web 开发**选项，才能按照以下截图进行操作：
- en: '![Figure 1.1 – VS installation dialog ](img/Figure_1.1_B18370.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – VS 安装对话框](img/Figure_1.1_B18370.jpg)'
- en: Figure 1.1 – VS installation dialog
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – VS 安装对话框
- en: 'If you have VS previously installed, you can check if **ASP.NET and web development**
    is already installed by following these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前已经安装了 VS，可以通过以下步骤检查是否已安装 **ASP.NET 和 Web 开发**：
- en: Go to Windows **Settings** | **Apps** | **Apps & features**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Windows **设置** | **应用** | **应用和功能**。
- en: Search for `Visual Studio` under **App list**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **应用列表** 中搜索 **Visual Studio**。
- en: Select the vertical ellipsis (the three vertical dots).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择垂直省略号（三个垂直点）。
- en: 'Select **Modify**, as shown in the following screenshot:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择如图所示的操作 **修改**：
- en: '![Figure 1.2 – Modifying VS installation ](img/Figure_1.2_B18370.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 修改 VS 安装](img/Figure_1.2_B18370.jpg)'
- en: Figure 1.2 – Modifying VS installation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 修改 VS 安装
- en: VS is big, as it contains plenty of components to install. Also, after installation,
    it is the slowest to load, in comparison with *Rider* and *VS Code*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: VS 很大，因为它包含许多需要安装的组件。此外，与 *Rider* 和 *VS Code* 相比，安装后它加载速度最慢。
- en: ReSharper
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReSharper
- en: '**JetBrains ReSharper** is a popular commercial plugin for VS. ReSharper adds
    multiple features to VS; however, from a TDD standpoint, we are interested in
    the following aspects:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**JetBrains ReSharper** 是 VS 的一个流行的商业插件。ReSharper 为 VS 添加了多个功能；然而，从 TDD 的角度来看，我们感兴趣的是以下方面：'
- en: '**Refactoring**: ReSharper adds many refactoring features that come in handy
    when you reach the refactoring stage of TDD.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：ReSharper 添加了许多在 TDD 的重构阶段非常有用的重构功能。'
- en: '**Code generation**: Generating code with ReSharper is particularly useful
    when creating your unit tests first, then generating code after.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码生成**：使用 ReSharper 生成代码特别有用，尤其是在首先创建单元测试然后生成代码的情况下。'
- en: '**Unit testing**: ReSharper supercharges the unit testing tools in VS and has
    support for more unit testing frameworks.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：ReSharper 加强了 VS 的单元测试工具，并支持更多的单元测试框架。'
- en: ReSharper is a subscription-based product with a 30-day trial. I would recommend
    you to start first with VS without ReSharper, then add it later when you are familiar
    with the capabilities of VS so that you recognize the benefits of adding ReSharper.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ReSharper 是一款基于订阅的产品，提供 30 天的试用期。我建议您首先使用不带 ReSharper 的 VS，然后在熟悉 VS 的功能后再添加它，这样您就能认识到添加
    ReSharper 的好处。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Each new release of VS adds additional code refactoring and code generation
    capabilities similar to those of ReSharper. However, as of now, ReSharper has
    more advanced features.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: VS 的每个新版本都会添加额外的代码重构和代码生成功能，类似于 ReSharper 的功能。然而，截至目前，ReSharper 拥有更先进的功能。
- en: 'In this book, the discussion on ReSharper will be limited to this section.
    You can download ReSharper here: [https://www.jetbrains.com/resharper/](https://www.jetbrains.com/resharper/).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，关于 ReSharper 的讨论将仅限于本节。您可以从这里下载 ReSharper：[https://www.jetbrains.com/resharper/](https://www.jetbrains.com/resharper/)。
- en: JetBrains Rider
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JetBrains Rider
- en: '*JetBrains*, the company behind *Rider*, is the same company behind the popular
    *ReSharper* VS plugin. If you have chosen **JetBrains Rider** for your .NET development,
    then you have all the features that are required in this book. Rider has the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*JetBrains*，*Rider* 背后的公司，也是流行的 *ReSharper* VS 插件的背后公司。如果您选择了 *JetBrains Rider*
    进行 .NET 开发，那么您将拥有本书中所需的所有功能。Rider 具有以下特点：'
- en: A powerful **unit test runner** that competes with **Test Explorer** of VS
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个强大的 **单元测试运行器**，与 VS 的 **测试资源管理器**相媲美
- en: Feature-rich code refactoring and code generation capabilities with more advanced
    features than those of VS 2022
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的代码重构和代码生成功能，比 VS 2022 的功能更先进
- en: The aforementioned points are crucial for building a system *TDD-style*; however,
    I have chosen VS for this book rather than Rider. Although the instructions in
    this book are meant for VS 2022, they can be applied to Rider, taking into consideration
    that Rider has a different menu system and shortcuts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述要点对于以 *TDD 风格* 构建系统至关重要；然而，我选择在本书中使用 VS 而不是 Rider。尽管本书中的说明是针对 VS 2022 的，但考虑到
    Rider 拥有不同的菜单系统和快捷键，它们也可以应用于 Rider。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**VS .NET** (VS release with .NET support) was released in February 2002, while
    Rider is more recent and was released in August 2017; so, VS is more established
    between .NET developers. I have nominated VS for this book over Rider for this
    reason.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**VS .NET**（带有 .NET 支持的 VS 版本）于 2002 年 2 月发布，而 Rider 更新，于 2017 年 8 月发布；因此，VS
    在 .NET 开发者中更为成熟。我之所以选择 VS 而不是 Rider 来编写这本书，是因为这个原因。'
- en: 'You can download Rider here: [https://www.jetbrains.com/rider/](https://www.jetbrains.com/rider/).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处下载 Rider：[https://www.jetbrains.com/rider/](https://www.jetbrains.com/rider/).
- en: VS Code
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code
- en: If you are a fan of VS Code, you will be pleased to know that Microsoft added
    native support for visual unit testing (which is essential for TDD) in July 2021,
    with the version 1.59 release.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢 VS Code，你将很高兴地知道，微软在 2021 年 7 月的版本 1.59 发布中添加了对可视化单元测试的原生支持（这对于 TDD 是必不可少的）。
- en: VS Code is a lightweight IDE—it has good native refactoring options and a bunch
    of third-party refactoring plugins. The simplicity and elegance of VS Code attract
    many TDD practitioners, but the available C# features—especially those used in
    TDD—are not as advanced as those of VS or Rider.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 是一个轻量级 IDE——它具有良好的原生重构选项和一系列第三方重构插件。VS Code 的简洁和优雅吸引了众多 TDD 实践者，但其 C#
    功能——尤其是在 TDD 中使用的功能——并不像 VS 或 Rider 那样先进。
- en: I will be using *VS* in this book, but you can adapt the examples to VS Code
    where relevant. To download VS Code, you can visit [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这本书中使用 *VS*，但你可以将示例适应到相关的 VS Code 中。要下载 VS Code，你可以访问 [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
- en: .NET and C# versions
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 和 C# 版本
- en: VS 2022 comes with **.NET 6** and **C# 10** support. This is what we will be
    using for the purposes of this chapter and the rest of the book.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: VS 2022 支持 **.NET 6** 和 **C# 10**。这是我们将在本章和本书其余部分使用的内容。
- en: 'I initiated a small poll to gather some public opinion in my LinkedIn group—you
    can see the results here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的 LinkedIn 群组中发起了一项小调查，以收集一些公众意见——你可以在这里看到结果：
- en: '![Figure 1.3 – LinkedIn IDE poll results ](img/Figure_1.3_B18370.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – LinkedIn IDE 投票结果](img/Figure_1.3_B18370.jpg)'
- en: Figure 1.3 – LinkedIn IDE poll results
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – LinkedIn IDE 投票结果
- en: As you can see, VS has the highest usage of 58%, with 18% who use the ReSharper
    plugin with VS, then Rider comes second at 24%, then in third place comes VS Code
    with 18%. However, given that this is only 45 votes, it is meant to give you an
    indication and would definitely not reflect the market.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，VS 的使用率最高，为 58%，其次是使用 VS 和 ReSharper 插件的 18%，然后是排名第二的 Rider，占 24%，第三名是
    VS Code，占 18%。然而，鉴于这只有 45 票，这只是为了给你一个指示，肯定不会反映市场情况。
- en: Picking the right IDE is a debatable subject between developers. I know that
    every time I ask a developer practicing TDD about their chosen IDE, they would
    swear by how good their IDE is! In conclusion, use the IDE that makes you more
    productive.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的 IDE 是开发者之间有争议的话题。我知道每次我询问实践 TDD 的开发者他们选择的 IDE 时，他们都会发誓他们的 IDE 多么好！总之，使用能让你更高效的
    IDE。
- en: Building a solution skeleton with unit testing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单元测试构建解决方案框架
- en: Now that we’ve got the technical requirements out of the way, it’s time to build
    our first implementation. For this chapter, and to keep the focus on TDD concepts,
    let’s start with simple business requirements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了技术要求，是时候构建我们的第一个实现了。为了本章，并保持对 TDD 概念的关注，让我们从简单的业务需求开始。
- en: Let’s assume that you are a developer, working for a fictitious company called
    **Unicorn Quality Solutions Inc.** (**UQS**), which produces high-quality software.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一名开发者，在一家名为 **Unicorn Quality Solutions Inc.**（**UQS**）的虚构公司工作，该公司生产高质量的软件。
- en: Requirements
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求
- en: The software teams in **UQS** follow an agile approach and describe business
    requirements in terms of a **user story**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**UQS** 中的软件团队采用敏捷方法，并以 **用户故事** 的形式描述业务需求。'
- en: 'You are working on a math library that is packaged to be consumed by other
    developers. You can think of this as if you are building a feature within a **NuGet
    library** to be used by other applications. You’ve picked a user story to implement,
    as outlined here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在开发一个打包供其他开发者使用的数学库。你可以将其视为在 **NuGet 库** 中构建一个功能，以便其他应用程序使用。你已经选择了一个用户故事来实现，如下所述：
- en: '**Story Title:**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**故事标题：**'
- en: '*Integers Division*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数除法*'
- en: '**Story Description:**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**故事描述：**'
- en: '*As a math library client, I want a method to divide two integers*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为数学库客户端，我希望有一个方法来除以两个整数*'
- en: '**Acceptance Criteria:**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**验收标准：**'
- en: '*Supports an Int32 input and a decimal output*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*支持 Int32 输入和十进制输出*'
- en: '*Supports high-precision return with no/minimal rounding*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*支持高精度返回，无/最小舍入*'
- en: '*Supports dividing divisible and indivisible integers*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*支持除以可除和不可除的整数*'
- en: '*Throws a DivideByZeroException when dividing by 0*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*当除以0时抛出DivideByZeroException异常*'
- en: Creating a project skeleton
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目骨架
- en: You will need two C# projects for this story. One is the **class library** that
    will contain the production code and a second library for unit testing the class
    library.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个故事，你需要两个C#项目。一个是包含生产代码的**类库**，另一个是用于对类库进行单元测试的库。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Class libraries enable you to modularize functionality that can be used by multiple
    applications. When compiled, they will generate **dynamic-link library** (**DLL**)
    files. A class library cannot run on its own, but it can run as part of an application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类库使您能够模块化可以被多个应用程序使用的功能。编译后，它们将生成**动态链接库（DLL**）文件。类库不能独立运行，但它可以作为应用程序的一部分运行。
- en: If you have not worked with a class library before, for the purposes of this
    book, you can treat it like a console app or a web app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有使用过类库，为了本书的目的，您可以将其视为控制台应用程序或Web应用程序。
- en: Creating a class library project
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建类库项目
- en: We are going to create the same projects set up in two ways—via the **graphical
    user interface** (**GUI**) and via the .NET **command-line interface** (**CLI**).
    Choose what you prefer or what you are familiar with.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以两种方式创建相同的项目设置——通过**图形用户界面（GUI**）和通过.NET **命令行界面（CLI**）。选择您喜欢的或您熟悉的方式。
- en: Via the GUI
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过图形用户界面（GUI）
- en: 'To create a class library, run VS and then follow these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建类库，运行VS，然后按照以下步骤操作：
- en: From the menu, select **File** | **New** | **Project**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**文件** | **新建** | **项目**。
- en: Look for `Class Library (C#)`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`Class Library (C#)`。
- en: 'Select the rectangle containing **Class Library (C#)** | hit **Next**. The
    **Add a new project** dialog will display, as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择包含**类库（C#）**的矩形 | 点击**下一步**。将显示**添加新项目**对话框，如下所示：
- en: '![Figure 1.4 – Finding the Class Library (C#) project template ](img/Figure_1.4_B18370.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 查找类库（C#）项目模板](img/Figure_1.4_B18370.jpg)'
- en: Figure 1.4 – Finding the Class Library (C#) project template
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 查找类库（C#）项目模板
- en: Important Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure you can see the **C#** tag in the box and do *NOT* select the **Class
    Library (.NET Framework)** item. We are using .NET (not classical .NET Framework).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您可以看到框中的**C#**标签，并且不要选择**类库 (.NET Framework)**项。我们使用.NET（而不是经典的.NET Framework）。
- en: 'In the `Uqs.Arithmetic` in the `UqsMathLib` in the **Solution name** field,
    then hit **Next**. The process is illustrated in the following screenshot:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UqsMathLib`中的`Uqs.Arithmetic`的**解决方案名称**字段中，然后点击**下一步**。过程如图下所示：
- en: '![Figure 1.5 – Configure your new project dialog ](img/Figure_1.5_B18370.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 配置新项目对话框](img/Figure_1.5_B18370.jpg)'
- en: Figure 1.5 – Configure your new project dialog
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 配置新项目对话框
- en: 'In the `.NET 6.0 (Long-term support)` and hit **Create**. The process is illustrated
    in the following screenshot:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.NET 6.0 (长期支持)`中点击**创建**。过程如图下所示：
- en: '![Figure 1.6 – Additional information ](img/Figure_1.6_B18370.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 其他信息](img/Figure_1.6_B18370.jpg)'
- en: Figure 1.6 – Additional information
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 其他信息
- en: We now have a class library project within the solution, using the *VS GUI*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在解决方案中有一个类库项目，使用的是*VS GUI*。
- en: Via the CLI
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过命令行界面（CLI）
- en: 'If you prefer to create your project via the CLI, here are the required commands:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢通过命令行界面（CLI）创建项目，以下是所需的命令：
- en: Create a directory called `UqsMathLib` (`md UqsMathLib`).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UqsMathLib`的目录（`md UqsMathLib`）。
- en: 'Navigate to this directory via your terminal (`cd UqsMathLib`), as illustrated
    in the following screenshot:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过您的终端（`cd UqsMathLib`）导航到该目录，如图下所示：
- en: '![Figure 1.7 – Command Prompt showing the commands ](img/Figure_1.7_B18370.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 命令提示符显示命令](img/Figure_1.7_B18370.jpg)'
- en: Figure 1.7 – Command Prompt showing the commands
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 命令提示符显示命令
- en: 'Create a solution file (`.sln`) that will be generated with the same name as
    the directory—that is, `UqsMathLib.sln`—by running the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个与目录同名的解决方案文件（`.sln`），即`UqsMathLib.sln`：
- en: '[PRE0]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new class library called `Uqs.Arithmetic` in a directory with the
    same name and use *.NET 6.0*. Here’s the code you need to execute:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同名的目录中创建一个名为`Uqs.Arithmetic`的新类库，并使用*.NET 6.0*。以下是您需要执行的代码：
- en: '[PRE1]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the newly created project to the solution file by running the following
    command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令将新创建的项目添加到解决方案文件中：
- en: '[PRE2]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We now have a class library project within the solution, using the *CLI*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们解决方案中有一个类库项目，使用的是 *CLI*。
- en: Creating a unit testing project
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建单元测试项目
- en: Currently, we have a solution with one class library project. Next, we want
    to add the unit test library to our solution. For this, we will use **xUnit Test
    Project**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个包含一个类库项目的解决方案。接下来，我们想要将单元测试库添加到我们的解决方案中。为此，我们将使用**xUnit 测试项目**。
- en: xUnit.net is a free, open source, unit testing tool for .NET. It is licensed
    under Apache 2\. VS natively supports adding and running xUnit projects, so no
    special tool or plugin is needed to use xUnit.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit.net 是一个免费的、开源的 .NET 单元测试工具。它根据 Apache 2 许可。VS 本地支持添加和运行 xUnit 项目，因此不需要特殊工具或插件来使用
    xUnit。
- en: We will be going into more details about xUnit in [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066),
    *Getting Started with Unit Testing*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 3 章*](B18370_03.xhtml#_idTextAnchor066)“开始单元测试”中更详细地介绍 xUnit。
- en: 'We will follow a common convention for naming unit test projects: `[ProjectName].Tests.Unit`.
    Thus, our project will be called `Uqs.Arithmetic.Tests.Unit`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循命名单元测试项目的通用约定：`[ProjectName].Tests.Unit`。因此，我们的项目将被称为`Uqs.Arithmetic.Tests.Unit`。
- en: We will create a unit test project in two ways, so you can pick whatever suits
    you best.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以两种方式创建单元测试项目，这样您可以选择最适合您的方法。
- en: Via the GUI
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过 GUI
- en: 'To create a unit testing project, go to **Solution Explorer** in VS, then follow
    these steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建单元测试项目，请转到 VS 中的**解决方案资源管理器**，然后按照以下步骤操作：
- en: Right-click on the solution file (`UqsMathLib`).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击解决方案文件（`UqsMathLib`）。
- en: 'Go to **Add** | **New Project…**, as illustrated in the following screenshot:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**添加** | **新建项目…**，如图所示：
- en: '![Figure 1.8 – Creating a new project in a solution ](img/Figure_1.8_B18370.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 在解决方案中创建新项目](img/Figure_1.8_B18370.jpg)'
- en: Figure 1.8 – Creating a new project in a solution
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 在解决方案中创建新项目
- en: Look for **xUnit Test Project** | hit **Next**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找**xUnit 测试项目** | 点击**下一步**。
- en: Set the `Uqs.Arithmetic.Tests.Unit`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`Uqs.Arithmetic.Tests.Unit`。
- en: Hit **Next** | select **.NET 6.0** | hit **Create**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步** | 选择**.NET 6.0** | 点击**创建**。
- en: 'You have created a project via the VS GUI, but we still need to set the unit
    test project to have a reference to the class library. To do so, follow these
    steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您已通过 VS GUI 创建了一个项目，但我们仍然需要设置单元测试项目以对类库有引用。为此，请按照以下步骤操作：
- en: In VS Solution Explorer, right-click on `Uqs.Arithmetic.Tests.Unit`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS 解决方案资源管理器中，右键单击`Uqs.Arithmetic.Tests.Unit`。
- en: Select **Add Project Reference…**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加项目引用…**。
- en: Tick `Uqs.Arithmetic` and hit **OK**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Uqs.Arithmetic`并点击**确定**。
- en: We now have our solution fully constructed via the VS GUI. You may choose to
    do the same GUI steps in the CLI instead. In the next section, we will do exactly
    that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过 VS 图形用户界面（GUI）完全构建了解决方案。您可以选择在 CLI 中执行相同的 GUI 步骤。在下一节中，我们将做 exactly
    that。
- en: Via the CLI
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过 CLI
- en: Currently, we have a solution with one class library project. Now, we want to
    add the unit test library to our solution.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个包含一个类库项目的解决方案。现在，我们想要将单元测试库添加到我们的解决方案中。
- en: 'Create a new xUnit project called `Uqs.Arithmetic.Tests.Unit` in a directory
    with the same name and use .NET 6.0\. Here’s the code you need to execute:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有相同名称的目录中创建一个新的 xUnit 项目，名为 `Uqs.Arithmetic.Tests.Unit`，并使用 .NET 6.0。以下是您需要执行的代码：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the newly created project to the solution file by running the following
    command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令将新创建的项目添加到解决方案文件中：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now have two projects in our solution. As the unit test project will be testing
    the class library, the project should have a reference to the class library.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们解决方案中有两个项目。由于单元测试项目将测试类库，因此项目应该有对类库的引用。
- en: 'You have created a project via the CLI, but we still need to set the unit test
    project to have a reference to the class library. To do so, add a project reference
    from `Uqs.Arithmetic.Tests.Unit` to `Uqs.Arithmetic`, like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您已通过命令行界面（CLI）创建了一个项目，但我们仍然需要将单元测试项目设置为对类库有引用。为此，从`Uqs.Arithmetic.Tests.Unit`添加一个项目引用到`Uqs.Arithmetic`，如下所示：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now have our solution fully constructed via the CLI.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过 CLI 完全构建了解决方案。
- en: Final solution
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终解决方案
- en: 'Whichever method you’ve used to create the solution—either the VS GUI or the
    CLI—you should now have the same files created. Now, you can open the solution
    in VS, and you’ll see this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪种方法创建解决方案——无论是 VS GUI 还是 CLI——您现在都应该有相同的文件创建。现在，您可以在 VS 中打开解决方案，您会看到以下内容：
- en: '![Figure 1.9 – The final created solution structure ](img/Figure_1.9_B18370.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 最终创建的解决方案结构](img/Figure_1.9_B18370.jpg)'
- en: Figure 1.9 – The final created solution structure
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 最终创建的解决方案结构
- en: To start from a clean slate, delete `Class1.cs` as we won’t be using it—it was
    added automatically by the template.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从零开始，删除 `Class1.cs`，因为我们不会使用它——它是模板自动添加的。
- en: 'The logical structure of our two projects looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们两个项目的逻辑结构如下所示：
- en: '![Figure 1.10 – Projects’ logical structure ](img/Figure_1.10_B18370.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – 项目的逻辑结构](img/Figure_1.10_B18370.jpg)'
- en: Figure 1.10 – Projects’ logical structure
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 项目的逻辑结构
- en: 'What we’ve created so far are two projects: one that will be shipped to production
    at some stage (`Uqs.Arithmetic`) and one to test this project (`Uqs.Arithmetic.Tests.Unit`).
    The solution file links the two projects together.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止创建了两个项目：一个将在某个阶段发布到生产环境（`Uqs.Arithmetic`）和一个用于测试此项目（`Uqs.Arithmetic.Tests.Unit`）。解决方案文件将这两个项目链接在一起。
- en: Now that we have finished the less fun part of building the project skeleton
    and setting the dependencies, we can now start the more fun one, which is directly
    related to unit testing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了构建项目骨架和设置依赖项不那么有趣的部分，现在我们可以开始更有趣的部分，即与单元测试直接相关的内容。
- en: Familiarizing yourself with built-in test tools
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉内置测试工具
- en: We have reached the stage where we need to look into how to discover and execute
    tests, and to do that, we need to understand which tools are available to us.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了需要了解如何发现和执行测试的阶段，为此，我们需要了解哪些工具可供我们使用。
- en: 'We have code that is already generated by the xUnit template—look at the code
    inside `UnitTest1.cs`, as displayed here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了由 xUnit 模板生成的代码——看看这里显示的 `UnitTest1.cs` 内的代码：
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a normal C# class. `Fact` is an attribute from xUnit. It simply tells
    any xUnit-compatible tool that the method decorated with `Fact` is a **unit test
    method**. xUnit-compatible tools such as **Test Explorer** and **.NET CLI Test
    Command** should be able to find this method in your solution and run it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个正常的 C# 类。`Fact` 是来自 xUnit 的一个属性。它只是告诉任何与 xUnit 兼容的工具，被 `Fact` 装饰的方法是一个 **单元测试方法**。与
    xUnit 兼容的工具，如 **测试资源管理器** 和 **.NET CLI 测试命令** 应该能够在您的解决方案中找到此方法并运行它。
- en: Following the trend of the previous sections, we will utilize the available
    test tools in two ways—via the VS GUI and via the CLI.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着前几节的趋势，我们将以两种方式利用可用的测试工具——通过 VS GUI 和通过 CLI。
- en: Via the GUI
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 GUI
- en: 'VS comes with a GUI as a test runner to discover and execute tests—it is called
    **Test Explorer**. To see how a test runner would discover test methods, from
    the menu, go to **Test** | **Test Explorer**. You will see the following screen:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: VS 内置了一个 GUI 作为测试运行器来发现和执行测试——它被称为**测试资源管理器**。要查看测试运行器如何发现测试方法，从菜单中选择**测试**
    | **测试资源管理器**。您将看到以下屏幕：
- en: '![Figure 1.11 – Test Explorer showing unexecuted tests ](img/Figure_1.11_B18370.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 测试资源管理器显示未执行的测试](img/Figure_1.11_B18370.jpg)'
- en: Figure 1.11 – Test Explorer showing unexecuted tests
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 测试资源管理器显示未执行的测试
- en: 'As you can see, it detected all the tests in our solution, showing the tests
    in a *Project Name > Namespace > Class > Method* hierarchy. Also, you can see
    that the test hierarchy is grayed out and has an exclamation mark. This is a sign
    that the tests were never run. You can click on the upper-left `Fact`. The results
    are shown here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它检测到了我们解决方案中的所有测试，以 *项目名称 > 命名空间 > 类 > 方法* 的层次结构显示测试。您还可以看到测试层次结构被灰色显示，并带有感叹号。这是一个标志，表明测试从未运行过。您可以点击左上角的
    `Fact`。结果如下所示：
- en: '![Figure 1.12 – Test Explorer showing executed test results ](img/Figure_1.12_B18370.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – 测试资源管理器显示已执行的测试结果](img/Figure_1.12_B18370.jpg)'
- en: Figure 1.12 – Test Explorer showing executed test results
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 测试资源管理器显示已执行的测试结果
- en: Don’t expect anything fancy as we have an empty shell, but at least the tests
    will turn *green* and you will know that your setup is working. You can similarly
    discover and execute tests using the CLI.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个空壳，所以不要期望任何花哨的功能，但至少测试会变成 *绿色*，您将知道您的设置正在工作。您可以使用类似的方式使用 CLI 发现和执行测试。
- en: Via the CLI
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 CLI
- en: 'You can also execute the same test by using Command Prompt, going to the solution
    directory, and executing the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过使用命令提示符，进入解决方案目录，并执行以下命令来执行相同的测试：
- en: '[PRE7]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is what you are going to get:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您将要得到的结果：
- en: '![Figure 1.13 – .NET Test command discovering and executing tests ](img/Figure_1.13_B18370.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13 – .NET 测试命令发现和执行测试](img/Figure_1.13_B18370.jpg)'
- en: Figure 1.13 – .NET Test command discovering and executing tests
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – .NET 测试命令发现和执行测试
- en: Running commands such as this will come in handy later on when we want to automate
    test running.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此类命令将在我们想要自动化测试运行时派上用场。
- en: Implementing requirements with TDD
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TDD实现需求
- en: Before writing any code, it makes sense that we understand some terminologies
    and conventions to tune our brain on unit test-related keywords. So, we will briefly
    touch on **system under test** (**SUT**), **red/green** tests, and **Arrange-Act-Assert**
    (**AAA**). More details on these terminologies will follow in later chapters,
    but for now, we will cover the minimum to get a few tests running.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，理解一些术语和约定来调整我们的思维，关注单元测试相关的关键词是有意义的。因此，我们将简要介绍**系统测试对象**（**SUT**）、**红/绿测试**和**安排-行动-断言**（**AAA**）。这些术语的更多细节将在后面的章节中介绍，但现在我们将介绍运行几个测试所需的最小内容。
- en: While we are learning about terminology and conventions, we will ease into our
    implementation. One thing that you might find new or unordinary is writing a unit
    test first, then writing production code later. This is one main aspect of TDD,
    and you will first experience it in this section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习术语和约定时，我们将逐步进入实现。你可能发现的一个新或不寻常的地方是先编写单元测试，然后编写生产代码。这是TDD的一个主要方面，你将在本节中首次体验它。
- en: SUT
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SUT
- en: 'We refer to the code that you usually write to build a product as **production
    code**. Typical **object-oriented** (**OO**) production code looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常编写的用于构建产品的代码称为**生产代码**。典型的**面向对象**（**OO**）生产代码看起来像这样：
- en: '[PRE8]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we test this code, the unit test will call `MethodName` and assess the
    behavior of this method. When `MethodName` is executed, it may call other parts
    of the class and may use/call other classes. The code executed by `MethodName`
    is called SUT or **code under test** (**CUT**). However, the term *SUT* is used
    more often.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试这段代码时，单元测试将调用`MethodName`并评估该方法的性能。当`MethodName`执行时，它可能会调用类的其他部分，并可能使用/调用其他类。由`MethodName`执行的代码被称为SUT或**待测试代码**（**CUT**）。然而，*SUT*这个术语使用得更频繁。
- en: 'The SUT will have an entry point that will be executed by the unit tests. The
    entry point is usually the method that we are calling from the unit tests. The
    following screenshot should clarify the idea of a SUT and a SUT entry point:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: SUT将有一个入口点，该入口点将由单元测试执行。入口点通常是我们在单元测试中调用的方法。以下截图应该可以阐明SUT和SUT入口点的概念：
- en: '![Figure 1.14 – Unit tests operating on a SUT ](img/Figure_1.14_B18370.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图1.14 – 在SUT上运行的单元测试](img/Figure_1.14_B18370.jpg)'
- en: Figure 1.14 – Unit tests operating on a SUT
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 在SUT上运行的单元测试
- en: In the previous screenshot, you can see multiple unit tests calling the same
    SUT entry point. A detailed discussion of SUT is available in [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066),
    *Getting Started with Unit Testing*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图，你可以看到多个单元测试调用相同的SUT入口点。关于SUT的详细讨论可以在[*第3章*](B18370_03.xhtml#_idTextAnchor066)，*开始单元测试*中找到。
- en: Testing class
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试类
- en: 'A typical unit testing class uses the same names from the SUT, by convention.
    This is what a typical unit testing class looks like:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的单元测试类使用来自SUT的相同名称，这是约定俗成的。典型的单元测试类看起来是这样的：
- en: '[PRE9]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the `ClassName` and `MethodName` methods in the two previous snippets
    are not a coincidence. We want them to be the same, again, by convention. To start
    forming our test class, we need to design the class name and the method name.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在前两个代码片段中的`ClassName`和`MethodName`方法并不是巧合。我们希望它们通过约定保持一致。为了开始构建我们的测试类，我们需要设计类名和方法名。
- en: Class name
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类名
- en: From the requirements, we will need a class that will contain all our division
    methods, so let’s simply call the class `Division`; and if we were to create a
    unit test class to test the `Division` class, our unit test name would be called
    `DivisionTests`. Next, we will rename the `UnitTest1` class `DivisionTests` and
    rename the file as well so that it appears as `DivisionTests.cs`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从需求中，我们需要一个包含所有我们的除法方法的类，所以我们可以简单地将其命名为`Division`；如果我们创建一个用于测试`Division`类的单元测试类，我们的单元测试名称将是`DivisionTests`。接下来，我们将`UnitTest1`类重命名为`DivisionTests`，并将文件名也相应地更改为`DivisionTests.cs`。
- en: Tip
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can set your text cursor anywhere within the class name in the source code
    (in the previous case, it was `UnitTest1`) and hit *Ctrl* + *R*, *R* (hold *Ctrl*
    then press *R* quickly twice). Type the new name `DivisionTests` and hit *Enter*.
    This will also rename the file if the **Rename symbol’s file** checkbox is ticked.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在源代码中的类名（在上一个例子中是`UnitTest1`）的任何位置设置你的文本光标，然后按*Ctrl* + *R*，*R*（按住*Ctrl*然后快速连续按两次*R*）。输入新名称`DivisionTests`并按*Enter*。如果勾选了**重命名符号的文件**复选框，这也会重命名文件。
- en: Method name
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法名
- en: Luckily, the requirements are simple, so our method name will simply be `Divide`.
    `Divide` will be accepting two integer (`int32`) arguments, per the requirements,
    and returns a `decimal` value. We will go ahead and refactor our existing unit
    test from `Test1` to `Divide_Condition1_Expectation1`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，要求很简单，所以我们的方法名将简单地是 `Divide`。根据要求，`Divide` 将接受两个整数（`int32`）参数，并返回一个 `decimal`
    值。我们将继续重构我们的现有单元测试，从 `Test1` 更改为 `Divide_Condition1_Expectation1`。
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Arithmetic terminology-naming reminder**: If we have 10 / 5 = 2, then 10
    is the dividend, 5 is the divisor, and 2 is the quotient.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**算术术语命名提示**：如果我们有 10 / 5 = 2，那么 10 是被除数，5 是除数，2 是商。'
- en: Conditions and expectations
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件和期望
- en: When we test, we are setting a condition and defining what we expect when this
    condition is met. We start with the *core case*, also known as the *positive path*
    or the *happy path*. We finish all the positive paths first before going to other
    cases. Our mission in unit tests boils down to determining the condition and its
    expectation and having a unit test for every combination.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试时，我们设置一个条件并定义当这个条件满足时我们期望什么。我们首先从 *核心情况* 开始，也称为 *正向路径* 或 *快乐路径*。在处理其他情况之前，我们首先完成所有正向路径。我们的单元测试任务归结为确定条件和它的期望，并为每一种组合编写一个单元测试。
- en: 'To show the relationship between the method we are testing (the method in our
    SUT) and the associated condition and expectation, we will employ a well-used
    convention, as illustrated in the following code snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们正在测试的方法（我们的系统单元中的方法）与相关条件和期望之间的关系，我们将采用一个常用的约定，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are random examples of unit test method names to familiarize you with
    the previous convention:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些单元测试方法名的随机示例，以帮助您熟悉之前的约定：
- en: '`SaveUserDetails_MissingEmailAddress_EmailIsMissing`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SaveUserDetails_MissingEmailAddress_EmailIsMissing`'
- en: '`ValidateUserCredentials_HashedPasswordDoesntMatch_False`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValidateUserCredentials_HashedPasswordDoesntMatch_False`'
- en: '`GetUserById_IdDoesntExist_UserNotFoundException`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetUserById_IdDoesntExist_UserNotFoundException`'
- en: We will see more examples while designing our unit tests.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计我们的单元测试时，我们将看到更多示例。
- en: 'The core requirement is dividing two integers. The straightforward and simplest
    implementation is dividing two divisible integers and getting back a whole number.
    Our condition is *divisible integers* and we expect a *whole number*. Now, we
    should update the signature of our unit test to  `Divide_DivisibleIntegers_WholeNumber`
    and write the body of the test method, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 核心要求是除以两个整数。最直接和最简单的实现是除以可除整数并得到一个整数。我们的条件是 *可除整数*，我们期望得到一个 *整数*。现在，我们应该更新单元测试的签名为
    `Divide_DivisibleIntegers_WholeNumber` 并编写测试方法的主体，如下所示：
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code doesn’t compile as the `Division` class doesn’t exist at this stage,
    and we know that already as we have a squiggly line under `Division`. This is
    one of the rare occasions where not being able to compile due to a missing class
    is good. This indicates that our *test has failed*, which is also good!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码无法编译，因为在这个阶段 `Division` 类不存在，我们已知这一点，因为我们在 `Division` 下有一个波浪线。这是少数几个由于缺少类而无法编译的情况之一，这种情况是好的。这表明我们的
    *测试失败了*，这也是好的！
- en: While it does look silly that the test has failed because the code doesn’t compile
    as the `Division` SUT class is missing, this means that there is no SUT code yet.
    In [*Chapter 5*](B18370_05.xhtml#_idTextAnchor114), *Test-Driven Development Explained*,
    we will understand the reason behind considering the no-compilation case.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试失败看起来很愚蠢，因为代码无法编译，因为 `Division` 系统单元类缺失，但这意味着还没有 SUT 代码。在 [*第5章*](B18370_05.xhtml#_idTextAnchor114)，*测试驱动开发解释*
    中，我们将了解考虑无编译情况的原因。
- en: '`Assert` is a class from the xUnit library. The `Equal` static method has many
    overloads, one of which we are using here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert` 是 xUnit 库中的一个类。`Equal` 静态方法有很多重载，其中之一我们在这里使用：'
- en: '[PRE12]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When run, this method will flag to the xUnit framework if what we expect and
    what we’ve actually got are equal. When we run this test, if the result of this
    assertion is `true`, then the test has passed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此方法时，如果我们所期望的和实际得到的是相等的，它将向 xUnit 框架标记。当我们运行这个测试时，如果这个断言的结果是 `true`，那么测试就通过了。
- en: Red/green
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红色/绿色
- en: Failure is what we were looking for. In later chapters, we will discuss why.
    For now, it is sufficient to know that we need to start with a failed build (compilation)
    or failed test (failed assertion), then change that to a passed one. The fail/pass
    is also known as the **red/green refactor technique**, which mimics the idea of
    *bad/good* and *stop/go*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 失败正是我们所寻求的。在后续章节中，我们将讨论其原因。目前，只需知道我们需要从一个失败的构建（编译）或失败的测试（失败的断言）开始，然后将其更改为通过的状态。失败/通过也被称为**红/绿重构技术**，它模仿了**坏/好**和**停止/继续**的概念。
- en: 'We need to add the `Division` class and the `Divide` method and write the minimal
    code to make the test pass. Create a new file called `Division.cs` in the `Uqs.Arithmetic`
    project, like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加 `Division` 类和 `Divide` 方法，并编写最小化代码以使测试通过。在 `Uqs.Arithmetic` 项目中创建一个名为
    `Division.cs` 的新文件，如下所示：
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can create a class by placing the text cursor anywhere within the class
    name (in the previous case, it was `Division`) and hitting *Ctrl* + *.* (hold
    down the *Ctrl* key and then press *.*). Select `Uqs.Arithmetic`, and then hit
    `Divide` and hit *Ctrl* + *.*, select `Division` ready for your code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将文本光标放在类名（在之前的例子中是 `Division`）内的任何位置，然后按 *Ctrl* + *.*（按住 *Ctrl* 键然后按 *.*）来创建一个类。选择
    `Uqs.Arithmetic`，然后按 `Divide` 并按 *Ctrl* + *.*，选择 `Division` 准备编写你的代码。
- en: It is important to remember that *dividing two integers in C# will return an
    integer*. I have seen senior developers fail to remember this, which led to bad
    consequences. In the code that we implemented, we have only covered the integers
    division that will yield a whole quotient. This should satisfy our test.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在 C# 中，**除以两个整数将返回一个整数**。我见过一些资深开发者忘记这一点，这导致了不良后果。在我们实现的代码中，我们只涵盖了会产生整数商的整数除法。这应该能满足我们的测试。
- en: 'We are now ready to run our test with Test Explorer, so hit *Ctrl* + *R*, *A*,
    which will build your projects, then run all the tests (currently one test). You’ll
    notice that Test Explorer indicates green, and there is a green bullet with a
    tick mark between the test name and the `Fact` attribute. When clicked, it will
    show you some testing-related options, as illustrated in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用测试资源管理器运行我们的测试，所以按 *Ctrl* + *R*，*A*，这将构建你的项目，然后运行所有测试（目前有一个测试）。你会注意到测试资源管理器指示绿色，并且在测试名称和
    `Fact` 属性之间有一个带有勾号的绿色项目符号。点击它将显示一些与测试相关的选项，如下面的截图所示：
- en: '![Figure 1.15 – VS unit testing balloon ](img/Figure_1.15_B18370.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15 – VS 单元测试气球](img/Figure_1.15_B18370.jpg)'
- en: Figure 1.15 – VS unit testing balloon
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – VS 单元测试气球
- en: For the sake of completion, the full concept name is **red/green/refactor**,
    but we won’t be explaining the **refactor** bit here and will leave this for [*Chapter
    5*](B18370_05.xhtml#_idTextAnchor114), *Test-Driven Development Explained*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，完整的概念名称是 **红/绿/重构**，但在这里我们不会解释 **重构** 部分，并将这部分内容留到 [*第 5 章*](B18370_05.xhtml#_idTextAnchor114)，“测试驱动开发解释”中。
- en: The AAA pattern
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AAA 模式
- en: Unit testing practitioners noticed that test code format falls into a certain
    structure pattern. First, we declare some variables and do some preparations.
    This stage is called **Arrange**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试实践者注意到测试代码格式符合某种结构模式。首先，我们声明一些变量并做一些准备工作。这个阶段被称为 **Arrange**。
- en: The second stage is when we invoke the SUT. In the previous test, it was the
    line on which we called the `Divide` method. This stage is called **Act**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段是我们调用 SUT（系统单元）。在前面的测试中，这是调用 `Divide` 方法的行。这个阶段被称为 **Act**。
- en: The third stage is where we validate our assumption—this is where we have the
    `Assert` class being used. This stage is, not surprisingly, called **Assert**.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段是我们验证我们的假设——这是使用 `Assert` 类的地方。不出所料，这个阶段被称为 **Assert**。
- en: 'Developers usually divide each unit test with comments to denote these three
    stages, so if we apply this to our previous unit test, the method would look like
    this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常用注释将每个单元测试分成三个阶段，所以如果我们将这一点应用到我们之前的单元测试中，方法看起来会是这样：
- en: '[PRE14]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can learn more about the **AAA** pattern in [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066),
    *Getting Started with Unit Testing*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[*第 3 章*](B18370_03.xhtml#_idTextAnchor066)，“开始单元测试”中了解更多关于 **AAA** 模式的信息。
- en: More tests
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多测试
- en: We haven’t finished implementing the requirements. We need to add them iteratively,
    by adding a new test, checking that it fails, implementing it, then making it
    pass, and then repeating it!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成需求的实现。我们需要通过迭代地添加新测试、检查它失败、实现它、然后使其通过，并重复这一过程来添加它们！
- en: We are going to add a few more tests in the next sections to cover all the requirements,
    and we are also going to add some other tests to increase the quality.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中添加更多测试以覆盖所有要求，并且我们还将添加一些其他测试以提高质量。
- en: Dividing two indivisible numbers
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除以不可除的数
- en: 'We need to cover a case where two numbers are not divisible, so we add another
    unit testing method under the first one, like so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要覆盖一个情况，即两个数不能整除，所以我们就在第一个测试方法下添加另一个单元测试方法，如下所示：
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This unit test method is similar to the previous one, but the name of the method
    has changed to reflect the new condition and expectation. Also, the numbers have
    changed to fit the new condition and expectation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试方法与上一个类似，但方法名已更改以反映新的条件和期望。此外，数字也已更改以适应新的条件和期望。
- en: 'Run the test by employing any of the following methods:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下任何一种方法运行测试：
- en: Clicking the blue bullet that appears below `Fact`, then clicking **Run**
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击出现在 `Fact` 下方蓝色的子弹，然后点击 **运行**
- en: Opening `test name` code, and clicking the **Run** button
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开 `测试名称` 代码，并点击 **运行** 按钮
- en: Pressing *Ctrl* + *R*, *A*, which will run all tests
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下 *Ctrl* + *R*, *A*，这将运行所有测试
- en: 'You will notice that the test will fail—this is good! We have not implemented
    the division that will yield a decimal yet. We can go ahead and do it now, as
    follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现测试会失败——这是好事！我们还没有实现会产生小数的除法。现在我们可以继续这样做，如下所示：
- en: '[PRE16]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Dividing two integers in C# will return an integer, but dividing a decimal by
    an integer returns a decimal, therefore you almost always have to cast the dividend
    or the divisor—or both—to a decimal.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，除以两个整数将返回一个整数，但除以一个整数将返回一个小数，因此你几乎总是必须将除数或被除数（或两者）转换为小数。
- en: Run the test again, and this time it should pass.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，这次应该会通过。
- en: Division-by-zero test
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除以零测试
- en: 'Yes—bad things happen when you divide by zero. Let’s check whether our code
    can handle this, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——除以零会发生坏事。让我们检查我们的代码是否可以处理这种情况，如下所示：
- en: '[PRE17]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Record` class is another member of the xUnit framework. The `Exception`
    method records whether the SUT has raised any `Exception` object and returns `null`
    if there is none. This is the method’s signature:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record` 类是 xUnit 框架的另一个成员。`Exception` 方法记录 SUT 是否抛出了任何 `Exception` 对象，如果没有，则返回
    `null`。这是该方法签名：'
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`IsType` is a method that compares the class type between the angle brackets
    to the class type of the object that we passed as an argument, as illustrated
    in the following code snippet:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsType` 是一个方法，它比较尖括号内的类类型与作为参数传递的对象的类类型，如下面的代码片段所示：'
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When you run this test, it will pass! My first impression would be one of suspicion.
    The problem is that when it passes without writing explicit code, we don’t know
    yet whether this is a true or a coincidental pass—a false positive. There are
    many ways to validate whether this pass is incidental; the quickest way—for now—is
    to debug the code of `Divide_ZeroDivisor_DivideByZeroException`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个测试时，它会通过！我的第一印象可能是怀疑。问题是，在没有编写显式代码的情况下通过，我们还不知道这是否是一个真正的或偶然的通过——一个假阳性。有许多方法可以验证这个通过是否是偶然的；目前最快的方法是调试
    `Divide_ZeroDivisor_DivideByZeroException` 的代码。
- en: 'Click the **Test Bullet**, and then click the **Debug** link, as illustrated
    in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **测试子弹**，然后点击 **调试** 链接，如下面的截图所示：
- en: '![Figure 1.16 – The Debug option in the unit testing balloon ](img/Figure_1.16_B18370.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16 – 单元测试气球中的调试选项](img/Figure_1.16_B18370.jpg)'
- en: Figure 1.16 – The Debug option in the unit testing balloon
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 单元测试气球中的调试选项
- en: 'You will hit the exception directly, as illustrated in the following screenshot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你将直接遇到异常，如下面的截图所示：
- en: '![Figure 1.17 – Exception dialog ](img/Figure_1.17_B18370.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17 – 异常对话框](img/Figure_1.17_B18370.jpg)'
- en: Figure 1.17 – Exception dialog
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 异常对话框
- en: You’ll notice that the exception is happening at the right place at the division
    line, so this is what we actually wanted. While this method violated our initial
    attempt of red/green, having a pass immediately is still a genuine case that you
    would encounter in day-to-day coding.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到异常确实发生在除法线上，这正是我们想要的。虽然这种方法违反了我们最初的红色/绿色尝试，但立即通过仍然是一个你在日常编码中会遇到的真实案例。
- en: Testing extremes
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试极端情况
- en: The story did not mention testing the extremes, but as a developer, you know
    that most software bugs come from **edge cases**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 故事中没有提到测试极端情况，但作为一个开发者，你知道大多数软件错误都来自**边缘情况**。
- en: You want to build more confidence in your existing code, and you want to make
    sure that it can handle extremes well, as you’d expect it to.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望对自己的现有代码更有信心，并确保它能够很好地处理极端情况，正如你所期望的那样。
- en: 'The extreme values of an `int` data type can be obtained by these two constant
    fields of `int`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`数据类型的极端值可以通过`int`的这两个常量字段获得：'
- en: '`int.MaxValue` = ![](img/Formula_1.1_B18370.png)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int.MaxValue` = ![公式1.1](img/Formula_1.1_B18370.png)'
- en: '`int.MinValue` = ![](img/Formula_1.2_B18370.png)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int.MinValue` = ![公式1.2](img/Formula_1.2_B18370.png)'
- en: 'What we need to do is to test the following cases (note that we will only test
    for 12 decimal digits):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试以下情况（请注意，我们只测试到12位小数）：
- en: '`int.MaxValue / int.MinValue = -0.999999999534  `'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int.MaxValue / int.MinValue = -0.999999999534  `'
- en: '`(-int.MaxValue) / int.MinValue = 0.999999999534`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(-int.MaxValue) / int.MinValue = 0.999999999534`'
- en: '`int.MinValue / int.MaxValue = -1.000000000466`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int.MinValue / int.MaxValue = -1.000000000466`'
- en: '`int.MinValue / (-int.MaxValue) = 1.000000000466`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int.MinValue / (-int.MaxValue) = 1.000000000466`'
- en: 'So, we will need four unit tests to cover each case. However, there is a trick
    available in most unit test frameworks, including xUnit. We don’t have to write
    four unit tests—we can do this instead:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要四个单元测试来覆盖每个情况。然而，大多数单元测试框架，包括xUnit，都有一个技巧。我们不必编写四个单元测试——我们可以这样做：
- en: '[PRE20]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that now we have `Theory` rather than `Fact`. This is xUnit’s way of
    declaring that the unit test method is parametrized. Also, notice that we have
    four `InlineData` attributes; as you will have already figured out, each one of
    them corresponds to a test case.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在我们有`Theory`而不是`Fact`。这是xUnit声明单元测试方法是参数化的方式。此外，注意我们有四个`InlineData`属性；正如你可能会已经想到的，每个属性都对应一个测试用例。
- en: 'Our unit test method and the `InlineData` attributes have three parameters.
    When running the unit tests, each parameter will map to the corresponding unit
    test method’s parameter in the same order. The following screenshot shows how
    each parameter in the `InlineData` attribute corresponds to a parameter in the
    `Divide_ExtremeInput_CorrectCalculation` method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试方法和`InlineData`属性有三个参数。在运行单元测试时，每个参数将映射到相同顺序的单元测试方法的参数。以下截图显示了`InlineData`属性中的每个参数如何对应到`Divide_ExtremeInput_CorrectCalculation`方法中的参数：
- en: '![Figure 1.18 – InlineData parameters are mapped to the decorated method parameters
    ](img/Figure_1.18_B18370.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图1.18 – InlineData参数映射到装饰方法参数](img/Figure_1.18_B18370.jpg)'
- en: Figure 1.18 – InlineData parameters are mapped to the decorated method parameters
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18 – InlineData参数映射到装饰方法参数
- en: 'For assertion, we are using an overload of the `Equal` method that supports
    decimal **precision**, as illustrated in the following code snippet:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于断言，我们使用支持十进制**精度**的`Equal`方法的重载，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the tests, and you’ll notice that Test Explorer treats the four attributes
    as separate tests, as depicted in the following screenshot:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，你会注意到测试资源管理器将这四个属性视为单独的测试，如下面的截图所示：
- en: '![Figure 1.19 – VS Test Explorer showing grouped tests ](img/Figure_1.19_B18370.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图1.19 – VS测试资源管理器显示分组测试](img/Figure_1.19_B18370.jpg)'
- en: Figure 1.19 – VS Test Explorer showing grouped tests
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.19 – VS测试资源管理器显示分组测试
- en: Even More Tests
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 更多测试
- en: For brevity, and given that this chapter is a limited introduction, we didn’t
    explore all possible testing scenarios—take, for example, `int.MaxValue/int.MaxValue`,
    `int.MinValue/int.MinValue`, `0/number`, and `0/0`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，鉴于本章是一个有限的介绍，我们没有探索所有可能的测试场景——例如，`int.MaxValue/int.MaxValue`、`int.MinValue/int.MinValue`、`0/number`
    和 `0/0`。
- en: The limits of the required tests are going to be discussed in later chapters,
    along with their pros and cons.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所需测试的范围将在后面的章节中讨论，包括它们的优缺点。
- en: Writing tests before writing the code is not to every developer’s taste and
    might look unintuitive at the beginning, but you have a complete book to make
    you decide for yourself. In [*Chapter 5*](B18370_05.xhtml#_idTextAnchor114), *Test-Driven
    Development Explained*, you will dig deeper into implementation and best practices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前编写测试并不是每个开发者的喜好，并且一开始可能看起来不太直观，但你有完整的一本书来让你自己做出决定。在[*第5章*](B18370_05.xhtml#_idTextAnchor114)《测试驱动开发详解》中，你将更深入地了解实现和最佳实践。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While this chapter is meant for a quick implementation, I trust you did have
    a taste of what TDD is and picked up some skills, such as *xUnit*, *Test Explorer*,
    *test first*, *red/green*, and a few conventions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章旨在快速实现，但我相信你已经尝到了TDD的滋味，并掌握了一些技能，例如*xUnit*、*测试资源管理器*、*先测试后编码*、*红/绿*和一些约定。
- en: For a start, we have picked easy examples—of course—so, we have got no **dependency
    injection** (**DI**), nor mocking or anything fancy, because the stimulating stuff
    is coming next. So, I hope this chapter has made you excited about the rest of
    the book.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择了简单的例子——当然——因此，我们没有涉及**依赖注入**（**DI**），也没有模拟或其他复杂的东西，因为刺激的内容将在下一章出现。所以，我希望这一章已经让你对本书的其余部分感到兴奋。
- en: 'If you are like me when I first encountered TDD, you might be wondering the
    following: *Why test first?* *Isn’t this too much unit testing code?* *Is unit
    testing effective?* *What is the difference between unit testing and TDD?* *How
    many tests should I write?* You may have other questions too—these will be answered
    gradually while you progress through the book, and I promise I will make the answers
    as clear as possible.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我第一次遇到TDD时一样，可能会想知道以下问题：*为什么先进行测试？* *这不是单元测试代码太多吗？* *单元测试有效吗？* *单元测试和TDD有什么区别？*
    *我应该写多少个测试？* 你可能还有其他问题——这些问题的答案将在你阅读本书的过程中逐渐揭晓，我保证我会尽可能清晰地给出答案。
- en: In the next chapter, we will touch on a design pattern called DI, which is an
    essential requirement for working with TDD.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涉及一个名为DI的设计模式，这是使用TDD（测试驱动开发）的必要要求。
- en: Further reading
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解更多关于本章讨论的主题，你可以参考以下链接：
- en: 'Class libraries: [https://docs.microsoft.com/en-us/dotnet/standard/class-libraries](https://docs.microsoft.com/en-us/dotnet/standard/class-libraries)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类库: [https://docs.microsoft.com/en-us/dotnet/standard/class-libraries](https://docs.microsoft.com/en-us/dotnet/standard/class-libraries)'
- en: 'xUnit: [https://xunit.net/](https://xunit.net/)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'xUnit: [https://xunit.net/](https://xunit.net/)'
