- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: AR Development in Unity
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity中的AR开发
- en: In this chapter, we will immerse ourselves in the fascinating realm of AR development,
    from creating our first AR project in Unity to launching our first AR scene on
    a device or simulator. We will present to you numerous AR toolkits and plugins
    that Unity offers, and guide you in understanding their unique functionalities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将沉浸在AR开发的迷人领域，从在Unity中创建我们的第一个AR项目到在设备或模拟器上启动我们的第一个AR场景。我们将向您介绍Unity提供的众多AR工具包和插件，并指导您了解它们的独特功能。
- en: In a step-by-step manner, we will walk through the process of establishing an
    AR project in Unity, ensuring it is primed for smooth deployment onto any AR-supportive
    device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步讲解在Unity中建立AR项目的过程，确保它为顺利部署到任何支持AR的设备做好准备。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the AR landscape
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解AR领域
- en: Setting up an AR project in Unity using AR Foundation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AR Foundation在Unity中设置AR项目
- en: Testing AR experiences directly in Unity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中直接测试AR体验
- en: Deploying AR experiences onto mobile devices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将AR体验部署到移动设备上
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we dive into the practicality of the Unity Editor, it’s important to
    ensure your computer system is up to the task. *Unity 2021.3 LTS*, or a more recent
    version, is required to walk through the exercises that we’ll explore in this
    book. Check your hardware compatibility by comparing it with the system requirements
    provided on the Unity website at [https://docs.unity3d.com/Manual/system-requirements.html](https://docs.unity3d.com/Manual/system-requirements.html).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨Unity编辑器的实用性之前，确保您的计算机系统能够胜任这项任务是非常重要的。需要**Unity 2021.3 LTS**或更高版本，才能完成本书中将要探索的练习。通过比较Unity网站上提供的系统要求来检查您的硬件兼容性，网址为[https://docs.unity3d.com/Manual/system-requirements.html](https://docs.unity3d.com/Manual/system-requirements.html)。
- en: As we’ll be exploring AR development in this chapter, we will need either an
    Android or iOS device capable of supporting ARKit or ARCore. Review whether your
    device meets these requirements at [https://developers.google.com/ar/devices](https://developers.google.com/ar/devices).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在本章中探索AR开发，我们需要一个能够支持ARKit或ARCore的Android或iOS设备。请查看您的设备是否满足这些要求，网址为[https://developers.google.com/ar/devices](https://developers.google.com/ar/devices)。
- en: Understanding the AR landscape
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解AR领域
- en: As we start our exploration of AR, it’s crucial to first understand the foundational
    elements that enable this technology. How is it that our everyday devices can
    so effortlessly intertwine our physical reality with the digital? What mechanisms
    allow your device to sense, interpret, and interact with the world around it?
    And, perhaps most intriguingly, how can a simple screen transform into a doorway
    to an enhanced reality?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始探索AR时，首先理解使这项技术成为可能的基础元素至关重要。我们的日常设备是如何如此轻松地将我们的物理现实与数字世界交织在一起的？是什么机制允许您的设备感知、解释和与周围的世界互动？也许最引人入胜的是，一个简单的屏幕如何变成通往增强现实的大门？
- en: In this section, we aim to unpack the complex principles and mechanisms of AR,
    distilling them into a comprehensible format.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的目标是解开AR的复杂原理和机制，将它们提炼成易于理解的形式。
- en: If terms such as AR, MR, and VR still seem opaque or interchangeable to you,
    consider revisiting [*Chapter 1*](B20869_01.xhtml#_idTextAnchor000) for clarification.
    For now, our focus remains on AR, which transforms our world by superimposing
    it with elements of the digital domain. Let’s look at the different types of experiences
    that AR offers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AR、MR和VR等术语对您来说仍然模糊不清或可以互换，请考虑回顾[*第1章*](B20869_01.xhtml#_idTextAnchor000)以获得澄清。现在，我们的重点仍然是AR，它通过叠加数字域的元素来改变我们的世界。让我们看看AR提供的不同类型体验。
- en: What types of AR experiences exist?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在哪些类型的AR体验？
- en: 'The AR landscape is diverse, with experiences typically presenting themselves
    through one of several mediums: handheld mobile AR, AR glasses, or other types
    of AR such as projection-based AR or spatial AR. Each form has its unique characteristics,
    and their utilization depends on the context and the level of immersion desired.
    Let’s learn more about these:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AR领域是多样化的，体验通常通过以下几种媒介之一呈现：手持移动AR、AR眼镜或其他类型的AR，如基于投影的AR或空间AR。每种形式都有其独特的特点，其应用取决于上下文和所需的沉浸程度。让我们了解更多关于这些的信息：
- en: '**Handheld mobile AR**: Handheld mobile AR is perhaps the most widespread form
    of AR due to the ubiquity of smartphones. Imagine this type of AR as a window
    into an enriched reality. Through the screen of their smartphone or tablet, a
    user witnesses a mingling of the digital and the real. This overlay of digital
    content on a live camera feed breathes life into an otherwise static physical
    world. A prime example of this is the popular game *Pokémon Go*, where the user
    hunts for digital creatures that seem to inhabit our own world.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手持移动增强现实**：手持移动增强现实可能是最普遍的增强现实形式，因为智能手机的普及。想象一下这种类型的增强现实就像是一个通向丰富现实的窗口。通过智能手机或平板电脑的屏幕，用户见证了数字和现实的交织。这种数字内容叠加在实时摄像头流上的做法为原本静态的物理世界注入了活力。这一点的典型例子是流行的游戏*宝可梦GO*，其中用户在看似居住在我们自己世界中的数字生物中狩猎。'
- en: '**AR glasses**: AR glasses, on the other hand, provide a more immersive and
    hands-free AR experience. When the user dons these glasses, they step directly
    into an augmented world without the need for a separate device. Thanks to transparent
    displays, sensors, and cameras integrated into the glasses, digital information
    is seamlessly woven into the user’s field of view. The implications of this technology
    are far-reaching, with potential applications in industries ranging from manufacturing
    and healthcare to entertainment. An example of a game designed for AR glasses
    is a new iteration of the Pokémon Go game, aptly named *Pokémon Go AR+*. Pokémon
    Go AR+ revolutionizes the original concept of the game, taking full advantage
    of AR glasses’ capabilities. When wearing AR glasses, players are immersed in
    the Pokémon world more deeply. They can see Pokémon in their real-world surroundings
    as if they were actually there. Pokéstops and Gyms are visible in real-world locations,
    and players can interact with them directly. For example, if a Pokémon appears,
    the player can reach out to touch it and initiate a catch sequence. The game also
    allows for real-time battle simulations with other players using the AR environment.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强现实眼镜**：另一方面，增强现实眼镜提供了一种更沉浸式和无手操作的增强现实体验。当用户戴上这些眼镜时，他们直接进入一个增强世界，无需额外的设备。得益于眼镜中集成的透明显示屏、传感器和摄像头，数字信息无缝地融入用户的视野。这项技术的意义深远，潜在应用范围广泛，从制造业和医疗保健到娱乐行业。专为增强现实眼镜设计的游戏示例是名为*宝可梦GO
    AR+*的新版本游戏。宝可梦GO AR+彻底改变了游戏的原有概念，充分利用了增强现实眼镜的功能。当佩戴增强现实眼镜时，玩家可以更深入地沉浸在宝可梦世界中。他们可以看到在现实世界环境中的宝可梦，就像它们真的在那里一样。宝可梦站和道馆在现实世界的位置可见，玩家可以直接与之互动。例如，如果出现宝可梦，玩家可以伸手触摸它并启动捕捉序列。游戏还允许使用增强现实环境与其他玩家进行实时战斗模拟。'
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Though both handheld mobile AR and AR glasses act as pathways to AR, they differ
    significantly in their form factor, user experience, and level of immersion. Mobile
    AR serves as a portable gateway to an augmented world, accessible through a user’s
    smartphone or tablet. On the other hand, AR glasses offer a fully immersive experience
    where the augmented world is in direct view. Given the prevalence of smartphones,
    this book will primarily focus on AR development for Android and iOS handheld
    devices.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管手持移动增强现实和增强现实眼镜都作为进入增强现实的途径，但它们在形态、用户体验和沉浸程度方面存在显著差异。移动增强现实作为通向增强世界的便携式门户，可以通过用户的智能手机或平板电脑访问。另一方面，增强现实眼镜提供了一种完全沉浸式的体验，其中增强世界直接呈现在用户的视野中。鉴于智能手机的普及，本书将主要关注Android和iOS手持设备的增强现实开发。
- en: This does not mean, however, that AR glasses lack potential or usage. The focus
    on handheld devices mainly reflects their current wider use and accessibility.
    Despite this, AR glasses present significant opportunities and a level of immersion
    that handheld devices can’t match. Even though the book focuses on handheld AR,
    the fundamental principles of AR development it covers, such as understanding
    the 3D space, user interaction, and user experience design, are largely applicable
    to AR glasses. Readers interested in AR glasses development can still gain valuable
    insights, though they might need to supplement their learning with additional
    resources specifically focused on AR glasses technologies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着增强现实眼镜缺乏潜力或用途。对手持设备的关注主要反映了它们当前的更广泛使用和可及性。尽管如此，增强现实眼镜提供了手持设备无法比拟的显著机会和沉浸程度。尽管本书专注于手持增强现实，但它涵盖的增强现实开发的基本原则，如理解三维空间、用户交互和用户体验设计，在很大程度上也适用于增强现实眼镜。对增强现实眼镜开发感兴趣的读者仍然可以从中获得宝贵的见解，尽管他们可能需要通过专注于增强现实眼镜技术的额外资源来补充他们的学习。
- en: '**Projection-based AR**: Projection-based AR casts digital imagery onto real-world
    surfaces. A notable application of projection-based AR is found in the automotive
    industry, where AR has started to make a significant impact. Information such
    as navigation, speed, and other essential data can be projected onto the vehicle’s
    windshield, providing real-time visual cues to the driver without the need to
    take their eyes off the road.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于投影的AR**：基于投影的AR将数字图像投射到现实世界的表面上。基于投影的AR在汽车行业中有显著的应用，其中AR已经开始产生重大影响。如导航、速度和其他重要数据等信息可以投射到车辆的挡风玻璃上，为驾驶员提供实时视觉提示，而无需他们离开路面。'
- en: '**Spatial AR**: Spatial AR uses holographic displays to create an illusion
    of virtual objects cohabitating in our physical environment. Holographic displays
    could be likened to digital mirages, using a combination of light projection and
    optics to create three-dimensional virtual objects that appear to float in space.
    This form of AR doesn’t necessitate additional devices or wearables, enabling
    the user to interact with the holograms as if they were physically present.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间AR**：空间AR使用全息显示屏来创造虚拟对象与我们的物理环境共存的错觉。全息显示屏可以比作数字海市蜃楼，通过结合光投影和光学技术来创建三维虚拟对象，使其看起来像在空间中漂浮。这种形式的AR不需要额外的设备或可穿戴设备，使用户能够像它们物理存在一样与全息图进行交互。'
- en: Having explored the types of AR experiences, let’s now delve into the techniques
    and concepts that enable the overlay of virtual objects in the real world.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了AR体验的类型之后，我们现在将深入研究使虚拟对象在现实世界中叠加的技术和概念。
- en: What are marker-based and markerless AR?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是基于标记和无标记AR？
- en: AR is underpinned by a set of foundational principles that allow virtual objects
    to be accurately positioned and realistically interacted with in our physical
    world. These principles involve various technologies and techniques, such as **marker-based
    AR** and **markerless AR**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: AR建立在一系列基础原则上，这些原则允许虚拟对象在我们的物理世界中准确定位并实现真实交互。这些原则涉及各种技术和方法，例如**基于标记的AR**和**无标记AR**。
- en: Let’s now learn more about each of these technologies.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在更深入地了解这些技术。
- en: Marker-based AR
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于标记的AR
- en: Marker-based AR depends on specific markers or targets to initiate the display
    of AR content. These markers can take numerous forms, such as physical objects
    with identifiable patterns, QR codes, or images. When the AR system detects the
    marker, it overlays digital content onto it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于标记的AR依赖于特定的标记或目标来启动AR内容的显示。这些标记可以有多种形式，例如具有可识别图案的物理对象、二维码或图像。当AR系统检测到标记时，它会在其上叠加数字内容。
- en: 'When developing AR applications, there are several types of markers that can
    be used to trigger the display of AR content. Here’s an overview of some commonly
    utilized markers in AR:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发AR应用时，可以使用多种类型的标记来触发AR内容的显示。以下是AR中常用的一些标记的概述：
- en: '**Image markers**: These are distinct visual patterns or images that serve
    as the trigger for AR content. When an AR system detects these markers through
    the camera, it overlays the corresponding digital content onto them.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像标记**：这些是作为AR内容触发器的独特视觉图案或图像。当AR系统通过摄像头检测到这些标记时，它会在其上叠加相应的数字内容。'
- en: '**QR codes**: Quick response (QR) codes, which are two-dimensional barcodes
    containing specific information, can also serve as AR markers. When the camera
    or a QR code scanning library identifies these codes, it can trigger the display
    of certain AR content or interactions.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二维码**：快速响应（QR）码，这是一种包含特定信息的二维条码，也可以作为AR标记。当摄像头或二维码扫描库识别这些代码时，它可以触发显示特定的AR内容或交互。'
- en: '**3D object markers**: These markers involve using specific physical objects
    as triggers for AR content. The AR system identifies the object’s shape and features
    and uses this data to overlay the digital content.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3D对象标记**：这些标记涉及使用特定的物理对象作为AR内容的触发器。AR系统识别对象的形状和特征，并使用这些数据来叠加数字内容。'
- en: '**Location-based markers**: These markers use the user’s geolocation data to
    trigger AR content. By leveraging GPS or other location-tracking technologies,
    the AR system can overlay digital content that is relevant to the user’s current
    location.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于位置的标记器**：这些标记器利用用户的地理位置数据来触发AR内容。通过利用GPS或其他位置跟踪技术，AR系统可以在与用户当前位置相关的数字内容上叠加。'
- en: '**Code-based markers**: These are custom-designed patterns or symbols that
    can be recognized by the AR system and used as triggers. These markers are created
    and decoded using specific algorithms, providing a high degree of flexibility
    and customization for AR experiences.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于代码的标记**：这些是专门设计的图案或符号，可以被AR系统识别并用作触发器。这些标记使用特定的算法创建和解码，为AR体验提供高度的可定制性和灵活性。'
- en: The type of marker to use depends on the specific requirements of your AR application.
    Factors such as the desired user experience, tracking accuracy, and ease of marker
    recognition will guide marker selection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的标记类型取决于你的AR应用的具体要求。如期望的用户体验、跟踪精度和标记识别的简便性等因素将指导标记的选择。
- en: While many AR experiences use markers, not all do, as you will learn in the
    next subsection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多AR体验使用标记，但并非所有都如此，你将在下一小节中了解到。
- en: Markerless AR
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无标记AR
- en: Markerless AR, also known as **position-based AR** or **simultaneous localization
    and mapping** (**SLAM**)-based AR, doesn’t rely on predetermined markers or visual
    cues. It employs onboard sensors and complex algorithms to overlay digital information
    onto the physical world. Sensors can include **global positioning systems** (**GPS**),
    accelerometers, and cameras to ascertain the user’s location and orientation in
    the physical environment. With an understanding of the user’s location, these
    AR systems overlay virtual content onto the physical surroundings based on geographical
    coordinates.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无标记AR，也称为**基于位置的AR**或**同时定位与地图构建**（**SLAM**）-基于AR，不依赖于预定的标记或视觉线索。它使用机载传感器和复杂的算法将数字信息叠加到物理世界中。传感器可以包括**全球定位系统**（**GPS**）、加速度计和摄像头，以确定用户在物理环境中的位置和朝向。了解用户的位置后，这些AR系统根据地理坐标在物理周围叠加虚拟内容。
- en: 'Let’s delve into various options for implementing markerless AR and explore
    their real-world applications:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解实现无标记AR的各种选项，并探索它们的实际应用：
- en: '**Geolocation-based AR**: This approach primarily uses GPS and is suitable
    for placing AR objects on a larger scale in outdoor environments.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于地理位置的AR**：这种方法主要使用GPS，适合在户外环境中将AR对象放置在更大规模的位置。'
- en: An example of this is Niantic’s game Pokémon Go. Using the device’s GPS, the
    game places virtual Pokémon creatures in real-world locations, allowing players
    to find and catch them.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的一个例子是Niantic的游戏《精灵宝可梦GO》。使用设备的GPS，游戏在现实世界中的位置放置虚拟宝可梦生物，允许玩家找到并捕捉它们。
- en: '**Wi-Fi positioning system** (**WPS**): This method determines the device’s
    location based on the strength and origin of Wi-Fi signals. It’s especially relevant
    for indoor AR experiences where GPS may be less effective. For instance, *Indoor
    Atlas* offers a platform for indoor navigation that combines magnetic information
    and Wi-Fi signals. This has been used to enhance AR experiences in shopping malls,
    guiding the user to specific stores or attractions with digital markers.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wi-Fi定位系统**（**WPS**）：这种方法根据Wi-Fi信号强度和来源确定设备的位置。它对于室内AR体验特别相关，因为GPS可能不太有效。例如，*室内地图*提供了一个结合磁性信息和Wi-Fi信号的室内导航平台。这已被用于增强购物中心中的AR体验，使用数字标记引导用户到特定的商店或景点。'
- en: '**Bluetooth** and **ultra-wideband** (**UWB**): These positioning techniques
    are geared for micro-location experiences, providing high precision in smaller
    spaces such as rooms or exhibits. A practical application can be seen in museums
    and galleries, where Bluetooth beacons are used in AR apps. These apps then serve
    multimedia content to visitors based on their proximity to specific artworks or
    exhibits.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝牙**和**超宽带**（**UWB**）：这些定位技术旨在为微定位体验而设计，在较小的空间如房间或展览中提供高精度。一个实际的应用案例可以在博物馆和画廊中看到，在那里蓝牙信标被用于增强现实（AR）应用中。这些应用根据访客与特定艺术品或展览的接近程度，向他们提供多媒体内容。'
- en: '**SLAM**: SLAM is a more advanced technique that creates a digital map of the
    environment while tracking the user’s location. This technique involves complex
    algorithms and uses the device’s camera and other sensors. Imagine you’re in a
    dark room and you light up a flashlight. As you move the flashlight around, you
    start to see and remember where different things are, such as chairs or tables.
    Over time, you build a map in your head of the whole room. SLAM does something
    similar. It’s most suitable for applications that require accurate object placement
    and interaction in smaller spaces.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SLAM（同步定位与建图）**：SLAM是一种更高级的技术，在跟踪用户位置的同时创建环境的数字地图。这项技术涉及复杂的算法，并使用设备的摄像头和其他传感器。想象一下你在一个黑暗的房间里，你打开了一盏手电筒。当你移动手电筒时，你开始看到并记住不同物品的位置，比如椅子或桌子。随着时间的推移，你在脑海中构建了整个房间的地图。SLAM做的是类似的事情。它最适合需要在小空间内准确放置和交互物体的应用。'
- en: An example of SLAM is IKEA’s app, *IKEA Place*. On the app, the user can select
    a piece of furniture from IKEA’s catalog and the app overlays a 3D model of it
    onto the camera view, allowing the user to see how the item would look in their
    home.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这的一个例子是宜家的应用*IKEA Place*。在应用中，用户可以从宜家目录中选择一件家具，应用将3D模型叠加到摄像头视图中，使用户能够看到该物品在家中会是什么样子。
- en: '**Depth sensing**: This involves the use of advanced sensors such as **time-of-flight**
    (**ToF**) or **light detection and ranging** (**LIDAR**) sensors to capture the
    depth information of the surrounding environment. This method allows for more
    accurate placement and occlusion of virtual objects, where digital objects can
    correctly appear behind real-world objects based on depth information.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度感应**：这涉及到使用高级传感器，如**飞行时间**（ToF）或**光探测与测距**（LIDAR）传感器来捕捉周围环境的深度信息。这种方法允许更精确地放置和遮挡虚拟对象，基于深度信息，数字对象可以正确地出现在真实世界物体后面。'
- en: An example of this is Apple’s *ARKit 4.0* platform, which incorporates the **Depth
    API** that leverages the LIDAR scanner available on some iPad and iPhone models.
    Depth API enables more realistic AR experiences. The *Complete Anatomy* app uses
    ARKit’s depth sensing to place a detailed 3D human anatomy model into the real
    world, allowing the user to explore and interact with it as if it were physically
    present. Because of depth sensing, this model won’t accidentally appear halfway
    inside your sofa but will stand correctly beside it.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这的一个例子是苹果的*ARKit 4.0*平台，该平台集成了利用某些iPad和iPhone型号上可用的LIDAR扫描器的**深度API**。深度API使得AR体验更加逼真。《*Complete
    Anatomy*》应用程序使用ARKit的深度感应将详细的3D人体解剖模型放置到现实世界中，使用户能够像它真实存在一样探索和与之交互。由于深度感应，这个模型不会意外地出现在你的沙发中间，而是会正确地站在它旁边。
- en: '**Machine learning and AI**: Recent advances in AI and machine learning have
    opened new possibilities for markerless AR. Machine learning models can be trained
    to recognize different types of environments and objects, providing context for
    more intelligent and interactive AR experiences.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习和人工智能**：人工智能和机器学习的最新进展为无标记增强现实（AR）开辟了新的可能性。机器学习模型可以被训练以识别不同类型的环境和物体，为更智能和互动的AR体验提供上下文。'
- en: An example of this is Google’s *ARCore* platform, which uses machine learning
    to recognize and augment specific objects or types of objects. Google’s *AR Animals*
    feature uses ARCore to let the user search for an animal on Google and then view
    a 3D model of the animal in their space via AR.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这的一个例子是谷歌的*ARCore*平台，该平台使用机器学习来识别和增强特定的物体或物体类型。谷歌的*AR Animals*功能使用ARCore让用户在谷歌上搜索动物，然后通过AR在他们的空间中查看该动物的3D模型。
- en: Markerless AR offers immense possibilities for creating immersive and interactive
    AR experiences. Whether used in gaming, interior design, education, or a myriad
    of other applications, it has the potential to revolutionize how we interact with
    the digital world.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无标记AR为创建沉浸式和互动的AR体验提供了巨大的可能性。无论是在游戏、室内设计、教育还是其他无数的应用中，它都有潜力彻底改变我们与数字世界的互动方式。
- en: Understanding AR input types for interaction
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解AR交互输入类型
- en: Stepping into the realm of AR, one swiftly realizes that it’s not just about
    the mesmerizing blend of physical and virtual realities that one can see. It’s
    equally about how one can interact with these layered digital augmentations, a
    dimension defined by AR inputs. These inputs — modes by which the user interacts
    with the AR content — serve as a linchpin that shapes the overall AR experience.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 步入增强现实（AR）的领域，人们很快就会意识到，这不仅仅关乎人们所能看到的物理与虚拟现实的迷人融合。它同样关乎人们如何与这些层叠的数字增强进行交互，这是一个由AR输入定义的维度。这些输入——用户与AR内容交互的模式——作为连接点，塑造了整体的AR体验。
- en: 'As we venture further into this discussion, let’s shine a spotlight on various
    AR input types and how they breathe life into real-world applications:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步探讨这个话题，让我们聚焦于各种AR输入类型以及它们如何为现实世界应用注入活力：
- en: '**Touch input**: Touch input is a fundamental AR interaction. Simply put, the
    user can engage with the digital overlay through touch gestures on their AR device
    screen, be it a smartphone or a tablet. Touch input in AR includes not just tapping,
    but also other gestures such as swiping, pinching, and dragging. The specific
    gestures that can be used will depend on how the AR application is programmed.
    For example, a pinch gesture might be used to zoom in or out on an AR object,
    a swipe might rotate the object, and a drag could move the object around in the
    AR scene. The goal is to make the interaction with the AR elements as intuitive
    and natural as possible. *Snapchat lenses* provide a classic example of touch
    inputs at work. The user can animate the AR filters or induce changes by merely
    tapping different screen areas.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触摸输入**：触摸输入是AR交互的基础。简单来说，用户可以通过在AR设备屏幕上触摸手势来与数字叠加层进行交互，无论是智能手机还是平板电脑。AR中的触摸输入不仅包括点击，还包括其他手势，如滑动、捏合和拖动。可以使用的手势将取决于AR应用程序的编程方式。例如，捏合手势可能用于放大或缩小AR对象，滑动可能旋转对象，拖动可以在AR场景中移动对象。目标是使与AR元素的交互尽可能直观和自然。*Snapchat镜头*提供了触摸输入在应用中的经典例子。用户只需轻触不同的屏幕区域，就可以使AR滤镜动画化或引起变化。'
- en: '**Device motion**: Device motion is another pivotal AR input. By harnessing
    the data from onboard accelerometers, gyroscopes, and magnetometers, AR applications
    can interpret the orientation and movement of the device as an input. This input
    type proves particularly useful for AR experiences that involve maneuvering through
    an environment or controlling virtual elements. A case in point is the game Pokémon
    Go, where the player can simulate the act of *throwing* Pokéballs by swinging
    their device.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备运动**：设备运动是另一个关键的AR输入。通过利用设备上的加速度计、陀螺仪和磁力计的数据，AR应用程序可以将设备的朝向和运动作为输入。这种输入类型对于涉及在环境中导航或控制虚拟元素的用户体验特别有用。以游戏Pokémon
    Go为例，玩家可以通过挥动设备来模拟*投掷*宝可梦球的行为。'
- en: '**Voice commands**: Voice commands infuse AR applications with hands-free and
    accessibility-friendly interaction. *Google Glass*, an AR eyewear device, employs
    voice commands as one of its core input methods. The user can simply say *Okay,
    Glass* followed by a command such as *get directions* or *take a picture* to interact
    with the device.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语音命令**：语音命令为AR应用程序注入了免提和易于访问的交互方式。*Google Glass*这款AR眼镜设备将语音命令作为其核心输入方法之一。用户只需说出“好的，Glass”，然后跟上一个命令，如“获取路线”或“拍照”，就可以与设备交互。'
- en: '**Eye tracking**: Eye tracking is typically employed in advanced AR glasses.
    By tracking the user’s eye movements, these systems allow the user to interact
    with AR content just by looking at it. *North Focals* AR glasses are a good example
    of this technology in action. The user can steer a small, virtual cursor just
    by moving their eyes.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**眼动追踪**：眼动追踪通常用于高级AR眼镜。通过跟踪用户的眼动，这些系统允许用户仅通过注视即可与AR内容进行交互。*North Focals* AR眼镜是这一技术在应用中的良好例子。用户只需移动眼睛，就可以控制一个小型的虚拟光标。'
- en: '**Hand tracking** and **gesture recognition**: Hand tracking and gesture recognition
    can be used in highly immersive AR systems to interpret and track hand movements,
    enabling the user to touch and interact with virtual objects directly. Microsoft’s
    *HoloLens 2* is an example of this and allows the user to manipulate holograms
    with their hands, pinch to resize them, or tap them for interaction.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手势追踪**和**手势识别**：在高度沉浸式的AR系统中，手势追踪和手势识别可以用来解释和追踪手部动作，使用户能够直接触摸和与虚拟对象交互。微软的*HoloLens
    2*就是这一技术的例子，它允许用户用手势操作全息图像，捏合来调整大小，或轻触进行交互。'
- en: '**Physical controllers**: Physical controllers can range from handheld devices
    to wearable tech such as gloves, which provide tactile feedback and precise control
    in specific AR applications. For instance, the *Magic Leap One* AR headset is
    accompanied by a handheld controller, immersing the user into the AR experience
    by allowing them to interact with virtual content in a more nuanced manner.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理控制器**：物理控制器可以从手持设备到提供触觉反馈和精确控制的可穿戴技术（如手套）不等，适用于特定的AR应用。例如，*Magic Leap One*
    AR头戴式设备配有手持控制器，通过允许用户以更细腻的方式与虚拟内容交互，将用户沉浸在AR体验中。'
- en: As we have seen, AR inputs can significantly impact the immersive quotient of
    AR experiences. The choice of input methods hinges on the specific nature of the
    AR application. Therefore, understanding and implementing the most suitable input
    method can enhance an AR system’s realism and usability manifold.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，AR输入可以显著影响AR体验的沉浸感。输入方法的选择取决于AR应用的具体性质。因此，理解和实施最合适的输入方法可以极大地增强AR系统的真实性和可用性。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since this book primarily focuses on handheld mobile AR devices, to ensure that
    readers can easily reproduce all the projects presented within, we have chosen
    to restrict our scope to touch inputs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书主要关注手持式移动AR设备，为确保读者能够轻松复制书中展示的所有项目，我们选择将范围限制在触摸输入。
- en: In the next subsection, we will explore the AR toolkits available in Unity that
    can be utilized to implement the techniques we have just discussed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将探讨Unity中可用的AR工具包，这些工具包可以用来实现我们刚刚讨论的技术。
- en: Popular AR toolkits for Unity
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity的流行AR工具包
- en: 'In this section, we delve into Unity’s suite of AR toolkits, providing an overview
    for both budding and experienced developers seeking to navigate through their
    AR development journey. Each toolkit offers unique capabilities that aid developers
    in crafting compelling AR experiences. Let’s look at some of these now:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨Unity的AR工具包系列，为寻求在AR开发之旅中导航的新手和经验丰富的开发者提供概述。每个工具包都提供独特的功能，帮助开发者制作引人入胜的AR体验。现在让我们看看其中的一些：
- en: '**Vuforia**: Vuforia is a widely adopted AR platform, providing a blend of
    computer vision capabilities that accommodate both marker-based and markerless
    AR experiences. Its extensive feature set includes image tracking, object recognition,
    and target recognition, with wide-ranging platform support. An additional notable
    feature is Vuforia’s cloud recognition, allowing developers to house a multitude
    of target images remotely, further expanding the AR experience’s potential.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vuforia**：Vuforia是一个广泛采用的AR平台，提供了一组计算机视觉能力，可以适应基于标记和无标记的AR体验。其丰富的功能集包括图像跟踪、物体识别和目标识别，具有广泛的平台支持。另一个值得注意的功能是Vuforia的云识别，允许开发者远程托管大量目标图像，进一步扩展AR体验的潜力。'
- en: '**ARKit**: Within Apple’s playground, ARKit is the optimal toolkit for experiences
    targeting iOS devices. It is crafted specifically to complement the iOS ecosystem,
    offering developers a suite of advanced features such as world tracking, face
    tracking, and scene understanding. These elements collectively serve to enrich
    the user’s AR experience. ARKit predominantly uses Swift and Objective-C, Apple’s
    proprietary programming languages. However, when integrated with Unity through
    the AR Foundation package, developers can leverage C#, enabling a more accessible
    and familiar programming environment.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ARKit**：在苹果的游乐场中，ARKit是针对iOS设备体验的最佳工具包。它专门为iOS生态系统量身定制，为开发者提供了一系列高级功能，如世界跟踪、面部跟踪和场景理解。这些元素共同丰富了用户的AR体验。ARKit主要使用Swift和Objective-C，这是苹果的专有编程语言。然而，通过AR
    Foundation包与Unity集成时，开发者可以利用C#，从而提供一个更易于访问和熟悉的编程环境。'
- en: '**ARCore**: Google’s ARCore is the Android equivalent of ARKit, tailored for
    the world’s most popular mobile operating system. ARCore equips developers with
    features such as environmental understanding, motion tracking, and light estimation,
    all of which are essential elements for crafting realistic AR experiences. Primarily,
    ARCore uses Java for native development. But, similar to ARKit’s integration,
    ARCore can be incorporated into Unity projects via the AR Foundation package,
    allowing developers to use C#.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ARCore**：谷歌的ARCore是ARKit的Android版本，专为全球最受欢迎的移动操作系统量身定制。ARCore为开发者提供了环境理解、运动跟踪和光估计等功能，这些都是制作逼真AR体验的必要元素。主要来说，ARCore使用Java进行本地开发。但与ARKit的集成类似，ARCore可以通过AR
    Foundation包集成到Unity项目中，允许开发者使用C#。'
- en: '**AR Foundation**: AR Foundation stands as Unity’s high-level API package for
    constructing AR applications, unifying ARKit and ARCore’s capabilities. This ingenious
    package enables a single, streamlined workflow for creating cross-platform AR
    experiences, eradicating the need to write separate code bases for iOS and Android.
    It’s akin to owning a universal cookbook rather than individual recipe books for
    each cuisine. With AR Foundation, developers can leverage C#, a widely used, versatile
    programming language, making the process of crafting AR applications more efficient
    and intuitive.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR Foundation**: AR Foundation 是 Unity 的高级 API 包，用于构建 AR 应用程序，统一了 ARKit 和
    ARCore 的功能。这个巧妙的包使得创建跨平台的 AR 体验变得单一且流程化，消除了为 iOS 和 Android 编写单独代码库的需要。这就像拥有一本通用的食谱集，而不是每种菜肴的单独食谱书。使用
    AR Foundation，开发者可以利用广泛使用、功能多样的 C# 编程语言，使制作 AR 应用的过程更加高效和直观。'
- en: If you were to use ARCore and ARKit separately, you would need to write separate
    sets of code for each platform. You would need to use ARCore to build your AR
    app on Android, and then rewrite the code using ARKit to make it work on iOS.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你分别使用 ARCore 和 ARKit，你需要为每个平台编写不同的代码集。你需要使用 ARCore 在 Android 上构建你的 AR 应用，然后使用
    ARKit 重新编写代码，使其在 iOS 上运行。
- en: However, by using AR Foundation to develop AR apps, you only need to write a
    single set of code that works on both iOS and Android. AR Foundation provides
    a unified API that is compatible with both ARCore and ARKit, meaning you don’t
    need to write different code for each platform. It simplifies the development
    process and saves a lot of time and effort.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，通过使用 AR Foundation 开发 AR 应用，你只需要编写一套适用于 iOS 和 Android 的代码。AR Foundation 提供了一个统一的
    API，与 ARCore 和 ARKit 兼容，这意味着你不需要为每个平台编写不同的代码。它简化了开发过程，节省了大量时间和精力。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we’ll focus on creating AR applications using AR Foundation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于使用 AR Foundation 创建 AR 应用程序。
- en: However, it’s important to remember that the use of ARCore or ARKit could offer
    unique advantages in certain scenarios, thanks to platform-specific features exclusive
    to each. For example, ARKit brings to the table LIDAR support from *version 3.5*
    onward. This feature utilizes the LIDAR scanner integrated into select iPhone
    and iPad models, offering refined scene understanding and precise depth estimation.
    Another ARKit exclusive is the *Motion Capture* feature from *ARKit 3* onward,
    enabling developers to record human movement and apply it to a 3D character model,
    effectively transforming the device into a motion capture studio.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要记住，在特定场景下，使用 ARCore 或 ARKit 可能会提供独特的优势，这得益于每个平台独有的特定功能。例如，从 *版本 3.5*
    开始，ARKit 带来了 LIDAR 支持。这个功能利用了集成到某些 iPhone 和 iPad 模型中的 LIDAR 扫描仪，提供了精细的场景理解和精确的深度估计。另一个
    ARKit 独有的功能是从 *ARKit 3* 开始的 *运动捕捉* 功能，它允许开发者记录人类动作并将其应用于 3D 角色模型，有效地将设备转变为动作捕捉工作室。
- en: On the other hand, ARCore also has a unique set of features for Android devices.
    One such feature is the Depth API, which generates depth maps using a single RGB
    camera. While ARKit also has depth sensing capabilities, ARCore’s Depth API can
    function on a broader range of devices, even those without a dedicated depth sensor.
    Another distinctive feature of ARCore is *Augmented Images*, which allows the
    application to track and augment images at fixed locations, offering the potential
    for interaction with posters, murals, and similar items.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，ARCore 也为 Android 设备提供了一套独特的功能。其中一个功能是 Depth API，它使用单个 RGB 相机生成深度图。虽然 ARKit
    也具有深度感知能力，但 ARCore 的 Depth API 可以在更广泛的设备上运行，甚至在没有专用深度传感器的设备上。ARCore 的另一个独特功能是
    *增强图像*，它允许应用程序在固定位置跟踪和增强图像，为与海报、壁画和类似物品的交互提供了可能性。
- en: Important note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The examples mentioned earlier in this section may not be applicable when you
    are reading this book. Since ARKit, ARCore, and AR Foundation are constantly evolving,
    it is important to consult the latest documentation ([https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html))
    for the most up-to-date and accurate information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中提到的示例，在阅读这本书时可能不适用。由于 ARKit、ARCore 和 AR Foundation 不断演变，查阅最新的文档([https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html))对于获取最新和最准确的信息非常重要。
- en: Now, it is finally time to begin our first Unity AR project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以开始我们的第一个 Unity AR 项目了。
- en: Setting up an AR project in Unity using AR Foundation
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AR Foundation 在 Unity 中设置 AR 项目
- en: In this section, you will learn how to set up a simple AR project in Unity using
    AR Foundation. You will learn how you can place simple objects such as a cube,
    add plane detection functionalities, and implement touch inputs and anchors into
    your AR scenes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用 AR Foundation 在 Unity 中设置一个简单的 AR 项目。您将了解如何放置简单的对象，如立方体，添加平面检测功能，并将触摸输入和锚点实现到您的
    AR 场景中。
- en: Before using AR Foundation in our first AR application, however, we must first
    understand the architecture of this package.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用 AR Foundation 在我们的第一个 AR 应用程序之前，我们首先必须了解这个包的架构。
- en: Understanding AR Foundation’s architecture
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 AR 基础架构
- en: In this section, we’ll delve into the exciting world of Unity’s AR Foundation,
    a package that empowers you to create AR experiences across various platforms.
    Whether you aim to create applications for Android, Apple, or HoloLens, AR Foundation
    simplifies the process remarkably. Its extensive capabilities range from plane
    detection, image and object tracking, and face and body tracking, to point clouds
    and more. *Figure 4**.1* breaks down the architecture of AR Foundation into a
    hierarchy of components that seamlessly work together to offer a consistent AR
    experience across different devices.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨 Unity 的 AR 基础架构的激动人心的世界，这是一个使您能够在各种平台上创建 AR 体验的包。无论您旨在为 Android、Apple
    还是 HoloLens 创建应用程序，AR Foundation 都极大地简化了这一过程。其广泛的功能包括平面检测、图像和对象跟踪、面部和身体跟踪，以及点云等。*图
    4.1* 将 AR Foundation 的架构分解为组件的层次结构，这些组件无缝协作，为不同设备提供一致的 AR 体验。
- en: '![Figure 4.1 – AR Foundation’s architecture](img/B20869_04_01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – AR 基础架构](img/B20869_04_01.jpg)'
- en: Figure 4.1 – AR Foundation’s architecture
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – AR 基础架构
- en: The **AR App** represents the application where developers craft their AR experiences.
    It is directly linked with the **Managers**, which serve as the primary interfaces
    for specific AR functionalities.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR 应用** 代表开发者构建 AR 体验的应用程序。它与 **管理器** 直接相关联，这些管理器作为特定 AR 功能的主要接口。'
- en: The **AR PlaneManager** is crucial for detecting and tracking real-world planes,
    such as floors or walls. It provides a consistent means to engage with the physical
    environment around a user, feeding the app with data about surfaces in the user’s
    surroundings.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR PlaneManager** 对于检测和跟踪现实世界的平面至关重要，例如地板或墙壁。它提供了一个与用户周围物理环境交互的一致方式，向应用提供用户周围表面数据。'
- en: Similarly, the **ARRaycast Manager** plays an essential role in understanding
    user interactions within this AR space. It casts rays into the AR scene, determining
    where these rays intersect with real-world surfaces. This is particularly vital
    when users intend to place virtual objects on these surfaces or wish to interact
    with virtual elements in relation to the real world.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，**ARRaycast 管理器** 在理解这个 AR 空间中的用户交互方面发挥着至关重要的作用。它将射线投射到 AR 场景中，确定这些射线与真实世界表面的交点。当用户打算在这些表面上放置虚拟对象或希望与虚拟元素相关联地与真实世界交互时，这一点尤为重要。
- en: Delving deeper, these managers interact with **Subsystems**, abstract layers
    that communicate with the actual platform-specific modules. The **XRPlane Subsystem**
    standardizes data related to plane detection, ensuring that plane-related events
    and data are uniform, irrespective of whether it’s ARKit or ARCore doing the underlying
    work. The **XRRaycast Subsystem** offers a consistent interface for raycasting,
    abstracting the nuances of each platform’s approach.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究，这些管理器与 **子系统** 交互，这些子系统是抽象层，与实际的平台特定模块进行通信。**XRPlane 子系统** 标准化了与平面检测相关的数据，确保无论底层工作是由
    ARKit 还是 ARCore 完成，平面相关的事件和数据都是统一的。**XRRaycast 子系统** 提供了一个一致的射线投射接口，抽象了每个平台方法的细微差别。
- en: Lastly, the **Providers** represent the platform-specific SDKs that power AR
    on each device type. ARKit SDK is Apple’s contribution for its iOS devices, with
    specialized subsystems for plane detection and raycasting. On the other side,
    ARCore SDK is Google’s solution for Android, mirroring the functionalities offered
    by ARKit but tailored for the Android ecosystem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**提供者** 代表为每种设备类型提供 AR 功能的平台特定 SDK。ARKit SDK 是苹果为其 iOS 设备做出的贡献，具有专门的平面检测和射线投射子系统。另一方面，ARCore
    SDK 是谷歌为 Android 提供的解决方案，与 ARKit 提供的功能类似，但针对 Android 生态系统进行了定制。
- en: As you can see, AR Foundation offers XR developers a unified framework by allowing
    them to focus on their application’s AR experience without worrying about platform-specific
    intricacies. Through its layered architecture, it ensures that applications remain
    consistent and high-quality, whether deployed on an iPhone or an Android device.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，AR Foundation通过允许开发者集中精力在他们的AR体验上，而不必担心平台特定的复杂性，为XR开发者提供了一个统一的框架。通过其分层架构，它确保无论部署在iPhone还是Android设备上，应用程序都保持一致且高质量。
- en: With this understanding, it is finally time to create our first AR project in
    Unity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，现在是时候在Unity中创建我们的第一个AR项目了。
- en: Creating an AR project with Unity’s AR template
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Unity的AR模板创建AR项目
- en: 'Creating an AR project in Unity is quite straightforward. Follow these steps
    to get started:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中创建一个AR项目相当简单。按照以下步骤开始：
- en: Depending on your target AR platform — Android or iOS — you’ll need to navigate
    first to the `Installs` folder in the Unity Hub, click on the **Settings** icon
    adjacent to your version, select **Add Modules**, and install the appropriate
    build support.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的目标AR平台——Android或iOS——你首先需要导航到Unity Hub中的`Installs`文件夹，点击你版本旁边的**设置**图标，选择**添加模块**，并安装适当的构建支持。
- en: To show your project in the AR Unity template, you’d follow the subsequent steps.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在AR Unity模板中展示你的项目，你需要遵循后续的步骤。
- en: In the Unity Hub’s project window, click on the **New project** button in the
    top-right corner.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity Hub的项目窗口中，点击右上角的**新建项目**按钮。
- en: Choose the **AR** template and give your project a unique name of your choice,
    as shown in *Figure 4**.2*.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**AR**模板，并为你的项目起一个独特的名字，如图*图4.2*所示。
- en: "![Figure 4.2 – \uFEFFThe AR template available in the Unity Hub](img/B20869_04_02.jpg)"
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – Unity Hub中可用的AR模板](img/B20869_04_02.jpg)'
- en: Figure 4.2 – The AR template available in the Unity Hub
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – Unity Hub中可用的AR模板
- en: Why choose the AR template?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择AR模板？
- en: 'In Unity’s world, the AR template is like a bountiful garden, already seeded
    with pre-installed packages such as AR foundation, ARKit Face Tracking, ARKit
    XR-, ARCore XR-, Magic Leap XR-, and the OpenXR plugins, not to mention a sample
    scene. However, you might observe that this lush garden contains plants that aren’t
    necessary for your target landscape: Android or iOS. To maintain a cleaner garden,
    you can selectively pick the seeds you need – the OpenXR plugin, AR Foundation,
    Input System and the ARCore XR plugin (for Android) or ARKit XR plugin (for iOS)
    – from Unity’s own nursery, the package manager, and plant them in a regular 3D
    scene.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的世界里，AR模板就像一个富饶的花园，已经预装了AR基础、ARKit Face Tracking、ARKit XR-、ARCore XR-、Magic
    Leap XR-和OpenXR插件等预安装包，更不用说一个示例场景了。然而，你可能会注意到这个茂密的花园里有一些对你目标景观不必要的植物：Android或iOS。为了保持花园的整洁，你可以从Unity自己的苗圃——包管理器中，有选择地挑选你需要的种子——OpenXR插件、AR基础、输入系统和ARCore
    XR插件（用于Android）或ARKit XR插件（用于iOS），并将它们种植在一个普通的3D场景中。
- en: Finally, click on **Create Project**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**创建项目**。
- en: Once the scene loads in the Unity Editor, it should look like what is shown
    in *Figure 4**.3*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦场景在Unity编辑器中加载，它应该看起来像*图4.3*所示的那样。
- en: "![Figure 4.3 – \uFEFFUnity’s AR SampleScene](img/B20869_04_03.jpg)"
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – Unity的AR SampleScene](img/B20869_04_03.jpg)'
- en: Figure 4.3 – Unity’s AR SampleScene
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – Unity的AR SampleScene
- en: Important note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you don’t see the scene shown in *Figure 4**.3* in the Unity Editor, you
    can open it manually by selecting **Assets** | **ExampleAssets** | **SampleScene**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在Unity编辑器中看到*图4.3*所示的场景，你可以通过选择**资产** | **示例资产** | **SampleScene**手动打开它。
- en: The newly opend scene contains **Directional Light**, **AR Session Origin**,
    and **AR Session** GameObjects. If you wish to bring these objects into a new
    scene, you can conjure an **AR Session** GameObject by right-clicking in the hierarchy
    and choosing **XR** | **AR Session**. The **AR Session Origin** GameObject can
    be summoned in a similar fashion by selecting **XR** | **AR Session Origin**.
    That’s the initial magic performed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 新打开的场景包含**方向光**、**AR会话原点**和**AR会话**GameObject。如果你希望将这些对象带入一个新的场景，你可以在层次结构中右键点击，选择**XR**
    | **AR会话**来召唤一个**AR会话**GameObject。通过选择**XR** | **AR会话原点**，可以以类似的方式召唤**AR会话原点**GameObject。这就是最初施展的魔法。
- en: Important note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At the time of this book’s publication, **AR Session Origin** and **AR Session**
    represent the default GameObjects integrated into the *AR Foundation*’s template.
    Yet, given the dynamic nature of *AR Foundation*, continuous updates and revisions
    are anticipated. There are indications that **AR Session Origin** is slated to
    evolve into *XR Origin* (*Mobile AR*) in upcoming versions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书出版时，**AR 会话原点** 和 **AR 会话** 代表了集成到 *AR 基础* 模板中的默认 GameObjects。然而，鉴于 *AR 基础*
    的动态特性，预计会有持续更新和修订。有迹象表明，**AR 会话原点** 将在未来的版本中演变为 *XR 原点* (*移动 AR*)。
- en: Should you encounter such changes, don’t fret. The essence of this chapter remains
    intact and can be easily navigated. We recommend accessing our *GitHub* repository
    to clone the specific project versions we’ve worked with, ensuring compatibility
    with Unity. Often, transitioning from outdated GameObjects to their newer counterparts
    is seamless, requiring minimal, if any, adjustments to the existing logic.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到此类更改，请不要担心。本章的精髓保持不变，并且可以轻松导航。我们建议访问我们的 *GitHub* 仓库以克隆我们已工作的特定项目版本，确保与
    Unity 兼容。通常，从过时的 GameObjects 转换到它们的较新版本是无缝的，可能需要最少的，如果不是任何，对现有逻辑的调整。
- en: 'Stay adaptable and remember: the core concepts and foundations presented here
    remain your guide, even as the tools evolve.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 保持适应性，并记住：这里提出的核心概念和基础仍然是您的指南，即使工具在不断发展。
- en: Before we start inspecting these GameObjects, we first need to adjust some project
    settings of our AR scene.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始检查这些 GameObjects 之前，我们首先需要调整我们 AR 场景的一些项目设置。
- en: Changing the project settings
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改项目设置
- en: To define which providers we want to target with our AR scene, go to **XR Plug-in
    Management** under **Edit** | **Project Settings**. Depending on the platform
    we’re targeting, be it an Android or an iOS device, we activate the corresponding
    ARCore or ARKit checkbox. If you seek to embrace both platforms, enable both checkboxes.
    This will install the provider packages into your project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义我们想要针对我们的 AR 场景使用的提供者，请转到 **编辑** | **项目设置** 下的 **XR 插件管理**。根据我们针对的平台，无论是
    Android 还是 iOS 设备，我们激活相应的 ARCore 或 ARKit 复选框。如果您想同时拥抱这两个平台，请启用两个复选框。这将安装提供者包到您的项目中。
- en: Important note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you don’t see Android, iOS, or both tabs, it’s likely that the *Android*
    or *iOS Build Support* module hasn’t been integrated into your Editor. Let’s see
    how we can fix this problem.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到 Android、iOS 或两者都的选项卡，那么很可能是 *Android* 或 *iOS 构建支持* 模块尚未集成到您的编辑器中。让我们看看我们如何解决这个问题。
- en: '*Figure 4**.4* shows the installed Unity Editor with the Build Support modules
    marked in the Unity Hub.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.4* 显示了在 Unity Hub 中标记的构建支持模块的已安装 Unity 编辑器。'
- en: '![Figure 4.4 – The installed Unity Editor with the Build Support modules marked](img/B20869_04_04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 已安装的 Unity 编辑器，已标记的构建支持模块](img/B20869_04_04.jpg)'
- en: Figure 4.4 – The installed Unity Editor with the Build Support modules marked
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 已安装的 Unity 编辑器，已标记的构建支持模块
- en: The displayed image indicates an absence of the *iOS Build Support* module in
    the Unity Editor. To adjust this, go to the **Installs** tab in the Unity Hub.
    Click the **Settings** icon in the top-right corner of your Unity Editor installation.
    Then, select **Add Modules**, enable the checkboxes for **iOS Build Support**
    or **Android Build Support** – or both, if you will – and install them. Once the
    installation is finished, go back to your project’s **XR Plug-in** **Management**
    window.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的图像表明 Unity 编辑器中缺少 *iOS 构建支持* 模块。要调整此问题，请转到 Unity Hub 中的 **安装** 选项卡。点击 Unity
    编辑器安装右上角的 **设置** 图标。然后，选择 **添加模块**，为 **iOS 构建支持** 或 **Android 构建支持**（如果您愿意，也可以两者都选）启用复选框，并安装它们。安装完成后，返回到您项目的
    **XR 插件** **管理** 窗口。
- en: Now, you should find the **ARCore** and **ARKit** tabs under **XR** **Plug-in
    Management**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该在 **XR 插件管理** 下的 **ARCore** 和 **ARKit** 选项卡下找到它们。
- en: Now, select the **ARCore** tab to explore fields related to the configuration
    and settings of the ARCore packages in your Unity project. *Figure 4**.5* shows
    the **ARCore** tab with its default settings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择 **ARCore** 选项卡以探索与您 Unity 项目中 ARCore 包的配置和设置相关的字段。*图 4**.5* 显示了带有其默认设置的
    **ARCore** 选项卡。
- en: '![Figure 4.5 – The ARCore tab with its default settings](img/B20869_04_05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 默认设置的 ARCore 选项卡](img/B20869_04_05.jpg)'
- en: Figure 4.5 – The ARCore tab with its default settings
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 默认设置的 ARCore 选项卡
- en: 'Let’s go through the function of each field:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍每个字段的函数：
- en: '**Requirement**: This parameter dictates the necessity of ARCore for your application.
    If set to **Required**, it establishes ARCore as an integral component for your
    target device. Conversely, when marked as **Optional**, ARCore is positioned as
    an additional feature, supplementing the application’s capabilities when present
    but not essential for the application’s core functionality.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需求**：此参数决定了ARCore对您应用程序的必要性。如果设置为**必需**，则将ARCore确立为目标设备的一个基本组件。相反，当标记为**可选**时，ARCore被视为一个附加功能，当存在时补充应用程序的功能，但不是应用程序核心功能的必需品。'
- en: '**Depth**: This is the tool that gives your device the power of depth perception
    within its environment. Useful for occlusion and other advanced AR effects, it
    lets you toggle depth estimation in ARCore. If you set **Depth** to **Required**,
    your AR application will need to have depth estimation capabilities to function.
    On the other hand, selecting **Optional** means your AR application is capable
    of utilizing depth estimation features if the device supports it, but it doesn’t
    hamper the basic functioning if such features are absent.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：这是赋予您的设备在其环境中深度感知能力的工具。对于遮挡和其他高级AR效果非常有用，它允许您在ARCore中切换深度估计。如果您将**深度**设置为**必需**，则您的AR应用程序将需要深度估计功能才能运行。另一方面，选择**可选**意味着如果设备支持，您的AR应用程序可以利用深度估计功能，但如果这些功能不存在，也不会影响基本功能。'
- en: '**Ignore Gradle Version** checkbox: This is your control over the Gradle build
    system, an essential tool for building Android apps. When unchecked, Unity adheres
    to the specified Gradle version for your project. However, if checked, Unity gains
    autonomy, ignoring the specified version and choosing to operate on its default
    version.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略Gradle版本**复选框：这是您对Gradle构建系统的控制，它是构建Android应用程序的必备工具。当未选中时，Unity将遵循项目指定的Gradle版本。然而，如果选中，Unity将获得自主权，忽略指定的版本，并选择使用其默认版本。'
- en: While the default settings – having both the **Requirement** and **Depth** fields
    set to **Required** and the **Ignore Gradle Version** checkbox unchecked – suit
    most projects, there are exceptions. For instance, if you’re creating an AR application
    designed for a wide variety of devices with varying capabilities, or if your application’s
    main functionalities do not heavily rely on ARCore’s depth perception, you might
    want to set the **Depth** field to **Optional**. Furthermore, if you’re working
    on a project that requires a specific Gradle version or has conflicts with newer
    versions, checking the **Ignore Gradle Version** box would be necessary. However,
    for this chapter, we can keep the default settings.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然默认设置——**需求**和**深度**字段都设置为**必需**，以及**忽略Gradle版本**复选框未选中——适用于大多数项目，但也有一些例外。例如，如果您正在创建一个针对具有不同能力的各种设备的AR应用程序，或者如果您的应用程序的主要功能并不严重依赖于ARCore的深度感知，您可能希望将**深度**字段设置为**可选**。此外，如果您正在处理需要特定Gradle版本或与较新版本存在冲突的项目，选中**忽略Gradle版本**复选框将是必要的。然而，对于本章，我们可以保持默认设置。
- en: Next, we turn our attention to the **ARKit** tab. Just like its ARCore counterpart,
    these fields are connected to the configuration and settings of the ARKit packages
    in your Unity project. *Figure 4**.6* shows the **ARKit** tab with its default
    settings.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将注意力转向**ARKit**选项卡。就像其ARCore对应物一样，这些字段与您的Unity项目中ARKit包的配置和设置相关联。*图4.6*显示了具有默认设置的**ARKit**选项卡。
- en: '![Figure 4.6 – The ARKit tab with its default settings](img/B20869_04_06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 具有默认设置的ARKit选项卡](img/B20869_04_06.jpg)'
- en: Figure 4.6 – The ARKit tab with its default settings
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 具有默认设置的ARKit选项卡
- en: 'Let’s decode the roles of all the fields shown in *Figure 4**.6*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解码*图4.6*中显示的所有字段的含义：
- en: '**Requirement**: Acting in a manner similar to ARCore’s **Requirement** field,
    this indicator announces whether ARKit is deemed vital for your project.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需求**：与ARCore的**需求**字段作用类似，此指示器宣布ARKit是否被认为是您项目的重要部分。'
- en: '**Face Tracking**: Acting as a switch, this checkbox enables or disables the
    face tracking functionality in ARKit. When activated, it allows tracking and recognizing
    a range of facial features and expressions using the device’s front-facing camera.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面部追踪**：作为一个开关，此复选框启用或禁用ARKit中的面部追踪功能。当激活时，它允许使用设备的前置摄像头跟踪和识别一系列面部特征和表情。'
- en: For the moment, we’ll abide by the default settings – the **Requirement** field
    standing firm at **Required** and the **Face Tracking** checkbox remaining in
    the off position, as it’s not currently needed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将遵循默认设置——**需求**字段保持为**必需**，并且**人脸追踪**复选框保持关闭状态，因为目前不需要。
- en: In the forthcoming sections, we’re going to delve into the GameObjects that
    accompany the **AR** template. We’ll dive into their roles and demystify why they
    hold such significance. Let’s begin with the AR Session GameObject.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入研究与**AR**模板一起的GameObject。我们将探讨它们的作用，并揭示它们为何如此重要。让我们从AR会话GameObject开始。
- en: Understanding the AR Session GameObject
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解AR会话GameObject
- en: The **AR Session** GameObject manages the lifecycle of your AR application.
    To understand it, click on it in the scene hierarchy and navigate to the inspector
    window. As shown in *Figure 4**.7*, the **AR Session** GameObject contains the
    **AR Session** and the **AR Input** **Manager** components.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR会话**GameObject管理着你的AR应用的生命周期。要了解它，请在场景层次结构中点击它，并导航到检查器窗口。如图*图4.7*所示，**AR会话**GameObject包含**AR会话**和**AR输入****管理器**组件。'
- en: '![Figure 4.7 – The Inspector window when the AR Session GameObject is selected](img/B20869_04_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 选择AR会话GameObject时的检查器窗口](img/B20869_04_07.jpg)'
- en: Figure 4.7 – The Inspector window when the AR Session GameObject is selected
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 选择AR会话GameObject时的检查器窗口
- en: 'Let’s understand each of the fields shown in *Figure 4**.7*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解*图4.7*中显示的每个字段：
- en: '**Attempt Update** checkbox: This checkbox, when marked, is your instruction
    to the AR session to be vigilant about keeping the device’s pose and tracking
    state up-to-date with every frame and every tick of the clock. Checking the box
    commands the AR session to fetch fresh tracking data diligently, ensuring that
    even when the device’s tracking wavers temporarily, the AR elements maintain their
    alignment with the real world. Imagine an AR hoop shooting game. In this game,
    you see a virtual hoop overlaid onto your real-world environment through your
    device’s screen. The objective is to shoot virtual balls into this hoop from various
    angles and distances. For this to function well, it’s vital that the tracking
    data of your device is continuously updated. That’s where the **Attempt Update**
    checkbox comes in.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尝试更新**复选框：当勾选此复选框时，这是你对AR会话的指示，要求它对保持设备的姿态和追踪状态与每一帧和每一滴答保持更新保持警觉。勾选此框命令AR会话勤奋地获取新的追踪数据，确保即使设备的追踪暂时波动，AR元素也能保持与真实世界的对齐。想象一个AR投篮游戏。在这个游戏中，你通过设备的屏幕看到虚拟篮筐叠加在你的真实世界环境中。为了使游戏运行良好，确保你的设备的追踪数据持续更新至关重要。这就是**尝试更新**复选框的作用所在。'
- en: Activating **Attempt Update** commands the game to consistently refresh the
    tracking state, securing the harmony of the virtual objects with the real-world
    environment, notwithstanding transient tracking losses.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 激活**尝试更新**命令指示游戏持续刷新追踪状态，确保虚拟对象与真实世界环境的和谐，即使出现暂时的追踪损失。
- en: '**Match Frame Rate** checkbox: This, when marked, means that you’re asking
    the AR session to walk in step with the device’s camera frame rate. The AR session
    adjusts its rhythm to mirror the camera’s, culminating in a harmonious visual
    experience. Consider an AR app that lets the user envision virtual furniture within
    their actual space.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配帧率**复选框：当勾选此复选框时，意味着你要求AR会话与设备的相机帧率同步。AR会话调整其节奏以匹配相机的，最终实现和谐的视觉体验。考虑一个允许用户在他们的实际空间中构想虚拟家具的AR应用。'
- en: A ticked **Match Frame Rate** checkbox ensures the AR session’s frame rate keeps
    time with the camera’s, curbing visual discord between the actual space and the
    virtual furniture, thereby enabling a precise assessment of aesthetics.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 勾选的**匹配帧率**复选框确保AR会话的帧率与相机同步，抑制实际空间和虚拟家具之间的视觉不协调，从而实现精确的美学评估。
- en: '**Tracking Mode** drop-down menu: This is the key to defining the tracking
    quality of your AR session. The selected mode determines the AR system’s awareness
    of, and response to, the device’s motion and position in the real world. Picture
    an AR navigation app that superimposes virtual arrows over the physical world
    to guide the user.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追踪模式**下拉菜单：这是定义你的AR会话追踪质量的关键。所选模式决定了AR系统对设备在真实世界中的运动和位置的感知和响应。想象一个在物理世界之上叠加虚拟箭头的AR导航应用，以引导用户。'
- en: In this navigation app, opting for **Rotation and Position Tracking** imparts
    full tracking capabilities, ensuring the virtual arrows trace the contours of
    the real world accurately, guiding the user along their path with precision.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个导航应用程序中，选择 **旋转和位置跟踪** 提供了完整的跟踪能力，确保虚拟箭头准确追踪现实世界的轮廓，精确地引导用户沿着他们的路径。
- en: For our current exploration, we’ll stick with the default settings – both the
    **Attempt Update** and **Match Frame Rate** checkboxes are ticked and **Tracking
    Mode** is set to **Position And Rotation**. In the future, your choice of these
    settings should reflect your project’s goals and the intended user experience.
    To discover the best blend for your needs, we encourage you to experiment with
    different settings and configurations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们当前的探索，我们将坚持默认设置 – 两个 **尝试更新** 和 **匹配帧率** 复选框都被勾选，并且 **跟踪模式** 设置为 **位置和旋转**。在未来，你的这些设置选择应反映你的项目目标和预期的用户体验。为了发现最适合你需求的最佳组合，我们鼓励你尝试不同的设置和配置。
- en: The second component under the AR Session umbrella is the **AR Input** **Manager**
    component.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AR 会话之下，第二个组件是 **AR 输入** **管理器**组件。
- en: The AR Input Manager component translates the user’s interactions with the AR
    scene into meaningful input. It perceives and processes a variety of user inputs
    such as taps, touches, and gestures. It’s the invisible hand enabling interactivity
    in your AR application, allowing placement of objects or interactions with virtual
    elements. For instance, imagine an AR game where the user neutralizes virtual
    targets with a tap. The **AR Input Manager script** reads the tap on the screen
    and furnishes the requisite information to unleash the shooting action in the
    game.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: AR 输入管理器组件将用户的 AR 场景交互转换为有意义的输入。它感知和处理各种用户输入，如点击、触摸和手势。它是使你的 AR 应用程序交互性无形之手，允许放置对象或与虚拟元素交互。例如，想象一个
    AR 游戏，用户通过点击来消除虚拟目标。**AR 输入管理器脚本**读取屏幕上的点击，并提供必要的信息来释放游戏中的射击动作。
- en: Now, our focus shifts to the AR Session Origin GameObject.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的重点转向 AR 会话起源 GameObject。
- en: Exploring the AR Session Origin GameObject
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 AR 会话起源 GameObject
- en: The **AR Session Origin** GameObject is the primary element controlling the
    synchronization between the physical world and virtual objects projected in AR.
    It comprises various components, such as AR Session Origin, AR Plane Manager,
    AR Anchor Manager, AR Raycast Manager, and Anchor Creator, as we can see in *Figure
    4**.8*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR 会话起源** GameObject 是控制物理世界与 AR 中投射的虚拟对象之间同步的主要元素。它包含各种组件，如 AR 会话起源、AR 平面管理器、AR
    锚点管理器、AR 光线投射管理器和锚点创建器，正如我们在 *图 4.8* 中所看到的。'
- en: '![Figure 4.8 – The Inspector when AR Session Origin is selected](img/B20869_04_08.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 选择 AR 会话起源时的检查器](img/B20869_04_08.jpg)'
- en: Figure 4.8 – The Inspector when AR Session Origin is selected
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 选择 AR 会话起源时的检查器
- en: For the initiation phase of our AR development, we only require the AR Session
    Origin component. Hence, you may disable all other components for the time being.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们 AR 开发的启动阶段，我们只需要 AR 会话起源组件。因此，你现在可以暂时禁用所有其他组件。
- en: Think of AR Session Origin as the pivot point of your AR experience. It provides
    a basis for anchoring virtual objects within the AR environment. Let’s visualize
    an AR app allowing the user to place virtual furniture within their home. Here,
    the AR Session Origin component arranges and alignes the virtual furniture correctly
    within the user’s physical space.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将 AR 会话起源视为你的 AR 体验的支点。它为在 AR 环境中锚定虚拟对象提供了一个基础。让我们想象一个 AR 应用程序，允许用户将虚拟家具放置在他们家中。在这里，AR
    会话起源组件正确地安排和定位虚拟家具在用户的物理空间内。
- en: AR Session Origin ensures the alignment of the user’s environment with the position
    and orientation of the displayed AR scene. For instance, when a user places a
    virtual chair, this script maintains the chair’s positioning and orientation,
    no matter the user’s movement within the room. This is why this component is essential
    in creating an authentic AR experience.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: AR 会话起源确保用户的环境与显示的 AR 场景的位置和方向对齐。例如，当用户放置一个虚拟椅子时，此脚本会保持椅子的定位和方向，无论用户在房间内的移动。这就是为什么这个组件对于创建真实的
    AR 体验至关重要。
- en: For blending the virtual objects with the real-world footage, the AR session
    necessitates the presence of a camera. In the case of an existing main camera
    in your scene, you can safely remove it. AR Session Origin incorporates its own
    child **AR Camera**. This camera, devoid of any skybox for a monochromatic background,
    comes pre-equipped with necessary components, such as **Camera**, **Tracked Pose
    Driver**, **AR Camera Manager**, and **AR Camera Background**, as shown in *Figure
    4**.9*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将虚拟物体与真实世界的视频混合，AR会话需要存在一个相机。在你场景中已经存在主相机的情况下，你可以安全地移除它。AR会话原点集成了自己的子**AR相机**。这个相机没有用于单色背景的天空盒，预先配备了必要的组件，如**相机**、**跟踪姿态驱动器**、**AR相机管理器**和**AR相机背景**，如图*图4.9*所示。
- en: '![Figure 4.9 – The Inspector when AR Session Origin’s child AR Camera is selected](img/B20869_04_09.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 当选择AR会话原点的子AR相机时的检查器](img/B20869_04_09.jpg)'
- en: Figure 4.9 – The Inspector when AR Session Origin’s child AR Camera is selected
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 当选择AR会话原点的子AR相机时的检查器
- en: 'Let’s now learn more about each of these:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来详细了解每一个：
- en: Like a real-world camera, the **Camera** component captures and displays a portion
    of the game scene to the player – essentially, what you see on your device’s screen
    when playing an AR game. It can be positioned and rotated to capture different
    views within the game scene.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像现实世界的相机一样，**相机**组件捕捉并显示游戏场景的一部分给玩家看——本质上，就是你在玩AR游戏时在设备屏幕上看到的内容。它可以定位和旋转，以捕捉游戏场景中的不同视角。
- en: The **AR Camera Manager** component controls the phone camera settings, such
    as **Facing Direction**, **Light Estimation**, and **Auto Focus**. **Auto Focus**
    makes the camera automatically adjust its focus to keep AR objects sharp, just
    like autofocus in a regular camera. **Light Estimation** allows you to choose
    how the AR system estimates real-world lighting conditions to make virtual objects
    look more realistic. Options range from not estimating lighting at all (**None**)
    to estimating various aspects of lighting, such as **Ambient Light Intensity**
    and **Color**, and the main light source’s **Direction** and **Intensity**. **Facing
    Direction** decides the direction in which the AR Camera is facing. The **World**
    setting is typically for the rear-facing camera (seeing the environment), and
    **User** is for the front-facing camera (selfie mode). **None** disables this
    setting. For now, we can leave these settings as they are.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR相机管理器**组件控制手机相机的设置，如**面向方向**、**光估计**和**自动对焦**。**自动对焦**使相机自动调整其焦点以保持AR物体清晰，就像普通相机中的自动对焦一样。**光估计**允许你选择AR系统如何估计真实世界的光照条件，以使虚拟物体看起来更真实。选项范围从根本不估计光照（**无**）到估计光照的各个方面，如**环境光强度**和**颜色**，以及主光源的**方向**和**强度**。**面向方向**决定AR相机面向的方向。**世界**设置通常是用于后置摄像头（查看环境），而**用户**是用于前置摄像头（自拍模式）。**无**禁用此设置。目前，我们可以保持这些设置不变。'
- en: The **Tracked Pose Driver** component takes information about the device’s physical
    position and orientation, collectively referred to as its pose, and uses that
    to set the position, rotation, and scale of the camera within the Unity game scene.
    This is what’s referred to as the camera’s **Transform**. This ensures that the
    AR scene remains in harmony with the phone’s movements. To facilitate this, the
    Tracked Pose Driver provides several configurable options. **Device** lets you
    select the type of device being tracked. **Pose Source** allows you to choose
    the part of the device that provides the tracking data. The **Tracking Type**
    drop-down menu indicates what type of movement (rotation, position, or both) is
    tracked.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪姿态驱动器**组件获取关于设备物理位置和方向的信息，统称为姿态，并使用这些信息来设置Unity游戏场景中相机的位置、旋转和缩放。这被称为相机的**变换**。这确保了AR场景与手机的移动保持一致。为了方便这一过程，跟踪姿态驱动器提供了几个可配置的选项。**设备**允许你选择正在跟踪的设备类型。**姿态源**允许你选择提供跟踪数据的设备部分。**跟踪类型**下拉菜单指示跟踪哪种类型的运动（旋转、位置或两者）。 '
- en: '**Update Type** dictates when the tracking information updates, whether during
    the regular update cycle, before rendering the next frame, or both. If the **Use
    Relative Transform** checkbox is ticked, the tracking data is based on the device’s
    position and rotation relative to its initial state.'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**更新类型**决定了跟踪信息何时更新，是在常规更新周期中、在渲染下一帧之前，还是两者都更新。如果勾选了**使用相对变换**复选框，则跟踪数据基于设备相对于其初始状态的位置和旋转。'
- en: Finally, the **Use Pose Provider** field can be enabled to utilize an external
    source for tracking data, which is potentially useful for specialized tracking
    systems. Together, these settings give **Tracked Pose Driver** the flexibility
    to handle a wide range of AR scenarios.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，可以启用**使用姿态提供程序**字段以利用外部源进行跟踪数据，这对于专门的跟踪系统可能很有用。这些设置共同赋予**跟踪姿态驱动器**处理广泛AR场景的灵活性。
- en: The **AR Camera Background** component controls how the real-world view captured
    by your device’s camera is displayed in your AR scene. The **Use Custom Material**
    checkbox allows you to apply a custom material, for example, to add special visual
    effects to the real-world view. If left unchecked, the real-world view is displayed
    as is, without any additional effects.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR相机背景**组件控制您的设备相机捕获的真实世界视图在AR场景中的显示方式。**使用自定义材质**复选框允许您应用自定义材质，例如，为真实世界视图添加特殊视觉效果。如果未选中，则真实世界视图将按原样显示，不添加任何额外效果。'
- en: The AR Session Origin GameObject performs the critical task of converting AR
    session space into Unity’s world space. Given the unique coordinate system employed
    in AR (referred to as AR session space), this conversion is vital for accurately
    positioning the GameObjects relative to the AR Camera.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: AR会话原点GameObject执行将AR会话空间转换为Unity世界空间的临界任务。鉴于AR中使用的独特坐标系（称为AR会话空间），这种转换对于准确定位GameObject相对于AR相机至关重要。
- en: With this information about the most important GameObjects of our AR scene in
    mind, it is time to place a simple object in our AR scene.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记我们AR场景中最重要的GameObject的信息，现在是时候在我们的AR场景中放置一个简单对象了。
- en: Placing a simple cube into the AR scene
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一个简单的立方体放入AR场景
- en: To begin testing our AR functionality, we need a 3D object in our scene to visualize
    the AR effect. For this purpose, you can create a simple cube object. Right-click
    in your project hierarchy and choose `0`,`0`,`3`) and apply a rotation of (`30`,`0`,`0`),
    as shown in *Figure 4**.10*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始测试我们的AR功能，我们需要在场景中有一个3D对象来可视化AR效果。为此目的，您可以创建一个简单的立方体对象。在项目层次结构中右键单击，选择`0`,`0`,`3`)并应用旋转(`30`,`0`,`0`)，如图*图4**.10*所示。
- en: '![Figure 4.10 – The Transform values of the cube](img/B20869_04_10.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – 立方体的变换值](img/B20869_04_10.jpg)'
- en: Figure 4.10 – The Transform values of the cube
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 立方体的变换值
- en: These specific coordinates and rotations are only examples and can be altered
    according to your requirements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定的坐标和旋转只是示例，可以根据您的需求进行修改。
- en: The key objective is to position the object somewhere in the direction of the
    AR Camera and at a distinct distance. This placement will help verify whether
    the AR system is correctly overlaying virtual content onto the real world, as
    it provides a benchmark for alignment with your physical surroundings. It also
    allows you to gauge the depth perception capabilities of your AR system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关键目标是将对象放置在AR相机方向上，并在一个明显的距离处。这种放置将有助于验证AR系统是否正确地将虚拟内容叠加到真实世界中，因为它为您与物理环境对齐提供了一个基准。它还允许您评估AR系统的深度感知能力。
- en: To validate whether the cube will be correctly displayed in the AR view, you
    can either select the AR Camera in the hierarchy – this will cause a camera view
    to appear in the bottom-right corner of the **Scene** window – or switch to the
    **Game** window, as shown in *Figure 4**.11*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证立方体是否会在AR视图中正确显示，您可以选择层次结构中的AR相机 – 这将在**场景**窗口的右下角显示一个相机视图 – 或者切换到**游戏**窗口，如图*图4.11*所示。11*。
- en: '![Figure 4.11 – The Unity project showing how to validate whether the cube
    will be correctly displayed in the AR view](img/B20869_04_11.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – Unity项目展示如何验证立方体是否会在AR视图中正确显示](img/B20869_04_11.jpg)'
- en: Figure 4.11 – The Unity project showing how to validate whether the cube will
    be correctly displayed in the AR view
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – Unity项目展示如何验证立方体是否会在AR视图中正确显示
- en: 'In an AR application, AR Session Origin typically corresponds to the starting
    location of your device’s camera when the AR experience begins. However, positioning
    a virtual object directly at **Session Origin** can indeed cause some issues.
    Here are a few potential problems that could arise:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在AR应用程序中，AR会话原点通常对应于AR体验开始时您的设备相机的起始位置。然而，直接在**会话原点**放置虚拟对象确实可能引起一些问题。以下是一些可能出现的潜在问题：
- en: '**Inaccurate scaling**: If you were to place a virtual cube directly at **Session
    Origin**, it could appear disproportionately large or small compared to real-world
    objects. It’s like holding a real-life object very close to your eyes – even a
    small object can appear large.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不准确的缩放比例**：如果你将一个虚拟立方体直接放置在**会话原点**，它相对于现实世界中的物体可能会显得不成比例地很大或很小。这就像将一个真实物体非常靠近你的眼睛看——即使是小物体也会显得很大。'
- en: '**Interference with tracking**: **Session Origin** serves as a reference point
    for tracking the device’s movements in the real world. If you place a virtual
    object at this exact point, the AR system might struggle to track both the object
    and the device’s movements accurately.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪干扰**：**会话原点**作为跟踪设备在现实世界中的运动的参考点。如果你在这个确切点放置一个虚拟物体，AR系统可能难以准确跟踪物体和设备的运动。'
- en: '**Unpleasant user experience**: If a virtual object is positioned directly
    at **Session Origin**, it might appear too close to the user or even obstruct
    the user’s view of the rest of the AR scene, creating a less enjoyable experience.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不愉快的用户体验**：如果一个虚拟物体直接放置在**会话原点**，它可能会显得离用户太近，甚至遮挡用户对其他AR场景的视线，从而造成不愉快的体验。'
- en: Tip
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To avoid these issues, it’s generally recommended to position virtual objects
    at a reasonable distance from **Session Origin**. The precise location would depend
    on the specific requirements of your AR experience. For instance, if you’re creating
    an AR furniture placement app, you might position virtual furniture based on the
    detected real-world surfaces, such as floors and tables. By doing so, you ensure
    that the virtual furniture appears at an appropriate scale, doesn’t interfere
    with tracking, and provides a pleasant user experience by appearing in the correct
    place in the real world.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，通常建议将虚拟物体放置在**会话原点**的合理距离之外。确切的定位将取决于你的AR体验的具体要求。例如，如果你正在创建一个AR家具摆放应用，你可能根据检测到的现实世界表面（如地板和桌子）来定位虚拟家具。这样做可以确保虚拟家具以适当的比例出现，不会干扰跟踪，并在现实世界中出现在正确的位置，从而提供愉快的用户体验。
- en: After placing your cube, you can proceed with testing the scene by following
    the instructions outlined in the *Deploying AR experiences onto mobile devices*
    section of this chapter. As it stands, your AR application is simple, featuring
    a static object positioned in front of the user. However, we’re aiming for a more
    interactive experience, so we’ll delve into the anchor and plane detection functionalities
    in the upcoming section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置你的立方体后，你可以按照本章“将AR体验部署到移动设备”部分中概述的说明进行测试。目前，你的AR应用很简单，只在前方用户面前放置了一个静态对象。然而，我们希望提供更互动的体验，因此将在下一节深入探讨锚点和平面检测功能。
- en: Implementing plane detection in AR Foundation
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在AR Foundation中实现平面检测
- en: In this section, we will make use of AR Foundation’s **plane detection** capabilities.
    AR Foundation’s plane detection forms the crux of numerous practical applications
    by providing a cornerstone understanding of real-world environments. Its ability
    to identify and comprehend flat surfaces enables digital objects to interact meaningfully
    and realistically with physical spaces, enhancing the overall augmented reality
    experience.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用AR Foundation的**平面检测**功能。AR Foundation的平面检测通过提供对现实世界环境的基石理解，为众多实际应用奠定了基础。它识别和解析平坦表面的能力使得数字对象能够与物理空间进行有意义的、真实的交互，从而增强整体增强现实体验。
- en: In the retail and e-commerce sectors, plane detection is fundamental to accurate
    product visualization. It ensures a virtual couch is placed right in front of
    your living room wall and not in a random position in your room.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在零售和电子商务领域，平面检测对于准确的产品可视化至关重要。它确保虚拟沙发被放置在你的客厅墙壁前，而不是在你房间中的随机位置。
- en: This technology also underpins the immersive experiences in AR gaming. By identifying
    real-world surfaces, games such as Pokémon Go can accurately place virtual elements,
    enhancing the thrill of the chase. Other games use this technology to create worlds
    on your coffee table, maintaining the illusion by ensuring that virtual objects
    interact convincingly with the physical planes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也为AR游戏中的沉浸式体验奠定了基础。通过识别现实世界表面，如《精灵宝可梦GO》等游戏可以准确放置虚拟元素，增强追逐的乐趣。其他游戏使用这项技术来在你的咖啡桌上创建世界，通过确保虚拟对象与物理平面进行令人信服的交互来维持这种错觉。
- en: To make use of plane detection, enable the **AR Plane Manager** component you
    disabled in the *Exploring the AR Session Origin GameObject* section. Then, you
    can also delete the cube as we don’t need it anymore. Now, select **AR Session
    Origin** and inspect the **AR Plane Manager** component in the hierarchy.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用平面检测，启用在*探索AR会话原点GameObject*部分中禁用的**AR Plane Manager**组件。然后，您还可以删除立方体，因为我们不再需要它了。现在，选择**AR
    Session Origin**并检查层次结构中的**AR Plane Manager**组件。
- en: The **AR Plane Manager** component in Unity’s AR Foundation is responsible for
    detecting and tracking real-world surfaces, or planes, via your device’s camera.
    It utilizes AR technology to understand the physical environment, creating digital
    representations that can interact with virtual objects.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的AR Foundation中的**AR Plane Manager**组件负责通过您的设备摄像头检测和跟踪现实世界表面或平面。它利用AR技术来理解物理环境，创建可以与虚拟对象交互的数字表示。
- en: 'Here’s a breakdown of what **AR Plane** **Manager** does:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是**AR Plane** **Manager**所做的工作的分解：
- en: '**Plane Prefab**: This is essentially the digital template or blueprint used
    to represent detected planes. When **AR Plane Manager** identifies a flat surface
    (a plane) in the real world, it creates a **Plane Prefab** instance in the AR
    space. Each prefab instance corresponds to a specific real-world plane, providing
    a surface on which you can place or interact with virtual objects.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平面预制件**：这实际上是用于表示检测到的平面的数字模板或蓝图。当**AR Plane Manager**在现实世界中识别到一个平坦的表面（一个平面）时，它会在AR空间中创建一个**Plane
    Prefab**实例。每个预制件实例对应于一个特定的现实世界平面，提供了一个可以放置或与之交互的虚拟对象的表面。'
- en: Let’s say, for example, you’re creating an AR game where virtual cats roam around.
    The **Plane Prefab** instance could be a flat surface that the cats can walk on.
    If your living room floor is detected as a plane, a **Plane Prefab** instance
    will be created, providing a surface for your cats to frolic on.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设，例如，您正在创建一个AR游戏，其中虚拟猫四处游荡。**Plane Prefab**实例可以是一个猫可以行走的平坦表面。如果您的客厅地板被检测为一个平面，将创建一个**Plane
    Prefab**实例，为您的猫提供嬉戏的表面。
- en: '**Detection Mode**: This setting determines the orientation of planes that
    **AR Plane Manager** should detect. Here are some components within **Detection
    Mode** that would be useful for you:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测模式**：此设置确定**AR Plane Manager**应检测的平面的方向。以下是**检测模式**中一些对您有用的组件：'
- en: '**Everything**: This setting combines the detection of horizontal and vertical
    planes by **AR Plane Manager**. If you’re creating an AR furniture placement app,
    you might use this setting. The app could then detect both the floor (a horizontal
    plane, for placing a chair) and the walls (vertical planes, for hanging pictures).'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一切**：此设置通过**AR Plane Manager**结合了水平和垂直平面的检测。如果您正在创建一个AR家具放置应用，您可能会使用此设置。该应用可以检测地板（水平平面，用于放置椅子）和墙壁（垂直平面，用于挂画）。'
- en: '**Horizontal**: **AR Plane Manager** will detect only flat surfaces oriented
    horizontally, such as floors and tabletops. For instance, if you’re creating an
    AR game where characters run around on the floor, you’d likely use this mode.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平**：**AR Plane Manager**将仅检测水平方向的平坦表面，例如地板和桌面。例如，如果您正在创建一个AR游戏，其中角色在地板上跑来跑去，您可能会使用这种模式。'
- en: '**Vertical**: Conversely, this setting will detect only vertically oriented
    surfaces, such as walls and doors. This might be used in an AR interior design
    app that allows the user to place virtual paintings or wallpapers on their walls.'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直**：相反，此设置将仅检测垂直方向的表面，例如墙壁和门。这可能在允许用户在墙上放置虚拟画作或墙纸的AR室内设计应用中使用。'
- en: As we want to detect horizontal and vertical planes, the drop-down selection
    can remain at **Everything**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要检测水平和垂直平面，下拉选择可以保持在**一切**。
- en: Next, you will notice that the AR template already has an **ARPlane** prefab
    assigned. This prefab is what you will see on top of the detected surfaces. As
    this prefab is already configured, you can use the **ARPlane** prefab. However,
    you can also create your custom-made plane prefab. This can be done by right-clicking
    in the hierarchy window and selecting **XR** | **AR** **Default Plane.**
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您会注意到AR模板已经分配了一个**ARPlane**预制件。这个预制件就是您将在检测到的表面上方看到的。由于这个预制件已经配置好了，您可以使用**ARPlane**预制件。然而，您也可以创建您定制的平面预制件。这可以通过在层次结构窗口中右键单击并选择**XR**
    | **AR** **默认平面**来完成。
- en: '**AR Default Plane GameObject** in Unity’s AR Foundation is composed of various
    components, each of which performs a specific function within the overall system.
    Here’s a breakdown of what each of these components does:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity的AR Foundation中的AR默认平面GameObject**由各种组件组成，每个组件在整体系统中执行特定功能。以下是每个组件所做工作的分解：'
- en: '**AR Plane**: This script controls the essential behavior of a plane in the
    AR environment. Two notable fields in this script are as follows:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR平面**：此脚本控制AR环境中平面的基本行为。此脚本中有两个值得注意的字段如下：'
- en: '**Destroy on Removal** checkbox: If checked, when a detected plane is removed
    or no longer needed, the corresponding **Plane** GameObject is destroyed or removed
    from the Unity scene to free up resources. Imagine this to be like cleaning up
    toys when you’re done playing with them to make space for other activities.'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除时销毁**复选框：如果选中，当检测到的飞机被移除或不再需要时，相应的**平面**GameObject将被销毁或从Unity场景中移除以释放资源。想象一下，这就像在玩完玩具后打扫玩具，为其他活动腾出空间。'
- en: '**Vertex Changed Threshold**: This field controls how sensitive the plane is
    to changes in its detected shape. If the real-world surface changes, the plane’s
    mesh vertices will need to be updated. This threshold determines how much change
    is needed before an update occurs. It’s like deciding when to adjust a puzzle
    because the pieces have moved – too often can be unnecessary, yet too seldom and
    the picture may not make sense.'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点变化阈值**：此字段控制飞机对其检测到的形状变化的敏感度。如果现实世界表面发生变化，飞机的网格顶点需要更新。此阈值确定在更新发生之前需要多少变化。这就像决定何时调整拼图，因为拼图已经移动——太频繁可能是不必要的，而太稀少则图片可能没有意义。'
- en: '**AR Plane Mesh Visualizer**: This script is responsible for rendering the
    visual representation of a detected plane. Imagine you’re using an AR app on your
    phone to preview a piece of furniture in your room before buying it. When you
    point your phone’s camera at the floor, the app detects a flat surface – a plane.
    **AR Plane Mesh Visualizer** then creates a visible grid or pattern overlay on
    your phone screen that represents this detected plane.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR平面网格可视化器**：此脚本负责渲染检测到的平面的视觉表示。想象一下，你正在使用手机上的AR应用来预览在购买之前房间里的家具。当你用手机的摄像头指向地板时，应用检测到一个平坦的表面——一个平面。**AR平面网格可视化器**随后在你的手机屏幕上创建一个可见的网格或图案叠加，代表这个检测到的平面。'
- en: '**Tracking State Visibility** dropdown (**None**, **Limited**, **Tracking**):
    This setting determines when the plane should be visible based on the tracking
    quality. For instance, you might only want to see the plane when it’s fully tracked
    (good quality), or also when tracking is limited (lower quality). It’s like deciding
    when to display a picture – if it’s blurry, you might prefer to wait for it to
    load until it’s clear.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪状态可见性**下拉菜单（**无**，**有限**，**跟踪**）：此设置确定飞机何时应该可见，基于跟踪质量。例如，你可能只想在飞机完全被跟踪（高质量）时看到它，或者当跟踪有限（低质量）时也看到它。这就像决定何时显示图片——如果它模糊不清，你可能更喜欢等待它加载到清晰为止。'
- en: '**Hide Subsumed** checkbox: If checked, when one detected plane is subsumed
    by another (i.e., entirely overlapped by a larger plane), the smaller plane is
    hidden. This can make the AR scene less cluttered and more efficient. Think of
    this to be like removing smaller rugs when you put down a larger one that covers
    them completely.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐藏包含**复选框：如果选中，当一个检测到的平面被另一个平面包含（即完全被更大的平面覆盖）时，较小的平面将被隐藏。这可以使AR场景更简洁、更高效。想象一下，这就像在放下一个完全覆盖它们的更大地毯时移除较小的地毯。'
- en: '**Mesh Collider**: This component allows virtual objects to physically interact
    with the plane as if it were a solid surface. For example, if you drop a virtual
    ball onto the plane, **Mesh Collider** ensures that the ball bounces back rather
    than falling through the surface.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格碰撞器**：此组件允许虚拟对象以固体表面的方式与飞机进行物理交互。例如，如果你将一个虚拟球体扔到平面上，**网格碰撞器**确保球体弹回而不是穿过表面。'
- en: '**Mesh Filter** and **Mesh Renderer**: These work together to create and display
    the 3D mesh for the plane. **Mesh Filter** generates the shape of the plane (the
    mesh), while **Mesh Renderer** applies materials and textures and renders it on
    the screen. They’re like a sculptor and a painter respectively, working together
    to create a lifelike statue.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格过滤器**和**网格渲染器**：它们共同创建并显示平面的3D网格。**网格过滤器**生成平面的形状（网格），而**网格渲染器**应用材质和纹理并在屏幕上渲染它。它们分别像雕塑家和画家一样，共同工作以创建逼真的雕像。'
- en: '**Line Renderer**: This component is often used to draw the border around the
    detected plane, helping the user to see the extent of the plane. It’s like drawing
    a chalk outline around an area to indicate its boundaries.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线渲染器**：这个组件通常用于绘制检测到的平面的边界，帮助用户看到平面的范围。就像在某个区域周围画上粉笔轮廓来指示其边界一样。'
- en: All these components work in harmony to detect, represent, and interact with
    real-world surfaces in your AR applications, ensuring a seamless blend of virtual
    objects with the physical environment. You can keep the default settings for our
    scene.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件协同工作，以检测、表示和与你的 AR 应用程序中的真实世界表面进行交互，确保虚拟对象与物理环境的无缝融合。你可以保留我们场景的默认设置。
- en: After creating `Prefabs`. Next, drag `Prefabs` folder. Doing so will automatically
    create a prefab out of it. With **AR Session Origin** now selected, drag the **AR
    Default Plane** prefab to the appropriate **Plane Prefab** field of the **AR Plane
    Manager** component within the Inspector, as illustrated in *Figure 4**.12*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `Prefabs` 后，接下来拖动 `Prefabs` 文件夹。这样做将自动将其创建为预制件。现在选择 **AR 会话原点**，将 **AR 默认平面**
    预制件拖动到检查器中 **AR 平面管理器** 组件的适当 **平面预制件** 字段，如图 *图 4.12* 所示。
- en: '![Figure 4.12 – The AR Default Plane prefab assigned to the appropriate Plane
    Prefab field of the AR Plane Manager component](img/B20869_04_12.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 分配给 AR 平面管理组件适当平面预制件字段的 AR 默认平面预制件](img/B20869_04_12.jpg)'
- en: Figure 4.12 – The AR Default Plane prefab assigned to the appropriate Plane
    Prefab field of the AR Plane Manager component
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 分配给 AR 平面管理组件适当平面预制件字段的 AR 默认平面预制件
- en: Now, your application would be able to detect a plane in your environment and
    place the plane prefab of your choice on top of it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的应用程序将能够检测你环境中的平面，并将你选择的平面预制件放置在其上方。
- en: '*Figure 4**.13* shows the default plane prefab of Unity’s AR template.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.13* 展示了 Unity AR 模板的默认平面预制件。'
- en: '![Figure 4.13 – The plane prefab of Unity’s AR template detecting the wooden
    floor of an apartment](img/B20869_04_13.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – Unity AR 模板的平面预制件检测公寓的木地板](img/B20869_04_13.jpg)'
- en: Figure 4.13 – The plane prefab of Unity’s AR template detecting the wooden floor
    of an apartment
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – Unity AR 模板的平面预制件检测公寓的木地板
- en: As we can see, with AR Foundation, it is straightforward to incorporate plane
    detection into a project and to project patterns onto detected surfaces. In the
    upcoming section, we will merge these concepts with the use of anchors and touch
    inputs. This combination will enable us to place an object onto a detected surface
    simply by tapping on the screen.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用 AR 基础库，将平面检测集成到项目中并将图案投影到检测到的表面上非常简单。在下一节中，我们将结合使用锚点和触摸输入来合并这些概念。这种组合将使我们能够通过在屏幕上轻触来简单地放置一个对象到检测到的表面上。
- en: Implementing touch inputs and anchors
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现触摸输入和锚点
- en: 'To get started on working with touch inputs and anchors, enable the **AR Anchor
    Manager**, **AR Raycast Manager**, and **Anchor Creator** components in the Inspector
    when **AR Session Origin** is selected. These components are all we need to get
    the touch input and anchors to work. Let’s break each of them down:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用触摸输入和锚点，当选择 **AR 会话原点** 时，在检查器中启用 **AR 锚点管理器**、**AR 光线投射管理器** 和 **锚点创建器**
    组件。这些组件就是我们需要的，以便使触摸输入和锚点工作。让我们逐一分析它们：
- en: '**AR Anchor Manager** script: **AR Anchor Manager** operates as the custodian
    of object stability in your AR space. When you designate a position for a virtual
    object within your AR scene, **Anchor Manager** ensures the object remains tethered
    to that specific real-world location, irrespective of changes in device perspective.
    It is akin to an overseer, maintaining each virtual object in its correct placement
    relative to the real-world coordinates.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR 锚点管理器** 脚本：**AR 锚点管理器**作为你 AR 空间中对象稳定性的守护者。当你在你 AR 场景中为虚拟对象指定位置时，**锚点管理器**确保对象始终与该特定真实世界位置相连，无论设备视角如何变化。它就像一个监管者，保持每个虚拟对象相对于真实世界坐标的正确位置。'
- en: '**AR Raycast Manager** script: Acting as the tactile sense of your AR application,
    **AR Raycast Manager** emits invisible rays from your device into the scene. When
    these rays encounter a surface, they return data about its position and orientation.
    This process is key to interactions such as placing a virtual object on a real-world
    surface, as it enables your application to perceive and understand the topography
    of the environment.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR Raycast Manager**脚本：作为您AR应用的触觉感知，**AR Raycast Manager**从您的设备向场景发射不可见的射线。当这些射线遇到表面时，它们会返回有关其位置和方向的数据。这个过程对于放置虚拟对象在现实世界表面上的交互等操作至关重要，因为它使您的应用能够感知和理解环境的拓扑结构。'
- en: '**Anchor Creator** script: This script functions as an efficient tool, facilitating
    the creation and placement of new anchors within your scene. Given that anchors
    are pivotal to securing virtual objects in a consistent real-world location, **Anchor
    Creator** simplifies the process of generating these anchor points. This can range
    from situating a new virtual object to immobilizing an object in transit.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Anchor Creator**脚本：此脚本作为一个高效的工具，简化了在场景中创建和放置新锚点的过程。鉴于锚点对于在一致的现实世界位置固定虚拟对象至关重要，**Anchor
    Creator**简化了生成这些锚点的过程。这可以包括放置新的虚拟对象到使正在运输的对象固定不动。'
- en: Even though all components have a **Prefab** field, we just need to assign a
    prefab to the **AR Anchor Manager** component. This prefab will be spawned when
    we tap on the screen.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有组件都有一个**Prefab**字段，但我们只需要将一个预制体分配给**AR Anchor Manager**组件。当我们在屏幕上点击时，这个预制体会被实例化。
- en: When you tap on the screen, **AR Raycast Manager** determines where in the real
    world you’ve indicated by casting a ray from your screen touch point into the
    AR scene. If this ray hits a detected surface, **AR Anchor Manager** creates an
    anchor at this real-world location and ties the prefab to it. This process ensures
    the stable positioning of your virtual object in the AR scene.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击屏幕时，**AR Raycast Manager**通过从屏幕触摸点向AR场景发射射线来确定您在现实世界中的指示位置。如果这个射线击中了一个检测到的表面，**AR
    Anchor Manager**就会在这个现实世界位置创建一个锚点，并将预制体与之绑定。这个过程确保了您的虚拟对象在AR场景中的稳定定位。
- en: The prefab attached to **AR Anchor Manager** essentially acts as a template
    for the object you want to instantiate (or create) in the AR environment whenever
    the screen is tapped. This is why it’s essential to assign a prefab to **AR**
    **Anchor Manager**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 附在**AR Anchor Manager**上的预制体本质上充当了您想在AR环境中实例化（或创建）的对象的模板，无论何时屏幕被点击。这就是为什么将预制体分配给**AR**
    **Anchor Manager**至关重要的原因。
- en: The other components do not require a prefab because they are not directly responsible
    for creating objects in your AR scene. **AR Raycast Manager** deals with detecting
    the real-world surfaces you are interacting with, and **Anchor Creator** facilitates
    the creation and placement of the anchors themselves. Neither of these tasks necessitates
    the creation of a new object from a prefab.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 其他组件不需要预制体，因为它们不直接负责在您的AR场景中创建对象。**AR Raycast Manager**负责检测您与之交互的现实世界表面，而**Anchor
    Creator**则促进锚点本身创建和放置。这些任务都不需要从预制体中创建新对象。
- en: For demonstration purposes, we use a simple capsule primitive. Simply right-click
    in the hierarchy and select `0.2`,`0.2`,`0.2`). Now, create a new folder in the
    `Project` folder called `Prefabs` (right-click + **Create** | **Folder**) and
    drag the capsule into this folder. This will automatically create a prefab of
    the capsule that you can drag into the **Anchor Prefab** field of the **AR Anchor**
    **Manager** component.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们使用了一个简单的胶囊原形。只需在层次结构中右键单击，然后选择`0.2`,`0.2`,`0.2`)。现在，在`Project`文件夹中创建一个名为`Prefabs`的新文件夹（右键单击
    + **创建** | **文件夹**），并将胶囊拖入此文件夹。这将自动创建一个胶囊的预制体，您可以将它拖入**AR Anchor** **Manager**组件的**Anchor
    Prefab**字段。
- en: Now, your app should spawn the capsule on a touch input. *Figure 4**.14* shows
    the deployed application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您触摸屏幕时，您的应用应该会在触摸输入处实例化胶囊。*图4.14*显示了部署的应用。
- en: '![Figure 4.14 – The deployed application](img/B20869_04_14.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14 – 部署的应用](img/B20869_04_14.jpg)'
- en: Figure 4.14 – The deployed application
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – 部署的应用
- en: The preceding image illustrates the instantiated capsule prefabs following screen
    taps. These capsules are positioned atop the detected surface, confirming the
    effective operation of the AR systems. Specifically, **AR Raycast Manager** accurately
    casts rays from the screen touch point onto the detected surface, and in response,
    **AR Anchor Manager** successfully creates anchors, anchoring the prefabs at the
    indicated locations. Everything should now be working perfectly, so it’s time
    to build the scene onto your device. Depending on whether you’re using an Android
    or iOS device, you can navigate to the relevant subsection in the following section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片说明了屏幕点击后实例化的胶囊预制件。这些胶囊位于检测到的表面之上，证实了 AR 系统的有效运行。具体来说，**AR Raycast Manager**
    准确地将射线从屏幕触摸点投射到检测到的表面，作为回应，**AR Anchor Manager** 成功创建锚点，将预制件锚定在指示的位置。现在一切应该都运行得很好，是时候将场景构建到您的设备上了。根据您是否使用
    Android 或 iOS 设备，您可以在下一节的相关子节中导航。
- en: Testing AR experiences directly in Unity
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Unity 中直接测试 AR 体验
- en: 'As of *AR Foundation 5.0*, developers can conveniently test AR scenes right
    in the Unity Editor using the **XR Simulation** feature, without the constant
    need to deploy on mobile devices. By the time you read this book, this feature
    might already be pre-installed. Let’s quickly check that by following these steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 自 *AR Foundation 5.0* 以来，开发者可以使用 **XR 模拟** 功能方便地在 Unity 编辑器中测试 AR 场景，而无需不断在移动设备上部署。到您阅读这本书的时候，这个功能可能已经预先安装。让我们通过以下步骤快速检查：
- en: Navigate to **Edit** | **Project Settings**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**编辑** | **项目设置**。
- en: Choose **XR** **Plug-in Management**.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**XR 插件管理**。
- en: Look for the **XR Simulation** option under **Plug-in Providers** and enable
    it.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**插件提供者**下查找**XR 模拟**选项并启用它。
- en: If you don’t see the **XR Simulation** option, you’ll need to manually install
    *AR Foundation 5.0* or a newer version. The next section explains how to do this.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到**XR 模拟**选项，您需要手动安装 *AR Foundation 5.0* 或更高版本。下一节将解释如何进行此操作。
- en: Installing AR Foundation 5.0 or later versions and related packages
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 AR Foundation 5.0 或更高版本及相关包
- en: 'When you edit your project manifest, you control which package versions Unity
    loads into your project. There are two ways to edit your project manifest: add
    a package by name in **Package Manager**, or manually edit the project manifest
    file. Let’s do it in **Package Manager**:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编辑项目清单时，您控制着 Unity 将哪些包版本加载到您的项目中。有两种方法可以编辑项目清单：在**包管理器**中按名称添加包，或手动编辑项目清单文件。让我们在**包管理器**中完成它：
- en: Select **Window** | **Package Manager** to open the **Package** **Manager**
    window.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**窗口** | **包管理器**以打开**包管理器**窗口。
- en: Click on the small `com.unity.xr.arfoundation`. This will automatically add
    the most recent version available. At the time of writing, this is version **5.1.0**.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击小图标 `com.unity.xr.arfoundation`。这将自动添加最新版本。在撰写本文时，这是版本 **5.1.0**。
- en: If you want to use a specific version, you can type in your desired version
    in the **Version (****optional)** field.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想使用特定版本，您可以在**版本（可选）**字段中输入您想要的版本。
- en: Continue by updating the `com.unity.xr.openxr`. This action will import the
    latest version of the **OpenXR** plugin.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续更新 `com.unity.xr.openxr`。此操作将导入 **OpenXR** 插件的最新版本。
- en: If you’re upgrading from *AR Foundation 4* to a newer version, uninstall both
    the `com.unity.xr.arkit-face-tracking` and `com.unity.xr.arsubsystems`. If they
    appear in the search results, proceed with uninstallation; otherwise, they are
    not present in your project.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您是从 *AR Foundation 4* 升级到较新版本，请卸载 `com.unity.xr.arkit-face-tracking` 和 `com.unity.xr.arsubsystems`。如果它们出现在搜索结果中，请继续卸载；否则，它们不在您的项目中。
- en: Next, depending on your targeted mobile device platform, it’s important to update
    either the *ARCore* or *ARKit* packages. Navigate to the `com.unity.xr.arcore`
    and ensure its version aligns with that of *AR Foundation*. For iOS platforms,
    input `com.unity.xr.arkit`, making sure its version matches *AR Foundation*’s.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据您目标移动设备平台，更新 *ARCore* 或 *ARKit* 包非常重要。导航到 `com.unity.xr.arcore` 并确保其版本与
    *AR Foundation* 保持一致。对于 iOS 平台，输入 `com.unity.xr.arkit`，确保其版本与 *AR Foundation*
    匹配。
- en: Note
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Always remember to refer to the *AR Foundation* documentation for the most
    recent version details and Editor compatibility: [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/project-setup/install-arfoundation.html](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/project-setup/install-arfoundation.html).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得查阅 *AR 基础* 文档以获取最新版本细节和编辑器兼容性：[https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/project-setup/install-arfoundation.html](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/project-setup/install-arfoundation.html)。
- en: Now, if you revisit **XR Plug-in Management** via the aforementioned quick check,
    the **XR Simulation** option should be visible in the **Windows, Mac, Linux settings**
    tab, as shown in *Figure 4**.15*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你通过上述快速检查重新访问**XR 插件管理**，**XR 模拟**选项应该会在**Windows、Mac、Linux 设置**标签页中可见，如图
    *4.15* 所示。
- en: '![Figure 4.15 – The Windows, Mac, Linux settings tab of the XR Plug-in Management
    window with the XR Simulation checkbox enabled](img/B20869_04_15.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 启用 XR 模拟复选框的 XR 插件管理窗口的 Windows、Mac、Linux 设置标签页](img/B20869_04_15.jpg)'
- en: Figure 4.15 – The Windows, Mac, Linux settings tab of the XR Plug-in Management
    window with the XR Simulation checkbox enabled
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 启用 XR 模拟复选框的 XR 插件管理窗口的 Windows、Mac、Linux 设置标签页
- en: With this feature activated, you’re primed to choose an environment and test
    the AR scene within Unity.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能激活后，你就可以选择一个环境并在 Unity 中测试 AR 场景了。
- en: Choosing an environment and testing the scene
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择环境和测试场景
- en: To test an AR scene within Unity, you’ll need an environment that emulates the
    real-world setting. To find the right simulation setting, go to **Window** | **XR**
    | **AR** **Foundation** | **XR Environment**. In the middle of the **XR Environment**
    interface, there’s an **Environment** dropdown. Initially, your project will offer
    just one environment option. While it’s possible to add more by importing sample
    environments, **DefaultSimulationEnvironment** is usually adequate for most testing
    needs. Simply choose this option. Once you’ve made your selection, hit the play
    button to activate play mode and start the simulation. You’ll now be able to view
    your scene in real time, as depicted in *Figure 4**.16*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Unity 中测试 AR 场景，你需要一个模拟真实世界设置的环境。为了找到正确的模拟设置，请转到 **窗口** | **XR** | **AR 基础**
    | **XR 环境**。在 **XR 环境** 界面的中间位置，有一个 **环境** 下拉菜单。最初，你的项目将只提供一个环境选项。虽然可以通过导入示例环境来添加更多选项，但
    **DefaultSimulationEnvironment** 通常足以满足大多数测试需求。只需选择此选项。一旦做出选择，点击播放按钮以激活播放模式并开始模拟。现在你将能够实时查看你的场景，如图
    *4.16* 所示。
- en: '![Figure 4.16 – XR Simulation at runtime](img/B20869_04_16.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – 运行时的 XR 模拟](img/B20869_04_16.jpg)'
- en: Figure 4.16 – XR Simulation at runtime
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 运行时的 XR 模拟
- en: Pressing the play button transfers you to the **Game** mode of **XR Simulation**,
    presenting the simulated AR scene (highlighted as *1* in *Figure 4**.16*). In
    this mode, you can adjust the viewpoint as needed, witnessing features such as
    plane detection in real time. Once satisfied with the viewpoint, you can shift
    from **Game** mode to **Simulator** mode (highlighted as *2* in *Figure 4**.16*)
    using the dropdown in the top-left corner. It’s important to switch to **Simulator**
    mode to access the **XR Simulation** functionalities, such as touch inputs. Observing
    the scene shown as *2* in *Figure 4**.16*, you’ll notice key features such as
    the distinct white point pattern, indicating the detected plane, and white capsules,
    marking the spots where mouse clicks occurred.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放按钮会将你切换到 **XR 模拟** 的 **游戏** 模式，展示模拟的 AR 场景（如图 *4.16* 中的 *1* 所示）。在此模式下，你可以根据需要调整视角，实时见证如平面检测等特性。一旦对视角满意，你可以通过左上角的下拉菜单从
    **游戏** 模式切换到 **模拟器** 模式（如图 *4.16* 中的 *2* 所示）。切换到 **模拟器** 模式对于访问 **XR 模拟** 的功能，如触摸输入，非常重要。观察图
    *4.16* 中显示为 *2* 的场景，你会注意到如独特的白色点图案，指示检测到的平面，以及白色胶囊，标记鼠标点击的位置。
- en: However, it’s crucial to be aware of the constraints surrounding **XR Simulation**.
    Some elements might seem smaller than expected, and the resolution may not be
    the sharpest. Although **XR Simulation** provides a convenient testing avenue,
    it’s not a complete substitute for deploying the AR scene on an actual device.
    Consider it a tool for iterative testing until you’re confident about deploying
    it onto your target mobile device.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解**XR模拟**的限制至关重要。一些元素可能看起来比预期的要小，分辨率可能不是最清晰的。尽管**XR模拟**提供了一个方便的测试途径，但它并不是在真实设备上部署AR场景的完整替代品。将其视为在您对部署到目标移动设备有信心之前进行迭代测试的工具。
- en: Now, let’s proceed to launch the scene on our smartphone and observe the outcome.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续在智能手机上启动场景并观察结果。
- en: Deploying AR experiences onto mobile devices
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将AR体验部署到移动设备上
- en: 'It’s now time to launch your AR experiences onto smartphones or tablets. Primarily,
    you have two paths to accomplish this: deployment onto an Android or an iOS device.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将您的AR体验部署到智能手机或平板电脑上了。主要来说，您有两个途径来完成这个任务：部署到Android或iOS设备。
- en: For solo projects, where the AR application is meant for personal use, you may
    opt to deploy onto just Android or iOS, depending on your device’s operating system.
    However, for larger-scale projects that involve several users – be it academic,
    industrial, or any other group, irrespective of its size – it’s advisable to deploy
    and test the AR app on both Android and iOS platforms.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于个人项目，如果AR应用程序仅用于个人使用，您可以选择仅部署到Android或iOS，具体取决于您的设备操作系统。然而，对于涉及多个用户的更大规模项目——无论是学术的、工业的还是任何其他规模的组织——建议在Android和iOS平台上部署和测试AR应用程序。
- en: This strategy has multiple benefits. First, if your application gains momentum
    or its usage expands, it would already be compatible with both major platforms,
    eliminating the need for time-consuming porting later on. Second, making your
    app accessible on both platforms from the outset can draw in more users, and possibly
    attract increased funding or support.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略有多个好处。首先，如果您的应用程序获得动力或其使用范围扩大，它将已经与两个主要平台兼容，从而消除了以后进行耗时移植的需要。其次，从一开始就在两个平台上提供您的应用程序可以吸引更多用户，并可能吸引更多的资金或支持。
- en: Another key advantage to this is the cross-platform compatibility offered by
    Unity. This enables you to maintain a singular code base for both platforms, simplifying
    the management and updating process for your application. Any modifications made
    need to be done in one location and then deployed across both platforms.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这还有另一个关键优势，那就是Unity提供的跨平台兼容性。这使您可以为两个平台维护一个单一的代码库，简化了应用程序的管理和更新过程。任何修改都需要在一个位置完成，然后部署到两个平台。
- en: In the next section, we’ll delve into the steps required to deploy your AR scene
    onto an Android device.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨将您的AR场景部署到Android设备上所需的步骤。
- en: Deploying onto Android
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到Android
- en: 'This section outlines the procedure to deploy your AR scene onto an Android
    device. The initial part of the process involves enabling some settings on your
    phone to prepare it for testing. Here’s a step-by-step guide:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了将您的AR场景部署到Android设备上的步骤。过程的前一部分涉及在您的手机上启用一些设置，以准备测试。以下是一个逐步指南：
- en: Confirm that your device is compatible with ARCore. ARCore is essential for
    AR Foundation to work correctly. You can find a list of supported devices at [https://developers.google.com/ar/devices](https://developers.google.com/ar/devices).
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您的设备与ARCore兼容。ARCore是AR Foundation正确工作的必要条件。您可以在[https://developers.google.com/ar/devices](https://developers.google.com/ar/devices)找到支持的设备列表。
- en: Install ARCore, which AR Fo[undation uses to enable AR capabilities on Android
    devices. ARCo](https://play.google.com/store/apps/details?id=com.google.ar.core)re
    can be downloaded from the Google Play Store at [https://play.google.com/store/apps/details?id=com.google.ar.core](https://play.google.com/store/apps/details?id=com.google.ar.core).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装ARCore，这是AR Foundation用来在Android设备上启用AR功能的应用。ARCore可以从Google Play Store下载，链接为[https://play.google.com/store/apps/details?id=com.google.ar.core](https://play.google.com/store/apps/details?id=com.google.ar.core)。
- en: Activate **Developer Options**. To do this, open **Settings** on your Android
    device, scroll down, and select **About Phone**. Find **Build number** and tap
    it seven times until a message appears stating **You are now** **a developer!**
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活**开发者选项**。为此，打开您的Android设备上的**设置**，向下滚动，并选择**关于手机**。找到**构建号**并连续点击七次，直到出现消息提示**您现在**是**开发者**！
- en: Upon returning to the main **Settings** menu, you should now see an option called
    **Developer Options**. If it’s not present, perform an online search to find out
    how to enable developer mode for your specific device. Though the method described
    in the previous step is the most common, the variety of Android devices available
    might require slightly different steps.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到主**设置**菜单后，你现在应该会看到一个名为**开发者选项**的选项。如果它不存在，请进行在线搜索以了解如何为您的特定设备启用开发者模式。虽然前一步中描述的方法是最常见的，但可用的各种Android设备可能需要略微不同的步骤。
- en: With **Developer Options** enabled, turn on **USB Debugging**. This will allow
    you to transfer your AR scene to your Android device via a USB cable. Navigate
    to **Settings** | **Developer options**, scroll down to **USB Debugging**, and
    switch it on. Acknowledge any pop-up prompts.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**开发者选项**启用后，打开**USB调试**。这将允许您通过USB电缆将您的AR场景传输到您的Android设备。导航到**设置** | **开发者选项**，向下滚动到**USB调试**，并将其打开。确认任何弹出提示。
- en: 'Depending on your Android version, you might need to allow the installation
    of apps from unknown sources:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的Android版本，您可能需要允许安装来自未知来源的应用：
- en: 'For Android versions 7 (Nougat) and earlier: Navigate to **Settings** | **Security
    Settings** and then check the box next to **Unknown Sources** to allow the installation
    of apps from sources other than the Google Play Store.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Android 7（牛轧糖）及更早版本：导航到**设置** | **安全设置**，然后勾选**未知来源**旁边的框以允许安装来自Google Play
    Store之外的应用。
- en: 'For Android versions 8 (Oreo) and above: Select **Settings** |**Apps & Notifications**
    | **Special App Access** | **Install unknown apps** and activate **Unknown sources**.
    You will see a list of apps that you can grant permission to install from unknown
    sources. This is where you select the *File Manager* app, as you’re using it to
    download the unknown app from Unity.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Android 8（奥利奥）及更高版本：选择**设置** | **应用与通知** | **特殊应用访问** | **安装未知应用**并激活**未知来源**。您将看到一个可以授予安装未知来源权限的应用列表。这就是您选择*文件管理器*应用的地方，因为您正在使用它从Unity下载未知应用。
- en: Link your Android device to your computer using a USB cable. You can typically
    use your device’s charging cable for this. A prompt will appear on your Android
    device asking for permission to allow USB debugging from your computer. Confirm
    it.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用USB电缆将您的Android设备连接到您的计算机。通常您可以使用设备的充电电缆进行此操作。您的Android设备上会出现提示，要求允许计算机进行USB调试。确认它。
- en: With your Android device properly prepared for testing AR scenes, you can now
    proceed to deploy your Unity AR scene. This involves adjusting several parameters
    in the Unity Editor’s **Build Settings** and **Player Settings**.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Android设备为测试AR场景做好适当准备后，您现在可以继续部署您的Unity AR场景。这涉及到在Unity编辑器的**构建设置**和**玩家设置**中调整几个参数。
- en: 'Here’s a step-by-step guide on how to do this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个逐步指南，说明如何进行此操作：
- en: Select **File** | **Build Settings** | **Android**, then click the **Switch
    Platform** button. Now, your **Build Settings** should look something like what
    is illustrated in *Figure 4**.17*.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件** | **构建设置** | **Android**，然后点击**切换平台**按钮。现在，您的**构建设置**应该看起来像*图4.17*中所示。17*。
- en: '![Figure 4.17 – Unity’s Build Settings configuration for Android](img/B20869_04_17.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图4.17 – Unity为Android的构建设置配置](img/B20869_04_17.jpg)'
- en: Figure 4.17 – Unity’s Build Settings configuration for Android
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 – Unity为Android的构建设置配置
- en: Next, click on the `Android 7.0 Nougat (API level 24)` or above. This is crucial,
    as ARCore requires at least Android 7.0 to function properly.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击`Android 7.0 Nougat (API level 24)`或更高版本。这是至关重要的，因为ARCore至少需要Android 7.0才能正常工作。
- en: Remaining in the `com.company_name.application_name`. This pattern is a widely
    adopted convention for naming application packages in Android and is used to ensure
    unique identification for each application on the Google Play Store.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持处于`com.company_name.application_name`。这种模式是Android中广泛采用的命名应用包的惯例，用于确保每个应用在Google
    Play Store中的唯一标识。
- en: Return to `Builds`. Upon selecting this folder, Unity will construct the scene
    within the newly created `Builds` folder.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`构建`。选择此文件夹后，Unity将在新创建的`构建`文件夹中构建场景。
- en: This is how you can set up your Android device for deploying AR scenes onto
    it. In the next section, you will learn how you can deploy your AR scene onto
    an iOS device, such as an iPhone or iPad.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何设置您的Android设备以部署AR场景到它。在下一节中，您将学习如何将您的AR场景部署到iOS设备，例如iPhone或iPad。
- en: Deploying onto iOS
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到iOS
- en: Before we delve into the process of deploying an AR scene onto an iOS device,
    it’s important to discuss certain hardware prerequisites. Regrettably, if you’re
    using a Windows PC and an iOS device, it’s not as straightforward as deploying
    an AR scene made in Unity. The reason for this is that Apple, in its characteristic
    style, requires the use of *Xcode*, its proprietary development environment, as
    an intermediary step. This is only available on Mac devices, not Windows or Linux.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论将AR场景部署到iOS设备的过程之前，讨论某些硬件先决条件是很重要的。遗憾的是，如果你正在使用Windows PC和iOS设备，这并不像部署在Unity中制作的AR场景那样简单。原因在于，苹果以其特有的风格，要求使用*Xcode*，其专有开发环境，作为中间步骤。这只能在Mac设备上使用，不能在Windows或Linux上使用。
- en: 'If you don’t possess a Mac, there are still ways to deploy your AR scene onto
    an iOS device. Here are a few alternatives:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有Mac，仍然有方法将你的AR场景部署到iOS设备上。以下是一些替代方案：
- en: '*Borrowing a Mac*: The simplest solution to gain access to Xcode and deploy
    your app onto an iOS device is to borrow a Mac from a friend or coworker. It’s
    also worth checking whether local libraries, universities, or co-working spaces
    offer public access to Macs. For commercial or academic projects, it’s highly
    recommended to invest in a Mac for testing your AR app on iOS.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**借用Mac**：获取Xcode并部署你的应用程序到iOS设备的最简单方法是向朋友或同事借用Mac。也值得检查当地图书馆、大学或共享工作空间是否提供对Mac的公共访问。对于商业或学术项目，强烈建议投资购买Mac以测试你的AR应用程序在iOS上的运行情况。'
- en: '*Using a virtual machine*: Another no-cost alternative is to establish a macOS
    environment on your non-Apple PC. However, Apple neither endorses nor advises
    this method due to potential legal issues and stability concerns. Therefore, we
    won’t elaborate further or recommend it.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用虚拟机**：另一个无需成本的替代方案是在你的非苹果PC上建立macOS环境。然而，由于潜在的法律问题和稳定性问题，苹果既不推荐也不建议这种方法。因此，我们不会进一步阐述或推荐它。'
- en: '*Employing a Unity plugin*: Fortunately, a widely used Unity plugin enables
    deployment of an AR scene onto your iOS device with relatively less hassle. Navigate
    to `iOS Project Builder for Windows` by Pierre-Marie Baty. Though this plugin
    costs $50, it is a much cheaper alternative than buying a Mac. After purchasing
    the plugin, import it into your AR scene and configure everything correctly by
    following the plugin’s documentation ([https://www.pmbaty.com/iosbuildenv/documentation/unity.html](https://www.pmbaty.com/iosbuildenv/documentation/unity.html)).'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Unity插件**：幸运的是，一个广泛使用的Unity插件可以相对轻松地将AR场景部署到你的iOS设备上。通过Pierre-Marie Baty的`iOS
    Project Builder for Windows`导航。尽管这个插件需要50美元，但它比购买Mac便宜得多。购买插件后，将其导入到AR场景中，并按照插件的文档（[https://www.pmbaty.com/iosbuildenv/documentation/unity.html](https://www.pmbaty.com/iosbuildenv/documentation/unity.html)）正确配置一切。'
- en: In this book, we focus exclusively on deploying AR applications onto iOS devices
    using a Mac for running Unity and Xcode. This is due to potential inconsistencies
    and maintenance concerns with other aforementioned methods.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们专注于使用Mac运行Unity和Xcode将AR应用程序部署到iOS设备上。这是由于其他上述方法可能存在的不一致性和维护问题。
- en: 'Before you initiate the deployment setup, ensure that your Mac and iOS devices
    have the necessary software and settings. The following steps detail this preparatory
    process:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始部署设置之前，请确保你的Mac和iOS设备已安装必要的软件和设置。以下步骤详细说明了这个准备过程：
- en: Make sure the latest software versions are installed on your MacOS and iOS devices.
    Check for updates by navigating to **Settings** | **General** | **Software Update**
    on each device and install any that are available.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的MacOS和iOS设备上安装了最新版本的软件。通过在每个设备上导航到**设置** | **通用** | **软件更新**来检查更新，并安装任何可用的更新。
- en: Confirm that your iOS device supports ARKit, which is crucial for the correct
    functioning of AR Foundation. You can check compatibility at [https://developer.apple.com/documentation/arkit/](https://developer.apple.com/documentation/arkit/).
    Generally, any device running on iPadOS 11 or iOS 11 and later versions are compatible.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你的iOS设备支持ARKit，这对于AR Foundation的正确运行至关重要。你可以在[https://developer.apple.com/documentation/arkit/](https://developer.apple.com/documentation/arkit/)检查兼容性。一般来说，任何运行iPadOS
    11或iOS 11及更高版本的设备都是兼容的。
- en: You will need an Apple ID for the following steps. If you don’t have one, you
    can create it at [https://appleid.apple.com/account](https://appleid.apple.com/account).
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将需要Apple ID来完成以下步骤。如果你没有，你可以在[https://appleid.apple.com/account](https://appleid.apple.com/account)创建一个。
- en: Download the **Xcode** software onto your Mac from Apple’s developer website
    at [https://developer.apple.com/xcode/](https://developer.apple.com/xcode/).
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Apple的开发者网站[https://developer.apple.com/xcode/](https://developer.apple.com/xcode/)下载**Xcode**软件。
- en: Enable **Developer Mode** on your iOS device by going to **Settings** | **Privacy
    & Security** | **Developer Mode**, activate **Developer Mode**, and then restart
    your device. If you don’t find the **Developer Mode** option, connect your iOS
    device to a Mac using a cable. Open **Xcode**, then navigate to **Window** | **Devices
    and Simulator**. If your device isn’t listed in the left pane, ensure you trust
    the computer on your device by acknowledging the prompt that appears after you
    connect your device to the Mac. Subsequently, you can enable **Developer Mode**
    on your iOS device.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过前往**设置** | **隐私与安全** | **开发者模式**，启用**开发者模式**，然后重新启动你的设备。如果你找不到**开发者模式**选项，请使用数据线将你的iOS设备连接到Mac。打开**Xcode**，然后导航到**窗口**
    | **设备和模拟器**。如果你的设备没有在左侧面板中列出，请确保你在设备上信任该计算机，通过连接设备到Mac后出现的提示进行确认。随后，你可以在iOS设备上启用**开发者模式**。
- en: 'Having set up your Mac and iOS devices correctly, let’s now proceed with how
    to deploy your AR scene onto your iOS device. Each time you want to deploy your
    AR scene onto your iOS device, follow these steps:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置好你的Mac和iOS设备后，现在让我们继续了解如何将你的AR场景部署到iOS设备上。每次你想将你的AR场景部署到iOS设备上时，请按照以下步骤操作：
- en: Use a USB cable to connect your iOS device to your Mac.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用USB线将你的iOS设备连接到你的Mac。
- en: Within your Unity project, navigate to **File** | **Build Settings** and select
    **iOS** from **Platform options**. Click the **Switch** **Platform** button.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Unity项目中，导航到**文件** | **构建设置**，从**平台选项**中选择**iOS**，然后点击**切换平台**按钮。
- en: Check the **Development Build** option in **Build Settings** for iOS. This enables
    you to deploy the app for testing purposes onto your iOS device. This step is
    crucial to avoid the annual subscription cost of an Apple Developer account.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS的**构建设置**中检查**开发构建**选项。这使你能够将应用用于测试目的部署到iOS设备。这一步对于避免每年Apple开发者账户的订阅费用至关重要。
- en: Note
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Deploying apps onto an iOS device with a free Apple Developer account has certain
    limitations. You can only deploy up to three apps onto your device at once, and
    they need to be redeployed every 7 days due to the expiration of the free provisioning
    profile. For industrial or academic purposes, we recommend subscribing to a paid
    Developer account after thorough testing using the **Development** **Build** function.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用免费Apple开发者账户将应用部署到iOS设备有一定的限制。你一次只能部署最多三个应用到你的设备，并且由于免费配置文件到期，它们需要每7天重新部署。出于工业或学术目的，我们建议在彻底使用**开发构建**功能测试后订阅付费开发者账户。
- en: Remain in `com.company_name.application_name`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持处于`com.company_name.application_name`。
- en: Return to `Builds` and select it.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**构建**并选择它。
- en: '**Xcode** will open with the build, displaying an error message due to the
    need for a signing certificate. To create this, click on the error message, navigate
    to the **Signing and Capabilities** tab, and select the checkbox. In the **Team**
    drop-down menu, select **New Team**, and create a new team consisting solely of
    yourself. Now, select this newly-created team from the drop-down menu. Ensure
    that the information in the **Bundle Identifier** field matches your Unity Project
    found in **Edit** | **Project Settings** | **Player**.'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Xcode**会打开并显示构建，由于需要签名证书而显示错误消息。要创建此证书，请点击错误消息，导航到**签名和功能**选项卡，并选择复选框。在**团队**下拉菜单中，选择**新建团队**，创建一个仅由你自己组成的团队。现在，从下拉菜单中选择这个新创建的团队。确保**捆绑标识符**字段中的信息与在**编辑**
    | **项目设置** | **玩家**中找到的Unity项目相匹配。'
- en: While in **Xcode**, click on the **Any iOS Device** menu and select your specific
    iOS device as the output.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Xcode**中，点击**任何iOS设备**菜单，并选择你的特定iOS设备作为输出。
- en: Click the **Play** button on the top left of **Xcode** and wait for a message
    indicating **Build succeeded**. Your AR application should now be on your iOS
    device. However, you won’t be able to open it until you trust the developer (in
    this case, yourself). Navigate to **Settings** | **General** | **VPN & Device
    Management** on your iOS device, tap **Developer App certificate** under your
    **Apple ID**, and then tap **Trust (Your** **Apple ID)**.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Xcode**的左上角点击**播放**按钮，等待显示**构建成功**的消息。现在，你的AR应用应该已经在你的iOS设备上了。然而，你将无法打开它，直到你信任开发者（在这种情况下，即你自己）。在你的iOS设备上导航到**设置**
    | **通用** | **VPN与设备管理**，点击你的**Apple ID**下的**开发者应用证书**，然后点击**信任（你的** **Apple ID**）**。
- en: On your iOS device’s home screen, click the icon of your AR app. Grant the necessary
    permissions, such as camera access. Congratulations, you’ve successfully deployed
    your AR app onto your iOS device!
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的iOS设备主屏幕上，点击你的AR应用的图标。授予必要的权限，例如相机访问权限。恭喜你，你已经成功将你的AR应用部署到你的iOS设备上！
- en: You now know how to deploy your AR experiences onto both Android and iOS devices.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道了如何将你的AR体验部署到Android和iOS设备上。
- en: Let’s review what we have learned so far in this chapter before moving on to
    creating interactive XR experiences.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建交互式XR体验之前，让我们回顾一下本章到目前为止所学的内容。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve delved into the complexities and intricacies that surround
    AR glasses, exploring why these devices face numerous physical and technological
    challenges before they can be fully embraced by the public at large. We’ve examined
    the critical choice between marker-based and markerless approaches in your AR
    application, and we’ve discussed how this seemingly simple decision can significantly
    influence not only the development journey of your application but also its accessibility,
    versatility, and user engagement.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了围绕AR眼镜的复杂性和微妙之处，探讨了为什么这些设备在得到公众广泛接受之前面临许多物理和技术挑战。我们检查了在你的AR应用中基于标记和无标记方法之间的关键选择，并讨论了这一看似简单的决策如何显著影响你的应用程序的开发旅程，以及其可访问性、多功能性和用户参与度。
- en: Through the exploration and installation of Unity’s AR Foundation package, you
    are now empowered to create simple AR experiences of your own, and ready to deploy
    them across an extensive array of handheld, AR-compatible mobile devices.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索和安装Unity的AR Foundation包，你现在可以创建自己的简单AR体验，并准备好将它们部署到广泛的、兼容AR的手持移动设备上。
- en: We’ve also discovered that the deployment of an AR scene onto iOS devices can
    be a complex and time-intensive task, largely due to the various restrictions
    imposed by Apple’s ecosystem compared to the Android ecosystem. However, these
    constraints should not deter you from pursuing a cross-platform approach for your
    AR apps. By aiming for deployment across both operating systems, you ensure greater
    accessibility and increase the potential for reaching a broader audience.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现，将AR场景部署到iOS设备上可能是一个复杂且耗时的工作，这主要归因于苹果生态系统相对于安卓生态系统的各种限制。然而，这些限制不应阻止你为你的AR应用追求跨平台的方法。通过旨在跨两个操作系统部署，你确保了更大的可访问性，并增加了触及更广泛受众的潜力。
- en: By understanding the diverse aspects of AR development through Unity, you are
    well on your way to creating immersive AR experiences that truly stand out. In
    the next chapter, you will learn how you can use C# scripting and other techniques
    to add complex logic to your VR applications.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 通过通过Unity理解AR开发的各个方面，你正朝着创建真正引人入胜的AR体验迈进。在下一章中，你将学习如何使用C#脚本和其他技术给你的VR应用程序添加复杂逻辑。
