["```cs\n>npm install\n>npm test\n>npm start\n```", "```cs\n>npm run eject\n```", "```cs\n>npm install mocha@3.5.3\n>npm install chai@4.1.2\n>npm install enzyme@2.9.1\n>npm install sinon@3.2.1\n```", "```cs\n>npm install nock@9.0.1\n>npm install react-router-dom@4.2.2\n>npm install redux@3.7.2\n>npm install redux-mock-store@1.3.0\n>npm install redux-thunk@2.2.0\n```", "```cs\n>npm install babel-preset-es2015@6.24.1\n```", "```cs\n\"babel\": {\n   \"presets\": [\n     \"react\",\n     \"es2015\"\n   ]\n },\n```", "```cs\n\"test\": \"mocha --require ./scripts/test.js --compilers babel-core/register ./src/**/*.spec.js\"\n```", "```cs\n\"test:watch\": \"npm test -- -w\"\n```", "```cs\n'use strict'; \n\nimport jsdom from 'jsdom'; \nglobal.document = jsdom.jsdom('<html><body></body></html>'); \nglobal.window = document.defaultView; \nglobal.navigator = window.navigator; \n\nfunction noop() { \n  return {}; \n}\n\n// prevent mocha tests from breaking when trying to require a css file \nrequire.extensions['.css'] = noop; \nrequire.extensions['.svg'] = noop;\n```", "```cs\nimport React from 'react'; \nimport ReactDOM from 'react-dom'; \nimport { expect } from 'chai'; \n\nimport App from './App'; \n\ndescribe('(Component) App', () => { \n  it('renders without crashing', () => { \n        const div = document.createElement('div'); \n        ReactDOM.render(<App />, div); \n    }); \n}); \n```", "```cs\n>npm test\n>npm run test:watch\n>npm start\n```", "```cs\nimport { expect } from 'chai';\n\ndescribe('Mock Speaker Service', () => {\n  it('exits', () => {\n    expect(MockSpeakerService).to.exist;\n  });\n});\n```", "```cs\nlet MockSpeakerService = {};\n```", "```cs\nit('can be constructed', () => {\n  // arrange\n  let service = new MockSpeakerService();\n\n  // assert\n  expect(service).to.be.an.instanceof(MockSpeakerService);\n});\n```", "```cs\nclass MockSpeakerService {\n}\n```", "```cs\ndescribe('Get All', () => {\n  it('exists', () => {\n    // arrange\n    let service = new MockSpeakerService();\n\n    // assert\n    expect(service.getAll).to.exist;\n  });\n});\n```", "```cs\nclass MockSpeakerService {\n  getAll() {\n  }\n}\n```", "```cs\ndescribe('No Speakers Exist', () => {\n  it('returns an empty array', () => {\n    // arrange\n    let service = new MockSpeakerService();\n\n    // act\n    let promise = service.getAll();\n\n    // assert\n    return promise.then((result) => {\n      expect(result).to.have.lengthOf(0);\n    });      \n  });\n});\n```", "```cs\ngetAll() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(Object.assign([], this._speakers));\n    }, 0);\n  });\n}\n```", "```cs\ndescribe('Mock Speaker Service', () => {\n   it('exits', () => {\n     expect(MockSpeakerService).to.exist;\n   });\n\n   it('can be constructed', () => {\n     // arrange\n     let service = new MockSpeakerService();\n\n     // assert\n     expect(service).to.be.an.instanceof(MockSpeakerService);\n   });\n\n   describe('After Initialization', () => {\n     let service = null;\n\n     beforeEach(() => {\n       service = new MockSpeakerService();\n     });\n\n     describe('Get All', () => {\n       it('exists', () => {\n         // assert\n         expect(service.getAll).to.exist;\n       });\n\n       describe('No Speakers Exist', () => {\n         it('returns an empty array', () => {\n           // act\n           let promise = service.getAll();\n\n           // assert\n           return promise.then((result) => {\n             expect(result).to.have.lengthOf(0);\n           });\n         });\n       });\n     });\n   });\n });\n```", "```cs\ndescribe('Speaker Listing', () => {\n   it('returns speakers', () => {\n     // arrange\n     service.create({});\n\n     // act\n     let promise = service.getAll();\n\n     // assert\n     return promise.then((result) => {\n       expect(result).to.have.lengthOf(1);\n     });\n   });\n });\n```", "```cs\nit.skip('returns speakers', () => {\n```", "```cs\ndescribe('Create', () => {\n   it('exists', () => {\n     expect(service.create).to.exist;\n   });\n });\n```", "```cs\nclass MockSpeakerService {\n   create() {\n\n   }\n â€¦\n```", "```cs\nclass MockSpeakerService {\n   constructor() {\n     this._speakers = [];\n   }\n\n   create(speaker) {\n     this._speakers.push(speaker);\n   }\n\n   getAll() {\n     return new Promise((resolve, reject) => {\n       setTimeout(() => {\n         resolve(Object.assign([], this._speakers));\n       }, 0);\n     });\n   }\n }\n```", "```cs\nimport { expect } from 'chai';\n\n describe('Speaker Actions', () => {\n   describe('Sync Actions', () => {\n     describe('Get Speakers Success', () => {\n       it('exists', () => {\n         expect(getSpeakersSuccess).to.exist;\n       });\n     });\n   });\n });\n```", "```cs\nfunction getSpeakersSuccess() {\n }\n```", "```cs\nit('is created with correct data', () => {\n   // arrange\n   const speakers = [{\n     id: 'test-speaker',\n     firstName: 'Test',\n     lastName: 'Speaker'\n   }];\n\n   // act\n   const result = getSpeakersSuccess(speakers);\n\n   // assert\n   expect(result.type).to.equal(GET_SPEAKERS_SUCCESS);\n   expect(result.speakers).to.have.lengthOf(1);\n   expect(result.speakers).to.deep.equal(speakers);\n });\n```", "```cs\nconst GET_SPEAKERS_SUCCESS = 'GET_SPEAKERS_SUCCESS';\n\n function getSpeakersSuccess(speakers) {\n   return { type: GET_SPEAKERS_SUCCESS, speakers: speakers };\n }\n```", "```cs\nimport * as types from '../reducers/actionTypes';\n\n export function getSpeakersSuccess(speakers) {\n   return { type: types.GET_SPEAKERS_SUCCESS, speakers: speakers };\n }\n```", "```cs\nexport const GET_SPEAKERS_SUCCESS = 'GET_SPEAKERS_SUCCESS';\n```", "```cs\nimport thunk from 'redux-thunk';\n import configureMockStore from 'redux-mock-store';\n```", "```cs\ndescribe('Async Actions', () => {\n   describe('Get Speakers', () => {\n     it('exists', () => {\n       expect(speakerActions.getSpeakers).to.exist;\n     });\n   });\n });\n```", "```cs\nexport function getSpeakers() {\n }\n```", "```cs\nconst middleware = [thunk];\n let mockStore;\n\n beforeEach(() => {\n   mockStore = configureMockStore(middleware);\n });\n```", "```cs\nit('creates GET_SPEAKERS_SUCCESS when loading speakers', () => {\n  // arrange\n  const speaker = {\n    id: 'test-speaker',\n    firstName: 'Test',\n    lastName: 'Speaker'\n  };\n\n  const expectedActions = speakerActions.getSpeakersSuccess([speaker]);\n  const store = mockStore({\n    speakers: []\n  });\n```", "```cs\n  // act\n   return store.dispatch(speakerActions.getSpeakers()).then(() => {\n     const actions = store.getActions();\n\n     // assert\n     expect(actions[0].type).to.equal(types.GET_SPEAKERS_SUCCESS);\n   });\n });\n```", "```cs\nexport function getSpeakers() {\n   return function(dispatch) {\n   };\n };\n```", "```cs\nexport function getSpeakers() {\n   return function(dispatch) {\n     return new MockSpeakerService().getAll().then(speakers => {\n       dispatch(getSpeakersSuccess(speakers))\n     }).catch(err => {\n       throw(err);\n     });\n   };\n }\n```", "```cs\ndescribe('Speaker Reducers', () => {\n   describe('Speakers Reducer', () => {\n     it('exists', () => {\n       expect(speakersReducer).to.exist;\n     });\n   });\n });\n```", "```cs\nfunction speakersReducer() {\n }\n```", "```cs\nit('Loads Speakers', () => {\n   // arrange\n   const initialState = [];\n\n   const speaker = {\n     id: 'test-speaker',\n     firstName: 'Test',\n     lastName: 'Speaker'\n   };\n   const action = actions.getSpeakersSuccess([speaker]);\n\n   // act\n   const newState = speakersReducer(initialState, action);\n\n   // assert\n   expect(newState).to.have.lengthOf(1);\n   expect(newState[0]).to.deep.equal(speaker);\n });\n```", "```cs\nfunction speakersReducer(state = [], action) {\n   switch(action.type) {\n     case types.GET_SPEAKERS_SUCCESS:\n       return action.speakers;\n     default:\n       return state;\n   }\n }\n```", "```cs\nimport { expect } from 'chai';\nimport { SpeakersPage } from './SpeakersPage';\n\n describe('Speakers Page', () => {\n   it('exists', () => {\n     expect(SpeakersPage).to.exist;\n   });\n });\n```", "```cs\nexport class SpeakersPage {\n }\n```", "```cs\nimport React from 'react';\nimport Enzyme, { mount, shallow } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\nimport { SpeakersPage } from './SpeakersPage';\n\n describe('Render', () => {\n   beforeEach(() => {\n      Enzyme.configure({ adapter: new Adapter() });\n   });\n\n   it('renders', () => {\n     // arrange\n     const props = {\n       speakers: [{ \n         id: 'test-speaker', \n         firstName:'Test', \n         lastName:'Speaker' \n       }]\n     };\n\n     // act  \n     const component = shallow(<SpeakersPage { ...props } />);\n\n     // assert\n     expect(component.find('SpeakerList')).to.exist;                 \n     expect(component.find('SpeakerList').props().speakers)\n       .to.deep.equal(props.speakers);\n   });\n });\n```", "```cs\nexport class SpeakersPage extends Component {\n   render() {\n     return (\n       <SpeakerList speakers={this.props.speakers} />\n     );\n   }\n }\n```", "```cs\nexport const SpeakerList = ({speakers}) => {}\n```", "```cs\ndescribe('Speaker List', () => {\n   it('exists', () => {\n     expect(SpeakerList).to.exist;\n   });\n });\n```", "```cs\nfunction setup(props) {\n   const componentProps = {\n     speakers: props.speakers || []\n   };\n\n   return shallow(<SpeakerList {...componentProps} />);\n }\n\n describe('On Render', () => {\n   describe('No Speakers Exist', () => {\n     it('renders no speakers message', () => {\n       // arrange\n       const speakers = [];\n\n       // arrange\n       const component = setup({speakers});\n\n       // assert\n       expect(component.find('#no-speakers').text())\n         .to.equal('No Speakers Available.');\n     });\n   });\n });\n```", "```cs\nexport const SpeakerList = ({speakers}) => {\n   return (\n     <div>\n     <h1>Speakers</h1>\n     <div id=\"no-speakers\">No Speakers Available.</div>\n     </div>\n   );\n };\n```", "```cs\ndescribe('Speakers Exist', () => {\n   it('renders a table when speakers exist', () => {\n     // arrange\n     const speakers = [{\n       id: 'test-speaker-1',\n       firstName: 'Test',\n       lastName: 'Speaker 1'\n     }, {\n       id: 'test-speaker-2',\n       firstName: 'Test',\n       lastName: 'Speaker 2'\n     }];\n\n     // act\n     const component = setup({speakers});\n\n     // assert        \n     expect(component.find('.speakers')\n       .children()).to.have.lengthOf(2);\n     expect(component.find('.speakers')\n       .childAt(0).type().name).to.equal('SpeakerListRow');\n   });\n });\n```", "```cs\nexport const SpeakerList = ({speakers}) => {\n   let contents = <div>Error!</div>;\n\n   if(speakers.length === 0) {\n     contents = <div id=\"no-speakers\">No Speakers Available.</div>;\n   } else {\n     contents = (\n       <table className=\"table\">\n         <thead>\n           <tr>\n             <th>Name</th>\n             <th></th>\n           </tr>\n         </thead>\n         <tbody className=\"speakers\">\n           { \n             speakers.map(speaker => \n               <SpeakerListRow key={speaker.id} speaker={speaker} />) \n           }\n         </tbody>\n       </table>\n     );\n   }\n\n   return (\n     <div>\n     <h1>Speakers</h1>\n     { contents }\n     </div>\n   );\n };\n```", "```cs\n import React from 'react';\n import ReactDOM from 'react-dom';\n import {BrowserRouter} from 'react-router-dom';\n import {Provider} from 'react-redux';\n import registerServiceWorker from './registerServiceWorker';\n import configureStore from './store/configureStore';\n import { getSpeakers } from './actions/speakerActions';\n import 'bootstrap/dist/css/bootstrap.min.css';\n import './index.css';\n import App from './components/App.js';\n\n const store = configureStore();\n store.dispatch(getSpeakers());\n\n ReactDOM.render(\n   <Provider store={store}>\n     <BrowserRouter>\n       <App/>\n     </BrowserRouter>\n   </Provider>,\n   document.getElementById('root')\n );\n\n registerServiceWorker();\n```", "```cs\n<Route exact path='/speakers/:id' component={SpeakerDetailPage}/>\n<Route exact path='/speakers' component={SpeakersPage}/>\n```", "```cs\nimport { connect } from 'react-redux';\n\nfunction mapStateToProps(state) {\n   return {\n     speakers: state.speakers\n   };\n }\n\n function mapDispatchToProps(dispatch) {\n   return bindActionCreators(speakerActions, dispatch);\n }\n\n export default connect(mapStateToProps, mapDispatchToProps)(SpeakersPage);\n```", "```cs\ndescribe('Get Speaker By Id', () => {\n   it('exists', () => {\n     // assert\n     expect(service.getById).to.exist;\n   });\n });\n```", "```cs\ngetById() {\n }\n```", "```cs\ndescribe('Speaker Does Not Exist', () => {\n   it('SPEAKER_NOT_FOUND error is generated', () => {\n     // act\n     const promise = service.getById('fake-speaker');\n\n     // assert\n     return promise.catch((error) => {\n       expect(error.type).to.equal(errorTypes.SPEAKER_NOT_FOUND);\n     });\n   });\n });\n```", "```cs\ngetById(id) {\n   return new Promise((resolve, reject) => {\n     setTimeout(() => {\n         reject({ type: errorTypes.SPEAKER_NOT_FOUND });\n     }, 0);\n   });\n }\n```", "```cs\ndescribe('Speaker Exists', () => {\n   it('returns the speaker', () => {\n     // arrange\n     const speaker = { id: 'test-speaker' };\n     service.create(speaker);\n\n     // act\n     let promise = service.getById('test-speaker');\n\n     // assert\n     return promise.then((speaker) => {\n       expect(speaker).to.not.be.null;\n       expect(speaker.id).to.equal('test-speaker');\n     });\n   });\n });\n```", "```cs\ngetById(id) {\n   return new Promise((resolve, reject) => {\n     setTimeout(() => {\n       let speaker = this._speakers.find(x => x.id === id);\n       if(speaker) {\n         resolve(Object.assign({}, speaker));\n       } else {\n         reject({ type: errorTypes.SPEAKER_NOT_FOUND });\n       }\n     }, 0);\n   });\n }\n```", "```cs\ndescribe('Find Speaker Success', () => {\n   it('exists', () => {\n     expect(speakerActions.getSpeakerSuccess).to.exist;\n   });\n });\n```", "```cs\nexport function getSpeakerSuccess() {\n }\n```", "```cs\nit('is created with correct data', () => {\n   // arrange\n   const speaker = {\n     id: 'test-speaker',\n     firstName: 'Test',\n     lastName: 'Speaker'\n   };\n\n   // act\n   const result = speakerActions.getSpeakerSuccess(speaker);\n\n   // assert\n   expect(result.type).to.equal(types.GET_SPEAKER_SUCCESS);\n   expect(result.speaker).to.deep.equal(speaker);\n });\n```", "```cs\nexport function getSpeakerSuccess(speaker) {\n   return { type: types.GET_SPEAKER_SUCCESS, speaker: speaker };\n }\n```", "```cs\ndescribe('Get Speaker Failure', () => {\n   it('exists', () => {\n     expect(speakerActions.getSpeakerFailure).to.exist;\n   });\n });\n```", "```cs\nexport function getSpeakerFailure() {\n }\n```", "```cs\nit('is created with correct data', () => {\n   // arrange\n   const error = {\n     type: errorTypes.SPEAKER_NOT_FOUND\n   };\n\n   // act\n   const result = speakerActions.getSpeakerFailure(error);\n\n   // assert\n   expect(result.type).to.equal(types.GET_SPEAKER_FAILURE);\n   expect(result.error).to.deep.equal(error);\n });\n```", "```cs\nexport function getSpeakerFailure(error) {\n   return { type: types.GET_SPEAKER_FAILURE, error: error }\n }\n```", "```cs\nit('creates GET_SPEAKER_FAILURE when speaker is not found', () => {\n   // arrange\n   const speakerId= 'not-found-speaker';\n   const store = mockStore({\n     speaker: {}\n   });\n\n   // act\n   return (\n     store.dispatch(speakerActions.getSpeaker(speakerId)).then(() => {\n       const actions = store.getActions();\n\n       // assert\n       console.log(actions);\n       expect(actions[0].type).to.equal(types.GET_SPEAKER_FAILURE);\n     })\n   );\n });\n```", "```cs\nexport function getSpeaker(speakerId) {\n   return function(dispatch) {\n     return new MockSpeakerService().getById(speakerId).catch(err => {\n       dispatch(getSpeakerFailure(err));\n     });\n   };\n }\n```", "```cs\nimport { expect } from 'chai';\nimport { ServiceFactory as factory } from './serviceFactory';\n\ndescribe('Service Factory', () => {\n  it('exits', () => {\n    expect(factory).to.exist;\n  });\n});\n```", "```cs\nexport class ServiceFactory {\n}\n```", "```cs\ndescribe('Create Speaker Service', () => {\n   it('exists', () => {\n     expect(factory.createSpeakerService).to.exist;\n   });\n });\n```", "```cs\nstatic createSpeakerService() {\n }\n```", "```cs\nit('returns a speaker service', () => {\n   // act\n   let result = factory.createSpeakerService();\n\n   // assert\n   expect(result).to.be.an.instanceof(MockSpeakerService);\n });\n```", "```cs\nstatic createSpeakerService() {\n   return new MockSpeakerService();\n }\n```", "```cs\nit('returns the same speaker service', () => {\n   // act\n   let service1 = factory.createSpeakerService();\n   let service2 = factory.createSpeakerService();\n\n   // assert\n   expect(service1).to.equal(service2);\n });\n```", "```cs\nexport default class ServiceFactory {\n   constructor() {\n     this._speakerService = null;\n   }\n\n   static createSpeakerService() {\n     return this._speakerService = this._speakerService || \n                                   new MockSpeakerService();\n   }\n }\n```", "```cs\nit('creates GET_SPEAKER_SUCCESS when speaker is found', () => {\n   // arrange\n   const speaker = {\n     id: 'test-speaker',\n     firstName: 'Test',\n     lastName: 'Speaker'\n   };\n   const store = mockStore({ speaker: {} });\n   const expectedActions = [\n     speakerActions.getSpeakerSuccess([speaker.id])\n   ];\n   let service = factory.createSpeakerService();\n   service.create(speaker);\n\n   // act\n   return store.dispatch(\n     speakerActions.getSpeaker('test-speaker')).then(() => {\n       const actions = store.getActions();\n\n       // assert\n       expect(actions[0].type).to.equal(types.GET_SPEAKER_SUCCESS);\n       expect(actions[0].speaker.id).to.equal('test-speaker');\n       expect(actions[0].speaker.firstName).to.equal('Test');\n       expect(actions[0].speaker.lastName).to.equal('Speaker');\n     });\n });\n```", "```cs\nexport function getSpeaker(speakerId) {\n   return function(dispatch) {\n     return factory.createSpeakerService().getById(speakerId).then(\n       speaker => {\n         dispatch(getSpeakerSuccess(speaker));\n       }).catch(err => {\n         dispatch(getSpeakerFailure(err));\n       });\n   };\n }\n```", "```cs\ndescribe('Speaker Reducer', () => {\n     it('exists', () => {\n       expect(speakerReducer).to.exist;\n     });\n });\n```", "```cs\nexport function speakerReducer() {\n }\n```", "```cs\nit('gets a speaker', () => {\n   // arrange\n   const initialState = { id: '', firstName: '', lastName: '' };\n   const speaker = { id: 'test-speaker', firstName: 'Test', lastName: 'Speaker'};\n   const action = actions.getSpeakerSuccess(speaker);\n\n   // act\n   const newState = speakerReducer(initialState, action);\n\n   // assert\n   expect(newState).to.deep.equal(speaker);\n });\n```", "```cs\nexport function speakerReducer(state = { \n   id: '', \n   firstName: '', \n   lastName: ''\n }, action) {\n   switch(action.type) {\n     case types.GET_SPEAKER_SUCCESS:\n       return action.speaker;\n     default:\n       return state;\n   }\n }\n```", "```cs\ndescribe('Error Reducer', () => {\n   it('exists', () => {\n     expect(errorReducer).to.exist;\n   });\n });\n```", "```cs\nimport * as types from './actionTypes';\nimport * as errors from './errorTypes';\n\nexport function errorReducer() {\n}\n```", "```cs\nit('returns error state', () => {\n   // arrange\n   const initialState = [];\n   const error = { type: errorTypes.SPEAKER_NOT_FOUND };\n   const action = actions.getSpeakerFailure(error);\n\n   // act\n   const newState = errorReducer(initialState, action);\n\n   // assert\n   expect(newState).to.deep.equal([error]);\n });\n```", "```cs\nexport function errorReducer(state = [], action) {\n   switch(action.type) {\n     case types.GET_SPEAKER_FAILURE:\n       return [...state, action.error];\n     default:\n       return state;\n   }\n }\n```", "```cs\nit('ignores duplicate errors', () => {\n   // arrange\n   const error = { type: errorTypes.SPEAKER_NOT_FOUND };\n   const initialState = [error];\n   const action = actions.getSpeakerFailure(error);\n\n   // act\n   const newState = errorReducer(initialState, action);\n\n   // assert\n   expect(newState).to.deep.equal([error]);\n });\n```", "```cs\nexport function errorReducer(state = [], action) {\n   switch(action.type) {\n     case types.GET_SPEAKER_FAILURE:\n       let newState = [...state];\n\n       if(newState.every(x => x.type !== action.error.type)) {\n         newState.push(action.error);\n       }\n\n       return newState;\n     default:\n       return state;\n   }\n }\n```", "```cs\nit('clears when a non-error action is received', () => {\n   // arrange\n   const error = { type: errorTypes.SPEAKER_NOT_FOUND };\n   const initialState = [error];\n   const action = { type: 'ANY_NON_ERROR' };\n\n   // act\n   const newState = errorReducer(initialState, action);\n\n   // assert\n   expect(newState).to.deep.equal([]);\n });\n```", "```cs\ndefault:\n   return [];\n```", "```cs\ndescribe('Speaker Detail Page', () => {\n   it('exists', () => {\n     expect(SpeakerDetailPage).to.exist;\n   });\n });\n```", "```cs\nexport class SpeakerDetailPage extends Component {\n   render() {\n     return (<div></div>);\n   }\n }\n```", "```cs\ndescribe('Render', () => {\n   it('renders', () => {\n     // arrange\n     const props = {\n       match: { params: { id: 'test-speaker' } },\n       actions: { getSpeaker: (id) => { return Promise.resolve(); } },\n       speaker: { firstName: 'Test' } \n     };\n\n     // act\n     const component = mount(<SpeakerDetailPage { ...props } />);\n\n     // assert\n     expect(component.find('first-name').text()).to.contain('Test');\n   });\n });\n```", "```cs\nexport class SpeakerDetailPage extends Component {\n   constructor(state, context) {\n     super(state, context);\n\n     this.state = {\n       speaker: Object.assign({}, this.props.speaker)\n     };\n   }\n\n   render() {\n     return (\n       <SpeakerDetail speaker={this.state.speaker} />\n     );\n   }\n }\n```", "```cs\nexport class SpeakerDetailPage extends Component {\n   constructor(state, context) {\n     super(state, context);\n\n     this.state = {\n       speaker: Object.assign({}, this.props.speaker)\n     };\n\n     this.props.actions.getSpeaker(this.props.match.params.id)\n   }\n\n   componentWillReceiveProps(nextProps) {\n     if(this.props.speaker.id !== nextProps.speaker.id) {\n       this.setState({ speaker: Object.assign({}, nextProps.speaker) });\n     }\n   }\n\n   render() {\n     return (\n       <SpeakerDetail speaker={this.state.speaker} />\n     );\n   }\n }\n\n function mapStateToProps(state, ownProps) {\n   let speaker = { id: '', firstName: '', lastName: '' }\n\n   return {\n     speaker: state.speaker || speaker\n   };\n }\n\n function mapDispatchToProps(dispatch) {\n   return {\n     actions: bindActionCreators(speakerActions, dispatch)\n   }\n }\n\n export default  connect(\n   mapStateToProps,\n   mapDispatchToProps\n )(SpeakerDetailPage);\n```", "```cs\nconst speakers = [{\n   id: 'clayton-hunt',\n   firstName: 'Clayton',\n   lastName: 'Hunt'\n }, {\n   id: 'john-callaway',\n   firstName: 'John',\n   lastName: 'Callaway'\n }];\n\n let service = factory.createSpeakerService();\n speakers.forEach((speaker) => {\n   service.create(speaker);\n });\n```"]