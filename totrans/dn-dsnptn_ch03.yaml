- en: Chapter 3. A Logging Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。日志库
- en: In this chapter, we will try to create a **logging library** that will enable
    an application developer to log information to a media (file, network, or database)
    during program execution. This would be a critical library that the developer
    would be able to use for audit trail (domain pre-requisite) and code instrumentation
    (from a debugging and verification stand-point). We will design and implement
    this library from scratch, and make it available as an API to the end developer
    for consumption.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试创建一个**日志库**，它将允许应用程序开发者在程序执行期间将信息记录到媒体（文件、网络或数据库）。这将是一个关键的库，开发者可以使用它进行审计跟踪（领域先决条件）和代码调试（从调试和验证的角度）。我们将从头开始设计和实现这个库，并将其作为API提供给最终开发者使用。
- en: 'During the course of this chapter, as a reader, you will learn to leverage
    strategy pattern, factory method pattern, template pattern, singleton and prototype
    patterns to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的学习过程中，作为读者，你将学会利用策略模式、工厂方法模式、模板模式、单例和原型模式来完成以下任务：
- en: Writing data to a file stream
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入文件流
- en: Creating a simple **Data Access Layer** (**DAL**) using ADO.NET
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ADO.NET创建一个简单的**数据访问层（DAL**）
- en: Writing data to an SQLite database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入SQLite数据库
- en: Writing data to a network stream using the System.Net API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用System.Net API将数据写入网络流
- en: Handling concurrency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理并发
- en: Threads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: Requirements for the library
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库的需求
- en: 'Before we embark on writing the library, let us scribble down a preliminary
    requirement statement as shown next:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写库之前，让我们草拟一个初步的需求说明，如下所示：
- en: The logging library should provide a unified interface to handle log entries
    which are supposed to be persisted in a media (file, remote node, or a database)
    and target media should be determined during runtime from a configuration file.
    The API should be target-independent and there should be provision to add new
    log targets without changing the application logic.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 日志库应提供一个统一的接口来处理应持久保存在媒体（文件、远程节点或数据库）中的日志条目，目标媒体应在运行时从配置文件中确定。API应该是目标无关的，并且应该提供在不更改应用程序逻辑的情况下添加新日志目标的方法。
- en: Solutions approach
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案方法
- en: 'Before we write the code to implement our library (a Windows assembly), let
    us enumerate the requirements to get the big picture:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写实现我们的库（一个Windows汇编）的代码之前，让我们列举一下需求，以获得整体情况：
- en: The data should be written to multiple streams
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据应写入多个流
- en: File, network, and DB
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件、网络和数据库
- en: The developer API should be target-agnostic
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者API应该是目标无关的
- en: The library should maintain its object lifetime
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库应维护其对象生命周期
- en: The library should provide facility for adding new log targets
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库应提供添加新日志目标的功能
- en: The library should be able to handle concurrent writes to log targets
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库应该能够处理对日志目标的并发写入
- en: Writing content to a media
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将内容写入媒体
- en: 'To manage the complexity of code isolation, let''s declare a C# interface which
    will manage the idiosyncrasies of multiple log targets:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理代码隔离的复杂性，让我们声明一个C#接口，该接口将管理多个日志目标的特点：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The basic idea here, is that the concrete classes which implement the interface
    should provide an implementation of this method that writes the log to the respective
    media. But on closer inspection, we find that it is better to write a base class
    implementation of this method and its associated semantics in an abstract class.
    The base class implementation can add a log entry to a queue (that would give
    concurrency support), flush the queue, and persist to target the media when a
    threshold (configured) is reached. A method will be marked as abstract which will
    provide a mechanism for concrete classes to write entries for the respective media.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思想是，实现接口的具体类应该提供一种将日志写入相应媒体的方法实现。但经过仔细检查，我们发现最好在抽象类中编写这个方法及其相关语义的基础类实现。基础类实现可以将日志条目添加到队列中（这将提供并发支持），当达到阈值（配置）时刷新队列，并将数据持久化到目标媒体。将有一个方法被标记为抽象，为具体类提供写入相应媒体条目的机制。
- en: Since our library is supposed to work in a multi-threaded environment, we need
    to handle concurrency in a neat manner. While writing to a file or network, we
    need to be careful that only one thread gets access to the file or socket handle.
    We will leverage the .NET `async`/`await` declarative programming model to manage
    background processing tasks. **Model-view-controller** (**MVC**) is the most dominant
    paradigm for structuring applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的库应该在多线程环境中工作，我们需要以一种整洁的方式处理并发。在写入文件或网络时，我们需要小心，确保只有一个线程可以访问文件或套接字句柄。我们将利用.NET的`.NET
    `async`/`await`声明性编程模型来管理后台处理任务。**模型-视图-控制器**（**MVC**）是构建应用程序最占主导地位的范式。
- en: Template method pattern and content writers
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板方法模式和内容编写者
- en: In the first stage, we plan to flush the log contents to the file, network,
    and database targets. The bulk of our logic is common for all content writers.
    To aid separation of concerns and avoid duplication of code, it is best to let
    the concrete content writer classes manage their target media. Base implementation
    will take care of concurrency and queue management.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，我们计划将日志内容刷新到文件、网络和数据库目标。我们的大部分逻辑对所有内容编写者都是通用的。为了帮助分离关注点并避免代码重复，最好让具体的内容编写者类管理它们的目标媒体。基本实现将负责并发和队列管理。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: To make the code simple, we will leverage the `ConcurrentQueue` class (data
    structure introduced with .NET framework version 4) available with the `Systems.Collections.Concurrent`
    package. In the interest of clarity, we've left out the exception handling code.
    Please note that the `AggregateException` class should be leveraged for handling
    exceptions in concurrent execution scenarios.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码简单，我们将利用`ConcurrentQueue`类（随.NET框架版本4引入的数据结构）和`Systems.Collections.Concurrent`包一起提供的功能。为了提高清晰度，我们省略了异常处理代码。请注意，在并发执行场景中，应使用`AggregateException`类来处理异常。
- en: 'This class will make sure that only one thread gets to write to the queue at
    any point of time. We will implement an asynchronous `Flush` method using **Task
    Parallel Library** (**TPL**). This routine will retrieve data from the queue,
    and delegate the task of persistence (in the media of choice) to the respective
    concrete classes via an abstract method (`WriteToMedia`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将确保在任何时候只有一个线程可以写入队列。我们将使用**任务并行库**（**TPL**）实现异步的`Flush`方法。此例程将从队列中检索数据，并通过一个抽象方法（`WriteToMedia`）将持久化任务（在所选媒体中）委托给相应的具体类：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the contents of the queue reach a threshold level, a thread will acquire
    the lock for flushing the data. In our case, we will initiate flushing beyond
    10 items in queue:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦队列中的内容达到阈值水平，一个线程将获取锁以刷新数据。在我们的情况下，我们将启动超过10个队列项的刷新：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The concrete classes derived from `BaseContentWriter` will implement the following
    method to handle the specificities:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从`BaseContentWriter`派生的具体类将实现以下方法来处理特定情况：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: This is an instance of a template method pattern. The template method pattern
    is a behavioral design pattern where the bulk of logic resides in the base class,
    and certain steps of a process are implemented by concrete classes. In `BaseContentWriter`,
    we have the logic for adding elements to and retrieving elements from a concurrent
    queue. Persistence is taken care of by the sub-classes that implement our template
    method (`WriteToMedia`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模板方法模式的实例。模板方法模式是一种行为设计模式，其中大部分逻辑位于基类中，而某些步骤由具体类实现。在`BaseContentWriter`中，我们有向并发队列添加元素和从并发队列检索元素的逻辑。持久化由实现我们的模板方法（`WriteToMedia`）的子类负责。
- en: 'The following UML class diagram represents the realizations, dependencies,
    and associations between the various classes. Do observe the annotation that clearly
    outlines the template method pattern in action:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的UML类图表示了各种类之间的实现、依赖和关联。请注意，注释清楚地概述了模板方法模式的作用：
- en: '![Template method pattern and content writers](img/B05691_03_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法模式和内容编写者](img/B05691_03_01.jpg)'
- en: Writing a log entry to a file stream
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日志条目写入文件流
- en: 'We will use file streams to write a file. We implement the actual file handling
    logic in the `WriteToMedia` template method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用文件流来写入文件。我们在`WriteToMedia`模板方法中实现实际的文件处理逻辑：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Writing a log entry to a database
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日志条目写入数据库
- en: 'Some familiarity with ADO.NET is necessary to understand the nitty-gritties
    of this section. To make the matter simple, we have chosen SQLite as our database
    of choice to persist the log entries. One can choose MySQL, SQL Server, or Oracle.
    Because of the ADO.NET library, the code will be more or less the same for every
    RDBMS offering. We have created a class, `SQLAccess`, which wraps a subset of
    the ADO.NET calls to provide a simple interface for SQLite. The class encapsulates
    and leverages the ADO.NET provider for SQLite to provide an interaction with the
    SQLite database engine (x86/x64). In case this assembly (`System.Data.SQLite`)
    is not available locally, please use nuget to install it via the Package Manager
    Console as `PM> Install-Package System.Data.SQLite`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解本节的所有细节，需要对ADO.NET有一定的了解。为了简化问题，我们选择了SQLite作为我们的数据库选择来持久化日志条目。可以选择MySQL、SQL
    Server或Oracle。由于ADO.NET库，对于每个提供的RDBMS，代码将大致相同。我们创建了一个名为`SQLAccess`的类，它封装并利用了SQLite的ADO.NET提供程序，以提供与SQLite数据库引擎（x86/x64）的交互。如果此程序集（`System.Data.SQLite`）在本地不可用，请通过包管理控制台使用nuget安装它，命令为`PM>
    Install-Package System.Data.SQLite`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Open` method given next instantiates the connection object, and invokes
    the `Open` method of the ADO.NET connection object. If we require transaction
    support, we need to instantiate a transaction context (`SQLiteTransaction`) object:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`Open`方法实例化了连接对象，并调用了ADO.NET连接对象的`Open`方法。如果我们需要事务支持，我们需要实例化一个事务上下文（`SQLiteTransaction`）对象：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To insert a value or set of values to a database, we instantiate a command
    object by giving a connection object and a string (containing the SQL statement).
    ADO.NET has the `ExecuteNonQuery` method to execute the query:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值或值集插入数据库，我们需要通过提供一个连接对象和一个包含SQL语句的字符串来实例化一个命令对象。ADO.NET有`ExecuteNonQuery`方法来执行查询：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We close the connection once we have finished inserting records to the database:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在将记录插入数据库后关闭连接：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once we have a class which will help us persist data to a relational database,
    writing the template method (`WriteToMedia`) becomes easy. The whole code listing
    is given as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个类可以帮助我们将数据持久化到关系型数据库，编写模板方法（`WriteToMedia`）就变得容易了。整个代码列表如下所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Writing a log entry to a network stream
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日志条目写入网络流
- en: 'We will use the `TCPListener` class under the `System.Net` namespace for writing
    data to a network stream. For the current implementation, we have hard-coded the
    domain name (localhost:`127.0.0.1`) and port (`4500`). We can read these values
    from a configuration file. As usual, the whole action happens within the `WriteToMedia`
    template method. At the end of the chapter, we have given a simple implementation
    of a log server for the sake of completeness. The log server receives the entries
    we write, and prints it to its console:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`System.Net`命名空间下的`TCPListener`类来将数据写入网络流。对于当前实现，我们已将域名（localhost:`127.0.0.1`）和端口（`4500`）硬编码。我们可以从配置文件中读取这些值。像往常一样，整个操作都在`WriteToMedia`模板方法中完成。在章节末尾，我们提供了一个简单的日志服务器实现，以保持完整性。日志服务器接收我们写入的条目，并将其打印到其控制台：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have now implemented content writers for file, DB (using ADO.NET), and network
    streams. With this under our belt, we need to provide an interface for applications
    to consume these content writers. Depending on the logging strategy chosen by
    the application, the appropriate content writers are to be connected to the log
    data streams. This warrants another set of interfaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了文件、数据库（使用ADO.NET）和网络流的内联编写器。有了这些，我们需要为应用程序提供一个接口来消费这些内容编写器。根据应用程序选择的日志策略，适当的内容编写器应连接到日志数据流。这需要另一组接口。
- en: Logging strategy atop the strategy pattern
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在策略模式之上进行日志记录策略
- en: We will use the GoF strategy pattern to implement the interface for the logging
    library.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GoF策略模式来实现日志库的接口。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can treat the logging of data to different streams as algorithms, and strategy
    pattern is meant to parameterize the algorithm to be executed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将将数据记录到不同流中的日志视为算法，而策略模式旨在参数化要执行的算法。
- en: 'By having concrete classes for network, file, and DB strategies, we are able
    to swap the implementation logic:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为网络、文件和数据库策略提供具体的类，我们能够交换实现逻辑：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To test the code, we will write a `NullLogStrategy` class, which prints the
    log entry to the console. Since we have written the logic for scheduling the execution
    of the code, our implementation will be much simpler. We implement the template
    method (`DoLog`) through which we write the log entry in the console:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试代码，我们将编写一个`NullLogStrategy`类，该类将日志条目打印到控制台。由于我们已经编写了代码执行调度的逻辑，我们的实现将更加简单。我们通过实现模板方法（`DoLog`）在控制台中写入日志条目：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since we have taken pains to create the `ContentWriter` classes, our implementation
    of strategy classes is just a matter of implementing the `DoLog` template method,
    and delegating the actual work to the respective content writers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经费尽心思创建了`ContentWriter`类，因此我们的策略类实现只是实现`DoLog`模板方法，并将实际工作委托给相应的内容编写者：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following image illustrates the strategy pattern in action:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像说明了策略模式在实际中的应用：
- en: '![Logging strategy atop the strategy pattern](img/B05691_03_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![基于策略模式的日志策略](img/B05691_03_02.jpg)'
- en: The factory method pattern for instantiation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化的工厂方法模式
- en: Now, we should take care of the instantiation of the right object based on the
    parameter received (often retrieved  from a  configuration file )  to identify
    the strategy.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该根据接收到的参数（通常从配置文件中检索）来关注正确对象的实例化，以确定策略。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will use the GoF factory method pattern to instantiate the `LogStrategy`
    object. By checking the `loggertype` parameter, the appropriate concrete class
    will be instantiated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GoF工厂方法模式来实例化`LogStrategy`对象。通过检查`loggertype`参数，将实例化适当的具体类。
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The application developer can also control the logging strategy through a configuration
    entry. The process of instantiating the `LogStrategy` class is given as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用开发者也可以通过配置条目来控制日志策略。实例化`LogStrategy`类的过程如下所示：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Writing a generic factory method implementation
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写通用的工厂方法实现
- en: 'As discussed in the previous chapter, writing system logic without impacting
    the application warrants a mechanism - that of loading a class on the fly. We
    will tweak the factory method (`LogFactory`) implementation to make the system
    generic. We will use an XML file to provide the metadata that the factory method
    would use to create the respective log handler (`LogStrategy`) for the requested
    strategy (by the consumer). The sample XML file (`LogStrategy.xml`) is given as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，在不影响应用程序的情况下编写系统逻辑需要一个机制——即动态加载类。我们将调整工厂方法（`LogFactory`）的实现，使系统通用。我们将使用XML文件来提供工厂方法将用于创建相应日志处理程序（`LogStrategy`）的元数据，以满足请求的策略（由消费者）。以下是一个示例XML文件（`LogStrategy.xml`）：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The contents of the XML file can be read very easily using LINQ to XML.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LINQ to XML可以非常容易地读取XML文件的内容。
- en: Factory method, singleton, and prototype pattern for dynamic class loading
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法、单例和原型模式用于动态类加载
- en: The .NET Reflection API helps us to load a class dynamically and instantiate
    an object . There is option for cloning an existing object to create a new one.
    We will use both strategies, for  instantiation of objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: .NET反射API帮助我们动态加载类并实例化对象。有克隆现有对象以创建新对象的选择。我们将使用这两种策略来实例化对象。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The factory method (from the GoF catalog) is a pattern which solves the creation
    of objects through a static method exposed solely for this purpose. The object
    we create will be based on a particular class or derived class. The consumer of
    the `Factory` class can also indicate whether it requires a singleton or a prototype.
    The default behavior of the factory method is to create a singleton, and it will
    return the same instance whenever a call is made to the factory (`Get`) method.
    If the prototype option is given, a clone of the object will be created and returned.
    This is a good example that demonstrates how these three patterns compose and
    work in harmony to give you this desired outcome. Also note the adept usage of
    the dictionary object to achieve singletons. The constructs for creating an **object
    pool** is already present in this implementation. That would be a good exercise
    for any interested reader to uncover and implement.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法（来自 GoF 目录）是一种通过仅为此目的公开的静态方法解决对象创建的模式。我们创建的对象将基于特定的类或派生类。`Factory` 类的消费者也可以指示它是否需要单例或原型。工厂方法的默认行为是创建单例，并且每次调用工厂（`Get`）方法时都会返回相同的实例。如果提供了原型选项，将创建对象的副本并返回。这是一个很好的例子，展示了这三个模式如何组合并协同工作以提供所需的结果。同时请注意，字典对象被巧妙地用于实现单例。创建
    **对象池** 的结构已经存在于这个实现中。这将是任何感兴趣的读者发现和实现的好练习。
- en: 'The consumer of the `ObjectFactory` class would indicate whether it wants a
    reference to the object available in the cache or a clone of the object. We can
    clone an object using binary serialization. By writing an extension method leveraging
    generics, we can create an all-purpose clone routine. The following code snippet
    achieves that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectFactory` 类的消费者将指示它是否想要缓存中可用的对象引用或对象的副本。我们可以使用二进制序列化来克隆对象。通过利用泛型编写扩展方法，我们可以创建一个通用的克隆程序。以下代码片段实现了这一点：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, please note a cloneable interface could be leveraged in case you need
    custom cloning procedures. Now the implementation of `Get` becomes a straightforward
    affair; the following is a full listing of the `Get` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，如果需要自定义克隆过程，可以利用可克隆接口。现在 `Get` 方法的实现变得简单直接；以下是对 `Get` 方法的完整列表：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will be using the preceding class and different configuration files for all
    examples going forward. This will simplify our code, and we would have a terse
    listing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的所有示例中，我们将使用前面的类和不同的配置文件。这将简化我们的代码，并且我们将有一个简洁的列表。
- en: Refactoring the code with the generic factory method
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛型工厂方法重构代码
- en: 'Using `ObjectFactory`, our strategy instantiation becomes much cleaner. If
    we cannot locate a proper implementation of strategy by dictionary lookup (within
    the factory store), we will instantiate a `NullStrategy` object (fallback option):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ObjectFactory`，我们的策略实例化变得更加简洁。如果我们无法通过字典查找（在工厂存储中）找到适当的策略实现，我们将实例化一个 `NullStrategy`
    对象（回退选项）：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A log server for network logging
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个用于网络日志的日志服务器
- en: 'An implementation of a server application that can handle incoming streams
    of data from a remote application is given next. Here we are using System.Net''s
    `TCPListener` class to listen to the incoming connection. Once we receive a connection
    from the remote process, we will kick-start a thread to handle the log data from
    that connection. This implementation is given here for the sake of completeness:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个给出的是可以处理来自远程应用程序的数据流的客户端应用程序的实现。在这里，我们使用 System.Net 的 `TCPListener` 类来监听传入的连接。一旦我们从远程进程接收到连接，我们将启动一个线程来处理该连接的日志数据。这里给出这个实现是为了完整性：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A simple client program to test the library
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的客户端程序以测试库
- en: A simple test harness for the logging library is given next. The program accepts
    a command-line parameter, which is the log target (NET | FILE | DB). We create
    the appropriate logging strategy classes using the factory method pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个给出的是用于日志库的简单测试框架。程序接受一个命令行参数，即日志目标（NET | FILE | DB）。我们使用工厂方法模式创建适当的日志策略类。
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following UML diagram illustrates the key set of patterns in action for
    the logging API:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 UML 图展示了日志 API 中关键模式集的执行情况：
- en: '![A simple client program to test the library](img/B05691_03_03-1.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的客户端程序以测试库](img/B05691_03_03-1.jpg)'
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered more ground to gain a good understanding on some
    of the design patterns. We created a logging library which can log information
    from multiple threads and handle different targets like file, database, and remote
    servers. We used strategy pattern to swap the various logger implementations based
    on a configuration file. Once again, the template method pattern helped us to
    create an extensible solution for accommodating new log targets. All we needed
    to do was to override the base implementation with the specifics of the new log
    targets, as log information processing is handled by the base implementation.
    We extended our factory method pattern to handle arbitrary objects based on configuration
    files. We also learned to leverage dictionary objects for generating singletons
    and prototypes. In the next chapter, we will write a data access layer which can
    help an application target multiple databases. In the process, you will learn
    about adapter pattern, factory methods, and so on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了更多内容，以便对一些设计模式有一个良好的理解。我们创建了一个日志库，它可以记录来自多个线程的信息，并处理不同的目标，如文件、数据库和远程服务器。我们使用策略模式根据配置文件来交换各种日志实现。再次，模板方法模式帮助我们创建了一个可扩展的解决方案，以适应新的日志目标。我们只需要用新日志目标的具体实现覆盖基本实现，因为日志信息处理由基本实现处理。我们还扩展了我们的工厂方法模式，以便根据配置文件处理任意对象。我们还学会了利用字典对象来生成单例和原型。在下一章中，我们将编写一个数据访问层，它可以帮助应用程序针对多个数据库。在这个过程中，你将学习到适配器模式、工厂方法等。
