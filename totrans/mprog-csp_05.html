<html><head></head><body>
		<div><h1 id="_idParaDest-62" class="chapter-number"><a id="_idTextAnchor083"/>5</h1>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor084"/>Leveraging Attributes</h1>
			<p>We briefly touched on the concept of C# attributes in <a href="B19418_02.xhtml#_idTextAnchor026"><em class="ita ic">Chapter 2</em></a>, <em class="ita ic">Metaprogramming Concepts</em>. They are an obvious choice for adding explicit metadata to your source code. This is what they are intended for. Attributes should not carry heavy logic with them and should be viewed as just metadata.</p>
			<p>In this chapter, we will look into how you can leverage them in your code base, providing mechanisms for adorning types and members with valuable, rich information that can be used for different scenarios.</p>
			<p>We will cover the following topics:</p>
			<ul>
				<li>What is an attribute and how can it be applied?</li>
				<li>Finding types with specific attributes</li>
				<li>Generic attributes</li>
			</ul>
			<p>From this chapter, you should understand the power of attributes as a building block for metaprogramming, how to create your own custom attributes, and how you can discover them being used.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor085"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5</a>) and it builds on top of the <strong class="bo d">Fundamentals</strong> code, which is found at <a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</a>.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor086"/>What is an attribute and how can it be applied?</h1>
			<p>An <strong class="bo d">attribute</strong> is a special type<a id="_idIndexMarker155"/> that the C# compiler understands. It can be used to associate metadata to assemblies, types, and any member of a type. During compilation, the compiler will pick up the attributes and add them to the compiled assembly as metadata. You can place<a id="_idIndexMarker156"/> more than one attribute on every item.</p>
			<p>Creating your own custom attribute is as simple as this:</p>
			<pre class="source-code">
public class CustomAttribute : Attribute
{
}</pre>
			<p>And then using it is done as follows:</p>
			<pre class="source-code">
[Custom]
public class MyClass
{
}</pre>
			<p>Notice that you create the attribute with the <strong class="source-in ine">Attribute</strong> postfix in the name. While using it, you don’t need it and you only have <strong class="source-in ine">[Custom]</strong>. The C# compiler has a convention built into it saying you have to have the postfix, but it will ignore it when it’s used. This is a little bit weird and definitely violates the principle of least surprise.</p>
			<p>The nice thing about attributes is that they live outside the scope of the element itself, meaning that you don’t have to create an instance of the type with the metadata to access the metadata.</p>
			<p>Attributes can take parameters to give them specific information you want to capture. However, all parameters must be available at compile time. This means you can’t create new objects dynamically for any of the parameters.</p>
			<p>For instance, we can add a parameter to the attribute by taking the instance of another type:</p>
			<pre class="source-code">
public class CustomAttribute : Attribute
{
    public CustomAttribute(SomeType instance)
    {
    }
}</pre>
			<p>The compiler will allow the attribute to take the type – after all, it is a valid C# type. However, when you try to use it, you’re not allowed to create a new instance:</p>
			<pre class="source-code">
[Custom(new SomeType())] // Will give you a compiler error
public class MyClass
{
}</pre>
			<p>This is because the compiler needs the values to be available at compile time. Even though attributes are ultimately instantiated at runtime, the information captured and added to the compiled assembly is never executed. This means that you’re limited to things the compiler can<a id="_idIndexMarker157"/> resolve, such as primitive types (for example, <strong class="source-in ine">int</strong>, <strong class="source-in ine">float</strong>, and <strong class="source-in ine">double</strong>) and things such as strings – anything that can be represented as constants and not have to be created by the runtime to work.</p>
			<p>A valid parameter could be a string:</p>
			<pre class="source-code">
public class CustomAttribute : Attribute
{
    public CustomAttribute(string information)
    {
    }
}</pre>
			<p>With the constructor now taking a string, it will work not just at compile time but also at runtime.</p>
			<p>Since strings can be literal constants, you are allowed to use them:</p>
			<pre class="source-code">
[Custom("I'm a valid parameter")]
public class MyClass
{
}</pre>
			<p>Already, you can see the power of attributes – the ability to have additional information sitting there that your <a id="_idIndexMarker158"/>code can reason about and you can use to make decisions or even use for reporti<a id="_idTextAnchor087"/>ng.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor088"/>Limiting attribute usage</h2>
			<p>For attributes, you can also add<a id="_idIndexMarker159"/> metadata to them, which feels a little bit like inception; metadata for the metadata. The metadata that you add is to limit the scope of how the attribute can be used.</p>
			<p>You can be very specific about what elements in your code the attribute is for (class, property, field, and so on).</p>
			<p>The <strong class="source-in ine">[AttributeUsage]</strong> attribute allows you to be specific about the attribute. Let’s say you want to limit the usage to only classes – you can do the following:</p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class)]
public class CustomAttribute : Attribute
{
}</pre>
			<p>If you then try to add the attribute to something else other than a class, you will get a compiler error:</p>
			<pre class="source-code">
public class MyClass
{
    [Custom] // Compiler error
    public void SomeMethod()
    {
    }
}</pre>
			<p>The <strong class="source-in ine">[AttributeUsage]</strong> type is an enum holding different values for the different code elements attributes support. Every value in the enum represents a flag, making it possible to combine them and target multiple code element types.</p>
			<p>Let’s limit the code elements to <strong class="source-in ine">Class</strong>, <strong class="source-in ine">Method</strong>, and <strong class="source-in ine">Property</strong> by applying the <strong class="source-in ine">[AttributeUsage]</strong> attribute with these specified for the custom attribute:</p>
			<pre class="source-code">
[AttributeUsage(
    AttributeTargets.Class |
    AttributeTargets.Method |
    AttributeTargets.Property)]
public class CustomAttribute : Attribute
{
}</pre>
			<p>As you can see, using <a id="_idIndexMarker160"/>the bitwise <strong class="bo d">OR</strong> construct (<strong class="source-in ine">|</strong>) you can add all the elements you want to support.</p>
			<p>A little fun fact about <strong class="source-in ine">[AttributeUsage]</strong> is that it uses itself to tell the compiler that it can only be used for classes. Again, a little bit <a id="_idIndexMarker161"/>of inception there; the <strong class="source-in ine">[AttributeUsage]</strong> attribute is using <strong class="source-in ine">[AttributeUsage]</strong> to provide metadata about itself.</p>
			<p>In addition to limiting the code elements an attribute can be associated with, you can also tell whether or not you allow multiple instances of the attribute to be applied. You can also specify whether or not you allow the attribute to be available as metadata for types inheriting from the type that has the attribute applied to it.</p>
			<p>The <strong class="source-in ine">[AttributeUsage]</strong> attribute does, however, only take one parameter in its constructor. That means we have to use its properties explicitly.</p>
			<p>By default, attributes are limited to only being associated once per code element type. Trying to associate the attribute more than once will give you a compiler error:</p>
			<pre class="source-code">
[Custom]
[Custom] // Compiler error
public class MyClass
{
}</pre>
			<p>This behavior can be changed by simply using the <strong class="source-in ine">AllowMultiple</strong> property:</p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class, AllowMultiple =
  true)]
public class CustomAttribute : Attribute
{
}</pre>
			<p>Compiling the same code will now be allowed.</p>
			<p>The other property you can <a id="_idIndexMarker162"/>use for limiting the usage of the attributes is the <strong class="source-in ine">Inherited</strong> property. Setting this to <strong class="source-in ine">false</strong> will tell the compiler that the associated attribute is only the specific type it is being used explicitly and not for the derived type:</p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public class CustomAttribute : Attribute
{
}</pre>
			<p>As you saw earlier, you can add the attribute in a normal way to the class:</p>
			<pre class="source-code">
[Custom]
public class MyClass
{
}</pre>
			<p>You can add a class that inherits from the type with the <strong class="source-in ine">[Custom]</strong> attribute applied to it:</p>
			<pre class="source-code">
public class MyOtherClass : MyClass
{
}</pre>
			<p>The metadata associated with the <strong class="source-in ine">MyClass</strong> base type will not be associated with <strong class="source-in ine">MyOtherClass</strong> when the <strong class="source-in ine">Inherited</strong> property is set to <strong class="source-in ine">false</strong>. This is, by default, turned on, meaning that the derived type will have the same metadata associated with it.</p>
			<p>To create an attribute, inheriting from <strong class="source-in ine">Attribute</strong> and applying <strong class="source-in ine">[AttributeUsage]</strong> is all you need to do. However, you might want to bring more clarity and explicitness to your <a id="_idIndexMarker163"/>metadata by not allowing inheritance from your attribute. Sealing your class will disable anyone inheriting from your custom attribute.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor089"/>Sealing your attribute class</h2>
			<p>Since attributes represent specific metadata, they’re not a regular code construct that you use for holding logic. Therefore, you will <a id="_idIndexMarker164"/>find that you don’t need to create base attributes that other, more specific attributes inherit from. In fact, it could make your metadata unclear if you use inheritance as your metadata will lose explicitness and you would bring implicitness into it.</p>
			<p>Because of this, it is considered good practice to not allow for the inheritance of attributes and stop it at a compiler level by making the attribute class <strong class="source-in ine">sealed</strong>:</p>
			<pre class="source-code">
public sealed class CustomAttribute : Attribute
{
}</pre>
			<p>If you then try to create a more specific attribute that inherits from it, you will get a compiler error.</p>
			<p>Now that we’ve covered all the mechanics involved in creating custom attributes and how you can make them very specific to your use case, you are probably eager to start actually discovering them and putting them to <a id="_idTextAnchor090"/>good use.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor091"/>Finding types with specific attributes</h1>
			<p>Since attributes are created at <a id="_idIndexMarker165"/>compile time and do not require you to have an instance of a type that has been associated with attributes, you can discover attributes using the type system.</p>
			<p>If you look at the <strong class="source-in ine">System.Type</strong> type, you’ll see that it implements a type called <strong class="source-in ine">MemberInfo</strong> that sits in the <strong class="source-in ine">System.Reflection</strong> namespace. This base class serves as the base class for <strong class="source-in ine">PropertyInfo</strong>, <strong class="source-in ine">MethodInfo</strong>, <strong class="source-in ine">FieldInfo</strong>, and most of the specific info types representing code elements we can discover through the type system.</p>
			<p>On the <strong class="source-in ine">MemberInfo</strong> type, you<a id="_idIndexMarker166"/> find a method called <strong class="source-in ine">GetCustomAttributes()</strong>. This lets you get a collection of attributes associated with the particular code element.</p>
			<p>Take the class we had before:</p>
			<pre class="source-code">
[Custom]
public class MyClass
{
}</pre>
			<p>You can then quite easily get to the custom attributes on a type and loop through them and perform the actions you want to:</p>
			<pre class="source-code">
foreach( var attr in typeof(MyClass).GetCustomAttributes() )
{
    // Do something based on the attribute
}</pre>
			<p>Using <strong class="source-in ine">typeof()</strong> is very explicit and can be used just for this type. For a more dynamic solution, you can discover what types have a specific attribute, which you can leverage for the work we did in <a href="B19418_04.xhtml#_idTextAnchor059"><em class="ita ic">Chapter 4</em></a>, <em class="ita ic">Reasoning about Types </em><em class="ita ic">Using <a id="_idTextAnchor092"/>Reflection</em>.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor093"/>Personal Identifiable Information (PII)</h2>
			<p>Let’s go back to the GDPR theme we<a id="_idIndexMarker167"/> touched on in previous chapters. In <a href="B19418_04.xhtml#_idTextAnchor059"><em class="ita ic">Chapter 4</em></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, we used types to discover what was personally identifiable information. Another approach could be to use custom attributes as an explicit metadata approach. With attributes, we can associate more than what we did with a base type in <a href="B19418_04.xhtml#_idTextAnchor059"><em class="ita ic">Chapter 4</em></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>. You can add metadata about the reason for collecting the data.</p>
			<p>You can capture this with an attribute like the following:</p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class |
  AttributeTargets.Property | AttributeTargets.Parameter,
    AllowMultiple = false, Inherited = true)]
public class PersonalIdentifiableInformationAttribute :
  Attribute
{
    public PersonalIdentifiableInformationAttribute(string
      reasonForCollecting = "")
    {
        ReasonForCollecting = reasonForCollecting;
    }
    public string ReasonForCollecting { get; }
}</pre>
			<p>The code creates an attribute that can be applied to classes, properties, and parameters. It does not <a id="_idIndexMarker168"/>allow multiple instances of itself to be applied to the code element it will be applied to. It allows the metadata to be available for any type that inherits from the type that has this metadata applied to it or its members. One of the things it is interesting to know about GDPR is the reason the system collects specific data – the attribute, therefore, has this as optional metadata.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">You’ll find this implementation in the <strong class="source-in ine">Fundamentals</strong> project in the GitHub repository.</p>
			<p>Start by creating a folder called <a href="B19418_05.xhtml#_idTextAnchor083"><em class="ita ic">Chapter 5</em></a>. Change into this folder in your command-line interface and create a new console project:</p>
			<pre class="source-code">
dotnet new console</pre>
			<p>The next thing you’ll need to do is to reference the Fundamentals project. If you have the project next to the <strong class="source-in ine">Chapter5</strong> folder, do the following:</p>
			<pre class="source-code">
dotnet add reference ../Fundamentals/Fundamentals.csproj</pre>
			<p>With that in place, let’s say you want to create an object that encapsulates an employee:</p>
			<pre class="source-code">
public class Employee
{
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public string SocialSecurityNumber { get; set; } =
      string.Empty;
}</pre>
			<p>This type clearly holds <a id="_idIndexMarker169"/>properties that would be identifiable for the person; let’s add the appropriate metadata for its members:</p>
			<pre class="source-code">
using Fundamentals.Compliance.GDPR;
public class Employee
{
    [PersonalIdentifiableInformation("Employment records")]
    public string FirstName { get; set; } = string.Empty;
    [PersonalIdentifiableInformation("Employment records")]
    public string LastName { get; set; } = string.Empty;
    [PersonalIdentifiableInformation("Uniquely identifies
      the employee")]
    public string SocialSecurityNumber { get; set; } =
      string.Empty;
}</pre>
			<p>With this, we now have enough information to discover any type in the system that holds this type of information.</p>
			<p>Building on the assembly and type discovery system introduced in <a href="B19418_04.xhtml#_idTextAnchor059"><em class="ita ic">Chapter 4</em></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, we can query specifically for this.</p>
			<p>Since every member on a type inherits from the <strong class="source-in ine">MemberInfo</strong> type found in the <strong class="source-in ine">System.Reflection</strong> namespace, we can easily create a convenience extension method allowing us to check whether a member has a specific attribute associated with it.</p>
			<p>You can then create a <a id="_idIndexMarker170"/>simple extension method that allows you to check whether an attribute is associated with a member:</p>
			<pre class="source-code">
public static class MemberInfoExtensions
{
    public static bool HasAttribute&lt;TAttribute&gt;(this
      MemberInfo memberInfo) where TAttribute : Attribute
        =&gt; memberInfo.GetCustomAttributes&lt;TAttribute&gt;()
          .Any();
}</pre>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">You’ll find this implementation in the <strong class="source-in ine">Fundamentals</strong> project in the GitHub repository.</p>
			<p>With this in place, you can discover all the types with this information:</p>
			<pre class="source-code">
using Fundamentals;
var types = new Types();
var piiTypes = types.All.Where(_ =&gt; _
                    .GetMembers()
                    .Any(m =&gt; m.HasAttribute&lt;Personal
                      IdentifiableInformation
                        Attribute&gt;()));
var typeNames = string.Join("\n", piiTypes.Select(_ =&gt;
  _.FullName));
Console.WriteLine(typeNames);</pre>
			<p>The <strong class="source-in ine">HasAttribute&lt;&gt;</strong> extension method is a powerful little helper that you’ll find handy in all scenarios where<a id="_idIndexMarker171"/> you want to do simple querying of type metadata based on attributes.</p>
			<p>To create a GDPR report with the reason for collecting information, change the <strong class="source-in ine">Program.cs</strong> file look like the following:</p>
			<pre class="source-code">
using System.Reflection;
using Fundamentals;
var types = new Types();
Console.WriteLine("\n\nGDPR Report");
var typesWithPII = types.All
                        .SelectMany(_ =&gt;
                            _.GetProperties()
                                .Where(p =&gt; p.HasAttribute
                                 &lt;PersonalIdentifiable
                                  InformationAttribute&gt;()))
                        .GroupBy(_ =&gt; _.DeclaringType);
foreach (var typeWithPII in typesWithPII)
{
    Console.WriteLine($"Type: {typeWithPII.Key!
      .FullName}");
    foreach (var property in typeWithPII)
    {
        var pii = property.GetCustomAttribute&lt;
          PersonalIdentifiableInformationAttribute&gt;();
        Console.WriteLine($"  Property : {property.Name}");
        Console.WriteLine($"    Reason :
          {pii.ReasonForCollecting}");
    }
}</pre>
			<p>The code leverages the type <a id="_idIndexMarker172"/>discovery introduced in <a href="B19418_04.xhtml#_idTextAnchor059"><em class="ita ic">Chapter 4</em></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, and uses LINQ extension methods to select all the types that have properties with <strong class="source-in ine">[PersonalIdentifiableInformationAttribute]</strong> applied. It then groups them by type so that you can easily loop through and present the members with the attribute per type.</p>
			<p>Running this will yield the following result:</p>
			<pre class="source-code">
GDPR Report
Type: Main.Employee
  Property : FirstName
    Reason : Employment records
  Property : LastName
    Reason : Employment records
  Property : SocialSecurityNumber
    Reason : Uniquely identifies the employee</pre>
			<p>This type of metadata is very valuable for a business. If your business gets a query from the government about a GDPR audit, with your code fully loaded with metadata you can easily create a report on what type of data you’re collecting and the reason for collecting it.</p>
			<p>You could also present this type of information to the end users of your system. It is very valuable for a user to know what the system collects about them. This builds a trusting relationship between the system and your users.</p>
			<p>GDPR is a very good use case for getting very useful metadata into your code base, but it is just one of many use <a id="_idIndexMarker173"/>cases. You can, of course, make use of metadata in a more actionable way other than j<a id="_idTextAnchor094"/>ust for reporting.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor095"/>Generic attributes</h1>
			<p>One of the limitations of C# attributes <a id="_idIndexMarker174"/>that we used to have is that attributes could not be generic types taking generic arguments. Prior to C# 11, you would get a compiler error if you added a <a id="_idIndexMarker175"/>generic argument to your attribute class. This limitation is lifted with the release of <strong class="bo d">C# 11</strong>.</p>
			<p>Up till C# 11, the only way you could collect type information was for the attribute to have parameters or properties that were of type <strong class="source-in ine">System.Type</strong>. This became very verbose:</p>
			<pre class="source-code">
public class CustomAttribute : Attribute
{
    public CustomAttribute(Type theType)
}</pre>
			<p>And then adorning a type with the attribute would be as follows:</p>
			<pre class="source-code">
[Custom(typeof(string))]
public class MyClass
{
}</pre>
			<p>With C# 11, now you can improve how you get type information:</p>
			<pre class="source-code">
public class CustomAttribute&lt;T&gt; : Attribute
{
}</pre>
			<p>When you adorn a type <a id="_idIndexMarker176"/>with the attribute, you use the generic argument:</p>
			<pre class="source-code">
[Custom&lt;string&gt;]
public class MyClass
{
}</pre>
			<p>If you’re looking to have a parameter that is dynamic in type, you can do the following:</p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class, AllowMultiple =
  true)]
public class CustomAttribute&lt;T&gt; : Attribute
{
    public CustomAttribute(T someParameter)
    {
        SomeParameter = someParameter;
    }
    public T SomeParameter { get; }
}</pre>
			<p>The code defines an attribute that takes a generic argument and it then requires a parameter for the attribute, which will then be of the generic type. It then uses the same generic type when exposing the metadata as a property on the attribute.</p>
			<p>When adorning types with the attribute, you specify the type and the parameter because the attribute has to be of the type specified:</p>
			<pre class="source-code">
[Custom&lt;int&gt;(42)]
[Custom&lt;string&gt;("Forty two)]
public class MyClass
{
}</pre>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Normally the C# compiler is very good at inferring the type for generic arguments based on the type passed in. But with generic attributes, you have to explicitly give it the generic type every time.</p>
			<p>Generic attributes can be<a id="_idIndexMarker177"/> another powerful metadata collection approach. It adds flexibility to how you can co<a id="_idTextAnchor096"/>nstruct your metadata.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor097"/>Summary</h1>
			<p>In this chapter, we’ve looked at what C# attributes are and how powerful they are for describing explicit metadata in your code. We’ve looked at all the mechanics of how you can create your own custom attributes and apply them very to different code elements. From this type of metadata, you can now enrich your code.</p>
			<p>With the enrichment looked at in this chapter, you’ve seen how you can quite easily discover this metadata and put it to good use for your business.</p>
			<p>In our next chapter, we will dive further into the capabilities of the .NET runtime and look at how you can dynamically generate code based on metadata, making you more productive as a developer in doing so.</p>
		</div>
	</body></html>