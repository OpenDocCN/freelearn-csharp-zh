<html><head></head><body>
		<div><h1 id="_idParaDest-81" class="chapter-number"><a id="_idTextAnchor082"/>3</h1>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/>What Is Multi-Tenancy, and Why Is It Important in SaaS Applications?</h1>
			<p>Multi-tenancy has become a critical architectural pattern in modern <strong class="bold">Software as a Service</strong> (<strong class="bold">SaaS</strong>) applications, enabling providers to serve multiple customers (tenants) from a single instance of their software.</p>
			<p>This chapter will delve into this very important part of building SaaS applications –termed <em class="italic">multi-tenancy</em> – whereby multiple tenants can use the <em class="italic">same instance</em> of a deployed application and still keep their data private and segregated.</p>
			<p>Under a multi-tenancy system, multiple customers of the SaaS application can use the same instance of the application and also optionally use the same database, but their data is segregated, such that no other tenant can see the data – unless it is explicitly shared. This obviously raises a number of concerns about security and data privacy. For a company building a multi-tenant SaaS application, it is extremely important to ensure that any given customer is only ever able to see their own data and never anyone else’s!</p>
			<p>Many strategies, patterns, utilities, and technologies can be leveraged to ensure that an individual tenant’s data remains segregated, but the first line of defense is – as always –a sound technical understanding of the underlying concepts. It is particularly important that the development team appreciates this when the application is being crafted. Multi-tenancy is essential for any SaaS application that will scale, which almost all of them will aim to do!</p>
			<p>The privacy and security of data in a SaaS multi-tenant application are paramount. It’s hard to think of any instance where a multi-tenant SaaS application is built that did not require at least some of the tenants’ and users’ data to remain private. Robust data security and segregation of data are, therefore, key considerations when setting out to build a SaaS application.</p>
			<p>When starting out on the development cycle for a new application, it is considerably easier to build robust security into the application at the very start of the project than it is to retrospectively add it in later! It is also much less risky to get the security and segregation working correctly from the start – once the inevitable application sprawl and feature creep start, it is considerably harder to convince yourself that everything really is locked down as tightly as it should be.</p>
			<p>We are covering this topic early in this book so that, as we build out our demo application, you will have a solid understanding of multi-tenancy and how it impacts future design choices. I strongly encourage you to take the same approach when building a SaaS application, taking the time at the start of the project to plan a strategy for multi-tenancy and the security considerations that will arise.</p>
			<p>During this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Gaining an understanding of what multi-tenancy is</li>
				<li>Considering the options for data storage with multi-tenant applications</li>
				<li>Understanding the design considerations through the application layers</li>
				<li>Discussing security considerations</li>
			</ul>
			<p>By the end of the chapter, you’ll have a good understanding of multi-tenancy, multi-tenant applications, and the specific security considerations that will arise when working on SaaS and, specifically, multi-tenant software applications.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>All code from this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-3">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-3</a>.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/>What is multi-tenancy?</h1>
			<p>Multi-tenancy is <a id="_idIndexMarker125"/>a software architecture pattern commonly used in SaaS applications, wherein a single application instance serves multiple customer groups or organizations, known as tenants. Each tenant shares the same underlying infrastructure and resources, such as servers, databases, and application logic, but maintains its own isolated data and configurations. This approach allows for optimized resource usage, streamlined maintenance, and reduced operational costs. The primary challenge in a multi-tenant architecture is to ensure data isolation, security, and performance for each tenant, while also offering customization and scalability. In essence, multi-tenancy enables SaaS providers to deliver a cost-effective, secure, and customizable solution to a diverse range of customers, using a shared application instance.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>Disambiguating customers, tenants, and users</h2>
			<p>When talking about multi-tenancy, is it important to disambiguate the related but distinct concepts:</p>
			<ul>
				<li><strong class="bold">Customers</strong>: Customers<a id="_idIndexMarker126"/> refer to the organizations or individuals who purchase or subscribe to a software product or service. In the context of SaaS applications, customers may be represented as one or more tenants, with each customer group having access to its own isolated environment within the shared application instance. The term “customer” generally emphasizes the business relationship and financial aspect of using a software product or service.</li>
				<li><strong class="bold">Tenants</strong>: Tenants <a id="_idIndexMarker127"/>represent separate organizations, companies, or groups that use a shared instance of a SaaS application in a multi-tenant architecture. Each tenant has its own isolated data, configurations, and customizations while sharing the same software infrastructure and resources with other tenants. A key aspect of a multi-tenant system is that each tenant can have multiple users associated with it, enabling individual access and personalized experiences within the shared application instance.</li>
				<li><strong class="bold">Users</strong>: Users are<a id="_idIndexMarker128"/> the individual people who interact with a software system or application, often with unique login credentials and personalized settings. Users belong to a specific tenant, organization, or group, and their actions and access within the system can be managed with role-based permissions or access control. Users represent the actual individuals using the software, carrying out various tasks and activities within the application.</li>
			</ul>
			<p>Let’s consider an example where two large companies use a SaaS application. The companies are customers, and to keep this example simple, each will have a single tenant in the application. Each company could have hundreds or thousands of employees who use the system. It would be typical for both companies to want to customize the app in some way for their own employees. For example, they may want to display their logo when a user logs in. This would be achieved by having two <em class="italic">tenants </em>in the application, each configured to show the correct logo to the users who belong to that company.</p>
			<p>There will be two levels of data segregation. The individual tenant configuration (the logo, for example) will be separate, and any user operating within that tenant must always see the correct logo. There will be a further level of segregation, keeping each individual user’s data private.</p>
			<p>Users with elevated permissions within a tenant (admin users) may be able to modify details for other users within that same tenant, but never for any other tenants.</p>
			<p>It is very important to keep this in mind as we progress through this chapter – make sure that you understand the difference between users and tenants before moving on:</p>
			<ul>
				<li>A customer can have one or more tenants in an application, often one, meaning that the terms <em class="italic">customer</em> and <em class="italic">tenant</em> can be used interchangeably</li>
				<li>A tenant can have one or more users under it, most often more than one, meaning that the terms should not be used interchangeably</li>
			</ul>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/>What are the alternatives to multi-tenancy?</h2>
			<p>While SaaS <a id="_idIndexMarker129"/>applications are largely synonymous with <a id="_idIndexMarker130"/>multi-tenant applications, it is technically possible to deliver a SaaS application as a single-tenant application.</p>
			<p>If a single-tenant approach is followed, then every time a new tenant is onboarded, there is an entirely new application stack and a new database deployed for that specific tenant. There <em class="italic">could</em> be some very specific and limited shared services, such as a shared login page that redirects the customer to their own instance of the application, but in general, this will be a completely unique and isolated deployment of the software on a per-customer basis.</p>
			<p>A single-tenant application<a id="_idIndexMarker131"/> is generally considered to be the most secure method and could be considered the most reliable method to deliver an application to a single customer. However, it is significantly most expensive to do this for each and every customer, and the costs to scale such an architecture quickly become unmanageable.</p>
			<p>The resources required to maintain, support, upgrade, and customize such an application are very high, meaning that the price to the end user is also high, and would typically restrict your customer base to the enterprise. If your end goal is to attract non-enterprise customers, this single-tenant approach is very unlikely to be successful.</p>
			<p>It is also somewhat stretching the definition of SaaS. If each customer simply gets a unique installation of the software, albeit in the cloud, then it is much closer to the traditional method of delivering software – on a CD with a unique key printed on it!</p>
			<p>Single tenancy<a id="_idIndexMarker132"/> in a SaaS application would really only be done for a very small subset of use cases. For this book, we will not consider this any further, other than to mention that it is technically possible to build a SaaS application without making use of a multi-tenant architecture!</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor088"/>The advantages and disadvantages of multi-tenancy</h2>
			<p>Some of the advantages <a id="_idIndexMarker133"/>of using a multi-tenant architecture are as follows:</p>
			<ul>
				<li><strong class="bold">Cost</strong>: Multi-tenancy is typically a very cost-efficient way to deliver an application from the point of view of provisioning resources (app servers, databases, and so on). Multi-tenancy also tends to be very cost-efficient when considering ongoing support and maintenance costs. The marginal cost for every additional tenant, and each additional user within that tenant, will typically not add much to the overall cost once the application has gone live.</li>
				<li><strong class="bold">Tiered pricing</strong>: Customers can be offered a range of pricing options to suit them and their organization specifically. The pricing can scale linearly as new tenants are added and users are introduced from the new tenant’s organization.</li>
				<li><strong class="bold">Easy to update</strong>: With only one instance of the application being accessed by many tenants, a single update can be performed that will get every user across all tenants on the latest and greatest version. Note that it is also possible, if more complex, to configure this <a id="_idIndexMarker134"/>using <strong class="bold">Continuous Deployment</strong> (<strong class="bold">CD</strong>) <strong class="bold">pipelines</strong> under a single-tenant model.</li>
				<li><strong class="bold">Scalability</strong>: A SaaS application using a multi-tenant architecture will typically scale up very easily as the number of tenants and users increases. Assuming that a cloud provider is used, this can happen literally effortlessly on the part of the development team. A cloud service can be configured so that as additional demand is placed on the system by the<a id="_idIndexMarker135"/> growing user base, additional resources are deployed automatically.</li>
			</ul>
			<p>It’s not all good, though – there are a few disadvantages that should also be considered:</p>
			<ul>
				<li><strong class="bold">Increased complexity</strong>: From a <a id="_idIndexMarker136"/>software architecture point of view, a multi-tenant application is almost by definition more challenging to build. There are additional complexities throughout the application stack, starting with the database requiring some form of segmentation by tenant all the way up the stack to the user interface, where each user must be securely authenticated and authorized to access only certain parts of the system.</li>
				<li><strong class="bold">Increased security requirements</strong>: The fact that multiple tenants share a single application instance necessitates a much more thorough approach to user security. It is typically an absolute disaster scenario for a business if one of their user’s private data is leaked to another user through their application, and doubly so if that user belonged to a different tenant organization.</li>
				<li><strong class="bold">Downtime is a disaster</strong>: If a multi-tenant SaaS system goes down for any reason, then typically, every single customer will have no access to the application. This obviously makes reducing downtime absolutely critical.</li>
				<li><strong class="bold">Noisy neighbors</strong>: Given that each tenant shares an application, they are, therefore, also sharing resources, such as the compute time of the cluster or the servers on which the application is deployed. One particularly compute-hungry user could have a knock-on effect on every other user of a system.</li>
			</ul>
			<p>An observation from the preceding lists is that the advantages provided are significant and cannot really be worked around if using a single-tenant architecture. However, the disadvantages of a multi-tenant system can usually be mitigated by simply taking more time upfront to design the system well. Of course, there is a cost in doing so, which must be balanced carefully when choosing the application architecture and making decisions about system design.</p>
			<p>In general, though, the higher upfront cost will be returned many times over as the number of tenants and the user base starts to grow and the power of the SaaS/multi-tenant application is realized!</p>
			<p>I hope that with the preceding discussion, I have convinced you of the benefits of multi-tenant architecture and encouraged you to consider this at the very start of your project. We can now move on to discuss the specifics of designing for multi-tenancy, starting with the most important – data storage!</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor089"/>Options for data storage with multi-tenant applications</h1>
			<p>A<a id="_idIndexMarker137"/> database in any application is typically the foundation upon which the rest of the application is built. The decisions that are taken when selecting and designing the database will have significant knock-on effects on the data access/API layer and probably some impact on the user interface as well.</p>
			<p>Additionally, the data stored in an application will represent your customers’ business information. Often, this information will be incredibly valuable to them, and by entrusting it to you – as a developer working on a SaaS application – they are showing significant trust that you can keep this valuable asset safe. The database underpinning a SaaS application should be like a bank vault where your customers are happy to deposit their data!</p>
			<p>Therefore, making the correct choices in database design is extremely important for the rest of the application development, and also for the tenants and individual users of the application.</p>
			<p>While this section is focused on the database, its role as the foundation for the rest of the application will necessitate some discussion about how the choices made will impact other layers and parts of the application.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor090"/>Key considerations</h2>
			<p>The approach taken for data storage is very important, with a few key areas to consider before you start building.</p>
			<h3>Design complexity</h3>
			<p>Generally, when starting to build a<a id="_idIndexMarker138"/> new application, it is a good idea to focus on simplicity in design, and only add complexity when it is required. Building in multi-tenancy does add significant complexity to the application, so it is very important that the level of complexity is considered and the solution is sized accordingly.</p>
			<p>Consider how many tenants you expect to have, and pick a solution that matches that. Consider also how important data isolation is, and pick a solution that matches that.</p>
			<p>You should also keep in mind that some customers – particularly large corporate customers – may expect some degree of customization. Allowing per-customer customizations can start to exponentially increase the complexity of a design. While it is generally preferred to avoid any kind of customization, this may not be possible. If it is felt that this will be a requirement, then some consideration for this eventuality should be taken into account at the design stage.</p>
			<h3>Support complexity</h3>
			<p>While the <a id="_idIndexMarker139"/>process of developing the application is, of course, costly for the company that is funding the undertaking, it is important to consider the ongoing cost of actually running the application. This is the period in the application life cycle where it is expected to generate revenue, and that will not be possible if there are huge ongoing support and maintenance costs.</p>
			<p>One very important aspect of ongoing maintenance is monitoring your tenants’ usage. The “80–20” principle will most likely apply, and you need to know which of your tenants are the most profitable… and which are the most problematic!</p>
			<p>You need to consider that some of your tenants will have higher availability requirements than others. Will you be able to support a tenant with a 99.99% uptime requirement? And do you understand the additional costs and technical trade-offs in offering this level of service?</p>
			<p>Support and maintenance can quickly become a technical and financial nightmare if they are not considered early on in the project life cycle.</p>
			<h3>Scale</h3>
			<p>No application ever <a id="_idIndexMarker140"/>launched with a billion users – they all started with one!</p>
			<p>When planning a SaaS application, you need to have at least some idea of the scale that you expect to operate at over the short, medium, and long term. With this understanding, you can make smart decisions that suit the individual users and the tenants from launch day through to platform maturity.</p>
			<p>There is no point in wasting effort and resources to build for a billion users on day one. Similarly, there is no way to get to a billion users if there is no plan in place to adequately service that number of users.</p>
			<h3>Performance</h3>
			<p>Under a multi-tenant system, many<a id="_idIndexMarker141"/> users will be sharing – and, therefore, competing for access to – resources. This includes users under separate tenants, who would typically work for different organizations.</p>
			<p>You need to consider how a typical tenant and a typical user will use the system. For example, if you are building an enterprise system and focusing on a single time zone, you should expect to see almost all the usage during business hours. You will need to size your resources to meet this demand, even though they will be idle out of business hours.</p>
			<p>You may face a similar problem with – for example – a streaming service that will spike in usage in the evening.</p>
			<p>Note that this scenario would offer a considerable advantage to a company offering its services across multiple time zones, where the usage spikes could be flattened out.</p>
			<p>Users in a multi-tenant system competing for shared resources is known as the “noisy neighbor” problem. This phenomenon is where one tenant or user is exhibiting particularly heavy resource usage and, by doing so, degrades the system performance for its other users. This problem is inevitable to a certain extent when building a multi-tenant system, but there are ways it can be mitigated, such as the following:</p>
			<ul>
				<li>Implementing throttling to prevent a single tenant or user from consuming a disproportionate amount of resources.</li>
				<li>Monitoring how the tenants and users interact with the system and working around the more resource-intensive examples. For example, they could be moved to a separate cluster.</li>
				<li>Purchasing <a id="_idIndexMarker142"/>additional cloud resources. This is something of a blunt instrument, but it is effective.</li>
			</ul>
			<h3>Isolation</h3>
			<p>As we h discussed <a id="_idIndexMarker143"/>previously, it is of the utmost importance that data that relates to one tenant is invisible to another tenant, and each of the users within those tenants. An individual tenant’s data must be isolated. There are a few ways this can be achieved:</p>
			<ul>
				<li>Containers can be used on a one-container-per-tenant basis. This can be a very effective method to compartmentalize tenants of a system, but there would be scaling concerns should the application turn into the next Facebook.</li>
				<li>Separate tables can be used per tenant in the same database. This provides a good degree of assurance that data cannot “leak,” but again, this would not scale efficiently to hundreds of tenants and millions of users.</li>
				<li>Tenant ID-based isolation, where data in the database is all in one table, with a <code>tenant_id</code> column. This scales very well but could be considered to be less secure than the previous options.</li>
			</ul>
			<p>There is no “one-size-fits-all” approach to this problem. The level of isolation required will depend on the type of customers and the type of data being stored. This should be carefully considered at the start of a project, as changing the approach to data isolation later in the project life cycle can be <a id="_idIndexMarker144"/>extremely challenging.</p>
			<h3>Cost</h3>
			<p>Of course, we <a id="_idIndexMarker145"/>would like the most secure, performant, and easy-to-maintain application possible, but as application developers, we must always operate within the confines of the economic realities that are faced by the company building the application.</p>
			<p>Even with matters as important as data security, there is always a cost trade-off to be made.</p>
			<p>It is extremely helpful if these are understood at the start of a project so that there are no nasty surprises later!</p>
			<p>A database is foundational to the rest of an application, and making the correct choices regarding the aforementioned considerations is extremely important. The choices that are made at this stage will significantly impact the rest of the application. We will consider this in the next section.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor091"/>Design considerations through the application layers</h1>
			<p>The approach<a id="_idIndexMarker146"/> that will be taken to solve a multi-tenancy<a id="_idIndexMarker147"/> problem is probably one of the most important decisions to take in the early stages of a project. It can be one of the most expensive and technically challenging aspects to make a change to later in the project life cycle. The planning and the design of a solution for the multi-tenant problem must start in the very early phases and will influence all of the various layers in the application.</p>
			<p>The core reason for multi-tenancy is to segregate data that one customer stores such that it is not visible to a user under a different tenant.</p>
			<p>The key decision to make is where the data will be segregated, and this primarily affects the design of the database. The decision driver for this will have to be related to the users of a system. To make this decision, it is vital to understand the following:</p>
			<ul>
				<li>Who your tenants will be.</li>
				<li>How your users will use a system.</li>
				<li>What the consequences of a data breach are to your customers.</li>
				<li>What the customers’ tolerance for risk versus cost is. Would they prefer a more costly but more secure solution or a cheaper solution?</li>
				<li>What the consequences of a data leak are to a business</li>
			</ul>
			<p>Users of social media sites do not seem overly concerned for their privacy, and so will likely tolerate a less security-conscious approach to data segregation. Also, users of social media are often not prepared to pay anything for the system, so they are very price-conscious and not at all data privacy-conscious. Indeed, the business model of a social network is often to sell users’ data to the highest bidder!</p>
			<p>Enterprise customers will almost never tolerate a social media-esque approach to data and will always prefer a more secure regime. Some enterprise customers will not accept a multi-tenant system at all. Military or government customers, for example, would almost certainly consider the risks too high and would insist on a single-tenant solution.</p>
			<p>If the customers of an application are likely to be primarily motivated<a id="_idIndexMarker148"/> by security, and in particular, rigorous data segregation and an absolute guarantee that there will be no slip-ups, then the best solution is to not design a multi-tenant application and, therefore, not build a SaaS application! Given that this book is about developing SaaS applications, we will discount this customer class entirely. However, it is important to be aware of the limitation of the technique. A customer base that is primarily motivated by absolute data security over all other considerations is very unlikely to accept an app that is delivered via SaaS. These users will most likely require on-premises solutions hosted inside their own network, with full control over the data retained by the users’ organization.</p>
			<p>Given that we are building for customers that we feel will buy a SaaS application, let’s consider those!</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/>One database per tenant</h2>
			<p>The most secure way<a id="_idIndexMarker149"/> to segregate one tenant’s data from another is to store the data in completely separate databases. This has a considerable overhead in terms of maintaining and updating the multiple databases (one per customer) that are required under this scheme. This approach all but guarantees there will be no data leaks, but the additional overheads are considerable. An application that uses this scheme will also present challenges in scaling, and it may lead to spiraling costs if there is a per-instance license for the database platform that is selected.</p>
			<p>The issue of scaling does present a hard cap on the number of tenants that a system could be designed for. There is no way that Microsoft could make their DevOps platform work if every tenant organization had a unique and segregated database – there are simply too many customers for that to be feasible.</p>
			<p>Aside from <a id="_idIndexMarker150"/>security, one other benefit of this scheme is that the number of rows of data stored in the individual database will be lower than in a shared database, so there may be a slight performance boost possible in the database layer. Note that this may be offset in the application layers.</p>
			<p>This type of scheme would be used only if the number of customers was quite small and were hugely security-conscious. There would be an argument in these cases to build single-tenant, on-premises systems.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/>Shared schema</h2>
			<p>This is the most common solution<a id="_idIndexMarker151"/> that is used for the vast majority of commonly used SaaS applications that you may encounter in day-to-day use. Even some potentially sensitive applications, such as a system that hosts financial and taxation information, may make use of a shared schema.</p>
			<p>Under this regime, a single database is used, with tables containing data from multiple tenants. The data is protected from being shared using some form of identification in the database.</p>
			<p>Using this scheme significantly boosts the benefits that are derived from using the SaaS paradigm in the first place. These days, there are plenty of well-understood and well-used ways of keeping data secure under such a scheme. There may also be an argument to be made that having only one database and one schema to keep on top of actually makes it easy to secure a system.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor094"/>One schema per tenant</h2>
			<p>This is the <a id="_idIndexMarker152"/>halfway house between the two aforementioned options. Under this method, a single database is used, but the same schema is deployed to the database multiple times, once per customer. Each schema is isolated, and there are no connections or relations between the individual customers’ schema.</p>
			<p>In some ways, this is the best of both worlds, and in other ways, it’s the worst.</p>
			<p>There is still a significant additional overhead in managing the many schemas, and there is still a hard cap on the number of individual tenants that this could be scaled up to. Particularly<a id="_idIndexMarker153"/> security-conscious customers may still be turned off by this, considering it too much of a risk to even share a database.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>One table per tenant</h2>
			<p>This is very <a id="_idIndexMarker154"/>closely related to the aforementioned <em class="italic">one schema per tenant</em> method. Under this paradigm, every tenant in the system has a table added to the database that pertains only to them.</p>
			<p>The pros and cons of the previous method also apply here.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>Examples</h2>
			<p>To illustrate these points, I’ll build an example that demonstrates the two preceding segregations.</p>
			<p>We will<a id="_idIndexMarker155"/> imagine there are four tenant organizations of the <code>GoodHabits</code> app. These tenants are as follows:</p>
			<ul>
				<li>AscendTech, who is very security-conscious and wants a private database</li>
				<li>Bluewave, who is also security-minded and also wants a private database</li>
				<li>CloudSphere, who is a price-conscious customer and takes the cheaper option to have a shared database</li>
				<li>DataStream, who will also use the shared database and share it with CloudSphere</li>
			</ul>
			<p>With these four example organizations, we can demonstrate how a multi-tenant database can work. This example will not be exhaustive but will provide a solid foundational understanding.</p>
			<p>In this section, we will build on the <code>GoodHabits</code> database and API project that we created in the previous chapter.</p>
			<h3>Adding the required packages</h3>
			<p>We only need to add one nuget package to the <code>HabitService</code> project for this chapter. Navigate to the project folder in a terminal, and enter the following:</p>
			<pre class="source-code">
<strong class="bold">dotnet add package Microsoft.AspNetCore.Mvc.NewtonsoftJson;</strong></pre>
			<h3>Modifying the entity</h3>
			<p>Many of the<a id="_idIndexMarker156"/> tables in the database will require a column that identifies the owner of the data – the tenant! To facilitate this, we can start by creating an interface called <code>I</code><code>H</code><code>asTenant</code>. Create the file with the following commands:</p>
			<pre class="source-code">
<strong class="bold">cd GoodHabits.Database; \</strong>
<strong class="bold">mkdir Interfaces; \</strong>
<strong class="bold">cd Interfaces; \</strong>
<strong class="bold">touch IHasTenant.cs; \</strong>
<strong class="bold">cd ..;</strong></pre>
			<p>Then, copy the following code into the file:</p>
			<pre class="source-code">
namespace GoodHabits.Database;
public interface IHasTenant
{ public string TenantName { get; set; } }</pre>
			<p>You will recall that we previously created an entity class called <code>Habit</code> that defined the data structure for the database. This entity will need to have a <code>TenantName</code> value, so it should implement the <code>IHasTenant</code> interface. Modify the class that we created in <a href="B19343_02.xhtml#_idTextAnchor056"><em class="italic">Chapter 2</em></a> such that it looks like this:</p>
			<pre class="source-code">
namespace GoodHabits.Database.Entities;
public class Habit : IHasTenant
{
  public int Id { get; set; }
  public string Name { get; set; } = default!;
  public string Description { get; set; } = default!;
  public string TenantName { get; set; } = default!;
}</pre>
			<h3>Creating the tenant configuration</h3>
			<p>The <a id="_idIndexMarker157"/>configuration for the tenants in a live system would typically be stored in a separate database somewhere – a client portal application or similar. However, for the purposes of this demo, we will just use the <code>appsettings.json</code> file. Add the following to the <code>appsettings.json</code> file in the <code>Goodhabits.HabitService</code> project:</p>
			<pre class="source-code">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "TenantSettings": {
    "DefaultConnectionString": "Data
      Source=sqlserver;Initial
      Catalog=GoodHabitsDatabase;
      User Id=sa;Password=Password1;
      MultipleActiveResultSets=True;
      TrustServerCertificate=True;",
    "Tenants": [
      {
        "TenantName": "AscendTech",
        "ConnectionString": "Data Source=sqlserver;
          Initial Catalog=AscendTechGoodHabitsDatabase;
          User Id=sa;Password=Password1;
          MultipleActiveResultSets=True;
          TrustServerCertificate=True;"
      },
      {
        "TenantName": "Bluewave",
        "ConnectionString": "Data Source=sqlserver;
        Initial Catalog=BluewaveGoodHabitsDatabase;
        User Id=sa;Password=Password1;
        MultipleActiveResultSets=True;
        TrustServerCertificate=True;"
      },
      {
        "TenantName": "CloudSphere"
      },
      {
        "TenantName": "Datastream"
      }
    ]
  }
}</pre>
			<p>The preceding configuration has defined four tenants:</p>
			<ul>
				<li>The first two, AscendTech and Bluewave, want fully segregated databases and have had connection strings specified that are unique to them</li>
				<li>The second two, CloudSphere and Datastream, do not have a unique connection string, so they are considered to be happy to use the shared database</li>
			</ul>
			<p>In the <code>GoodHabits.Database</code> project, add a class that matches the structure of the config that we added into <code>appsettings.json</code> previously. The config will be loaded into this at startup. Call the class <code>TenantSettings</code>, and then paste <a id="_idIndexMarker158"/>in the following:</p>
			<pre class="source-code">
namespace GoodHabits.Database;
public class TenantSettings
{
    public string? DefaultConnectionString { get; set; }
    public List&lt;Tenant&gt;? Tenants { get; set; }
}
public class Tenant
{
    public string? TenantName { get; set; }
    public string? ConnectionString { get; set; }
}</pre>
			<h3>Creating a tenant service</h3>
			<p>Next, we will<a id="_idIndexMarker159"/> create a service that can provide details about the tenants to other parts of the application that may be interested.</p>
			<p>Start in the <code>GoodHabits.Database</code> project by adding an interface called <code>ITenantService</code>, and then add the following code:</p>
			<pre class="source-code">
namespace GoodHabits.Database;
public interface ITenantService
{
    public string GetConnectionString();
    public Tenant GetTenant();
}</pre>
			<p>Next, we<a id="_idIndexMarker160"/> need to implement this service. This is done in the HabitService project and should look like this. Double-check that you are adding this to the HabitService project and not the Database project:</p>
			<pre class="source-code">
using Microsoft.Extensions.Options;
using GoodHabits.Database;
namespace GoodHabits.HabitService;
public class TenantService : ITenantService
{
    private readonly TenantSettings _tenantSettings;
    private HttpContext _httpContext;
    private Tenant _tenant;
    public TenantService(IOptions&lt;TenantSettings&gt;
      tenantSettings, IHttpContextAccessor contextAccessor)
    {
        _tenantSettings = tenantSettings.Value;
        _httpContext = contextAccessor.HttpContext!;
        if (_httpContext != null)
        {
            if (_httpContext.Request.Headers.TryGetValue(
              "tenant", out var tenantId))
            {
                SetTenant(tenantId!);
            }
            else
            {
                throw new Exception("Invalid Tenant!");
            }
        }
    }
    private void SetTenant(string tenantId)
    {
        _tenant = _tenantSettings!.Tenants.Where(a =&gt;
          a.TenantName == tenantId).FirstOrDefault();
        if (_tenant == null) throw new Exception("Invalid
          Tenant!");
        if (string.IsNullOrEmpty(_tenant.ConnectionString))
          SetDefaultConnectionStringToCurrentTenant();
    }
    private void
      SetDefaultConnectionStringToCurrentTenant() =&gt;
        _tenant.ConnectionString =
          _tenantSettings.DefaultConnectionString;
    public string GetConnectionString() =&gt;
      _tenant?.ConnectionString!;
    public Tenant GetTenant() =&gt; _tenant;
}</pre>
			<p>The<a id="_idIndexMarker161"/> primary function of the preceding code block is to intercept incoming HTTP requests, check that there is a tenant named in the header, and match that name with a known tenant.</p>
			<h3>Modifying the SeedData and AppDbContext classes</h3>
			<p>You will <a id="_idIndexMarker162"/>remember that in <a href="B19343_02.xhtml#_idTextAnchor056"><em class="italic">Chapter 2</em></a>, we added some seed data. As we now require a tenant name to be present in the database, we will have to update the seed data. Copy in the following, or just add the <code>TenantName</code>:</p>
			<pre class="source-code">
using GoodHabits.Database.Entities;
using Microsoft.EntityFrameworkCore;
public static class SeedData
{
    public static void Seed(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;Habit&gt;().HasData(
            new Habit { Id = 100, Name = "Learn French",
            Description = "Become a francophone",
            TenantName = "CloudSphere" },
            new Habit { Id = 101, Name = "Run a marathon",
              Description = "Get really fit",
              TenantName = "CloudSphere"  },
            new Habit { Id = 102, Name = "Write every day",
              Description = "Finish your book project",
              TenantName = "CloudSphere"  }
        );
    }
}</pre>
			<p>The <code>GoodHabitsDbContext</code> class<a id="_idIndexMarker163"/> that was created previously had a single hardcoded database connection string. We will replace this and make use of the multiple database connections that we defined in the preceding config.</p>
			<p>Replace the <code>GoodHabitsDbContext</code> class entirely with the following:</p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
using GoodHabits.Database.Entities;
namespace GoodHabits.Database;
public class GoodHabitsDbContext : DbContext
{
  private readonly ITenantService _tenantService;
  public GoodHabitsDbContext(DbContextOptions options,
    ITenantService service) : base(options) =&gt;
    _tenantService = service;
  public string TenantName { get =&gt; _tenantService
    .GetTenant()?.TenantName ?? String.Empty; }
  public DbSet&lt;Habit&gt;? Habits { get; set; }
    protected override void
      OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        var tenantConnectionString =
          _tenantService.GetConnectionString();
        if (!string.IsNullOrEmpty(tenantConnectionString))
        {
            optionsBuilder.UseSqlServer(_tenantService
              .GetConnectionString());
        }
    }
    protected override void OnModelCreating(ModelBuilder
      modelBuilder)
  {
    base.OnModelCreating(modelBuilder);
    modelBuilder.Entity&lt;Habit&gt;().HasQueryFilter(a =&gt;
      a.TenantName == TenantName);
    SeedData.Seed(modelBuilder);
    }
  public override async Task&lt;int&gt;
    SaveChangesAsync(CancellationToken cancellationToken =
    new CancellationToken())
  {
    ChangeTracker.Entries&lt;IHasTenant&gt;()
        .Where(entry =&gt; entry.State == EntityState.Added ||
          entry.State == EntityState.Modified)
        .ToList()
        .ForEach(entry =&gt; entry.Entity.TenantName =
          TenantName);
    return await base.SaveChangesAsync(cancellationToken);
  }
}</pre>
			<p>The main change in the preceding code is that the connection string is now read from the <code>TenantService</code> class that we created previously. This is far more dynamic and allows us to create new databases for new tenants on the fly as we build the app. This is also far more secure than having a connection string hardcoded in the source code and checked into the repository.</p>
			<p>Another important change to note is that we add a query filter at the context level. This ensures that only the correct tenant can read their data, which is a very important security consideration.</p>
			<p>Finally, we have <a id="_idIndexMarker164"/>overridden the <code>SaveChangesAsync</code> method. This allows us to set the tenant name here and not have to consider it in any of our other implementation code. This cleans up the rest of our code considerably.</p>
			<h3>Writing a service layer</h3>
			<p>We have <a id="_idIndexMarker165"/>now configured the <code>Habit</code> service and the database to work in a multi-tenant way, enforcing the presence of a tenant ID in every request. This is a good start to provide good security and separation between tenants.</p>
			<p>Next, we’ll demonstrate what we did by hooking up the database and the service and placing some test calls to the Habit service, showing how the tenancy is enforced.</p>
			<p>We will start by writing a service layer. Open a terminal in the <code>HabitService</code> folder and run the following script:</p>
			<pre class="source-code">
<strong class="bold">touch IHabitService.cs; \</strong>
<strong class="bold">touch HabitService.cs;</strong></pre>
			<p>Populate the<a id="_idIndexMarker166"/> interface with the following:</p>
			<pre class="source-code">
using GoodHabits.Database.Entities;
namespace GoodHabits.HabitService;
public interface IHabitService
{
        Task&lt;Habit&gt; Create(string name, string
          description);
        Task&lt;Habit&gt; GetById(int id);
        Task&lt;IReadOnlyList&lt;Habit&gt;&gt; GetAll();
}</pre>
			<p>Then, populate the class with the following:</p>
			<pre class="source-code">
using GoodHabits.Database;
using GoodHabits.Database.Entities;
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.HabitService;
public class HabitService : IHabitService
{
    private readonly GoodHabitsDbContext _dbContext;
    public HabitService(GoodHabitsDbContext dbContext) =&gt;
      _dbContext = dbContext;
    public async Task&lt;Habit&gt; Create(string name,
      string description)
    {
        var habit = _dbContext.Habits!.Add(new Habit { Name
          = name, Description = description }).Entity;
        await _dbContext.SaveChangesAsync();
        return habit;
    }
    public async Task&lt;IReadOnlyList&lt;Habit&gt;&gt; GetAll() =&gt;
      await _dbContext.Habits!.ToListAsync();
    public async Task&lt;Habit&gt; GetById(int id) =&gt;   await
      _dbContext.Habits.FindAsync(id);
}</pre>
			<p>This <a id="_idIndexMarker167"/>service is just a simple wrapper around some of the calls to the database. We could add a lot more functionality, but this will serve to demonstrate how multi-tenancy works in practice.</p>
			<h3>Writing the controller</h3>
			<p>With the<a id="_idIndexMarker168"/> service created, we’ll now add a controller that makes the data from the service available over HTTP.</p>
			<p>Run the following script in the <code>HabitService</code> folder to set up the required files:</p>
			<pre class="source-code">
<strong class="bold">rm WeatherForecast.cs; \</strong>
<strong class="bold">cd Controllers; \</strong>
<strong class="bold">rm WeatherForecastController.cs; \</strong>
<strong class="bold">touch HabitsController.cs; \</strong>
<strong class="bold">cd ..; \</strong>
<strong class="bold">mkdir Dtos; \</strong>
<strong class="bold">cd Dtos; \</strong>
<strong class="bold">touch CreateHabitDto.cs</strong></pre>
			<p>Then, add <a id="_idIndexMarker169"/>the code for the controller, as shown here:</p>
			<pre class="source-code">
using GoodHabits.HabitService.Dtos;
using Microsoft.AspNetCore.Mvc;
namespace GoodHabits.HabitService.Controllers;
[ApiController]
[Route("api/[controller]")]
public class HabitsController : ControllerBase
{
    private readonly ILogger&lt;HabitsController&gt; _logger;
    private readonly IHabitService _habitService;
    public HabitsController(
        ILogger&lt;HabitsController&gt; logger,
        IHabitService goodHabitsService
        )
    {
        _logger = logger;
        _habitService = goodHabitsService;
    }
    [HttpGet("{id}")]
    public async Task&lt;IActionResult&gt; GetAsync(int id) =&gt;
      Ok(await _habitService.GetById(id));
    [HttpGet]
    public async Task&lt;IActionResult&gt; GetAsync() =&gt; Ok(await
      _habitService.GetAll());
    [HttpPost]
    public async Task&lt;IActionResult&gt;
      CreateAsync(CreateHabitDto request) =&gt; Ok(await
      _habitService.Create(request.Name,
      request.Description));
}</pre>
			<p>This controller<a id="_idIndexMarker170"/> simply gives us two endpoints to create and read a habit from the database, via the service layer that we created previously.</p>
			<p>Finally, add the following code to the <code>CreateHabitDto</code> file:</p>
			<pre class="source-code">
namespace GoodHabits.HabitService.Dtos;
public class CreateHabitDto {
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
}</pre>
			<h3>Adding a service extension</h3>
			<p>Now that <a id="_idIndexMarker171"/>we are potentially dealing with many instances of the database, we need to add the ability to create and update all of the databases when the application starts up. We will create an extension to the service collection to facilitate this.</p>
			<p>Add a <a id="_idIndexMarker172"/>class to the HabitService project called <code>ServiceCollectionExtensions</code>, and then add the following code:</p>
			<pre class="source-code">
using GoodHabits.Database;
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.HabitService;
public static class ServiceCollectionExtensions
{
    public static IServiceCollection
      AddAndMigrateDatabases(this IServiceCollection
      services, IConfiguration config)
    {
        var options = services.GetOptions
          &lt;TenantSettings&gt;(nameof(TenantSettings));
        var defaultConnectionString =
          options.DefaultConnectionString;
        services.AddDbContext&lt;GoodHabitsDbContext&gt;(m =&gt;
          m.UseSqlServer(e =&gt; e.MigrationsAssembly(
          typeof(GoodHabitsDbContext).Assembly.FullName)));
        var tenants = options.Tenants;
        foreach (var tenant in tenants)
        {
            string connectionString;
            if (string.IsNullOrEmpty(
              tenant.ConnectionString))
            {
                connectionString = defaultConnectionString;
            }
            else
            {
                connectionString = tenant.ConnectionString;
            }
            using var scope = services
              .BuildServiceProvider().CreateScope();
            var dbContext =
              scope.ServiceProvider.GetRequiredService&lt;Good
              HabitsDbContext&gt;();
            dbContext.Database.SetConnectionString(
              connectionString);
            if (dbContext.Database.GetMigrations()
              .Count() &gt; 0)
            {
                dbContext.Database.Migrate();
            }
        }
        return services;
    }
    public static T GetOptions&lt;T&gt;(this IServiceCollection
      services, string sectionName) where T : new()
    {
        using var serviceProvider =
          services.BuildServiceProvider();
        var configuration =
          serviceProvider.GetRequiredService&lt;
          IConfiguration&gt;();
        var section = configuration.GetSection(
          sectionName);
        var options = new T();
        section.Bind(options);
        return options;
    }
}</pre>
			<p>The key point to understand from the preceding code is that the database connection string is set on a per-tenant basis, and that the tenants’ database is updated per the latest migrations when that tenant logs in to the app.</p>
			<p>This <a id="_idIndexMarker173"/>system takes much of the overhead of maintaining many databases away from the administrators. It is all handled automatically!</p>
			<h3>Application plumbing</h3>
			<p>Finally, we <a id="_idIndexMarker174"/>need to wire up all these new services. This is done in the <code>Program.cs</code> file in the <code>GoodHabits.HabitService</code> project. In this file, paste the following:</p>
			<pre class="source-code">
using GoodHabits.HabitService;
using GoodHabits.Database;
using GoodHabits.HabitService;
using Microsoft.OpenApi.Models;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddHttpContextAccessor();
builder.Services.AddControllers().AddNewtonsoftJson();
builder.Services.AddSwaggerGen(c =&gt; c.SwaggerDoc("v1", new OpenApiInfo { Title = "GoodHabits.HabitService", Version = "v1" }));
builder.Services.AddTransient&lt;ITenantService, TenantService&gt;();
builder.Services.AddTransient&lt;IHabitService, HabitService&gt;();
builder.Services.Configure&lt;TenantSettings&gt;(builder.Configuration.GetSection(nameof(TenantSettings)));
builder.Services.AddAndMigrateDatabases(builder.Configuration);
builder.Services.AddEndpointsApiExplorer();
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
    app.UseSwagger();
    app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(
      "/swagger/v1/swagger.json", "GoodHabits.HabitService
      v1"));
}
app.UseHttpsRedirection();
app.UseRouting();
app.UseAuthorization();
app.MapControllers();
app.Run();</pre>
			<p>In this code, you <a id="_idIndexMarker175"/>can see that we add the two new services that we created. We also make use of the service extension created previously and configure the Swagger endpoints.</p>
			<h3>Testing</h3>
			<p>With the previous<a id="_idIndexMarker176"/> configurations in place, we can now run the application and see how the changes we made have affected the operation of the controllers.</p>
			<p>Because we have made some changes to the database (by adding the <code>TenantName</code> column to the <code>Habit</code> table), we will need to create a new migration with Entity Framework. Create the migration by navigating to the database project and running the following:</p>
			<pre class="source-code">
<strong class="bold">dotnet-ef migrations add MultiTenant --startup-project ../GoodHabits.HabitService/GoodHabits.HabitService.csproj</strong></pre>
			<p>Start the application with <code>dotnet run</code> and check that the API runs correctly.</p>
			<p>You can look at the API in Swagger, but if you try to hit one of the endpoints, you will see an invalid tenant exception. This is expected, as we now have to add a header to every request to identify which tenant the request is for.</p>
			<div><div><img src="img/B19343_03_01.jpg" alt="Figure 3.1 – The Swagger error"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The Swagger error</p>
			<p>If all has gone well, the API will start, and you can view it in Swagger to see the preceding available endpoints!</p>
			<p>In order to test <code>HabitService</code>, we will use the <code>ThunderClient</code> extension that we installed in <a href="B19343_02.xhtml#_idTextAnchor056"><em class="italic">Chapter 2</em></a>.</p>
			<p>Open<a id="_idIndexMarker177"/> the <code>ThunderClient</code> extension, click on <code>CloudSphere</code>.</p>
			<div><div><img src="img/B19343_03_02.jpg" alt="Figure 3.2 – The ThunderClient request"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The ThunderClient request</p>
			<p>The preceding is a properly configured request with the tenant added. Hitting <strong class="bold">Send</strong> will issue the response, and if everything has worked, you should see the following response:</p>
			<div><div><img src="img/B19343_03_03.jpg" alt="Figure 3.3 – The ThunderClient response"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – The ThunderClient response</p>
			<p>The preceding <a id="_idIndexMarker178"/>shows that we have successfully returned the data for the <code>CloudSphere</code> tenant.</p>
			<p>You should take some time now to do some more investigations with this and convince yourself that we have correctly limited access to data on a per-tenant basis!</p>
			<p>That is the end of the practical part of this chapter. We’ll now move on to consider the security implications of what we have done.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/>Security considerations</h1>
			<p>I think that it should <a id="_idIndexMarker179"/>go without saying that multi-tenancy significantly affects the security landscape of a SaaS application.</p>
			<p>There are many aspects to security, ranging from simple (or at least standard) considerations, such as authenticating users to the ability of the application, to withstanding very rare events, such as a natural disaster taking out a crucial data center or a vital internet backbone.</p>
			<p>The word “security” in this context refers to the overall ability of an application to withstand anything that the world may throw at it – and continue to keep the tenants’ and users’ data correct, accessible, and private! This can include hacks, attacks, natural disasters, coding errors leaking data, or even <a id="_idIndexMarker180"/>regulatory issues, such as the <strong class="bold">General Data Protection </strong><strong class="bold">Regulation</strong> (<strong class="bold">GDPR</strong>).</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>Potential security pitfalls</h2>
			<p>Developers<a id="_idIndexMarker181"/> of every type of application will face <a id="_idIndexMarker182"/>a broad range of potential security issues. It is an unfortunate reality of SaaS applications and, particularly, multi-tenant applications that the developers of such will have to consider nearly all possible security threats!</p>
			<p>SaaS applications are typically layered, with at least a database, an API, and a user interface. Each of these layers presents an attack vector. SaaS applications are also often hosted on a cloud service. Hosting in the cloud is generally more secure than hosting on-premises, but there are a number of additional attack vectors that must be considered. Most importantly, the user accounts of the administrators can be compromised and the admin pages accessed remotely. This is generally less of a concern with on-prem solutions, which may have no remote access at all.</p>
			<p>This section will list some of the security considerations that you will have to take into account as a developer of SaaS applications.</p>
			<h3>Resource access management</h3>
			<p>First, and most <a id="_idIndexMarker183"/>obviously, access to the resources in a system must be limited to only those with permission to see those resources.</p>
			<p>For example, and rather obviously, data pertaining to one tenant should never be visible to a user on another tenant, unless there is a case where data is deliberately shared. When developing a SaaS application, it’s important to understand that an attacker will target the user interface, the API, and also the database in an effort to gain access to the data.</p>
			<p>An attacker will also attempt to intercept data when it is “in flight.” When data moves from the database to the API, or from the API to the user interface, it is vulnerable.</p>
			<p>As well as individual user data, it is likely that there will be sections of an application that are only accessible by users in a certain <em class="italic">role</em>, such as administrators.</p>
			<p>Any SaaS system that fails to control resource access will very quickly be compromised, and an application with a reputation for losing customers’ data will quickly cease to attract customers. Failures in this area can be catastrophic to an application and, indeed, a company’s reputation.</p>
			<p>This is a <a id="_idIndexMarker184"/>very important consideration in a SaaS application, particularly a multi-tenant application where tenants will share access to certain resources (such as the database), and access to these resources must be managed very carefully.</p>
			<h3>Data leaks</h3>
			<p>Similar to <a id="_idIndexMarker185"/>the aforementioned, data leaks can prove very costly in terms of reputation, and they can also have hugely significant financial implications for the business that owns the application!</p>
			<p>While a data leak is, in some ways, a failure of resource access, it is normally a more general problem. Some examples to consider are as follows:</p>
			<ul>
				<li>A user interface that transmits credit card details from the client to the server in plain text, allowing a <strong class="bold">man-in-the-middle</strong> (<strong class="bold">MitM</strong>) attack<a id="_idIndexMarker186"/> that gathers the credit card information from all users. As stated previously, data “in flight” tends to be vulnerable.</li>
				<li>An API endpoint that misses the authentication attribute, thus rendering it accessible by anyone, whether they are authenticated or not. Similarly, an API endpoint may have an incorrect authentication attribute. This is extremely important, and measures should be put in place to automatically test that the API is appropriately secured.</li>
				<li>A database with poor security that allows an attacker to access, download, or delete the data in the database.</li>
				<li>A server or a VM that has been improperly configured and can be accessed remotely by a malicious user.</li>
				<li>Poor password hygiene that allows attackers to <em class="italic">guess</em> the passwords of users, either by brute force, rainbow tables, or similar <em class="italic">blunt-force</em> attacks.</li>
			</ul>
			<p>Very often these days, data breaches can come with a very large financial penalty for a company that has operated an insecure application. In 2018, the <strong class="bold">British Airways</strong> (<strong class="bold">BA</strong>) website leaked the credit card data of 380,000 customers – one of whom would go on to write this book! The financial cost to BA was £183 million ($244 million at the time of writing the book). It would have been considerably cheaper for BA to hire a team of developers and security specialists to secure its website in the first place!</p>
			<p>There is an<a id="_idIndexMarker187"/> additional consideration when building a SaaS application, in particular an application with a multi-tenant database. A large risk vector for these types of applications in terms of data leaks is that one tenant’s data will accidentally be revealed to a user belonging to a different tenant when those two tenants share a storage resource, an app server, a database, or similar. As discussed in this chapter, a rigorous approach to designing a multi-tenant solution when the app is in the concept stage is needed!</p>
			<h3>Data corruptions</h3>
			<p>The <a id="_idIndexMarker188"/>various users and tenants in a multi-tenant application are separated from each other in one of the ways described previously, but the reality is that they are often sharing some (or many) of the same resources. They may be sharing a database, an app server, a user authentication system, and so on. Should one of these systems be corrupted by one user, there may be some contagion, and the corruption may spread and subsequently impact another user. This is rare in the modern era where cloud resources are typically used, and the big cloud providers should have a handle on these types of issues.</p>
			<p>The primary mitigation for this is to be very careful when segregating individual tenant’s concerns and to use a reputable cloud provider.</p>
			<p>It goes without saying that you should back up your data regularly and also check that an application can be recovered from said backups!</p>
			<h3>Hacks and attacks</h3>
			<p>While <a id="_idIndexMarker189"/>some of the aforementioned data leaks could be classed as hacks or attacks, a data leak is typically more <em class="italic">passive</em> – like a pipe that is leaking water. A hack is more active – like a pipe that someone has hit with an axe!</p>
			<p>There is a huge range of attacks that the operators of SaaS applications may face, but deep-diving security concerns are out of the scope of this chapter and, indeed, this book.</p>
			<p>However, it is worth considering the possibility of a co-tenant attack, as they are specific to a multi-tenant application. While an external attacker will typically have some access to the application, assuming that, as a minimum, the login page is available over the public internet, a fully paid-up user will by definition have more access to more parts of the system; therefore, they will be in a better position to mount an attack. This attack could be <a id="_idIndexMarker190"/>against the infrastructure or other users.</p>
			<h3>Configuration</h3>
			<p>SaaS <a id="_idIndexMarker191"/>applications add a degree of complexity, and with this complexity will come a certain amount of configuration overhead.</p>
			<p>A configuration error could, for example, accidentally leak a production password or access to a database or other resource.</p>
			<p>It is very easy to overlook configuration parameters, but this can be a costly mistake. Everything should be stored in as secure a way as possible, making use of key vaults and secret managers as much as possible.</p>
			<p>Care should also be taken when it comes to checking configuration files in the source code repository, as this is unfortunately a common way to leak passwords and the like.</p>
			<h3>Storage</h3>
			<p>Every <a id="_idIndexMarker192"/>SaaS application will have some form of data stored, and that data presents an attack vector that can be utilized to compromise the application.</p>
			<h3>Data retention and deletion</h3>
			<p>Similar to the <a id="_idIndexMarker193"/>aforementioned, a SaaS application will retain sensitive data. It is vitally important that this is secured. Another key consideration with data retention is that in many jurisdictions, individuals have the “right to be forgotten,” where all of the data relating to that individual must be anonymized.</p>
			<p>This can be very challenging in the context of a SaaS application for the following reasons:</p>
			<ul>
				<li>The database will typically be multi-tenant. How easy is it to completely wipe out all of the information relating to one tenant without orphaning other records?</li>
				<li>Logging will most likely be performed across all layers – user interface, API, and database. How sure can you be that there is no sensitive customer data in those logs?</li>
				<li>Backups are obviously a very important part of the security of a system, but should you have to do a restoration at any point, how can you be sure that previously deleted data has not now been restored?</li>
			</ul>
			<p>All of the<a id="_idIndexMarker194"/> aforementioned require a meticulous approach to data retention and deletion in order to guarantee your customers that their data is secure.</p>
			<h3>Regulations</h3>
			<p>A<a id="_idIndexMarker195"/> huge part of data security when building a modern SaaS application is to understand the regulatory frameworks that you must comply with. The internet offers a truly global reach for your application, but that global reach means that you may have to consider a huge array of regulatory frameworks, of which the consequences for breaching are often astronomically high fines and penalties.</p>
			<p>The European Union’s GDPR law stipulates rules for how organizations must use personal data, and the penalties for breaching these regulations can be incredibly harsh – 10 million euros, or 2% of a firm’s entire annual global turnover. These kinds of laws are becoming increasingly common in many jurisdictions.</p>
			<p>Key questions to ask yourself in this regard are as follows:</p>
			<ul>
				<li>What jurisdictions govern the data that will be stored in this application?</li>
				<li>Do your applications adhere to these requirements?</li>
				<li>Do the<a id="_idIndexMarker196"/> partners and third parties that you are working with adhere to these regulations?</li>
			</ul>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Good security practices for multi-tenant applications</h2>
			<p>I hope<a id="_idIndexMarker197"/> that the preceding set of potential horror stories hasn’t put you off! In this section, I’ll list some of the mitigations that <a id="_idIndexMarker198"/>should be considered.</p>
			<h3>Governance, risk, and compliance (GRC) protocols</h3>
			<p>GRC is<a id="_idIndexMarker199"/> a set of <a id="_idIndexMarker200"/>processes and procedures that a business will put in place for many reasons, such as for meeting objectives, maintaining regulatory compliance, or adequately securing a SaaS application! These could be as follows:</p>
			<ul>
				<li>Procedures that detail how an application upgrade should be performed and a list of pre-release checks.</li>
				<li>Procedures that manage and control access to your customers’ private data or IPs.</li>
				<li>Restrictions on which members of staff have access to production databases. Note that, ideally, no one should!</li>
			</ul>
			<h3>Isolation of assets and resources</h3>
			<p>As much as is <a id="_idIndexMarker201"/>practically possible, resources should be isolated from each other. Obviously, the app layer will need some access to the database; otherwise, how will it access data? However, it is good practice to run the database and the application on different servers or VMs. Note that isolation can bring in performance issues if not done correctly – this is a delicate balance!</p>
			<p>With multi-tenant applications, individual users’ and tenants’ data should also be isolated as much as possible from other users and tenants. Ideally, all user data should be encrypted such that only the owner of the data can make sense of it. In this way, even if a data leak does occur, it’s not possible to infer anything of value from the data leak.</p>
			<h3>Auditing</h3>
			<p>This is<a id="_idIndexMarker202"/> good practice for all applications, not just SaaS/multi-tenant. Independent third parties should be consulted to audit the security and compliance of all IT systems and also your tenants’ data.</p>
			<p>As well as checking that data is physically secure, auditors should also confirm that industry standards are being followed and that any regulatory frameworks are adhered to.</p>
			<h3>Using Data Loss Prevention (DLP) software</h3>
			<p>There<a id="_idIndexMarker203"/> are many commercial DLP solutions available. It is worth considering delegating this complex and extremely important to a specialist provider.</p>
			<h3>Managing access carefully</h3>
			<p>A SaaS/multi-tenant application is particularly susceptible to security issues arising from improperly <a id="_idIndexMarker204"/>allocated access to a resource. This is true from a company point of view – developers should not have access to production databases. This is also true from a user point of view.</p>
			<p>User access should be managed based on identities (who are the individual users?) and also through roles (what types of user classes do the individuals fall into?).</p>
			<h3>Being very careful with collaborative tools</h3>
			<p>Often, a <a id="_idIndexMarker205"/>SaaS application will allow users to choose to share certain resources with other selected users within the same tenant, and less commonly with users in a different tenant. This can be an incredibly effective addition to a SaaS app and is indeed a massive advantage to using a multi-tenant solution. However, this introduces a security risk whereby the application itself can programmatically leak data. Significant additional care should be taken when building collaborative elements in a SaaS app, as these will be the first place a bad actor will look to exploit access to another user’s data.</p>
			<p>Good security is hard in any application, and doubly so when dealing with multi-tenant applications. As ever, it is much easier to start a project with good practices in place than it is to add them later!</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>Summary</h1>
			<p>As we can see, multi-tenancy is a large and complex topic but one that is absolutely core to understanding when building a SaaS application.</p>
			<p>The decisions that are made on how a database is segregated will have the largest impact on the rest of an application, but it is very important to consider how the presence of multiple tenants will affect the API and the user interface layers as well.</p>
			<p>Multi-tenancy introduces considerable additional security considerations. These should be thought of upfront and kept in mind throughout the development process.</p>
			<p>Having said this, the additional challenges of implementing a multi-tenant solution provide <em class="italic">massive</em> potential upsides! The reach of an application can be truly global, and the scalability is unmatched by any other paradigm. Consider the biggest tech companies in the world – Google, Meta, Netflix, and so on. Every one of these companies has embraced the idea of SaaS and multi-tenancy, and they have done so for a good reason!</p>
			<p>In the next chapter, we will build on what we have learned about multi-tenancy and learn about how to build databases and plan for data-rich applications.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor101"/>Further reading</h1>
			<ul>
				<li>Single Tenant vs Multi Tenant: SaaS Architecture:<strong class="bold"> </strong><a href="https://www.clickittech.com/aws/single-tenant-multi-tenant/">https://www.clickittech.com/aws/single-tenant-multi-tenant/</a></li>
				<li>Multi-tenancy strategies: <a href="https://www.linkedin.com/pulse/effective-multi-tenancy-strategies-saas-applications-kulkarni/">https://www.linkedin.com/pulse/effective-multi-tenancy-strategies-saas-applications-kulkarni/</a></li>
				<li>Strategies to build a scalable multi-tenant SaaS solution: <a href="https://aws.amazon.com/blogs/apn/in-depth-strategies-for-building-a-scalable-multi-tenant-saas-solution-with-amazon-redshift/">https://aws.amazon.com/blogs/apn/in-depth-strategies-for-building-a-scalable-multi-tenant-saas-solution-with-amazon-redshift/</a></li>
				<li>Implementing multi-tenancy SaaS apps: <a href="https://developers.redhat.com/articles/2022/05/09/approaches-implementing-multi-tenancy-saas-applications">https://developers.redhat.com/articles/2022/05/09/approaches-implementing-multi-tenancy-saas-applications</a></li>
				<li>A definition of multi-tenancy: <a href="https://www.techtarget.com/whatis/definition/multi-tenancy">https://www.techtarget.com/whatis/definition/multi-tenancy</a></li>
				<li>How multi-tenancy affects embedded analysis: <a href="https://yurbi.com/blog/what-is-multi-tenancy-security-and-how-does-it-impact-embedded-analytics/">https://yurbi.com/blog/what-is-multi-tenancy-security-and-how-does-it-impact-embedded-analytics/</a></li>
				<li>DLP definition: <a href="https://digitalguardian.com/blog/what-data-loss-prevention-dlp-definition-data-loss-prevention">https://digitalguardian.com/blog/what-data-loss-prevention-dlp-definition-data-loss-prevention</a></li>
			</ul>
		</div>
	</body></html>