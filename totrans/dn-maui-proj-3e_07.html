<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-119"><a id="_idTextAnchor569"/>7</h1>
<h1 id="_idParaDest-120"><a id="_idTextAnchor570"/><a id="_idTextAnchor571"/><a id="_idTextAnchor572"/><a id="_idTextAnchor573"/>Building a Location Tracking App Using GPS and Maps</h1>
<p>In this chapter, we will create a location tracking app that saves the location of the user and displays it as a heat map. We will learn how to run tasks in the background on iOS, macOS, and Android devices. We will extend the .NET MAUI <code>Map</code> control to display the map with the saved locations directly in the map.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Tracking the location of a user in the background on an iOS device and a macOS device</li>
<li>Tracking the location of a user in the background on an Android device</li>
<li>How to show maps in a .NET MAUI app</li>
<li>How to extend the functionality of .NET MAUI maps</li>
</ul>
<p>Let’s get started!</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor574"/>Technical requirements</h1>
<p>To be able to complete this project, you’ll need to have Visual Studio for Mac or Windows installed, as well as the .NET MAUI components. See <em class="italic">Chapter 1</em>, <em class="italic">Introduction to .NET MAUI</em>, for more details on how to set up your environment. To build an iOS app using Visual Studio for Windows, you must have a Mac connected. If you don’t have access to a Mac at all, you can just complete the Android part of this project.</p>
<p>You can find the full source for the code in this chapter at <a href="https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition">https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition</a>.</p>
<p class="callout-heading">Important information for Windows users</p>
<p class="callout">At the time of writing, there was no <code>Map</code> control for the Windows platform in .NET MAUI. This is due to the lack of a <code>Map</code> control in the underlying WinUI platform. For the latest information on <code>Map</code> support in Windows, visit the <code>Map</code> documentation at <a href="https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map">https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map</a>.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor575"/><a id="_idTextAnchor576"/>Project overview</h1>
<p>Many apps can be made richer by adding a map and location services. In this project, we will build a location tracking app that we will call <code>MeTracker</code>. This app will track the position of the <a id="_idIndexMarker683"/>user and save it to an SQLite database so that we can visualize the result in the form of a heat map. To build this app, we will learn how to set up processes in the background on iOS, macOS, and Android. Luckily for us, the iOS and macOS implementations are identical; however, the Android implementation is very different. For the map, we will use the .NET MAUI <code>Maps</code> component and extend its functionality to build a heat map.</p>
<p>Due to the lack of <code>Map</code> support on Windows, and just for some variety, this chapter will use Visual Studio for Mac screenshots and references. If you don’t have a Mac, don’t worry; you can still complete the project for Android on your Windows development machine. If you need help with the steps, look at some of the earlier chapters for equivalent steps.<a id="_idTextAnchor577"/></p>
<p>The estimated build time for this project is 180 minutes.<a id="_idTextAnchor578"/></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor579"/>Building the MeTracker app</h1>
<p>It’s time to <a id="_idIndexMarker684"/>start building the app. Use the following steps to create a project from a template:</p>
<ol>
<li>Open Visual Studio for Mac and click <strong class="bold">New</strong>:</li>
</ol>
<div><div><img alt="Figure 7.1 – Visual Studio for Mac start screen" src="img/B19214_07_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Visual Studio for Mac start screen</p>
<ol>
<li value="2">In the <strong class="bold">Choose a template for your new project</strong> dialog, use the <strong class="bold">.NET MAUI App</strong> template, which <a id="_idIndexMarker685"/>is under <strong class="bold">Multiplatform</strong> | <strong class="bold">App</strong>; then, click <strong class="bold">Continue</strong>:</li>
</ol>
<div><div><img alt="Figure 7.2 – New project﻿" src="img/B19214_07_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – New project<a id="_idTextAnchor580"/></p>
<ol>
<li value="3">In the <strong class="bold">Configure your new .NET MAUI App</strong> dialog, ensure the <strong class="bold">.NET 7.0</strong> target <a id="_idIndexMarker686"/>framework is selected, then click <strong class="bold">Continue</strong>:</li>
</ol>
<div><div><img alt="Figure 7.3 – Choosing a target framework" src="img/B19214_07_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Choosing a target framework</p>
<ol>
<li value="4">In the <code>MeTracker</code>, and then <a id="_idIndexMarker687"/>click <strong class="bold">Create</strong>:</li>
</ol>
<div><div><img alt="Figure 7.4 – Naming the new app﻿" src="img/B19214_07_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Naming the new app<a id="_idTextAnchor581"/></p>
<p>If you <a id="_idIndexMarker688"/>run the app now, you should see something like the following:</p>
<div><div><img alt="Figure 7.5 – MeTracker app on macOS" src="img/B19214_07_5.jpg"/>
</div>
</div>
<p class="IMG---Figure"><a id="_idTextAnchor582"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – MeTracker app on macOS</p>
<p>Now that <a id="_idIndexMarker689"/>we have created a project from a template, it’s time to start coding!</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor583"/>Creating a repository to save the locations of the users</h2>
<p>The first <a id="_idIndexMarker690"/>thing we will do is <a id="_idIndexMarker691"/>create a repository that we can use to save the locations of <a id="_idTextAnchor584"/>the use<a id="_idTextAnchor585"/>rs.</p>
<h3>Creating a model for the location data</h3>
<p>Before <a id="_idIndexMarker692"/>we create a repository, we will create a model class that will represent a user location. Follow these steps to do so:</p>
<ol>
<li>Create a new <code>Models</code> folder that we can use for all our models.</li>
<li>Create a <code>Location</code> class in the <code>Models</code> folder and add properties for <code>Id</code>, <code>Latitude</code>, and <code>Longitude</code>.</li>
<li>Create two <a id="_idIndexMarker693"/>constructors – one that’s empty and one that takes <code>latitude</code> and <code>longitude</code> as arguments. Use the following code to do so:<pre class="source-code">
Using'System;
namespace MeTracker.Models;
public class Location
{
    public Location() {}
    public Location(double latitude, double longitude)
    {
        Latitude = latitude;
        Longitude = longitude;
    }
    public int Id { get; set; }
    public double Latitude { get; set; }
    public double Longitude { get; set<a id="_idTextAnchor586"/><a id="_idTextAnchor587"/><a id="_idTextAnchor588"/>; }
}</pre></li> </ol>
<p>Now that we have created a model, we can start creating a repository.</p>
<h3>Creating a repository</h3>
<p>First, we will <a id="_idIndexMarker694"/>create an interface for the repository. Follow these steps to do so:</p>
<ol>
<li>Create a new folder called <code>Repositories</code>.</li>
<li>In our new folder, create an interface called <code>ILocationRepository</code>.</li>
<li>Write the following code in the new file that we created for the interface:<pre class="source-code">
using MeTracker.Models;
using System;
using System.Threading.Tasks;
namespace MeTracker.Repositories;
public interface ILocationRepository
{
    Task SaveAsync(Models.Location location);
}</pre></li> </ol>
<p>Now that we <a id="_idIndexMarker695"/>have an interface, we need to create an implementation of it. Follow these steps to do so:</p>
<ol>
<li>Create a new <code>LocationRepository</code> class in the <code>Repositories</code> folder.</li>
<li>Implement the <code>ILocationRepository</code> interface and add the <code>async</code> keyword to the <code>SaveAsync</code> method using the following code:<pre class="source-code">
using System;
using System.Threading.Tasks;
using MeTracker.Models;
namespace MeTracker.Repositories;
public class LocationRepository : ILocationRepository
{
    public async Task SaveAsync(Models.Location location)
    {
<a id="_idTextAnchor589"/>    }
}</pre></li> </ol>
<p class="callout-heading">A word on the Async suffix</p>
<p class="callout">You will see <a id="_idIndexMarker696"/>in this and many other chapters in this book the use of <code>Async</code> as a suffix on methods. Appending a suffix of <code>Async</code> to all asynchronous methods is a .NET convention. How do we know whether a method is asynchronous in an interface where you can’t see the <code>async</code> keyword? It will most likely return a <code>Task</code> or <code>ValueTask</code> object. There are some cases where an asynchronous method will return <code>void</code>; however, that is frowned upon, as Stephen Cleary explains in his article at <a href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx">https://msdn.microsoft.com/en-us/magazine/jj991977.aspx</a>, so you won’t see it used in this book.</p>
<p>To store <a id="_idIndexMarker697"/>the data, we will use an SQLite database and the <strong class="bold">object-relational mapper </strong>(<strong class="bold">ORM</strong>) known as SQLite-net so that we can write <a id="_idIndexMarker698"/>code against a domain model instead of using SQL to perform operations against the database. This is an open source library that was created by Frank A. Krueger. Let’s set this up by going through the following steps:</p>
<ol>
<li>Add a reference to <code>sqli<a id="_idTextAnchor590"/>te-net-pcl</code> by right-clicking the <code>Dependencies</code> node in <strong class="bold">Solution Explorer</strong>:</li>
</ol>
<div><div><img alt="Figure 7.6 – Adding the NuGet package" src="img/B19214_07_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Adding the NuGet package</p>
<ol>
<li class="upper-roman">Select <strong class="bold">Manage NuGet Packages…</strong> from the context menu to open the <strong class="bold">NuGet </strong><strong class="bold">Packages</strong> window.</li>
<li class="upper-roman">Check the <code>sqlite-net-pcl</code> into the search box as shown next:</li>
</ol>
<div><div><img alt="Figure 7.7 – Adding the sqlite-net-pcl package" src="img/B19214_07_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Adding the sqlite-net-pcl package</p>
<ol>
<li class="upper-roman" value="3">Finally, check the <a id="_idIndexMarker699"/>box next to <code>sqlite-net-pcl</code> and click <strong class="bold">Add Package</strong>.</li>
</ol>
<ol>
<li value="2">Go to the <code>Location</code> model class and add <code>PrimaryKeyAttribute</code> and <code>Auto</code><strong class="source-inline">
IncrementAttribute</strong> attributes to the <code>Id</code> property. When we add these attributes, the <code>Id</code> property will be a primary key in the database, and a value for it will be automatically created. The <code>Location</code> class should now look like the following:<pre class="source-code">
<strong class="bold">using SQLite;</strong>
namespace MeTracker.Models;
public class Location
{
    public Location() { }
    public Location(double latitude, double longitude)
    {
        Latitude = latitude;
        Longitude = longitude;
    }
<strong class="bold">    [PrimaryKey]</strong>
<strong class="bold">    [AutoIncrement]</strong>
    public int Id { get; set; }
    public double Latitude { get; set; }
    public double Longitude { get; set; }
}</pre></li> <li>Write the following code in the <code>LocationRepository</code> class to create a connection <a id="_idIndexMarker700"/>to the SQLite database. An <code>if</code> statement is used to check whether we have already created a connection. If we have, we won’t create a new one; instead, we will use the connection that we’ve already created:<pre class="source-code">
private SQLiteAsyncConnection connection;
private async Task CreateConnectionAsync()
{
    if (connection != null)
    {
        return;
    }
    var databasePath = Path.Combine(Environment.GetFolderPath (Environment.SpecialFolder .MyDocuments), "Locations.db");
    connection = new SQLiteAsyncConnection(databasePath);
    await connection.CreateTableAsync&lt;Location&gt;();
}</pre></li> </ol>
<p>Now, it’s time to implement the <code>SaveAsync</code> method, which will take a <code>location</code> object as a parameter and store it in the database.</p>
<p>We will use the <code>CreateConnectionAsync</code> method in the <code>SaveAsync</code> method to ensure that <a id="_idIndexMarker701"/>a connection is created when we try to save data to the database. When we know that we have an active connection, we can just use the <code>InsertAsync</code> method and pass the <code>location</code> parameter of the <code>SaveAsync</code> method as a<a id="_idTextAnchor591"/>n argument.</p>
<p>Edit the <code>SaveAsync</code> method in the <code>LocationRepository</code> class so that it looks like this:</p>
<pre class="source-code">
public async Task SaveAsync(Models.Location location)
{
    await CreateConnectionAsync();
    await connection.InsertAsync(l<a id="_idTextAnchor592"/><a id="_idTextAnchor593"/><a id="_idTextAnchor594"/>ocation);
}</pre> <p>That wraps up the repository for now, so let’s move on to the location tracking service.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor595"/>Creating a service for location tracking</h2>
<p>To track a user’s location, we need to write code according to the platform. .NET MAUI has methods <a id="_idIndexMarker702"/>for getting the location of a user, but it cannot be used in the background. To be able to use the code that we will <a id="_idIndexMarker703"/>write for each platform, we need to create an interface. For the <code>ILocationRepository</code> interface, there is just one implementation that will be used on both platforms (iOS and Android), whereas for the location tracking service, we will have one implementation for each platform.</p>
<p>Go through the following steps to create an <code>ILocationTrackingService</code> interface:</p>
<ol>
<li>Create a new folder called <code>Services</code>.</li>
<li>Create a new <code>ILocationTrackingService</code> interface in the <code>Services</code> folder.</li>
<li>In the interface, add a method called <code>StartTracking</code>, as shown in the following code snippet:<pre class="source-code">
public interface ILocationTrackingService
{
    void Start<a id="_idTextAnchor596"/>Tracking();
}</pre></li> </ol>
<p>To make sure we can run and test our app while we implement the location tracking service for each platform, we will use a partial class. The main part of the class will be in the shared <a id="_idIndexMarker704"/>code section of the project and the platform-specific portions of the class will be in the platform-specific folders. We will <a id="_idIndexMarker705"/>come back to each implementation later in this chapter.</p>
<p>Create a class called <code>LocationTrackingService</code> in the <code>Services</code> folder, as shown:</p>
<pre class="source-code">
public partial class LocationTrackingService : ILocationTrackingService
{
    public void StartTracking()
    {
        StartTrackingInternal();
    }
    partial void StartTrack<a id="_idTextAnchor597"/><a id="_idTextAnchor598"/>ingInternal();
}</pre> <p>We are using an interface to abstract our implementation. We are also using a partial class to abstract each specific implementation, but providing a base implementation so that we don’t have to have an implementation for every platform immediately. However, the two methods (partial classes and base class inheritance) do not play together with the same method.</p>
<p>An implementation of the <code>StartTracking</code> interface method requires the <code>public</code> keyword, which would look like this:</p>
<pre class="source-code">
public void StartTracking() {}</pre> <p>Then, make it partial, like so:</p>
<pre class="source-code">
public partial void StartTracking() {}</pre> <p>The compiler complains that there is no initial definition of the partial method – that is, one that has no implementation.</p>
<p>Remove the empty definition, like so:</p>
<pre class="source-code">
public partial void StartTracking();</pre> <p>The compiler now complains because it has an accessibility modifier, <code>public</code>.</p>
<p>There is just <a id="_idIndexMarker706"/>no making the compiler happy in this case. Therefore, to avoid these issues, we implement the <code>StartTracking</code> interface method by calling a <code>StartTrackingInternal</code> partial method. We will <a id="_idIndexMarker707"/>visit the implementation of <code>StartTrackingInternal</code> for each platform later in this chapter; for now, the app should compile and run, even though we haven’t implemented <code>StartTrackingInternal</code>.</p>
<p>Now that we have the interface and base implementation of the location tracking service, we can turn our attention to the app logic and user interface.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor599"/>Setting up the app logic</h2>
<p>Now that we have created the interfaces, we need to track the location of the user and save it locally <a id="_idIndexMarker708"/>on the device. It’s time to write some code so that we can start tracking a user. We still don’t have any code that tracks the location of the user, but it<a id="_idTextAnchor600"/> will be easier to write this if we have already written the code that starts the<a id="_idTextAnchor601"/> tracking process.</p>
<h3>Creating a view with a map</h3>
<p>To start with, we will <a id="_idIndexMarker709"/>create a view with a simple map that is centered on the position of the user. Let’s set this up by going through the following steps:</p>
<ol>
<li>Create a new folder called <code>Views</code>.</li>
<li>In the <code>Views</code> folder, create a XAML-based <code>ContentPage</code> template and n<a id="_idTextAnchor602"/>ame it <code>MainView</code>:</li>
</ol>
<div><div><img alt="Figure 7.8 – Adding the .NET MAUI XAML Con﻿﻿tentPage component" src="img/B19214_07_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Adding the .NET MAUI XAML Con<a id="_idTextAnchor603"/><a id="_idTextAnchor604"/>tentPage component</p>
<ol>
<li value="3">Add a <a id="_idIndexMarker710"/>reference to <code>Microsoft.Maui.Controls.Maps</code> by right-clicking the <code>Dependencies</code> node in <strong class="bold">Solution Explorer</strong>:</li>
</ol>
<div><div><img alt="Figure 7.9 – Adding the NuGet package" src="img/B19214_07_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Adding the NuGet package</p>
<ol>
<li class="upper-roman">Select <strong class="bold">Manage NuGet Packages…</strong> from <a id="_idIndexMarker711"/>the context menu to open the <strong class="bold">NuGet package </strong><strong class="bold">manager</strong> window.</li>
<li class="upper-roman">Type <code>Microsoft.Maui.Controls.Maps</code> into the search box as shown next:</li>
</ol>
<div><div><img alt="Figure 7.10 – Addin﻿g the .NET MAUI Maps package" src="img/B19214_07_10..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Adding the .NET MAUI Maps package</p>
<ol>
<li class="upper-roman" value="3">Finally, check the box next to <code>Microsoft.Maui.Controls.Maps</code> and click <strong class="bold">Add Package</strong>.</li>
</ol>
<ol>
<li value="4">Add the <a id="_idIndexMarker712"/>Map initialization code by opening the <code>MauiProgram.cs</code> file and making the highlighted change:<pre class="source-code">
var builder = MauiApp.CreateBuilder();
builder
    .UseMauiApp&lt;App&gt;()
    .ConfigureFonts(fonts =&gt;
    {
        fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
        fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
    })
    <strong class="bold">.UseMauiMaps();</strong>
    return builder.Build();</pre></li> <li>Add the namespace for <code>Microsoft.Maui.Controls.Maps</code> to <code>MainView</code> using the following highlighted code:<pre class="source-code">
&lt;ContentPage 
             _idTextAnchor605"/&gt;om/winfx/2009/xaml"
    <strong class="bold">xmlns:<a id="_idTextAnchor606"/>maps="clr-namespace:Microsoft.Maui.Controls.Maps;assembly=Microsoft.Maui.Controls.Maps"</strong>
    x:Class="MeTracker.Views.MainView"
    Title="MainView"&gt;</pre><p class="list-inset">Now, we can <a id="_idIndexMarker713"/>use the map in our view. Because we want <code>Map</code> to cover the whole page, we can add it to the root of <code>ContentPage.</code></p></li> <li>Add <code>Map</code> to <code>ContentPage</code> with a name so that we can access it from the code-behind file. Name it <code>Map</code>, as shown in the following code snippet:<pre class="source-code">
&lt;ContentPage 
             
    
    x:Class="MeTracker.Views.MainView"
    Title="MainView"&gt;
    <strong class="bold">&lt;maps:Map x:Name="Map" /&gt;</strong>
&lt;/ContentPage&gt;</pre></li> </ol>
<p>Before we can start the app to see the <code>Map</code> control for the first time, we need to set the shell to use our new <code>MainView</code> template instead of the default <code>MainPage</code> template. But first, we will delete the <code>MainPage.xaml</code> and <code>MainPage.xaml.cs</code> files that we created when we started the project since we won’t be using them here:</p>
<ol>
<li>Delete the <code>MainPage.xaml</code> and <code>MainPage.xaml.cs</code> files in the project since we will be setting our <code>MainView</code> template as the first view that the user sees.</li>
<li>Edit the <code>AppShell.xaml</code> file, as shown in the following highlighted code:<pre class="source-code">
&lt;Shell
    x:Class="MeTracker.AppShell"
    
    
    
    <strong class="bold"></strong>
    Shell.FlyoutBehavior="Disabled"&gt;
    &lt;ShellContent
        Title="Home"
        ContentTemplate="{DataTemplate <strong class="bold">views:MainView</strong>}"
        Route="<strong class="bold">MainView</strong>" /&gt;
&lt;/Shell&gt;</pre></li> </ol>
<p>Could we <a id="_idIndexMarker714"/>have used the existing <code>MainPage</code> template as it was? Sure – it really doesn’t make any difference to the compiler what the XAML file is named or where it is located, but for consistency and by MVVM convention in .NET MAUI, we put our <em class="italic">pages</em> in the <code>Views</code> folder and suffix page names with <code>Views</code>.</p>
<p>Choosing either Mac Catalyst or an iOS simulator and running the app will produce the result shown in <em class="italic">Figure 7</em><em class="italic">.11</em>. Android won’t work until we have completed the next section:</p>
<div><div><img alt="Figure 7.11 – Running the app after adding the Map control" src="img/B19214_07_11..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Running the app after adding the Map control</p>
<p>Now that <a id="_idIndexMarker715"/>we have a page with the <code>Map</code> control on it, we will need to make sure we have permission from the user to use location information.</p>
<h3>Declaring platform-specific location permissions</h3>
<p>To use the <code>Map</code> control, we need to declare that we require permission to location information. The <code>Map</code> control will make the runtime request if it is required. iOS/Mac Catalyst <a id="_idIndexMarker716"/>and Android each have their own way of declaring the required permissions. We will start with iOS/Mac Catalyst, following which we will do Android.</p>
<p>Open the <code>info.plist</code> file in the <code>Platforms/iOS</code> folder into <strong class="bold">Property List Editor</strong> by double-clicking on it. Add two new entries to the file, highlighted in the next screenshot:</p>
<div><div><img alt="Figure 7.12 – Editing info.plist for iOS" src="img/B19214_07_12..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Editing info.plist for iOS</p>
<p>Make <a id="_idIndexMarker717"/>the same changes in the <code>info.plist</code> file in the <code>Platforms/MacCatalyst</code> folder, as shown next:</p>
<div><div><img alt="Figure 7.13 – Editing info.plist for Mac Catalyst" src="img/B19214_07_13..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Editing info.plist for Mac Catalyst</p>
<p class="callout-heading">Windows users</p>
<p class="callout">To edit the <code>info.plist</code> files on Windows, you need to open the file in a text editor by right-clicking the file, selecting <strong class="bold">Open With…</strong>, and then choosing <strong class="bold">XML Editor</strong>. Then, add the entries highlighted in the next code snippet.</p>
<p>Editing the <code>info.plist</code> file using the <strong class="bold">Property List Editor</strong> results in the changes highlighted next:</p>
<pre class="source-code">
    &lt;key&gt;XSAppIconAssets&lt;/key&gt;
    &lt;string&gt;Assets.xcassets/appicon.appiconset&lt;/string&gt;
    <strong class="bold">&lt;key&gt;NSLocationAlwaysAndWhenInUseUsageDescript<a id="_idTextAnchor607"/>ion&lt;/key&gt;</strong>
<strong class="bold">    &lt;string&gt;Can we use your location at all tim<a id="_idTextAnchor608"/>es?&lt;/string&gt;</strong>
<strong class="bold">    &lt;key&gt;NSLocationWhenInUseUsageDescript<a id="_idTextAnchor609"/>ion&lt;/key&gt;</strong>
<strong class="bold">    &lt;string&gt;Can we use your location when your app is being used?&lt;/string&gt;</strong>
&lt;/dict&gt;
&lt;/plist&gt;</pre> <p>To track <a id="_idIndexMarker718"/>the location of the user in the background with Android, we need to declare five permissions, as shown in the following table:</p>
<table class="No-Table-Style" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>ACCESS_COARSE_LOCATION</p>
</td>
<td class="No-Table-Style">
<p>To get an approximate location for the user</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>ACCESS_FINE_LOCATION</p>
</td>
<td class="No-Table-Style">
<p>To get a precise location for the user</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>ACCESS_NETWORK_STATE</p>
</td>
<td class="No-Table-Style">
<p>We need this because the location services in Android use information from a network to determine the location of the user</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>ACCESS_WIFI_STATE</p>
</td>
<td class="No-Table-Style">
<p>We need this because the location services in Android use information from a Wi-Fi network to determine the location of the user</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>RECEIVE_BOOT_COMPLETED</p>
</td>
<td class="No-Table-Style">
<p>So that the background job can start again after the device is rebooted</p>
</td>
</tr>
</tbody>
</table>
<p>The following steps will declare the required permissions for our app:</p>
<ol>
<li>Open the <code>MainActivity.cs</code> file in the <code>Platforms/Android</code> folder.</li>
<li>After the <code>using</code> declarations’ block method, add the following <code>assembly</code> attributes, highlighted next:<pre class="source-code">
<a id="_idTextAnchor610"/>using Android.App;
using Android.Runtime;
<strong class="bold"><a id="_idTextAnchor611"/>[assembly: UsesPermission(Android.Manifest.Permission.AccessCoarseLocation)]</strong>
<strong class="bold">[assembly: UsesPermission(Android.Manifest.Permission.AccessFineLocation)]</strong>
<strong class="bold">[assembly: UsesPermission(Android.Manifest.Permission.AccessWifiState)]</strong>
<strong class="bold">[assembly: UsesPermission(Android.Manifest.Permission.ReceiveBootCompleted)]</strong>
namespace MeTracker;</pre><p class="list-inset">Note that we don’t declare <code>Android.Manifest.Permission.AccessNetworkState</code> because it is part of the .NET MAUI template.</p></li> </ol>
<p>Now <a id="_idIndexMarker719"/>that we have declared all the permissions that we require, we can enable the map services on Android.</p>
<p>Android requires an <strong class="bold">API key</strong> for <strong class="bold">Google Maps</strong> to work with maps. The Microsoft documentation regarding how to obtain an API key can be found at <a href="https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map?view=net-maui-7.0#get-a-google-maps-api-key">https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/map?view=net-maui-7.0#get-a-google-maps-api-key</a>. Follow those instructions to obtain your Google Maps key, then use your key in the following steps to configure the Google Maps API key in the app:</p>
<ol>
<li>Open <code>AndroidManifest.xml</code>, which is in the <code>Platforms/Android</code> folder, by right-clicking on the file and selecting <strong class="bold">Open With…</strong>, then selecting <strong class="bold">XML (</strong><strong class="bold">Text) Editor</strong>.</li>
<li>Insert a metadata element as a child of the application element, as shown in the following highlighted code, replacing <code>"{YourKeyHere}"</code> with the key you obtained from Google:<pre class="source-code">
&lt;application android:label="MeTracker.Android"&gt;
<strong class="bold">  &lt;meta-data android:name="com.google.android.geo.API_KEY" android:value="{YourKeyHere}" /&gt;</strong>
&lt;/application&gt;<a id="_idTextAnchor612"/></pre></li> </ol>
<p>Recent versions of Android and iOS have changed how permissions are handled. Certain permissions such as location are not granted without explicit approval from the user while the app is running. It is also possible that the user can deny permissions. Let’s look at how to handle runtime permission requests in the next section.</p>
<h3>Requesting location permission at runtime</h3>
<p>Before we can use the location of the user, we need to request permissions from the user. .NET MAUI has cross-platform permission APIs, and we just need a tiny bit of code to make <a id="_idIndexMarker720"/> handling the request a little nicer. To implement the permission request handling, follow these steps:</p>
<ol>
<li>Create a new class called <code>AppPermissions</code> in the root of the project.</li>
<li>Edit the new file to look like the following:<pre class="source-code">
namespace MeTracker;
internal partial class AppPermissions
{
    internal partial class AppPermission : Permissions.LocationWhenInUse
    {
    }
    public static async Task&lt;PermissionStatus&gt; CheckRequiredPermissionAsync() =&gt; await Permissions.CheckStatusAsync&lt;AppPermission&gt;();
    public static async Task&lt;PermissionStatus&gt; CheckAndRequestRequiredPermissionAsync()
    {
        PermissionStatus status = await Permissions.CheckStatusAsync&lt;AppPermission&gt;();
        if (status == PermissionStatus.Granted)
            return status;
        if (status == PermissionStatus.Denied &amp;&amp; DeviceInfo.Platform == DevicePlatform.iOS)
        {
            // Prompt the user to turn on in settings
            // On iOS once a permission has been denied it may not be requested again from the application
            await App.Current.MainPage.DisplayAlert("Required App Permissions", "Please enable all permissions in Settings for this App, it is useless without them.", "Ok");
        }
        if (Permissions.ShouldShowRationale&lt;AppPermission&gt;())
        {
            // Prompt the user with additional information as to why the permission is needed
            await App.Current.MainPage.DisplayAlert("Required App Permissions", "This is a location based app, without these permissions it is useless.", "Ok");
        }
        status = await MainThread.InvokeOnMainThreadAsync(Permissions.RequestAsync&lt;AppPermission&gt;);
        return status;
    }
}</pre><p class="list-inset">This <a id="_idIndexMarker721"/>creates a type named <code>AppPermission</code> that derives from the default .NET MAUI <code>LocationWhenInUse</code> permission class.</p><p class="list-inset">The <code>CheckRequiredPermission</code> method is used to ensure our app has the right permissions before we attempt any operations that might fail if we don’t. Its implementation is to call the .NET MAUI <code>CheckSyncStatus</code> method with our <code>AppPermission</code> type. It returns a <code>PermissionStatus</code> type, which is an enum. We are mostly interested in the <code>Denied</code> and <code>Granted</code> values.</p><p class="list-inset">The <code>CheckAndRequestRequiredPermission</code> method handles the intricacies of requesting access from the user. The first step is to simply check and see whether the permission has already been granted, and if it has, return the status. Next, if we are on iOS and the permission has been denied, it cannot be requested again, so you must instruct the user on how to grant permission to the app by using the settings panel. Android includes in the request behavior the ability to nag the user if they have denied access. This behavior is exposed through .NET MAUI with the <code>ShouldShowRationale</code> method. It will return <code>false</code> for any platform that does not support this behavior, and on Android, it will return <code>true</code> the first time the user denies access and <code>false</code> if the user denies it a second time. Finally, we request access to the <code>AppPermission</code> type from the user. Again, .NET MAUI is hiding all the platform implementation details from us, making checking and requesting access to certain resources very straightforward.</p></li> </ol>
<p>Now that <a id="_idIndexMarker722"/> we have the <code>AppPermissions</code> class in place, we can use it to request the current location of the user, and center that map on that location.</p>
<h3>Centering the map on the current user location</h3>
<p>We will <a id="_idIndexMarker723"/>center the map on the position of the user in the constructor of <code>MainView.xaml.cs</code>. Because we want to fetch the user’s location asynchronously and this needs to be executed on the main thread, we will use <code>MainThread.BeginInvokeOnMainThread</code> to run an anonymous method on the main thread. Once we have the location, we can use the <code>MoveToRegion</code> method of <code>Map</code>. We can set this up by going through the following steps:</p>
<ol>
<li>Open <code>MainView.xaml.cs</code>.</li>
<li>Add the highlighted code shown in the following code snippet to the constructor of the <code>MainView.xaml.cs</code> class:<pre class="source-code">
public MainView ()
{
    InitializeComponent();
    MainThread.BeginInvokeOnMainThread(async () =&gt;
    {
        var status = await AppPermissions.CheckAndRequestRequiredPermissionAsync();
        if (status == PermissionStatus.Granted)
        {
            var location = await Geolocation.GetLastKnownLocationAsync();
            if (location == null)
            {
                location = await Geolocation.GetLocationAsync();
            }
            Map.MoveToRegion(MapSpan.FromCenterAndRadius(
                location,
                Distance.FromKilometers(50)));
        }
    });
}</pre></li> </ol>
<p>If you <a id="_idIndexMarker724"/>run the application now, it should look something like the following:</p>
<div><div><img alt="Figure 7.14 – Map centered on user location" src="img/B19214_07_14..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Map centered on user location</p>
<p>Now that <a id="_idIndexMarker725"/>we have the map displaying our current location, let’s start building the logic of the rest of the app, starting with our <code>ViewModel</code> class.</p>
<h3>Creating a ViewModel class</h3>
<p>Before we create an actual <code>ViewModel</code> class, we will create an abstract base view model that <a id="_idIndexMarker726"/>all view models can inherit from. The idea behind this base view model is that we can write common code in it. In this case, we will implement the <code>INotifyPropertyChanged</code> interface by usi<a id="_idTextAnchor613"/>ng the <code>CommunityToolkit.Mvvm</code> NuGet package. To add the package, follow these steps:</p>
<ol>
<li>Add a reference to <code>CommunityToolkit.Mvvm</code> by right-clicking the <code>Dependencies</code> node in <strong class="bold">Solution Explorer</strong>:</li>
</ol>
<div><div><img alt="Figure 7.15 – Adding the NuGet package" src="img/B19214_07_15..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Adding the NuGet package</p>
<ol>
<li value="2">Select <strong class="bold">Manage NuGet Packages…</strong> from <a id="_idIndexMarker727"/>the context menu to open the <strong class="bold">NuGet package </strong><strong class="bold">manager</strong> window.</li>
<li>Type <code>CommunityToolkit.Mvvm</code> into the search box, as shown next:</li>
</ol>
<div><div><img alt="Figure 7.16 – Adding the CommunityToolkit.Mvvm package" src="img/B19214_07_16..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Adding the CommunityToolkit.Mvvm package</p>
<ol>
<li value="4">Finally, check the box next to <code>CommunityToolkit.Mvvm</code> and click <strong class="bold">Add Package</strong>.</li>
</ol>
<p>Now, we can <a id="_idIndexMarker728"/>create a <code>ViewModel</code> class by going through the following steps:</p>
<ol>
<li>Create a folder called <code>ViewModels</code> in the project.</li>
<li>Create a new class called <code>ViewModel</code>.</li>
<li>Modify the template code to match the following:<pre class="source-code">
using CommunityToolkit.Mvvm.ComponentModel;
namespace MeTracker.ViewModels;
public partial class ViewModel : ObservableObject
{
}</pre></li> </ol>
<p>The next step <a id="_idIndexMarker729"/>is to create the actual view model that will use <code>ViewModel</code> as a base class. Let’s set this up by going through the following steps:</p>
<ol>
<li>Create a new <code>MainViewModel</code> class in the <code>ViewModels</code> folder.</li>
<li>Make the <code>MainViewModel</code> class inherit <code>ViewModel</code>.</li>
<li>Add a read-only field of the <code>ILocationTrackingService</code> type and name it <code>locationTrackingService</code>.</li>
<li>Add a read-only field of the <code>ILocationRepository</code> type and name it <code>locationRepository</code>.</li>
<li>Create a constructor with <code>ILocationTrackingService</code> and <code>ILocationRepository</code> as parameters.</li>
<li>Set the values of the fields that we created in <em class="italic">steps 3</em> and <em class="italic">4</em> with the values from the parameters, as shown in the following code snippet:<pre class="source-code">
public class MainViewModel : View<a id="_idTextAnchor614"/>Model
{
    private readonly ILocationRepository locationRepository;
    private readonly ILocationTrackingService locationTrackingService;
    public MainViewModel(ILocationTrackingService locationTrackingService,
        ILocationRepository locationRepository)
    {
        <strong class="bold">this.locationTrackingService = locationTrackingService;</strong>
<strong class="bold">        this.locationRepository = locationRepository;</strong>
<a id="_idTextAnchor615"/>    }
}</pre></li> </ol>
<p>To make the app start tracking the location of a user, we need to run the code that starts the tracking process on the main thread. Follow these steps:</p>
<ol>
<li>In the constructor of the newly created <code>MainViewModel</code> class, add an invocation to the main thread using <code>MainThread.BeginInvokeOnMainThread</code>.</li>
<li>Call <code>locationService.StartTracking</code> in the action that we pass to the <code>BeginInvokeOnMainThread</code> method. This is shown in the following highlighted code:<pre class="source-code">
public MainViewModel(ILocationTrackingService locationTrackingService, ILocationRepository locationRepository)
{
    this.locationTrackingService = locationTrackingService;
    this.locationRepository = locationRepository;
<strong class="bold">    MainThread.BeginInvokeOnMainThread(() =&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">        locationTrackingService.StartTracking();</strong>
<strong class="bold">    });</strong>
}</pre></li> </ol>
<p>Finally, we need <a id="_idIndexMarker730"/>to inject a <code>MainViewModel</code> class into the constructor of <code>MainView</code> and assign the <code>MainViewModel</code> instance to the binding context of the view. This will allow what data binding we’ve done to be processed, and the properties of <code>MainViewModel</code> will be bound to the controls in the user interface. Follow these steps:</p>
<ol>
<li>Go to the constructor of the <code>Views/MainView.xaml.cs</code> file.</li>
<li>Add <code>MainViewModel</code> as a parameter of the constructor and call it <code>viewModel</code>.</li>
<li>Set <code>BindingContext</code> as the instance of <code>MainViewModel</code>, as shown in the following code snippet:<pre class="source-code">
public MainView(<strong class="bold">MainViewModel viewModel</strong>)
{
    InitializeCom<a id="_idTextAnchor616"/>ponent();
    <strong class="bold">BindingContext = viewModel;</strong>
    MainThread.BeginInvokeOnMainThread(async () =&gt;
    {
        var location = await Geolocation.GetLastKnownLocationAsync();
        if(location == null)
        {
            location = await Geolocation.GetLocationAsync();
        }
        Map.MoveToRegion(MapSpan.FromCenterAndRadius(
            location, Distance.FromKilometers(5)));
    });
}</pre></li> </ol>
<p>In order <a id="_idIndexMarker731"/>for .NET MAUI to locate the classes <a id="_idIndexMarker732"/>we have implemented in this section so far, we need to add them to the <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) container.</p>
<h3>Adding classes to the DI container</h3>
<p>Since we <a id="_idIndexMarker733"/>have added a parameter to the constructor of the view, the .NET MAUI <code>View</code> framework won’t be able to construct the view automatically. So, we need to add <code>MainView</code>, <code>MainViewModel</code>, <code>LocationTrackingService</code>, and <code>LocationRepository</code> instances to the DI container. To do that, follow these steps:</p>
<ol>
<li>Open the <code>MauiProgram.cs</code> file.</li>
<li>Add the following highlighted lines to the <code>CreateMauiApp</code> method:<pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    builder
        .UseMauiApp&lt;App&gt;()
        .ConfigureFonts(fonts =&gt;
        {
            fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
            fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
        })
        .UseMauiMaps(); 
#if DEBUG
    builder.Logging.AddDebug();
#endif
<strong class="bold">        </strong>    <strong class="bold">builder.Services.AddSingleton&lt;Services.ILocationTrackingService, Services.LocationTrackingService&gt;();</strong>
<strong class="bold">        builder.Services.AddSingleton&lt;Repositories.ILocationRepository, Repositories.LocationRepository&gt;();</strong>
<strong class="bold">        builder.Services.AddTransient(typeof(ViewModels.MainViewModel));</strong>
<strong class="bold">        builder.Services.AddTransient(typeof(Views.MainView));</strong>
    return builder.Build();
}</pre></li> </ol>
<p>Now, we will <a id="_idIndexMarker734"/>be able to run the app again. We haven’t changed any of the interfaces, so it should look and behave the same as before. If it doesn’t, go back through the previous section carefully to make sure you have all the code correct.</p>
<p>Let’s add some code so that we can track the user’s location over time using background locati<a id="_idTextAnchor617"/><a id="_idTextAnchor618"/><a id="_idTextAnchor619"/><a id="_idTextAnchor620"/><a id="_idTextAnchor621"/><a id="_idTextAnchor622"/><a id="_idTextAnchor623"/><a id="_idTextAnchor624"/>on tracking.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor625"/>Background location tracking on iOS and Mac Catalyst</h2>
<p>The <a id="_idIndexMarker735"/>code for location tracking <a id="_idIndexMarker736"/>is something that we need to write for each platform. For iOS and Mac Catalyst, we will use <code>CLLocationManager</code> from the <code>CoreLocat<a id="_idTextAnchor626"/><a id="_idTextAnchor627"/>ion</code> namespace.</p>
<h3>Enabling location updates in the background</h3>
<p>When <a id="_idIndexMarker737"/>we want to perform tasks in the background in an iOS or Mac Catalyst app, we need to declare what we want to do in the <code>info.plist</code> file. The following steps show how we go about this:</p>
<ol>
<li>Open <code>info.plist</code>; you will need to do this for both <code>Platforms/iOS/info.plist </code>and <code>Platforms/MacCatalyst/info.plist</code>.</li>
<li>Add the following highlighted entry using the <strong class="bold">Property List Editor</strong> by selecting <strong class="bold">Required background modes</strong> from the dropdown and <strong class="bold">App registers for location updates</strong>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 7.17 – Adding location updates" src="img/B19214_07_17..jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17 – Adding location updates</p>
<p>We can also enable background modes directly in the <code>info.plist</code> file if we open it with an XML editor. In this case, we will add the following XML:</p>
<pre class="source-code">
&lt;key&gt;UIBackgroundModes&lt;/key&gt;
&lt;array&gt;
&lt;string&gt;location&lt;/st<a id="_idTextAnchor628"/><a id="_idTextAnchor629"/><a id="_idTextAnchor630"/><a id="_idTextAnchor631"/>ring&gt;
&lt;/array&gt;</pre> <h3>Subscribing to location updates</h3>
<p>Now that we have prepared the <code>info.plist</code> file for location tracking, it is time to write <a id="_idIndexMarker738"/>the actual code that will track the location of the user. If we don’t set <code>CLLocationManager</code> to not pause location updates, location updates can be paused automatically by iOS or Mac Catalyst when the location data is unlikely to change. In this app, we don’t want that to happen because we want to save the location multiple times so that we can establish whether a user visits a particular location frequently.</p>
<p>If you recall from earlier, we already defined the service as a partial class with a partial method; now, we will finish the service by implementing the platform-specific pieces of the service. Let’s set this up:</p>
<ol>
<li>Create a new folder named <code>Services</code> in the <code>Platforms/iOS</code> folder.</li>
<li>Create a new class named <code>LocationTrackingService</code> in the <code>Services</code> folder.</li>
<li>Modify the class to match the following:<pre class="source-code">
namespace MeTracker.Services;
public partial class LocationTrackingService : ILocationTr<a id="_idTextAnchor632"/>ackingService
{
    partial void StartTrackingInternal()
    {
    }
}</pre></li> <li>Add a private field for <code>CLLocationManager</code>.</li>
<li>Create an instance of <code>CLLocationManager</code> in the <code>StartTrackingInternal</code> method.</li>
<li>Set <code>PausesLocationUpdatesAutomatically</code> to <code>false</code>.<p class="list-inset">Before we can start tracking the location of the user, we need to set the accuracy of the data that we want to receive from <code>CLLocationManager</code>. We will also add an event handler to handle location updates.</p></li>
<li>Set <code>DesiredAccuracy</code> to <code>CLLocation.</code><code>Accuracy</code><code>BestForNavigation</code>. One of the constraints when running the app in the background is that <code>DesiredAccuracy</code> needs to be set to either <code>Accuracy</code><code>Best</code> or <code>Accuracy</code><code>BestForNavigation</code>.</li>
<li>Set <code>AllowBackgroundLocationUpdates</code> to <code>true</code> (as shown in the following code snippet) so that the location updates will continue, even when the app is running in the background.<p class="list-inset">Your <a id="_idIndexMarker739"/>changes should<a id="_idTextAnchor633"/> look like this:</p><pre class="source-code">
<strong class="bold">CLLocation l<a id="_idTextAnchor634"/><a id="_idTextAnchor635"/>ocationManager;</strong>
partial void StartTrac<a id="_idTextAnchor636"/>kingInternal()
{
<strong class="bold">    locationManager = new CLLocationManager</strong>
<strong class="bold">    {</strong>
<strong class="bold">        PausesLocationUpdatesAutomatically = false,</strong>
<strong class="bold">        DesiredAccuracy = CLLocation.</strong><strong class="bold">Accuracy</strong><strong class="bold">BestForNavigation,</strong>
<strong class="bold">        AllowsBackgroundLocationUpdates = true</strong>
<strong class="bold">    };</strong>
<strong class="bold">    // Add code here</strong>
}</pre></li> </ol>
<p>The next step is to ask the user for permission to track their location. We will request permission to track their location all the time, but the user has the option of only giving us permission to track their location when they are using the app. Because the user also has the option of denying us permission to track their location, we need to check this before we start. Let’s set this up:</p>
<ol>
<li>Add an event handler for <code>LocationsUpdated</code> just after the <code>// Add code here</code> comment. It should look like the code highlighted in the fo<a id="_idTextAnchor637"/>llowing snippet:<pre class="source-code">
partial void StartTrackingInternal()
{
    locationManager = new CLLocationManager
    {
        PausesLocationUpdatesAutomatically = false,
        DesiredAccuracy = CLLocation.AccuracyBestForNavigation,
        AllowsBackgroundLocationUpdates = true
    };
    // Add code here
<strong class="bold">    locationManager.LocationsUpdated +=</strong>
<strong class="bold">async (object sender, CLLocationsUpdatedEventArgs e) <a id="_idTextAnchor638"/>=&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Final block of code goes here</strong>
<strong class="bold">    };</strong>
};</pre></li> <li>After <a id="_idIndexMarker740"/>the event handler, call the <code>RequestAlwaysAuthorization</code> method of the instance that we recently created in <code>C<a id="_idTextAnchor639"/>LLocationManager</code>:<pre class="source-code">
partial void StartTrackingInternal()
{
    locationManager = new CLLocationManager
    {
        PausesLocationUpdatesAutomatically = false,
        DesiredAccuracy = CLLocation.AccurracyBestForNavigation,
        AllowsBackgroundLocationUpdates = true
    };
    // Add code here
    locationManager.LocationsUpdated +=
async (object sender, CLLocationsUpdatedEventArgs e) =&gt;
    {
        // Final block of code goes here
    };
<strong class="bold">    locationManager.RequestAlwaysAuthorization();</strong>
};</pre></li> <li>Then, call <a id="_idIndexMarker741"/>the <code>StartUpdatingLocation</code> method of <code>locationManager</code>:<pre class="source-code">
partial void StartTrackingInternal()
{
    locationManager = new CLLocationManager
    {
        PausesLocationUpdatesAutomatically = false,
        DesiredAccuracy = CLLocation.AccurracyBestForNavigation,
        AllowsBackgroundLocationUpdates = true
    };
  <a id="_idTextAnchor640"/>  // Add code here
    locationManager.LocationsUpdated +=
async (object sender, CLLocationsUpdatedEventArgs e<a id="_idTextAnchor641"/>) =&gt;
    {
        // Final block of code<a id="_idTextAnchor642"/> goes here
    };
    locationManager.RequestAlwaysAuthorization();
<strong class="bold">    locationManager.StartUpdatingLocation();</strong>
};</pre></li> </ol>
<p class="callout-heading">Tip</p>
<p class="callout">The higher the accuracy is, the higher the battery consumption. If we only want to track where the user has been and not how popular a place is, we could also set <code>AllowDeferredLocationUpdatesUntil</code>. This way, we can specify that the user has to move a specific distance before the location is updated. We can also specify how often we want the location to be updated using the <code>timeout</code> argument. The most power-efficient solution to track how long a user has been at a place is to use the <code>StartMonitoringVisits</code> method of <a id="_idTextAnchor643"/><code>CLLocationManager</code>.</p>
<p>Now, it’s time <a id="_idIndexMarker742"/>to handle the <code>LocationsUpdated</code> event. Let’s go through the following steps:</p>
<ol>
<li>Add a private field called <code>locationRepository</code> that is of the <code>ILocationRepository</code> type.</li>
<li>Add a constructor that has <code>ILocationRepository</code> as a parameter. Set the value of the parameter to the <code>locationRepository</code> field. Your class should resemble the following code snippet:<pre class="source-code">
<a id="_idTextAnchor644"/>using CoreLocation;
<strong class="bold">using MeTracker.Repositories;</strong>
namespace MeTracker.Services;
public partial class LocationTrackingService : ILocationTrackingService
{
    CLLocationManag<a id="_idTextAnchor645"/>er locationManager;
<strong class="bold">    ILocationRepository locationRepository;</strong>
<strong class="bold">    public LocationTrackingService(ILocationRepository locationRepository)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        this.locationRepository = locationRepository;</strong>
<strong class="bold">    }</strong>
    partial void Star<a id="_idTextAnchor646"/>tTrackingInternal()
    {
    // Remainder of code <a id="_idTextAnchor647"/>omitted for brevity
    }</pre></li> <li>Read the latest location of the <code>Locations</code> property of <code>CLLocationsUpdatedEventArgs</code>.</li>
<li>Create an instance of <code>MeTracker.Models.Location</code> and pass the latitude and longitude of the latest location to it.</li>
<li>Save <a id="_idIndexMarker743"/>the location using the <code>SaveAsync</code> method of <code>ILocationRepository</code>.</li>
<li>The code should be placed after the <code>// Final block of code goes here</code> comment. It should look like the code shown in bold in the following fragment:<pre class="source-code">
locationManager.LocationsUpdated +=
async (object sender, CLLocationsUpdatedEventArgs e) =&gt;
{
    // Final blo<a id="_idTextAnchor648"/>ck of code goes here
    <strong class="bold">var lastLocation = e.Locations.Last();</strong>
    <strong class="bold">var newLocation = new Models.Location(lastLocation.Coordinate.Latitude, lastLocation.Coordinate.Longitude);</strong>
     <strong class="bold">await locationRepository.SaveAsync(newLocation);</strong>
};</pre></li> </ol>
<p>With that, we have completed the tracking part of the app for iOS. The implementation is identical for Mac Catalyst; you can either repeat the steps in this section for Mac Catalyst (but create the file as <code>Platforms/MacCatalyst/Services</code> instead of <code>Platforms/iOS/S<a id="_idTextAnchor649"/>ervices</code>) or copy the <code>Platforms/iOS/Services/LocationTrackingService.cs</code> file to the <code>Platforms/MacCatalyst/Services</code> folder.</p>
<p>No<a id="_idTextAnchor650"/>w, we will implement background tracking for Android, following which we will visualize the loc<a id="_idTextAnchor651"/>ation tracking data.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor652"/>Background location tracking with Android</h2>
<p>The <a id="_idIndexMarker744"/>Android way to carry out background updates is very different from how we implemented it with iOS. With Android, we need to create a <code>JobService</code> c<a id="_idTextAnchor653"/><a id="_idTextAnchor654"/><a id="_idTextAnchor655"/><a id="_idTextAnchor656"/><a id="_idTextAnchor657"/>lass and schedule it.</p>
<h3>Creating a background job</h3>
<p>To track the location of users in the background, we need to create a background job. A background <a id="_idIndexMarker745"/>job is used by the OS to allow developers to execute code even when the app is not in the foreground or visible on the screen. Follow these steps to create a background job to capture a user’s location:</p>
<ol>
<li>Create a new folder named <code>Services</code> in the <code>Platforms/Android</code> folder.</li>
<li>Create a new class called <code>LocationJobService</code> in the <code>Services</code> folder.</li>
<li>Make the class inherit from <code>Android.App.Job.JobServic<a id="_idTextAnchor658"/>e</code> as a base class.</li>
<li>Add <code>using Android.App.Job</code> and <code>using Android.App.Job</code> declarations to the top of the file.</li>
<li>Implement the <code>OnStartJob</code> and <code>OnStopJob</code> abstract methods, as shown in the f<a id="_idTextAnchor659"/>ollowing code snippet:<pre class="source-code">
using Android.App;
using Android.App.Job;
namespace MeTracker.Platforms.Android.Services;
internal class LocationJobService : JobService
{
    public override bool OnStartJob(JobParameters @params)
    {
        return true;
    }
    public override bool OnStopJob(JobParameters @params)
    {
        return true;
    }
}</pre></li> </ol>
<p>All the Android services in the app need to be added to the <code>AndroidManifest.xml</code> file. We don't have to do this manually; instead, we can add an attribute to the <code>LocationJobService</code> class, which will then be generated in the <code>AndroidManifest.xml</code> file. We will use the <code>Name</code> and <code>Permission</code> properties to set the required information, as shown in the f<a id="_idTextAnchor660"/>ollowing code snippet:</p>
<pre class="source-code">
<strong class="bold">[Service(Name = "MeTracker.Platforms.Android.Services.LocationJobService", Permission = "android.permission.BIND_JOB_SERVICE")]</strong>
internal class LocationJ<a id="_idTextAnchor661"/><a id="_idTextAnchor662"/><a id="_idTextAnchor663"/>obService : JobService</pre> <h3>Scheduling a background job</h3>
<p>When we have created a job, we need to schedule it. We will do this from <code>LocationTrackingService</code> in the <code>Platforms/Android</code> folder. To configure the job, we will use the <code>JobInfo.Builder</code> class.</p>
<p>We will <a id="_idIndexMarker746"/>use the <code>SetPersisted</code> method to ensure that the job starts again after a reboot. This is why we added the <code>RECEIVE_BOOT_COMPLETED</code> permission earlier.</p>
<p>To schedule a job, at least one constraint is needed. In this case, we will use <code>SetOverrideDeadline</code>. This will specify that the job needs to run before the specified time (in milliseconds) has elapsed.</p>
<p>The <code>SetRequiresDeviceIdle</code> method can be used to make sure that a job only runs when the device is not being used by a user. We could pass <code>true</code> to the method if we want to make sure that we don’t slow down the device when the user is using it.</p>
<p>The <code>SetRequiresBatteryNotLow</code> method can be used to specify that a job should not run when the battery level is low. We recommend that this always be set to <code>true</code> if you don’t have a good reason to run the job when the battery is low. This is because we don’t want our applications to drain the user’s battery.</p>
<p>So, let’s implement <code>LocationTrackingService</code>. Follow these steps to do so:</p>
<ol>
<li>Create a new class named <code>LocationTrackingService</code> in the <code>Platforms/Android/Services</code> folder.</li>
<li>Modify the class to l<a id="_idTextAnchor664"/>ook like the following:<pre class="source-code">
namespace MeTracker.Services;
public partial class LocationTrackingService : ILocationTrackingService
{
    partial void <a id="_idTextAnchor665"/>StartTrackingInternal()
    {
    }
}</pre></li> <li>Create a <code>JobInfo.Builder</code> class based on an ID that we’ll specify (we will use <code>1</code> here) and the component name (which we’ll create from the application context and the Java class) in the <code>StartTrackingInternal</code> method. The component <a id="_idIndexMarker747"/>name is used to specify which code will run during the job.</li>
<li>Use the <code>SetOverrideDeadline</code> method and pass <code>1000</code> to it to make the job run before 1 second has elapsed from when the job was created.</li>
<li>Use the <code>SetPersisted</code> method and pass <code>true</code> to make the job persist even after the device is rebooted.</li>
<li>Use the <code>SetRequiresDeviceIdle</code> method and pass <code>false</code> so that the job will run even when a user is using the device.</li>
<li>Use the <code>SetRequiresBatteryLow</code> method and pass <code>true</code> to make sure that we don’t drain the user’s battery. This method was added in Android API level 26.<p class="list-inset">The code for <code>LocationTrackingService</code> sh<a id="_idTextAnchor666"/>ould now look like this:</p><pre class="source-code">
<strong class="bold">using Android.App.Job;</strong>
<strong class="bold">using Android.Content;</strong>
<strong class="bold">using MeTracker.Platforms.Android.Services;</strong>
namespace MeTracker.Services;
public partial class LocationTrackingService : ILocationTrackingService
{
    partial void Start<a id="_idTextAnchor667"/>TrackingInternal()
    {
<strong class="bold">        var javaClass = Java.Lang.Class.FromType(typeof(LocationJobService));</strong>
<strong class="bold">        var componentName = new ComponentName(global::Android.App.Application.Context, javaClass);</strong>
<strong class="bold">        var jobBuilder = new JobInfo.Builder(1, componentName);</strong>
<strong class="bold">        jobBuilder.SetOverrideDeadline(1000);</strong>
<strong class="bold">        jobBuilder.SetPersisted(true);</strong>
<strong class="bold">        jobBuilder.SetRequiresDeviceIdle(false);</strong>
<strong class="bold">        jobBuilder.SetRequiresBatteryNotLow(true);</strong>
<strong class="bold">        var jobInfo = jobBuilder.Build();</strong>
    }
}</pre></li> </ol>
<p>The last <a id="_idIndexMarker748"/>step in the <code>StartTrackingInternal</code> method is to schedule the job with the system using <code>JobScheduler</code>. The <code>JobScheduler</code> service is an Android system service. To get an instance of a system service, we will use the application context. Follow these steps to do so:</p>
<ol>
<li>Use the <code>GetSystemService</code> method on <code>Application.Context</code> to get the <code>JobScheduler</code> service.</li>
<li>Cast the result to <code>JobScheduler</code>.</li>
<li>Use the <code>Schedule</code> method on the <code>JobScheduler</code> class and pass the <code>JobInfo</code> object to schedule the job, as shown in th<a id="_idTextAnchor668"/>e following code snippet:<pre class="source-code">
var jobScheduler = (JobScheduler)global::Android.App.Application.Context.GetSystemService(Context.JobSchedulerService);
jobScheduler.Schedule(jobInfo);</pre></li> </ol>
<p>Now that <a id="_idIndexMarker749"/>the job is scheduled, we can start receiving location updates<a id="_idTextAnchor669"/><a id="_idTextAnchor670"/>; let’s work on that next.</p>
<h3>Subscribing to location updates</h3>
<p>Once we <a id="_idIndexMarker750"/>have scheduled the job, we can write the code to specify what the job should do – that is, track the location of a user. To do this, we will use <code>LocationManager</code>, which is a <code>SystemService</code> class. With <code>LocationManager</code>, we can either request a single location update or we can subscribe to location updates. In this case, we want to subscribe to location updates.</p>
<p>We will start by creating an instance of the <code>ILocationRepository</code> interface. We will use this to save the locations to the SQLite database. Let’s set this up:</p>
<ol>
<li>Create a constructor for <code>LocationJobService</code>.</li>
<li>Create a <code>private</code> read-only field for the <code>ILocationRepository</code> interface called <code>locationRepository</code>.</li>
<li>Use <code>Services.GetService&lt;T&gt;</code> in the constructor to create an instance of <code>ILocationRepository</code>, as shown in <a id="_idTextAnchor671"/>the following code snippet:<pre class="source-code">
private ILocationRepo<a id="_idTextAnchor672"/>sitory locationRepository;
public<a id="_idTextAnchor673"/> LocationJobService()
{
    locationReposito<a id="_idTextAnchor674"/>ry = MauiApplication.Current.Services.GetService&lt;ILocationRepository&gt;();
}</pre></li> </ol>
<p>Before we subscribe to location updates, we will add a listener. To do this, we will use the <code>Android.Locations.ILocationListener</code> interface.</p>
<p><a id="_idTextAnchor675"/>Follow these steps:</p>
<ol>
<li>Add the <code>Android.Locations.ILocationListener</code> interface to <code>LocationJobService</code>.</li>
<li>Add the following namespace declarations to the top of the file:<pre class="source-code">
using Android.Content;
using Android.Locations;
using Android.OS;
using Android.Runtime;
using MeTracker.Repositories;</pre></li> <li>Implement <a id="_idIndexMarker751"/>the interface and remove all instances of <code>throw </code><code>new NotImplemented</code><strong class="source-inline">
Exception();</strong>. This is added to the methods when you let Visual Studio generate an implementation of the interface.<p class="list-inset">The method implementations should look like those in the following code snippet:</p><pre class="source-code">
    public override bool OnStartJob(JobParameters @params)
    {
        return true;
    }
    public void OnLocationChanged(global::Android.Locations.Location location) { }
    public override bool OnStopJob(JobParameters @params) =&gt; true;
    public void OnStatusChanged(string provider, [GeneratedEnum] Availability status, Bundle extras) { }
    public void OnProviderDisabled(string provider) { }
    public void OliknProviderEnabled(string provider) { }</pre></li> <li>In the <code>OnLocationChanged</code> method, map the <code>Android.Locations.Location</code> object to the <code>Model.Location</code> object.</li>
<li>Use the <code>SaveAsync</code> method on the <code>LocationRepository</code> class, as shown in the <a id="_idIndexMarker752"/>following code snippet:<pre class="source-code">
public void OnLocationChanged(Android.L<a id="_idTextAnchor676"/>ocations.Location location)
{
<code>var newLocation = new Models.Location(location.Latitude, location.Longitude);</code>
<code>locationReposit<a id="_idTextAnchor677"/>ory.SaveAsync(newLocation);</code>
}</pre></li> </ol>
<p>Now that we have created a listener, we can subscribe to location updates. Follow these steps to do so:</p>
<ol>
<li>Create a <code>static</code> field of the <code>LocationManager</code> type named <code>locationManager</code>. Make sure it has the same lifetime as the app.</li>
<li>It is possible in Android that <code>JobService</code> will start before <code>MainView</code> is displayed and we request location permissions. To prevent any errors due to missing permissions, we will check for them first:<pre class="source-code">
public override bool OnStar<a id="_idTextAnchor678"/>tJob(JobParameters @params)
{
    PermissionStatus status = PermissionStatus.Unknown;
    Task.Run(async ()=&gt; status = await AppPermissions.CheckRequiredPermissionAsync()).Wait();
    if (status == PermissionStatus.Granted)
    {
    }
}</pre><p class="list-inset">We run <code>CheckRequiredPermissionsAsync</code> inside a <code>Task.Run</code> instance because it’s an <code>async</code> call, and we can’t add <code>async</code> to the method because the return <a id="_idIndexMarker753"/>type is incompatible. The call to <code>Wait</code> turns the <code>async</code> call into a synchronous one. If the result is <code>Granted</code>, then we can continue.</p></li> <li>Go to the <code>StartJob</code> method in <code>LocationJobService</code>. Get <code>LocationManager</code> by using <code>GetSystemService</code> on <code>ApplicationContext</code>.</li>
<li>To subscribe for location updates, use the <code>RequestLocationUpdates</code> method, as shown <a id="_idTextAnchor679"/>in the following code snippet:<pre class="source-code">
public override bool OnSt<a id="_idTextAnchor680"/>artJob(JobParameters @params)
{
    PermissionStatus status = PermissionStatus.Unknown;
    Task.Run(async ()=&gt; status = await AppPermissions.CheckRequiredPermissionAsync()).Wait();
    if (status == PermissionStatus.Granted)
    {
        <strong class="bold">locationManager = (LocationManager)ApplicationContext.GetSystemService  (Context.LocationService);</strong>
    <strong class="bold">    locationManager.RequestLocationUpdates (LocationManager.GpsProvider, 1000L, 0.1f, this);</strong>
        return true;
    }
    return false;
}</pre></li> </ol>
<p>The first argument that we pass to the <code>RequestLocationUpdates</code> method ensures that we get locations from the GPS. The second ensures that at least <code>1000</code> milliseconds will elapse <a id="_idIndexMarker754"/>between location updates. The third argument ensures that the user moves at least <code>0.1</code> meters to get a location update. The last argument specifies which listener we should use. Because the current class implements the <code>Android.Locations.ILocationListener</code> interface, we will pass <code>this</code>.</p>
<p>Now that we have collected location data on from the user and stored it in our SQLite database, we can <a id="_idTextAnchor681"/><a id="_idTextAnchor682"/>now display that data on a map.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor683"/>Creating a heat map</h2>
<p>To visualize the data that we have collected, we will create a heat map. We will add lots of dots to <a id="_idIndexMarker755"/>the map and make them different colors, based on how much time a user spends in a particular place. The most popular places will <a id="_idIndexMarker756"/>have a warm color, while the least popular places will have a cold color.</p>
<p>Before we add the dots to the map, we need to get a<a id="_idTextAnchor684"/><a id="_idTextAnchor685"/><a id="_idTextAnchor686"/>ll locations from the repository.</p>
<h3>Adding the GetAllAsync method to LocationRepository</h3>
<p>In order <a id="_idIndexMarker757"/>to visualize the data, we <a id="_idIndexMarker758"/>need to write some code <a id="_idIndexMarker759"/>so that location data can be read from the database. Let’s set this up:</p>
<ol>
<li>Open the <code>ILocationRepository.cs</code> file.</li>
<li>Add a <code>GetAllAsync</code> method that returns a list of <code>Location</code> objects, using the following code:<pre class="source-code">
Task&lt;List&lt;Models.Location&gt;&gt; GetAllAsync();</pre></li> <li>Open the <code>LocationRepository.cs</code> file, which implements <code>ILocationRepository</code>.</li>
<li>Implement the new <code>GetAllAsync</code> method and return all the saved locations in the database, as shown in the following code snippet:<pre class="source-code">
public async Task&lt;List&lt;Location&gt;&gt; GetAllAsync()
{
    await CreateConnectionAsync();
    var locations = await connection.Table&lt;Location&gt; ().ToL<a id="_idTextAnchor687"/><a id="_idTextAnchor688"/>istAsync();
    return locations;
}</pre></li> </ol>
<h3>Preparing the data for visualization</h3>
<p>Before we <a id="_idIndexMarker760"/>can visualize the data on the map, we need <a id="_idIndexMarker761"/>to prepare the data. The first thing we will do is create a new model that we can use for the prepared data. Let’s set this up:</p>
<ol>
<li>In the <code>Models</code> folder, create a new class called <code>Point</code>.</li>
<li>Add properties for <code>Location</code>, <code>Count</code>, and <code>Heat</code>, as shown in the following code snippet:<pre class="source-code">
namespace M<a id="_idTextAnchor689"/>eTracker.Models{
public class Point
{
    public Location Location { get; set; }
    public int Count { get; set; } = 1;
    public Color Heat { get; set; }
}
}</pre><p class="list-inset"><code>MainViewModel</code> will store the locations that we will find later on. Let’s add a property for storing points.</p></li> <li>Open the <code>MainViewModel</code> class.</li>
<li>Add a <code>private</code> field called <code>points</code>, which is of the <code>List&lt;Point&gt;</code> type.</li>
<li>Add the <code>ObservableProperty</code> attribute to the <code>points</code> field, as shown in the following code snippet:<pre class="source-code">
[ObservableProperty]
private List&lt;Models.Point&gt; points;</pre></li> </ol>
<p>Now that we have storage for our points, we must add some code so that we can add locations. We will do this by implementing the <code>LoadDataAsync</code> method of the <code>MainViewModel</code> class and making sure that it is called on the main thread, right after location tracking has started.</p>
<p>The first thing <a id="_idIndexMarker762"/>we will do is group the saved locations so that all locations within 200 meters will be handled as one point. We will track <a id="_idIndexMarker763"/>how many times we have logged a position within that point so that we can decide which color the point will be on the map. Let’s set this up:</p>
<ol>
<li>Add an <code>async</code> method called <code>LoadDataAsync</code>. This returns a <code>Task</code> object to <code>Main</code><strong class="source-inline">
</strong><code>ViewModel</code>.</li>
<li>Call the <code>LoadDataAsync</code> method from the constructor after the call to the <code>StartTracking</code> method on <code>ILocationTrackingService</code>, as shown in the following code snippet:<pre class="source-code">
public MainViewModel(ILocationTrackingService locationTrackingService, ILocationRepository locationRepository)
{
    this.locationTrackingService = locationTrackingService;
    this.locationRepository = locationRepository;
    MainThread.BeginInvokeOnMainThread(<strong class="bold">async</strong>() =&gt;
    {
        locationTrackingService.StartTracking();
        <strong class="bold">await LoadDataAsync();</strong>
    });
}</pre></li> </ol>
<p>The first step of the <code>LoadDataAsync</code> method is to read all tracked locations from the SQLite database. When we have all the locations, we will loop through them and create points.</p>
<p>To calculate <a id="_idIndexMarker764"/>the distance between a location <a id="_idIndexMarker765"/>and a point, we will use the <code>CalculateDistance</code> method, as shown in the following code snippet:</p>
<pre class="source-code">
private async Task LoadDataAsync()
{
    var locations = await locationRepository.GetAll();
    var pointList = new List&lt;Models.Point&gt;();
    foreach (var location in locations)
    {
        //If no points exist, create a new one and continue to the next location in the list
        if (!pointList.Any())
        {
            pointList.Add(new Models.Point() { Location = location });
            continue;
        }
        var pointFound = false;
        //try to find a point for the current location
        foreach (var point in pointList)
        {
            var distance = Location.CalculateDistance(
                new Location(point.Location.Latitude, point.Location.Longitude),
                new Location(location.Latitude, location.Longitude),
                DistanceUnits.Kilometers);
            if (distance &lt; 0.2)
            {
                pointFound = true;
                point.Co<a id="_idTextAnchor690"/>u<a id="_idTextAnchor691"/>nt++;
                break;
            }
        }
        //if no point is found, add a new Point to the list of points
        if (!pointFound)
        {
            pointList.Add(new Models.Point() { Location = location });
        }
        // Next section of code goes here
    }
}</pre> <p>When we <a id="_idIndexMarker766"/>have a list of points, we can calculate <a id="_idIndexMarker767"/>the heat color for each point. We are going to use the <strong class="bold">hue</strong>, <strong class="bold">saturation</strong>, and <strong class="bold">lightness</strong> (<strong class="bold">HSL</strong>) representation of a color, as described here:</p>
<ul>
<li><strong class="bold">Hue</strong>: Hue is a <a id="_idIndexMarker768"/>degree on the color wheel that goes from 0 to 360, with 0 being red and 240 being blue. Because we want our most popular places to be red (hot) and our least popular places to be blue (cold), we will calculate a value between 0 and 240 for each point, based on how many times the user has been to that point. This means that we will only use two-thirds of the scale.</li>
<li><code>1</code> in the code).</li>
<li><code>0.5</code> in the code).</li>
</ul>
<p>The first thing that we need to do is find out how many times the user has been to the most popular and least popular places. Let’s take a look:</p>
<ol>
<li>First, check that the list of points is not empty.</li>
<li>Get the <code>Min</code> and <code>Max</code> values for the <code>Count</code> property in the list of points.</li>
<li>Calculate the difference between the minimum and the maximum values.</li>
<li>The code should be added after the <code>// Next section of code goes here</code> comment at the bottom of the <code>LoadDataAsync</code> method, as shown in the following code snippet:<pre class="source-code">
private async Task LoadDataAsync()
{
    // The rest of the method has been omitted for brevity
    // Next section of code goes here
<strong class="bold">    <a id="_idTextAnchor692"/>if (pointList == null || !pointList.Any())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        return;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    var pointMax = pointList.Select(x =&gt; x.Count).Max();</strong>
<strong class="bold">    var pointMin = pointList.Select(x =&gt; x.Count).Min();</strong>
<strong class="bold">    var diff = (float)(pointMax - pointMin);</strong>
<strong class="bold">    // Last section of code goes here</strong>
}</pre></li> </ol>
<p>Now, we can <a id="_idIndexMarker771"/>calculate the heat for each point, as follows:</p>
<ol>
<li>Loop through all the points.</li>
<li>The following <a id="_idIndexMarker772"/>code should be added after the <code>// Last section of code goes here</code> comment, at the bottom of the <code>LoadDataAsync()</code> method (this is highlighted in the following co<a id="_idTextAnchor693"/>de snippet):<pre class="source-code">
private async Task LoadDataAsync()
{
    // The rest of the method has been omitted for brevity
    // Next section of code goes here
    if (pointList == null || !pointList.Any())
    {
        return;
    }
    var pointMax = pointList.Select(x =&gt; x.Count).Max();
    var pointMin = pointList.Select(x =&gt; x.Count).Min();
    var diff = (float)(pointMax - pointMin);
    // Last section of code goes here
    <strong class="bold">foreach (var point in pointList)</strong>
    <strong class="bold">{</strong>
        <strong class="bold">var heat = (2f / 3f) - ((float)point.Count / diff);</strong>
        <strong class="bold">point.Heat = Color.FromHsla(heat, 1, 0.5);</strong>
    <strong class="bold">}</strong>
    <strong class="bold">Points = pointList;</strong>
}</pre></li> </ol>
<p>That’s all <a id="_idIndexMarker773"/>we need to do to set up location tracking <a id="_idIndexMarker774"/>in the <code>MeTracker</code> project. Now, let’s tur<a id="_idTextAnchor694"/><a id="_idTextAnchor695"/><a id="_idTextAnchor696"/>n our attention to visualizing the data we receive.</p>
<h3>Adding data visualizations</h3>
<p>In .NET MAUI, the <code>Map</code> control can render additional information over the map. This includes pins and custom shapes, which are called <code>MapElements</code>. We could simply add each <a id="_idIndexMarker775"/>location that is stored in the repository as a pin; however, to get the heat map, we want to add a colored dot to the map for each location, so we <a id="_idIndexMarker776"/>will use <code>MapElements</code> for each location.</p>
<p>If the <code>MapElements</code> property were <code>BindableProperty</code> , we could use a converter to map the <code>MainViewModel</code> <code>Points</code> property to the map’s <code>MapElements</code> property in a binding. But <code>MapElements</code> is not a bindable property,  so it won’t be tha<a id="_idTextAnchor697"/>t easy.</p>
<p>Let’s start by creating a custom map control.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor698"/>Creating a custom control for the map</h2>
<p>To show the heat map on our map, we will create a new control. Since <code>Map</code> is a sealed class, we won’t <a id="_idIndexMarker777"/>be able to subclass it directly; instead, we will encapsulate the <code>Map</code> control inside <code>ContentView</code> with <code>BindableProperty</code> to get access to the <code>Points</code> data from <code>ViewModel</code>.</p>
<p>Follow these <a id="_idIndexMarker778"/>steps to create the custom control:</p>
<ol>
<li>Create a new folder called <code>Controls</code>.</li>
<li>Create a new class called <code>CustomMap</code>.</li>
<li>Add <code>ContentView</code> as a base class to the new class, as shown in the following code snippet:<pre class="source-code">
namespace MeTracker.Controls;
public class CustomM<a id="_idTextAnchor699"/>ap : ContentView
{
    public CustomMap()
    {
    }
}</pre></li> </ol>
<p>Now, we need to add the <code>Map</code> control to the custom control. Follow these steps to add the <code>Map</code> control:</p>
<ol>
<li>Derive the <code>CustomMap</code> control from the .NET MAUI <code>Map</code> control, as highlighted in the following code snippet:<pre class="source-code">
<strong class="bold">using Microsoft.Maui.Controls.Maps;</strong>
<strong class="bold">using Microsoft.Maui.Maps;</strong>
<strong class="bold">using Map = Microsoft.Maui.Controls.Maps.Map;</strong>
namespace MeTracker.Controls;
public class CustomMap : <strong class="bold">Map</strong>
{
    public CustomMap()
    {
    }
}</pre></li> <li>Initialize the map in the constructor, as shown with the new changes highlighted:<pre class="source-code">
public CustomMap()
{
    IsScrollEnabled = true;
    IsShowingUser = true;
}</pre></li> </ol>
<p>If we want <a id="_idIndexMarker779"/>to have properties that we want to bind data to, we need to create a <code>BindableProperty</code> class. This should be <a id="_idIndexMarker780"/>a public static field in the class. We also need to create a regular property to hold the value. The naming of the properties is really important. The name of <code>BindableProperty</code> needs to be <code>{NameOfTheProperty}Property</code>; for example, the name of <code>BindableProperty</code> that we will create in the following steps will be <code>PointsProperty</code> because the name of the property is <code>Points</code>. A <code>BindableProperty</code> is created using the static <code>Create</code> method on the <code>BindableProperty</code> class. This requires at least four arguments, as follows:</p>
<ul>
<li><code>propertyName</code>: This is the name of the property as a string.</li>
<li><code>returnType</code>: This is the type that will be returned from the property.</li>
<li><code>declaringType</code>: This is the type of the class that <code>BindableProperty</code> is declared in.</li>
<li><code>defaultValue</code>: This is the default value that will be returned if no value is set. This is an optional argument. If it is not set, .NET MAUI will use <code>null</code> as a default value.</li>
</ul>
<p>The <code>set</code> and <code>get</code> methods for the property will call methods in the base class to set or get values from <code>BindableProperty</code>:</p>
<ol>
<li>Create <code>BindableProperty</code> called <code>PointsProperty</code>, as shown in the following code snippet:<pre class="source-code">
public static BindableProperty PointsProperty = BindableProperty.Create(nameof(Points), typeof(List&lt;Models.Point&gt;), typeof(CustomMap), new List&lt;Models.Point&gt;());</pre></li> <li>Create a <a id="_idIndexMarker781"/>property of the <code>List&lt;Models.Point&gt;</code> type called <code>Points</code>. Remember to cast the result of <code>GetValue</code> so that <a id="_idIndexMarker782"/>it’s the same type as the property. We need to do this because <code>GetValue</code> will return the value as a <code>type</code> object:<pre class="source-code">
public List&lt;Models.Point&gt; Points
{
get =&gt; GetValue(PointsProperty) as Li<a id="_idTextAnchor700"/>st&lt;Models.Point&gt;;
set =&gt; SetValue(PointsProperty, value);
}</pre></li> </ol>
<p>In order to display <code>Points</code>, we need to convert them to <code>MapElements</code>. This is accomplished using a <code>BindingProperty</code> event called <code>PropertyChanged</code>. <code>PropertyChanged</code> is fired every time <code>BindingProperty</code> changes. To add the event and convert <code>Points</code> to <code>MapElements</code>, add the following highlighted code to the class:</p>
<pre class="source-code">
public readonly static BindableProperty PointsProperty = BindableProperty.Create(nameof(Points), typeof(List&lt;Models.Point&gt;), typeof(MapView), new List&lt;Models.Point&gt;(), <strong class="bold">propertyChanged: OnPointsChanged</strong>);
<strong class="bold">private static void OnPointsChanged(BindableObject bindable, object oldValue, object newValue)</strong>
<strong class="bold">{</strong>
<strong class="bold">    var map = bindable as Map;</strong>
<strong class="bold">    if (newValue == null) return;</strong>
<strong class="bold">    if (map == null) return;</strong>
<strong class="bold">    foreach (var point in newValue as List&lt;Models.Point&gt;)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Instantiate a Circle</strong>
<strong class="bold">        Circle circle = new()</strong>
<strong class="bold">        {</strong>
<strong class="bold">            Center = new Location(point.Location.Latitude, point.Location.Longitude),</strong>
<strong class="bold">            Radius = new Distance(200),</strong>
<strong class="bold">            StrokeColor = Color.FromArgb("#88FF0000"),</strong>
<strong class="bold">            StrokeWidth = 0,</strong>
<strong class="bold">            FillColor = point.Heat</strong>
<strong class="bold">        };</strong>
<strong class="bold">        // Add the Circle to the map's MapElements collection</strong>
<strong class="bold">        map.MapElements.Add(circle);</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong>
public List&lt;Models.Point&gt; Points
{
    get =&gt; GetValue(PointsProperty) as List&lt;Models.Point&gt;;
    set =&gt; SetValue(PointsProperty, value);
}</pre> <p>Now that <a id="_idIndexMarker783"/>we’ve created a custom <a id="_idIndexMarker784"/>map control, we will use it to replace the <code>Map</code> control in <code>MainView</code>. Follow these steps:</p>
<ol>
<li>In the <code>MainView.xaml</code> file, declare the namespace for the custom control.</li>
<li>Replace the <code>Map</code> control with the new control that we have created.</li>
<li>Add a binding to the <code>Points</code> property in <code>MainViewModel</code>, as shown in the following code snippet:<pre class="source-code">
&lt;ContentPage  

x:Class="MeTracker.Views.MainView"&gt;
&lt;map:Custo<a id="_idTextAnchor701"/><a id="_idTextAnchor702"/><a id="_idTextAnchor703"/><a id="_idTextAnchor704"/>mMap x:Name="Map" Points="{Binding Points}" /&gt;
&lt;/ContentPage&gt;</pre></li> </ol>
<p>This concludes this section on how to extend the <code>Maps</code> control. The final<a id="_idTextAnchor705"/> step for our app is to refresh the map when the app resumes.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor706"/>Refreshing the map when the app resumes</h2>
<p>The last thing we will do is make sure that the map is up to date with the latest points when the <a id="_idIndexMarker785"/>app is resumed. The easiest way to do this is to set the <code>MainPage</code> property in the <code>App.xaml.cs</code> file to a new instance of <code>AppShell</code>, in the same way as the constructor, as shown in the following code snippet:</p>
<pre class="source-code">
protected override void OnResume()
{
    base.OnResume();
<strong class="bold">    MainPage = new AppShell();</strong>
}</pre> <p>The <code>MeTracker</code> app is now complete – try it out. A sample screenshot is shown in <em class="italic">Figure 7</em><em class="italic">.18</em>:</p>
<div><div><img alt="" role="presentation" src="img/B19214_07_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18 – MeTracker on iOS and Android</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor707"/>Summary</h1>
<p>In this chapter, we built an app for iOS, Mac Catalyst, and Android that tracked the location of a user. When we built the app, we learned how to use maps in .NET MAUI and how to use location tracking when it’s running in the background. We also learned how to extend .NET MAUI with custom controls. With this knowledge, we can create applications that perform other tasks in the background. We also learned how to extend most controls in .NET MAUI.</p>
<p>Here are some ways you could extend this app even further:</p>
<ul>
<li>Right now, the app updates the map location when the app resumes. How could you update the map when the location changes?</li>
<li>Add a view that lists all locations from the database. Allow the user to remove a location from the list.</li>
</ul>
<p>The next project will be a weather app. In the next chapter, we will use an existing weather service API to retrieve weather data and then display that data in the app.</p>
</div>
</body></html>