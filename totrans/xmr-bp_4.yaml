- en: Chapter 4.  Building an Audio Player Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we move back to native Xamarin. We will integrate native audio
    functions for processing a sound file using the `AVFramework` in iOS with the
    `AVAudioSessions`, `AVAudioSettings`, and `AVAudioRecorder` objects. In Android
    you will use the `MediaPlayer` object from the `Android.Media` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expected knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: Some knowledge of either iOS `AVAudioSessions`, `AVAudioSettings`, and `AVAudioRecorder`,
    or the Android `MediaPlayer` and `MediaRecorder` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSLayoutConstraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inversion of control with MVVMCross
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View models with Xamarin native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSLayoutContraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVVMCross setup inside the Portable Class Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up MVVMCross with iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up MVVMCross with Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SoundHandler` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the iOS `SoundHandler` using the `AVAudioPlayer` framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mvx IoC container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The audio player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cleaner code approach to `NSLayout`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `AudioPlayerPageViewModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Android `SoundHandler` using the `MediaPlayer` framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML and Mvx bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are back to Xamarin native, it's time to get your mind out of XAML
    and back into native iOS and Android. We aren't going to spend much time on user
    interface design, but more on audio processing using the native frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are testing this application on your computer, the microphone will still
    work as it will be using your laptop's microphone.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have looked into cross-platform applications and code sharing, we are
    going to apply some of these principles to native development and setup an MVVM
    architecture. Let''s begin by setting up three different projects, an iOS, Android,
    and PCL project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solution setup](img/B05293_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inversion of control with MVVMCross
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two chapters, we looked at the IoC container and bootstrapping fundamentals;
    now it's time to use a different library for this principle with Xamarin native.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all projects, we want to import the `MVVMCross` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inversion of control with MVVMCross](img/B05293_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MVVMCross is available for `Xamarin.Forms`, `Xamarin.iOS`, `Xamarin.Android`,
    `Xamarin.Mac`, and Windows, so take your pick.
  prefs: []
  type: TYPE_NORMAL
- en: MVVMCross is set up quite differently to `AutoFac`, but the principles are the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: View-models with Xamarin native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we add the libraries, let''s start with the `AudioPlayer.Portable` project.
    Create a new folder called `ViewModels`, and add a new file called `MainPageViewModel.cs`.
    Let''s start implementing our first view-model with MVVMCross:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we built our `Xamarin.Forms` view-models, we created our own base view-model
    for handling property changes; using this library we can cut a few corners with
    base properties. `MvxViewModel` has a similar implementation with handling property
    changes; for our `MainPage`, we are going to develop the same first page as the
    last chapter, so let''s start with the private properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we are using a different `Command` type, called `MvxCommand`? It
    works very much the same as the `Xamarin.Forms.Command`. Let''s add the public
    properties and see how we handle property changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: It is exactly the same as the `set` function. We are checking whether the value
    has changed; if it has, then we set the `private` property and call `RaisePropertyChanged`.
    The only difference is we are passing an action into the function with the `public`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start building the user interface for the `MainPage`. This time,
    we are going to develop the iOS interface entirely off a `.cs` sheet. Add a new
    `.cs` file and call it `MainPage.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating the bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first step is to build the user interface. We are going to add two `UIButtons`, `UILabel`,
    and `UIImageView` to the view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the bindings for the user interface elements. Add the following
    to the bottom of the `ViewDidLoad` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we create a binding context (`BindingSet`), we will set up all the bindings
    through the binding set. The first binding is with the `description` label. The
    object we are binding too must be a string (`DescriptionMessage` is our string
    object from the view-model).
  prefs: []
  type: TYPE_NORMAL
- en: Further on, we can specify the particular properties of a UI element using the
    `For` function, and in the parameter we specify the name of the property. In our
    case, we are specifying the `Title` property of `UIButton`, then calling the `To`
    function to bind our specified string object. We have also done this with `UIViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last bindings we are using are `MvxCommands` from our view-model.
    We don't need to specify the property name for this; all we do is call the `To`
    function and specify the command in the view-model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `UIImageView` we created, we used an image called `audio.png`. You can
    put in any image you like, provided the name matches the one being loaded inside
    the `UIImage`. All resources for this example can be found via the GitHub link:
    [https://github.com/flusharcade/chapter4-audioplayer](https://github.com/flusharcade/chapter4-audioplayer).'
  prefs: []
  type: TYPE_NORMAL
- en: NSLayoutContraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a closer look at where we are initializing our UI elements. The `TranslatesAutoresizingMaskIntoConstraints`
    property is used to determine whether we are going to use `NSLayoutConstraints`
    to build our user interface. When we set it to `false`, it means we have to implement
    the layout constraints for this element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to build the user interface using layout constraints. Let''s add
    the following after the elements are added to `mainView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first two lines, we are adding constraints for the `UIView`. As the
    view contains only one `UIView`, we create two constraints for the vertical and
    horizontal properties of the `mainView` object. The `vertical` property is set
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This means `mainView` will be stretched to the entire height of the containing
    view, and the same applies for the `horizontal` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The width of the `mainView` object will be stretched to the entire width of
    the containing view. These two text lines are known as `VisualFormat.NSLayoutContraints`,
    and they use text input as a visual representation, describing how views present
    in their parent views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the other properties we pass into the `AddConstraints` function,
    we pass in `NSLayoutFormatOption` used for the view to abide by (that is, aligned
    left/top), then the metrics and `NSDictionary`, which will contain the UI elements
    involved in the constraint. You will notice some other constraints, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These constraints include padding around the UI element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can even simply place a dash character around the UI element, which will
    place a default padding of `8`.
  prefs: []
  type: TYPE_NORMAL
- en: MVVMCross setup inside the PCL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Further into the MVVMCross framework, let's begin by building the `MvxApplication`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is not the same as the application class inside a `Xamarin.Forms` application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the `CreatableTypes` function being called; the function uses
    reflection to find all classes in the core assembly that are `Creatable`, meaning
    they have a public constructor and they are not abstract. Then, following this
    function, only register the class interfaces with their names ending in `Service`
    as lazy singletons.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The lazy singleton ensures that if a class implements `IOne` and `ITwo`, then
    the same instance will be returned when resolving both `IOne` and `ITwo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more part to add to the `Application` class. We must register
    the starting point, so add the following line under the `RegisterAsLazySingleton`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Setting up MVVMCross with iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we move over to the iOS project. For each platform, we must implement a
    `Setup` class that will be used to instantiate the `MvxApplication` class. Add
    a new class called `IosSetup` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we must include a constructor that takes in an `MvxApplicationDelegate`
    and `UIWindow`; these will be passed into the base on instantiation. We also have
    two functions that are overriden as part of the `MvxIosSetup` object.
  prefs: []
  type: TYPE_NORMAL
- en: Start with the `CreateApp` function. All we are doing here is instantiating
    the `MvxApplication` class that we implemented previously. We will break this
    down into more detail when we implement the `AppDelegate` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also override the `CreateDebugTrace` functions, which will instantiate
    a new `DebugTrace` object. Firstly, let''s create a new folder called `Logging`
    inside our PCL project, add a new file called `DebugTrace.cs`, and implement the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As part of the `IMvxTrace` interface, we must implement all these functions.
    The functions are not complicated; we are simply catching errors and outputting
    text to the console when these functions are called. All the functions called
    via the `DebugTrace` object are routed via a singleton object. We will be sharing
    this object between the two platform projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now that we have completed all our MVVMCross requirements for iOS, let''s
    piece it all together via the `AppDelegate` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What exactly are we doing in the `FinishedLaunching` function?
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we instantiate our `UIWindow` to the size of the main screen bounds.
    Then we instantiate the `IosSetup` class by passing in the new `UIWindow` object,
    and call the `Initialize` function we implemented in our `MvxApplication` in the
    PCL. Then, we use the Mvx IoC container to resolve the `IMvxAppStart` interface
    and call `Start` to begin the application at our `MainPageViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We have now set up MVVMCross with our iOS project; let's go ahead
    and do the same for the Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MVVMCross with Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already completed the `PCL` setup for `MVVMCross`, we only need to create
    the setup object, which will inherit the `MvxAndroidSetup` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `AndroidSetup.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is very much the same as the iOS setup, but in the constructor we must
    pass in the Android context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the final setup on Android. We don''t normally have an application
    to override. Instead, MVVMCross by default provides a splash screen. Delete the
    `MainActivity` class that is automatically created, and replace it with a new
    activity called `SplashScreenActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t need to add anything into our constructor, but we must add the `MainLauncher
    = true` flag to the attribute to ensure this is the first thing created when the
    platform starts. We must also create the new XML view for the splash screen activity.
    For this example, we are going to create a simple screen with a `TextView`:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try creating a splash screen that will display an image to give the application
    branding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s everything; lets test run both platforms and we should now have the
    following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up MVVMCross with Android](img/B05293_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The SoundHandler interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One issue with playing audio across multiple platforms is we can't share much
    code when processing audio. We must create an interface and register implementations
    through an IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to create the `ISoundHandler` interface. In the `AudioPlayer.Portable`
    project, add in a new folder called `Sound`. In this folder, add a new file called
    `ISoundHandler.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our interface will describe all the functions we will be using to process our
    audio streams via the `AudioPlayerPage` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's go ahead and start with the iOS implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the iOS SoundHandler using the AVAudioPlayer framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AVAudioPlayer` class is the framework we will be using to play and control
    our audio streams in iOS, so let''s begin by adding a new folder called `Sound`
    to the iOS project. We then want to create a new file called `SoundHandler.cs` that
    will inherit the `ISoundHandler` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a private `AVAudioPlayer` object and add our public `IsPlaying`,
    which will hold the playing status of the audio player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add in the functions of the interface. In each function, we will be
    using the audio player object to do all our audio processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first function will load the file from the `Resources` folder. In this example,
    we are going to be loading in a Moby song (personally one of my favorites).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add in any audio file, provided the name matches the filename being
    loaded via the `NSURL` object. If you want to use the same file as this one, visit
    the GitHub link stated previously.
  prefs: []
  type: TYPE_NORMAL
- en: The second function will control starting and stopping the audio. If we click
    the play button first, it will play and set the status of `IsPlaying` to `true`.
    Then if we click the play button again, it will stop the audio and set the `IsPlaying`
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the rest of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'All of this is straightforward: our `Stop` function will stop the audio. Our
    `Rewind` function will stop the audio and set the current time to 0 (meaning the
    beginning of the audio stream). Our `Forward` function will stop the audio and
    move the current time to the end of the stream. The last two functions will set
    the current position of the audio stream to the double value passed in. This will
    be used with our progress slider; when the slider position changes, the value
    will be passed into this function to update the position of the audio stream.
    Finally, the last function will retrieve the current time value so we can update
    our user interface with this detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now that we have our sound handler implemented for iOS, we want to register
    this through the IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: The Mvx IoC container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVVMCross comes with its very own IoC container. It works exactly like our
    previous example with Autofac, but we are not going to be using modules. Let''s
    begin by registering our sound handler implementation; open our `AppDelegate.cs`
    file and create a new private function called `setupIoC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also register our view-models so we can retrieve registered interfaces
    within our view-model''s constructor. Let''s add a new folder called `IoC` inside
    our `AudioPlayer.Portable` project. Add a new file called `PortableMvxIoCRegistrations.cs`
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we must call the static function `InitIoC` from the `AppDelegate` function
    `SetupIoC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have everything we require registered inside the IoC container,
    let's begin building the `AudioPlayerPage`.
  prefs: []
  type: TYPE_NORMAL
- en: The audio player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our next step in this project is to build the user interface for controlling
    the audio. Add a new file called `AudioPlayerPage.cs` inside the `Views` folder;
    don''t forget to add the attribute above the class declaration to register the
    view-model for the MVVMCross framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have declared some local scope variables that need to be used across multiple
    functions; you will see how these will be used later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create the UI elements via the `ViewDidLoad` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have labels for displaying the current track name, the start time, and the
    end time. We also have our buttons for controlling the audio stream (play, pause,
    rewind, and forward). Finally, we have our progress slider for animating the current
    time of the audio; we are also going to be using this to change the position of
    the audio.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to add the button events for controlling some UI changes on the
    button images; add the event handler assignation under the declaration of the
    play button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TouchUpInside` event will fire every time we click the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then create the function for the event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time we click the play button, it will move the image back and forth
    between the play and pause icon. Now let''s add the rewind and forward button
    handlers; add the following lines under each UI element declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we add the event handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the play button handler, but this time we always set the
    playing status to false, and set the play button image to the play icon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all audio images, please visit the GitHub link given previously.
  prefs: []
  type: TYPE_NORMAL
- en: A cleaner code approach to NSLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On our previous screen, we built a very simple user interface using `NSLayoutContraints`.
  prefs: []
  type: TYPE_NORMAL
- en: Would you agree that the code looked quite clunky?
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `AudioPlayerPage`, we are going to use a cleaner approach to coding
    the `NSLayoutConstraints`. Firstly, create a new folder called `Extras`, and add
    a new file called `DictionaryViews.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A cleaner code approach to NSLayout](img/B05293_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This class is going to inherit the `IEnumerable` interface in order to create
    an `NSDictionary`; part of this interface is we must specify the `GetEnumerator`
    function. It will pull this from the `NSDictionary`; we also have our `Add` function,
    which simply adds a new `UIView` to the dictionary. Then we have the static implicit
    operator which will return the object as an `NSDictionary` (this is used so we
    can directly pass the object as an `NSDictionary` to the `FromVisualLayout` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go ahead and create one of these inside our `AudioPlayerPage`; paste
    the following under the declaration of the fast forward button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We now have a new `IEnumerable`/`NSDictionary` with all the required
    views to be used through the entire interface. We can directly pass this object
    into the `NSLayoutConstraint` function `FromVisualFormat` so we don''t need to
    repeat the declaration of new dictionaries when we create each `NSLayoutContraint`.
    Now add all the UI elements to the correct parent views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s build all the `NSLayoutConstraints`; our first is the `UIViewController''sUIView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We have our new approach, using the `System.Linq` function `Concat` to combine
    all the `NSLayoutContraints` required for the view. We only have to call the `AddConstraints`
    function once, and pass in one array of all the required constraints for that
    parent view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our constraint for `mainView` and `buttonView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly the same approach, but it looks much nicer and it reduces the
    number of times we call `AddConstraints`. The view only needs to add all the constraints
    once, and lay out the elements once, so it is much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final step in building the user interface is to set up the MVVMCross bindings;
    we use the same approach as the `MainPage`. Let''s create a new binding set between
    the `AudioPlayerPage` and the `AudioPlayerPageViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Before we get into creating our bindings, let's first build our `AudioPlayerPageViewModel`
    for the `AudioPlayer.Portable` project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating AudioPlayerPageViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `AudioPlayerPageViewModel` must include our `ISoundHandler` interface.
    We are going to be controlling the audio from this view-model, so our buttons
    can initiate the required events on the sound handler. Let''s begin by making
    a new file inside the `ViewModels` folder called `AudioPlayerPageViewModel.cs`,
    and implementing the private properties to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Then we must add the `public` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are only going to show two of the `public` properties as examples, as the
    code is repetitive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We also need to add these two public variables, which are going to take both
    the `CurrentTime` and `EndTime` double values and create a formatted string from
    a `TimeSpan` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we are also calling `RaisePropertyChanged` on the string inside
    the double setter? Every time we get a new current time value, the formatted string
    needs to update as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for our constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here we are pulling out the `ISoundHandler` implementation from the IoC container,
    as we will be registering this view-model inside the IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to add two new functions to the view-model, `Load` and `Dispose`.
    These two functions will be called when the `AudioPlayerPage` is shown, and when
    it disappears. They will also be used when the audio stream is started and stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first add the `Load` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `Load` function will be called when the page is shown, and when the audio
    stream starts. The function uses the `Task` framework to run a repeating loop
    in the background, so every second we will retrieve the current time of the audio
    stream from the `ISoundHandler` interface. We propagate the updates to the current
    time label on the `AudioPlayerPage` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we are using the `SynchronisationContext.Current` variable?
  prefs: []
  type: TYPE_NORMAL
- en: This is used for threading purposes so we make sure that we set our `CurrentTime`
    variable on the main UI thread. Since this loop is running on a separate thread,
    if we made changes to this variable on a separate thread, it will break the application
    because you are trying to make UI changes off the main UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `Dispose` function; this will be called every time the `AudioPlayerPage`
    disappears and when the audio stream is stopped (we don''t need to make updates
    to the UI when the audio stream is not playing). This ensures we stop the background
    loop when the page is not visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The private variable `_updating` is used to control the status of whether the
    background loop is running, so we make sure that only one background loop is running
    at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s initiate the audio commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Looking more closely at these commands, using `PlayPauseCommand` we will call
    `Load` or `Dispose` based on the playing status of the audio stream, and it will
    also call `PlayPause` on the `ISoundHandler` interface, which controls the audio
    stream. The `rewindCommand` property will set the current time to 0, set the current
    time on the audio stream to 0, and stop the background loop. The `forwardCommand`
    property will set the current time to the end duration of the audio stream (which
    it will retrieve from the `ISoundHandler` interface), set the current time on
    the audio stream to the end duration, and stop the background loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to create a `public` function to set the current time of the
    audio stream. This will be used by our progress slider every time the value changes,
    this function will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now revert back to the `AudioPlayerPage` and add the final additions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we declared a local variable before for the view-model that is bound
    to the view, we want to pull this out of the data context of the `UIView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Our local variable has the bounded view-model. We need to call some public
    methods on the view-model from our view. We must add in our event handler for
    the `ValueChanged` event on the progress slider. Add the following under the declaration
    of the progress slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create the event handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the calls to the `Load` function when the page appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Override `ViewDidDisappear` to call the `Dispose` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And create the following bindings in the binding set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We have our labels bound to the description, which are hard coded. This is why
    we must make changes to the `CurrentTime` variable on the main UI thread, because
    it affects what is displayed on the `currentLabel`. We also have our `MvxCommand`
    bindings on our audio buttons. Finally, we have our bindings on the `Value` property
    of the progress slider to match the `CurrentTime` variable, and the `MaxValue`
    to match the end time of the audio stream, so it matches the percentage playing
    time of the audio stream.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! Try running the application and playing around with the play/pause
    and progress slider functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to building the equivalent for the Android version.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Android SoundHandler using the MediaPlayer framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement the same functionality for the sound handler interface in Android,
    we will be using the the `MediaPlayer` framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new folder in the Android project called `Sound`, and create
    a new file called `SoundHandler.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The same as the iOS version, let''s add the `Load` and `PlayPause` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We have some exception handling in the `Load` function just in case for any
    reason the file doesn''t load; it will stop our app from crashing. When you place
    the `.mp3` inside the Android project, it must be placed in the `Assets` folder,
    and make sure the file build action is set to `AndroidAsset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the Android SoundHandler using the MediaPlayer framework](img/B05293_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inside our `load` function, after we initialize the `MediaPlayer` object, we
    set the stream type to `Stream.Music`, and then we use `AssestFileDescriptor`
    to retrieve the `.mp3` file. The `MediaPlayer's` source is then set to the `.mp3`
    file from `AssetFileDescriptor`. We then call `Prepare` and set the volume to
    full (1.0f).
  prefs: []
  type: TYPE_NORMAL
- en: Our `PlayPause` function is very simple; we simply check whether the audio is
    playing to determine whether we pause or start the audio stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `Stop` function requires the `Reset` function to be called on the `MediaPlayer`
    after we call `Stop`. The `Duration` and `CurrentPosition` functions require the
    value to be divided by 1,000, as the values from `MediaPlayer` are in milliseconds.
    This is the same when we call `SeekTo` on `MediaPlayer`; because we are passing
    in a value in seconds, it has to be multiplied by 1,000 to give the answer in
    milliseconds. Then on to the `Rewind` and `Forward` functions; we must `Pause`
    the audio stream first then call the `SeekTo` method to set the stream position.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We now have our Android implementation for the `ISoundHandler` interface,
    so let's get on to building the Android user interface.
  prefs: []
  type: TYPE_NORMAL
- en: XML and Mvx bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our Android user interface will start at `MainPage`, so we need to add a new
    file called `MainPage.xml`, and a new `MvxActivity` called `MainPage.cs`. Firstly,
    add in a new folder called `Views`; this is where we will be storing our `MvxActivities`.
    Let''s add a new file called `MainPage.cs` to the `Views` folder, and create a
    new file in the **Resources** | **Layout** folder called `Main.xml`. Our `Main.xml`
    is going to start with a `LinearLayout` and contain four elements: `ImageView`,
    `TextView`, and two `Buttons`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look more closely at the `local:Mvxbind` properties on the `Buttons`
    and `TextView`. This is where we will set up our bindings to the view-model. We
    must also add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: Does this look familiar?
  prefs: []
  type: TYPE_NORMAL
- en: It is the same as our XAML sheets in `Xamarin.Forms`; we must import this namespace
    so we can use the binding properties on our UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to copy all the images into the `drawable` folder before you try
    building the project.
  prefs: []
  type: TYPE_NORMAL
- en: MvxActivities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MvxActivities` are an extended object from a regular Android `Activity`; the
    app knows we are using the MVVMCross binding system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement `MainPageMvxActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to set up our IoC registrations in the IoC container when this
    activity is created. Then we simply set the content view to the XML sheet we created
    previously. Let''s test out the Android application and click run; you should
    now have a `MainPage` screen like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MvxActivities](img/B05293_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we move on to the fun part: let''s add a new `.xml` and `MvxActivity` for
    the `AudioPlayerPage`. Before we begin implementing the user interfaces for this
    page, we will need to create a custom `SeekBar`, because we want to register a
    new type of event for the `"UP"` motion event. Create a new folder called `Controls`
    and add a new file called `CustomSeekBar.cs`, then implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We need to do this custom event because we are binding the progress of the audio
    stream to the SeekBar. Since we want to control the audio position, we need to
    make sure that only this event fires when we finish moving the seek bar.
  prefs: []
  type: TYPE_NORMAL
- en: Why can't we just use the `ProgressChanged` event, isn't that the same thing?
  prefs: []
  type: TYPE_NORMAL
- en: If we were to register the view-model function `UpdateAudioPosition` to the
    `ProgressChanged` event, every time the background loop updates the current time
    property, the SeekBar will call this event and try to set the audio position every
    second we update the SeekBar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s build the XML for the `AudioPlayerPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It is a fairly large `.xml` sheet. Starting from the top, we have `LinearLayout`,
    which contains `ImageView` at the very top where we will display the album art.
    We then have two `LinearLayouts`, which contain horizontal orientation for the
    three `ImageButtons` and the `TextViews`. These are stacked one under the other.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have our custom `SeekBar` at the very bottom under the `TextView`
    items. You will notice the `layout_weight` property used on the `TextView` items,
    so both have the same width. We then use `gravity` to float each label to either
    side of the `SeekBar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fantastic! Now let''s add the `MvxActivity` for the `AudioPlayerPage` to the
    `Views` folder, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It all looks very similar to the iOS page. We assign the same types of event
    for each audio button. Now add the event functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You will notice the `NoHistory` flag set to true on this `Activity`, so every
    time we load the `Activity`, it loads a new `Activity`, and does not load any
    previously created `AudioPlayerPage`. We also override the `OnDestroy` function
    so it will call the `Dispose` method on our view-model.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an equivalent to the following iOS line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much more straightforward in Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And voila! We now have our Android version.
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project and relax to one of Moby's greatest hits.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented audio on iOS and Android using `Xamarin.iOS`
    and `Xamarin.Android`. We learned how to load audio, stream audio, and process
    audio via start, stop, play, pause, rewind, and fast forward commands. We also
    built an MVVM architecture for native using MVVM Cross. In the next chapter, we
    will build an application for absorbing a web service using `Xamarin.Forms`. We
    will set up a `ListView` and create an `ObservableCollection` for displaying JSON
    objects.
  prefs: []
  type: TYPE_NORMAL
