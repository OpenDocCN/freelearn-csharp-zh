- en: Adding Audio and Visual Effects to Our Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 11](7098e2ac-1871-4cb2-98ba-36f3acdb0515.xhtml), *Scripting Victory
    and Defeat*, we designed and scripted our game's victory and defeat conditions.
    We updated our game's scripts to manage the Cucumber Man's health, including updating
    the HUD's health bar. We implemented our victory and end-of-game logic through
    scripting. We also implemented the lives remaining and enabled dynamic on-screen
    indicators of those lives. Lastly, we scripted the random respawning of our player
    character.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will plan and implement audio and visual effects to help
    enhance overall gameplay. Specifically, we will add audio to key events in our
    combat system and add several special effects using Unity's Particle System to
    enhance the game's visual appeal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Unity's audio system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning our game's audio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing our game's audio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Unity's lights and shadows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Unity's special effects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding visual effects to our game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering Unity's audio system
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity has an impressive array of audio capabilities. It supports 3D spatial
    sound, which provides a surround-sound effect. This gives our audio source a point
    and dimension. There are also extensive mixing and mastering capabilities in Unity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the basics of audio in Unity and take a look
    at the Audio Mixer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Unity audio basics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity supports several audio effects, including the Duck Volume Audio Effect,
    which allows us to manipulate an audio signal's volume.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The term `duck` refers to making the audio signal quieter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a variety of audio formats in Unity. You can see the four formats
    listed here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio Interchange File Format** (**AIFF**)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MP3
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ogg Vorbis** (**OGG**)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WAV
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have audio assets that are in a file format different from these four,
    you can probably use a free audio conversion tool to change the file format.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: When we import an audio file into a Unity game, the file becomes an audio clip.
    Audio clips can also be created from within Unity by using your computer's microphone.
    You can even create audio clips via scripts during your game.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, audio sources are attached to objects. These audio sources emit, or
    play, sound and audio listener components do receive the sound emitted by audio
    sources. You can think of audio listeners as the player's ears inside the game
    world, hearing what's near them. Usually, one audio listener component is attached
    to the main camera so that the sounds it picks up on align well with what is displayed
    in the game view. Listeners are also attached to objects. Let's look at an example
    to see how a GameObject, an audio source, and listeners are related.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we are creating a zoo simulation and are working on the bovine section.
    There is a holding area for cows. Cows are generally quiet, but might be noisy
    eaters. The cow would be our GameObject and it would emit a *chewing* audio clip.
    The audio clip's RAW file (that is, `chewing.aiff`) would be identified as an
    audio source component attached to the cow GameObject. Now, let's say there is
    a farmer character. We can attach a listener to the farmer, which is also an object.
    That listener is a script that performs certain actions if it hears the sound
    from the cow. Perhaps, if the listener picks up the *chewing* sound, they will
    know that more hay is needed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the relationships between the various components:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6475a6ed-0b1d-4cea-a6e9-e146cece8d05.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: You will learn how to use these components later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Unity's Audio Mixer
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity's Audio Mixer gives you the ability to mix and master audio sources and
    effects. To access the Audio Mixer, you select Window from the pull-down menu,
    and then select Audio Mixer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'When you first open the Audio Mixer window, you will see that there are no
    mixers in your project. As you can see in the following screenshot, there is a
    + icon on the far-right side of that window:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1731d2b-d6fe-4bd3-a0bb-a2006bedef64.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Clicking that icon enables you to create a mixer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have a mixer in your project, the Audio Mixer window reveals four
    sections on the left. As shown in the following screenshot, these are Mixers,
    Snapshots, Groups, and Views. All the mixers in your project will be listed here.
    The Snapshots are a collection of parameters that you can use in your mixer. An
    Audio Mixer Group can be used to modify audio source sounds prior to them reaching
    the listeners. The final section is Views. A View is just a saved state of the
    mixer groups:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8906b466-1d78-4f4f-a0ff-8f5aede6ad93.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'To the right of the Audio Mixer window, you see a single mixer in our project.
    When you click the Add button, you will see a popup, shown here, that reveals
    several options:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f84d98ad-13cf-4029-af9f-df0ea96abfa2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: We will not use these options in our game, but they are worth exploring if you
    intend to implement advanced audio effects in your game.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Planning our game's audio
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning a game's audio is an important part of game design. Just because we
    can do something with regards to audio, does not mean we should. Too much audio
    can be as off-putting as not enough.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The audio selected for the Cucumber Man game is intended to provide sufficient
    demonstration of how to import, configure, and script a game for various audio
    effects. To that end, the following audio will be implemented in our Cucumber
    Man game:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Animations that require sounds:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cucumber Man
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Jump
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Throw
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Die
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Respawn
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cucumber Beetles
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Eat
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Standing Run
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Die
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Events that require sounds:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player Defeat
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Player Victory
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will perform the implementation in the next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our game's audio
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement the audio requirements listed in the previous
    section. We will import, configure, and script our game to complete the implementation. Before
    we get started, you should open your Unity game project. Alternatively, you can
    download the Starting-Chapter-12 Unity project available from the publisher's
    companion site.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement our game''s audio in three steps, each handled in subsequent
    sections:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Importing audio assets
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Cucumber Beetle audio
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Cucumber Man audio
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing audio assets
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first task is to import the audio assets into our game project. Here are
    the steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Open the game project.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, right-click Assets and select Create | Folder.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new folder `Audio`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Audio` folder and select Import Package | Custom Package.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `cucumber_man_audio.unitypackage` file available from the publisher''s
    site for this book. You should see the following screenshot pop up in your Unity
    interface:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57ea928c-cf96-45c3-81f5-9748565bd9cb.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: In the Import Unity Package dialog window, ensure all audio files are selected
    and click the Import button.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, select the first audio file. Then, in the Inspector panel,
    use the interface to play the audio clip.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 7 for each of the nine audio clips. This will familiarize you with
    each sound and ensure they can play on your computer.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have our audio assets in our game project, let''s review how each
    of them will be used. The following table maps each audio file to the appropriate
    in-game animation or event:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '| **In-Game animation/Event** | **Related GameObject** | **Audio asset** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| Jump animation | Cucumber Man | `jump.wav` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| Throw animation | Cucumber Man | `throw.wav` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| Die animation | Cucumber Man | `cm_die.wav` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| Respawn event | Cucumber Man | `respawn.wav` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| Eat animation | Cucumber Beetle | `eating.wav` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| Standing Run animation | Cucumber Beetle | `attack.wav` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| Die on Ground animation | Cucumber Beetle | `beetle_die.wav` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| Die Standing animation | Cucumber Beetle | `beetle_die.wav` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| Player Defeat event | Cucumber Man | `game_over.wav` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| Player Victory event | Cucumber Man | `victory.wav` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: Implementing the Cucumber Beetle audio
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will configure the Cucumber Beetle prefab so that it supports
    audio when the Cucumber Beetles eat, when they run while standing, and when they
    die. Here are the steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Select the beetle prefab in the Project panel's `Assets` | `Prefabs` folder.
    If you have more than one prefab, be sure to use the one that is used in your
    game.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll to the bottom and click the Add Component button.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Audio | Audio Source.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Play On Awake box.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normally, we would assign an `AudioClip` to our Audio Source component. Since
    our Cucumber Beetles will have more than one audio clip, we will not assign one
    here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to edit the `BeetleNPC` script. Open that script file and
    make the following modifications:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following statement to the `Start()` method:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Edit the `OnTriggerEnter()` method as shown here. You will see two `audioSource.PlayOneShot()`
    statements, one each for the `eating` and `attack` audio clips:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Edit the `DestroySelfOnGround()` method, shown as follows. Here you can see
    that we added the `audioSource.PlayOneShot(die)` statement:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Edit the `DestroySelfStanding()` method as shown in the following code block.
    Here, you can see we added the `audioSource.PlayOneShot(die)` statement:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that the scripting task is complete, we need to assign the designated audio
    clips to the variables we created:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll until you see the Beetle NPC (Script) component.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `eating` audio clip from the Project panel's `Assets` | `Audio` folder
    to the appropriate spot in the Beetle NPC (Script) component.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat step 11 for the `attack` and `beetle_die` audio clips. Your Beetle NPC
    (Script) component should look like the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dec5e8a0-a8ea-4e36-b977-9ec8c7241f8c.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: All that's left is for you to test this new functionality by playing the game.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Cucumber Man audio
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will configure the Cucumber Man prefab so that it supports
    audio when the Cucumber Beetles eat, when they run while standing, and when they
    die. Here are the steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Select the Cucumber Man in the Hierarchy panel.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll to the bottom and click the Add Component button.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Audio | Audio Source.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Play On Awake box.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normally, we would assign an `AudioClip` to our Audio Source component. Since
    our Cucumber Man will have more than one audio clip, we will not assign one here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to edit the `BeetleNPC` script. Open that script file and
    make the following modifications:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a `Start()` method, shown as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Edit the `Update()` method, as shown here, so that it includes the three `audioSource.PlayOneShot()`
    statements:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Edit the `ReSpawnCucumberMan()` method as shown here. You can see that we added
    the `audioSource.PlayOneShot()` statement:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that our script changes for the `CucumberManManager` script file are complete,
    we need to assign the designated audio clips to the variables we created. Here
    are the steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll until you see the Cucumber Man Manager (Script)
    component.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `cm_die` audio clip from the Project panel's `Assets` | `Audio` folder
    to the appropriate spot in the Cucumber Man Manager (Script) component.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat step 10 for the `respawn` and `game_over` audio clips. Your Cucumber
    Man Manager (Script) component should look like this:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c0bcf2c8-12ed-4cd1-8075-33ccdc560616.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'So far, we have taking care of the dying, respawning, and game over audio clips.
    Next, we will handle the jumping and throwing audio clips:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Open the `PlayerController` script for editing.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following statement to the `Start()` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following statement to the beginning of the `Jump()` method:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following statement to the beginning of the `Throw()` method:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that our script changes for the `PlayerController` script file are complete,
    we need to assign the designated audio clips to the variables we created. Here
    are the steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll until you see the Player Controller (Script)
    component.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `jump` audio clip from the Project panel's `Assets` | `Audio` folder
    to the appropriate spot in the Player Controller (Script) component.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the `throw` audio clip from the Project pane''s `Assets` | `Audio` folder
    to the appropriate spot in the Player Controller (Script) component. Your Player
    Controller (Script) component should look like the following:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a6fc6ef-92ae-487c-a58b-3b3efd8b6b0a.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'The last audio clip for us to implement is the victory clip. We will start
    by editing the `VictoryManager` script. Open that script file and make the following
    modifications:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a  `Start()` method, as shown here:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Edit the `Update()` method, shown as follows. You will notice that we only
    added an audio clip playback for the victory condition, as we''ve already taken
    care of the defeat condition:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that our script changes for the `VictoryManager` script file are completed,
    we need to assign the victory audio clip to the variable we created. Here are
    the steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy panel, select `HUD_Canvas` | `EndOfGame` | Victory.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, scroll until you see the Victory Manager (Script) component.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the `victory` audio clip from the Project panel''s `Assets` | `Audio`
    folder to the appropriate spot in the Victory Manager (Script) component. Your Victory
    Manager (Script) component should look like the following screenshot:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9212a714-f234-4959-9246-ca31f91e0744.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: You are now ready to test this new functionality by playing the game.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent time to save both your scene and your project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Unity's lights and shadows
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lighting in games is important as it is what allows GameObjects to be seen.
    If we did not have lights in our game, the game screen would be completely black.
    In Unity, it is easy to take lighting for granted because, when we create a new
    scene, there is a default Main Camera and a Directional Light.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Shadows in game worlds are another component that can be taken for granted because
    Unity's default settings regarding shadows is often sufficient for games.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at light sources and shadows.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Adding light sources
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Unity, lights are GameObjects and are available in several different types.
    Here are the most common types of light sources:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Directional light
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point light
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spot light
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area light
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of these lights.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Directional light
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Directional light is like the sun. As you can see from the following Inspector
    panel, there are several settings that can be adjusted for Directional lights
    beyond the Transform''s Position, Rotation, and Scale:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5aa1f7d5-0c20-4063-9842-d069f0f69bac.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: The following table provides information about key settings for Directional
    lights.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Details** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| Color | You can select a color for the light to emit. For realistic outdoor
    scenes, you would probably use a light yellow color. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| Mode | You can select from Realtime, Baked, or Mixed lighting modes. When
    Realtime is selected, the direct light is computed each frame during the game.
    This provides a realistic game experience and is the default mode. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| Intensity | Adjust this to control brightness.  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| Shadow Type | There are three options here: Soft Shadows, Hard Shadows, and
    No Shadows. Soft Shadows cast soft edges and avoid the sharp-edged shadows that
    are cast using Hard Shadows. As you would expect, Soft Shadows is more processor-intensive
    than Hard Shadows. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| Realtime Shadows | This area provides additional control over your shadows.
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: Point light
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Point lights are like light bulbs without lampshades. In fact, they are the
    ideal type of light to use to simulate a small, local source of light such as
    a table lamp, wall sconce, or chandelier. As you can see in the following screenshot
    of the Inspector panel, you can modify the Range, Color, and Intensity. You can
    also select from Realtime, Baked, or Mixed render modes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7db0af5b-9b96-4196-aaa8-3b6d5b737ce7.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: Spot light
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Spot light is like a flashlight and provides cone-shaped illumination. This
    type of light is ideal for simulating flashlights, automobile headlights, plane
    lights, search lights, and Spot lights. As you can see in the following Inspector
    panel screenshot, there is a Spot Angle property. Spot lights also have properties in
    common with other types of lights.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42ea7d07-aef9-4c88-aefa-fd81b77ea634.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Area light
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Area (baked only) light is something that is used when you bake images into
    textures. This type of light is great for simulating light coming out of a building,
    such as from a window. Area lights are also good for LED stadium lighting. The
    properties Width and Height, shown in the following screenshot, are not present
    in Directional, Point, and Spot lights:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fd6f05f-5c13-49ff-92ad-8ea9b8277178.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: Shadows
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity affords us great control over shadows in our game scenes. We can control
    which objects cast shadows, which objects can receive shadows, and various properties
    of the shadows. Shadows in Unity closely replicate the way shadows exist in the
    real world. As discussed earlier in this chapter, there are soft shadows and hard
    shadows.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Soft shadows result in greater realism, but at the cost of additional computations
    and processing. Hard shadows provide less realistic, but often acceptable, shadows
    during a game and are less processor intensive. Hard shadows are easy to identify
    in a game because the shadows cast will have sharp, blocky shadow edges.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Unity's special effects
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity has a great capabilities for special effects in three categories: Particle
    System, Trail Renderer, and Line Renderer. These are available via the GameObject
    | Effects top menu.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding an Effects component to a GameObject is accomplished by using the Add
    Component | Effects option in the Inspector panel. As you can see in the following
    screenshot, the Particle System, Trail Renderer, and Line Renderer options are
    available via this method. There are also additional options, such as Lens Flare
    and Halo:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c26c352-2b90-41c1-a868-731cbb611090.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: In this section, we will discuss the Particle System and Trail Renderer effects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Particle System
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Particle Systems use a vast number of tiny 2D images or meshes in a scene to
    simulate effects such as liquids, smoke, flames, pixie dust, fireworks, and clouds.
    The basic concept is that one simple 2D image or mesh can be used in large quantities
    to create a robust and dense visual effect. These 2D images or meshes are the
    particle, and they collectively form the Particle System.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Each particle in a Particle System is rendered from a specific point and has
    a limited lifespan. How long this lifespan lasts depends on your implementation,
    but it typically only lasts a few seconds.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following Inspector panel screenshot, there are several
    parameters that allow us to customize the behavior of Particle Systems. We will
    add a Particle System to our game later in this chapter:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a37e9b8a-74bb-4d55-99bb-9d4ac63fec60.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'When we add a Particle System to our scene, Unity presents us with an interface,
    the Particle Effect panel, in the lower-right corner of the Scene view. This interface
    allows us to play, pause, and stop the Particle simulation, as well as adding
    additional parameter settings while observing the changes to the simulation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/265fc7f7-165c-4482-855c-1a6fab6d88f3.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Unity 2018, in beta at the time of this book's publication, has support for
    GPU instancing of Particle System mesh rendering, support for Orbital Velocity,
    and enables particle emitter shapes, which permits texture reading for masking
    and color tinting.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Trail Renderer
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Trail Renderer is a visual effect that creates a trail behind a GameObject
    as it moves. Classic examples of this are a jet''s afterburner, a car''s exhaust,
    and the Tasmanian Devil''s visual swoosh (dust cloud). The following Inspector
    panel screenshot illustrates the parameters that can be manipulated to customize
    a Trail Renderer:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0f6f962-5560-478e-914d-a572ebe494f9.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'The primary Trail Renderer settings are described here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| Cast Shadows | There are four options here: On, Off, Two-Sided, and Shadows
    Only. The default setting is On. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| Receive Shadows | This is an on/off toggle. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| Materials | You can select a particle shader for the material and adjust
    the size. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| Time | This setting defines the length of the trail. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| Autodestruct | You can select this option to have the trail GameObject destroyed
    once it has been idle for the number of seconds set in the Time setting. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: Adding visual effects to our game
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game already has a Directional light and, as discussed earlier in this chapter,
    it acts like the sun—shining light from high above our terrain. The shadows from
    our Cucumber Man, Cucumber Beetles, cherries, cherry trees, and cucumber patches
    can be seen on the grass. We do not need to make any changes to them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The visual effects changes we will make in this section are:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Point light to our cherry trees
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a special effect using the Particle System
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Point light to our cherry trees
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, the Cucumber Man can walk up to and under the cherry trees in our
    sandbox area. Those trees are very dense and, because the only source of light
    comes from our directional light, it is too dark for the Cucumber Man to see the
    cherries he is picking from the tree. This is just simulated for the sake of adding
    a point light. So, we will use the following steps to add a point light to our
    cherry trees in the sandbox area of our scene:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In Scene view, navigate to a cherry tree and zoom in so that you can see the
    base of the tree
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the top menu, select GameObject | Light | Point Light
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relocate the Point Light so that it is at the center of the tree trunk
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, select a Color such as a light red
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, change the Range to `11`
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, increase the Intensity to `30`
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reposition the point light so that it looks similar to the following image:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/01c70dce-f4e4-4ac1-a27d-094ac6884f9e.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: Repeat steps 1 through 7 for each cherry tree in your sandbox area. Test your
    game in game mode to see the results.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Add a special effect using the Particle System
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will add a particle system to our spawn pads so that a
    special effect is attached to them. Here are the steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: In Scene view, navigate to a spawn pad and zoom in so you can see the pad clearly.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the top menu, select GameObject | Effects | Particle System.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relocate the Particle System so that it is at the center and base of the spawn
    pad.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy panel, drag the Particle System so that it is subordinate to
    a spawn pad.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, click the settings cog in the Transform component and
    select Reset. This resets the position of the Particle System to the Transform
    of the spawn pad.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, select a Color that contrasts with the red of the spawn
    pad and the green of the terrain and cherry tree, such as blue.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, change the Max Particles to `10,000`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, increase the Shape | Shape to Edge.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，将形状改为边缘形状。
- en: In the Inspector panel, increase the Shape | Radius to 1.5.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，将形状的半径增加到1.5。
- en: 'When completed, your Particle System should look similar to the following screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成时，你的粒子系统应该看起来类似于以下截图：
- en: '![](img/8df633b0-a375-41dd-bab2-486c31106a41.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8df633b0-a375-41dd-bab2-486c31106a41.png)'
- en: Repeat steps 1 through 9 for each spawn pad in your sandbox area.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的沙盒区域中的每个出生点重复步骤1至9。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we planned and implemented audio and visual effects to enhance
    the overall gameplay. Specifically, we added audio to key events in our combat
    system and added lighting and particle special effects. We started with an overview
    of Unity's Audio System, then planned and implemented our game's audio. We then
    shifted to an introduction to lights and shadows in Unity and covered selected
    special effects. We concluded by adding a Point light to our cherry trees and
    a special effect to our spawn pads.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们计划和实现了音频和视觉效果，以增强整体游戏体验。具体来说，我们在战斗系统的关键事件中添加了音频，并添加了照明和粒子特效。我们从Unity音频系统的概述开始，然后计划和实现了我们游戏的音频。然后转向Unity中灯光和阴影的介绍，并涵盖了选定的特效。最后，我们在樱桃树上添加了一个点光源，并在出生点添加了一个特效。
- en: In [Chapter 13](e8407796-3bbd-4f54-bbcc-e1bd89284de5.xhtml), *Optimizing Our
    Game for Deployment*, you will learn how to diagnose performance problems and
    how to optimize scripts and graphic rendering. You will also learn how to deploy
    your game to multiple platforms.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](e8407796-3bbd-4f54-bbcc-e1bd89284de5.xhtml)，“优化我们的游戏以供部署”，你将学习如何诊断性能问题以及如何优化脚本和图形渲染。你还将学习如何将你的游戏部署到多个平台。
