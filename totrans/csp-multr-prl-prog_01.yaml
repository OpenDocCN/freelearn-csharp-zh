- en: Chapter 1. Understanding Multiprocessing and Multiple Cores
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 理解多处理和多核。
- en: Taking into consideration the fact that we know how to develop C# applications
    and can make the software do *what* we need it to, this book focuses on how we
    can make our C# applications perform their tasks more efficiently and faster by
    taking advantage of today's powerful hardware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们知道如何开发C#应用程序，并且可以使软件完成我们需要的任务，这本书重点介绍了我们如何通过利用今天强大的硬件来使我们的C#应用程序执行任务更加高效和快速。
- en: In the *old days*, computers had a single CPU that could run one software thread
    at a time. With sophisticated scheduling logic and fast clock and bus speeds,
    they were able to make it appear that multiple software threads were running at
    the same time, but this was just an illusion. A single CPU system with one core
    in the CPU can only execute one thread's instruction every clock cycle. A computer
    has a clock that controls the execution of the CPU. Each time the clock counts
    one unit, the CPU executes an instruction. In this model, there is limited need
    to develop applications that use multiple software threads. It can still be useful
    for UI responsiveness so that a long-running task does not *freeze* the user interface.
    We will discuss this more in [Chapter 2](ch02.html "Chapter 2. Looking at Multithreaded
    Classes – BackgroundWorker"), *Looking at Multithreaded Classes – BackgroundWorker*.
    So, multithreaded applications allow software applications to be more responsive
    to the user but not to process tasks faster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在**过去**，计算机有一个单一的CPU，一次只能运行一个软件线程。通过复杂的调度逻辑和快速的时钟和总线速度，它们能够使多个软件线程同时运行，但这只是一个错觉。具有一个核心的CPU的单CPU系统在每个时钟周期只能执行一个线程的指令。计算机有一个时钟来控制CPU的执行。每当时钟计数一个单位时，CPU就执行一条指令。在这个模型中，开发使用多个软件线程的应用程序的需求有限。它仍然可以用于UI响应性，以便长时间运行的任务不会使用户界面**冻结**。我们将在[第二章](ch02.html
    "第二章. 查看多线程类 – BackgroundWorker")中进一步讨论这个问题，*查看多线程类 – BackgroundWorker*。因此，多线程应用程序允许软件应用程序对用户更加响应，但并不加快处理任务的速率。
- en: 'We must understand some fundamentals related to the multiprocessing capabilities
    offered by modern computers. We will have to consider them in order to develop
    applications that take full advantage of parallel processing features. In this
    chapter, we will cover many topics to help us understand the new challenges involved
    in parallel programming with modern hardware. Upon reading it and following the
    exercises, we shall benefit in the following ways:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须了解一些与现代计算机提供的多处理能力相关的基本原理。我们必须考虑它们，以便开发充分利用并行处理功能的应用程序。在本章中，我们将涵盖许多主题，以帮助我们理解使用现代硬件进行并行编程的新挑战。阅读它并完成练习后，我们将从以下方面受益：
- en: Begin a paradigm shift in software design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始软件设计范式的转变。
- en: Understand the techniques needed to develop a new generation of applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解开发新一代应用程序所需的技巧。
- en: Have an idea of the performance improvements we can achieve using parallel programming
    with C# using Gustafson's and Amdahl's laws
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下，我们可以使用C#和古斯塔夫森（Gustafson）以及阿姆达尔（Amdahl）定律实现性能提升。
- en: Perform accurate response-time estimation for critical processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对关键过程进行精确的响应时间估计。
- en: Mono-processor systems – the old gladiators
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单处理器系统 – 古老的角斗士
- en: 'The **mono-processor** systems use old-fashioned, classic computer architecture.
    The microprocessor receives an input stream, executes the necessary processes,
    and sends the results in an output stream that is distributed to the indicated
    destinations. The following diagram represents a mono-processor system (one processor
    with just one **core**) with one user and one task running:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**单处理器**系统使用老式的、经典的计算机架构。微处理器接收输入流，执行必要的处理，并将结果以输出流的形式发送到指定的目的地。以下图表示了一个单处理器系统（只有一个**核心**）中运行一个用户和一个任务的情况：'
- en: '![Mono-processor systems – the old gladiators](img/8321EN_01_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![单处理器系统 – 古老的角斗士](img/8321EN_01_01.jpg)'
- en: This working scheme is known as **input-processing-output** (**IPO**) or **single
    instruction, single data** (**SISD**). This basic design represents a **von Neumann
    machine**, developed by the outstanding mathematician, John von Neumann, in 1952.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作方案被称为**输入-处理-输出**（**IPO**）或**单指令，单数据**（**SISD**）。这种基本设计代表了由杰出的数学家约翰·冯·诺伊曼（John
    von Neumann）于1952年开发的**冯·诺伊曼机**。
- en: Single core – only one warrior to fight against everybody
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单核 – 只有一个战士对抗所有人。
- en: These days, systems with a single processing core, with just one logical processor,
    are known as **single core**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，具有单一处理器核心、只有一个逻辑处理器的系统被称为**单核**。
- en: When there is only one user running an application in a mono-processor machine
    and the processor is fast enough to deliver an adequate response time in **critical**
    operations, the model will work without any major problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个用户在单处理器机器上运行应用程序，并且处理器足够快，能够在**关键**操作中提供足够的响应时间时，该模型将无任何重大问题地运行。
- en: For example, consider a robotic servant in the kitchen having just two hands
    to work with. If you ask him to do one task that requires both his hands, such
    as washing up, he will be efficient. He has a single processing core.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个厨房中的机器人服务员，他只有两只手可以工作。如果你要求他完成一项需要两只手同时进行的任务，比如洗碗，他会很有效率。他有一个单一的处理器核心。
- en: However, suppose that you ask him to do various tasks—wash up, clean the oven,
    prepare your lunch, mop the floor, cook dinner for your friends, and so on. You
    give him the list of tasks, and he works down the tasks. But since there is so
    much washing up, it's 2 p.m. before he even starts preparing your lunch—by which
    time you get very hungry and prepare it yourself. You need more robots when you
    have multiple tasks. You need multiple execution cores and many logical processors.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你要求他完成各种任务——洗碗、清洁烤箱、准备你的午餐、拖地、为你的朋友做晚餐等等。你给他任务列表，他按列表完成任务。但由于洗碗太多，他甚至在准备你的午餐之前就已经是下午2点了——这时你已经非常饿了，于是你自己准备。当你有多个任务时，你需要更多的机器人。你需要多个执行核心和许多逻辑处理器。
- en: Each task performed by the robot is a critical operation, because you and your
    friends are very hungry!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人执行的每一项任务都是一个关键操作，因为你和你的朋友都非常饿！
- en: Let's consider another case. We have a mono-processor computer and it has many
    users connected, requesting services that the computer must process. In this case,
    we have many input streams and many output streams, one for each connected user.
    As there is just one microprocessor, there is only one input channel and only
    one output channel. Therefore, the input streams are enqueued (**multiplexing**)
    for processing, and then the same happens with the output streams, but the order
    is inverted.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个案例。我们有一个单处理器计算机，并且连接了多个用户，请求计算机必须处理的服务。在这种情况下，我们有多个输入流和多个输出流，每个连接的用户一个。由于只有一个微处理器，因此只有一个输入通道和一个输出通道。因此，输入流被排队（**多路复用**）以进行处理，然后输出流也会发生同样的情况，但顺序相反。
- en: Doing a tiny bit of each task
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做一点每一项任务
- en: Why does the robot take so long to cook dinner for you and your friends? The
    robot does a tiny bit of each task and then goes back to the list to see what
    else he should be doing. He has to keep moving to the list, read it, and then
    starts a new task. The time it takes to complete the list is much longer because
    he is not fast enough to finish multiple tasks in the required time. That's **multiplexing**,
    and the delay is called **von Neumann's bottleneck**. Multiplexing takes additional
    time because you have just one robot to do everything you need in the kitchen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么机器人要花这么长时间为你和你的朋友做晚餐？机器人会做一点每一项任务，然后回到列表中看看他还应该做什么。他必须不断移动到列表中，阅读它，然后开始一项新任务。完成列表所需的时间要长得多，因为他不够快，无法在规定的时间内完成多项任务。这就是**多路复用**，延迟被称为**冯·诺伊曼瓶颈**。多路复用需要额外的时间，因为你只有一个机器人来完成厨房中所有需要做的事情。
- en: Systems that provide concurrent access to multiple users are known as **multiuser**
    systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对多个用户并发访问的系统被称为**多用户**系统。
- en: If the processor is not fast enough to deliver an adequate response time in
    every critical operation requested by each connected user, a bottleneck will be
    generated in the processor's input queue. This is well known in computer architecture
    as von Neumann's bottleneck.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理器不够快，无法为每个连接用户请求的每个关键操作提供足够的响应时间，处理器输入队列将产生瓶颈。这在计算机体系结构中被称为冯·诺伊曼瓶颈。
- en: 'There are three possible solutions to this problem, each consisting of upgrading
    or increasing one of the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有三个可能的解决方案，每个方案都包括升级或增加以下之一：
- en: The processor's speed, by using a faster robot. He will need less time to finish
    each task.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用更快的机器人来提高处理器的速度。他将需要更少的时间来完成每一项任务。
- en: The processor's capacity to process instructions concurrently (in parallel),
    that is, adding more hands to the robot and the capability to use his hands to
    do different jobs.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器处理指令的并发能力（并行），即给机器人添加更多手，以及使用他的手来完成不同工作的能力。
- en: The number of installed processors or the number of processing cores, that is,
    adding more robots. They can all focus on one task, but everything gets done in
    parallel. All tasks are completed faster and you get your lunch on time. That
    is multitasking.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装的处理器数量或处理核心数量，即增加更多的机器人。它们都可以专注于一项任务，但所有任务都是并行完成的。所有任务都更快完成，你也能准时得到午餐。这就是多任务处理。
- en: No matter which option we pick, we must consider other factors that depend particularly
    on the kind of operations performed by the computer and which could generate additional
    bottlenecks. In some cases, the main memory access speed could be too slow (the
    robot takes too much time to read each task). In other cases, the disks' subsystem
    could have bad response times (the robot takes too much time to memorize the tasks
    to be done), and so on. It is important to make a detailed analysis of these topics
    before making a decision to troubleshoot bottlenecks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择哪种选项，我们都必须考虑其他因素，这些因素特别依赖于计算机执行的操作类型，并且可能产生额外的瓶颈。在某些情况下，主存储器访问速度可能太慢（机器人花费太多时间读取每个任务）。在其他情况下，磁盘子系统可能响应时间不佳（机器人花费太多时间记住要执行的任务），等等。在做出决定以排除瓶颈之前，对这些主题进行详细分析是很重要的。
- en: Moreover, sometimes the amount of data that needs to be processed is too large
    and the problem is the transfer time between the memory and the processor, that
    is, the robot is too slow to move each hand. Poor robot! Why don't you buy a new
    model?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时需要处理的数据量太大，问题在于内存和处理器之间的传输时间，也就是说，机器人移动每只手太慢。糟糕的机器人！你为什么不买一个新模型呢？
- en: In the last few years, every new microarchitecture developed by microprocessor
    manufacturers has focused on improving the processor's capacity to run instructions
    in parallel (a robot with more hands). Some examples of these are the continuous
    duplication of processing structures such as the **Arithmetic and Logic Unit**
    (**ALU**) and **Floating Point Unit** (**FPU**), and the growing number of processing
    cores that are included in one single physical processor. Hence, you can build
    a super robot with many independent robots and many hands. Each sub-robot can
    be made to specialize in a specific task, thus parallelizing the work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，微处理器制造商开发的每一个新的微架构都专注于提高处理器并行执行指令的能力（一个有更多手的机器人）。这些例子包括对**算术逻辑单元**（**ALU**）和**浮点单元**（**FPU**）等处理结构的持续复制，以及单个物理处理器中包含的处理核心数量的增加。因此，你可以构建一个由许多独立的机器人和许多手组成的超级机器人。每个子机器人可以专门从事一项特定任务，从而并行化工作。
- en: Computers used as servers, with many connected users and running applications,
    take greater advantage of modern processors' capacity to run instructions in parallel
    as compared to those computers used by only one user. We will learn how to take
    full advantage of those features in the applications that are developed using
    the C# programming language. You want the robot to get your lunch on time!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务器使用的计算机，连接了多个用户并运行应用程序，比仅由一个用户使用的计算机更能充分利用现代处理器并行执行指令的能力。我们将学习如何利用C#编程语言开发的应用程序中的这些功能。你希望机器人准时为你准备午餐！
- en: Multiprocessor systems – many warriors to win a battle
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多处理器系统 – 多个战士赢得战斗
- en: Systems with multiple processors are a solution to von Neumann's bottleneck,
    but it is first necessary to know their detailed features in order to set aside
    some myths about them. They do not offer an immediate performance improvement
    for all applications! The dilemma is that systems with multiple processors are
    not always the most appropriate solution to a performance problem.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多处理器系统是解决冯·诺伊曼瓶颈的方案，但首先需要了解它们的详细特征，以便摒弃关于它们的某些神话。它们并不为所有应用程序提供即时的性能提升！困境在于，多处理器系统并不总是解决性能问题的最佳方案。
- en: 'There are two basic procedures to distribute tasks in systems with multiple
    processors:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有多个处理器的系统中分配任务有两种基本方法：
- en: '**Symmetrical multiprocessing (SMP)**: Any available processor or core can
    execute tasks. The most used and efficient one is **n-way symmetrical multiprocessing**,
    where *n* is the number of installed processors. With this procedure, each processor
    can execute a task isolated from the rest and also when a particular software
    is not optimized for multiprocessing systems. You have eight robots in the kitchen.
    When a robot is free, he goes back to the list to see what else he should be doing
    and starts working on the next task (8-way symmetrical multiprocessing).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称多处理（SMP）**：任何可用的处理器或核心都可以执行任务。最常用且效率最高的是*n*路对称多处理，其中*n*是安装的处理器数量。通过这种方法，每个处理器都可以独立执行任务，即使特定的软件没有针对多处理系统进行优化。厨房里有八个机器人。当一个机器人空闲时，他会回到列表中查看他应该做什么，并开始处理下一个任务（8路对称多处理）。'
- en: '**Asymmetrical multiprocessing (AMP or ASMP)**: Usually, one processor acts
    as the main processor. It works as a manager and is in charge of distributing
    the tasks to the other available processors, using different kinds of algorithms
    for this purpose. You have nine robots in the kitchen. One of them is in charge
    of task distribution (the manager robot). He is always reading the list and watching
    the other robots work (the worker robots are the processors dedicated to run tasks).
    When a robot is free, the manager robot tells him what to do next.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非对称多处理（AMP或ASMP）**：通常，一个处理器作为主处理器。它充当管理者，负责将任务分配给其他可用的处理器，为此使用不同的算法。厨房里有九个机器人。其中一个负责任务分配（管理者机器人）。他总是阅读列表并观察其他机器人工作（工人机器人是专门运行任务的处理器）。当一个机器人空闲时，管理者机器人会告诉他下一步该做什么。'
- en: The robots are expensive! You do not want to waste a robot to distribute the
    tasks. You would rather have robots that are independent. You want robots arranged
    similar to a symmetrical multiprocessing scheme.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人太贵了！你不想浪费一个机器人去分配任务。你更希望拥有独立的机器人。你希望机器人排列成类似于对称多处理方案的样式。
- en: The n-way symmetric multiprocessing procedure achieves the best performance
    and the best resources usage, where *n* can be two or more processors. With it,
    every available processor can execute tasks in an absolutely dynamic way. This
    is the reason why most multiprocessing systems use this approach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: n路对称多处理程序实现了最佳性能和最佳资源利用率，其中*n*可以是两个或更多处理器。通过它，每个可用的处理器都可以以绝对动态的方式执行任务。这就是为什么大多数多处理系统都采用这种方法。
- en: 'A symmetric multiprocessing system with many users connected or numerous tasks
    running provides a good solution to von Neumann''s bottleneck. The multiple input
    streams are distributed to the different available processors for their execution,
    and they generate multiple concurrent output streams, as shown in the following
    diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 具有许多用户连接或运行许多任务的对称多处理系统为解决冯·诺伊曼瓶颈提供了一个良好的解决方案。多个输入流被分配到不同的可用处理器进行执行，并生成多个并发输出流，如下面的图所示：
- en: '![Multiprocessor systems – many warriors to win a battle](img/8321EN_01_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![多处理器系统 – 许多战士赢得战斗](img/8321EN_01_02.jpg)'
- en: But what if there is so much washing up that it takes a single robot several
    days to complete? A bottleneck will be generated again. Are his hands as fast
    as necessary? Are his legs too slow? Is he a lazy robot?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果洗碗量如此之大，以至于单个机器人需要几天时间才能完成，瓶颈将再次产生。他的手是否足够快？他的腿是否太慢？他是一个懒惰的机器人吗？
- en: We have to take into account that if the response time of a processor to a user's
    request is not quick enough, a bottleneck will be generated again. However, it
    can also be generated by other problems along the performance waterfall. We must
    delve deeper into the process in order to understand these potential performance
    issues.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须考虑到，如果处理器对用户请求的响应时间不够快，瓶颈将再次产生。然而，它也可能由性能瀑布中的其他问题引起。我们必须深入了解过程，以了解这些潜在的性能问题。
- en: Therefore, while the number of users or the number of tasks being executed in
    a multiprocessing system increases, it is more likely to run out of processing
    capacity, among other things. If this happens, each user's tasks being executed
    will take longer to run, and for that reason, the response time will worsen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当多处理系统中的用户数量或正在执行的任务数量增加时，很可能会耗尽处理能力，以及其他一些因素。如果发生这种情况，每个用户正在执行的任务运行时间将更长，因此响应时间会变差。
- en: 'Under these circumstances, there are two possible approaches to keep the response
    time untouched:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有两种可能的方法可以保持响应时间不变：
- en: '**Replacing the existing processors with new ones (buying super robots)**:
    In order to apply this solution, there should be processors with better performance
    ratios than the ones that are currently used, or with more execution cores (to
    achieve a greater degree of parallelism). They also have to be compatible with
    the motherboard and with the sockets used by them. The great disadvantage of this
    approach is that the old processors are thrown out. It is also expensive.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用新的处理器替换现有的处理器（购买超级机器人）**：为了应用此解决方案，应该有性能比率比目前使用的处理器更好的处理器，或者拥有更多执行核心（以实现更高的并行度）。它们还必须与主板兼容，以及与它们使用的插槽兼容。这种方法的一个重大缺点是旧处理器被丢弃。这也很昂贵。'
- en: '**Adding new processors to work with the existing ones (buying new robots to
    help the existing ones)**: In order to apply this solution, there should be free
    sockets on the motherboard.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向现有处理器添加新的处理器（购买新机器人以帮助现有机器人）**：为了应用此解决方案，主板应该有空闲插槽。'
- en: Multiple core processors and hyperthreading
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多核心处理器和超线程
- en: We have discussed multiple- and single-CPU computer systems. Now, let's take
    a look at multiple core CPU's and hyperthreading. A multiple core CPU has more
    than one physical processing unit. In essence, it acts like more than one CPU.
    The only difference is that all cores of a single CPU share the same memory cache
    instead of having their own memory cache. From the multithreaded parallel developer
    standpoint, there is very little difference between multiple CPUs and multiple
    cores in a CPU. The total number of cores across all of the CPUs of a system is
    the number of physical processing units that can be scheduled and run in parallel,
    that is, the number of different software threads that can truly execute in parallel.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了多CPU和单CPU计算机系统。现在，让我们来看看多核心CPU和超线程。多核心CPU拥有多个物理处理单元。本质上，它就像多个CPU一样工作。唯一的区别是，单个CPU的所有核心共享相同的内存缓存，而不是拥有自己的内存缓存。从多线程并行开发者的角度来看，多CPU和多核心之间的差异非常小。系统所有CPU的核心总数是可以并行调度和运行的物理处理单元的数量，即可以真正并行执行的软件线程的数量。
- en: There is a slight performance bottleneck with having multiple cores in a CPU
    versus having multiple CPUs with single cores due to the sharing of the memory
    bus. For most applications, this is negligible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存总线的共享，与拥有多个单核CPU相比，在CPU中拥有多个核心会有轻微的性能瓶颈。对于大多数应用程序来说，这可以忽略不计。
- en: For the parallel developer trying to estimate performance gains by using a parallel
    design approach, the number of physical cores is the key factor to use for estimations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于试图通过使用并行设计方法来估计性能提升的并行开发者，物理核心的数量是用于估计的关键因素。
- en: 'This diagram shows three physical CPUs each having two logical cores:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了三个物理CPU，每个CPU拥有两个逻辑核心：
- en: '![Multiple core processors and hyperthreading](img/8321EN_01_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![多核心处理器和超线程](img/8321EN_01_03.jpg)'
- en: 'The following diagram shows a CPU with four logical cores, each having its
    own memory and then shared memory between them:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了一个具有四个逻辑核心的CPU，每个核心都有自己的内存，然后是它们之间的共享内存：
- en: '![Multiple core processors and hyperthreading](img/8321EN_01_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![多核心处理器和超线程](img/8321EN_01_04.jpg)'
- en: Next, let's discuss hyperthreading. This is a proprietary simultaneous multithreading
    (SMT) technology, which Intel has developed, that allows a single physical core
    in a CPU to have multiple logical cores. Each of these logical cores is called
    a **hardware thread** and can be scheduled separately by the **operating system**
    (**OS**) scheduler.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论超线程。这是一种英特尔开发的专有同时多线程（SMT）技术，它允许CPU中的单个物理核心拥有多个逻辑核心。这些逻辑核心中的每一个都称为**硬件线程**，可以被**操作系统**（**OS**）调度器单独调度。
- en: 'The OS has to implement SMT to be able to take advantage of hyperthreading
    technology, but today, most operating systems do. Even though each hardware thread
    (logical core) appears as a separate core for the OS to schedule, only one logical
    core per physical core can execute a software instruction at a time. Hyperthreading
    is explained in the following diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统必须实现SMT才能利用超线程技术，但今天，大多数操作系统都做到了。尽管每个硬件线程（逻辑核心）对于操作系统来说都表现为一个单独的核心来调度，但每个物理核心一次只能有一个逻辑核心执行软件指令。超线程在以下图中解释：
- en: '![Multiple core processors and hyperthreading](img/8321EN_01_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![多核心处理器和超线程](img/8321EN_01_05.jpg)'
- en: This is important to realize when you examine your computer hardware and estimate
    performance gains of a parallel application. For our examples of performance estimations
    using Amdahl's and Gustafson's laws, we will only be counting physical cores because
    technically logical cores, in a single physical core, cannot execute instructions
    during the same clock cycle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查计算机硬件并估计并行应用程序的性能提升时，这一点很重要。在我们使用Amdahl定律和Gustafson定律进行性能估计的例子中，我们只会计算物理核心，因为从技术上讲，在单个物理核心中，逻辑核心在同一个时钟周期内不能执行指令。
- en: Taking advantage of multiple execution cores
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用多执行核心
- en: One of the techniques to improve the processing capacity consists of increasing
    the microprocessors' working frequency (**overclocking**), which raises the number
    of instructions capable of processing in the same period. This technique has been
    used for many years and has evolved from the legendary 8086/8088 with its poor
    4.77 MHz (megahertz) to the many GHz (gigahertz) of modern microprocessors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 提高处理能力的一种技术是增加微处理器的运行频率（**超频**），这提高了在相同时间内可处理的指令数量。这项技术已经使用了多年，并从传奇的8086/8088（其频率为4.77
    MHz（兆赫兹））发展到现代微处理器的许多GHz（千兆赫兹）。
- en: Nevertheless, microprocessor manufacturers are increasingly facing difficulties
    in raising the frequencies because the manufacturing process becomes more complex
    and the generated heat is difficult to dissipate in an efficient and inexpensive
    way.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，微处理器制造商在提高频率方面越来越面临困难，因为制造过程变得更加复杂，并且产生的热量难以以高效且经济的方式散发。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Consider our robot instance again. You want to buy a single robot, but want
    him to clean the oven in 5 seconds. That is possible, but he needs plutonium as
    an energy source because he must move his arms and legs at a very high speed.
    Besides, he needs an ambient temperature of 50F (5 degrees Fahrenheit) or -15C
    (-15 degrees Celsius). Why? Well, because metals moving at very high speeds generate
    heat. You do not want a burnt robot. Moreover, plutonium is very expensive. Something
    similar happens with modern microprocessors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑我们的机器人实例。你想要购买一台单个机器人，但希望它在5秒内清洁烤箱。这是可能的，但他需要钚作为能量来源，因为他必须以非常高的速度移动他的手臂和腿。此外，他还需要环境温度为50华氏度（5度华氏度）或-15摄氏度。为什么？好吧，因为以非常高的速度移动的金属会产生热量。你不想有一个烧毁的机器人。此外，钚非常昂贵。类似的情况也发生在现代微处理器上。
- en: Therefore, the other alternative is to develop new microarchitectures; incorporating
    first duplicated, and then quadruplicated processing structures, and so on. In
    this way, there are many subprocessors in one single microprocessor's package.
    These subprocessors are known as **execution cores** or **processing cores**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，另一种选择是开发新的微架构；首先复制，然后四倍复制处理结构，依此类推。这样，一个单一的微处理器封装中就有许多子处理器。这些子处理器被称为**执行核心**或**处理核心**。
- en: Microprocessors with multiple execution cores, also known as **multicore**,
    offer many complete execution cores that are interconnected in a single package.
    Their physical look is very similar to a conventional single core microprocessor.
    Nevertheless, they are equivalent to something like two or more microprocessors
    inside a single piece of silicon, as well as many pieces of silicon interconnected
    under the same physical package. Of course, we are avoiding a full discussion
    of the deep technical issues.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多执行核心的微处理器，也称为**多核**，在一个封装中提供了许多相互连接的完整执行核心。它们的物理外观与传统的单核微处理器非常相似。然而，它们相当于在单个硅片内部以及在同一物理封装下相互连接的许多硅片。当然，我们正在避免对深层次技术问题的全面讨论。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At present, most available modern computers have microprocessors with at least
    two execution cores (dual core). Therefore, they are computers with multiprocessing
    capabilities.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，大多数可用的现代计算机都配备了至少两个执行核心（双核）。因此，它们是具有多处理能力的计算机。
- en: Ever since the rise of multiple execution cores, the possibilities of combining
    the communication architectures, the different cores owned, and shared resources
    have continued to multiply. As with everything in life, in each possibility, there
    is a trade-off between manufacturing costs and performance. For this reason, a
    new land appeared in the microprocessor world.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 自从多执行核心的兴起以来，结合通信架构、不同核心所拥有的和共享资源的可能性一直在增加。就像生活中的每一件事一样，在每一种可能性中，制造成本和性能之间都存在权衡。因此，在微处理器世界中出现了一片新天地。
- en: In some cases, each execution core includes L1 and L2 cache memories. Caches
    can be divided up into levels with smaller, faster caches accessed first, and
    slower, larger ones accessed next. An architecture can employ as many caches as
    it wants, but typically you will see two levels. This allows the architecture
    to house often-used data in a cache with lower latency for faster retrieval.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, L2 cache memories are shared between two or more cores. Therefore,
    each core will have access to the whole L2 cache.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The greater the number of resources included in each core and the fewer the
    resources shared with the others, the greater the processing speed achieved by
    each core. On the other hand, sharing resources between cores benefits applications
    not optimized for multiprocessing because they use a single execution core.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The robots' communications interface must be as efficient as possible, since
    you want the robots to do many different tasks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Achieving efficient external memory accesses is one of the most important matters
    with these microarchitectures. The communication with external memory has a great
    overhead with respect to time, compared to the internal core speed. When we design
    the most critical algorithms for our applications, we must minimize the external
    memory access in order to achieve the best performance. It is one of the main
    subjects to consider in designing applications that will be developed with parallelism
    in mind.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options available to speed up the tasks done by the robots, taking
    into account the washing-up example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Divide the washing-up into parts corresponding to the number of robots available,
    and have the robots do their own portion of the global task
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a big pile of washing-up, and have each robot pick items up from that pile
    when they have room in their sinks to do that washing-up
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The internal bus is very important, because it transports data between the different
    execution cores. Many microprocessors use one or more dedicated buses for that
    task with very high working speeds, while others establish those communications
    through the **Front Side Bus** (**FSB**), which is a less efficient way. When
    the microprocessor has more than two cores, the architecture could be any possible
    merger between the known architectures for single-and dual-core microprocessors.
    There are some microprocessors built by two pairs of cores, each one using a dedicated
    bus for the data interchange between both the cores, but with both pairs talking
    through the FSB.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: When we are optimizing applications to take full advantage of these microarchitectures,
    one of the things that we should minimize is the information going through the
    FSB. Besides, we must consider this in evaluating the optimized application's
    efficiency. If we don't, we will probably draft wrong conclusions about them and
    we will try to optimize already maximized performances (according to the underlying
    hardware architecture).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: A system with asymmetric multiprocessing based on many independent physical
    processors has many FSBs to access external memory, one for each physical processor.
    However, a system with a microprocessor having multiple cores has to share the
    FSB that acts as a great single door to the outside world and to the external
    memory. Therefore, the tasks to coordinate the activities in the execution cores
    require additional time to avoid conflicts in the shared FSB. This is an important
    difference between multiprocessing using independent physical microprocessors
    and multiple cores in one physical microprocessor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基于许多独立物理处理器的非对称多处理系统具有许多FSB来访问外部内存，每个物理处理器一个。然而，具有多个核心的微处理器的系统必须共享作为通往外部世界和外部内存的巨大单扇门的FSB。因此，协调执行核心活动的任务需要额外的时间来避免在共享FSB中的冲突。这是使用独立物理微处理器进行多处理和在一个物理微处理器中多个核心之间的重要区别。
- en: The probability that an FSB will become a bottleneck is very high when applications
    are not optimized to take full advantage of cache memories included in each core.
    Therefore, when the software is running over these microarchitectures, it should
    avoid frequent accesses to the main memory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序没有优化以充分利用每个核心中包含的缓存内存时，FSB成为瓶颈的概率非常高。因此，当软件在这些微架构上运行时，应避免频繁访问主内存。
- en: Besides, many asymmetric multiprocessing systems use duplicated communication
    channels with the main memory. This feature is not available in many multicore
    microprocessors. It makes it nearly impossible to predict the performance of applications
    in completely different system architectures. However, designing them with parallelism
    in mind will take full advantage of any feature present in the system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多非对称多处理系统使用与主内存的双倍通信通道。这个特性在许多多核微处理器中不可用。这使得预测在不同系统架构中应用程序的性能几乎不可能。然而，考虑到并行性来设计它们将充分利用系统中的任何特性。
- en: Nowadays, microprocessors with multiple execution cores are widespread. However,
    we can find many of them arranged in an n-way asymmetric multiprocessing system
    such as an 8-core system with two physical quad-core microprocessors. It is a
    very attractive setup in high-end workstations and servers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，多核执行核心的微处理器已经非常普遍。然而，我们可以发现许多微处理器被安排在一个n路非对称多处理系统中，例如具有两个物理四核微处理器的8核系统。这对于高端工作站和服务器来说是一个非常吸引人的配置。
- en: In the coming years, microprocessors are going to include more and more processing
    cores. Modern operating systems are already optimized to take advantage of their
    parallel processing capabilities. We must optimize our applications to take full
    advantage of them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来几年里，微处理器将包含越来越多的处理核心。现代操作系统已经优化了以利用它们的并行处理能力。我们必须优化我们的应用程序以充分利用它们。
- en: Analyzing the microarchitectures used in modern microprocessors is a topic for
    an entire book. However, we needed some knowledge about them in order to understand
    the parallel processing capabilities that are useful for our goals.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 分析现代微处理器中使用的微架构是一个完整的书籍主题。然而，我们需要了解它们的一些知识，以便理解对我们目标有用的并行处理能力。
- en: Do not expect plutonium robots! They are still too expensive to maintain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不要期待钚机器人！它们维护起来仍然太昂贵。
- en: Examining our hardware
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的硬件
- en: As we will see with some of the tools used to analyze a system's hardware, most
    count logical cores and not just physical cores. This is important to remember
    because of the limitation mentioned in the previous section where a CPU only executes
    an instruction each clock cycle for a physical core.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将通过用于分析系统硬件的一些工具看到的那样，大多数系统只计算逻辑核心而不是物理核心。这一点很重要，因为在前一节中提到的限制中，CPU在每个时钟周期只为一个物理核心执行一条指令。
- en: 'Let''s take a second to look at some examples. First, if you are on a Windows
    machine (which we will assume for the examples in this book), you can right-click
    on the Taskbar and run the Task Manager. The following is a sample from my computer:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间看看一些例子。首先，如果你在一台Windows机器上（我们将假设这本书中的例子都是基于Windows的），你可以右键单击任务栏并运行任务管理器。以下是我电脑上的一个示例：
- en: '![Examining our hardware](img/8321EN_01_06.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![检查我们的硬件](img/8321EN_01_06.jpg)'
- en: When looking at the **Performance** tab, you can see it shows four CPUs running.
    This would lead us to believe that my system has four CPUs in it. But in fact
    it actually has one CPU that has two cores (physical) with each having two **hardware
    threads** (logical cores). So, the Task Manager in Windows shows us how many logical
    cores are there in our system. This is the number of schedulable hardware threads
    the system scheduler can utilize.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看**性能**标签时，你可以看到它显示了四个正在运行的CPU。这可能会让我们认为我的系统中有四个CPU。但实际上，它实际上只有一个具有两个核心（物理）的CPU，每个核心都有两个**硬件线程**（逻辑核心）。因此，Windows的任务管理器显示了我们系统中有多少逻辑核心。这是系统调度器可以利用的可调度硬件线程的数量。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**CPU-Z** is a handy utility to analyze the hardware of a computer in order
    to find information about a computer. You can download this free software from
    [http://www.cpuid.com/](http://www.cpuid.com/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**CPU-Z**是一个方便的工具，可以分析计算机的硬件以获取有关计算机的信息。你可以从[http://www.cpuid.com/](http://www.cpuid.com/)下载这款免费软件。'
- en: 'Here is the output from CPU-Z for my computer:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我电脑的CPU-Z输出结果：
- en: '![Examining our hardware](img/8321EN_01_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![检查我们的硬件](img/8321EN_01_07.jpg)'
- en: As you can see from the bottom of the CPU-Z output, I have **1** CPU with **2**
    cores and **4** hardware threads. It is important to understand how many CPUs,
    physical cores, and hardware threads a system has so you can properly estimate
    performance gains from parallel development. In the next sections, we will examine
    several methods to predict this performance gain based on the number of physical
    cores. This will also help you understand the gains possible by "throwing more
    hardware" at a software application designed with parallelism.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从CPU-Z输出的底部所示，我有一个**1**个CPU，**2**个核心和**4**个硬件线程。了解系统有多少CPU、物理核心和硬件线程非常重要，这样你可以正确估计并行开发带来的性能提升。在接下来的几节中，我们将检查几种基于物理核心数量预测这种性能提升的方法。这也有助于您了解通过向设计有并行性的软件应用程序“投入更多硬件”可能获得的收益。
- en: OS scheduler operations
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统调度器操作
- en: So far we have been discussing hardware and the number of CPUs, hardware cores,
    and logical cores; now, let's transition to software threads and the OS. A software
    application or service can run in one or many processes and threads. Typically,
    a **software application** has a user interface and is run by a user of the computer,
    while a **software process** is run by the OS and runs in the background. Both
    of these are types of software that are being executed by the computer they are
    running on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在讨论硬件和CPU、硬件核心和逻辑核心的数量；现在，让我们转向软件线程和操作系统。一个软件应用程序或服务可以在一个或多个进程和线程中运行。通常，一个**软件应用程序**有一个用户界面，并由计算机用户运行，而一个**软件进程**由操作系统运行并在后台运行。这两种都是计算机上正在执行的软件类型。
- en: Each **application** or **service** in turn has one or several processes that
    they actually execute inside. **Processes** are the running objects of an application
    or service. Also, each process has one or many execution threads (or software
    threads). The **threads** are the items that the scheduler schedules on the cores.
    I know this might seem confusing but it is important to understand the hardware
    from the ground up and how many physical cores can execute a software instruction,
    and the software from the top-down to each software thread that executes on a
    core.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个**应用程序**或**服务**都会有一个或多个它们实际执行的进程。**进程**是应用程序或服务的运行对象。此外，每个进程都有一个或多个执行线程（或软件线程）。**线程**是调度器在核心上安排的项目。我知道这可能会让人感到困惑，但了解硬件从底层到顶层的结构以及物理核心可以执行多少软件指令，以及从软件层面到每个在核心上执行的软件线程，这一点非常重要。
- en: The **scheduler** for an operating system is the subsystem of the OS that manages
    all of the software threads currently running and allocates execution time on
    the cores (both physical and logical) of the computer. Execution time is divided
    up in machine cycles, and a **machine cycle** is a tick of the computer's clock.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的**调度器**是其管理当前所有运行的软件线程并分配计算机核心（包括物理和逻辑核心）执行时间的子系统。执行时间被划分为机器周期，而**机器周期**是计算机时钟的一次滴答。
- en: The scheduler determines which software threads run on which core (physical)
    each clock cycle. So, during each clock cycle in a computer, each core can execute
    an instruction of a software thread. Remember that using hyperthreading technology,
    the scheduler treats each logical core as a physical core. But in actuality, in
    each clock cycle, each physical core executes a single software thread's instruction.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Also important in our parallel development and estimation of performance gains
    is that we are assuming in our estimates that all hardware cores are available
    to our software application each clock cycle. In reality, most computers have
    many processes running at a given time and utilize some of the execution time
    of a core.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows, the Task Manager provides some useful information to see what is
    running and consuming hardware resources. We have already looked at the **Performance**
    tab. Now, let''s look at the **Processes** tab:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![OS scheduler operations](img/8321EN_01_08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: This tab in the Task Manager shows various information about the processes running
    on a Windows computer. As you can see from the **Threads** column in the preceding
    screenshot, some processes have many threads of execution at any given time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: You can go to the **View** menu and select **Select Columns** to change which
    columns of information are displayed by the Task Manager for each process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Designing for concurrency
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an understanding of today's hardware capabilities (multiple
    processors, multiple physical cores, and multiple logical cores (hardware threads))
    and OS schedulers, let's discuss how to take advantage of this in our software
    development.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We know that our hardware has the ability to execute multiple instructions at
    the same time. As we will see in later chapters, .NET provides several classes
    and libraries that allow us to develop software that runs in multiple threads
    instead of a single software thread. The question is then, when does it make sense
    to develop our software to run in multiple threads concurrently and what kind
    of performance gains can we expect?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: When designing for concurrency, we should look at a high-level abstraction of
    the application's requirements. Look at what functions the application performs
    and which functions can operate in parallel without affecting other functions.
    This will help us decide how to determine the amount of parallel operations we
    can design into the application. We will discuss in detail the .NET classes to
    implement both heavyweight concurrency (the `Thread` class) and lightweight concurrency
    (Task Parallel Library) in later chapters; but for now, we need to determine what
    and how much of our application can happen in parallel.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the application takes a list of items and encodes each item
    into an encrypted string, can the encoding of each item be run in parallel independent
    of the encoding of another item? If so, this "function" of the application is
    a good candidate for concurrency. Once you have defined all of the high-level
    functions an application must perform, this analysis will determine the amount
    of parallelism that the application can benefit from.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个应用程序接收一个项目列表并将每个项目编码成一个加密字符串，那么每个项目的编码是否可以独立于另一个项目的编码并行运行？如果是这样，这个应用程序的“功能”就是一个很好的并发候选。一旦你定义了应用程序必须执行的所有高级功能，这种分析将确定应用程序可以从中受益的并行程度。
- en: The following is a simple example of a parallel design where some of the functions
    operate sequentially and others in parallel. As we will see in the next section,
    once we can define how much of the application functions concurrently versus sequentially,
    then we can understand the performance gains we can expect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个并行设计的简单例子，其中一些功能顺序执行，而其他功能并行执行。正如我们将在下一节中看到的，一旦我们能够定义应用程序功能是并行还是顺序执行的比例，我们就可以了解我们可以期望的性能提升。
- en: '![Designing for concurrency](img/8321EN_01_09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![为并发设计](img/8321EN_01_09.jpg)'
- en: 'A lot of parallel designs employ some sort of pipelining design where some
    sequential work is performed, then some parallel work, then some sequential work,
    and so on. The preceding diagram shows a simple model for a pipeline design. Another
    popular concurrent design pattern is the **producer-consumer** model, which is
    really just a variation on the pipeline model. In this design, one function of
    the application *produces* an output that is *consumed* by another function of
    the application. The following is a diagram of this design pattern. In this example,
    each function can operate in parallel. The **Load Image** function *produces*
    image files to be *consumed* by the **Scale Image** function. The **Scale Image**
    function also produces thumbnail images to be consumed by the **Filter Image**
    function, and so on. Each of the function blocks can run in multiple concurrent
    threads because they are independent of each other:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 许多并行设计采用某种流水线设计，其中一些工作顺序执行，然后是并行工作，然后是顺序工作，如此循环。前面的图示展示了流水线设计的一个简单模型。另一种流行的并发设计模式是**生产者-消费者**模型，这实际上只是流水线模型的一种变体。在这个设计中，应用程序的一个功能*生产*一个输出，由应用程序的另一个功能*消费*。以下是这个设计模式的图示。在这个例子中，每个功能都可以并行操作。**加载图像**功能*生产*图像文件，由**缩放图像**功能*消费*。**缩放图像**功能也生产缩略图，由**过滤图像**功能*消费*，等等。由于这些功能块相互独立，它们可以运行在多个并发线程中：
- en: 'The following diagram illustrates the sequential operation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了顺序操作：
- en: '![Designing for concurrency](img/8321EN_01_10.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![为并发设计](img/8321EN_01_10.jpg)'
- en: 'The following diagram illustrates the parallel pipeline design:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了并行流水线设计：
- en: '![Designing for concurrency](img/8321EN_01_11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![为并发设计](img/8321EN_01_11.jpg)'
- en: Estimating performance improvements
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 估计性能提升
- en: One of the most common mistakes in designing or upgrading systems with multiple
    processors is making linear projections in their processing speed. It is very
    common to consider that each additional processor in the system will increase
    the performance in a way that is directly proportional to its processing capacity.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计或升级多处理器系统时，最常见的错误之一是在处理速度上进行线性预测。通常认为，系统中每个额外的处理器都会以与其处理能力成正比的方式提高性能。
- en: For instance, when we have a system with just one processor, and if we add three
    more, we will not have four times the performance. This is because each time we
    add a processor, the time they dedicate to coordinate their work and the task
    assignment process increases. Therefore, because of the increased processing power
    spent on managing tasks, their performance will not increase linearly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们有一个只有一个处理器的系统时，如果我们再添加三个，我们不会得到四倍的性能。这是因为每次我们添加一个处理器，它们用于协调工作和任务分配过程的时间就会增加。因此，由于用于管理任务的额外处理能力增加，它们的性能不会线性增长。
- en: The additional robots added to the kitchen must talk among themselves to coordinate
    their work.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到厨房的额外机器人必须相互交流以协调它们的工作。
- en: 'The coordination costs and the performance increment depend upon a number of
    factors including the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 协调成本和性能提升取决于许多因素，包括以下：
- en: '**The operating system and its management procedures to coordinate and distribute
    processes and threads among multiple processors**: This is the robots'' accuracy
    in assigning the appropriate task to the most capable robot model for that particular
    task.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The level of optimization to run multiple processors offered by applications**:
    This is one of the most relevant points, even when we are using an n-way symmetric
    multiprocessing scheme. In this book, we will learn to reach high levels of optimizations
    for concurrency in our software. This can be correlated to the robots'' abilities
    to work with other robots on the same tasks.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The microprocessors'' microarchitecture**: This corresponds to how fast the
    robots move their hands and legs, and do similar tasks.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The speed of the memory subsystem shared by the microprocessors**: This is
    the robots'' communications interface.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The speed of the I/O buses shared by the microprocessors**: This is the robots''
    efficiency and precision in managing their hands and legs to do each task (mopping
    the floor and cooking, for example).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these items represent a problem when we design or upgrade a machine, because
    we need answers to the following questions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: How many microprocessors do we need when the number of users increases? How
    many robots do you need according to the number of friends/tasks?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many microprocessors do we need to increase an application's performance?
    How many robots do you need to accelerate the wash-up time?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many microprocessors do we need to run a critical process within a specific
    time period? How many robots do you need to clean the oven in 5 minutes?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need a reference, similar to the one offered in the following table, in
    which we can see the coordination cost and the relative performance for an increasing
    number of processors:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| Number of processors | Coordination cost | Relative performance |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '|   | **In relative processors** | **In percentage** | **In relative processors**
    | **In percentage** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.00 | 0% | 1.00 | 100% |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.09 | 5% | 1.91 | 95% |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0.29 | 10% | 2.71 | 90% |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0.54 | 14% | 3.46 | 86% |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0.84 | 17% | 4.16 | 83% |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1.17 | 19% | 4.83 | 81% |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1.52 | 22% | 5.48 | 78% |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| 8 | 1.90 | 24% | 6.10 | 76% |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| 9 | 2.29 | 25% | 6.71 | 75% |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| 10 | 2.70 | 27% | 7.30 | 73% |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| 11 | 3.12 | 28% | 7.88 | 72% |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| 12 | 3.56 | 30% | 8.44 | 70% |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| 13 | 4.01 | 31% | 8.99 | 69% |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| 14 | 4.47 | 32% | 9.53 | 68% |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| 15 | 4.94 | 33% | 10.06 | 67% |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| 16 | 5.42 | 34% | 10.58 | 66% |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| 17 | 5.91 | 35% | 11.09 | 65% |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| 18 | 6.40 | 36% | 11.60 | 64% |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| 19 | 6.91 | 36% | 12.09 | 64% |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| 20 | 7.42 | 37% | 12.58 | 63% |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| 21 | 7.93 | 38% | 13.07 | 62% |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| 22 | 8.46 | 38% | 13.54 | 62% |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| 23 | 8.99 | 39% | 14.01 | 61% |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| 24 | 9.52 | 40% | 14.48 | 60% |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| 25 | 10.07 | 40% | 14.93 | 60% |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| 26 | 10.61 | 41% | 15.39 | 59% |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| 27 | 11.16 | 41% | 15.84 | 59% |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| 28 | 11.72 | 42% | 16.28 | 58% |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| 29 | 12.28 | 42% | 16.72 | 58% |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| 30 | 12.85 | 43% | 17.15 | 57% |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 12.85 | 43% | 17.15 | 57% |'
- en: '| 31 | 13.42 | 43% | 17.58 | 57% |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 31 | 13.42 | 43% | 17.58 | 57% |'
- en: '| 32 | 14.00 | 44% | 18.00 | 56% |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 14.00 | 44% | 18.00 | 56% |'
- en: This table was prepared taking into account an overall average performance test
    with many typical applications well optimized for multiprocessing, and the most
    modern processors with multiple execution cores used in workstations and servers.
    These processors were all compatible with AMD64 or EMT64 instruction sets, also
    known as x86-64\. We can take these values as a reference in order to have an
    idea of the performance improvement that we will see in optimized applications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此表是在考虑了许多典型应用程序的整体平均性能测试，以及工作站和服务器中使用的最现代的多执行核心处理器的情况下准备的。这些处理器都兼容AMD64或EMT64指令集，也称为x86-64。我们可以将这些值作为参考，以便了解我们在优化应用程序中将会看到的性能提升。
- en: 'As shown in the previous table, the coordination cost grows exponentially as
    the number of processors or cores increases. The following graph shows the relative
    performance versus the number of processors:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，随着处理器或核心数量的增加，协调成本呈指数增长。以下图表显示了相对性能与处理器数量的关系：
- en: '![Estimating performance improvements](img/8321EN_01_12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![估算性能提升](img/8321EN_01_12.jpg)'
- en: As we can see in the preceding screenshot, the relative performance grows logarithmically
    as the number of processors or cores increase.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，随着处理器或核心数量的增加，相对性能呈对数增长。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following are the formulas used to calculate the values presented in the
    table and the graphs:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用以计算表中值和图表中值的公式：
- en: '*Coordination cost = 0.3 x logarithm (number of processors) x (number of processors
    - 1)*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*协调成本 = 0.3 x 对数（处理器数量）x（处理器数量 - 1）*'
- en: '*Relative performance = number of processors - coordination cost*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*相对性能 = 处理器数量 - 协调成本*'
- en: The percentages are the result of the division between the coordination cost
    or the relative performance and the total number of microprocessors installed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比是协调成本或相对性能与安装的总微处理器数量的比值。
- en: Nowadays, the problem is that without many concurrent users, multiple processor
    systems have not proved to be as useful as expected. The use of machines equipped
    with more than one processor in workstations used by just one user is meaningful
    only when the applications executed are designed to work with multiple processors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是没有许多并发用户，多处理器系统并没有证明像预期的那样有用。在仅由一个用户使用的工作站中，配备一个以上处理器的机器的使用只有在执行的应用程序设计为与多个处理器一起工作时才有意义。
- en: Most applications designed for a single user are not optimized to take full
    advantage of multiple processors. Therefore, if the code is not prepared to use
    these additional processors, their performance will not improve, as was explained
    earlier.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数为单个用户设计的应用程序都没有优化以充分利用多个处理器。因此，如果代码没有准备好使用这些额外的处理器，其性能将不会提高，正如之前所解释的。
- en: But, why does this happen? The answer is simple. The process to develop applications
    that take full advantage of multiple processors is much more complex than traditional
    software development (this book will show how to make this task much easier).
    With the exception of specialized applications requiring a lot of processing capacity
    and those dedicated to resolving complex calculations, most applications have
    been developed using a traditional, linear programming scheme.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为什么会这样呢？答案很简单。开发充分利用多个处理器的应用程序的过程比传统的软件开发过程要复杂得多（本书将展示如何使这项任务变得更容易）。除了需要大量处理能力的专业应用程序和那些专门用于解决复杂计算的应用程序之外，大多数应用程序都是使用传统的、线性的编程方案开发的。
- en: Nevertheless, the release of physical microprocessors with multiple logical
    execution cores lead to the widespread availability of multiprocessing systems
    and an urgent need to take full advantage of these microarchitectures.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，具有多个逻辑执行核心的物理微处理器的发布导致了多处理器系统的广泛应用和充分利用这些微架构的迫切需求。
- en: 'A system with multiple processors can be analyzed and measured by the following
    items:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下项目分析和衡量具有多个处理器的系统：
- en: '**Total number of processors and their features**: This is the total number
    of robots and their features.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器总数及其特性**：这是机器的总数及其特性。'
- en: '**Processing capacity (discounting the coordination overload)**: This is the
    robots'' speed at working on each task (without communicating).'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microarchitecture and architecture**: This is the number of execution cores
    in each physical microprocessor and the number of physical microprocessors with
    each microarchitecture. These are the subrobots in each robot, the number of hands,
    legs, and their speed.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared memory''s bus bandwidth**: This is the maximum number of concurrent
    communications that the robots can establish.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I/O bus bandwidth**: This is the robots'' efficiency, precision, and speed
    in managing their hands and legs concurrently to do each task.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bandwidth between processors**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: This bus allows the processors to establish a fluid communication between them.
    It is also known as the **inter-processor bus**. In some microarchitectures, this
    bus is the same as the FSB. It competes with the outputs to the microprocessors'
    outside world and therefore steals available bandwidth. The great diversity in
    microarchitectures makes it difficult to foretell the performance of the applications
    optimized for multiprocessing in every running context that is possible in the
    modern computing world.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: We are considering neither the storage space nor the amount of memory. We are
    focused on the parameters that define the operation and the performance of multiple
    processors.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Amdahl's law
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Amdahl's law is one of the two laws of parallel optimization that is used to
    help determine the expected performance gains with parallel computer designs,
    for both hardware and software.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Amdahl's law is a formula to help estimate the performance gains to be expected
    in an application given the amount of the application that is executed concurrently
    and the number of physical cores in the machine.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Gene Amdahl is a computer architect who in 1967 presented his algorithm to compute
    the maximum expected performance improvement that can be expected when part of
    a system is written for parallelism. The algorithm calculates the expected speedup
    as a percentage.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'This law takes into account the number of physical cores of execution, *N*,
    the percentage, *P*, of the application that is concurrent, and the percentage,
    *B*, that is serial. The time it takes to process when *N* cores are being used
    is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '*T (N) = T(1) x (P + 1/Nx(1-N))*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the maximum speedup (*N*) would be calculated as:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '*Speedup (N) = T(1)/T(N) = T(1)/T(1)(B+1/N(1-P)) = 1/(P+1/N(1-P))*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'So, Amdahl''s law states that if, for example, 50 percent of an application
    is run sequentially, 50 percent is concurrent, and the computer has two cores,
    then the maximum speedup is:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '*Speedup = 1/((1-.50)+.5/2) = 1.333*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: So, if the task took 100 execution cycles sequentially, then it will take 75
    cycles with 50 percent concurrency because *75 (work units) x 1.33333 (percentage
    speedup) = 100 (work units)*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph shows the predicted speed increase of an application based
    on the number of additional processors and the percentage of the code that can
    run in parallel:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了基于额外处理器的数量和可以并行运行的代码百分比的预测速度增加：
- en: '![Amdahl''s law](img/8321EN_01_13.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Amdahl定律](img/8321EN_01_13.jpg)'
- en: This law allows you to be able to estimate the performance gain of concurrency
    and to determine if the benefits are worth the extra complexity it adds to development,
    debug, and support. The extra costs of development, debug, and support have to
    be considered when developing a parallel software application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这一定律使你能够估计并发性能提升，并确定这些好处是否值得它为开发、调试和支持带来的额外复杂性。在开发并行软件应用程序时，必须考虑开发、调试和支持的额外成本。
- en: Gustafson's law
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gustafson定律
- en: Gustafson's law tries to address a shortfall of Amdahl's law by factoring in
    the scale of a problem. Gustafson was under the assumption that the problem size
    is not fixed but grows (scales). Amdahl's law calculates the speedup of a given
    problem size per the number of execution cores. Gustafson's law calculates a scaled
    speedup.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Gustafson定律试图通过考虑问题的规模来解决Amdahl定律的不足。Gustafson假设问题规模不是固定的，而是增长的（可缩放的）。Amdahl定律根据执行核心的数量计算给定问题大小的速度提升。Gustafson定律计算缩放速度提升。
- en: 'Gustafson''s law is: *S (P) = P – a * (P – 1)* where *S* is the speedup percentage,
    *P* is the number of processing cores, and *a* is the percentage of concurrency
    of the application:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Gustafson定律是：*S(P) = P – a * (P – 1)* 其中 *S* 是速度提升百分比，*P* 是处理核心的数量，*a* 是应用程序的并发百分比：
- en: '![Gustafson''s law](img/8321EN_01_14.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Gustafson定律](img/8321EN_01_14.jpg)'
- en: You will notice that the curves for a given percentage of concurrency do not
    level off in Gustafson's calculation versus Amdahl's.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在Gustafson的计算中，给定并发百分比的曲线与Amdahl的计算相比并没有达到水平。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about multiprocessor and multicore hardware
    architectures and how the operating system scheduler manages them. We also learned
    how to design a software application for parallel operation and the performance
    gains we can expect from this. This chapter prepared us for the rest of the book
    and showed us the possibilities today's hardware can give the software developer
    if they are aware of the potential that multiple CPUs and multiple cores bring.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于多处理器和多核硬件架构的知识，以及操作系统调度器如何管理它们。我们还学习了如何设计用于并行操作的软件应用程序，以及我们可以从这个中期待的性能提升。本章为我们整本书的其余部分做好了准备，并展示了如果软件开发者意识到多CPU和多核带来的潜力，今天的硬件可以为软件开发者提供哪些可能性。
- en: Now that we've learned about the principles of multiprocessing and multiple
    cores, we're ready to learn the main components of a parallel program, the processes
    and the threads, which is the topic of the next chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了多处理和多核原理，我们准备学习并行程序的主要组件，即进程和线程，这是下一章的主题。
