- en: '*Chapter* *5*: Asynchronous Programming with C#'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET `async` and `await` keywords, was introduced in .NET Framework 4.5\.
    The C# language’s support for these keywords was released at the same time in
    C# 5\. Now, a decade later, the TAP model is an integral part of most .NET developers’
    toolsets.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain asynchronous programming in C#, explore how to use
    `Task` objects, and delve into best practices of using `async` and `await` for
    **I/O-bound** and **CPU-bound** scenarios with .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: More about asynchronous programming in .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Task objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interop with synchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple background tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a deeper understanding of asynchronous
    programming and should feel confident enough to add advanced async features to
    your team’s projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using the .NET **command-line interface** (**CLI**)
    and Visual Studio Code to build and run the sample projects. To follow along with
    the examples, the following software is recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code version 1.65 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 version 17.0 or later if you
    are using Windows 10 or 11, Visual Studio 2022 for Mac on macOS 10.13 or later,
    or JetBrains Rider will work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by working our way through some examples that use the TAP
    model with `async` and `await`.
  prefs: []
  type: TYPE_NORMAL
- en: More about asynchronous programming in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of scenarios where async code is usually introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '**I/O-bound operations**: These involve resources fetched from the network
    or disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU-bound operations**: These are in-memory, CPU-intensive operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will create some real-world examples that use `async` and
    `await` for each type of operation. Whether you are waiting for an external process
    to complete or performing CPU-intensive operations within your application, you
    can leverage asynchronous code to improve your application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at some examples of I/O-bound operations.
  prefs: []
  type: TYPE_NORMAL
- en: I/O-bound operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are working with I/O-bound code that is constrained by file or network
    operations, your code should use `async` and `await` to wait for the operations
    to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET methods to perform network and file I/O are asynchronous, so the use
    of `Task.Run` will not be necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadToEndAsync` method, splits the text where `Environment.NewLine` characters
    are found, and returns the data as a `List<string>` instance. Each line of text
    from the file is an item in the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`HttpClient` class to download a file from the provided URL with the `await`
    keyword before splitting and returning the lines of text in a list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Those are some common I/O-bound operations, but what is a CPU-bound operation
    and how does it differ?
  prefs: []
  type: TYPE_NORMAL
- en: CPU-bound operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, your application is not waiting for an external process to complete.
    The application itself is performing a CPU-intensive operation that takes time
    to complete, and you want the application to remain responsive until the operation
    has finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have a method that accepts a `List<string>` instance where
    each item in the list contains an XML representation of this `JournalEntry` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume that `EntryText` can be extremely large because some users who
    write in the journal application will add dozens of pages of text to a single
    entry. Each entry is stored in a database as XML and the application that loads
    the entries has a `DeserializeEntries` method to deserialize each XML string and
    return the data as a `List<JournalEntry>` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After months of adding journal entries, users are complaining about the time
    it takes to load the existing entries. They would like to start creating a new
    entry while the data is loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, using asynchronous .NET code can keep an application’s user interface
    responsive while waiting for a long-running process to complete. The thread is
    free to perform other work until the non-blocking call is completed. By adding
    an async method named `DeserializeJournalDataAsync` that calls the existing method
    with an awaited `Task.Run` method, the client code can remain responsive while
    users create new journal entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re working with serialized data in JSON format instead of XML, the synchronous
    and asynchronous methods of deserialization are very similar. This is because
    .NET provides both the `Deserialize` and `DeserializeAsync` methods in the `System.Text.Json.JsonSerializer`
    class. Here are both methods with their differences highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `Deserialize` method accepts `string`, but `DeserializeAsync` does not.
    Instead, we must create a `MemoryStream` instance from the `jsonEntry` string
    to pass to `DeserializeAsync`. Other than that, only the return types of the methods
    differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s wrap up this section by looking at one more method for handling JSON
    deserialization of a list of journal entries. In this example, the method that
    deserializes the data only processes a single JSON entry. A parent method named
    `GetJournalEntriesAsync` uses a LINQ `Select` operator to call `DeserializeJsonEntryAsync`
    for each string in the list and stores an `IEnumerable<Task<JournalEntry>>` instance
    in a `getJournalTasks` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code awaits all the `Task` objects in `journalTasks`, returning
    the results of every call as an array of `JournalEntry` objects. You can either
    declare `GetJournalEntriesAsync` with a return type of `Task<JournalEntry[]>`
    or use `ToList`, as we have in this sample, to return `Task<List<JournalEntry>>`.
    You can see how LINQ streamlines your code when it is necessary to iterate over
    a list of items and make an async call with each item.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen some different ways to use async and await in your code for both
    I/O-bound and CPU-bound operations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how **nested async methods** are chained and how to start
    the top level of that chain.
  prefs: []
  type: TYPE_NORMAL
- en: Nested async methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to using async methods, it is important to use `await` when you
    want to preserve the order of execution. It is also important to preserve that
    chain of awaited calls to the entry point for the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your application is a console application, the primary entry
    point is the `Main` method in `Program.cs`. If you cannot make this `Main` method
    `async`, then none of the method calls beneath `Main` are made with the `await`
    keyword. That is the reason why .NET now supports `async` `Main` methods. Now,
    when you create a new console application with .NET 6, it has an `async` `Main`
    method by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the entry point for execution is an event handler, you should mark the event
    handler method as `async`. This is the only time you will see `async` methods
    with a `void` return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at an example of the right way to chain multiple nested async methods
    in a console application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new console application. Inside a folder named `AsyncSamples`,
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the process completes, open the new `AsyncSamples.csproj` in Visual Studio
    Code or your editor of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class to the project named `TaskSample`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `TaskSample` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now open `Program.cs` and add some code to call `DoThingsAsync`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s illustrate the order and hierarchy of the methods being called by our
    project. The `Main` method calls `DoThingsAsync`, which in turn calls `DoFirstThingAsync`
    and `DoSecondThingAsync`. Finally, within `DoFirstThingAsync`, `DoAnotherThingAsync`
    is called. When each of these `async` methods is called with the `await` operator,
    the order of operations is predictable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: The order of operations for awaited methods ](img/Figure_5.1_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The order of operations for awaited methods'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program and examine the order of the console output. Everything should
    be executing in the expected order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2: Examining the output of the AsyncSamples console application
    ](img/Figure_5.2_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Examining the output of the AsyncSamples console application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add two additional methods to the `TaskSample` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DoingThingsWrongAsync` method has removed the `await` from the call to
    `DoFirstThingAsync`. So, the execution of `DoSecondThingAsync` will begin before
    `DoFirstThingAsync` has been completed. That might be OK if none of the subsequent
    code relies on the processing that happens within `DoFirstThingAsync`. However,
    any unhandled exceptions inside a method that is not awaited will not automatically
    bubble up to the `calling` method. The `Task` instance for the call will have
    a `Status` value of `Faulted`, the `IsFaulted` property will be `true`, and the
    `Exception` property will contain the unhandled exception information.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding case, any unhandled exceptions in `DoFirstThingAsync` will
    go undetected. If you have a case where you are not awaiting a `Task` instance,
    be sure to monitor the status of the `Task` instance in case of exceptions. This
    is one of the reasons why you should never have an `async void` method. It does
    not return a `Task` instance to be awaited.
  prefs: []
  type: TYPE_NORMAL
- en: The `DoBlockingThings` method will maintain the correct order of operations,
    but by calling `DoFirstThingAsync().Wait()` instead of awaiting the call, the
    thread executing `DoBlockingThings` will be blocked. It will wait for the call
    to `DoFirstThingAsync` to complete instead of being free to pick up other work
    until the long-running async method completes. Using blocking calls such as `Wait()`
    or `Result` can quickly deplete the available threads in `ThreadPool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `Program.cs` to call all three of the public `TaskSample` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the program and examine the console output to see how it is impacted
    by omitting `await` inside `DoingThingsWrongAsync`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3: Console output when calling all the TaskSample methods ](img/Figure_5.3_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Console output when calling all the TaskSample methods'
  prefs: []
  type: TYPE_NORMAL
- en: The output may differ a little each time, depending on how the `ThreadPool`
    threads are allocated. In this case, the second call to `DoFirstThingAsync` remains
    incomplete until the third call to that same method starts. Even though `Program.cs`
    awaits its call to `DoingThingsWrongAsync`, the code inside of that method was
    still executing after the next call to `DoBlockingThingsAsync` was invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Things can get very unpredictable when async tasks are not awaited. You should
    always await a task unless you have a good reason not to do so. Next, let’s explore
    some properties and methods available in the `Task` class.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Task objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working directly with `Task` objects can be extremely useful when introducing
    threading to existing projects. As we saw in the previous section, it is important
    to update the entire call stack when introducing `async` and `await`. On a large
    code base, those changes could be extensive and would require quite a bit of regression
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: You can instead use `Task` and `Task<TResult>` to wrap the existing methods
    that you want to run asynchronously. Both `Task` types represent the asynchronous
    work being done by a method or action. You use `Task` when a method would have
    otherwise returned void. Use `Task<TResult>` with methods that have a non-void
    return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of two synchronous method signatures and their async equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We have seen some examples of using `Task` objects in this chapter. Now it is
    time to explore additional properties, methods, and uses of these two types.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Task methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start, we will discover some commonly used `Task` methods in practical examples.
    Consider the ProcessOrders method that accepts a list of orders to be processed
    and submitted. The four `Task` methods used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Task.Run`: Runs a method on a thread on the thread pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.StartNew`: Runs a method on a thread on the thread pool, with
    `TaskCreationOptions` provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`processOrdersTask.ContinueWith`: When the `processOrdersTask` completes, it
    will execute the method provided on the same thread pool thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.WaitAll`: This method will block the current thread and wait for all
    tasks in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods have been highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what is happening on each line of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Task.Run` will create a new background thread and queue it on `ThreadPool`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Task.Factory.StartNew` will also create a new background thread and queue
    it on `ThreadPool`. In addition, we are providing `TaskCreattionOptions.LongRunning`
    as a parameter of `StartNew` to indicate that creating additional threads is warranted
    because this task may take a while to complete. This will prevent delays for other
    tasks queued on `ThreadPool`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ContinueWith` will queue `SendOrders` on a `ThreadPool` thread, but the thread
    will not start until `processOrdersTask` has been completed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Task.WaitAll` is the synchronous equivalent of the `async` method, `Task.WhenAll`.
    It will block the current thread until `labelTask` and `sendTask` are complete.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, `SendConfirmation` is called to notify the customer that their orders
    have been processed and sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using tasks in this way can achieve the same result as an `async` method that
    awaits tasks to achieve parallel processing. The main difference is that the current
    thread will be blocked at *step 4* when `WaitAll` is called.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful method we will explore next is `RunSynchronously`. This starts
    a task but executes it synchronously on the current thread. The asynchronous equivalent
    is to call `Start` on a task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `ProcessData` method accepts a parameter indicating whether
    the data must be processed on the UI thread. It is possible that some data processing
    requires interacting with the UI to present the user with some options or other
    feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s explore some of the properties of the `Task` and `Task<TResult>`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Task properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will review the properties available on a `Task` object.
    Most of the properties are related to the status of a task, so we will start with
    the `Status` property. The `Status` property returns `TaskStatus`, which is an
    enumeration with eight possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Created (0)`: The task has been created and initialized but has not been scheduled
    on `ThreadPool`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingForActivation (1)`: The task is waiting to be scheduled by .NET'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingToRun (2)`: The task has been scheduled but has not started executing
    yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Running (3)`: The task is currently running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingForChildrenToComplete (4)`: The task has been completed but there are
    attached child tasks that are still running or waiting to run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RanToCompletion (5)`: The task successfully ran to completion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Canceled (6)`: The task was canceled and acknowledged the cancellation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Faulted (7)`: An unhandled exception was encountered while executing the task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following properties of `Task` and `Task<TResult>` are shortcuts to check
    statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IsCanceled`: Returns `true` if the task’s `Status` is `Canceled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsCompleted`: Returns `true` if the task’s `Status` is `RanToCompletion`,
    `Canceled`, or `Faulted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsCompletedSuccessfully`: Returns `true` if the task’s `Status` is `RanToCompletion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsFaulted`: Returns `true` if the task’s `Status` is `Faulted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using these properties can streamline status checks in your code. The remaining
    instance properties of the `Task` object follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncState`: Returns the state that was provided when creating the task. If
    no state was provided, this property returns `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreationOptions`: Returns the `CreationOptions` values that were provided
    when creating the task. If no options were provided, it defaults to `TaskCreationOptions.None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exception`: Returns an `AggregateException` instance containing unhandled
    exceptions encountered while the task was running. `Wait` or `WaitAll` should
    be called in a `try`/`catch` block that handles the `AggregateException` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Id`: A system-assigned identifier for the task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a quick look at how to correctly catch an `AggregateException` instance
    and inspect the `Exception` property of the faulted task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: This code will write the status of the task to the console after completion.
    If an unhandled exception is encountered, the error message will be written to
    the console in the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re more familiar with the members of `Task` and `Task<TResult>`,
    let’s discuss some use cases for calling synchronous code from async code and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Interop with synchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with existing projects and introducing async code to the system,
    there will be points where synchronous and asynchronous code intersect. We have
    already seen some examples of how to handle this interop in this chapter. In this
    section, we will focus on that interop in both directions: sync calling async
    and async calling sync.'
  prefs: []
  type: TYPE_NORMAL
- en: We will create a sample project with classes containing synchronous methods
    representing legacy code and another set of classes with modern `async` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by discussing how to consume `async` methods in your legacy synchronous
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Executing async from synchronous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will be working with a .NET console application that gets
    a patient and their list of medications. The application will call a synchronous
    `GetPatientAndMedications` method that in turn calls an async `GetPatientInfoAsync`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new .NET console application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `Patient`, `Provider`, and `Medication` classes to a `Models` folder and
    `HealthcareService` and `MedicationLoader` classes to a `SyncToAsync` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4: The initial project structure for calling async from sync code
    ](img/Figure_5.4_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: The initial project structure for calling async from sync code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the necessary properties for the model classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `GetPatientInfoAsync` method in the `HealthcareService` class. This
    method creates a patient with a provider and two medications after injecting a
    2-second async delay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the implementation for the `MedicationLoader` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GetPatientAndMedications` method calls `GetPatientInfoAsync` and uses the
    `Result` property to synchronously wait for the `async` method to complete and
    return the value. Using `Result` is the same as using the `Wait()` method on an
    `async` method that returns no value. The current thread is blocked until the
    method completes.
  prefs: []
  type: TYPE_NORMAL
- en: We have wrapped the call in a `try`/`catch` block that handles an `AggregateException`
    instance. If the call was successful, and the `patient` variable is not `null`,
    `ProcessPatientInfo` is called before returning the patient data to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to `Program.cs` to call the synchronous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program. You should see this output in the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s try to load the same data but with an `async` method calling some
    legacy synchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: Executing synchronous code as async
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will mirror the previous example. There will be a `PatientLoader`
    instance with async methods calling a `PatientService` instance with a synchronous
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `PatientService` class to a new `AsyncToSync` folder in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `GetPatientInfo` method with a similar implementation to the `GetPatientInfoAsync`
    method in the previous example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The differences here are that the method is not `async`, it returns a `Patient`
    instance instead of a `Task<Patient>` instance, and we’re injecting a delay with
    `Thread.Sleep` instead of `Task.Delay`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `PatientLoader` class in the `AsyncToSync` folder, and start its
    implementation by creating a new instance of `PatientService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create the async version of `ProcessPatientInfo` from the previous example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create the `GetPatientAndMedsAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The primary differences from the last example are highlighted. The `synchronous`
    class to `GetPatientInfo` is wrapped in a call to `await Task.Run`, which will
    wait for the call without blocking the current thread from performing other work.
  prefs: []
  type: TYPE_NORMAL
- en: We are now using `Exception` instead of `AggregateException` in the `catch`
    block. You should always use `AggregateException` with blocking `Wait` and `Result`
    calls and use `Exception` with `async` and `await`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the async call to `ProcessPatientInfoAsync` is awaited if the `patient`
    variable is not `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next update `Program.cs` to call the new `PatientLoader` code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program, and the output should look similar to the previous example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should have a solid understanding of how to interop between asynchronous
    and synchronous code. Let’s move forward and create an example of loading data
    from several `async` methods in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple background tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see code samples for loading data from multiple sources
    in parallel, not waiting until the method is ready to return the data to the caller.
    The technique is slightly different for synchronous and asynchronous code, but
    the general idea is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, review this method that calls three async methods and uses `Task.WhenAll`
    to wait before returning the patient data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, review this synchronous version of the method, which uses `Task.WaitAll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Even this version of the code, which uses a blocking `WaitAll` call, will perform
    faster than making separate synchronous calls to the three methods.
  prefs: []
  type: TYPE_NORMAL
- en: The complete implementation of this `ParallelPatientLoader` class is available
    in the GitHub repository for this chapter. Let’s finish up the chapter by listing
    some best practices for using `async`, `await`, and `Task` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with async code, there are many best practices of which you should
    be aware. In this section, we will list the most important ones to remember in
    your day-to-day development. **David Fowler**, who is a veteran member of the
    ASP.NET team at Microsoft and a .NET expert, maintains an open source list of
    many other best practices. I recommend bookmarking this page for later reference
    while working with your own projects: [https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are my top recommendations (in no particular order) to follow when working
    with async code:'
  prefs: []
  type: TYPE_NORMAL
- en: Always prefer `async` and `await` over synchronous methods and blocking calls
    such as `Wait()` and `Result`. If you are creating a new project, you should build
    with async in mind from the start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unless you are using `Task.WhenAll` to wait for multiple operations simultaneously,
    you should directly await a method rather than creating a `Task` instance and
    awaiting it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not use `async` `void`. Your async methods should always return `Task`, `Task<TResult>`,
    `ValueTask`, or `ValueTask<TResult>`. The only exceptions are event handlers that
    have existing signatures that return `void`. Event `Main` methods can be async
    in .NET 6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not mix blocking code and asynchronous code. Use `async` calls through the
    call stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `Task.Run` instead of `Task.Factory.StartNew` unless you need to pass additional
    parameters to one of the `StartNew` overloaded methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Long-running `async` methods should support cancellation. We will discuss cancellation
    in depth in [*Chapter 11*](B18552_11_ePub.xhtml#_idTextAnchor173).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Synchronize the usage of shared data. Your code should add locks to prevent
    any overwriting of data in objects used across threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always use `async` and `await` for I/O-bound work such as network and file access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you create an `async` method, add the `Async` suffix to its name. This
    helps to differentiate `sync` and `async` methods at a glance. An `async` method
    to return user information should be named `GetUserInfoAsync`, not `GetUserInfo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not use `Thread.Sleep` in async methods. If your code must wait for a fixed
    period, use `await Task.Delay`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Those are my 10 rules to get you started, but there are many more best practices
    for async development with .NET. We will discover more of them as we progress
    through the remaining chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s wrap up and review what we have learned about async programming in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered quite a bit of information about asynchronous
    development with C# and. NET. We started by covering some of the ways to handle
    I/O-bound and CPU-bound operations in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created some practical examples that use the `Task` and `Task<TResult>`
    classes and discovered how to work with multiple `Task` objects. You got some
    practical advice for interop between modern asynchronous code and legacy synchronous
    methods. Finally, we covered some of the most important rules to remember when
    working with asynchronous code and `Task` objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 6*](B18552_06_ePub.xhtml#_idTextAnchor098), you
    will learn the ins and outs of parallel programming in .NET using the **Task Parallel
    Library** (**TPL**) and learn how to the avoid common pitfalls of parallel programming.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which property of `Task` makes a blocking call to return data from the underlying
    method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `async` method of the `Task` class should be used to await multiple tasks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the blocking equivalent of `Task.WhenAll()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type should an `async` method always return?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are `async` methods more suited to I/O-bound or CPU-bound operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*True or false*: `Async` methods should never end with `Async` as their suffix.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method can be used to wrap a synchronous method in an `async` call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
