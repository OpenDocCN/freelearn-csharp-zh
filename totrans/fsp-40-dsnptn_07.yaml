- en: 'Chapter 7.  Advanced Techniques: Functions Revisited'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 高级技术：函数回顾
- en: 'This chapter builds upon the basic F# idioms in functions, pattern matching,
    and data sequences that we have observed in the previous chapters. Here, I turn
    to the advanced patterns of data transformations, in other words, the repeated
    use of functions over data. The goal of this chapter is to familiarize you with
    the major patterns where combined basic F# idioms work in synergy. This chapter
    covers the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于我们在前几章中观察到的函数、模式匹配和数据序列的基本F#惯用用法。在这里，我转向数据转换的高级模式，换句话说，就是函数在数据上的重复使用。本章的目标是使你熟悉主要模式，其中结合的基本F#惯用用法协同工作。本章涵盖了以下主题：
- en: Advanced **recursion** patterns, including tail recursion and the mutual recursion
    of functions and sequences
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级**递归**模式，包括尾递归和函数与序列的相互递归
- en: '**Folding** as a universal pattern of aggregation'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折叠**作为聚合的通用模式'
- en: '**Memoization** and **lazy evaluation** as complementary patterns of the **just-in-time
    principle** applied to data'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记忆化**和**惰性求值**作为应用于数据的**即时原则**的补充模式'
- en: The **continuation passing** pattern extending the core **call-return** principle
    of function interaction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展函数交互核心**调用-返回**原则的**延续传递**模式
- en: Advanced pattern matching by generalizing matching with **active patterns**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过泛化匹配**活动模式**的高级模式匹配
- en: These synergies often manifest themselves in clean, concise, and efficient F#
    code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些协同作用通常在干净、简洁、高效的F#代码中体现出来。
- en: A deep dive into recursion
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨递归
- en: I've already scratched the surface of **recursion** in [Chapter 3](text00030.html#ch03
    "Chapter 3.  Basic Functions") , *Basic Functions* , showing how the `rec` modifier
    changes the scoping of the function definition. This explicit indication allows
    the function to reference itself before the function body is fully defined. Now
    I'll show you how recursion can be employed in the right or wrong way so that
    you can learn to follow the right recursion pattern.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在[第3章](text00030.html#ch03 "第3章。基本函数")中简要介绍了**递归**，展示了`rec`修饰符如何改变函数定义的作用域。这种明确的指示允许函数在函数体完全定义之前引用自身。现在我将向你展示递归可以以正确或错误的方式使用，这样你就可以学会遵循正确的递归模式。
- en: Tail recursion
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归
- en: I would not be breaking new ground by pointing out that a function, recursive
    or not, as it is implemented these days, consumes a certain amount of resources
    for local values, argument values, and so forth. A non-recursive function consumes
    these resources upon being called and releases them upon returning the result.
    So far, so good.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 指出函数（递归或非递归）在当前实现中消耗一定量的资源用于局部值、参数值等，这并不是什么新发现。非递归函数在调用时消耗这些资源，并在返回结果时释放它们。到目前为止，一切顺利。
- en: But what happens when the function calls itself? Each nested call can stash
    local resources to be released when this particular level of recursion is done.
    Hence, a deep recursion may temporarily increase resource consumption. Quite frequently,
    run-time implementations of the function call and return semantics (including
    the F# one) use the application *stack space* of a limited volume to temporarily
    stash the local resources. If a recursive function aggressively consumes this
    space by deeply nesting self-calls without unwinding the stack, this reserved
    volume can be exhausted, ending the chain of nested self-calls with the notorious
    .NET `StackOverflowException` . Even when stack overflow is not the case, the
    stack space hungry implementation puts a strain on resources and the performance,
    as the allocations and releases of stack frames keeping the function call local
    context take time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但当函数调用自身时会发生什么？每个嵌套调用都可以存储局部资源，在完成这个特定的递归级别时释放。因此，深度递归可能会暂时增加资源消耗。运行时函数调用和返回语义的实现（包括F#的实现）通常使用有限体积的应用程序*堆栈空间*来暂时存储局部资源。如果一个递归函数通过深度嵌套自我调用而不会展开堆栈，这个预留的体积可能会耗尽，以臭名昭著的.NET
    `StackOverflowException`结束嵌套的自我调用链。即使没有堆栈溢出，对堆栈空间的贪婪实现也会对资源和对性能造成压力，因为分配和释放堆栈帧以保持函数调用局部上下文需要时间。
- en: 'A classic (although severely worn out) example of a poorly arranged recursion
    aiming at the calculation of the **factorial** ([https://en.wikipedia.org/wiki/Factorial](https://en.wikipedia.org/wiki/Factorial)
    ) function is as follows (`Ch7_1.fsx` ):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的（尽管严重磨损的）例子是组织不良的递归，目的是计算**阶乘**函数（[https://en.wikipedia.org/wiki/Factorial](https://en.wikipedia.org/wiki/Factorial)），如下所示（`Ch7_1.fsx`）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '(I retreat to the `BigInteger` type here, as in order to cause the stack overflow
    the argument should be in such a range that the result of the factorial function
    may easily consist of thousands of digits). Now, with the help of FSI, let''s
    look at what would be the values of [PRE1] and [PRE2]  . The following screenshot
    shows a number of quite a high magnitude for the first call, but the second call
    fails exactly as was predicted with `StackOverflowException` :'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: （我退回到 `BigInteger` 类型，因为为了引起堆栈溢出，参数应该在一个范围内，这样阶乘函数的结果可能很容易由数千位组成）。现在，借助 FSI，让我们看看
    [PRE1] 和 [PRE2] 的值会是什么。以下截图显示第一次调用有一个相当高的数值，但第二次调用正如预测的那样，以 `StackOverflowException`
    失败：
- en: '![Tail recursion](img/Image00027.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![尾递归](img/Image00027.jpg)'
- en: The failure of a non-tail recursive function call
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 非尾递归函数调用的失败
- en: What happens here is that this implementation continuously nests calls to [PRE3]
    , with the decreasing argument value piling stack frames until it reaches [PRE4]
    . Then, it begins to unwind the stack performing deferred multiplications, ending
    up with an empty stack and sought function value. It is easy to notice that the
    amount of consumed stack frames coincides with the function argument value. It
    is enough stack space to accommodate 1000 frames, but 10 times more than overwhelms
    the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，这个实现不断地调用 [PRE3]，随着参数值递减，堆栈帧堆积，直到达到 [PRE4]。然后，它开始展开堆栈，执行延迟乘法，最终堆栈为空，并得到所需的功能值。很容易注意到消耗的堆栈帧的数量与函数参数值相匹配。有足够的堆栈空间来容纳1000个帧，但10倍于此就会压倒应用程序。
- en: 'What can be done here? We may grasp that all partial multiplications can be
    done immediately as the recursion unwinds and the interim result may be passed
    as an extra argument. Such a wise twist to the previous naive approach is shown
    in the following snippet (`Ch7_1.fsx` ):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里能做什么呢？我们可能意识到所有部分乘法都可以在递归展开时立即完成，并且中间结果可以作为额外的参数传递。这种对先前天真方法的巧妙转变在以下代码片段（`Ch7_1.fsx`）中显示出来：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding [PRE6] definition, recursion is delegated to the inner `factorial_tail_call`
    function, which has two arguments instead of one:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 [PRE6] 定义中，递归被委托给内部 `factorial_tail_call` 函数，该函数有两个参数而不是一个：
- en: One is the **factorial** argument for any calculation step (it is hidden by
    the use of `function` in place of more descriptive `match` construction)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个是任何计算步骤的**阶乘**参数（它被使用 `function` 而不是更具描述性的 `match` 构造所隐藏）
- en: The other is **accumulator ** `acc` , carrying the interim product for the already
    performed recursion steps
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个是**累加器** `acc`，它携带已经执行递归步骤的中间乘积
- en: It is easy to spot now that the recursive call to `factorial_tail_call` does
    not constitute any sort of subexpression of any other expression involving other
    values from the context; also, evaluating this self-contained expression is the
    last action the self-calling function performs. That's why it is called a **tail
    call** , and thereafter, the function having all the recursive calls as tail calls
    is called **tail recursive** .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易看出，对 `factorial_tail_call` 的递归调用不构成任何其他涉及上下文其他值的表达式的子表达式；此外，评估这个自包含的表达式是自我调用函数执行的最后一个操作。这就是为什么它被称为**尾调用**，此后，所有递归调用都是尾调用的函数被称为**尾递归**。
- en: 'Let''s take a look at how the [PRE7] implementation will do after being exercised
    with arguments of a substantial magnitude. In order to save space, let''s output
    the number of digits in the function''s result string presentation with an elegant
    `let howLong = (string >> String.length)` combinator instead of the actual result
    factorial number as the following screenshot shows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 [PRE7] 实现在使用大量参数进行练习后会做什么。为了节省空间，让我们使用优雅的 `let howLong = (string >> String.length)`
    组合器来输出函数结果字符串表示中的数字位数，而不是像以下截图所示的实际阶乘数：
- en: '![Tail recursion](img/Image00028.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![尾递归](img/Image00028.jpg)'
- en: Pushing factorial limits with the tail-recursive implementation
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尾递归实现来推动阶乘极限
- en: After tail recursion's invigorating refactoring, our [PRE8] implementation does
    not have any problem calculating even the factorial of 100,000, or in traditional
    math notation, *100,000!* . It's time to get excited indeed, as this number requires
    almost half a million digits to be recorded, `456574` to be exact!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在对尾递归进行振奋人心的重构之后，我们的[PRE8]实现计算100,000的阶乘没有任何问题，或者用传统的数学符号表示，就是*100,000!*。确实值得兴奋，因为这个数字需要记录近五十万个数字，确切数字是`456574`！
- en: 'Careful readers may observe that the implementation of [PRE9] that''s free
    of subexpressions and context-carried values very closely resembles the good old
    imperative cycle. Surprisingly, this is exactly what the F# optimizing compiler
    does in such cases. I refer those of you interested in the inner workings of the
    tail recursion compilation to this blog from the Microsoft Visual F# team: **Tail
    calls in F#** ([https://blogs.msdn.microsoft.com/fsharpteam/2011/07/08/tail-calls-in-f/](https://blogs.msdn.microsoft.com/fsharpteam/2011/07/08/tail-calls-in-f/)
    ).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者可能会注意到，[PRE9]的实现，其中没有子表达式和上下文携带的值，非常类似于古老的好命令循环。令人惊讶的是，这正是F#优化编译器在这种情况下所做的事情。我建议对尾递归编译的内部工作原理感兴趣的读者参考微软Visual
    F#团队的这篇博客：**F#中的尾调用**([https://blogs.msdn.microsoft.com/fsharpteam/2011/07/08/tail-calls-in-f/](https://blogs.msdn.microsoft.com/fsharpteam/2011/07/08/tail-calls-in-f/)
    )。
- en: Mutual recursion
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相互递归
- en: So far, all the considered use cases related to recursion were dealing with
    **self-recursion** , where the recursive function calls itself. However, it is
    not hard to extrapolate that recursive function abstraction allows a natural generalization,
    where the group of two or more functions dispatch to each other in definitions,
    allowing circular dependencies. This generalization brings the **mutual recursion**
    pattern to the table.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有考虑到的与递归相关的用例都涉及**自递归**，即递归函数调用自身。然而，不难推断出递归函数抽象允许自然推广，其中两个或更多函数在定义中相互调度，允许循环依赖。这种推广将**相互递归**模式引入其中。
- en: 'To express this kind of mutual dependency, F# introduces a special kind of
    `let rec` binding, where definitions of two or more constituent functions are
    grouped together with the `and` keyword as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表达这种相互依赖，F#引入了一种特殊的`let rec`绑定，其中两个或更多组成函数的定义通过`and`关键字组合在一起，如下所示：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As outlined in **recursive functions** ([https://msdn.microsoft.com/en-us/library/dd233232.aspx](https://msdn.microsoft.com/en-us/library/dd233232.aspx)
    ), I have already covered the inner workings of the single function binding that
    has the `rec` modifier in [Chapter 3](text00030.html#ch03 "Chapter 3.  Basic Functions")
    , *Basic Functions* . Mutual recursion binding simply extends the same principle:
    one or more `and` parts just throw in additional bindings, making the bound function
    names available for forward referral immediately.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如在**递归函数**([https://msdn.microsoft.com/en-us/library/dd233232.aspx](https://msdn.microsoft.com/en-us/library/dd233232.aspx)
    )中概述的，我已经在[第3章](text00030.html#ch03 "第3章。基本函数") *基本函数* 中介绍了具有`rec`修饰符的单个函数绑定的内部工作原理。相互递归绑定简单地扩展了相同的原则：一个或多个`and`部分只是添加额外的绑定，使得绑定的函数名可以立即用于前向引用。
- en: 'Conceptually, the mutual recursion is quite a simple generalization. However,
    the growing number of moving parts may make the reasoning about mutually recursive
    function behavior quite complicated, allowing bugs to sneak in. A good illustration
    of the above observation can be the example definition of the mutually recursive
    functions pair `Even` and `Odd` provided on MSDN at the reference given above.
    The following code shows the following two mutually recursive functions definition
    taken from there (`Ch7_2.fsx` ):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，相互递归是一个非常简单的推广。然而，随着移动部件数量的增加，对相互递归函数行为的推理可能会变得相当复杂，从而允许错误悄悄进入。上述观察的一个很好的例子是MSDN上提供的相互递归函数对`Even`和`Odd`的定义示例。以下代码显示了从那里（`Ch7_2.fsx`）取出的以下两个相互递归函数的定义：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The definition looks very succinct and elegant, right? Unfortunately, this
    impression is superficial, and the preceding definition does not work as expected
    in certain cases, allowing recursion to run away without stopping. Just check
    for yourself how the preceding code works for the `Even(1)` test case: it runs
    away! I refer those of you interested in the fixing of this mutually recursive
    definition to my blog post **A Tale of Two Functions** ([https://infsharpmajor.wordpress.com/2013/04/21/a-tale-of-two-functions/](https://infsharpmajor.wordpress.com/2013/04/21/a-tale-of-two-functions/)
    ) published in April 2013, where I covered the bases of the issue, its history,
    and the suggested fix.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 定义看起来非常简洁和优雅，对吧？不幸的是，这种印象是表面的，前面的定义在特定情况下并不按预期工作，允许递归无限运行而不会停止。请你自己检查前面的代码对于`Even(1)`测试用例是如何工作的：它会无限运行！我建议对修复这个相互递归定义感兴趣的读者查看我于2013年4月发布的博客文章**两个函数的故事**([https://infsharpmajor.wordpress.com/2013/04/21/a-tale-of-two-functions/](https://infsharpmajor.wordpress.com/2013/04/21/a-tale-of-two-functions/))，我在那里讨论了问题的基本原理、其历史和提出的修复方案。
- en: It seems to me that a certain similarity exists between the definition of mutually
    recursive functions and the piece of imperative code peppered with many `goto`
    . operators. In both cases it is similarly hard to mentally track the flow of
    control, which in turn creates the opportunity for bugs to sneak in.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，相互递归函数的定义和带有许多`goto`操作符的命令式代码片段之间似乎存在某种相似性。在这两种情况下，心理上追踪控制流的流程都同样困难，这反过来又为错误悄悄潜入创造了机会。
- en: 'Let me now turn to a sample of a good application of a mutual recursion pattern,
    demonstrating the bits and pieces of reasoning behind taming its power. I''m going
    to use my own **Stack Overflow answer** ([http://stackoverflow.com/a/9772027/917053](http://stackoverflow.com/a/9772027/917053)
    ) to the question there **Using Functional Programming to compute prime numbers
    efficiently** ([http://stackoverflow.com/questions/9766613/using-functional-programming-to-compute-prime-numbers-efficiently](http://stackoverflow.com/questions/9766613/using-functional-programming-to-compute-prime-numbers-efficiently)
    ). I approach this challenge with the arsenal of patterns already uncovered until
    this point in the narrative as shown here (`Ch7_2.fsx` ):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我转向一个相互递归模式良好应用的示例，展示驯服其力量的推理背后的点点滴滴。我将使用我自己的**Stack Overflow回答**([http://stackoverflow.com/a/9772027/917053](http://stackoverflow.com/a/9772027/917053))，针对那里的问题**使用函数式编程高效计算素数**([http://stackoverflow.com/questions/9766613/using-functional-programming-to-compute-prime-numbers-efficiently](http://stackoverflow.com/questions/9766613/using-functional-programming-to-compute-prime-numbers-efficiently))。我将使用在叙述中到这一点为止已经发现的模式来应对这个挑战，如下所示(`Ch7_2.fsx`)：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first piece is the definition of the `primes` sequence of an indefinite
    length (in fact, limited by the manner of the preceding implementation to `int`
    prime numbers only but this matter can be easily generalized). The surprising
    part here is that a sequence binding `seq {...}` can be a part of mutually recursive
    function bindings. Nevertheless, the `primes` binding uses the `seq { yield 2;
    yield! Seq.unfold nextPrime 3 }` sequence expression, which yields the first prime
    number 2, followed by `yield!` of the `Seq.unfold` generator function relying
    on the assumption that there is a `nextPrime` function around that, being given
    a prime number argument can generate the next prime number of the greater value.
    Please take into account how I use a forward reference to `nextPrime` granted
    by the `rec` modifier of the `let` binding. It's very convenient and it allows
    you to postpone the definition of `nextPrime` , concentrating only on the sequence
    generation at the moment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是定义不定长度的`primes`序列（实际上，由于前面实现的限制，仅限于`int`类型的素数，但这个问题可以很容易地推广）。令人惊讶的部分在于，一个序列绑定`seq
    {...}`可以是相互递归函数绑定的一部分。尽管如此，`primes`绑定使用了`seq { yield 2; yield! Seq.unfold nextPrime
    3 }`序列表达式，它产生了第一个素数2，然后是`yield!`的`Seq.unfold`生成函数，它依赖于假设存在一个`nextPrime`函数，给定一个素数参数可以生成下一个更大的素数。请考虑我是如何使用`let`绑定的`rec`修饰符提供的`nextPrime`的前向引用。这非常方便，并且允许你推迟`nextPrime`的定义，专注于当前序列的生成。
- en: So far, so good. Now, I turn directly to the definition of `nextPrime` . I do
    that with an assumption that there is a function `isPrime` around that, being
    given an `int` argument, can find out whether it's a prime number or not. Again,
    as discussed earlier, I will make a forward reference to `isPrime` without bothering
    about its implementation at the moment thanks to the `let rec ...` `and` `...`
    binding that allows me such freedom.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在，我直接转向 `nextPrime` 的定义。我这样做是基于假设有一个函数 `isPrime` 在那里，给定一个 `int`
    参数，可以找出它是否是素数。同样，正如之前讨论的那样，我将向前引用 `isPrime`，而不必担心它的实现，这要归功于允许我这样做的 `let rec ...`
    和 `...` 绑定。
- en: The `nextPrime` function is built by the rules of the `Seq.unfold` higher-order
    function. The first thing it calculates is the next candidate for primeness regardless
    of the primeness of the argument at the moment with a slightly obscure binding,
    `let next = n + if n%6 = 1 then 4 else 2` . In fact, there is nothing exciting
    here, apparently, potential candidates are odd numbers and I begin unfolding with
    the smallest odd prime, `3` . For each candidate of value `n` , if `n` is greater
    by 1 than a multiple of `6` , then the next candidate would be `n + 4` (as `n
    + 2` is apparently; the multiple of `3` ); otherwise, it's just `n + 2` , you
    know, just a small optimization. Next, having a prime candidate `n` and the following
    `n` prime candidate `next` at hand, I check whether value `n` is prime with the
    help of the (not yet defined) `isPrime` function. If affirmative, it returns the
    `Some(n, next)option` ; otherwise, it recursively calls itself with `next` as
    the argument.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextPrime` 函数是通过 `Seq.unfold` 高阶函数的规则构建的。它首先计算的是下一个候选素数，无论当前参数的素性如何，使用一个稍微晦涩的绑定，`let
    next = n + if n%6 = 1 then 4 else 2`。实际上，这里并没有什么令人兴奋的，显然，潜在的候选数是奇数，我以最小的奇数素数 `3`
    开始展开。对于每个值为 `n` 的候选数，如果 `n` 比 `6` 的倍数大 `1`，则下一个候选数将是 `n + 4`（因为 `n + 2` 显然是 `3`
    的倍数）；否则，它只是 `n + 2`，你知道，这只是一个小优化。接下来，有了素数候选 `n` 和随后的 `n` 素数候选 `next`，我使用（尚未定义的）`isPrime`
    函数检查 `n` 的值是否为素数。如果是肯定的，它返回 `Some(n, next)` 选项；否则，它以 `next` 作为参数递归地调用自身。'
- en: 'Great! The last piece of the puzzle is to define `isPrime` . The first thing
    is that it sifts out integers of less than 2 (an additional useful property of
    `isPrime` is that it can be used just as a primeness detector to be called from
    elsewhere). Now pay attention: for argument values greater than or equal to `2`
    , it actively uses the members of the already generated `primes` sequence of lesser
    than or equal to the square root of the argument values with the help of the `Seq.tryFind`
    higher-order function for the checking! That''s why I cached the output of the
    sequence expression with `Seq.cache` in the definition of `primes` ; otherwise,
    `isPrime` would be slow. We trade here the memory space for the execution speed.
    So, `Seq.tryFind` traverses the cache until it either finds the factor of the
    argument value or it reaches the point where the `primes` member multiplied by
    itself gets greater than the argument. The first outcome means that the argument
    is not a prime number, and the second means that it is a prime number. This statement
    wraps up the lengthy and slightly annoying comments about the implementation of
    `primes` .'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！拼图的最后一部分是定义 `isPrime`。首先，它筛选出小于 `2` 的整数（`isPrime` 的一个额外有用特性是它可以作为一个素性检测器从其他地方调用）。现在请注意：对于大于或等于
    `2` 的参数值，它积极使用小于或等于参数值平方根的已生成的 `primes` 序列的成员，这得益于 `Seq.tryFind` 高阶函数的检查！这就是为什么我在
    `primes` 的定义中用 `Seq.cache` 缓存序列表达式的输出；否则，`isPrime` 会很慢。在这里，我们用内存空间换取执行速度。因此，`Seq.tryFind`
    遍历缓存，直到它要么找到参数值的因子，要么到达 `primes` 成员乘以自身大于参数值的位置。第一个结果意味着参数不是素数，第二个结果意味着它是素数。这个陈述总结了关于
    `primes` 实现的冗长且有点令人烦恼的注释。
- en: 'I wrap up this section by checking how performant the `primes` implementation
    is. For this purpose, let me turn to the familiar **Project Euler** ([https://projecteuler.net/](https://projecteuler.net/)
    ), particularly to the **Problem 10 - Summation of Primes** ([https://projecteuler.net/problem=10](https://projecteuler.net/problem=10)
    ):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过检查 `primes` 实现的性能来结束这一部分。为此，让我转向熟悉的 **Project Euler** ([https://projecteuler.net/](https://projecteuler.net/)
    )，特别是 **问题 10 - 素数求和** ([https://projecteuler.net/problem=10](https://projecteuler.net/problem=10)
    )。
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Applying the `primes` definition to the summation of prime numbers not exceeding
    2,000,000 is shown in the upcoming figure. It takes just less than 1.5 seconds
    on my computer. Also, consider that the repeated run yields the result in just
    10 milliseconds, thanks to the sequence caching:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `primes` 定义应用于不超过 2,000,000 的质数求和，将在接下来的图中展示。在我的电脑上，这只需要不到 1.5 秒。此外，考虑到重复运行的结果只需
    10 毫秒，这要归功于序列缓存：
- en: '![Mutual recursion](img/Image00029.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![互递归](img/Image00029.jpg)'
- en: Using mutual recursion for primes generation
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用互递归生成质数
- en: Personally, I find a lot of aesthetic value in the `primes` code, in how it
    uses forward references twice, finally closing in on the self-computed data. And
    each of three circularly dependent parts of the definition is a pure function
    (well, kind of, as caching definitely represents a hidden state but in a very
    clean form). This is the power of functional programming!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我发现 `primes` 代码中有很多美学价值，尤其是在它如何两次使用前向引用，最终锁定在自我计算的数据上。定义中的三个相互依赖的部分都是纯函数（好吧，有点像，因为缓存确实代表了一种隐藏的状态，但以一种非常干净的形式）。这就是函数式编程的力量！
- en: Folding
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 折叠
- en: 'Now is the perfect time to revisit the `factorial` function that I used at
    the beginning of this chapter when covering tail recursion. Let''s take a sequence
    of `bigint` numbers from `1I` to a value `n` represented by the following expression:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是回顾我在本章开头介绍尾递归时使用的 `factorial` 函数的完美时机。让我们从以下表达式 `1I` 到值 `n` 的 `bigint` 数列中取一个序列：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Does the `factorial(n)` function represent nothing else but a product of the
    factors, each being a member of the preceding sequence? Sure, it can be seen (and
    implemented) as such. Let me create this implementation in the best traditions
    of the imperative programming style as shown here (`Ch7_3.fsx` ):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial(n)` 函数难道不是仅仅表示了因数的乘积，每个因数都是前一个序列的成员吗？当然，它可以被看作是这样（并且可以如此实现）。让我按照命令式编程风格的最好传统，如以下所示（`Ch7_3.fsx`）创建这个实现：'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Expressed in plain words, this implementation can be laid out in the following
    manner:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话来说，这种实现可以按照以下方式展开：
- en: Take a mutable value that will serve as a result accumulator
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取一个可变值，它将作为结果累加器使用
- en: Enumerate the sequence of factors
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出因数序列
- en: For each factor in the sequence, get a new value of the accumulator by multiplying
    the current accumulator value by the current factor
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于序列中的每个因子，通过将当前累加器值乘以当前因子来获取新的累加器值
- en: Return the final accumulator value as a function result
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将最终累加器值作为函数结果返回
- en: Some of you with experience in object-oriented design may perhaps have already
    spotted the signs of the **visitor** ([https://en.wikipedia.org/wiki/Visitor_pattern](https://en.wikipedia.org/wiki/Visitor_pattern)
    ) pattern in the preceding implementation. Indeed, the operation (multiplication
    in this case) is applied to the sequence data without in any way changing this
    data, eventually deriving the result as the aggregate of these repeated operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在面向对象设计方面有经验的你，可能已经在前面的实现中发现了**访问者**([https://en.wikipedia.org/wiki/Visitor_pattern](https://en.wikipedia.org/wiki/Visitor_pattern)
    ) 模式的迹象。确实，操作（在这个例子中是乘法）被应用于序列数据，而没有以任何方式改变这些数据，最终将结果作为这些重复操作的汇总。
- en: 'Generalizing this in the form of a higher-order function signature, the following
    can be derived:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以高阶函数签名的形式概括，可以得到以下内容：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, the function of type `(''State -> ''T -> ''State)` named `folder` applies
    to the pair of arguments:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，名为 `folder` 的类型为 `('State -> 'T -> 'State)` 的函数应用于以下两个参数：
- en: The first of type `'State` representing the accumulator
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个类型为 `'State`，表示累加器
- en: The second of type `seq 'T` representing the sequence of elements that have
    the type `'T`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个类型为 `seq 'T`，表示具有 `'T` 类型的元素序列
- en: The `folder` function returns the final value of the accumulator. This function,
    named `fold` , represents the ubiquitous pattern of data processing by name `folding`
    .
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`folder` 函数返回累加器的最终值。这个名为 `fold` 的函数代表了数据处理的通用模式，名为 `folding`。'
- en: 'As can be expected, the generic folding of the preceding form is indeed a member
    of the F# core library: **Seq.fold<''T,''State> function ** ([https://msdn.microsoft.com/en-us/library/ee353471.aspx](https://msdn.microsoft.com/en-us/library/ee353471.aspx)
    ). Rewriting [PRE17] with the help of the `Seq.fold` library function, which hides
    all these pesky moving parts involved (the enumerator, state holder, and traversing
    enumeration), gives the following, much more terse version (`Ch7_3.fsx` ):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，前面形式化的通用折叠确实是F#核心库的一个成员：**Seq.fold<'T,'State>函数** ([https://msdn.microsoft.com/en-us/library/ee353471.aspx](https://msdn.microsoft.com/en-us/library/ee353471.aspx)
    )。使用`Seq.fold`库函数重写[PRE17]，该函数隐藏了所有这些讨厌的移动部件（枚举器、状态持有者和遍历枚举），给出了以下更简洁的版本（`Ch7_3.fsx`）：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s compare both implementations from a performance standpoint. The results
    of running both versions side by side are given in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从性能的角度比较这两种实现。以下截图显示了运行这两个版本的结果：
- en: '![Folding](img/Image00030.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![折叠](img/Image00030.jpg)'
- en: Hand-coded folding versus the library fold function performance
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 手动编写的折叠与库折叠函数的性能比较
- en: 'It should not be surprising to observe that the `library` function shows slightly
    better performance than the hand coded imperative version. The `library` function
    implementation is highly optimized. For those who are curious, the current library
    implementation of the `fold` function taken from GitHub looks like what is shown
    in the following snippet (`Ch3_7.fsx` ):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`library`函数的性能略优于手动编写的命令式版本，这并不令人惊讶。`library`函数的实现高度优化。对于那些好奇的人来说，GitHub上当前`fold`函数的库实现看起来就像以下片段（`Ch3_7.fsx`）所示：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You may have already noticed how closely folding resembles tail recursion with
    the accumulator. This resemblance is not accidental. Both thread the state through
    the sequence of function calls, although the `recursive` function materializes
    these calls when it is executed, while the `fold` function applies the `folder`
    function to the explicit to-be-folded data sequence.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到折叠与带有累加器的尾递归有多么相似。这种相似性并非偶然。两者都通过函数调用的序列传递状态，尽管`recursive`函数在执行时实际实现了这些调用，而`fold`函数则将`folder`函数应用于显式的待折叠数据序列。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It can be formally proven that in a language with first-order tuples and functions,
    which F# is, any function can be expressed as `fold` . I refer those of you who
    are interested to the classic paper on this subject: Graham Hutton''s **A Tutorial
    on the Expressiveness and Universality of Fold** ([www.cs.nott.ac.uk/~pszgmh/fold.pdf](http://www.cs.nott.ac.uk/~pszgmh/fold.pdf)
    ).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以形式化证明，在具有一阶元组和函数的语言中，例如F#，任何函数都可以表示为`fold`。我建议对这一主题感兴趣的读者参考关于此的经典论文：Graham
    Hutton的**关于折叠的表达能力和普遍性的教程**([www.cs.nott.ac.uk/~pszgmh/fold.pdf](http://www.cs.nott.ac.uk/~pszgmh/fold.pdf)
    )。
- en: Memoization
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: The next two relatively advanced topics I will cover somehow resemble the **Just **
    **in ** **Time** approach taken outside of the compilation context. With **Just
    in Time** ([https://en.wikipedia.org/wiki/Just_in_Time](https://en.wikipedia.org/wiki/Just_in_Time)
    ), Wikipedia comes up first with a production strategy in manufacturing, where
    components are delivered immediately before being utilized as a way of being *lean*
    on inventory costs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个相对高级的主题，我在某种程度上将它们与编译上下文之外的**即时**（**Just in Time**）方法进行了比较。在**即时**（[https://en.wikipedia.org/wiki/Just_in_Time](https://en.wikipedia.org/wiki/Just_in_Time)）中，维基百科首先提出了一个生产策略，在制造过程中，组件在投入使用之前立即交付，作为一种减少库存成本的*精益*方法。
- en: As a matter of fact, **memoization** and **lazy evaluation** complement each
    other in this *lean* calculation sense. While laziness allows you not to perform
    calculations until the result is absolutely required, memoization makes the results
    of the already performed *fat* resource expensive calculations reusable by not
    allowing them to be wasted.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，**记忆化**和**惰性求值**在这个*精益*计算意义上是相辅相成的。虽然惰性允许你不必在结果绝对需要之前进行计算，但记忆化通过不允许这些已经执行过的*昂贵*资源密集型计算结果被浪费，使得这些结果可重用。
- en: 'I have already used memoization somewhat when implementing prime number generation
    earlier in this chapter for covering mutual recursion. An expensively generated
    sequence was cached there in order to use the already generated elements to find
    the next ones, which are not generated yet. Now, I want to concentrate on memoization
    in general, allowing any function to be memoized. Prior to doing this, it is important
    that you realize the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前面这个章节中实现素数生成时已经使用了一些缓存，为了覆盖互递归。在那里，一个昂贵的序列被缓存起来，以便使用已经生成的元素来找到尚未生成的下一个元素。现在，我想专注于缓存的一般用法，允许任何函数都可以被缓存。在这样做之前，重要的是要意识到以下内容：
- en: Memoization may work for *pure functions only* . This is almost obvious; if
    a function is not referentially transparent, it cannot be memoized as memoization
    captures solely arguments, not arguments, *and* state
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存可能只适用于 *纯函数*。这几乎是显而易见的；如果一个函数不是引用透明的，那么它不能被缓存，因为缓存只捕获参数，而不是参数、*和*状态。
- en: Memoization exploits a precalculated state
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存利用了预先计算的状态
- en: 'With this in mind, let''s mimic implementations presented elsewhere on the
    Internet ([https://blogs.msdn.microsoft.com/dsyme/2007/05/31/a-sample-of-the-memoization-pattern-in-f/](https://blogs.msdn.microsoft.com/dsyme/2007/05/31/a-sample-of-the-memoization-pattern-in-f/)
    and [http://www.fssnip.net/8P](http://www.fssnip.net/8P) ) in order to investigate
    related limitations and gotchas as shown here (`Ch7_4.fsx` ):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，让我们模仿互联网上其他地方提出的实现（[https://blogs.msdn.microsoft.com/dsyme/2007/05/31/a-sample-of-the-memoization-pattern-in-f/](https://blogs.msdn.microsoft.com/dsyme/2007/05/31/a-sample-of-the-memoization-pattern-in-f/)
    和 [http://www.fssnip.net/8P](http://www.fssnip.net/8P)），以便调查相关的限制和问题，如下所示（`Ch7_4.fsx`）：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The type inferred for memoization by the F# compiler is shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: F# 编译器为缓存推断的类型如下：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, `f` represents a function to be memoized, `cache` serves as a state repository
    using the immutable **Map F# collection** ([https://msdn.microsoft.com/en-us/library/ee353880.aspx](https://msdn.microsoft.com/en-us/library/ee353880.aspx)
    ) under the hood. `memoize` itself represents a full-fledged high-order function
    that takes a function as an argument and also returns a function. This closes
    over mutable `cache` (an F# 4.0 feature) and does the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`f` 代表一个需要缓存的结果的函数，`cache` 作为状态存储库，在底层使用不可变的 **Map F# 集合** ([https://msdn.microsoft.com/en-us/library/ee353880.aspx](https://msdn.microsoft.com/en-us/library/ee353880.aspx))。`memoize`
    本身代表一个完整的高阶函数，它接受一个函数作为参数，并返回一个函数。这封闭了可变的 `cache`（F# 4.0 的一个特性）并执行以下操作：
- en: If its argument `x` , which is used as a key against the closed `Map` `cache`
    can be found, then it logs the indication that the precached value is to be used
    and returns this `res` value.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其参数 `x`，作为对封闭的 `Map` `cache` 的键，可以被找到，那么它记录了预缓存值将被使用的信息，并返回这个 `res` 值。
- en: Otherwise, it mutates the closed `cache` to a new `Map` that has, in addition
    to the existed entries, the entry represented by the newly calculated tuple (`x,
    f(x)` ), then it logs the fact that memoization took place and returns `f(x)`
    .
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它将封闭的 `cache` 转换为一个新的 `Map`，除了现有的条目外，还包括由新计算出的元组（`x, f(x)`）表示的条目，然后记录缓存发生的事实，并返回
    `f(x)`。
- en: 'Let''s see for now how this works in FSI, which the following screenshot captures:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 FSI 中它是如何工作的，以下截图捕捉了这一过程：
- en: '![Memoization](img/Image00031.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![缓存](img/Image00031.jpg)'
- en: Memoization with F# Map
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 F# Map 的缓存
- en: 'First, I memoized the `fun` `x -> x*x` function, which is supposed to represent
    a "fat" resource hungry calculation into the `fm:(int -> int)` function. Then,
    I used `fm` a couple of times with different arguments as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将 `fun x -> x*x` 函数缓存起来，这个函数原本应该代表一个“胖”的资源密集型计算，变成了 `fm:(int -> int)` 函数。然后，我像这里所示一样，用不同的参数调用了
    `fm` 几次：
- en: '`fm 10` : The result `100` was memoized for argument 10 and then returned'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fm 10`：结果 `100` 被缓存，用于参数 10 并返回'
- en: '`fm 42` : The result `1764` was also memoized and then returned'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fm 42`：结果 `1764` 也被缓存并返回'
- en: '`fm 10` : As this argument value has already occurred, the result `100` is
    returned without any recalculation'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fm 10`：由于这个参数值已经出现，结果 `100` 被返回，无需任何重新计算'
- en: This pattern seems quite straightforward; however, it carries a few gotchas.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式看起来相当简单；然而，它有几个需要注意的问题。
- en: For example, the signature of `memoize` indicates that `'a` is required in order
    to represent comparison; what gives? Digging down the `memoize` implementation
    allows you to conclude that this constraint is a mere corollary of using F# `Map`
    to back the state persistence.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`memoize`的签名表明需要`'a`来表示比较；那是什么意思？深入挖掘`memoize`实现会让你得出结论，这个约束仅仅是使用F# `Map`作为状态持久化后的一种推论。
- en: As the implementation behind `Map` is likely to be a **balanced tree** , it
    requires its keys to be *comparable* for rebalancing. Oops! Sounds like a **leaky
    abstraction** ([https://en.wikipedia.org/wiki/Leaky_abstraction](https://en.wikipedia.org/wiki/Leaky_abstraction)
    ) takes place here. Also, this may be a limiting factor for the application of
    memoization generically, as comparability is not a universal property of a generic
    type `'a` .
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Map`背后的实现可能是一个**平衡树**，它需要其键是**可比较的**以便重新平衡。哎呀！听起来这里发生了**抽象泄漏**([https://en.wikipedia.org/wiki/Leaky_abstraction](https://en.wikipedia.org/wiki/Leaky_abstraction))。此外，这也可能成为通用记忆化应用的一个限制因素，因为可比较性并不是泛型类型`'a`的通用属性。
- en: 'Let''s change the persistence implementation mechanism to a generic **Dictionary**
    ([https://msdn.microsoft.com/en-us/library/xfhwa508(v=vs.100).aspx](https://msdn.microsoft.com/en-us/library/xfhwa508(v=vs.100).aspx)
    ), as shown in the following code (`Ch7_4.fsx` ):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将持久化实现机制更改为通用的**字典**([https://msdn.microsoft.com/en-us/library/xfhwa508(v=vs.100).aspx](https://msdn.microsoft.com/en-us/library/xfhwa508(v=vs.100).aspx))，如下面的代码所示
    (`Ch7_4.fsx`)：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This changes the memoized argument constraint from comparison to equality as
    shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记忆化参数约束从比较改为相等，如下所示：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This can be considered more universal, only until some innocuous usage like
    this occurs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被认为是更普遍的情况，直到出现一些无害的使用，如下所示：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Executing this code will end up with the following exception:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码将导致以下异常：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What the heck? Turns out nothing special happened, just another leaky abstraction
    has taken place, and consequently, the gotcha occurred. This time, the gotcha
    stems from the underlying persistence mechanism that does not allow you to have
    the `null` value as a `Dictionary` key (on the contrary, `Map` happily allows
    this)!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 究竟是怎么回事？结果是并没有发生什么特别的事情，只是另一个抽象泄漏发生了，因此出现了问题。这次，问题源于不允许你将`null`值作为`Dictionary`键的底层持久化机制（相反，`Map`却乐意这样做）！
- en: Finally, I want to touch the matter of combining memoization with recursion,
    as quite frequently, recursion is the tool to solve problems with the **divide
    and conquer** strategy, where memoization fits naturally and may really shine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想谈谈将记忆化与递归结合的问题，因为递归经常是解决采用**分而治之**策略的问题的工具，其中记忆化自然适用，并且可能真正发光。
- en: 'Let''s take some use case more appropriate for the purpose, for example, the
    simple calculation of *binomial coefficients* with the help of **Pascal''s triangle**
    ([https://en.wikipedia.org/wiki/Pascal%27s_triangle](https://en.wikipedia.org/wiki/Pascal%27s_triangle)
    ) as shown here (`Ch7_4.fsx` ):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些更符合目的的使用案例，例如，借助**帕斯卡三角形**([https://en.wikipedia.org/wiki/Pascal%27s_triangle](https://en.wikipedia.org/wiki/Pascal%27s_triangle))进行简单的二项式系数计算，如下所示
    (`Ch7_4.fsx`)：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The easily noticeable recurrent relationship between elements of Pascal's triangle
    rows allows you to expect a serious benefit from memoization.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 帕斯卡三角形行元素之间容易察觉的递归关系让你可以期待从记忆化中获得重大好处。
- en: 'The memoized implementation of `binomial` is also straightforward; `memoize`
    is turned into an internal function in order to strip the logging introduced within
    its initial version. The only other problem left is that the memoized function
    has one argument. However, applying uncurrying helps with this trouble nicely
    as shown here (`Ch7_4.fsx` ):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`binomial`的记忆化实现也很简单；`memoize`被转换为一个内部函数，以便去除其初始版本中引入的日志。唯一剩下的问题是记忆化函数有一个参数。然而，应用反柯里化可以很好地解决这个问题，如下所示
    (`Ch7_4.fsx`)：'
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now it''s time to measure the gain achieved from the memoization. The code
    in the upcoming figure measures the duration of repeating `binomial 500 2` 10,000
    times compared to the duration of repeating it 10,000 times as `memoizedBinomial
    (500,2)` :'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候衡量记忆化带来的收益了。即将到来的图中的代码测量重复`binomial 500 2` 10,000次与重复`memoizedBinomial
    (500,2)` 10,000次所需的时间：
- en: '![Memoization](img/Image00032.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![记忆化](img/Image00032.jpg)'
- en: Memoizing of the "divide and conquer" solution
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: “分而治之”解决方案的记忆化
- en: The results of the comparison are absolutely stunning, that is, `23781 / 15
    = 1585` , which means that memoization has improved the performance by 1585 times!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 比较的结果绝对令人震惊，即 `23781 / 15 = 1585`，这意味着记忆化将性能提高了 1585 倍！
- en: Lazy evaluation
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性求值
- en: 'This concept is very simple. By default, F# follows the **eager evaluation**
    ([https://en.wikipedia.org/wiki/Eager_evaluation](https://en.wikipedia.org/wiki/Eager_evaluation)
    ) strategy, or an expression is evaluated as soon as it is bound. The alternative
    strategy available in other functional programming languages is to postpone the
    calculations until their result is absolutely necessary. F# can be explicitly
    told where to use lazy evaluation; by default, it uses lazy evaluations only for
    sequences. Expressing lazy evaluation if F# is not complicated syntactically,
    the following binding serves the purpose as shown:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念非常简单。默认情况下，F# 遵循 **贪婪求值** ([https://en.wikipedia.org/wiki/Eager_evaluation](https://en.wikipedia.org/wiki/Eager_evaluation)
    ) 策略，或者一个表达式一旦绑定就会被求值。在其他函数式编程语言中可用的另一种策略是推迟计算，直到其结果绝对必要。F# 可以明确地告诉在哪里使用惰性求值；默认情况下，它只为序列使用惰性求值。在
    F# 中表达惰性求值在语法上并不复杂，以下绑定如所示地达到了目的：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `name` is bound to the result of calculating `expression` , but the calculation
    itself is postponed. The type of value `name` is a special one, that is, `Lazy<'T>;`
    it represents a wrapper over `'T` , which is the type of the expression per se.
    The computation gets performed by calling the `Force` method of type `Lazy<'T>`
    , like this `name.Force()` . This action also unwraps the underlying type of `Lazy`
    , so the type of the `name.Force()` expression is `'T` .
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name` 被绑定到计算 `expression` 的结果，但计算本身被推迟。`name` 的值类型是特殊的，即 `Lazy<'T>`；它表示对
    `'T` 的封装，`'T` 是表达式的本身类型。计算通过调用 `Lazy<'T>` 类型的 `Force` 方法来执行，就像这样 `name.Force()`。这个动作也会展开
    `Lazy` 的底层类型，因此 `name.Force()` 表达式的类型是 `'T`。
- en: Take into account that this feature is not specific to F#; the `Lazy<T>` class
    is a part of the .NET framework class library of the System namespace.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个特性并不特定于 F#；`Lazy<T>` 类是 System 命名空间中 .NET 框架类库的一部分。
- en: It is important to understand that the expression is calculated only once, so
    if the expression wrapped into the `lazy` method has a side effect, it is performed
    only once on the expression calculation. Even if the calculation is forced another
    time, nothing will happen on the side; only the cached result will be returned.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解表达式只计算一次，所以如果封装到 `lazy` 方法中的表达式有副作用，它只会在表达式计算上执行一次。即使再次强制计算，副作用也不会发生；只会返回缓存的值。
- en: 'Let''s demonstrate this with the following snippet (`Ch7_5.fsx` ):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下片段（`Ch7_5.fsx`）来演示：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot shows how this code behaves in FSI:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这段代码在 FSI 中的行为：
- en: '![Lazy evaluation](img/Image00033.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![惰性求值](img/Image00033.jpg)'
- en: Lazy evaluation and side-effects
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值和副作用
- en: Note that the binding for `twoByTwo` did not bring any calculations to life,
    but it wrapped the future calculation into the `Lazy` type. Then, the first `twoByTwo.Force()`
    function performed the wrapped calculation, so the side-effect popped up. Finally,
    any consequent `twoByTwo.Force()` function will just repeatedly bring the result
    of the very first calculation without any side-effects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`twoByTwo` 的绑定并没有使任何计算变得活跃，但它将未来的计算封装到了 `Lazy` 类型中。然后，第一个 `twoByTwo.Force()`
    函数执行了封装的计算，因此副作用出现了。最后，任何后续的 `twoByTwo.Force()` 函数都只会重复带来第一次计算的结果，而没有任何副作用。
- en: The lazy evaluation pattern has its own niche in enterprise F# development.
    I often use it when in need of a resource that's probably being initialized; if
    this need really materializes, I want it to happen only once. For example, we
    can consider reading the Production environment configuration settings from Azure
    `KeyVault` when a service runs in the Production environment while using some
    other configuration information carrier in other environments, for example, environment
    variables pointing to data stubs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值模式在企业 F# 开发中有一个自己的领域。我经常在需要可能正在初始化的资源时使用它；如果这个需求真的实现了，我希望它只发生一次。例如，我们可以考虑在服务在生产环境中运行时从
    Azure `KeyVault` 读取生产环境配置设置，而在其他环境中使用其他配置信息载体，例如指向数据存根的环境变量。
- en: Continuation passing style
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续传递风格
- en: 'This sophisticated technique of arranging recursion allows you to avoid stack
    consumption by putting all function calls into the tail position with **continuation**
    , that is, a function that performs the remaining computations instead of returning
    result to the caller. Let me demonstrate this technique by refactoring the *factorial*
    implementation one more time as shown in the following snippet (`Ch7_6.fsx` ):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排递归的复杂技术允许你通过将所有函数调用放入尾位置（即执行剩余计算而不是将结果返回给调用者）来避免栈消耗。让我通过再次重构*阶乘*实现来演示这项技术，如下面的代码片段所示（`Ch7_6.fsx`）：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Although slightly mind-bending, the code consists of all tail calls:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有点令人费解，但代码全部由尾递归组成：
- en: A recursive call to itself [PRE31] is a tail call
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对自身的递归调用[PRE31]是尾递归
- en: A new continuation anonymous function also makes a tail call to the old continuation,
    `cont`
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的延续匿名函数也调用旧的延续，`cont`
- en: 'The `cont` function has inferred signature of `(BigInteger -> ''a);` so, in
    order to perform the sought-for calculations, using the `id` identity function
    for the `cont` as the first argument of [PRE32] would be just fine. Testing the
    continuation passing style implementation of [PRE33] function in FSI is presented
    in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`cont`函数推断出的签名是`(BigInteger -> ''a);`因此，为了执行所需的计算，使用`id`身份函数作为[PRE32]的第一个参数对`cont`来说就足够了。以下截图展示了在FSI中测试[PRE33]函数的延续传递风格实现：'
- en: '![Continuation passing style](img/Image00034.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![延续传递风格](img/Image00034.jpg)'
- en: Implementing a factorial function with the help of continuation passing style
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用延续传递风格实现阶乘函数
- en: This works perfectly, although those of you not already familiar with continuation
    passing style may develop a headache when dealing with this code for the first
    time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，尽管那些不熟悉延续传递风格的人第一次处理这段代码时可能会头疼。
- en: Active patterns
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动模式
- en: I promised in [Chapter 4](text00039.html#page "Chapter 4.  Basic Pattern Matching")
    , *Basic Pattern Matching* , that I would add to the subject by covering **active
    patterns** ; now is a perfect time. Remember matching with **guards?** Guards
    provide a way to drill down into the matched `pattern-expression` function by
    attaching an arbitrary calculation having the `bool` result.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第4章](text00039.html#page "第4章。基本模式匹配")，*基本模式匹配*中承诺，我会通过涵盖**活动模式**来增加这个主题的内容；现在正是时候。记得**守卫**的匹配吗？守卫提供了一种通过附加一个具有`bool`结果的不定计算来深入挖掘匹配的`pattern-expression`函数的方法。
- en: 'Guard mechanism adds a certain customization potential to the vanilla pattern
    matching, but it is kind of detached: regardless of how much data decomposition
    is required in order to complete the guard calculation, all this effort is discarded
    for both matching and non-matching possible calculation results. Wouldn''t it
    be nice to have a fully customizable transition between the recognition and transformation
    phases of pattern matching? Active patterns aim exactly at this matter. Broadly
    speaking, active patterns represent a special kind of function allowed to be used
    inside `pattern-expression` .'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫机制为普通的模式匹配添加了一定的定制潜力，但它有点脱离：无论需要多少数据分解来完成守卫计算，所有这些努力都会在匹配和非匹配的可能计算结果中都被丢弃。不是很好吗？在模式匹配的识别和转换阶段之间有一个完全可定制的过渡？活动模式正是针对这个问题。广义上讲，活动模式代表了一种特殊类型的函数，允许在`pattern-expression`中使用。
- en: 'They allow you to implement some typical patterns of data transformations in
    a very terse and elegant manner as following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它们允许你以非常简洁和优雅的方式实现一些典型的数据转换模式，如下所示：
- en: Advanced transformations between types
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型之间的高级转换
- en: Partitioning data into groups by relevant and irrelevant categories
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据相关和不相关的类别将数据分组
- en: Performing full categorization, in other words, taking any data and processing
    it according to this piece of data belonging to a specific category out of the
    couple given
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行完全分类，换句话说，就是将任何数据按照这个数据属于给定的一对中的特定类别进行处理
- en: Let's look at how active patterns play with each case of these data processing
    patterns.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看活动模式如何与这些数据处理模式的每一个案例互动。
- en: Type transformations with active patterns
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用活动模式进行类型转换
- en: 'Active patterns use a special naming convention when being defined within a
    `let` binding:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 活动模式在`let`绑定中定义时使用特殊的命名约定：
- en: 'The name of the active pattern function must begin with a capital letter even
    if it is a double-ticked like this: [PRE34]'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使像这样使用双引号，主动模式函数的名称也必须以大写字母开头：[PRE34]
- en: The name of the active pattern function must be wrapped into *banana clips*
    `(|` `and` `|)` as in [PRE35]
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主动模式函数的名称必须被包裹在*香蕉夹* `(|` `and` `|)` 中，如[PRE35]所示
- en: The data in which an active pattern works always comes as the last argument
    in the definition and at the time of its use being taken from the context (`match`
    , `function` , or any other F# construction where pattern matching occurs); all
    but the last arguments in a multi-argument definition are parameters that generalize
    the active pattern workings.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 主动模式工作的数据总是作为定义中的最后一个参数出现，并在使用时从上下文（`match`、`function` 或任何其他发生模式匹配的 F# 构造）中获取；在多参数定义中，除了最后一个参数之外的所有参数都是参数化主动模式工作的参数。
- en: Finally, when a literal is used at the place of the last argument, the `pattern-expression`
      is considered matched when the result of the active pattern calculation matches
    the literal. If a name is used instead of the literal, then this name gets bound
    to the result of the active pattern calculation to be used in the corresponding
    `result-expression` transformation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当在最后一个参数的位置使用字面量时，如果主动模式计算的结果与字面量匹配，则 `pattern-expression` 被认为是匹配的。如果使用名称而不是字面量，则该名称绑定到主动模式计算的结果，并在相应的
    `result-expression` 转换中使用。
- en: Does this sound confusing? In fact, it is easier than it may sound. Let me turn
    to some illustrative samples that might help.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来是否令人困惑？实际上，它比听起来要简单。让我转向一些可能有助于说明的示例。
- en: 'The first one represents a dummy sample as shown in the following code (`Ch7_7.fsx`
    ):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表示一个虚拟样本，如下面的代码所示（`Ch7_7.fsx`）：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `Echo` active pattern is very minimalistic; it just echoes the input into
    the result. Then, the `checkEcho` function puts this definition to use. In the
    first `pattern-expression` , it simply checks whether the result of the `Echo
    p` calculation (`p` is implicitly taken from the head of the `match` construction)
    equals `42` . If it does, then the corresponding result expression returns string
    `"42!"` . Otherwise, the next `result-expression` is evaluated by unconditionally
    binding the result of the `Echo p` calculation to variable `x` , which in turn
    is used in `result-expression` to produce a `"... is not good"` string.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Echo` 主动模式非常简约；它只是将输入回显到结果中。然后，`checkEcho` 函数将这个定义付诸实践。在第一个 `pattern-expression`
    中，它简单地检查 `Echo p` 计算的结果（`p` 是从 `match` 构造的头部隐式获取的）是否等于 `42`。如果是，则相应的结果表达式返回字符串
    `"42!"`。否则，下一个 `result-expression` 将无条件地将 `Echo p` 计算的结果绑定到变量 `x`，然后这个变量在 `result-expression`
    中被用来生成一个 `"... is not good"` 字符串。'
- en: So, when using the preceding sample in FSI, `checkEcho 0` produces `"0 is not
    good"` , while `checkEcho 42` produces `"42!"` .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当在FSI中使用前面的示例时，`checkEcho 0`产生`"0 is not good"`，而`checkEcho 42`产生`"42!"`。
- en: 'Is it getting clearer? Another simple sample reinforcing this understanding
    would be an active pattern:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否变得更清晰了？另一个加强这种理解的简单示例将是一个主动模式：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'While keeping the same type for the argument and result, this performs just
    a simple value transformation. The usage of the above active pattern is shown
    in the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持参数和结果类型相同的情况下，这仅仅执行了一个简单的值转换。上述主动模式的使用在以下屏幕截图中显示：
- en: '![Type transformations with active patterns](img/Image00035.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![使用主动模式的类型转换](img/Image00035.jpg)'
- en: A simple type transformation with an active pattern
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主动模式进行简单的类型转换
- en: The binding [PRE38] that defines the active pattern does not match anything;
    instead, it takes the matched value and returns it, adding 2.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 定义主动模式的绑定[PRE38]不匹配任何内容；相反，它取匹配的值并返回它，然后加2。
- en: The binding [PRE39] is used as a part of the match construct and given the input
    argument `40` , it returns `x` bound to a sum value of `42` .
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定[PRE39]用作匹配构造的一部分，并给出输入参数 `40`，它返回绑定到 `42` 的和值。
- en: The binding [PRE40] is a slightly mind boggling example that becomes clear if
    you remember that the `let` binding of a value is a corner case of pattern matching
    based data disassembling, so [PRE41] gets applied to input argument `40` and binds
    the result `42` to `x` .
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定[PRE40]是一个稍微令人困惑的例子，如果你记得值绑定的 `let` 是基于模式匹配的数据解构的边缘情况，那么 [PRE41] 就应用于输入参数
    `40` 并将结果 `42` 绑定到 `x`。
- en: At this point, this specific use case of applying active patterns for data transformations
    should be clear enough; I want to apply it in a more practically sound use case.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用活动模式进行数据转换的特定用例应该已经足够清晰；我想将其应用于一个更实际的应用场景。
- en: 'It is a rather widespread technique to use  **globally unique identifiers,
    or GUIDs** ([https://en.wikipedia.org/wiki/Globally_unique_identifier](https://en.wikipedia.org/wiki/Globally_unique_identifier)
    ) to label unique entities popping up in the course of running a business. For
    example, in Jet.com, GUIDs are used to label customer orders, merchant orders,
    merchant order items, shipping, fulfillment centers, SKUs...the complete list
    would be too long. These codes are mostly exchanged and displayed as strings of
    32 hexadecimal digits. In some nodes of the system, it is required that you validate
    that a given string is a legitimate representation of a GUID. This task can be
    easily performed with the help of active patterns as shown here (`Ch7_7.fsx` ):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局唯一标识符（GUID）([https://en.wikipedia.org/wiki/Globally_unique_identifier](https://en.wikipedia.org/wiki/Globally_unique_identifier)
    )来标记在业务运行过程中出现的唯一实体是一种相当普遍的技术。例如，在Jet.com，GUID用于标记客户订单、商家订单、商家订单项、运输、履行中心、SKU...完整的列表会太长。这些代码大多以32个十六进制数字的字符串形式交换和显示。在某些系统节点中，需要验证给定的字符串是否是GUID的合法表示。这项任务可以很容易地通过活动模式完成，如下所示（`Ch7_7.fsx`）：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding code has many interesting bits and pieces, such as the set of
    allowable `hexCharSet` hexadecimal characters that are calculated only once and
    are local to the active pattern `IsValidGuidCode` definition; the pair of internal
    active patterns `HasRightSize` and `IsHex` , each responsible only for the single
    verified property and disregarding its own input argument using one from the outer
    active pattern instead; and finally, the way two `pattern-expressions` are combined
    with `&` , again omitting the argument as it is already delivered to their bodies
    and combining the final result within `result-expression` based upon entities
    distilled in the complementary `pattern-expression` . Those of you who fully understand
    how the preceding snippet works can claim yourselves to be experts on the subject
    of active patterns.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码有许多有趣的片段，例如允许的`hexCharSet`十六进制字符集，这些字符只计算一次，并且是活动模式`IsValidGuidCode`定义的局部；一对内部活动模式`HasRightSize`和`IsHex`，每个模式只负责单个验证属性，并使用外部活动模式中的一个而不是自己的输入参数；最后，两个`pattern-expressions`通过`&`组合在一起，再次省略了参数，因为它已经传递给了它们的主体，并在`result-expression`中将最终结果基于在互补的`pattern-expression`中提炼出的实体组合。那些完全理解上述代码片段如何工作的人可以自称是活动模式主题的专家。
- en: 'To ensure that this code really works, let me perform a quick test drive. The
    upcoming figure reflects the results of this test, showing that the `IsValidGuidCode`
    active pattern correctly identifies the `"abc"` string as an invalid GUID and
    `"0123456789AbCdEfFFEEDDCCbbAA9988 "` as a valid one:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这段代码真的能工作，让我快速测试一下。下面的图反映了测试结果，显示`IsValidGuidCode`活动模式正确地将`"abc"`字符串识别为无效GUID，将`"0123456789AbCdEfFFEEDDCCbbAA9988
    "`识别为有效GUID：
- en: '![Type transformations with active patterns](img/Image00036.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用活动模式进行类型转换](img/Image00036.jpg)'
- en: Verifying a GUID string using active patterns
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用活动模式验证GUID字符串
- en: By the way, active patterns of the (`|active pattern name|` ) form that I have
    covered so far are named **single total active patterns** , as they deal with
    a single data type, transforming it into the same or a different data type by
    the enclosed calculation. Another peculiarity of considered samples is that all
    of them were working on a single argument. I will cover **active patterns with
    parameters** later in this chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我迄今为止所涵盖的形如（`|活动模式名称|`）的活动模式被称为**单全活动模式**，因为它们处理单个数据类型，通过包含的计算将其转换为相同或不同的数据类型。考虑的样本的另一个特点是它们都在单个参数上工作。我将在本章后面介绍**带参数的活动模式**。
- en: Data partitioning with active patterns
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用活动模式进行数据分区
- en: My next foray into F# active patterns use as processing patterns is concerned
    with the typical practice of having data that may constitute one or more cases
    suitable for the processing and "just the rest" unsuitable. In the spirit of F#'s
    ubiquitous use of options active patterns capable of performing the above manner
    of partitioning transform the input data type into an `Option` type, where the
    `None` case represents unsuitable data and `Some` wraps one or more types of suitable
    data.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 F# 活跃模式作为处理模式的使用的新尝试，关注的是典型的做法，即数据可能构成一个或多个适合处理的情况，以及“其余的”不适合的情况。在 F# 无处不在地使用能够执行上述方式划分的选项活跃模式的精神下，将输入数据类型转换为
    `Option` 类型，其中 `None` 情况表示不适合的数据，而 `Some` 包裹一个或多个适合的数据类型。
- en: 'The definition of such active patterns is unambiguously distinguishable by
    having `|_` characters prepended to the right-hand side banana clip `|)` of the
    active pattern definition. The active patterns of this type are called **partial
    active patterns** and their name groups look like this: `(|name 1[|name 2...]|_|)`
    . Let''s consider a pretty sizeable piece of real code from one of the Jet.com
    production systems to demonstrate this technique.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种活跃模式定义的明确区分是通过在活跃模式定义的右侧香蕉剪辑 `|)` 前面添加 `|_` 字符来实现的。这种类型的活跃模式称为**部分活跃模式**，它们的名称组看起来像这样：`(|name
    1[|name 2...]|_|)`。让我们考虑一个相当大的真实代码片段，来自 Jet.com 的一个生产系统，以展示这种技术。
- en: The task at hand is to process the invoices from Jet.com vendors (shipping carriers,
    payment processors, and others) that package their data in the form of comma-separated
    files. I use "comma-separated" broadly here, as separators can be any characters.
    Files may or may not have headers and can carry just a gazillion other irregularities.
    Uploading these invoices for processing followed by archiving is a problem that
    carries a certain complexity.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当前任务是对 Jet.com 供应商（运输承运人、支付处理器等）的发票进行处理，这些供应商以逗号分隔的文件形式包装他们的数据。在这里，我广泛地使用“逗号分隔”，因为分隔符可以是任何字符。文件可能包含或不含标题，并且可能携带无数其他不规则性。上传这些发票进行处理，然后存档，这是一个具有一定复杂性的问题。
- en: For the purposes of this chapter, I will take only a partially related problem,
    namely recognizing whether the last uploaded file is of a known `Processable`
    type and should be processed or whether it is not and should be rejected.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我将只考虑一个部分相关的问题，即识别最后上传的文件是否为已知的 `Processable` 类型，应该进行处理，或者它不是，应该被拒绝。
- en: In order to keep the code implementing the preceding task reasonably short for
    the purposes of the book, I'll limit the number of vendors to just three, that
    is, **FedEx**  and  **OnTrac** shipping carriers and the **Braintree** payment
    processor.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使书中实现前述任务的代码尽可能简短，我将供应商数量限制为仅三个，即运输承运人**联邦快递**（FedEx）、**OnTrac**和支付处理器**Braintree**。
- en: 'I begin with the `Processable` here that lists known vendor files as following
    (`Ch7_8.fsx` ):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 `Processable` 开始，列出已知供应商文件如下（`Ch7_8.fsx`）：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Nothing fancy here; just a common practice of representing domain entities with
    discriminated unions, perhaps slightly augmented.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么花哨的；只是用区分联合表示领域实体的常见做法，可能略有增强。
- en: 'Next, file headers are hardcoded here and also significantly stripped from
    the right-hand side as the complete contents do not matter much as shown here
    (`Ch7_8.fsx` ):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，文件标题是硬编码的，并且从右侧显著剥离，因为完整的内 容并不重要，如所示（`Ch7_8.fsx`）：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And finally, the active pattern definition is as follows (`Ch7_8.fsx` ):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，活跃模式定义如下（`Ch7_8.fsx`）：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The active pattern name, as expected, points to the partial active pattern,
    the argument is of type `System.IO.Stream` carrying the file contents, and its
    return is of type `Processable` option.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，活跃模式名称指向部分活跃模式，参数是 `System.IO.Stream` 类型，携带文件内容，其返回值是 `Processable` 选项类型。
- en: The function first creates `StreamReader` and reads the first line from there
    into the `hdr` value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先创建 `StreamReader` 并从那里读取第一行到 `hdr` 值中。
- en: Then, it takes a list of tuples, which members perform pairing of `Processable`
    cases with the string literals denoting the corresponding comma-separated file
    headers and tries to find the element that has the second part of the tuple that
    is equal to the `hdr` . If such exists, then the file can be processed and the
    function returns option value `Some` , wrapping the first part of the found tuple.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它接受一个元组的列表，其中成员将`Processable`案例与表示相应逗号分隔的文件头部的字符串字面量配对，并尝试找到元组的第二部分等于`hdr`的元素。如果存在这样的元素，则可以处理该文件，函数返回选项值`Some`，封装找到的元组的第一个部分。
- en: If the element is not found (option value `None` case), consider at this point
    that often `OnTrac` files may not carry headers. To exploit this knowledge, I
    examine a bit more into the already taken stream contents and whether the file
    begins with some symbols pointing to the `OnTrac` origin the active pattern returns
    `Some (Processable.OnTracFile)` ; otherwise, the file is considered non-processable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到元素（选项值`None`情况），在此点考虑，通常`OnTrac`文件可能不带标题。为了利用这一知识，我进一步检查已采取的流内容以及文件是否以指向`OnTrac`来源的某些符号开头，活跃模式返回`Some
    (Processable.OnTracFile)`；否则，该文件被认为是不可处理的。
- en: In my opinion, the `IsProcessable` active pattern represents quite a terse and
    clean implementation of the business feature.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，`IsProcessable`活跃模式代表了业务功能的相当简洁和清晰的实现。
- en: Data categorization with active patterns
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用活跃模式进行数据分类
- en: I wrap up our journey into the exciting world of F# active patterns with the
    active pattern type that applies to the processing pattern of **categorization**
    , or partitioning the data into the entirety of subcategories that completely
    cover the domain entity, not leaving any space for non-applicable outliers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我用适用于**分类**处理模式的活跃模式类型来结束我们对F#活跃模式的精彩世界的探索，即把数据划分成完全覆盖域实体的所有子类别，不留任何非适用异常值的空间。
- en: As some of you may have already deducted, the name associated with this active
    pattern is **multicase active pattern** . Its syntactic definition is also very
    distinguishable from the already considered cases. It has contained between the
    banana clips just few case names separated from each other by `|` pipe symbols.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你们中的一些人可能已经推断出的，与这种活跃模式相关联的名称是**多案例活跃模式**。其句法定义也与已经考虑过的案例非常不同。它包含在香蕉夹之间，只有几个用`|`管道符号分隔的案例名称。
- en: Let's delve into the illustrative sample. An e-commerce domain operating with
    payments considers different payment terms and policies. In particular, if the
    payment terms are not immediate, it make sense to introduce a certain policy or
    policies concerned with determining when each particular payment is due. Hence,
    given the date on which a service or merchandise was supplied, the corresponding
    payment is due or not due depends on the amount of time passed from that date
    to now.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨说明性样本。一个电子商务域在支付方面考虑不同的支付条款和政策。特别是，如果支付条款不是即时的，引入确定每个特定付款何时到期的某些政策或政策是有意义的。因此，根据提供服务或商品的那一天，相应的付款是否到期取决于从那天到现在的经过时间。
- en: 'The implementation using active patterns is very straightforward; just for
    simplicity, let''s assume that the business has adopted a single policy of postponing
    the payments for no more than three days (certainly, the policy can be a subject
    of parameterization in a more sophisticated design) as shown here (`Ch7_9.fsx`
    ):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用活跃模式来实现非常直接；为了简单起见，让我们假设业务已经采用了一项单一天政策，即最多推迟三天付款（当然，在更复杂的设计中，这项政策可以是参数化的主题）如下所示（`Ch7_9.fsx`）：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The function using the active pattern is also pretty simple, but this is OK
    for the purpose of illustration. The preceding code is presented in the following
    figure:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用活跃模式的函数也很简单，但这对说明目的来说是可以接受的。前面的代码在以下图中展示：
- en: '![Data categorization with active patterns](img/Image00037.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![使用活跃模式进行数据分类](img/Image00037.jpg)'
- en: Multi-case active patterns for data categorization
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 多案例活跃模式用于数据分类
- en: I forgot to mention that the maximal number of cases in F# 4.0 multicase active
    patterns as of today is limited to 7, which may be the limiting factor in using
    active patterns in some cases.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我忘记提到，截至今天，F# 4.0多案例活跃模式中的最大案例数限制为7，这可能是某些情况下使用活跃模式的限制因素。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was quite a long field trip into relatively advanced F# idioms
    that an average F# developer uses in the course of a work day quite frequently.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了相对高级的F#惯用法，这是普通F#开发者在工作日中非常频繁使用的。
- en: The next chapter will cover even more widely used language patterns playing
    the central role in data crunching, with F# demonstrating polymorphic behavior
    for multiple data collection types.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖更多广泛使用的语言模式，这些模式在数据处理中扮演着核心角色，F#展示了针对多种数据集合类型的多态行为。
