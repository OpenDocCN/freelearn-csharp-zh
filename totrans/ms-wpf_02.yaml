- en: Debugging WPF Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 WPF 应用程序
- en: When our WPF programs don't work as expected, we need to debug them, as we would
    with any other language. However, at first it can seem to be a daunting task,
    as WPF is very different from other languages. For example, when declaring a Dependency
    Property, we normally add a CLR property wrapper for convenience. However, the
    WPF Framework won't call it when the property value is changing, so we'd wait
    a long time for a break point in that setter to be hit
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 WPF 程序未按预期工作，我们需要像对待任何其他语言一样对其进行调试。然而，一开始这可能看起来是一项艰巨的任务，因为 WPF 与其他语言非常不同。例如，当我们声明依赖属性时，我们通常为了方便添加一个
    CLR 属性包装器。然而，当属性值改变时，WPF 框架不会调用它，所以我们会在那个设置器的断点被命中之前等待很长时间。
- en: When we're testing our newly developed code, we need to be able to check the
    values of our data bound properties, and there are a number of ways to do that,
    although some are far from obvious. In this chapter, we'll investigate a number
    of important sources of information to help us to locate the mistakes in our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在测试新开发的代码时，我们需要能够检查我们数据绑定属性的值，并且有几种方法可以做到这一点，尽管其中一些并不明显。在本章中，我们将调查一些重要的信息来源，以帮助我们定位代码中的错误。
- en: We'll discover a variety of tactics to help us when debugging the data bound
    values and find out how to track down the actual cause of a problem when faced
    with the dreaded `XamlParseException`. We'll cover all of these topics in detail
    shortly, but for now, let's first start with the absolute basics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发现各种策略来帮助我们调试数据绑定值，并找出在遇到可怕的 `XamlParseException` 时如何追踪问题的实际原因。我们将详细讨论所有这些主题，但现在，让我们首先从绝对的基础开始。
- en: Utilizing the output window
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用输出窗口
- en: When we've made changes to our XAML but don't see what we are expecting to see
    in the UI, the first place to look for errors is in the Output window of Visual
    Studio. If this window is not already visible, then you can display it by selecting
    the Output option from the View menu or by pressing *Ctrl* + *W* and then *O*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对 XAML 进行了更改但未在 UI 中看到我们期望看到的内容时，首先查找错误的地方是 Visual Studio 的输出窗口。如果此窗口尚未可见，则可以通过从视图菜单中选择输出选项或按
    *Ctrl* + *W* 然后按 *O* 来显示它。
- en: However, if you have a binding error but don't see any reference to it in the
    Output window, it could be because your Visual Studio is not currently set up
    to output debug information to it. You can turn this functionality on in the Visual
    Studio Options dialog window. Navigate to Tools | Options | Debugging | Output
    Window | General Output Settings.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您有一个绑定错误但在输出窗口中没有看到任何关于它的引用，这可能是因为您的 Visual Studio 当前未设置将调试信息输出到其中。您可以在
    Visual Studio 选项对话框中启用此功能。导航到工具 | 选项 | 调试 | 输出窗口 | 通用输出设置。
- en: 'The General Output Settings section has several options that you can turn on
    and off. The most important ones are All debug output and Exception Messages,
    but it is generally a good practice to leave them all set to On. When set, binding
    errors will be displayed in the Output window in the following format:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在“通用输出设置”部分有几个选项，您可以打开或关闭它们。其中最重要的选项是“所有调试输出”和“异常消息”，但通常将它们全部设置为开启是一个好的实践。当设置后，绑定错误将以以下格式在输出窗口中显示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s take a closer look at this error. The plain English translation for
    this would be as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个错误。这个错误的普通英语翻译如下：
- en: There is no public property named `ViewName` in the object of type `MainViewModel` with
    a `HashCode` value of `3910657`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型为 `MainViewModel` 且 `HashCode` 值为 `3910657` 的对象中不存在名为 `ViewName` 的公共属性。
- en: The error was raised from a `Binding.Path` value that was specified as `ViewName`,
    which was set on the `Text` property of a `TextBox` instance named `NameTextBox`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误是从 `Binding.Path` 值引发的，该值被指定为 `ViewName`，它设置在名为 `NameTextBox` 的 `TextBox`
    实例的 `Text` 属性上
- en: 'This could be rewritten with descriptive names rather than specific details,
    like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用描述性的名称而不是具体细节来重写，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have our '*key*' to explain what these values represent, we can
    see that they are really very descriptive. Not only are we provided with the name
    of the data bound UI control, if it is set, and the used binding path, but also
    the type of the data source, along with the hash code of the actual instance of
    that type that is being used.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了解释这些值代表什么的“*关键*”，我们可以看到它们确实是描述性的。不仅我们提供了数据绑定 UI 控件的名称，如果设置了，以及使用的绑定路径，还包括数据源的类型，以及正在使用的该类型实际实例的哈希码。
- en: These errors highlight the mistakes that have been made in the XAML files. The
    type of errors displayed in this window will include incorrectly labeled binding
    paths, such as using non-existent property names, or otherwise invalid binding
    source paths. While it won't catch every problem, there is a way to make it output
    additional information that could help us to track down our more elusive problems.
    In order to do this, first display the Options dialog window. Navigate to Tools
    | Options | Debugging | Output Window | WPF Trace Settings.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误突出了在XAML文件中犯下的错误。在此窗口中显示的错误类型将包括错误标记的绑定路径，例如使用不存在的属性名称，或无效的绑定源路径。虽然它不会捕获每个问题，但有一种方法可以使其输出可能帮助我们追踪更难以捉摸的问题的额外信息。为了做到这一点，首先显示选项对话框窗口。导航到工具
    | 选项 | 调试 | 输出窗口 | WPF跟踪设置。
- en: 'Here, you can find a number of options, each with a variable level of output: Animation,
    Data Binding, Dependency Properties, Documents, Freezable, HWND Hosting, Markup,
    Name Scope, Resource Dictionaries, and Routed Events. The various levels of output
    and their meanings are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以找到许多选项，每个选项都有不同级别的输出：动画、数据绑定、依赖属性、文档、可冻结、HWND托管、标记、名称范围、资源字典和路由事件。各种输出级别及其含义如下：
- en: 'Critical: Enables tracing of Critical events only'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键：仅启用跟踪关键事件
- en: 'Error: Enables tracing of Critical and Error events'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误：启用跟踪关键和错误事件
- en: 'Warning: Enables tracing of Critical, Error, and Warning events'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告：启用跟踪关键、错误和警告事件
- en: 'Information: Enables tracing of Critical, Error, Warning, and Information events'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息：启用跟踪关键、错误、警告和信息事件
- en: 'Verbose: Enables tracing of Critical, Error, Warning, Information, and Verbose
    events'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详尽：启用跟踪关键、错误、警告、信息和详尽事件
- en: 'ActivityTracing: Enables tracing of Stop, Start, Suspend, Transfer, and Resume
    events'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActivityTracing：启用跟踪停止、开始、挂起、传输和恢复事件
- en: It is fairly common to permanently have the Data Binding option set to Warning
    or Error, with the other options set to Off. The general rule of thumb when using
    these options is to use the minimum level required, except when trying to find
    problems, because they will slow down the running of the application. It should
    be noted, however, that this extra debug trace output will not affect Release
    builds at all.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 永久将数据绑定选项设置为警告或错误，而将其他选项设置为关闭，这种情况相当常见。使用这些选项的一般规则是使用所需的最小级别，除非在尝试查找问题时，因为它们会减慢应用程序的运行速度。然而，需要注意的是，这种额外的调试跟踪输出不会对发布构建产生任何影响。
- en: If you set the Data Binding entry to an output of Verbose or All and look in
    the Output window when running your application, you will understand why it will
    negatively affect performance. Even when not displaying this debug information
    in the Output window, the WPF Framework will still be performing a great number
    of checks when there are binding errors. It is, therefore, very important to clear
    up all errors and warnings that are displayed, to minimize the amount of work
    that the Framework does when trying to resolve them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将数据绑定条目设置为详尽或全部输出，并在运行应用程序时查看输出窗口，你将理解为什么它会负面影响性能。即使不在输出窗口中显示此调试信息，当存在绑定错误时，WPF框架仍将执行大量的检查。因此，清除显示的所有错误和警告非常重要，以最大限度地减少框架在尝试解决它们时的工作量。
- en: Putting Presentation Trace Sources to work
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用演示跟踪源
- en: As useful as it is, there are certain occasions when using the Output window
    will not suffice. Perhaps we have far too much output to look through now and
    would like to view it on the way home from work, or maybe we need to see this
    kind of debug trace information after our application has been deployed. In these
    cases and others, it's time to enable the WPF Presentation Trace Sources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它很有用，但在某些情况下，使用输出窗口是不够的。也许我们现在有太多的输出需要查看，希望在工作回家的路上查看，或者也许我们需要在应用程序部署后查看这种类型的调试跟踪信息。在这些情况下以及其他情况下，是时候启用WPF演示跟踪源了。
- en: There are a number of different trace sources that we can employ to output detailed
    tracing data for us. The choice is the same as that found in the WPF Trace Settings
    options and, in fact, after setting the values there, the Output window has already
    been showing us the debug trace output.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用多种不同的跟踪源来为我们输出详细的跟踪数据。选择与WPF跟踪设置选项中找到的选择相同，实际上，在设置这些值之后，输出窗口已经显示给我们调试跟踪输出。
- en: By default, WPF uses a `DefaultTraceListener` object to send the information
    to the Output window, but we can override that and/or configure the output to
    be sent to a text and/or XML file instead or as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，WPF使用`DefaultTraceListener`对象将信息发送到输出窗口，但我们可以覆盖它，并/或配置输出以发送到文本和/或XML文件，或者同时发送。 '
- en: In order to do this, we need to alter our `app.config` file, which is found
    in the root folder of our startup project. We'll need to add a `system.diagnostics`
    section and within it, add `sources`, `switches`, and `sharedlisteners` elements.
    The `switches` element holds the switch that determines the output level, as specified
    in the previous section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们需要修改我们的`app.config`文件，该文件位于启动项目的根目录中。我们需要添加一个`system.diagnostics`部分，并在其中添加`sources`、`switches`和`sharedlisteners`元素。`switches`元素包含一个开关，用于确定输出级别，如前文所述。
- en: 'The `sharedlisteners` element specifies which kind of output we want to utilize.
    The three types are:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`sharedlisteners`元素指定了我们想要利用的输出类型。这三种类型是：'
- en: '`System.Diagnostics.ConsoleTraceListener`: Sends the traces to the Output window'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.ConsoleTraceListener`：将跟踪信息发送到输出窗口'
- en: '`System.Diagnostics.TextWriterTraceListener`: Outputs to a text file'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.TextWriterTraceListener`：输出到文本文件'
- en: '`System.Diagnostics.XmlWriterTraceListener`: Outputs to an XML file'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.XmlWriterTraceListener`：输出到XML文件'
- en: Finally, we need to add a `source` element for each trace source that we want
    to listen to, and specify which switch and listener we want to use with it. Therefore,
    we are able to output different trace sources to different media and with different
    levels of output. These trace sources are the same as those found in the WPF Trace
    Settings options, although in the configuration file, we need to specify their
    full names.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为每个我们想要监听的跟踪源添加一个`source`元素，并指定我们想要与其一起使用的开关和监听器。因此，我们能够将不同的跟踪源输出到不同的媒体，并以不同的输出级别输出。这些跟踪源与WPF跟踪设置选项中找到的相同，尽管在配置文件中，我们需要指定它们的完整名称。
- en: 'The choices are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 选项如下：
- en: '`System.Windows.Media.Animation`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Media.Animation`'
- en: '`System.Windows.Data`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Data`'
- en: '`System.Windows.DependencyProperty`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.DependencyProperty`'
- en: '`System.Windows.Documents`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Documents`'
- en: '`System.Windows.Freezable`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Freezable`'
- en: '`System.Windows.Interop.HwndHost`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Interop.HwndHost`'
- en: '`System.Windows.Markup`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Markup`'
- en: '`System.Windows.NameScope`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.NameScope`'
- en: '`System.Windows.ResourceDictionary`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.ResourceDictionary`'
- en: '`System.Windows.RoutedEvent`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.RoutedEvent`'
- en: '`System.Windows.Shell`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Windows.Shell`'
- en: 'Let''s see an example configuration file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例配置文件：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Focusing on the `system.diagnostics` section from the example, we see that there
    is one source element that is specifying the `System.Windows.Data` source (for
    data binding information), the switch named `Switch`, and the `TextListener` listener.
    Looking first in the `switches` section, we find the switch named `Switch` and
    note that it is set with an output level of `All`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中的`system.diagnostics`部分来看，我们看到有一个指定了`System.Windows.Data`源（用于数据绑定信息）的源元素，一个名为`Switch`的开关，以及`TextListener`监听器。首先在`switches`部分中查找名为`Switch`的开关，并注意它被设置为`All`输出级别。
- en: Below this, in the `sharedlisteners` element, we see the listener named `TextListener`.
    This listener is of type `System.Diagnostics.TextWriterTraceListener` and this
    outputs to a text file which is specified by the value of the `initializeData`
    attribute. We end with a `trace` element that sets the tab size of the text document
    to four spaces and ensures that data is flushed out of the buffer after each write
    to prevent trace data from being lost due to a crash.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之下，在`sharedlisteners`元素中，我们看到名为`TextListener`的监听器。这个监听器是`System.Diagnostics.TextWriterTraceListener`类型，它输出到一个由`initializeData`属性值指定的文本文件。我们以一个`trace`元素结束，该元素设置文本文档的制表符大小为四个空格，并确保在每次写入后刷新缓冲区，以防止由于崩溃而丢失跟踪数据。
- en: 'To set a less verbose output, we can simply alter the switch to use one of
    the other levels of output, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置更简洁的输出，我们可以简单地更改开关以使用其他输出级别之一，如下所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As mentioned earlier, WPF can use a `DefaultTraceListener` object to send trace
    information to the Output window when particular options are set in Visual Studio.
    The name of this listener is `Default`. In order to stop the default behavior
    of this `DefaultTraceListener`, we can remove it using our `source` element, as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当在Visual Studio中设置特定选项时，WPF可以使用`DefaultTraceListener`对象将跟踪信息发送到输出窗口。该监听器的名称为`Default`。为了停止此`DefaultTraceListener`的默认行为，我们可以使用我们的`source`元素将其移除，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s good to be aware of this fact, because if we also configured our own
    `ConsoleTraceListener` object, we could end up with our Output window duplicating
    trace events. However, it is also possible to add multiple listeners into each
    `source` element if required:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点是很好的，因为如果我们还配置了自己的 `ConsoleTraceListener` 对象，我们可能会遇到输出窗口重复跟踪事件的情况。然而，如果需要，也可以将多个监听器添加到每个
    `source` 元素中：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also add different listeners for different sources:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为不同的来源添加不同的监听器：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Different output levels for different sources can be added as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按如下方式为不同的来源添加不同的输出级别：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One neat feature that WPF Presentation Trace Sources provide is the ability
    to create our own custom trace sources:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 展示跟踪来源提供的一个很酷的功能是能够创建我们自己的自定义跟踪来源：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the `DefaultTraceListener` was already configured to send information
    to the Output window in the WPF Trace Settings options mentioned in the previous
    section, so the traces from this source will also be sent to the Output window
    automatically. If you have not set those options but want to view the trace output
    there, then you will need to manually add a reference to the `ConsoleTraceListener`
    to this source as shown in the preceding code snippets.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`DefaultTraceListener` 已经在上一节提到的 WPF 跟踪设置选项中配置为向输出窗口发送信息，因此从这个来源发出的跟踪信息也将自动发送到输出窗口。如果您尚未设置这些选项但希望在那里查看跟踪输出，那么您需要手动将
    `ConsoleTraceListener` 的引用添加到此来源，如前述代码片段所示。
- en: 'In the code, we are now able to output custom trace information to this source:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们现在能够将自定义跟踪信息输出到这个来源：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To specify different levels of importance, we use the `TraceEventType` enumeration:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定不同的重要性级别，我们使用 `TraceEventType` 枚举：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After outputting the debug information, we can optionally flush the existing
    listeners to ensure that they receive the events in the buffers before continuing:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出调试信息后，我们可以选择刷新现有的监听器，以确保它们在继续之前接收到缓冲区中的事件：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we need to ensure that we close the `TraceSource` object to free resources
    when we have outputted the necessary information:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保在输出必要信息后关闭 `TraceSource` 对象以释放资源：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The best part of this tracing functionality is the fact that we can turn it
    on and off using the configuration file, either at design time, runtime, or even
    on production versions of the application. As the configuration file is basically
    a text file, we can manually edit it and then restart the application so that
    it reads the new configuration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪功能最好的部分是我们可以通过配置文件来开启和关闭它，无论是在设计时、运行时，甚至在应用程序的生产版本中。由于配置文件基本上是一个文本文件，我们可以手动编辑它，然后重新启动应用程序，使其读取新的配置。
- en: 'Imagine that we had two switches in our file and that our default configuration
    used the switch named `OffSwitch`, so that there was no tracing output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的文件中有两个开关，并且我们的默认配置使用名为 `OffSwitch` 的开关，因此没有跟踪输出：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now imagine that we have deployed our application and it is installed on a user's
    computer. It's worth noting at this point that the actual deployed configuration
    file that is created from the `app.config` file will have the same name as the
    executable file. In our case, it would be named `CompanyName.ApplicationName.exe.config`
    and would reside in the same folder as the executable file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们已经部署了我们的应用程序，并且它已安装在使用者的计算机上。此时值得注意的一点是，从 `app.config` 文件创建的实际部署配置文件将与可执行文件具有相同的名称。在我们的例子中，它将被命名为
    `CompanyName.ApplicationName.exe.config` 并位于可执行文件相同的文件夹中。
- en: 'If this installed application was not behaving correctly, we could locate this
    configuration file, and simply change the switch to the one named `AllSwitch`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此安装的应用程序表现不正确，我们可以定位此配置文件，并简单地将其切换到名为 `AllSwitch` 的选项：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After restarting the application, the new configuration would be read and our
    custom traces would be written to the specified text file. One alternative to
    restarting the application would be to call the `Refresh` method of the `Trace`
    class, which has the same effect of initiating a new read of the configuration
    file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新启动应用程序后，新的配置将被读取，我们的自定义跟踪信息将被写入指定的文本文件。重启应用程序的一个替代方案是调用 `Trace` 类的 `Refresh`
    方法，它具有启动配置文件新读取的相同效果：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method call can even be connected to a menu item or other UI control to
    enable tracing to be turned on and off without having to restart the application.
    Using either of these methods of refreshing the configuration file, we can attain
    important debug information from our software, even when it is in production.
    However, great care should be taken to ensure that text or XML file tracing is
    not permanently enabled on released software, as it will negatively affect performance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法调用甚至可以连接到一个菜单项或其他UI控件，以便在不重新启动应用程序的情况下启用和关闭跟踪。使用这两种方法之一刷新配置文件，我们可以在软件处于生产状态时获取重要的调试信息。然而，应非常小心，确保在发布的软件上不会永久启用文本或XML文件跟踪，因为它会负面影响性能。
- en: 'While the WPF Presentation Trace Sources are typically available by default
    these days, in a few cases, we may need to manually enable this tracing functionality
    by adding the following registry key:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如今WPF呈现跟踪源通常默认可用，但在少数情况下，我们可能需要手动通过添加以下注册表键来启用此跟踪功能：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once the `WPF` registry key has been added, we need to add a new `DWORD` value
    to it, name it `ManagedTracing`, and set its value to `1`. We should then have
    access to the WPF Presentation Trace Sources. We've now seen a number of ways
    of finding the information that we need at runtime, but what about if the application
    won't even run?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了`WPF`注册表键，我们需要向其中添加一个新的`DWORD`值，命名为`ManagedTracing`，并将其值设置为`1`。然后我们应该能够访问WPF呈现跟踪源。我们已经看到了几种在运行时找到所需信息的方法，但如果应用程序根本无法运行呢？
- en: Discovering inner exceptions
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现内部异常
- en: When we are building the content of our Views, we often make the odd typographical
    mistake here and there. Perhaps, we mistype the name of one of our properties
    in a binding path, or copy and paste some code that references other code that
    we have not copied.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建视图的内容时，我们经常在这里或那里犯一些打字错误。也许我们在绑定路径中误输了某个属性的名称，或者复制粘贴了一些引用了我们未复制的其他代码的代码。
- en: 'At first, it may appear to be quite difficult to find the source of these types
    of errors, because when we run our application, the actual error that is raised
    by Visual Studio is usually of type `XamlParseException` and bares no direct relation
    to the actual error. The additional information provided is also of little help.
    Here is a typical example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，找到这些类型错误的来源可能看起来相当困难，因为当我们运行我们的应用程序时，Visual Studio抛出的实际错误通常是`XamlParseException`类型，并且与实际错误没有直接关系。提供的信息也帮助不大。以下是一个典型的例子：
- en: '![](img/d884d8a1-747a-4b93-861c-079504959e25.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d884d8a1-747a-4b93-861c-079504959e25.png)'
- en: 'Let''s investigate this further. We can see that the additional information
    supplied here says:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步调查。我们可以看到这里提供的信息补充如下：
- en: '''Provide value on ''System.Windows.Markup.StaticResourceHolder'' threw an
    exception.'' Line number ''48'' and line position ''41''.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '''在''System.Windows.Markup.StaticResourceHolder''上提供值时抛出了异常。''行号''48''和行位置''41''。'
- en: Now let's try to break this down to some meaningful information. Firstly, it
    is clear that the exception was thrown by the `System.Windows.Markup.StaticResourceHolder`
    class. By itself, this information is not very useful, but at least we know that
    the problem has something to do with a `StaticResource` that could not be resolved.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将这个问题分解成一些有意义的 信息。首先，很明显异常是由`System.Windows.Markup.StaticResourceHolder`类抛出的。仅凭这个信息本身并不很有用，但至少我们知道问题与一个无法解析的`StaticResource`有关。
- en: The next bit of information that we can gather from this message is that the
    problem occurred on line 48 and position 41\. However, without informing us of
    which file this relates to, this information is also not very useful. The Exception
    dialog window shown in the preceding screenshot will often have a line pointing
    to the line and position in the current file, which can also be another red herring.
    In this particular case, it was indeed false information as there was no error
    there, but at least that tells us that the problem has not arisen from the current
    file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从这条消息中我们可以获取的下一个信息是问题发生在第48行和位置41。然而，如果没有告诉我们这与哪个文件相关，这些信息也不是很有用。前一个屏幕截图所示的错误对话框通常会有一条指向当前文件行和位置的线，这也可能是一个误导。在这个特定的情况下，这确实是错误信息，因为那里没有错误，但至少这告诉我们问题并非来自当前文件。
- en: The trick to finding out what caused the real problem that occurred is for us
    to click the View Detail... link in the window. This will open the View Detail
    window, where we can see all of the property values of `XamlParseException`. Looking
    at the `StackTrace` and `TargetSite` property values won't help in the way that
    they usually do with normal exceptions. However, if we open up and inspect the
    `InnerException` property value, we can finally find out what actually happened.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 找出实际发生问题的真正原因的技巧是点击窗口中的“查看详细信息...”链接。这将打开“查看详细信息”窗口，在那里我们可以看到 `XamlParseException`
    的所有属性值。查看 `StackTrace` 和 `TargetSite` 属性值并不能像通常处理正常异常那样有所帮助。然而，如果我们打开并检查 `InnerException`
    属性值，我们最终可以找出实际上发生了什么。
- en: 'Let''s do that with our example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们的例子来做这件事：
- en: '![](img/c7253db5-f62c-41f5-9f31-b8d094d27645.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7253db5-f62c-41f5-9f31-b8d094d27645.png)'
- en: At last, we have something that we can work with. The `InnerException.Message`
    property value states: `"Cannot find resource named 'BaseButtonStyle'. Resource
    names are case sensitive"`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们终于有了可以工作的东西。`InnerException.Message` 属性的值表明：“找不到名为 'BaseButtonStyle' 的资源。资源名称区分大小写”。
- en: 'Therefore, our offending object references the `BaseButtonStyle` style. A quick
    search for ''`BaseButtonStyle`'' through the solution files in Visual Studio will
    locate the source of the problem. In this case, our problem lay in the `Application.Resources`
    section of the `App.xaml` file. Let''s take a closer look:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的问题对象引用了 `BaseButtonStyle` 样式。在 Visual Studio 中的解决方案文件中快速搜索 '`BaseButtonStyle`'
    将定位问题的来源。在这种情况下，我们的问题出在 `App.xaml` 文件的 `Application.Resources` 部分中。让我们仔细看看：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we can see a style that is based on another style, but the base style is
    apparently missing. It is this missing base style that is the `StaticResource` named
    `BaseButtonStyle` that caused this error. We can fix this problem easily by either
    creating the referenced base style in the `App.xml` file, or by removing the `BasedOn`
    property from the `SmallButtonStyle` style.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个基于另一个样式的样式，但基础样式显然缺失。正是这个缺失的基础样式，即名为 `BaseButtonStyle` 的 `StaticResource`，导致了这个错误。我们可以通过在
    `App.xml` 文件中创建引用的基础样式，或者从 `SmallButtonStyle` 样式中删除 `BasedOn` 属性来轻松解决这个问题。
- en: We should always bear in mind that errors like these will most likely reside
    in the code that we have just been editing, so that also helps us to narrow down
    the search. It is therefore beneficial to run the application often when implementing
    XAML that may contain errors, as the more code we write between checking our progress,
    the more code we need to look through to find the problem.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终牢记，像这样的错误很可能存在于我们刚刚编辑过的代码中，这也帮助我们缩小搜索范围。因此，在实现可能包含错误的 XAML 时，经常运行应用程序是有益的，因为我们在检查进度之间写的代码越多，我们需要查找以找到问题的代码就越多。
- en: Debugging data bound values
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试数据绑定值
- en: So far, we have seen that we can utilize a number of sources of information
    to help with tracking down the causes of our problems. However, what about actual
    debugging? In other GUI languages, we can add breakpoints at various locations
    in our code and watch our values changing as we step through our code. While we
    can also do this with WPF applications, it is not always so obvious where to put
    our breakpoints to ensure that program execution will hit them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们可以利用许多信息来源来帮助我们追踪问题的原因。然而，实际的调试呢？在其他 GUI 语言中，我们可以在代码的各个位置设置断点，并在逐步执行代码时观察值的改变。虽然我们也可以在
    WPF 应用程序中这样做，但并不总是那么明显在哪里放置断点以确保程序执行会触碰到它们。
- en: If you remember from the previous chapter, the `CommandManager.RequerySuggested`
    event is raised when `CommandManager` detects a change in the UI that could reflect
    on whether a command could execute or not. Well, it turns out that two of the
    conditions that the `CommandManager` looks out for is when the application window
    is either activated or deactivated and we can take advantage of this to help us
    when debugging. Note that the application window is deactivated when the user
    moves focus from it and is reactivated when the user returns focus to it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得上一章的内容，当 `CommandManager` 检测到 UI 发生变化，可能会影响命令是否可以执行时，会触发 `CommandManager.RequerySuggested`
    事件。好吧，结果是 `CommandManager` 寻找的两个条件之一是应用程序窗口被激活或停用，我们可以利用这一点来帮助我们进行调试。请注意，当用户将焦点从应用程序窗口移开时，应用程序窗口会被停用，当用户将焦点返回到它时，它会被重新激活。
- en: Therefore, while running the application side by side with Visual Studio, we
    can put a breakpoint in any method that is being used as a `canExecute` handler
    for our `ActionCommand` class, thereby removing focus from the application. Now,
    when we click back on the WPF application, the focus will be returned to it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们在Visual Studio中与应用程序并行运行时，我们可以在用作`ActionCommand`类`canExecute`处理程序的任何方法中设置一个断点，从而将焦点从应用程序中移除。现在，当我们点击回WPF应用程序时，焦点将返回到它。
- en: This will cause the `CommandManager.RequerySuggested` event to be raised and
    as a result, the `canExecute` handler will be called and our breakpoint will be
    hit. This basically means that we are able to get the program execution into our
    View Models to debug parameter values any and every time that we need to. Let's
    see what else we can do to help fix our data binding errors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致`CommandManager.RequerySuggested`事件被触发，结果，`canExecute`处理程序将被调用，我们的断点将被命中。这基本上意味着我们能够将程序执行控制到我们的视图模型中，以便在任何需要的时候调试参数值。让我们看看我们还能做些什么来帮助我们修复数据绑定错误。
- en: Outputting values to UI controls
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将值输出到UI控件
- en: One of the simplest ways of working out what values our data bound properties
    have is to just data bind them to other UI controls that have a textual output.
    For example, if we have a collection of items and we want to do something with
    the selected item, but whatever that is isn't working, we need to verify that
    our binding to that selected item is correct.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们的数据绑定属性具有哪些值的最简单方法之一是将它们绑定到具有文本输出的其他UI控件。例如，如果我们有一个项目集合，我们想要对所选项目执行某些操作，但无论是什么操作都没有正常工作，我们需要验证我们对所选项目的绑定是否正确。
- en: To visualize the result of the binding, we can simply copy and paste the binding
    path to the `Text` property of a `TextBox` and run the application. If our binding
    path is correct, we'll see something output in the `TextBox` and if not, we'll
    know that the problem that we're having is, in fact, down to the binding path.
    We can, therefore, use this method to verify that objects that don't normally
    have a textual output are at least correctly data bound or not.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化绑定结果，我们可以简单地复制并粘贴绑定路径到`TextBox`的`Text`属性，并运行应用程序。如果我们的绑定路径正确，我们将在`TextBox`中看到一些输出，如果不正确，我们将知道我们遇到的问题实际上是由于绑定路径引起的。因此，我们可以使用这种方法来验证那些通常没有文本输出的对象是否至少正确地进行了数据绑定。
- en: This simple technique can help in any situation where the faulty data binding
    is not already rendered in a text-based UI control. For example, we might need
    to debug a data bound value because a particular visual effect that is created
    with a `DataTrigger` instance is not working and we need to determine whether
    the problem is related to the UI control or the data binding path.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的技术可以帮助在任何数据绑定错误尚未在基于文本的UI控件中渲染的情况下。例如，我们可能需要调试一个数据绑定值，因为使用`DataTrigger`实例创建的特定视觉效果没有正常工作，我们需要确定问题是否与UI控件或数据绑定路径有关。
- en: Catching changing Dependency Property values
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获变化的依赖属性值
- en: 'As we saw at the beginning of this chapter, the WPF Framework won''t call the
    CLR property wrappers of our Dependency Properties when the property values are
    changing. However, there is a way to accomplish this using callback handlers.
    In fact, we''ve already seen an example of this when we were looking at the creation
    of the `OnEnterKeyDown` Attached Property. Let''s remind ourselves what that looked
    like:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所看到的，当属性值发生变化时，WPF框架不会调用我们的依赖属性的CLR属性包装器。然而，有一种方法可以使用回调处理程序来完成这项任务。实际上，当我们查看`OnEnterKeyDown`附加属性创建时，我们已经看到了一个这样的例子。让我们回顾一下它的样子：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For this Attached Property, we used a particular overload of the `DependencyProperty.RegisterAttached`
    method that accepts a `PropertyMetadata` object, which enabled us to assign a
    `PropertyChangedCallback` handler to the property. Note that there is an identical
    overload for the `DependencyProperty.Register` method for declaring Dependency
    Properties.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个附加属性，我们使用了`DependencyProperty.RegisterAttached`方法的特定重载，它接受一个`PropertyMetadata`对象，这使得我们能够将`PropertyChangedCallback`处理程序分配给属性。请注意，对于声明依赖属性，`DependencyProperty.Register`方法也有一个相同重载。
- en: Program execution will enter these `PropertyChangedCallback` handlers each time
    their related Dependency Property changes, so that makes them perfect for debugging
    their values. While we don't often need to attach these handlers, it only takes
    a moment to add one when we need to and they enable us to find out what's going
    on with the Dependency Property values at runtime.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每当相关的依赖属性发生变化时，程序执行将进入这些`PropertyChangedCallback`处理程序，这使得它们非常适合调试它们的值。虽然我们并不经常需要附加这些处理程序，但当我们需要时，添加一个处理程序只需要片刻时间，并且它们使我们能够了解在运行时依赖属性值的情况。
- en: Exploiting converters
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用转换器
- en: If we're having a problem with a data binding that uses an `IValueConverter` to
    convert the data bound value from one type to another, then we can place a breakpoint
    into the `Convert` method of the converter. As long as we have correctly set up
    the converter, we can be sure that the breakpoint will be hit when the binding
    is evaluated at runtime. If it doesn't get hit, that will mean that we have not
    set it up correctly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到了使用`IValueConverter`将数据绑定值从一种类型转换为另一种类型的数据绑定问题，那么我们可以在转换器的`Convert`方法中放置一个断点。只要我们正确设置了转换器，我们就可以确信在运行时评估绑定时将命中断点。如果没有命中，那将意味着我们没有正确设置它。
- en: 'However, even when we are not already using a converter on a binding that is
    not displaying the value that we are expecting, we can still add one just for
    this purpose. We can either add an existing converter to the binding, if we have
    one of the relevant type, or we can create a simple converter specifically for
    the purpose of debugging and use that instead. Let''s take a look at how we might
    do this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使我们已经在绑定上使用了一个没有显示我们期望的值的转换器，我们仍然可以只为这个目的添加一个。如果我们有相关类型的现有转换器，我们可以将其添加到绑定中；或者，我们可以创建一个专门用于调试的简单转换器并使用它。让我们看看我们可能如何做到这一点：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see from the preceding code snippet, it's a very simple implementation
    of the `IValueConverter` interface. We start by specifying that we are converting
    from `object` to `object` in the `ValueConversion` attribute, thereby outlining
    that we are not actually converting any data bound values in this converter. The
    rest of the class represents a typical converter class, but without any conversion
    code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中可以看到，这是一个对`IValueConverter`接口的非常简单的实现。我们首先在`ValueConversion`属性中指定我们正在从`object`转换为`object`，从而概述了在这个转换器中实际上并没有转换任何数据绑定值。类中的其余部分代表了一个典型的转换器类，但没有包含任何转换代码。
- en: The only real point of interest here are the two calls to the `Debugger.Break`
    method from the `System.Diagnostics` assembly. When the program execution reaches
    either of these method calls, it will automatically break, just as if there were
    breakpoints set on these lines. Therefore, when using this converter, we don't
    even need to set breakpoints; we can just plug it into the binding, run the program,
    and investigate the value of the `value` input parameter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正值得关注的是对`System.Diagnostics`程序集中的`Debugger.Break`方法的两次调用。当程序执行到达这两个方法调用中的任何一个时，它将自动中断，就像在这些行上设置了断点一样。因此，当使用这个转换器时，我们甚至不需要设置断点；我们只需将其连接到绑定，运行程序，并调查`value`输入参数的值。
- en: 'It can be attached like any other converter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以像任何其他转换器一样附加：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, this method can be unsafe to use in a production environment and the
    converter should be removed when debugging is finished. If it is left connected
    in release code, an Exception will be thrown at runtime, complaining that Windows
    has encountered a user-defined breakpoint. Although I wouldn''t recommend leaving
    a converter that is just used for debugging data bound values connected in a production
    environment, we can make a slight alteration to it to completely eliminate the
    danger of this occurring:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法在生产环境中使用可能是不安全的，并且当调试完成后应该移除转换器。如果它在发布代码中保持连接，则在运行时将抛出一个异常，抱怨Windows遇到了用户定义的断点。虽然我不建议在用于调试数据绑定值的转换器连接到生产环境中，但我们可以对其进行轻微的修改，以完全消除这种情况发生的危险：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, the `Debugger.Break` method and the data bound value have been moved into
    a separate `Break` method, where the value of the `value` input parameter can
    be inspected. Note the use of the `ConditionalAttribute` attribute on this new
    method. It provides a way to include or exclude methods that it has been set on,
    depending on the current solution configuration. If the configuration is set to
    debug, this method can be called, but otherwise, all calls to it are removed from
    the compiled code. In this way, we can be assured that we will not run into problems
    with our release code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Debugger.Break` 方法以及数据绑定值已经被移动到一个单独的 `Break` 方法中，其中可以检查 `value` 输入参数的值。注意这个新方法上使用的
    `ConditionalAttribute` 属性。它提供了一种方式，根据当前解决方案配置来包含或排除被设置的方法。如果配置设置为调试，则可以调用此方法，否则，所有对其的调用都将从编译后的代码中移除。这样，我们可以确保我们的发布代码不会遇到问题。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've investigated the best ways to track down our coding problems.
    We've looked at the various debug tracing outputs that we have access to and even
    discovered how to output our own custom trace information. We discovered that
    the exceptions that are thrown in WPF often hide their useful information in their
    `InnerException` properties. Finally, we found out a number of tips and tricks
    to use when trying to find errors with our data bound values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了追踪编码问题的最佳方法。我们查看了我们可访问的各种调试跟踪输出，甚至发现了如何输出我们自己的自定义跟踪信息。我们发现 WPF 中抛出的异常通常将它们有用的信息隐藏在它们的
    `InnerException` 属性中。最后，我们找到了一些技巧和窍门，当尝试查找与数据绑定值相关的错误时可以使用。
- en: The next chapter delves deeply into the subject of application frameworks and
    we get started on constructing our own. We find out about the benefit of base
    classes and discover alternative ways to implement our framework functionality.
    The chapter will finish off by investigating a variety of techniques to ensure
    that our applications maintain the essential Separation of Concerns that MVVM
    provides.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章深入探讨了应用程序框架的主题，并开始构建我们自己的框架。我们了解到基类的优势，并发现了实现框架功能的其他替代方法。章节将以调查确保我们的应用程序保持
    MVVM 提供的基本关注点分离的各种技术结束。
