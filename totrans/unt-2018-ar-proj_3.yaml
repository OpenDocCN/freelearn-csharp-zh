- en: Censored - Various Sensor Data and Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you'll excuse the cheeky pun in the title. In this chapter, we will discuss
    the various sensors that we can access through the various SDKs provided to us.
    This includes ARKit, Vuforia, ARCore, Swift API, and the Java API. Now, the reason
    we will be going with this route is because there are some things in the core
    APIs that are not exposed in the SDKs provided to Unity but that we can leverage
    using native plugins with wrapper calls in C#. To break this up, to be a little
    more succinct without going outside of the bounds of this book, I will not be
    teaching the syntax of the Java or Swift programming languages; there are already
    some fantastic books that have been written by other Packt authors that cover
    this material, such as *Beginning Swift* ([https://www.packtpub.com/application-development/beginning-swift](https://www.packtpub.com/application-development/beginning-swift))
    and *Java Programming for Beginners (*[https://www.packtpub.com/application-development/java-programming-beginners](https://www.packtpub.com/application-development/java-programming-beginners)).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be broken down into several main sections, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging sensors with Plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Unity Plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# Language Plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ Language Plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift Language Plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective-C Language Plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Language Plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By breaking the chapter down into these distinct sections, we can make it much
    easier for you to find the specific section you want.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create basic plugins in C#, C++, Swift, Objective-C, and Java. Each
    one will be an implementation of a basic mathematical return value. Writing the
    plugins in their native code should take no more than 10 minutes to complete for
    each native code snippet. You must have a working test in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with AR Applications and games, there are bound to be prerequisites,
    and with this book this will be no different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the requirements for an Apple Mac computer:'
  prefs: []
  type: TYPE_NORMAL
- en: macOS 11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcode 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono Framework **5.14.0**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity 2017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARKit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is suggested that you have a 2013 or later model Mac computer, as older versions
    do not support the Metal API for graphics.
  prefs: []
  type: TYPE_NORMAL
- en: When you install Unity on a Mac, it will install Visual Studio for Mac as well;
    the catch is it requires Mono Framework to run, so be sure to download and install
    everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the requirements for a Windows computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 GB of RAM or more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARCore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK 8 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information, click on these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://store.unity.com/](https://store.unity.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/arkit/](https://developer.apple.com/arkit/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.mono-project.com/download/stable/#download-mac](http://www.mono-project.com/download/stable/#download-mac)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.visualstudio.com/](https://www.visualstudio.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.Android.com/studio/](https://developer.android.com/studio/)'
  prefs: []
  type: TYPE_NORMAL
- en: Sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First things first, we need to get a good grasp of what sensors are and what
    they can be used for, before we get into the various mini projects that will coincide
    with each of the SDKs we will be using. This list of sensors is by no means a
    complete list and are some of the most common ones that we can leverage in AR
    applications and games:'
  prefs: []
  type: TYPE_NORMAL
- en: Fingerprint Sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radiation Sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heart Rate Monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pedometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Air Humidity Sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thermometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Barometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light Sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proximity Sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magnetometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gyroscope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient Light Sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iris Scanner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IR Blaster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch Sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microphone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Air Gesture Sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal Receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LiFi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will describe what each of these sensors is and what they
    can be used for, besides their native functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Proximity Sensor**: The proximity sensor can detect when the cellphone is
    within a certain range of objects and manipulate software or hardware to react
    in a certain way, once the sensor’s trigger has been tripped. It is generally
    used to reduce the total amount of battery consumption by dimming the backlight
    of the cellphone when it reaches a certain range of the user’s ear or pocket.
    Theoretical usage in AR games and applications requires a little bit of thinking
    outside the box. We know that a proximity sensor can’t detect the difference between
    objects, so what we could do is detect whether there are multiple objects near
    the device and register an event based on that.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gyroscope**: The gyroscope is a sensor designed to read and output the direction
    of a cellphone or device with the sensor installed. It is generally used to power
    apps and detect the orientation of the device to determine whether the UI should
    be displayed in landscape or portrait mode. Theoretical usage in AR games and
    applications could be to use the device to act as a compass for traversing the
    game world.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fingerprint scanner sensor**: The fingerprint scanner sensor is a sensor
    designed to detect whether pressure has been added to a special plate and to read
    the input data from the plate.'
  prefs: []
  type: TYPE_NORMAL
- en: It is generally used to add an additional layer of security over a login password.
    It is much more secure and harder to bypass than most standard passwords, even
    with AES encryption with salting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Camera**: The camera is itself a sensor. It is able to able to digitize waves
    of light and the electromagnetic radiation emitted so that a device can interpret
    the information and display it in a way that is understandable to the user. It
    is generally used to take pictures to store and retrieve.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Barometer**: The barometer sensor is designed to detect changes in the atmospheric
    pressure, which in turn means it can effectively act as a means of forecasting
    the weather.'
  prefs: []
  type: TYPE_NORMAL
- en: It is generally used to determine the weather in the general vicinity where
    the user is located.
  prefs: []
  type: TYPE_NORMAL
- en: '**Thermometer**: The thermometer sensor is a sensor used to detect changes
    in temperature and store/send that information to be displayed or acted upon.
    It is generally used to keep track of and measure the temperature of sensitive
    components in the device.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accelerometer**: The accelerometer is a sensor designed to detect the momentum
    of the device, and, by extension, detect the momentum of the user. It is generally
    used to determine the speed in which the user is travelling while in possession
    of the device.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pedometer**: The pedometer is a sensor that is designed to take the user’s
    momentum within the confines of human speed limits and convert it into steps walked.
    It is generally used to calculate the user’s daily step count and display it at
    a specific time for the user to review.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Touch sensor**: The touch sensor is designed to detect when a user’s finger
    touches the device’s screen and return the position and length of time the finger
    was in that location.'
  prefs: []
  type: TYPE_NORMAL
- en: It is generally used to activate and manipulate all the basic and advanced usage
    for the device.
  prefs: []
  type: TYPE_NORMAL
- en: '**Microphone**: The microphone is a sensor designed to detect sound waves and
    convert them into digital information that the device can understand and store.
    It is generally used to pick up the sound waves during a phone call and transmit
    that data to a connected device remotely.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ambient light sensor**: The ambient light sensor is designed to react to
    a variety of light conditions in such a way that it mimics how the human eyes
    would perceive and react to those different light scenarios. It is generally used
    for power saving by adjusting the backlight intensity levels (lighten or darken
    the screen), based on the lighting of the area around the device.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iris Scanner sensor**: The iris scanner sensor is designed to create high-resolution
    images of the eye. It is used mainly for security purposes. It is considered a
    form of biometric security, as it will only accept data from a specific eye for
    unlocking the device.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Air gesture sensor**: The air gesture sensor is able to detect via infrared
    sensors — movements from hands in front of the device’s screen. It is generally
    used to add basic control of the device without needing to use the touch screen,
    for example, activating the screen or applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Heart rate monitor sensor**: The heart rate monitor sensor is a sensor designed
    to be able to track someone''s heartbeat using a combination of algorithms, green
    LEDs, and the accelerometer to measure blood flow, and store this information.
    It is generally used to accurately measure your heartbeat during exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Air Humidity Sensor**: The air humidity sensor is a thermal conductivity
    sensor that utilizes aspects of the temperature sensor to be able to detect humidity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Light sensor**: There are many different types of light sensors that could
    be photoresistors, photodiodes, or even phototransistors. They are designed to
    detect whether there is light in a given area and, if so, how much light is available.
    A light sensor generally works in tandem with the ambient light sensor to give
    accurate light assessment for taking pictures.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Magnetometer**: The magnetometer is a sensor designed for measuring magnetic
    forces. Magnetometers are generally used for treasure-finder apps.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IR Blaster sensor**: The IR Blaster sensor is a sensor designed to emulate
    an infrared remote control. It is generally used to create a universal remote
    control app for a variety of devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**GNSS** (**Global Navigation Satellite System**): GNSS is a sensor designed
    to pick up signals from multiple satellites for better accuracy, availability,
    and redundant data collection.'
  prefs: []
  type: TYPE_NORMAL
- en: It is generally used to poll for a user's location in order to give more accurate
    results in a GPS app.
  prefs: []
  type: TYPE_NORMAL
- en: '**NFC** (**Near-Field Communication**): NFC sensors are designed to be wireless
    data transferers for proximity-based communication. They are generally used for
    using services such as Apple Pay and Apple Wallet payments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signal receiver sensor**: The signal receiver sensor is a sensor designed
    to receive radio waves and convert them into a digital form that the device can
    understand. It is generally used for telephone calls or for playing music from
    the radio.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LiFi sensor**: LiFi sensors, also known as *Light Fidelity Sensors,* use
    **Light-emitting diodes**  (**LEDs**) to transmit data. They are generally used
    for areas that cannot use Wi-Fi, such as power plants, to send and receive data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock**: The **Real-Time Clock** or **RTC** is designed to accurately keep
    track of the time.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a clock that shows the exact time.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging sensors with plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously stated, we can access the information provided by any exposed
    piece of hardware and send that information to our applications and/or games we
    create within Unity. The catch is that if there isn’t an implementation within
    Unity or the SDKs we are using for AR applications, we will need to create a plugin
    with a wrapper to access that sensor.
  prefs: []
  type: TYPE_NORMAL
- en: This is also heavily dependent on which devices we want to target and whether
    we want to target both iOS and Android-based devices without any implementations
    done for us. If so, then we need to create the plugin ourselves. We can’t just
    write a plugin in C#, though; we would need native plugins to call upon these
    sensors to do our bidding. This means that we will need to utilize the Java and
    Swift languages for their respective operating systems. For Android, the native-level
    code would be Java or C++, and for iOS, the native-level code would be Swift,
    Objective-C, or C++.
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely important that we first understand how the sensor values are
    returned to us from the JDK and Apple SDKs. The JDK breaks all of the sensors
    down into specific categories. The accelerometer, the gyroscope, and the pedometer
    are all in the motion sensors category; the temperature sensor is located within
    the environment sensors category.
  prefs: []
  type: TYPE_NORMAL
- en: There is an imperative distinction to be made between the categories that need
    to be fully understood. The environment sensors category returns a single sensor
    value for each sensor event; meanwhile, the motion sensors category will return
    a multi-dimensional array of each sensor event that occurs. With this tidbit of
    information out of the way, let's move on to the next section, where we will learn
    how to write and dissect basic plugins for Unity in C++, C#, Java, Swift, and
    Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unity plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is gain an understanding of what a plugin is for
    Unity before we can create and dissect a very simple plugin for Unity.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a plugin?**'
  prefs: []
  type: TYPE_NORMAL
- en: A *plugin* is a dll file that stores code written in a different programming
    language that is a base implementation of some event that needs to be executed
    or in the same language that gives the base implementation of core code that functions
    as a library or non-changeable event.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is a very simplistic definition, but we can do better by explaining
    what they can do for the developer, or a developer who wants to utilize code you
    have written. Plugins allow a developer to extend existing code without having
    to trudge through the source library by accessing methods and properties that
    are made public to them, which adds new features to the game engine that is not
    natively present, separates operating system-specific code, and they can reduce
    the size of an application.
  prefs: []
  type: TYPE_NORMAL
- en: For Unity specifically, plugins allow us to directly interface with native calls
    and use them as we wish in our application or games. Many developers tend to create
    plugins with native system calls to extend the render pipeline or for enhancing
    shaders.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that there are two very distinct plugin types available
    to use in Unity. Those two types are **Native Plugins** and **Managed Plugins**.
    A very simplified explanation of the difference between native and managed plugins
    is that native plugins are for low-level calls, and managed plugins are an easy
    way to hide source code.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a more nuanced differentiation between them than this old
    adage.
  prefs: []
  type: TYPE_NORMAL
- en: A managed plugin can and will easily hide source code from prying eyes when
    a developer wants to sell something in the asset store. It can also be used to
    include libraries and frameworks that are not otherwise readily available to Unity.
    For example, a developer could import the Entity Framework dll files into Unity
    and utilize the Entity Framework to create, manage, and handle database code with
    Unity. The final thing that a managed plugin can do is allow a developer to utilize
    some .NET languages and compilers that are not supported by Unity, such as F#,
    JScript, IronPython, ClosureCLR, or even Powershell. For example, a developer
    could create a plugin for Unity that allows for scripting in IronPython, or they
    could write game code using IronPython and import it as a plugin and use it without
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: A native plugin, on the other hand, is profoundly more powerful. A native plugin
    normally consists of using Java, Swift, Objective-C, or C++ to access the direct
    hardware of their respective devices and provide functionality that a developer
    could otherwise not have access to within Unity. Let’s say a developer is working
    with a device that connects to a smartphone that is not normally present in smartphones;
    in this case, we will go with the **BACtrack Mobile Pro** as our example.
  prefs: []
  type: TYPE_NORMAL
- en: The BACtrack Mobile pro is a police-grade breathalyzer that can check a user’s
    blood alcohol content and send that information to a device via Bluetooth connections.
    This developer wants to make a drinking-style AR game, and they want to make the
    game harder, the higher the end user’s BAC level is. This developer would need
    to use a native plugin to gain access to the BACtrack device’s sensors' results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that a firm understanding should have been gained from this explanation,
    we can finally start looking at the structure of a plugin for C++, Swift, C#,
    and Java. What we will do is create a very simple plugin that will simply add
    two numbers together. This is to keep things simple and allow for the flow of
    steps for the overall workflow to be much more easy to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a list of file types that Unity will automatically recognize as plugins.
    It is very important that we familiarize ourselves with these file formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.dll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.winmd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.so`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.JAR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.aar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.xex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.def`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.suprx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.prx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.sprx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.rpl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.cpp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.cc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.jslib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.jspre`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.m`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.mm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.swift`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.xib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then there are also folder types that are treated as single plugins; they are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.framework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bundle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `.plugin` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With native plugins for Unity, you can run into C linkage issues that will cause
    a phenomenon called **Name Mangling**. Name mangling is also called *name decoration,*
    which is essentially a process that gives each function in a program a unique
    name; this is so that the linkers can separate common names in the language. The
    issue comes from the fact that there is no standard for this, and they typically
    don’t work well with C compilers.
  prefs: []
  type: TYPE_NORMAL
- en: C# language plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s get started by creating our first plugin with C#:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to begin by opening Visual Studio and creating a new project. This
    new project type will be inside the Windows Desktop subfolder of Visual C# and
    will need to be a Class Library (.NET Framework):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3d0e6c5b-eeb5-4b97-90f3-0c1d4d3188f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Project type
  prefs: []
  type: TYPE_NORMAL
- en: 'The project name will be `CSharpManagedPlugin`, and the Framework version will
    be `.NET Framework 3.5`. Select the OK button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8779b8f-379e-45ae-ba88-5d9b4cbb622f.png)'
  prefs: []
  type: TYPE_IMG
- en: Project setup
  prefs: []
  type: TYPE_NORMAL
- en: Making sure to change the Framework version to 3.5 is extremely important, as
    we need to make sure that Unity can utilize our plugin without experimental support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created our solution, we can change the class name from `Class1`
    to `Addition`. Now, add an integer method called `addify` with the parameters
    of `a` and `b`, and then return `a` plus `b`. Your code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now build the solution that will generate the dll file we need. We can
    now open Unity and see how we can utilize this plugin with Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load Unity, and let’s begin by creating a new project. The project will be
    of type 3D, and the name I will give it is `Packtpub`. I will start by creating
    two folders; the first one will be called `Plugins`*,* and the other will be called
    `PluginWrappers`. This will allow us to keep our project organized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8392a826-8df7-46e9-9a41-b37f86176cf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Project setup
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by taking the C# dll file we created and dragging it into the
    `Plugins` folder. I named my dll file `CSharpManagedPlugin` to make it a bit easier
    to differentiate between the different plugins we have at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/43972a9a-fd7a-4f2e-9601-37de0e59e1cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Plugin added
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the `CSharpManagedPlugin`, in the inspector, you will see more
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/36356fdf-ce23-4dcd-870d-53efdbaaef10.png)'
  prefs: []
  type: TYPE_IMG
- en: Inspector
  prefs: []
  type: TYPE_NORMAL
- en: As long as the target version of .NET is the same or lower than that of Unity,
    you should receive no errors and should be able to use it in the editor, standalone,
    in WebGL, Linux, Windows, and Mac OS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we can do now is move over to our `PluginWrappers` folder and get this
    bad boy up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new script; mine will be called `CSharpWrapper`. We can now open the
    script in Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee6e760c-e9ac-4fa7-a322-314c89947dd0.png)'
  prefs: []
  type: TYPE_IMG
- en: Script
  prefs: []
  type: TYPE_NORMAL
- en: 'Managed plugins are the easiest, and all we need to do is call our plugin directly,
    just as if it were a non-monobehavior script. Your code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we called our plugin as if it were just another namespace in
    the assembly. We can now attach this Unity class to a GameObject, and we will
    see the results of step 7 appear in the console window of the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: C++ language plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving on to C++, we will use Visual Studio once more to create this project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This project type will be in Visual C++ | Windows Desktop | Dynamic-Link Library
    (DLL):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3e4de19e-d199-4a64-98b3-b6a522ea0c5b.png)'
  prefs: []
  type: TYPE_IMG
- en: The name of this project will be `NativeWindowsPlugin`, and C++ will be slightly
    different than the managed plugins, due to name mangling, which we will learn
    how to avoid next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, to get around this problem of name mangling, we need to create a header
    and cpp file. Take a look at this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, what is happening when we use the `__declspec, dllexport` call
    is that we are avoiding the usage of a `.def` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that our header has been created, we need to fill out the information in
    our cpp file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure to include the header for the native windows plugin, and fill out
    the function details of `addify` here. Your code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Click on Build Solution*,* and we will be ready to jump into Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load Unity, and let’s open our `Packtpub` project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we did previously, we will be using our `Plugins` and `PluginWrappers`
    folders for keeping things organized. Copy the `CPlusPlusPlugin` into the `Plugins`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/42a685f6-75bd-4e2c-b74b-b37048bfb1d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Folder structure
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the plugin in the inspector, you will notice that it is
    only available for Windows. That is because we only had our if directive set for
    Windows and no other operating system. This is something you should keep in mind
    when wanting to work with multiple operating systems with C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a new C# class in the `PluginWrappers` folder called `CPlusPlusWrapper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4983c9bb-ad1a-4789-996d-58249dba21e5.png)'
  prefs: []
  type: TYPE_IMG
- en: CPlusPlusWrapper
  prefs: []
  type: TYPE_NORMAL
- en: The code here will be different than what we used for the native plugin. We
    will need to import the dll file using a very special attribute called `DllImport`.
    This attribute requires the string name of the plugin we used and then underneath
    the attribute, we need to make sure it is a **Public Static Extern Method**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Public static extern method types designate that the method call we want to
    use will be static, public, and loaded from an external assembly. To use the DLL
    Import attribute, we need to use the System.Runtime.InteropServices namespace.
    Your code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After we do that, the call is essentially the same from there on out. It is
    a little bit different, and a little more involved, but, overall, it is very easy
    once you understand how it works. You can now attach this C# script to a GameObject
    and run it to test the results.
  prefs: []
  type: TYPE_NORMAL
- en: Swift language plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Swift Language Plugins** have the extension of .swift and have a completely
    different structure than C#, Java, and C++, which is to be expected, as Swift
    is only available on macOS devices. The language itself has elements from a variety
    of sources, and while I will not go into greater details of the finer points of
    the language, I will say that I like the methodologies they incorporated into
    the language structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Swift and Objective-C require the usage of Xcode, and while the basic setup
    is very similar, there are some key differences. Swift plugins require you to
    utilize both Objective-C and Swift to create a plugin that boils down to the implementation
    in Swift and you call that Swift code in Objective-C. This exceeds the parameters
    of this section, as the nuances of both languages need to be explored further.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C language plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objective-C plugins are similar in some ways to Swift plugins and many of the
    basic steps are the same. Objective-C has been around for quite a long time and
    was Apple''s version of the C language family. While Swift has been designed to
    be Objective-C''s successor, Apple has not depreciated the language and is still
    a powerful tool to use and know:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, open Xcode, and get ready to have some fun:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02cf291a-2b58-4b98-b851-abbf323b0d58.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Create a new Xcode project and we'll have a big list of items to choose
    from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go over to macOS and select Library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although the Library is not available with iOS projects, you can also go with
    Bundle or Cocoa Framework Library types as well for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Library and click Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cdfc05e8-8ae9-422f-bed8-e43e2bb8fe4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set the product name to `ObjectiveCPlugin`; this keeps us in line with how
    the projects have been developed thus far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f9bf4e6a-1cc1-4df3-898d-cc0a7d5c57a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, before we continue, let''s look at the various Frameworks that are available
    for us in the drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8629d8ad-3026-4712-a912-90dff864ff40.png)'
  prefs: []
  type: TYPE_IMG
- en: We have Cocoa, STL, and None. Cocoa gives us what we need for Objective C and
    Swift, **STL** is the **Standard Template Library** for C++, and None is a blank
    C++ and C project, with no Standard Libraries attached to it. We will stick with
    Cocoa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should take a look at what is available to us with Type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/819fa5cb-25f7-42a4-b1f2-3df4cf0d13ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type gives us the choice between Dynamic and Static, which would be a **Dynamic
    Library** or a **Static Library**. A static library is a library that is resolved
    at compile time and copied into a target application that produces an object file
    and an executable. A dynamic library is the opposite. It is resolved at runtime
    and only produces the header and source file that can be called in another application
    or program. We will stick with dynamic here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/658e962e-05f8-46be-abc2-dd556684fd2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our base Library file has a `.h` and `.m` file already created for us, so all
    we have to do is fill in the code that is needed. Let''s go ahead and fill in
    the header file. Look at this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Right away, we can see that it looks very similar to C++, with the slight difference
    of syntax. Next up, let''s take a look at the `.m` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And, again, it''s pretty much the same as C++, where we just fill in what the
    method actually does. We can now build the project and get ready to import it
    into Unity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f427f6e-f87c-4f8b-863a-c1b534d2e344.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can open Unity after the project has been built and get ready for the
    fun part. Inside the `Plugins` folder that we previously created, create a new
    folder called `iOS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/48f0b748-900e-4ff9-a52e-d363d170ff1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the `iOS` folder, copy the `.h` and `.m` files that were created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4855414b-c518-409b-9d80-ceccecf3b430.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go over to the `PluginWrappers` folder and create a new script called
    `ObjectiveCWrapper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb37579b-135c-4c58-9cad-1bd1b4e5a0c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now open the class in C# and add our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about Objective-C is that it does not have the name mangling
    issues that C++ has, so we don't need to worry about doing the `extern` method
    before. Instead, due to the way code is compiled for iOS devices, we have to call
    `__internal`, instead of the name of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, we would have to build this for iOS and open it in Xcode to finish
    the compile process and either run it on an iPhone or the iPhone Simulator to
    test the results.
  prefs: []
  type: TYPE_NORMAL
- en: Java language plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the Java language plugin, we have two choices that work just fine. We have
    the Java Library, which compiles to a JAR file, and the Android Library, which
    compiles to AAR format. To access Android-specific functions, we need to create
    the Android Library, and for pure Java language usage, we would create the Java
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a major distinction between the two, and this should be discussed.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Android Library projects contain native and Java code along with resource files
    and an Android Manifest. They will include the `.class` files and `.jar` files
    that need to be precompiled into the Android Studio project, before being imported
    into Unity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Library projects are built directly to be JAR files, and they can be imported
    into Unity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these plugins need to be run on an Android device; this means you cannot
    test them in the editor; you must build and run on an emulator or on an actual
    device. If you want to get the best from plugins, using the Java Language. Android
    Library projects offer the most bang for your buck.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that being said, let’s open Android Studio and create our basic library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on File, highlight New, and locate New Module. The Module options window
    will open in a new window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/03dda026-b9fa-43d8-b119-3674436d52b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Android Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the option of selecting a Java Library or Android Library. As
    discussed previously, it is much more advantageous to use the Android Library,
    so select that one and click Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/96588a2f-a48a-44b1-b671-aca0e05ea9c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Library choices
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can name and configure our module. I will set the library name to be
    `AndroidLibrary`; the module name will automatically be made to be the name of
    the library in lowercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The package name will be changed to `com.packtpub.Androidlibrary`, and the
    Minimum SDK version will be `API 21: Android 5.0 (Lolipop)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c04678d-5647-4b02-870c-a00d50d17d11.png)'
  prefs: []
  type: TYPE_IMG
- en: Module setup
  prefs: []
  type: TYPE_NORMAL
- en: Once that has been set up, click Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the left-hand side of the Android Studio Editor, we can see the layout of
    the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fe0571f2-5362-4b6d-bfd4-b15ef6710f20.png)'
  prefs: []
  type: TYPE_IMG
- en: Layout
  prefs: []
  type: TYPE_NORMAL
- en: 'The main area we want to focus on is the `java` folder with the name of `com.packtpub.Androidlibrary`.
    We need to right-click on this specific one and add a new Java class to it. This
    will open a brand-new window to set up the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a388bc86-6e29-444e-b764-b0e52068f1c1.png)'
  prefs: []
  type: TYPE_IMG
- en: New class
  prefs: []
  type: TYPE_NORMAL
- en: I will name the class `Additions` to specify that we are just making a simple
    math library and then select the OK button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The procedure is the same for C#: we will just add a public `int` with the
    name of `AddMe` with the parameters of `int a` and `int b`, with the return being
    `a + b`. Your code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Click on the Build button at the top of the editor window, and click on Make
    Project. This will build the project for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s take a quick look at the output folder of the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/51ffa1e3-1328-44f0-bd68-eecfac0893a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the project folder
  prefs: []
  type: TYPE_NORMAL
- en: We can see here that we have quite a few folders and other miscellaneous files.
    The AAR file we need is located in the `AndroidLibrary` folder. The exact location
    would be Android library, Build, Outputs, AAR.
  prefs: []
  type: TYPE_NORMAL
- en: The AAR file is technically a zip file, so you can unzip and look at its contents
    by using "7zip"; however, this is the exact file we need to use in Unity. Now,
    it is time to open Unity and see how we can get Unity to interact with this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load up Unity, and let’s open our `Packtpub` project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we did previously, we will be using our `Plugins` and `PluginWrappers`
    folders for keeping things organized. Copy the AAR file into the `Plugins` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea9c9eb2-8d3c-41f2-8db2-2e896f677935.png)'
  prefs: []
  type: TYPE_IMG
- en: Plugins folder
  prefs: []
  type: TYPE_NORMAL
- en: In the `PluginWrappers` folder, create a C# class called `JavaWrapper`, and
    then open it in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code is slightly different than the C# and other native implementations.
    We will need a preprocessor directive to check whether this code is being executed
    in Android.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we will create a new Android Java Object with the string name of the class
    we created in Java.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will follow that up with a call of that class with the string value of the
    method we want, followed by the parameters. Your code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can’t test this code in the Unity Editor, but we can build the project
    out and test it on an Android device, after attaching it to a game object to run.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sensor driver in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, what if we wanted to implement our own sensor from the hardware provided?
    As it turns out, Google has already thought of that and has a very in-depth tutorial
    on creating and registering your own driver which can be viewed at [https://developer.Android.com/things/sdk/drivers/location](https://developer.android.com/things/sdk/drivers/location).
    I will go over a few of the items specified, but it is best to read what they
    wrote.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we will just look at the sample code provided that will make it so
    that we can convert GPS data as a plugin. The basic structure is exactly the same
    as the one we used to create our basic plugin in Java. The next step will be to
    write our code so that it returns the data so that it can be passed from the native
    plugin to Unity. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, all you need to do is compile the plugin as specified in the previous section
    and add it to Unity in exactly the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed various sensors that are generally available
    to us from mobile market devices. We have discussed how to create a basic plugin
    in the major languages for the different platforms at our disposal, and we now
    have all of the basic knowledge we need to get started making AR applications
    and games with Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take what we have learned so far and create a prototype
    project that will allow us to incorporate sound as the basis for an AR application.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before continuing to the next chapter, I would suggest taking the time to read
    some of the references I have provided in the further reading section that will
    give you insights on how to access various sensors for Android and Apple devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be extremely instrumental in you being able to solve the coding challenges
    presented in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple C++ plugin that works with Linux, Windows, and Mac desktop environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a plugin in Java that will allow the device to actively read the temperature
    for 10 seconds and display it on your device's screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a C# plugin that can access your web camera on your laptop, and send
    that information to the Unity Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following set of challenges are for those that have access to a Mac computer
    (if you don''t, you can modify these to be for Windows or Android):'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Swift plugin that will read a finger press on the screen and log the
    exact location of the finger press either via text or via display colors on the
    screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an Objective-C plugin that takes the information from the camera sensor
    and logs it in a text file in binary format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity is able to utilize plugins from C++:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: 'You create your own implementations for handling sensors to inject into Unity
    via plugins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use ARKit to create an Objective-C plugin for Unity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build Java plugins to be used with Unity that are targeted at iOS devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift plugins are easier to develop than Objective-C plugins for Unity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fingerprint sensor is only available on Android devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: 'A camera is technically a sensor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: 'A gyroscope is used all the time in iOS and Android devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: 'A thermometer sensor is used to keep track of and measure the temperature of
    sensitive components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: 'An accelerometer is not a sensor designed to detect the momentum of the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.) True
  prefs: []
  type: TYPE_NORMAL
- en: B.) False
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation is always the best place to learn more about the
    sensors. Check out the following link for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.Android.com/guide/topics/sensors/sensors_overview](https://developer.android.com/guide/topics/sensors/sensors_overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/documentation/coremotion](https://developer.apple.com/documentation/coremotion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/documentation/coremotion/cmsensorrecorder](https://developer.apple.com/documentation/coremotion/cmsensorrecorder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
