<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Positions, Movement and Navigation for Character GameObjects</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Player control of a 2D GameObject (and limiting the movement within a rectangle)</li><li class="listitem" style="list-style-type: disc">Player control of a 3D GameObject (and limiting the movement within a rectangle)</li><li class="listitem" style="list-style-type: disc">Choosing destinations – find the nearest (or a random) spawn point </li><li class="listitem" style="list-style-type: disc">Choosing destinations – respawn to the most recently passed checkpoint</li><li class="listitem" style="list-style-type: disc">NPC NavMeshAgent to seek or flee destination while avoiding obstacles</li><li class="listitem" style="list-style-type: disc">NPC NavMeshAgent to follow waypoints in sequence</li><li class="listitem" style="list-style-type: disc">Controlling the object group movement through flocking</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Introduction</h1></div></div></div><p>Many GameObjects in games move! Movement can be controlled by the player, by the (simulated) laws of physics in the environment, or by<a class="indexterm" id="id840"/> the <strong>Non-Player Character</strong> (<strong>NPC</strong>) logic; for example, objects that follow a path of waypoints, or seek (move towards) or flee (away) from the current position of a character. Unity provides several controllers, for first and third-person characters, and for vehicles such as cars and airplanes. GameObject movement can also be controlled through the state machines of the Unity Mecanim animation system.</p><p>However, there maybe times when you wish to tweak the Player character controllers from Unity, or write your own. You might wish to write directional logic—simple or sophisticated <strong>Artificial Intelligence</strong> (<strong>AI</strong>) to control the game's NPC and enemy characters. Such AI might involve your computer program making objects orient and move towards or away from <a class="indexterm" id="id841"/>characters or other game objects.</p><p>This chapter presents a range of such directional recipes, from which many games can benefit in terms of a richer and more exciting user experience.</p><p>Unity provides sophisticated classes and components including the Vector3 class and rigid body physics for modeling realistic movements, forces, and collisions in games. We make use of these game engine features to implement some sophisticated NPC and enemy character movements in the recipes of this chapter.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec227"/>The big picture</h2></div></div></div><p>For 3D games (and to some extent, 2D games as well), a fundamental class of object is the Vector3 class—objects<a class="indexterm" id="id842"/> that store and manipulate (x,y,z) values representing locations in 3D space. If we draw an imaginary arrow from the origin (0,0,0) to a point on space, then the direction and length of this arrow (vector) can represent a velocity or force (that is, a certain amount of magnitude in a certain direction).</p><p>If we ignore all the character controller components, colliders, and the physics system in Unity, we can write code that teleports objects directly to a particular (x, y, z) location in our scene. And sometimes this is just what we want to do; for example, we may wish to spawn an object at a location. However, in most cases, if we want objects to move in more physically realistic ways, then we either apply a force to the object, or change its velocity component. Or if it has a Character Controller component, then we can send it a <code class="literal">Move()</code> message. With the introduction of Unity NavMeshAgents (and associated Navigation Meshes), we can now set a destination for an object with a NavMeshAgent, and then the built-in pathfinding logic will do the work of moving our NPC object on a path towards the given (x, y, z) destination location.</p><p>As well as deciding which technique will be used to move an object, our game must also do the work of deciding how to choose the destination locations, or the direction and magnitude of changes to movement. This can involve logic to tell an NPC or enemy object the destination of the Player's character (to be moved towards, and then perhaps attacked when close enough). Or perhaps shy NPC objects will be given the direction to the Player's character, so that they can flee in the opposite direction, until they are a safe distance away.</p><p>Other core concepts in the NPC object movement and creation (instantiation) include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spawn points<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Specific locations in the scene where objects are to be created, or moved to</li></ul></div></li><li class="listitem" style="list-style-type: disc">Waypoints<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The sequence of locations to define a path for NPCs or perhaps, the Player's character to follow</li></ul></div></li><li class="listitem" style="list-style-type: disc">Checkpoints<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Locations (or colliders) that, once passed through, change what happens in the game (for example, extra time, or if a Player's character gets killed, they respawn to the last crossed checkpoint, and so on)</li></ul></div></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Player control of a 2D GameObject (and limiting the movement within a rectangle)</h1></div></div></div><p>While the rest of the recipes in this chapter are demonstrated in 3D projects, basic character movement in 2D, and also limiting the movement to a bounding rectangle, are core skills for many<a class="indexterm" id="id843"/> 2D games, and so this first recipe illustrates how to achieve these features for a 2D game.</p><p>Since in <a class="link" href="ch03.html" title="Chapter 3. 2D Animation">Chapter 3</a>, <em>Inventory GUI</em>, we already have a basic 2D game, we'll adapt this game to restrict the movement to a bounding rectangle.</p><div><img alt="Player control of a 2D GameObject (and limiting the movement within a rectangle)" src="img/1362OT_08_11.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec228"/>Getting ready</h2></div></div></div><p>This recipe builds on a simple 2D game called <em>Creating the Simple2DGame_SpaceGirl</em> mini-game from <a class="link" href="ch03.html" title="Chapter 3. 2D Animation">Chapter 3</a>, <em>Inventory GUI</em>. Start with a copy of this game, or use the provided completed recipe project as the basis for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec229"/>How to do it...</h2></div></div></div><p>To create a 2D <a class="indexterm" id="id844"/>sprite controlled by the user with the movement that is limited within a rectangle, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new empty GameObject named <strong>corner_max</strong>, and position it somewhere above and to the right of the GameObject called <strong>Player-girl1</strong>. With this GameObject selected in the <strong>Hierarchy</strong> view, choose the large yellow oblong icon, highlighted in the <strong>Inspector</strong> panel.<div><img alt="How to do it..." src="img/1362OT_08_18.jpg"/></div></li><li class="listitem">Duplicate the <strong>corner_max</strong> GameObject by naming the clone as <strong>corner_min</strong>, and position this clone somewhere below and to the left of the <strong>player-spaceGirl1</strong> GameObject. The coordinates of these two GameObjects will determine the maximum and minimum bounds of movement, permitted for the player's character.</li><li class="listitem">Modify the C# Script called <code class="literal">PlayerMove</code> to declare some new variables at the beginning of the class:<div><pre class="programlisting">public Transform corner_max;
public Transform corner_min;
private float x_min;
private float y_min;
private float x_max;
private float y_max;</pre></div></li><li class="listitem">Modify the C# Script called <code class="literal">PlayerMove</code> so that the <code class="literal">Awake()</code> method now gets a reference to the SpriteRenderer, and uses this object to help setup the maximum and <a class="indexterm" id="id845"/>minimum X and Y movement limits:<div><pre class="programlisting">void Awake(){
  rigidBody2D = GetComponent&lt;Rigidbody2D&gt;();
  x_max = corner_max.position.x;
  x_min = corner_min.position.x;
  y_max = corner_max.position.y;
  y_min = corner_min.position.y;
}</pre></div></li><li class="listitem">Modify the C# Script called <code class="literal">PlayerMove</code> to declare a new method called <code class="literal">KeepWithinMinMaxRectangle()</code>:<div><pre class="programlisting">  private void KeepWithinMinMaxRectangle(){
    float x = transform.position.x;
    float y = transform.position.y;
    float z = transform.position.z;
    float clampedX = Mathf.Clamp(x, x_min, x_max);
    float clampedY = Mathf.Clamp(y, y_min, y_max);
    transform.position = new Vector3(clampedX, clampedY, z);
  }</pre></div></li><li class="listitem">Modify the C# Script called <code class="literal">PlayerMove</code> so that, after having done everything else in the <code class="literal">FixedUpdate()</code>method, a call will finally be made to the <code class="literal">KeepWithinMinMaxRectangle()</code> method:<div><pre class="programlisting">  void FixedUpdate(){
    float xMove = Input.GetAxis("Horizontal");
    float yMove = Input.GetAxis("Vertical");

    float xSpeed = xMove * speed;
    float ySpeed = yMove * speed;

    Vector2 newVelocity = new Vector2(xSpeed, ySpeed);

    rigidBody2D.velocity = newVelocity;	

    // restrict player movement
    KeepWithinMinMaxRectangle();
  }</pre></div></li><li class="listitem">With the <strong>player-SpaceGirl1</strong> GameObject in the <strong>Hierarchy</strong> view, drag the <strong>corner_max</strong> and <strong>corner_min</strong> GameObjects over the public variables called <code class="literal">corner_max</code> and <code class="literal">corner_min</code> in the <strong>Inspector</strong>.</li><li class="listitem">Before running the scene in the <strong>Scene</strong> panel, try repositioning the <strong>corner_max</strong> and <strong>corner_min </strong>GameObjects. When you run the scene, the positions of these two GameObjects (max and min, and X and Y) will be used as the limits of movement for the Player's <strong>player-SpaceGirl1</strong> character.</li><li class="listitem">While all this <a class="indexterm" id="id846"/>works fine, let's make the rectangular bounds of the movement visually explicit in the <strong>Scene</strong> panel by having a yellow "gizmo" rectangle drawn. Add the following method to the C# script class called <code class="literal">PlayerMove</code>:<div><pre class="programlisting">void OnDrawGizmos(){
  Vector3 top_right = Vector3.zero;
  Vector3 bottom_right = Vector3.zero;
  Vector3 bottom_left = Vector3.zero;
  Vector3 top_left = Vector3.zero;

  if(corner_max &amp;&amp; corner_min){
    top_right = corner_max.position;
    bottom_left = corner_min.position;

    bottom_right = top_right;
    bottom_right.y = bottom_left.y;

    top_left = top_right;
    top_left.x = bottom_left.x;
  }

  //Set the following gizmo colors to YELLOW
  Gizmos.color = Color.yellow;

  //Draw 4 lines making a rectangle
  Gizmos.DrawLine(top_right, bottom_right);
  Gizmos.DrawLine(bottom_right, bottom_left);
  Gizmos.DrawLine(bottom_left, top_left);
  Gizmos.DrawLine(top_left, top_right);
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec230"/>How it works...</h2></div></div></div><p>You added the empty GameObjects called <strong>corner_max</strong> and <strong>corner_min</strong> to the scene. The X- and Y- coordinates of these GameObjects will be used to determine the bounds of movement that we will permit for the character called <strong>player-SpaceGirl1</strong>. Since these are the empty GameObjects, they will not be seen by the player when in the play-mode. However, we can see and move them in the <strong>Scene</strong> panel, and having added the yellow oblong icons, we can see their positions and names very easily.</p><p>Upon <code class="literal">Awake()</code> the <code class="literal">PlayerMoveWithLimits</code> object, inside the <strong>player-SpaceGirl1</strong> GameObject, records the maximum and minimum X- and Y- values of the GameObjects called <strong>corner_max</strong> and <strong>corner_min</strong>. Each time the physics system is called via the <code class="literal">FixedUpdate()</code> method, the velocity of the <strong>player-SpaceGirl1 </strong>character is set according to the horizontal and vertical keyboard/joystick inputs. However, the final action of the <code class="literal">FixedUpdate() </code>method is to call the <code class="literal">KeepWithinMinMaxRectangle() </code>method, which uses the <code class="literal">Math.Clamp(…)</code> function to move the character back inside the X- and Y- limits. This happens so that the player's character is not permitted to move outside the area <a class="indexterm" id="id847"/>defined by the <strong>corner_max</strong> and <strong>corner_min</strong> GameObjects.</p><p>The <code class="literal">OnDrawGizmos() m</code>ethod tests<a class="indexterm" id="id848"/> that the references to the <strong>corner_max</strong> and <strong>corner_min</strong> GameObjects are not null, and then sets the positions of the four Vector3 objects, representing the four corners defined by the rectangle with <strong>corner_max</strong> and <strong>corner_min</strong> at the opposite corners. It then sets the Gizmo color to yellow, and draws lines, connecting the four corners in the <strong>Scene</strong> panel.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec231"/>See also</h2></div></div></div><p>Refer to the next recipe for more information about limiting player controlled character movements.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Player control of a 3D GameObject (and limiting the movement within a rectangle)</h1></div></div></div><p>Many of the <a class="indexterm" id="id849"/>3D recipes in this chapter are built on this basic project, which constructs a scene with a textured terrain, a <strong>Main Camera</strong>, and a red cube that can be moved around by the user with the four directional arrow keys. The bounds of movement of the cube are constrained using the same technique as in the previous 2D recipe.</p><div><img alt="Player control of a 3D GameObject (and limiting the movement within a rectangle)" src="img/1362OT_08_01.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec232"/>How to do it...</h2></div></div></div><p>To create a basic 3D <a class="indexterm" id="id850"/>cube controlled game, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new, empty 3D project.</li><li class="listitem">Once the project has been created, import the single Terrain Texture named <code class="literal">SandAlbedo</code> (it was named <code class="literal">GoodDirt</code> in Unity 4). Choose menu: <strong>Assets | Import Package | Environments</strong>, deselect everything, and then locate and tick the asset: <code class="literal">Assets/Environment/TerrainAssets/SurfaceTextures/ SandAlbedo.psd</code>.<div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>You could have just added the Environment Asset Package when creating the project—but this would have imported 100s of files, and we only needed this one. Starting a project in Unity, then selectively importing just what we need is the best approach to take, if you want to keep the project's Asset folders to small sizes.</p></div></div></li><li class="listitem">Create a terrain positioned at (-15, 0, -10) and sized 30 by 20.<div><div><h3 class="title"><a id="note37"/>Note</h3><p>The transform position for the terrains relates to their corner and not their center.</p><p>Since the Transform position of the terrains relates to the corner of the object, we center such objects at (0,0,0) by setting the X-coordinate equal to ( -1*width/2), and the Z-coordinate equal to (-1*length/2). In other words, we slide the object by half its width and half its height to ensure that its center is just where we want it.</p><p>In this case, the width is 30 and the length is 20, hence we get -15 for X (-1 * 30/2), and -10 for Z (-1 * 20/2).</p></div></div></li><li class="listitem">Texture paint this terrain with your texture called <code class="literal">SandAlbedo</code>.</li><li class="listitem">Create a <a class="indexterm" id="id851"/>directional light (it should face downwards to the terrain with the default settings—but if it doesn't for some reason, then rotate it so that the terrain is well lit).</li><li class="listitem">Make the following changes to the Main Camera:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">position = (0, 20, -15)</li><li class="listitem" style="list-style-type: disc">rotation = (60, 0, 0)</li></ul></div></li><li class="listitem">Change the <strong>Aspect Ratio</strong> of the <strong>Game Panel</strong> from <strong>Free Aspect</strong> to <strong>4:3</strong>. You will now see the whole of the <strong>Terrain</strong> in the <strong>Game Panel</strong>.</li><li class="listitem">Create a new empty GameObject named <strong>corner_max</strong>, and position it at (14, 0, 9). With this GameObject selected in the <strong>Hierarchy,</strong> choose the large, yellow oblong icon, highlighted in the <strong>Inspector</strong> panel.</li><li class="listitem">Duplicate the <strong>corner_max</strong> GameObject, naming the clone as <strong>corner_min</strong>, and position this clone at (-14, 0, -9). The coordinates of these two GameObjects will determine the maximum and minimum bounds of the movement permitted for the player's character.</li><li class="listitem">Create a new <strong>Cube </strong>GameObject named <strong>Cube-player</strong> at a position called (0, 0.5, 0), and size it as (1,1,1).</li><li class="listitem">Add to the <strong>Cube-player </strong>GameObject, apply a component called <strong>Physics | RigidBody</strong>, and uncheck the <strong>RigidBody</strong> property <strong>Use Gravity</strong>.</li><li class="listitem">Create a red <strong>Material</strong> named <strong>m_red</strong>, and apply this <strong>Material</strong> to <strong>Cube-player</strong>.</li><li class="listitem">Add the following C# script class called <code class="literal">PlayerControl</code> to the <strong>Cube-player</strong>:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class PlayerControl : MonoBehaviour {
  public Transform corner_max;
  public Transform corner_min;

  public float speed = 40;
  private Rigidbody rigidBody;

  private float x_min;
  private float x_max;
  private float z_min;
  private float z_max;

  void Awake (){
    rigidBody = GetComponent&lt;Rigidbody&gt;();
    x_max = corner_max.position.x;
    x_min = corner_min.position.x;
    z_max = corner_max.position.z;
    z_min = corner_min.position.z;
  }

  void FixedUpdate() {
    KeyboardMovement();
    KeepWithinMinMaxRectangle();
  }

  private void KeyboardMovement (){
    float xMove = Input.GetAxis("Horizontal") * speed * Time.deltaTime;
    float zMove = Input.GetAxis("Vertical") * speed * Time.deltaTime;

    float xSpeed = xMove * speed;
    float zSpeed = zMove * speed;

    Vector3 newVelocity = new Vector3(xSpeed, 0, zSpeed);

    rigidBody.velocity = newVelocity;	

    // restrict player movement
    KeepWithinMinMaxRectangle ();
  }

  private void KeepWithinMinMaxRectangle (){
    float x = transform.position.x;
    float y = transform.position.y;
    float z = transform.position.z;
    float clampedX = Mathf.Clamp(x, x_min, x_max);
    float clampedZ = Mathf.Clamp(z, z_min, z_max);
    transform.position = new Vector3(clampedX, y, clampedZ);
  }

  void OnDrawGizmos (){
    Vector3 top_right = Vector3.zero;
    Vector3 bottom_right = Vector3.zero;
    Vector3 bottom_left = Vector3.zero;
    Vector3 top_left = Vector3.zero;

    if(corner_max &amp;&amp; corner_min){
      top_right = corner_max.position;
      bottom_left = corner_min.position;

      bottom_right = top_right;
      bottom_right.z = bottom_left.z;

      top_left = bottom_left;
      top_left.z = top_right.z;
    } 

    //Set the following gizmo colors to YELLOW
    Gizmos.color = Color.yellow;

    //Draw 4 lines making a rectangle
    Gizmos.DrawLine(top_right, bottom_right);
    Gizmos.DrawLine(bottom_right, bottom_left);
    Gizmos.DrawLine(bottom_left, top_left);
    Gizmos.DrawLine(top_left, top_right);
  }
}</pre></div></li><li class="listitem">With the <strong>Cube-player</strong> GameObject selected in the <strong>Hierarchy,</strong> drag the GameObjects called <strong>corner_max</strong> and <strong>corner_min</strong> over the public variables called <code class="literal">corner_max</code> and <code class="literal">corner_min</code> in the <strong>Inspector</strong> panel.</li><li class="listitem">When you <a class="indexterm" id="id852"/>run the scene, the positions of the <strong>corner_max</strong> and <strong>corner_min</strong> GameObjects will define the bounds of movement for the Player's <strong>Cube-player</strong> character.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec233"/>How it works...</h2></div></div></div><p>The scene contains a positioned terrain so that its center is <code class="literal">(0,0,0)</code>. The red cube is controlled by the user's arrow keys through the <code class="literal">PlayerControl</code> script.</p><p>Just as with the previous 2D recipe, a reference to the (3D) RigidBody component is stored when the <code class="literal">Awake()</code> method executes, and the maximum and minimum X- and Z- values are retrieved from the two corner GameObjects, and is stored in the <code class="literal">x_min</code>, <code class="literal">x_max</code>, <code class="literal">z_min</code>, and <code class="literal">z_max</code> variables. Note that for this basic 3D game, we won't allow any Y-movement, although such movement (and bounding limits by adding a third 'max-height' corner GameObject) can be easily added by extending the code in this recipe.</p><p>The <code class="literal">KeyboardMovement() m</code>ethod reads<a class="indexterm" id="id853"/> the horizontal and vertical input values (which the Unity default settings read from the four directional arrow keys). Based on these left-right and up-down <a class="indexterm" id="id854"/>values, the velocity of the cube is updated. The amount it will move depends on the speed variable.</p><p>The <code class="literal">KeepWithinMinMaxRectangle()</code> method uses the <code class="literal">Math.Clamp(…)</code> function to move the character back inside the<a class="indexterm" id="id855"/> X and Z limits, so that the player's character is not permitted to move outside the area defined by the <strong>corner_max</strong> and <strong>corner_min</strong> GameObjects.</p><p>The <code class="literal">OnDrawGizmos()</code> method tests<a class="indexterm" id="id856"/> that the references to the <strong>corner_max</strong> and <strong>corner_min</strong> GameObjects are not null, and then sets the positions of the four Vector3 objects, representing the four corners defined by the rectangle with the <strong>corner_max</strong> and <strong>corner_min</strong> GameObjects at the opposite corners. It then sets the Gizmo color to <strong>yellow</strong>, and draws lines connecting the four corners in the <strong>Scene</strong> panel.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec82"/>Choosing destinations – find the nearest (or a random) spawn point</h1></div></div></div><p>Many games make use of spawn points and waypoints. This recipe demonstrates two very common examples of spawning—the choosing of either a random spawn point, or the nearest one to<a class="indexterm" id="id857"/> an object of interest (such as the Player's character), and then the instantiation of an object at that chosen point.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec234"/>Getting ready</h2></div></div></div><p>This recipe builds upon the previous recipe. So, make a copy of this project, open it, and then follow the next steps.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec235"/>How to do it...</h2></div></div></div><p>To find a random <a class="indexterm" id="id858"/>spawn point, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <strong>Sphere</strong> sized as (1,1,1) at (2,2,2) position, and apply the <code class="literal">m_red</code> Material.</li><li class="listitem">Create a new Prefab named <code class="literal">Prefab-ball</code>, and drag your <strong>Sphere</strong> into it (and then delete the <strong>Sphere</strong> from the <strong>Hierarchy</strong> panel).</li><li class="listitem">Create a new capsule object named <code class="literal">Capsule-spawnPoint</code> at (3, 0.5, 3), give it the tag as <code class="literal">Respawn</code> (this is one of the default tags that Unity provides).<div><div><h3 class="title"><a id="note38"/>Note</h3><p>For testing, we'll leave these Respawn points visible. For the final game, we'll then uncheck the Mesh Rendered of each Respawn GameObject, so that they are not visible to the Player.</p></div></div></li><li class="listitem">Make<a class="indexterm" id="id859"/> several copies of your <strong>Capsule-spawnPoint</strong> by moving them to different locations on the terrain.</li><li class="listitem">Add an<a class="indexterm" id="id860"/> instance of the following C# script class called <code class="literal">SpawnBall</code> to the <strong>Cube-the player</strong> GameObject:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class SpawnBall : MonoBehaviour {
  public GameObject prefabBall;
  private SpawnPointManager spawnPointManager;
  private float destroyAfterDelay = 1;
  private float testFireKeyDelay = 0;

  void Start (){
    spawnPointManager = GetComponent&lt;SpawnPointManager&gt; ();
    StartCoroutine("CheckFireKeyAfterShortDelay");
  }

  IEnumerator CheckFireKeyAfterShortDelay () {
    while(true){
      yield return new WaitForSeconds(testFireKeyDelay);
      // having waited, now we check every frame
      testFireKeyDelay = 0; 
      CheckFireKey();
    }
  }

  private void CheckFireKey() {
    if(Input.GetButton("Fire1")){
      CreateSphere();
      // wait half-second before alling next spawn
      testFireKeyDelay = 0.5f;
    }
  }

  private void CreateSphere(){
    GameObject spawnPoint = spawnPointManager.RandomSpawnPoint ();
    GameObject newBall = (GameObject)Instantiate (prefabBall, spawnPoint.transform.position, Quaternion.identity);
    Destroy(newBall, destroyAfterDelay);
  }
}</pre></div></li><li class="listitem">Add an<a class="indexterm" id="id861"/> instance of the following C# script class called <code class="literal">SpawnPointManager</code> to the <code class="literal">Cube-player</code> GameObject:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class SpawnPointManager : MonoBehaviour {
  private GameObject[] spawnPoints;

  void Start() {
    spawnPoints = GameObject.FindGameObjectsWithTag("Respawn");
  }

  public GameObject RandomSpawnPoint (){
    int r = Random.Range(0, spawnPoints.Length);
    return spawnPoints[r];
  }
}</pre></div></li><li class="listitem">Ensure<a class="indexterm" id="id862"/> that <strong>Cube-player</strong> is selected in the <strong>Inspector</strong> for the <code class="literal">SpawnBall</code> scripted component. Then, drag <strong>Prefab-ball</strong> over the public variable projectile called <strong>Prefab Ball</strong>.</li><li class="listitem">Now, run your game. When you click on the mouse (fire) button, a sphere will be instantiated randomly to one of the capsule locations.<div><img alt="How to do it..." src="img/1362OT_08_04.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec236"/>How it works...</h2></div></div></div><p>The <strong>Capsule-spawnPoint</strong> objects<a class="indexterm" id="id863"/> represent candidate locations, where we might wish to create an instance of our ball Prefab. When our <code class="literal">SpawnPointManager</code> object, inside the <strong>Cube-player</strong> GameObject, receives the <code class="literal">Start()</code> message, the <strong>respawns</strong> GameObject array is set to the array, which is returned from the call to <code class="literal">FindGameObjectsWithTag("Respawn")</code>. This creates an array of all the objects in the scene with the tag called <code class="literal">Respawn</code> — that is, all our <strong>Capsule-spawnPoint</strong> objects.</p><p>When our<a class="indexterm" id="id864"/> <code class="literal">SpawnBall</code> object GameObject <strong>Cube-player</strong> receives the <code class="literal">Start()</code> message, it sets the <code class="literal">spawnPointManager</code> variable to be a reference to its sibling <code class="literal">SpawnPointManager</code> script component. Next, we start the <strong>coroutine</strong> method called <a class="indexterm" id="id865"/>
<code class="literal">CheckFireKeyAfterShortDelay()</code>.</p><p>The <code class="literal">CheckFireKeyAfterShortDelay()</code> method uses a typical Unity coroutine technique that goes into an infinite loop using a delay controlled by the value of the <code class="literal">testFireKeyDelay</code> variable. The delay is to make Unity wait before calling <code class="literal">CheckFireKey()</code> to test if the user wants a new sphere to be spawned.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>Coroutines are an advanced technique, where execution inside the method can be paused, and resumed from the same point. The <code class="literal">Yield</code> command temporarily halts the execution of code in the method, allowing Unity to go off and execute code in the other GameObjects and undertake physics and rendering work and more. They are perfect for situations where, at regular intervals, we wish to check whether something has happened (such as testing for the Fire key, or whether a response message has been received from an Internet request and so on).</p><p>Learn more<a class="indexterm" id="id866"/> about the Unity coroutines at <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html">http://docs.unity3d.com/Manual/Coroutines.html</a>.</p></div></div><p>The <code class="literal">SpawnBall</code> method <code class="literal">CheckFireKey()</code> tests whether, at that instant, the user is pressing the <strong>Fire</strong> button. If the <strong>Fire</strong> button is pressed, then the <code class="literal">CreateSphere()</code>method is called. Also, the <code class="literal">testFireKeyDelay</code> variable is set to 0.5. This ensures that we won't test the <strong>Fire</strong> button again for half a second.</p><p>The<a class="indexterm" id="id867"/> <code class="literal">SpawnBall</code> method <code class="literal">CreateSphere()</code>assigns variable <code class="literal">spawnPoint</code> to the <code class="literal">GameObject</code> returned by a call to the <code class="literal">RandomSpawnpoint(…)</code> method of our <code class="literal">spawnPointManager</code>. Then it creates a new instance of <code class="literal">prefab_Ball</code> (via the public variable) at the same position as the <code class="literal">spawnPoint</code> GameObject.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec237"/>There's more...</h2></div></div></div><p>There are some details that you don't want to miss.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec56"/>Choosing the nearest spawn point</h3></div></div></div><p>Rather than just choosing a random spawn point, let's search through array spawnpoints, and choose the closest one to our player.</p><p>To find the nearest<a class="indexterm" id="id868"/> spawn point, we need to do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following method to the C# script class called <code class="literal">SpawnPointManager</code>:<div><pre class="programlisting">public GameObject NearestSpawnpoint (Vector3 source){
  GameObject nearestSpawnPoint = spawnPoints[0];
  Vector3 spawnPointPos = spawnPoints[0].transform.position;
  float shortestDistance = Vector3.Distance(source, spawnPointPos);

  for (int i = 1; i &lt; spawnPoints.Length; i++){
    spawnPointPos = spawnPoints[i].transform.position;
    float newDist = Vector3.Distance(source, spawnPointPos);
    if (newDist &lt; shortestDistance){
      shortestDistance = newDist;
      nearestSpawnPoint = spawnPoints[i];
    }
  }

  return nearestSpawnPoint;
}</pre></div></li><li class="listitem">We now need to change the first line in the C# class called <code class="literal">SpawnBall</code> so that the <code class="literal">spawnPoint</code> variable is set by a call to our new method called <code class="literal">NearestSpawnpoint(…)</code>:<div><pre class="programlisting">private void CreateSphere(){
  GameObject spawnPoint = spawnPointManager.NearestSpawnpoint(transform.position);

  GameObject newBall = (GameObject)Instantiate (prefabBall, spawnPoint.transform.position, Quaternion.identity);
  Destroy(newBall, lifeDuration);
}</pre></div></li></ol></div><p>In the <code class="literal">NearestSpawnpoint(…)</code> method, we set <code class="literal">nearestSpawnpoint</code> to the first (array index 0) GameObject in the array as our default. We then loop through the rest of the array (array index 1 up to <code class="literal">spawnPoints.Length</code>). For each GameObject in the array, we test to see if its distance is less than the shortest distance so far, and if it is, then we update the shortest<a class="indexterm" id="id869"/> distance, and also set <code class="literal">nearestSpawnpoint </code>to the current element. When the array has been searched, we return the GameObject that the <code class="literal">nearestSpawnpoint</code> variable refers to.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec57"/>Avoiding errors due to an empty array</h3></div></div></div><p>Let's make our code a little <a class="indexterm" id="id870"/>more robust, so that it can cope with the issue of an empty <code class="literal">spawnPoints</code> array—that is, when there are no objects tagged <strong>Respawn</strong> in the scene.</p><p>To cope with the no objects tagged <strong>Respawn</strong> we need to do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Improve our <code class="literal">Start()</code> method in the C# script class called <code class="literal">SpawnPointManager</code>, so that an ERROR is logged if the array of objects tagged <strong>Respawn</strong> is empty:<div><pre class="programlisting">public GameObject NearestSpawnpoint (Vector3 source){
void Start() {
  spawnPoints = GameObject.FindGameObjectsWithTag("Respawn");

  // logError if array empty
  if(spawnPoints.Length &lt; 1) Debug.LogError ("SpawnPointManagaer - cannot find any objects tagged 'Respawn'!");
}</pre></div></li><li class="listitem">Improve the <code class="literal">RandomSpawnPoint()</code> and <code class="literal">NearestSpawnpoint()</code>methods in the C# script class called <code class="literal">SpawnPointManager</code>, so that they still return a GameObject even if the array is empty:<div><pre class="programlisting">public GameObject RandomSpawnPoint (){
  // return current GameObject if array empty
  if(spawnPoints.Length &lt; 1) return null;

// the rest as before ...</pre></div></li><li class="listitem">Improve the<a class="indexterm" id="id871"/> <code class="literal">CreateSphere()</code>method in the C# class called <code class="literal">SpawnBall</code>, so that we only attempt to instantiate a new GameObject if the <code class="literal">RandomSpawnPoint()</code> and <code class="literal">NearestSpawnpoint()</code>methods have returned a non-null object reference:<div><pre class="programlisting">private void CreateSphere(){
  GameObject spawnPoint = spawnPointManager.RandomSpawnPoint ();

  if(spawnPoint){
    GameObject newBall = (GameObject)Instantiate (prefabBall, spawnPoint.transform.position, Quaternion.identity);
    Destroy(newBall, destroyAfterDelay);
  }
}</pre></div></li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec238"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The same techniques and code can be used for selecting spawn points or waypoints. Refer to the <em>NPC NavMeshAgent control to follow waypoints in sequence</em> recipe in this chapter for more information about waypoints.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec83"/>Choosing destinations – respawn to the most recently passed checkpoint</h1></div></div></div><p>A <strong>checkpoint</strong> usually<a class="indexterm" id="id872"/> represents a certain distance through the game (or perhaps a <strong>track</strong>) in which<a class="indexterm" id="id873"/> an agent (user or NPC) has succeeded reaching. Reaching (or passing) checkpoints often results in bonus awards, such as <em>extra time</em>, <em>points</em>, <em>ammo</em>, and so on. Also, if a player has multiple lives, then often a player will be respawned only back as far as the most recently passed checkpoint, rather than right to the beginning of the level.</p><p>This recipe demonstrates a simple approach to the checkpoints, whereby once the player's character has passed a<a class="indexterm" id="id874"/> checkpoint, if they die they are moved back only to the most recently passed checkpoint.</p><div><img alt="Choosing destinations – respawn to the most recently passed checkpoint" src="img/1362OT_08_09.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec239"/>Getting ready</h2></div></div></div><p>This recipe builds upon the player-controlled 3D cube Unity project that you created at the beginning of this chapter. So, make a copy of this project, open it, and then follow the steps for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec240"/>How to do it...</h2></div></div></div><p>To have the respawn <a class="indexterm" id="id875"/>position upon losing a life change depending on the checkpoints passed, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Move the <strong>Cube-player</strong> GameObject to the (12, 0.5, 0) position.</li><li class="listitem">Select <strong>Cube-player</strong> in the <strong>Inspector</strong> panel and add a <strong>Character Controller</strong> component by clicking on <strong>Add Component</strong> | <strong>Physics</strong> | <strong>Character Controller</strong> (this is to enable the <code class="literal">OnTriggerEnter</code> collision messages to be received).</li><li class="listitem">Create a cube named <strong>Cube-checkpoint-1</strong> at (5, 0, 0), scaled to (1, 1, 20).</li><li class="listitem">With <strong>Cube-checkpoint-1</strong> selected, check the <strong>Is Trigger</strong> property of its <strong>Box Collider</strong> component in the <strong>Inspector</strong> panel.</li><li class="listitem">Create a <strong>CheckPoint</strong> tag, and assign this tag to <strong>Cube-checkpoint-1</strong>.</li><li class="listitem">Duplicate <strong>Cube-checkpoint-1</strong> by naming the <strong>Cube-checkpoint-2</strong> clone and positioning it at (-5, 0, 0).</li><li class="listitem">Create a sphere named <strong>Sphere-Death</strong> at (7, 0.5, 0). Assign the <strong>m_red</strong> material to this sphere to make it red.</li><li class="listitem">With <strong>Sphere-Death</strong> selected, check the <strong>Is Trigger</strong> property of its <strong>Sphere Collider</strong> component in the <strong>Inspector</strong> panel.</li><li class="listitem">Create a <strong>Death</strong> tag, and assign this tag to <strong>Sphere-Death</strong>.</li><li class="listitem">Duplicate<a class="indexterm" id="id876"/> <strong>Sphere-Death</strong>, and position this clone at (0, 0.5, 0).</li><li class="listitem">Duplicate <strong>Sphere-Death</strong> a second time, and position this second clone at (-10, 0.5, 0).</li><li class="listitem">Add an instance of the following C# script class called <code class="literal">CheckPoints</code> to the <strong>Cube-player</strong> GameObject:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class CheckPoints : MonoBehaviour {
  private Vector3 respawnPosition;

  void Start (){
    respawnPosition = transform.position;
  }

  void OnTriggerEnter (Collider hit){
    if(hit.CompareTag("CheckPoint")){
      respawnPosition = transform.position;
    }

    if(hit.CompareTag("Death")){
      transform.position = respawnPosition;
    }
  }
}</pre></div></li><li class="listitem">Run the scene. If the cube runs into a red sphere <em>before</em> crossing a checkpoint, it will be respawned back to its starting position. Once the red cube has passed a checkpoint, if a red sphere is hit, then the cube will be moved back to the location of the most recent checkpoint that it passed through.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec241"/>How it works...</h2></div></div></div><p>The C# script class called <code class="literal">CheckPoints</code> has one variable called <code class="literal">respawnPosition</code>, which is a Vector3 that refers to the position the player's cube is to be moved to (respawned) if it collides with a <strong>Death</strong> tagged object. The default setting for this is the position of the player's cube when the scene begins—so in the <code class="literal">Start()</code>method, we set it to the player's <a class="indexterm" id="id877"/>position.</p><p>Each time an object tagged called <strong>CheckPoint</strong> is collided with, the value of <code class="literal">respawnPosition</code> is updated to the current position of the player's red cube at this point in time (that is, where it is when it touches the stretched cube tagged called <strong>CheckPoint</strong>). So that the next time the object tagged <strong>Death</strong> is hit, the cube will be respawned back to where it last touched the object tagged called <strong>CheckPoint</strong>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec84"/>NPC NavMeshAgent to seek or flee destination while avoiding obstacles</h1></div></div></div><p>The introduction of Unity's NavMeshAgent has greatly simplified the coding for NPC and enemy agent behaviors. In this recipe, we'll add some wall (scaled cubes) obstacles, and generate a NavMesh, so that Unity knows not to try to walk through the walls. We then add a NavMeshAgent <a class="indexterm" id="id878"/>component to our NPC GameObject, and tell it to head to a stated destination location by intelligently planning and following a path, while avoiding the wall obstacles.</p><p>In the next screenshot, we<a class="indexterm" id="id879"/> can see in the <strong>Scene</strong> panel the squares that represent potential points on the path. We can also see lines showing the current temporary direction and destination around the current obstacle.</p><p>When the <strong>Navigation</strong> panel is visible, then the <strong>Scene</strong> panel displays the blue-shaded <em>walkable</em> areas, and unshaded, non-walkable areas at the edge of the terrain and around each of the two <em>wall</em> objects.</p><div><img alt="NPC NavMeshAgent to seek or flee destination while avoiding obstacles" src="img/1362OT_08_05.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec242"/>Getting ready</h2></div></div></div><p>This recipe builds upon the player-controlled 3D cube Unity project that you created at the beginning of this chapter. So, make a copy of this project, open it, and then follow the steps for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec243"/>How to do it...</h2></div></div></div><p>To make an <a class="indexterm" id="id880"/>object seek or flee from a position, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Delete the <strong>Cube-player</strong> GameObject, since we are going to be creating an NPC computer controlled agent.</li><li class="listitem">Create a sphere named <strong>Sphere-arrow</strong> that is positioned at (2, 0.5, 2). Scale it as (1,1,1).</li><li class="listitem">Create a second sphere named <strong>Sphere-small</strong>. Scale it as (0.5, 0.5, 0.5).</li><li class="listitem">Child <strong>Sphere-small</strong> to <strong>Sphere-arrow</strong> and position it at (0, 0, 0.5).<div><div><h3 class="title"><a id="note39"/>Note</h3><p>
<strong>Childing</strong> refers to making <a class="indexterm" id="id881"/>one GameObject, in the <strong>Hierarchy</strong> panel, a child of another GameObject. This is done by dragging the object that is to be childed over the object to be the parent. Once completed, the parent-child relationship is indicated visually by all children being right-indented and positioned immediately below their parent in the <strong>Hierarchy</strong> panel. If a parent object is transformed (moved/scaled/rotated), then all its children will also <a class="indexterm" id="id882"/>be transformed accordingly.</p></div></div></li><li class="listitem">In the <strong>Inspector</strong> panel, add a new NavMeshAgent to <strong>Sphere-arrow</strong>; choose <strong>Add Component</strong> | <strong>Navigation</strong> | <strong>Nav Mesh Agent</strong>.</li><li class="listitem">Set the <strong>Stopping Distance</strong> property of <strong>NavMeshAgent</strong> component to <code class="literal">2</code>.</li><li class="listitem">Add the<a class="indexterm" id="id883"/> following C# script class called <code class="literal">ArrowNPCMovement</code> to GameObject <strong>Sphere-arrow</strong>:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ArrowNPCMovement : MonoBehaviour {
  public GameObject targetGO;
  private NavMeshAgent navMeshAgent;

  void Start (){
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    HeadForDestintation();
  }

  private void HeadForDestintation (){
    Vector3 destinaton = targetGO.transform.position;
    navMeshAgent.SetDestination (destinaton);
  }
}</pre></div></li><li class="listitem">Ensure that <strong>Sphere-arrow</strong> is selected in the <strong>Inspector</strong> panel for the <code class="literal">ArrowNPCMovement</code> scripted component. Drag <strong>Capsule-destination</strong> over the variable <strong>Projectile</strong> called <strong>Target GO</strong>.</li><li class="listitem">Create a 3D cube named <strong>Cube-wall</strong> at (-6, 0, 0), and scale it to (1, 2, 10).</li><li class="listitem">Create another 3D cube named <strong>Cube-wall</strong> at (-2, 0, 6), and scale it to (1, 2, 7).</li><li class="listitem">Display the <strong>Navigation</strong> panel by choosing <strong>Window</strong> | <strong>Navigation</strong>.<div><div><h3 class="title"><a id="note40"/>Note</h3><p>A great place to <em>dock</em> the <strong>Navigation</strong> panel is next to the <strong>Inspector</strong> panel since you will never be using the <strong>Inspect</strong> and <strong>Navigation</strong> panels at the same time.</p></div></div></li><li class="listitem">In the <strong>Hierarchy</strong> tab, select both of the <strong>Cube-wall</strong> objects (we select the objects that are <em>not</em> supposed to be a part of<a class="indexterm" id="id884"/> the <strong>walkable</strong> parts of our scene), and then in the <strong>Navigation</strong> panel, check the <strong>Navigation Static</strong> checkbox. Then, click<a class="indexterm" id="id885"/> on the <strong>Bake</strong> button at the bottom of the <strong>Navigation</strong> panel. When the <strong>Navigation</strong> panel is displayed, you'll see a blue <em>tint</em> on the parts of the <strong>Scene</strong> that are walkable. Candidate areas for a <strong>NavMeshAgent</strong> are supposed to be considered as parts of a path to a destination.<div><img alt="How to do it..." src="img/1362OT_08_06.jpg"/></div></li><li class="listitem">Now run your game. You will see the <strong>Sphere-arrow</strong> GameObject automatically move towards the <strong>Capsule-destination</strong> GameObject, following a path that avoids the two wall objects.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec244"/>How it works...</h2></div></div></div><p>The <strong>NavMeshAgent</strong> component that we added to GameObject<strong> Sphere-arrow</strong> does most of the work for us. <strong>NavMeshAgents</strong> need 2 things: a destination location to head towards, and a <strong>NavMesh</strong> component of the terrain with walkable/non-walkable areas, so that it can plan a path, avoiding obstacles. We created two obstacles (the <strong>Cube-wall</strong> objects), and these were selected when we created <strong>NavMesh</strong> for this scene in the <strong>Navigation</strong> panel.</p><p>The location for our NPC object to travel towards is the position of the <strong>Capsule-destination</strong> GameObject at (-12, 0, 8); but of course, we could just move this object in the <strong>Scene</strong> panel at <a class="indexterm" id="id886"/><strong>Design-time</strong>, and its new position would be the destination when we run the game.</p><p>The C# script class called <code class="literal">ArrowNPCMovement</code> has two variables: one is a reference to the destination GameObject, and the second is a reference to the NavMeshAgent component of the GameObject in which our instance of the <code class="literal">ArrowNPCMovement</code> class is also a component. When the scene starts, via the <code class="literal">Start()</code> method, the <strong>NavMeshAgent</strong> sibling component is found, and the <code class="literal">HeadForDestination()</code> method is called, which sets the destination of the NavMeshAgent to the position of the destination GameObject.</p><p>Once the NavMeshAgent has a target to head towards, it will plan a path there and will keep moving until it arrives (or gets within the <strong>Stopping Distance</strong> if that parameter has been set to a<a class="indexterm" id="id887"/> distance greater than zero).</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Ensure that the object with the NavMeshAgent component is selected in the <strong>Hierarchy</strong> panel at runtime to be able to see this navigation data in the <strong>Scene</strong> panel.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec245"/>There's more...</h2></div></div></div><p>There are some details that you don't want to miss.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec58"/>Constantly updating the NavMeshAgent destination to Player's character current location</h3></div></div></div><p>Rather than a destination that is fixed when the scene starts, let's allow the <strong>Capsule-destination</strong> object to be moved by the player while the scene is running. In every frame, we'll get our NPC arrow to reset the NavMeshAgent's destination to wherever the <strong>Capsule-destination</strong> has been moved to.</p><p>To allow the user movement<a class="indexterm" id="id888"/> of the destination object and frame-by-frame updating of NavMeshAgent destination, we need to do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Add an instance of the C# script class called <code class="literal">PlayerControl</code> as a component of <strong>Capsule-destination</strong>.</li><li class="listitem">Update the C# script class called <code class="literal">ArrowNPCMovement</code> so that we call the <code class="literal">HeadForDestintation() </code>method every frame, that is, from <code class="literal">Update()</code>, rather than just once in <code class="literal">Start()</code>:<div><pre class="programlisting">void Start (){
  navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
}

void Update (){
  HeadForDestintation();
}</pre></div></li></ol></div><p>Now, when you run the game, you can use the arrow keys to move the destination location, and the NavMeshAgent will update its paths in each frame, based on the updated <a class="indexterm" id="id889"/>position of the <strong>Capsule-destination</strong> GameObject.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec59"/>Constantly update NavMeshAgent destination to flee away from Player's character current location</h3></div></div></div><p>Rather than seeking towards the player's current position, let's make our NPC agent always attempt to flee away <a class="indexterm" id="id890"/>from the player's location. For example, an enemy with very low-health points might run away, and so gain time to regain its health before fighting again.</p><div><img alt="Constantly update NavMeshAgent destination to flee away from Player's character current location" src="img/1362OT_08_10.jpg"/></div><p>To instruct our NavMeshAgent to flee away from the player's location, we need to replace the C# script class called <code class="literal">ArrowNPCMovement</code> with the following:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ArrowNPCMovement : MonoBehaviour {
  public GameObject targetGO;
  private NavMeshAgent navMeshAgent;
  private float runAwayMultiplier = 2;
  private float runAwayDistance;

  void Start(){
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    runAwayDistance = navMeshAgent.stoppingDistance * runAwayMultiplier;
  }

  void Update () {
    Vector3 enemyPosition = targetGO.transform.position;
    float distanceFromEnemy = Vector3.Distance(transform.position, enemyPosition);
    if (distanceFromEnemy &lt; runAwayDistance)
      FleeFromTarget (enemyPosition);
  }

  private void FleeFromTarget(Vector3 enemyPosition){
    Vector3 fleeToPosition = Vector3.Normalize(transform.position - enemyPosition) * runAwayDistance;
    HeadForDestintation(fleeToPosition);
  }

  private void HeadForDestintation (Vector3 destinationPosition){
    navMeshAgent.SetDestination (destinationPosition);
  }
}</pre></div><p>The <code class="literal">Start()</code> method caches a reference to the NavMeshAgent component, and also calculates the <code class="literal">runAwayDistance</code> variable to be twice the NavMeshAgent's stopping distance (although this can be changed by changing the value of the <code class="literal">runAwayMultiplier</code> variable accordingly). When the distance to the enemy is less than the value of this variable, then we'll instruct the computer-controlled object to flee in the opposite direction.</p><p>The <code class="literal">Update()</code> method <a class="indexterm" id="id891"/>calculates whether the distance to the enemy is within the <code class="literal">runAwayDistance</code>, and if so, it calls the <code class="literal">FleeFromTarget(…)</code> method that passes the location of the enemy as a parameter.</p><p>The <code class="literal">FleeFromTarget(…)</code> method calculates a point that is the <code class="literal">runAwayDistance</code> Unity units away from the Player's<a class="indexterm" id="id892"/> cube, in a direction that is directly away from the computer-controlled object. This is achieved by subtracting the enemy position vector from the current transform's position. Finally, the <code class="literal">HeadForDestintation(…)</code> method is called, passing the flee-to position, which results in the NavMeshAgent being told to set the location as its new destination.</p><div><div><h3 class="title"><a id="note41"/>Note</h3><p>The Unity units are arbitrary, since they are just numbers in a computer. However, in most cases, it simplifies things to think of distances in terms of meters (1 Unity unit = 1 meter), and mass in terms of kilograms (1 Unity unit  = 1 kilogram). Of course, if your game is based on a microscopic world, or a pan-galatic space travel and more, then you need to decide what each Unity unit corresponds to for your game context. For <a class="indexterm" id="id893"/>more discussion of units in Unity, check out the <a class="ulink" href="http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487"> http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487</a> link.</p></div></div><p>As the following<a class="indexterm" id="id894"/> screenshot illustrates, the NavMeshAgent plans a path to the position to flee towards:</p><div><img alt="Constantly update NavMeshAgent destination to flee away from Player's character current location" src="img/1362OT_08_17.jpg"/></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec60"/>Create a mini point-and-click game</h3></div></div></div><p>Another way to<a class="indexterm" id="id895"/> choose the destination for our <strong>Sphere-arrow</strong> GameObject is by the user clicking on an object on the screen, and then the <strong>Sphere-arrow</strong> GameObject moving to the location of the clicked object.</p><p>To allow the user to select the destination objects with point-and-click, we need to do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Remove the <code class="literal">ArrowNPCMovement</code> component from the <strong>Sphere-arrow</strong> GameObject.</li><li class="listitem">Create some target objects, such as a black cube, a blue sphere, and a green cylinder. Note that, to be a target, each object needs to have a collider component in order to receive the <code class="literal">OnMouseOver</code> event messages (when creating primitives objects from the Unity menu <strong>Create</strong> | <strong>3D Object</strong>, the colliders are automatically created).</li><li class="listitem">Add an<a class="indexterm" id="id896"/> instance of the following C# script class called <code class="literal">ClickMeToSetDestination</code> to each of the GameObjects that you wish to be a clickable target:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ClickMeToSetDestination : MonoBehaviour {
  private NavMeshAgent playerNavMeshAgent;
  private MeshRenderer meshRenderer;
  private bool mouseOver = false;

  private Color unselectedColor;

  void Start (){
    meshRenderer = GetComponent&lt;MeshRenderer&gt;();
    unselectedColor = meshRenderer.sharedMaterial.color;

    GameObject playerGO = GameObject.FindGameObjectWithTag("Player");
    playerNavMeshAgent = playerGO.GetComponent&lt;NavMeshAgent&gt;();
  }

  void Update (){
    if (Input.GetButtonDown("Fire1") &amp;&amp; mouseOver)
      playerNavMeshAgent.SetDestination(transform.position);
  }

  void OnMouseOver (){
    mouseOver = true;
    meshRenderer.sharedMaterial.color = Color.yellow;
  }

  void OnMouseExit (){
    mouseOver = false;
    meshRenderer.sharedMaterial.color = unselectedColor;
  }
}</pre></div></li></ol></div><p>Now, while running the game, when your mouse is over one of the three objects, that object will be highlighted yellow. If you click on the mouse button when the object is highlighted, the <strong>Sphere-arrow</strong> GameObject will make its way up to (but stopping just before) the clicked <a class="indexterm" id="id897"/>object.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec85"/>NPC NavMeshAgent to follow the waypoints in a sequence</h1></div></div></div><p>Waypoints <a class="indexterm" id="id898"/>are often used as a guide to make autonomously moving NPCs and enemies follow a path in a general way (but be able to respond with other directional behaviors, such as flee or seek, if friends/predators/prey are sensed nearby). The waypoints are arranged in a sequence, so that when the character reaches, or gets close to a waypoint, it will then select the next waypoint in the sequence as the target location to move towards. This recipe demonstrates an arrow object moving towards a waypoint, and then, when it gets close enough, it will choose the next waypoint in the sequence as the new target destination. When the last waypoint has been reached, it again starts heading towards the first waypoint.</p><p>Since Unity's NavMeshAgent has simplified coding NPC behavior, our work in this recipe becomes basically finding the position of the next waypoint, and then telling the NavMeshAgent that this waypoint is its new destination.</p><div><img alt="NPC NavMeshAgent to follow the waypoints in a sequence" src="img/1362OT_08_08.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec246"/>Getting ready</h2></div></div></div><p>This recipe<a class="indexterm" id="id899"/> builds upon the player-controlled 3D cube Unity project that you created at the beginning of this chapter. So, make a copy of this project, open it, and then follow the steps for this recipe.</p><p>For this recipe, we have prepared the yellow brick texture image that you need in a folder named <code class="literal">Textures</code> in the <code class="literal">1362_08_06</code> folder<code class="literal">.</code>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec247"/>How to do it...</h2></div></div></div><p>To instruct an object to follow a sequence of waypoints, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Delete the <strong>Cube-player</strong> GameObject, since we are going to be creating an NPC computer controlled agent.</li><li class="listitem">Create a sphere named <strong>Sphere-arrow</strong>, position at (2, 0.5, 2), and scale it as (1,1,1).</li><li class="listitem">Create a second sphere named <strong>Sphere-small</strong>, and scale it as (0.5, 0.5, 0.5).</li><li class="listitem">Child <strong>Sphere-small</strong> to <strong>Sphere-arrow</strong>, and then position it at (0, 0, 0.5).</li><li class="listitem">In the <strong>Inspector,</strong> add a new NavMeshAgent to <strong>Sphere-arrow</strong>, and then choose <strong>Add Component</strong> | <strong>Navigation</strong> | <strong>NavMeshAgent</strong>.</li><li class="listitem">Set the <strong>Stopping Distance</strong> property of the <strong>NavMeshAgent</strong> component to <code class="literal">2</code>.</li><li class="listitem">Display the <strong>Navigation</strong> panel by choosing <strong>Window</strong> | <strong>Navigation</strong>.</li><li class="listitem">Click on the <strong>Bake</strong> button at the bottom of the <strong>Navigation</strong> panel. When the <strong>Navigation</strong> panel is displayed, you'll see a blue <em>tint</em> on the parts of the <strong>Scene</strong> panel that are walkable, which will be all parts of the terrain, except near the edges.</li><li class="listitem">Add an<a class="indexterm" id="id900"/> instance of the following C# script class called <code class="literal">ArrowNPCMovement</code> to the <strong>Sphere-arrow</strong> GameObject:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ArrowNPCMovement : MonoBehaviour {
  private GameObject targetGO = null;
  private WaypointManager waypointManager;
  private NavMeshAgent navMeshAgent;

  void Start (){
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    waypointManager = GetComponent&lt;WaypointManager&gt;();
    HeadForNextWayPoint();
  }

  void Update (){
    float closeToDestinaton = navMeshAgent.stoppingDistance * 2;
    if (navMeshAgent.remainingDistance &lt; closeToDestinaton){
      HeadForNextWayPoint ();
    }
  }

  private void HeadForNextWayPoint (){
    targetGO = waypointManager.NextWaypoint (targetGO);
    navMeshAgent.SetDestination (targetGO.transform.position);
  }
}</pre></div></li><li class="listitem">Create a new capsule object named <strong>Capsule-waypoint-0</strong> at (-12, 0, 8), and give it the <strong>waypoint</strong> tag.</li><li class="listitem">Copy <strong>Capsule-waypoint -0,</strong> name the copy as <strong>Capsule-waypoint -3,</strong> and position this copy at (8, 0, -8).<div><div><h3 class="title"><a id="note42"/>Note</h3><p>We are going to add some intermediate waypoints numbered 1 and 2 later on. This is why our second waypoint here is numbered 3, in case you were wondering.</p></div></div></li><li class="listitem">Add the<a class="indexterm" id="id901"/> following C# script class called <code class="literal">WaypointManager</code> to the <strong>Sphere-arrow</strong> GameObject:<div><pre class="programlisting">using UnityEngine;

public class WaypointManager : MonoBehaviour {
  public GameObject wayPoint0;
  public GameObject wayPoint3;

  public GameObject NextWaypoint(GameObject current){
    if(current == wayPoint0)
      return wayPoint3;
    else
      return wayPoint0;
  }
}</pre></div></li><li class="listitem">Ensure that <strong>Sphere-arrow </strong>is selected in the <strong>Inspector</strong> for the <code class="literal">WaypointManager</code> scripted component. Drag <strong>Capsule-waypoint-0</strong> and <strong>Capsule-waypoint-3</strong> over the public variable projectile called <strong>Way Point 0 </strong>and<strong> Way Point 3, </strong>respectively.<div><img alt="How to do it..." src="img/1362OT_08_07.jpg"/></div></li><li class="listitem">Display the Navigation panel by choosing <strong>Window | Navigation</strong>.</li><li class="listitem">Click on the <strong>Bake</strong> button at the bottom of the <strong>Navigation</strong> panel. When the <strong>Navigation</strong><a class="indexterm" id="id902"/> panel is displayed, you'll see a blue <em>tint</em> on the parts of the <strong>Scene</strong> that are <em>walkable</em>, which will be all the parts of the terrain, except near the edges.</li><li class="listitem">Now, run your game. The arrow object will first move towards one of the waypoint capsules, then when it gets close to it, it will slow down, turn around, head towards the other waypoint capsule, and keep doing that continuously.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec248"/>How it works...</h2></div></div></div><p>The <strong>NavMeshAgent</strong> component that we added to the <strong>Sphere-arrow</strong> GameObject does most of the work for us. <strong>NavMeshAgents</strong> need two things: a destination location to head towards, and a NavMesh, so that it can plan a path, avoiding obstacles.</p><p>We created two possible waypoints to be the location for our NPC to move towards: <strong>Capsule-waypoint-0</strong> and <strong>Capsule-waypoint-3</strong>.</p><p>The C# script class called <code class="literal">WaypointManager</code> has one job — to return a reference to the next waypoint that our NPC should head towards. There are two variables: <code class="literal">wayPoint0</code> and <code class="literal">wayPoint3</code> that reference to the two waypoint GameObjects in our scene. The <code class="literal">NextWaypoint(…)</code> method takes a single parameter named <code class="literal">current</code>, which is a reference to the current waypoint that the object was moving towards (or null). This method's task is to return a reference to the <strong>next</strong> waypoint that the NPC should travel towards. The logic for this method is simple—if <code class="literal">current</code> refers to <code class="literal">waypoint0</code>, then we'll return <code class="literal">waypoint3</code>, otherwise we'll return <code class="literal">waypoint0</code>. Note that if we pass this <code class="literal">null</code> method, then we'll get <code class="literal">waypoint0</code> back (so, it is our default first waypoint).</p><p>The C# script class called <code class="literal">ArrowNPCMovement</code> has three variables: one is a reference to the destination GameObject named <code class="literal">targetGO</code>. The second is a reference to the <code class="literal">NavMeshAgent</code> component of the GameObject in which our instance of the class called <code class="literal">ArrowNPCMovement</code> is also a component. The third variable called <code class="literal">WaypointManager</code> is a reference to the sibling scripted component, an instance of our <code class="literal">WaypointManager</code> script class.</p><p>When the scene starts, via the <code class="literal">Start()</code>method, the <strong>NavMeshAgent</strong> and <code class="literal">WaypointManager</code> sibling components are found, and the <code class="literal">HeadForDestination()</code>method is called.</p><p>The <code class="literal">HeadForDestination()</code> method first sets the variable called <code class="literal">targetGO</code> to refer to the GameObject<a class="indexterm" id="id903"/> that is returned by a call to <code class="literal">NextWaypoint(…)</code> of the scripted component called <code class="literal">WaypointManager</code> (that is, <code class="literal">targetGO</code> is set to refer to either <strong>Capsule-waypoint-0</strong> or <strong>Capsule-waypoint-3</strong>). Next, it instructs the <code class="literal">NavMeshAgent</code> to make its destination the position of the <code class="literal">targetGO</code> GameObject.</p><p>Each frame method called <code class="literal">Update()</code> is called. A test is made to see if the distance from the NPC arrow object is close to the destination waypoint. If the distance is smaller than twice the <em>stopping distance</em>, set in our <code class="literal">NavMeshAgent</code>, then a call is made to <code class="literal">WaypointManager</code>.<code class="literal">NextWaypoint(…)</code> to update our target destination to be the next waypoint in the sequence.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec249"/>There's more...</h2></div></div></div><p>There are some details that you don't want to miss.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec61"/>More efficient to avoid using NavMeshes for waypoints</h3></div></div></div><p>NavMeshes are far<a class="indexterm" id="id904"/> superior to waypoints, since a location in a general area (not a specific point) can be used, and the path finding the algorithm will automatically find the shortest route. For a succinct recipe (such as the above), we can<a class="indexterm" id="id905"/> simplify the implementation of waypoints using NavMeshes for calculating movements for us. However, for optimized, real-world games the most common way to move from one waypoint to the next is via linear interpolation, or by implementing Craig Reynold's Seek algorithm (for details follow the link listed in the Conclusion section, at the end of this chapter).</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec62"/>Working with arrays of waypoints</h3></div></div></div><p>Having a separate C# script class called <code class="literal">WaypointManager</code> to simply swap between <strong>Capsule-waypoint-0</strong> and <strong>Capsule-waypoint-3</strong> may have seemed to be a heavy duty and over-engineering task, but this was actually a very good move. An object of the script class called <code class="literal">WaypointManager</code> has the job of returning the <em>next</em> waypoint. It is now very straightforward to add a more sophisticated approach of having an array of waypoints, without us having to change any code in the script class called <code class="literal">ArrowNPCMovement</code>. We can choose a random <a class="indexterm" id="id906"/>waypoint to be the next destination (see the <em>Choosing destinations – find nearest (or a random) spawnpoint</em> recipe). Or, we can have an array of waypoints, and choose the next one in the sequence.</p><p>To improve our game to work with an array of waypoints in the sequence to be followed, we need to do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Copy <strong>Capsule-waypoint-0</strong>, name the copy as <strong>Capsule-waypoint-1</strong>, and position this copy at (0, 0, 8).</li><li class="listitem">Make four more copies (named <strong>Capsule-waypoint-1</strong>, <strong>2, 4</strong>, <strong>5</strong>), and position them as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Capsule-waypoint-1</strong>: Position = (-2, 0, 8)</li><li class="listitem" style="list-style-type: disc"><strong>Capsule-waypoint-2</strong>: Position = (8, 0, 8)</li><li class="listitem" style="list-style-type: disc"><strong>Capsule-waypoint-4</strong>: Position = (-2, 0, -8)</li><li class="listitem" style="list-style-type: disc"><strong>Capsule-waypoint-5</strong>: Position = (-12, 0, -8)</li></ul></div></li><li class="listitem">Replace the C# script class called <code class="literal">WaypointManager</code> with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;
using System;

public class WaypointManager : MonoBehaviour {
  public GameObject[] waypoints;

  public GameObject NextWaypoint (GameObject current)
  {
    if( waypoints.Length &lt; 1)
      Debug.LogError ("WaypointManager:: ERROR - no waypoints have been added to array!");

    int currentIndex = Array.IndexOf(waypoints, current);
    int nextIndex = ((currentIndex + 1) % waypoints.Length);
    return waypoints[nextIndex];
  }
}</pre></div></li><li class="listitem">Ensure that <strong>Sphere-arrow</strong> is selected. In the <strong>Inspector</strong> panel for the <code class="literal">WaypointManager</code> scripted component set the size of the <code class="literal">Waypoints</code> array to <code class="literal">6</code>. Now, drag in all the six capsule waypoint objects called as <code class="literal">Capsule-waypoint</code>-<code class="literal">0</code>/<code class="literal">1</code>/<code class="literal">2</code>/<code class="literal">3</code>/<code class="literal">4</code>/<code class="literal">5</code>.</li><li class="listitem">Run the game. Now, the <strong>Sphere-arrow</strong> GameObject will first move towards the waypoint 0 (top left, and then follow the sequence around the terrain).</li><li class="listitem">Finally, you can make it look as if the Sphere is following a yellow brick road. Import the provided yellow brick texture, add this to your terrain, and paint the texture an oval-shaped path between the waypoints. You may also uncheck the Mesh Rendered component for each waypoint capsule, so that the user does not see any of the way points, but just the arrow object following<a class="indexterm" id="id907"/> the yellow brick path</li></ol></div><p>In the <code class="literal">NextWaypoint(…)</code> method, first we check in case the array is empty, in which case an error is logged. Next, the array index for the current waypoint GameObject is found (if present in the array). Finally, the array index for the next waypoint is calculated using a modulus operator to support a cyclic sequence, returning to the beginning of the array after the last element has been visited.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec63"/>Increased flexibility with a WayPoint class</h3></div></div></div><p>Rather than forcing a GameObject to follow a single rigid sequence of locations, we can make things more flexible by defining a <code class="literal">WayPoint</code> class, whereby each waypoint GameObject has an array<a class="indexterm" id="id908"/> of possible destinations, and each of these has its own array and so on. In this way<a class="indexterm" id="id909"/> a <strong>di-graph</strong> (<strong>directed graph</strong>) can be implemented, of which a linear sequence is just one possible instance.</p><p>To improve our game to work with a di-graph of waypoints, do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Remove the scripted <code class="literal">WayPointManager</code> component from the <strong>Sphere-arrow</strong> GameObject.</li><li class="listitem">Replace the C# script class called <code class="literal">ArrowNPCMovement</code> with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ArrowNPCMovement : MonoBehaviour {
  public Waypoint waypoint;
  private bool firstWayPoint = true;
  private NavMeshAgent navMeshAgent;

  void Start (){
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    HeadForNextWayPoint();
  }

  void Update () {
    float closeToDestinaton = navMeshAgent.stoppingDistance * 2;
    if (navMeshAgent.remainingDistance &lt; closeToDestinaton){
      HeadForNextWayPoint ();
    }
  }

  private void HeadForNextWayPoint (){
    if(firstWayPoint)
      firstWayPoint = false;
    else
      waypoint = waypoint.GetNextWaypoint();

    Vector3 target = waypoint.transform.position;
    navMeshAgent.SetDestination (target);
  }
}</pre></div></li><li class="listitem">Create a new C# script class called <code class="literal">WayPoint</code> with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Waypoint: MonoBehaviour {
  public Waypoint[] waypoints;

  public Waypoint GetNextWaypoint () {
    return waypoints[ Random.Range(0, waypoints.Length) ];
  }
}</pre></div></li><li class="listitem">Select all the six GameObjects called <strong>Capsule-waypoint -0</strong>/<strong>1</strong>/<strong>2</strong>/<strong>3</strong>/<strong>4</strong>/<strong>5,</strong> and add to them a scripted instance of C# class called <code class="literal">WayPoint</code>.</li><li class="listitem">Select the <strong>Sphere-arrow</strong> GameObject and add to it a scripted instance of C# class called <code class="literal">WayPoint</code>.</li><li class="listitem">Ensure that the <strong>Sphere-arrow</strong> GameObject is selected: in the <strong>Inspector</strong> panel for the <code class="literal">ArrowNPCMovement</code> scripted component drag <strong>Capsule-waypoint-0</strong> into the <strong>Waypoint</strong> public variable slot.</li><li class="listitem">Now, we need to link <strong>Capsule-waypoint-0</strong> to <strong>Capsule-waypoint-1</strong>, <strong>Capsule-waypoint-1</strong> to <strong>Capsule-waypoint -2</strong>, and so on. Select <strong>Capsule-waypoint-0</strong>, set its <code class="literal">Waypoints</code> array size to <code class="literal">1</code>, and drag in <strong>Capsule-waypoint-1</strong>. Next, select <strong>Capsule-waypoint-1</strong>, set its <strong>Waypoints</strong> array size to 1, and drag in <strong>Capsule-waypoint-2</strong>. Do the following until you finally link <strong>Capsule-waypoint-5</strong> back to <strong>Capsule-waypoint-0</strong>.</li></ol></div><p>You now have a much more flexible game architecture, allowing GameObjects to randomly select one of several different paths at each waypoint reached. In this final recipe variation, we have implemented a waypoint sequence, since each waypoint has an array of just one linked <a class="indexterm" id="id910"/>waypoint. However, if you change the array size to 2 or more, you will then be creating a graph of linked waypoints, adding random variations in the sequence of waypoints that a computer controlled character follows for any given run of your game.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec86"/>Controlling the object group movement through flocking</h1></div></div></div><p>A realistic, natural-looking, flocking behavior (for example birds or antelopes or bats) can be created through<a class="indexterm" id="id911"/> creating collections of objects with the following four simple rules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Separation</strong>: Avoiding getting too close to neighbors</li><li class="listitem" style="list-style-type: disc"><strong>Avoid Obstacle</strong>: Turning away from an obstacle immediately ahead</li><li class="listitem" style="list-style-type: disc"><strong>Alignment</strong>: Moving in the general direction the flock is heading</li><li class="listitem" style="list-style-type: disc"><strong>Cohesion</strong>: Moving towards the location in the middle of the flock</li></ul></div><p>Each member of the flock acts independently, but needs to know about the current heading and location of the members of its flock. This recipe shows you how to create a scene with two flocks of cubes: one flock of green cubes and, one flock of yellow cubes. To keep things simple, we'll not worry about separation in our recipe.</p><div><img alt="Controlling the object group movement through flocking" src="img/1362OT_08_15.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec250"/>Getting ready</h2></div></div></div><p>This recipe builds upon the player-controlled cube Unity project that you created in the first recipe. So, make a copy of this project, open it, and then follow the steps for this<a class="indexterm" id="id912"/> recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec251"/>How to do it...</h2></div></div></div><p>To make a group of objects flock together, please follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a Material in the <strong>Project</strong> panel, and name it as <code class="literal">m_green</code> with the Main Color tinted green.</li><li class="listitem">Create a Material in the <strong>Project</strong> panel, and name it as <code class="literal">m_yellow</code> with Main Color tinted yellow.</li><li class="listitem">Create a 3D Cube GameObject named <code class="literal">Cube-drone</code> at (0,0,0). Drag the <code class="literal">m_yellow</code> Material into this object.</li><li class="listitem">Add a <strong>Navigation</strong> | <strong>NavMeshAgent</strong> component to <code class="literal">Cube-drone</code>. Set the <strong>Stopping Distance</strong> property of the <strong>NavMeshAgent</strong> component to <code class="literal">2</code>.</li><li class="listitem">Add a <strong>Physics RigidBody</strong> component to <code class="literal">Cube-drone</code> with the following properties:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Mass</strong> is <code class="literal">1</code></li><li class="listitem" style="list-style-type: disc"><strong>Drag</strong> is <code class="literal">0</code></li><li class="listitem" style="list-style-type: disc"><strong>Angular Drag</strong> is <code class="literal">0.05</code></li><li class="listitem" style="list-style-type: disc"><strong>Use Gravity</strong> and <strong>Is Kinematic</strong> are both unchecked</li><li class="listitem" style="list-style-type: disc">Under <strong>Constrains Freeze Position</strong> for the <strong>Y</strong>-axis is checked</li></ul></div></li><li class="listitem">You will see the following Inspector values for your cube's rigid body component:<div><img alt="How to do it..." src="img/1362OT_08_16.jpg"/></div></li><li class="listitem">Create the following C# script class called <code class="literal">Drone</code>, and add an instance as a component<a class="indexterm" id="id913"/> to the <code class="literal">Cube-drone</code> GameObject:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Drone : MonoBehaviour {
  private NavMeshAgent navMeshAgent;

  void Start() {
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
  }

  public void SetTargetPosition(Vector3 swarmCenterAverage, Vector3 swarmMovementAverage) {
    Vector3 destination = swarmCenterAverage + swarmMovementAverage;
    navMeshAgent.SetDestination(destination);
  }
}</pre></div></li><li class="listitem">Create a new empty Prefab named <code class="literal">dronePrefabYellow</code>, and from the <strong>Hierarchy</strong> panel, drag your <code class="literal">Cube-boid</code> GameObject into this Prefab.</li><li class="listitem">Now, drag the <code class="literal">m_green</code> Material into the <code class="literal">Cube-boid</code> GameObject.</li><li class="listitem">Create a new empty Prefab named <code class="literal">dronePrefabGreen</code>, and from the <strong>Hierarchy</strong> panel, drag your <code class="literal">Cube-drone</code> GameObject into this Prefab.</li><li class="listitem">Delete the <code class="literal">Cube-drone</code> GameObject from the <strong>Scene</strong> panel.</li><li class="listitem">Add the<a class="indexterm" id="id914"/> following C# script <code class="literal">Swarm</code> class to the <strong>Main Camera</strong>:<div><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Swarm : MonoBehaviour {
  public int droneCount = 20;
  public GameObject dronePrefab;

  private List&lt;Drone&gt; drones = new List&lt;Drone&gt;();

  void Awake() {
    for (int i = 0; i &lt; droneCount; i++)
      AddDrone();
  }

  void FixedUpdate() {
    Vector3 swarmCenter = SwarmCenterAverage();
    Vector3 swarmMovement = SwarmMovementAverage();

    foreach(Drone drone in drones)
      drone.SetTargetPosition(swarmCenter, swarmMovement);
  }

  private void AddDrone() {
    GameObject newDroneGO = (GameObject)Instantiate(dronePrefab);
    Drone newDrone = newDroneGO.GetComponent&lt;Drone&gt;();
    drones.Add(newDrone);
  }

  private Vector3 SwarmCenterAverage() {
    // cohesion (swarm center point)
    Vector3 locationTotal = Vector3.zero;

    foreach(Drone drone in drones)
      locationTotal += drone.transform.position;

    return (locationTotal / drones.Count);
  }

  private Vector3 SwarmMovementAverage() {
    // alignment (swarm direction average)
    Vector3 velocityTotal = Vector3.zero;

    foreach(Drone drone in drones)
      velocityTotal += drone.rigidbody.velocity;

    return (velocityTotal / drones.Count);	
  }
}</pre></div></li><li class="listitem">With <strong>Main Camera</strong> selected in the <strong>Hierarchy</strong> panel, drag <code class="literal">prefab_boid_yellow</code>, from the <strong>Project</strong> panel, over the public variable of <strong>Drone</strong> Prefab.</li><li class="listitem">With <strong>Main Camera</strong> selected in the <strong>Hierarchy</strong> panel, add a second instance of the script class called <code class="literal">Swarm</code> to this GameObject, and then drag <code class="literal">prefab_boid_green</code>, from the <strong>Project</strong> panel, over the public variable of <strong>Drone</strong> Prefab.</li><li class="listitem">Create a new Cube named <code class="literal">wall-left</code> with the following properties:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Position = (-15, 0.5, 0)</li><li class="listitem" style="list-style-type: disc">Scale = (1, 1, 20)</li></ul></div></li><li class="listitem">Duplicate<a class="indexterm" id="id915"/> the <code class="literal">wall-left</code> object by naming the new object as <code class="literal">wall-right</code>, and change the position of <code class="literal">wall-right</code> to (15, 0.5, 0).</li><li class="listitem">Create a new Cube named as <code class="literal">wall-top</code> with the following properties:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Position = (0, 0.5, 10)</li><li class="listitem" style="list-style-type: disc">Scale = (31, 1, 1)</li></ul></div></li><li class="listitem">Duplicate the <code class="literal">wall-top</code> object by naming the new object as <code class="literal">wall-bottom</code>, and change the position of <code class="literal">wall-bottom</code> to (0, 0.5, -10).</li><li class="listitem">Create a new Sphere named as <code class="literal">Sphere-obstacle</code> with the following properties:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Position = (5, 0, 3)</li><li class="listitem" style="list-style-type: disc">Scale = (10, 3, 3)</li></ul></div></li><li class="listitem">In the <strong>Hierarchy</strong> panel, select the <code class="literal">Sphere-obstacle</code> GameObject. Then in the <strong>Navigation</strong> panel, check the <strong>Navigation Static</strong> checkbox. Then, click on the <strong>Bake</strong> button at the bottom of the <strong>Navigation</strong> panel.</li><li class="listitem">Finally, make the player's red cube larger by setting its scale to (3,3,3).</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec252"/>How it works...</h2></div></div></div><p>The <code class="literal">Swarm</code> class contains three variables:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">droneCount</code>: It is an integer<a class="indexterm" id="id916"/> referencing the number of the <code class="literal">Swarm</code> class members created</li><li class="listitem" style="list-style-type: disc"><code class="literal">dronePrefab</code>: It references<a class="indexterm" id="id917"/> to the Prefab to be cloned to create swarm members</li><li class="listitem" style="list-style-type: disc"><code class="literal">Drone</code>: A list of objects that<a class="indexterm" id="id918"/> reference <code class="literal">drones</code>, a list of all the scripted <code class="literal">Drone</code> components inside all the <code class="literal">Swarm</code> objects that have been created</li></ul></div><p>Upon creation, as the scene starts, the <code class="literal">Swarm</code> script class <code class="literal">Awake()</code> method loops to create <code class="literal">droneCount</code> swarm members by repeatedly calling the <code class="literal">AddDrone()</code> method. This method instantiates a new <code class="literal">GameObject</code> from the prefab, and then sets the <code class="literal">newDrone</code> variable to be a<a class="indexterm" id="id919"/> reference to the Drone-scripted object, inside the new <code class="literal">Swarm</code> class member. In each frame, the <code class="literal">FixedUpdate()</code> method loops through the list of <code class="literal">Drone</code> objects by calling their <code class="literal">SetTargetPosition(…)</code> method, and passing in the <code class="literal">Swarm</code> center location and the average of all the swarm member velocities.</p><p>The rest of this <code class="literal">Swarm</code> class is made up of two methods: one (<code class="literal">SwarmCenterAverage</code>) returns a Vector3 object, representing the average position of all the <code class="literal">Drone</code> objects, and the other (<code class="literal">SwarmMovementAverage</code>) returns a <code class="literal">Vector3</code> object, representing the average velocity (movement force) of all the <code class="literal">Drone</code> objects as described in the following list.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SwarmMovementAverage()</code>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is the general direction that the swarm is moving in?</li><li class="listitem" style="list-style-type: disc">This is known <a class="indexterm" id="id920"/>as <strong>alignment</strong>—a swarm member attempting to move in the same direction as the swarm average</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">SwarmCenterAverage()</code>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is the center position of the swarm?</li><li class="listitem" style="list-style-type: disc">This is known as<a class="indexterm" id="id921"/> <strong>cohesion</strong>—a swarm member attempting to move towards the center of the swarm</li></ul></div></li></ul></div><p>The core work is undertaken by the <code class="literal">Drone</code> class. Each drone's <code class="literal">Start(…)</code> method finds and caches a reference to its NavMeshAgent component.</p><p>Each drone's <code class="literal">UpdateVelocity(…)</code> method takes as input two Vector3 arguments: <code class="literal">swarmCenterAverage</code> and <code class="literal">swarmMovementAverage</code>. This method then calculates the desired new velocity for this Drone (by simply adding the two vectors), and then uses the result (a Vector3 location) to update the NavMeshAgent's target location.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec253"/>There's more...</h2></div></div></div><p>There are some details that you don't want to miss.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec64"/>Learn more about flocking Artificial Intelligence</h3></div></div></div><p>Most of the flocking models in modern computing owe much to the work of Craig Reynolds in the 1980s. Learn<a class="indexterm" id="id922"/> more about Craig and his boids program at <a class="ulink" href="http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)">http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec87"/>Conclusion</h1></div></div></div><p>In this chapter, we have introduced recipes demonstrating a range of player and computer controlled characters, vehicles, and objects. Player character controllers are fundamental to the usability experience of every game, while the NPC objects and characters add rich interactions to many games:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn more about Unity NavMeshes from this Unity tutorial, which is available at <a class="ulink" href="http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes">http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes</a></li><li class="listitem" style="list-style-type: disc">Learn more about the Unity 2D character controllers at <a class="ulink" href="http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers">http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers</a></li><li class="listitem" style="list-style-type: disc">Learn lots about the computer-controlled moving GameObjects from the classic paper entitled <em>Steering Behaviors For Autonomous Characters</em> by Craig W. Reynolds, presented at the GDC-99 (Game Developer's Conference) at <a class="ulink" href="http://www.red3d.com/cwr/steer/gdc99/">http://www.red3d.com/cwr/steer/gdc99/</a></li><li class="listitem" style="list-style-type: disc">Learn about the Unity 3D character component and control at:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.unity3d.com/Manual/class-CharacterController.html">http://docs.unity3d.com/Manual/class-CharacterController.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character">http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character</a></li></ul></div></li></ul></div><p>Every game needs textures—here are some of the sources of free textures suitable for many games:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">CG Textures are available at <a class="ulink" href="http://www.cgtextures.com/">http://www.cgtextures.com/</a></li><li class="listitem" style="list-style-type: disc">Naldz Graphics blog are available at <a class="ulink" href="http://naldzgraphics.net/textures/">http://naldzgraphics.net/textures/</a></li></ul></div></div></body></html>