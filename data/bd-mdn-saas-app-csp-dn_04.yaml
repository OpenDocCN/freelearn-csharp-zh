- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building Databases and Planning for Data-Rich Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建数据库和规划数据丰富的应用
- en: In previous chapters, we established a foundational SaaS application consisting
    of a straightforward database with a single table. This database was connected
    to an API, and we showcased secure multi-tenancy implementation using SQL Server,
    .NET, and Entity Framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们建立了一个基础SaaS应用，该应用包含一个简单的数据库和单个表。该数据库连接到API，我们展示了使用SQL Server、.NET和Entity
    Framework实现的secure multi-tenancy。
- en: In this chapter, we will delve deeper into the intricacies of the database layer
    and its interactions with Entity Framework. As the bedrock of an entire application,
    the design choices made at the database level will influence every subsequent
    layer in the stack. We will explore how to construct and design resilient databases
    for data-intensive SaaS applications. You will acquire a variety of skills, such
    as normalization, indexing, performance optimization, as well as techniques to
    test and maintain the database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨数据库层及其与Entity Framework的交互。作为整个应用的基础，数据库层面的设计选择将影响堆栈中的每一层。我们将探讨如何构建和设计适用于数据密集型SaaS应用的健壮数据库。您将掌握各种技能，例如规范化、索引、性能优化，以及测试和维护数据库的技术。
- en: Once deployed, a database often represents the most demanding aspect of a system
    to keep current. The database is inherently stateful, and it is crucial to prevent
    data loss or corruption during updates. In addition to learning about database
    design and construction, we will examine several strategies to maintain and update
    the database, with an emphasis on the tools provided by Entity Framework.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署，数据库通常代表系统中最具挑战性的部分，需要保持最新状态。数据库本质上是状态化的，在更新过程中防止数据丢失或损坏至关重要。除了学习数据库设计和构建，我们还将探讨维护和更新数据库的几种策略，重点介绍Entity
    Framework提供的工具。
- en: The expertise you gain in this chapter is vital to create scalable and dependable
    SaaS applications. By mastering the methods discussed in this chapter, you will
    be capable of designing databases optimized for performance, scalability, and
    maintainability, thereby facilitating the development and maintenance of your
    SaaS applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中获得的技能对于创建可扩展和可靠的SaaS应用至关重要。通过掌握本章讨论的方法，您将能够设计出针对性能、可扩展性和可维护性优化的数据库，从而促进SaaS应用的开发和维护。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: The importance of data in a SaaS application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在SaaS应用中的重要性
- en: Building a database using SQL Server and Entity Framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQL Server和Entity Framework构建数据库
- en: Testing the database and data-rich applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试数据库和数据丰富的应用
- en: Working in production, keeping your database up to date, and keeping your data
    safe
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中工作，保持数据库更新，并确保数据安全
- en: Data and a database are the foundations of a SaaS application. Let’s start by
    considering how important they are.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和数据库是SaaS应用的基础。让我们首先考虑它们的重要性。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有本章的代码都可以在[https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4)找到。
- en: The importance of data in a SaaS application
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据在SaaS应用中的重要性
- en: In a SaaS application, a database serves as the foundation for the application.
    The database (or more accurately, the data contained within) is what drives the
    application and where the primary value for users lies. A SaaS application without
    data is just an empty shell!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在SaaS应用中，数据库是应用的基础。数据库（或更准确地说，其中的数据）是驱动应用并位于用户主要价值所在的地方。没有数据的SaaS应用只是一个空壳！
- en: One of the key considerations when building a SaaS application is the type of
    data that the application will store and how it will be used. Will the application
    be storing large amounts of structured data, such as customer records or transaction
    histories? Or will it be storing unstructured data, such as the data underpinning
    a social media feed? The type of data will have a significant impact on the design
    and architecture of the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建SaaS应用程序时，一个关键的考虑因素是应用程序将存储的数据类型以及其使用方式。应用程序是否会存储大量结构化数据，例如客户记录或交易历史？或者它是否会存储非结构化数据，例如支撑社交媒体数据流的数据？数据类型将对应用程序的设计和架构产生重大影响。
- en: Another important consideration is how the data will be accessed and manipulated.
    Will the data be accessed by a large number of users simultaneously, or will it
    only be accessed by a few users at a time? Will the data be updated frequently,
    or will it be mostly static? These factors will influence the choice of database
    technology and the design of the data model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是数据如何被访问和操作。数据是否会被大量用户同时访问，或者只是由少数用户一次访问？数据是否会被频繁更新，或者主要是静态的？这些因素将影响数据库技术选择和数据模型设计。
- en: In a SaaS application, it is also important to consider how the data will be
    shared among different tenants. As we discussed in the previous chapter, the data
    for each tenant must be kept separate and secure, while still allowing for efficient
    access to and manipulation of the data that pertains to the current tenant. This
    requires careful planning and design of a data model and database schema.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在SaaS应用程序中，考虑数据如何在不同的租户之间共享也很重要。正如我们在上一章中讨论的，每个租户的数据必须保持独立和安全，同时仍然允许高效地访问和操作与当前租户相关的数据。这需要仔细规划和设计数据模型和数据库模式。
- en: It is also important to consider scalability. While a SaaS application may well
    start off with a small user base and thus a comparatively low number of reads/writes,
    this can change very quickly as the user base increases! It’s important to design
    a data model and schema in a way that allows the application to grow. Similarly,
    the amount of data that is transmitted over the internet must be managed. Bandwidth
    is not free nor unlimited, and in data-intensive applications, this can become
    a burden.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要考虑可扩展性。虽然SaaS应用程序可能一开始用户基础较小，因此读写次数相对较低，但随着用户基础的快速增长，这可能会迅速改变！设计数据模型和模式时，重要的是要确保应用程序可以扩展。同样，通过互联网传输的数据量也必须得到管理。带宽不是免费的，也不是无限的，在数据密集型应用程序中，这可能会成为一种负担。
- en: The importance of data is not limited to technical considerations. Data plays
    a crucial role in the user experience. The way that data is presented, organized,
    and accessed can significantly impact the usability of an application. While this
    is, of course, dependent on the user interface, the structure of the underlying
    data, and the ease and speed with which it can be queried, will be noticed at
    the frontend by end users.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的重要性不仅限于技术考虑。数据在用户体验中扮演着至关重要的角色。数据的表现方式、组织方式和访问方式可以显著影响应用程序的可用性。当然，这取决于用户界面、底层数据的结构和查询的便捷性和速度，这些都会在前端被最终用户注意到。
- en: For a company building an application and hosting a database, data can be a
    key source of revenue. Some SaaS applications monetize their data by selling access
    to information about consumer demographics and buying habits to businesses looking
    to target specific market demographics. This data is often collected and classified
    by machine learning algorithms, allowing for insights about the users and creators
    of the data. With this valuable information, businesses can create targeted marketing
    campaigns and improve their products and services to better meet the needs of
    their customers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建应用程序并托管数据库的公司来说，数据可以是一个关键的收入来源。一些SaaS应用程序通过向寻求针对特定市场细分市场的企业销售有关消费者人口统计和购买习惯的信息来货币化其数据。这些数据通常由机器学习算法收集和分类，从而可以深入了解数据的用户和创建者。有了这些宝贵的信息，企业可以创建有针对性的营销活动，并改进其产品和服务，更好地满足客户的需求。
- en: Data is important for a myriad of reasons, and so it should go without saying
    that maintaining data security and compliance is a crucial aspect of building
    a successful SaaS application. It is the responsibility of the SaaS provider to
    ensure that sensitive data, such as financial or personal information, is kept
    secure and compliant with relevant regulations. To achieve this, the SaaS provider
    may need to implement various security measures, such as encryption and access
    controls, to protect the data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对于众多原因来说都很重要，因此维护数据安全和合规性是构建成功的 SaaS 应用程序的一个关键方面。确保敏感数据，如财务或个人信息，得到安全保护并符合相关法规是
    SaaS 提供商的责任。为了实现这一点，SaaS 提供商可能需要实施各种安全措施，如加密和访问控制，以保护数据。
- en: Data and the database are absolutely critical parts of a SaaS application, and
    it’s important for SaaS developers to have a strong understanding of how to design,
    build, and maintain data-rich applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和数据库是 SaaS 应用程序中绝对关键的部分，对于 SaaS 开发人员来说，了解如何设计、构建和维护数据丰富的应用程序非常重要。
- en: Building a database
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建数据库
- en: In this section, we will focus on using SQL Server and Entity Framework to design
    and construct a database for your SaaS application. We will cover a range of topics,
    including choosing the right database technology, designing an efficient and scalable
    data model with Entity Framework, and implementing database security and compliance
    measures with SQL Server. By the end of this section, you will have a solid understanding
    of how to build a robust and reliable database for your SaaS application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点介绍使用 SQL Server 和 Entity Framework 设计和构建您的 SaaS 应用程序的数据库。我们将涵盖一系列主题，包括选择合适的数据库技术、使用
    Entity Framework 设计高效且可扩展的数据模型，以及使用 SQL Server 实施数据库安全性和合规性措施。在本节结束时，您将深入了解如何为您的
    SaaS 应用程序构建一个强大且可靠的数据库。
- en: Types of database
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库类型
- en: Because this is a book focused on making use of the Microsoft stack, I will
    focus on SQL Server as the underlying database platform, and I will use Entity
    Framework to interact with the database. SQL Server is a **relational database**,
    which is a type of database that stores data in the form of tables, with rows
    representing individual records and columns representing data attributes. It is
    a very structured way to store data, and the “shape” of the data must be known
    in advance and built into the application at design time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一本专注于利用 Microsoft 堆栈的书籍，所以我会重点关注 SQL Server 作为底层数据库平台，并使用 Entity Framework
    与数据库交互。SQL Server 是一种 **关系数据库**，它以表的形式存储数据，其中行代表单个记录，列代表数据属性。这是一种非常结构化的数据存储方式，数据的“形状”必须在设计时预先知道并构建到应用程序中。
- en: 'While we will focus on SQL Server and, therefore, relational data, it is worth
    briefly considering the alternatives, which are outside the scope of this book.
    Some of the following alternatives may be worth further investigation if you have
    a specific use case that may require something other than relational data:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将重点关注 SQL Server 以及因此关系数据，但简要考虑替代方案是有价值的，这些替代方案超出了本书的范围。如果您有特定的用例可能需要除关系数据之外的数据，以下的一些替代方案可能值得进一步研究：
- en: '**Document databases**: A document database is a type of database that stores
    data in the form of documents. In this context, a document is data that is typically
    made up of key-value pairs and is designed to be scalable and flexible. In a document
    database, the structure or shape of the data will not be set when the database
    is designed, making it a good choice to store and query large volumes of data
    with diverse structures.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档数据库**：文档数据库是一种以文档形式存储数据的数据库类型。在这个上下文中，文档是由键值对组成的数据，旨在可扩展和灵活。在文档数据库中，数据的结构或形状在数据库设计时不会被设定，这使得它成为存储和查询具有不同结构的大量数据的良好选择。'
- en: '**Graph databases**: These databases store data in the form of nodes (representing
    data entities) and edges (representing relationships between nodes). They are
    often used in applications that need to represent complex relationships between
    data entities, such as social networks or recommendation engines.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图数据库**：这些数据库以节点（表示数据实体）和边（表示节点之间的关系）的形式存储数据。它们通常用于需要表示数据实体之间复杂关系的应用程序中，例如社交网络或推荐引擎。'
- en: '**Key-value stores**: These databases store data in the form of key-value pairs,
    where the key is used to identify the data and the value is the data itself. They
    are often used for simple data storage and retrieval scenarios where the data
    does not need to be queried or indexed. This is similar to a document database
    but more limited in that it is only really suitable for simple use cases.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值存储**：这些数据库以键值对的形式存储数据，其中键用于标识数据，值是数据本身。它们通常用于简单的数据存储和检索场景，其中数据不需要查询或索引。这与文档数据库类似，但更有限，因为它仅真正适用于简单的用例。'
- en: '**In-memory databases**: These databases store data in memory, rather than
    on disk. They are often used for applications that require fast read and write
    access to data, such as online gaming or financial applications. Note that in-memory
    databases can also be used to help test databases. These are two separate use
    cases and should not be confused.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存数据库**：这些数据库将数据存储在内存中，而不是磁盘上。它们通常用于需要快速读写数据访问的应用程序，例如在线游戏或金融应用程序。请注意，内存数据库也可以用于帮助测试数据库。这两个用例是分开的，不应混淆。'
- en: '**Time-series databases**: These databases are designed specifically for storing
    and querying time-stamped data, such as sensor readings or financial transactions.
    They are often used in applications that need to analyze data over time.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间序列数据库**：这些数据库专门设计用于存储和查询带时间戳的数据，如传感器读数或金融交易。它们通常用于需要分析随时间变化数据的程序。'
- en: In this chapter, we will focus on SQL Server, which is a relational database.
    We will interact with the database using a tool that Microsoft developed specifically
    for this purpose – namely, Entity Framework.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于SQL Server，这是一个关系型数据库。我们将使用微软专门为此目的开发的工具与数据库进行交互——即实体框架（Entity Framework）。
- en: What is ACID?
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是ACID？
- en: 'When working with databases – and particularly relational databases – you will
    often come across the acronym **ACID**. This refers to the four properties of
    a database transaction – namely, atomicity, consistency, isolation, and durability:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数据库（尤其是关系型数据库）一起工作时，你经常会遇到**ACID**这个缩写。这指的是数据库事务的四个属性——即原子性、一致性、隔离性和持久性：
- en: '**Atomicity**: A transaction is treated as a single, indivisible unit of work,
    and either all its operations are completed or none of them are'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：事务被视为一个单一、不可分割的工作单元，要么所有操作都完成，要么一个都不完成'
- en: '**Consistency**: The transaction brings the database from one valid state to
    another, preserving database invariants and constraints'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：事务将数据库从一个有效状态转换到另一个有效状态，保持数据库的不变性和约束'
- en: '**Isolation**: The concurrent execution of transactions results in a system
    state that would be obtained if transactions were executed serially, in some order'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：事务的并发执行会导致一个系统状态，这个状态就像事务按某种顺序串行执行一样'
- en: '**Durability**: Once a transaction has been committed, its changes to the database
    persist and survive future system failures'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：一旦事务被提交，其对数据库的更改将持久存在并能够生存未来的系统故障'
- en: These properties are a set of properties that are guaranteed by a database management
    system to ensure the reliability and consistency of data stored in a database.
    ACID is most commonly associated with **relational database management systems**
    (**RDBMS**), such as Oracle, MySQL, PostgreSQL, and Microsoft SQL Server. However,
    some newer databases, such as NoSQL databases and NewSQL databases, may also provide
    ACID guarantees, although they may have different levels of consistency and durability.
    The level of ACID support depends on the specific database technology and how
    it is implemented and configured.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性是一组由数据库管理系统保证的属性，以确保数据库中存储数据的可靠性和一致性。ACID最常与**关系型数据库管理系统**（**RDBMS**）相关联，例如Oracle、MySQL、PostgreSQL和Microsoft
    SQL Server。然而，一些较新的数据库，如NoSQL数据库和新SQL数据库，也可能提供ACID保证，尽管它们可能具有不同的一致性和持久性级别。ACID支持的水平取决于特定的数据库技术以及它的实现和配置。
- en: ACID is generally associated with transactions in relational databases, and
    less commonly so in NoSQL or document databases. In this chapter, and indeed throughout
    this book, we will focus on SQL Server, a relational database that provides support
    for ACID transactions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ACID通常与关系型数据库中的事务相关联，而在NoSQL或文档数据库中则较少见。在本章中，实际上在整个书中，我们将专注于SQL Server，这是一个提供ACID事务支持的关系型数据库。
- en: Entity Framework
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体框架（Entity Framework）
- en: Entity Framework is an **object-relational mapping** (**ORM**) tool that allows
    developers to interact with a database using .NET objects. It simplifies the process
    of accessing and manipulating data by eliminating the need to write SQL queries
    and manually map data to objects. Entity Framework is well-suited for developers
    who are familiar with .NET and want to streamline their data access and manipulation
    tasks, which makes it an excellent choice for study in this .NET-focused book!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 是一个 **对象关系映射**（**ORM**）工具，它允许开发者使用 .NET 对象与数据库进行交互。它通过消除编写
    SQL 查询和手动将数据映射到对象的需求来简化访问和操作数据的过程。Entity Framework 对于熟悉 .NET 并希望简化数据访问和操作任务的开发者来说非常适合，这使得它成为本以
    .NET 为重点的书籍中学习的绝佳选择！
- en: While we will focus on SQL Server, one of the big benefits of using Entity Framework
    is its ability to generate database-agnostic code, allowing developers to change
    a database platform or support multiple database platforms without having to significantly
    rewrite their code. This feature is of particular interest when dealing with a
    multi-tenant SaaS application, where certain customers may mandate a specific
    database platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们会专注于 SQL Server，但使用 Entity Framework 的一大好处是它能够生成数据库无关的代码，这使得开发者能够在不显著重写代码的情况下更改数据库平台或支持多个数据库平台。当处理多租户
    SaaS 应用程序时，这一特性尤其有趣，因为某些客户可能要求使用特定的数据库平台。
- en: Entity Framework wraps up a lot of the complexities associated with writing
    code that interacts with a database. Concepts such as lazy loading, change tracking,
    and automatic migration of data and schema changes are handled out of the box.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 包含了与编写与数据库交互的代码相关的许多复杂性。例如，懒加载、更改跟踪以及数据模式和架构更改的自动迁移等概念都是开箱即用的。
- en: Unlike many other ORMs, Entity Framework supports several different approaches
    to interacting with a database, including the traditional database-first approach,
    the code-first approach, and the model-first approach. This gives developers the
    flexibility to choose the approach that best fits their needs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他 ORM 不同，Entity Framework 支持与数据库交互的几种不同方法，包括传统的数据库优先方法、代码优先方法和模型优先方法。这为开发者提供了选择最适合他们需求的方法的灵活性。
- en: Entity Framework is a powerful tool that can greatly enhance the productivity
    of experienced .NET developers by simplifying data access and manipulation tasks,
    and it is highly recommended when approaching a project that will be highly dependent
    on a data platform – such as a SaaS application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 是一个强大的工具，可以通过简化数据访问和操作任务来大大提高经验丰富的 .NET 开发者的生产力，并且在处理高度依赖于数据平台的项目（如
    SaaS 应用程序）时，它被高度推荐。
- en: It is out of the scope of this chapter to cover all of the possible ways to
    use Entity Framework, so I will focus on one – Code First.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的范围不包括所有可能的 Entity Framework 使用方式，因此我将专注于其中一种——代码优先。
- en: Code first with Entity Framework
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Entity Framework 的代码优先
- en: Code first with Entity Framework is a development approach that allows developers
    to create their .NET application’s data model using C# code, rather than designing
    a database using a UI such as SQL Server Management Studio, or through writing
    and maintaining SQL scripts. This approach is particularly useful for developers
    who prefer to work with code and want more control over their application’s data
    model. With code first, developers can define their data model using classes and
    properties in their code, and Entity Framework will handle the creation and management
    of the underlying database. This approach allows developers to focus on the data
    model and business logic of their application, without having to worry about the
    implementation details of the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Entity Framework 的代码优先是一种开发方法，它允许开发者使用 C# 代码创建他们的 .NET 应用程序的数据模型，而不是使用 SQL
    Server Management Studio 等用户界面来设计数据库，或者通过编写和维护 SQL 脚本来实现。这种方法对于喜欢使用代码并且希望对应用程序的数据模型有更多控制的开发者来说特别有用。使用代码优先，开发者可以使用代码中的类和属性来定义他们的数据模型，而
    Entity Framework 将处理底层数据库的创建和管理。这种方法允许开发者专注于应用程序的数据模型和业务逻辑，而无需担心数据库的实现细节。
- en: We saw this approach in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056). When
    the database was configured, we didn’t write a single line of SQL code – we wrote
    a C# class called `GoodHabits.cs` and defined the data structure in C# code. We
    then used two commands on the Entity Framework CLI that updated the database.
    In [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), we modified this file to facilitate
    multi-tenancy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B19343_02.xhtml#_idTextAnchor056)中看到了这种方法。当数据库配置时，我们没有写一行 SQL 代码——我们编写了一个名为
    `GoodHabits.cs` 的 C# 类，并在 C# 代码中定义了数据结构。然后我们使用了两个 Entity Framework CLI 命令来更新数据库。在[*第三章*](B19343_03.xhtml#_idTextAnchor082)中，我们修改了这个文件以支持多租户。
- en: Stored procedures with Entity Framework
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Entity Framework 的存储过程
- en: Traditionally, it has been very common to use stored procedures when designing
    a database. While this is still a very valid and useful approach to database development,
    it is increasingly being seen as best practice to use an ORM such as Entity Framework
    to access and manipulate data in a database, rather than using stored procedures.
    There are a few reasons for this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在数据库设计时使用存储过程是非常常见的。虽然这仍然是一种非常有效且实用的数据库开发方法，但它越来越被视为最佳实践，即使用 ORM（对象关系映射）如
    Entity Framework 来访问和操作数据库中的数据，而不是使用存储过程。这有几个原因。
- en: Entity Framework allows you to work with objects and entities in your code,
    rather than having to write raw SQL queries. This gives you a higher level of
    abstraction, which can make it easier to develop an application. With this approach,
    you can build your database in a familiar object-orientated way, which can make
    it easier to reason about and maintain. Entity Framework is able to interpret
    relationships between objects and create database relationships from C# code.
    If you create logic and then model it in a stored procedure, Entity Framework
    loses sight of that logic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 允许你在代码中与对象和实体一起工作，而不是必须编写原始的 SQL 查询。这为你提供了一个更高层次的抽象，可以使开发应用程序变得更加容易。采用这种方法，你可以以熟悉面向对象的方式构建数据库，这可以使推理和维护变得更加容易。Entity
    Framework 能够从 C# 代码中解析对象之间的关系，并创建数据库关系。如果你在存储过程中创建逻辑并将其建模，Entity Framework 就会失去对这种逻辑的视线。
- en: Another huge benefit of using Entity Framework is that many database platforms
    are supported out of the box. However, logic in stored procedures is typically
    not transferrable between database platforms and would have to be built and maintained
    separately on a per-platform basis.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Entity Framework 的另一个巨大好处是，许多数据库平台都支持即插即用。然而，存储过程中的逻辑通常无法在不同数据库平台之间迁移，并且必须分别在每个平台上单独构建和维护。
- en: Finally, Entity Framework has a number of testing tools available to use. Using
    stored procedures and triggers will require specific testing infrastructure and
    techniques, and this may make it harder to test an application because logic is
    split between code and the database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Entity Framework 提供了多种可用的测试工具。使用存储过程和触发器将需要特定的测试基础设施和技术，这可能会使得测试应用程序变得更加困难，因为逻辑被分散在代码和数据库之间。
- en: 'There are certain cases when using stored procedures or triggers may be beneficial.
    These include the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用存储过程或触发器可能是有益的。以下是一些例子：
- en: When working with very large datasets, or in situations where performance is
    critical, it may be advantageous to execute logic directly against a database
    by way of a stored procedure
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理非常大的数据集或在性能至关重要的场合时，通过存储过程直接在数据库上执行逻辑可能是有利的。
- en: In cases where data security is a concern, stored procedures can help to prevent
    unauthorized access to data by limiting the types of queries that can be run against
    a database.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据安全是关注点的情况下，存储过程可以帮助通过限制对数据库可以运行的查询类型来防止对数据的未授权访问。
- en: In cases where you want to abstract the data access layer of your application
    from the underlying database schema, using stored procedures can help to decouple
    the two. This can be particularly useful in situations where a database schema
    may change frequently.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你想要将应用程序的数据访问层从底层数据库模式抽象出来的情况下，使用存储过程可以帮助解耦这两个部分。这在数据库模式可能频繁变化的情况下尤其有用。
- en: It is important to understand your specific use case when deciding whether or
    not to make use of stored procedures in your database. For the demo application,
    we will continue to use Entity Framework to manipulate and access the database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否在数据库中使用存储过程时，理解你的具体用例非常重要。对于演示应用程序，我们将继续使用 Entity Framework 来操作和访问数据库。
- en: Normalization
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规范化
- en: Database normalization is the process of organizing a database in a way that
    reduces redundancy and improves data integrity. It involves dividing the database
    into smaller, more focused tables that are related to each other through relationships.
    The goal of normalization is to eliminate redundancy and ensure that each piece
    of data is stored in only one place in the database. Normalization is an important
    step in the database design process and can greatly improve the performance and
    reliability of a database.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库规范化是将数据库组织成减少冗余并提高数据完整性的过程。它涉及将数据库划分为更小、更专注的表，这些表通过关系相互关联。规范化的目标是消除冗余并确保每条数据只存储在数据库中的一个地方。规范化是数据库设计过程中的一个重要步骤，可以极大地提高数据库的性能和可靠性。
- en: Entity Framework supports the process of normalizing a database in several ways.
    One of the main ways it does this is through the creation and modification of
    tables and relationships within the database. This allows developers to structure
    their data in a way that reduces redundancy and improves data integrity – a key
    goal of normalization. Entity Framework also includes support for the automatic
    migration of data changes. This means that when developers make changes to their
    data model, those changes are automatically reflected in the underlying database.
    This can be particularly useful when normalizing a database, as it allows developers
    to easily update the structure of their data without having to manually migrate
    data between tables.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework支持以多种方式支持数据库的规范化过程。其中主要的方式是通过在数据库中创建和修改表以及关系。这允许开发者以减少冗余并提高数据完整性的方式来结构化他们的数据——这是规范化的关键目标。Entity
    Framework还包括对数据变更自动迁移的支持。这意味着当开发者对他们的数据模型进行更改时，这些更改会自动反映在底层数据库中。这在规范化数据库时尤其有用，因为它允许开发者轻松地更新他们的数据结构，而无需在表之间手动迁移数据。
- en: In addition, Entity Framework’s LINQ query syntax allows developers to easily
    retrieve and manipulate data from a normalized database. It supports a wide range
    of operations, including filtering, sorting, and aggregation, making it easy to
    work with data from multiple tables. Finally, Entity Framework’s support for eager
    and lazy loading allows developers to optimize the performance of their application
    by only loading the data they need on demand, rather than loading all data upfront.
    This can be harder with a poorly normalized database. Overall, Entity Framework
    provides a number of tools and features to help developers normalize their databases
    and improve the performance and reliability of their applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Entity Framework的LINQ查询语法允许开发者轻松地从规范化数据库中检索和操作数据。它支持广泛的操作，包括过滤、排序和聚合，使得处理来自多个表的数据变得容易。最后，Entity
    Framework对预加载和懒加载的支持允许开发者通过仅在需要时加载数据来优化应用程序的性能，而不是一次性加载所有数据。这在规范化不良的数据库中可能更困难。总的来说，Entity
    Framework提供了一系列工具和功能，以帮助开发者规范化他们的数据库，并提高他们应用程序的性能和可靠性。
- en: There are several normal forms that can be used to measure the degree of normalization
    in a database. The first three (called 1NF, 2NF, and 3NF) are used to address
    redundancy in a database and are generally considered to be good practice in most
    instances.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种范式可以用来衡量数据库中规范化的程度。前三个（称为1NF、2NF和3NF）用于解决数据库中的冗余问题，并且在大多数情况下通常被认为是良好的实践。
- en: Beyond the first three, the additional normal forms are designed to address
    specific types of problems; however, these are less commonly used and are considered
    out of the scope of this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 超过前三个，额外的范式是为了解决特定类型的问题而设计的；然而，这些范式使用较少，并且被认为超出了本章的范围。
- en: It is worth noting that achieving higher normal forms does not always constitute
    a better-designed database. It is generally better to design a database that is
    efficient and performant around a specific use case than to adhere blindly to
    the normalization rules. That said, achieving 3NF is usually a good starting point
    from which to work, and further normalization, or indeed denormalization, can
    follow from there.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，实现更高的范式并不总是构成更好的数据库设计。通常，围绕特定的用例设计一个高效且性能良好的数据库比盲目遵循规范化规则要好。尽管如此，实现3NF通常是一个良好的起点，从这里可以进一步进行规范化，或者实际上进行反规范化。
- en: Let’s illustrate this with an example. Let’s consider adding a user table to
    the `GoodHabit` example we developed in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点。让我们考虑向我们在[*第2章*](B19343_02.xhtml#_idTextAnchor056)中开发的`GoodHabit`示例中添加一个用户表。
- en: 'To achieve the first normal form (1NF), all attributes in the database must
    be atomic. This means that each column in the database should contain a single
    value. We could design a user table that looked like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到第一范式（1NF），数据库中的所有属性都必须是原子的。这意味着数据库中的每一列都应该包含一个单一值。我们可以设计一个看起来像这样的用户表：
- en: '![Figure 4.1 – Poorly normalized data](img/B19343_Figure_4.1.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 未良好归一化的数据](img/B19343_Figure_4.1.jpg)'
- en: Figure 4.1 – Poorly normalized data
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 未良好归一化的数据
- en: 'The preceding table shows poorly normalized data. The **Name** column contains
    two pieces of information (first and last name), which may be useful to use separately.
    The **Habits** column contains a comma-separated list of data. This can be improved
    upon like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格显示了未良好归一化的数据。**名称**列包含两份数据（姓名和姓氏），这些信息可能单独使用时很有用。**习惯**列包含以逗号分隔的数据列表。这可以通过以下方式改进：
- en: '![Figure 4.2 – Data in the first normal form (1NF)](img/B19343_Figure_4.2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 第一范式（1NF）中的数据](img/B19343_Figure_4.2.jpg)'
- en: Figure 4.2 – Data in the first normal form (1NF)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 第一范式（1NF）中的数据
- en: The preceding table shows the data in 1NF. Each attribute holds a single value.
    We now have a row in the database for each habit, but the users appear multiple
    times. If Dave decided that he would prefer to be called David, we would have
    to update the data in multiple places.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格显示了1NF中的数据。每个属性只包含一个值。现在数据库中为每个习惯都有一个行，但用户出现了多次。如果Dave决定他更愿意被称为David，我们就必须更新多个地方的数据。
- en: 'To move this data into the second normal form, we need to break the data into
    two tables – one for the user, and one for the habit. We will need a third table
    to link the users to the habits they are going to work on:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此数据移动到第二范式，我们需要将数据拆分为两个表——一个用于用户，一个用于习惯。我们还需要一个第三张表来将用户与将要工作的习惯联系起来：
- en: '![Figure 4.3 – Data in the second normal form (2NF)](img/B19343_Figure_4.3.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 第二范式（2NF）中的数据](img/B19343_Figure_4.3.jpg)'
- en: Figure 4.3 – Data in the second normal form (2NF)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 第二范式（2NF）中的数据
- en: 'This is much better, and we can start to see that this could be queried and
    updated in a very tidy way. There is one further improvement we could make though.
    The **Habit** table has a **Frequency** column that is indirectly dependent on
    the ID column. This is called a transitive dependency. In order to move this data
    to the third normal form, we must break this transitive dependency by adding a
    **Frequency** table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就更好了，我们可以开始看到这些数据可以非常整洁地进行查询和更新。尽管如此，我们还可以进行一项进一步的改进。**习惯**表有一个**频率**列，它是间接依赖于**ID**列的。这被称为传递依赖。为了将此数据移动到第三范式，我们必须通过添加一个**频率**表来打破这种传递依赖：
- en: '![Figure 4.4 – Data in the third normal form (3NF)](img/B19343_Figure_4.4.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 第三范式（3NF）中的数据](img/B19343_Figure_4.4.jpg)'
- en: Figure 4.4 – Data in the third normal form (3NF)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 第三范式（3NF）中的数据
- en: The third normal form is sufficient at this stage, and we’ll take this no further.
    You can see that all of the data is separated into individual tables, and linked
    through foreign key constraints to the **UserHabit** table. This allows efficient
    querying and updating of the data in the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，第三范式已经足够了，我们不会进一步扩展。你可以看到所有数据都被分离到单独的表中，并通过外键约束与**用户习惯**表相连接。这允许高效地查询和更新数据库中的数据。
- en: Indexing and performance optimization
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引和性能优化
- en: Indexing a database means creating a separate data structure that is used to
    improve the performance of certain types of queries. Indexes are typically created
    on specific columns within a table, allowing the database to quickly locate the
    rows that match given criteria. For example, if you have a large table of customer
    records and you frequently search for customers by their last name, you could
    create an index on the `last_name` column to improve the performance of those
    searches. Indexes can significantly improve the performance of certain types of
    queries, but they also have a cost in terms of storage space and maintenance.
    As a result, it is important to carefully consider which columns should be indexed
    and to balance the benefits of indexing with the costs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数据库意味着创建一个单独的数据结构，用于提高某些类型查询的性能。索引通常在表中的特定列上创建，允许数据库快速定位匹配给定条件的行。例如，如果你有一个包含大量客户记录的大表，并且你经常通过姓氏搜索客户，你可以在`last_name`列上创建一个索引来提高这些搜索的性能。索引可以显著提高某些类型查询的性能，但它们在存储空间和维护方面也有成本。因此，仔细考虑哪些列应该被索引，并权衡索引的好处与成本是很重要的。
- en: To do indexing with Entity Framework, developers can use a variety of tools
    and approaches. One way to do indexing is to use the Entity Framework Fluent API,
    which allows developers to define indexes on their entities using code. To create
    an index using the Fluent API, developers can use the `HasIndex` method and specify
    the properties that should be included in the index. Another option is to use
    Entity Framework Designer, a visual tool that allows developers to design their
    data model using a graphical interface. The Designer includes the ability to define
    indexes on entities by right-clicking on an entity and selecting **Add Index**.
    Finally, developers can use database migrations to create indexes on their entities
    by adding the appropriate code to their migration files.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Entity Framework进行索引，开发者可以使用各种工具和方法。进行索引的一种方法是使用Entity Framework Fluent
    API，它允许开发者通过代码在其实体上定义索引。要使用Fluent API创建索引，开发者可以使用`HasIndex`方法并指定应包含在索引中的属性。另一个选项是使用Entity
    Framework Designer，这是一个可视化工具，允许开发者通过图形界面设计他们的数据模型。设计器包括通过在实体上右键单击并选择**添加索引**来定义实体索引的能力。最后，开发者可以通过向迁移文件中添加适当的代码来使用数据库迁移在他们的实体上创建索引。
- en: Configuring indexes with Entity Framework is straightforward!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Entity Framework配置索引非常简单！
- en: 'If we consider the `GoodHabit` table that we developed in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056),
    we used the following C# code to define the structure of the table:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑我们在[*第2章*](B19343_02.xhtml#_idTextAnchor056)中开发的`GoodHabit`表，我们使用了以下C#代码来定义表的结构：
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can add an index to the `Name` column by decorating the class with an attribute
    like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式使用属性装饰类来向`Name`列添加索引：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will instruct the database platform to create an index for the `Name`
    column. We could do the same for the `ID` column in the same way. You can create
    a composite index by setting the attribute as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指导数据库平台为`Name`列创建一个索引。我们可以以同样的方式为`ID`列创建索引。你可以通过以下方式设置属性来创建一个组合索引：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you need to set the sort order of the indexes, you can use one of the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要设置索引的排序顺序，你可以使用以下方法之一：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want to name your index, you can use the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要给你的索引命名，你可以使用以下方法：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is a great deal of flexibility provided by Entity Framework, and it is
    out of the scope of this book to cover all of it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework提供了大量的灵活性，本书的范围不包括所有内容。
- en: You can get more information about it at [https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations](https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations](https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations)了解更多信息。
- en: We will now build out a database for the example application, being mindful
    of what we have just learned.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为示例应用程序构建数据库，同时考虑到我们刚刚学到的内容。
- en: Designing a database schema using Entity Framework code first
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Entity Framework代码首先设计数据库模式
- en: 'Before we start designing a database, let’s stop and think about what our requirements
    are:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设计数据库之前，让我们先停下来思考一下我们的需求是什么：
- en: The database will store user information to identify individual users
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库将存储用户信息以识别单个用户
- en: Users can add habits to the database to track their progress and achieve their
    goals
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以向数据库添加习惯以跟踪他们的进度并实现他们的目标
- en: Users can log progress for each habit and set reminders to perform it
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以为每个习惯记录进度并设置提醒来执行它
- en: Users can set goals for their habits, such as running a certain number of miles
    or saving a certain amount of money
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以为他们的习惯设置目标，例如跑一定数量的英里或存一定数量的钱
- en: The database can support users in achieving their goals and improving their
    overall well-being by tracking and managing their habits
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库可以通过跟踪和管理用户习惯来支持用户实现目标并提高他们的整体福祉
- en: 'The following figure shows a diagram representing the database that we just
    configured. This shows the tables, columns, and relationships between the tables:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了代表我们刚刚配置的数据库的图表。这显示了表、列以及表之间的关系：
- en: '![Figure 4.5 – A suggested database schema](img/B19343_Figure_4.5.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 建议的数据库模式](img/B19343_Figure_4.5.jpg)'
- en: Figure 4.5 – A suggested database schema
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 建议的数据库模式
- en: The preceding diagram shows a schema that can meet the requirements defined
    previously.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了一个可以满足先前定义要求的模式。
- en: Creating the entity classes
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建实体类
- en: 'As we are using Entity Framework code first, we will build this database by
    writing C# code. Create the entity classes with the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 Entity Framework 代码优先，我们将通过编写 C# 代码来构建这个数据库。使用以下内容创建实体类：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We already have the `Habit` entity, but we will update it with some additional
    properties. Copy the following code into `Habit.cs`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了 `Habit` 实体，但我们将使用一些额外的属性来更新它。将以下代码复制到 `Habit.cs` 中：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, `Goal.cs` should look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Goal.cs` 应该看起来像这样：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Progress.cs` should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Progress.cs` 应该看起来像这样：'
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Reminder.cs` should look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reminder.cs` 应该看起来像这样：'
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, `User.cs` should look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`User.cs` 应该看起来像这样：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following lines of code into the `GoodHabitsDbContext` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码行添加到 `GoodHabitsDbContext` 类中：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can create the migration by running the following in the console:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在控制台中运行以下命令来创建迁移：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The migrations will be automatically applied to the database when `HabitService`
    runs, so simply run the Habit service to push the changes to the database.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `HabitService` 运行时，迁移将自动应用到数据库中，因此只需运行习惯服务即可将更改推送到数据库。
- en: Using the Server Explorer to view the database, we can see that the schema has
    been successfully applied!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器资源管理器查看数据库，我们可以看到模式已成功应用！
- en: '![Figure 4.6 – The schema applied to the database](img/B19343_Figure_4.6.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 应用到数据库的模式](img/B19343_Figure_4.6.jpg)'
- en: Figure 4.6 – The schema applied to the database
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 应用到数据库的模式
- en: The preceding figure shows that the schema has successfully migrated to the
    database.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示，模式已成功迁移到数据库中。
- en: Testing data-rich applications
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据丰富的应用程序
- en: Testing the database layer of a SaaS application is an essential part of the
    development process. A database is a critical component of any application, as
    it stores and manages the data that an application relies on. Ensuring that the
    database is working correctly is crucial for the overall stability and performance
    of the application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 SaaS 应用程序的数据库层是开发过程中的一个重要部分。数据库是任何应用程序的关键组件，因为它存储和管理应用程序所依赖的数据。确保数据库正常工作对于应用程序的整体稳定性和性能至关重要。
- en: There are several challenges that you may encounter when testing the database
    layer of your application. One challenge is ensuring that the database schema
    is correct and that the data is stored and retrieved correctly. Another challenge
    is ensuring that the database is properly optimized for performance, particularly
    if you are dealing with large amounts of data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试应用程序的数据库层时，您可能会遇到几个挑战。一个挑战是确保数据库模式正确，并且数据被正确存储和检索。另一个挑战是确保数据库已适当优化以获得性能，尤其是如果您处理大量数据时。
- en: There are a number of different techniques that you can use to test the database
    layer of your application. One common technique is to use unit tests to verify
    that individual database functions are working correctly. Another technique is
    to use integration tests to ensure that the database is working correctly in conjunction
    with the rest of the application. You may also want to use performance tests to
    ensure that the database is able to handle large amounts of data without experiencing
    any issues.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用多种不同的技术来测试应用程序的数据库层。一种常见的技术是使用单元测试来验证单个数据库功能是否正常工作。另一种技术是使用集成测试来确保数据库与应用程序的其余部分一起正确工作。您还可能想使用性能测试来确保数据库能够处理大量数据而不会出现任何问题。
- en: Unit tests are a type of automated testing that is used to verify the behavior
    of individual units of code, such as individual functions or methods. In contrast
    to unit tests, integration tests focus on testing how different parts of an application
    work together as a system. Integration tests are used to ensure that different
    components of the application are able to communicate and interact with one another
    correctly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种自动化测试类型，用于验证单个代码单元的行为，例如单个函数或方法。与单元测试不同，集成测试关注于测试应用程序的不同部分作为一个系统如何协同工作。集成测试用于确保应用程序的不同组件能够正确地相互通信和交互。
- en: Upgrading a database
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级数据库
- en: Upgrading a database with Entity Framework involves making changes to the database
    schema and data to reflect changes in an application. This can include adding
    new tables or columns, modifying existing tables or columns, and migrating data
    from one format to another.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Entity Framework升级数据库涉及对数据库架构和数据进行更改，以反映应用程序中的更改。这可能包括添加新表或列、修改现有表或列，以及将数据从一种格式迁移到另一种格式。
- en: There are several approaches that you can take when upgrading a database with
    Entity Framework. One approach is to use the `DbMigrations` class to automatically
    generate and execute the necessary SQL commands to update the database schema.
    This can be convenient, as it allows you to make changes to the database using
    a high-level API, rather than having to write raw SQL commands. However, it can
    also be less flexible than some other approaches, as it relies on Entity Framework
    to generate the SQL commands, and that may not always produce optimal results.
    This is the approach that we will take in this chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Entity Framework升级数据库时，你可以采取几种方法。一种方法是用`DbMigrations`类自动生成和执行必要的SQL命令来更新数据库架构。这可能是方便的，因为它允许你使用高级API对数据库进行更改，而不是必须编写原始SQL命令。然而，它可能不如其他方法灵活，因为它依赖于Entity
    Framework生成SQL命令，而这可能并不总是产生最佳结果。这是我们本章将采用的方法。
- en: It is worth being aware of a popular alternative approach, which is to use Entity
    Framework’s `DbContext` class to manually execute SQL commands to update a database.
    This can be more flexible, as you have complete control over the SQL commands
    that are executed. However, it can also be more time-consuming and error-prone,
    as you have to write and debug the SQL commands yourself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有一个流行的替代方法，即使用Entity Framework的`DbContext`类手动执行SQL命令来更新数据库。这可以更加灵活，因为你可以完全控制执行的SQL命令。然而，这也可能更加耗时和容易出错，因为你必须自己编写和调试SQL命令。
- en: Finally, it is, of course, possible to update a database separately from Entity
    Framework using any preferred method, which most likely involves executing SQL
    scripts.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当然，你可以使用任何首选方法独立于Entity Framework更新数据库，这很可能涉及执行SQL脚本。
- en: I think that it is generally preferable to make use of the built-in migration
    tools and allow Entity Framework to do the heavy lifting for us.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为通常最好使用内置的迁移工具，并让Entity Framework为我们做繁重的工作。
- en: We saw this process in practice twice – when we created the initial migration
    in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056), and when we just updated the
    schema.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实践中看到了这个过程两次——当我们创建[*第二章*](B19343_02.xhtml#_idTextAnchor056)中的初始迁移时，以及当我们刚刚更新架构时。
- en: 'If you look at the `Migrations` folder in the `Database` project, you should
    see the following files:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看“数据库”项目中的“迁移”文件夹，你应该会看到以下文件：
- en: '![Figure 4.7 – The Migrations folder](img/B19343_Figure_4.7.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 迁移文件夹](img/B19343_Figure_4.7.jpg)'
- en: Figure 4.7 – The Migrations folder
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 迁移文件夹
- en: In the preceding figure, we can see the `.._InitialSetup.cs` file that contains
    our first pass, the `.._MultiTenant.cs` file that has the modifications that we
    made in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), and the `AdditionalEntities.cs`
    file that we added in this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到包含我们第一次尝试的`.._InitialSetup.cs`文件，包含我们在[*第三章*](B19343_03.xhtml#_idTextAnchor082)中做出的修改的`.._MultiTenant.cs`文件，以及我们在这章中添加的`AdditionalEntities.cs`文件。
- en: 'If you recall, in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056), we added
    the initial migration with the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在[*第二章*](B19343_02.xhtml#_idTextAnchor056)中，我们添加了以下初始迁移：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, when creating the second migration, we used this instead:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在创建第二个迁移时，我们使用了以下方法：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The reason for this is that the work we did in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082)
    to introduce the multi-tenancy has added parameters to the constructor, which
    are defined in the API project. Pointing the migration tool at the API project
    allows it to create migrations via the `HabitService` project.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在[*第3章*](B19343_03.xhtml#_idTextAnchor082)中引入多租户所做的工增加了构造函数的参数，这些参数在API项目中定义。将迁移工具指向API项目允许它通过`HabitService`项目创建迁移。
- en: If you look into either of these generated classes, you will see two methods,
    named `Up` and `Down`. These methods allow the migration to be added to the database,
    or rolled back.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这些生成的类中的任何一个，你会看到两个名为`Up`和`Down`的方法。这些方法允许迁移被添加到数据库中，或者回滚。
- en: Applying the migrations
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用迁移
- en: 'Because of how we have configured the databases for multi-tenancy in [*Chapter
    3*](B19343_03.xhtml#_idTextAnchor082), we do not need to manually update each
    database. However, should you find you need to manually update a database, you
    can use the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在[*第3章*](B19343_03.xhtml#_idTextAnchor082)中配置了数据库的多租户模式，因此我们不需要手动更新每个数据库。然而，如果你发现你需要手动更新数据库，你可以使用以下方法：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Issuing this command will instruct Entity Framework to look in the `Migrations`
    folder and compare the migrations that it finds there with the migrations that
    are present in the database. If there are any additional migrations that have
    not yet been applied to the database, Entity Framework will apply those migrations.
    Let’s take a closer look at the first one we created, called `initial`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 发出此命令将指示Entity Framework在`Migrations`文件夹中查找，并将找到的迁移与数据库中现有的迁移进行比较。如果有任何尚未应用到数据库的额外迁移，Entity
    Framework将应用这些迁移。让我们更详细地看看我们创建的第一个迁移，名为`initial`：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code is auto-generated by the migration tool, but it’s perfectly acceptable
    to manually adjust the code here if there is a reason to. We can see two methods
    here. One is called `Up`, and the other `Down`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码由迁移工具自动生成，但如果有必要，可以手动调整此处的代码。我们在这里可以看到两个方法。一个叫做`Up`，另一个叫做`Down`。
- en: The `Up` method creates the table in the database, and the `Down` method drops
    the table. This is converted into SQL code, which is issued to the database engine
    when the `database update` command is issued.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Up`方法在数据库中创建表，而`Down`方法删除表。这被转换为SQL代码，当发出`database update`命令时，将向数据库引擎发出。'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a lot in this chapter!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量的内容！
- en: We learned that data is important in a SaaS application. This can be trying
    not only from a technical point of view but also from the point of view of a user,
    as well as the organization building the application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到数据在SaaS应用程序中非常重要。这不仅从技术角度来看是如此，而且从用户的角度以及构建应用程序的组织角度来看也是如此。
- en: We then moved on to a technical implementation with Entity Framework, demonstrating
    how to build a database in code using C#, and then automatically generate migrations
    and update the database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向使用Entity Framework的技术实现，展示了如何使用C#在代码中构建数据库，然后自动生成迁移并更新数据库。
- en: We also talked about testing strategies and maintaining a database in production.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了测试策略和在生产中维护数据库。
- en: In the next chapter, we will build out the API layer and start to interact with
    the data structure we previously created. The application will start to take shape!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建API层并开始与之前创建的数据结构进行交互。应用程序将开始成形！
- en: Further reading
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'What is Code-First?: [https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx](https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Code-First?：[https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx](https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx)
- en: 'Testing with Entity Framework: [https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/](https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Entity Framework进行测试：[https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/](https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/)
- en: 'Data-driven culture: [https://www.smartkarrot.com/resources/blog/data-driven-culture/](https://www.smartkarrot.com/resources/blog/data-driven-culture/)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据驱动文化：[https://www.smartkarrot.com/resources/blog/data-driven-culture/](https://www.smartkarrot.com/resources/blog/data-driven-culture/)
- en: 'Database normalization: [https://www.sqlshack.com/what-is-database-normalization-in-sql-server/](https://www.sqlshack.com/what-is-database-normalization-in-sql-server/)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库规范化：[https://www.sqlshack.com/what-is-database-normalization-in-sql-server/](https://www.sqlshack.com/what-is-database-normalization-in-sql-server/)
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In what ways can a business monetize data that is present in a SaaS application?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 商业如何货币化SaaS应用程序中存在的数据？
- en: What are the ethical considerations around data monetization?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据货币化有哪些伦理考量？
- en: How are foreign key relationships represented in Entity Framework?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外键关系在Entity Framework中是如何表示的？
- en: What is the difference between a unit test and an integration test?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试和集成测试之间有什么区别？
- en: If I want to roll back migration in a live database, how do I ensure that no
    data is lost?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我想在实时数据库中回滚迁移，我如何确保不丢失任何数据？
