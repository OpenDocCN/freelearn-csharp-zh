- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: C# Fundamentals in Unity – Variables, Loops, and Troubleshooting Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# Fundamentals in Unity – Variables, Loops, and Troubleshooting Techniques
- en: In this chapter, you’ll deepen your understanding of Unity and C# by exploring
    the core programming concepts that bring games to life. After setting up Unity
    and gaining a basic grasp of C#, we’ll explore C# syntax to understand the structure
    of effective code writing. You’ll learn about different types of data storage
    and how to manage information within your games.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将通过探索使游戏栩栩如生的核心编程概念来加深对 Unity 和 C# 的理解。在设置 Unity 并掌握 C# 的基本知识后，我们将探索 C#
    语法，以了解有效代码编写的结构。您将了解不同类型的数据存储以及如何在游戏中管理信息。
- en: We then progress to controlling game flow through conditional statements and
    loops, which allows for dynamic responses to player actions and game events. The
    chapter also covers function structuring to help organize and simplify your code,
    making complex tasks manageable and reusable. Additionally, we’ll equip you with
    debugging techniques to ensure that your game operates smoothly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着通过条件语句和循环来控制游戏流程，这允许对玩家动作和游戏事件进行动态响应。本章还涵盖了函数结构，以帮助组织和简化代码，使复杂任务变得可管理并可重用。此外，我们还将为您提供调试技术，以确保游戏运行顺畅。
- en: By building on your initial knowledge of Unity and C#, this chapter aims to
    elevate your skills from foundational to practical, enhancing your capability
    to create interactive and engaging gaming experiences.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Unity 和 C# 的初始知识基础上构建，本章旨在将您的技能从基础提升到实践，增强您创建互动和引人入胜的游戏体验的能力。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: An introduction to C# syntax
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 语法简介
- en: Variables and data types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和数据类型
- en: Control structures in C#
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 中的控制结构
- en: Writing basic functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写基本函数
- en: Exploring Unity-specific functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Unity 特定函数
- en: Debugging C# scripts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 C# 脚本
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the technical requirements for the chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章的技术要求：
- en: '**The Unity Editor (the latest stable version)**: Download and install the
    latest stable release of the Unity Editor via Unity Hub to ensure compatibility
    with the covered topics.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity 编辑器（最新稳定版本）**：通过 Unity Hub 下载并安装最新稳定版本的 Unity 编辑器，以确保与所涵盖主题的兼容性。'
- en: '**Unity Hub**: Use Unity Hub to manage Unity installations and project versions
    effectively.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity Hub**：使用 Unity Hub 有效地管理 Unity 安装和项目版本。'
- en: '**An Integrated Development Environment (IDE)**: A recommended IDE, such as
    Visual Studio or Visual Studio Code, configured for Unity development to write,
    debug, and manage C# scripts.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成开发环境 (IDE)**：推荐使用 Visual Studio 或 Visual Studio Code 等IDE，配置为 Unity 开发，用于编写、调试和管理
    C# 脚本。'
- en: '**An internet connection**: Required to access Unity documentation and community
    forums for troubleshooting and support.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网连接**：需要访问 Unity 文档和社区论坛以进行故障排除和支持。'
- en: 'You can find the examples/files related to this chapter here: [https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter03](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter03)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到与本章相关的示例/文件：[https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter03](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter03)
- en: An introduction to C# syntax
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 语法简介
- en: '**C# (C Sharp)** is a modern, object-oriented, and type-safe programming language
    developed by Microsoft. It is widely used for developing desktop applications,
    web applications, and game development with Unity. Understanding the structure
    of C# coding is essential for effective programming. Here’s a breakdown of the
    basic structure and some key elements in C#:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#（C Sharp）** 是由微软开发的一种现代、面向对象且类型安全的编程语言。它被广泛用于开发桌面应用程序、Web 应用程序以及使用 Unity
    的游戏开发。理解 C# 编码的结构对于有效编程至关重要。以下是基本结构和 C# 中的某些关键元素的概述：'
- en: The basic structure of a C# program
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 程序的基本结构
- en: 'A typical C# program consists of the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 C# 程序包括以下内容：
- en: '`System` is a namespace that includes classes such as `Console`, which can
    be used for input and output operations. For example, `using UnityEngine;` usually
    appears at the top of the script.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System` 是一个包含 `Console` 等类别的命名空间，这些类可用于输入和输出操作。例如，`using UnityEngine;` 通常出现在脚本顶部。'
- en: '**A class declaration**: A class is a blueprint from which objects are created.
    A **class** encapsulates data for the object and methods to manipulate that data.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类声明**：类是创建对象的蓝图。**类**封装了对象的数据以及操作这些数据的方法。'
- en: '**A main method**: This is the entry point of a C# program, where the program
    execution begins. It must be declared inside a class or a struct.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要方法**：这是 C# 程序的入口点，程序执行从这里开始。它必须声明在类或结构体内部。'
- en: '**Statements and expressions**: These are the actions that can be performed
    within the methods, such as declaring variables, loops, and conditionals.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句和表达式**：这些是在方法内可以执行的操作，例如声明变量、循环和条件语句。'
- en: '`;` character is used as a statement terminator, indicating the end of an individual
    statement or instruction, allowing for the separation and clarification of distinct
    operations within the code.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`;` 字符用作语句终止符，表示单个语句或指令的结束，允许在代码中分离和阐明不同的操作。'
- en: '`//`, and multiline comments are enclosed between `/*` and `*/`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//`，多行注释在 `/*` 和 `*/` 之间。'
- en: C# is a modern, object-oriented programming language by Microsoft, essential
    for developing desktop, web, and Unity applications. Understanding its structure,
    including namespaces, class declarations, main methods, statements, and comments,
    is central to effective programming. Next, we will explore the expected features
    and structure of the code header.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是微软开发的一种现代、面向对象的编程语言，对于开发桌面、Web 和 Unity 应用程序至关重要。理解其结构，包括命名空间、类声明、主方法、语句和注释，对于有效的编程至关重要。接下来，我们将探讨代码头部的预期功能和结构。
- en: Expected features and structure – a header
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预期功能和结构 – 头文件
- en: 'In C#, a header might not refer to a specific part of code as it would in a
    file format or a protocol specification. However, the top of a C# file often contains
    the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，头文件可能不会像在文件格式或协议规范中那样指向代码的特定部分。然而，C# 文件的顶部通常包含以下内容：
- en: '`using System;` allows you to use classes in the `System` namespace without
    fully qualifying their names.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using System;` 允许你使用 `System` 命名空间中的类，而无需完全限定它们的名称。'
- en: '**Namespace declaration**: As previously mentioned, this organizes your code
    and avoids name conflicts.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间声明**：如前所述，这组织了你的代码并避免了名称冲突。'
- en: At the top of a C# file, you will often find `using` directives for namespaces
    and a namespace declaration to organize code and avoid name conflicts. Next, we
    will explore the structure and features of methods in C#.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 文件的顶部，你通常会找到用于命名空间的 `using` 指令和命名空间声明，以组织代码并避免名称冲突。接下来，我们将探讨 C# 中方法的结构和功能。
- en: Expected features and structure – method structure
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预期功能和结构 – 方法结构
- en: 'A method in C# is structured as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的方法结构如下：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down the code to understand the example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码来理解这个例子：
- en: '`accessModifier`: This specifies the visibility of a variable or a method from
    another class. It is usually either `private` or `public`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accessModifier`：这指定了变量或方法从另一个类中的可见性。它通常是 `private` 或 `public`。'
- en: '`returnType`: The data type of the value that the method returns. If the method
    does not return a value, the return type is `void`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returnType`：方法返回的值的类型。如果方法不返回值，则返回类型为 `void`。'
- en: '`MethodName`: The name of the method, following the naming conventions.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodName`：方法名，遵循命名约定。'
- en: '`parameterList`: Enclosed in parentheses, these are the inputs to the method,
    specified with their data types.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameterList`：括号内包含的是方法的输入，指定了它们的数据类型。'
- en: A method in C# is structured with an access modifier (specifying visibility),
    a return type (the data type of the return value), a method name, and a parameter
    list (inputs to the method with their data types). Next, we will discuss the differences
    between class-level variables and method variables.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的方法结构包括访问修饰符（指定可见性）、返回类型（返回值的类型）、方法名和参数列表（带有数据类型的方法输入）。接下来，我们将讨论类级别变量和方法变量之间的区别。
- en: Class-level variables versus method variables
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类级别变量与方法变量对比
- en: '`public` access modifier; otherwise, use `private` or `protected` for encapsulation.
    Here’s an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `public` 访问修饰符；否则，为了封装，使用 `private` 或 `protected`。以下是一个示例：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This C# code defines a class named `MyClass` that contains a private integer
    variable, `classLevelVariable`, accessible only within the class itself. The class
    also includes a public method, `MyMethod`, that can access and manipulate the
    `classLevelVariable`. The private scope of the variable ensures that it is encapsulated
    and protected from external modifications, while `MyMethod` can use it for various
    internal operations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 C# 代码定义了一个名为 `MyClass` 的类，该类包含一个私有整数变量 `classLevelVariable`，该变量只能在类内部访问。该类还包括一个公共方法
    `MyMethod`，它可以访问并操作 `classLevelVariable`。变量的私有作用域确保了其封装性，并防止外部修改，而 `MyMethod`
    可以用它进行各种内部操作。
- en: 'Conversely, **method variables** (**local variables**) are declared inside
    a method and can only be used within that. They are not accessible by other methods
    in the class. Here’s an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**方法变量**（**局部变量**）是在方法内部声明的，并且只能在其中使用。它们不能被类中的其他方法访问。以下是一个示例：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each programming language has its structures and conventions. C# is no different.
    By learning these, you can write clear, maintainable, and efficient C# code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有其结构和约定。C# 也不例外。通过学习这些，你可以编写清晰、可维护和高效的 C# 代码。
- en: In this section, we explored the fundamental structure of a C# program, including
    essential elements such as namespace and class declarations, the main method,
    and the usage of statements and expressions, emphasizing the ‘;’ character as
    a statement terminator. We highlighted the role of using directives such as `using
    UnityEngine;` to simplify development, by eliminating the need to fully qualify
    class names. We differentiated between class-level variables, accessible throughout
    the class, and method variables, restricted to their respective methods. Understanding
    these basic structures and conventions is vital for crafting clear, maintainable,
    and efficient C# code. Moving forward, we’ll gain a deeper understanding of C#
    data types and variables, which will enhance your programming effectiveness in
    this versatile language.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 C# 程序的基本结构，包括命名空间声明、类声明、主方法和语句和表达式的使用等基本元素，强调了分号字符作为语句终止符的作用。我们强调了使用指令如
    `using UnityEngine;` 的作用，它可以简化开发过程，通过消除完全限定类名的需要。我们区分了类级别变量，可以在整个类中访问，以及方法变量，仅限于它们各自的方法。理解这些基本结构和约定对于编写清晰、可维护和高效的
    C# 代码至关重要。接下来，我们将更深入地了解 C# 数据类型和变量，这将提高你在这种多才多艺的语言中的编程效率。
- en: Variables and data types
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和数据类型
- en: In this section, we will delve into the fundamental concepts of variables and
    data types in C#, essential for storing and manipulating data within your applications.
    Understanding how C# categorizes data into different types and how these types
    interact with memory – specifically the stack and heap – is important for efficient
    programming.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究 C# 中变量和数据类型的基本概念，这对于在应用程序中存储和操作数据至关重要。理解 C# 如何将数据分类到不同的类型以及这些类型如何与内存交互——特别是栈和堆——对于高效编程非常重要。
- en: We’ll explore the distinction between value types, which store data directly,
    and reference types, which store references to the actual data, illuminating their
    respective uses of stack and heap memory. Our journey through C#’s data landscape
    will cover the gamut from primitive types, such as integers, floating-point numbers,
    Booleans, characters, and bytes, to more complex constructs such as structs and
    enumerations, which allow for more structured data representation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨值类型和引用类型之间的区别，值类型直接存储数据，而引用类型存储对实际数据的引用，阐明它们各自在栈和堆内存中的用途。我们通过 C# 的数据景观之旅将涵盖从整数、浮点数、布尔值、字符和字节等原始类型，到更复杂的结构体和枚举等更复杂结构，这些结构允许更结构化的数据表示。
- en: Furthermore, we’ll examine classes, the backbone of object-oriented programming
    in C#, alongside strings, arrays, and delegates, each offering unique capabilities
    to handle text, collections of data, and method references, respectively. This
    comprehensive overview will equip you with a solid understanding of C#’s data
    handling mechanisms, paving the way for more advanced programming techniques and
    effective memory management in your C# applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将探讨类，这是 C# 面向对象编程的支柱，以及字符串、数组和委托，它们分别提供处理文本、数据集合和方法引用的独特功能。这个全面的概述将使你具备扎实的
    C# 数据处理机制理解，为更高级的编程技术和 C# 应用程序中的有效内存管理铺平道路。
- en: Understanding variables and data types
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解变量和数据类型
- en: In this section, we’ll dive into the basics of variables and data types in C#,
    essential for any programming task. **Variables** act as placeholders for data
    that can change, while understanding C#’s various **data types** helps you to
    choose the most efficient way to store and handle this data. This knowledge is
    key to writing effective and resource-efficient C# code, providing a strong foundation
    for more complex programming concepts ahead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解 C# 中变量和数据类型的基础知识，这对于任何编程任务都是必不可少的。**变量**充当可以更改的数据的占位符，而理解 C# 的各种**数据类型**有助于你选择最有效的方式来存储和处理这些数据。这种知识对于编写有效且资源高效的
    C# 代码至关重要，为更复杂的编程概念提供了坚实的基础。
- en: In C# programming, variables are essential, as they act as named storage spots
    for data in your code. Each variable is defined with a specific data type, determining
    the nature of the data it can hold, such as integers, text, or more complex objects.
    This clear declaration is integral in a statically typed language such as C#,
    where the data type of a variable is established at compile time, enhancing code
    safety and readability.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 编程中，变量是必不可少的，因为它们充当代码中数据的命名存储位置。每个变量都定义了一个特定的数据类型，确定了它可以持有的数据的性质，例如整数、文本或更复杂的对象。这种清晰的声明对于静态类型语言（如
    C#）至关重要，其中变量的数据类型在编译时确定，从而增强了代码的安全性和可读性。
- en: C# classifies data types into two main categories – value types and reference
    types. `int`), floating-point numbers (`float` and `double`), and Booleans (`bool`),
    store data directly. `string`), arrays, and objects, store a reference to the
    actual data, impacting how information is passed and managed in your programs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C# 将数据类型分为两大类——值类型和引用类型。值类型（如 `int`），浮点数（如 `float` 和 `double`），以及布尔类型（`bool`）直接存储数据。引用类型（如
    `string`），数组，和对象存储对实际数据的引用，这影响了信息在程序中的传递和管理。
- en: This fundamental understanding of variables and data types sets the stage for
    all programming tasks in C#, from simple data manipulation to complex application
    logic. It’s a cornerstone concept that ensures that your code is not only functional
    but also efficient and effective, paving the way for more advanced C# programming
    skills.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对变量和数据类型的基本理解为 C# 中的所有编程任务奠定了基础，从简单的数据操作到复杂的应用逻辑。这是一个基石概念，确保了你的代码不仅功能性强，而且高效且有效，为更高级的
    C# 编程技能铺平了道路。
- en: Why is it important to choose the right data type?
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么选择正确的数据类型很重要？
- en: Choosing the right data type in C# is critical for optimizing memory usage and
    ensuring efficient data manipulation. Each data type has a specific memory footprint
    and value range, so selecting one that closely matches your needs can significantly
    enhance your application’s performance. For example, using a `byte` instead of
    an `int` for small numeric values saves memory, which is important in large datasets
    or memory-constrained environments.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中选择合适的数据类型对于优化内存使用和确保高效的数据操作至关重要。每种数据类型都有特定的内存占用和值范围，因此选择一个与你的需求紧密匹配的类型可以显著提高应用程序的性能。例如，对于小的数值，使用
    `byte` 而不是 `int` 可以节省内存，这在大型数据集或内存受限的环境中尤为重要。
- en: Using appropriate data types, such as strings for text and integers or floats
    for numerical values, can make your code more understandable and reduce the likelihood
    of errors by ensuring data is stored and processed correctly. For instance, an
    `enum` clearly conveys fixed value sets such as the days of the week, improving
    code readability and maintainability. In summary, thoughtful data type selection
    is key to writing efficient, clear, and robust C# code, impacting both application
    performance and the developer experience.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的数据类型，如字符串用于文本，整数或浮点数用于数值，可以使你的代码更易于理解，并通过确保数据被正确存储和处理来降低出错的可能性。例如，`enum`
    可以清楚地传达固定值集，如一周中的日子，从而提高代码的可读性和可维护性。总之，谨慎选择数据类型是编写高效、清晰和健壮的 C# 代码的关键，它影响着应用程序的性能和开发者的体验。
- en: Understanding variables and data types in C# is essential for efficient data
    storage and manipulation. These concepts form the foundation for more complex
    programming challenges and memory management. As we delve into stack and heap
    memory, distinguishing between value and reference types is important for effective
    data handling and performance in C# development.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 C# 中的变量和数据类型对于高效的数据存储和处理至关重要。这些概念构成了更复杂编程挑战和内存管理的基础。当我们深入研究堆栈和堆内存时，区分值类型和引用类型对于有效的数据处理和
    C# 开发中的性能至关重要。
- en: Memory management in C# – stack versus heap
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 中的内存管理——堆栈与堆
- en: As we delve deeper into the intricacies of C# programming, a solid grasp of
    variables and data types will form the bedrock of our journey. These fundamental
    concepts are indispensable for any developer, as they dictate how data is stored,
    manipulated, and accessed within a program.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入到C#编程的复杂性中，对变量和数据类型的牢固掌握将成为我们旅程的基石。这些基本概念对于任何开发者都是不可或缺的，因为它们决定了数据在程序中的存储、操作和访问方式。
- en: Understanding the nuanced differences between value types and reference types,
    and their respective storage mechanisms in stack and heap memory, is indispensable.
    This foundational knowledge not only enhances code efficiency and clarity but
    also paves the way to master more complex aspects of memory management in C#.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 理解值类型和引用类型之间的细微差别，以及它们在栈和堆内存中的相应存储机制，是必不可少的。这种基础知识不仅提高了代码的效率和清晰度，而且为掌握C#内存管理的更复杂方面铺平了道路。
- en: As we transition to exploring the dynamics of stack versus heap memory, the
    significance of informed data type selection becomes increasingly apparent, directly
    impacting your application’s performance and reliability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向探索栈与堆内存的动态性时，明智地选择数据类型的重要性变得越来越明显，这直接影响到应用程序的性能和可靠性。
- en: The following diagram illustrates the division of a computer’s memory into heap
    and stack sections. The main difference is how the computer makes use of each
    section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了计算机内存分为堆和栈部分。主要区别在于计算机如何使用每个部分。
- en: '![Figure 3.1 – The stack and heap are portions of a computer’s memory](img/B22128_03_1.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 栈和堆是计算机内存的部分](img/B22128_03_1.jpg)'
- en: Figure 3.1 – The stack and heap are portions of a computer’s memory
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 栈和堆是计算机内存的部分
- en: In the context of C#, stack and heap memory play pivotal roles in managing how
    your program stores and accesses data. The **stack** is a **last-in, first-out**
    (**LIFO**) structure, used for static memory allocation. This means that the most
    recently added item is the first to be removed. **Static memory allocation** refers
    to memory that is allocated at compile time and whose size and lifetime are fixed,
    as opposed to **dynamic memory allocation**, which happens at runtime. The stack
    holds local variables and function calls, ensuring quick access and efficient
    management of scope-bound variables. **Scope-bound variables** are variables that
    exist only within the context of a specific function or block of code – for example,
    when a function is called, its local variables are pushed onto the stack, and
    when the function returns, these variables are popped off the stack.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#的背景下，栈和堆内存对于管理程序如何存储和访问数据起着关键作用。**栈**是一个**后进先出**（**LIFO**）结构，用于静态内存分配。这意味着最后添加的项目是第一个被移除的。**静态内存分配**指的是在编译时分配的内存，其大小和生命周期是固定的，与**动态内存分配**相对，后者在运行时发生。栈持有局部变量和函数调用，确保快速访问和高效管理作用域内变量。**作用域内变量**是指仅在特定函数或代码块上下文中存在的变量
    – 例如，当函数被调用时，其局部变量被推入栈中，当函数返回时，这些变量被从栈中弹出。
- en: Conversely, the **heap** is used for dynamic memory allocation, where objects
    and data structures that require global access or longer lifetimes are stored.
    Unlike the stack, the heap is less organized, allowing for the flexibility of
    variable size and lifetime but at the cost of slower performance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**堆**用于动态内存分配，其中存储了需要全局访问或较长时间生命周期的对象和数据结构。与栈不同，堆的组织性较差，允许变量大小和生命周期的灵活性，但代价是性能较慢。
- en: Understanding the distinct functionalities and use cases of stack and heap memory
    is essential for effective C# programming, impacting memory usage, application
    performance, and even error management.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 理解栈和堆内存的独立功能和使用场景对于有效的C#编程至关重要，它影响着内存使用、应用程序性能，甚至错误管理。
- en: In C#, value types and reference types utilize stack and heap memory differently,
    reflecting their distinct characteristics and usage. Value types, such as integers
    and Booleans, are stored directly on the stack, where their values are allocated
    and deallocated in a tightly managed LIFO manner. This approach lends itself to
    fast and efficient access, particularly for short-lived variables.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，值类型和引用类型使用栈和堆内存的方式不同，反映了它们各自的特征和用法。值类型，如整数和布尔值，直接存储在栈上，其值以紧密管理的LIFO方式分配和释放。这种方法有利于快速和高效的访问，尤其是对于短期变量。
- en: Reference types, including objects, strings, and arrays, are stored on the heap,
    a less structured memory area. While the actual data resides in the heap, the
    stack holds references or pointers to these heap-allocated objects. This separation
    allows reference types to be accessed and modified by different parts of a program
    beyond the scope of their creation, facilitating dynamic memory management but
    with a potential impact on performance, due to the overhead of heap allocation
    and garbage collection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型，包括对象、字符串和数组，存储在堆上，这是一个结构较松散的内存区域。虽然实际数据位于堆上，但栈持有对这些堆分配对象的引用或指针。这种分离允许引用类型在创建范围之外的不同程序部分中被访问和修改，从而促进动态内存管理，但可能会因为堆分配和垃圾回收的开销而对性能产生影响。
- en: Building on our exploration of C# programming, we’ve laid the groundwork for
    it with an understanding of variables, data types, and their management within
    stack and heap memory. This foundation is significant, as it dictates how data
    is stored and accessed, with value types on the stack for quick access and reference
    types on the heap for dynamic allocation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在对C#编程的探索基础上，我们已经通过理解变量、数据类型及其在栈和堆内存中的管理为其奠定了基础。这个基础非常重要，因为它决定了数据的存储和访问方式，值类型在栈上用于快速访问，而引用类型在堆上用于动态分配。
- en: As we move forward and delve into primitive types such as integers, floating-point
    numbers, Booleans, characters, and bytes, we’ll apply these core concepts of memory
    allocation to understand their specific roles, limitations, and applications in
    C#. This progression is key to enhancing our coding practices and understanding,
    preparing us for more advanced data handling and efficient application development
    in C#.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们向前迈进并深入研究诸如整数、浮点数、布尔值、字符和字节等原始类型，我们将应用这些内存分配的核心概念来理解它们在C#中的特定角色、限制和应用。这种逐步推进对于提高我们的编码实践和理解至关重要，为我们准备在C#中进行更高级的数据处理和高效的应用程序开发打下基础。
- en: Primitive types
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型
- en: As we venture further into the essentials of C# programming, our next focus
    is on **primitive types** – a fundamental aspect of coding that underpins how
    we represent and manipulate basic data. These types include integers, with their
    defined usage and limits; floating-point numbers, which offer varying degrees
    of precision for mathematical calculations; Booleans for true/false logic; characters
    for textual data; and bytes for efficient data storage and manipulation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步深入C#编程的精髓，我们的下一个焦点是**原始类型**——这是编码的基础，支撑着我们如何表示和操作基本数据。这些类型包括具有定义用途和限制的整数；提供不同精度数学计算的浮点数；用于真/假逻辑的布尔值；用于文本数据的字符；以及用于高效数据存储和操作的字节。
- en: Each of these data types plays a pivotal role in the construction of robust
    and efficient C# applications, serving as the building blocks for more complex
    data structures and algorithms. Understanding their characteristics and applications
    is essential for any developer looking to master the nuances of C# programming.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据类型中的每一个都在构建健壮和高效的C#应用程序中扮演着关键角色，是更复杂的数据结构和算法的构建块。理解它们的特性和应用对于任何希望掌握C#编程细微之处的开发者来说都是必不可少的。
- en: Primitive types – integers
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始类型 – 整数
- en: In C# programming, **integers** serve as a fundamental data type to represent
    whole numbers, necessary for a wide array of programming tasks such as counting,
    looping, and arithmetic operations that require precision to the nearest whole
    number. C# provides several subtypes of integers to cater to various needs, each
    with its own range and size, thereby ensuring developers can choose the most appropriate
    type based on their specific requirements.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程中，**整数**作为表示整数的根本数据类型，对于计数、循环和需要精确到最接近整数的结果的算术运算等广泛的编程任务至关重要。C#提供了几个整数的子类型，以满足各种需求，每个子类型都有自己的范围和大小，从而确保开发者可以根据其特定需求选择最合适的数据类型。
- en: 'When working with numerical data in C#, it’s important to choose the appropriate
    integer data type to ensure both efficiency and adequacy for the required range.
    Here is a list detailing the different integer data types in C#, each suited for
    various numerical ranges and memory efficiency considerations:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中处理数值数据时，选择适当的整数数据类型对于确保效率和满足所需范围的需求至关重要。以下是一个列表，详细说明了C#中的不同整数数据类型，每种类型都适合不同的数值范围和内存效率考虑：
- en: '`int` or `Int32`: The most commonly used integer type, `int`, has a range from
    -2,147,483,648 to 2,147,483,647\. It’s the default choice for numerical operations
    in C#, due to its balance between range and memory efficiency.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 或 `Int32`：最常用的整数类型，`int` 的范围从 -2,147,483,648 到 2,147,483,647。由于它在范围和内存效率之间的平衡，它是
    C# 中数值操作的默认选择。'
- en: '`long` or `Int64`: When you need to store larger numbers beyond the capacity
    of `int`, `long` comes into play with a much wider range, from -9,223,372,036,854,775,808
    to 9,223,372,036,854,775,807\. It’s ideal for scenarios requiring extensive numerical
    data, such as large counts or high-range calculations.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long` 或 `Int64`：当你需要存储超出 `int` 容量的更大数字时，`long` 就派上用场，它具有更宽的范围，从 -9,223,372,036,854,775,808
    到 9,223,372,036,854,775,807。它适用于需要大量数值数据的场景，如大量计数或高范围计算。'
- en: '`short` or `Int16`: For smaller numerical data where memory usage is a concern,
    `short` offers a more compact range, from -32,768 to 32,767\. It’s useful in constrained
    environments or when dealing with a limited set of data.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short` 或 `Int16`：对于内存使用是关注点的较小数值数据，`short` 提供了一个更紧凑的范围，从 -32,768 到 32,767。它在受限环境中或处理有限数据集时很有用。'
- en: '`byte`: The `byte` type represents an 8-bit positive integer with a range from
    0 to 255\. It’s particularly useful in file I/O operations, binary data processing,
    and scenarios where the data range is inherently limited to a byte’s size. Because
    bytes are always a positive number, they are also known as **unsigned**.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`：`byte` 类型表示一个 8 位正整数，范围从 0 到 255。它在文件 I/O 操作、二进制数据处理以及数据范围本质上限制在字节大小的场景中特别有用。由于字节始终是正数，它们也被称为**无符号**。'
- en: Selecting the right integer subtype is pivotal to optimizing memory usage and
    preventing overflow errors. Each subtype is tailored to specific numerical ranges
    and scenarios, making an understanding of their limits and applications a key
    aspect of efficient and robust C# programming.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的整数子类型对于优化内存使用和防止溢出错误至关重要。每个子类型都针对特定的数值范围和场景进行了定制，因此了解它们的限制和应用是高效且健壮的 C#
    编程的关键方面。
- en: Primitive types – floating-point numbers
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始类型 - 浮点数
- en: '`float` and `double`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`float` 和 `double`。'
- en: The `float` type, or `double`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`float` 类型，或 `double`。'
- en: Conversely, the `double` type, or `double` the go-to type for high-precision
    calculations, scientific computations, and any application where the accuracy
    of floating-point numbers is paramount. In some situations, it can be more digits.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`double` 类型，或者说是用于高精度计算、科学计算以及任何对浮点数精度至关重要的应用的“首选”类型。在某些情况下，它可以有更多的数字。
- en: Choosing between `float` and `double` depends on the specific requirements of
    your application – for instance, in graphics programming or simple game mechanics,
    `float` might suffice for performance reasons.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `float` 和 `double` 之间进行选择取决于你应用程序的具体要求——例如，在图形编程或简单的游戏机制中，出于性能原因，`float` 可能就足够了。
- en: In contrast, financial applications or complex scientific simulations might
    necessitate the precision offered by `double`. Understanding the trade-offs between
    precision and performance is key when working with floating-point numbers in C#.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，金融应用或复杂的科学模拟可能需要 `double` 提供的精度。在 C# 中处理浮点数时，理解精度和性能之间的权衡至关重要。
- en: Primitive types – Booleans
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始类型 - 布尔值
- en: In C#, `bool` types, are the simplest form of data representation, encapsulating
    the essence of binary logic with only two possible values – `true` or `false`.
    This fundamental type is instrumental in control flow and decision-making processes
    within a program, such as evaluating conditions in `if`-`else` statements, loops,
    and toggling states in applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，`bool` 类型是最简单的数据表示形式，它只包含两个可能的值——`true` 或 `false`，封装了二进制逻辑的本质。这种基本类型在程序的控制流和决策过程中至关重要，例如在
    `if-else` 语句、循环中评估条件以及在应用程序中切换状态。
- en: Whether it’s checking whether user input is valid, determining the outcome of
    a logical operation, or controlling the visibility of UI elements, Booleans serve
    as the backbone for binary decisions, making them an indispensable tool in the
    arsenal of C# programming. Their straightforward nature allows for clear and concise
    code, enhancing readability and maintainability in software development.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是检查用户输入是否有效、确定逻辑运算的结果，还是控制 UI 元素的可见性，布尔值作为二元决策的支柱，是 C# 编程工具箱中不可或缺的工具。它们直观的特性使得代码清晰简洁，提高了软件开发的可读性和可维护性。
- en: Primitive types – characters
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始类型 - 字符
- en: In C# programming, the foundation of text manipulation begins with the primitive
    `char` type is essential for operations that require examination or manipulation
    of text at the character level, providing a building block for parsing, analyzing,
    and processing individual elements of strings.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程中，文本操作的基础始于基本`char`类型，这对于需要检查或操作文本的字符级操作是必不可少的，为解析、分析和处理字符串的各个元素提供了构建块。
- en: Expanding upon the concept of individual characters, C# introduces the `string`
    type to represent sequences of characters as unified entities. **Strings** in
    C# are immutable; once a string object is created, its value cannot be altered.
    This immutability enhances the security and stability of string data across various
    operations, ensuring that string values remain consistent throughout the program’s
    execution.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展单个字符的概念的基础上，C#引入了`string`类型来表示字符序列作为统一实体。C#中的**字符串**是不可变的；一旦创建了一个字符串对象，其值就不能更改。这种不可变性增强了字符串数据在各种操作中的安全性和稳定性，确保字符串值在整个程序执行过程中保持一致。
- en: However, the immutable nature of strings also requires careful consideration
    of memory usage and performance, especially in scenarios involving extensive string
    manipulation. This is because operations that appear to modify a string actually
    result in the creation of new string instances – that is, a duplicate string is
    created in memory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，字符串的不可变性质也要求仔细考虑内存使用和性能，尤其是在涉及大量字符串操作的场景中。这是因为看似修改字符串的操作实际上会导致创建新的字符串实例——即在内存中创建一个重复的字符串。
- en: Understanding the interplay between `char` for single characters and `string`
    for character sequences is key for effective text handling in C#. This knowledge
    allows developers to navigate the intricacies of text processing with precision,
    leveraging the `char` and `string` types to their full potential for a wide array
    of applications, from simple data entry to complex text analysis and manipulation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`char`类型用于单个字符和`string`类型用于字符序列之间的相互作用对于在C#中有效处理文本至关重要。这种知识使开发者能够精确地导航文本处理的复杂性，利用`char`和`string`类型充分发挥其潜力，适用于从简单的数据录入到复杂的文本分析和操作的各种应用。
- en: Primitive types – bytes
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本类型 – 字节
- en: In C# programming, the `byte` type essential for reading and writing data streams,
    converting between different data representations, and interfacing with external
    systems where precise control over data encoding is required. Whether it’s parsing
    a JSON payload from a web service or handling multimedia files, bytes provide
    the granularity needed for detailed and efficient data manipulation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程中，`byte`类型对于读取和写入数据流、在不同数据表示之间转换以及与需要精确控制数据编码的外部系统接口是必不可少的。无论是解析来自网络服务的JSON有效负载还是处理多媒体文件，字节提供了进行详细和高效数据操作所需的粒度。
- en: Exploring primitive types in C# has given us a solid grasp of the fundamental
    data types essential for programming. Each data type, from integers and floating-points
    to Booleans, characters, strings, and bytes, serves a specific purpose, enhancing
    logical operations and data handling.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 探索C#中的基本类型使我们牢固地掌握了编程中必不可少的根本数据类型。每种数据类型，从整数和浮点数到布尔值、字符、字符串和字节，都服务于特定的目的，增强了逻辑操作和数据处理。
- en: As we move on to exploring structs, these fundamental insights into Primitive
    Types will prove invaluable, offering a clear perspective on when and why user-defined
    value types might be preferred over or used alongside these basic data types.
    This progression lays a solid groundwork to understand the versatility and utility
    of structs in C#, enhancing our ability to create more efficient and robust applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续探索结构体，对这些基本类型的深入了解将非常有价值，它提供了清晰的角度，了解何时以及为什么用户定义的值类型可能比这些基本数据类型更受欢迎或与之一起使用。这种进展为理解结构体在C#中的多功能性和实用性奠定了坚实的基础，增强了我们创建更高效和健壮应用程序的能力。
- en: Structs – user-defined value types
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体 – 用户定义的值类型
- en: In the realm of C# programming, **structs** stand out as user-defined value
    types that bundle related variables, offering a compact alternative to classes
    with value-type behavior. This section will illuminate what structs are, their
    practical uses, and how they compare to primitive types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程领域，**结构体**作为用户定义的值类型脱颖而出，将相关变量捆绑在一起，为具有值类型行为的类提供了一个紧凑的替代品。本节将阐明结构体是什么，它们的实际用途以及它们与基本类型相比如何。
- en: Understanding when to employ structs over primitives is key to enhancing code
    efficiency and clarity, especially when representing lightweight data structures.
    As we explore structs, we’ll uncover their strategic advantages in optimizing
    C# applications.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时使用结构体而不是原始类型对于提高代码效率和清晰度至关重要，尤其是在表示轻量级数据结构时。随着我们探索结构体，我们将发现它们在优化C#应用程序中的战略优势。
- en: In C#, `struct` is a keyword used to define user-defined value types, enabling
    developers to encapsulate a collection of related variables under one name. Unlike
    classes, which are reference types, structs are value types, meaning each instance
    holds its own data, and a copy is created with each assignment or method call.
    This characteristic makes `struct` particularly beneficial when defining lightweight
    data structures, such as coordinates, color values, or complex numbers, where
    the overhead of reference types can be avoided.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`struct`是一个关键字，用于定义用户定义的值类型，使开发者能够将一组相关变量封装在一个名称下。与作为引用类型的类不同，结构体是值类型，这意味着每个实例都持有自己的数据，并且每次赋值或方法调用都会创建一个副本。这种特性使得`struct`在定义轻量级数据结构（如坐标、颜色值或复数）时特别有益，可以避免引用类型带来的开销。
- en: Structs are defined using the `struct` keyword, and their value-type nature
    contributes to improved performance in scenarios that demand the efficient handling
    of small, immutable data types, reducing the burden on garbage collection and
    enhancing memory utilization. Ideal for high-performance computing tasks within
    C#, structs offer a compact and efficient way to represent data, especially when
    a large number of instances are involved.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体使用`struct`关键字定义，它们的值类型特性有助于在需要高效处理小型不可变数据类型的场景中提高性能，减少垃圾回收的负担并提高内存利用率。对于C#中的高性能计算任务，结构体提供了一种紧凑且高效的数据表示方式，尤其是在涉及大量实例时。
- en: The difference between structs and primitive types
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体与原始类型之间的区别
- en: In C#, structs offer a distinct contrast to primitive types, as they allow for
    the encapsulation of multiple related data items into a single entity, unlike
    single-value primitives such as `int` or `bool`. While primitive types are the
    foundation for basic data representation, structs extend this capability by bundling
    related fields, making them ideal for modeling more complex, but still lightweight,
    data structures.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，结构体与原始类型形成了鲜明的对比，因为它们允许将多个相关数据项封装成一个单一实体，与像`int`或`bool`这样的单值原始类型不同。虽然原始类型是基本数据表示的基础，但结构体通过捆绑相关字段扩展了这种能力，使其非常适合建模更复杂但仍然轻量级的数据结构。
- en: The decision to use structs over primitive types hinges on the need for such
    compound data constructs without the overhead of reference types, such as classes.
    Structs are particularly advantageous when you require value-type semantics, ensuring
    that each instance is a separate copy, which is vital in scenarios such as mathematical
    computations, geometric operations, or any situation where data integrity and
    performance are paramount.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构体而不是原始类型的决定取决于对这种复合数据结构的需求，同时避免引用类型（如类）的开销。当需要值类型语义时，结构体特别有利，确保每个实例都是独立的副本，这在数学计算、几何运算或任何数据完整性和性能至关重要的场景中至关重要。
- en: Therefore, choosing between primitive types and structs involves evaluating
    the complexity of the data you’re working with and the performance implications
    of value versus reference type semantics in your C# applications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在原始类型和结构体之间进行选择涉及评估你正在处理的数据的复杂性和在C#应用程序中值类型与引用类型语义的性能影响。
- en: In our exploration of C# programming, we’ve delved into the significant role
    of structs, user-defined value types that encapsulate related variables, providing
    a structured yet lightweight alternative to classes. Through the `struct` keyword,
    C# allows you to efficiently group data, ideal for representing complex but compact
    data structures such as coordinates or color values, with the added benefit of
    value-type semantics that enhance performance and memory efficiency. This distinction
    from both primitive types and classes underscores the utility of structs in scenarios
    where data integrity, performance, and the avoidance of reference type overhead
    are paramount.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索C#编程的过程中，我们已经深入研究了结构体（struct）的重要作用，结构体是一种封装相关变量的用户定义值类型，它提供了结构化但轻量级的类替代品。通过`struct`关键字，C#允许你高效地组合数据，非常适合表示复杂但紧凑的数据结构，如坐标或颜色值，并且还增加了值类型语义，这有助于提高性能和内存效率。这种与原始类型和类的区别突出了结构体在数据完整性、性能和避免引用类型开销至关重要的场景中的实用性。
- en: As we move on to discuss enumerations (enums), we will build on this foundation
    of efficient data representation, moving toward enums’ ability to make code more
    readable and maintainable by providing a meaningful and type-safe way to work
    with sets of related constants, further enriching the toolkit for effective C#
    development.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续讨论枚举（enum），我们将在此基础上构建高效数据表示的基础，转向枚举通过提供有意义且类型安全的方式来处理相关常量集，从而使代码更易于阅读和维护，进一步丰富了有效C#开发的工具集。
- en: 'The following figure shows a color palette selection screen:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了颜色调色板选择屏幕：
- en: '![Figure 3.2 – Enums can populate drop-down menus, where the player can select
    configurations for the game. Here, the player can select the color palette they
    want](img/B22128_03_2.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 枚举可以填充下拉菜单，玩家可以在其中选择游戏的配置。在此，玩家可以选择他们想要的颜色调色板](img/B22128_03_2.jpg)'
- en: Figure 3.2 – Enums can populate drop-down menus, where the player can select
    configurations for the game. Here, the player can select the color palette they
    want
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 枚举可以填充下拉菜单，玩家可以在其中选择游戏的配置。在此，玩家可以选择他们想要的颜色调色板
- en: Enums populate the pop-up menu and act as a filter, reducing the number of color
    palettes shown. In the preceding figure, the range of color palettes hasn’t yet
    been updated to reflect the choice of **Combat - Fall**. When the player selects
    a different enum from the menu, the display of color palettes will update to reflect
    that choice.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举填充弹出菜单并充当过滤器，减少了显示的颜色调色板数量。在先前的图中，颜色调色板的范围尚未更新以反映**战斗 - 秋季**的选择。当玩家从菜单中选择不同的枚举时，颜色调色板的显示将更新以反映该选择。
- en: Enumerations (enum)
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举（enum）
- en: We’ll now shift our focus to another pivotal construct in C#, `enum`. Enums
    are a powerful tool to enhance code readability and maintainability by allowing
    developers to define a set of named constants, making programs easier to understand
    and less prone to errors. This feature is particularly useful in scenarios where
    a variable can only take one of a small set of possible values, such as days of
    the week, months of the year, or command states.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把注意力转向C#中的另一个关键结构，即`enum`。枚举通过允许开发者定义一组命名的常量，从而是一种强大的工具，可以增强代码的可读性和可维护性，使程序更容易理解且更不容易出错。这个特性在变量只能取一小组可能值的情况下特别有用，例如一周中的日子、一年中的月份或命令状态。
- en: In this section, we’ll delve into the fundamentals of enums, exploring how they
    can be defined and utilized in C# to create more intuitive and error-resistant
    code. Enums not only contribute to cleaner code but also enforce type safety,
    ensuring that variables adhere to predefined constraints, further solidifying
    their role in crafting robust C# applications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究枚举的基本原理，探讨如何在C#中定义和利用枚举来创建更直观且不易出错的代码。枚举不仅有助于编写更干净的代码，还强制执行类型安全，确保变量遵守预定义的约束，从而进一步巩固其在构建健壮C#应用程序中的角色。
- en: In C#, an enum is a unique data type that allows a variable to represent a specific
    set of predefined constants, which improves code clarity and maintains type safety
    by limiting values to the defined set.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，枚举（enum）是一种独特的数据类型，它允许一个变量表示一组预定义的常量，这通过限制值到定义的集合中，提高了代码的清晰度并维护了类型安全。
- en: Enums play a critical role in C# by making code more readable and maintainable
    through the use of symbolic names for sets of related values. By defining an `enum`,
    developers can replace obscure integer values with descriptive identifiers, making
    code intuitively understandable at a glance. This not only reduces the likelihood
    of errors but also eases the maintenance and update processes, as changes can
    be made in one centralized location without sifting through scattered numeric
    literals.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举在C#中发挥着关键作用，通过使用相关值集的符号名称来使代码更易于阅读和维护。通过定义一个枚举，开发者可以用描述性标识符替换晦涩的整数值，使代码一目了然。这不仅降低了出错的可能性，还简化了维护和更新过程，因为更改可以在一个集中的位置进行，无需在散布的数字字面量中筛选。
- en: The self-documenting nature of enums enhances collaboration among developers
    and contributes to the overall robustness and clarity of the codebase, establishing
    enums as an essential construct for structured and efficient C# programming.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的自我文档特性增强了开发者之间的协作，并为代码库的整体健壮性和清晰性做出了贡献，确立了枚举作为结构化和高效C#编程的基本结构。
- en: 'In C#, defining and using enums is straightforward and enhances the semantic
    clarity of the code. An enum is defined by using the `enum` keyword, followed
    by a name and a set of named constants enclosed in curly braces. Once defined,
    an enum can be used as a type for variables, parameters, or return values, allowing
    you to work with a set of predefined options in a type-safe manner, such as the
    following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，定义和使用枚举非常简单，并且增强了代码的语义清晰度。枚举通过使用`enum`关键字定义，后跟一个名称和一组用花括号括起来的命名常量。一旦定义，枚举就可以用作变量、参数或返回值的类型，允许您以类型安全的方式处理一组预定义的选项，如下所示：
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this snippet, `Day` is an enum representing the days of the week, and `meetingDay`
    is a variable of type `Day`, assigned the `Day.Monday` value. Using enums in this
    way makes code more readable and maintainable, as it clearly communicates the
    intent and the range of possible values without resorting to numeric literals,
    which can be error-prone and less descriptive.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`Day`是一个表示星期的枚举，而`meetingDay`是一个类型为`Day`的变量，被分配了`Day.Monday`的值。以这种方式使用枚举使代码更易于阅读和维护，因为它清楚地传达了意图和可能的值范围，而不必依赖于可能导致错误的数字字面量。
- en: Exploring enums in C# reveals their importance in enhancing code readability
    and maintainability by using named constants instead of numeric literals. Enums
    represent fixed sets, such as days of the week, making code more intuitive and
    error-resistant. Their straightforward syntax and type safety improve clarity
    and robustness, replacing arbitrary numeric values with descriptive identifiers.
    This change facilitates easier maintenance and better collaboration. Transitioning
    from enums, we enter the realm of classes, the foundation of object-oriented programming
    in C#, which allows for the creation of intricate data structures and encapsulates
    behavior and state for sophisticated applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 探索C#中的枚举，可以发现它们通过使用命名常量而不是数字字面量来增强代码的可读性和可维护性。枚举代表固定的集合，例如星期几，使代码更直观且具有抗错误性。它们简单的语法和类型安全性提高了清晰性和健壮性，用描述性标识符替换了任意的数值，这有助于简化维护和更好的协作。从枚举过渡到类，我们进入了面向对象编程的领域，这是C#中面向对象编程的基础，它允许创建复杂的数据结构，并为复杂的应用程序封装行为和状态。
- en: Classes – user-defined reference types
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类 – 用户定义的引用类型
- en: Venturing further into the realm of C# programming, we will now turn our attention
    to classes, the quintessential element of object-oriented programming that epitomizes
    the language’s capability to model real-world complexities. `class` or **classes**
    in C# are user-defined reference types that provide the framework to encapsulate
    data and behavior into a single cohesive unit.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程的更深入领域，我们现在将注意力转向类，这是面向对象编程的典范元素，体现了语言建模现实世界复杂性的能力。在C#中，`class`或**类**是用户定义的引用类型，它提供了一个框架，将数据和行为封装成一个单一的统一单元。
- en: This section will take a deep dive into the anatomy of classes, exploring their
    role as the backbone of sophisticated data structures and systems. By understanding
    how classes encapsulate data and define behaviors through methods, we uncover
    the power of C# to facilitate complex, scalable, and maintainable software designs,
    marking a pivotal advancement in our journey through C# programming.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将深入探讨类的解剖结构，研究其在复杂数据结构和系统中的骨干作用。通过理解类如何通过方法封装数据和定义行为，我们揭示了C#在促进复杂、可扩展和可维护的软件开发设计方面的力量，标志着我们在C#编程之旅中的关键进步。
- en: Classes in C# are pivotal to the paradigm of object-oriented programming, encapsulating
    data and behavior into coherent units and serving as the blueprints to create
    objects. They embody the core principles of encapsulation, allowing for data and
    methods to be bundled together.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的类在面向对象编程范式中至关重要，将数据和行为封装成一致的单元，并作为创建对象的蓝图。它们体现了封装的核心原则，允许将数据和方法捆绑在一起。
- en: Moreover, C# classes introduce the concept of **abstract classes**, a key feature
    that allows a class to declare methods without providing their implementation,
    compelling other classes that inherit from them to implement these abstract methods.
    This mechanism is important for defining a contract for a group of related classes,
    ensuring consistency while providing the flexibility to have varied implementations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C#类引入了**抽象类**的概念，这是一个关键特性，允许类声明方法而不提供其实施，迫使从它们继承的其它类实现这些抽象方法。这种机制对于定义一组相关类的契约至关重要，确保一致性同时提供灵活的实现方式。
- en: By integrating abstract classes into our discussion, we grasp a deeper understanding
    of how C# facilitates complex data structures and behaviors, reinforcing the language’s
    capability to manage and removecomplexity, which is essential for developing sophisticated
    and scalable software systems.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将抽象类整合到我们的讨论中，我们更深入地理解了C#如何促进复杂的数据结构和行为，强化了语言管理并移除复杂性的能力，这对于开发复杂和可扩展的软件系统至关重要。
- en: The purpose of classes in C#
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C#中类的目的
- en: Classes in C# are instrumental in facilitating complex data structures, providing
    a robust framework to model intricate relationships and behaviors within software
    applications. By encapsulating data fields and operations into a single cohesive
    unit, classes enable the creation of composite types that can mirror real-world
    entities and their interactions with high fidelity. This encapsulation not only
    helps to organize code around related functionalities but also enhances data integrity,
    by restricting access to sensitive information through access modifiers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的类在促进复杂数据结构方面发挥着关键作用，提供了一个强大的框架来模拟软件应用内部复杂的关系和行为。通过将数据字段和操作封装成一个单一的统一单元，类能够创建可以高保真地反映现实世界实体及其相互作用的复合类型。这种封装不仅有助于围绕相关功能组织代码，还通过访问修饰符限制对敏感信息的访问来增强数据完整性。
- en: Furthermore, classes support the composition and inheritance, allowing developers
    to build complex hierarchical structures and extend functionality in a controlled
    manner. This ability to nest classes within one another or create class hierarchies
    means that even the most complex data relationships can be efficiently represented
    and manipulated, leading to more maintainable and scalable code bases that can
    evolve to meet changing requirements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类支持组合和继承，允许开发者以受控的方式构建复杂的层次结构并扩展功能。这种在类之间嵌套或创建类层次结构的能力意味着即使是最复杂的数据关系也可以高效地表示和处理，从而产生更易于维护和可扩展的代码库，能够适应不断变化的需求。
- en: Our exploration of classes in C# highlights their major role in object-oriented
    design. Classes serve as blueprints for objects, enabling the creation of complex
    data structures and behaviors. Abstract classes further enhance C# by ensuring
    consistent and flexible implementations, forming a solid foundation for scalable
    and maintainable applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对C#中类的探索突出了它们在面向对象设计中的主要作用。类作为对象的蓝图，能够创建复杂的数据结构和行为。抽象类通过确保一致性和灵活的实现进一步增强了C#，为可扩展和可维护的应用程序奠定了坚实的基础。
- en: As we transition from the structured world of classes to the nuanced realm of
    strings, we’ll delve deeper into their immutable nature and the efficient handling
    and manipulation of textual data in C#, building upon our initial discussion of
    primitive character types to explore more complex string operations and methods.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从类结构化的世界过渡到字符串的微妙领域时，我们将更深入地探讨它们的不可变性质，以及C#中文本数据的有效处理和操作，基于我们对原始字符类型的初步讨论，我们将探索更复杂的字符串操作和方法。
- en: Strings – sequences of characters
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串 – 字符序列
- en: Diving into the realm of textual data in C#, we encounter **strings**, which
    are intricate sequences of characters that form the backbone of text manipulation
    within the language. This section will explore the nature of strings, particularly
    focusing on their immutable characteristic, which dictates that once a string
    is created, it cannot be altered. We’ll examine how this immutability impacts
    the efficient handling of strings in C#, from memory management to performance
    considerations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中深入文本数据领域，我们会遇到**字符串**，它们是字符的复杂序列，构成了语言中文本操作的基础。本节将探讨字符串的本质，特别是它们不可变的特性，这决定了一旦创建字符串，就无法对其进行修改。我们将研究这种不可变性如何影响C#中字符串的高效处理，从内存管理到性能考虑。
- en: Additionally, we’ll cover the common operations and methods associated with
    strings, such as concatenation, comparison, searching, and formatting. Understanding
    these aspects of strings is fundamental for any developer looking to master text
    processing and manipulation in C#, enabling the creation of more dynamic, responsive,
    and data-rich applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将涵盖与字符串相关的常见操作和方法，例如连接、比较、搜索和格式化。理解这些字符串的方面对于任何希望掌握C#中文本处理和操作的程序员来说都是基本的，它使得创建更动态、响应更快、数据更丰富的应用程序成为可能。
- en: A `string` in C# is a sequence of Unicode characters used to represent and manipulate
    text data within the language.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`string`是一个Unicode字符序列，用于在语言中表示和操作文本数据。
- en: In C#, strings are a fundamental data type designed to handle textual information.
    The exploration of strings reveals their immutable nature, meaning that once a
    string object is created, its content cannot be changed. This characteristic of
    strings might seem limiting at first glance, but it is a deliberate design choice
    that enhances the security and performance of string operations. When a string
    is modified, such as through concatenation or replacement, C# creates a new string
    object rather than altering the original, ensuring thread safety and simplifying
    memory management.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，字符串是一种基本的数据类型，旨在处理文本信息。对字符串的探索揭示了它们的不可变性质，这意味着一旦创建字符串对象，其内容就无法更改。这种字符串的特性乍一看可能显得有限，但它是一种故意的工程设计选择，可以增强字符串操作的安全性并提高性能。当字符串被修改，如通过连接或替换时，C#会创建一个新的字符串对象而不是修改原始对象，确保线程安全并简化内存管理。
- en: The `StringBuilder` class is specifically designed for scenarios where a string
    needs to be modified repeatedly, such as in loops or complex concatenation operations.
    `StringBuilder` works by maintaining a mutable buffer of characters, allowing
    for modifications without the need to create new string objects for each change.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`类专门设计用于需要重复修改字符串的场景，例如在循环或复杂的连接操作中。`StringBuilder`通过维护一个可变的字符缓冲区来工作，允许进行修改而无需为每次更改创建新的字符串对象。'
- en: The following figure shows a string, **Hello World!**, displayed as text on
    a screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了在屏幕上作为文本显示的字符串，**Hello World**！
- en: '![Figure 3.3 – A message, Hello World!, displayed on the game’s screen](img/B22128_03_3.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 在游戏屏幕上显示的消息，Hello World!](img/B22128_03_3.jpg)'
- en: Figure 3.3 – A message, Hello World!, displayed on the game’s screen
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 在游戏屏幕上显示的消息，Hello World!
- en: In the preceding figure, a C# script sent the text **Hello World!** to a Unity
    UI Text game object. A Unity UI Text game object’s sole purpose is to display
    text on a screen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，一个C#脚本将文本**Hello World!**发送到Unity UI Text游戏对象。Unity UI Text游戏对象的唯一目的是在屏幕上显示文本。
- en: 'Moreover, C# offers a variety of methods for common string operations, such
    as searching for substrings, splitting strings based on delimiters, and formatting
    strings for display. These methods are optimized to work with the immutable nature
    of strings, providing developers with powerful tools for text manipulation that
    balance performance with ease of use. Understanding how to leverage these features
    and when to use `StringBuilder` for more efficient string handling is key for
    developers working effectively with textual data in C#, ensuring that applications
    remain responsive and resource-efficient. The following code demonstrates how
    to use the `StringBuilder` class in C# to efficiently concatenate multiple strings
    into a single output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C# 提供了各种常见字符串操作的方法，例如搜索子字符串、根据分隔符拆分字符串以及格式化字符串以供显示。这些方法针对字符串的不可变特性进行了优化，为开发者提供了强大的文本处理工具，在性能和易用性之间取得了平衡。了解如何利用这些特性以及在何时使用
    `StringBuilder` 以实现更有效的字符串处理是 C# 开发者有效处理文本数据的关键，确保应用程序保持响应和资源高效。以下代码演示了如何在 C#
    中使用 `StringBuilder` 类来有效地将多个字符串连接成一个输出：
- en: '[PRE4]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `StringBuilder` is used to append multiple strings together.
    This approach is more efficient than using `+` or `String.Concat` for concatenation
    (as explained in the next paragraph), especially in scenarios involving large
    numbers of concatenations, as it avoids creating multiple intermediate string
    objects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，使用 `StringBuilder` 将多个字符串连接在一起。这种方法比使用 `+` 或 `String.Concat` 进行连接（如下一段所述）更有效，尤其是在涉及大量连接的场景中，因为它避免了创建多个中间字符串对象。
- en: Strings in C# come equipped with a wide array of methods and operations that
    facilitate comprehensive text manipulation and analysis, making them highly versatile
    for various programming needs. Common operations include **concatenation**, which
    combines multiple strings into one; **comparison**, which evaluates the lexical
    or value equality of strings; and **searching**, which allows you to find substrings
    or characters within larger strings.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的字符串配备了广泛的方法和操作，便于全面的文本处理和分析，使它们在各种编程需求中非常灵活。常见的操作包括 **连接**，将多个字符串合并为一个；**比较**，评估字符串的词法或值相等性；以及
    **搜索**，允许你在较大的字符串中找到子字符串或字符。
- en: Additionally, strings can be modified through methods such as `Replace` to swap
    text segments, `Trim` to remove whitespace, and `Split` to divide a string into
    an array based on delimiter characters. These operations, among others, provide
    developers with the tools to effectively handle and transform textual data, enabling
    everything from simple data formatting to complex text processing tasks within
    C# applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，字符串可以通过 `Replace` 方法修改以交换文本段，`Trim` 方法删除空白，以及 `Split` 方法根据分隔符字符将字符串拆分为数组。这些操作以及其他操作为开发者提供了有效处理和转换文本数据所需的工具，从简单的数据格式化到
    C# 应用程序中的复杂文本处理任务。
- en: Our exploration of strings in C# has revealed their indispensable role in text
    manipulation, characterized by their immutable nature, which enhances security
    and performance but requires the use of `StringBuilder` to avoid the overhead
    of creating new strings. Additionally, C# provides extensive methods for concatenation,
    comparison, searching, and formatting, offering developers a robust toolkit for
    sophisticated text processing, which is essential for dynamic and data-rich applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 C# 中字符串的探索揭示了它们在文本处理中的不可或缺的作用，其不可变特性增强了安全性和性能，但需要使用 `StringBuilder` 来避免创建新字符串的开销。此外，C#
    提供了广泛的方法用于连接、比较、搜索和格式化，为开发者提供了一个强大的工具集，用于复杂的文本处理，这对于动态和数据处理丰富的应用程序至关重要。
- en: As we shift our focus from strings to arrays, we will delve into a structured
    approach to handling collections of items, marking another significant step in
    mastering C# data structures and enhancing our ability to manage and organize
    data efficiently in software development.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们关注点从字符串转向数组，我们将深入探讨一种结构化的方法来处理项目集合，这标志着在掌握 C# 数据结构和提高我们在软件开发中高效管理和组织数据的能力方面迈出的另一个重要步骤。
- en: Arrays – collections of items of a single type
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组 – 单一类型项目的集合
- en: Moving on from the nuanced world of strings, we will delve into the structured
    domain of **arrays** in C#, a fundamental construct to manage collections of items
    of a single type.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 离开字符串的微妙世界，我们将深入到 C# 中结构化的数组领域，这是一个用于管理单一类型项目集合的基本结构。
- en: Arrays serve as the bedrock to organize data into indexed sequences, allowing
    for the efficient storage and retrieval of fixed-size collections. Understanding
    arrays is essential for any C# developer, as they provide a straightforward yet
    powerful means to handle multiple data items collectively, enhancing the capability
    to construct more organized, efficient, and scalable code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是组织数据成为索引序列的基础，允许高效地存储和检索固定大小的集合。对于任何C#开发者来说，理解数组是至关重要的，因为它们提供了一种简单而强大的方式来集体处理多个数据项，从而增强构建更组织化、高效和可扩展代码的能力。
- en: This section will introduce the concept of arrays, highlighting their utility
    in various programming scenarios where a predetermined number of elements need
    to be stored and accessed systematically. We’ll explore the syntax to declare
    arrays, the process of initializing them, and the methods to iterate over their
    elements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍数组的概念，强调其在各种编程场景中的实用性，在这些场景中需要系统地存储和访问预定的元素数量。我们将探讨声明数组的语法、初始化它们的过程以及遍历其元素的方法。
- en: Arrays in C# are a foundational data structure designed to store fixed-size
    collections of elements, all of the same type, in a way that places each item
    next to the previous one in memory. They offer a straightforward yet powerful
    way to organize data, making it easily accessible via an index. The utility of
    arrays extends across various programming scenarios, from handling lists of variables
    in a controlled manner to performing batch operations on sets of data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的数组是一种基础的数据结构，旨在以将每个项目紧挨着前一个项目的方式存储固定大小的元素集合，所有元素类型相同。它们提供了一种简单而强大的组织数据的方式，通过索引使其易于访问。数组在各个编程场景中的实用性广泛，从以受控方式处理变量列表到对数据集执行批量操作。
- en: By providing a fixed-size, ordered collection, arrays facilitate operations
    such as sorting, searching, and iterating with ease and efficiency. This characteristic
    makes arrays an indispensable tool in software development, particularly when
    dealing with a known quantity of elements that require uniform handling and when
    performance considerations, such as quick access and modification of data, are
    paramount.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个固定大小、有序的集合，数组使得排序、搜索和迭代等操作变得轻松高效。这一特性使得数组在软件开发中成为不可或缺的工具，尤其是在处理已知数量的元素且需要统一处理，以及性能考虑（如快速访问和修改数据）至关重要的场合。
- en: The syntax to declare arrays in C# is intuitive yet flexible, allowing developers
    to specify the type and size of the array explicitly. An array declaration begins
    with the type of elements it will store, followed by square brackets to denote
    the array, and then the array name.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中声明数组的语法直观且灵活，允许开发者明确指定数组的类型和大小。数组声明从它将存储的元素类型开始，然后是方括号表示数组，最后是数组名称。
- en: 'For example, declaring an integer array named `numbers` that can hold five
    elements is done with `int[] numbers = new int[5];`. This syntax sets the foundation
    to initialize arrays, either at the point of declaration with predefined values,
    such as `int[] numbers = {1, 2, 3, 4, 5};`, or by assigning values to individual
    elements post-declaration using their index, such as `numbers[0] = 1;`. Here is
    an example of array initialization and element assignment in C#:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，声明一个名为`numbers`的整数数组，它可以容纳五个元素，可以通过`int[] numbers = new int[5];`来完成。这种语法为初始化数组奠定了基础，无论是通过声明时预定义的值，例如`int[]
    numbers = {1, 2, 3, 4, 5};`，还是通过在声明后使用它们的索引分配值，例如`numbers[0] = 1;`。以下是在C#中初始化数组和分配元素的示例：
- en: '[PRE5]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code snippet initializes an integer array with five elements and then sets
    the first element to `1`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码初始化了一个包含五个元素的整数数组，并将第一个元素设置为`1`。
- en: '`int[,] matrix;`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`int[,] matrix;`.'
- en: '`for` loop (explained in more detail in the following `for` loop section) is
    a popular choice for iterating through an array, as it provides control over the
    index, offering the ability to access each element directly. A `for` loop iterating
    over the `numbers` array might look like `for(int i = 0; i < numbers.Length; i++)
    { Debug.Log(numbers[i]); }`, where `numbers.Length` dynamically refers to the
    size of the array.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环（在接下来的`for`循环部分中详细解释）是遍历数组的流行选择，因为它提供了对索引的控制，能够直接访问每个元素。一个遍历`numbers`数组的`for`循环可能看起来像`for(int
    i = 0; i < numbers.Length; i++) { Debug.Log(numbers[i]); }`，其中`numbers.Length`动态地指代数组的大小。'
- en: 'C# also offers the `foreach` loop, which abstracts away the index handling,
    making iterations more concise, as in `foreach(int number in numbers) { Debug.Log(number);
    }`. This approach is particularly useful for operations that don’t require manipulating
    the array’s structure or tracking the index. Note that `Debug.Log` serves to log
    messages to the Unity Console, a common practice in Unity development for debugging.
    The following code snippet shows examples of `for` loops and `foreach` loops:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还提供了 `foreach` 循环，它抽象了索引处理，使迭代更加简洁，例如 `foreach(int number in numbers) { Debug.Log(number);
    }`。这种方法特别适用于不需要操作数组结构或跟踪索引的操作。请注意，`Debug.Log` 用于将消息记录到 Unity 控制台，这是 Unity 开发中常见的调试实践。以下代码片段展示了
    `for` 循环和 `foreach` 循环的示例：
- en: '[PRE6]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code snippet iterates through the numbers array using a `for`
    loop and a `foreach` loop, printing each element to the debug log. The `for` loop
    iterates over each element in the numbers array and displays the results in the
    Unity Console. The `foreach` loop does exactly the same in a single line.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段使用 `for` 循环和 `foreach` 循环遍历数字数组，将每个元素打印到调试日志中。`for` 循环遍历数字数组中的每个元素，并在
    Unity 控制台中显示结果。`foreach` 循环以单行完成同样的操作。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: C# uses the `Length` property to provide the number of elements an array can
    hold, effectively indicating its size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: C# 使用 `Length` 属性来提供数组可以容纳的元素数量，从而有效地指示其大小。
- en: Mastering the syntax, declaration, and iteration techniques for arrays in C#
    empowers developers to adeptly manage and manipulate data collections, a skill
    foundational to algorithm development, data set management, and feature creation
    that relies on structured data access. This proficiency in handling arrays forms
    a critical component of adept C# programming, bridging the gap to more advanced
    concepts such as delegates.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握 C# 中数组语法、声明和迭代技术的技巧，使开发者能够熟练地管理和操作数据集合，这是算法开发、数据集管理以及依赖于结构化数据访问的功能创建的基础技能。这种处理数组的熟练度是高效
    C# 编程的关键组成部分，为更高级的概念如委托搭建了桥梁。
- en: As we move on from the structured world of arrays to the dynamic realm of Delegates,
    we will explore the role of delegates as method references that are pivotal for
    event handling and callbacks, further expanding the versatility and power of C#
    in creating responsive and interactive applications. This next step will delve
    into how delegates are declared, instantiated, and utilized, marking a deeper
    foray into the nuanced capabilities of C# in managing not just data but also the
    behaviors and interactions within software systems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从数组的结构化世界过渡到委托的动态领域时，我们将探讨委托作为方法引用在事件处理和回调中的角色，进一步扩展 C# 在创建响应式和交互式应用程序中的多功能性和强大功能。这一步将深入探讨委托的声明、实例化和使用方法，标志着对
    C# 在管理数据、行为和软件系统内交互的细微能力进行更深入探索的标志。
- en: Delegates – references to methods
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托 – 方法的引用
- en: As we venture deeper into the advanced constructs of C# programming, we encounter
    **delegates**, a powerful feature that encapsulates method references, enabling
    flexible and dynamic method invocation. Delegates play a pivotal role in the design
    of event-driven and callback mechanisms, allowing methods to be passed as parameters
    and stored as variables, thus facilitating extensible and maintainable code architectures.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入到 C# 编程的高级结构中，我们会遇到 **委托**，这是一个强大的功能，它封装了方法引用，使得方法调用变得灵活和动态。委托在事件驱动和回调机制的设计中扮演着核心角色，允许方法作为参数传递并存储为变量，从而促进可扩展和可维护的代码架构。
- en: In this section, we will unravel the concept of delegates, exploring their significance
    in orchestrating event handling and implementing callback methods. We’ll also
    delve into the practicalities of declaring, instantiating, and using delegates
    in C#, shedding light on their versatility and utility in crafting sophisticated
    and responsive applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将揭示委托的概念，探讨其在事件处理和实现回调方法中的重要性。我们还将深入探讨在 C# 中声明、实例化和使用委托的实用性，阐明它们在构建复杂和响应式应用程序中的灵活性和实用性。
- en: Delegates in C# are akin to function pointers in other programming languages
    but are type-safe, meaning they hold references only to methods that match their
    signature. This feature allows developers to encapsulate a reference to a method
    inside a delegate object, enabling the delegate to invoke the method it references
    dynamically. This capability is particularly significant in the construction of
    event-driven programs and the implementation of callback methods, where actions
    need to be deferred or decided at runtime.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的委托类似于其他编程语言中的函数指针，但它们是类型安全的，这意味着它们只持有与它们的签名匹配的方法的引用。这一特性允许开发者在委托对象内部封装对方法的引用，使委托能够动态地调用它引用的方法。这种能力在构建事件驱动程序和实现回调方法中尤为重要，在这些情况下，动作需要在运行时延迟或决定。
- en: Event handling and implementing callback methods
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件处理和实现回调方法
- en: Delegates serve as the backbone of event handling, connecting events to their
    handlers. When an event occurs, the delegate calls the methods attached to it,
    allowing the program to respond to user interactions, system signals, or other
    trigger points seamlessly. For example, in a graphical user interface, a button
    click event can be linked to a delegate, which in turn invokes the method(s) designated
    to respond to the click, abstracting the event-handling mechanism and providing
    a clear and flexible way to manage event responses.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是事件处理的基础，将事件与其处理程序连接起来。当事件发生时，委托调用附加到其上的方法，使程序能够无缝地响应用户交互、系统信号或其他触发点。例如，在图形用户界面中，按钮点击事件可以链接到委托，进而调用指定响应点击的方法，抽象事件处理机制，提供清晰灵活的事件响应管理方式。
- en: Callback methods leverage delegates to specify a method that should be called
    upon the completion of a particular task, such as asynchronous operations. This
    approach is invaluable in scenarios where a task is executed, and upon its completion,
    a specific piece of code needs to be executed, such as updating the user interface
    or processing results. By using delegates for callbacks, C# programs can maintain
    a clean separation of concerns, improve code reusability, and enhance the scalability
    of the application architecture.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 回调方法利用委托来指定在特定任务完成后应调用的方法，例如异步操作。在任务执行后需要执行特定代码的场景中，这种方法非常有价值，例如更新用户界面或处理结果。通过使用委托进行回调，C#
    程序可以保持关注点的清晰分离，提高代码的可重用性，并增强应用程序架构的可扩展性。
- en: Understanding delegates and their role in event handling and callback methods
    reveals the dynamic and flexible nature of method invocation in C#. This mechanism
    not only elevates the abstraction level of method calls but also opens up a plethora
    of possibilities to design responsive, decoupled, and maintainable applications.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 理解委托及其在事件处理和回调方法中的作用，揭示了 C# 中方法调用的动态和灵活特性。这种机制不仅提高了方法调用的抽象级别，而且为设计响应式、解耦和可维护的应用程序提供了大量可能性。
- en: Declaring, instantiating, and using delegates
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明、实例化和使用委托
- en: '`delegate` keyword, followed by a return type, the delegate’s name, and any
    parameters in parentheses. For instance, `delegate int MathOperation(int a, int
    b);` defines a delegate that can hold references to any method that takes two
    integers as inputs and returns an integer.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`delegate` 关键字，后跟返回类型、委托的名称以及括号中的任何参数。例如，`delegate int MathOperation(int a,
    int b);` 定义了一个委托，它可以持有任何接受两个整数作为输入并返回整数的方法的引用。'
- en: '`int Add(int x, int y) { return x + y; }` method, you can instantiate the previously
    declared `MathOperation` delegate with this method – `MathOperation op = Add;`.
    This instantiation doesn’t invoke the `Add` method but, rather, creates a delegate
    instance, `op`, that refers to `Add`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`int Add(int x, int y) { return x + y; }` 方法，你可以使用这个方法实例化之前声明的 `MathOperation`
    委托 – `MathOperation op = Add;`。这种实例化不会调用 `Add` 方法，而是创建一个引用 `Add` 的委托实例 `op`。'
- en: '`op` delegate instance, you can call `int result = op(5, 3);`, which will invoke
    the `Add` method through the delegate, passing `5` and `3` as arguments and storing
    the result, `8`, in `result`. Delegates can also be passed as parameters to methods,
    enabling callback mechanisms and event-handling systems where methods can be specified
    dynamically at runtime.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `op` 委托实例，你可以调用 `int result = op(5, 3);`，这将通过委托调用 `Add` 方法，传递 `5` 和 `3` 作为参数，并将结果
    `8` 存储在 `result` 中。委托还可以作为参数传递给方法，实现回调机制和事件处理系统，其中方法可以在运行时动态指定。
- en: 'Here’s a simple example that encapsulates the preceding concepts:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单示例，封装了上述概念：
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, `Debug.Log` serves to log messages to the Unity Console. The
    `MathOperation` delegate is declared, instantiated with the `Add` method, and
    then used to perform addition, demonstrating the declaration, instantiation, and
    usage of delegates in C#. This pattern is fundamental in C# to create flexible,
    reusable, and loosely coupled code structures.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Debug.Log`用于将消息记录到Unity控制台。声明了`MathOperation`委托，用`Add`方法实例化，然后用于执行加法，展示了在C#中声明、实例化和使用委托的模式。这种模式在C#中是创建灵活、可重用和松耦合代码结构的基础。
- en: As we move on from these fundamental building blocks to control structures in
    C#, we’ll shift our focus to the flow of execution within a program, exploring
    how decisions and iterations are managed to create dynamic and responsive applications.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从这些基本构建块转向C#中的控制结构时，我们将把重点转移到程序内的执行流程上，探索如何管理决策和迭代以创建动态和响应式的应用程序。
- en: Control structures in C#
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的控制结构
- en: Control structures are the backbone of programming in C#, orchestrating the
    flow of execution and enabling dynamic decision-making within applications. This
    section will embark on a comprehensive exploration of control structures, from
    the fundamental conditional statements that guide program decisions, based on
    specific conditions, to looping constructs that facilitate repetitive tasks across
    collections and datasets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构是C#编程的骨架，协调执行流程并使应用程序内的动态决策成为可能。本节将全面探索控制结构，从基于特定条件的程序决策的基本条件语句开始，到促进集合和数据集上重复性任务的循环结构。
- en: We’ll delve into the syntax and practical applications of `if`-`else` and `switch`
    statements, uncover the iterative power of `for`, `while`, `do-while`, and `foreach`
    loops, and navigate through the utility of jump statements such as `break`, `continue`,
    and `return` to control execution flow.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入研究`if`-`else`和`switch`语句的语法和实际应用，揭示`for`、`while`、`do-while`和`foreach`循环的迭代能力，并了解`break`、`continue`和`return`等跳转语句的实用性，以控制执行流程。
- en: By understanding these elements, you will be able to craft more efficient, readable,
    and responsive C# applications. As we commence this journey with an introduction
    to control structures, we will set the stage for a deeper understanding of how
    they dictate program behavior and enhance the capacity for complex problem-solving
    and interaction within software development.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这些元素，你将能够构建更高效、易读和响应式的C#应用程序。随着我们开始这段旅程，通过介绍控制结构，我们将为更深入地理解它们如何指导程序行为以及增强软件开发中复杂问题解决和交互的能力奠定基础。
- en: An introduction to control structures
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制结构的介绍
- en: '`if` statements to managing cycles through loops. Grasping control structures
    is crucial for developers to construct coherent, efficient, and adaptable C# code,
    making them fundamental to creating sophisticated software solutions.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`if`语句管理循环。掌握控制结构对于开发者构建连贯、高效和适应性的C#代码至关重要，它们是创建复杂软件解决方案的基础。
- en: Control structures fundamentally dictate the flow of execution in programs by
    determining which code blocks are executed, in what order, and under what conditions.
    In C#, structures such as `if`-`else` statements allow programs to make decisions,
    executing different paths based on specific conditions. Loop constructs such as
    `for`, `while`, and `foreach` enable the repeated execution of code blocks, iterated
    until a particular condition is met.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构从根本上决定了程序的执行流程，通过确定哪些代码块被执行、执行顺序以及什么条件下执行。在C#中，如`if`-`else`语句这样的结构允许程序做出决策，根据特定条件执行不同的路径。循环结构如`for`、`while`和`foreach`允许代码块的重复执行，直到满足特定条件。
- en: This conditional and repetitive execution framework provided by control structures
    allows programs to perform complex tasks, from processing data collections to
    responding to user interactions, thereby transforming static code into dynamic,
    responsive applications that can tackle real-world problems efficiently.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构提供的这种条件和重复执行框架允许程序执行复杂任务，从处理数据集合到响应用户交互，从而将静态代码转化为动态、响应式的应用程序，能够高效地解决现实世界的问题。
- en: Having established how control structures orchestrate the flow of execution
    within programs, we now narrow our focus to conditional statements, a pivotal
    subset that enables decision-making in C#.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在确立了控制结构如何协调程序内的执行流程之后，我们现在将重点缩小到条件语句，这是一个关键的子集，它使C#中的决策成为可能。
- en: Conditional statements
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句
- en: Diving into the realm of conditional statements, we will explore the `if`-`else`
    and `switch` statements – critical components that enable C# programs to make
    decisions and guide the program down different paths, based on certain conditions.
    This section explains the syntax and practical uses of these structures through
    examples and comparisons, highlighting their roles in enhancing code readability,
    efficiency, and adaptability. We’ll also delve into how an if-then statement evaluates
    conditions to execute code blocks, directing the flow of execution based on specific
    criteria, thereby increasing the functionality and logical structure of code in
    real-world applications.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到条件语句的领域，我们将探讨`if-else`和`switch`语句——这些是使C#程序能够根据特定条件做出决策并引导程序沿着不同路径的关键组件。本节通过示例和比较解释了这些结构的语法和实际用途，强调了它们在提高代码可读性、效率和适应性方面的作用。我们还将深入了解if-then语句如何评估条件以执行代码块，根据特定标准指导执行流程，从而增加实际应用中代码的功能性和逻辑结构。
- en: The following figure shows the score portion of a game screen. The game has
    ended and a message appears, **Player Wins!**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了游戏屏幕的得分部分。游戏已经结束，出现了一条信息，**玩家胜利**！
- en: '![Figure 3.4 – Part of a game screen showing the score of the player and the
    enemy, as well as a game-ending message, Player Wins!](img/B22128_03_4.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 游戏屏幕的一部分，显示了玩家的得分和敌人的得分，以及游戏结束信息，玩家胜利！](img/B22128_03_4.jpg)'
- en: Figure 3.4 – Part of a game screen showing the score of the player and the enemy,
    as well as a game-ending message, Player Wins!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 游戏屏幕的一部分，显示了玩家的得分和敌人的得分，以及游戏结束信息，玩家胜利！
- en: In the C# script that manages the score display, there is an if-then statement
    that gets called when the game ends. In this case, the player won, so **Player
    Wins!** is displayed. If the player lost, **Player Lost!** would be displayed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理得分显示的C#脚本中，当游戏结束时，会调用一个if-then语句。在这种情况下，玩家获胜，因此显示**玩家胜利**！如果玩家输了，将显示**玩家失败**！
- en: The `if-then` statement is a fundamental control structure in programming that
    executes a certain block of code based on the evaluation of a condition. Its basic
    syntax in C# involves the `if` keyword, followed by a condition enclosed in parentheses
    and a code block enclosed in curly braces. If the condition evaluates to `true`,
    the code within the braces is executed; if `false`, the code block is skipped.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-then`语句是编程中的基本控制结构，根据条件的评估执行特定的代码块。其在C#中的基本语法涉及`if`关键字，后跟括号内的条件和一个花括号内的代码块。如果条件评估为`true`，则执行花括号内的代码；如果为`false`，则跳过代码块。'
- en: 'This simple yet powerful structure allows developers to introduce decision-making
    into their programs, enabling actions such as validating user input, making calculations
    based on dynamic data, or controlling the flow of execution based on specific
    criteria, thereby adding a layer of logic and adaptability to applications. The
    following code checks a variable if it is greater than `5`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单而强大的结构允许开发者在程序中引入决策，使动作如验证用户输入、根据动态数据进行计算或根据特定标准控制执行流程成为可能，从而为应用程序添加一层逻辑和适应性。以下代码检查一个变量是否大于`5`：
- en: '[PRE8]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, `Debug.Log` serves to log messages to the Unity Console, a
    common practice in Unity development for debugging. The `number > 5` condition
    is evaluated. Since `number` holds the value `10`, which is indeed greater than
    `5`, the condition is `true`, and the code within the curly braces is executed,
    printing `The number is greater than 5` to the Unity log.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Debug.Log`用于将消息记录到Unity控制台，这是Unity开发中常见的调试实践。评估`number > 5`条件。由于`number`持有值`10`，确实大于`5`，因此条件为`true`，执行花括号内的代码，将`The
    number is greater than 5`打印到Unity日志。
- en: The `if-then` statement is a key tool in C# for conditional execution, enabling
    programs to make decisions and react to different scenarios. This foundational
    concept paves the way to explore looping constructs, where we’ll delve into how
    `for`, `while`, and `foreach` loops facilitate repeated execution of code, allowing
    for efficient data processing and control flow management in more complex programming
    tasks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-then`语句是C#中进行条件执行的关键工具，使程序能够做出决策并对不同场景做出反应。这个基础概念为探索循环结构铺平了道路，我们将深入研究`for`、`while`和`foreach`循环如何促进代码的重复执行，允许在更复杂的编程任务中进行高效的数据处理和控制流管理。'
- en: Looping constructs
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环结构
- en: Venturing into the realm of **looping constructs** in C#, we will explore the
    versatile mechanisms that enable the repetitive execution of code, a fundamental
    aspect of programming that enhances efficiency and capability.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 探索C#中的**循环结构**领域，我们将研究那些使代码能够重复执行的多功能机制，这是编程的一个基本方面，它提高了效率和功能。
- en: This section will cover the `for`, `while`, `do-while`, and `foreach` loops,
    each with its unique syntax and suitable for different iterative scenarios. From
    `for` loops, ideal for situations with a known number of iterations, such as traversing
    arrays, to `while` loops, which cater to conditions with uncertain iteration counts,
    and `do-while` loops, which ensure at least one execution, we’ll dissect their
    applications through practical examples.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖`for`、`while`、`do-while`和`foreach`循环，每个循环都有其独特的语法，适用于不同的迭代场景。从适用于已知迭代次数的情况的`for`循环，如遍历数组，到适用于迭代次数不确定的条件`while`循环，以及确保至少执行一次的`do-while`循环，我们将通过实际示例剖析它们的应用。
- en: Additionally, the `foreach` loop’s elegance in effortlessly iterating over collections
    will be highlighted, demonstrating its role in simplifying code and enhancing
    readability. These looping constructs are indispensable tools in a developer’s
    arsenal, enabling the creation of more dynamic, responsive, and efficient C# programs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`foreach`循环在轻松遍历集合方面的优雅性将被突出显示，展示其在简化代码和增强可读性方面的作用。这些循环结构是开发者工具箱中不可或缺的工具，使创建更动态、响应更快、更高效的C#程序成为可能。
- en: The for loop
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: The `for` statement in C# is used to execute a block of code repeatedly for
    a specified number of times, allowing precise control over the flow through iterations
    based on initial conditions, an end condition, and an increment expression.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'C#中的`for`语句用于重复执行代码块，指定次数，允许根据初始条件、结束条件和增量表达式精确控制迭代流程。 '
- en: 'Venturing deeper into the `for` statement in C#, its syntax serves as a beacon
    for structured, repeatable tasks, particularly when the number of iterations is
    predetermined. The `for` loop is constructed with three essential components –
    the initialization, the condition, and the iteration statement, all enclosed within
    parentheses and separated by semicolons. This structure provides a compact and
    powerful way to manage loop execution. The following is a sample structure of
    a typical `for` loop:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解C#中的`for`语句，其语法为结构化、可重复的任务提供灯塔，尤其是在迭代次数预先确定的情况下。`for`循环由三个基本组件构成——初始化、条件和迭代语句，所有这些都被括号包围，并用分号分隔。这种结构提供了一种紧凑而强大的方式来管理循环执行。以下是一个典型`for`循环的示例结构：
- en: '[PRE9]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s understand the elements of this code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这段代码的元素：
- en: '`initialization`: This is the starting point of the loop, where variables are
    typically declared and initialized. It’s executed only once at the beginning.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`初始化`：这是循环的起点，通常在这里声明和初始化变量。它只在开始时执行一次。'
- en: '`condition`: The loop continues to execute the code block as long as this condition
    evaluates to `true`. It’s checked before each iteration, acting as a gatekeeper
    to further execution.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`条件`：只要这个条件评估为`true`，循环就会继续执行代码块。它在每个迭代之前进行检查，充当进一步执行的守门人。'
- en: '`iteration`: After each loop iteration, this statement is executed. It’s often
    used to update the loop variable, guiding the loop toward its end condition.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`迭代`：在每次循环迭代之后，执行这个语句。它通常用于更新循环变量，引导循环向其结束条件前进。'
- en: Note that each element is separated by `;` (a semicolon).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个元素之间由`;`（分号）分隔。
- en: 'A classic use case for the `for` loop is iterating over arrays. Arrays, by
    their nature, have a fixed size, making the `for` loop an ideal candidate to traverse
    their elements. For example, to sum the elements of an array, you might employ
    a `for` loop where the initialization sets a counter to `0`, the condition checks
    that the counter is less than the array’s length, and the iteration increments
    the counter:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的一个经典用法是遍历数组。由于数组本质上具有固定的大小，因此`for`循环是遍历其元素的理想选择。例如，为了计算数组的元素总和，你可能使用一个`for`循环，其中初始化将计数器设置为`0`，条件检查计数器是否小于数组的长度，迭代增加计数器：'
- en: '[PRE10]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In addition to array traversal, `for` loops are immensely useful in situations
    requiring repetitive actions with a clear start and end point, such as generating
    a series of numbers, processing items in a list, or executing a task a specific
    number of times. This loop’s precise control over the iteration process, from
    start to finish, makes it a versatile tool in a programmer’s toolkit, adaptable
    to a wide range of algorithmic challenges.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数组遍历之外，`for` 循环在需要重复执行且具有明确开始和结束点的场景中非常有用，例如生成一系列数字、处理列表中的项目或执行特定次数的任务。这个循环从开始到结束对迭代过程的精确控制，使其成为程序员工具箱中的一种多用途工具，能够适应广泛的算法挑战。
- en: The while loop
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: Moving on from the structured and count-based iterations offered by `for` loops,
    we enter the more conditionally driven world of `while` loops in the context of
    Unity3D game development. The `while` statement in C# is adept at executing a
    block of code repeatedly as long as a specified condition remains `true`. This
    feature is particularly valuable in game development scenarios where the number
    of iterations is not predetermined and may depend on dynamic in-game events or
    states.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `for` 循环提供的结构化和基于计数的迭代转向，我们在 Unity3D 游戏开发背景下进入了一个更多基于条件的 `while` 循环的世界。C#
    中的 `while` 语句擅长在指定的条件保持 `true` 的情况下重复执行代码块。这个特性在游戏开发场景中特别有价值，其中迭代的次数不是预先确定的，可能取决于动态的游戏事件或状态。
- en: 'The syntax of a `while` loop remains elegantly simple, focusing on the condition
    that controls the loop:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环的语法保持简洁优雅，专注于控制循环的条件：'
- en: '[PRE11]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this structure, the loop’s condition is checked before each execution of
    its body. If `true`, the code within the loop is executed. This process repeats
    until the condition is no longer met, at which point the loop stops, and execution
    proceeds with the code that follows the loop.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，循环的条件在执行其主体之前进行检查。如果条件为 `true`，则执行循环内的代码。这个过程会重复，直到条件不再满足，此时循环停止，执行继续进行循环之后的代码。
- en: This looping mechanism is incredibly useful in game development for tasks such
    as waiting for a player’s action, continuously checking for game state changes,
    or performing actions until a certain game condition is met.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环机制在游戏开发中非常有用，用于诸如等待玩家动作、持续检查游戏状态变化或执行直到满足特定游戏条件等任务。
- en: 'Consider a Unity3D scenario where you need to wait for specific player input
    to trigger an in-game event, utilizing the `while` loop combined with Unity’s
    event-driven architecture. Instead of a direct user prompt, you might use `Debug.Log`
    to output messages for debugging purposes:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个 Unity3D 场景，你需要等待特定的玩家输入来触发游戏事件，利用 `while` 循环结合 Unity 的事件驱动架构。而不是直接的用户提示，你可能使用
    `Debug.Log` 输出调试信息：
- en: '[PRE12]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this adapted coroutine example, `Debug.Log` serves to log messages to the
    Unity Console, a common practice in Unity development for debugging. The loop
    checks for a specific condition (in this case, the `CheckForExitInput()` method
    simulating the check for player input) and continues to iterate until the condition
    is met. The inclusion of `yield return null;` within the loop is a critical Unity-specific
    consideration, ensuring that the loop yields execution to prevent blocking the
    main thread, which is particularly important in the frame-based execution environment
    of Unity3D. This example underscores the `while` loop’s versatility in adapting
    to the dynamic, event-driven nature of game development within Unity.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改后的协程示例中，`Debug.Log` 用于将消息记录到 Unity 控制台，这是 Unity 开发中常见的调试实践。循环检查特定条件（在这种情况下，是模拟检查玩家输入的
    `CheckForExitInput()` 方法）并继续迭代，直到条件满足。在循环中包含 `yield return null;` 是一个关键的 Unity
    特定考虑，确保循环释放执行，防止阻塞主线程，这在 Unity3D 的基于帧的执行环境中尤为重要。这个例子强调了 `while` 循环在适应 Unity 游戏开发中动态、事件驱动特性的多用途性。
- en: The do-while loop
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`do-while` 循环'
- en: Moving on from the condition-first approach of `while` loops, we step into the
    realm of `do-while` loops, which introduce a subtle yet impactful twist to the
    looping construct in C#.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `while` 循环的条件优先方法转向，我们进入 `do-while` 循环的领域，它在 C# 中的循环结构中引入了一种微妙但影响深远的转折。
- en: The defining characteristic of a `do-while` loop is its guarantee of executing
    the loop’s body at least once, making it uniquely suited for scenarios where the
    loop’s code needs to run before any condition checking occurs. This feature is
    particularly useful in situations where an initial execution is required regardless
    of the condition, with subsequent iterations dependent on a dynamic condition
    evaluated after each execution.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while` 循环的显著特征是它至少执行一次循环体的保证，这使得它特别适合于循环代码需要在任何条件检查之前运行的场景。这个特性在需要初始执行而不论条件如何，后续迭代依赖于每次执行后评估的动态条件的情况下特别有用。'
- en: 'The syntax of a `do-while` loop emphasizes its execute-first nature:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while` 循环的语法强调了其先执行后检查的特性：'
- en: '[PRE13]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this structure, the code block within the `do` section executes unconditionally
    on the first pass. Only after this initial execution does the loop evaluate the
    `condition` specified in the `while` part. If the condition is `true`, the loop
    continues with another iteration, re-evaluating the condition after each pass.
    The loop terminates when the condition evaluates to `false`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，`do` 部分内的代码块在第一次遍历时无条件执行。只有在这个初始执行之后，循环才会评估 `while` 部分中指定的 `condition`。如果条件为
    `true`，则循环继续进行另一轮迭代，并在每次遍历后重新评估条件。当条件评估为 `false` 时，循环终止。
- en: 'To illustrate the `do-while` loop in action, let’s consider an example relevant
    to Unity3D game development. Imagine a scenario where a player must be prompted
    at least once to make a choice, with the possibility of repeating the prompt based
    on certain in-game conditions, such as the player not making a valid choice:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `do-while` 循环的实际应用，让我们考虑一个与 Unity3D 游戏开发相关的例子。想象一个场景，玩家至少需要被提示一次做出选择，根据某些游戏条件（如玩家没有做出有效的选择）有重复提示的可能性：
- en: '[PRE14]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the `do-while` loop ensures that the message prompting the
    player to make a choice is displayed at least once by using `Debug.Log`. The loop
    then checks whether a valid choice has been made through `CheckPlayerChoice()`.
    The inclusion of `yield return null;` within the loop is a key Unity-specific
    practice, ensuring that the loop yields execution to maintain the game’s responsiveness.
    This example demonstrates the `do-while` loop’s utility in game development contexts,
    ensuring that an initial action is taken, with subsequent actions contingent on
    dynamic game state conditions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`do-while` 循环通过使用 `Debug.Log` 确保至少显示一次提示玩家做出选择的提示信息。然后循环检查是否通过 `CheckPlayerChoice()`
    做出了有效的选择。循环中包含 `yield return null;` 是 Unity 特定的关键实践，确保循环将执行权交出，以保持游戏响应。这个例子展示了
    `do-while` 循环在游戏开发上下文中的实用性，确保执行初始操作，后续操作取决于动态的游戏状态条件。
- en: The foreach loop
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: foreach 循环
- en: Moving on from the guaranteed initial execution of `do-while` loops, we shift
    our focus to the `foreach` loop, a construct designed with collections in mind.
    The `foreach` loop stands out for its simplicity and readability, especially when
    it comes to iterating over elements in collections such as arrays, lists, or any
    enumerable set. This loop abstracts away the complexity of indexing and bounds
    checking, allowing for a more intuitive and error-resistant approach to collection
    traversal.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `do-while` 循环的保证初始执行来看，我们将注意力转向 `foreach` 循环，这是一个专为集合设计的结构。`foreach` 循环因其简单性和可读性而突出，尤其是在迭代数组、列表或任何可枚举集合中的元素时。这个循环抽象掉了索引和边界检查的复杂性，允许采用更直观且更不易出错的集合遍历方法。
- en: 'The `foreach` loop follows a straightforward syntax that emphasizes the element
    being processed rather than the loop mechanics:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 循环遵循一种简单的语法，强调正在处理的元素而不是循环机制：'
- en: '[PRE15]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this construct, `item` represents the current element from `collection` being
    iterated over, with `var` being a placeholder for the actual type of elements
    in the collection. The loop automatically moves through each element in the collection,
    executing the code block for every item until it reaches the end.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，`item` 代表正在迭代的 `collection` 中的当前元素，而 `var` 是集合中实际元素类型的占位符。循环会自动遍历集合中的每个元素，为每个元素执行代码块，直到到达集合的末尾。
- en: 'To illustrate the elegance of the `foreach` loop in a Unity3D context, consider
    a scenario where you have a collection of game objects that need to be individually
    processed, such as resetting their positions or updating their states:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `foreach` 循环在 Unity3D 上下文中的优雅性，考虑一个场景，其中你有一个需要逐个处理的游戏对象集合，例如重置它们的坐标或更新它们的状态：
- en: '[PRE16]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, the `foreach` loop iterates over each `GameObject` in the `gameObjects`
    list, logging its name and resetting its position. The simplicity of the `foreach`
    loop makes the code easy to read and understand, clearly expressing the intention
    of iterating over all objects and performing actions on them without the boilerplate
    of traditional loop constructs. This example showcases how `foreach` loops can
    enhance code clarity and maintainability in game development scenarios, particularly
    when dealing with collections of objects.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`foreach`循环遍历`gameObjects`列表中的每个`GameObject`，记录其名称并重置其位置。`foreach`循环的简洁性使得代码易于阅读和理解，清楚地表达了迭代所有对象并对其执行操作而不需要传统循环结构的样板代码。这个例子展示了`foreach`循环如何在游戏开发场景中增强代码的清晰性和可维护性，尤其是在处理对象集合时。
- en: C# offers versatile looping constructs for various programming needs – the `for`
    loop is ideal for fixed iterations, demonstrated by array traversal; the `while`
    loop suits indefinite iterations, as shown when awaiting user input; the `do-while`
    loop guarantees at least one execution, useful for initial actions such as player
    prompts; and the `foreach` loop simplifies collection iteration, improving code
    readability, such as in-game object processing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了多种灵活的循环结构，以满足不同的编程需求——`for`循环适用于固定迭代次数，如数组遍历所示；`while`循环适用于不确定迭代次数，如等待用户输入时所示；`do-while`循环保证至少执行一次，适用于初始动作，如玩家提示；而`foreach`循环简化了集合迭代，提高了代码的可读性，如在游戏对象处理中。
- en: We’ll now move on to control flow, looking at how C# jump statements such as
    `break`, `continue`, and `return` provide nuanced execution management within
    loops and functions, enhancing the programming toolkit for developers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向控制流，探讨C#中的跳转语句，如`break`、`continue`和`return`，如何在循环和函数中提供细微的执行管理，增强开发者的编程工具箱。
- en: Jump statements
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳转语句
- en: Diving into the control flow mechanisms of C#, we will explore `break` statement,
    which halts loop or switch case execution; the `continue` statement for skipping
    to the next loop iteration; and the `return` statement, which exits methods or
    loops early. Additionally, while less favored, the `goto` statement will be explored
    for its ability to jump to labeled positions in code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨C#的控制流机制，我们将研究`break`语句，它用于停止循环或switch case的执行；`continue`语句用于跳转到下一个循环迭代；以及`return`语句，它用于提前退出方法或循环。此外，虽然不太受欢迎，但`goto`语句也将被探讨，因为它能够跳转到代码中的标记位置。
- en: Each of these statements serves a unique purpose in managing the flow of execution,
    enhancing the flexibility and decision-making capabilities of C# programs. Through
    examples, we’ll see how these tools are applied in practice, from terminating
    loops to selectively bypassing iterations or returning values.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句在管理执行流程中各司其职，增强了C#程序的灵活性和决策能力。通过示例，我们将看到这些工具在实际应用中的运用，从终止循环到选择性地跳过迭代或返回值。
- en: The break statement
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`break`语句'
- en: The `break` statement in C# is a powerful control flow mechanism used to immediately
    terminate the execution of enclosing loops or switch cases. Within loops, such
    as `for`, `while`, or `do-while`, `break` can be used to exit a loop prematurely
    when a certain condition is met, bypassing the loop’s normal termination condition.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`break`语句是一种强大的控制流机制，用于立即终止包围的循环或switch case的执行。在`for`、`while`或`do-while`等循环中，当满足特定条件时，`break`可以用来提前退出循环，跳过循环的正常终止条件。
- en: This is particularly useful in scenarios where continuing the iteration is unnecessary
    or undesirable, such as when a search has found a match. In switch cases, the
    `break` statement concludes a case block, preventing the program from continuing
    to execute the next case.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这在迭代继续执行是不必要或不受欢迎的情况下特别有用，例如在搜索找到匹配项时。在switch case中，`break`语句结束一个case块，防止程序继续执行下一个case。
- en: 'To illustrate the use of the `break` statement within a loop, consider a scenario
    in a game where you need to find and process a specific item from a collection
    of items. Once the item is found and processed, continuing the loop is redundant.
    Here, the `break` statement efficiently halts the loop, saving processing time
    and resources:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`break`语句在循环中的使用，考虑一个游戏场景，你需要从物品集合中找到并处理一个特定的物品。一旦找到并处理了物品，继续循环就是多余的。在这里，`break`语句有效地停止了循环，节省了处理时间和资源：
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, the `foreach` loop iterates over a list of game items. When
    the target item is found, it’s processed, and the `break` statement immediately
    terminates the loop. This prevents unnecessary iterations over the remaining items,
    demonstrating the `break` statement’s utility in enhancing efficiency and control
    within loops.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`foreach`循环遍历游戏物品列表。当找到目标物品时，对其进行处理，并立即使用`break`语句终止循环。这防止了对剩余物品的不必要迭代，展示了`break`语句在增强循环效率和控制的效用。
- en: The continue statement
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`continue`语句'
- en: Moving on from the abrupt termination offered by the `break` statement, we encounter
    the `continue` statement, which serves a more nuanced purpose in loop control.
    Unlike `break`, which exits a loop entirely, `continue` merely skips the remaining
    portion of the current iteration and proceeds to the next iteration of the loop.
    This statement is particularly useful in scenarios where certain conditions within
    a loop’s body render the remaining code unnecessary or irrelevant for that iteration,
    allowing the loop to efficiently move on to the next cycle.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从`break`语句提供的突然终止中跳出来，我们遇到了`continue`语句，它在循环控制中起着更微妙的作用。与完全退出循环的`break`不同，`continue`仅跳过当前迭代的剩余部分，并继续到循环的下一个迭代。这个语句在循环体内的某些条件使得剩余代码对于该迭代不必要或不相关的情况下特别有用，允许循环有效地进入下一个周期。
- en: The `continue` statement shines in situations where only specific iterations
    require the execution of certain code, while others should be bypassed. For instance,
    in a loop processing a collection of data, there might be cases where specific
    conditions, such as invalid or irrelevant data points, warrant skipping to the
    next iteration without executing the remaining code in the loop body.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句在仅需要执行特定迭代的某些代码，而其他迭代应跳过的情况下特别出色。例如，在处理数据集合的循环中，可能会有特定条件，如无效或不相关的数据点，需要跳到下一个迭代，而无需执行循环体内的剩余代码。'
- en: 'Consider a gaming scenario where various entities in a game need to be updated,
    but some entities are in a state that makes them ineligible for certain updates.
    Using the `continue` statement, the loop can skip these entities without breaking
    out of the loop entirely:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个游戏场景，其中游戏中的各种实体需要更新，但某些实体处于一种使其无法进行某些更新的状态。使用`continue`语句，循环可以跳过这些实体，而无需完全跳出循环：
- en: '[PRE18]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the loop iterates over a list of game entities, checking each
    entity’s eligibility for an update. The `continue` statement is used to skip over
    any entities that aren’t eligible, allowing the loop to move directly to the next
    entity without executing the update code. This approach keeps the loop running
    for all entities while efficiently handling only those that meet the specified
    criteria, demonstrating the `continue` statement’s use in enhancing loop functionality.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，循环遍历游戏实体列表，检查每个实体的更新资格。使用`continue`语句跳过任何不符合资格的实体，使循环能够直接移动到下一个实体，而无需执行更新代码。这种方法使循环对所有实体保持运行，同时高效地处理满足特定标准的那些实体，展示了`continue`语句在增强循环功能方面的应用。
- en: The return statement
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`return`语句'
- en: Building on the theme of controlling execution flow within loops, as seen with
    the `continue` statement, we move on to the `return` statement, which introduces
    a broader scope of control. Unlike `continue`, which affects only the current
    loop iteration, `return` has the power to exit not just the loop but also the
    entire method in which it’s placed. This capability makes `return` particularly
    potent for early exits from methods, based on specific conditions, and it can
    also be used within loops nested inside methods to terminate a method’s execution
    prematurely.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 基于在循环中控制执行流程的主题，正如通过`continue`语句所看到的，我们继续探讨`return`语句，它引入了更广泛的作用域。与仅影响当前循环迭代的`continue`不同，`return`具有退出不仅循环而且放置它的整个方法的能力。这种能力使得`return`对于基于特定条件的早期退出方法特别有效，它也可以在方法内部嵌套的循环中使用，以提前终止方法的执行。
- en: The `return` statement is versatile, allowing it to be used to end a method’s
    execution and, optionally, return a value if the method is designed to produce
    an output. This is useful in scenarios where a certain result or condition within
    a loop (or the method at large) indicates that no further processing is necessary,
    allowing the program to exit the method and potentially return a value to the
    caller.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句非常灵活，允许它用来结束方法的执行，并且如果方法设计为产生输出，还可以选择性地返回一个值。这在某些情况下很有用，例如，当循环（或方法整体）中的某个结果或条件表明不需要进一步处理时，允许程序退出方法，并可能向调用者返回一个值。'
- en: 'For instance, consider a method tasked with searching for a specific value
    within a collection. Once the value is found, there’s no need to continue the
    search, and the method can return immediately, possibly indicating the success
    of the search or the value found:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个负责在集合中搜索特定值的方法。一旦找到值，就没有必要继续搜索，方法可以立即返回，可能表示搜索成功或找到的值：
- en: '[PRE19]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the `FindValue` method iterates over a list of integers searching
    for a target value. Upon finding the target, the method immediately returns `true`,
    signaling success. If the loop completes without finding the target, the method
    returns `false`, indicating failure. The `return` statement’s ability to exit
    the method at any point, especially from within a loop, highlights its significance
    in controlling execution flow and providing efficient and readable code solutions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`FindValue` 方法遍历一个整数列表以搜索目标值。一旦找到目标，该方法立即返回 `true`，表示成功。如果循环结束而没有找到目标，则方法返回
    `false`，表示失败。`return` 语句能够在任何点退出方法，尤其是在循环内部，这突出了它在控制执行流程和提供高效且可读的代码解决方案中的重要性。
- en: The goto statement
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`goto`语句'
- en: Shifting from the structured flow control provided by the `return` statement,
    we approach the `goto` statement, a more debated feature of C#. While `return`
    offers a clean and structured way to exit loops and methods, `goto` introduces
    a level of flexibility that can lead to complex and less maintainable code if
    not used judiciously. The `goto` statement enables an unconditional jump to a
    labeled position within code, which can disrupt the natural flow of execution
    and make the logic harder to follow.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从`return`语句提供的结构化流程控制转向`goto`语句，这是C#中更具争议性的特性之一。虽然`return`提供了干净且结构化的方式来退出循环和方法，但`goto`引入了一种灵活性，如果不谨慎使用，可能会导致复杂且难以维护的代码。`goto`语句允许在代码中无条件地跳转到标记位置，这可能会破坏执行的自然流程，使逻辑更难跟随。
- en: Despite its potential for direct and straightforward jumps within a method,
    the usage of `goto` is often used with caution in modern programming practices.
    The primary concern is that it can lead to *spaghetti code*, characterized by
    tangled control structures that are difficult to understand and maintain. This
    is especially true in complex methods where multiple `goto` statements can obscure
    the execution path, making the code less readable and more prone to errors.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`goto`在方法内部进行直接和简单的跳转具有潜在的优势，但在现代编程实践中，其使用通常非常谨慎。主要担忧是它可能导致*意大利面代码*，这种代码的特点是错综复杂的控制结构，难以理解和维护。这在复杂的方法中尤其如此，多个`goto`语句可能会掩盖执行路径，使代码的可读性降低，更容易出错。
- en: For completeness, it’s important to acknowledge that `goto` can be useful in
    certain narrow scenarios, such as breaking out of nested loops or when dealing
    with complex state machines where the use of other constructs might not be as
    efficient or clear.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，重要的是要承认在某些特定场景中，`goto` 可以是有用的，例如跳出嵌套循环或处理复杂的状态机时，使用其他构造可能不够高效或清晰。
- en: However, these cases are the exception rather than the rule, and alternatives
    such as loop control statements (`break` and `continue`), exception handling,
    or refactoring into smaller, more manageable methods are generally recommended
    to maintain code clarity and integrity.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些情况是例外而不是规则，通常建议使用循环控制语句（`break`和`continue`）、异常处理或重构为更小、更易于管理的函数来维护代码的清晰性和完整性。
- en: 'For example, instead of using `goto` to exit nested loops, a `break` statement
    with a flag variable or returning a value from a method (when applicable) can
    often achieve the same result, with greater readability:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，与其使用 `goto` 来退出嵌套循环，不如使用带有标志变量的 `break` 语句或从方法中返回一个值（如果适用），这通常可以达到相同的结果，并且具有更高的可读性：
- en: '[PRE20]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this revised approach, a flag variable, `found`, controls the exit from the
    nested loops without the need for `goto`, preserving the structured and understandable
    flow of the code. This example underscores the recommendation to seek alternatives
    to `goto`, enhancing code readability and maintainability.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种改进的方法中，一个标志变量 `found` 控制从嵌套循环中退出，无需使用 `goto`，从而保留了代码的结构化和可理解性流程。这个例子强调了寻求
    `goto` 的替代方案的建议，增强了代码的可读性和可维护性。
- en: In C#, control flow statements such as `break`, `continue`, `return`, and `goto`
    provide nuanced ways to manage execution paths. The `break` statement is used
    to exit loops or switch cases prematurely, enhancing efficiency in certain scenarios,
    such as terminating a search upon success.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，控制流语句如 `break`、`continue`、`return` 和 `goto` 提供了管理执行路径的细微方式。`break` 语句用于提前退出循环或
    `switch` 情况，在某些场景中提高了效率，例如在成功后终止搜索。
- en: The `continue` statement skips the remainder of a loop’s current iteration,
    moving directly to the next, allowing for selective processing based on specific
    conditions. The `return` statement offers a way to exit methods early, potentially
    with a value, streamlining functions by ending execution when further processing
    is unnecessary.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句跳过循环当前迭代的剩余部分，直接进入下一迭代，允许根据特定条件进行选择性处理。`return` 语句提供了一种提前退出方法的方式，可能带有值，通过在进一步处理不再必要时结束执行来简化函数。'
- en: Ultimately, the `goto` statement, while capable of unconditional jumps to labeled
    positions, should be approached with caution due to its potential to complicate
    code structure, and you should opt for more structured alternatives to maintain
    code clarity and maintainability.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`goto` 语句虽然能够无条件跳转到标记位置，但由于其可能使代码结构复杂化，因此应谨慎使用，并且应该选择更结构化的替代方案以保持代码的清晰性和可维护性。
- en: Best practices
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: As we move on from the nuanced details of jump statements to a broader perspective
    of control structures in C#, it’s essential to recognize their pivotal role in
    crafting dynamic and interactive applications. Control structures, from conditional
    statements to loops and jump commands, form the backbone of program flow management,
    enabling developers to dictate the execution paths and decision-making processes
    within their code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从跳转语句的细微细节转向对 C# 中控制结构的更广泛视角时，认识到它们在构建动态和交互式应用程序中的关键作用是至关重要的。从条件语句到循环和跳转命令的控制结构构成了程序流程管理的骨架，使开发者能够指定其代码中的执行路径和决策过程。
- en: This section will encapsulate the importance of selecting the right control
    structure for varying programming scenarios, ensuring that each choice aligns
    with the specific needs and logic of an application. Emphasizing best practices,
    we’ll delve into strategies to maintain clean and understandable code, such as
    minimizing deep nesting of structures and favoring `switch` statements over multiple
    `if-else` constructs for enhanced clarity and readability. These guidelines aim
    to equip developers with the insights needed to utilize control structures effectively,
    fostering the development of efficient, maintainable, and robust C# applications.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将封装选择正确控制结构对于不同编程场景的重要性，确保每个选择都与应用程序的具体需求和逻辑相一致。强调最佳实践，我们将深入研究保持代码清洁和可理解的战略，例如最小化结构的深层嵌套，并优先考虑
    `switch` 语句而不是多个 `if-else` 结构以提高清晰度和可读性。这些指南旨在为开发者提供利用控制结构有效所需的见解，促进高效、可维护和健壮的
    C# 应用程序的开发。
- en: 'Choosing the appropriate control structure for a given programming need in
    C# is a critical decision that directly impacts the clarity, efficiency, and maintainability
    of code. The nature of the task at hand should guide this choice:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中为特定的编程需求选择合适的控制结构是一个关键决策，它直接影响代码的清晰度、效率和可维护性。手头任务的本质应指导这一选择：
- en: For tasks with a known number of iterations, such as processing every element
    in an array or a list, a `for` or `foreach` loop is typically the most straightforward
    and readable option.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有已知迭代次数的任务，例如处理数组或列表中的每个元素，`for` 或 `foreach` 循环通常是最直接和可读的选项。
- en: When dealing with operations that should repeat until a certain condition changes,
    without a predetermined number of iterations, `while` or `do-while` loops offer
    the necessary flexibility, with `do-while` ensuring at least one execution regardless
    of the condition.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理需要重复执行直到某个条件改变的操作，而没有预定的迭代次数时，`while` 或 `do-while` 循环提供了必要的灵活性，其中 `do-while`
    确保至少执行一次，无论条件如何。
- en: Control structures in C# such as conditional statements (`if-else` and `switch`),
    looping constructs (`for`, `while`, `do-while`, and `foreach`), and jump statements
    (`break`, `continue`, and `return`) are vital for directing program flow and enabling
    dynamic applications. For multiple conditions, switch statements improve readability
    and organization over nested `if`-`else` structures. Best practices include avoiding
    deep nesting, simplifying complex functions into smaller methods, and using early
    exits to maintain clear and maintainable code. Effective use of these structures
    ensures efficient and dynamic C# code.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 中的控制结构，如条件语句（`if-else` 和 `switch`）、循环结构（`for`、`while`、`do-while` 和 `foreach`）以及跳转语句（`break`、`continue`
    和 `return`），对于指导程序流程和实现动态应用至关重要。对于多个条件，`switch` 语句比嵌套的 `if-else` 结构提高了可读性和组织性。最佳实践包括避免深层嵌套、将复杂函数简化为更小的方法，以及使用早期退出以保持代码的清晰和可维护性。有效使用这些结构确保了高效的动态
    C# 代码。
- en: In more complex scenarios, where the flow needs to be altered dramatically,
    such as exiting loops or methods early based on specific conditions, jump statements
    such as `break`, `continue`, and `return` come into play, each serving a distinct
    purpose.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更复杂的场景中，当需要根据特定条件大幅度改变流程，例如提前退出循环或方法时，跳转语句如`break`、`continue`和`return`就派上用场，每个都有其独特的用途。
- en: Understanding the nuances and intended use cases of each control structure allows
    developers to make informed decisions, leading to cleaner, more efficient code
    that aligns with best practices in software development.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 理解每个控制结构的细微差别和预期用途，使开发者能够做出明智的决定，从而编写出更清晰、更高效的代码，符合软件开发的最佳实践。
- en: Writing basic functions
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基本函数
- en: In our journey of mastering C# programming within Unity3D, this section unfolds
    the essence and mechanics of functions, pivotal for crafting structured and robust
    code. Functions stand at the core of programming, enabling code reuse, enhancing
    organization, and ensuring the maintainability of projects.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握 Unity3D 中 C# 编程的旅途中，本节揭示了函数的本质和机制，这对于构建结构化和健壮的代码至关重要。函数是编程的核心，它使代码重用、增强组织性并确保项目的可维护性。
- en: Starting with an introduction to the anatomy of functions – spanning return
    types, names, parameters, and scope – we’ll go through practical examples, shedding
    light on their applications. We will then discuss Unity-specific practices, illustrating
    how custom functions integrate within the engine’s life cycle, and progress to
    advanced topics such as recursion, lambda expressions, and the nuanced use of
    delegates and events.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数的解剖结构介绍开始——包括返回类型、名称、参数和作用域——我们将通过实际例子来探讨它们的应用。然后，我们将讨论 Unity 特定的实践，说明自定义函数如何在引擎的生命周期中集成，并进一步探讨递归、lambda
    表达式以及委托和事件的微妙使用。
- en: Complemented by best practices and debugging tips, this exploration aims to
    equip you with the knowledge to harness functions effectively, fostering the development
    of dynamic and interactive Unity3D applications.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 结合最佳实践和调试技巧，本探索旨在为您提供有效利用函数的知识，促进动态和交互式 Unity3D 应用程序的开发。
- en: An introduction to functions in C#
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 函数简介
- en: In the landscape of C# programming, functions emerge as fundamental building
    blocks, enabling developers to encapsulate reusable pieces of code that perform
    specific tasks. A **function** in programming is essentially a defined sequence
    of statements that work together to execute a particular operation. By wrapping
    these operations in functions, programmers can call upon these predefined tasks
    from various points in their code, fostering a modular and organized approach
    to software development.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 编程的领域中，函数作为基本构建块出现，使开发者能够封装可重用的代码片段，以执行特定任务。编程中的**函数**本质上是一系列定义好的语句，它们协同工作以执行特定的操作。通过将这些操作封装在函数中，程序员可以从代码的各个点调用这些预定义的任务，从而促进软件开发模块化和组织化。
- en: The importance of functions transcends mere code execution; they are instrumental
    in organizing code into logical, manageable segments. This organization is core
    for both individual developers and teams working on larger projects, as it enhances
    readability and maintainability. Functions allow for the isolation of specific
    functionalities, making it easier to debug and test discrete parts of the code
    base.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的重要性超越了仅仅的代码执行；它们在将代码组织成逻辑上可管理段方面起着关键作用。这种组织对于个人开发者和在大型项目上工作的团队来说都是核心的，因为它提高了可读性和可维护性。函数允许隔离特定的功能，使得调试和测试代码库的离散部分变得更加容易。
- en: Moreover, the **principle of reusability** that functions offer cannot be overstated.
    By defining a function once, it can be reused across different parts of a project,
    or even in entirely different projects, without the need to rewrite code. This
    not only saves time and effort but also reduces the likelihood of errors, as well-tested
    functions become reliable building blocks for new applications.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，函数提供的**重用原则**不容小觑。通过一次定义函数，它可以在项目的不同部分或完全不同的项目中重用，而无需重写代码。这不仅节省了时间和精力，还减少了错误的可能性，因为经过充分测试的函数成为构建新应用的可靠构建块。
- en: In essence, functions serve as the backbone of structured programming in C#,
    enabling developers to create more dynamic, efficient, and maintainable code.
    Their role in promoting code reusability, enhancing organization, and facilitating
    project maintenance is invaluable in the fast-paced and ever-evolving world of
    software development.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，函数是C#结构化编程的骨架，使开发者能够创建更动态、高效和可维护的代码。它们在促进代码重用、增强组织和促进项目维护方面的作用在软件开发快速发展和不断变化的世界中是无价的。
- en: The basic structure of a function
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数的基本结构
- en: Building upon the foundational understanding of functions in C#, we now transition
    to dissecting their basic structure, a key aspect that underpins their functionality
    and utility in programming. This section delves into the anatomy of a C# function,
    exploring the syntax elements that constitute a function, including return types,
    function names, parameters, and the function body. Each component plays a pivotal
    role in defining what the function does, how it does it, and what it returns after
    execution.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在对C#中函数的基础理解之上，我们现在转向剖析其基本结构，这是支撑其功能性和编程中实用性的关键方面。本节深入探讨C#函数的解剖结构，探讨构成函数的语法元素，包括返回类型、函数名、参数和函数体。每个组件都在定义函数做什么、如何做以及执行后返回什么方面发挥着关键作用。
- en: Additionally, we’ll unravel the concept of scope within a function, a critical
    factor that determines the visibility and lifetime of variables and the function
    itself, further influencing how functions interact with the rest of the program.
    Understanding these structural elements is key to mastering how to create and
    use functions in C#, paving the way for more advanced programming techniques and
    concepts.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将解开函数内的作用域概念，这是一个决定变量及其自身可见性和生命周期的关键因素，进一步影响函数如何与程序的其他部分交互。理解这些结构元素是掌握如何在C#中创建和使用函数的关键，为更高级的编程技术和概念铺平道路。
- en: 'In C#, the syntax of a function encompasses four main components:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，函数的语法包括四个主要组成部分：
- en: '`return type` indicates the data type of the value the function will return,
    or `void` if no value is returned.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`返回类型`表示函数将返回的数据类型，或者如果没有返回值，则为`void`。'
- en: '**Function name**: The function name identifies the function and follows naming
    conventions for easy identification.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数名**：函数名标识函数，并遵循命名约定以便于识别。'
- en: '**Parameters**: Parameters, listed within parentheses, allow the function to
    accept inputs, making it adaptable to various data.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：参数列在括号内，允许函数接受输入，使其能够适应各种数据。'
- en: '**Function body**: The function body, enclosed in curly braces, contains the
    executable code that defines the function’s operations.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数体**：函数体被大括号包围，包含定义函数操作的可执行代码。'
- en: Together, these elements form the blueprint of a function, setting the stage
    for more detailed discussions on their roles and best practices in subsequent
    sections.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素共同构成了函数的蓝图，为后续章节中更详细地讨论它们的作用和最佳实践奠定了基础。
- en: The concept of **scope** within a function pertains to the visibility and lifetime
    of variables and the function itself within a program. In C#, variables defined
    inside a function, including its parameters, are local to that function. This
    means they are only accessible and modifiable within the confines of the function
    body, effectively isolating the function’s internal state from the rest of the
    program.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内的**作用域**概念涉及到变量和函数本身在程序中的可见性和生命周期。在C#中，定义在函数内部的变量，包括其参数，都是局部于该函数的。这意味着它们只能在函数体内部访问和修改，有效地将函数的内部状态与程序的其他部分隔离开来。
- en: This encapsulation ensures that a function’s operations do not inadvertently
    affect other parts of the code, promoting cleaner, more modular programming practices.
    Understanding scope is indispensable for managing data within functions, preventing
    naming conflicts, and safeguarding the integrity of the function’s execution.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这种封装确保了函数的操作不会无意中影响代码的其他部分，促进了更干净、更模块化的编程实践。理解作用域对于在函数内管理数据、防止命名冲突和确保函数执行完整性是必不可少的。
- en: Having outlined the fundamental structure of a function in C#, including its
    return type, name, parameters, and body, we will now move on to apply these concepts
    with a simple function example. This practical illustration will demonstrate how
    the theoretical components come together in a cohesive unit, providing a clearer
    understanding of how functions are constructed and executed in a real-world programming
    scenario.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在概述了C#函数的基本结构之后，包括其返回类型、名称、参数和主体，我们现在将使用一个简单的函数示例来应用这些概念。这个实际示例将展示理论组件如何作为一个统一的整体结合在一起，从而更清楚地理解函数如何在现实世界的编程场景中被构建和执行。
- en: A simple function example
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的函数示例
- en: To understand the practical application of functions in C# within game development,
    let’s consider a simple example – a function that calculates the player’s score
    by adding points collected during gameplay. This example illustrates how the return
    type, function name, parameters, and function body work together to perform a
    specific task. By exploring this fundamental operation, we can appreciate the
    power and utility of functions in creating dynamic game features, setting a foundation
    for more complex game mechanics.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解C#在游戏开发中函数的实际应用，让我们考虑一个简单的例子——一个通过在游戏过程中收集到的分数来计算玩家得分的函数。这个例子说明了返回类型、函数名、参数和函数体如何共同工作以执行特定任务。通过探索这个基本操作，我们可以欣赏到函数在创建动态游戏功能、为更复杂的游戏机制奠定基础方面的强大功能和实用性。
- en: 'A quintessential example to illustrate the use of functions in C# is a function
    that adds two numbers together. This function embodies the basic structure and
    syntax of C# functions, demonstrating how inputs are taken through parameters,
    processed, and then outputted as a return value. Consider the following simple
    function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子来说明C#中函数的使用是一个将两个数字相加的函数。这个函数体现了C#函数的基本结构和语法，展示了如何通过参数接收输入，进行处理，然后将结果作为返回值输出。考虑以下简单的函数：
- en: '[PRE21]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, `bool` before `WonWinsBattle` specifies that the function will
    return a Boolean value. `WonWinsBattle` is the function’s name, and it clearly
    describes the function’s purpose. The `int player` and `int enemy` parameters
    are the two numbers that will be compared. Inside the function body, the comparison
    of `player` and `enemy` is determined. If `player` is greater, `true` is returned;
    otherwise, `false` is returned. This simple function encapsulates the essence
    of C# functions, showcasing their ability to perform tasks and return results
    in a clean, modular fashion.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`bool`在`WonWinsBattle`之前指定该函数将返回一个布尔值。`WonWinsBattle`是函数的名称，它清楚地描述了函数的目的。`int
    player`和`int enemy`参数是要比较的两个数字。在函数体内，`player`和`enemy`的比较被确定。如果`player`更大，则返回`true`；否则，返回`false`。这个简单的函数封装了C#函数的精髓，展示了它们以干净、模块化的方式执行任务并返回结果的能力。
- en: Building on the foundational example of a simple addition function, we will
    now delve deeper into the intricacies of function parameters and return types,
    starting with a closer examination of parameters. This exploration will enhance
    our understanding of how functions receive and utilize input values, further illustrating
    the flexibility and power of C# functions in accommodating a wide range of data
    and scenarios.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单加法函数的基础示例之上，我们将现在深入探讨函数参数和返回类型的复杂性，首先从对参数的更仔细检查开始。这次探索将增强我们对函数如何接收和使用输入值的理解，进一步展示了C#函数在适应广泛的数据和场景方面的灵活性和强大功能。
- en: Function parameters and return types – parameters in detail
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数和返回类型 - 参数的详细说明
- en: In the realm of C# functions, parameters play a vital role by defining the inputs
    that a function can accept, thereby enabling customization and flexibility in
    the function’s operation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#函数的领域内，参数通过定义函数可以接受的输入起着至关重要的作用，从而使得函数的操作具有定制性和灵活性。
- en: This section will delve into the nuances of parameters in detail, exploring
    how they are defined, the process of passing arguments to a function, and the
    implications of doing so. We’ll also explore the different types of parameters
    – value, reference, and output – each serving a unique purpose in function interactions,
    and how they influence the behavior of functions in handling data. This comprehensive
    overview will equip you with a deeper understanding of function parameters and
    their pivotal role in C# programming.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将详细探讨参数的细微差别，探索它们的定义方式、向函数传递参数的过程以及这样做的影响。我们还将探讨不同类型的参数 - 值、引用和输出 - 每种类型在函数交互中都有独特的作用，以及它们如何影响函数处理数据的行为。这个全面的概述将使你对函数参数及其在C#编程中的关键作用有更深入的理解。
- en: '**Parameters** are the bridge between a function and the outside world, allowing
    functions to receive data from external sources and operate on it. When defining
    a function in C#, parameters are specified within the parentheses following the
    function name, with each parameter defined by a type and a name. This setup not
    only informs the function about the kind and number of inputs it should expect
    but also dictates the form of data that the calling code needs to supply.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**是函数与外部世界之间的桥梁，允许函数从外部来源接收数据并对其进行操作。在C#中定义函数时，参数在函数名后面的括号内指定，每个参数由一个类型和一个名称定义。这种设置不仅让函数了解它应该期望的种类和数量的输入，而且还规定了调用代码需要提供的数据形式。'
- en: 'For example, in a function designed to determine whether a player is grounded
    – that is, the player’s shoe soles equal to the floor – the syntax for such a
    function definition would be as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个旨在确定玩家是否接触地面的函数（即玩家的鞋底与地面相等）中，此类函数定义的语法如下：
- en: '[PRE22]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Passing arguments to a function is the act of supplying the actual values for
    these parameters when the function is called. The arguments must match the parameters
    in both type and order, ensuring that the data the function operates on is compatible
    with its definition. For instance, calling the `IsGrounded` function with two
    floats, such as `IsGrounded(10, 20)`, passes `10` and `20` as arguments to the
    `floorElevation` and `playerElevation` parameters, respectively.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 向函数传递参数是在函数被调用时提供这些参数的实际值的行为。参数必须在类型和顺序上与参数匹配，以确保函数操作的数据与其定义兼容。例如，使用两个浮点数调用`IsGrounded`函数，如`IsGrounded(10,
    20)`，将`10`和`20`作为参数分别传递给`floorElevation`和`playerElevation`参数。
- en: Note that `IsGrounded` is an important script for games, such as determining
    whether a player can jump. If they are not on the floor, they are either jumping
    or falling. Additionally, a player’s elevation is measured from the base of their
    shoes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IsGrounded`是游戏中的一个重要脚本，例如用于确定玩家是否可以跳跃。如果玩家不在地面上，他们要么在跳跃，要么在坠落。此外，玩家的海拔高度是从鞋底测量的。
- en: The relationship between parameters and arguments is foundational to the versatility
    and reusability of functions in C#. By abstracting away specific values and focusing
    on the types of data, functions can be written in a general, reusable form, capable
    of operating on a variety of inputs. This mechanism underscores the importance
    of carefully defining and using parameters to enhance a function’s utility and
    integration within larger software systems.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 参数与参数之间的关系是C#中函数灵活性和可重用性的基础。通过抽象特定的值并关注数据类型，可以编写通用且可重用的函数形式，能够处理各种输入。这种机制强调了仔细定义和使用参数以增强函数的实用性和在更大软件系统中的集成的重要性。
- en: In C#, parameters can be categorized into three main types based on how they
    pass data to functions – value, reference, and output parameters. Each type has
    its unique behavior and use case, influencing how data is transferred and manipulated
    within functions.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，根据它们如何将数据传递给函数，参数可以分为三种主要类型：值、引用和输出参数。每种类型都有其独特的行为和用例，影响数据在函数内部如何传输和处理。
- en: Value parameters
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值参数
- en: 'In C#, parameters are typically treated as value parameters by default. This
    means that when you call a function, the actual values of the arguments are passed
    to the function, and the function operates on a copy of that data. Any changes
    made to the parameters within the function do not affect the original values outside
    the function. This behavior is useful when you want the function to work with
    the input data without modifying the original variables – for example, in a function
    that updates a message about how many stars a player has left:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，参数默认情况下通常被视为值参数。这意味着当你调用一个函数时，实际参数的值会被传递给函数，函数在数据的副本上操作。在函数内部对参数所做的任何更改都不会影响函数外部的原始值。这种行为在你想让函数使用输入数据而不修改原始变量时很有用——例如，在一个更新玩家剩余星星数量的消息的函数中：
- en: '[PRE23]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The number of stars for a player is passed to the method, `UpdateStarMessage`.
    The string variable, `starMessage`, is changed to reflect the current number of
    stars.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的星星数量被传递到`UpdateStarMessage`方法中。字符串变量`starMessage`被更改以反映当前的星星数量。
- en: Reference parameters
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用参数
- en: 'When a parameter is defined as a reference parameter using the `ref` keyword,
    it means the function receives a reference to the original data. Any changes made
    to the parameter within the function are reflected in the original data outside
    the function. **Reference parameters** are useful when a function needs to modify
    the input data or when passing large data structures that would be inefficient
    to copy, such as large arrays or objects:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个参数被定义为使用`ref`关键字引用参数时，这意味着函数接收原始数据的引用。在函数内部对参数所做的任何更改都会反映在函数外部的原始数据中。**引用参数**在需要修改输入数据或传递大型数据结构（如大型数组或对象）时非常有用，因为这些数据结构复制起来效率低下：
- en: '[PRE24]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The integer variable score is referenced as the focus of the `UpdateScore` method.
    When executed, `UpdateScore` simply adds 10 to the variable score.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 整数变量`score`作为`UpdateScore`方法的焦点。当执行时，`UpdateScore`简单地将10加到变量`score`上。
- en: Output parameters
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出参数
- en: 'Defined with the `out` keyword, **output parameters** are similar to reference
    parameters but are specifically intended to return data to the caller. The function
    is expected to assign a value to output parameters before it completes. Output
    parameters are often used when a function needs to return more than one value:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`out`关键字定义的**输出参数**与引用参数类似，但它们专门用于将数据返回给调用者。函数在完成之前预期将值分配给输出参数。输出参数通常在函数需要返回多个值时使用：
- en: '[PRE25]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, the provided function, `CalculateStats`, takes an array
    of integers, `numbers`, as input and two output parameters, `sum` and `average`.
    The `sum` parameter is calculated using the `Sum` method, which is a built-in
    `numbers` array, casting the length to `float` to ensure a floating-point division.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，提供的函数`CalculateStats`接受一个整数数组`numbers`作为输入，以及两个输出参数`sum`和`average`。`sum`参数是通过使用`Sum`方法计算的，该方法是一个内置的`numbers`数组，将长度转换为`float`以确保浮点除法。
- en: Note
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: LINQ in Unity’s C# is a set of query capabilities directly integrated into the
    language, allowing efficient data manipulation and querying of collections and
    arrays. Basically, advanced programmers in the past generated extensions to existing
    C# to solve frequently needed tasks like sorting an array, or simply summing its
    value. It saves from having to reproduce work already done by others.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的C#中的LINQ是一组直接集成到语言中的查询功能，允许高效地操作和查询集合和数组。基本上，过去的先进程序员生成现有的C#的扩展来解决经常需要的任务，如排序数组或简单地求和其值。这避免了重复他人的工作。
- en: Understanding the distinctions and appropriate use cases for value, reference,
    and output parameters gives you more precise control over data flow in C# functions,
    ensuring that functions can be designed to effectively meet various programming
    needs. In C# programming, parameters stand as a critical component of functions,
    delineating the inputs they can receive and significantly enhancing their versatility
    and adaptability.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 理解值、引用和输出参数的区别和适当的使用场景，可以让你更精确地控制C#函数中的数据流，确保函数能够有效地满足各种编程需求。在C#编程中，参数是函数的关键组成部分，它界定了函数可以接收的输入，并显著增强了其灵活性和适应性。
- en: This exploration has shed light on the intricacies of defining parameters, the
    mechanics of passing arguments, and their consequential effects on function behavior.
    We traversed the landscape of parameter types – value, reference, and output –
    each with its distinct role in data handling within functions.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这次探索揭示了定义参数的复杂性、传递参数的机制以及它们对函数行为的影响。我们遍历了参数类型——值、引用和输出——每个都在函数内部的数据处理中扮演着独特的角色。
- en: From the basic value parameters, which ensure the immutability of original data,
    to reference and output parameters, which allow for direct data manipulation and
    multiple return values, understanding these types is pivotal. This knowledge not
    only underscores the importance of judicious parameter usage but also paves the
    way for more advanced function implementations.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 从确保原始数据不可变的基本值参数，到允许直接数据操作和多个返回值的引用和输出参数，理解这些类型至关重要。这种知识不仅强调了谨慎使用参数的重要性，而且为更高级的函数实现铺平了道路。
- en: Next, we will shift our focus toward learning more about return types, further
    unraveling how functions conclude their operations and communicate results, seamlessly
    connecting the dots between inputs and outputs in the functional paradigm of C#
    programming.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把注意力转向学习更多关于返回类型的知识，进一步揭示函数如何结束操作并传达结果，无缝地将输入和输出连接起来，在C#编程的功能范式之间。
- en: Explaining return types
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释返回类型
- en: Our exploration of return types will illuminate a fundamental aspect of C# functions
    – dictating their output. This segment will highlight the importance of return
    types, from specific data types to using `void` for non-returning functions, through
    illustrative examples. Understanding return types is essential for defining a
    function’s purpose and output, enhancing the precision and effectiveness of your
    C# programming endeavors.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对返回类型的探索将阐明C#函数的一个基本方面——决定它们的输出。这一部分将强调返回类型的重要性，从具体的数据类型到使用`void`来表示不返回值的函数，通过示例进行说明。理解返回类型对于定义函数的目的和输出至关重要，可以增强你C#编程工作的精确性和有效性。
- en: '**Return types** are integral to C# functions, serving as a declaration of
    the kind of data a function will send back to its caller upon completion. This
    characteristic is requisite because it not only informs the compiler about the
    data type to expect but also guides developers in understanding what a function
    does and how its output can be utilized. Essentially, the return type sets a contract
    between the function and its environment, ensuring consistency and predictability
    in the function’s behavior.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回类型**是C#函数的核心组成部分，它声明了函数在完成时将向调用者返回的数据类型。这一特性是必需的，因为它不仅通知编译器预期的数据类型，而且指导开发者理解函数的功能以及如何利用其输出。本质上，返回类型在函数及其环境之间建立了一种契约，确保函数行为的连贯性和可预测性。'
- en: For example, a function declared with an `int` return type is expected to compute
    and return an integer value. This explicit declaration prevents ambiguity, allowing
    developers to integrate the function seamlessly into further calculations or logic
    that rely on an integer result. Conversely, a function with a `void` return type
    signifies that it will perform its intended operations without providing any direct
    output. Such functions are typically used for their side effects, such as modifying
    global state, processing input/output operations, or triggering events.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个声明为 `int` 返回类型的函数预期将计算并返回一个整数值。这种明确的声明防止了歧义，使得开发者可以无缝地将函数集成到依赖于整数结果的进一步计算或逻辑中。相反，具有
    `void` 返回类型的函数表示它将执行其预期操作而不提供任何直接输出。这类函数通常用于其副作用，例如修改全局状态、处理输入/输出操作或触发事件。
- en: The significance of return types extends beyond the immediate value they provide.
    They are a cornerstone of type safety in C#, ensuring that the data flow within
    an application adheres to defined constraints, reducing errors. For instance,
    attempting to assign the output of a `void` function to a variable would result
    in a compile-time error, preventing potential runtime issues. This clear definition
    and enforcement of return types reinforce the robustness and reliability of code
    written in C#.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型的重要性不仅限于它们提供的直接值。它们是 C# 中类型安全的基础，确保应用程序中的数据流遵循定义的约束，从而减少错误。例如，尝试将 `void`
    函数的输出分配给变量会导致编译时错误，从而防止潜在的运行时问题。这种明确定义和执行返回类型增强了用 C# 编写的代码的健壮性和可靠性。
- en: 'To illustrate the diversity of return types in C#, let’s consider several examples
    that showcase the different kinds of outputs that a function can provide. Each
    example highlights how the return type influences the function’s design and utility:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 C# 中返回类型的多样性，让我们考虑几个示例，这些示例展示了函数可以提供不同类型的输出。每个示例都强调了返回类型如何影响函数的设计和实用性：
- en: '**Returning a simple value**: Here’s an example of the output:'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回简单值**：以下是一个输出示例：'
- en: '[PRE26]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this straightforward example, the `GetPlayerScore` function is defined with
    an `int` return type, indicating that it will return an integer value. When called,
    it provides a specific score value, which can be used directly in the calling
    code, such as in comparisons or calculations.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，`GetPlayerScore` 函数被定义为具有 `int` 返回类型，表示它将返回一个整数值。当被调用时，它提供一个特定的分数值，可以直接在调用代码中使用，例如在比较或计算中。
- en: '**Returning a complex type**: Here’s an example of the output:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回复杂类型**：以下是一个输出示例：'
- en: '[PRE27]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the `GetPlayerDetails` function returns an object of a custom type, `Player`.
    This demonstrates how functions can construct and return complex data types, encapsulating
    more detailed information that can be accessed by the caller.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`GetPlayerDetails` 函数返回一个自定义类型 `Player` 的对象。这展示了函数如何构建和返回复杂的数据类型，封装更详细的信息，这些信息可以被调用者访问。
- en: '**Void return type**: Here’s an example of the output:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`void` 返回类型**：以下是一个输出示例：'
- en: '[PRE28]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `LogPlayerEntry` function has a `void` return type, signifying that it does
    not return any value. Functions such as these are executed for their side effects
    – in this case, writing to the log (which can be viewed in the console) – without
    affecting the flow of data in the program.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LogPlayerEntry` 函数具有 `void` 返回类型，表示它不返回任何值。这类函数执行是为了其副作用——在这种情况下，写入日志（可以在控制台中查看）——而不影响程序中的数据流。'
- en: '**Returning arrays or collections**: Here’s an example of the output:'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回数组或集合**：以下是一个输出示例：'
- en: '[PRE29]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Functions can also return arrays or other collection types, as shown by `GetPlayerAbilities`,
    which provides an array of strings representing player abilities. This capability
    is particularly useful for returning multiple related values.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数还可以返回数组或其他集合类型，如 `GetPlayerAbilities` 所示，它提供了一个表示玩家能力的字符串数组。这种能力对于返回多个相关值特别有用。
- en: These examples underscore the flexibility and power of return types in C#, enabling
    functions to convey a wide range of information – from simple data types to complex
    objects and collections. By carefully choosing the appropriate return type, developers
    can design functions that precisely meet their program’s requirements, enhancing
    clarity and facilitating effective data handling.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例强调了C#中返回类型的灵活性和强大功能，使得函数能够传达广泛的信息——从简单的数据类型到复杂对象和集合。通过仔细选择合适的返回类型，开发者可以设计出精确满足程序要求的函数，增强清晰度并促进有效的数据处理。
- en: The choice of return types in C# functions is significant, as it defines a function’s
    output and shapes its utility within an application. From simple data types to
    `void` and complex objects, return types ensure that functions can effectively
    communicate results, adhere to type safety, and maintain consistent behavior.
    Examples ranging from basic integers to complex types and collections demonstrate
    the adaptability and precision that return types afford in C# programming, enhancing
    the robustness and reliability of its code.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#函数中，返回类型的选择非常重要，因为它定义了函数的输出并决定了它在应用程序中的用途。从简单的数据类型到`void`和复杂对象，返回类型确保函数能够有效地传达结果，遵守类型安全，并保持一致的行为。从基本整数到复杂类型和集合的例子展示了返回类型在C#编程中的适应性和精确性，增强了代码的健壮性和可靠性。
- en: As we transition from the specifics of return types, we will move on to understanding
    function overloading, a concept that further expands the versatility and capability
    of functions in C#. Function overloading allows multiple functions with the same
    name to coexist, distinguished by their parameter lists, enabling even more nuanced
    and flexible function implementations.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从返回类型的具体细节过渡到理解函数重载这一概念时，我们将进一步了解C#中函数的多样性和能力。函数重载允许具有相同名称的多个函数共存，通过它们的参数列表来区分，使得函数的实现更加细致和灵活。
- en: Function overloading
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数重载
- en: '**Function overloading** in C# introduces the ability to have multiple functions
    with the same name within the same scope, differentiated by their parameter lists.
    This powerful feature allows developers to create several versions of a function,
    each tailored to handle different types and numbers of arguments, thereby enhancing
    a program’s flexibility and readability. Overloading enables more intuitive interaction
    with functions, as the most appropriate version is automatically invoked based
    on the provided arguments, streamlining code execution and simplifying function
    usage.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数重载**在C#中引入了在相同作用域内拥有多个同名函数的能力，这些函数通过它们的参数列表来区分。这一强大功能允许开发者创建多个函数版本，每个版本都针对处理不同类型和数量的参数而定制，从而增强了程序的灵活性和可读性。重载功能使得与函数的交互更加直观，因为根据提供的参数，最合适的版本会自动被调用，从而简化了代码执行并简化了函数的使用。'
- en: 'The advantage of function overloading lies in its ability to offer a more intuitive
    and context-sensitive approach to function usage. For instance, consider a `Print`
    function designed to output different types of data to the console. Instead of
    creating uniquely named functions for each data type, such as `PrintString` and
    `PrintInt`, overloading allows you to have multiple `Print` functions, each designed
    to handle a specific data type or scenario. This not only simplifies the function’s
    usage by providing a common interface but also makes the code more readable and
    maintainable. The upcoming example might look like an error, the same script repeated
    three times with different arguments, but in this instance, C# determines which
    function to execute based on the argument:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载的优势在于它提供了一种更直观和上下文相关的函数使用方法。例如，考虑一个`Print`函数，它被设计用来将不同类型的数据输出到控制台。而不是为每种数据类型创建具有独特名称的函数，例如`PrintString`和`PrintInt`，重载允许你拥有多个`Print`函数，每个函数都设计用来处理特定的数据类型或场景。这不仅通过提供通用接口简化了函数的使用，也使得代码更加可读和易于维护。即将出现的示例可能看起来像是一个错误，因为相同的脚本重复了三次，但在这个例子中，C#会根据参数确定执行哪个函数：
- en: '[PRE30]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, each `Print` function is overloaded to handle a different
    data type – an integer, a string, and a double. When `Print` is called with an
    integer argument, the first function is invoked; when called with a string, the
    second; and so on. This seamless selection process, managed by the compiler, streamlines
    code and enhances its adaptability to varying data types and requirements, demonstrating
    the power and utility of function overloading in C#.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，每个 `Print` 函数都进行了重载，以处理不同的数据类型——一个整数、一个字符串和一个双精度浮点数。当 `Print` 使用整数参数调用时，第一个函数被调用；当使用字符串调用时，第二个；依此类推。这种无缝的选择过程由编译器管理，简化了代码，并增强了其适应不同数据类型和需求的能力，展示了
    C# 中函数重载的强大和实用性。
- en: Function overloading in C# enhances the language’s flexibility by allowing multiple
    functions with the same name but different parameter lists. This enables tailored
    function versions for various data types and argument counts, facilitating more
    intuitive and context-sensitive function interactions. Through `overloading`,
    functions can be designed to accommodate diverse data types, simplifying code
    usage and improving maintainability. The compiler’s role in selecting the appropriate
    function version, based on the arguments provided, streamlines execution and underscores
    C#’s adaptability to different programming needs.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的函数重载通过允许具有相同名称但不同参数列表的多个函数，增强了语言的灵活性。这使得可以为各种数据类型和参数数量定制函数版本，从而促进更直观和上下文相关的函数交互。通过
    `重载`，函数可以设计为适应不同的数据类型，简化代码使用并提高可维护性。编译器根据提供的参数选择适当的函数版本，简化了执行并强调了 C# 对不同编程需求的适应性。
- en: As we transition from the general principles of function overloading, we will
    move on to exploring Unity-specific functions in Unity3D, where the concept of
    overloading continues to play a decisive role in developing dynamic and responsive
    game elements.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们从函数重载的一般原则过渡，我们将转向探索 Unity3D 中的 Unity 特定函数，在那里重载的概念在开发动态和响应性游戏元素中继续发挥着决定性作用。
- en: Exploring Unity-specific functions
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Unity 特定函数
- en: In Unity3D, functions such as `Start()` and `Update()` extend beyond standard
    C# practices, serving as integral life cycle entry points. `Start()` initializes
    settings, while `Update()` executes code at every frame, closely aligning with
    a game’s runtime behavior and orchestrating the flow of execution with precision
    and reliability.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity3D 中，`Start()` 和 `Update()` 等函数超越了标准的 C# 实践，作为重要的生命周期入口点。`Start()` 初始化设置，而
    `Update()` 在每一帧执行代码，与游戏的运行时行为紧密一致，并精确可靠地编排执行流程。
- en: The `Start()` function is called once in the lifetime of a script, just before
    the first frame update and after all objects are initialized. This function serves
    as the ideal place to set initial conditions, gather references to components,
    and perform setup operations critical to the script’s role in a game. Since `Start()`
    is executed only once, it’s efficient for tasks that need to run at the beginning
    of the game or scene, ensuring a smooth setup before the game enters its main
    loop.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 函数在脚本的生命周期中只调用一次，在第一帧更新之前和所有对象初始化之后。这个函数是设置初始条件、收集组件引用和执行对脚本在游戏中的角色至关重要的设置操作的理想位置。由于
    `Start()` 只执行一次，它对于需要在游戏或场景开始时运行的任务来说效率很高，确保在游戏进入主循环之前有一个平稳的设置。'
- en: Conversely, the `Update()` function is called once per frame and is at the heart
    of most scripts in Unity. It’s where the bulk of a game’s frame-to-frame logic
    takes place, from handling user inputs and updating animations to managing physics
    calculations and game state transitions. The frequency of `Update()` calls makes
    it suitable for operations that need to check or change regularly over time, contributing
    to the dynamic and responsive nature of gameplay.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`Update()` 函数每帧调用一次，是 Unity 中大多数脚本的核心。在这里，游戏从处理用户输入和更新动画到管理物理计算和游戏状态转换的逻辑大部分发生。`Update()`
    调用的频率使其适合需要定期检查或改变的操作，从而有助于游戏动态和响应性的特性。
- en: These functions fit seamlessly into the Unity life cycle, a cycle of events
    and processes that run throughout the life of a game or application. `Start()`
    kicks off the life cycle by performing initial setups, followed by `Update()`
    maintaining the ongoing activities and logic needed for each frame. Together,
    they form a robust framework for scripting game behavior, allowing developers
    to hook into Unity’s life cycle and ensure their code executes at the right moments,
    maintaining both order and efficiency in game development.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数无缝地融入Unity的生命周期，这是一个贯穿游戏或应用程序整个生命周期的事件和过程循环。`Start()`通过执行初始设置启动生命周期，然后是`Update()`维护每帧所需的持续活动和逻辑。它们共同构成了一个强大的脚本框架，用于编写游戏行为，允许开发者挂钩到Unity的生命周期，并确保他们的代码在正确的时刻执行，保持游戏开发中的秩序和效率。
- en: Creating custom functions within Unity
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Unity中的自定义函数
- en: Creating custom functions within Unity scripts is a fundamental practice that
    allows developers to modularize code, making it more organized, readable, and
    reusable. These custom functions can be called from Unity-specific functions such
    as `Start()` and `Update()`, enabling a structured approach to game development
    where complex tasks are broken down into manageable, self-contained units of logic.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity脚本中创建自定义函数是一种基本实践，它允许开发者模块化代码，使其更加有序、可读和可重用。这些自定义函数可以从Unity特有的函数，如`Start()`和`Update()`中调用，从而实现一种结构化的游戏开发方法，将复杂任务分解为可管理的、自包含的逻辑单元。
- en: 'To define a custom function, you start by declaring it within a Unity script,
    following the same syntax as standard C# functions. This involves specifying the
    return type, naming the function, defining any parameters it requires, and then
    implementing the logic within the function body. For instance, a function to update
    a player’s health might look like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个自定义函数，你首先需要在Unity脚本中声明它，遵循与标准C#函数相同的语法。这包括指定返回类型、命名函数、定义它所需的任何参数，然后在函数体中实现逻辑。例如，一个更新玩家健康的函数可能看起来像这样：
- en: '[PRE31]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once defined, this custom function can be invoked from any of the Unity-specific
    functions. For example, you might call `UpdatePlayerHealth()` within the `Update()`
    function to continuously check for and apply any damage that the player receives:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，这个自定义函数就可以从任何Unity特有的函数中调用。例如，你可能会在`Update()`函数中调用`UpdatePlayerHealth()`，以持续检查并应用玩家收到的任何伤害：
- en: '[PRE32]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This approach allows developers to encapsulate specific behaviors and operations
    within custom functions, keeping the core Unity functions such as `Update()` clean
    and focused on the game’s primary loop logic. By calling custom functions within
    `Start()`, `Update()`, or other life cycle functions, developers can ensure that
    their game logic is executed at the appropriate times, contributing to the overall
    structure and functionality of the game.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许开发者将特定的行为和操作封装在自定义函数中，使核心Unity函数如`Update()`保持干净和专注于游戏的主要循环逻辑。通过在`Start()`、`Update()`或其他生命周期函数中调用自定义函数，开发者可以确保他们的游戏逻辑在适当的时间执行，从而有助于游戏的整体结构和功能。
- en: Moreover, leveraging custom functions in this manner enhances the scalability
    of Unity projects, as developers can easily add, modify, or remove functionalities
    without significantly disrupting the main game loop. It also facilitates collaboration
    and debugging by isolating functionality, making it easier to identify and resolve
    issues within specific parts of the game logic.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以这种方式利用自定义函数可以增强Unity项目的可扩展性，因为开发者可以轻松地添加、修改或删除功能，而不会显著干扰主游戏循环。它还通过隔离功能，使识别和解决游戏逻辑特定部分的问题变得更加容易，从而促进协作和调试。
- en: Unity-specific functions such as `Start()` and `Update()` form the backbone
    of game scripts in Unity, orchestrating initial setups and ongoing actions within
    the game loop. Integrating custom functions into these key life cycle methods
    allows for streamlined, organized code that enhances game functionality.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Unity特有的函数，如`Start()`和`Update()`，构成了Unity中游戏脚本的骨架，协调游戏循环中的初始设置和持续动作。将这些自定义函数集成到这些关键的生命周期方法中，可以创建出结构化、有序的代码，从而增强游戏功能。
- en: Transitioning to the topic of access modifiers, we’ll explore how they govern
    the visibility and accessibility of these functions and variables, ensuring controlled
    interaction and security within Unity’s scripting environment.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 转到访问修饰符的话题，我们将探讨它们如何控制这些函数和变量的可见性和可访问性，确保在Unity脚本环境中进行受控交互和安全。
- en: Access modifiers
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: '`public` and `private` in Unity scripts are key to managing how functions and
    variables are accessed and modified. They serve as essential tools in C# to encapsulate
    script data, ensuring that only intended interactions occur within and between
    scripts. This segment will explore the impact of these modifiers on script security
    and structure, emphasizing their role in maintaining clean and safe code in Unity
    projects.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity脚本中，`public`和`private`是管理函数和变量如何被访问和修改的关键。它们是C#中的基本工具，用于封装脚本数据，确保只在脚本内部和脚本之间发生预期的交互。本节将探讨这些修饰符对脚本安全性和结构的影响，强调它们在保持Unity项目中代码整洁和安全方面的作用。
- en: Access modifiers in Unity scripts, such as `public`, `private`, `protected`,
    and `internal`, define the scope of accessibility for functions, variables, and
    other members within a script. These modifiers are fundamental to C# programming,
    playing a pivotal role in encapsulating data and ensuring that the internal implementation
    details of a class or a script are hidden and protected from unintended access.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Unity脚本中的访问修饰符，如`public`、`private`、`protected`和`internal`，定义了函数、变量和其他成员在脚本中的可访问范围。这些修饰符是C#编程的基础，在封装数据和确保类或脚本的内部实现细节被隐藏并防止意外访问方面发挥着关键作用。
- en: The `public` modifier makes a function or variable accessible from any other
    script or class within a Unity project. This level of openness is useful for variables
    that need to be exposed in the Unity Inspector or for functions that must be callable
    from other scripts, such as event handlers or API methods. For example, a `public`
    function in a player character script might be called by an enemy script to apply
    damage.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`修饰符使函数或变量可以从Unity项目中的任何其他脚本或类中访问。这种开放程度对于需要在Unity检查器中公开的变量或必须从其他脚本中调用的函数（如事件处理程序或API方法）非常有用。例如，玩家角色脚本中的`public`函数可能被敌人脚本调用以施加伤害。'
- en: Conversely, the `private` modifier restricts access to the function or variable
    to the class that it is declared in. This is the default access level for class
    members in C# and is used to encapsulate a class’s internal workings, only allowing
    access through public methods if necessary. This encapsulation principle is key
    to object-oriented design, promoting modularity and reducing dependencies between
    different parts of a code base.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`private`修饰符将函数或变量的访问限制在声明它的类中。这是C#中类成员的默认访问级别，用于封装类的内部工作，仅在必要时才通过公共方法允许访问。这种封装原则是面向对象设计的关键，促进了模块化并减少了代码库不同部分之间的依赖性。
- en: Other modifiers, such as `protected`, allow access from within the class itself
    and any subclass that inherits from it, facilitating a controlled inheritance
    structure. The `internal` modifier restricts access to within the assembly, which
    in Unity typically means the entire project, offering a balance between `public`
    and `private`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 其他修饰符，如`protected`，允许从类本身及其任何继承自该类的子类中访问。`internal`修饰符限制访问范围在程序集内，在Unity中通常意味着整个项目，在`public`和`private`之间提供了一个平衡。
- en: Understanding and applying these access modifiers correctly is important in
    Unity scripting to ensure that components interact with each other in a controlled
    and expected manner. They help to maintain a clear boundary between what is meant
    to be interacted with from the outside and what should remain internal to the
    class, contributing to the overall robustness and maintainability of the game
    code.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 正确理解和应用这些访问修饰符对于Unity脚本编写非常重要，以确保组件以受控和预期的方式相互交互。它们有助于在类的外部交互意图和内部应保持不变的部分之间保持清晰的边界，从而有助于游戏代码的整体健壮性和可维护性。
- en: Access modifiers in Unity, such as `public` and `private`, play a central role
    in defining the accessibility of script elements, ensuring controlled interaction
    and data protection within your game’s code. By effectively employing these modifiers,
    developers can safeguard the internal logic of scripts and expose only what’s
    necessary, maintaining a clean and secure architecture.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的访问修饰符，如`public`和`private`，在定义脚本元素的可访问性方面发挥着核心作用，确保在游戏代码中实现受控的交互和数据保护。通过有效地使用这些修饰符，开发者可以保护脚本的内逻辑，仅公开必要的内容，保持整洁和安全的架构。
- en: We will move on from the structured use of access modifiers to the concept of
    recursion – a powerful, albeit intricate, programming technique that allows functions
    to call themselves, opening new dimensions for problem-solving and algorithm implementation
    in Unity scripts.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个结构化的访问修饰符的使用转向递归的概念——这是一种强大但复杂的编程技术，允许函数调用自身，为在 Unity 脚本中的问题解决和算法实现开辟新的维度。
- en: Advanced function concepts – recursion
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级函数概念——递归
- en: Recursion is a powerful programming technique that involves a function invoking
    itself to tackle a problem, by breaking it down into smaller, more manageable
    sub-tasks. This approach is particularly well-suited for problems that can be
    defined in terms of similar, smaller problems, such as traversing hierarchical
    data structures or solving complex mathematical equations. By repeatedly calling
    itself to address these sub-problems, the function can find a solution to the
    original, larger problem systematically and efficiently.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种强大的编程技术，它涉及一个函数通过调用自身来处理问题，通过将其分解为更小、更易于管理的子任务来实现。这种方法特别适合于可以用类似、更小的子问题来定义的问题，例如遍历分层数据结构或解决复杂的数学方程。通过反复调用自身来解决这些子问题，函数可以系统地、高效地找到原始、更大问题的解决方案。
- en: 'Consider the following example – listing a game object’s children:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例——列出游戏对象的子对象：
- en: '[PRE33]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example, `TraverseTransformHierarchy`, prints the name of the parent game
    object. Then, it references the child game objects. Each is recursively called
    back to `TraverseTransformHierarchy`. We’ll learn more about game objects and
    their transform components in later chapters.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，`TraverseTransformHierarchy` 函数打印父游戏对象的名字。然后，它引用子游戏对象。每个子对象都会递归地调用 `TraverseTransformHierarchy`。我们将在后面的章节中了解更多关于游戏对象及其变换组件的内容。
- en: Recursion, with its elegant self-referential function calls, is a powerful tool
    for breaking down complex problems into simpler, manageable tasks in Unity scripts.
    In game development, recursion can be particularly useful for tasks such as navigating
    hierarchical data structures (such as game object hierarchies), implementing search
    algorithms (for pathfinding), or managing game states. For example, using recursion
    to traverse a game object tree can simplify code that needs to apply transformations
    or collect data from nested game objects. Similarly, recursive algorithms can
    streamline pathfinding by breaking down the search process into smaller, repetitive
    tasks. By leveraging recursion, developers can create more efficient and readable
    code for game-related problems that naturally fit recursive solutions.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 递归，以其优雅的自引用函数调用，是分解复杂问题为更简单、可管理任务的强大工具，在 Unity 脚本中特别有用。在游戏开发中，递归对于诸如导航分层数据结构（如游戏对象层次结构）、实现搜索算法（用于路径查找）或管理游戏状态等任务特别有用。例如，使用递归遍历游戏对象树可以简化需要应用于嵌套游戏对象的变换或收集数据的代码。同样，递归算法可以通过将搜索过程分解为更小、重复的任务来简化路径查找。通过利用递归，开发者可以为自然适合递归解决方案的游戏相关问题创建更高效、更易读的代码。
- en: Moving on from the structured recursion approach, we will delve into the realm
    of lambda expressions and anonymous methods, modern C# features that provide concise,
    flexible ways to define functions inline, further expanding the toolkit for problem-solving
    and event handling in Unity development.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构化的递归方法转向，我们将深入 lambda 表达式和匿名方法的领域，这些是现代 C# 功能，提供了简洁、灵活的方式来定义内联函数，进一步扩展了 Unity
    开发中问题解决和事件处理的工具集。
- en: Lambda expressions and anonymous methods
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda 表达式和匿名方法
- en: Lambda expressions and anonymous methods in C# offer sophisticated means to
    define and execute functions inline, enabling succinct and flexible code writing.
    These advanced concepts allow you to create quick, one-off function-like entities
    without the need for explicit naming, streamlining event handling and custom logic
    implementation in Unity scripts. This section will explore how these constructs
    can enhance code readability and efficiency, particularly in scenarios requiring
    concise, on-the-fly functionality.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的 Lambda 表达式和匿名方法提供了复杂的手段来定义和内联执行函数，使得代码简洁且灵活。这些高级概念允许你创建快速、一次性的类似函数实体，无需显式命名，简化了
    Unity 脚本中的事件处理和自定义逻辑实现。本节将探讨这些结构如何增强代码的可读性和效率，特别是在需要简洁、即时功能的情况下。
- en: '**Lambda expressions** and **anonymous methods** in C# offer streamlined, powerful
    alternatives to define functions inline, without the need for a formal declaration.
    These constructs are particularly useful for short snippets of code that are passed
    as arguments to methods, especially those that take delegates or expression trees
    as parameters.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的**lambda表达式**和**匿名方法**提供了定义内联函数的流畅且强大的替代方案，无需正式声明。这些结构特别适用于作为方法参数传递的短代码片段，尤其是那些接受代表或表达式树作为参数的方法。
- en: 'Lambda expressions, symbolized by the `=>` operator, provide a concise way
    to write inline expressions that can contain multiple statements. For instance,
    a lambda expression to square a number could be written as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以`=>`运算符表示的lambda表达式提供了一种简洁的方式来编写包含多个语句的内联表达式。例如，一个用于平方数字的lambda表达式可以写成如下所示：
- en: '[PRE34]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This expression defines a function that takes an integer, `x`, and returns its
    square, demonstrating the simplicity and elegance of lambda expressions for straightforward
    operations.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 此表达式定义了一个函数，它接受一个整数`x`并返回其平方，展示了lambda表达式在直接操作中的简洁和优雅。
- en: Anonymous methods offer a similar level of inline functionality, allowing for
    blocks of code to be defined without a name, often used in places where delegate
    types are expected. While lambda expressions have largely superseded anonymous
    methods in terms of popularity and usage due to their brevity, both serve the
    purpose of making C# code more concise and readable, particularly when working
    with event handling or LINQ queries in Unity scripts. Their ability to encapsulate
    functionality in a succinct, expressive manner makes these advanced concepts valuable
    tools in the C# programmer’s arsenal.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法提供了类似的内联功能级别，允许定义没有名称的代码块，通常用于期望代表类型的场合。尽管由于它们的简洁性，lambda表达式在流行度和使用上已经很大程度上取代了匿名方法，但两者都服务于使C#代码更加简洁和可读性的目的，尤其是在处理Unity脚本中的事件处理或LINQ查询时。它们能够以简洁、表达性强的方式封装功能，使这些高级概念成为C#程序员工具箱中的宝贵工具。
- en: C# lambda expressions and anonymous methods simplify function definition and
    execution, enabling concise, inline code blocks. These features streamline event
    handling and LINQ queries, improving readability and maintainability. The succinct
    syntax allows you to define functionality on the fly, paving the way for advanced
    event-driven programming.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: C#的lambda表达式和匿名方法简化了函数的定义和执行，使内联代码块更加简洁。这些功能简化了事件处理和LINQ查询，提高了可读性和可维护性。简洁的语法允许您即时定义功能，为高级事件驱动编程铺平了道路。
- en: Moving on from these inline methods, we will delve into the realms of delegates
    and events, powerful constructs in C# that facilitate a robust event handling
    system, enabling objects to communicate effectively without being tightly coupled,
    which is a cornerstone in the development of responsive and interactive Unity
    applications.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些内联方法继续前进，我们将深入探讨代表和事件的领域，这些在C#中强大的结构有助于构建健壮的事件处理系统，使对象能够有效地进行通信而无需紧密耦合，这是开发响应性和交互式Unity应用程序的基础。
- en: Delegates and events
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代表和事件
- en: '**Events** and **delegates** in Unity3D serve as the backbone of flexible and
    decoupled event-handling mechanisms, allowing objects and systems within a game
    to interact and respond to actions and changes seamlessly.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**和**代表**在Unity3D中充当灵活且解耦的事件处理机制的骨架，允许游戏中的对象和系统无缝地交互和响应动作及变化。'
- en: Events in Unity offer a structured approach to broadcasting messages and triggering
    responses across different components. Events act as special kinds of multicast
    delegates that can be subscribed to by multiple listeners. When an event is raised,
    all subscribed methods are called, making it an ideal tool to implement publish-subscribe
    patterns. This decouples the event sender from the receivers, as the sender doesn’t
    need to know which objects listen to the event, enhancing modularity and scalability.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的事件提供了一种结构化的方法来广播消息并在不同的组件之间触发响应。事件作为可以由多个监听器订阅的特殊类型的多播代表。当事件被触发时，所有已订阅的方法都会被调用，这使得它成为实现发布-订阅模式的理想工具。这解耦了事件发送者与接收者，因为发送者不需要知道哪些对象监听事件，从而增强了模块化和可扩展性。
- en: Delegates, conversely, are type-safe function pointers that allow developers
    to define callback methods adhering to a specific signature. This capability is
    essential for designing callback systems, where a delegate can point to any function
    that matches its signature, providing a way to invoke these functions at appropriate
    times without knowing the exact method at compile time. By utilizing delegates,
    developers can create a communication channel, where objects can subscribe to
    and react to events without needing direct references to each other. This system
    not only enhances the modularity and reusability of code but also empowers developers
    to construct dynamic and interactive game elements with sophisticated response
    behaviors, all while maintaining clean and maintainable code structures.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，委托是类型安全的函数指针，允许开发者定义符合特定签名的回调方法。这种能力对于设计回调系统至关重要，其中委托可以指向任何匹配其签名的函数，提供在编译时不知道确切方法的情况下，在适当的时间调用这些函数的方法。通过使用委托，开发者可以创建一个通信通道，其中对象可以订阅并响应事件，而无需直接引用彼此。这个系统不仅增强了代码的模块化和可重用性，而且使开发者能够构建具有复杂响应行为的动态和交互式游戏元素，同时保持代码结构的整洁和可维护性。
- en: 'For example, consider a simple event in a game that notifies multiple systems
    when a player’s health changes:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个简单的游戏事件，当玩家的健康值发生变化时，它会通知多个系统：
- en: '[PRE35]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, `OnHealthChanged` is an event based on the `HealthChangedDelegate`
    delegate. Other parts of the game, such as the UI or achievement system, can subscribe
    to this event and react to health changes accordingly, updating the health bar
    or unlocking a *survival* achievement, for instance. This structure enables a
    flexible and decoupled system where components can communicate efficiently, key
    to building complex and interactive environments in Unity3D.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`OnHealthChanged`是一个基于`HealthChangedDelegate`委托的事件。游戏的其他部分，如UI或成就系统，可以订阅此事件并相应地响应健康值的变化，例如更新健康条或解锁一个*生存*成就。这种结构实现了一个灵活且解耦的系统，其中组件可以高效地通信，这对于在Unity3D中构建复杂和交互式环境至关重要。
- en: Delegates and events in Unity3D provide a robust framework for decoupled communication
    between game components, enabling efficient event handling and callback mechanisms.
    By leveraging these constructs, developers can design systems where objects subscribe
    to and react to events seamlessly, fostering modularity and interactivity within
    a game environment.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Unity3D中的委托和事件提供了一个强大的框架，用于游戏组件之间的解耦通信，实现了高效的事件处理和回调机制。通过利用这些结构，开发者可以设计系统，其中对象可以无缝地订阅并响应事件，促进游戏环境中的模块化和交互性。
- en: Let’s now move on from the technical intricacies of delegates and events to
    best practices in Unity3D development, focusing on strategies that ensure code
    efficiency, maintainability, and optimal performance, laying the groundwork to
    build well-structured and scalable Unity applications.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从委托和事件的复杂技术细节转向Unity3D开发的最佳实践，重点关注确保代码效率、可维护性和最佳性能的策略，为构建结构良好和可扩展的Unity应用程序奠定基础。
- en: Best practices
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Adhering to best practices in function design is pivotal for crafting efficient,
    readable, and maintainable Unity3D applications. By focusing on principles such
    as single responsibility for functions, adhering to naming conventions, and thorough
    commenting, developers can ensure clarity and ease of maintenance. Additionally,
    embracing a modular design enhances testing and debugging processes.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循函数设计的最佳实践对于构建高效、可读和可维护的Unity3D应用程序至关重要。通过关注如函数的单职责原则、遵循命名约定和详尽的注释等原则，开发者可以确保代码的清晰性和易于维护。此外，采用模块化设计可以增强测试和调试过程。
- en: This section will also shed light on common pitfalls in function programming,
    such as infinite recursion and scope issues, and provide essential debugging tips,
    including leveraging the Unity Console and breakpoints. To conclude, we’ll encapsulate
    the discussed best practices and common challenges, encouraging developers to
    experiment with functions to elevate the interactivity and dynamism of their Unity3D
    projects.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还将探讨函数编程中的常见陷阱，如无限递归和作用域问题，并提供必要的调试技巧，包括利用Unity控制台和断点。最后，我们将总结讨论的最佳实践和常见挑战，鼓励开发者通过实验函数来提升他们Unity3D项目的交互性和动态性。
- en: 'In the development of Unity3D applications, adhering to best practices in function
    design is not just beneficial – it’s essential for creating code that is both
    effective and sustainable in the long time. Here are some of the best practices
    you should keep in mind while developing Unity3D applications:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity3D应用程序的开发中，遵循函数设计的最佳实践不仅有益，而且对于创建长期有效和可持续的代码至关重要。以下是一些你在开发Unity3D应用程序时应记住的最佳实践：
- en: One fundamental principle is the **single responsibility of functions** – each
    function should be tasked with a single, clear purpose. This focus not only makes
    functions easier to understand and reuse but also simplifies debugging and testing
    by isolating functionality.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的原则是**函数的单责任原则**——每个函数应该承担一个单一、明确的目的。这种专注不仅使函数更容易理解和重用，而且通过隔离功能简化了调试和测试。
- en: Equally important are naming conventions and commenting. Descriptive and consistent
    naming helps to quickly convey the purpose of a function, making the code base
    more navigable and intuitive.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样重要的是命名约定和注释。描述性和一致的命名有助于快速传达函数的目的，使代码库更易于导航和直观。
- en: Thorough commenting provides insights into the logic behind code, especially
    in complex or non-obvious implementations, facilitating maintenance and future
    modifications.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细的注释可以揭示代码背后的逻辑，特别是在复杂或非直观的实现中，有助于维护和未来的修改。
- en: Modular design takes these concepts further by organizing code into distinct,
    loosely coupled modules, each responsible for a specific aspect of the application.
    This modularity is key in scaling projects, enabling parallel development, and
    simplifying the testing process, as each module can be tested independently before
    integration.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化设计将这些概念进一步发展，通过将代码组织成独立、松散耦合的模块，每个模块负责应用的一个特定方面。这种模块化对于扩展项目、实现并行开发和简化测试过程至关重要，因为每个模块都可以在集成前独立测试。
- en: However, even with the best practices in place, developers might encounter common
    pitfalls, such as **infinite recursion**, where a function repeatedly calls itself
    without an exit condition, leading to stack overflow errors. **Off-by-one errors**,
    which occur when a loop iterates one time too many or too few, and scope issues
    can also lead to bugs that are often tricky to diagnose. To combat these challenges,
    Unity provides powerful debugging tools. The Unity Console is invaluable for logging
    messages and errors, while breakpoints allow developers to pause execution and
    inspect the current state of an application, identifying the root causes of issues
    more effectively.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使有最佳实践，开发者可能会遇到常见的陷阱，如**无限递归**，即函数在没有退出条件的情况下反复调用自身，导致堆栈溢出错误。"**偏移量错误**"，当循环迭代次数过多或过少时发生，以及作用域问题也可能导致难以诊断的bug。为了应对这些挑战，Unity提供了强大的调试工具。Unity控制台对于记录消息和错误非常有价值，而断点允许开发者暂停执行并检查应用程序的当前状态，更有效地识别问题的根本原因。
- en: In conclusion, by embracing best practices in function design, and being aware
    of common pitfalls, developers can enhance the quality and maintainability of
    their Unity3D applications. Experimentation with functions, combined with a solid
    understanding of Unity’s debugging tools, can lead to more dynamic, interactive,
    and engaging game experiences, pushing the boundaries of what’s possible within
    the Unity engine.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，通过采用函数设计的最佳实践，并意识到常见的陷阱，开发者可以提高他们Unity3D应用程序的质量和可维护性。对函数的实验，结合对Unity调试工具的扎实理解，可以带来更动态、互动和吸引人的游戏体验，推动Unity引擎内可能性的边界。
- en: This section covered the basics of writing functions in C# for Unity3D, including
    function definition, parameters, and return types, as well as advanced concepts
    such as recursion, lambda expressions, and anonymous methods. We also touched
    on Unity-specific functions, access modifiers, and the role of delegates and events
    in creating flexible event-handling systems. Practical examples and best practices
    were provided to help developers create efficient and maintainable functions,
    enhancing their Unity3D projects. Now, let’s move on to exploring techniques to
    debug C# scripts, ensuring that your code runs smoothly and efficiently.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了在Unity3D中编写C#函数的基础知识，包括函数定义、参数和返回类型，以及递归、lambda表达式和匿名方法等高级概念。我们还简要介绍了Unity特定的函数、访问修饰符以及在创建灵活的事件处理系统中的委托和事件的作用。提供了实际示例和最佳实践，以帮助开发者创建高效且易于维护的函数，从而增强他们的Unity3D项目。现在，让我们继续探讨调试C#脚本的技术，以确保你的代码运行顺畅且高效。
- en: Debugging C# scripts
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试C#脚本
- en: Mastering basic debugging and troubleshooting techniques is essential for any
    Unity developer looking to create robust and error-free games. This introduction
    sets the stage for a deeper dive into the critical aspects of debugging in Unity,
    starting with an overview of why debugging is a cornerstone of game development.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握基本的调试和故障排除技术对于任何希望创建健壮且无错误的游戏的Unity开发者来说至关重要。本介绍为深入探讨Unity调试的关键方面奠定了基础，从概述为什么调试是游戏开发的基础开始。
- en: We’ll explore the functionalities of Unity’s `Debug.Log()` and breakpoints,
    this section aims to equip you with the foundational knowledge needed for efficient
    problem-solving. In addition, we’ll discuss the best practices that can preemptively
    reduce errors and streamline the debugging process.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索Unity的`Debug.Log()`功能和断点的功能，本节旨在为你提供高效解决问题的基础知识。此外，我们还将讨论可以预先减少错误并简化调试过程的最佳实践。
- en: This overview not only prepares you to tackle bugs immediately but also builds
    a solid base for advanced debugging strategies, discussed later in the book, ensuring
    that your journey through Unity development is as smooth and productive as possible.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这份概述不仅让你能够立即应对bug，还为你构建了一个坚实的基础，以便在书中稍后讨论的高级调试策略，确保你的Unity开发之旅尽可能顺畅和高效。
- en: An introduction to debugging in Unity
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity调试简介
- en: '**Debugging** is an indispensable part of game development, serving as the
    critical process of identifying, diagnosing, and rectifying errors or bugs within
    game code to ensure optimal functionality and performance. In the context of Unity,
    understanding and leveraging the suite of debugging tools provided is paramount
    for developers.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试**是游戏开发不可或缺的一部分，它作为识别、诊断和纠正游戏代码中错误或bug的关键过程，以确保最佳的功能性和性能。在Unity的背景下，理解和利用提供的调试工具套件对于开发者来说至关重要。'
- en: '![Figure 3.5 – The Console window showing Unity and programmer-generated messages](img/B22128_03_5.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 显示Unity和程序员生成消息的控制台窗口](img/B22128_03_5.jpg)'
- en: Figure 3.5 – The Console window showing Unity and programmer-generated messages
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 显示Unity和程序员生成消息的控制台窗口
- en: Among these tools, the Unity Console stands out as a central hub to monitor
    runtime behavior, log informational messages, and catch errors and warnings. This
    section will highlight the significance of adept debugging practices in crafting
    seamless gaming experiences and familiarize developers with Unity’s debugging
    environment, emphasizing the Console’s role in maintaining and enhancing the quality
    of game projects.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些工具中，Unity控制台作为一个中心枢纽脱颖而出，用于监控运行时行为、记录信息性消息以及捕获错误和警告。本节将强调熟练的调试实践在制作无缝游戏体验中的重要性，并使开发者熟悉Unity的调试环境，强调控制台在维护和提升游戏项目质量中的作用。
- en: Understanding Unity’s Console window
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Unity的控制台窗口
- en: The Unity **Console** window is a powerful feature within the Unity Editor that
    acts as a diagnostic tool, providing developers with real-time insights into their
    game’s runtime behavior. It compiles a comprehensive log of messages, including
    informational texts, warnings, and error reports, which are imperative for debugging.
    Understanding how to navigate the Console, interpret the variety of messages it
    displays, and effectively use its filtering options to isolate relevant data is
    fundamental for efficient troubleshooting.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**控制台**窗口是Unity编辑器中的一个强大功能，它作为一个诊断工具，为开发者提供了对游戏运行时行为的实时洞察。它编译了一个包含信息文本、警告和错误报告的综合性日志，这对于调试至关重要。了解如何导航控制台、解释它显示的各种消息以及有效地使用其过滤选项来隔离相关数据，对于高效的故障排除是基本的。
- en: This section delves into the Console’s key features, guiding developers on how
    to decipher error messages and warnings to pinpoint issues, as well as exploring
    how filtering can enhance the debugging process by focusing on specific types
    of messages or log entries, streamlining the path to a bug-free game.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了控制台的关键功能，指导开发者如何解读错误消息和警告以定位问题，以及探索如何通过专注于特定类型的消息或日志条目来增强过滤功能，从而简化无错误游戏的开发路径。
- en: The Unity **Console** window is an essential tool within the Unity Editor, offering
    developers a centralized view of runtime logs, including errors, warnings, and
    informational messages. It features capabilities such as stack trace for errors,
    allowing developers to trace issues back to their source code, and customizable
    filters to focus on specific issues or message types. Understanding the Console’s
    functionalities enables developers to efficiently monitor their game’s behavior,
    identify problematic code, and streamline the debugging process, making it an
    indispensable asset in game development.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**控制台**窗口是Unity编辑器中的一个基本工具，为开发者提供了一个对运行时日志的集中视图，包括错误、警告和信息消息。它具有错误堆栈跟踪等功能，允许开发者将问题追溯到其源代码，以及可定制的过滤器，以便专注于特定问题或消息类型。了解控制台的功能使开发者能够有效地监控游戏的行为，识别有问题的代码，并简化调试过程，使其成为游戏开发中不可或缺的资产。
- en: Reading and interpreting error messages and warnings in Unity involves analyzing
    the text for key details, such as the error type, the affected script or asset,
    and the line number where the issue occurred. These messages often provide a concise
    description of the problem, guiding developers toward the source of the error.
    By paying close attention to this information and understanding the context within
    the code, developers can diagnose issues more accurately and take appropriate
    corrective actions, effectively reducing debugging time and enhancing overall
    code quality.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中阅读和解释错误消息和警告涉及分析文本以获取关键细节，例如错误类型、受影响的脚本或资产以及问题发生时的行号。这些消息通常提供了对问题的简洁描述，指导开发者找到错误的源头。通过密切关注这些信息并理解代码中的上下文，开发者可以更准确地诊断问题并采取适当的纠正措施，从而有效地减少调试时间并提高代码的整体质量。
- en: '![Figure 3.6 – An expanded view of the Console window’s upper-right-hand corner,
    showing the filtering options – logs, warnings, and errors](img/B22128_03_6.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 控制台窗口右上角的一个扩展视图，显示了过滤选项 – 日志、警告和错误](img/B22128_03_6.jpg)'
- en: Figure 3.6 – An expanded view of the Console window’s upper-right-hand corner,
    showing the filtering options – logs, warnings, and errors
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 控制台窗口右上角的一个扩展视图，显示了过滤选项 – 日志、警告和错误
- en: Unity’s Console offers filtering options that significantly streamline the debugging
    process by allowing developers to isolate specific types of messages, such as
    errors, warnings, or logs. These filters can be combined with search functionality
    to narrow down the output, based on keywords or phrases, enabling developers to
    quickly focus on relevant issues amid potentially overwhelming volumes of log
    data. By effectively utilizing these filtering capabilities, developers can enhance
    their efficiency in identifying and resolving issues within their Unity projects,
    leading to a more focused and productive debugging workflow.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的控制台提供了过滤选项，通过允许开发者隔离特定类型的消息，如错误、警告或日志，显著简化了调试过程。这些过滤器可以与搜索功能结合使用，根据关键词或短语缩小输出范围，使开发者能够快速关注可能令人不知所措的大量日志数据中的相关问题。通过有效地利用这些过滤能力，开发者可以提高他们在Unity项目中识别和解决问题的效率，从而实现更专注和高效的调试工作流程。
- en: The Unity Console is a vital tool for developers, providing a comprehensive
    overview of runtime logs, errors, and warnings, with advanced filtering to pinpoint
    issues. Mastering the Console’s features enables efficient debugging and problem-solving
    in Unity projects. Next, we’ll explore common script errors, their causes and
    symptoms, and strategies for resolution, further equipping developers to maintain
    smooth, error-free games.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Unity控制台是开发者的重要工具，它提供了对运行时日志、错误和警告的全面概述，具有高级过滤功能，可以定位问题。掌握控制台的功能可以有效地在Unity项目中调试和解决问题。接下来，我们将探讨常见的脚本错误、其原因和症状，以及解决策略，进一步帮助开发者维护平稳、无错误的游戏。
- en: Common errors in Unity scripts
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity脚本中的常见错误
- en: In Unity scripting, developers frequently encounter a variety of errors that
    can disrupt the development flow and gameplay experience. These include syntax
    errors, often resulting from typos or misuse of language constructs, which prevent
    scripts from compiling. Runtime errors, such as `null` reference exceptions and
    index out-of-range issues, occur while a game is running and often stem from improper
    data handling or accessing elements outside of their bounds. Logical errors, conversely,
    are more insidious, as they involve flaws in the game’s intended logic, leading
    to unexpected or incorrect behavior despite error-free compilation. Understanding
    and addressing these common pitfalls are essential for developing robust and error-free
    Unity games.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity脚本中，开发者经常遇到各种错误，这些错误可能会打断开发流程和游戏体验。这些错误包括语法错误，通常由拼写错误或语言结构的误用导致，这会阻止脚本编译。运行时错误，如`null`引用异常和索引越界问题，在游戏运行时发生，通常源于不适当的数据处理或访问超出其边界的元素。相反，逻辑错误更为隐蔽，因为它们涉及游戏预期逻辑中的缺陷，即使在编译无错误的情况下，也会导致意外的或不正确的行为。理解和解决这些常见陷阱对于开发健壮且无错误的Unity游戏至关重要。
- en: Syntax errors
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法错误
- en: '**Syntax errors** in Unity scripts are among the most straightforward issues
    to identify and resolve, yet they are also some of the most common. These errors
    typically arise from typos, incorrect use of C# operators, missing semicolons,
    mismatched parentheses, or other deviations from the language’s syntactical rules.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法错误**在Unity脚本中是最容易识别和解决的直接问题之一，但它们也是最常见的问题。这些错误通常源于拼写错误、C#运算符使用不当、缺少分号、括号不匹配或其他违反语言语法规则的情况。'
- en: The Unity Editor is quite adept at flagging these issues, often highlighting
    them directly in the script editor with descriptive error messages that point
    to the line and nature of the mistake. Addressing syntax errors usually involves
    a careful review of the indicated code lines, ensuring that they conform to the
    correct syntax expected by C#.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: Unity编辑器非常擅长标记这些问题，通常会在脚本编辑器中直接突出显示，并带有描述性的错误消息，指出错误所在的行和错误性质。纠正语法错误通常涉及仔细审查指示的代码行，确保它们符合C#期望的正确语法。
- en: Correcting these errors is essential to allow a script to compile and run as
    intended, taking the first step toward a functional Unity application.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 纠正这些错误对于允许脚本按预期编译和运行至关重要，这是朝着功能性的Unity应用程序迈出的第一步。
- en: Runtime errors
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时错误
- en: '**Runtime errors** occur while a Unity game is running and often manifest as
    disruptive issues that can halt execution or cause unintended behavior. The two
    prevalent types of runtime errors are null reference exceptions and index out-of-range
    errors.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时错误**在Unity游戏运行时发生，通常表现为中断执行或导致意外行为的问题。两种常见的运行时错误是null引用异常和索引越界错误。'
- en: '`null`, indicating that it hasn’t been instantiated or is otherwise unavailable.
    **Index out-of-range errors** occur when trying to access elements of an array
    or list using an index that exceeds the bounds of the collection, such as requesting
    the sixth item in a five-element array.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`表示它尚未实例化或以其他方式不可用。**索引越界错误**发生在尝试使用超出集合边界的索引访问数组或列表的元素时，例如在一个五个元素的数组中请求第六个元素。'
- en: Both types of errors are indicative of issues with data handling or logic flow
    in the script, requiring developers to carefully check their code for incorrect
    assumptions about object availability or collection sizes, and implement checks
    or safeguards to prevent these errors.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的错误都表明脚本中数据处理或逻辑流程存在问题，需要开发者仔细检查代码，以避免对对象可用性或集合大小的错误假设，并实施检查或安全措施以防止这些错误。
- en: Logical errors
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑错误
- en: '**Logical errors** in Unity scripts represent discrepancies between the intended
    behavior of the game and its actual execution, often resulting in unexpected outcomes
    without necessarily causing the program to crash. These errors are typically the
    result of flawed reasoning, incorrect assumptions, or oversight in the game’s
    logic flow, such as incorrect conditionals, improper loop configurations, or misapplied
    game mechanics.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: Unity脚本中的**逻辑错误**代表了游戏预期行为与其实际执行之间的差异，通常会导致意外的结果，而不会导致程序崩溃。这些错误通常是推理错误、错误的假设或游戏逻辑流程中的疏忽的结果，例如条件判断错误、不正确的循环配置或游戏机制应用不当。
- en: Unlike syntax or runtime errors, logical errors don’t produce explicit error
    messages, making them more challenging to diagnose. Identifying these requires
    a thorough understanding of a game’s intended functionality and often involves
    extensive testing and debugging to observe discrepancies in behavior, necessitating
    a methodical approach to isolate and correct the flawed logic.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 与语法错误或运行时错误不同，逻辑错误不会产生明确的错误消息，这使得它们更难以诊断。识别这些错误需要彻底了解游戏的预期功能，通常涉及广泛的测试和调试来观察行为差异，需要一种系统的方法来隔离和纠正有缺陷的逻辑。
- en: Common errors in Unity scripts, ranging from syntax mishaps and runtime issues
    to elusive logical errors, can significantly impede game development and player
    experience. Tackling these challenges necessitates a keen eye for detail in identifying
    syntax and runtime errors, often facilitated by Unity’s error messages, and a
    critical approach to uncovering logical errors through the testing and analysis
    of game behavior.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: Unity脚本中常见的错误，从语法错误和运行时问题到难以捉摸的逻辑错误，都可能严重阻碍游戏开发和玩家体验。解决这些挑战需要敏锐的细节观察力，以识别语法和运行时错误，通常由Unity的错误消息提供帮助，以及一种批判性的方法来通过测试和分析游戏行为来揭示逻辑错误。
- en: Let’s move on from identifying these common pitfalls to delve into the realm
    of debugging techniques, equipping developers with practical strategies and tools
    to efficiently diagnose, isolate, and rectify issues, ensuring smoother development
    workflows and more robust game functionalities.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们超越识别这些常见陷阱，深入到调试技术的领域，为开发者提供实用的策略和工具，以有效地诊断、隔离和纠正问题，确保更流畅的开发工作流程和更健壮的游戏功能。
- en: Debugging techniques
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试技术
- en: Effective debugging techniques are essential for navigating and resolving issues
    in Unity scripts. Utilizing `Debug.Log()` allows developers to print diagnostic
    messages and variable values to the Unity Console, providing real-time insights
    into a game’s state and behavior.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的调试技术对于在Unity脚本中导航和解决问题至关重要。利用`Debug.Log()`方法允许开发者将诊断消息和变量值打印到Unity控制台，提供对游戏状态和行为的实时洞察。
- en: Leveraging breakpoints, particularly in conjunction with IDEs such as Visual
    Studio, enables you to pause execution at critical points, offering an in-depth
    look at a program’s state at specific moments in time. Step-by-step execution,
    or stepping through code, further complements this by allowing a granular inspection
    of the code execution flow, making it easier to pinpoint the exact locations and
    causes of errors.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 利用断点，尤其是在与Visual Studio等IDE结合使用时，可以使你在关键点暂停执行，从而深入了解程序在特定时间点的状态。逐步执行，或逐行执行代码，通过允许对代码执行流程进行细粒度检查，进一步补充了这一点，使得定位错误的确切位置和原因变得更加容易。
- en: Together, these techniques form a robust toolkit for Unity developers to efficiently
    diagnose and resolve issues within their projects.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术共同构成了Unity开发者高效诊断和解决项目内问题的强大工具包。
- en: Using the Debug.Log() method
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Debug.Log()方法
- en: The `Debug.Log()` method in Unity is a simple yet powerful tool to monitor the
    execution flow of a game and understand its state at runtime. By printing messages
    and variable values directly to the Unity Console, developers can gain immediate
    feedback on how different parts of their game are operating.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的`Debug.Log()`方法是一个简单但强大的工具，用于监控游戏的执行流程并了解其运行时状态。通过直接将消息和变量值打印到Unity控制台，开发者可以立即了解他们游戏的不同部分是如何运行的。
- en: This can be particularly useful to verify that certain sections of code have
    been reached or to track the values of variables at specific points during gameplay.
    The ability to dynamically output this information without interrupting a game’s
    execution makes `Debug.Log()` an invaluable resource to troubleshoot and refine
    game logic, aiding developers in swiftly identifying and rectifying issues within
    their scripts.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于验证代码的某些部分是否已被执行或追踪游戏过程中特定点的变量值非常有用。能够在不中断游戏执行的情况下动态输出这些信息，使`Debug.Log()`成为调试和优化游戏逻辑的无价资源，帮助开发者迅速识别和纠正脚本中的问题。
- en: Leveraging breakpoints with IDEs
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用IDE中的断点
- en: Leveraging breakpoints within Unity through IDEs such as Visual Studio is an
    indispensable debugging strategy that allows developers to pause game execution
    at specific lines of code. By setting breakpoints, developers can halt the running
    game at critical points, enabling a thorough examination of the current state,
    including variable values, call stacks, and the flow of execution.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 通过IDE（如Visual Studio）利用Unity中的断点是一种不可或缺的调试策略，允许开发者暂停游戏在特定代码行的执行。通过设置断点，开发者可以在关键点停止运行的游戏，从而彻底检查当前状态，包括变量值、调用堆栈和执行流程。
- en: This **pause-and-inspect approach** facilitates a deeper understanding of how
    a game’s logic unfolds in real time, making it easier to pinpoint discrepancies
    and errors. The integration of Unity with powerful IDEs enhances this debugging
    process, providing a seamless environment for developers to dissect and debug
    their game’s code effectively, thereby ensuring smoother development cycles and
    more stable game releases.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这种**暂停并检查**的方法有助于更深入地理解游戏逻辑在实时中的展开方式，使其更容易定位差异和错误。Unity与强大IDE的集成增强了这一调试过程，为开发者提供了一个无缝的环境，以便有效地分解和调试游戏代码，从而确保更平稳的开发周期和更稳定的游戏发布。
- en: Step-by-step execution
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逐步执行
- en: '**Step-by-step execution**, also known as **stepping through code**, is a methodical
    debugging approach that allows developers to advance through their Unity scripts
    one line at a time. This technique provides an opportunity to observe the precise
    behavior of a game’s code under the microscope, revealing how variables change
    and functions are called in sequence.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**逐步执行**，也称为**单步执行代码**，是一种系统性的调试方法，允许开发者逐行前进他们的Unity脚本。这种技术提供了一个机会，可以在显微镜下观察游戏代码的精确行为，揭示变量如何变化以及函数是如何按顺序调用的。'
- en: By carefully analyzing the execution flow in this granular manner, developers
    can uncover the origins of errors and understand the conditions leading up to
    them. Step-by-step execution is particularly effective in isolating and diagnosing
    complex issues that may not be immediately apparent, making it an indispensable
    tool in the debugging arsenal to ensure accuracy and functionality in game development.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式仔细分析执行流程，开发者可以揭示错误的根源并了解导致它们的条件。逐步执行在隔离和诊断可能不会立即显现的复杂问题方面特别有效，使其成为确保游戏开发中准确性和功能性的调试工具库中不可或缺的工具。
- en: Debugging techniques involve identifying and fixing errors in software code,
    often through methods such as step-by-step code execution, using debugging tools,
    and logging. Transitioning to best practices involves adopting systematic approaches,
    such as writing clean and modular code, conducting thorough testing, utilizing
    version control systems, and employing code reviews. Incorporating these practices
    not only enhances the debugging process but also improves overall software quality
    and development efficiency.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 调试技术涉及识别和修复软件代码中的错误，通常通过逐步代码执行、使用调试工具和记录日志等方法。过渡到最佳实践涉及采用系统性的方法，例如编写整洁和模块化的代码、进行彻底的测试、利用版本控制系统以及进行代码审查。采用这些实践不仅增强了调试过程，还提高了整体软件质量和开发效率。
- en: Best practices
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Debugging effectively requires discipline and knowledge. Keep your scripts clean
    and modular for easier error identification. Regularly scan the Console for new
    issues. Remember, debugging is an iterative process. Develop a systematic approach,
    starting with these basics, and dive deeper into advanced techniques later for
    complete mastery.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的调试需要纪律和知识。保持你的脚本整洁和模块化，以便更容易地识别错误。定期扫描控制台以查找新问题。记住，调试是一个迭代的过程。从这些基础知识开始，制定一个系统性的方法，并在以后深入掌握高级技术。
- en: For smoother debugging, keep your scripts lean and well-organized. Break down
    complex tasks into smaller, independent modules. This makes pinpointing issues
    easier, such as identifying a single faulty switch instead of rewiring the esntire
    house. Modular code means faster fixes and less debugging frustration.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更顺畅的调试，请保持你的脚本精简且井然有序。将复杂任务分解成更小、独立的模块。这使得定位问题变得更容易，例如识别单个故障开关而不是重新布线整个房屋。模块化代码意味着更快的修复和更少的调试挫折。
- en: Integrate vigilance into your development routine! Regularly checking the Unity
    Console after tests and code changes becomes your early warning system. Think
    of it as a friendly voice whispering potential issues before they become major
    roadblocks. Those error messages and warnings hold valuable clues, making your
    debugging journey smoother and faster. A quick scan becomes a habit, and a helpful
    habit becomes a debugging superpower.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 将警觉性融入你的开发常规！在测试和代码更改后定期检查Unity控制台成为你的早期预警系统。把它想象成一个友好的声音在问题成为主要障碍之前低声提醒潜在的问题。那些错误信息和警告包含了宝贵的线索，使你的调试之旅更加顺畅和快速。快速扫描变成了一种习惯，而有益的习惯变成了一种调试超级能力。
- en: Unity offers a wealth of resources to illuminate your path. Dive into the official
    documentation ([https://docs.unity3d.com/Manual/index.html](https://docs.unity3d.com/Manual/index.html)),
    your trusted companion, which is brimming with tutorials and solutions for common
    challenges. Explore the vibrant Unity forums ([https://forum.unity.com/](https://forum.unity.com/)),
    where experienced developers share their wisdom and insights. It might be best
    to begin with the *Getting Started* forum, and then navigate to the specific topic
    forum you are researching. Contribute your question, delve into similar cases,
    and harness the collective knowledge.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了丰富的资源来照亮你的道路。深入官方文档([https://docs.unity3d.com/Manual/index.html](https://docs.unity3d.com/Manual/index.html))，你的可靠伴侣，其中充满了教程和常见挑战的解决方案。探索充满活力的Unity论坛([https://forum.unity.com/](https://forum.unity.com/))，经验丰富的开发者在这里分享他们的智慧和见解。最好从*入门*论坛开始，然后导航到你正在研究的特定主题论坛。提出你的问题，深入研究类似案例，并利用集体智慧。
- en: Remember that countless developers have faced similar hurdles before you, and
    the Unity community can be your key to unlocking creative solutions and propelling
    your debugging skills to new heights.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，无数的开发者在你的之前都面临过类似的挑战，Unity社区可以成为你解锁创意解决方案和提升调试技能到新高度的关键。
- en: Summary
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You’ve conquered the foundational C# skills necessary for your Unity development
    journey. This chapter equipped you with the essential building blocks – understanding
    C# syntax and structure, wielding various data types to store information, mastering
    control flow with loops and conditionals, building reusable functions for organized
    code, and finally, gaining the initial tools to fix your C# scripts through basic
    debugging. Remember that practice is your key to mastery. Apply these skills through
    experimentation, and you’ll build a solid C# foundation to create amazing games
    in Unity. In the next section, we’ll learn more about Unity’s provided methods
    and how to use them to craft a game.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经掌握了Unity开发旅程所需的C#基础技能。本章为你提供了必要的构建块——理解C#语法和结构，使用各种数据类型来存储信息，掌握循环和条件语句来控制流程，构建可重用函数以组织代码，最后，通过基本的调试来修复你的C#脚本。记住，实践是掌握的关键。通过实验应用这些技能，你将建立一个坚实的C#基础，以在Unity中创建令人惊叹的游戏。在下一节中，我们将学习更多关于Unity提供的方法以及如何使用它们来制作游戏。
