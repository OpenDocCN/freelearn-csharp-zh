["```cs\nIEnumerator LoadAssetAsync(string assetName)\n{\n    ResourceRequest load =\n      Resources.LoadAsync<GameObject>(assetName);\n    while (!load.isDone)\n    {\n        yield return null; // Yield until the next frame\n    }\n    GameObject loadedAsset = load.asset as GameObject;\n    // Additional logic to utilize the loaded asset\n}\n```", "```cs\nIEnumerator MoveObject(Vector3 start, Vector3 end, float duration)\n{\n    float elapsedTime = 0;\n    while (elapsedTime < duration)\n    {\n        transform.position = Vector3.Lerp(start, end,\n          (elapsedTime / duration));\n        elapsedTime += Time.deltaTime;\n        yield return null;\n    }\n    transform.position = end;\n}\n```", "```cs\nIEnumerator StartDelay(float delay)\n{\n    yield return new WaitForSeconds(delay);\n    // Action to perform after the delay\n    Debug.Log(\"Delay completed\");\n}\n```", "```cs\nIEnumerator CheckGameState()\n{\n    while (true)\n    {\n        switch (currentState)\n        {\n            case GameState.Starting:\n                // Initialize game start routines\n                break;\n            case GameState.Playing:\n                // Handle gameplay logic\n                break;\n            case GameState.Ending:\n                // Clean up after game end\n                yield break; // Exit the coroutine\n        }\n        yield return null; // Wait for the next frame\n    }\n}\n```", "```cs\nCoroutine myCoroutine;\nvoid StartMyCoroutine()\n{\n    if (myCoroutine != null)\n        StopCoroutine(myCoroutine);\n    myCoroutine = StartCoroutine(MyCoroutineMethod());\n}\nvoid StopMyCoroutine()\n{\n    if (myCoroutine != null)\n        StopCoroutine(myCoroutine);\n}\n```", "```cs\nIEnumerator WaitForThenAct()\n{\n    yield return new WaitForFixedUpdate();\n    // Good for physics-related updates\n    // Code here executes after all physics has been processed\n}\n```", "```cs\nusing System.Collections.Generic;\nusing UnityEngine;\npublic class InventoryManager : MonoBehaviour\n{\n    // Dictionary to hold item IDs and their names\n    Dictionary<int, string> inventory = new Dictionary<int,\n       string>();\n    void Start()\n    {\n        // Adding items to the dictionary\n        inventory.Add(1, \"Sword\");\n        inventory.Add(2, \"Shield\");\n        inventory.Add(3, \"Health Potion\");\n        // Displaying an item name by its ID\n        Debug.Log(\"Item with ID 1: \" + inventory[1]);\n    }\n}\n```", "```cs\nusing UnityEngine;\n[System.Serializable]\npublic class PlayerPreferences\n{\n    public float audioVolume;\n    public int brightness;\n    public bool subtitlesEnabled;\n}\npublic class PreferencesManager : MonoBehaviour\n{\n    void Start()\n    {\n        PlayerPreferences prefs = new PlayerPreferences()\n        {\n            audioVolume = 0.8f,\n            brightness = 50,\n            subtitlesEnabled = true\n        };\n        // Serialize the PlayerPreferences object to a JSON string\n        string prefsJson = JsonUtility.ToJson(prefs);\n        Debug.Log(\"Serialized JSON: \" + prefsJson);\n        // Deserialize the JSON string back to a new PlayerPreferences object\n        PlayerPreferences loadedPrefs = JsonUtility\n          .FromJson<PlayerPreferences>(prefsJson);\n        Debug.Log(\"Loaded Preferences: \" + \"Audio Volume - \" + \n                   loadedPrefs.audioVolume +\n                  \", Brightness - \" + loadedPrefs.brightness +\n                  \", Subtitles Enabled - \" + loadedPrefs\n                  .subtitlesEnabled); \n    }\n}\n```", "```cs\n// Define a simple event system\npublic delegate void InputAction(string key);\npublic static event InputAction OnInputReceived;\nvoid Update() {\n    if (Input.GetKeyDown(KeyCode.Space)) {\n        OnInputReceived?.Invoke(\"Space\");\n    }\n}\n// In another class\nvoid OnEnable() {\n    CustomEventManager.OnInputReceived += HandleSpace;\n}\nvoid OnDisable() {\n    CustomEventManager.OnInputReceived -= HandleSpace;\n}\nvoid HandleSpace(string key) {\n    if (key == \"Space\") {\n        // Perform jump\n    }\n}\n```", "```cs\n// Event declaration\npublic delegate void VolumeChange(float newVolume);\npublic static event VolumeChange OnVolumeChanged;\n// Trigger the event when the slider changes\npublic void VolumeSliderChanged(float volume) {\n    OnVolumeChanged?.Invoke(volume);\n}\n// In the audio manager class\nvoid OnEnable() {\n    UIManager.OnVolumeChanged += UpdateVolume;\n}\nvoid OnDisable() {\n    UIManager.OnVolumeChanged -= UpdateVolume;\n}\nvoid UpdateVolume(float volume) {\n    audioSource.volume = volume;\n}\n```", "```cs\n// Define an event for entering a trigger zone\npublic delegate void PlayerTrigger(string zoneID);\npublic static event PlayerTrigger OnPlayerEnterTriggerZone;\nvoid OnTriggerEnter(Collider other) {\n    if (other.CompareTag(\"Player\")) {\n        OnPlayerEnterTriggerZone?.Invoke(this.zoneID);\n    }\n}\n// In the game manager or dialogue system\nvoid OnEnable() {\n    EnvironmentManager.OnPlayerEnterTriggerZone += TriggerDialogue;\n}\nvoid OnDisable() {\n    EnvironmentManager.OnPlayerEnterTriggerZone -= TriggerDialogue;\n}\nvoid TriggerDialogue(string zoneID) {\n    if (zoneID == \"StoryZone\") {\n        // Start specific dialogue\n    }\n}\n```", "```cs\nvoid OnEnable() {\n    EventManager.OnCustomEvent += CustomEventHandler;\n}\nvoid OnDisable() {\n    EventManager.OnCustomEvent -= CustomEventHandler;\n}\n```", "```cs\nvoid CustomEventHandler() {\n    PerformAction();\n    UpdateUI();\n    SaveData();\n    PlaySound();\n    LogEvent();\n    // Multiple actions directly in the event handler\n}\n```", "```cs\nvoid CustomEventHandler() {\n    PerformActions();\n    // Delegates to another method\n}\nvoid PerformActions() {\n    PerformAction();\n    UpdateUI();\n    SaveData();\n    PlaySound();\n    LogEvent();\n}\n```", "```cs\n// Before optimization: Nested loops\nfor (int i = 0; i < array.Length; i++)\n{\n    for (int j = 0; j < array[i].Length; j++)\n    {\n        // Perform operation\n    }\n}\n// After optimization: Single loop\nint arrayWidth = array[0].Length;\n// Assuming all inner arrays have the same length\nint totalElements = array.Length * arrayWidth;\nfor (int k = 0; k < totalElements; k++)\n{\n    int i = k / arrayWidth; // Calculate the row index\n    int j = k % arrayWidth;\n      // Calculate the column index using modulo operation\n    // Perform operation\n}\n```", "```cs\n// Before optimization: Instantiate and destroy objects\nGameObject myObject = Instantiate(prefab, position, rotation);\nDestroy(gameObject);\n// After optimization: Object pooling\nGameObject pooledObject = GetPooledObject();\nif (pooledObject != null)\n{\n    pooledObject.SetActive(true);\n    pooledObject.transform.position = position;\n    pooledObject.transform.rotation = rotation;\n}\n```", "```cs\nusing UnityEngine;\npublic class InvokeSendMessageCoroutineExample :\n             MonoBehaviour\n{\n    void Start()\n    {\n        Invoke(\"DelayedAction\", 2.0f); // Using Invoke\n        StartCoroutine(WaitAndPerformAction(3.0f));\n        // Using Coroutine\n    }\n    void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            SendMessage(„PerformAction\");\n            // Using SendMessage\n        }\n    }\n    void DelayedAction()\n    {\n        Debug.Log(\"Action performed after delay.\");\n    }\n    IEnumerator WaitAndPerformAction(float delay)\n    {\n        yield return new WaitForSeconds(delay); // Waiting\n        Debug.Log(\"Coroutine action performed\n                   after delay.\");\n    }\n    void PerformAction()\n    {\n        Debug.Log(„Action performed via SendMessage.\");\n    }\n}\n```", "```cs\npublic class ObjectPool : MonoBehaviour\n{\n    public GameObject prefab;\n    public int poolSize = 10;\n    private List<GameObject> pooledObjects;\n    private void Start()\n    {\n        pooledObjects = new List<GameObject>();\n        for (int i = 0; i < poolSize; i++)\n        {\n            GameObject obj = Instantiate(prefab);\n            obj.SetActive(false);\n            pooledObjects.Add(obj);\n        }\n    }\n    public GameObject GetPooledObject()\n    {\n        foreach (GameObject obj in pooledObjects)\n        {\n            if (!obj.activeInHierarchy)\n            {\n                obj.SetActive(true);\n                return obj;\n            }\n        }\n        return null;\n    }\n}\n```", "```cs\n// Array for storing enemy positions\nVector3[] enemyPositions = new Vector3[10];\n// Adding enemy positions to the array\nfor (int i = 0; i < enemyPositions.Length; i++)\n{\n    enemyPositions[i] = new Vector3(i * 2, 0, 0); // Example position initialization\n}\n```", "```cs\n// Value type example: int\nint score = 100;\n// Reference type example: object\nGameObject player = Instantiate(playerPrefab);\n```", "```cs\n// Before optimization: Inefficient loop\nforeach (GameObject enemy in enemies)\n{\n    if (enemy.activeSelf)\n    {\n        // Perform resource-intensive operation\n    }\n}\n// After optimization: Skip inactive enemies\nforeach (GameObject enemy in enemies)\n{\n    if (!enemy.activeSelf)\n    {\n        continue;\n    }\n    // Perform resource-intensive operation\n}\n```"]