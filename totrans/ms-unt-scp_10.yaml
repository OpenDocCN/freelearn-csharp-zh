- en: Chapter 10. Source Control and Other Tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter considers three main tips and tricks to script in C# or to work
    with scripts. These tips are themselves powerful and important but do not belong
    squarely in any of the previous chapters, which are divided mainly by subject
    matter. The tips are listed here in no particular order and their main justification
    for inclusion is based largely on their usefulness, and also because their documentation
    elsewhere is sparse and often inconclusive. Consequently, this chapter reads as
    a useful collection of did-you-know tips and tricks, which taken together, offer
    knowledge that is substantial and practical. The three tips cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Git revision control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource folders and externals files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and saving games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git – source control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **source control** or **revision control** refers to any software aimed
    at making development in practice both simpler and safer for as many people as
    possible. In short, it allows you to track and undo changes to your files easily
    and quickly, as well as share these changes with others. Typically, software development
    (including game development) relies on two important facts or ingredients. First,
    it’s a collective effort where multiple developers work together as part of a
    team, either at the same physical location (such as an office) or across distant
    locations but sharing a virtual space (such as a virtual office, forum, or even
    e-mail). Second, during development, developers will tweak, edit, and make improvements
    to the source code. From these two seemingly simple facts comes a range of important
    needs that revision control aims to satisfy.
  prefs: []
  type: TYPE_NORMAL
- en: 'These needs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collaboration**: When multiple developers work on coding the same project,
    they’ll usually need to share source files. They can send them back and forth
    through e-mail or other manual methods, but this makes coding difficult on a large
    scale and on long-term projects. It quickly becomes difficult to monitor the code
    changes over time and integrate or merge two sets of changes into one file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverting**: Sometimes, code changes and improvements turn out to be mistaken.
    A proposed edit or fix doesn’t always have the intended outcome and must be undone
    or reverted to the earlier state. You can keep copies of the earlier files yourself,
    but maintaining potentially many copies over time will be tedious and unnecessarily
    confusing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracking changes and histories**: Often, you’ll need to keep track of who
    does what, especially when debugging. If someone makes a code edit, you’ll want
    to know who changed the code, why, and when. Again, you could manually maintain
    a logfile, writing in comments and entries to document the changed process, but
    this would be tedious and time consuming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revision control aims to solve the three main problems of collaboration, reversion,
    and tracking changes. Revision control software includes Git, Perforce, Microsoft
    Team Foundation Server, and others. This chapter specifically considers Git; it
    is widely used, free, cross-platform, and open source. Using Git, you can begin
    by configuring a special database, known as a **repository**, which can be either
    local (on your computer) or remote (via a network). Then, once configured, you
    can track and maintain all and any changes to your Unity projects, allowing you
    to revert to the earlier states of your project, if needed, and to share or collaborate
    with others. Let’s see how to configure Git for general use using a graphical
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step #1 – downloading'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to get up and running with Git for Unity projects. This
    chapter explores a combination of the official Git package alongside the frontend
    TortoiseGit. Using these two packages, developers can track and maintain all changes
    to their projects, whether working alone or in a team.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, download and install the official Git software, which is available
    at [http://git-scm.com/](http://git-scm.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #1 – downloading](img/0655OT_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Downloading and installing Git
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Detailed information on using Git can be found in the free, online e-book, *Pro
    Git*, *Scott Chacon and Ben Straub*, *Apress*, available at [http://git-scm.com/book/en/v2](http://git-scm.com/book/en/v2).
  prefs: []
  type: TYPE_NORMAL
- en: After Git is installed and downloaded, it’s useful to get TortoiseGit. This
    is not part of the original Git package but is an optional frontend component
    for Windows, which it allows you to integrate Git with the Windows shell as well
    as interact with Git through a GUI rather than the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download and install TortoiseGit, go to [https://code.google.com/p/tortoisegit/](https://code.google.com/p/tortoisegit/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #1 – downloading](img/0655OT_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Downloading and installing TortoiseGit
  prefs: []
  type: TYPE_NORMAL
- en: 'Step #2 – building a Unity project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reason to install Git originally was to track and maintain changes to a
    Unity project, allowing you to revert them if needed, acting as a backup version
    in case anything happens to the original files, and to share changes with other
    developers. This depends, therefore, on whether you already have a Unity project
    to maintain. The next step, then, after installing both Git and TortoiseGit is
    to either create a new Unity project or to find an existing one that should be
    tracked. The following is the screenshot of the Unity project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #2 – building a Unity project](img/0655OT_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing a Unity project folder
  prefs: []
  type: TYPE_NORMAL
- en: 'After finding a Unity project, open the project folder in Windows explorer
    to see the project files. If you don’t know or don’t remember the location of
    the folder, you could open it directly in explorer from the Unity Editor interface.
    To achieve this, right-click inside the Unity **Project** panel and select **Show
    in Explorer** from the context menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #2 – building a Unity project](img/0655OT_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing the project folder from the Unity interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Step #3 – configuring Unity for source control'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git works with both binary and text files, but it works best with text files.
    When working with Unity, the editor generates many metadata files for your project
    and the assets you import. By default, these files are hidden and are in a binary
    form, and they exist inside the Unity project folder. Some of the generated metafiles
    are specific only to the instance of Unity that runs on your computer, such as
    interface preferences, while other files pertain to assets and data that are part
    of the project, such as meshes, textures, and script files. To get the best results
    from Git, you’ll need to adjust Unity’s default behavior by making metafiles visible
    in the **Project** explorer, and also using text-based formats as opposed to binary
    formats. To achieve this, go to **Edit** | **Project Settings** | **Editor** from
    the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, use the object inspector to set the **Version Control** field to
    **Visible Meta Files** and the **Asset Serialization** field to **Force Text**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #3 – configuring Unity for source control](img/0655OT_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring Unity for version control
  prefs: []
  type: TYPE_NORMAL
- en: 'When these settings are changed, you will see a `.meta` file associated with
    each project asset, including scenes. In addition, the metafile will be in a human-readable
    text format, which can even be edited (though manual editing is not recommended).
    Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #3 – configuring Unity for source control](img/0655OT_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing a scene asset (in text format) inside a text editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Step #4 – creating a Git repository'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next phase, after creating and configuring a Unity project, is to create
    the Git database or repository itself that will track and maintain all changes
    to the Unity files. The repository can be either remote (hosted on a network or
    external computer) or local (hosted on the same computer). The repository will
    retain the original files and all the changes done to them over time, allowing
    you to revert to earlier versions of files, if required. The repository can also
    be shared and merged with other repositories for file sharing. This chapter considers
    only local repositories, so let’s create one now. To do this, open the Unity project
    folder (the root folder) and then right-click to show the Windows context menu.
    From the menu, choose **Git Init Here**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #4 – creating a Git repository](img/0655OT_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Git repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, a new and hidden folder named `.git` will be generated. This
    folder features all the repository files for the project. The icons for files
    and folders will change to default red symbols, indicating that the files inside
    the project folder have not yet been added to the repository, so Git cannot track
    changes made to them (we’ll deal with this soon). This is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #4 – creating a Git repository](img/0655OT_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Folders highlighted in red contain files not included in the Git repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Step #5 – ignoring files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Git repository is now created, ready to receive its first set of files
    (a *commit*). However, before adding them, there are some specific files and types
    that can safely be ignored. Unity features some project or system-specific files
    that are less project critical than user critical; that is, some files always
    contain only user interface preferences as well as read-only files, or temps,
    and other specific data that need not be added to the repository and can be safely
    ignored. To ignore these, we can create a `.gitignore` text file inside the project’s
    root folder and list all the files and folders to be ignored, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #5 – ignoring files](img/0655OT_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Git ignore file to exclude specific file types from the repository
  prefs: []
  type: TYPE_NORMAL
- en: 'For Unity, this file (`.gitignore`) should look as follows. Be sure to put
    the file inside the root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Step #6 – creating the first commit'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The repository is now configured to receive the first set of Unity project files.
    To add these, right-click inside the root folder window, and from the context
    menu, go to **Git Commit** | **Master**. In Git, files are typically submitted
    not one by one but in batches. The **Commit** window allows you to select all
    files to commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **All** button to select all files in the folder and then assign
    a description in the **Message** field to the commit. The message should allow
    any user to understand the files that the commit contains. When ready, click on
    **OK** to commit the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #6 – creating the first commit](img/0655OT_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Submitting the original project files
  prefs: []
  type: TYPE_NORMAL
- en: 'When the commit is completed, the file icons will turn green to indicate a
    file match, that is, to indicate that the files in the project folder are identical
    to those in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #6 – creating the first commit](img/0655OT_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Files are up to date with the repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Step #7 – changing files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git is supposed to be a complete file-tracking solution; this means that it
    should store not only your original files but all the subsequent changes and edits,
    allowing you to revert to any previous version.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now return to Unity and change your files, adding new assets or editing
    the existing ones, the file icons inside the Windows explorer change to red again,
    indicating a mismatch between the local files and the repository files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #7 – changing files](img/0655OT_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Changing files
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide that your most recent changes were a mistake and you’d like to
    revert back to the changes made last, you can do this by right-clicking inside
    the project folder window and going to **TortoiseGit** | **Revert...** from the
    context menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #7 – changing files](img/0655OT_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reverting (undoing) recent changes
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Revert** dialog will show, allowing you to select files for reversion.
    Select all the required files and then choose **OK**. Git will then restore all
    the selected files, overwriting the local versions with the latest versions from
    the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #7 – changing files](img/0655OT_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select files to revert
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you might not want to revert or undo the recent changes.
    Instead, you might have created a valid change; this should be added to the Git
    repo as the latest version of the files. If so, then simply recommit the files.
    Right-click inside the project folder window and, from the context menu, go to
    **Git Commit** | **Master**. Be sure to enter a new and descriptive message for
    the commit inside the **Message** field of the **Commit** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step #8 – getting files from the repo'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the original commit of all the files has been made, if you were to delete
    every file in the Unity folder either intentionally or accidentally, except for
    the `.git` and `.gitignore` files, you could still retrieve all the latest files
    again. This is because the Git repo contains the files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #8 – getting files from the repo](img/0655OT_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can retrieve deleted files in the project folder from the Git repo
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, if you are really following along with the book by deleting your
    own files, make sure to keep a manual backup of them, in case anything goes wrong
    during testing!
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, right-click inside the project folder window and navigate
    to **TortoiseGit** | **Switch/Checkout** from the context menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #8 – getting files from the repo](img/0655OT_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Switch/Checkout option to retrieve the latest files from the repo
  prefs: []
  type: TYPE_NORMAL
- en: From the **Switch/Checkout** dialog, select the **Master** branch for the **Switch
    To** field.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also need to enable the **Force** check from the options (see the
    documentation for more details). Then, click on **OK** to retrieve the latest
    files. You will see the following screenshot once all the files are retrieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #8 – getting files from the repo](img/0655OT_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Retrieving the latest files with checkout
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you might want to switch your project back to an earlier commit
    in the repo, retrieving not the latest files, but an earlier commit instead. To
    do this, first go to **Tortoise Git** | **Switch /Checkout** from the context
    menu to show the **Checkout** dialog. Then, from the **Switch To** group, enable
    the **Commit** radio box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #8 – getting files from the repo](img/0655OT_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enabling the Commit radio button to retrieve older commits
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the browse button (**…**) next to the **Commit** field to display the
    repo commits available, and select the earlier version to switch to. Then, click
    on **OK** to exit the **Repo Commits** dialog, and click on **OK** again to confirm
    the checkout from the selected commit. The files from the selected commit will
    then be restored to the project folder. Remember that each commit has an author
    (for those working in teams), and this lets you get a picture of who has changed
    what:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #8 – getting files from the repo](img/0655OT_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting older commits from the repo to restore
  prefs: []
  type: TYPE_NORMAL
- en: 'Step #9 – browsing the repo'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you’ll want to neither add nor retrieve files from the repository,
    but simply browse them to see what is there. You can do this quickly and easily
    using the Repo Browser tool, which is part of TortoiseGit. To access the tool,
    go to **TortoiseGit** | **Repo Browser** from the context menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #9 – browsing the repo](img/0655OT_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: View the Repo Browser tool
  prefs: []
  type: TYPE_NORMAL
- en: 'The Repo Browser tool allows you to preview the files and hierarchy from a
    GUI window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step #9 – browsing the repo](img/0655OT_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Examining the files inside the repo
  prefs: []
  type: TYPE_NORMAL
- en: Resources folder and external files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your games will frequently rely on external data loaded from files such as
    XML files, perhaps, for subtitles, localization, or level serialization. Have
    a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resources folder and external files](img/0655OT_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Printing a message loaded from an external text file asset that will compile
    with the project
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, you want a specific range of abilities. The first one is the
    ability to dynamically load data from the file into memory in a way that Unity
    can parse and understand. The second is the ability to change and edit the file
    contents, even after importing it into Unity, and then have the effects of the
    changes update in the game without requiring code changes. The third is the ability
    to compile and distribute your standalone game with the file included as part
    of the main Unity build, rather than as a separate and editable file alongside
    the main executable. To elaborate further on the third point, you don’t usually
    want to distribute your game as a standalone build alongside separate and external
    files, such as XML files, which can be opened and edited by the gamer. Instead,
    as the developer, you want to edit and change the files from the Unity Editor,
    and you want the files themselves to be compiled and built into your final Unity
    standalone project, like other assets. You can achieve this using resource folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use resource folders, create a folder named `resources` in the Unity project.
    A project can feature none, one, or more `resources` folders. Inside the folder,
    add all assets, such as text files that can be loaded by Unity at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resources folder and external files](img/0655OT_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding external files to the resources folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a file is added to the `resources` folder, you can load it into memory
    with the `Resources.Load` function. See the following code sample 10-1, which
    loads a sample text asset into a UI text component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on resource folders and the `Resources` class is available
    in the online Unity documentation at [http://docs.unity3d.com/ScriptReference/Resources.html](http://docs.unity3d.com/ScriptReference/Resources.html).
  prefs: []
  type: TYPE_NORMAL
- en: AssetBundles and external files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’re using Unity Pro and want to offer dynamic content to users, allowing
    gamers to **modify** (**mod**) game content, add their own assets, and add-ons,
    as well as support your own add-ons and plugins, then AssetBundles can be useful.
    AssetBundles let you package together many disparate Unity assets into a single,
    external file outside the main project, which can be loaded into any Unity project
    dynamically, either from a local file on disk or via the Internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AssetBundles and external files](img/0655OT_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building AssetBundles from selected assets
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, import the Unity asset bundle editor script to build AssetBundles
    easily from the **Project** panel. To do this, paste the following code sample
    10-2 into a C# script file located inside an `Editor` folder in your project;
    otherwise, you can download the script from: [http://docs.unity3d.com/ScriptReference/BuildPipeline.BuildAssetBundle.html](http://docs.unity3d.com/ScriptReference/BuildPipeline.BuildAssetBundle.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To make an AssetBundle, select all the assets in the **Project** panel to be
    included in the bundle and then go to **Assets** | **Build AssetBundle from Selection**
    from the menu bar. Once selected, choose a location on your computer where the
    bundle should be saved.
  prefs: []
  type: TYPE_NORMAL
- en: '![AssetBundles and external files](img/0655OT_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting assets to be included in an AssetBundle
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to test the AssetBundle, create a new project or open a different project
    without the assets, and you can load them into your project at runtime using the
    `WWW` class. See the following code sample 10-3 for a sample script that downloads
    an AssetBundle from a local file, extracts a texture asset, and assigns it to
    the material of an attached mesh renderer component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the texture asset will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AssetBundles and external files](img/0655OT_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Loading a texture asset from an AssetBundle onto a mesh renderer
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on AssetBundles can be found in the online Unity documentation
    at [http://docs.unity3d.com/Manual/AssetBundlesIntro.html](http://docs.unity3d.com/Manual/AssetBundlesIntro.html).
  prefs: []
  type: TYPE_NORMAL
- en: Persistent data and saved games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allowing the gamer to save and load the state of their game is important for
    many games, especially longer duration games such as adventures, real-time strategies,
    and RPGs. In these cases, the game should allow the user to save and load game
    data to and from external files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is achieved in Unity using data serialization via either XML or binary
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistent data and saved games](img/0655OT_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Saving the Transform properties of an object to an XML file
  prefs: []
  type: TYPE_NORMAL
- en: '**Serialization** is the process of converting, or translating, data in memory
    (such as the state of a component on a `GameObject`) into a stream that can be
    written to a file and then loaded back from a file to recreate the component in
    memory, as it was when it was saved. The process of creating a save-game, therefore,
    is about first deciding which data must be saved and loaded (which is game specific)
    and then creating a new class to hold that data. Consider the following code sample
    10-4 (`ObjSerializer.cs`) that can be attached to any `GameObject` to serialize
    its Transform component (Translation, Rotation, and Scale) to and from an external
    file, both in the XML and binary formats. To achieve this, the `XmlSerializer`
    class is used to convert an object in memory to XML, and the BinaryFormatter converts
    an object in memory to a binary file. XML files are human-readable text files,
    while binary files cannot normally be read or understood by humans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A full example of loading and saving game data can be found in the book’s companion
    files in the `Chapter10/XML_and_Binary` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final chapter considered three main tips of which, perhaps, the only underlying
    theme has been file management. The first tip considered Git version control,
    specifically, how the free and open source version control software allows us
    to track changes across a project as well as collaborate easily with other developers.
    The second tip concerned loading file data dynamically, first using internal project
    files inside a `resources` folder and then using AssetBundles. The latter options
    are especially useful for the creation of external assets that can be edited by
    both developers and gamers alike. The third and final tip demonstrated how in-game
    data can be saved to a file and then loaded back through serialization. Through
    serialization, users can save and restore game data, allowing them to resume playback
    at a later time.
  prefs: []
  type: TYPE_NORMAL
