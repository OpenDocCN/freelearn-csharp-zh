<html><head></head><body>
		<div id="_idContainer044">
			<h1 id="_idParaDest-132" class="chapter-number"><a id="_idTextAnchor196"/>12</h1>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor197"/>Go Beyond Inheritance</h1>
			<p>With object-oriented languages such as C#, we can derive our types from other types and we can also implement contracts (interfaces) and make them fulfill that contract. Implementing interfaces and making an implementation fulfill these is really one of the great things about a type-safe language. With the compiler, we get everything checked to make sure we implement the contract, while at runtime, we can leverage the interface type to be a representation rather than having to know the <span class="No-Break">actual implementor.</span></p>
			<p>Sometimes, however, the verbosity of having to implement an interface can be too much. It can also be limited to what you’re trying <span class="No-Break">to achieve.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Method <span class="No-Break">signature conventions</span></li>
				<li>By the end of the chapter, you will have an idea of how conventions can let you go beyond having to inherit from a base type or an interface and how that sometimes caters to a cleaner <span class="No-Break">code base.</span></li>
			</ul>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor198"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12</a>) and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor199"/>Method signature conventions</h1>
			<p>Coming up with good <a id="_idIndexMarker433"/>examples to do a home run on a topic for a book can be very hard. For this chapter, I’ve decided to go with something that is part of my <span class="No-Break">day-to-day job.</span></p>
			<p>I work with a platform that is centered around event-driven architecture, or more specifically, with event sourcing. This topic might be unfamiliar to you, so let’s dive into what this specifically is, to give you <span class="No-Break">the context.</span></p>
			<p>In traditional <strong class="bo d">CRUD</strong> (short for <strong class="bo d">Create, Read, Update, Delete</strong>) systems, the primary focus is on the concrete data that is<a id="_idIndexMarker434"/> commonly stored in a relational or document database. These systems revolve around the four fundamental operations – creating new records, retrieving existing records, updating records, and <span class="No-Break">deleting records.</span></p>
			<p>The data in such systems represents the outcome of a user’s actions, and the system’s flow typically follows a one-to-one mapping from the user’s input form to the database. However, this approach to software development has a significant drawback – it only captures the effect and not <span class="No-Break">the cause.</span></p>
			<p>With event sourcing, the effect is less important, and it’s all about capturing what caused the effect. The cause captures how we got to the conclusion, as shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B19418_12_01.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Capturing the cause</p>
			<p>The cause is <a id="_idIndexMarker435"/>what is known as an event – something that happened in the system. We capture these by giving them a clear name, and we store them in the sequence in which they occur. The events are never deleted. All events are stored in what is referred to as<a id="_idIndexMarker436"/> an <strong class="bo d">event store</strong>. There are technologies out there that specialize in this, such as the platform I’m working on, called <span class="No-Break">Cratis (</span><a href="https://cratis.io"><span class="No-Break">https://cratis.io</span></a><span class="No-Break">),</span>
but <a id="_idIndexMarker437"/>you could also use any database and do <span class="No-Break">this yourself.</span></p>
			<p>By prioritizing the capturing of events, we gain the ability to control how the effects are presented. This is achieved by extracting relevant information from various event types as they occur and then converting it into specialized objects for easy access. These objects are typically stored in conventional data stores such as relational or document databases, which allow for the efficient querying of the <span class="No-Break">end result.</span></p>
			<p>One major advantage of this approach is that the event store becomes the source of truth in the system rather than relying solely on traditional data stores. This means that modifying how data is represented becomes significantly easier, as you can simply replay the relevant events when implementing changes. You can also decide to have multiple representations, catering to special needs within a system. This could then have a huge performance benefit, as well as clarity in code, and avoiding tension often seen in developing systems where one shares the same data <span class="No-Break">and objects.</span></p>
			<p>The following figure shows an imaginary bank system with events being produced and how they are projected down to materialized objects, referred to as read models. It also shows the relationship with other systems or other microservices in a microservice-centric architecture by projecting to events that can be communicated outside of the bounds of the <span class="No-Break">system-producing events.</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B19418_12_02.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Imaginary bank system with events produced</p>
			<p>The<a id="_idIndexMarker438"/> observer is a key element of this architecture. They are the ones responsible for observing the events as they occur and creating an effect. For the most part, the effect comes in the form of a projection to a read model that is stored, but it could also perform other tasks such as sending emails or, in fact, append new events as the consequence of an analysis the <span class="No-Break">observer performs.</span></p>
			<p>It’s these observers that we want to bring forward as an example in this chapter. Let’s narrow it down to a pipeline that looks like the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B19418_12_03.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Logical pipeline</p>
			<p>A command <a id="_idIndexMarker439"/>represents something the user desires, an action to be performed. The action typically would then decide what event, or possibly multiple events, it should generate. This is appended to the main event log within the event store. The event log is the event sequence that holds all the events in the order they occurred, with an incremental <span class="No-Break">sequence number.</span></p>
			<p>Once the event is in the event log, we want to notify all the interested observers that the event has been appended and they <span class="No-Break">should react.</span></p>
			<p>The following figure shows more concretely what we want to accomplish and will be the basis of the example in <span class="No-Break">this chapter.</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B19418_12_04.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Concrete pipeline</p>
			<p>In order to be able to do this, you’re going to need some infrastructure that will give you <span class="No-Break">the convention<a id="_idTextAnchor200"/>s.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor201"/>Infrastructure</h1>
			<p>Let’s create a bare foundation of what’s<a id="_idIndexMarker440"/> needed for having observers that can respond to events <span class="No-Break">being appended.</span></p>
			<p>Let’s create a folder called <strong class="source-in ine">Chapter12</strong> at the root of your repository. Change into this folder in your command-line interface and create a new <span class="No-Break">console project:</span></p>
			<pre class="source-code">
dotnet new console</pre>
			<p>You’re going to make use of the Microsoft hosting model to get the .NET default service provider without spinning up a web application. To achieve this, you’ll need the package called <strong class="source-in ine">Microsoft.Extensions.Hosting</strong>. In the terminal, you’d add the reference by doing <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet add package Microsoft.Extensions.Hosting</pre>
			<p>The next thing you’ll need to do is to reference the <strong class="source-in ine">Fundamentals</strong> project. In the terminal, do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet add reference ../Fundamentals/Fundamentals.csproj</pre>
			<p>As I discussed in <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, one of the things I do in all my code is to formalize types rather than use primitives. This makes the APIs much clearer and also helps <span class="No-Break">avoid mistakes.</span></p>
			<p>You’re going to be using <strong class="source-in ine">ConceptAs&lt;&gt;</strong> to formalize <span class="No-Break">the types.</span></p>
			<p>Inside the <strong class="source-in ine">Chapter12</strong> folder, create a folder dedicated to the <strong class="source-in ine">EventSourcing</strong> infrastructure, and call this <span class="No-Break">folder </span><span class="No-Break"><strong class="source-in ine">EventSourcing</strong></span><span class="No-Break">.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">EventSourceId.cs</strong> and make it look<a id="_idIndexMarker441"/> like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using Fundamentals;
namespace EventSourcing;
public record EventSourceId(string Value) :
  ConceptAs&lt;string&gt;(Value)
{
    public static EventSourceId New() =&gt;
      new(Guid.NewGuid().ToString());
}</pre>
			<p>The <strong class="source-in ine">EventSourceId</strong> concept represents the unique identifier of the source of events. In domain modeling, this is typically the identifier of an object, a noun, in your domain. An example of this could be the unique identifier of a bank account or the unique identifier of a person in the system. The <strong class="source-in ine">EventSourceId</strong> code sets up <strong class="source-in ine">ConceptAs&lt;&gt;</strong> for this and makes the inner value a string, enabling basically any representation of a unique identifier. It adds a convenient method for creating a new <strong class="source-in ine">EventSourceId</strong> by leveraging <strong class="source-in ine">Guid</strong>, which can then generate a unique identifier on the fly. You’ll be using <strong class="source-in ine">EventSourceId</strong> later and it should become clearer why <span class="No-Break">it’s needed.</span></p>
			<p>When appending an event to a sequence of events, as we discussed earlier, every event gets a sequence number. This is an incremental number that increases by 1 for every event added. Let’s <a id="_idIndexMarker442"/>formalize a type that represents <span class="No-Break">this number.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">EventSequenceNumber.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using Fundamentals;
namespace EventSourcing;
public record EventSequenceNumber(ulong Value) :
  ConceptAs&lt;ulong&gt;(Value)
{
    public static implicit operator
      EventSequenceNumber(ulong value) =&gt; new(value);
}</pre>
			<p>The code introduces a concrete type for <strong class="source-in ine">EventSequenceNumber</strong> that is <strong class="source-in ine">ConceptAs&lt;&gt;</strong> with its inner value of the <strong class="source-in ine">ulong</strong> type. With <strong class="source-in ine">ulong</strong>, you get a full 64-bit value and this should most likely be more than sufficient as an incremental sequence number. For convenience, there is also an implicit operator that can convert <strong class="source-in ine">ulong</strong> to the encapsulated <span class="No-Break"><strong class="source-in ine">EventSequenceNumber</strong></span><span class="No-Break"> type.</span></p>
			<p>For the observers that you’ll be adding later, you’ll be marking them with an attribute to indicate they are an observer. An alternative to this would be to use an empty interface. The point of this is just to be able to mark a type, making it possible <span class="No-Break">to discover.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">ObserverAttribute.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace EventSourcing;
[AttributeUsage(AttributeTargets.Class, AllowMultiple =
  false)]
public sealed class ObserverAttribute : Attribute
{
}</pre>
			<p>The code introduces an attribute that can be added <span class="No-Break">to classes.</span></p>
			<p>For the observer methods, you typically find the information related to the event in addition to the actual <a id="_idIndexMarker443"/>event itself. The type of information you want to know is the <strong class="source-in ine">EventSourceId</strong>, <strong class="source-in ine">EventSequenceNumber</strong>, and when the event occurred. We call <span class="No-Break">this </span><span class="No-Break"><strong class="source-in ine">EventContext</strong></span><span class="No-Break">.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">EventContext.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace EventSourcing;
public record EventContext(
    EventSourceId EventSourceId,
    EventSequenceNumber SequenceNumber,
    DateTimeOffset Occurred);</pre>
			<p>The code holds <strong class="source-in ine">EventSourceId</strong>, <strong class="source-in ine">SequenceNumber</strong>, and <strong class="source-in ine">Occurred</strong> in the form of <strong class="source-in ine">DateTimeOffset</strong>. In a full event-sourced system, we would typically hold more details, but this will suffice for <span class="No-Break">this example.</span></p>
			<p>For the events to be discoverable and classified as events, you’re going to need a building block in <span class="No-Break">the infrastructure.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">IEvent.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace EventSourcing;
public interface IEvent { }</pre>
			<p>Now comes the juicy <a id="_idIndexMarker444"/>part: the code that will discover methods on a type that matches <span class="No-Break">certain criteria.</span></p>
			<p>The convention we’re looking for is one that allows for two base method signatures and two variants of these, supporting both synchronous and <span class="No-Break">asynchronous models.</span></p>
			<p>The synchronous signatures are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
void &lt;name-of-method&gt;(YourEventType @event);
void &lt;name-of-method&gt;(YourEventType @event, EventContext
  context);</pre>
			<p>And then the asynchronous signatures are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Task &lt;name-of-method&gt;(YourEventType @event);
Task &lt;name-of-method&gt;(YourEventType @event, EventContext
  context);</pre>
			<p>As you can see, the convention does not care about the name of the method but only the parameters and return types. This gives flexibility to the developer in creating more precise named methods and increases the readability and maintainability of the code, something regular inheritance wouldn’t <span class="No-Break">allow for.</span></p>
			<p>Let’s create a system that enables calling the methods <span class="No-Break">by convention.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">ObserverHandler.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using System.Reflection;
namespace EventSourcing;
public class ObserverHandler
{
    readonly Dictionary&lt;Type, IEnumerable&lt;MethodInfo&gt;&gt;
      _methodsByEventType;
    readonly IServiceProvider _serviceProvider;
    readonly Type _targetType;
    public IEnumerable&lt;Type&gt; EventTypes =&gt;
      _methodsByEventType.Keys;
    public ObserverHandler(IServiceProvider
      serviceProvider, Type targetType)
    {
        _serviceProvider = serviceProvider;
        _targetType = targetType;
        _methodsByEventType =
          targetType.GetMethods(BindingFlags.Instance |
          BindingFlags.NonPublic | BindingFlags.Public)
                                        .Where(_ =&gt;
                                      IsObservingMethod(_))
                                        .GroupBy(_ =&gt;
                                      _.GetParameters()[0].
                                      ParameterType)
                                        .ToDictionary(_ =&gt;
                                      _.Key, _ =&gt;
                                      _.ToArray()
                                      .AsEnumerable());
    }
}</pre>
			<p>The code sets up the basis for the <strong class="source-in ine">ObserverHandler</strong> class. The constructor takes two parameters, <strong class="source-in ine">serviceProvider</strong> and <strong class="source-in ine">targetType</strong>. The <strong class="source-in ine">serviceProvider</strong> parameter will be used to get instances of <strong class="source-in ine">targetType</strong> representing the observer when an event needs to be handled. Within the constructor, the code uses reflection to look for instance methods, both <a id="_idIndexMarker445"/>public and <span class="No-Break">non-public methods.</span></p>
			<p>It then filters down the methods by those matching the signature with a method called <strong class="source-in ine">IsObservingMethod()</strong>, which you’ll be adding next. Then it groups it by the first parameter on the method, which is the event type, and creates a dictionary enabling <span class="No-Break">fast lookup.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Notice the <strong class="source-in ine">EventTypes</strong> property that is added; this exposes what event types the handler supports, and this will come in <span class="No-Break">handy later.</span></p>
			<p>In the LINQ query, it uses the <strong class="source-in ine">IsObservingMethod()</strong> method, which is a method that should be inside the <strong class="source-in ine">ObserverHandler</strong> class. Add the following private method at the bottom of the <span class="No-Break"><strong class="source-in ine">ObserverHandler</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
bool IsObservingMethod(MethodInfo methodInfo)
{
    var isObservingMethod =
      methodInfo.ReturnType.IsAssignableTo(typeof(Task)) ||
                            methodInfo.ReturnType ==
                              typeof(void);
    if (!isObservingMethod) return false;
    var parameters = methodInfo.GetParameters();
    if (parameters.Length &gt;= 1)
    {
        isObservingMethod = parameters[0]
          .ParameterType.IsAssignableTo(typeof(IEvent));
        if (parameters.Length == 2)
        {
            isObservingMethod &amp;= parameters[1]
              .ParameterType == typeof(EventContext);
        }
        else if (parameters.Length &gt; 2)
        {
            isObservingMethod = false;
        }
        return isObservingMethod;
    }
    return false;
}</pre>
			<p>To identify allowed signatures, the code examines <strong class="source-in ine">MethodInfo</strong> and begins by recognizing the permitted return types, which are <strong class="source-in ine">Task</strong> or <strong class="source-in ine">void</strong>. If the return type is anything other than a valid observing method, it will be considered invalid. The code then proceeds to examine the parameters of the method. If the method has one parameter and its type <a id="_idIndexMarker446"/>implements the <strong class="source-in ine">IEvent</strong> interface, it qualifies as an observing method. Alternatively, if the method has two parameters and the first parameter type implements <strong class="source-in ine">IEvent</strong>, and the second parameter type is <strong class="source-in ine">EventContext</strong>, then it is also classified as an <span class="No-Break">observing method.</span></p>
			<p>With the <a id="_idIndexMarker447"/>discovery part in place, all you need is a method that understands the convention and can invoke the method on <span class="No-Break">the observer.</span></p>
			<p>In the <strong class="source-in ine">ObserverHandler</strong> class, add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
public async Task OnNext(IEvent @event, EventContext
  context)
{
    var eventType = @event.GetType();
    if (_methodsByEventType.ContainsKey(eventType))
    {
        var actualObserver =
          _serviceProvider.GetService(_targetType);
        Task returnValue;
        foreach (var method in
          _methodsByEventType[eventType])
        {
            var parameters = method.GetParameters();
            if (parameters.Length == 2)
            {
                returnValue =
                  (Task)method.Invoke(actualObserver, new
                  object[] { @event, context })!;
            }
            else
            {
                returnValue =
                  (Task)method.Invoke(actualObserver, new
                  object[] { @event })!;
            }
            if (returnValue is not null) await returnValue;
        }
    }
}</pre>
			<p>The <strong class="source-in ine">OnNext()</strong> method<a id="_idIndexMarker448"/> is responsible for doing the call to the observer; it does so by taking an event of any type implementing the <strong class="source-in ine">IEvent</strong> interface and <strong class="source-in ine">EventContext</strong> for the event. From this, it finds the method in <strong class="source-in ine">_methodsByEventType</strong> populated in the constructor based on the type of event supported by the observer. If it is supported, it goes on to get an instance of the observer type by using the service provider. For each method, it invokes based on the correct signature for the method and if the method is asynchronous, it will await <span class="No-Break"><strong class="source-in ine">Task</strong></span><span class="No-Break"> returned.</span></p>
			<p>With the concrete handler that handles the invocation, you’re going to need a service that knows about all the observers and can call the correct ones when an <span class="No-Break">event occurs.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">IObservers.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace EventSourcing;
public interface IObservers
{
    Task OnNext(IEvent @event, EventContext context);
}</pre>
			<p>The code<a id="_idIndexMarker449"/> represents the contract for <strong class="source-in ine">IObservers</strong>. The <strong class="source-in ine">OnNext()</strong> method will be the method called by the system that knows when events <span class="No-Break">have occurred.</span></p>
			<p>You’re going to need an implementation of <span class="No-Break">this interface.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">Observers.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using System.Reflection;
using Fundamentals;
namespace EventSourcing;
[Singleton]
public class Observers : IObservers
{
    readonly IEnumerable&lt;ObserverHandler&gt; _handlers;
    public Observers(ITypes types, IServiceProvider
      serviceProvider)
    {
        _handlers = types.All.Where(_ =&gt;
          _.HasAttribute&lt;ObserverAttribute&gt;())
                            .Select(_ =&gt;
                            {
                                var observer =
                                  _.GetCustomAttribute
                                  &lt;ObserverAttribute&gt;()!;
                                return new
                                  ObserverHandler(
                                  serviceProvider, _);
                            });
    }
}</pre>
			<p>The code leverages <strong class="source-in ine">ITypes</strong> from fundamentals for discovery. The code scans through all the types and filters out those that do not have <strong class="source-in ine">ObserverAttribute</strong>, leaving only the types that do have it. For every type that has the <strong class="source-in ine">ObserverAttribute</strong>, it then creates an instance of <strong class="source-in ine">ObserverHandler</strong> by passing in <strong class="source-in ine">serviceProvider</strong> and the target type, which is the <span class="No-Break">observer itself.</span></p>
			<p>For invoking the handler, you need an implementation of the <strong class="source-in ine">OnNext()</strong> method. In the <strong class="source-in ine">Observers</strong> class, add the following method at <span class="No-Break">the bottom:</span></p>
			<pre class="source-code">
public Task OnNext(IEvent @event, EventContext context)
{
    var tasks = _handlers.Where(_ =&gt;
      _.EventTypes.Contains(@event.GetType()))
                        .Select(_ =&gt; _.OnNext(@event,
                          context));
    return Task.WhenAll(tasks);
}</pre>
			<p>The code filters<a id="_idIndexMarker450"/> down to only the handlers that are capable by looking at the <strong class="source-in ine">EventTypes</strong> property of the handler, and whether it contains the type of the <strong class="source-in ine">@event</strong> argument. It then calls the <strong class="source-in ine">OnNext()</strong> method of the handler and collects all the <strong class="source-in ine">Task</strong> instances for all the calls it made, so that it can wait for them all <span class="No-Break">to finish.</span></p>
			<p>With the observer infrastructure in place, you’ll need something that triggers this. We’re not going to implement a fully working event sourcing system, as that would be too involved. Instead, we’re going to make a few shortcuts and not save the <span class="No-Break">events anywhere.</span></p>
			<p>In an event-sourced system, you need a place to append the events to a sequence; the main place you <a id="_idIndexMarker451"/>append to is called an event log. Let’s introduce <span class="No-Break">this concept.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">IEventLog.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace EventSourcing;
public interface IEventLog
{
    Task Append(EventSourceId eventSourceId, IEvent
      @event);
}</pre>
			<p>The code represents the contract for the event log with only one method in this version, which enables you to append an event for a <span class="No-Break">specific </span><span class="No-Break"><strong class="source-in ine">EventSourceId</strong></span><span class="No-Break">.</span></p>
			<p>You’ll need an implementation of the <span class="No-Break"><strong class="source-in ine">IEventLog</strong></span><span class="No-Break"> interface.</span></p>
			<p>Within the <strong class="source-in ine">EventSourcing</strong> folder, create a file called <strong class="source-in ine">EventLog.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace EventSourcing;
public class EventLog : IEventLog
{
    readonly IObservers _observers;
    EventSequenceNumber _sequenceNumber = 0;
    public EventLog(IObservers observers)
    {
        _observers = observers;
    }
    public async Task Append(EventSourceId eventSourceId,
      IEvent @event)
    {
        // TODO: persist the event
        await _observers.OnNext(
            @event,
            new EventContext(eventSourceId,
              _sequenceNumber, DateTimeOffset.UtcNow));
        _sequenceNumber++;
    }
}</pre>
			<p>The code <a id="_idIndexMarker452"/>represents a very simplistic implementation that takes a direct dependency on <strong class="source-in ine">IObservers</strong> for it to call when an event has been appended. It manages internally the <strong class="source-in ine">_sequenceNumber</strong>. As you can see, there is no persistence and the whole implementation is naive at best. But it serves the purpose of <span class="No-Break">this chapter.</span></p>
			<p>Now that you have built all this nice infrastructure for invoking methods by the convention on observers, you’re probably eager to take it <a id="_idTextAnchor202"/>out for <span class="No-Break">a spin.</span></p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor203"/>Using the infrastructure</h1>
			<p>Going with the bank <a id="_idIndexMarker453"/>theme of the chapter, let’s create something that represents that domain. In a bank, you can open an account, deposit and withdraw money from it, and then possibly, and ultimately, close an account. All of these are very important events that happen in the lifespan of <span class="No-Break">an account.</span></p>
			<p>Within the root folder of the chapter code, create a file called <strong class="source-in ine">Events.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using EventSourcing;
namespace Chapter12;
public record BankAccountOpened(string CustomerName) :
  IEvent;
public record BankAccountClosed() : IEvent;
public record DepositPerformed(decimal Amount) : IEvent;
public record WithdrawalPerformed(decimal Amount) : IEvent;</pre>
			<p>The code holds all the events we want for now as <strong class="source-in ine">record</strong> types and they all implement the <span class="No-Break"><strong class="source-in ine">IEvent</strong></span><span class="No-Break"> interface.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">In a production environment, I would recommend keeping one file per type, as that makes it easier to navigate and discover events in <span class="No-Break">your system.</span></p>
			<p>With the events in place, you can now go ahead and create observers that will react to the <span class="No-Break">events occurring.</span></p>
			<p>Within the root folder of the chapter code, create a file called <strong class="source-in ine">AccountLifecycle.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using EventSourcing;
namespace Chapter12;
[Observer]
public class AccountLifecycle
{
    public Task Opened(BankAccountOpened @event)
    {
        Console.WriteLine($"Account opened for
          {@event.CustomerName}");
        return Task.CompletedTask;
    }
    public Task Closed(BankAccountClosed @event,
      EventContext context)
    {
        Console.WriteLine($"Account with id
          {context.EventSourceId} closed");
        return Task.CompletedTask;
    }
}</pre>
			<p>The code adds a<a id="_idIndexMarker454"/> class called <strong class="source-in ine">AccountLifecycle</strong> and adorns it with the <strong class="source-in ine">[Observer]</strong> attribute. Its purpose is to only deal with the life cycle events of <strong class="source-in ine">BankAccountOpened</strong> and <strong class="source-in ine">BankAccountClosed</strong>. Notice that it uses the convention fully with custom names of the methods and also the <span class="No-Break">different signatures.</span></p>
			<p>For the events that affect the balance of an account, you could then separate that particular logic into its <span class="No-Break">own observer.</span></p>
			<p>Within the <a id="_idIndexMarker455"/>root folder of the chapter code, create a file called <strong class="source-in ine">AccountBalance.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using EventSourcing;
namespace Chapter12;
[Observer]
public class AccountBalance
{
    public Task DepositPerformed(DepositPerformed @event,
      EventContext context)
    {
        Console.<a href="mailto:%7b@event.Amount%7d">WriteLine($"Dep</a>osit of {@event.Amount}
          performed on {context.EventSourceId}");
        return Task.CompletedTask;
    }
    public Task WithdrawalPerformed(WithdrawalPerformed
      @event, EventContext context)
    {
        Console.Wri<a href="mailto:%7b@event.Amount%7d">teLine($"Withdr</a>awal of {@event.Amount}
          performed on {context.EventSourceId}");
        return Task.CompletedTask;
    }
}</pre>
			<p>The code adds a class called <strong class="source-in ine">AccountBalance</strong> and adorns it with the <strong class="source-in ine">[Observer]</strong> attribute. Its purpose is to only deal with the balance events of <strong class="source-in ine">DepositPerformed</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-in ine">WithdrawalPerformed</strong></span><span class="No-Break">.</span></p>
			<p>Both observers are just logging what has happened to the console. In a real implementation of these, you’d probably want to store the data somewhere. The benefit here is that you could store the data in two different locations. For life cycle events, you’re only interested in the ownership and any details related to the account, while with the<a id="_idIndexMarker456"/> balance events, you’re only interested in what affects the balance and not interested in anything else. Breaking these things up makes it easier to choose the right technology for the job and also model each of these independently and create a less <span class="No-Break">coupled system.</span></p>
			<p>Now you want to do the last hookup and throw some events at it and verify that it does <span class="No-Break">the job.</span></p>
			<p>Open the <strong class="source-in ine">Program.cs</strong> file and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using Chapter12;
using EventSourcing;
using Fundamentals;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
var host = Host.CreateDefaultBuilder()
    .ConfigureServices((context, services) =&gt;
    {
        var types = new Types();
        services.AddSingleton&lt;ITypes&gt;(types);
        services.AddBindingsByConvention(types);
        services.AddSelfBinding(types);
    })
    .Build();</pre>
			<p>The code sets up the necessary plumbing code to get the default .NET inversion of the control container going; it leverages <strong class="source-in ine">AddBindingsByConvention()</strong> that you created in <a href="B19418_10.xhtml#_idTextAnchor162"><span class="No-Break"><em class="ita ic">Chapter 10</em></span></a>, <em class="ita ic">Convention over Configuration</em>, to hook up services by convention, and <strong class="source-in ine">AddSelfBinding()</strong> that you created in <a href="B19418_11.xhtml#_idTextAnchor177"><span class="No-Break"><em class="ita ic">Chapter 11</em></span></a>, <em class="ita ic">Applying the </em><span class="No-Break"><em class="ita ic">Open-Closed Principle</em></span><span class="No-Break">.</span></p>
			<p>With the basic <a id="_idIndexMarker457"/>infrastructure in place, you can now ask for an instance of <strong class="source-in ine">IEventLog</strong> and start appending events <span class="No-Break">to it.</span></p>
			<p>Add the following code at the bottom <span class="No-Break">of </span><span class="No-Break"><strong class="source-in ine">Program.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var eventLog = host.Services
  .GetRequiredService&lt;IEventLog&gt;();
var bankAccountId = EventSourceId.New();
eventLog.Append(bankAccountId, new BankAccountOpened("Jane
  Doe"));
eventLog.Append(bankAccountId, new DepositPerformed(100));
eventLog.Append(bankAccountId, new
  WithdrawalPerformed(32));
eventLog.Append(bankAccountId, new BankAccountClosed());</pre>
			<p>Running your program should give you a <span class="No-Break">similar output:</span></p>
			<pre class="source-code">
Account opened for Jane Doe
Deposit of 100 performed on a3d7dbae-9e2a-4d2d-a070-
ead70e48f87a
Withdrawal of 32 performed on a3d7dbae-9e2a-4d2d-a070-
ead70e48f87a
Account with id a3d7dbae-9e2a-4d2d-a070-ead70e48f87a closed</pre>
			<p>You now have the beginning of an event-sourcing component. But more importantly, it should give you an idea of what could be done dynamically without having to be tied to the strictness <span class="No-Break">of inheritance.</span></p>
			<p>As an illustration <a id="_idIndexMarker458"/>of the implication of doing this with inheritance instead, we would need something like an interface that defines the method for the event; it could look something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public interface IObserveEvent&lt;TEvent&gt; where TEvent :
  IEvent
{
    Task Handle(TEvent @event, EventContext context);
}</pre>
			<p>With this interface, we could take the <strong class="source-in ine">AccountLifecycle</strong> observer and do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public class AccountLifecycle :
    IObserveEvent&lt;BankAccountOpened&gt;,
    IObserveEvent&lt;BankAccountClosed&gt;
{
    public Task Handle(BankAccountOpened @event,
      EventContext context)
    {
        Console.WriteLine($"Account opened for
          {@event.CustomerName}");
        return Task.CompletedTask;
    }
    public Task Handle(BankAccountClosed @event,
      EventContext context)
    {
        Console.WriteLine($"Account with id
          {context.EventSourceId} closed");
        return Task.CompletedTask;
    }
}</pre>
			<p>While using this approach can provide compile-time safety, there are several downsides to consider. Firstly, naming every method <strong class="source-in ine">Handle</strong> can lead to ambiguity and confusion, both in terms of tooling and readability. It may be difficult to determine which method to work with without carefully examining the parameters. Additionally, this approach limits you to only one method handling one event, while the convention-based approach allows for <a id="_idIndexMarker459"/>multiple individual methods with specific purposes to handle different aspects of <span class="No-Break">the event.</span></p>
			<p>If you have an observer handling numerous events, you’d end up having to implement <strong class="source-in ine">IObserveEvent&lt;&gt;</strong> for every type it handles. This can easily make your code less readable <span class="No-Break">and maintainable.</span></p>
			<p>There are pros and cons to both approaches, but hopefully, the takeaway is the potential this gives and, hopefully, it is useful and applicable to the c<a id="_idTextAnchor204"/>ode bases you <span class="No-Break">work on.</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor205"/>Summary</h1>
			<p>Conventions, like those explained in this chapter with the discovery of well-known signatures, can be very powerful and help clean up your code. Forcing the developer to implement an interface for every class supported can be tedious and make the code look a <span class="No-Break">little strange.</span></p>
			<p>The downside of using a convention for method signatures is obviously that you are now at the mercy of runtime checks; there is no compiler that will help you. If you happen to make a little error, it won’t be noticed until you’re at runtime, which can be very annoying while in the zone and developing. In <a href="B19418_17.xhtml#_idTextAnchor299"><span class="No-Break"><em class="ita ic">Chapter 17</em></span></a>, <em class="ita ic">Static Code Analysis</em>, we will look at how we can detect errors at <span class="No-Break">compile time.</span></p>
			<p>In the next chapter, we’re going to look at how automation can go further with conventions to put developers in the pit of success and avoid a <span class="No-Break">recipe-driven development.</span></p>
		</div>
	</body></html>