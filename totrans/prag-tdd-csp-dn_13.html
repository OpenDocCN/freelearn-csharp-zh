<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-287"><a id="_idTextAnchor297"/>13</h1>
<h1 id="_idParaDest-288"><a id="_idTextAnchor298"/>The Intricacies of Rolling Out TDD</h1>
<p>I have frequently seen developers putting their efforts into trying to convince the business to follow TDD or adopt unit tests. In fact, this is a situation in which I have often found myself, and for this reason, I want to share my experience with you in this chapter.</p>
<p>After reading this book, you might feel strongly about implementing TDD in your direct team or large organization to reap the quality benefits. So far, so good. The second stage is doing this in a structured manner and being prepared for the business’ counter-arguments and rejections.</p>
<p>We will highlight the challenges and guide you through the process of convincing your business and team to take the TDD approach. In this chapter, we will discuss the following topics:</p>
<ul>
<li>Technical challenges</li>
<li>Team challenges</li>
<li>Business challenges</li>
<li>TDD arguments and misconceptions</li>
</ul>
<p>After reading this chapter, you will be ready to present your team and/or business with a plan to move forward with TDD.</p>
<h1 id="_idParaDest-289"><a id="_idTextAnchor299"/>Technical challenges</h1>
<p>There is a set of technical and business challenges an organization must overcome before adopting TDD. Here, we will cover the technical challenges, and in the next section, we will consider the team challenges and then the wider organization challenges (business challenges). We will start with a diagram to explain the workflow of rolling out TDD in your organization:</p>
<div><div><img alt="Figure 13.1 – Technical challenges when planning to move to TDD  " height="767" src="img/Figure_13.1_B18370.jpg" width="1218"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Technical challenges when planning to move to TDD </p>
<p>We will go through the diagram in the next sub-sections, so let’s start.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor300"/>Greenfield or brownfield?</h2>
<p>If you are working on a brownfield project, the technical challenges were well presented in the previous chapter, so I will not go further into these challenges. To introduce TDD, you need to consider the effort, suitability, and alternatives.</p>
<p>If you are starting a new project (a greenfield project), then you are in luck. You can go ahead with your plan.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor301"/>Tools and infrastructure</h2>
<p>Today, with the availability of the cloud, having<a id="_idIndexMarker882"/><a id="_idIndexMarker883"/> an infrastructure to run your <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) pipeline is easy and cheap. However, some organizations have restrictions on using the cloud and you might struggle to get a CI server. </p>
<p>If you don’t have a CI server in place, then at the risk of sounding pessimistic, doing TDD is doomed to fail. This is because developers will break the unit tests and you will have them disabled or failing.</p>
<p>Some developers also like to invest in tools such as <strong class="bold">JetBrains ReSharper</strong> for its good-quality test runner and refactoring capabilities, but this is optional. Also, you may want to consider JetBrains Rider as it has all the capabilities of ReSharper, as discussed in <a href="B18370_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a> of this book. </p>
<p>However, if you are using MS Visual Studio Professional 2022 or later, you already have a good tool for a proper TDD process.</p>
<p>The technical challenges are not all you need to think about. Consider also your team and its readiness to embrace TDD and then your business challenges. Let’s continue with the team challenges.</p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor302"/>Team challenges</h1>
<p>If you are a solo developer<a id="_idIndexMarker884"/><a id="_idIndexMarker885"/> working on a project, no worries, you can do whatever. However, most business projects are implemented by a team, so making the effort to use TDD is a team decision. Again, let’s start with a workflow diagram:</p>
<div><div><img alt="Figure 13.2 – Team challenges when planning to move to TDD  " height="805" src="img/Figure_13.2_B18370.jpg" width="1207"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Team challenges when planning to move to TDD </p>
<p>We will go through this diagram in the next sub-sections. Let’s go through the points to keep in mind when planning to move your team – whether <a id="_idIndexMarker886"/><a id="_idIndexMarker887"/>you are a developer wanting to influence the team or in a position where you can enforce technical standards.</p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor303"/>Team experience</h2>
<p>Unit testing requires DI, which in turn<a id="_idIndexMarker888"/><a id="_idIndexMarker889"/> requires experience in OOP. Your team members may be unfamiliar with unit testing or may mistake unit testing with integration testing.</p>
<p class="callout-heading">Important notes</p>
<p class="callout">The xUnit and NUnit libraries are widely used to implement integration tests. Because they have the suffix <strong class="bold">Unit</strong>, developers <a id="_idIndexMarker890"/><a id="_idIndexMarker891"/>sometimes incorrectly assume the written tests are unit tests. I’ve seen teams claiming they have unit tests, but when I inspected the code, I discovered otherwise.</p>
<p>If your team requires training in TDD, then they need to be educated on what it is, how to do it, and the value of TDD. I have a book in mind to recommend for the training, but I will leave it to you to guess which it is.</p>
<p class="callout-heading">Important notes</p>
<p class="callout">I usually ask the team to read certain material on their own before having a session or several sessions on the topic. Training a team can be done in many ways, and it is more related to your company and team culture. I also document the conventions and the agreement on Confluence or whatever tool the organization uses for documentation.</p>
<p>It is important to have a competent developer in the team, who understands unit testing, is a good explainer, and can squeeze in some time, which could be you. This would be helpful, as your team will have questions when they start TDD.</p>
<p>But training the team may not be an option for many reasons. Having a few members of the team doing unit testing and others not won’t be productive, as everyone is going to operate on the same code base, so having everybody trained and ready for TDD is a prerequisite. </p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor304"/>Willingness</h2>
<p>Some teams are not willing to do unit testing whether they feel it is difficult or increases development time or they don’t perceive the value.</p>
<p class="callout-heading">Important notes</p>
<p class="callout">I have seen unit testing enforced by an organization, but the team was unwilling to write the tests, and they just created a unit test project with meaningless tests to tick the box of the question <em class="italic">Have you implemented unit testing?</em>.</p>
<p>Having the team synchronized with the objective and collaborating for one goal is valuable in promoting product quality. </p>
<p>If your team is not willing to go for TDD for whatever reason but unit testing is OK, then go for it! You can gently introduce TDD soon after. It doesn’t need to be all or nothing. It is also worth noting that some members can do TDD while others can do unit tests.</p>
<h3>Unit testing is useless</h3>
<p>I have heard this argument from many<a id="_idIndexMarker892"/><a id="_idIndexMarker893"/> developers. They might have formed their opinion on bad implementations of unit testing or have other reasons. Certainly, unit testing has some disadvantages, but so do most technologies.</p>
<p>Your best shot is to understand the reasons behind this misconception and see whether you can address them.</p>
<h3>TDD is useless, I would do unit testing</h3>
<p>TDD is controversial and <a id="_idIndexMarker894"/><a id="_idIndexMarker895"/>sometimes developers have their own experiences that told them that TDD is unusable. This is OK as long as they are happy with unit testing because not all team members have to do TDD.</p>
<p>If the developers who don’t believe in unit tests are building their arguments on seeing bad practices, then your job might be to promote good practices.</p>
<p>The team’s willingness to follow TDD has a crucial impact on the success of the project, so it is important to have everybody on the same page.</p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor305"/>Timing</h2>
<p>TDD requires some<a id="_idIndexMarker896"/><a id="_idIndexMarker897"/> preparations and extra effort to get the essential quality, following the <em class="italic">no pain, no gain</em> mantra. Having the right time is important and it should definitely not be near the release time or when the team is stressed.</p>
<p>The perfect time is at the start of the project, but there is no harm in introducing it later.</p>
<p>Once you’ve passed the first and second challenges, you will have the business challenges, which are arguably the hardest.</p>
<h1 id="_idParaDest-296"><a id="_idTextAnchor306"/>Business challenges</h1>
<p>The business here means a <a id="_idIndexMarker898"/><a id="_idIndexMarker899"/>higher technical authority outside the team, who can enforce rules. Also, it can be the project manager or the product owner.</p>
<p>I believe that a successful rollout of TDD or unit testing comes from top to bottom, management-wise. Enforcement can come from:</p>
<ul>
<li>Head of development</li>
<li>Development manager</li>
<li>Team lead</li>
<li>Technical lead </li>
<li>IT auditing</li>
</ul>
<p>If this is a personal initiative or a team initiative, the team might think of dropping it under delivery pressure. However, if they are responsible for providing unit tests as part of the delivery, including a coverage level, then it cannot be missed.</p>
<p>Let’s think of TDD from the business perspective, so that we are better equipped and articulated in getting our points across.</p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor307"/>Business benefits of TDD</h2>
<p>We are well aware of what the <a id="_idIndexMarker900"/><a id="_idIndexMarker901"/>benefits of TDD are from a technical point of view. But businesses would be more open to the benefits from the business point of view, so let’s get into it.</p>
<h3>Fewer bugs </h3>
<p>This is clearly the biggest seller, as nobody likes bugs. Some businesses are stung by a high number of defects in their products, and having less is definitely a welcome promise.</p>
<p>The only issue is that it is hard to prove a lower number of bugs via statistics – the project will have unit tests from day one, so we can’t make a comparison between before and after.</p>
<h3>Live documentation for the project</h3>
<p>One thing that worries the business is documentation, which has a tight relationship with developers’ turnover. The risk is that if a developer leaves, some of the business knowledge is lost. To prevent this situation, it is important to have the business rules robustly documented, and, in all honesty, I can’t think of any tool that is better for this than unit tests.</p>
<p>Project documentation contains documents that cannot be covered by unit tests, such as project architecture. However, the detailed business rules that nobody will remember in a few months will be covered by unit tests and monitored with every developer source control push.</p>
<p>Promoting unit testing as a documentation tool is powerful and will give you listening ears from the business.</p>
<h3>Fewer testing resources</h3>
<p>In the old days, manual testing<a id="_idIndexMarker902"/><a id="_idIndexMarker903"/> took a good chunk of the <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>). Today, with unit tests and other automated<a id="_idIndexMarker904"/><a id="_idIndexMarker905"/> tests, manual testing has shrunk in size and the number of required manual testers has gone down. Some organizations have even eliminated manual testing completely in favor of having automated tests (including unit tests).</p>
<p>So, the promise of unit tests is about covering lots of edge cases and business rules with fewer testers and almost no regression test time.</p>
<p class="callout-heading">Important note</p>
<p class="callout"><strong class="bold">Regression testing</strong> is going through<a id="_idIndexMarker906"/><a id="_idIndexMarker907"/> existing functionality to ensure it is still working. This typically happens before a new release.</p>
<p>Obviously, fewer testing resources means less cost, while less time means shipping a feature faster, which naturally leads us to the next topic.</p>
<h3>Ability to release in short cycles</h3>
<p>The development model today in more agile organizations has moved to shipping a few features now and then. </p>
<p>Having unit tests regressing the code with every change and a CI/CD system in place means your software is ready to be shipped anytime.</p>
<p>No clever business person will believe all these aforementioned benefits will come at no cost, so next, we will discuss the disadvantages of unit testing.</p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor308"/>Disadvantages from the business perspective</h2>
<p>In general, extra quality requires more<a id="_idIndexMarker908"/><a id="_idIndexMarker909"/> effort, and TDD is no different, but luckily the disadvantages are minimal.</p>
<h3>Slight delay in the first release</h3>
<p>We have discussed before that<a id="_idIndexMarker910"/><a id="_idIndexMarker911"/> teams not using TDD tend to deliver faster in the first period; we have spoken about this in <a href="B18370_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Test-Driven Development Explained</em>. Here is a quick reminder:</p>
<div><div><img alt="" height="658" src="img/Figure_13.3_B18370.jpg" width="1190"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – TDD versus no unit testing</p>
<p>The idea here is that the effort of writing unit tests adds to the development time in the short term, but the speed becomes faster in the mid and long terms.</p>
<p>This is a small price to pay for quality, but just be aware of this point.</p>
<h3>Delay in the first release is not acceptable</h3>
<p>There are circumstances where the business wants the first version as soon as possible and they are not interested in looking beyond this. Here are a few scenarios:</p>
<ul>
<li>The product manager wants the first version out as soon as possible, as this can lead them to get a higher bonus or a promotion.</li>
<li>There is a competitive advantage in releasing as soon as possible and not worrying about the future. This is the mentality of a start-up trying to survive. </li>
<li>This project is done for a third party, and the business doesn’t get paid extra for ensuring added quality. But getting this in the shortest time possible is the intention.</li>
</ul>
<p>It would be clear if the business is not interested, and you can feel this in advance if you know the business model that the company uses. This is not a criticism against TDD, but it would become a disadvantage when mixed with such <a id="_idIndexMarker912"/><a id="_idIndexMarker913"/>scenarios.</p>
<p>Now that we have gone through all the challenges and the merits of TDD, let’s form a plan to introduce TDD.</p>
<h1 id="_idParaDest-299"><a id="_idTextAnchor309"/>TDD arguments and misconceptions</h1>
<p>Here are a few hints and tips – from my own<a id="_idIndexMarker914"/><a id="_idIndexMarker915"/> experience – that will occur again and again in a conversation with the business or your colleagues. </p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor310"/>Unit testing, not TDD</h2>
<p>When discussing with the business, to reduce the complexity of the conversation, especially if the business is not tech-savvy, use the term unit testing rather than TDD. TDD is a technical process that individuals will do themselves and it is not directly related to the business, so why complicate the discussion by adding it? Sometimes the business has heard the term TDD, and they are excited about it, so then TDD is the right term to use!</p>
<p>My advice is to use unit testing in your conversation unless the business has some preference for the term TDD.</p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor311"/>Unit testing is not implemented by testers</h2>
<p>The term <em class="italic">testing</em> in unit testing is misleading to the non-techies as it implies a tester doing manual testing. I have had this conversation with many business individuals.</p>
<p>It is important to clarify that unit testing has more functionality other than just testing, such as the following:</p>
<ul>
<li>Shaping the code design architecture of the project</li>
<li>Live documenting the code </li>
<li>Instant feedback during development when breaking a business rule </li>
</ul>
<p>Also, unit tests are written in C# (or whatever other language you are using), and they are implemented by the same developer writing the code. A manual tester, most probably, won’t have the willingness or the expertise to write these tests.</p>
<p>This argument might be triggered when the business is wondering why you want to consume the engineers’ expensive time on unit testing when there are testers that could (as they initially thought) do the unit tests.</p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor312"/>The way for writing and maintaining documentation</h2>
<p>I am sure experienced business people will relate to the lack of documentation or the documentation becoming out of date.</p>
<p>As you already know, documenting<a id="_idIndexMarker916"/><a id="_idIndexMarker917"/> the code with unit tests provides fresh documentation versus text-based stale documentation that is written and forgotten or covers part of the system (a hit and a miss). The keyword here is up-to-date, fresh, or live. Obviously, we are talking about part of the documentation and you might have to make this clear. This is the detailed business rules part.</p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor313"/>We have incompetent developers</h2>
<p>Businesses sometimes believe they have incompetent developers, and this is why they are producing plenty of bugs. I have heard this argument whispered by the business on multiple occasions when talking about their team.</p>
<p>When I hear this argument, I quickly dig and discover that the business does not have a structure in place for the agile process and that the developers are rewarded for how fast they finish developing a feature. We all know that person who takes the shortest route to get their features done and show off to the business!</p>
<p>Developers are highly logical individuals who like structure and order. Having a development process with TDD will definitely reduce bugs and set things on track.</p>
<p>Your challenge here is to show how the TDD process and the tests will have a positive effect on the problem.</p>
<h1 id="_idParaDest-304"><a id="_idTextAnchor314"/>Summary</h1>
<p>This chapter utilizes all the knowledge provided in this book and demonstrates the challenges of rolling out TDD into your organization. I hope I gave you enough arguments to convince the team and the business to subscribe to the TDD point of view.</p>
<p>Besides this chapter, your presentation skills and familiarity with the subject will be highly useful when planning to roll out TDD.</p>
<p>In this book, I have endeavored to provide practical examples of real frameworks and tools that I’ve worked with, rather than using abstract and oversimplified examples. I wrote the book out of love and passion for the topic and I tried to stay pragmatic, and I hope I delivered what I aimed to deliver.</p>
<p>While the title of this book refers to TDD, this book contains pragmatic examples of OOP and good programming practices, and by finishing the book, I trust you have stepped into the world of advanced software engineering.</p>
<p>Good luck and I would love to know how the book has contributed to you or your team adopting TDD. </p>
</div>
</div>


<div><div><h1 id="_idParaDest-305"><a id="_idTextAnchor315"/>Appendix 1: Commonly Used Libraries with Unit Tests</h1>
<p>We have used two major libraries for unit testing across the book:</p>
<ul>
<li>xUnit</li>
<li>NSubstitute</li>
</ul>
<p>Your team may be using these libraries already. Or you may have done a bit of experimentation with unit testing, and you want to expand your horizon into more libraries. While these libraries are popular, other libraries can replace them or work side by side with them. This appendix will skim through the following libraries:</p>
<ul>
<li>MSTest</li>
<li>NUnit</li>
<li>Moq</li>
<li>Fluent Assertions</li>
<li>AutoFixture</li>
</ul>
<p>All these libraries use the MIT license, the most permissive license and you can install any of them via NuGet.</p>
<p>By the end of this appendix, you will be familiar with the libraries that form the ecosystem of unit testing in .NET.</p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor316"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix1">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix1</a></p>
<h1 id="_idParaDest-307"><a id="_idTextAnchor317"/>Unit testing frameworks</h1>
<p>We have seen xUnit, and we <a id="_idIndexMarker918"/>have briefly spoken about MSTest and NUnit. This section will give you a feeling of what these other frameworks are about.</p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor318"/>MSTest</h2>
<p><strong class="bold">MSTest</strong> used to be<a id="_idIndexMarker919"/> popular, as it was installed as part of <strong class="bold">Visual Studio</strong> (<strong class="bold">VS</strong>) in the <a id="_idIndexMarker920"/>older versions of VS. Prior to NuGet’s <a id="_idIndexMarker921"/>existence, using a <em class="italic">built-in</em> library could cut configuration and deployment time compared to adding and using another framework such as<a id="_idIndexMarker922"/> NUnit.</p>
<p>Before NuGet, installing a new library involved manually copying DLLs, putting them in the right location, changing some configurations, and pushing them into source control for the team to share the same files. So, having a pre-installed library and one that didn’t require configuration, such as MSTest, was a blessing. We have moved a long way since then.</p>
<p>To add an MSTest project<a id="_idIndexMarker923"/> into your solution, you can do it via the UI:</p>
<div><div><img alt="Figure A1.1 – Adding MSTest via the UI " height="738" src="img/Figure_A1.1_B18370.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure A1.1 – Adding MSTest via the UI</p>
<p>Notice that <a id="_idIndexMarker924"/>there are two copies of the C# version. The bottom <a id="_idIndexMarker925"/>one is for the classical .NET Framework, and the top one is what we use with .NET Core.</p>
<p>You can <a id="_idIndexMarker926"/>add MSTest via the <code>dotnet</code> CLI:</p>
<pre class="source-code">dotnet new mstest</pre>
<p>MSTest and xUnit have similar syntax, so let me show you the code in xUnit and its equivalent in MSTest. I’ll start with xUnit:</p>
<pre class="source-code">public class WeatherAnalysisServiceTests
{
    …
    <strong class="bold">public WeatherAnalysisServiceTests()</strong>
    {
        _sut = new (_openWeatherServiceMock);
    }
    [Fact]
    public async Task GetForecastWeatherAnalysis_
        LatAndLonPassed_ReceivedByOpenWeatherAccurately()
        …
        // Assert
        Assert.<strong class="bold">Equal</strong>(LAT, actualLat);
        Assert.Equal(LON, actualLon);
    }
    …</pre>
<p>The <a id="_idIndexMarker927"/>equivalent in <a id="_idIndexMarker928"/>MSTest is as follows:</p>
<pre class="source-code"><strong class="bold">[TestClass]</strong>
public class WeatherAnalysisServiceTests
{
    …
    <strong class="bold">[TestInitialize]</strong>
    <strong class="bold">public void TestInitialize()</strong>
    {
        _sut = new(_openWeatherServiceMock);
    }
    <strong class="bold">[TestMethod]</strong>
    public async Task GetForecastWeatherAnalysis_
      LatAndLonPassed_ReceivedByOpenWeatherAccurately()
    {
        …
        // Assert
        Assert.<strong class="bold">AreEqual</strong>(LAT, actualLat);
        Assert.<strong class="bold">AreEqual</strong>(LON, actualLon);
    }
    …</pre>
<p>You can directly <a id="_idIndexMarker929"/>spot a few differences between the two code snippets:</p>
<ul>
<li>The unit test class in MSTest has to be decorated with <code>TestClass</code>.</li>
<li>The constructor in MSTest would work, but the standard way of initializing is to decorate a method with <code>TestInitialize</code>.</li>
<li>Both libraries use the <code>Assert</code> class name, but the method names in the class are different; for example, xUnit uses <code>Equal</code> and <code>True</code>, while MSTest uses <code>AreEqual</code> and <code>IsTrue</code>.</li>
</ul>
<p>When doing multiple tests, xUnit and MSTest use different attributes. This code is in xUnit:</p>
<pre class="source-code">[Theory]
[InlineData("Freezing", -1)]
[InlineData("Scorching", 46)]
public async Task GetForecastWeatherAnalysis_
   Summary_MatchesTemp(string summary, double temp)
{
…</pre>
<p>In MSTest, the equivalent code will look like this:</p>
<pre class="source-code">[DataTestMethod]
[DataRow("Freezing", -1)]
[DataRow("Scorching", 46)]
public async Task GetForecastWeatherAnalysis_
   Summary_MatchesTemp(string summary, double temp)
{
…</pre>
<p>Here, you can notice two differences:</p>
<ul>
<li><code>Theory</code> becomes <code>DataTestMethod</code>.</li>
<li><code>InlineData</code> becomes <code>DataRow</code>.</li>
</ul>
<p>As you can see, there <a id="_idIndexMarker930"/>isn’t much difference between the two libraries. Also, executing the test running, running the Test Explorer and other test activities other than the code stay the same.</p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor319"/>NUnit</h2>
<p><strong class="bold">NUnit</strong> used <a id="_idIndexMarker931"/>to be the dominant library in the first decade of the two-thousands; it is still <a id="_idIndexMarker932"/>in use today, with xUnit becoming more prevalent.</p>
<p>To add an NUnit <a id="_idIndexMarker933"/>project to your solution, you can do it via the UI:</p>
<div><div><img alt="Figure A1.2 – Adding NUnit via the UI " height="738" src="img/Figure_A1.2_B18370.jpg" width="1123"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure A1.2 – Adding NUnit via the UI</p>
<p>Just like MSTest, NUnit<a id="_idIndexMarker934"/> has two copies of the .NET version. The bottom one is<a id="_idIndexMarker935"/> for the classical .NET Framework, and the top one is what we use with .NET Core.</p>
<p>You can add <a id="_idIndexMarker936"/>NUnit via the <code>dotnet</code> CLI:</p>
<pre class="source-code">dotnet new nunit</pre>
<p>NUnit and xUnit have similar syntax, so let me show you the code in NUnit and its equivalent in MSTest. I’ll start with xUnit:</p>
<pre class="source-code">public class WeatherAnalysisServiceTests
{
    …
    <strong class="bold">public WeatherAnalysisServiceTests()</strong>
    {
        _sut = new (_openWeatherServiceMock);
    }
    [Fact]
    public async Task GetForecastWeatherAnalysis_
        LatAndLonPassed_ReceivedByOpenWeatherAccurately()
        …
        // Assert
        Assert.<strong class="bold">Equal</strong>(LAT, actualLat);
        Assert.Equal(LON, actualLon);
    }
    …</pre>
<p>The <a id="_idIndexMarker937"/>equivalent<a id="_idIndexMarker938"/> in MSTest is as follows:</p>
<pre class="source-code">public class WeatherAnalysisServiceTests
{
    …
    <strong class="bold">[Setup]</strong>
    <strong class="bold">public void Setup()</strong>
    {
        _sut = new(_openWeatherServiceMock);
    }
    <strong class="bold">[Test]</strong>
    public async Task GetForecastWeatherAnalysis_
      LatAndLonPassed_ReceivedByOpenWeatherAccurately()
    {
        …
        // Assert
        <strong class="bold">Assert.That(actualLat, Is.EqualTo(LAT));</strong>
        <strong class="bold">Assert.That(actualLon, Is.EqualTo(LON));</strong>
    }
    …</pre>
<p>You can directly <a id="_idIndexMarker939"/>spot a few differences between the two code snippets:</p>
<ul>
<li>The constructor in NUnit would work, but the standard way of initializing is to decorate a method with <code>Setup</code>.</li>
<li>Both libraries use the <code>Assert</code> class name, but the method names in the class are different; for example, xUnit uses <code>Equal</code>, while NUnit uses <code>AreEqual</code>.</li>
<li>The style of NUnit uses a fluent interface design, and the recommended approach to test equality is to use <code>That</code> and <code>Is.EqualTo</code>.</li>
</ul>
<p>When doing multiple tests, xUnit and NUnit use different class names. This code is in xUnit:</p>
<pre class="source-code">[Theory]
[InlineData("Freezing", -1)]
[InlineData("Scorching", 46)]
public async Task GetForecastWeatherAnalysis_
   Summary_MatchesTemp(string summary, double temp)
{
…</pre>
<p>In NUnit, the equivalent code will look like this:</p>
<pre class="source-code">[Theory]
[TestCase("Freezing", -1)]
[TestCase("Scorching", 46)]
public async Task GetForecastWeatherAnalysis_
   Summary_MatchesTemp(string summary, double temp)
{
…</pre>
<p>Here, you can notice that <code>InlineData</code> becomes <code>TestCase</code>. Besides this, there isn’t much difference between the two libraries, and their template is included in the default installation of VS 2022.</p>
<p>These three libraries are interchangeable, and the syntax changes are minimal. Once you are used to one, it will take minimal time to switch to the other.</p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor320"/>Mocking libraries</h1>
<p>There is no shortage of mocking libraries<a id="_idIndexMarker940"/> in .NET; however, the top two used libraries are NSubstitute and Moq. We have covered plenty of examples of NSubstitute in this book, so let’s see how Moq works.</p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor321"/>Moq</h2>
<p><strong class="bold">Moq</strong> has the <a id="_idIndexMarker941"/>same <a id="_idIndexMarker942"/>role and same functionality, more or less, as NSubstitute. Given that the book was using NSubstitute, the fastest way to introduce Moq is to compare the two libraries. Let’s start with a snippet from NSubstitute:</p>
<pre class="source-code"><strong class="bold">private IOpenWeatherService _openWeatherServiceMock = </strong>
    <strong class="bold">Substitute.For&lt;IOpenWeatherService&gt;();</strong>
private WeatherAnalysisService _sut;
private const decimal LAT = 2.2m;
private const decimal LON = 1.1m;
public WeatherAnalysisServiceTests()
{
    _sut = new (_openWeatherServiceMock);
}
[Fact]
public async Task GetForecastWeatherAnalysis_
    LatAndLonPassed_ReceivedByOpenWeatherAccurately()
{
    // Arrange
    decimal actualLat = 0;
    decimal actualLon = 0;
    <strong class="bold">_openWeatherServiceMock.OneCallAsync(</strong>
        <strong class="bold">Arg.Do&lt;decimal&gt;(x =&gt; actualLat = x),</strong>
        <strong class="bold">Arg.Do&lt;decimal&gt;(x =&gt; actualLon = x),</strong>
        <strong class="bold">Arg.Any&lt;IEnumerable&lt;Excludes&gt;&gt;(), </strong>
        <strong class="bold">Arg.Any&lt;Units&gt;())</strong>
       <strong class="bold">.Returns(Task.FromResult(GetSample(_defaultTemps)));</strong>
    // Act
    await _sut.GetForecastWeatherAnalysis(LAT, LON);
    // Assert
    Assert.Equal(LAT, actualLat);
    Assert.Equal(LON, actualLon);
}</pre>
<p>This snippet instantiates and creates a mock object from <code>IOpenWeatherService</code> and spies on the <code>lat</code> and <code>lon</code> input parameters of <code>OneCallAsync</code>. The idea is to ensure the two parameters passed to <code>GetForecastWeatherAnalysis</code> are passed without modification to the <code>OneCallAsync</code> method. </p>
<p>Let’s look <a id="_idIndexMarker943"/>at the same <a id="_idIndexMarker944"/>code using Moq:</p>
<pre class="source-code"><strong class="bold">private IOpenWeatherService _openWeatherServiceMock = </strong>
    <strong class="bold">Mock.Of&lt;IOpenWeatherService&gt;();</strong>
private WeatherAnalysisService _sut;
private const decimal LAT = 2.2m;
private const decimal LON = 1.1m;
public WeatherAnalysisServiceTests()
{
    _sut = new (_openWeatherServiceMock);
}
[Fact]
public async Task GetForecastWeatherAnalysis_
    LatAndLonPassed_ReceivedByOpenWeatherAccurately()
{
    // Arrange
    decimal actualLat = 0;
    decimal actualLon = 0;
    <strong class="bold">Mock.Get(_openWeatherServiceMock)</strong>
        <strong class="bold">.Setup(x =&gt; x.OneCallAsync(It.IsAny&lt;decimal&gt;(),</strong>
        <strong class="bold">It.IsAny&lt;decimal&gt;(), </strong>
        <strong class="bold">It.IsAny&lt;IEnumerable&lt;Excludes&gt;&gt;(),</strong>
        <strong class="bold">It.IsAny&lt;Units&gt;()))</strong>
        <strong class="bold">.Callback&lt;decimal, decimal, </strong>
        <strong class="bold">IEnumerable&lt;Excludes&gt;, Units&gt;((lat, lon, _, _) =&gt; {</strong>
            <strong class="bold">actualLat = lat; actualLon = lon; })</strong>
       <strong class="bold">.Returns(Task.FromResult(GetSample(_defaultTemps)));</strong>
    // Act
    await _sut.GetForecastWeatherAnalysis(LAT, LON);
    // Assert
    Assert.Equal(LAT, actualLat);
    Assert.Equal(LON, actualLon);
}</pre>
<p>This Moq code doesn’t look much different from its NSubstitute rival. Let’s analyze the differences:</p>
<ul>
<li>NSubstitute <a id="_idIndexMarker945"/>instantiates a mock object<a id="_idIndexMarker946"/> using the <code>Substitute.For</code> method, whereas Moq does it using <code>Mock.Of</code>.</li>
<li>NSubstitute uses extension methods such as <code>Returns</code> to configure the mock object, whereas Moq doesn’t use extensions.</li>
<li>NSubstitute uses <code>Args.Any</code> to pass parameters, whereas Moq uses <code>It.IsAny</code>.</li>
</ul>
<p>In general, while Moq favors syntax with lambda expressions, NSubstitute takes another route and uses extension methods. NSubstitute tries to make the code look as natural as possible and get out of the way by having less syntax, while Moq relies on the power of lambdas.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Moq has another way of creating a mock. I opted to show the modern version.</p>
<p>In my opinion, using one library or another is a matter of style and syntax preference.</p>
<h1 id="_idParaDest-312"><a id="_idTextAnchor322"/>Unit testing helper libraries</h1>
<p>I have seen <a id="_idIndexMarker947"/>developers adding these two libraries to their unit tests to enhance the syntax and readability: <strong class="bold">Fluent Assertions</strong> and <strong class="bold">AutoFixture</strong>.</p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor323"/>Fluent Assertions</h2>
<p>Fluent implementation<a id="_idIndexMarker948"/>, also known as a fluent interface, is trying to make the code read like an<a id="_idIndexMarker949"/> English<a id="_idIndexMarker950"/> sentence. Take this example:</p>
<pre class="source-code">Is.Equal.To(…);</pre>
<p>Some developers like to have the tests written in this way as it supports a more natural way of reading a test. Some like it for their own reasons.</p>
<p><code>FluentAssertions</code> is a popular library that integrates with all popular test frameworks among MSTest, Nunit, and xUnit to enable fluent interfaces. You can add it to your unit test project via NuGet under the name <code>FluentAssertions</code>.</p>
<p>Let’s see how our code will be without and with the library:</p>
<pre class="source-code">// Without
Assert.Equal(LAT, actualLat);
// With
actualLat.Should().Be(LAT);</pre>
<p>But the previous snippet doesn’t show the true power of the library, so let’s do some other examples:</p>
<pre class="source-code">// Arrange
string actual = "Hi Madam, I am Adam";
// Assert actual.Should().StartWith("Hi")
    .And.EndWith("Adam")
    .And.Contain("Madam")
    .And.HaveLength(19);</pre>
<p>The previous snippet is an example of a fluent syntax, and the code is self-explanatory. To test this code, you will require a few lines of the standard <code>Assert</code> syntax.</p>
<p>Here is another example:</p>
<pre class="source-code">// Arrange
var integers = new int[] { 1, 2, 3 };
// Assert
integers.Should().OnlyContain(x =&gt; x &gt;= 0);
integers.Should().HaveCount(10, 
  "The set does not contain the right number of elements");</pre>
<p>The previous code is also self-explanatory.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">While these code snippets show the power of <code>FluentAssertions</code>, asserting too many unrelated elements in a unit test is not recommended. These examples are for illustration only and do not focus on best unit testing practices.</p>
<p>These<a id="_idIndexMarker951"/> two code snippets are enough to show <a id="_idIndexMarker952"/>why some developers are fond of this syntax style. Now that you know about it, the choice of using such syntax is yours.</p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor324"/>AutoFixture</h2>
<p>Sometimes, you have to<a id="_idIndexMarker953"/> generate data to populate an object. The<a id="_idIndexMarker954"/> object may be directly related to your unit test. Or maybe you just want to populate it for the rest of the unit to execute, but it is not the subject of the test. This is when <strong class="bold">AutoFixture</strong> comes to the rescue. </p>
<p>You can write the tedious code to generate an object, or you can use <code>AutoFixture</code>. Let’s illustrate this with an example. Consider the following <code>record</code> class:</p>
<pre class="source-code">public record OneCallResponse
{
    public double Lat { get; set; }
    public double Lon { get; set; }
    …
    public Daily[] Daily { get; set; }
}
public record Daily
{
    public DateTime Dt { get; set; }
    public Temp Temp { get; set; }
    …
}
// More classes</pre>
<p>Populating this in the <code>Arrange</code> part of your unit test will increase the size of your unit test and distract the test from its real intention.</p>
<p>AutoFixture can create an instance of this class using the least amount of code:</p>
<pre class="source-code">var oneCallResponse = _fixture.Create&lt;OneCallResponse&gt;();</pre>
<p>This will create an object of this class and populate it with random values. These are some of the values:</p>
<pre class="source-code">{OneCallResponse { Lat = 186, Lon = 231, Timezone = Timezone9d27503a-a90d-40a6-a9ac-99873284edef, TimezoneOffset = 177, Daily = Uqs.WeatherForecaster.Daily[] }}
    Daily: {Uqs.WeatherForecaster.Daily[3]}
    EqualityContract: {Name = "OneCallResponse" FullName = 
        "Uqs.WeatherForecaster.OneCallResponse"}
    Lat: 186
    Lon: 231
    Timezone: "Timezone9d27503a-a90d-40a6-a9ac-99873284edef"
    TimezoneOffset: 177</pre>
<p>The previous output is the first level of the <code>OneCallResponse</code> class, but all the succeeding levels are also populated.</p>
<p>But what if you <a id="_idIndexMarker955"/>want fine control of the generated data? Let’s say we want to generate the class, but with the <code>Daily</code> property having an array length of <code>8</code> rather than a random size:</p>
<pre class="source-code">var oneCallResponse = _fixture.Build&lt;OneCallResponse&gt;()
  .With(x =&gt; x.Daily,_fixture.CreateMany&lt;Daily&gt;(8).ToArray())
  .Create(); </pre>
<p>This will <a id="_idIndexMarker956"/>generate everything randomly, but the <code>Daily</code> property will have eight array elements with random values.</p>
<p>This library has plenty of methods and customizations; this section only scratches the surface.</p>
<p>This appendix is a brief pointer to several libraries used for, or in conjunction with, unit testing. The intention here is to tell you these libraries exist and intrigue you to dig further if the need arises.</p>
<h1 id="_idParaDest-315"><a id="_idTextAnchor325"/>Further reading </h1>
<p>To learn more about the topics discussed in the chapter, you can refer to the following links:</p>
<ul>
<li><em class="italic">xUnit</em>: <a href="https://xunit.net">https://xunit.net</a></li>
<li><em class="italic">MSTest</em>: <a href="https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest">https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest</a></li>
<li><em class="italic">NUnit</em>: <a href="https://nunit.org">https://nunit.org</a></li>
<li><em class="italic">Moq</em>: <a href="https://github.com/moq/moq4%0D">https://github.com/moq/moq4</a></li>
<li><em class="italic">Fluent Assertions</em>: <a href="https://fluentassertions.com%0D">https://fluentassertions.com</a></li>
<li><em class="italic">AutoFixture</em>: <a href="https://github.com/AutoFixture">https://github.com/AutoFixture</a></li>
</ul>
</div>
</div>


<div><div><h1 id="_idParaDest-316"><a id="_idTextAnchor326"/>Appendix 2: Advanced Mocking Scenarios</h1>
<p>This book has numerous examples of straightforward mocking scenarios. And the good news is, in a clean code environment, implementing most of those mocking requirements will be easy.</p>
<p>However, there are times when you have to <em class="italic">innovate</em> a bit to be able to mock your desired class. I did not want to end this book without presenting you with a scenario, so here you go.</p>
<p>In this appendix, we will experience how to combine a fake with a mock to deal with a .NET class called <code>HttpMessageHandler</code>. By the end of this appendix, you will be familiar with more NSubstitute functionalities and ready to tackle more advanced mocking cases. </p>
<h1 id="_idParaDest-317"><a id="_idTextAnchor327"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix2">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix2</a></p>
<h1 id="_idParaDest-318"><a id="_idTextAnchor328"/>Writing an OpenWeather client library</h1>
<p>We have used the OpenWeather service in this book frequently, so I will give you a quick reminder – OpenWeather <a id="_idIndexMarker957"/>provides a set of RESTful APIs to bring you the weather and the forecast.</p>
<p>To consume the service from a C# application, it is good to have a library that will translate RESTful <a id="_idIndexMarker958"/>API calls to C# and shield the developer from the little details of HTTP. We call this sort <a id="_idIndexMarker959"/>of library a <strong class="bold">RESTful client library</strong> or sometimes a <strong class="bold">software development kit</strong> (<strong class="bold">SDK</strong>).</p>
<p>We will build an SDK for this service using TDD (of course!) and, while doing so, we will encounter more <a id="_idIndexMarker960"/>advanced mocking requirements.</p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor329"/>The One Call API</h2>
<p>OpenWeather has an API called <strong class="bold">One Call</strong> that <a id="_idIndexMarker961"/>will get you today’s weather information <a id="_idIndexMarker962"/>and the forecast for the next few days. The best way to illustrate how this works is by using an example that gets the weather and the forecast for Greenwich, London.</p>
<p>First, issue a RESTful <code>GET</code> request. You can use your browser for this: </p>
<pre class="source-code">https://api.openweathermap.org/data/2.5/onecall?
  lat=51.4810&amp;lon=0.0052&amp;appid=[yourapikey]</pre>
<p>Notice that the first two query string parameters are the latitude and the longitude of Greenwich, and the last one is your API key (which is omitted here). You will get a response similar to this:</p>
<pre class="source-code">{
   "lat":51.481,
   "lon":0.0052,
   "timezone":"Europe/London",
   "timezone_offset":3600,
   "current":{
      "dt":1660732533,
      "sunrise":1660711716,
      "sunset":1660763992,
      "temp":295.63,
      "feels_like":295.76,
      "pressure":1011,
      "humidity":70,
…</pre>
<p>This is a very <a id="_idIndexMarker963"/>long JSON output; it is around 21,129 characters.</p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor330"/>Creating the solution skeleton</h2>
<p>We have created <a id="_idIndexMarker964"/>a library and tested it frequently, so we will need to do the same here:</p>
<ol>
<li>Create a library project, call it <code>Uqs.OpenWeather</code>, and delete the sample class.</li>
<li>Create an xUnit project and call it <code>Uqs.OpenWeather.Test.Unit</code>.</li>
<li>Add a reference from the test project to the library.</li>
<li>Add NSubstitute from NuGet to the test project. </li>
<li>Rename the class and the filename in the unit test to <code>ClientTests.cs</code>.</li>
</ol>
<p>Your VS solution will look like this:</p>
<div><div><img alt="Figure A2.1 – Project skeleton’s Solution Explorer " height="278" src="img/Figure_A2.1_B18370.jpg" width="402"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure A2.1 – Project skeleton’s Solution Explorer</p>
<p>We are now ready to write the first unit test with TDD.</p>
<h2 id="_idParaDest-321"><a id="_idTextAnchor331"/>Starting the implementation with TDD</h2>
<p>At this moment, you <a id="_idIndexMarker965"/>can open <a id="_idIndexMarker966"/>your <code>ClientTests.cs</code> and start your first test, which will drive the library’s architecture.</p>
<p>We want to pass to a C# method, which we will call <code>OneCallAsync</code>, the two required parameters, <code>lat</code> and <code>lon</code>. This will then generate a URL with the right query string. So, our unit test class and the first unit test code will start to take shape, as shown in the following code base:</p>
<pre class="source-code">public class ClientTests
{
    private const string ONECALL_BASE_URL = 
      "https://api.openweathermap.org/data/2.5/onecall";
    private const string FAKE_KEY = "thisisafakeapikey";
    private const decimal GREENWICH_LATITUDE = 51.4769m;
    private const decimal GREENWICH_LONGITUDE = 0.0005m;
    [Fact]
    public async Task 
    OneCallAsync_LatAndLonPassed_UrlIsFormattedAsExpected()
    {
        // Arrange
        var httpClient = new HttpClient();
        var client = new Client(FAKE_KEY, httpClient);
        // Act
        var oneCallResponse = await
            client.OneCallAsync(GREENWICH_LATITUDE,   
            GREENWICH_LONGITUDE);
        // Assert
        // will need access to the generated URL
    }
}</pre>
<p>Given that the API key needs to be sent with every API call, the API key is to be in the constructor and not part of the method parameters.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Having the API key in the constructor will free the class’s consumer of having to fetch the API key to pass it to the method call. Instead, it will become the responsibility of the dependency injection setup to fetch the key, which makes more sense.</p>
<p>We will definitely <a id="_idIndexMarker967"/>need the <code>HttpClient</code> class because your client will be using REST, and this is what you usually <a id="_idIndexMarker968"/>use with RESTful calls in .NET Core. However, when using this class, we may face the following <a id="_idIndexMarker969"/>challenges:</p>
<ul>
<li><code>HttpClient</code> is a concrete class, and calling any method on it will lead to <code>HttpClient</code> issuing a call to the destination – this is the default behavior, but it can be tweaked.</li>
<li><code>HttpClient</code> doesn’t give us access to the generated URL, which is what we want in the current test.</li>
</ul>
<p>We need to figure out a way to intercept the call before <code>HttpClient</code> calls the destination (which is the actual third-party service) and get a hold of the generated URL for inspection. Of course, we also want to eliminate the outbound call as this is a unit test, and we don’t want to call the third party for real.</p>
<p><code>HttpClient</code> can be passed an instance of <code>HttpMessageHandler</code> in the constructor, and then from <code>HttpMessageHandler</code> we can get hold of the generated URL by spying on <code>HttpMessageHandler.SendAsync</code> and eliminate the real call. But <code>HttpMessageHandler</code> is an abstract class, so we cannot instantiate it; we need to inherit from it.</p>
<p>So, let’s create a <a id="_idIndexMarker970"/>child class <a id="_idIndexMarker971"/>from <code>HttpMessageHandler</code> and call it <code>FakeHttpMessageHandler</code> in your unit test project, as follows:</p>
<pre class="source-code">public class FakeHttpMessageHandler : HttpMessageHandler
{
    private HttpResponseMessage _fakeHttpResponseMessage;
    public FakeHttpMessageHandler(
        HttpResponseMessage responseMessage)
    {
        _fakeHttpResponseMessage = responseMessage;
    }
    protected override Task&lt;HttpResponseMessage&gt; 
        SendAsync(HttpRequestMessage request, 
        CancellationToken cancellationToken)
    =&gt; SendSpyAsync(request, cancellationToken);
    
    public virtual Task&lt;HttpResponseMessage&gt; 
        SendSpyAsync(HttpRequestMessage request,
        CancellationToken cancellationToken)
    =&gt; Task.FromResult(_fakeHttpResponseMessage);
}</pre>
<p>We have created a fake class that will allow us to get access to <code>HttpRequestMessage</code>. Now, our <code>Arrange</code> will look like this:</p>
<pre class="source-code">// Arrange
var httpResponseMessage = new HttpResponseMessage()
{
    StatusCode = HttpStatusCode.OK,
    Content = new StringContent("{}")
};
<strong class="bold">var fakeHttpMes<a id="_idTextAnchor332"/>sageHandler = Substitute.ForPartsOf</strong>
    <strong class="bold">&lt;FakeHttpMessageHandler&gt;(httpResponseMessage);</strong>
HttpRequestMessage? actualReqMessage = null;
fakeHttpMessageHandler.SendSpyAsync(
    <strong class="bold">Arg.Do&lt;HttpRequestMessage&gt;(x =&gt; actualReqMessage = x), </strong>
    Arg.Any&lt;CancellationToken&gt;())
    .Returns(Task.FromResult(httpResponseMessage));
var fakeHttpClient = new 
  HttpClient(fakeHttpMessageHandler);
var client = new Client(FAKE_KEY, fakeHttpClient);</pre>
<p>We first created a response message, so any method call will return this empty object. This object will <a id="_idIndexMarker972"/>contain <a id="_idIndexMarker973"/>the third-party response when we run the real code.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">We have created a fake for <code>HttpMessageHandler</code>; we could have mocked it as well. Both work, and it is based on preference of what is more readable. Here I feel that having a fake <code>HttpMessageHandler</code> is easier to read.</p>
<p class="callout">Also note that the preceding implementation could be called a stub (rather than a fake) but I opted to refer to it as fake as it contains some real implementation. Sometimes there is a thin line between stubs and fakes.</p>
<p>Note that we used NSubstitute to create a mock of the fake. The reason for that is we want to have access to <code>HttpRequestMessage</code>, which contains our final URL.</p>
<p>We have used <code>Substitute.ForPartsOf</code> rather than <code>Substitute.For</code> for the first time in this book, because <code>For</code> is not meant for concrete classes; the code will compile, but you will get a runtime error.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">We have always used <code>Substitute.For&lt;ISomeInterface&gt;</code> and this is what you would do in 95% of the cases. We have not created an instance of a concrete class. For concrete classes, without interfaces, you would use <code>ForPartsOf&lt;SomeClass&gt;</code>.</p>
<p>Our <code>Assert</code> section <a id="_idIndexMarker974"/>becomes <a id="_idIndexMarker975"/>this:</p>
<pre class="source-code">string actualUrl = actualHttpRequestMessage!.RequestUri!
    .AbsoluteUri.ToString();
Assert.Contains(ONECALL_BASE_URL, actualUrl);
Assert.Contains($"lat={GREENWICH_LATITUDE}", actualUrl);
Assert.Contains($"lon={GREENWICH_LONGITUDE}", actualUrl);</pre>
<p>Now, we are ready to write the production code.</p>
<h2 id="_idParaDest-322"><a id="_idTextAnchor333"/>Fail then pass</h2>
<p>The code will fail to even <a id="_idIndexMarker976"/>compile as we have not created the production code, which will give us the TDD fail that we are looking for. Now, we shall do the minimal implementation that will pass the test:</p>
<pre class="source-code">public class Client
{
    …
    public async Task&lt;OneCallResponse&gt; OneCallAsync(
        decimal latitude, decimal longitude)
    {
        const string ONECALL_URL_TEMPLATE = "/onecall";
        var uriBuilder = new UriBuilder(
          BASE_URL + ONECALL_URL_TEMPLATE);
        var query = HttpUtility.ParseQueryString("");
        query["lat"] = latitude.ToString();
        query["lon"] = longitude.ToString();
        query["appid"] = _apiKey;
        uriBuilder.Query = query.ToString();
        var _ = await _httpClient
            .GetStringAsync(uriBuilder.Uri.AbsoluteUri);
        return new OneCallResponse();
    }
}</pre>
<p>Run your test again, and it will pass.</p>
<p>We’ve done a lot <a id="_idIndexMarker977"/>for this test, but other tests will flow easily as they will use the same fake that we’ve created. Let’s do a recap of what we’ve done.</p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor334"/>Recap</h2>
<p>Here is a recap of all the important activities that we’ve done to make the first test pass:</p>
<ul>
<li>We wanted to write a test that checks whether the URL is formed right.</li>
<li>We had to get into the internals of <code>HttpClient</code> to get the URL.</li>
<li><code>HttpClient</code> doesn’t have the right methods to spy on the generated URL.</li>
<li>We created a fake <code>FakeHttpMessageHandler</code> that inherited <code>HttpMessageHandler</code> and passed it to <code>HttpClient</code> so we can reach the <code>HttpClient</code> internals.</li>
<li>We mocked our fake <code>FakeHttpMessageHandler</code> and spied on the URL.</li>
<li>We utilized a less-used method of NSubstitute for creating a mock, <code>Substitute.ForPartsOf</code>, which allowed us to mock a concrete class.</li>
<li>We followed the standard TDD route of fail and pass to implement our production code.</li>
</ul>
<p>I hope this made the activities clearer. You have the full source code to inspect if this is not the case.</p>
<p>You will encounter similar advanced mocking scenarios in the future, so how do you attack them?</p>
<h2 id="_idParaDest-324"><a id="_idTextAnchor335"/>Investigating complex mocking scenarios</h2>
<p>Like everything in a developer’s life, you will be able to find someone else who has encountered a <a id="_idIndexMarker978"/>similar mocking scenario to the one you are facing. Searching online for <code>access url HttpClient NSubstitute</code> would have given you the clues you needed to cut through the problem quickly.</p>
<p>The good news is that most of the sophisticated mocking problems have already been sorted out, and the solutions have been published (thanks to all developers’ hard work). You just need to understand the concept and incorporate it into your solution. </p>
<p>In this appendix, we went through a more advanced but less frequent mocking scenario. It requires <a id="_idIndexMarker979"/>more fiddling and extra effort, but with experience in mocking, you will become familiar with these scenarios, and you will cut through them in no time. </p>
<h1 id="_idParaDest-325"><a id="_idTextAnchor336"/>Further reading</h1>
<p>To learn more about the topics discussed in the chapter, you can refer to <em class="italic">OpenWeather’s</em> official website: <a href="https://openweathermap.org">https://openweathermap.org</a></p>
</div>
</div>
</body></html>