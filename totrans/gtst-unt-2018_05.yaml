- en: Lights, Cameras, and Shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created our game's terrain and made several customizations
    to the terrain, based on our design mock-up in [Chapter 3](df7798e1-3730-4af7-8c04-857d71ac78d2.xhtml),
    *Designing the Game*. We used shaping tools, painted the terrain, and added water.
    We even created our own tree from scratch. In addition, we created a material
    and imported a texture file.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore cameras and lighting in Unity. We will start
    with a look at cameras to include perspectives, frustums, and Skyboxes. Next,
    we will learn a few uses of multiple cameras to include mini-maps. We will also
    cover the different types of lighting, explore reflection probes, and conclude
    with a look at shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing reflection probes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding shadows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to use the same Unity project featured in this chapter, you can
    download the `Starting-Chapter-05.zip` file from the publisher's companion site.
    Once you download the file, decompress it and then open the project in Unity.
    It contains the completed work from the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Working with cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cameras render scenes so that the user can view them. Think about the hidden
    complexity in that statement. Our games are 3D, but people playing our games view
    them on 2D displays such as a televisions, computer monitors, or mobile devices.
    Fortunately for us, Unity makes implementing cameras easy work.
  prefs: []
  type: TYPE_NORMAL
- en: Cameras are GameObjects and can be edited using transform tools in the Scene
    view as well as in the Inspector panel. Every scene must have at least one camera.
    In fact, when a new scene is created, Unity creates a camera named Main Camera.
    As you will see later in this chapter, a scene can have multiple cameras.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Scene view, cameras are indicated with a white camera silhouette, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/faa1fe2a-b7bc-4675-9c0d-8a32d1c5f608.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click our Main Camera in the Hierarchy panel, we are provided with
    a Camera Preview in the Scene view. This gives us a preview of what the camera
    sees as if it were in game mode. We will change this in [Chapter 7](6a3fb463-b0c2-4145-9096-bc52d55cf905.xhtml),
    *Implementing Our Player Character*. We also have access to several parameters
    via the Inspector panel. The Camera component in the Inspector panel is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da4c15dd-68d8-4608-bf05-6d17aac6bc79.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at each of these parameters with relation to our *Cucumber Beetle*
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: The Clear Flags parameter lets you switch between Skybox, Solid Color, Depth
    Only, and Don't Clear. The selection here informs Unity which parts of the screen
    to clear. We will leave this setting as Skybox. You will learn more about Skyboxes
    later in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Background parameter is used to set the default background fill (color)
    of your game world. This will only be visible after all game objects have been
    rendered and if there is no Skybox. Our *Cucumber Beetle* game will have a Skybox,
    so this parameter can be left with the default color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Culling Mask parameter allows you to select and deselect the layers you
    want the camera to render. The default selection options are Nothing, Everything,
    Default, TransparentFX, Ignore Raycast, Water, and UI. For our game, we will select
    Everything. If you are not sure which layer a game object is associated with,
    select it and look at the Layer parameter in the top section of the Inspector
    panel. There you will see the assigned layer. You can easily change the layer
    as well as create your own unique layers. This gives you finite rendering control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Projection parameter allows you to select which projection, perspective
    or orthographic, you want for your camera. We will cover both of those projections
    later in this chapter. When *perspective* projection is selected, we are given
    access to the Field of View parameter. This is for the width of the camera's angle
    of view. The value range is 1-179°. You can use the slider to change the values
    and see the results in the Camera Preview window. When orthographic projection
    is selected, an additional Size parameter is available. This refers to the viewport
    size. For our game, we will select perspective projection with the Field of View
    set to `60`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Clipping Planes parameters include Near and Far. These settings set the
    closest and furthest points, relative to the camera, that rendering will happen
    at. For now, we will leave the default settings of `0.3` and `1000` for the Near
    and Far parameters, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Viewport Rect parameter has four components – X, Y, W, and H – that determine
    where the camera will be drawn on the screen. As you would expect, the X and Y
    components refer to horizontal and vertical positions, and the W and H components
    refer to width and height. You can experiment with these values and see the changes
    in the Camera Preview. For our game, we will leave the default settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Depth parameter is used when we implement more than one camera. We can set
    a value here to determine the camera's priority in relation to others. Larger
    values indicate a higher priority. The default setting is sufficient for our game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Rendering Path parameter defines what rendering methods our camera will
    use. The options are Use Graphics Settings, Forward, Deferred, Legacy Vertex Lit,
    and Legacy Deferred (light prepass). We will use the Use Graphics Settings option
    for our game, which also uses the default setting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Target Texture parameter is not something we will use in our game. When
    a render texture is set, the camera is not able to render to the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Occlusion Culling parameter is a powerful setting. If enabled, Unity will
    not render objects that are occluded, or not seen by the camera. An example would
    be objects inside a building. If the camera can currently only see the external
    walls of the building, then none of the objects inside those walls can be seen.
    So, it makes sense to not render those. We only want to render what is absolutely
    necessary to help ensure our game has smooth gameplay and no lag. We will leave
    this as enabled for our game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Allow HDR parameter is a checkbox that toggles a camera's **High Dynamic
    Range** (**HDR**) rendering. We will leave the default setting of enabled for
    our game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Allow MSAA parameter is a toggle that determines whether our camera will
    use a **Multisample Anti-Aliasing** (**MSAA**) render target. MSAA is a computer
    graphics optimization technique and we want this enabled for our game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding camera projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two camera projections used in Unity: perspective and orthographic.
    With perspective projection, the camera renders a scene based on the camera angle,
    as it exists in the scene. Using this projection, the further away an object is
    from the camera, the smaller it will be displayed. This mimics how we see things
    in the real world. Because of the desire to produce realistic games, or games
    that approximate the realworld, perspective projection is the most commonly used
    in modern games. It is also what we will use in our *Cucumber Beetle* game.'
  prefs: []
  type: TYPE_NORMAL
- en: The other projection is orthographic. An orthographic perspective camera renders
    a scene uniformly without any perspective. This means that objects further away
    will not be displayed smaller than objects closer to the camera. This type of
    camera is commonly used for top-down games and is the default camera projection
    used in 2D and Unity's UI system.
  prefs: []
  type: TYPE_NORMAL
- en: We will use perspective projection for our *Cucumber Beetle* game.
  prefs: []
  type: TYPE_NORMAL
- en: Orientating your frustum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a camera is selected in the Hierarchy view, its frustum is visible in
    the Scene view. A frustum is a geometric shape that looks like a pyramid that
    has had its top cut off, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62ef6855-c538-4da0-949d-806725dc3d31.png)'
  prefs: []
  type: TYPE_IMG
- en: The near, or top, plane is parallel to its base. The base is also referred to
    as the far plane. The frustum's shape represents the viable region of your game.
    Only objects in that region are rendered. Using the camera object in Scene view,
    we can change our camera's frustum shape.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Skybox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create game worlds, we typically create the ground, buildings, characters,
    trees, and other game objects. What about the sky? By default, there will be a
    textured blue sky in your Unity game projects. That sky is sufficient for testing
    but does not add to an immersive gaming experience. We want a bit more realism,
    such as clouds, and that can be accomplished by creating a Skybox.
  prefs: []
  type: TYPE_NORMAL
- en: A Skybox is a six-sided cube visible to the player beyond all other objects.
    So, when a player looks beyond your objects, what they see is your Skybox. As
    we said, Skyboxes are six-sided cubes, which means you will need six separate
    images that can essentially be clamped to each other to form the cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Default Skybox** that Unity projects start
    with as well as the completed **Custom Skybox** you will create in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7773dbf4-8633-4200-a584-64c150d43ef4.png)'
  prefs: []
  type: TYPE_IMG
- en: To follow along, you will need the six images located in the `Chapter5-Skybox.zip`
    file on the publisher's companion site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a Skybox:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a `Skybox` subfolder in the `Assets` folder. We
    will use this folder to store our textures and materials for the Skybox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the provided six Skybox images, or your own, into the new `Skybox` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the `Skybox` folder is selected in the `Project` panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the top menu, select Assets | Create | Material. In the Project panel,
    name the material `Skybox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Skybox material selected, turn your attention to the Inspector panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Shader drop-down menu and select SkyBox | 6 Sided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Select button for each of the six images and navigate to the images
    you added in step 2\. Be sure to match the appropriate texture to the appropriate
    cube face. For example, the `SkyBox_Front` texture matches the `Front[+Z]` cube
    face on the Skybox Material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to assign our new Skybox to our scene, select Window | Lighting | Settings
    from the top menu. This will bring up the Lighting settings dialog window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Lighting settings dialog window, click on the small circle to the right
    of the Skybox Material input field. Then, close the selection window and the Lighting
    window. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d35925b2-1a99-424e-a187-5024c1d10830.png)'
  prefs: []
  type: TYPE_IMG
- en: You will now be able to see your Skybox in the Scene view. When you click on
    the Camera in the Hierarchy panel, you will also see the Skybox as it will appear
    from the camera's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to save your scene and your project.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Unity games must have a least one camera, but we are not limited to using
    just one. As you will see in [Chapter 7](6a3fb463-b0c2-4145-9096-bc52d55cf905.xhtml),
    *Implementing Our Player Character*, we will attach our main camera, or primary
    camera, to our player character. It will be as if the camera is following the
    character around the game environment. This will become the eyes of our character.
    We will play the game through our character's view.
  prefs: []
  type: TYPE_NORMAL
- en: A common use of a second camera is to create a mini-map that can be seen in
    a small window on top of the game display. These mini-maps can be made to toggle
    on and off or be permanent/fixed display components. Implementations might consist
    of a fog-of-war display, a radar showing enemies, or a global top-down view of
    the map for orientation purposes. You are only limited by your imagination. In
    [Chapter 9](6e2e628c-4c81-4ec3-bd4f-2ae0f2a29aab.xhtml), *Adding a Heads-Up Display*,
    we will create a mini-map as a radar showing where beetles are in relation to
    the Cucumber Man's current position.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of multiple cameras is to provide the player with the ability to
    switch between third-person and first-person views. You will remember from [Chapter
    1](f4fba83f-4f23-4537-a130-ed8dab8f3815.xhtml), *Downloading and Installing Unity*,
    that the first-person view puts the player's arms in view, while in the third-person
    view, the player's entire body is visible. We can use two cameras in the appropriate
    positions to support viewing from either camera. In a game, you might make this
    a toggle—say, with the *C* keyboard key—that switches from one camera to the other.
    Depending on what is happening in the game, the player might enjoy this ability.
  prefs: []
  type: TYPE_NORMAL
- en: Some single-player games feature multiple playable characters. Giving the player
    the ability to switch between these characters gives them greater control over
    the game strategy. To achieve this, we would need to have cameras attached to
    each playable character and then give the player the ability to swap characters.
    We would do this through scripting. This is a pretty advanced implementation of
    multiple characters.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of multiple cameras is adding specialty views in a game. These specialty
    views might include looking through a door's peep-hole, looking through binoculars
    at the top of a skyscraper, or even looking through a periscope. We can attach
    cameras to objects and change their viewing parameters to create unique camera
    use in our games. We are only limited by our own game designs and imagination.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use cameras as cameras. That's right! We can use the camera game
    object to simulate actual in-game cameras. One example is implementing security
    cameras in a prison-escape game.
  prefs: []
  type: TYPE_NORMAL
- en: Working with lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we explored the uses of cameras for Unity games. Just
    like in the real world, cameras need lights to show us objects. In Unity games,
    we use multiple lights to illuminate the game environment.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, we have both dynamic lighting techniques as well as light baking options
    for better performance. We can add numerous light sources throughout our scenes
    and selectively enable or disable an object's ability to cast or receive shadows.
    This level of specificity gives us tremendous opportunity to create realistic
    game scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the secret behind Unity's ability to so realistically render light and
    shadows is that Unity models the actual behavior of lights and shadows. Real-time
    global illumination gives us the ability to instantiate multiple lights in each
    scene, each with the ability to directly or indirectly impact objects in the scene
    that are within range of the light sources.
  prefs: []
  type: TYPE_NORMAL
- en: Indirect light refers to lights bouncing off objects and reflecting on other
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add and manipulate ambient light in our game scenes. This is often
    done with Skyboxes, a tri-colored gradient, or even a single color. Each new scene
    in Unity has default ambient lighting, which we can control by editing the values
    in the the Lighting window. In that window, you have access to the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time Lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed Lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightmapping Settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug Settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No changes to these are required for our game at this time. We have already
    set the environmental lighting to our Skybox. In [Chapter 12](f7abb907-5397-4668-972e-e69acb441421.xhtml),
    *Adding Audio and Visual Effects to Our Game*, we will look at Fog, which is available
    under the Other Settings section of the Lighting window.
  prefs: []
  type: TYPE_NORMAL
- en: When we create our scenes in Unity, we have three options for lighting. We can
    use real-time dynamic light, use the baked lighting approach, or use a mixture
    of the two. Our games perform more efficiently with baked lighting, compared to
    real-time dynamic lighting, so if performance is a concern, try using baked lighting
    where you can.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to ambient lighting, there are four types of light: directional,
    point, spot, and area. We will look at each of these in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Directional lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a new scene in Unity, a directional light is automatically created
    for us. This emphasizes the importance of directional lights. This type of light
    provides illumination in a specific direction. Using transform tools, we have
    full control over the direction of these lights.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of directional lighting is generating sunlight in our scenes. Although
    the light from directional lights is similar to that of the sun, there is no actual
    sun-like object that the light comes from. As shown in the following screenshot,
    Directional Lights, when selected, indicate the direction of its illumination
    with yellow rays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ae83abf-dfc6-4dca-b7fc-6a901b483150.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the great aspects of using directional lighting is that illumination
    strength is not dependent on an object's distance from the Directional Light object.
    This type of lighting defines the direction of the light, and distance has no
    impact on the illumination.
  prefs: []
  type: TYPE_NORMAL
- en: With a Directional Light selected, you have access to several parameters in
    the Inspector panel. In addition to the Transform section, there is a Light section
    where you can change several settings to include the light color and intensity.
    The remaining parameters are worth exploring and no changes are required to complete
    our game.
  prefs: []
  type: TYPE_NORMAL
- en: To add additional directional lights, you would select, from the top menu, GameObject
    | Light | Directional Light.
  prefs: []
  type: TYPE_NORMAL
- en: For the *Cucumber Beetle* game, we will keep the default Directional Light.
    You can use the transform tools to modify the location, rotation, and light direction.
  prefs: []
  type: TYPE_NORMAL
- en: Point lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Point lights get their name from the fact that they are lights sources emanating
    from a specific point. These light objects, as indicated in the following diagram,
    emit light in all directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a86bee4-295d-4e8f-838f-f023d65aca92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These lights are typically used to simulate fireballs or light bulbs. They
    can also be used to simulate some magic or special lighting effects. As you can
    see in the following screenshot, point lights have several properties that affect
    how they impact the game environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efc38960-980e-4b4e-b690-362249b3e8c3.png)'
  prefs: []
  type: TYPE_IMG
- en: The Range is the distance between the center of the light to the outside arc
    of the light. We can also change the Color and Intensity to produce the results
    we desire.
  prefs: []
  type: TYPE_NORMAL
- en: To create a point light, we select GameObject | Light | Directional Light from
    the top menu.
  prefs: []
  type: TYPE_NORMAL
- en: Spot lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spot lights are another type of lighting in Unity. They are meant to provide
    lighting on a specific spots. Common examples are flashlights and vehicle headlights.
    As you can see from the following screenshot, the light originates from the source
    in an outward cone shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cca867e9-6bab-453f-a451-5dc20a4d9e6b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Inspector panel, we can change the Range, Spot Angle, Color and Intensity.
    Range, in this context, refers to the distance between the light source and the
    furthest point in the cone. The Spot Angle is the angle of the outward exterior
    edge of the cone shape. The Spot Angle range is 1-179°. The larger the value is,
    the larger the cone face will be.
  prefs: []
  type: TYPE_NORMAL
- en: To create a spotlight, we select GameObject | Light | Spot Light from the top
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: Area lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use an area light, we define a rectangle using the transform tools or the
    Inspector panel. Area lights emit light from one side of their rectangle. The
    following screenshot shows what an area light object looks like in the Unity editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42e8ea41-a204-4319-bce7-1ada809160e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Area lights are unique from the other types of light as they can only be baked.
    This means that real-time rendering will not take place during gameplay. The reason
    for this is to conduct all the processing regarding area lights prior to gameplay.
    This processing, if accomplished in real time in a game, would likely result in
    sufficient lag.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, the Type is set as Area (baked
    only) and cannot be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59474f91-f7c8-4f9f-9667-9e715f25310a.png)'
  prefs: []
  type: TYPE_IMG
- en: Area lights can be used instead of point lights when baked lighting is okay
    and you desire software shadows.
  prefs: []
  type: TYPE_NORMAL
- en: To create an area light, we select GameObject | Light | Area Light from the
    top menu.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing reflection probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection probes capture a 360° spherical view of their surroundings. In this
    sense, it is somewhat like a camera. That captured image is used by nearby objects
    that have reflective materials.
  prefs: []
  type: TYPE_NORMAL
- en: To create a reflection probe, we select GameObject | Light | Reflection Probe from
    the top menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following screenshot, the reflection probe is a sphere
    and has captured the view of its surroundings. When objects are placed in close
    proximity to the reflection probe, the reflections will be visible on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/869cbf2e-a76c-4ead-934b-0690abce3f28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A review of a reflection probe in the Inspector panel, shown as follows, reveals
    several settings that we can change to affect how the probe works and how it impacts
    our game environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb3bf621-160c-45a6-b05d-9ec934a0a8bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following list of properties highlights the ones you are most likely to
    change in the Unity games you create:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type: You can select Baked, Custom, or Realtime. Remember, we can improve game
    performance if we bake our lighting whenever possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Importance: When there are multiple rendering probes in the area, you can set
    the importance of each of them. The higher the value, the greater the importance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Intensity: The lowest value is zero. You can experiment with the results of
    changing this setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resolution: You can select 16, 32, 64, 128, 256, 512, 1024, or 2048 for the
    resolution of the captured image reflection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As indicated earlier in this chapter, our game scenes can have numerous light
    sources, and we can enable or disable an object's ability to cast or receive shadows.
    We have shadows in the real world and it is important to consider, for our Unity
    games, what objects cast shadows and what objects receive shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Mesh Renderer component of an object in
    the Inspector panel. Let''s review the key settings of this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13a70f50-0219-4806-84bf-3b33d32695df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Light Probes: It can be set to Blend Probes, Use Proxy Volume, or Off. You
    will most likely use the default Blend Probes for simple Unity games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reflection Probes: This setting can be turned off or set to Blend Probes, Blend
    Probes And Skybox, or Simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cast Shadows: This setting can be set to On, Off, Two-Sided, or Shadows Only.
    The default is On, so you should disable this for all objects that do not need
    to cast shadows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Receive Shadows: This setting is a toggle that tells Unity whether you want
    that object to receive shadows or not. As you would expect, this takes extra processing
    to display during the game. So, if you do not need an object to receive shadows,
    deselect this for greater performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored cameras and lighting. We started with a look at
    cameras that included perspectives, frustums, and Skyboxes. Next, we learned possible
    uses of multiple cameras in Unity games. We also covered the different types of
    lighting, explored reflection probes, and concluded with a look at shadows.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create 3D objects using Unity's native toolset.
    We will also import several objects into our game to complete our game environment,
    including the tree we made in [Chapter 4](04be4d7b-8c85-4d9e-baf2-43965183f99f.xhtml),
    *Creating Our Terrain*.
  prefs: []
  type: TYPE_NORMAL
